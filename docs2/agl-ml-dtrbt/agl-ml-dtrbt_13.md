# *第十章*：推荐系统

在本章中，我们将了解推荐系统是什么，讨论它们的各种类型，并通过**DataRobot**实现的内容推荐系统进行实践。在本章中，**推荐系统**、**推荐系统**、**推荐引擎**和**推荐引擎**被交替使用。

在最简单的形式中，推荐系统向用户或买家推荐可能相关的项目。在今天的商业环境中，企业往往有大量的商品、产品或服务出售，这使得用户或买家与其期望的产品或服务连接变得更加困难。本章解释了推荐引擎在当前商业空间中的普遍性。

虽然这本书不是涵盖推荐系统所有方面的地方，但我们将讨论如何利用 DataRobot 构建和（从）推荐引擎中进行预测，并概述这些系统的概念，以及对其类型的简要讨论。因此，在本章结束时，你将学习如何利用 DataRobot 构建内容推荐引擎。本章的主要内容包括以下内容：

+   推荐系统概念介绍

+   构建推荐系统的方法

+   在 DataRobot 中定义和设置推荐系统

+   在 DataRobot 中构建推荐系统

+   使用 DataRobot 进行推荐系统预测

# 技术要求

本章的大部分内容需要访问 DataRobot 软件。代码示例基于一个相对较小的数据集，Book-Crossing，由三个表格组成，其操作是在**Jupyter Notebook**中完成的。

查看以下视频，了解代码的实际应用效果[`bit.ly/3HxcNUL`](https://bit.ly/3HxcNUL)。

## Book-Crossing 数据集

用于说明 DataRobot 在构建推荐系统中的应用的示例，基于 Cai-Nicolas Ziegler 及其同事的 Book-Crossing 数据集。此数据集可在[`www2.informatik.uni-freiburg.de/~cziegler/BX/`](http://www2.informatik.uni-freiburg.de/~cziegler/BX/)访问。

注意

在使用此数据集之前，本书的作者已通知数据集的所有者关于其在本书中的使用情况。

Cai-Nicolas Ziegler, Sean M. McNee, Joseph A. Konstan, Georg Lausen (2005). *通过主题多样化改进推荐列表。第 14 届国际万维网会议（WWW '05）论文集*。2005 年 5 月 10 日至 14 日，日本千叶。

数据是在 2004 年 8 月至 9 月期间，对 Book-Crossing 社区进行了为期四周的收集过程中收集的。随后的三个表格，以 CSV 格式提供，构成了这个数据集。

+   `User-ID`以整数形式呈现。还提供了用户的`Location`和`Age`值。

+   `ISBM`、`Book-Title`、`Book-Author`、`Year-Of-Publication`、`Publisher`。

+   `Book-Rating` 评分值要么是隐式的 `0`，要么在 `1` 到 `10` 之间是显式的（数值越高，评分越好）。然而，在本项目的背景下，我们将仅关注用于模型开发的显式评分。表格还包括 `User-ID` 和 `ISBN` 值。

# 推荐系统的概念介绍

企业长期以来一直有向客户推荐其产品或服务的传统。例如，走进一家书店，你可能会看到其他客户购买的流行书籍列表。这是一种简单的推荐系统，因为它为买家提供了一个潜在购买产品的快照。

为了在数字经济中取得胜利，企业正变得越来越以客户为中心。**以客户为中心**意味着公司旨在将客户的需求放在首位。尽管如此，由于客户的需求像客户本身一样多样化，企业需要采取独特的方法来推出他们的产品。这在一定程度上解释了**基于流行度的推荐系统**的失败，因为它们未能考虑买家的独特档案。随着数字化程度的提高、商业产品种类的增加以及客户需求多样性的增长，这种方法不太可能取得成功。

有趣的是，数据科学工具可以通过多种方式考虑买家的需求，从而为推荐系统提供多种提高智能的方法。

在介绍不同类型的推荐系统时，我们将继续使用书店的例子。

首先，**基于项目的协同过滤**推荐系统方法根据买家的产品购买历史以及这些 *产品* 与其他产品的关联向书买家提出产品建议。因此，如果某人购买了 *Book A*，并且 *Book A* 与 *Book B* 相关联，那么就会建议 *Book B*。第二种方法，**基于用户的协同过滤**，在提出建议时考虑了 *买家* 之间的相似性。因此，如果 *Buyer A* 与 *Buyer B* 相似，并且 *Buyer A* 购买了 *Book C*，那么就会向 *Buyer B* 推荐购买 *Book C*。第三种方法，**基于内容的推荐**，在提出建议时考虑了书籍和用户特征。最后，**混合系统**方法在提出建议时结合了基于协同和基于内容的方法。很容易看出，这两种方法都各有优缺点。我们现在将更深入地探讨这些方法以及如何使用 DataRobot 构建基于内容的推荐系统。

# 构建推荐系统的方法

推荐系统的目标是向买家推荐相关的产品。由于它们能够考虑买家的独特性，智能推荐引擎为商家创造了数十亿美元的收入，并帮助买家找到相关的产品。这对消费者和商家来说都是双赢的局面。已经介绍了各种数据驱动的方法来创建智能推荐系统。推荐系统有三种主要方法：协同过滤系统、基于内容的系统和混合系统。以下小节将讨论这些方法中的每一个。

## 协同过滤推荐系统

协同过滤推荐系统背后的核心思想是利用他人的过去行为来推断个人可能感兴趣的内容。协同过滤方法借鉴了产品与用户之间历史交互的数据存储。*表 10.1*展示了用户对书籍评分的交互矩阵。每个用户用 1 到 5 的数字对一本书进行评分，其中 5 代表最高程度的享受。在没有评分的地方，假定个人没有阅读这本书。协同过滤有两种主要类型：*基于项目*的协同过滤和*基于用户*的协同过滤。

![表 10.1 – 用户/产品交互矩阵![图片](img/Figure_10.01_B17159.jpg)

表 10.1 – 用户/产品交互矩阵

*基于项目的协同过滤*系统（或**基于项目的协同算法**）在项目之间寻找相似性，并基于这些相似性进行推荐。这种方法基于根据项目与个人之前喜欢或购买的项目相似程度来向个人推荐项目。根据*表 10.1*，基于项目的过滤方法可以很容易地看出*书 C*和*书 E*在之前的读者中被以相似的方式评分。基于这种项目关系，如果一个人高度评价*书 C*，就会推荐*书 E*，反之亦然。因此，由于*用户 5*高度评价*书 E*且未见过*书 C*，就提出了推荐*书 C*，因为他们很可能喜欢*书 C*。

基于*用户协同过滤*的系统，会在*用户*之间找到相似性，并基于这些相似性进行推荐。**用户到用户协同算法**旨在找到行为相似或处于相同行为邻域的用户，这是通过他们的历史行为建立的。然后算法考虑他们的偏好并做出推荐。这些推荐系统的核心思想是假设如果个体*是*相似的，*他们*喜欢的东西也将相似。从*表 10.1*中可以推断出*用户 2*和*用户 4*有相似的书籍兴趣。因为*用户 4*对*书籍 D*给出了高度评价，所以认为*用户 2*喜欢*书籍 D*的可能性很高，因此推荐。正如我们所看到的，这两种协同过滤方法都是基于*相似性*这一理念。

相似度度量提供了做出推荐的基础。有几个相似度度量，其中**皮尔逊相关系数**和**余弦相似度**是最受欢迎的。其他人通过利用*邻域*来接近这种相似度的测量。**K 最近邻**算法被用来找到被推荐或推荐给的对象最近的物品或用户。

由于交互数据集容易获取，构建协同过滤系统比基于内容的系统要容易得多，这将在下一节中讨论。然而，推荐系统的协同方法有几个缺点。在*表 10.1*的背景下，引入了一个没有历史记录的新用户*用户 6*。很容易看出，协同过滤系统将难以向这位用户做出推荐。对于没有历史数据的项目来说，问题类似。这个问题，也被称为**冷启动**问题，已经被广泛记录。**数据稀疏性**是与协同过滤相关联的另一个常见问题。大多数平台和大型企业都有买家和产品。然而，最活跃的用户只会购买一小部分可用的产品。因此，在驱动这些引擎时，存在一个数据缺口，这些数据对于有意义地计算相似性是必要的。

## 基于内容的推荐系统

*基于内容的推荐*系统基于项目特征和用户档案进行建议。这种方法有一个不同的数据结构作为其基础。基于内容的系统是`1`和`5`，模型是基于回归的，因为它预测一个区间变量。这个模型变成了基于内容的推荐引擎。

从前面的讨论中，我们可以看出，基于内容的系统可以轻松缓解冷启动问题，因为书籍和用户很可能有一些形式的描述。与协同过滤系统相比，基于内容的系统更具可扩展性，因为在生产环境中，当需要时可以轻松地进行预测，而不是必须同时为所有用户和产品进行预测。重要的是，即使用户只评价或购买少量产品，基于内容的系统仍然可以表现良好，因为它们关注的是描述，而不是用户或产品。然而，当物品的特征不易获得时，大多数基于内容的系统都会遇到困难。在某些情况下，为产品生成属性可能会很具挑战性（例如，如果产品包含图像或声音）。在这种情况下，基于内容的系统将没有描述可以分析。此外，由于日益增长的在线隐私担忧，用户的人口统计信息可能不易获得。协同过滤和基于内容的推荐方法的局限性导致了混合系统的使用。

## 混合推荐系统

*混合推荐系统*是推荐系统的一种集成方法。混合系统通过利用两种或更多推荐策略的组合来为用户生成推荐。通过这样做，它们减轻了归因于任何一种策略的限制，从而受益于*众人的智慧*。

混合系统有几种方法。最常用（也是最容易实现）的是**加权方法**。在这里，独立推荐系统的分数被汇总以给出一个总推荐分数。汇总方法多种多样，包括基本平均、应用规则和使用线性函数。**阶段方法**也可以部署。这通常涉及将推荐系统的结果作为另一个推荐系统的输入特征。因此，*阶段 1*系统的输出成为*阶段 2*系统的额外输入。**切换方法**涉及使用规则在不同的推荐系统之间切换，以利用特定环境下的优势。例如，如果协同过滤被认为给出了更好的结果，切换机制可以使用协同过滤方法，但当出现冷启动时，它可以切换到基于内容的方法。混合系统相对于基于内容的系统的一个优势是，当物品特征难以确定时，可以开发推荐。正如将在*第十一章*中展示的，*与地理空间数据、NLP 和图像处理一起工作*，DataRobot 具有先进的图像和文本数据特征提取能力。

# 在 DataRobot 中定义和设置推荐系统

由于 DataRobot 能够从图像、音频和文本数据中提取特征，它有效地管理了基于内容的推荐系统的特征可用性限制。此外，DataRobot 的自动化机器学习模型流程意味着它非常适合利用基于内容的优势，同时弥补这种方法的特征不可用性限制。如 *技术要求* 部分所述，我们示例中使用的数据集包括三个表。这包括用户表（展示用户资料）、书籍表（概述书籍特征）和评分表（包含用户书籍评分）。由于我们有一个描述书籍的表，另一个描述用户的表，将这些表和评分集合并为基于内容的推荐系统场景。为此，我们使用了 Jupyter Notebook。*图 10.1* 展示了我们运行的脚本，用于导入数据集、操作数据、合并表并将数据写回 CSV 文件：

![图 10.1 – Jupyter Notebook 中的数据处理![图 10.02_B17159.jpg](img/Figure_10.02_B17159.jpg)

图 10.1 – Jupyter Notebook 中的数据处理

在评分表中，`rating` 值为 `0` 的行被排除，因为这些评分是隐含的。这些行将在 *使用 DataRobot 进行推荐系统预测* 部分中用来演示如何使用推荐引擎进行预测。通过更改表头以及将 `ratings`、`books` 和 `users` 值合并到一个表中，每一行都描述了一个用户和一本书，以及一个评分。数据快照显示在 *表 10.2* 中。尽管我们可以使用 Python API 方法（如将在 *第十二章*，*DataRobot Python API*）中所示，在 Jupyter Notebook 中创建 DataRobot 项目以保持一致性，但我们下载了数据文件：`rating.csv`。

![表 10.2 – 数据快照![图 10.03_B17159.jpg](img/Figure_10.03_B17159.jpg)

表 10.2 – 数据快照

按照在 *第六章*，*使用 DataRobot 进行模型构建* 中建立的过程，我们为推荐系统创建了一个 DataRobot 项目。在执行此操作时，我们将 `rating.csv` 文件拖入初始项目窗口。这打开了 *图 10.2* 中显示的窗口。对于每一行，由于书籍评分被用作用户兴趣的指标，它可以作为目标变量。由于目标变量 `ratings` 的性质，这个推荐系统的机器学习模型将是回归模型类型。

![图 10.2 – DataRobot 项目启动窗口![图 10.04_B17159.jpg](img/Figure_10.04_B17159.jpg)

图 10.2 – DataRobot 项目启动窗口

如预期，评分的范围是`1`到`10`。理想情况下，我们将删除具有隐含评分（`0`）和`user_ID`字段的行，以创建一个用于建模的稳健数据集。接下来要做的事情是构建推荐系统的机器学习模型。

# 在 DataRobot 中构建推荐系统

在**组 ID 特征**字段中，`user_id`的一个优势。

如*第六章*中详细说明的，*使用 DataRobot 进行模型构建*，当在模型创建过程中模型**存储库**标签页的搜索字段中的`Training Schedule`或简单地`Training`时，DataRobot 开始开发机器学习模型。这将显示相关模型列表（见*图 10.3*）：

![图 10.3 – 选择最适合推荐系统的先进建模方法![图片](img/Figure_10.05_B17159.jpg)

图 10.3 – 选择最适合推荐系统的先进建模方法

除了选择这些建模方法并将其包括在要创建的模型列表中之外，还基于`Informative Features`执行了所有五个`交叉验证`运行。点击**运行任务**将它们包括到处理队列中。

在模型创建完成后，下一步是评估它们的准确性。在此之前，检查**相对重要性**图表以确认我们的模型是否符合常识是很重要的。正如*图 10.4*所示，通过**洞察**窗口打开**变量重要性**窗口为我们提供了探索这些模型的机会：

![图 10.4 – 变量重要性![图片](img/Figure_10.06_B17159.jpg)

图 10.4 – 变量重要性

在`London`旁边和标题的一个方面（例如，`Kingdom`）的值可以解释为对模型有影响。因此，在这个简化的例子中，创建了一个更高阶的特征，它是`London`和`Kingdom`之间的交互。因此，根据这个新创建的高阶特征的存在与否，评分预测会相应地发生很大变化。

在模型选择中，使用“定制的`Keras Slim 残差神经网络回归器使用自适应训练计划（1 层：64 个单元）`是表现最好的模型（见*图 10.5*）。重要的是要强调，在某些情况下，测量推荐系统模型的准确性并不像表面上那么简单。想象一下，在这种情况下，当一个人购买一本书时，我们只能有一个`1`的评分，否则就是`0`。天真地衡量模型的准确性变得有限，因为`0`评分并不一定意味着个人对物品不感兴趣。这是因为可能个人从未读过这本书。因为一个好的推荐系统会推荐与个人档案相匹配的未读书籍，所以它很可能有相当比例的误报。这是因为，尽管他们的当前评分是`0`，但相关用户很可能对阅读它们感兴趣。在这些情况下，**召回率**类型的指标在评估模型性能时变得更加重要。鉴于我们只确定个人购买物品的情况，单独评估这些情况是合理的。因此，模型准确性预测正确阅读的书籍的程度，通常称为**召回率**，成为一个更合适的指标。

![图 10.5 – 推荐系统排行榜标签页![图 10.7 – 数据图 B17159.jpg](img/Figure_10.07_B17159.jpg)

图 10.5 – 推荐系统排行榜标签页

对于推荐系统，在决定使用哪种模型时，准确性和预测速度是非常重要的考虑因素。为了使这个讨论有据可依，重要的是要理解，在推荐系统中进行预测有两种主要方法。第一种方法是对用户和物品组合进行批评分，其中物品尚未被用户阅读。随着物品和用户的增加，这个数据集呈指数级增长。第二种方法是*实时预测*。例如，想象一个人到达一个电子商务平台。那个人的数据以及产品的数据会迅速评分，建议几乎瞬间完成。在这两种情况下，预测速度对商业成功至关重要。DataRobot 的`Keras Slim 残差神经网络回归器使用自适应训练计划（1 层：64 个单元）`的预测速度是每 1000 次预测`1.6746`，每次预测的预测速度是`35.57`毫秒。一些混合模型的验证分数看起来更好，但在预测速度方面要弱得多。

![图 10.6 – DataRobots 的速度与准确性图表![图 10.8 – 数据图 B17159.jpg](img/Figure_10.08_B17159.jpg)

图 10.6 – DataRobots 的速度与准确性图表

这表明，尽管这个模型非常准确，但在做出预测时速度非常慢。**速度与准确性**图表展示了几个模型的速度和准确性的快照可视化。可以使用**模型比较**工具进行更深入的成对比较。为了继续讨论预测，我们现在将转向在 DataRobot 中进行推荐系统预测。

# 使用 DataRobot 进行推荐系统预测

在 DataRobot 上从推荐引擎创建建议是直接的。我们使用拖放方法（如前几章所述），因为我们的预测数据集很小。对于更大的数据集（超过 1 GB），这是推荐系统的典型情况，建议使用 DataRobot 预测 API。创建模型和进行预测的 API 方法在*第十二章*，*DataRobot Python API*中有详细说明。

我们的示例预测数据集大小为 64 MB，因此拖放方法很合适。对于这种预测方法，我们指定从原始数据集中要使用的列。理想情况下，我们至少需要一个物品和用户的标识符。如图 10.7 所示，我们选择在我们的预测中包含`ISBN`、`user_id`和`title`字段。我们将预测数据集拖放到指定区域。像往常一样，这个数据集很快就会被评估，我们会看到**运行外部测试**或**计算预测**选项。

![图 10.7 – 推荐引擎预测设置![图片](img/Figure_10.09_B17159.jpg)

图 10.7 – 推荐引擎预测设置

在这一点上，我们点击`.csv`文件（见*表 10.3*）。如前所述，预测集是从原始数据集中抽取的，其中评分是隐式的（因此评分分数为零）。因此，预测数据集只包含可能的用户-物品交互的有限样本。一些用户（例如，`user_id`为`8`的用户），大约有`10`个物品评分，而一些用户只有`1`个物品评分。在理想情况下，所有未看到的物品都应该被评分。话虽如此，向用户提供的建议是按照预测兴趣的顺序进行的。对于用户`8`，首先提供的是名为《A Second Chicken Soup for the Woman's Soul (Chicken Soup for the Soul Series)》的书籍。在某些情况下，使用的是前*n*个推荐。在我们的案例中，前*n*指的是，对于每个用户，根据其预测值选择前*n*本书籍。

![表 10.3 – 推荐引擎样本预测![图片](img/Figure_10.10_B17159.jpg)

表 10.3 – 推荐引擎样本预测

选择的模型可以使用 DataRobot 部署为 **REST** API，如*第八章*“模型评分和部署”中所示，然后可以通过 DataRobot API 调用（我们将在*第十二章*“DataRobot Python API”中讨论）对数据进行评分。一些 DataRobot 模型可以下载为 **JAR** 文件，这些文件可以与其他应用程序集成以进行实时预测。在其他情况下，可以使用不同的用户-物品交互进行批量预测，然后存储在大数据存储表中，例如 **Google Cloud BigQuery**。

# 摘要

在本章中，我们介绍了并评估了推荐系统的不同方法。我们考察了基于内容和协同过滤推荐系统的数据结构要求，并讨论了它们的潜在假设。然后我们指出 DataRobot 在从具有挑战性的数据类型（例如，图像数据）中提取特征方面的优势，这些数据类型通常限制了基于内容系统的使用。然后我们展示了如何使用小数据集构建和使用基于内容的推荐系统进行预测。

需要强调的是，本项目使用的数据集由多种数据类型组成。DataRobot 能够提取特征并整合不同数据类型以创建机器学习模型。在下一章中，我们将探讨在创建机器学习模型时如何使用包含图像、文本和位置数据的组合数据集。
