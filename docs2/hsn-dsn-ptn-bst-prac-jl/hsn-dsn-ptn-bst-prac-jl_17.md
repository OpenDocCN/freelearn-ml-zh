# 评估

# 第一章

**使用设计模式有哪些好处？**

设计模式帮助程序员将已经证明有效的方法应用于常见问题。在次优实现之后，将节省更多时间用于寻找适当的解决方案或修复设计问题。反模式为避免常见设计缺陷提供了额外的指导。

**有哪些关键的设计原则？**

关键设计原则包括 SOLID、DRY、KISS、POLA、YAGNI 和 POLP。这些原则被广泛认为是面向对象编程的良好指导，但它们同样适用于其他编程范式。

**开放/封闭原则解决了什么问题？**

开放/封闭原则鼓励程序员设计一个易于扩展的系统，而无需修改正在扩展的组件。它促进了软件组件更好的重用性。

**为什么接口分离对于软件重用很重要？**

接口分离促进了接口的最简设计，以便软件组件更容易实现相应的接口。一个庞大而复杂的接口难以实现，并且使组件的可重用性降低。

开发可维护的软件的最简单方法是什么？

最简单的方式是遵守 KISS、DRY、POLA 和 SOLID 等通用设计原则。

**避免过度设计和臃肿软件的好习惯是什么？**

避免过度设计和臃肿软件的最佳方式是根据 YAGNI 原则仅实现绝对必要的功能。同时，保持简单（KISS）并避免重复代码（DRY）。

**内存使用如何影响系统性能？**

当系统分配更多内存时，它也会更频繁地触发**垃圾回收器**（**GC**）。垃圾回收是一个相对昂贵的操作，因此，它可能会减慢系统。避免过度内存分配通常是优化应用程序性能的最佳方法之一。

# 第二章

**我们如何创建一个新的命名空间？**

命名空间是通过模块块创建的。通常，模块被定义为 Julia 包的一部分。

**我们如何将模块的功能暴露给外部世界？**

可以使用导出语句将模块内定义的函数和其他对象暴露出来。

**当同一函数名从不同的包导出时，我们如何引用正确的函数？**

我们可以直接在函数名前加上包名。作为替代方案，我们可以对一个包使用`using`语句，对另一个使用导入语句，这样我们就可以直接使用第一个包的函数名，而对其他包使用前缀语法。

**我们在什么时候将代码分离成多个模块？**

当代码变得太大，难以管理时，是时候考虑将代码分离成模块了。我们期望进行一些重构，以确保模块之间适当的耦合级别。

**为什么语义版本化在管理包依赖时很重要？**

语义版本化定义了在新版本中引入破坏性更改时的明确合同。当正确且一致地使用时，它有助于程序员确定更改是否与现有软件兼容，以及是否需要额外的测试。

**定义抽象类型的函数行为有何用途？**

为抽象类型定义函数行为是有用的，因为可以将相同的行为应用于相应的子类型。

**何时应该使类型可变？**

当预期数据类型的一些部分需要更改时，将类型设置为可变是合适的。出于性能原因需要减少内存分配时，这也很有用。

**参数类型有何用途？**

参数类型允许在不硬编码字段类型的情况下定义具体类型，因此可以使用相同的类型为不同的目的生成新的变体。

# 第三章

**位置参数与关键字参数有何不同？**

位置参数必须按照它们在函数签名中定义的顺序传递。它们通常是必需的，但可以通过提供默认值来使其可选。关键字参数可以按它们书写的任何顺序传递，并且当未提供默认值时是可选的。

**展开和吸入有何区别？**

展开和吸入具有相同的语法，但在不同的上下文中意味着不同的事情。展开指的是从元组或数组自动分配函数参数。吸入指的是将多个函数参数传递为一个单一的元组变量，该变量可以从函数体中访问。

**do-syntax 的目的是什么？**

Do-syntax 是一种方便的方式来格式化需要作为匿名函数包装并传递给另一个函数的代码块。这使得代码更加易于阅读。

**有什么工具可以检测与多重分派相关的方法歧义？**

可以使用来自`Test`包的`detect_ambiguities`函数来检测单个模块或多个模块内的方法歧义。

**我们如何确保在参数方法中传递相同的具体类型？**

确保函数的参数传递相同的具体类型的一个方便方法是将这些参数指定为类型参数（例如，`T`）。请注意，只要类型参数作为独立类型使用，而不是参数类型的一部分，例如，`AbstractVector{T}`，这就会起作用。

**在没有正式语言语法的情况下如何实现接口？**

即使 Julia 没有指定接口的正式语法，也可以根据接口设计者的规范实现接口。

**我们如何实现特质，特质有何用途？**

特质可以通过一个函数来实现，该函数接受特定的数据类型并返回一个标志。通常，特质被定义为返回布尔值，即特质是否存在。然而，它也可以设计为返回多个值以指示各种特质。如果开发者需要通过编程方式确定数据类型（或数据类型的组合）是否具有特定行为，特质是有用的。

# 第四章

**有哪两种方法可以引用表达式以便稍后进行代码操作？**

一种方法是将表达式用`:(`和`)`括起来。另一种方法是将代码放在`quote`和`end`关键字之间。一般来说，quote 块用于多行表达式。

**`eval`函数在哪个作用域中执行代码？**

`eval`函数评估全局作用域中的代码。因此，如果它从一个模块内的函数中使用，那么被评估的代码将位于模块的作用域内。

**我们如何将物理符号插入到引号表达式中，而不是将其误解释为源代码？**

要将符号插入到引号表达式，创建一个`QuoteNode`对象并正常插入该对象。

**定义非标准字符串字面量的宏的命名约定是什么？**

非标准字符串字面量定义为以`_str`结尾的宏。例如，当为 IP 地址定义`ip_str`宏时，它可以这样写：`ip"192.168.1.1"`。

**何时使用`esc`函数？**

`esc`函数需要确保引号表达式在调用点被评估，这可能是函数的局部作用域。

**生成的函数与宏有何不同？**

生成的函数可以访问参数的类型。它们是按定义是函数，因此与宏不同，它们没有访问源代码的能力。宏在语法级别上操作，并且没有任何运行时信息。生成的函数和宏都应返回表达式。

**我们如何调试元编程代码？**

调试宏可能具有挑战性。这归结于确保返回的表达式是正确的。我们可以使用`@macroexpand`宏（或相应的`macroexpand`函数）来验证结果。此外，由于宏或生成的函数是使用常规 Julia 代码定义的，因此可以使用相同的调试技术，例如`println`。

# 第五章

**委托模式是如何工作的？**

委托模式可以通过将父对象包装在新对象中来实现。新对象的功能可以转发（或委托）给父对象。

**特质的目的何在？**

特质的目的是正式定义某些对象的行为。一旦定义了特质，我们就可以通过编程方式检查一个对象是否具有该特质。

**特质总是二元的吗？**

特性通常是二元的，但没有强制性要求。只要特性是互斥的，那就没问题。Julia 的`Base.IteratorSize`特性就是一个多值特性的好例子。

**能否将特性用于不同类型层次结构中的对象？**

是的，特性不受抽象类型层次结构定义方式的限制。相同的特性可以分配给来自不同类型层次结构的对象。

**参数类型有哪些好处？**

参数类型允许我们为数据类型定义一个模板。可以通过填充参数来程序性地创建新的数据类型。参数类型的主要好处是代码变得更短，因为我们不需要列出每个可能的具体类型。

**我们如何使用参数类型来存储信息？**

可以将额外的信息作为参数存储在类型本身中。访问此类数据非常方便，因为它是第一类数据，并且可以在接受参数类型参数的函数中使用。

# 第六章

**为什么使用全局变量会影响性能？**

全局变量是无类型的。每次使用时，编译器都必须生成可以处理可能遇到的所有数据类型的代码。因此，编译器不能生成高度优化的代码。

**当无法用常量替换时，使用全局变量的良好替代方案是什么？**

我们可以定义一个有类型的全局常量作为占位符。`Ref`类型也可以用来保存变量的单个值。因为`Ref`包含数据类型，编译器可以生成更优化的代码。

**为什么数组结构体比结构体数组表现更好？**

现代 CPU 可以并行执行许多数值计算。当内存对齐并打包成数组时，硬件缓存可以快速查找它们。结构体数组可能将对象散布在内存中，这会损害性能。

**`SharedArray`的局限性是什么？**

`SharedArray`只支持位类型。如果我们需要并行处理非位类型数据，那么就不能使用 SharedArrays。

**除了使用并行进程之外，有什么是替代多核计算的方法？**

一种替代方案是使用多线程功能。Julia 1.3 版本实现了一个支持多级并行的最先进的多线程调度器。

**在使用缓存模式时，必须注意哪些问题？**

缓存化以空间换取时间。使用缓存需要更多的内存空间。根据函数结果，它可能或可能不会影响应用程序的内存占用。如果系统中的内存已经受限，这可能不是最佳选择。

**性能提升中屏障函数背后的魔法是什么？**

当使用`barrier`函数时，编译器可以根据传递给函数的参数类型来专门化函数。即使参数类型不稳定，当遇到新类型时，也会自动编译一个新的专门化函数。

# 第七章

**什么是输入耦合和输出耦合？**

输入耦合表示有多少外部组件依赖于当前组件。相比之下，输出耦合表示当前组件依赖于多少外部组件。这些测量有助于确定当前组件与其他组件的耦合程度。

**从可维护性的角度来看，双向依赖为什么不好？**

双向依赖往往会引入混乱的意大利面条式代码。为了理解单个组件，开发者必须处理并理解它所使用和依赖的其他组件。

**有什么简单的方法可以即时生成代码？**

`@eval`宏可以用来生成代码。例如，它可以在`for`循环中使用，以便将变量插入到函数的定义中。结果是定义了多个函数，它们在代码结构和逻辑方面都相似。

**代码生成的替代方案是什么？**

有时，不需要代码生成。相反，开发者可以选择使用函数式编程技术，如闭包，来重用现有逻辑。代码生成可能会增加程序的大小，并使程序更难调试。因此，在深入代码生成技术之前，开发者考虑其他选项将是明智的。

**何时以及为什么我们应该考虑构建一个特定领域的语言？**

**特定领域语言（DSL**）通常用于编写特定领域内清晰且易于理解代码。例如，`DifferentialEquations`包允许开发者使用与相应数学方程非常相似的语法编写代码。由于语法友好，它允许开发者专注于数学建模而不是编码方面。

**开发特定领域语言有哪些可用的工具？**

`MacroTools`包提供了几个方便的宏，这些宏在编写宏和特定领域语言中非常有帮助。`@capture`宏允许用户执行模式匹配和解析源代码。`prewalk`和`postwalk`函数允许我们在抽象语法树中手术性地替换表达式。`@capture`和`prewalk`/`postwalk`的组合使其成为开发特定领域语言的一个非常强大的工具。

# 第八章

**开发评估函数有哪些好处？**

评估函数是向特定对象的用户提供官方 API 的绝佳方式。因此，底层实现与接口解耦。如果实现有任何变化，只要评估函数的契约保持不变，就不会对对象的用户产生任何影响。

**有什么简单的方法可以阻止使用对象的内部字段？**

最简单的方法是使用特殊的命名约定来阻止使用对象的内部字段。常用的约定是将下划线作为字段名称的前缀。如果程序员尝试使用该字段，那么他们会提醒自己该字段应该是私有的。

**哪些函数可以作为属性接口的一部分进行扩展？**

`Base` 包中有三个函数可以被扩展以提供特定功能，用于字段访问的点表示法。这些函数是 `getproperty`、`setproperty!` 和 `propertynames`。一个需要记住的重要点是，一旦这些函数被定义，所有直接的字段访问都必须改为 `getfield` 和 `setfield!` 以避免递归问题。

**如何在捕获异常后从 catch-block 中捕获堆栈跟踪？**

一旦捕获到异常，我们可以使用 `catch_backtrace` 函数来捕获异常被捕获之前的堆栈帧。然后我们可以将结果传递给 `stacktrace` 函数以检索 `StackFrame` 对象的数组。

**如何避免对需要最佳性能的系统中的 try-catch 块的性能影响？**

避免使用 try-catch 块的性能影响最好的方法是根本不使用它。我们应该找到其他处理异常的方法。例如，我们可以检查任何可能导致后续函数失败的条件。在这种情况下，我们可以主动处理这种情况。另一种选择是在循环外部捕获异常；因此，我们会在更高的级别处理异常。

**使用 `retry` 函数有哪些好处？**

`retry` 函数是一种自动重复可能失败的操作的绝佳方式。这样做可以确保重要任务能够得到保证完成，除非有其他类型的不可恢复异常。

**我们如何隐藏模块内部使用的全局变量和函数？**

我们可以使用 let-block，这样全局变量就被绑定在 let-block 中，而不是暴露在模块的全局作用域中。当需要将函数暴露给模块时，定义在 let-block 内部的函数可以被声明为全局。

# 第九章

**可以使用哪种预定义的数据类型方便地创建新的单例类型？**

内置的 `Val` 类型可以轻松地创建新的单例类型。`Val` 构造函数可以接受任何位类型值，并返回类型为 `Val{X}` 的单例，其中 `X` 是传递给构造函数的值。

**使用单例类型分发的优点是什么？**

使用单例类型分发，我们可以消除依赖于数据类型的条件语句。它还允许我们通过仅定义新函数来添加新功能，而无需修改现有函数。因为 Julia 原生支持分派，所以不需要创建任何自定义函数仅用于分派。

**为什么我们要创建模拟器？**

模拟器在自动化测试中非常有用。首先，如果一个函数需要连接到远程网络服务，那么始终连接到实时服务可能不方便，甚至可能成本高昂。在这种情况下，可以使用模拟器来代替服务。其次，模拟器可以被设计成测试所有正面和负面场景，以便将所需的测试包含在自动化测试过程中。

**模拟和模拟之间的区别是什么？**

模拟器关注的是状态验证，即在模拟器使用后**被测试函数**（**FUT**）的输出。另一方面，模拟关注的是行为验证，即模拟函数是如何被 FUT 使用的。一般来说，模拟也像模拟器一样包括状态验证。

**组合性意味着什么？**

组合性意味着函数可以组合起来创建更大的东西有多容易。可组合函数允许通过重用现有代码来构建应用程序。因为函数在 Julia 中是一等公民，所以只要函数只接受单个参数，它们就可以很容易地组合。

**使用功能管道的主要约束是什么？**

功能管道的主要约束是管道中参与的功能只能接受单个参数。需要多个参数的函数可以被转换为一个`curried`函数，这样高阶函数就可以参与管道。

**功能管道有什么用途？**

功能管道对于数据处理管道非常有用，特别是如果过程本质上是线性的。对于某些人来说，语法易于阅读。

# 第十章

**一级盗版的风险和潜在好处是什么？**

一级盗版指的是第三方功能被自定义实现重新定义的情况。风险在于自定义实现可能不符合第三方模块预期的合同。如果代码编写错误，系统可能会变得不稳定并崩溃。

**由于二级盗版可能会出现什么问题？**

二级盗版指的是在函数参数中不使用自己的类型扩展第三方功能的情况。这可能会出现问题，因为没有保证另一个依赖包也实现了二级盗版，可能与你的盗版函数冲突。结果可能是一个不稳定的系统。

**三级盗版是如何引起麻烦的？**

类型 III 盗用指的是一种情况，即第三方函数通过您的自定义类型进行了扩展，但目的不同。虽然函数定义使用自定义类型作为参数，但无法保证第三方模块不会因为鸭子类型而最终使用您的函数。因此，您的盗用函数泄漏到第三方模块中，导致意外结果。

**在指定函数参数时，我们应该注意哪些问题？**

在指定函数参数时，我们应该避免使参数类型过于狭窄。过于狭窄的参数限制了函数的可重用性。

**使用抽象函数参数如何影响系统性能？**

当使用抽象类型指定函数参数时，系统性能不受影响。Julia 总是根据传递给函数的类型来指定函数。因此，没有运行时开销。

**使用抽象字段类型为复合类型时，系统性能如何受到影响？**

当在复合类型的字段中使用抽象类型时，系统性能会受到负面影响。Julia 编译器必须在内存中存储这些对象的指针，因为它必须支持与这些字段相关的任何数据类型。因为必须解引用指针才能访问数据，所以系统性能可能会大幅下降。

# 第十一章

**我们可以使用什么技术来实现抽象工厂模式？**

为了实现抽象工厂模式，我们可以创建一个抽象类型的层次结构。然后，我们可以实现接受单例类型作为参数的具体函数。通过多分派，我们应该能够调用适合正确平台或环境的正确函数。

**如何在多线程应用程序中避免单例被多次初始化？**

为了避免单例的多次初始化，我们可以使用可重入锁来同步线程。第一个线程将能够获取锁并初始化单例，而其他线程应在初始化完成后等待。必须在初始化结束时释放锁。

**实现观察者模式时，Julia 的哪个特性是必不可少的？**

我们可以实现`setproperty!`函数，以便可以监控对象的字段的所有更新，并触发额外的操作。

**我们如何使用模板方法模式来自定义操作？**

我们可以设计模板函数，通过关键字参数接受自定义函数。关键字参数可以默认为标准实现，同时调用者也可以传递自定义函数。函数的预期接口应该有明确的文档说明。

**我们如何制作适配器以实现目标接口？**

我们可以通过创建一个新的类型来包装原始类型来制作一个适配器。然后，我们可以在新类型上实现预期的接口。使用委托模式，新类型可以通过将特定函数转发到原始类型来重用现有功能。

**享元模式有哪些好处，我们可以使用什么策略来实现它？**

使用享元模式时，由于对象是共享的，我们可以潜在地节省大量内存空间。一般技术是维护一个参考表，该表使用更紧凑的数据元素作为查找键。该键用于查找更占用内存的对象。

**我们可以使用 Julia 的哪个特性来实现策略模式？**

我们可以使用单例类型作为函数参数来实现策略模式。具有适当算法（策略）的函数在运行时通过多重分派自动选择。

# 第十二章

**实现继承与行为子类型化有何不同？**

实现继承允许子类从超类继承字段和方法。行为子类型化允许子类型继承为超类型定义的方法。

**与实现继承相关的一些主要问题是什么？**

实现继承是有问题的，因为有时，子类可能不想从超类继承字段，即使定义父子关系在逻辑上是有意义的。正如从正方形-矩形问题中所示，子类可能更加限制性，并移除功能，而不是在超类之上添加新功能。其次，实现继承受到脆弱基类问题的困扰，对超类的更改可能无意中修改了子类的行为。

**什么是鸭式类型？**

鸭式类型是一种动态特性，它允许在不进行强类型检查的情况下分发方法。只要函数遵循预期的接口合约，就可以分发函数。

**方法参数的变异性是什么，为什么？**

方法参数是协变的，因为它们与 Liskov 替换原则一致，该原则指出，定义为接受类型 *S* 的函数应该能够与 *S* 的任何子类型一起工作。

**为什么在 Julia 中参数化类型是不变的？**

在 Julia 中，参数化类型是不变的，这是一个非常实际的原因。类型参数明确地确定了底层容器的内存布局。当它是不变的，就有机会通过连续压缩存储数据来达到高性能，而不需要解引用指针。

**对角线规则何时适用？**

当类型变量在协变位置出现多次时，会应用对角线规则。当从不变位置（如参数化类型）明确确定相同的类型变量时，该规则存在例外。
