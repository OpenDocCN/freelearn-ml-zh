- en: Design Patterns and Related Principles
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计模式和相关的原则
- en: Nowadays, learning and applying design patterns is an important aspect of software
    engineering. Design patterns are like water – you can't live without them. Don't
    believe me? Just ask hiring managers, and you will find that many of them have
    design patterns in their job postings as well as related questions in job interviews.
    It is a common belief that design patterns are important ingredients for software
    development and everyone should know them.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，学习和应用设计模式是软件工程的一个重要方面。设计模式就像水一样——没有它们你无法生存。你不相信吗？只需问问招聘经理，你就会发现他们中的许多人不仅在职位发布中提到了设计模式，而且在面试中也提出了相关问题。人们普遍认为，设计模式是软件开发的重要成分，每个人都应该了解它们。
- en: 'In this chapter, we will provide some context about why design patterns are
    useful and how they have served us well in the past few decades. By understanding
    the motivation behind design patterns, we will be able to set forth a set of guiding
    principles for developing software. The following topics will be discussed in
    this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将提供一些关于为什么设计模式是有用的以及它们在过去几十年里是如何为我们服务的背景信息。通过理解设计模式背后的动机，我们将能够提出一套指导原则，用于软件开发。本章将讨论以下主题：
- en: The history of design patterns
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计模式的起源
- en: Software design principles
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 软件设计原则
- en: Software quality objectives
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 软件质量目标
- en: Let's get started!
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: The history of design patterns
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计模式的起源
- en: Design patterns is not a new concept to computer programmers. Since personal
    computers became more affordable and popular in the 1980s, the programming profession
    flourished and a lot of code was written for a variety of applications.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式对计算机程序员来说不是一个新概念。自从20世纪80年代个人电脑变得价格更合理且更受欢迎以来，编程职业蓬勃发展，并为各种应用编写了大量代码。
- en: I remember that, when I was 14 years old, learning the GOTO statement for a
    BASIC program was one of the coolest things. It literally allowed me to take a
    control flow to a different part of the code at any time. Perhaps not too surprisingly,
    when I learned about structured programming and the Pascal language in college,
    I started to realize how GOTO statements produce messy spaghetti code. Using GOTO
    for branching purposes is a pattern. It's just a bad one because it makes code
    difficult to understand, follow, and debug. In today's *lingua franca,* we call
    them anti-patterns. When it comes to structured programming techniques, organizing
    code in small functions is a pattern as well, one that has been taught as a mainstream
    subject in programming courses.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我记得，当我14岁的时候，学习BASIC程序的GOTO语句是我觉得最酷的事情之一。它实际上允许我在任何时候将控制流程带到代码的另一个部分。也许并不令人惊讶，当我上大学时学习了结构化编程和Pascal语言，我开始意识到GOTO语句会产生混乱的意大利面代码。用GOTO进行分支是一个模式。它只是一个很糟糕的模式，因为它使得代码难以理解、跟踪和调试。在今天的*通用语言*中，我们称它们为反模式。当涉及到结构化编程技术时，将代码组织成小函数也是一个模式，这是编程课程中作为主流主题教授的内容。
- en: When I graduated from college, I started my programming career and spent plenty
    of time *hacking away*. I had the opportunity to do various kinds of research
    and find out how systems are designed. For example, I realized that the Unix operating
    system has a beautiful design. That is because it consists of many small programs,
    which individually do not have a ton of functionality, but you can compose them
    in any number of ways to solve more complex problems. I was also fond of the Scheme
    programming language, which came out of MIT's AI Lab. The simplicity and versatility
    of the language still amazes me today. Scheme's heritage can be traced to Lisp,
    which had some influence on how the Julia language was designed.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当我从大学毕业时，我开始我的编程生涯，并花费了大量时间进行*黑客攻击*。我有机会进行各种研究，并了解系统是如何设计的。例如，我意识到Unix操作系统有一个美丽的设计。那是因为它由许多小程序组成，这些程序本身并没有很多功能，但你可以用任何数量的方式将它们组合起来，以解决更复杂的问题。我也非常喜欢Scheme编程语言，它起源于麻省理工学院的AI实验室。这种语言的简洁性和多功能性至今仍让我感到惊奇。Scheme的遗产可以追溯到Lisp，这对Julia语言的设计产生了一定的影响。
- en: The rise of design patterns
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计模式的出现
- en: In 1994, while I was diving deep into C++ and distributed computing for a financial
    application, four software professionals, also known as the Gang of Four or GoF,
    came together and published a book about design patterns, and it took the object-oriented
    programming community by storm. The group collected and classified 23 design patterns
    that were commonly utilized when developing large-scale systems. They also chose
    to explain the concepts using **Unified Modeling Language** (**UML**) and C++
    and Smalltalk.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 1994年，当我深入到C++和分布式计算中，为金融应用程序开发时，四位软件专业人士，也被称为四人帮或GoF，聚集在一起并出版了一本关于设计模式的书，该书在面向对象编程社区中引起了轰动。该小组收集和分类了在开发大型系统时常用的23个设计模式。他们还选择使用**统一建模语言**（**UML**）和C++、Smalltalk来解释这些概念。
- en: For the first time, a set of design patterns had been collected, organized,
    explained, and widely distributed to software developers. Perhaps one of the most
    significant decisions by the group was to organize these patterns in a highly
    structured and easily consumable format. Since then, programmers have been able
    to communicate with each other easily about how they design their software. In
    addition, they can visually present software design with a universal notation.
    When one person talks about the Singleton pattern, another person can immediately
    understand and even visualize in his/her mind how that component works. Isn't
    that convenient?
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 首次，一套设计模式被收集、组织、解释并广泛分发给软件开发者。也许该小组做出的最重大决定之一就是将这些模式组织成高度结构化和易于消费的格式。从那时起，程序员们可以轻松地相互交流他们如何设计软件。此外，他们可以使用通用符号直观地展示软件设计。当一个人谈论单例模式时，另一个人可以立即理解和甚至在自己的脑海中可视化该组件的工作方式。这不是很方便吗？
- en: Even more surprisingly, design patterns suddenly became the gospel when it come
    to building good software. In some ways, using them was even perceived as the
    only way to write good software. GoF patterns were so widely preached across the
    development community that many people abused them and used them everywhere without
    good reason. The problem is – *When all you have is a hammer, everything looks
    like a nail! *Not everything can be solved or should be solved by the same patterns.
    When design patterns are overused or misused, the code becomes more abstract,
    more complicated, and more difficult to manage.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 更令人惊讶的是，设计模式在构建优秀软件时突然成为了圣经。在某种程度上，使用它们甚至被视为编写优秀软件的唯一途径。GoF模式在开发社区中被广泛传播，以至于许多人滥用它们，没有合理的理由就将它们应用到各个地方。问题是——*当你只有一把锤子时，一切看起来都像钉子！*并非所有问题都可以或应该用相同的模式来解决。当设计模式被过度使用或误用时，代码变得更加抽象、复杂，也更难以管理。
- en: So, what have we learned from the past? We recognize that every abstraction
    comes with a cost. Every design pattern comes with its own pros and cons. One
    of the main objectives of this book is to discuss not just the how but also the
    why and why not, and under what circumstances a pattern should be used or not
    used. We, as software professionals, will then be equipped with the information
    we need to make good judgment calls about when to apply these patterns.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们从过去学到了什么？我们认识到，每个抽象都伴随着成本。每个设计模式都有其自身的优缺点。本书的主要目标之一不仅是讨论如何使用，还要讨论为什么使用或不使用，以及在什么情况下应该使用或不使用某个模式。作为软件专业人士，我们将装备所需的信息，以便在何时应用这些模式时做出良好的判断。
- en: More thoughts about GoF patterns
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于GoF模式的更多思考
- en: 'GoF design patterns are classified into three main categories:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: GoF设计模式分为三大类：
- en: '**Creational patterns**: These cover how to construct objects in various ways.
    Since object-oriented programming brings together data and behavior, and a class
    may inherit the structure and behavior of an ancestor class, there are some complexities
    involved when building a large application. Creational patterns help standardize
    object creation methods in various situations.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建型模式**：这些模式涵盖了以各种方式构建对象的方法。由于面向对象编程将数据和操作结合在一起，并且一个类可能继承祖先类的结构和行为，因此在构建大型应用程序时涉及一些复杂性。创建型模式有助于在各种情况下标准化对象创建方法。'
- en: '**Structural patterns**: These cover how objects can be extended or composed
    to make bigger thing. The purpose of these patterns is to allow software components
    to be reused or replaced more easily.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结构型模式**：这些模式涵盖了如何扩展或组合对象以形成更大的事物。这些模式的目的在于使软件组件更容易重用或替换。'
- en: '**Behavioral patterns**: This cover how objects can be designed to perform
    separate tasks and communicate with each other. A large application can be decomposed
    into independent components and the code becomes easier to maintain. The object-oriented
    programming paradigm requires solid interaction between objects. The purpose of
    these patterns is to make software components more flexible and more convenient
    for collaboration with each other.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行为模式**：这涵盖了如何设计对象以执行单独的任务并相互通信。大型应用程序可以被分解成独立的组件，从而使代码更容易维护。面向对象编程范式要求对象之间有坚实的交互。这些模式的目的在于使软件组件更加灵活，并更方便彼此协作。'
- en: One school of thought is that design patterns are created to address limitations
    in their respective programming language. Two years after the GoF book was published,
    Peter Norvig published research showing that 16 of the 23 design patterns are
    either unnecessary or can be simplified in a dynamic programming language such
    as Lisp.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一种观点是，设计模式是为了解决各自编程语言中的局限性而创建的。在 GoF 书籍出版两年后，彼得·诺维格发表了一项研究，表明 23 个设计模式中的 16
    个要么是不必要的，或者可以在像 Lisp 这样的动态编程语言中简化。
- en: '*This is not an unimportant observation*. In the context of object-oriented
    programming, additional abstraction from a class hierarchy requires the software
    designer to think about how objects are instantiated and interact with each other.
    In a strong, statically typed language such as Java, it is even more necessary
    to reason about the behavior and interaction of objects. In [Chapter 11](9984b03e-c2c1-4b65-8f07-6240804db32d.xhtml),
    *Traditional Object-Oriented Patterns*, we will circle back to this topic and
    discuss how Julia works differently compared to object-oriented programming.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*这是一个不容忽视的观察结果*。在面向对象编程的背景下，从类层次结构中抽象出额外的抽象需要软件设计者思考对象是如何实例化和相互交互的。在一个强大、静态类型语言如
    Java 中，对对象的行为和交互进行推理就更加必要了。在第 11 章，*传统面向对象模式*中，我们将回到这个话题，并讨论 Julia 与面向对象编程相比是如何不同的。'
- en: For now, we will start with the basics and review some software design principles.
    These principles are like the North star, guiding us as we build applications.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们将从基础知识开始，回顾一些软件设计原则。这些原则就像北极星，在我们构建应用程序时指引我们。
- en: How do we describe patterns in this book?
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们如何在本书中描述模式？
- en: If you are new to Julia programming, this book will help you understand how
    to write more idiomatic Julia code. We will also focus on describing some of the
    most useful patterns that are already used in the existing open source Julia ecosystem.
    That includes Julia's own Base and `stdlib` packages as the Julia runtime is largely
    written in Julia itself. We will also reference other packages that are used for
    numerical computing and web programming.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你刚开始学习 Julia 编程，这本书将帮助你理解如何编写更符合 Julia 习惯的代码。我们还将专注于描述一些在现有的开源 Julia 生态系统中被广泛使用的最有用的模式。这包括
    Julia 自己的 Base 和 `stdlib` 包，因为 Julia 运行时大部分是用 Julia 编写的。我们还将参考其他用于数值计算和网络编程的包。
- en: For ease of reference, we will organize our patterns by name. For example, the
    Holy Traits pattern refers to a specific method for implementing traits. The Domain-Specific
    Language pattern talks about how to build new syntax to represent specific domain
    concepts. The sole purpose of having a name is just ease of reference.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了便于参考，我们将按名称组织我们的模式。例如，神圣特质模式指的是实现特质的具体方法。领域特定语言模式讨论了如何构建新的语法来表示特定的领域概念。拥有名称的唯一目的是为了便于参考。
- en: When we discuss these design patterns in this book, we will try to understand
    the motivation behind them. What specific problem are we trying to solve? What
    would be a real-world situation where such a pattern would be useful? Then, we
    will get into the details of how to solve these problems. Sometimes, there may
    be several ways to solve the same problem, in which case we will look into each
    possible solution and discuss the pros and cons.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在本书中讨论这些设计模式时，我们将试图理解其背后的动机。我们试图解决什么具体问题？在现实世界中，什么样的场景会用到这样的模式？然后，我们将深入探讨如何解决这些问题。有时，解决同一个问题可能有几种方法，在这种情况下，我们将研究每种可能的解决方案，并讨论其优缺点。
- en: Having said that, it is important for us to understand the ultimate goal of
    using design patterns. Why do we want to use design patterns in the first place?
    To answer this question, it would be useful for us to first understand some key
    software design principles.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，了解使用设计模式的最终目标对我们来说很重要。我们为什么要首先使用设计模式？为了回答这个问题，首先了解一些关键的软件设计原则会有所帮助。
- en: Software design principles
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件设计原则
- en: 'While this book does not cover object-oriented programming, some object-oriented
    design principles are universal and could be applied to any programming language
    and paradigm. Here, we will take a look at some of the most well-known design
    principles. In particular, we will cover the following:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这本书没有涵盖面向对象编程，但一些面向对象的设计原则是通用的，可以应用于任何编程语言和范式。在这里，我们将探讨一些最著名的设计原则。特别是，我们将涵盖以下内容：
- en: '**SOLID**: Single Responsibility, Open/Closed, Liskov Substitution, Interface
    Segregation, Dependency Inversion'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SOLID**: 单一职责、开放/封闭、李斯克夫替换、接口隔离、依赖倒置'
- en: '**DRY**: Don''t Repeat Yourself'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DRY**: 不要重复自己'
- en: '**KISS**: Keep It Simple, Stupid!'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**KISS**: 简单就是美！'
- en: '**POLA**: Principle of Least Astonishment'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**POLA**: 最小惊讶原则'
- en: '**YAGNI**: You Aren''t Gonna Need It'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**YAGNI**: 你不会需要它'
- en: '**POLP**: Principle of Least Privilege'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**POLP**: 最小权限原则'
- en: Let's start with SOLID.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从SOLID开始。
- en: SOLID
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SOLID
- en: 'The SOLID principle consists of the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: SOLID原则由以下内容组成：
- en: '**S**: Single Responsibility Principle'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**S**: 单一职责原则'
- en: '**O**: Open/Closed Principle'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**O**: 开放/封闭原则'
- en: '**L**: Liskov Substitution Principle'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**L**: 李斯克夫替换原则'
- en: '**I**: Interface Segregation Principle'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**I**: 接口隔离原则'
- en: '**D**: Dependency Inversion Principle'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**D**: 依赖倒置原则'
- en: Let's understand each concept in detail.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细了解每个概念。
- en: Single Responsibility Principle
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单一职责原则
- en: The Single Responsibility Principle states that every module, class, and function
    should be responsible for a single functional objective. There should be only
    one reason to make any changes.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 单一职责原则指出，每个模块、类和函数都应该只负责一个功能目标。应该只有一个理由去修改任何东西。
- en: 'The benefits of this principle are listed here:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这个原则的好处如下：
- en: The programmer can focus on a single context during development.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在开发过程中，程序员可以专注于单一上下文。
- en: The size of each component is smaller.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个组件的大小更小。
- en: The code is easier to understand.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码更容易理解。
- en: The code can be tested more easily.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码更容易测试。
- en: Open/Closed Principle
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开放/封闭原则
- en: The Open/Closed Principle states that every module should be open for extension
    but closed for modification. It is necessary to distinguish between enhancement
    and extension—enhancement refers to a core improvement of the existing module,
    while an extension is considered an add-on that provides additional functionality.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 开放/封闭原则指出，每个模块应该对扩展开放，但对修改封闭。区分增强和扩展是必要的——增强指的是现有模块的核心改进，而扩展被认为是提供额外功能的附加组件。
- en: 'The following are the benefits of this principle:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是这个原则的好处：
- en: Existing components can be easily reused to derive new functionalities.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现有的组件可以很容易地重用来派生新的功能。
- en: Components are loosely coupled so it is easier to replace them without affecting
    the existing functionality.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件松散耦合，因此更容易替换而不影响现有功能。
- en: Liskov Substitution Principle
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 李斯克夫替换原则
- en: The Liskov Substitution Principle states that a program that accepts type *T*
    can also accept type *S* (which is a subtype of *T*), without any change in behavior
    or intended outcome.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 李斯克夫替换原则指出，一个接受类型*T*的程序也可以接受类型*S*（它是*T*的子类型），而不改变行为或预期结果。
- en: 'The following are the benefits of this principle:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是这个原则的好处：
- en: A function can be reused for any subtype passed in the arguments.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数可以用于任何传入参数的子类型。
- en: Interface Segregation Principle
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口隔离原则
- en: The Interface Segregation Principle states that a client should not be forced
    to implement interfaces that it does not need to use.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 接口隔离原则指出，客户端不应该被迫实现它不需要使用的接口。
- en: 'The following are the benefits of this principle:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是这个原则的好处：
- en: Software components are more modular and reusable.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 软件组件更模块化和可重用。
- en: New implementations can be created more easily.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的实现可以更容易地创建。
- en: Dependency Inversion Principle
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖倒置原则
- en: The Dependency Inversion Principle states that high-level classes should not
    depend on low-level classes; instead, high-level classes should depend on an abstraction
    that low-level classes implement.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖倒置原则指出，高级类不应该依赖于低级类；相反，高级类应该依赖于低级类实现的抽象。
- en: 'The following are the benefits of this principle:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是这个原则的好处：
- en: Components are more decoupled.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件更加解耦。
- en: The system becomes more flexible and can adapt to changes more easily. Low-level
    components can be replaced without affecting high-level components.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统变得更加灵活，可以更容易地适应变化。低级组件可以被替换，而不会影响高级组件。
- en: DRY
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DRY
- en: 'We''ll now cover the DRY principle:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将介绍DRY原则：
- en: '**D**: Don''t'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**D**: 不要'
- en: '**R**: Repeat'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**R**: 重复'
- en: '**Y**: Yourself'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Y**: 自己'
- en: This acronym is a good way of reminding programmers that duplicate code is bad.
    It is obvious that duplicate code can be difficult to maintain—whenever logic
    is changed, multiple places in the code are affected.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这个缩写是一个很好的方式来提醒程序员，重复代码是坏事。显然，重复代码可能难以维护——每当逻辑发生变化时，代码中的多个地方都会受到影响。
- en: What do we do when duplicate code is found? Eliminate it and create a common
    function that is reusable from multiple source files.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们发现重复代码时，我们该怎么办？消除它，并创建一个可以从多个源文件复用的通用函数。
- en: In addition, sometimes code is not 100% duplicated but instead is 90% similar.
    That is not an uncommon scenario. In that case, consider redesigning the relevant
    components, possibly refactoring code to a common interface.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，有时代码并不是100%重复的，而是90%相似。这种情况并不少见。在这种情况下，考虑重新设计相关组件，可能需要将代码重构到公共接口。
- en: KISS
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: KISS
- en: 'Let''s talk about the KISS principle:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们谈谈KISS原则：
- en: '**K**: Keep'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**K**: 保持'
- en: '**I**: It'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**I**: 它'
- en: '**S**: Simple'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**S**: 简单'
- en: '**S**: Stupid!'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**S**: 愚蠢！'
- en: Often, when we design software, we like to think ahead and try to deal with
    all kinds of future scenarios. The trouble with building such *future-proof *software
    is that it takes exponentially more effort to design and code properly. Practically
    speaking, it's a conundrum—there is no 100% future-proof solution because technology
    changes, business changes, and people change. Also, over-engineering could lead
    to excessive abstraction and indirection, making a system more difficult to test
    and maintain.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 经常，当我们设计软件时，我们喜欢提前思考并尝试处理各种未来的场景。构建这种**防未来的**软件的麻烦在于，它需要指数级更多的努力来设计和编码。从实际的角度来看，这是一个难题——因为技术会变化，业务会变化，人也会变化，所以没有100%的防未来解决方案。此外，过度设计可能会导致过度抽象和间接，使系统更难测试和维护。
- en: In addition, when using Agile software development methods, we value faster
    and high-quality delivery over perfection or excess engineering. Keeping the design
    and code simple is a virtue that every programmer should keep in mind.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当使用敏捷软件开发方法时，我们重视快速和高质的交付，而不是完美或过度工程。保持设计和代码简单是每个程序员都应该记住的美德。
- en: POLA
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: POLA
- en: 'Let''s look at the POLA principle:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看POLA原则：
- en: '**P**: Principle'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**P**: 原则'
- en: '**O**: Of'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**O**: 的'
- en: '**L**: Least'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**L**: 最小化'
- en: '**A**: Astonishment'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**A**: 惊讶'
- en: POLA states that a software component should be easy to understand and its behavior
    should never be a surprise (or, more accurately, *astonishing*) to the client.
    How do we do that?
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: POLA原则指出，软件组件应该易于理解，其行为永远不应该让客户感到惊讶（或者更准确地说，*震惊*）。我们如何做到这一点？
- en: 'The following are some things to keep in mind:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些需要注意的事项：
- en: Make sure that the names of the module, function, or function arguments are
    clear and unambiguous.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保模块、函数或函数参数的名称清晰且无歧义。
- en: Ensure that modules are right-sized and well maintained.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保模块大小适中且维护良好。
- en: Ensure that interfaces are small and easy to understand.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保接口小且易于理解。
- en: Ensure that functions have few positional arguments.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保函数具有很少的位置参数。
- en: YAGNI
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: YAGNI
- en: 'Let''s move on to the YAGNI principle:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续讨论YAGNI原则：
- en: '**Y**: You'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Y**: 你'
- en: '**A**: Aren''t'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**A**: 不'
- en: '**G**: Gonna'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**G**: 将来'
- en: '**N**: Need'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**N**: 需要'
- en: '**I**: It'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**I**: 它'
- en: 'YAGNI says you should only develop software that is needed today. This principle
    came from **Extreme Programming** (**XP**). See what Ron Jeffries, co-founder
    of XP, wrote in his blog:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: YAGNI原则指出，你应该只开发今天需要的软件。这个原则来自**极限编程**（**XP**）。看看极限编程的共同创始人Ron Jeffries在他的博客中写了什么：
- en: '"Always implement things when you actually need them, never when you just foresee
    that you need them."'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: “总是在你需要的时候实现事物，而不是仅仅预见你需要它们的时候。”
- en: 'Software engineers are sometimes tempted to develop functionality that they
    feel the customer will need in the future. It''s been proven time and time again
    that this is not the most effective way to develop software. Consider the following
    scenarios:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 软件工程师有时会诱惑开发他们认为客户将来会需要的功能。一次又一次地证明，这并不是开发软件最有效的方法。考虑以下场景：
- en: The functionality is never needed by the customer and so the code is never used.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能永远不会被客户需要，因此代码永远不会被使用。
- en: The business environment changes and the system has to be redesigned or replaced.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 商业环境发生变化，系统需要重新设计或替换。
- en: The technology changes and the system has to be upgraded to use a new library,
    a new framework, or a new language.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 技术发生变化，系统需要升级以使用新的库、新的框架或新的语言。
- en: The cheapest software is the one that you didn't write. *You aren't gonna need
    it!*
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 代价最低的软件是你没有写的那部分。*你不会需要它！*
- en: POLP
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: POLP
- en: 'Now, for POLP:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看POLP：
- en: '**P**: Principle'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**P**：原则'
- en: '**O**: Of'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**O**：的'
- en: '**L**: Least'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**L**：最小'
- en: '**P**: Privilege'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**P**：权限'
- en: POLP states that a client must be given access only to the information or functions
    that they need. POLP is one of the most important pillars for building secure
    applications, and it is widely adopted by cloud infrastructure vendors such as
    Amazon, Microsoft, and Google.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: POLP指出，客户端只能访问他们需要的或功能。POLP是构建安全应用最重要的支柱之一，并且被像亚马逊、微软和谷歌这样的云基础设施供应商广泛采用。
- en: 'There are quite a few benefits when POLP is applied:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用POLP时，有很多好处：
- en: Sensitive data is protected and not exposed to non-privileged users.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 敏感数据受到保护，不会暴露给非特权用户。
- en: The system can be tested more easily since the number of use cases is limited.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于用例数量有限，系统可以更容易地进行测试。
- en: The system becomes less prone to misuse because only limited access is given
    and the interface is simpler.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于只提供了有限的访问权限并且接口更简单，系统不太可能被误用。
- en: The software design principles that we have learned about so far are great tools.
    Although SOLID, DRY, KISS, POLA, YAGNI, and POLP seem to be just a bunch of acronyms,
    they are useful in designing better software. While SOLID principles came from
    the object-oriented programming paradigm, SOLID's concepts can still be applied
    to other languages and environments. As we work through the rest of the chapters
    in this book, I would encourage you to keep them in mind.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止学到的软件设计原则是伟大的工具。尽管SOLID、DRY、KISS、POLA、YAGNI和POLP看起来只是一堆缩写，但在设计更好的软件时它们是有用的。虽然SOLID原则来自面向对象编程范式，但SOLID的概念仍然可以应用于其他语言和环境。随着我们在本书的其余章节中继续前进，我鼓励你记住它们。
- en: In the next section, we will go over several software quality objectives when
    designing software.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论设计软件时的几个软件质量目标。
- en: Software quality objectives
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件质量目标
- en: Everyone likes beautiful design. I do, too. But, the use of design patterns
    is not just to make something look good. Everything we do should have a purpose.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 每个人都喜欢美好的设计。我也一样。但是，使用设计模式的目的不仅仅是让某物看起来好看。我们做的每一件事都应该有目的。
- en: 'The GoF classified object-oriented design patterns as creational, structural,
    and behavioral. For Julia, let''s take a different perspective and classify our
    patterns by their respective software quality objectives as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: GoF将面向对象设计模式分为创建型、结构型和行为型。对于Julia，让我们从不同的角度出发，根据各自的软件质量目标对模式进行分类，如下所示：
- en: Reusability
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可重用性
- en: Performance
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能
- en: Maintenance
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维护
- en: Safety
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全性
- en: Let's understand each of these in the following sections.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在接下来的章节中了解每个概念。
- en: Reusability
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可重用性
- en: People often talk about top-down and bottom-up approaches when designing software.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当设计软件时，人们经常谈论自顶向下和自底向上的方法。
- en: The **top-down approach** starts with a large problem and breaks it down into
    a set of smaller problems. Then, if the problems are not small enough, as discussed
    when we looked at the Single Responsibility Principle, we further break down the
    problem into even smaller ones. The process repeats and eventually the problem
    is small enough to design and code.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**自顶向下的方法**从一个大问题开始，将其分解成一系列较小的问题。然后，如果问题不够小，正如我们在查看单一职责原则时所讨论的，我们将进一步将问题分解成更小的问题。这个过程会重复进行，最终问题足够小，可以设计和编码。'
- en: The **bottom-up approach** works in the opposite direction. Given domain knowledge,
    you can start creating building blocks, and then create more complex ones by composing
    from these building blocks.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '**自底向上的方法**是相反的方向。给定领域知识，你可以开始创建构建块，然后通过组合这些构建块创建更复杂的构建块。'
- en: Regardless of how it is done, eventually there will be a set of components that
    work with each other, thereby forming the basis of the application.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 无论采用何种方式，最终都会有一组相互协作的组件，从而形成应用程序的基础。
- en: 'I like the metaphor. Even a 5-year old child can build a variety of structures
    using just several kinds of Lego block. Imagination is the limit. Do you ever
    wonder why it is so powerful? Well, if you recall, every Lego block has a standard
    set of connectors: one, two, four, six, eight, or more. Using these connectors,
    each block can plug into another block easily. When you create a new structure,
    you can combine it with other structures to create even larger, more complex structures.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢这个比喻。即使是5岁的孩子也能仅用几种乐高积木块搭建出各种结构。想象力是无限的。你是否曾想过为什么它如此强大？好吧，如果你还记得，每个乐高积木块都有一个标准的连接器集合：一个、两个、四个、六个、八个或更多。使用这些连接器，每个积木块可以轻松地插入另一个积木块。当你创建一个新的结构时，你可以将其与其他结构结合，以创建更大、更复杂的结构。
- en: When building applications, the key design principle is to create pluggable
    interfaces so every component can be reused easily.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建应用程序时，关键的设计原则是创建可插拔的接口，以便每个组件都可以轻松重用。
- en: Characteristics of reusable components
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可重用组件的特征
- en: 'The following are important characteristics of reusable components:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是可以重用组件的重要特征：
- en: Each component serves a single purpose (the S in SOLID).
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个组件只服务于单一目的（SOLID中的S）。
- en: Each component is well defined and ready for reuse (the O in SOLID).
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个组件都定义良好，并准备好重用（SOLID中的O）。
- en: An abstract type hierarchy is designed for parent-child relationships (the L
    in SOLID).
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为父-子关系设计了抽象类型层次结构（SOLID中的L）。
- en: Interfaces are defined as a small set of functions (the I in SOLID).
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口被定义为一个小集合的函数（SOLID中的I）。
- en: Interfaces are used to bridge between components (the D in SOLID).
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用接口在组件之间建立桥梁（SOLID中的D）。
- en: Modules and functions are designed with simplicity in mind (KISS).
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块和函数的设计考虑了简洁性（KISS原则）。
- en: Reusability is important because it means we can avoid duplicated code and wasted
    effort. The less code we write, the less work we need to do to maintain software.
    That includes not just the development effort but also the time testing, packaging,
    and upgrading. Reusability is also one of the reasons why open source software
    is so successful. In particular, the Julia ecosystem contains many open source
    packages and they tend to borrow functionalities from each other.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 可重用性很重要，因为它意味着我们可以避免代码重复和浪费精力。我们编写的代码越少，维护软件所需的工作就越少。这包括开发工作，也包括测试、打包和升级的时间。可重用性也是开源软件之所以成功的原因之一。特别是，Julia生态系统包含许多开源包，它们往往相互借用功能。
- en: Next, we will discuss another software quality objective—performance.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论另一个软件质量目标——性能。
- en: Performance
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能
- en: The Julia language is designed for high-performance computing. It does not come
    for free, however. When it comes to performance, it takes practice to write code
    that is more compiler-friendly, thus making it more likely to translate the program
    into optimized machine code.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Julia语言是为高性能计算设计的。然而，这并非免费。在性能方面，编写更符合编译器友好的代码需要实践，这使得程序更可能被转换为优化的机器代码。
- en: For the past few decades, computers have seemed to become faster and faster
    every year. What used to be performance bottlenecks are more easily solved using
    today's hardware. At the same time, we are also facing more challenges due to
    the explosion of data. A good example is the field of big data and data science.
    As the amount of data grows, we need even more computing power to handle these
    new use cases.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几十年里，计算机似乎每年都在变得越来越快。过去曾是性能瓶颈的问题，现在使用今天的硬件更容易解决。同时，我们也面临着更多挑战，因为数据的爆炸性增长。一个很好的例子是大数据和数据科学领域。随着数据量的增长，我们需要更多的计算能力来处理这些新的用例。
- en: 'Unfortunately, the speed of computers has not grown as rapidly as it did in
    the past. Moore''s Law states that the number of transistors on a microchip doubles
    roughly every 18 months, and since 1960 it has been correlated with the growth
    in CPU speed. However, it is well known that Moore''s Law will no longer be applicable
    soon due to a physical limitation: the number of transistors that can be fitted
    to a chip and the precision of the fabrication process.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，计算机的速度增长并没有像过去那样快。摩尔定律指出，芯片上晶体管的数量大约每18个月翻一番，自1960年以来，它与CPU速度的增长相关。然而，众所周知，由于物理限制，摩尔定律很快将不再适用：芯片上可以容纳的晶体管数量和制造过程的精度。
- en: In order to address today's computational needs, especially in the world of
    artificial intelligence, machine learning, and data science, practitioners have
    been gearing toward a *scale-out* strategy that utilizes multiple CPU cores across
    many servers, and looking at exploiting the efficiency of GPUs and TPUs.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 为了应对今天的计算需求，特别是在人工智能、机器学习和数据科学的世界中，从业者一直在转向一种利用多台服务器上多个CPU核心的 *扩展* 策略，并研究利用GPU和TPU的效率。
- en: Characteristics of high-performance code
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高性能代码的特性
- en: 'The following are characteristics of high-performance code:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些高性能代码的特性：
- en: Functions are small and can be optimized easily (S in SOLID).
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数较小，易于优化（SOLID 中的 S）。
- en: Functions contains simple logic rather than complex logic (KISS).
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数包含简单的逻辑而不是复杂的逻辑（KISS）。
- en: Numeric data is laid out in contiguous memory space so the compiler can fully
    utilize CPU hardware.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字数据被布局在连续的内存空间中，以便编译器可以充分利用CPU硬件。
- en: Memory allocation should be kept to a minimum to avoid excessive garbage collection.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应将内存分配保持在最低限度，以避免过多的垃圾回收。
- en: Performance is an important aspect of any software project. It is particularly
    important for data science, machine learning, and scientific computing use cases.
    A small design change can make a big difference—depending on the situation, it
    could possibly turn a 24-hour process into a 30-minute process. It could also
    give users real-time experience when using a web application rather than a please
    wait... dialog.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 性能是任何软件项目的重要方面。对于数据科学、机器学习和科学计算用例来说，尤其重要。一个小设计变更可能会带来很大的差异——根据情况，它可能将24小时的过程缩短到30分钟，也可能在使用Web应用时为用户提供实时体验，而不是请等待...
    对话框。
- en: Next, we will discuss software maintainability as another software quality objective.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论软件的可维护性作为另一个软件质量目标。
- en: Maintainability
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可维护性
- en: Software can be maintained more easily when it is designed properly. Generally
    speaking, if you are able to effectively use the design principles listed previously
    (SOLID, KISS, DRY, POLA, YAGNI, and POLP), then your application is more likely
    to be well architected and designed for long-term maintenance.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当软件设计得当，维护起来会更加容易。一般来说，如果你能够有效地使用之前列出的设计原则（SOLID、KISS、DRY、POLA、YAGNI 和 POLP），那么你的应用程序更有可能具有良好的架构和长期维护的设计。
- en: Maintainability is an important ingredient for large-scale applications. A research
    project from graduate school may not last long. On the contrary, an enterprise
    application may last for decades. Recently, I heard from a colleague that COBOL
    is still in use and COBOL programmers are still making a good living.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 可维护性是大型应用程序的重要成分。一个研究生项目可能不会持续很长时间。相反，一个企业应用程序可能持续数十年。最近，我从一个同事那里听说COBOL仍在使用，COBOL程序员仍然能过上好日子。
- en: We often hear about technical debt. Similar to monetary debt in real life, technical
    debt is something that you must pay for whenever code is changed. And the longer
    the technical debt stays in place, the more effort you have to spend.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常听到技术债务。与现实生活中货币债务类似，技术债务是每次代码更改时你必须支付的东西。而且，技术债务存在的时间越长，你付出的努力就越多。
- en: To understand why, consider a module that is bloated with duplicate code or
    unnecessary dependencies. Whenever a new functionality is added, you have to update
    multiple parts of the source code, and you have to perform regression testing
    for a larger area of the system. So, you end up paying (in terms of programming
    time and effort) for the debt every time the code is changed until the debt is
    fully repaid (that is, until the code is fully refactored).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解为什么，考虑一个充斥着重复代码或不必要的依赖的模块。每当添加新功能时，你必须更新源代码的多个部分，并且需要对系统更大的区域进行回归测试。因此，每次代码更改时，你都要为债务付出（从编程时间和努力的角度来看）直到债务完全偿还（即，直到代码完全重构）。
- en: Characteristics of maintainable code
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可维护代码的特性
- en: 'The following are characteristics of maintainable code:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些可维护代码的特性：
- en: No unused code (YAGNI).
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不使用未使用的代码（YAGNI）。
- en: No duplicate code (DRY).
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不重复代码（DRY）。
- en: Code is concise and short (KISS).
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码简洁简短（KISS）。
- en: Code is clear and easy to understand (KISS).
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码清晰易懂（KISS）。
- en: Every function has a single purpose (the S in SOLID).
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个函数都有一个单一的目的（SOLID 中的 S）。
- en: Every module contains functions that relate to and work with each other (the
    S in SOLID).
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个模块都包含相互关联并协同工作的函数（SOLID 中的 S）。
- en: Maintainability is an important aspect of any application. When designed properly,
    even large applications can be changed frequently and easily without fear. Applications
    can also last a long time, reducing the cost of the software.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 可维护性是任何应用程序的重要方面。当设计得当，即使是大型应用程序也可以频繁且容易地更改，而不必担心。应用程序也可以长时间运行，从而降低软件的成本。
- en: Next, we will discuss software safety as another quality objective.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论软件安全性作为另一个质量目标。
- en: Safety
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全性
- en: '"Safety—the condition of being safe from undergoing or causing hurt, injury,
    or loss."'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: “安全性——指免受伤害、受伤或损失的状态。”
- en: – Merriam-Webster Dictionary
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: – 梅里厄姆-韦伯斯特词典
- en: Applications are expected to function correctly. When an application malfunctions,
    there could be undesired consequences and some of those could be fatal. Consider
    a mission-critical rocket-launch subsystem used by NASA. A single defect could
    cause the launch to be delayed; or, in the worst-case scenario, it could cause
    the rocket to explode in mid-air.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 预期应用程序能够正确运行。当应用程序出现故障时，可能会产生不希望的结果，其中一些可能是致命的。考虑一下美国宇航局使用的至关重要的火箭发射子系统。一个缺陷可能导致发射延迟；或者，在最坏的情况下，它可能导致火箭在空中爆炸。
- en: Programming languages are designed to allow flexibility but at the same time
    provide safety features so software engineers can make fewer mistakes. For example,
    the compiler's static type checking ensures that the correct types are passed
    to functions that expect those types. In addition, most computer programs operate
    on data, and as we know, data is not always clean or available. Hence, the ability
    to handle bad or missing data is an important software quality.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 编程语言被设计为允许灵活性，同时提供安全特性，以便软件工程师犯更少的错误。例如，编译器的静态类型检查确保将正确的类型传递给期望这些类型的函数。此外，大多数计算机程序在数据上操作，正如我们所知，数据并不总是干净或可用的。因此，处理不良或缺失数据的能力是重要的软件质量。
- en: Characteristics of safe applications
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全应用程序的特征
- en: 'Some characteristics of safe applications follow:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 安全应用程序的一些特征如下：
- en: Each module exposes a minimum set of types, functions, and variables.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个模块都公开一组最小的类型、函数和变量。
- en: Each function is called with arguments such that the respective types implement
    the expected behavior of the function (the L in SOLID; POLA).
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个函数都使用参数调用，使得相应的类型实现函数的预期行为（SOLID中的L；POLA）。
- en: The return value of a function is clear and documented (POLA).
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数的返回值清晰并已记录（POLA）。
- en: Missing data is handled properly (POLA).
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正确处理缺失数据（POLA）。
- en: Variables are limited to the smallest scope.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量限制在最小的范围内。
- en: Exceptions are caught and handled accordingly.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常被捕获并相应处理。
- en: Safety is one of the most important objectives here. An erroneous application
    can cause major disasters. It can even cost a company millions of dollars. In
    2010, Toyota recalled over 400,000 of its Prius hybrid cars due to a software
    defect with the **Anti-lock Braking System** (**ABS**). In 1996, the Ariane 5
    rocket launched by the European Space Agency exploded just 40 seconds after launch.
    Of course, these are only a few more extreme examples. By utilizing best practices,
    we can avoid getting into these kinds of embarrassing and costly incidents.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 安全性在这里是最重要的目标之一。一个错误的应用程序可能造成重大灾难。它甚至可能使公司损失数百万美元。2010年，丰田因防抱死制动系统（**ABS**）的软件缺陷召回超过40万辆Prius混合动力汽车。1996年，欧洲航天局发射的阿丽亚娜5火箭在发射后40秒爆炸。当然，这些只是几个更极端的例子。通过利用最佳实践，我们可以避免陷入这类尴尬且代价高昂的事件。
- en: Now, we understand the importance of software design principles and software
    quality objectives.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们理解了软件设计原则和软件质量目标的重要性。
- en: Summary
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we started by going back in time and reviewing the history
    of design patterns. We discussed why design patterns can be useful for software
    professionals and how we would like to organize design patterns in this book given
    what we have learned in the past.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先回顾了设计模式的历史，讨论了为什么设计模式对软件专业人士有用，以及根据我们过去学到的知识，我们如何希望组织本书中的设计模式。
- en: We went over several key software design principles that can be applied universally
    in any programming language, as it is important that we keep them in mind when
    developing code and applying design patterns in Julia. We covered SOLID, DRY,
    KISS, POLA, YAGNI, and POLP. These design principles are well known and well received
    by the object-oriented programming community.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们回顾了几个可以在任何编程语言中普遍应用的软件设计原则，这在开发代码和应用Julia的设计模式时非常重要。我们涵盖了SOLID、DRY、KISS、POLA、YAGNI和POLP。这些设计原则在面向对象编程社区中广为人知，并且受到好评。
- en: Finally, we discussed some software quality objectives that we want to achieve
    by using design patterns. In this book, we have decided to focus on reusability,
    maintainability, performance, and safety objectives. We also appreciated the benefits
    of these objectives and reviewed some general guidelines for achieving these objectives.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们讨论了一些我们希望通过使用设计模式来实现的软件质量目标。在这本书中，我们决定专注于可重用性、可维护性、性能和安全目标。我们还欣赏了这些目标的好处，并回顾了一些实现这些目标的一般性指南。
- en: The next chapter is going to be exciting! We will get our hands dirty and look
    into how Julia programs are organized and how to use Julia's type system, along
    with some basics about Julia.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将会非常精彩！我们将深入探讨Julia程序的组织方式以及如何使用Julia的类型系统，同时还会介绍一些关于Julia的基础知识。
- en: Questions
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Review the following questions to reinforce your understanding of the subjects
    in this chapter. Answers are provided at the back of the book:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾以下问题，以加强你对本章主题的理解。答案在书的后面提供：
- en: What are the benefits of using design patterns?
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用设计模式有哪些好处？
- en: Name some key design principles.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列举一些关键的设计原则。
- en: What problem does the Open/Closed Principle solve?
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开放/封闭原则解决了什么问题？
- en: Why is interface segregation important for software reusability?
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么接口隔离对于软件的可重用性很重要？
- en: What are the simplest ways to keep an application maintainable?
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保持应用程序可维护性的最简单方法是什么？
- en: What is a good practice for avoiding over-engineered and bloated software?
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 避免过度设计和臃肿软件的好习惯是什么？
- en: How does memory usage affect system performance?
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 内存使用如何影响系统性能？
