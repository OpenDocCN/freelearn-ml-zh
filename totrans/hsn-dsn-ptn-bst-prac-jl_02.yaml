- en: Design Patterns and Related Principles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nowadays, learning and applying design patterns is an important aspect of software
    engineering. Design patterns are like water – you can't live without them. Don't
    believe me? Just ask hiring managers, and you will find that many of them have
    design patterns in their job postings as well as related questions in job interviews.
    It is a common belief that design patterns are important ingredients for software
    development and everyone should know them.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will provide some context about why design patterns are
    useful and how they have served us well in the past few decades. By understanding
    the motivation behind design patterns, we will be able to set forth a set of guiding
    principles for developing software. The following topics will be discussed in
    this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The history of design patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Software design principles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Software quality objectives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: The history of design patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Design patterns is not a new concept to computer programmers. Since personal
    computers became more affordable and popular in the 1980s, the programming profession
    flourished and a lot of code was written for a variety of applications.
  prefs: []
  type: TYPE_NORMAL
- en: I remember that, when I was 14 years old, learning the GOTO statement for a
    BASIC program was one of the coolest things. It literally allowed me to take a
    control flow to a different part of the code at any time. Perhaps not too surprisingly,
    when I learned about structured programming and the Pascal language in college,
    I started to realize how GOTO statements produce messy spaghetti code. Using GOTO
    for branching purposes is a pattern. It's just a bad one because it makes code
    difficult to understand, follow, and debug. In today's *lingua franca,* we call
    them anti-patterns. When it comes to structured programming techniques, organizing
    code in small functions is a pattern as well, one that has been taught as a mainstream
    subject in programming courses.
  prefs: []
  type: TYPE_NORMAL
- en: When I graduated from college, I started my programming career and spent plenty
    of time *hacking away*. I had the opportunity to do various kinds of research
    and find out how systems are designed. For example, I realized that the Unix operating
    system has a beautiful design. That is because it consists of many small programs,
    which individually do not have a ton of functionality, but you can compose them
    in any number of ways to solve more complex problems. I was also fond of the Scheme
    programming language, which came out of MIT's AI Lab. The simplicity and versatility
    of the language still amazes me today. Scheme's heritage can be traced to Lisp,
    which had some influence on how the Julia language was designed.
  prefs: []
  type: TYPE_NORMAL
- en: The rise of design patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In 1994, while I was diving deep into C++ and distributed computing for a financial
    application, four software professionals, also known as the Gang of Four or GoF,
    came together and published a book about design patterns, and it took the object-oriented
    programming community by storm. The group collected and classified 23 design patterns
    that were commonly utilized when developing large-scale systems. They also chose
    to explain the concepts using **Unified Modeling Language** (**UML**) and C++
    and Smalltalk.
  prefs: []
  type: TYPE_NORMAL
- en: For the first time, a set of design patterns had been collected, organized,
    explained, and widely distributed to software developers. Perhaps one of the most
    significant decisions by the group was to organize these patterns in a highly
    structured and easily consumable format. Since then, programmers have been able
    to communicate with each other easily about how they design their software. In
    addition, they can visually present software design with a universal notation.
    When one person talks about the Singleton pattern, another person can immediately
    understand and even visualize in his/her mind how that component works. Isn't
    that convenient?
  prefs: []
  type: TYPE_NORMAL
- en: Even more surprisingly, design patterns suddenly became the gospel when it come
    to building good software. In some ways, using them was even perceived as the
    only way to write good software. GoF patterns were so widely preached across the
    development community that many people abused them and used them everywhere without
    good reason. The problem is – *When all you have is a hammer, everything looks
    like a nail! *Not everything can be solved or should be solved by the same patterns.
    When design patterns are overused or misused, the code becomes more abstract,
    more complicated, and more difficult to manage.
  prefs: []
  type: TYPE_NORMAL
- en: So, what have we learned from the past? We recognize that every abstraction
    comes with a cost. Every design pattern comes with its own pros and cons. One
    of the main objectives of this book is to discuss not just the how but also the
    why and why not, and under what circumstances a pattern should be used or not
    used. We, as software professionals, will then be equipped with the information
    we need to make good judgment calls about when to apply these patterns.
  prefs: []
  type: TYPE_NORMAL
- en: More thoughts about GoF patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'GoF design patterns are classified into three main categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Creational patterns**: These cover how to construct objects in various ways.
    Since object-oriented programming brings together data and behavior, and a class
    may inherit the structure and behavior of an ancestor class, there are some complexities
    involved when building a large application. Creational patterns help standardize
    object creation methods in various situations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Structural patterns**: These cover how objects can be extended or composed
    to make bigger thing. The purpose of these patterns is to allow software components
    to be reused or replaced more easily.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Behavioral patterns**: This cover how objects can be designed to perform
    separate tasks and communicate with each other. A large application can be decomposed
    into independent components and the code becomes easier to maintain. The object-oriented
    programming paradigm requires solid interaction between objects. The purpose of
    these patterns is to make software components more flexible and more convenient
    for collaboration with each other.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One school of thought is that design patterns are created to address limitations
    in their respective programming language. Two years after the GoF book was published,
    Peter Norvig published research showing that 16 of the 23 design patterns are
    either unnecessary or can be simplified in a dynamic programming language such
    as Lisp.
  prefs: []
  type: TYPE_NORMAL
- en: '*This is not an unimportant observation*. In the context of object-oriented
    programming, additional abstraction from a class hierarchy requires the software
    designer to think about how objects are instantiated and interact with each other.
    In a strong, statically typed language such as Java, it is even more necessary
    to reason about the behavior and interaction of objects. In [Chapter 11](9984b03e-c2c1-4b65-8f07-6240804db32d.xhtml),
    *Traditional Object-Oriented Patterns*, we will circle back to this topic and
    discuss how Julia works differently compared to object-oriented programming.'
  prefs: []
  type: TYPE_NORMAL
- en: For now, we will start with the basics and review some software design principles.
    These principles are like the North star, guiding us as we build applications.
  prefs: []
  type: TYPE_NORMAL
- en: How do we describe patterns in this book?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are new to Julia programming, this book will help you understand how
    to write more idiomatic Julia code. We will also focus on describing some of the
    most useful patterns that are already used in the existing open source Julia ecosystem.
    That includes Julia's own Base and `stdlib` packages as the Julia runtime is largely
    written in Julia itself. We will also reference other packages that are used for
    numerical computing and web programming.
  prefs: []
  type: TYPE_NORMAL
- en: For ease of reference, we will organize our patterns by name. For example, the
    Holy Traits pattern refers to a specific method for implementing traits. The Domain-Specific
    Language pattern talks about how to build new syntax to represent specific domain
    concepts. The sole purpose of having a name is just ease of reference.
  prefs: []
  type: TYPE_NORMAL
- en: When we discuss these design patterns in this book, we will try to understand
    the motivation behind them. What specific problem are we trying to solve? What
    would be a real-world situation where such a pattern would be useful? Then, we
    will get into the details of how to solve these problems. Sometimes, there may
    be several ways to solve the same problem, in which case we will look into each
    possible solution and discuss the pros and cons.
  prefs: []
  type: TYPE_NORMAL
- en: Having said that, it is important for us to understand the ultimate goal of
    using design patterns. Why do we want to use design patterns in the first place?
    To answer this question, it would be useful for us to first understand some key
    software design principles.
  prefs: []
  type: TYPE_NORMAL
- en: Software design principles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While this book does not cover object-oriented programming, some object-oriented
    design principles are universal and could be applied to any programming language
    and paradigm. Here, we will take a look at some of the most well-known design
    principles. In particular, we will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**SOLID**: Single Responsibility, Open/Closed, Liskov Substitution, Interface
    Segregation, Dependency Inversion'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DRY**: Don''t Repeat Yourself'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**KISS**: Keep It Simple, Stupid!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**POLA**: Principle of Least Astonishment'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**YAGNI**: You Aren''t Gonna Need It'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**POLP**: Principle of Least Privilege'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start with SOLID.
  prefs: []
  type: TYPE_NORMAL
- en: SOLID
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The SOLID principle consists of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**S**: Single Responsibility Principle'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**O**: Open/Closed Principle'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**L**: Liskov Substitution Principle'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**I**: Interface Segregation Principle'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**D**: Dependency Inversion Principle'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's understand each concept in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Single Responsibility Principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Single Responsibility Principle states that every module, class, and function
    should be responsible for a single functional objective. There should be only
    one reason to make any changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The benefits of this principle are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: The programmer can focus on a single context during development.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The size of each component is smaller.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code is easier to understand.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code can be tested more easily.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open/Closed Principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Open/Closed Principle states that every module should be open for extension
    but closed for modification. It is necessary to distinguish between enhancement
    and extension—enhancement refers to a core improvement of the existing module,
    while an extension is considered an add-on that provides additional functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the benefits of this principle:'
  prefs: []
  type: TYPE_NORMAL
- en: Existing components can be easily reused to derive new functionalities.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Components are loosely coupled so it is easier to replace them without affecting
    the existing functionality.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Liskov Substitution Principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Liskov Substitution Principle states that a program that accepts type *T*
    can also accept type *S* (which is a subtype of *T*), without any change in behavior
    or intended outcome.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the benefits of this principle:'
  prefs: []
  type: TYPE_NORMAL
- en: A function can be reused for any subtype passed in the arguments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interface Segregation Principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Interface Segregation Principle states that a client should not be forced
    to implement interfaces that it does not need to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the benefits of this principle:'
  prefs: []
  type: TYPE_NORMAL
- en: Software components are more modular and reusable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New implementations can be created more easily.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependency Inversion Principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Dependency Inversion Principle states that high-level classes should not
    depend on low-level classes; instead, high-level classes should depend on an abstraction
    that low-level classes implement.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the benefits of this principle:'
  prefs: []
  type: TYPE_NORMAL
- en: Components are more decoupled.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The system becomes more flexible and can adapt to changes more easily. Low-level
    components can be replaced without affecting high-level components.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DRY
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll now cover the DRY principle:'
  prefs: []
  type: TYPE_NORMAL
- en: '**D**: Don''t'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**R**: Repeat'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Y**: Yourself'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This acronym is a good way of reminding programmers that duplicate code is bad.
    It is obvious that duplicate code can be difficult to maintain—whenever logic
    is changed, multiple places in the code are affected.
  prefs: []
  type: TYPE_NORMAL
- en: What do we do when duplicate code is found? Eliminate it and create a common
    function that is reusable from multiple source files.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, sometimes code is not 100% duplicated but instead is 90% similar.
    That is not an uncommon scenario. In that case, consider redesigning the relevant
    components, possibly refactoring code to a common interface.
  prefs: []
  type: TYPE_NORMAL
- en: KISS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s talk about the KISS principle:'
  prefs: []
  type: TYPE_NORMAL
- en: '**K**: Keep'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**I**: It'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**S**: Simple'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**S**: Stupid!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Often, when we design software, we like to think ahead and try to deal with
    all kinds of future scenarios. The trouble with building such *future-proof *software
    is that it takes exponentially more effort to design and code properly. Practically
    speaking, it's a conundrum—there is no 100% future-proof solution because technology
    changes, business changes, and people change. Also, over-engineering could lead
    to excessive abstraction and indirection, making a system more difficult to test
    and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, when using Agile software development methods, we value faster
    and high-quality delivery over perfection or excess engineering. Keeping the design
    and code simple is a virtue that every programmer should keep in mind.
  prefs: []
  type: TYPE_NORMAL
- en: POLA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look at the POLA principle:'
  prefs: []
  type: TYPE_NORMAL
- en: '**P**: Principle'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**O**: Of'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**L**: Least'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A**: Astonishment'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: POLA states that a software component should be easy to understand and its behavior
    should never be a surprise (or, more accurately, *astonishing*) to the client.
    How do we do that?
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are some things to keep in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure that the names of the module, function, or function arguments are
    clear and unambiguous.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensure that modules are right-sized and well maintained.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensure that interfaces are small and easy to understand.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensure that functions have few positional arguments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: YAGNI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s move on to the YAGNI principle:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Y**: You'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A**: Aren''t'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**G**: Gonna'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**N**: Need'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**I**: It'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'YAGNI says you should only develop software that is needed today. This principle
    came from **Extreme Programming** (**XP**). See what Ron Jeffries, co-founder
    of XP, wrote in his blog:'
  prefs: []
  type: TYPE_NORMAL
- en: '"Always implement things when you actually need them, never when you just foresee
    that you need them."'
  prefs: []
  type: TYPE_NORMAL
- en: 'Software engineers are sometimes tempted to develop functionality that they
    feel the customer will need in the future. It''s been proven time and time again
    that this is not the most effective way to develop software. Consider the following
    scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: The functionality is never needed by the customer and so the code is never used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The business environment changes and the system has to be redesigned or replaced.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The technology changes and the system has to be upgraded to use a new library,
    a new framework, or a new language.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The cheapest software is the one that you didn't write. *You aren't gonna need
    it!*
  prefs: []
  type: TYPE_NORMAL
- en: POLP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, for POLP:'
  prefs: []
  type: TYPE_NORMAL
- en: '**P**: Principle'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**O**: Of'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**L**: Least'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**P**: Privilege'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: POLP states that a client must be given access only to the information or functions
    that they need. POLP is one of the most important pillars for building secure
    applications, and it is widely adopted by cloud infrastructure vendors such as
    Amazon, Microsoft, and Google.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are quite a few benefits when POLP is applied:'
  prefs: []
  type: TYPE_NORMAL
- en: Sensitive data is protected and not exposed to non-privileged users.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The system can be tested more easily since the number of use cases is limited.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The system becomes less prone to misuse because only limited access is given
    and the interface is simpler.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The software design principles that we have learned about so far are great tools.
    Although SOLID, DRY, KISS, POLA, YAGNI, and POLP seem to be just a bunch of acronyms,
    they are useful in designing better software. While SOLID principles came from
    the object-oriented programming paradigm, SOLID's concepts can still be applied
    to other languages and environments. As we work through the rest of the chapters
    in this book, I would encourage you to keep them in mind.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will go over several software quality objectives when
    designing software.
  prefs: []
  type: TYPE_NORMAL
- en: Software quality objectives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Everyone likes beautiful design. I do, too. But, the use of design patterns
    is not just to make something look good. Everything we do should have a purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 'The GoF classified object-oriented design patterns as creational, structural,
    and behavioral. For Julia, let''s take a different perspective and classify our
    patterns by their respective software quality objectives as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Reusability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maintenance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Safety
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's understand each of these in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Reusability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: People often talk about top-down and bottom-up approaches when designing software.
  prefs: []
  type: TYPE_NORMAL
- en: The **top-down approach** starts with a large problem and breaks it down into
    a set of smaller problems. Then, if the problems are not small enough, as discussed
    when we looked at the Single Responsibility Principle, we further break down the
    problem into even smaller ones. The process repeats and eventually the problem
    is small enough to design and code.
  prefs: []
  type: TYPE_NORMAL
- en: The **bottom-up approach** works in the opposite direction. Given domain knowledge,
    you can start creating building blocks, and then create more complex ones by composing
    from these building blocks.
  prefs: []
  type: TYPE_NORMAL
- en: Regardless of how it is done, eventually there will be a set of components that
    work with each other, thereby forming the basis of the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'I like the metaphor. Even a 5-year old child can build a variety of structures
    using just several kinds of Lego block. Imagination is the limit. Do you ever
    wonder why it is so powerful? Well, if you recall, every Lego block has a standard
    set of connectors: one, two, four, six, eight, or more. Using these connectors,
    each block can plug into another block easily. When you create a new structure,
    you can combine it with other structures to create even larger, more complex structures.'
  prefs: []
  type: TYPE_NORMAL
- en: When building applications, the key design principle is to create pluggable
    interfaces so every component can be reused easily.
  prefs: []
  type: TYPE_NORMAL
- en: Characteristics of reusable components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are important characteristics of reusable components:'
  prefs: []
  type: TYPE_NORMAL
- en: Each component serves a single purpose (the S in SOLID).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each component is well defined and ready for reuse (the O in SOLID).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An abstract type hierarchy is designed for parent-child relationships (the L
    in SOLID).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interfaces are defined as a small set of functions (the I in SOLID).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interfaces are used to bridge between components (the D in SOLID).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modules and functions are designed with simplicity in mind (KISS).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reusability is important because it means we can avoid duplicated code and wasted
    effort. The less code we write, the less work we need to do to maintain software.
    That includes not just the development effort but also the time testing, packaging,
    and upgrading. Reusability is also one of the reasons why open source software
    is so successful. In particular, the Julia ecosystem contains many open source
    packages and they tend to borrow functionalities from each other.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will discuss another software quality objective—performance.
  prefs: []
  type: TYPE_NORMAL
- en: Performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Julia language is designed for high-performance computing. It does not come
    for free, however. When it comes to performance, it takes practice to write code
    that is more compiler-friendly, thus making it more likely to translate the program
    into optimized machine code.
  prefs: []
  type: TYPE_NORMAL
- en: For the past few decades, computers have seemed to become faster and faster
    every year. What used to be performance bottlenecks are more easily solved using
    today's hardware. At the same time, we are also facing more challenges due to
    the explosion of data. A good example is the field of big data and data science.
    As the amount of data grows, we need even more computing power to handle these
    new use cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, the speed of computers has not grown as rapidly as it did in
    the past. Moore''s Law states that the number of transistors on a microchip doubles
    roughly every 18 months, and since 1960 it has been correlated with the growth
    in CPU speed. However, it is well known that Moore''s Law will no longer be applicable
    soon due to a physical limitation: the number of transistors that can be fitted
    to a chip and the precision of the fabrication process.'
  prefs: []
  type: TYPE_NORMAL
- en: In order to address today's computational needs, especially in the world of
    artificial intelligence, machine learning, and data science, practitioners have
    been gearing toward a *scale-out* strategy that utilizes multiple CPU cores across
    many servers, and looking at exploiting the efficiency of GPUs and TPUs.
  prefs: []
  type: TYPE_NORMAL
- en: Characteristics of high-performance code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are characteristics of high-performance code:'
  prefs: []
  type: TYPE_NORMAL
- en: Functions are small and can be optimized easily (S in SOLID).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions contains simple logic rather than complex logic (KISS).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Numeric data is laid out in contiguous memory space so the compiler can fully
    utilize CPU hardware.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory allocation should be kept to a minimum to avoid excessive garbage collection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance is an important aspect of any software project. It is particularly
    important for data science, machine learning, and scientific computing use cases.
    A small design change can make a big difference—depending on the situation, it
    could possibly turn a 24-hour process into a 30-minute process. It could also
    give users real-time experience when using a web application rather than a please
    wait... dialog.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will discuss software maintainability as another software quality objective.
  prefs: []
  type: TYPE_NORMAL
- en: Maintainability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Software can be maintained more easily when it is designed properly. Generally
    speaking, if you are able to effectively use the design principles listed previously
    (SOLID, KISS, DRY, POLA, YAGNI, and POLP), then your application is more likely
    to be well architected and designed for long-term maintenance.
  prefs: []
  type: TYPE_NORMAL
- en: Maintainability is an important ingredient for large-scale applications. A research
    project from graduate school may not last long. On the contrary, an enterprise
    application may last for decades. Recently, I heard from a colleague that COBOL
    is still in use and COBOL programmers are still making a good living.
  prefs: []
  type: TYPE_NORMAL
- en: We often hear about technical debt. Similar to monetary debt in real life, technical
    debt is something that you must pay for whenever code is changed. And the longer
    the technical debt stays in place, the more effort you have to spend.
  prefs: []
  type: TYPE_NORMAL
- en: To understand why, consider a module that is bloated with duplicate code or
    unnecessary dependencies. Whenever a new functionality is added, you have to update
    multiple parts of the source code, and you have to perform regression testing
    for a larger area of the system. So, you end up paying (in terms of programming
    time and effort) for the debt every time the code is changed until the debt is
    fully repaid (that is, until the code is fully refactored).
  prefs: []
  type: TYPE_NORMAL
- en: Characteristics of maintainable code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are characteristics of maintainable code:'
  prefs: []
  type: TYPE_NORMAL
- en: No unused code (YAGNI).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No duplicate code (DRY).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code is concise and short (KISS).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code is clear and easy to understand (KISS).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every function has a single purpose (the S in SOLID).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every module contains functions that relate to and work with each other (the
    S in SOLID).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maintainability is an important aspect of any application. When designed properly,
    even large applications can be changed frequently and easily without fear. Applications
    can also last a long time, reducing the cost of the software.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will discuss software safety as another quality objective.
  prefs: []
  type: TYPE_NORMAL
- en: Safety
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"Safety—the condition of being safe from undergoing or causing hurt, injury,
    or loss."'
  prefs: []
  type: TYPE_NORMAL
- en: – Merriam-Webster Dictionary
  prefs: []
  type: TYPE_NORMAL
- en: Applications are expected to function correctly. When an application malfunctions,
    there could be undesired consequences and some of those could be fatal. Consider
    a mission-critical rocket-launch subsystem used by NASA. A single defect could
    cause the launch to be delayed; or, in the worst-case scenario, it could cause
    the rocket to explode in mid-air.
  prefs: []
  type: TYPE_NORMAL
- en: Programming languages are designed to allow flexibility but at the same time
    provide safety features so software engineers can make fewer mistakes. For example,
    the compiler's static type checking ensures that the correct types are passed
    to functions that expect those types. In addition, most computer programs operate
    on data, and as we know, data is not always clean or available. Hence, the ability
    to handle bad or missing data is an important software quality.
  prefs: []
  type: TYPE_NORMAL
- en: Characteristics of safe applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Some characteristics of safe applications follow:'
  prefs: []
  type: TYPE_NORMAL
- en: Each module exposes a minimum set of types, functions, and variables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each function is called with arguments such that the respective types implement
    the expected behavior of the function (the L in SOLID; POLA).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The return value of a function is clear and documented (POLA).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Missing data is handled properly (POLA).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variables are limited to the smallest scope.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exceptions are caught and handled accordingly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Safety is one of the most important objectives here. An erroneous application
    can cause major disasters. It can even cost a company millions of dollars. In
    2010, Toyota recalled over 400,000 of its Prius hybrid cars due to a software
    defect with the **Anti-lock Braking System** (**ABS**). In 1996, the Ariane 5
    rocket launched by the European Space Agency exploded just 40 seconds after launch.
    Of course, these are only a few more extreme examples. By utilizing best practices,
    we can avoid getting into these kinds of embarrassing and costly incidents.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we understand the importance of software design principles and software
    quality objectives.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we started by going back in time and reviewing the history
    of design patterns. We discussed why design patterns can be useful for software
    professionals and how we would like to organize design patterns in this book given
    what we have learned in the past.
  prefs: []
  type: TYPE_NORMAL
- en: We went over several key software design principles that can be applied universally
    in any programming language, as it is important that we keep them in mind when
    developing code and applying design patterns in Julia. We covered SOLID, DRY,
    KISS, POLA, YAGNI, and POLP. These design principles are well known and well received
    by the object-oriented programming community.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we discussed some software quality objectives that we want to achieve
    by using design patterns. In this book, we have decided to focus on reusability,
    maintainability, performance, and safety objectives. We also appreciated the benefits
    of these objectives and reviewed some general guidelines for achieving these objectives.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter is going to be exciting! We will get our hands dirty and look
    into how Julia programs are organized and how to use Julia's type system, along
    with some basics about Julia.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Review the following questions to reinforce your understanding of the subjects
    in this chapter. Answers are provided at the back of the book:'
  prefs: []
  type: TYPE_NORMAL
- en: What are the benefits of using design patterns?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name some key design principles.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What problem does the Open/Closed Principle solve?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is interface segregation important for software reusability?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the simplest ways to keep an application maintainable?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a good practice for avoiding over-engineered and bloated software?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does memory usage affect system performance?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
