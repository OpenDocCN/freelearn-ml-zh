- en: Chapter 2. R – A Powerful Tool for Developing Machine Learning Algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before using the machine learning techniques, we need to choose the proper software.
    There are many programming languages and types of software that provide the user
    with machine learning tools. In fact, the most important part is knowing which
    techniques to use and how to build new ones, and the software is just a tool.
    However, choosing the right software allows you to build faster and more accurate
    solutions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn:'
  prefs: []
  type: TYPE_NORMAL
- en: The software requirements for building a machine learning solution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How R, combined with RStudio, facilitates the development of a machine learning
    solution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The structure of R
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The tools of R
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some important R packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why R
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Understanding the challenges in developing machine learning solutions helps
    in choosing the software that allows you to face them in the easiest and most
    effective way. This chapter illustrates the software requirements and explains
    why we will use R.
  prefs: []
  type: TYPE_NORMAL
- en: An interactive approach to machine learning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Developing a machine learning solution consists of steps that have different
    requirements. In addition, the result of a step helps in improving the previous,
    so it's often necessary to come back to modify it.
  prefs: []
  type: TYPE_NORMAL
- en: Before facing a problem and building its machine learning solution, we want
    to know as much as possible about the challenge and the available resources. Effectively,
    it's very important to have all the possible information in order to define the
    right path to the solution. For this purpose, starting from the data, we extract
    business insights and patterns from the data using statistical and machine learning
    tools.
  prefs: []
  type: TYPE_NORMAL
- en: A simple example is a big supermarket that launches a new marketing campaign
    that targets some specific customers. The available data is the transactions about
    the past sales. Before building any machine learning technique, we need some basic
    information such as the total number of customers and the total sales volume in
    the previous year. After knowing the total number of customers, we want to identify
    the average customer's annual expenditure. Then, the next step can be to divide
    the customers in groups with homogeneous purchasing habits and compute the average
    customer's annual expenditure for each group.
  prefs: []
  type: TYPE_NORMAL
- en: After extracting some basic information, we have a more detailed overview of
    the problem, and there will be new questions coming out very often. Therefore,
    we need to identify new patterns and extract new insights by applying other statistical
    and machine learning models. This procedure will go on until the information allows
    us to identify the final machine learning solution.
  prefs: []
  type: TYPE_NORMAL
- en: There are often different options for a solution to a problem. In order to choose
    the most proper one, we can build some of them and compare their results. In addition,
    most of the algorithms can be tuned to improve their performance, and the tuning
    depends on the results.
  prefs: []
  type: TYPE_NORMAL
- en: In conclusion, building a machine learning solution consists of different steps
    strongly related with each other. The target of a new step is based on the analysis
    of the previous one, and sometimes, a step is modified on the basis of the following
    results. There isn't a well-defined path that goes from the start to the end,
    and the software should allow that.
  prefs: []
  type: TYPE_NORMAL
- en: '![An interactive approach to machine learning](img/7740OS_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Expectations of machine learning software
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are different options for a machine learning software, and this section
    shows what we are expecting from our choice. The software should, at the same
    time, provide the user with the machine learning tools and allow specific solutions
    to be built.
  prefs: []
  type: TYPE_NORMAL
- en: The most important machine learning techniques are provided by different types
    of software and packages. However, using cutting-edge techniques improves the
    solution. Most of the machine learning algorithms are developed by the academic
    world and used for research, so it takes time before they come into business.
    In addition, apart from a few exceptions, companies don't have enough resources
    to develop advanced techniques. Therefore, software should allow the user to access
    the tools developed in academia. In the case of free and open source software,
    there is usually an international community that provides the users with many
    packages that contain cutting-edge tools.
  prefs: []
  type: TYPE_NORMAL
- en: Another software requirement is to allow the user to develop quick and effective
    solutions. The approach to the machine learning problems requires a lot of interaction
    in the sense that the user often modifies the solution depending on the result.
    A good user-friendly graphic package is important to explore the results of each
    step and determine what to do. Therefore, the tool should allow the user to quickly
    build reusable components for data exploration, process, and visualization.
  prefs: []
  type: TYPE_NORMAL
- en: 'In conclusion, the software requirements are:'
  prefs: []
  type: TYPE_NORMAL
- en: Machine learning tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Graphic packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reusability of components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: R and RStudio
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The software that we will use is R and this subsection explains why.
  prefs: []
  type: TYPE_NORMAL
- en: '**R** is a programming language designed for data analysis and machine learning.
    It''s an interpreted language in the sense that it executes the commands directly,
    so it is more user friendly than other programming languages. Although its learning
    curve is steeper compared to some commercial software, R is easier to learn compared
    to other programming languages.'
  prefs: []
  type: TYPE_NORMAL
- en: R is the most popular programming language for statistics, and there is a huge
    international community that supports it. Its repository (CRAN) contains more
    than 5,000 packages with statistics and machine learning tools. In this way, we
    can use the most cutting-edge tools provided by its international community.
  prefs: []
  type: TYPE_NORMAL
- en: Other useful R tools are its graphic packages that allow the generation of nice
    and professional charts using just a few lines of code. In this way, it's very
    easy to explore data and results during the solution development.
  prefs: []
  type: TYPE_NORMAL
- en: Another advantage of R is **RStudio**, which is an IDE projected for R. RStudio
    includes an interactive console and tools that are used to access the R help,
    visualize/save charts, and for debugging. R, combined with RStudio, allows the
    users to develop powerful machine learning solutions relatively quickly.
  prefs: []
  type: TYPE_NORMAL
- en: The R tutorial
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I assume that you are already familiar with a programming language, although
    not necessarily R. This section contains a brief R tutorial that shows some tools
    that are useful for building machine learning solutions. Since a proper introduction
    to R would require an entire book, this tutorial focuses on just some relevant
    topics.
  prefs: []
  type: TYPE_NORMAL
- en: If you're already familiar with R, you can quickly read through this section.
    If you're new to R, I advise you to combine this section with an interactive online
    tutorial to get a more complete overview. In addition, it'll be very useful to
    play with the tools in order to acquire more familiarity.
  prefs: []
  type: TYPE_NORMAL
- en: Before starting with the tutorial, we need to install R and RStudio. Both types
    of software are open source, and they support the most relevant operating systems.
    It's also useful to read the RStudio tutorial to understand how to use this powerful
    IDE.
  prefs: []
  type: TYPE_NORMAL
- en: My advice is to generate a new R script in the RStudio environment and to copy
    and paste the code into the script. You can run the command by going to the specific
    command line and pressing *Ctrl* + *Enter*.
  prefs: []
  type: TYPE_NORMAL
- en: The basic tools of R
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The basic structure of R is very easy. Any kind of variable is stored in an
    object that can be visualized by typing its name. Let''s start defining some numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We can visualize an object by typing its name, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We can perform some basic operations on the objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of any operation can be stored in another object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The standard syntax used to add comments to the code consists of starting the
    line with a hash, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We can apply the R functions to the object and the syntax is very easy since
    the arguments are always within the parenthesis: `result <- functionName(argument1,
    argument2, …)`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, we can use `sum` to compute the sum of numeric variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, for the operators, we can store the output of a function into another
    object, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'There are also functions that print a message on the console. For instance,
    given any object, `print` displays its content in the same way, that is, by just
    typing the object name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The syntax used to define new functions is easy. For instance, we can define
    a function, `funProd`, which computes the product of its two arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `n1` and `n2` inputs are defined within the parenthesis and the operations
    are contained in the curly brackets. The `return` method terminates the function,
    giving the result as the output. We can visualize the code within any function
    just by typing its name.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to keep track of what the function is doing, we can print the variables
    while the function is executing, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example code files from your account at [http://www.packtpub.com](http://www.packtpub.com)
    for all the Packt Publishing books you have purchased. If you purchased this book
    elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are different R functions associated with documentation. We can use `help`
    to display their description, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Another option is to use `sum`, but personally, I prefer to use `help` in order
    to use the same parenthesis syntax of the other R functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to perform basic R operations, we have to store the data in the vectors
    that are objects that contain a sorted collection of values. We can define a new
    vector using `c`, which is a function that concatenates its input, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We can extract an element of the vector using square brackets. The first element
    can be extracted putting `1` inside the square brackets. Please note that R indexes
    differently from other programming languages such as Python, where the first element
    is indexed as `0` instead of `1`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We can extract more than one element at the same time by putting a vector inside
    the square brackets, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also perform some basic operations on the vectors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to define a vector that contains a sequence of integers, we can
    use this notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The vectors can contain undefined values, which are `NA` in R:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: If we perform an operation on an `NA` value, the output will be `NA`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another important data element is Boolean. Boolean variables are defined using
    `TRUE` and `FALSE`, and the basic operators are `&` or `&&` (AND), `|` or `||`
    (OR), as well as `!` (NOT). Boolean elements can be single elements or vectors.
    In the case of vectors, the shorter forms (`&` and `|`) compare each element and
    the long forms (`&&` and `||`) evaluate only the first element of each vector,
    shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We can define Boolean variables using relational operators such as `==` (equal
    to), `!=` (not equal to), `<=` (less than or equal to), `>=`, `<`, and `>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Boolean variables can be included in the `if` statements defined by `if` with
    a syntax similar to the functions. We put the condition within the parenthesis
    and the operations are within the curly brackets, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We can define `for` loops using `for` and their syntax is the same as `if`.
    The parenthesis contains the variable name and the vector with the values, and
    the curly brackets contain the operations, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to repeat an operation for a fixed number of times, we can define
    a vector that contains the first *n* integer numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This subsection showed some basic components of R. The next subsection presents
    the R objects that analyze the data.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the basic R objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are different kinds of objects, and we have seen some of them: `numeric`,
    `function`, `boolean`, and `vector`. We can easily identify the class of the objects
    used in the previous examples.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `a1` vector belongs to the `numeric` class because all its elements are
    numeric. In the same way, a vector with logical elements belongs to `logical`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Strings are defined using single or double quotes, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'There are different string functions such as `paste`, which concatenates two
    strings, and `substring`, which extracts a subset from the string, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s possible to define a `string` vector in the same way as `numeric` or
    `logical`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: A vector can include any kind of object (even functions potentially). What happens
    if we define a vector that contains strings and numbers?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding code, R converted the numbers into characters in order
    to have a homogeneous vector. However, there are other data structures that allow
    us to store heterogeneous objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we have categoric variables, we can use strings to store them, but there
    is another option: `factors`. This R object contains a variable whose value belongs
    to a defined set of values known as `levels`. Each level is associated with an
    integer and the data can be treated as integers or characters that obtain the
    same result. Factors can also help in creating ordinal variables.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting from a string, we can generate a factor using `factor`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Using levels, we can identify the possible values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Another useful function, although not necessarily related to factors, is `table`,
    and it counts the occurrences of each level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Another useful data element is `Date`, and it is one of the R options used
    to store dates. We start building a string such as `''2013-01-01''` and defining
    the position of the year, month, and day in another string, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, using `as.Date`, we can generate the date object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We can apply simple operations on dates, such as adding a definite number of
    days:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use Boolean operators to match two dates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Another data type is `list`, and it defines an ordered heterogeneous collection
    of data elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Each object can be associated with a key that allows us to access it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'In both cases, we can extract an element from a list using a double square
    bracket and the position of the element, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'In the case of `l2`, we have defined its key, so we can access its elements
    using the `$` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We can visualize all the key names using `names`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s also possible to define or change the key names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to extract a sublist from a list, we can use the single square brackets,
    similar to the vectors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'An R object that allows you to store tabular data is a `matrix`. To generate
    a new matrix, put all the values in a vector and use `matrix`, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `t`, we can transpose a matrix, which means we can switch the rows with
    the columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding code, `matrix1` and `matrix2` contain only numeric
    data. Using `cbind`, we can add another column. What happens if we add a character
    column?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: R converts numbers into characters. The reason is that the matrices, like vectors,
    can contain only homogeneous data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The matrices can have row and column names, and we can display them using `rownames`
    and `colnames`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'We defined `matrix3` by adding a column to `matrix3`. Its columns and R automatically
    set the last column name equal to the vector name, that is, `vector3`. Using the
    same functions, we can set the row and column names manually, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'We can visualize a data frame using `View`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For the data frames, refer to the scripts of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some functions that allow the same operation to be performed on each
    element of a vector, matrix, or list. The functions are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`apply`: Apply a function to each row, column, or element of a matrix'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sapply`: Apply a function to each element of a vector'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lapply`: Apply a function to each element of a list'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `sapply` function is the easiest, so we can start with it. We can define
    a vector `x1` with the integer numbers between `1` and `10`, and a function, `func1`,
    which returns the square of the input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can use `sapply` by specifying the arguments: `X`—the array, and `FUN`—the
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, we can use `lapply`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The function that performs an operation on a matrix is `apply`. It can be used
    to apply the same function to each row. Let''s first define a matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to apply the `sum` function to each row, we use `apply`, defining
    the `MARGIN` input equal to `1`, which specifies that we perform the operation
    on each row:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Defining `MARGIN = 2`, we perform the operation on each column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'We can apply the function to each element of the matrix using `MARGIN = c(1,
    2)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: This section showed some R objects and tools that are relevant to machine learning
    analysis. However, they're still just the basics.
  prefs: []
  type: TYPE_NORMAL
- en: What are the R standards?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are some style rules for having a clean and standardized code, and this
    subsection shows some of them.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike other programming languages, R doesn't require any indentation. However,
    indenting the code makes it more readable and clean. The R standard is to use
    two spaces, and RStudio automatically defines this indentation.
  prefs: []
  type: TYPE_NORMAL
- en: The standard for assigning a variable is to use the `<-` operator even if it's
    possible to use `=` to make R more similar to other programming languages. However,
    the two operators have a different meaning if used within function input.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are different options for the identifiers, and personally, I like the
    lower camel case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: However, the R community is very big and there are different conventions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each operator should be surrounded by spaces, and in a function''s input, there
    should always be a space after a comma:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: There are some other style rules, and you can find them at [https://google-styleguide.googlecode.com/svn/trunk/Rguide.xml](https://google-styleguide.googlecode.com/svn/trunk/Rguide.xml).
  prefs: []
  type: TYPE_NORMAL
- en: Some useful R packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are different R packages that provide users with general-purpose functions
    and specific techniques. This chapter introduces two powerful general purpose
    packages: `data.table` and `plyr`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Some packages are already installed in the basic version of R. However, in
    order to use `data.table` and `plyr`, we need to download them from the official
    CRAN repository using `install.packages`. Let''s start with `data.table`, which
    is a package that provides additional tools used to deal with data frames:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'If the command doesn''t work, you can specify the repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'After installing the package, we need to load it in order to use its functions.
    Unfortunately, R will import all the functions from the package without using
    a namespace, and sometimes there might be name conflicts across different packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The package contains a new class called `data.table`, which inherits from `data.frame`.
    Inheritance means that data tables can use all the data frame tools, if not overrided,
    plus others.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to use the package, the starting point is a dataset that we will analyze.
    R provides the user with some datasets, and we can see their list and description
    using `data`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The dataset that we will use is `iris`. Although it''s a very standard dataset
    for the tutorials, I decided to use it since it''s good to use to show the data
    table tools. I promise that I will choose more interesting topics in the following
    chapters. First, let''s read the data description:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The dataset contains the data about three species of iris flowers: `setosa`,
    `versicolor`, and `virginica`. The data displays the length and the width of the
    sepal and the petals of each flower.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `iris` dataset is a data frame. First, let''s convert it into a data table
    using `data.table`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The `dtIris` object belongs to the `data.table` and `data.frame` classes because
    of inheritance. Before analyzing the data, we can use `str` to quickly explore
    the structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, there are four numerical columns that show the attributes of
    the flower and one factor column that shows the species. Now, using `print`, we
    can display the data contained in `dtIris`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can see the first and last five rows. In order to see the whole table,
    we can use `View`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'After viewing the data, let''s see the basic operations. The square brackets
    allow us to perform a wide range of operations. For instance, by putting a number
    in the square brackets, we extract the related row:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'By putting a vector, we can extract more rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to extract a column, we insert the column name as the second argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of the column name, we could have used the number of the column position,
    which, is 5 in this case. We can also extract rows and columns at the same time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'What if we want to define a data table that has only the first three columns?
    We can use a similar notation, including `Species` as a string and adding `with
    = F` as the third argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also extract a data table with two or more columns of `dtIris`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'We put a vector in the first argument to select rows. Like data frames and
    matrices, we can select the rows that define a logical vector, for instance `dtIris$Sepal.Length
    > 7`. In the case of data tables, we can directly access the columns without using
    the `$` operator. Then, we just need to include `Sepal.Length > 7` as the first
    argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'To define a new column, we can use the `:=` operator in the second square bracket
    argument. We can access the other columns just by typing their name. For instance,
    we can define `Sepal.Area` as the product of `Sepal.Length * Sepal.Width`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to compute the average `Sepal.Area`, we can perform the operation
    within the second argument in the square brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'What if we want to know the average petal area for each species? The syntax
    is the same; we include `by = ''Species''` in the third argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'We compute more statistics at the same time. For instance, we can determine
    the maximum and minimum sepal area for each species. In this case, the syntax
    is similar, with the addition of `list` in the second argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Another useful package is `plyr`, and it contains some functions similar to
    `apply` and is applicable in different contexts. Let''s first install and load
    the package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'A useful function is `dlply`, and it splits a data frame into chunks, applies
    a function to each chunk, and defines a list that contains the function output.
    The types of input are given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.data`: This is the data frame.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.variables`: This is the variable that defines the split. Each chunk corresponds
    to a possible value of the variable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.fun`: This is the function to apply to each chunk.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For instance, starting from the `iris` data frame, we can compute the average
    sepal length for each species. First, we can define `funcDl` by computing the
    average sepal length:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can use `dlply` to apply `funcDl` to each species:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s explore the data that is contained in the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Each element of the list has the name of the corresponding species. Let''s
    take a look at one of the elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'The `dlply` function generates a list starting from a data frame, and in the
    name, `d` stands for data frame, and `l` stands for list. There are other `ply`
    functions and the options are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`a`: Array'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`d`: Data frame'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`l`: List'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For instance, `adply` defines a data frame starting from an array, and `laply`
    defines an array starting from a list.
  prefs: []
  type: TYPE_NORMAL
- en: This section introduced two useful packages. There are more than 5,000 packages
    in the CRAN repository, and we will see a few of them in the following chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you understood the software required to develop a machine learning
    solution. You saw why R, combined with RStudio, is a good tool to use to help
    you overcome machine learning challenges.
  prefs: []
  type: TYPE_NORMAL
- en: You learned about the basics of R and some of the most important data types
    and functions. You have also seen packages such as `data.table` and `plyr`.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter shows you a simple example of a challenge that can be faced
    using exploratory data analysis and machine learning. You will see R tools used
    to build charts and use machine learning algorithms.
  prefs: []
  type: TYPE_NORMAL
