- en: Chapter 1. Getting Started with Microsoft Cognitive Services
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章. Microsoft Cognitive Services入门
- en: You have just started on the road to learning about Microsoft Cognitive Services.
    This chapter will serve as a gentle introduction to the services that it offers.
    The end goal is to understand a bit more about what these Cognitive Services APIs
    can do for you. By the end of this chapter, we will have created an easy-to-use
    project template. You will have learned how to detect faces in images and have
    the number of faces spoken back to you.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 您刚刚开始学习关于Microsoft Cognitive Services的道路。本章将作为对其提供的服务的一个温和的介绍。最终目标是更好地了解这些认知服务API能为您做什么。到本章结束时，我们将创建一个易于使用的项目模板。您将学会如何在图像中检测人脸，并且会听到人脸数量的反馈。
- en: 'Throughout this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Applications that already use Microsoft Cognitive Services
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已经使用Microsoft Cognitive Services的应用程序
- en: Creating a template project
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建模板项目
- en: Detecting faces in images using a Face API
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Face API在图像中检测人脸
- en: Discovering what Microsoft Cognitive Services can offer
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索Microsoft Cognitive Services能提供什么
- en: Doing text-to-speech conversion using the Bing Speech API
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Bing Speech API进行文本到语音的转换
- en: Cognitive Services in action for fun and life-changing purposes
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 认知服务在实际中的应用，用于娱乐和改变生活
- en: The best way to introduce Microsoft Cognitive Services is to see how it can
    be used in action. Microsoft (as well as other companies) has created a lot of
    example applications to show off its capabilities. Several may be seen as silly,
    such as the How-Old.net ([http://how-old.net/](http://how-old.net/)) image analysis
    and the *what if I were that person* application. These applications have generated
    quite some buzz, and they show off some of the APIs in a good way.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 介绍Microsoft Cognitive Services的最佳方式是看看它如何在实际中使用。微软（以及其他公司）已经创建了许多示例应用程序来展示其功能。其中一些可能看起来很傻，比如How-Old.net
    ([http://how-old.net/](http://how-old.net/)) 图像分析和“如果我变成那个人”应用程序。这些应用程序已经引起了很多关注，并以良好的方式展示了API的一些功能。
- en: The one demonstration that is truly inspiring, though, is the one featuring
    a visually impaired person. Talking computers inspired him to create an application
    to allow blind and visually impaired people to understand what is going on around
    them. The application has been built upon Microsoft Cognitive Services. It gives
    us a good idea of how these APIs can be used to change the world, for the better.
    Before moving on, head over to [https://www.youtube.com/watch?v=R2mC-NUAmMk](https://www.youtube.com/watch?v=R2mC-NUAmMk)
    and take a peek into the world of Microsoft Cognitive Services.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 真正令人鼓舞的一个演示是关于一个视力受损的人。会说话的电脑激发了他创建一个应用程序，让盲人和视力受损的人能够理解周围发生的事情。该应用程序是基于Microsoft
    Cognitive Services构建的。它让我们很好地了解这些API如何改变世界，使之变得更好。在继续之前，请访问[https://www.youtube.com/watch?v=R2mC-NUAmMk](https://www.youtube.com/watch?v=R2mC-NUAmMk)并一窥Microsoft
    Cognitive Services的世界。
- en: Setting up the boilerplate code
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置样板代码
- en: Before we start diving into the action, we will go through some initial setup.
    More to the point, we will set up some boilerplate code that we will utilize throughout
    this book.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始深入行动之前，我们将进行一些初始设置。更具体地说，我们将设置一些样板代码，我们将在整本书中利用这些代码。
- en: To get started, you will need to install a version of Visual Studio, preferably
    Visual Studio 2015 or later. The Community Edition will work fine for this purpose.
    You do not need anything more than what the default installation offers.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，您需要安装Visual Studio的一个版本，最好是Visual Studio 2015或更高版本。社区版就足够用于这个目的了。您不需要比默认安装提供的内容更多。
- en: Note
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can find Visual Studio 2017 at [https://www.microsoft.com/en-us/download/details.aspx?id=48146](https://www.microsoft.com/en-us/download/details.aspx?id=48146).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://www.microsoft.com/en-us/download/details.aspx?id=48146](https://www.microsoft.com/en-us/download/details.aspx?id=48146)找到Visual
    Studio 2017。
- en: Throughout this book, we will utilize the different APIs to build a smart-house
    application. The application will be created to see how a futuristic house might
    appear. If you have seen the Iron Man movies, you can think of the application
    as resembling Jarvis, in some ways.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们将利用不同的API构建一个智能家居应用程序。该应用程序旨在展示未来房屋可能的样子。如果您看过《钢铁侠》电影，您可以将该应用程序想象成某种形式的Jarvis。
- en: In addition, we will be making smaller sample applications using the Cognitive
    Services APIs. Doing so will allow us to look at each API, even those that did
    not make it to the final application.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: What's common with all the applications that we will build is that they will
    be **Windows Presentation Foundation** (**WPF**) applications. This is fairly
    well known, and allows us to build applications using the **Model-View-ViewModel**
    (**MVVM**) pattern. One of the advantages of taking this road is that we will
    be able to see the API usage quite clearly. It also separates code so that you
    can bring the API logic to other applications with ease.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps describe the process of creating a new WPF project:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Open Visual Studio and select **File** | **New** | **Project**.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the dialog, select the **WPF Application** option from **Templates** | **Visual
    C#**, as shown in the following screenshot:![Setting up the boilerplate code](img/B12373_01_01.jpg)
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete the `MainWindow.xaml` file and create the files and folders that are
    shown in the following screenshot:![Setting up the boilerplate code](img/B12373_01_02.jpg)
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will not go through the MVVM pattern in detail, as this is out of the scope
    of this book. The key takeaway from the screenshot is that we have separated the
    `View` from what becomes the logic. We then rely on the `ViewModel` to connect
    the pieces.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want to learn more about MVVM, I recommend reading [http://www.codeproject.com/Articles/100175/Model-View-ViewModel-MVVM-Explained](http://www.codeproject.com/Articles/100175/Model-View-ViewModel-MVVM-Explained).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to run this, however, we do need to set up our project. Go through
    the following steps:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `App.xaml` file and make sure the `StartupUri` is set to the correct
    `View`, as shown in the following code (class name and namespace may vary based
    on the name of your application):'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Open the `MainViewModel.cs` file and make it inherit from the `ObservableObject`
    class.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the `MainView.xaml` file and add the `MainViewModel` file as `DataContext`
    to it, as shown in the following code (namespace and class names may vary based
    on the name of your application):'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Following this, we need to fill in the content of the `ObservableObject.cs`
    file. We start off by having it inherit from the `INotifyPropertyChanged` class
    as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This is a rather small class, which should contain the following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We declare a property changed event and create a function to raise the event.
    This will allow the **user interface** (**UI**) to update its values when a given
    property has changed.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to be able to execute actions when buttons are clicked. This can
    be achieved when we put some content into the `DelegateCommand.cs` file. Start
    by making the class inherit the `ICommand` class, and declare the following two
    variables:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The two variables we have created will be set in the constructor. As you will
    notice, you are not required to add the `_canExecute` parameter, and you will
    see why in a bit:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To complete the class, we add two `public` functions and one `public` event,
    as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The functions declared will return the corresponding predicate, or action, declared
    in the constructor. This will be something we declare in our `ViewModel` instances,
    which, in turn, will be something that executes an action or tells the application
    that it can or cannot execute an action. If a button is in a state where it is
    disabled (that is, when the `CanExecute` function returns `false`) and the state
    of the `CanExecute` function changes, the event that is declared will let the
    button know.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: With that in place, you should be able to compile and run the application, so
    go on and try that. You will notice that the application does not actually do
    anything or present any data yet, but we have an excellent starting point.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we do anything else with the code, we are going to export the project
    as a template using the following steps. This is so that we do not have to redo
    all these steps for each small sample project we create:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace the namespace names with substitute parameters:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In all the `.cs` files, replace the namespace name with `$safeprojectname$`
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In all the `.xaml` files, replace the project name with `$safeprojectname$`
    where applicable (typically the class name and namespace declarations)
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to **File** | **Export Template**. This will open the **Export Template**
    wizard, as shown in the following screenshot:![Setting up the boilerplate code](img/B12373_01_03.jpg)
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Project Template** button. Select the project we just created
    and click on the **Next** button.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Just leave the icon and preview image empty. Enter a recognizable name and description.
    Click on the **Finish** button:![Setting up the boilerplate code](img/B12373_01_04.jpg)
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The template is now exported to a `.zip` file and stored in the specified location.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By default, the template will be imported into Visual Studio again. We are going
    to test that it works immediately by creating a project for this chapter. So go
    ahead and create a new project, selecting the template that we just created. The
    template should be listed in the **Visual C#** section of the installed templates
    list. Call the project `Chapter1`, or something else, if you prefer. Make sure
    it compiles and that you are able to run it before we move to the next step.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Detecting faces with the Face API
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the newly created project, we will now try our first API, the Face API.
    We will not be doing a whole lot, but we will still see how simple it is to detect
    faces in images.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps we need to go through in order to do this are as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Register for a Face API preview subscription at Microsoft Azure
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the necessary **NuGet** packages to our project
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a UI to the application
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Detect faces on command
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Head over to [https://portal.azure.com](https://portal.azure.com) to start the
    process of registering for a free subscription to the Face API. You will be taken
    to a login page. Log on with your Microsoft account; if you do not have one, then
    register for one.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 转到[https://portal.azure.com](https://portal.azure.com)开始注册Face API免费订阅的过程。您将被带到登录页面。使用您的Microsoft账户登录；如果您没有，则需要注册一个。
- en: 'Once logged in, you will need to add a new resource by clicking on **+ New**
    on the right-hand menu. Search for **Face API** and select the first entry, as
    shown in the following screenshot:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 登录后，您需要通过点击右侧菜单中的**+ 新建**来添加一个新的资源。搜索**Face API**并选择第一个条目，如下截图所示：
- en: '![Detecting faces with the Face API](img/B12373_01_05.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![使用Face API检测人脸](img/B12373_01_05.jpg)'
- en: 'Enter a name and select the subscription, location, and pricing tier. At the
    time of writing, there are two pricing options, one free and one paid, as shown
    in the following screenshot:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 输入一个名称并选择订阅、位置和定价层。在撰写本文时，有两种定价选项，一个是免费的，一个是付费的，如下截图所示：
- en: '![Detecting faces with the Face API](img/B12373_01_06.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![使用Face API检测人脸](img/B12373_01_06.jpg)'
- en: 'Once created, you can go into the newly created resource. You will need one
    of the two available API keys. These can be found in the **Keys** option of the
    **Resource Management** menu, as shown in the following screenshot:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建，您就可以进入新创建的资源。您需要两个可用的API密钥之一。这些可以在**资源管理**菜单的**密钥**选项中找到，如下截图所示：
- en: '![Detecting faces with the Face API](img/B12373_01_07.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![使用Face API检测人脸](img/B12373_01_07.jpg)'
- en: Some of the APIs that we will cover have their own NuGet packages created. Whenever
    this is the case, we will utilize those packages to do the operations we want
    to perform. A common feature of all APIs is that they are REST APIs, which means
    that in practice you can use them with whichever language you want. For those
    APIs that do not have their own NuGet package, we call the APIs directly through
    HTTP.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要介绍的一些API有自己的NuGet包。每当这种情况发生时，我们将利用这些包来执行我们想要执行的操作。所有API的共同特点是它们都是REST API，这意味着在实践中，您可以使用任何语言来使用它们。对于没有自己的NuGet包的API，我们直接通过HTTP调用API。
- en: 'A NuGet package does exist for the Face API we are using now, so we need to
    add that to our project. Head over to the **NuGet Package Manager** option for
    the project we created earlier. In the **Browse** tab, search for the `Microsoft.ProjectOxford.Face`
    package and install the package from Microsoft, as shown in the following screenshot:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们现在使用的Face API，确实存在一个NuGet包，因此我们需要将其添加到我们的项目中。转到我们之前创建的项目中的**NuGet包管理器**选项。在**浏览**选项卡中，搜索`Microsoft.ProjectOxford.Face`包，并从Microsoft安装该包，如下截图所示：
- en: '![Detecting faces with the Face API](img/B12373_01_08.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![使用Face API检测人脸](img/B12373_01_08.jpg)'
- en: As you will notice, another package will also be installed. This is the `Newtonsoft.Json`
    package, which is required by the Face API.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所注意到的，另一个包也将被安装。这是Face API所需的`Newtonsoft.Json`包。
- en: The next step is to add a UI to our application. We will be adding this in the
    `MainView.xaml` file. Open this file where the template code that we created earlier
    should be. This means that we have `DataContext`, and can make bindings for our
    elements, which we will define now.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是向我们的应用程序添加UI。我们将在`MainView.xaml`文件中添加这个。这意味着我们有`DataContext`，可以为我们的元素创建绑定，我们现在将定义这些元素。
- en: 'First, we add a grid and define some rows for the grid, as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们添加一个网格并定义一些网格行，如下所示：
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Three rows are defined. The first is a row where we will have an image, the
    second is a line for the status message, and the last is where we will place some
    buttons.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了三行。第一行是我们将放置图片的行，第二行是状态消息的行，最后一行我们将放置一些按钮。
- en: 'Next, we add our `image` element, as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们添加我们的`image`元素，如下所示：
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We have given it a unique name. By setting the `Stretch` parameter to `Uniform`,
    we ensure that the image keeps its aspect ratio. Further on, we place this element
    in the first row. Last, we bind the image source to a `BitmapImage` in the `ViewModel`,
    which we will look at in a bit.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们给它起了一个独特的名字。通过将`Stretch`参数设置为`Uniform`，我们确保图片保持其宽高比。进一步地，我们将此元素放置在第一行。最后，我们将图片源绑定到`ViewModel`中的`BitmapImage`，我们稍后会看到。
- en: 'The next row will contain a text block with some status text. The `Text` property
    will be bound to a string property in the `ViewModel`, as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行将包含一个带有一些状态文本的文本块。`Text`属性将绑定到`ViewModel`中的字符串属性，如下所示：
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The last row will contain one button to browse for an image and one button
    to be able to detect faces. The `command` properties of both buttons will be bound
    to the `DelegateCommand` properties in the `ViewModel`, as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'With the `View` in place, make sure that the code compiles and runs it. This
    should present you with the following UI:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '![Detecting faces with the Face API](img/B12373_01_09.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
- en: 'The last part of the process is to create the binding properties in our `ViewModel`
    and make the buttons execute something. Open the `MainViewModel.cs` file. The
    class should already inherit from the `ObservableObject` class. First, we define
    two variables as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `string` variable will hold the path to our image, while the `IFaceServiceClient`
    variable is to interface the Face API. Next, we define two properties, as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: What we have here is a property for the `BitmapImage`, mapped to the `Image`
    element in the `View`. We also have a `string` property for the status text, mapped
    to the text block element in the `View`. As you may also notice, when either of
    the properties is set, we call the `RaisePropertyChangedEvent` event. This will
    ensure that the UI updates when either property has new values.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we define our two `DelegateCommand` objects and perform some initialization
    through the constructor, as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The properties for the commands are `public` to get, but `private` to set. This
    means that we can only set them from within the `ViewModel`. In our constructor,
    we start off by setting the status text. Next, we create an object of the Face
    API, which needs to be created with the API key we got earlier. In addition, it
    needs to specify the root URI, pointing at the location of the service. It can,
    for instance, be [https://westeurope.api.cognitive.microsoft.com/face/v1.0](https://westeurope.api.cognitive.microsoft.com/face/v1.0)
    if the service is located in west Europe.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: 'If the service is located in the west US, you would replace `westeurope` with
    `westus`. The root URI can be found in the following place in Azure Portal:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '![Detecting faces with the Face API](img/B12373_01_10.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
- en: 'At last, we create the `DelegateCommand` constructor for our command properties.
    Note how the `browse` command does not specify a predicate. This means that it
    will always be possible to click on the corresponding button. To make this compile,
    we need to create the functions specified in the `DelegateCommand` constructors:
    the `Browse`, `DetectFace`, and `CanDetectFace` functions.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: 'We start the `Browse` function by creating an `OpenFileDialog` object. This
    dialog is assigned a filter for JPEG images, and, in turn, it is opened, as shown
    in the following code. When the dialog is closed, we check the result. If the
    dialog was canceled, we simply stop further execution:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'With the dialog closed, we grab the filename of the file selected and create
    a new URI from it, as shown in the following code:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'With the newly created URI, we want to create a new `BitmapImage`. We specify
    it so that it uses no cache, and we set the URI source of the URI that we created,
    as shown in the following code:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 使用新创建的 URI，我们想要创建一个新的 `BitmapImage`。我们指定它不使用缓存，并设置我们创建的 URI 的 URI 源，如下面的代码所示：
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The last step we take is to assign the bitmap image to our `BitmapImage` property
    so that the image is shown in the UI. We also update the status text to let the
    user know that the image has been loaded, as shown in the following code:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是将位图图像分配给我们的 `BitmapImage` 属性，以便在 UI 中显示图像。我们还更新状态文本，让用户知道图像已被加载，如下面的代码所示：
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `CanDetectFace` function checks whether or not the `DetectFacesButton`
    button should be enabled. In this case, it checks whether our image property actually
    has a URI. If it does by extension, then that means that we have an image and
    we should be able to detect faces, as shown in the following code:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`CanDetectFace` 函数检查是否应该启用 `DetectFacesButton` 按钮。在这种情况下，它检查我们的图像属性是否实际上有一个
    URI。如果有，那么这意味着我们有一个图像，我们应该能够检测到人脸，如下面的代码所示：'
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Our `DetectFace` method calls an `async` method to upload and detect faces.
    The return value contains an array of the `FaceRectangles` variable. This array
    contains the rectangle area for all face positions in the given image. We will
    look into the function that we are going to call in a bit.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `DetectFace` 方法调用一个 `async` 方法来上传和检测人脸。返回值包含 `FaceRectangles` 变量的数组。这个数组包含给定图像中所有人脸位置的矩形区域。我们稍后会查看将要调用的函数。
- en: 'After the call has finished executing, we print a line containing the number
    of faces to the debug console window, as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 调用完成后，我们将打印包含人脸数量的行到调试控制台窗口，如下所示：
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the `UploadAndDetectFacesAsync` function, we create a `Stream` from the
    image, as shown in the following code. This stream will be used as input for the
    actual call to the Face API service:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `UploadAndDetectFacesAsync` 函数中，我们根据以下代码从图像创建一个 `Stream`。这个流将被用作调用 Face API
    服务的实际输入：
- en: '[PRE20]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The following line is the actual call to the detection endpoint for the Face
    API:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行是调用 Face API 检测端点的实际调用：
- en: '[PRE21]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The first parameter is the file stream that we created in the previous step.
    The rest of the parameters are all optional. The second parameter should be `true`
    if you want to get a face ID. The next parameter specifies whether you want to
    receive face landmarks or not. The last parameter takes a list of facial attributes
    that you may want to receive. In our case, we want the `age` parameter to be returned,
    so we need to specify that.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是我们之前创建的文件流。其余参数都是可选的。第二个参数应该为 `true`，如果您想获取人脸 ID。下一个参数指定您是否想接收人脸特征点。最后一个参数接受您可能想要接收的面部属性列表。在我们的例子中，我们希望返回
    `age` 参数，因此我们需要指定它。
- en: 'The return type of this function call is an array of faces, with all the parameters
    that you have specified, as shown in the following code:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数调用的返回类型是一个包含所有您指定参数的人脸数组，如下面的代码所示：
- en: '[PRE22]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The first line iterates over all faces and retrieves the approximate age of
    all faces. This is later printed to the debug console window, in the `foreach`
    loop.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行遍历所有人脸并检索所有人脸的大致年龄。这稍后将在 `foreach` 循环中打印到调试控制台窗口。
- en: The second line iterates over all faces and retrieves the face rectangle, with
    the rectangular location of all faces. This is the data that we return to the
    calling function.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行遍历所有人脸并检索人脸矩形，包括所有人脸的矩形位置。这是我们返回给调用函数的数据。
- en: Add a `catch` clause to finish the method. Where an exception is thrown in our
    API call, we catch that. We want to show the error message and return an empty
    `FaceRectangle` array.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个 `catch` 子句来完成方法。在我们的 API 调用中抛出异常时，我们捕获它。我们想显示错误消息并返回一个空的 `FaceRectangle`
    数组。
- en: 'With that code in place, you should now be able to run the full example. The
    end result will look like the following screenshot:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在放置了上述代码后，您现在应该能够运行完整的示例。最终结果将类似于以下截图：
- en: '![Detecting faces with the Face API](img/B12373_01_11.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Face API 检测人脸](img/B12373_01_11.jpg)'
- en: 'The result debug console window will print the following text:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 调试控制台窗口将打印以下文本：
- en: '[PRE23]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: An overview of different APIs
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不同 API 的概述
- en: Now that you have seen a basic example of how to detect faces, it is time to
    learn a bit about what else Cognitive Services can do for you. When using Cognitive
    Services, you have 21 different APIs to hand. These are, in turn, separated into
    five top-level domains depending on what they do. These domains are vision, speech,
    language, knowledge, and search. We will learn more about them in the following
    sections.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经看到了如何检测面部的基本示例，是时候学习一下认知服务还能为您做什么了。当使用认知服务时，您有21个不同的API可供选择。这些API根据它们的功能被分为五个顶级领域。这些领域是视觉、语音、语言、知识和搜索。我们将在接下来的章节中了解更多关于它们的信息。
- en: Vision
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视觉
- en: APIs under the **vision** flags allow your apps to understand images and video
    content. They allow you to retrieve information about faces, feelings, and other
    visual content. You can stabilize videos and recognize celebrities. You can read
    text in images and generate thumbnails from videos and images.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 带有**视觉**标志的API允许您的应用程序理解图像和视频内容。它们允许您检索有关面部、情感和其他视觉内容的信息。您可以稳定视频并识别名人。您可以在图像中读取文本并从视频和图像中生成缩略图。
- en: There are four APIs contained in the vision domain, which we will look at now.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 视觉领域包含四个API，我们现在将探讨它们。
- en: Computer vision
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 计算机视觉
- en: Using the **computer vision** API, you can retrieve actionable information from
    images. This means that you can identify content (such as image format, image
    size, colors, faces, and more). You can detect whether or not an image is adult/racy.
    This API can recognize text in images and extract it to machine-readable words.
    It can detect celebrities from a variety of areas. Lastly, it can generate storage-efficient
    thumbnails with smart-cropping functionality.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**计算机视觉**API，您可以从图像中检索可操作信息。这意味着您可以识别内容（例如图像格式、图像大小、颜色、面部等）。您可以检测图像是否为成人/色情。此API可以识别图像中的文本并将其提取为机器可读的单词。它可以识别来自各个领域的名人。最后，它还可以生成具有智能裁剪功能的存储高效的缩略图。
- en: We will look into computer vision in [Chapter 2](ch02.html "Chapter 2. Analyzing
    Images to Recognize a Face"), *Analyzing Images to Recognize a Face*.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第二章](ch02.html "第二章. 分析图像以识别面部")*分析图像以识别面部*中探讨计算机视觉。
- en: Face
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 面部
- en: We have already seen a very basic example of what the Face API can do. The rest
    of the API revolves around the detection, identification, organization, and tagging
    of faces in photos. As well as face detection, you can also see how likely it
    is that two faces belong to the same person. You can identify faces and also find
    similar-looking faces. We can also use the API to recognize emotions in images.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了Face API的一个非常基本的示例。其余的API主要围绕照片中面部检测、识别、组织和标记进行。除了面部检测，您还可以看到两个面部属于同一个人的可能性有多大。您可以识别面部并找到相似外观的面部。我们还可以使用API来识别图像中的情感。
- en: We will dive further into the Face API in [Chapter 2](ch02.html "Chapter 2. Analyzing
    Images to Recognize a Face"), *Analyzing Images to Recognize a Face*.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第二章](ch02.html "第二章. 分析图像以识别面部")*分析图像以识别面部*中进一步探讨Face API。
- en: Video indexer
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 视频索引器
- en: Using the **video indexer** API, you can start indexing videos immediately upon
    upload. This means that you can get video insights without using experts or custom
    code. Content discovery can be improved, utilizing the powerful artificial intelligence
    of this API. This allows you to make your content more discoverable.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**视频索引器**API，您可以在上传后立即开始索引视频。这意味着您可以在不使用专家或自定义代码的情况下获取视频洞察力。利用此API强大的人工智能，可以提高内容发现能力。这使得您的内容更容易被发现。
- en: The video indexer API will be covered in greater detail in [Chapter 3](ch03.html
    "Chapter 3. Analyzing Videos"), *Analyzing Videos*.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 视频索引器API将在[第三章](ch03.html "第三章. 分析视频")*分析视频*中进行更详细的介绍。
- en: Content moderator
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内容审核员
- en: The **content moderator** API utilizes machine learning to automatically moderate
    content. It can detect potentially offensive and unwanted images, videos, and
    text for over 100 languages. In addition, it allows you to review detected material
    to improve the service.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '**内容审核员**API利用机器学习自动审核内容。它可以检测超过100种语言的潜在冒犯性和不受欢迎的图像、视频和文本。此外，它还允许您审查检测到的材料以改进服务。'
- en: The content moderator will be covered in [Chapter 2](ch02.html "Chapter 2. Analyzing
    Images to Recognize a Face"), *Analyzing Images to Recognize a Face*.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 内容审核员将在[第二章](ch02.html "第二章. 分析图像以识别面部")*分析图像以识别面部*中进行介绍。
- en: Custom vision service
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定制视觉服务
- en: The **custom vision service** allows you to upload your own labeled images to
    a vision service. This means that you can add images that are specific to your
    domain to allow recognition using the computer vision API.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '**定制视觉服务** 允许您将您自己的标记图像上传到视觉服务。这意味着您可以将特定于您领域的图像添加到视觉服务中，以便使用计算机视觉 API 进行识别。'
- en: The custom vision service will be covered in more detail in [Chapter 2](ch02.html
    "Chapter 2. Analyzing Images to Recognize a Face"), *Analyzing Images to Recognize
    a Face*.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 定制视觉服务将在 [第 2 章](ch02.html "第 2 章。分析图像以识别面部") *分析图像以识别面部* 中更详细地介绍。
- en: Speech
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 语音
- en: Adding one of the Speech APIs allows your application to hear and speak to your
    users. The APIs can filter noise and identify speakers. Based on the recognized
    intent, they can drive further actions in your application.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 添加其中一个语音 API 允许您的应用程序听到并与其用户对话。这些 API 可以过滤噪音并识别说话人。基于识别的意图，它们可以在您的应用程序中驱动进一步的行动。
- en: The speech domain contains three APIs that are outlined in the following sections.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 语音领域包含三个 API，将在以下部分中概述。
- en: Bing Speech
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Bing Speech
- en: Adding the **Bing Speech** API to your application allows you to convert speech
    to text and vice versa. You can convert spoken audio to text either by utilizing
    a microphone or other sources in real time or by converting audio from files.
    The API also offers speech intent recognition, which is trained by the **Language
    Understanding Intelligent Service** (**LUIS**) to understand the intent.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 将 **Bing Speech** API 添加到您的应用程序中，允许您将语音转换为文本，反之亦然。您可以通过利用麦克风或其他实时源或将音频文件转换为文本来实现将语音音频转换为文本。该
    API 还提供语音意图识别，这是由 **语言理解智能服务**（**LUIS**）训练的，以理解意图。
- en: Speaker recognition
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 说话人识别
- en: The **speaker** **recognition** API gives your application the ability to know
    who is talking. By using this API, you can verify that the person that is speaking
    is who they claim to be. You can also determine who an unknown speaker is based
    on a group of selected speakers.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**说话人** **识别** API 使您的应用程序能够知道谁在说话。通过使用此 API，您可以验证说话的人就是他们所声称的人。您还可以根据所选的说话人群体确定未知说话人。'
- en: Translator speech API
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 翻译语音 API
- en: The **translator speech** API is a cloud-based automatic translation service
    for spoken audio. Using this API, you can add end-to-end translation across web
    apps, mobile apps, and desktop applications. Depending on your use cases, it can
    provide you with partial translations, full translations, and transcripts of the
    translations cover all speech-related APIs in [Chapter 5](ch05.html "Chapter 5. Speaking
    with Your Application"), *Speak with Your Application*.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**翻译语音** API 是一个基于云的自动语音翻译服务。使用此 API，您可以在 Web 应用程序、移动应用程序和桌面应用程序中添加端到端翻译。根据您的用例，它可以为您提供部分翻译、完整翻译和翻译的转录本，涵盖所有与语音相关的
    API，在 [第 5 章](ch05.html "第 5 章。与应用程序对话") *与应用程序对话* 中。'
- en: Language
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 语言
- en: APIs that are related to the language domain allow your application to process
    natural language and learn how to recognize what users want. You can add textual
    and linguistic analysis to your application, as well as natural language understanding.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 与语言领域相关的 API 允许您的应用程序处理自然语言并学习如何识别用户的需求。您可以为您的应用程序添加文本和语言分析，以及自然语言理解。
- en: The following five APIs can be found in the language domain.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 以下五个 API 可在语言领域找到。
- en: Bing Spell Check
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Bing 拼写检查
- en: The **Bing Spell Check** API allows you to add advanced spell checking to your
    application.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '**Bing 拼写检查** API 允许您为您的应用程序添加高级拼写检查。'
- en: This API will be covered in [Chapter 6](ch06.html "Chapter 6. Understanding
    Text"), *Understanding Text*.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 此 API 将在 [第 6 章](ch06.html "第 6 章。理解文本") *理解文本* 中进行介绍。
- en: Language Understanding Intelligent Service (LUIS)
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 语言理解智能服务 (LUIS)
- en: LUIS is an API that can help your application understand commands from your
    users. Using this API, you can create language models that understand intents.
    By using models from Bing and Cortana, you can make these models recognize common
    requests and entities (such as places, times, and numbers). You can add conversational
    intelligence to your applications.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: LUIS 是一个可以帮助您的应用程序理解用户命令的 API。使用此 API，您可以创建理解意图的语言模型。通过使用 Bing 和 Cortana 的模型，您可以使得这些模型能够识别常见的请求和实体（如地点、时间和数字）。您可以为您的应用程序添加对话智能。
- en: LUIS will be covered in [Chapter 4](ch04.html "Chapter 4. Letting Applications
    Understand Commands"), *Let Applications Understand Commands*.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: LUIS 将在 [第 4 章](ch04.html "第 4 章。让应用程序理解命令") *让应用程序理解命令* 中进行介绍。
- en: Text analytics
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文本分析
- en: The **text analytics** API will help you in extracting information from text.
    You can use it to find the sentiment of a text (whether the text is positive or
    negative), and will also be able to detect the language, topic, key phrases, and
    entities that are used throughout the will also cover the text analysis API in
    [Chapter 6](ch06.html "Chapter 6. Understanding Text"), *Understanding Text*.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Translator Text API
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By adding the **translator text** API, you can get textual translations for
    over 60 languages. It can detect languages automatically, and you can customize
    the API to your needs. In addition, you can improve translations by creating user
    groups, utilizing the power of crowdsourcing.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: The translator text API will not be covered in this book.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Knowledge
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we talk about **knowledge** APIs, we are talking about APIs that allow
    you to tap into rich knowledge. This may be knowledge from the web or from academia,
    or it may be your own data. Using these APIs, you will be able to explore the
    different nuances of knowledge.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: The following four APIs are contained in the knowledge API domain.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Project Academic Knowledge
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using the **Project** **Academic Knowledge** API, you can explore relationships
    among academic papers, journals, and authors. This API allows you to interpret
    natural language user query strings, which allows your application to anticipate
    what the user is typing. It will evaluate what is being typed and return academic
    knowledge entities.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: This API will be covered in more detail in [Chapter 8](ch08.html "Chapter 8. Querying
    Structured Data in a Natural Way"), *Query Structured Data in a Natural Way*.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Knowledge exploration
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **knowledge exploration** API will let you add the possibility of using
    interactive searches for structured data in your projects. It interprets natural
    language queries and offers autocompletions to minimize user effort. Based on
    the query expression received, it will retrieve detailed information about matching
    objects.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Details on this API will be covered in [Chapter 8](ch08.html "Chapter 8. Querying
    Structured Data in a Natural Way"), *Query Structured Data in a Natural Way*.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Recommendations solution
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **recommendations solution** API allows you to provide personalized product
    recommendations for your customers. You can use this API to add a frequently-bought-together
    functionality to your application. Another feature that you can add is item-to-item
    recommendations, which allows customers to see what other customers like. This
    API will also allow you to add recommendations based on the prior activity of
    the customer.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: We will go through this API in [Chapter 7](ch07.html "Chapter 7. Building Recommendation
    Systems for Businesses"), *Building Recommendation Systems for Businesses*.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: QnA Maker
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **QnA Maker** is a service to distill information for frequently asked questions
    (FAQ). Using existing FAQs, either online or in a document, you can create question
    and answer pairs. Pairs can be edited, removed, and modified, and you can add
    several similar questions to match a given pair.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: We will cover QnA Maker in [Chapter 8](ch08.html "Chapter 8. Querying Structured
    Data in a Natural Way"), *Query Structured Data in a Natural Way*.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Project Custom Decision Service
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Project Custom Decision Service** is a service designed to use reinforced
    learning to personalize content. The service understands any context and can provide
    context-based content.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: This book does not cover Project Custom Decision Service.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Search
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Search** APIs give you the ability to make your applications more intelligent
    with the power of Bing. Using these APIs, you can use a single call to access
    data from billions of web pages, images, videos, and news articles.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: The search domain contains the following APIs.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Bing Web Search
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With **Bing Web Search**, you can search for details in billions of web documents
    that are indexed by Bing. All the results can be arranged and ordered according
    to a layout that you specify, and the results are customized to the location of
    the end user.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Bing Web Search will be covered in [Chapter 9](ch09.html "Chapter 9. Adding
    Specialized Searches"), *Adding Specialized Search*.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Bing Image Search
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using the **Bing Image Search** API, you can add an advanced image and metadata
    search to your application. Results include URLs to images, thumbnails, and metadata.
    You will also be able to get machine-generated captions, similar images, and more.
    This API allows you to filter the results based on image type, layout, freshness
    (how new the image is), and license. Bing Image Search will be covered in [Chapter
    9](ch09.html "Chapter 9. Adding Specialized Searches"), *Adding Specialized Search*.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Bing Video Search
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Bing Video Search** will allow you to search for videos and return rich results.
    The results could contain metadata from the videos, static or motion-based thumbnails,
    and the video itself. You can add filters to the results based on freshness, video
    length, resolution, and price.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Bing Video Search will be covered in [Chapter 9](ch09.html "Chapter 9. Adding
    Specialized Searches"), *Adding Specialized Search*.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Bing News Search
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you add **Bing News Search** to your application, you can search for news
    articles. Results can include authoritative images, related news and categories,
    information on the provider, URLs, and more. To be more specific, you can filter
    news based on topics.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Bing News Search will be covered in [Chapter 9](ch09.html "Chapter 9. Adding
    Specialized Searches"), *Adding Specialized Search*.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Bing Autosuggest
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Bing Autosuggest** API is a small but powerful one. It will allow your
    users to search faster using their search suggestions, allowing you to connect
    a powerful search functionality to your apps.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: Bing Autosuggest will be covered in [Chapter 9](ch09.html "Chapter 9. Adding
    Specialized Searches"), *Adding Specialized Search*.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Bing Visual Search
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using the **Bing Visual Search** API, you can identify and classify images.
    You can also acquire knowledge about images.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Bing Visual Search will be covered in [Chapter 9](ch09.html "Chapter 9. Adding
    Specialized Searches"), *Adding Specialized Search*.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Bing Custom Search
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By utilizing the **Bing Custom Search** API, you can create a powerful, customized
    search that fits your needs. This tool is an ad-free commercial tool that allows
    you to deliver the search results you want.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Bing Custom Search will be covered in [Chapter 9](ch09.html "Chapter 9. Adding
    Specialized Searches"), *Adding Specialized Search*.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: Bing Entity Search
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using the **Bing Entity Search** API, you can enhance your searches. The API
    will find the most relevant entity based on your search terms. It will find entities
    such as famous people, places, movies, and more.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: We will not cover Bing Entity Search in this book.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Getting feedback on detected faces
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have seen what else Microsoft Cognitive Services can offer, we are
    going to add an API to our face detection application. In this section, we will
    add the Bing Speech API to make the application say the number of faces out loud.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: This feature of the API is not provided in the NuGet package, and as such, we
    are going to use the REST API.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: To reach our end goal, we are going to add two new classes, `TextToSpeak` and
    `Authentication`. The first class will be in charge of generating the correct
    headers and making the calls to our service endpoint. The latter class will be
    in charge of generating an authentication token. This will be tied together in
    our `ViewModel`, where we will make the application speak back to us.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: We need to get our hands on an API key first. Head over to the Microsoft Azure
    Portal. Create a new service for Bing Speech.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: To be able to call the Bing Speech API, we need to have an authorization token.
    Go back to Visual Studio and create a new file called `Authentication.cs`. Place
    this in the `Model` folder.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: We need to add two new references to the project. Find the `System.Runtime.Serialization`
    and `System.Web` packages in the **Assembly** tab in the **Add References** window
    and add them.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: 'In our `Authentication` class, define four `private` variables and one `public`
    property, as follows:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The constructor should accept one string parameter, `clientSecret`. The `clientSecret`
    parameter is the API key you signed up for.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: 'In the constructor, assign the `_clientSecret` variable, as follows:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Create a new function called `Initialize`, as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We then fetch the access token in a method that we will create shortly.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we create our `timer` class, which will call the `callback` function
    in nine minutes. The `callback` function will need to fetch the access token again
    and assign it to the `_token` variable. It also needs to ensure that we run the
    timer again in nine minutes.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to create the `GetToken` method. This method should return a `Task<string>`object,
    and it should be declared as `private` and marked as `async`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 'In the method, we start by creating an `HttpClient` object, pointing to an
    endpoint that will generate our token. We specify the root endpoint and add the
    token issue path, as follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We then go on to make a POST call to generate a token, as follows:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'When the request has been sent, we expect there to be a response. We want to
    read this response and return the response string:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Add a new file called `TextToSpeak.cs`, if you have not already done so. Put
    this file in the `Model` folder.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: Beneath the newly created class (but inside the namespace), we want to add two
    event argument classes. These will be used to handle audio events, which we will
    see later.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: 'The `AudioEventArgs` class simply takes a generic `stream`, as shown in the
    following code. You can imagine it being used to send the audio stream to our
    application:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The next class allows us to send an event with a specific error message:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We move on to start on the `TextToSpeak` class, where we start off by declaring
    some events and class members, as follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The first two lines in the class are events that use the event argument classes
    that we created earlier. These events will be triggered if a call to the API finishes
    (returning some audio), or if anything fails. The next few lines are string variables,
    which we will use as input parameters. We have one line to contain our access
    token information. The last line creates a new list, which we will use to hold
    our request headers.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: 'We add two constant strings to our class, as follows:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The first string contains the request URI. That is the REST API endpoint that
    we need to call to execute our request. Next, we have a string defining our **Speech
    Synthesis Markup Language** (**SSML**) template. This is where we will specify
    what the speech service should say, and how it should say it.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we create our constructor, as follows:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Here, we are just initializing some of the variables that we declared earlier.
    As you may see, we are defining the voice as female and we define it so that it
    uses a specific voice. In terms of gender, it can be either female or male. The
    voice name can be one of a long list of options. We will look more into the details
    of that list when we go through this API in a later chapter.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: The last line specifies the output format of the audio. This will define the
    format and codec in use by the resultant audio stream. Again, this can be a number
    of varieties, which we will look into in a later chapter.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: Following the constructor, there are three public methods that we will create.
    These will generate an authentication token and some HTTP headers, and finally
    execute our call to the API. Before we create these, you should add two helper
    methods to be able to raise our events. Call them the `RaiseOnAudioAvailable`
    and `RaiseOnError` methods. They should accept `AudioEventArgs` and `AudioErrorEventArgs`
    as parameters.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add a new method called the `GenerateHeaders` method, as follows:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Here, we add the HTTP headers to our previously created list. These headers
    are required for the service to respond, and if any are missing, it will yield
    an `HTTP/400` response. We will cover what we are using as headers in more detail
    later. For now, just make sure that they are present.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: 'Following this, we want to add a new method called `GenerateAuthenticationToken`,
    as follows:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This method accepts one string parameter, the client secret (your API key).
    First, we create a new object of the `Authentication` class, which we looked at
    earlier, as follows:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We use the authentication object to retrieve an access token. This token is
    used in our authorization token string, which, as we saw earlier, is being passed
    on in our headers. If the application for some reason fails to generate the access
    token, we trigger an error event.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Finish this method by adding the associated catch clause. If any exceptions
    occur, we want to raise a new error event.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: 'The last method that we need to create in this class is going to be called
    the `SpeakAsync` method, as shown in the following screenshot. This method will
    actually perform the request to the Speech API:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The method takes two parameters. One is the string, which will be the text that
    we want to be spoken. The next is `cancellationToken`; this can be used to propagate
    the command that the given operation should be cancelled.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: When entering the method, we create three objects that we will use to execute
    the request. These are classes from the .NET library. We will not be going through
    them in any more detail.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: 'We generated some headers earlier, and we need to add these to our HTTP client.
    We do this by adding the headers in the preceding `foreach` loop, basically looping
    through the entire list, as shown in the following code:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Next, we create an `HTTP Request Message`, specifying the request URI and the
    fact that we will send data through the `POST` method. We also specify the content
    using the SSML template that we created earlier, adding the correct parameters
    (gender, voice name, and the text we want to be spoken), as shown in the following
    code:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We use the HTTP client to send the HTTP request asynchronously, as follows:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The following code is a continuation of the asynchronous send call that we
    made previously. This will run asynchronously as well, and check the status of
    the response. If the response is successful, it will read the response message
    as a stream and trigger the audio event. If everything succeeds, then that stream
    should contain our text in spoken words:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: If the response indicates anything other than success, we will raise the error
    event.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: We also want to add a catch clause and a `finally` clause to this. Raise an
    error if an exception is caught and dispose of all objects used in the `finally`
    clause.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: 'The final code we need specifies that the continuation task is attached to
    the parent task. We also need to add `cancellationToken` to this task. Add the
    following code to finish off the method:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'With this in place, we are now able to utilize this class in our application.
    Open the `MainViewModel.cs` file and declare a new class variable, as follows:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Add the following code in the constructor to initialize the newly added object.
    We also need to call a function to generate the authentication token, as follows:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'After we have created the object, we hook up the two events to event handlers.
    Then we generate an authentication token by creating a `GenerateToken` function
    with the following content:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Then we generate an authentication token, specifying the API key for the Bing
    Speech API. If that call succeeds, we generate the HTTP headers required.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to add the event handlers, so create the `_textToSpeak_OnError` method
    first, as follows:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: It should be a rather simple method, just outputting the error message to the
    user in the status text field.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to create a `_textToSpeak_OnAudioAvailable` method, as follows:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Here, we utilize the `SoundPlayer` class from the .NET framework. This allows
    us to add the stream data directly and simply play the message.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part that we need for everything to work is to make the call to the
    `SpeakAsync` method. We can make this by adding the following at the end of our
    `DetectFace` method:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: With that in place, you should now be able to compile and run the application.
    By loading a photo and clicking on **Detect face**, you should be able to get
    the number of faces in the image spoken back to you. Just remember to have your
    audio turned on!
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter was a brief introduction to Microsoft Cognitive Services. We started
    off by creating a template project to easily create new projects for the coming
    chapters. We tried this template by creating an example project for this chapter.
    Then you learned how to detect faces in images by utilizing the Face API. From
    there, we took a quick tour of what Cognitive Services has to offer. We finished
    off by adding text-to-speech capabilities to our application by using the Bing
    Speech API.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will go into more detail of the vision part of the APIs. There,
    you will learn how to analyze images using the computer vision API. You will go
    into more detail about the Face API and will learn how to detect emotions in faces
    by using the emotion API. We will use some of this to start building our smart-house
    application.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
