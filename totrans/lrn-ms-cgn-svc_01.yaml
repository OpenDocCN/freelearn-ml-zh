- en: Chapter 1. Getting Started with Microsoft Cognitive Services
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章. Microsoft Cognitive Services入门
- en: You have just started on the road to learning about Microsoft Cognitive Services.
    This chapter will serve as a gentle introduction to the services that it offers.
    The end goal is to understand a bit more about what these Cognitive Services APIs
    can do for you. By the end of this chapter, we will have created an easy-to-use
    project template. You will have learned how to detect faces in images and have
    the number of faces spoken back to you.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 您刚刚开始学习关于Microsoft Cognitive Services的道路。本章将作为对其提供的服务的一个温和的介绍。最终目标是更好地了解这些认知服务API能为您做什么。到本章结束时，我们将创建一个易于使用的项目模板。您将学会如何在图像中检测人脸，并且会听到人脸数量的反馈。
- en: 'Throughout this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Applications that already use Microsoft Cognitive Services
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已经使用Microsoft Cognitive Services的应用程序
- en: Creating a template project
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建模板项目
- en: Detecting faces in images using a Face API
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Face API在图像中检测人脸
- en: Discovering what Microsoft Cognitive Services can offer
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索Microsoft Cognitive Services能提供什么
- en: Doing text-to-speech conversion using the Bing Speech API
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Bing Speech API进行文本到语音的转换
- en: Cognitive Services in action for fun and life-changing purposes
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 认知服务在实际中的应用，用于娱乐和改变生活
- en: The best way to introduce Microsoft Cognitive Services is to see how it can
    be used in action. Microsoft (as well as other companies) has created a lot of
    example applications to show off its capabilities. Several may be seen as silly,
    such as the How-Old.net ([http://how-old.net/](http://how-old.net/)) image analysis
    and the *what if I were that person* application. These applications have generated
    quite some buzz, and they show off some of the APIs in a good way.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 介绍Microsoft Cognitive Services的最佳方式是看看它如何在实际中使用。微软（以及其他公司）已经创建了许多示例应用程序来展示其功能。其中一些可能看起来很傻，比如How-Old.net
    ([http://how-old.net/](http://how-old.net/)) 图像分析和“如果我变成那个人”应用程序。这些应用程序已经引起了很多关注，并以良好的方式展示了API的一些功能。
- en: The one demonstration that is truly inspiring, though, is the one featuring
    a visually impaired person. Talking computers inspired him to create an application
    to allow blind and visually impaired people to understand what is going on around
    them. The application has been built upon Microsoft Cognitive Services. It gives
    us a good idea of how these APIs can be used to change the world, for the better.
    Before moving on, head over to [https://www.youtube.com/watch?v=R2mC-NUAmMk](https://www.youtube.com/watch?v=R2mC-NUAmMk)
    and take a peek into the world of Microsoft Cognitive Services.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 真正令人鼓舞的一个演示是关于一个视力受损的人。会说话的电脑激发了他创建一个应用程序，让盲人和视力受损的人能够理解周围发生的事情。该应用程序是基于Microsoft
    Cognitive Services构建的。它让我们很好地了解这些API如何改变世界，使之变得更好。在继续之前，请访问[https://www.youtube.com/watch?v=R2mC-NUAmMk](https://www.youtube.com/watch?v=R2mC-NUAmMk)并一窥Microsoft
    Cognitive Services的世界。
- en: Setting up the boilerplate code
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置样板代码
- en: Before we start diving into the action, we will go through some initial setup.
    More to the point, we will set up some boilerplate code that we will utilize throughout
    this book.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始深入行动之前，我们将进行一些初始设置。更具体地说，我们将设置一些样板代码，我们将在整本书中利用这些代码。
- en: To get started, you will need to install a version of Visual Studio, preferably
    Visual Studio 2015 or later. The Community Edition will work fine for this purpose.
    You do not need anything more than what the default installation offers.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，您需要安装Visual Studio的一个版本，最好是Visual Studio 2015或更高版本。社区版就足够用于这个目的了。您不需要比默认安装提供的内容更多。
- en: Note
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can find Visual Studio 2017 at [https://www.microsoft.com/en-us/download/details.aspx?id=48146](https://www.microsoft.com/en-us/download/details.aspx?id=48146).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://www.microsoft.com/en-us/download/details.aspx?id=48146](https://www.microsoft.com/en-us/download/details.aspx?id=48146)找到Visual
    Studio 2017。
- en: Throughout this book, we will utilize the different APIs to build a smart-house
    application. The application will be created to see how a futuristic house might
    appear. If you have seen the Iron Man movies, you can think of the application
    as resembling Jarvis, in some ways.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们将利用不同的API构建一个智能家居应用程序。该应用程序旨在展示未来房屋可能的样子。如果您看过《钢铁侠》电影，您可以将该应用程序想象成某种形式的Jarvis。
- en: In addition, we will be making smaller sample applications using the Cognitive
    Services APIs. Doing so will allow us to look at each API, even those that did
    not make it to the final application.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还将使用认知服务API创建较小的示例应用程序。这样做将允许我们查看每个API，即使是那些没有进入最终应用程序的API。
- en: What's common with all the applications that we will build is that they will
    be **Windows Presentation Foundation** (**WPF**) applications. This is fairly
    well known, and allows us to build applications using the **Model-View-ViewModel**
    (**MVVM**) pattern. One of the advantages of taking this road is that we will
    be able to see the API usage quite clearly. It also separates code so that you
    can bring the API logic to other applications with ease.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要构建的所有应用程序的共同点在于它们将是**Windows Presentation Foundation**（**WPF**）应用程序。这是相当知名的，并允许我们使用**模型-视图-视图模型**（**MVVM**）模式来构建应用程序。走这条路的一个优点是我们将能够清楚地看到API的使用情况。它还使代码分离，这样你可以轻松地将API逻辑带到其他应用程序中。
- en: 'The following steps describe the process of creating a new WPF project:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤描述了创建新的WPF项目的过程：
- en: Open Visual Studio and select **File** | **New** | **Project**.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Visual Studio，选择**文件** | **新建** | **项目**。
- en: In the dialog, select the **WPF Application** option from **Templates** | **Visual
    C#**, as shown in the following screenshot:![Setting up the boilerplate code](img/B12373_01_01.jpg)
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在对话框中，从**模板** | **Visual C#**中选择**WPF应用程序**选项，如下所示：![设置模板代码](img/B12373_01_01.jpg)
- en: Delete the `MainWindow.xaml` file and create the files and folders that are
    shown in the following screenshot:![Setting up the boilerplate code](img/B12373_01_02.jpg)
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除`MainWindow.xaml`文件，并创建以下截图所示的文件和文件夹：![设置模板代码](img/B12373_01_02.jpg)
- en: We will not go through the MVVM pattern in detail, as this is out of the scope
    of this book. The key takeaway from the screenshot is that we have separated the
    `View` from what becomes the logic. We then rely on the `ViewModel` to connect
    the pieces.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会详细讲解MVVM模式，因为这超出了本书的范围。从截图中的关键点来看，我们已经将`View`与逻辑部分分离。然后我们依赖`ViewModel`来连接这些部分。
- en: Note
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you want to learn more about MVVM, I recommend reading [http://www.codeproject.com/Articles/100175/Model-View-ViewModel-MVVM-Explained](http://www.codeproject.com/Articles/100175/Model-View-ViewModel-MVVM-Explained).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于MVVM的信息，我建议阅读[http://www.codeproject.com/Articles/100175/Model-View-ViewModel-MVVM-Explained](http://www.codeproject.com/Articles/100175/Model-View-ViewModel-MVVM-Explained)。
- en: 'To be able to run this, however, we do need to set up our project. Go through
    the following steps:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了能够运行这个程序，我们确实需要设置我们的项目。按照以下步骤进行：
- en: 'Open the `App.xaml` file and make sure the `StartupUri` is set to the correct
    `View`, as shown in the following code (class name and namespace may vary based
    on the name of your application):'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`App.xaml`文件，确保`StartupUri`设置为正确的`View`，如下所示（类名和命名空间可能根据应用程序的名称而变化）：
- en: '[PRE0]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Open the `MainViewModel.cs` file and make it inherit from the `ObservableObject`
    class.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`MainViewModel.cs`文件，并让它继承自`ObservableObject`类。
- en: 'Open the `MainView.xaml` file and add the `MainViewModel` file as `DataContext`
    to it, as shown in the following code (namespace and class names may vary based
    on the name of your application):'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`MainView.xaml`文件，并将`MainViewModel`文件作为`DataContext`添加到其中，如下所示（命名空间和类名可能根据应用程序的名称而变化）：
- en: '[PRE1]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Following this, we need to fill in the content of the `ObservableObject.cs`
    file. We start off by having it inherit from the `INotifyPropertyChanged` class
    as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要填写`ObservableObject.cs`文件的内容。我们首先让它继承自`INotifyPropertyChanged`类，如下所示：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This is a rather small class, which should contain the following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当小的类，应该包含以下内容：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We declare a property changed event and create a function to raise the event.
    This will allow the **user interface** (**UI**) to update its values when a given
    property has changed.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明一个属性更改事件并创建一个函数来触发事件。这将允许**用户界面**（**UI**）在给定属性更改时更新其值。
- en: 'We also need to be able to execute actions when buttons are clicked. This can
    be achieved when we put some content into the `DelegateCommand.cs` file. Start
    by making the class inherit the `ICommand` class, and declare the following two
    variables:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要能够在按钮点击时执行操作。这可以通过在`DelegateCommand.cs`文件中放入一些内容来实现。首先让这个类继承自`ICommand`类，并声明以下两个变量：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The two variables we have created will be set in the constructor. As you will
    notice, you are not required to add the `_canExecute` parameter, and you will
    see why in a bit:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的两个变量将在构造函数中设置。正如你将注意到的，你不需要添加`_canExecute`参数，你很快就会明白原因：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To complete the class, we add two `public` functions and one `public` event,
    as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成类，我们添加两个`public`函数和一个`public`事件，如下所示：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The functions declared will return the corresponding predicate, or action, declared
    in the constructor. This will be something we declare in our `ViewModel` instances,
    which, in turn, will be something that executes an action or tells the application
    that it can or cannot execute an action. If a button is in a state where it is
    disabled (that is, when the `CanExecute` function returns `false`) and the state
    of the `CanExecute` function changes, the event that is declared will let the
    button know.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 声明的函数将返回构造函数中声明的相应谓词或动作。这将是我们在`ViewModel`实例中声明的，反过来，这将执行动作或告诉应用程序它是否可以执行动作。如果一个按钮处于禁用状态（即当`CanExecute`函数返回`false`时），并且`CanExecute`函数的状态发生变化，声明的该事件将让按钮知道。
- en: With that in place, you should be able to compile and run the application, so
    go on and try that. You will notice that the application does not actually do
    anything or present any data yet, but we have an excellent starting point.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好之后，你应该能够编译并运行应用程序，所以继续尝试吧。你会注意到应用程序实际上并没有做任何事情或展示任何数据，但我们有一个非常好的起点。
- en: 'Before we do anything else with the code, we are going to export the project
    as a template using the following steps. This is so that we do not have to redo
    all these steps for each small sample project we create:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们对代码进行任何其他操作之前，我们将按照以下步骤将项目导出为模板。这样做是为了我们不必为每个创建的小型样本项目重复所有这些步骤：
- en: 'Replace the namespace names with substitute parameters:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将命名空间名称替换为替代参数：
- en: In all the `.cs` files, replace the namespace name with `$safeprojectname$`
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在所有`.cs`文件中，将命名空间名称替换为`$safeprojectname$`
- en: In all the `.xaml` files, replace the project name with `$safeprojectname$`
    where applicable (typically the class name and namespace declarations)
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在所有`.xaml`文件中，将项目名称替换为`$safeprojectname$`（通常为类名和命名空间声明）
- en: Navigate to **File** | **Export Template**. This will open the **Export Template**
    wizard, as shown in the following screenshot:![Setting up the boilerplate code](img/B12373_01_03.jpg)
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到**文件** | **导出模板**。这将打开**导出模板**向导，如下截图所示：![设置样板代码](img/B12373_01_03.jpg)
- en: Click on the **Project Template** button. Select the project we just created
    and click on the **Next** button.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**项目模板**按钮。选择我们刚刚创建的项目，然后点击**下一步**按钮。
- en: Just leave the icon and preview image empty. Enter a recognizable name and description.
    Click on the **Finish** button:![Setting up the boilerplate code](img/B12373_01_04.jpg)
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只需将图标和预览图像留空。输入一个可识别的名称和描述。点击**完成**按钮：![设置样板代码](img/B12373_01_04.jpg)
- en: The template is now exported to a `.zip` file and stored in the specified location.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模板现在已导出为`.zip`文件并存储在指定的位置。
- en: By default, the template will be imported into Visual Studio again. We are going
    to test that it works immediately by creating a project for this chapter. So go
    ahead and create a new project, selecting the template that we just created. The
    template should be listed in the **Visual C#** section of the installed templates
    list. Call the project `Chapter1`, or something else, if you prefer. Make sure
    it compiles and that you are able to run it before we move to the next step.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，模板将再次导入到Visual Studio中。我们将通过创建本章的项目来测试它是否立即工作。所以请继续创建一个新的项目，选择我们刚刚创建的模板。该模板应列在已安装模板列表的**Visual
    C#**部分中。将项目命名为`Chapter1`或你喜欢的其他名称。确保在进入下一步之前编译并能够运行它。
- en: Detecting faces with the Face API
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用面部API检测面部
- en: With the newly created project, we will now try our first API, the Face API.
    We will not be doing a whole lot, but we will still see how simple it is to detect
    faces in images.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 使用新创建的项目，我们现在将尝试我们的第一个API，即面部API。我们不会做很多，但我们仍然会看到检测图像中的面部是多么简单。
- en: 'The steps we need to go through in order to do this are as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们需要遵循以下步骤：
- en: Register for a Face API preview subscription at Microsoft Azure
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Microsoft Azure注册面部API预览订阅
- en: Add the necessary **NuGet** packages to our project
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将必要的**NuGet**包添加到我们的项目中
- en: Add a UI to the application
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向应用程序添加UI
- en: Detect faces on command
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按命令检测面部
- en: Head over to [https://portal.azure.com](https://portal.azure.com) to start the
    process of registering for a free subscription to the Face API. You will be taken
    to a login page. Log on with your Microsoft account; if you do not have one, then
    register for one.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 转到[https://portal.azure.com](https://portal.azure.com)开始注册Face API免费订阅的过程。您将被带到登录页面。使用您的Microsoft账户登录；如果您没有，则需要注册一个。
- en: 'Once logged in, you will need to add a new resource by clicking on **+ New**
    on the right-hand menu. Search for **Face API** and select the first entry, as
    shown in the following screenshot:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 登录后，您需要通过点击右侧菜单中的**+ 新建**来添加一个新的资源。搜索**Face API**并选择第一个条目，如下截图所示：
- en: '![Detecting faces with the Face API](img/B12373_01_05.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![使用Face API检测人脸](img/B12373_01_05.jpg)'
- en: 'Enter a name and select the subscription, location, and pricing tier. At the
    time of writing, there are two pricing options, one free and one paid, as shown
    in the following screenshot:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 输入一个名称并选择订阅、位置和定价层。在撰写本文时，有两种定价选项，一个是免费的，一个是付费的，如下截图所示：
- en: '![Detecting faces with the Face API](img/B12373_01_06.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![使用Face API检测人脸](img/B12373_01_06.jpg)'
- en: 'Once created, you can go into the newly created resource. You will need one
    of the two available API keys. These can be found in the **Keys** option of the
    **Resource Management** menu, as shown in the following screenshot:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建，您就可以进入新创建的资源。您需要两个可用的API密钥之一。这些可以在**资源管理**菜单的**密钥**选项中找到，如下截图所示：
- en: '![Detecting faces with the Face API](img/B12373_01_07.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![使用Face API检测人脸](img/B12373_01_07.jpg)'
- en: Some of the APIs that we will cover have their own NuGet packages created. Whenever
    this is the case, we will utilize those packages to do the operations we want
    to perform. A common feature of all APIs is that they are REST APIs, which means
    that in practice you can use them with whichever language you want. For those
    APIs that do not have their own NuGet package, we call the APIs directly through
    HTTP.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要介绍的一些API有自己的NuGet包。每当这种情况发生时，我们将利用这些包来执行我们想要执行的操作。所有API的共同特点是它们都是REST API，这意味着在实践中，您可以使用任何语言来使用它们。对于没有自己的NuGet包的API，我们直接通过HTTP调用API。
- en: 'A NuGet package does exist for the Face API we are using now, so we need to
    add that to our project. Head over to the **NuGet Package Manager** option for
    the project we created earlier. In the **Browse** tab, search for the `Microsoft.ProjectOxford.Face`
    package and install the package from Microsoft, as shown in the following screenshot:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们现在使用的Face API，确实存在一个NuGet包，因此我们需要将其添加到我们的项目中。转到我们之前创建的项目中的**NuGet包管理器**选项。在**浏览**选项卡中，搜索`Microsoft.ProjectOxford.Face`包，并从Microsoft安装该包，如下截图所示：
- en: '![Detecting faces with the Face API](img/B12373_01_08.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![使用Face API检测人脸](img/B12373_01_08.jpg)'
- en: As you will notice, another package will also be installed. This is the `Newtonsoft.Json`
    package, which is required by the Face API.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所注意到的，另一个包也将被安装。这是Face API所需的`Newtonsoft.Json`包。
- en: The next step is to add a UI to our application. We will be adding this in the
    `MainView.xaml` file. Open this file where the template code that we created earlier
    should be. This means that we have `DataContext`, and can make bindings for our
    elements, which we will define now.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是向我们的应用程序添加UI。我们将在`MainView.xaml`文件中添加这个。这意味着我们有`DataContext`，可以为我们的元素创建绑定，我们现在将定义这些元素。
- en: 'First, we add a grid and define some rows for the grid, as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们添加一个网格并定义一些网格行，如下所示：
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Three rows are defined. The first is a row where we will have an image, the
    second is a line for the status message, and the last is where we will place some
    buttons.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了三行。第一行是我们将放置图片的行，第二行是状态消息的行，最后一行我们将放置一些按钮。
- en: 'Next, we add our `image` element, as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们添加我们的`image`元素，如下所示：
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We have given it a unique name. By setting the `Stretch` parameter to `Uniform`,
    we ensure that the image keeps its aspect ratio. Further on, we place this element
    in the first row. Last, we bind the image source to a `BitmapImage` in the `ViewModel`,
    which we will look at in a bit.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们给它起了一个独特的名字。通过将`Stretch`参数设置为`Uniform`，我们确保图片保持其宽高比。进一步地，我们将此元素放置在第一行。最后，我们将图片源绑定到`ViewModel`中的`BitmapImage`，我们稍后会看到。
- en: 'The next row will contain a text block with some status text. The `Text` property
    will be bound to a string property in the `ViewModel`, as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行将包含一个带有一些状态文本的文本块。`Text`属性将绑定到`ViewModel`中的字符串属性，如下所示：
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The last row will contain one button to browse for an image and one button
    to be able to detect faces. The `command` properties of both buttons will be bound
    to the `DelegateCommand` properties in the `ViewModel`, as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行将包含一个用于浏览图像的按钮和一个用于检测面部的按钮。两个按钮的`command`属性将绑定到`ViewModel`中的`DelegateCommand`属性，如下所示：
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'With the `View` in place, make sure that the code compiles and runs it. This
    should present you with the following UI:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在`View`就绪后，确保代码编译并运行它。这应该向您展示以下UI：
- en: '![Detecting faces with the Face API](img/B12373_01_09.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![使用面部API检测面部](img/B12373_01_09.jpg)'
- en: 'The last part of the process is to create the binding properties in our `ViewModel`
    and make the buttons execute something. Open the `MainViewModel.cs` file. The
    class should already inherit from the `ObservableObject` class. First, we define
    two variables as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 流程的最后部分是在我们的`ViewModel`中创建绑定属性，并使按钮执行某些操作。打开`MainViewModel.cs`文件。该类应该已经继承自`ObservableObject`类。首先，我们定义以下两个变量：
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `string` variable will hold the path to our image, while the `IFaceServiceClient`
    variable is to interface the Face API. Next, we define two properties, as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`string`变量将保存我们图像的路径，而`IFaceServiceClient`变量用于与面部API接口。接下来，我们定义两个属性，如下所示：'
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: What we have here is a property for the `BitmapImage`, mapped to the `Image`
    element in the `View`. We also have a `string` property for the status text, mapped
    to the text block element in the `View`. As you may also notice, when either of
    the properties is set, we call the `RaisePropertyChangedEvent` event. This will
    ensure that the UI updates when either property has new values.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这里有一个`BitmapImage`属性，映射到`View`中的`Image`元素。我们还有一个`string`属性用于状态文本，映射到`View`中的文本块元素。您可能也注意到，当设置任一属性时，我们调用`RaisePropertyChangedEvent`事件。这将确保当任一属性有新值时，UI会更新。
- en: 'Next, we define our two `DelegateCommand` objects and perform some initialization
    through the constructor, as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义我们的两个`DelegateCommand`对象，并在构造函数中执行一些初始化，如下所示：
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The properties for the commands are `public` to get, but `private` to set. This
    means that we can only set them from within the `ViewModel`. In our constructor,
    we start off by setting the status text. Next, we create an object of the Face
    API, which needs to be created with the API key we got earlier. In addition, it
    needs to specify the root URI, pointing at the location of the service. It can,
    for instance, be [https://westeurope.api.cognitive.microsoft.com/face/v1.0](https://westeurope.api.cognitive.microsoft.com/face/v1.0)
    if the service is located in west Europe.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 命令的属性是`public`以获取，但`private`以设置。这意味着我们只能从`ViewModel`内部设置它们。在我们的构造函数中，我们首先设置状态文本。接下来，我们创建一个面部API的对象，该对象需要使用我们之前获得的API密钥创建。此外，它需要指定根URI，指向服务位置。例如，如果服务位于西欧，可以是[https://westeurope.api.cognitive.microsoft.com/face/v1.0](https://westeurope.api.cognitive.microsoft.com/face/v1.0)。
- en: 'If the service is located in the west US, you would replace `westeurope` with
    `westus`. The root URI can be found in the following place in Azure Portal:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务位于西美国，您将用`westus`替换`westeurope`。根URI可以在Azure门户的以下位置找到：
- en: '![Detecting faces with the Face API](img/B12373_01_10.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![使用面部API检测面部](img/B12373_01_10.jpg)'
- en: 'At last, we create the `DelegateCommand` constructor for our command properties.
    Note how the `browse` command does not specify a predicate. This means that it
    will always be possible to click on the corresponding button. To make this compile,
    we need to create the functions specified in the `DelegateCommand` constructors:
    the `Browse`, `DetectFace`, and `CanDetectFace` functions.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们为我们的命令属性创建`DelegateCommand`构造函数。注意`browse`命令没有指定谓词。这意味着始终可以点击相应的按钮。为了使代码编译，我们需要创建`DelegateCommand`构造函数中指定的函数：`Browse`、`DetectFace`和`CanDetectFace`函数。
- en: 'We start the `Browse` function by creating an `OpenFileDialog` object. This
    dialog is assigned a filter for JPEG images, and, in turn, it is opened, as shown
    in the following code. When the dialog is closed, we check the result. If the
    dialog was canceled, we simply stop further execution:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过创建一个`OpenFileDialog`对象来开始`Browse`函数。此对话框分配了一个JPEG图像过滤器，然后打开，如下面的代码所示。当对话框关闭时，我们检查结果。如果对话框被取消，我们简单地停止进一步执行：
- en: '[PRE14]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'With the dialog closed, we grab the filename of the file selected and create
    a new URI from it, as shown in the following code:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 对话框关闭后，我们获取所选文件的文件名，并从它创建一个新的URI，如下面的代码所示：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'With the newly created URI, we want to create a new `BitmapImage`. We specify
    it so that it uses no cache, and we set the URI source of the URI that we created,
    as shown in the following code:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 使用新创建的 URI，我们想要创建一个新的 `BitmapImage`。我们指定它不使用缓存，并设置我们创建的 URI 的 URI 源，如下面的代码所示：
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The last step we take is to assign the bitmap image to our `BitmapImage` property
    so that the image is shown in the UI. We also update the status text to let the
    user know that the image has been loaded, as shown in the following code:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是将位图图像分配给我们的 `BitmapImage` 属性，以便在 UI 中显示图像。我们还更新状态文本，让用户知道图像已被加载，如下面的代码所示：
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `CanDetectFace` function checks whether or not the `DetectFacesButton`
    button should be enabled. In this case, it checks whether our image property actually
    has a URI. If it does by extension, then that means that we have an image and
    we should be able to detect faces, as shown in the following code:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`CanDetectFace` 函数检查是否应该启用 `DetectFacesButton` 按钮。在这种情况下，它检查我们的图像属性是否实际上有一个
    URI。如果有，那么这意味着我们有一个图像，我们应该能够检测到人脸，如下面的代码所示：'
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Our `DetectFace` method calls an `async` method to upload and detect faces.
    The return value contains an array of the `FaceRectangles` variable. This array
    contains the rectangle area for all face positions in the given image. We will
    look into the function that we are going to call in a bit.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `DetectFace` 方法调用一个 `async` 方法来上传和检测人脸。返回值包含 `FaceRectangles` 变量的数组。这个数组包含给定图像中所有人脸位置的矩形区域。我们稍后会查看将要调用的函数。
- en: 'After the call has finished executing, we print a line containing the number
    of faces to the debug console window, as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 调用完成后，我们将打印包含人脸数量的行到调试控制台窗口，如下所示：
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the `UploadAndDetectFacesAsync` function, we create a `Stream` from the
    image, as shown in the following code. This stream will be used as input for the
    actual call to the Face API service:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `UploadAndDetectFacesAsync` 函数中，我们根据以下代码从图像创建一个 `Stream`。这个流将被用作调用 Face API
    服务的实际输入：
- en: '[PRE20]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The following line is the actual call to the detection endpoint for the Face
    API:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行是调用 Face API 检测端点的实际调用：
- en: '[PRE21]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The first parameter is the file stream that we created in the previous step.
    The rest of the parameters are all optional. The second parameter should be `true`
    if you want to get a face ID. The next parameter specifies whether you want to
    receive face landmarks or not. The last parameter takes a list of facial attributes
    that you may want to receive. In our case, we want the `age` parameter to be returned,
    so we need to specify that.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是我们之前创建的文件流。其余参数都是可选的。第二个参数应该为 `true`，如果您想获取人脸 ID。下一个参数指定您是否想接收人脸特征点。最后一个参数接受您可能想要接收的面部属性列表。在我们的例子中，我们希望返回
    `age` 参数，因此我们需要指定它。
- en: 'The return type of this function call is an array of faces, with all the parameters
    that you have specified, as shown in the following code:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数调用的返回类型是一个包含所有您指定参数的人脸数组，如下面的代码所示：
- en: '[PRE22]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The first line iterates over all faces and retrieves the approximate age of
    all faces. This is later printed to the debug console window, in the `foreach`
    loop.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行遍历所有人脸并检索所有人脸的大致年龄。这稍后将在 `foreach` 循环中打印到调试控制台窗口。
- en: The second line iterates over all faces and retrieves the face rectangle, with
    the rectangular location of all faces. This is the data that we return to the
    calling function.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行遍历所有人脸并检索人脸矩形，包括所有人脸的矩形位置。这是我们返回给调用函数的数据。
- en: Add a `catch` clause to finish the method. Where an exception is thrown in our
    API call, we catch that. We want to show the error message and return an empty
    `FaceRectangle` array.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个 `catch` 子句来完成方法。在我们的 API 调用中抛出异常时，我们捕获它。我们想显示错误消息并返回一个空的 `FaceRectangle`
    数组。
- en: 'With that code in place, you should now be able to run the full example. The
    end result will look like the following screenshot:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在放置了上述代码后，您现在应该能够运行完整的示例。最终结果将类似于以下截图：
- en: '![Detecting faces with the Face API](img/B12373_01_11.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Face API 检测人脸](img/B12373_01_11.jpg)'
- en: 'The result debug console window will print the following text:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 调试控制台窗口将打印以下文本：
- en: '[PRE23]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: An overview of different APIs
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不同 API 的概述
- en: Now that you have seen a basic example of how to detect faces, it is time to
    learn a bit about what else Cognitive Services can do for you. When using Cognitive
    Services, you have 21 different APIs to hand. These are, in turn, separated into
    five top-level domains depending on what they do. These domains are vision, speech,
    language, knowledge, and search. We will learn more about them in the following
    sections.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经看到了如何检测面部的基本示例，是时候学习一下认知服务还能为您做什么了。当使用认知服务时，您有21个不同的API可供选择。这些API根据它们的功能被分为五个顶级领域。这些领域是视觉、语音、语言、知识和搜索。我们将在接下来的章节中了解更多关于它们的信息。
- en: Vision
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视觉
- en: APIs under the **vision** flags allow your apps to understand images and video
    content. They allow you to retrieve information about faces, feelings, and other
    visual content. You can stabilize videos and recognize celebrities. You can read
    text in images and generate thumbnails from videos and images.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 带有**视觉**标志的API允许您的应用程序理解图像和视频内容。它们允许您检索有关面部、情感和其他视觉内容的信息。您可以稳定视频并识别名人。您可以在图像中读取文本并从视频和图像中生成缩略图。
- en: There are four APIs contained in the vision domain, which we will look at now.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 视觉领域包含四个API，我们现在将探讨它们。
- en: Computer vision
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 计算机视觉
- en: Using the **computer vision** API, you can retrieve actionable information from
    images. This means that you can identify content (such as image format, image
    size, colors, faces, and more). You can detect whether or not an image is adult/racy.
    This API can recognize text in images and extract it to machine-readable words.
    It can detect celebrities from a variety of areas. Lastly, it can generate storage-efficient
    thumbnails with smart-cropping functionality.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**计算机视觉**API，您可以从图像中检索可操作信息。这意味着您可以识别内容（例如图像格式、图像大小、颜色、面部等）。您可以检测图像是否为成人/色情。此API可以识别图像中的文本并将其提取为机器可读的单词。它可以识别来自各个领域的名人。最后，它还可以生成具有智能裁剪功能的存储高效的缩略图。
- en: We will look into computer vision in [Chapter 2](ch02.html "Chapter 2. Analyzing
    Images to Recognize a Face"), *Analyzing Images to Recognize a Face*.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第二章](ch02.html "第二章. 分析图像以识别面部")*分析图像以识别面部*中探讨计算机视觉。
- en: Face
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 面部
- en: We have already seen a very basic example of what the Face API can do. The rest
    of the API revolves around the detection, identification, organization, and tagging
    of faces in photos. As well as face detection, you can also see how likely it
    is that two faces belong to the same person. You can identify faces and also find
    similar-looking faces. We can also use the API to recognize emotions in images.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了Face API的一个非常基本的示例。其余的API主要围绕照片中面部检测、识别、组织和标记进行。除了面部检测，您还可以看到两个面部属于同一个人的可能性有多大。您可以识别面部并找到相似外观的面部。我们还可以使用API来识别图像中的情感。
- en: We will dive further into the Face API in [Chapter 2](ch02.html "Chapter 2. Analyzing
    Images to Recognize a Face"), *Analyzing Images to Recognize a Face*.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第二章](ch02.html "第二章. 分析图像以识别面部")*分析图像以识别面部*中进一步探讨Face API。
- en: Video indexer
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 视频索引器
- en: Using the **video indexer** API, you can start indexing videos immediately upon
    upload. This means that you can get video insights without using experts or custom
    code. Content discovery can be improved, utilizing the powerful artificial intelligence
    of this API. This allows you to make your content more discoverable.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**视频索引器**API，您可以在上传后立即开始索引视频。这意味着您可以在不使用专家或自定义代码的情况下获取视频洞察力。利用此API强大的人工智能，可以提高内容发现能力。这使得您的内容更容易被发现。
- en: The video indexer API will be covered in greater detail in [Chapter 3](ch03.html
    "Chapter 3. Analyzing Videos"), *Analyzing Videos*.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 视频索引器API将在[第三章](ch03.html "第三章. 分析视频")*分析视频*中进行更详细的介绍。
- en: Content moderator
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内容审核员
- en: The **content moderator** API utilizes machine learning to automatically moderate
    content. It can detect potentially offensive and unwanted images, videos, and
    text for over 100 languages. In addition, it allows you to review detected material
    to improve the service.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '**内容审核员**API利用机器学习自动审核内容。它可以检测超过100种语言的潜在冒犯性和不受欢迎的图像、视频和文本。此外，它还允许您审查检测到的材料以改进服务。'
- en: The content moderator will be covered in [Chapter 2](ch02.html "Chapter 2. Analyzing
    Images to Recognize a Face"), *Analyzing Images to Recognize a Face*.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 内容审核员将在[第二章](ch02.html "第二章. 分析图像以识别面部")*分析图像以识别面部*中进行介绍。
- en: Custom vision service
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定制视觉服务
- en: The **custom vision service** allows you to upload your own labeled images to
    a vision service. This means that you can add images that are specific to your
    domain to allow recognition using the computer vision API.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '**定制视觉服务** 允许您将您自己的标记图像上传到视觉服务。这意味着您可以将特定于您领域的图像添加到视觉服务中，以便使用计算机视觉 API 进行识别。'
- en: The custom vision service will be covered in more detail in [Chapter 2](ch02.html
    "Chapter 2. Analyzing Images to Recognize a Face"), *Analyzing Images to Recognize
    a Face*.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 定制视觉服务将在 [第 2 章](ch02.html "第 2 章。分析图像以识别面部") *分析图像以识别面部* 中更详细地介绍。
- en: Speech
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 语音
- en: Adding one of the Speech APIs allows your application to hear and speak to your
    users. The APIs can filter noise and identify speakers. Based on the recognized
    intent, they can drive further actions in your application.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 添加其中一个语音 API 允许您的应用程序听到并与其用户对话。这些 API 可以过滤噪音并识别说话人。基于识别的意图，它们可以在您的应用程序中驱动进一步的行动。
- en: The speech domain contains three APIs that are outlined in the following sections.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 语音领域包含三个 API，将在以下部分中概述。
- en: Bing Speech
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Bing Speech
- en: Adding the **Bing Speech** API to your application allows you to convert speech
    to text and vice versa. You can convert spoken audio to text either by utilizing
    a microphone or other sources in real time or by converting audio from files.
    The API also offers speech intent recognition, which is trained by the **Language
    Understanding Intelligent Service** (**LUIS**) to understand the intent.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 将 **Bing Speech** API 添加到您的应用程序中，允许您将语音转换为文本，反之亦然。您可以通过利用麦克风或其他实时源或将音频文件转换为文本来实现将语音音频转换为文本。该
    API 还提供语音意图识别，这是由 **语言理解智能服务**（**LUIS**）训练的，以理解意图。
- en: Speaker recognition
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 说话人识别
- en: The **speaker** **recognition** API gives your application the ability to know
    who is talking. By using this API, you can verify that the person that is speaking
    is who they claim to be. You can also determine who an unknown speaker is based
    on a group of selected speakers.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**说话人** **识别** API 使您的应用程序能够知道谁在说话。通过使用此 API，您可以验证说话的人就是他们所声称的人。您还可以根据所选的说话人群体确定未知说话人。'
- en: Translator speech API
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 翻译语音 API
- en: The **translator speech** API is a cloud-based automatic translation service
    for spoken audio. Using this API, you can add end-to-end translation across web
    apps, mobile apps, and desktop applications. Depending on your use cases, it can
    provide you with partial translations, full translations, and transcripts of the
    translations cover all speech-related APIs in [Chapter 5](ch05.html "Chapter 5. Speaking
    with Your Application"), *Speak with Your Application*.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**翻译语音** API 是一个基于云的自动语音翻译服务。使用此 API，您可以在 Web 应用程序、移动应用程序和桌面应用程序中添加端到端翻译。根据您的用例，它可以为您提供部分翻译、完整翻译和翻译的转录本，涵盖所有与语音相关的
    API，在 [第 5 章](ch05.html "第 5 章。与应用程序对话") *与应用程序对话* 中。'
- en: Language
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 语言
- en: APIs that are related to the language domain allow your application to process
    natural language and learn how to recognize what users want. You can add textual
    and linguistic analysis to your application, as well as natural language understanding.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 与语言领域相关的 API 允许您的应用程序处理自然语言并学习如何识别用户的需求。您可以为您的应用程序添加文本和语言分析，以及自然语言理解。
- en: The following five APIs can be found in the language domain.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 以下五个 API 可在语言领域找到。
- en: Bing Spell Check
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Bing 拼写检查
- en: The **Bing Spell Check** API allows you to add advanced spell checking to your
    application.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '**Bing 拼写检查** API 允许您为您的应用程序添加高级拼写检查。'
- en: This API will be covered in [Chapter 6](ch06.html "Chapter 6. Understanding
    Text"), *Understanding Text*.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 此 API 将在 [第 6 章](ch06.html "第 6 章。理解文本") *理解文本* 中进行介绍。
- en: Language Understanding Intelligent Service (LUIS)
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 语言理解智能服务 (LUIS)
- en: LUIS is an API that can help your application understand commands from your
    users. Using this API, you can create language models that understand intents.
    By using models from Bing and Cortana, you can make these models recognize common
    requests and entities (such as places, times, and numbers). You can add conversational
    intelligence to your applications.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: LUIS 是一个可以帮助您的应用程序理解用户命令的 API。使用此 API，您可以创建理解意图的语言模型。通过使用 Bing 和 Cortana 的模型，您可以使得这些模型能够识别常见的请求和实体（如地点、时间和数字）。您可以为您的应用程序添加对话智能。
- en: LUIS will be covered in [Chapter 4](ch04.html "Chapter 4. Letting Applications
    Understand Commands"), *Let Applications Understand Commands*.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: LUIS 将在 [第 4 章](ch04.html "第 4 章。让应用程序理解命令") *让应用程序理解命令* 中进行介绍。
- en: Text analytics
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文本分析
- en: The **text analytics** API will help you in extracting information from text.
    You can use it to find the sentiment of a text (whether the text is positive or
    negative), and will also be able to detect the language, topic, key phrases, and
    entities that are used throughout the will also cover the text analysis API in
    [Chapter 6](ch06.html "Chapter 6. Understanding Text"), *Understanding Text*.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '**文本分析**API将帮助您从文本中提取信息。您可以使用它来查找文本的情感（文本是正面还是负面），并且还将能够检测语言、主题、关键词和实体，这些内容将在[第6章](ch06.html
    "第6章. 理解文本")*理解文本*中涵盖文本分析API。'
- en: Translator Text API
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 翻译文本API
- en: By adding the **translator text** API, you can get textual translations for
    over 60 languages. It can detect languages automatically, and you can customize
    the API to your needs. In addition, you can improve translations by creating user
    groups, utilizing the power of crowdsourcing.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加**翻译文本**API，您可以为超过60种语言获得文本翻译。它可以自动检测语言，并且您可以根据需要自定义API。此外，您可以通过创建用户组，利用众包的力量来提高翻译质量。
- en: The translator text API will not be covered in this book.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '**翻译文本API**在本书中不会介绍。'
- en: Knowledge
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 知识
- en: When we talk about **knowledge** APIs, we are talking about APIs that allow
    you to tap into rich knowledge. This may be knowledge from the web or from academia,
    or it may be your own data. Using these APIs, you will be able to explore the
    different nuances of knowledge.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论**知识**API时，我们指的是允许您利用丰富知识的API。这可能来自网络或学术界，或者可能是您自己的数据。使用这些API，您将能够探索知识的不同细微差别。
- en: The following four APIs are contained in the knowledge API domain.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 以下四个API包含在知识API领域。
- en: Project Academic Knowledge
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 项目学术知识
- en: Using the **Project** **Academic Knowledge** API, you can explore relationships
    among academic papers, journals, and authors. This API allows you to interpret
    natural language user query strings, which allows your application to anticipate
    what the user is typing. It will evaluate what is being typed and return academic
    knowledge entities.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**项目学术知识**API，您可以探索学术论文、期刊和作者之间的关系。此API允许您解释自然语言用户查询字符串，这使得您的应用程序能够预测用户正在输入的内容。它将评估正在输入的内容并返回学术知识实体。
- en: This API will be covered in more detail in [Chapter 8](ch08.html "Chapter 8. Querying
    Structured Data in a Natural Way"), *Query Structured Data in a Natural Way*.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 本API将在[第8章](ch08.html "第8章. 以自然方式查询结构化数据")*以自然方式查询结构化数据*中详细介绍。
- en: Knowledge exploration
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 知识探索
- en: The **knowledge exploration** API will let you add the possibility of using
    interactive searches for structured data in your projects. It interprets natural
    language queries and offers autocompletions to minimize user effort. Based on
    the query expression received, it will retrieve detailed information about matching
    objects.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '**知识探索**API将允许您在项目中添加使用交互式搜索结构化数据的功能。它解释自然语言查询并提供自动完成以减少用户工作量。根据接收到的查询表达式，它将检索有关匹配对象的详细信息。'
- en: Details on this API will be covered in [Chapter 8](ch08.html "Chapter 8. Querying
    Structured Data in a Natural Way"), *Query Structured Data in a Natural Way*.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 关于此API的详细信息将在[第8章](ch08.html "第8章. 以自然方式查询结构化数据")*以自然方式查询结构化数据*中介绍。
- en: Recommendations solution
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 推荐解决方案
- en: The **recommendations solution** API allows you to provide personalized product
    recommendations for your customers. You can use this API to add a frequently-bought-together
    functionality to your application. Another feature that you can add is item-to-item
    recommendations, which allows customers to see what other customers like. This
    API will also allow you to add recommendations based on the prior activity of
    the customer.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '**推荐解决方案**API允许您为您的客户提供个性化的产品推荐。您可以使用此API向您的应用程序添加经常一起购买的功能。您还可以添加另一个功能，即项目到项目的推荐，这允许客户看到其他客户喜欢的内容。此API还将允许您根据客户的先前活动添加推荐。'
- en: We will go through this API in [Chapter 7](ch07.html "Chapter 7. Building Recommendation
    Systems for Businesses"), *Building Recommendation Systems for Businesses*.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第7章](ch07.html "第7章. 为企业构建推荐系统")*为企业构建推荐系统*中介绍此API。
- en: QnA Maker
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: QnA Maker
- en: The **QnA Maker** is a service to distill information for frequently asked questions
    (FAQ). Using existing FAQs, either online or in a document, you can create question
    and answer pairs. Pairs can be edited, removed, and modified, and you can add
    several similar questions to match a given pair.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '**QnA Maker** 是一个用于提炼常见问题（FAQ）信息的服务。使用现有的 FAQ，无论是在线的还是文档中的，您都可以创建问题和答案对。可以对这些对进行编辑、删除和修改，并且您可以添加几个类似的问题以匹配给定的对。'
- en: We will cover QnA Maker in [Chapter 8](ch08.html "Chapter 8. Querying Structured
    Data in a Natural Way"), *Query Structured Data in a Natural Way*.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 [第 8 章](ch08.html "第 8 章。以自然方式查询结构化数据") *以自然方式查询结构化数据* 中介绍 QnA Maker。
- en: Project Custom Decision Service
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 项目自定义决策服务
- en: '**Project Custom Decision Service** is a service designed to use reinforced
    learning to personalize content. The service understands any context and can provide
    context-based content.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '**项目自定义决策服务** 是一个旨在使用强化学习来个性化内容的服务。该服务理解任何上下文，并能提供基于上下文的内容。'
- en: This book does not cover Project Custom Decision Service.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 本书不涉及项目自定义决策服务。
- en: Search
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 搜索
- en: '**Search** APIs give you the ability to make your applications more intelligent
    with the power of Bing. Using these APIs, you can use a single call to access
    data from billions of web pages, images, videos, and news articles.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '**搜索** API 使您能够利用 Bing 的力量使您的应用程序更加智能。使用这些 API，您可以通过单次调用访问来自数十亿网页、图片、视频和新闻文章的数据。'
- en: The search domain contains the following APIs.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索域包含以下 API。
- en: Bing Web Search
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Bing 网络搜索
- en: With **Bing Web Search**, you can search for details in billions of web documents
    that are indexed by Bing. All the results can be arranged and ordered according
    to a layout that you specify, and the results are customized to the location of
    the end user.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 **Bing 网络搜索**，您可以在 Bing 索引的数十亿网络文档中搜索详细信息。所有结果都可以根据您指定的布局进行排列和排序，并且结果会根据最终用户的地理位置进行定制。
- en: Bing Web Search will be covered in [Chapter 9](ch09.html "Chapter 9. Adding
    Specialized Searches"), *Adding Specialized Search*.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Bing 网络搜索将在 [第 9 章](ch09.html "第 9 章。添加专业搜索") *添加专业搜索* 中介绍。
- en: Bing Image Search
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Bing 图片搜索
- en: Using the **Bing Image Search** API, you can add an advanced image and metadata
    search to your application. Results include URLs to images, thumbnails, and metadata.
    You will also be able to get machine-generated captions, similar images, and more.
    This API allows you to filter the results based on image type, layout, freshness
    (how new the image is), and license. Bing Image Search will be covered in [Chapter
    9](ch09.html "Chapter 9. Adding Specialized Searches"), *Adding Specialized Search*.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 **Bing 图片搜索** API，您可以将高级图片和元数据搜索添加到您的应用程序中。结果包括图片的 URL、缩略图和元数据。您还将能够获取机器生成的标题、相似图片等。此
    API 允许您根据图片类型、布局、新鲜度（图片的新旧程度）和许可证筛选结果。Bing 图片搜索将在 [第 9 章](ch09.html "第 9 章。添加专业搜索")
    *添加专业搜索* 中介绍。
- en: Bing Video Search
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Bing 视频搜索
- en: '**Bing Video Search** will allow you to search for videos and return rich results.
    The results could contain metadata from the videos, static or motion-based thumbnails,
    and the video itself. You can add filters to the results based on freshness, video
    length, resolution, and price.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '**Bing 视频搜索** 将允许您搜索视频并返回丰富结果。结果可能包含视频的元数据、静态或基于运动的缩略图以及视频本身。您可以根据新鲜度、视频长度、分辨率和价格对结果添加过滤器。'
- en: Bing Video Search will be covered in [Chapter 9](ch09.html "Chapter 9. Adding
    Specialized Searches"), *Adding Specialized Search*.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Bing 视频搜索将在 [第 9 章](ch09.html "第 9 章。添加专业搜索") *添加专业搜索* 中介绍。
- en: Bing News Search
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Bing 新闻搜索
- en: If you add **Bing News Search** to your application, you can search for news
    articles. Results can include authoritative images, related news and categories,
    information on the provider, URLs, and more. To be more specific, you can filter
    news based on topics.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将 **Bing 新闻搜索** 添加到您的应用程序中，您可以搜索新闻文章。结果可以包括权威图片、相关新闻和类别、提供者信息、URL 等更多信息。具体来说，您可以根据主题对新闻进行筛选。
- en: Bing News Search will be covered in [Chapter 9](ch09.html "Chapter 9. Adding
    Specialized Searches"), *Adding Specialized Search*.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Bing 新闻搜索将在 [第 9 章](ch09.html "第 9 章。添加专业搜索") *添加专业搜索* 中介绍。
- en: Bing Autosuggest
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Bing 自动完成
- en: The **Bing Autosuggest** API is a small but powerful one. It will allow your
    users to search faster using their search suggestions, allowing you to connect
    a powerful search functionality to your apps.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '**Bing 自动完成** API 是一个小巧但功能强大的 API。它将允许您的用户通过搜索建议更快地搜索，使您能够将强大的搜索功能连接到您的应用程序中。'
- en: Bing Autosuggest will be covered in [Chapter 9](ch09.html "Chapter 9. Adding
    Specialized Searches"), *Adding Specialized Search*.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 必应自动完成将在[第9章](ch09.html "第9章。添加专业搜索")*添加专业搜索*中介绍。
- en: Bing Visual Search
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 必应视觉搜索
- en: Using the **Bing Visual Search** API, you can identify and classify images.
    You can also acquire knowledge about images.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**必应视觉搜索**API，您可以识别和分类图像。您还可以获取有关图像的知识。
- en: Bing Visual Search will be covered in [Chapter 9](ch09.html "Chapter 9. Adding
    Specialized Searches"), *Adding Specialized Search*.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 必应视觉搜索将在[第9章](ch09.html "第9章。添加专业搜索")*添加专业搜索*中介绍。
- en: Bing Custom Search
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 必应自定义搜索
- en: By utilizing the **Bing Custom Search** API, you can create a powerful, customized
    search that fits your needs. This tool is an ad-free commercial tool that allows
    you to deliver the search results you want.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用**必应自定义搜索**API，您可以创建一个强大、定制的搜索，满足您的需求。这个工具是一个无广告的商业工具，允许您提供您想要的搜索结果。
- en: Bing Custom Search will be covered in [Chapter 9](ch09.html "Chapter 9. Adding
    Specialized Searches"), *Adding Specialized Search*.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 必应自定义搜索将在[第9章](ch09.html "第9章。添加专业搜索")*添加专业搜索*中介绍。
- en: Bing Entity Search
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 必应实体搜索
- en: Using the **Bing Entity Search** API, you can enhance your searches. The API
    will find the most relevant entity based on your search terms. It will find entities
    such as famous people, places, movies, and more.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**必应实体搜索**API，您可以增强您的搜索。该API将根据您的搜索词找到最相关的实体。它将找到诸如名人、地点、电影等实体。
- en: We will not cover Bing Entity Search in this book.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将不会在本书中介绍必应实体搜索。
- en: Getting feedback on detected faces
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取检测到的面部反馈
- en: Now that we have seen what else Microsoft Cognitive Services can offer, we are
    going to add an API to our face detection application. In this section, we will
    add the Bing Speech API to make the application say the number of faces out loud.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了微软认知服务还能提供什么，我们将向我们的面部检测应用程序添加一个API。在本节中，我们将添加必应语音API，使应用程序能够大声说出面部数量。
- en: This feature of the API is not provided in the NuGet package, and as such, we
    are going to use the REST API.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 此API功能在NuGet包中未提供，因此我们将使用REST API。
- en: To reach our end goal, we are going to add two new classes, `TextToSpeak` and
    `Authentication`. The first class will be in charge of generating the correct
    headers and making the calls to our service endpoint. The latter class will be
    in charge of generating an authentication token. This will be tied together in
    our `ViewModel`, where we will make the application speak back to us.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 为了达到我们的最终目标，我们将添加两个新的类，`TextToSpeak`和`Authentication`。第一个类将负责生成正确的头信息并调用我们的服务端点。后者类将负责生成认证令牌。这些将在我们的`ViewModel`中结合在一起，我们将使应用程序能够对我们说话。
- en: We need to get our hands on an API key first. Head over to the Microsoft Azure
    Portal. Create a new service for Bing Speech.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要获取一个API密钥。前往微软Azure门户。为必应语音创建一个新的服务。
- en: To be able to call the Bing Speech API, we need to have an authorization token.
    Go back to Visual Studio and create a new file called `Authentication.cs`. Place
    this in the `Model` folder.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够调用必应语音API，我们需要一个授权令牌。回到Visual Studio，创建一个名为`Authentication.cs`的新文件。将其放在`Model`文件夹中。
- en: We need to add two new references to the project. Find the `System.Runtime.Serialization`
    and `System.Web` packages in the **Assembly** tab in the **Add References** window
    and add them.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要向项目添加两个新的引用。在**添加引用**窗口的**组件**选项卡中找到`System.Runtime.Serialization`和`System.Web`包，并将它们添加。
- en: 'In our `Authentication` class, define four `private` variables and one `public`
    property, as follows:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`Authentication`类中，定义四个`private`变量和一个`public`属性，如下所示：
- en: '[PRE24]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The constructor should accept one string parameter, `clientSecret`. The `clientSecret`
    parameter is the API key you signed up for.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数应接受一个字符串参数，`clientSecret`。`clientSecret`参数是您注册的API密钥。
- en: 'In the constructor, assign the `_clientSecret` variable, as follows:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，按照以下方式分配`_clientSecret`变量：
- en: '[PRE25]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Create a new function called `Initialize`, as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`Initialize`的新函数，如下所示：
- en: '[PRE26]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We then fetch the access token in a method that we will create shortly.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在稍后创建的方法中获取访问令牌。
- en: Finally, we create our `timer` class, which will call the `callback` function
    in nine minutes. The `callback` function will need to fetch the access token again
    and assign it to the `_token` variable. It also needs to ensure that we run the
    timer again in nine minutes.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们创建我们的`timer`类，它将在九分钟后调用`callback`函数。`callback`函数需要再次获取访问令牌并将其分配给`_token`变量。它还需要确保我们在九分钟后再次运行计时器。
- en: Next, we need to create the `GetToken` method. This method should return a `Task<string>`object,
    and it should be declared as `private` and marked as `async`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建`GetToken`方法。此方法应返回一个`Task<string>`对象，并且应声明为`private`并标记为`async`。
- en: 'In the method, we start by creating an `HttpClient` object, pointing to an
    endpoint that will generate our token. We specify the root endpoint and add the
    token issue path, as follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法中，我们首先创建一个`HttpClient`对象，指向将生成令牌的端点。我们指定根端点并添加令牌发行路径，如下所示：
- en: '[PRE27]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We then go on to make a POST call to generate a token, as follows:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们继续进行POST调用以生成令牌，如下所示：
- en: '[PRE28]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'When the request has been sent, we expect there to be a response. We want to
    read this response and return the response string:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 当请求发送后，我们期望有一个响应。我们想要读取这个响应并返回响应字符串：
- en: '[PRE29]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Add a new file called `TextToSpeak.cs`, if you have not already done so. Put
    this file in the `Model` folder.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有这样做，请添加一个名为`TextToSpeak.cs`的新文件。将此文件放在`Model`文件夹中。
- en: Beneath the newly created class (but inside the namespace), we want to add two
    event argument classes. These will be used to handle audio events, which we will
    see later.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在新创建的类（但位于命名空间内部）下方，我们想要添加两个事件参数类。这些将被用来处理音频事件，我们将在后面看到。
- en: 'The `AudioEventArgs` class simply takes a generic `stream`, as shown in the
    following code. You can imagine it being used to send the audio stream to our
    application:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`AudioEventArgs`类简单地接受一个泛型`stream`，如下面的代码所示。你可以想象它被用来将音频流发送到我们的应用程序：'
- en: '[PRE30]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The next class allows us to send an event with a specific error message:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个类允许我们发送带有特定错误消息的事件：
- en: '[PRE31]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We move on to start on the `TextToSpeak` class, where we start off by declaring
    some events and class members, as follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续开始`TextToSpeak`类的编写，首先声明一些事件和类成员，如下所示：
- en: '[PRE32]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The first two lines in the class are events that use the event argument classes
    that we created earlier. These events will be triggered if a call to the API finishes
    (returning some audio), or if anything fails. The next few lines are string variables,
    which we will use as input parameters. We have one line to contain our access
    token information. The last line creates a new list, which we will use to hold
    our request headers.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 类中的前两行是使用我们之前创建的事件参数类的事件。如果API调用完成（返回一些音频）或发生任何错误时，这些事件将被触发。接下来的几行是字符串变量，我们将用作输入参数。我们有一行用于包含我们的访问令牌信息。最后一行创建了一个新列表，我们将用它来存储我们的请求头。
- en: 'We add two constant strings to our class, as follows:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向我们的类中添加了两个常量字符串，如下所示：
- en: '[PRE33]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The first string contains the request URI. That is the REST API endpoint that
    we need to call to execute our request. Next, we have a string defining our **Speech
    Synthesis Markup Language** (**SSML**) template. This is where we will specify
    what the speech service should say, and how it should say it.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个字符串包含请求URI。这是我们执行请求需要调用的REST API端点。接下来，我们有一个定义我们的**语音合成标记语言**（**SSML**）模板的字符串。这是我们指定语音服务应该说什么，以及如何说的地方。
- en: 'Next, we create our constructor, as follows:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建我们的构造函数，如下所示：
- en: '[PRE34]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Here, we are just initializing some of the variables that we declared earlier.
    As you may see, we are defining the voice as female and we define it so that it
    uses a specific voice. In terms of gender, it can be either female or male. The
    voice name can be one of a long list of options. We will look more into the details
    of that list when we go through this API in a later chapter.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只是在初始化我们之前声明的某些变量。如您所见，我们正在定义声音为女性，并定义它使用特定的声音。在性别方面，可以是女性或男性。声音名称可以是长列表中的一个选项。我们将在稍后的章节中更详细地了解该列表的细节。
- en: The last line specifies the output format of the audio. This will define the
    format and codec in use by the resultant audio stream. Again, this can be a number
    of varieties, which we will look into in a later chapter.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行指定了音频的输出格式。这将定义结果音频流的格式和编解码器。同样，这可以有多种选择，我们将在后面的章节中探讨。
- en: Following the constructor, there are three public methods that we will create.
    These will generate an authentication token and some HTTP headers, and finally
    execute our call to the API. Before we create these, you should add two helper
    methods to be able to raise our events. Call them the `RaiseOnAudioAvailable`
    and `RaiseOnError` methods. They should accept `AudioEventArgs` and `AudioErrorEventArgs`
    as parameters.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数之后，我们将创建三个公共方法。这些方法将生成一个认证令牌和一些HTTP头信息，并最终执行我们对API的调用。在我们创建这些方法之前，你应该添加两个辅助方法来能够引发我们的事件。将它们命名为`RaiseOnAudioAvailable`和`RaiseOnError`方法。它们应该接受`AudioEventArgs`和`AudioErrorEventArgs`作为参数。
- en: 'Next, add a new method called the `GenerateHeaders` method, as follows:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，添加一个名为`GenerateHeaders`的新方法，如下所示：
- en: '[PRE35]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Here, we add the HTTP headers to our previously created list. These headers
    are required for the service to respond, and if any are missing, it will yield
    an `HTTP/400` response. We will cover what we are using as headers in more detail
    later. For now, just make sure that they are present.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将HTTP头信息添加到我们之前创建的列表中。这些头信息对于服务响应是必需的，如果缺少任何，它将返回`HTTP/400`响应。我们将在稍后更详细地介绍我们使用哪些头信息。现在，只需确保它们存在即可。
- en: 'Following this, we want to add a new method called `GenerateAuthenticationToken`,
    as follows:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，我们想要添加一个名为`GenerateAuthenticationToken`的新方法，如下所示：
- en: '[PRE36]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This method accepts one string parameter, the client secret (your API key).
    First, we create a new object of the `Authentication` class, which we looked at
    earlier, as follows:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法接受一个字符串参数，即客户端密钥（你的API密钥）。首先，我们创建一个`Authentication`类的新对象，这是我们之前看过的，如下所示：
- en: '[PRE37]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We use the authentication object to retrieve an access token. This token is
    used in our authorization token string, which, as we saw earlier, is being passed
    on in our headers. If the application for some reason fails to generate the access
    token, we trigger an error event.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用认证对象来检索访问令牌。这个令牌用于我们的授权令牌字符串，正如我们之前看到的，它被包含在我们的头信息中。如果应用程序由于某种原因无法生成访问令牌，我们将触发一个错误事件。
- en: Finish this method by adding the associated catch clause. If any exceptions
    occur, we want to raise a new error event.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加相关的`catch`子句来完成这个方法。如果发生任何异常，我们希望引发一个新的错误事件。
- en: 'The last method that we need to create in this class is going to be called
    the `SpeakAsync` method, as shown in the following screenshot. This method will
    actually perform the request to the Speech API:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类中，我们需要创建的最后一个方法将被命名为`SpeakAsync`方法，如下面的截图所示。这个方法实际上会向语音API发起请求：
- en: '[PRE38]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The method takes two parameters. One is the string, which will be the text that
    we want to be spoken. The next is `cancellationToken`; this can be used to propagate
    the command that the given operation should be cancelled.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法接受两个参数。一个是字符串，它将是我们要被读出的文本。下一个是`cancellationToken`；这可以用来传播给定操作应该被取消的命令。
- en: When entering the method, we create three objects that we will use to execute
    the request. These are classes from the .NET library. We will not be going through
    them in any more detail.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 进入方法时，我们创建了三个我们将用于执行请求的对象。这些是从.NET库中的类。我们不会对它们进行更详细的介绍。
- en: 'We generated some headers earlier, and we need to add these to our HTTP client.
    We do this by adding the headers in the preceding `foreach` loop, basically looping
    through the entire list, as shown in the following code:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前生成了一些头信息，我们需要将这些添加到我们的HTTP客户端中。我们通过在先前的`foreach`循环中添加头信息来实现，基本上是遍历整个列表，如下面的代码所示：
- en: '[PRE39]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Next, we create an `HTTP Request Message`, specifying the request URI and the
    fact that we will send data through the `POST` method. We also specify the content
    using the SSML template that we created earlier, adding the correct parameters
    (gender, voice name, and the text we want to be spoken), as shown in the following
    code:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个`HTTP 请求消息`，指定请求URI以及我们将通过`POST`方法发送数据的事实。我们还使用我们之前创建的SSML模板指定内容，添加正确的参数（性别、语音名称和要被读出的文本），如下面的代码所示：
- en: '[PRE40]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We use the HTTP client to send the HTTP request asynchronously, as follows:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用HTTP客户端异步发送HTTP请求，如下所示：
- en: '[PRE41]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The following code is a continuation of the asynchronous send call that we
    made previously. This will run asynchronously as well, and check the status of
    the response. If the response is successful, it will read the response message
    as a stream and trigger the audio event. If everything succeeds, then that stream
    should contain our text in spoken words:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是之前我们进行的异步发送调用的延续。这将异步运行，并检查响应的状态。如果响应成功，它将作为流读取响应消息并触发音频事件。如果一切顺利，那么该流应该包含我们用语音说的文本：
- en: '[PRE42]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: If the response indicates anything other than success, we will raise the error
    event.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 如果响应指示的不是成功，我们将引发错误事件。
- en: We also want to add a catch clause and a `finally` clause to this. Raise an
    error if an exception is caught and dispose of all objects used in the `finally`
    clause.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望为此添加一个`catch`子句和一个`finally`子句。如果在`finally`子句中捕获到异常，则引发错误并销毁所有使用的对象。
- en: 'The final code we need specifies that the continuation task is attached to
    the parent task. We also need to add `cancellationToken` to this task. Add the
    following code to finish off the method:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的最终代码指定了延续任务附加到父任务上。我们还需要向此任务添加`cancellationToken`。添加以下代码来完成方法：
- en: '[PRE43]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'With this in place, we are now able to utilize this class in our application.
    Open the `MainViewModel.cs` file and declare a new class variable, as follows:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在此基础上，我们现在可以在我们的应用程序中利用这个类。打开`MainViewModel.cs`文件，并声明一个新的类变量，如下所示：
- en: '[PRE44]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Add the following code in the constructor to initialize the newly added object.
    We also need to call a function to generate the authentication token, as follows:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中添加以下代码以初始化新添加的对象。我们还需要调用一个函数来生成认证令牌，如下所示：
- en: '[PRE45]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'After we have created the object, we hook up the two events to event handlers.
    Then we generate an authentication token by creating a `GenerateToken` function
    with the following content:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们创建了对象之后，我们将两个事件连接到事件处理器上。然后，我们通过创建一个包含以下内容的`GenerateToken`函数来生成一个认证令牌：
- en: '[PRE46]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Then we generate an authentication token, specifying the API key for the Bing
    Speech API. If that call succeeds, we generate the HTTP headers required.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们生成一个认证令牌，指定必应语音API的API密钥。如果该调用成功，我们生成所需的HTTP头。
- en: 'We need to add the event handlers, so create the `_textToSpeak_OnError` method
    first, as follows:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要添加事件处理器，因此首先创建`_textToSpeak_OnError`方法，如下所示：
- en: '[PRE47]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: It should be a rather simple method, just outputting the error message to the
    user in the status text field.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该是一个相当简单的方法，只需将错误消息输出到用户的状态文本字段即可。
- en: 'Next, we need to create a `_textToSpeak_OnAudioAvailable` method, as follows:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建一个`_textToSpeak_OnAudioAvailable`方法，如下所示：
- en: '[PRE48]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Here, we utilize the `SoundPlayer` class from the .NET framework. This allows
    us to add the stream data directly and simply play the message.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们利用.NET框架中的`SoundPlayer`类。这允许我们直接添加流数据并简单地播放消息。
- en: 'The last part that we need for everything to work is to make the call to the
    `SpeakAsync` method. We can make this by adding the following at the end of our
    `DetectFace` method:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让一切正常工作，我们需要调用`SpeakAsync`方法。我们可以在`DetectFace`方法的末尾添加以下内容来实现这一点：
- en: '[PRE49]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: With that in place, you should now be able to compile and run the application.
    By loading a photo and clicking on **Detect face**, you should be able to get
    the number of faces in the image spoken back to you. Just remember to have your
    audio turned on!
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在此基础上，你现在应该能够编译并运行应用程序。通过加载一张照片并点击**检测面部**，你应该能够听到图像中面部数量的语音反馈。只需记得打开你的音频即可！
- en: Summary
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter was a brief introduction to Microsoft Cognitive Services. We started
    off by creating a template project to easily create new projects for the coming
    chapters. We tried this template by creating an example project for this chapter.
    Then you learned how to detect faces in images by utilizing the Face API. From
    there, we took a quick tour of what Cognitive Services has to offer. We finished
    off by adding text-to-speech capabilities to our application by using the Bing
    Speech API.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 本章简要介绍了微软认知服务。我们首先创建了一个模板项目，以便为即将到来的章节轻松创建新项目。我们通过为本章创建一个示例项目来尝试这个模板。然后，你学习了如何通过利用面部API在图像中检测面部。从那里，我们快速浏览了认知服务提供的内容。最后，我们通过使用必应语音API为我们的应用程序添加了文本到语音的功能。
- en: The next chapter will go into more detail of the vision part of the APIs. There,
    you will learn how to analyze images using the computer vision API. You will go
    into more detail about the Face API and will learn how to detect emotions in faces
    by using the emotion API. We will use some of this to start building our smart-house
    application.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将详细介绍API的视觉部分。在那里，你将学习如何使用计算机视觉API分析图像。你将更深入地了解面部API，并学习如何通过使用情感API来检测面部表情。我们将利用这些知识开始构建我们的智能家居应用程序。
