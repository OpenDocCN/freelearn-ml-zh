<html><head></head><body><div class="chapter" title="Chapter&#xA0;6.&#xA0;Understanding Text"><div class="titlepage"><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Understanding Text</h1></div></div></div><p>The previous chapter covered the speech APIs. Throughout this chapter, we will look closer at more language APIs. We will learn how to use spellcheck features. We will then discover how to detect languages, key phrases, and sentiment in text. Finally, we will look at the translator text API to see how we can detect languages and translate text.</p><p>By the end of this chapter, we will have covered the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Checking spelling and recognizing slang and informal language, common names, homonyms, and brands</li><li class="listitem" style="list-style-type: disc">Detecting language, key phrases, and sentiment in text</li><li class="listitem" style="list-style-type: disc">Translating text on the fly</li></ul></div><div class="section" title="Setting up a common core"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec35"/>Setting up a common core</h1></div></div></div><p>Before we get into the<a class="indexterm" id="id357"/> details, we want to set ourselves up for success. At the time of writing, none of the language APIs that we will be covering have NuGet client packages. As such, we will need to call directly to the REST endpoints. Because of this, we will do some work beforehand to make sure that we get away with writing less code.</p><div class="section" title="New project"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec48"/>New project</h2></div></div></div><p>We will not be <a class="indexterm" id="id358"/>adding the APIs to our smart-house application. Using the following steps, create a new project using the MVVM template that we created in <a class="link" href="ch01.html" title="Chapter 1. Getting Started with Microsoft Cognitive Services">Chapter 1</a>, <span class="emphasis"><em>Getting Started with Microsoft Cognitive Services</em></span>:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Go into the NuGet package manager and install <code class="literal">Newtonsoft.Json</code>. This will help us deserialize API responses and serialize request bodies.</li><li class="listitem">Right-click on <span class="strong"><strong>References</strong></span>.</li><li class="listitem">In the <span class="strong"><strong>Assemblies</strong></span> tab, select <span class="strong"><strong>System.Web</strong></span> and <span class="strong"><strong>System.Runtime.Serialization</strong></span>.</li><li class="listitem">Click <span class="strong"><strong>OK</strong></span>.</li><li class="listitem">In the <code class="literal">MainView.xaml</code> file, add a <code class="literal">TabControl</code> element. All our additional views will be added as <code class="literal">TabItems</code> in the <code class="literal">MainView</code>.</li></ol></div></div><div class="section" title="Web requests"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec49"/>Web requests</h2></div></div></div><p>All the APIs follow<a class="indexterm" id="id359"/> the same pattern. They call on their respective endpoints using either <code class="literal">POST</code> or <code class="literal">GET</code> requests. Further on, they pass on parameters as query strings, and some as request bodies. Since they have these similarities, we can create one class that will handle all API requests.</p><p>In the <code class="literal">Model</code> folder, add a new class and call it <code class="literal">WebRequest</code>.</p><p>We also need a few <code class="literal">private</code> variables, as follows:</p><div class="informalexample"><pre class="programlisting">    private const string JsonContentTypeHeader = "application/json";

    private static readonly JsonSerializerSettings _settings = new JsonSerializerSettings
    {
        DateFormatHandling = DateFormatHandling.IsoDateFormat,
        NullValueHandling = NullValueHandling.Ignore,
        ContractResolver = new CamelCasePropertyNamesContractResolver()
    };

    private HttpClient _httpClient;
    private string _endpoint;</pre></div><p>The constant, <code class="literal">JsonContentTypeHeader</code>, defines the content type that we want to use for all API calls. The <code class="literal">_settings</code> phrase is a <code class="literal">JsonSerializerSettings</code> object, which specifies how we want JSON data to be (de)serialized.</p><p>The <code class="literal">_httpClient</code> is the object that will be used to make our API requests. The last member, <code class="literal">_endpoint</code>, will hold the API endpoint.</p><p>As shown in the following code, our constructor will accept two parameters: one string for the URI, and one string for the API key:</p><div class="informalexample"><pre class="programlisting">    public WebRequest(string uri, string apiKey)
    {
        _endpoint = uri;
               
        _httpClient = new HttpClient();
        _httpClient.DefaultRequestHeaders.Add("Ocp-Apim-Subscription-Key", apiKey);
    }</pre></div><p>We assign the <code class="literal">uri</code> to the corresponding member. Next, we create a new object of a <code class="literal">HttpClient </code>type and add one request header. This is the header that contains the given <code class="literal">apiKey</code>.</p><p>The class will <a class="indexterm" id="id360"/>contain one function, <code class="literal">MakeRequest</code>. This should have the return type of <code class="literal">Task&lt;TResponse&gt;</code>, meaning a type that we specify when calling the function. As you can see in the following code, it should accept three parameters: a <code class="literal">HttpMethod</code>, a query <code class="literal">string</code>, and a <code class="literal">TRequest</code>, (which is a request body that we specify in the call). The function should be asynchronous:</p><div class="informalexample"><pre class="programlisting">public async Task &lt;TResponse&gt; MakeRequest &lt;TRequest, TResponse (HttpMethod method, string queryString, TRequest requestBody = default(TRequest))</pre></div><p>The preceding lines show the complete function signature. Note how we do not need to specify a request body, as there are some cases where it may be empty. We will cover what <code class="literal">TRequest</code> and <code class="literal">TResponse</code> may be in a bit.</p><p>We enter a <code class="literal">try</code> clause, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">    try {
        string url = $"{_endpoint}{queryString}";
        var request = new HttpRequestMessage(method, url);

        if (requestBody != null)
            request.Content = new StringContent (JsonConvert.SerializeObject(requestBody, _settings), Encoding.UTF8, JsonContentTypeHeader);

        HttpResponseMessage response = await _httpClient.SendAsync(request);</pre></div><p>First, we create a <code class="literal">url</code>, consisting of our <code class="literal">_endpoint</code> and the <code class="literal">queryString</code>. Using this and the specified <code class="literal">method</code>, we create a <code class="literal">HttpRequestMessage</code> object.</p><p>If we have a <code class="literal">requestBody</code>, we add <code class="literal">Content</code> to the <code class="literal">request</code> object by serializing the <code class="literal">requestBody</code>.</p><p>With the request in order, we make an asynchronous call to <code class="literal">SendAsync</code> on the <code class="literal">_httpClient</code> object. This will call the API endpoint, returning a <code class="literal">HttpResponseMessage</code> containing the response.</p><p>If the <code class="literal">response</code> is successful, we want to get the <code class="literal">Content</code> as a string. This is done as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Make an asynchronous call to <code class="literal">ReadAsStringAsync</code>. This will return a string.</li><li class="listitem">Deserialize the string as a <code class="literal">TResponse</code> object.</li><li class="listitem">Return the deserialized object to the caller.</li></ol></div><p>In the case<a class="indexterm" id="id361"/> that there is no data in <code class="literal">responseContent</code>, we return a default <code class="literal">TResponse</code>. This will contain default values for all properties, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">    if (response.IsSuccessStatusCode)
    {
        string responseContent = null;
       
        if (response.Content != null)
            responseContent = await response.Content.ReadAsStringAsync();
        if (!string.IsNullOrWhiteSpace(responseContent))
            return JsonConvert.DeserializeObject&lt;TResponse&gt;(responseContent,_settings);

        return default(TResponse);
    }</pre></div><p>If the API response contains any error code, then we try to get the error message as a string (<code class="literal">errorObjectString</code>). In a typical application, you would want to deserialize this and propagate it to the user. However, as this is a simple example application, we will choose to output it to the <code class="literal">Debug</code> console window, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">    else
    {
        if (response.Content != null &amp;&amp; response.Content.Headers.ContentType.MediaType.Contains (JsonContentTypeHeader))
        {
            var errorObjectString = await response.Content.ReadAsStringAsync();
            Debug.WriteLine(errorObjectString);
        }
    }</pre></div><p>Make sure you add the corresponding <code class="literal">catch</code> clause and output any exceptions to the <code class="literal">Debug</code> console window. Also, make sure that you return a default <code class="literal">TResponse</code> if any exceptions occur.</p></div><div class="section" title="Data contracts"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec50"/>Data contracts</h2></div></div></div><p>As we<a class="indexterm" id="id362"/> need to (de)serialize JSON data as a part of the requests and responses to the APIs, we need to create data contracts. These will act as the <code class="literal">TResponse</code> and <code class="literal">TRequest</code> objects, used in the <code class="literal">WebRequest</code> class.</p><p>Add a new folder called <code class="literal">Contracts</code> to the project. A typical data contract may look like the following:</p><div class="informalexample"><pre class="programlisting">    [DataContract]
    public class TextErrors {
       [DataMember]
       public string id { get; set; }

       [DataMember]
       public string message { get; set; }
    }</pre></div><p>This correlates to <a class="indexterm" id="id363"/>errors in the text analytics API. As you can see, it has two string properties for <code class="literal">id</code> and <code class="literal">message</code>. Both may appear in an API response.</p><p>When discussing each API, we will see all request and response parameters in either table form or JSON format. We will not look at how each of these translates into a data contract, but it will take a similar form to that previously shown. It is then up to you to create the contracts needed.</p><p>The most important thing to note is that the property names must be identical to the corresponding JSON property.</p><p>Make sure that the code compiles and that you can run the application before continuing.</p></div></div></div>
<div class="section" title="Correcting spelling errors"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec36"/>Correcting spelling errors</h1></div></div></div><p>The Bing Spell<a class="indexterm" id="id364"/> Check API leverages the power of machine learning and statistical machine translation to train and evolve a highly contextual algorithm for spellchecking. Doing so allows us to utilize this to perform spellchecking using context.</p><p>A typical spellchecker will follow dictionary-based rule sets. As you can imagine, this will need continuous updates and expansions.</p><p>Using the Bing Spell Check API, we can recognize and correct slang and informal language. It can recognize common naming errors and correct word-breaking issues. It can detect and correct words that sound the same, but differ in meaning and spelling (homophones). It can also detect and correct brands and popular expressions.</p><p>Create a new <code class="literal">View</code> in the <code class="literal">View</code> folder; call the file <code class="literal">SpellCheckView.xaml</code>. Add a <code class="literal">TextBox</code> element for the input query. We will also need two <code class="literal">TextBox</code> elements for the pre- and post-context. Add a <code class="literal">TextBox</code> element to show the result and a <code class="literal">Button</code> element to execute the spellcheck.</p><p>Add a new <code class="literal">ViewModel</code> in the folder named <code class="literal">ViewModel</code>; call the file <code class="literal">SpellCheckViewModel.cs</code>. Make the class <code class="literal">public</code>, and let it inherit from the <code class="literal">ObservableObject</code> class. Add the following <code class="literal">private</code> member:</p><div class="informalexample"><pre class="programlisting">    private WebRequest _webRequest;</pre></div><p>This is the <code class="literal">WebRequest</code> class that we created earlier.</p><p>We need properties corresponding to our <code class="literal">View</code>. This means that we need four <code class="literal">string</code> properties and one <code class="literal">ICommand</code> property.</p><p>If you have not already<a class="indexterm" id="id365"/> done so, register for a free API key at <a class="ulink" href="https://portal.azure.com">https://portal.azure.com</a>.</p><p>The constructor should look like the following:</p><div class="informalexample"><pre class="programlisting">    public SpellCheckViewModel()
    {
        _webRequest = new WebRequest ("https://api.cognitive.microsoft.com/bing/v7.0/spellcheck/?", "API_KEY_HERE");
        ExecuteOperationCommand = new DelegateCommand(
        ExecuteOperation, CanExecuteOperation);
    }</pre></div><p>We create a new object of a <code class="literal">WebRequest</code> type, specifying the Bing Spell Check API endpoint and the API key. We also create a new <code class="literal">DelegateCommand</code> for our <code class="literal">ExecuteOperationCommand</code>, <code class="literal">ICommand</code>, property.</p><p>The <code class="literal">CanExecuteOperation</code> property should return <code class="literal">true</code> if our input query is filled in and <code class="literal">false</code> otherwise.</p><p>To execute a call to the API, we do the following:</p><div class="informalexample"><pre class="programlisting">    private async void ExecuteOperation(object obj)
    {
        var queryString = HttpUtility.ParseQueryString(string.Empty);

        queryString["text"] = InputQuery;
        queryString["mkt"] = "en-us";
        //queryString["mode"] = "proof";

        if (!string.IsNullOrEmpty(PreContext)) queryString["preContextText"] = PreContext;

        if(!string.IsNullOrEmpty(PostContext))
      queryString["postContextText"] = PostContext;</pre></div><p>First, we create a <code class="literal">queryString</code> using <code class="literal">HttpUtility</code>. This will format the string so that it can be used in a URI.</p><p>As we will be calling the API using a <code class="literal">GET</code> method, we need to specify all parameters in the string. The required parameters are <code class="literal">text</code> and <code class="literal">mkt</code>, which are the input query and language, respectively. If we have entered <code class="literal">PreContext</code> and/or <code class="literal">PostContext</code>, then we add these parameters as well. We will look at the different parameters in more detail in a bit.</p><p>To make the request, we need to make the following call:</p><div class="informalexample"><pre class="programlisting">        SpellCheckResponse response = await _webRequest.MakeRequest &lt;object, SpellCheckResponse&gt;(HttpMethod.Get, queryString.ToString());
        ParseResults(response);
    }</pre></div><p>We call <code class="literal">MakeRequest</code> on the <code class="literal">_webRequest</code> object. As we are making a <code class="literal">GET</code> request, we do not need any request<a class="indexterm" id="id366"/> body, and we pass on <code class="literal">object</code> as <code class="literal">TRequest</code>. We expect a <code class="literal">SpellCheckResponse</code> contract in return. This will contain the resultant data, and we will look at the parameters in greater detail in a bit.</p><p>When we have a response, we pass that on to a function to parse it, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">    private void ParseResults(SpellCheckResponse response)
    {
        if(response == null || response.flaggedTokens == null || response.flaggedTokens.Count == 0)
        {
            Result = "No suggestions found";
            return;
        }

        StringBuilder sb = new StringBuilder();
        sb.Append("Spell checking results:nn");</pre></div><p>If we do not have any response, we exit the function. Otherwise, we create a <code class="literal">StringBuilder</code> to format the results, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">    foreach (FlaggedTokens tokens in response.flaggedTokens)
    {
        if (!string.IsNullOrEmpty(tokens.token))
            sb.AppendFormat("Token is: {0}n", tokens.token);

        if(tokens.suggestions != null || tokens.suggestions.Count != 0)
        {
            foreach (Suggestions suggestion in tokens.suggestions)
            {
                sb.AppendFormat("Suggestion: {0} - with score: {1}n", suggestion.suggestion, suggestion.score);
            }
            sb.Append("n");
        }
    }
    Result = sb.ToString();</pre></div><p>If we have any corrected spellings, we loop through them. We add all suggestions to the <code class="literal">StringBuilder</code>, making sure<a class="indexterm" id="id367"/> that we add the likelihood of the suggestion being correct. At the end, we make sure that we output the result to the UI.</p><p>The following table describes all the parameters we can add to the API call:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Parameter</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">text</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The text that we want to check for spelling and grammar errors.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">mode</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The current mode of the spellcheck. It can be either of the following:</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Proof</strong></span>: Spelling corrections for long queries, as typically used in MS Word.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Spell</strong></span>: Used for search engine corrections. Can be used for queries up to nine words long (tokens).</li></ul></div>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">preContextText</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The string that gives context to the text. The petal parameter is valid, but if you specify bike in this parameter, it will be corrected to pedal.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">postContextText</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The string that gives context to the text. The read parameter is valid, but if you specify carpet in this parameter, it may be corrected to red.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">mkt</code>
</p>
</td><td style="text-align: left" valign="top">
<p>For proof mode, the language must be specified. It can currently be en-us, es-es, or pt-br. For spell mode, all language codes are supported.</p>
</td></tr></tbody></table></div><p>A successful response will be a JSON response, containing the following:</p><div class="informalexample"><pre class="programlisting">    {
        "_type": "SpellCheck",
        "flaggedTokens": [
        {
            "offset": 5,
            "token": "Gatas",
            "type": "UnknownToken",
            "suggestions": [
            {
                "suggestion": "Gates",
                "score": 1
            }]
        }]
    }</pre></div><p>The <code class="literal">offset</code> is where the word appears in the text and <code class="literal">token</code> is the word that contains the error, while <code class="literal">type</code> describes the type of error. The <code class="literal">suggestions</code> phrase contains an array with the suggested <a class="indexterm" id="id368"/>correction and the probability of it being correct.</p><p>When the <code class="literal">View</code> and <code class="literal">ViewModel</code> have been correctly initialized, as seen in previous chapters, we should be able to compile and run the example.</p><p>An example output of running a spellcheck may give the following result:</p><div class="mediaobject"><img alt="Correcting spelling errors" src="graphics/B12373_06_01.jpg"/></div></div>
<div class="section" title="Extracting information through textual analysis"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec37"/>Extracting information through textual analysis</h1></div></div></div><p>Using the <span class="strong"><strong>text analytics</strong></span> API, we are<a class="indexterm" id="id369"/> able to analyze text. We will cover language detection, key-phrase analysis, and sentiment analysis. In addition, a new feature is the ability to detect topics. This does, however, require a lot of sample text, and as such, we will not go into detail on this last feature.</p><p>For all our text-analysis tasks, we will be using a new <code class="literal">View</code>. Add a new <code class="literal">View</code> into the <code class="literal">View</code> folder called <code class="literal">TextAnalysisView.xaml</code>. This should contain a <code class="literal">TextBox</code> element for the input query. It should also have a <code class="literal">TextBox</code> element for the result. We will need three <code class="literal">Button</code> elements, one for each detection analysis that we will perform.</p><p>We will also need a new <code class="literal">ViewModel</code>, so add <code class="literal">TextAnalysisViewModel.cs</code> to the <code class="literal">ViewModel</code> folder. In this, we need two <code class="literal">string</code> properties, one for each <code class="literal">TextBox</code>. Also add three <code class="literal">ICommand</code> properties, one for each of our buttons.</p><p>If you have not already done so, register <a class="indexterm" id="id370"/>for an API key at <a class="ulink" href="https://portal.azure.com">https://portal.azure.com</a>.</p><p>Add a <code class="literal">private</code> member called <code class="literal">_webRequest</code> of a <code class="literal">WebRequest </code>type. With that in place, we can create our constructor, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">    public TextAnalysisViewModel()
    {
        _webRequest = new WebRequest("ROOT_URI","API_KEY_HERE");
        DetectLanguageCommand = new DelegateCommand(DetectLanguage, CanExecuteOperation);
        DetectKeyPhrasesCommand = new DelegateCommand(DetectKeyPhrases, CanExecuteOperation);
        DetectSentimentCommand = new DelegateCommand(DetectSentiment, CanExecuteOperation);
    }</pre></div><p>The constructor creates a new <code class="literal">WebRequest</code> object, specifying the API endpoint and API key. We then go on to create the <code class="literal">DelegateCommand</code> objects for our <code class="literal">ICommand</code> properties. The <code class="literal">CanExecuteOperation</code> function should return <code class="literal">true</code> if we have entered the input query and <code class="literal">false</code> otherwise.</p><div class="section" title="Detecting language"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec51"/>Detecting language</h2></div></div></div><p>The API can detect which language<a class="indexterm" id="id371"/> is used in text from over 120 different languages.</p><p>This is a <code class="literal">POST</code> call, so we need to send in a request body. A request body should consist of <code class="literal">documents</code>. This is basically an array containing a unique <code class="literal">id</code> for each <code class="literal">text</code>. It also needs to contain the text itself, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">    private async void DetectLanguage(object obj)
    {
        var queryString = HttpUtility.ParseQueryString("languages");
        TextRequests request = new TextRequests
        {
            documents = new List&lt;TextDocumentRequest&gt;
            {
                new TextDocumentRequest {id="FirstId", text=InputQuery}                            
            }
        };

        TextResponse response = await _webRequest.MakeRequest&lt;TextRequests, TextResponse&gt;(HttpMethod.Post, queryString.ToString(), request);</pre></div><p>We create a <code class="literal">queryString</code> specifying the REST endpoint that we want to reach. Then we go on to create a <code class="literal">TextRequest</code> contract, which contains documents. As we only want to check one piece of text, we <a class="indexterm" id="id372"/>add one <code class="literal">TextDocumentRequest</code> contract, specifying an <code class="literal">id</code> and the <code class="literal">text</code>.</p><p>When the request is created, we call <code class="literal">MakeRequest</code>. We expect the response to be of a <code class="literal">TextResponse </code>type and the request body to be of a <code class="literal">TextRequests </code>type. We pass along <code class="literal">POST</code> as the call method, the <code class="literal">queryString</code>, and the <code class="literal">request</code> body.</p><p>If the response is successful, then we loop through the <code class="literal">detectedLanguages</code>. We add the languages to a <code class="literal">StringBuilder</code>, also outputting the probability of that language being correct. This is then displayed in the UI, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">    if(response.documents == null || response.documents.Count == 0)
    {
        Result = "No languages was detected.";
        return;
    }

    StringBuilder sb = new StringBuilder();

    foreach (TextLanguageDocuments document in response.documents)
    {
        foreach (TextDetectedLanguages detectedLanguage in document.detectedLanguages)
        {
            sb.AppendFormat("Detected language: {0} with score {1}n", detectedLanguage.name, detectedLanguage.score);
        }
    }

    Result = sb.ToString();</pre></div><p>A successful response will contain the following JSON:</p><div class="informalexample"><pre class="programlisting">    {
        "documents": [
        {
            "id": "string",
            "detectedLanguages": [
            {
                "name": "string",
                "iso6391Name": "string",
                "score": 0.0
            }]
        }],
        "errors": [
        {
            "id": "string",
            "message": "string"
        }]
    }</pre></div><p>This contains an array of <code class="literal">documents</code> <code class="literal">-</code>, as many as were provided in the request. Each document will be<a class="indexterm" id="id373"/> marked with a unique <code class="literal">id</code> and contain an array of <code class="literal">detectedLanguage</code> instances. These languages will have the <code class="literal">name</code>, <code class="literal">iso6391Name</code>, and the probability (<code class="literal">score</code>) of being correct.</p><p>If any errors occur for any document, we will get an array of <code class="literal">errors</code>. Each error will contain the <code class="literal">id</code> of the document where the error occurred and the <code class="literal">message</code> as a string.</p><p>A successful call will create a result similar to the one shown in the following screenshot:</p><div class="mediaobject"><img alt="Detecting language" src="graphics/B12373_06_02.jpg"/></div></div><div class="section" title="Extracting key phrases from text"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec52"/>Extracting key phrases from text</h2></div></div></div><p>Extracting key phrases from<a class="indexterm" id="id374"/> text may be useful if we want our application to know key talking points. Using this, we can learn what people are discussing in articles, discussions, or other such sources of text.</p><p>This call also uses the <code class="literal">POST</code> method, which requires a request body. As with language detection, we need to specify documents. Each document will need a unique ID, the text, and the language used. At the time of writing, English, German, Spanish, and Japanese are the only languages that are supported.</p><p>To extract key phrases, we use the following code:</p><div class="informalexample"><pre class="programlisting">    private async void DetectKeyPhrases(object obj)
    {
        var queryString = HttpUtility.ParseQueryString("keyPhrases");
        TextRequests request = new TextRequests
        {
            documents = new List&lt;TextDocumentRequest&gt;
            {
                new TextDocumentRequest { id = "FirstId", text = InputQuery, language = "en" }
            }
        };

        TextKeyPhrasesResponse response = await _webRequest.MakeRequest&lt;TextRequests, TextKeyPhrasesResponse&gt;(HttpMethod.Post, queryString.ToString(), request);</pre></div><p>As you can see, it is quite similar to detecting languages. We create a <code class="literal">queryString</code> using <code class="literal">keyPhrases</code> as the REST endpoint. We create a request object of the <code class="literal">TextRequests </code>type. We <a class="indexterm" id="id375"/>add the documents list, creating one new <code class="literal">TextDocumentRequest</code>. Again, we need the <code class="literal">id</code> and <code class="literal">text</code>, but we have also added a <code class="literal">language</code> tag, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">    if (response.documents == null || response.documents?.Count == 0)
    {
        Result = "No key phrases found.";
        return;
    }

    StringBuilder sb = new StringBuilder();
            
    foreach (TextKeyPhrasesDocuments document in response.documents)
    {
        sb.Append("Key phrases found:n");
        foreach (string phrase in document.keyPhrases)
        { 
            sb.AppendFormat("{0}n", phrase);
        }
    }

    Result = sb.ToString();</pre></div><p>If the response contains any key phrases then we loop through them and output them to the UI. A successful response will provide the following JSON:</p><div class="informalexample"><pre class="programlisting">    {
        "documents": [{
            "keyPhrases": [
            "string" ],
            "id": "string"
        }],
        "errors": [
        {
            "id": "string",
            "message": "string"
        } ]
    }</pre></div><p>Here we have an array of <code class="literal">documents</code>. Each document has a unique <code class="literal">id</code>, corresponding to the ID in the request. Each <a class="indexterm" id="id376"/>document also contains an array of strings, with <code class="literal">keyPhrases</code>.</p><p>As with language detection, any errors will be returned as well.</p></div><div class="section" title="Learning whether a text is positive or negative"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec53"/>Learning whether a text is positive or negative</h2></div></div></div><p>Using sentiment <a class="indexterm" id="id377"/>analysis, we can detect whether or not a text is positive. If you have a merchandise website where users can submit feedback, this feature<a class="indexterm" id="id378"/> can automatically analyze whether the feedback is generally positive or negative.</p><p>The sentiment scores are returned as a number between 0 and 1, where a high number indicates a positive sentiment.</p><p>As with the previous two analyses, this is a <code class="literal">POST</code> call, requiring a request body. Again, we need to specify the documents, and each document requires a unique ID, the text, and the language, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">    private async void DetectSentiment(object obj)
    {
        var queryString = HttpUtility.ParseQueryString("sentiment");
        TextRequests request = new TextRequests
        {
            documents = new List&lt;TextDocumentRequest&gt;
            {
                new TextDocumentRequest { id = "FirstId", text = InputQuery, language = "en" }
            } 
        };

        TextSentimentResponse response = await _webRequest.MakeRequest &lt;TextRequests, TextSentimentResponse&gt;(HttpMethod.Post, queryString.ToString(), request);</pre></div><p>We create a <code class="literal">queryString</code> pointing to <code class="literal">sentiment</code> as the REST endpoint. The data contract is <code class="literal">TextRequests</code>, containing <code class="literal">documents</code>. The document we pass on has a unique <code class="literal">id</code>, the text, and the language:</p><p>A call to <code class="literal">MakeRequest</code> will require a request body of a <code class="literal">TextSentimentRequests </code>type, and we expect the result to be of a  <code class="literal">TextSentimentResponse </code>type.</p><p>If the response contains any <code class="literal">documents</code>, we loop through them. For each document, we check the <code class="literal">score</code>, and output whether or not the text is positive or negative. This is then shown in the UI, as follows:</p><div class="informalexample"><pre class="programlisting">    if(response.documents == null || response.documents?.Count == 0)
    {
        Result = "No sentiments detected";
        return;
    }

    StringBuilder sb = new StringBuilder();

    foreach (TextSentimentDocuments document in response.documents)
    {
        sb.AppendFormat("Document ID: {0}n", document.id);

        if (document.score &gt;= 0.5)
            sb.AppendFormat("Sentiment is positive, with a score of{0}n", document.score);
        else
            sb.AppendFormat("Sentiment is negative with a score of {0}n", document.score);
    }

    Result = sb.ToString();</pre></div><p>A successful response <a class="indexterm" id="id379"/>will result in the<a class="indexterm" id="id380"/> following JSON:</p><div class="informalexample"><pre class="programlisting">    {
        "documents": [
        {
            "score": 0.0,
            "id": "string"
        }],
        "errors": [
        {
            "id": "string",
            "message": "string"
        }]
    }</pre></div><p>This is an array of <code class="literal">documents</code>. Each document will have a corresponding <code class="literal">id</code> as the request and the sentiment <code class="literal">score</code>. If any <code class="literal">errors</code> have occurred, they will be entered as we saw in the language and key-phrase detection sections.</p><p>A successful test can look like the following:</p><div class="mediaobject"><img alt="Learning whether a text is positive or negative" src="graphics/B12373_06_03.jpg"/></div></div></div>
<div class="section" title="Translating text on the fly"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec38"/>Translating text on the fly</h1></div></div></div><p>Using the<a class="indexterm" id="id381"/> translator text API, you can easily add translations to your application. The API allows you to automatically detect the language. This can be used to serve localized content, or to quickly translate content. It also allows us to look up alternative translations that can be used to translate words into different contexts.</p><p>In addition, the translator text API can be used to build customized translation systems. This means that you can improve the existing models. This can be done by adding existing human translations related to expressions and vocabulary in your industry.</p><p>The translator text API is available as a REST API. We will cover the four endpoints that you can reach. To use the API, the following root URL should be used:</p><div class="informalexample"><pre class="programlisting">https://api.cognitive.microsofttranslator.com</pre></div><p>Sign up for an API key at Microsoft Azure Portal.</p><div class="section" title="Translating text"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec54"/>Translating text</h2></div></div></div><p>To translate text from one<a class="indexterm" id="id382"/> language to another, you should call the following URL path:</p><div class="informalexample"><pre class="programlisting">/translate</pre></div><p>The following parameters must be specified:</p><div class="informalexample"><pre class="programlisting">To - Language to translate to. Must be specified as two-letter language code.</pre></div><p>This parameter can be specified multiple times.</p><p>The request body must contain the text that is to be translated.</p><p>A successful call <a class="indexterm" id="id383"/>will result in the following JSON output:</p><div class="informalexample"><pre class="programlisting">[
   {
      "detectedLanguage": {
         "language": "en",
         "score": 1.0
      },
      "translations": [
         "text": "Translated text",
         "to": "en"
      ]
   }
]</pre></div></div><div class="section" title="Converting text script"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec55"/>Converting text script</h2></div></div></div><p>To translate text from<a class="indexterm" id="id384"/> one language script (such as Arabic) to another (such as Latin), you should call the following URL path:</p><div class="informalexample"><pre class="programlisting">/transliterate</pre></div><p>The following parameters must be specified:</p><div class="informalexample"><pre class="programlisting">language - two-letter language code of language used in the language script.
fromScript - four-letter code for script language you are translating from.
toScript - four-letter code for script language you are translating to.</pre></div><p>The request body must contain the text that is to be translated.</p><p>A successful call will result in the following JSON output:</p><div class="informalexample"><pre class="programlisting">[
   {
      "text": "translated text"
      "script": "latin"
   }
]</pre></div></div><div class="section" title="Working with languages"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec56"/>Working with languages</h2></div></div></div><p>There are two paths that <a class="indexterm" id="id385"/>you can use when working with languages. The first one is used to detect language in a specific text. The second one is used to get a list of languages supported by the other APIs.</p><div class="section" title="Detecting the language"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec46"/>Detecting the language</h3></div></div></div><p>To detect the language<a class="indexterm" id="id386"/> that a certain text uses, you should call the following URL path:</p><div class="informalexample"><pre class="programlisting">/detect</pre></div><p>The request body must contain the text that is to be translated. No parameters are needed.</p><p>A successful call will result in the following JSON output:</p><div class="informalexample"><pre class="programlisting">[
   {
      "language": "en",
      "score": 1.0,
      "isTranslationSupported": true,
      "isTransliterationSupported": false,
      "alternatives": [
         {
            "language": "pt",
            "score": 0.8,
            "isTranslationSupported": false
            "isTransliterationSupported": false
         },
         {
            "language": "latn",
            "score": 0.7,
            "isTranslationSupported": true
            "isTransliterationSupported": true
         }
      ]
   }
]</pre></div></div><div class="section" title="Getting supported languages"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec47"/>Getting supported languages</h3></div></div></div><p>To get a list of supported<a class="indexterm" id="id387"/> languages, you should call the following URL path:</p><div class="informalexample"><pre class="programlisting">/languages</pre></div><p>No parameters or body are required for this call.</p><p>A successful call will result in the following JSON output:</p><div class="informalexample"><pre class="programlisting">[
   "translation": {
      ...
      "en": {
         "name": "English",
         "nativeName": "English",
         "dir": "ltr"
      },
      ...
   },
   "transliteration": {
      "ar": {
         "name": "Latin",
         "nativeName": "",
         "scripts": [
            {
               "code": "Arab",
               "name": "Arabic",
               "nativeName": "",
               "dir": "rtl",
               "toScripts": [
                  {
                     "code:" "Latn",
                     "name": "Latin",
                     "nativeName": "",
                     "dir": "ltr"
                  }
               ]
            },
            {
               "code": "Latn",
               "name": "Latin",
               "nativeName": "",
               "dir": "ltr",
               "toScripts": [
                  {
                     "code:" "Arab",
                     "name": "Arabic",
                     "nativeName": "",
                     "dir": "rtl"
                  }
               ]
            }
         ]
      },
      ...
   },
   "dictionary": {
      "af": {
         "name": "Afrikaans",
         "nativeName": "Afrikaans",
         "dir": "ltr",
         "translations": [
            {
               "name": "English",
               "nativeName": "English",
               "dir": "ltr",
               "code": "en"
            }
            ...
         ]
      }
      ...
   }
]</pre></div><p>As you can see, the<a class="indexterm" id="id388"/> two-letter country code is the key for each entry. You can also find the four-letter code for each transliterate language. This API path can be used as a basis for the other API paths.</p></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec39"/>Summary</h1></div></div></div><p>In this chapter, we have focused on the language APIs. We started by creating the parts that are needed to execute the API calls to the different services. Following this, we looked at the Bing Spell Check API. We moved on to more analytical APIs, where we learned how to detect languages, key phrases, and sentiment. Finally, we looked into how we can use the translator text API.</p><p>The next chapter will take us from language APIs to knowledge APIs. In the following chapter, we will learn how to recognize and identify entities based on context. In addition, we will learn how to use the recommendations API.</p></div></body></html>