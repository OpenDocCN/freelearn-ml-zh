<html><head></head><body>
		<div id="_idContainer097">
			<h1 id="_idParaDest-118"><a id="_idTextAnchor151"/>Chapter 8: Managing Models at Scale Using a Model Registry</h1>
			<p>As you begin to deploy multiple models and manage multiple model versions, ensuring core architectural practices such as governance, traceability, and recoverability are followed is challenging without using a model registry. A model registry is a central store containing metadata specific to a model version. It includes information on how the model was built, the performance of that model, as well as where and how the model is deployed. Model registry services or solutions often include additional capabilities, such as approval workflows and notifications. </p>
			<p>In this chapter, we'll cover the concept of a model registry and why a model registry is important for managing multiple models at scale. We'll also outline considerations you need to make when choosing a model registry implementation, in order to best meet the needs of your environment and operational requirements. For this, we'll examine two example implementations of a model registry. These will be a custom-built model registry using AWS services, as well as SageMaker's implementation (called the SageMaker model registry). </p>
			<p>Amazon SageMaker provides a built-in model registry. This is a fully managed model registry, optimized for use within Amazon SageMaker. However, if the Amazon SageMaker model registry does not meet your needs, there are several common patterns utilizing either a custom-built model registry or a third-party solution that also work well with Amazon SageMaker. Although there are many third-party model registries available that can be used for SageMaker-trained models, we do not cover them specifically in this chapter.</p>
			<p>In this chapter, we're going to cover the following main topics: </p>
			<ul>
				<li>Using a model registry</li>
				<li>Choosing a model registry solution</li>
				<li>Managing models using the Amazon SageMaker model registry</li>
			</ul>
			<h1 id="_idParaDest-119"><a id="_idTextAnchor152"/>Technical requirements </h1>
			<p>You will need an AWS account to run the examples included in this chapter. If you have not set up the data science environment yet, please refer to <a href="B17249_02_Final_JM_ePub.xhtml#_idTextAnchor039"><em class="italic">Chapter 2</em></a><em class="italic">, Data Science Environments</em>. This provides a walk-through of the setup process.</p>
			<p>Code examples included in the book are available on GitHub at the following URL: https://github.com/PacktPublishing/Amazon-SageMaker-Best-Practices/tree/main/Chapter08. You will need to install a Git client to access them (<a href="https://git-scm.com/">https://git-scm.com/</a>).</p>
			<p>The code for this chapter is in the <strong class="source-inline">CH08</strong> folder of the GitHub repository.</p>
			<h1 id="_idParaDest-120"><a id="_idTextAnchor153"/>Using a model registry</h1>
			<p>A model registry <a id="_idIndexMarker329"/>allows you to centrally track key metadata for each model version. The granularity of metadata tracked is often dependent on the chosen implementation (Amazon SageMaker's model registry, a custom solution, or a third-party solution).  </p>
			<p>Regardless of the implementation, the key metadata to consider includes model version identifiers, and the following information about each model version registered: </p>
			<ul>
				<li><strong class="bold">Model inputs</strong>: These<a id="_idIndexMarker330"/> include metadata related to the inputs and versions of those inputs used to train the model. This can include inputs such as the name of the Amazon S3 bucket storing the training data, training hyperparameters, and the <strong class="bold">Amazon Elastic Container Registry</strong> (<strong class="bold">ECR</strong>) repository or<a id="_idIndexMarker331"/> container image used for training.</li>
				<li><strong class="bold">Model performance</strong>: This<a id="_idIndexMarker332"/> includes model evaluation data such as training and validation metrics.</li>
				<li><strong class="bold">Model artifact</strong>: This <a id="_idIndexMarker333"/>includes metadata about the training model artifact. At a minimum, this includes the name of the Amazon S3 bucket storing the model artifact, as well as the name of the object (for example, <strong class="source-inline">model.tar.gz</strong>). </li>
				<li><strong class="bold">Model deployment</strong>: This includes <a id="_idIndexMarker334"/>metadata relating to the deployment of a model. This includes information such as the environment(s) a model version is deployed to, or the inference code that can be used for the registered model. </li>
			</ul>
			<p>Amazon SageMaker offers multiple options for training models including built-in algorithms, built-in frameworks (that is, script mode), and a bring-your-own container. Depending on the option chosen, the number of inputs required to train a model can vary. This could impact the metadata you choose to track. As a result, it's important to determine the minimum requirements of metadata that you need to track in order to meet any regulatory or internal traceability requirements you may have. </p>
			<p>When evaluating levels of<a id="_idIndexMarker335"/> granularity, you need to track your use case. Keep in mind the way your teams are using Amazon SageMaker to build models. <em class="italic">Figure 8.1</em> illustrates an example of the inputs, metrics, and artifacts to consider for tracking across the SageMaker options for training models:</p>
			<div>
				<div id="_idContainer090" class="IMG---Figure">
					<img src="image/B17249_08_01.jpg" alt="Figure 8.1 – Model build metadata across training options&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.1 – Model build metadata across training options</p>
			<p>Similar considerations exist for tracking and storing model deployment data. The metadata tracked for model deployments should provide enough information to package the model for deployment using Amazon SageMaker, to a real-time endpoint, or using batch transform. This should also allow someone to easily identify where a given model version is deployed, as well as how it is packaged for deployment and consumption. <em class="italic">Figure 8.2</em> illustrates an example of the inputs, deployment stages, and artifacts to consider for tracking across the SageMaker options for deploying models:</p>
			<div>
				<div id="_idContainer091" class="IMG---Figure">
					<img src="image/B17249_08_02.jpg" alt="Figure 8.2 – Model deploy metadata across deployment options&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.2 – Model deploy metadata across deployment options</p>
			<p>If you had a couple of<a id="_idIndexMarker336"/> models to manage, you could potentially track the previous information using a simple method, such as a spreadsheet. However, as you begin to scale to 20, 100, or thousands of models, that mechanism for tracking model metadata no longer scales. Centrally storing and tracking the information (shown in <em class="italic">Figures 8.1</em> and <em class="italic">8.2</em>) for each model version provides the following benefits: </p>
			<ul>
				<li><strong class="bold">Operational efficiencies</strong>: A model registry provides tracking and visibility into key inputs used to build a specific model version, output artifacts, and information about the deployment stages aligned to that version. Having this metadata allows for the ability to quickly understand how a model was built, how the model performed, information about the trained model artifact, and also provides the ability to track the environment(s) a specific version is deployed to. </li>
				<li><strong class="bold">Recoverability</strong>: To be able to recover a deployed model or roll back to a previous version, you need to have visibility to the inputs and input versions used to create a deployable artifact or a deployed model. In the event of system or human error, you can recover to a specific point in time using the metadata stored in the model registry, combined with protected versioned inputs. As an example, if an administrator were to accidentally delete a model endpoint, it should be easy to identify the artifacts needed to recreate that endpoint. This can be identified using metadata stored in the model registry that points to the location of the versioned model artifact, in combination with the versioned inference container image. </li>
				<li><strong class="bold">Pipeline sources and triggers</strong>: Often there is a need to bridge the model build and model deployment environments. This is typical in large enterprises that have central deployment teams, or in organizations that separate model build and model deployment roles. A model registry provides a mechanism to capture the minimum metadata needed for visibility into how a model is built. However, it can also be used to trigger approval workflows and downstream deployments. </li>
			</ul>
			<p>In the next section, we'll cover three patterns for creating a model registry to centrally track and manage machine learning models at scale. The considerations and high-level architectures of each will be outlined in order to guide you to the right fit for your specific use case. </p>
			<h1 id="_idParaDest-121"><a id="_idTextAnchor154"/>Choosing a model registry solution</h1>
			<p>There are multiple<a id="_idIndexMarker337"/> options available for implementing a model registry. While each implementation offers different features or capabilities, the concept of providing a central repository to track key metadata largely remains the same across implementations. In this section, we'll cover a few common patterns for creating a model registry, as well as discuss the considerations for each. The patterns covered in this section include the following: </p>
			<ul>
				<li>Amazon SageMaker model registry </li>
				<li>Building a custom model registry</li>
				<li>Utilizing a third-party or <strong class="bold">open source software</strong> (<strong class="bold">OSS</strong>) model registry</li>
			</ul>
			<h2 id="_idParaDest-122"><a id="_idTextAnchor155"/>Amazon SageMaker model registry</h2>
			<p>The Amazon SageMaker model registry<a id="_idIndexMarker338"/> is a managed service that allows you to centrally catalog models, manage model versions, associate metadata with your model versions, and manage the approval status of a model version. The service is continuously evolving with new features, so the information contained in this section is current as of the publication date. It's always recommended to validate the current features and capabilities with the official documentation<a id="_idIndexMarker339"/> for the <em class="italic">Amazon SageMaker model registry</em> (<a href="https://docs.aws.amazon.com/sagemaker/latest/dg/model-registry.html">https://docs.aws.amazon.com/sagemaker/latest/dg/model-registry.html</a>). The SageMaker model registry is optimized for use in conjunction with Amazon SageMaker Pipelines and projects; however, it can also be used independently as well. </p>
			<p>You can interact with the SageMaker's model registry programmatically, as well as within Amazon SageMaker Studio. Studio provides a visual interface and experience for version management. The Studio interface also provides additional search capabilities. These can be seen in the following screenshot: </p>
			<div>
				<div id="_idContainer092" class="IMG---Figure">
					<img src="image/B17249_08_03.jpg" alt="Figure 8.3 – The SageMaker Studio interface for the SageMaker model registry&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.3 – The SageMaker Studio interface for the SageMaker model registry</p>
			<p>The SageMaker model registry also includes an approval status that can be modified when a model is approved for production. This could be after a peer or designated deployment approver reviews the model metadata and metrics as a final quality gate for deployment. In the following screenshot, you can see how the approval status field integrates natively with MLOps projects in Amazon SageMaker Pipelines to create automatic triggers based on a change in model status:</p>
			<div>
				<div id="_idContainer093" class="IMG---Figure">
					<img src="image/B17249_08_04.jpg" alt="Figure 8.4 – SageMaker model registry – approval status&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.4 – SageMaker model re<a id="_idTextAnchor156"/>gistry – approval status</p>
			<p>The main components of the <a id="_idIndexMarker340"/>SageMaker model registry include the following: </p>
			<ul>
				<li><strong class="bold">Model registry</strong>: This is<a id="_idIndexMarker341"/> the central store containing model groups and it exists at the AWS account and AWS region levels. Cross-account privileges can be set up to interact with the model registry from other AWS accounts. </li>
				<li><strong class="bold">Model groups</strong>: Model <a id="_idIndexMarker342"/>groups are a logical grouping. They allow you to track different model versions that are related to, or grouped by, the same machine learning problem.</li>
				<li><strong class="bold">Model packages</strong>: Model <a id="_idIndexMarker343"/>packages are registered models or specific versions of a model.</li>
			</ul>
			<p><em class="italic">Figure 8.5</em> illustrates the main components, where each model version is a model package contained in a model group inside the model registry: </p>
			<div>
				<div id="_idContainer094" class="IMG---Figure">
					<img src="image/B17249_08_05.jpg" alt="Figure 8.5 – Amazon SageMaker model registry components and usage&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.5 – Amazon SageMaker model registry components and usage</p>
			<p>When <a id="_idIndexMarker344"/>registering a new model version within a model group, you can use either the AWS SDK for Python (<strong class="source-inline">boto3</strong>) with the <strong class="source-inline">create_model_package</strong> method (<a href="https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/sagemaker.html#SageMaker.Client.create_model_package">https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/sagemaker.html#SageMaker.Client.create_model_package</a>), or create a step within a model build pipeline, using the <strong class="source-inline">RegisterModel</strong> step (<a href="https://sagemaker.readthedocs.io/en/stable/workflows/pipelines/sagemaker.workflow.pipelines.html#pipeline">https://sagemaker.readthedocs.io/en/stable/workflows/pipelines/sagemaker.workflow.pipelines.html#pipeline</a>) within Amazon SageMaker Pipelines. Understanding the ways you can register a model is important for understanding how you can use the SageMaker model registry outside of SageMaker Pipelines. It is also important for understanding how you can integrate the SageMaker model registry into other workflow tooling options you may already be using.</p>
			<p>It's possible to register a model as either <strong class="bold">versioned</strong> or <strong class="bold">unversioned</strong>. Model packages that are versioned are part of a model group, and unversioned model packages are not part of a model group. The benefit of using a model group, or a versioned model, is the ability to logically group and manage models that are related, as well as provide the ability to automatically version models related to a specific <strong class="bold">machine learning</strong> (<strong class="bold">ML</strong>) problem. It's recommended to register your models using model groups with registered models that are versioned. This is the default setting. </p>
			<p>A registered model has specific metadata that can be associated with that version. The metadata is defined and configured by the API request parameters. At high-level, the API accepts and associates the <a id="_idIndexMarker345"/>following key metadata as input: </p>
			<ul>
				<li><strong class="bold">Inference specification</strong>: A series of parameters that provide detailed information and guidance on hosting the model for inference. Information passed includes data such as the Amazon ECR data. This contains the inference code image, the Amazon S3 bucket containing the trained model artifact, and the supported instance types when hosting the model for either real-time inference or for batch inference. For example, if a model requires GPU for inference, that can be captured in the registry. </li>
				<li><strong class="bold">Model metrics</strong>: Model evaluation metrics across evaluated categories, such as statistical bias in a model, or model quality.</li>
				<li><strong class="bold">Validation specification</strong>: Information about the SageMaker batch transform job(s) that were used to validate the model package (if applicable). </li>
				<li><strong class="bold">Algorithm specification</strong>: Details about the algorithm(s) used to create the model, as well as the Amazon S3 bucket containing the trained model artifact.</li>
				<li><strong class="bold">Metadata properties</strong>: These properties contain metadata for the <strong class="source-inline">CodeCommit</strong> commit ID, author of the source, the SageMaker Pipelines project ID, and the name of the <strong class="source-inline">CodeCommit</strong> repository. While they are not restricted for use outside Amazon SageMaker Pipelines, they are direct pointers to SageMaker Pipelines project resources. </li>
				<li><strong class="bold">Model approval status</strong>: This parameter is used to indicate whether a model is approved for deployment. This parameter can be used to manage workflows. In the case of SageMaker Pipelines projects, the automated workflow triggers are automatically set up based on the status of this field. If a model status is changed to <strong class="bold">approved</strong>, a downstream deployment workflow can be triggered. </li>
			</ul>
			<p>Amazon SageMaker's model registry is fully managed, meaning there are no servers to manage. It also natively integrates into SageMaker Pipelines, providing the ability to integrate directly with the model registry as a native step in your model build pipeline. It does this using the <strong class="source-inline">RegisterModel</strong> step. </p>
			<p>For example, if you build a model build pipeline that contains the automated steps for data processing, training, and model evaluation, you can add a conditional step to validate the evaluation metric. If the evaluation metric is above a specified threshold (for example, accuracy &gt; 90%), the pipeline can then be configured to automatically register your model. </p>
			<p>SageMaker's model registry<a id="_idIndexMarker346"/> also integrates natively with SageMaker Pipelines projects. Projects allow you to automatically provision MLOps pipelines and provision patterns that take advantage of the model registry. SageMaker projects can be used to automatically set up the model package group, as well as the approval workflows that can be used to trigger the pre-configured downstream deployment pipeline. </p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Amazon SageMaker Pipelines is covered in more detail in <a href="B17249_12_Final_JM_ePub.xhtml#_idTextAnchor222"><em class="italic">Chapter 12</em></a>, <em class="italic">Machine Learning Automated Workflows</em>. The model registry is a component within SageMaker Pipelines but can be used independently of SageMaker Pipelines. </p>
			<p>Many of the parameters passed as input to the <strong class="source-inline">CreateModelPackage</strong> API are tailored for Amazon SageMaker use and integrations with other Amazon SageMaker features. For example, data that can be associated with model metrics has a direct correlation with metrics produced with features such as Amazon SageMaker Clarify, model statistical bias metrics, Amazon SageMaker Model Monitor, and data quality constraint metrics. In another example, the validation specification relates specifically to a SageMaker batch transform job run to evaluate the SageMaker model package. </p>
			<p>In this section, we reviewed the high-level architecture and usage of the Amazon SageMaker model registry to provide a basis for comparison against other options that will be covered in the next sections. Multiple options are being covered in this chapter. This is in order to support a variety of use cases and to help you choose the right option for your specific use case.</p>
			<h2 id="_idParaDest-123"><a id="_idTextAnchor157"/>Building a custom model registry</h2>
			<p>A model registry can also be built<a id="_idIndexMarker347"/> using AWS services. Building a custom registry requires more effort to build the solution, set up the integrations between AWS services, set up the ML pipeline integrations, and then manage the solution. However, a custom registry also offers the ability to completely customize a registry to meet the needs specific to your use case. This could include requirements specific to tracking more granular metadata, or requirements to support multiple ML services/platforms. In this section, we'll review one pattern for creating a custom model registry using AWS services. </p>
			<p>The pattern shown in <em class="italic">Figure 8.6</em> illustrates a simple model registry built using Amazon DynamoDB. DynamoDB can be used to store model metadata using a design pattern that separates groups of models by partition key. You could also consider a design pattern establishing a new table for different teams or business units if table-level isolation is preferred. Controls should also be set up using <strong class="bold">AWS Identity and Access Management</strong> (<strong class="bold">IAM</strong>) to control <a id="_idIndexMarker348"/>access to DynamoDB for specific tables, as well as specific primary keys to set up controls on who can access specific model groupings: </p>
			<p class="figure-caption"> </p>
			<div>
				<div id="_idContainer095" class="IMG---Figure">
					<img src="image/B17249_08_06.jpg" alt="Figure 8.6 – Custom-built model registry using AWS services&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.6 – Custom-built model registry using AWS services</p>
			<p>The schema for a model registry based on DynamoDB provides flexibility in the metadata that can be stored for each model version. As an example, you may want to track data versions that correspond to the object(s) in an Amazon S3 bucket. A custom-built model registry provides the flexibility to define and adjust the schema to meet your individual requirements for traceability or for more granular metadata tracking.</p>
			<p>Interacting with a custom-built model registry can be done through the Amazon DynamoDB API (<strong class="bold">PutItem</strong>) or through a custom-built API. Using a simple <strong class="bold">PutItem</strong>, API can often work for smaller teams or teams that perform end-to-end tasks, such as model building, model <a id="_idIndexMarker349"/>deployment, and operating in a production environment. However, in many cases, a model registry is built as part of a shared service (or ML platform component) that serves multiple teams and use cases. In this case, it's recommended to build an API that includes similar controls and validations that are seen in a managed service, such as SageMaker's model registry. </p>
			<p>To extend a custom-built model registry to include workflow tasks, such as triggering a model deployment pipeline based on a changed attribute, the solution needs to be extended to set up the trigger to detect a change and then execute any downstream processes you want to invoke. To do this, you can enable DynamoDB Streams and AWS Lambda triggers. </p>
			<p>In this section, we covered a high-level implementation pattern for creating a custom model registry using AWS services. This example provides complete flexibility in the registry schema, data points collected, and in defining the intended usage. </p>
			<p>As an example, you may have some teams that utilize Amazon SageMaker features, but other teams that are utilizing other services or even building models on-premises. Building a custom registry also allows the flexibility to place the model registry in the AWS account you choose, based on your existing multi-account strategy, and adjust the schema based on usage. </p>
			<p>The pattern discussed also utilizes AWS-managed services, DynamoDB and API Gateway, meaning there are still no servers to manage. However, this is not a packaged solution. Therefore, the services need to be set up and configured. Interfacing code may need to be written, integrations between services need to be set up, and the solution needs to be managed. </p>
			<h2 id="_idParaDest-124"><a id="_idTextAnchor158"/>Utilizing a third-party or OSS model registry</h2>
			<p>Next, we'll briefly cover <a id="_idIndexMarker350"/>using a third-party or OSS implementation of a model registry. Because there are a lot of options available, this section will focus on high-level considerations, rather than diving deep into any specific implementation. Common implementations, such as MLflow, have existing documentation provided for integrating with Amazon SageMaker. Those resources should be utilized when implementing a third-party/OSS implementation and integrating with Amazon SageMaker.  </p>
			<p>When considering a third-party or OSS implementation, there are a few questions to consider when evaluating your options:</p>
			<ul>
				<li>Does the implementation require you to manage the underlying servers, meaning you need to incur some additional operational overhead to ensure servers are patched, monitored, scaled, and set up using a readily available architecture? </li>
				<li>Does the implementation offer native integrations that make it easy to integrate with Amazon SageMaker?</li>
				<li>What additional credentials do you need to set up and manage in order to integrate with Amazon SageMaker? </li>
			</ul>
			<p>Using a third-party or OSS option can add some additional overheads in terms of setup, integration, and ongoing management. However, many of these implementations offer robust capabilities, interfaces, and extensibility that may be preferred depending on your ML environments and use cases. </p>
			<p>In this section, we discussed three common patterns for model registry implementations for use with Amazon SageMaker models. Each pattern can be a valid choice depending on your requirements. As a result, key considerations for each were discussed to provide general guidance in order to choose the best implementation. </p>
			<p>In general, it is recommended to choose the option that provides the capabilities you need based on your own requirements, combined with the option that offers the lowest development and operational overhead. In the next section, we'll narrow the focus to a technical deep dive into the Amazon SageMaker model registry. </p>
			<h1 id="_idParaDest-125"><a id="_idTextAnchor159"/>Managing models using the Amazon SageMaker model registry</h1>
			<p>An introduction<a id="_idIndexMarker351"/> to the Amazon<a id="_idIndexMarker352"/> SageMaker model registry was included in the section titled <em class="italic">Amazon SageMaker model registry</em>. This was done in order to explain the high-level architecture and features that are important to consider when choosing a model registry implementation. In this section, we'll dive deeper into the Amazon SageMaker model registry by covering the process and best practice guidance when setting up and using SageMaker's model registry. </p>
			<p>SageMaker's model registry includes the model registry, as well as model groups and model packages. Each model group contains model versions, or model packages, related to the same ML problem. Each model package represents a specific version of a model and includes metadata associated with that version. The SageMaker model registry APIs are used when interacting with the SageMaker model registry, and those APIs can also be called through any of the following:</p>
			<ul>
				<li><strong class="bold">AWS Command Line Interface</strong> (<strong class="bold">CLI</strong>): This uses commands to interact with the model registry, such as <strong class="source-inline">create-model-package-group</strong> or <strong class="source-inline">create-model-package</strong> commands. </li>
				<li><strong class="bold">AWS Python SDK</strong> (<strong class="source-inline">boto3</strong>): This uses methods to interact with the model registry, such as the <strong class="source-inline">create_model_package_group</strong> or <strong class="source-inline">create_model_package</strong> methods.</li>
				<li><strong class="bold">Amazon SageMaker Studio</strong>: This uses the click-through interface in SageMaker Studio (as shown in <em class="italic">Figure 8.7</em>) to create a model package group. </li>
				<li><strong class="bold">Amazon SageMaker Pipelines</strong>: This uses the built-in <strong class="source-inline">RegisterModelstep</strong>.</li>
			</ul>
			<p><em class="italic">Figure 8.7</em> illustrates creating a model package group using the Studio UI:</p>
			<div>
				<div id="_idContainer096" class="IMG---Figure">
					<img src="image/B17249_08_07.jpg" alt="Figure 8.7 – Using SageMaker Studio to create a new model group&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.7 – Using SageMaker Studio to create a new model group</p>
			<p>Although you <a id="_idIndexMarker353"/>can interact with the<a id="_idIndexMarker354"/> model registry using any of the methods listed, in this chapter we'll cover interacting with the model registry using the AWS Python SDK (<strong class="source-inline">boto3</strong>), to showcase a lower level of abstraction that is not dependent on Amazon SageMaker Studio or Amazon SageMaker Pipelines. </p>
			<p>In this section, you learned more about the primary components of the SageMaker model registry, as well as the different ways you can interact with the model registry either programmatically or via the Studio UI. </p>
			<h2 id="_idParaDest-126"><a id="_idTextAnchor160"/>Creating a model package group</h2>
			<p>A model package group <a id="_idIndexMarker355"/>contains a collection of model packages or model versions. A model package group is not required for registering a model package; however, it is recommended for the manageability of your model versions across ML use cases. A model package group can contain one or more model packages. </p>
			<p>Creating a model package group involves a method that accepts only a few parameters on input to configure, as follows:</p>
			<p class="source-code">import time</p>
			<p class="source-code">model_package_group_name = "air-quality-" + str(round(time.time()))</p>
			<p class="source-code">model_package_group_input_dict = {</p>
			<p class="source-code">"ModelPackageGroupName" : model_package_group_name,</p>
			<p class="source-code">"ModelPackageGroupDescription" : "model package group for air quality models",</p>
			<p class="source-code">"Tags": [</p>
			<p class="source-code">            {</p>
			<p class="source-code">            "Key": "MLProject",</p>
			<p class="source-code">             "Value": "weather"</p>
			<p class="source-code">              }</p>
			<p class="source-code">]  </p>
			<p class="source-code">}</p>
			<p class="source-code">create_model_pacakge_group_response = sm_client.create_model_package_group(**model_package_group_input_dict)</p>
			<p class="source-code">print('ModelPackageGroup Arn : {}'.format(create_model_pacakge_group_response['ModelPackageGroupArn']))</p>
			<p>The preceding code is used to create a model package group that can then be used by ML builders, as well as with ML pipelines to register model packages (versions) for deployment. Configuration for a model package group requires only a model package group name and <a id="_idIndexMarker356"/>optionally a description and any tags you want to associate with the model group. </p>
			<p>Recommendations when creating model package groups include the following: </p>
			<ul>
				<li><strong class="bold">Establishing naming standards for model package groups</strong>: As the number of model package groups grows, having clear naming standards can help with easily identifying and searching for related model package groups. Some considerations may include a team identifier and/or project identifier. Because it's common to have more than one team working on models, a team identifier can help easily sort and search for models specific to a given team. It's also common to have more than one model used in an overall solution. In this case, it is valuable to have a way to group models related to a specific project or solution. This can be done through established naming conventions, as well as tagging. </li>
				<li><strong class="bold">Utilizing tags for fine-grained access</strong>: In the preceding example, a tag of <strong class="source-inline">MLProject</strong> is created with the value of <strong class="source-inline">weather</strong>. In this case, let's assume a weather team is responsible for building weather-related models and only team members belonging to the weather team should be able to view model package groups with this tag. Resource tags can be used to establish conditional policies for access.</li>
			</ul>
			<h2 id="_idParaDest-127"><a id="_idTextAnchor161"/>Creating a model package</h2>
			<p>A model package is a<a id="_idIndexMarker357"/> model version that can exist outside of a model package group, referred to as <em class="italic">unversioned</em>, or inside a model package group, referred to as <em class="italic">versioned</em>. A model package outside of a model package group is referred to as unversioned because it's not using the versioning capabilities of a model package group. It's recommended to register model packages using model package groups for automatic management of model versions, and for added manageability as the number of model versions increases.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Amazon SageMaker has two concepts called <strong class="bold">model package</strong>. The two are independent of each other. The first example is a model package that is created to package a model for deployment using the <strong class="source-inline">CreateModel</strong> API. This is required to deploy your model using Amazon SageMaker and is discussed in the <em class="italic">Amazon SageMaker documentation </em>(<a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sagemaker-mkt-model-pkg-model.html">https://docs.aws.amazon.com/sagemaker/latest/dg/sagemaker-mkt-model-pkg-model.html</a>). The second example, and the one we refer to in this chapter, is a model package specifically for Amazon SageMaker's model registry that is created using the <strong class="source-inline">CreateModelPackage</strong> API. </p>
			<p>The <strong class="source-inline">CreateModelPackage</strong> API <a id="_idIndexMarker358"/>accepts several parameters on input. The high-level parameter categories were already covered in the section titled <em class="italic">Amazon SageMaker model registry</em>, so in this section, we'll include an example that uses those parameters to then register a model using our sample use case. In <a href="B17249_12_Final_JM_ePub.xhtml#_idTextAnchor222"><em class="italic">Chapter 12</em></a>, <em class="italic">Machine Learning Automated Workflows</em>, we'll again discuss the model registry in the context of an ML pipeline, to demonstrate how a model registry can be integrated into your automated workflows. For now, we'll focus on registering a model package as an indication that it has passed initial model validation outside of a pipeline workflow. </p>
			<p>In this case, the model has been trained and we've evaluated the training metrics. Once our model reaches the minimum threshold identified for our evaluation metric, we are ready to register the model package. Using the AWS Python SDK (<strong class="source-inline">boto3</strong>), we'll register the model package, as shown in the following code:</p>
			<p class="source-code">modelpackage_inference_specification =  {</p>
			<p class="source-code">            "InferenceSpecification": {</p>
			<p class="source-code">            "Containers": [</p>
			<p class="source-code">            {</p>
			<p class="source-code">             "Image": xgboost_container,</p>
			<p class="source-code">             "ModelDataUrl": model_url</p>
			<p class="source-code">             }</p>
			<p class="source-code">             ],</p>
			<p class="source-code">             "SupportedContentTypes": [ "text/csv" ],</p>
			<p class="source-code">              "SupportedResponseMIMETypes": [ "text/csv" ],</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p class="source-code">create_model_package_input_dict = {</p>
			<p class="source-code">            "ModelPackageGroupName" : model_package_group_name,</p>
			<p class="source-code">           "ModelPackageDescription" : "Model to predict air quality ratings using XGBoost",</p>
			<p class="source-code">            "ModelApprovalStatus" : "PendingManualApproval"</p>
			<p class="source-code">}</p>
			<p class="source-code">create_model_package_input_dict.update(modelpackage_inference_specification)</p>
			<p class="source-code">create_mode_package_response = sm_client.create_model_package(**create_model_package_input_dict)</p>
			<p class="source-code">model_package_arn = create_mode_package_response["ModelPackageArn"]</p>
			<p class="source-code">print('ModelPackage Version ARN : {}'.format(model_package_arn))</p>
			<p><strong class="source-inline">ModelPackageGroupName</strong> is <a id="_idIndexMarker359"/>required to associate the model package with a model package group. This allows you to take advantage of automatic versioning, as previously discussed. </p>
			<p>The model packages can then be viewed using the <strong class="source-inline">list_model_packages</strong> method, as well as within Amazon SageMaker Studio. To list the model package, use the following code:</p>
			<p class="source-code">sm_client.list_model_packages(ModelPackageGroupName=model_package_group_name)</p>
			<p>Recommendations when creating <a id="_idIndexMarker360"/>model packages include the following:</p>
			<ul>
				<li><strong class="bold">Creating versioned packages</strong>: Associate model packages with a model group by specifying the model package group when you create your model package. This allows for automatic versioning and grouping of use cases for easier management. </li>
				<li><strong class="bold">Using model approval status</strong>: The optimal use of the model approval status field is to allow for peer reviews and trigger downstream deployment workflows using Amazon SageMaker projects. However, even without the use of Amazon SageMaker projects, the same field can be used to ensure data used to register a model passes a minimum set of criteria. For example, if there is a team standard to include explainability metrics for a registered model, then that <strong class="source-inline">ApprovalStatus</strong> can optionally be used after a peer review of the registered model to indicate minimum standards or criteria have been met for that model. </li>
				<li><strong class="bold">Protecting the inputs/artifacts referred to in the model registry</strong>: Details contained in the model registry can be used to recreate or roll back deployed models; however, those resources need to be protected from unauthorized access or accidental deletion. For example, if an administrator accidentally deletes a SageMaker endpoint, it can still be easily recreated using the resources identified in the model registry. This would include the S3 object containing the model artifact, the S3 object with inference code (optional), and the ECR inference image. If any of those inputs are not available or cannot be guaranteed, then re-creating that endpoint may not be possible. Therefore, the metadata gives the information required, but there are still additional steps needed to protect inputs and artifacts. </li>
				<li><strong class="bold">Considering tags when additional metadata is needed</strong>: The metadata within SageMaker's model registry is fixed to the input parameters that are defined in the API. However, tags can be used to supplement additional metadata. An example of the recommended use of tags here would be to capture the S3 version for resources such as the model artifact, in order to include more granularity on artifact tracking.</li>
				<li><strong class="bold">Utilizing tags for fine-grained access</strong>: In the preceding example, a tag of <strong class="source-inline">MLProject</strong> is created with the value of <strong class="source-inline">weather</strong>. In this case, let's assume a weather team is responsible for building weather-related models and only team members from this team should be able to register new models to this model package group or other model package groups created with this tag. Resource tags can be used to establish conditional policies for access, in order to create model packages within <a id="_idIndexMarker361"/>specific model package groups. Resource tags can be used to establish conditional policies for access. </li>
			</ul>
			<p>In this section, we detailed the steps necessary to create a model package group and register model packages to that model package group using the sample code provided for this chapter. We also outlined recommendations to consider when creating your own model package groups and model packages. <a href="B17249_12_Final_JM_ePub.xhtml#_idTextAnchor222"><em class="italic">Chapter 12</em></a>, <em class="italic">Machine Learning Automated Workflows</em>, will expand on the information covered in this chapter to include integrating Amazon SageMaker's model registry into an MLOps pipeline. </p>
			<h1 id="_idParaDest-128"><a id="_idTextAnchor162"/>Summary</h1>
			<p>In this chapter, we covered model registries and the benefits of utilizing a model registry to manage Amazon SageMaker models at scale. Common patterns for model registry implementations were covered, including Amazon SageMaker's model registry, building a custom model registry using AWS services, and utilizing a third-party or OSS model registry implementation. Each option is a valid choice depending on your use case and needs. However, we also highlighted some of the considerations when choosing the implementation that best fits your requirements. </p>
			<p>Finally, we did a deep dive into Amazon SageMaker's model registry, covering detailed recommendations for creating model package groups, as well as registering models by creating model packages. </p>
			<p>In the next chapter, we'll cover performing live tests and updates of production models using Amazon SageMaker endpoint production variants.</p>
		</div>
	</body></html>