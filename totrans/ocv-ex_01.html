<html><head></head><body><div class="chapter" title="Chapter&#xA0;1.&#xA0;Getting Started with OpenCV"><div class="titlepage"><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Getting Started with OpenCV</h1></div></div></div><p>Computer Vision applications are interesting and useful, but the underlying algorithms are computationally intensive. With the advent of cloud computing, we are getting more processing power to work with. The OpenCV library enables you to run Computer Vision algorithms efficiently in real time. It has been around for many years and it has become the standard library in this field. One of the main advantages of OpenCV is that it is highly optimized and available on almost all platforms. The discussions in this book will cover everything, including the algorithm we are using, why we are using it, and how to implement it in OpenCV.</p><p>In this chapter, we are going to learn how to install OpenCV on various operating systems. We will discuss what OpenCV offers out of the box and the various things that we can do using the in-built functions.</p><p>By the end of this chapter, you will be able to answer the following questions:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">How do humans process visual data and how do they understand image content?</li><li class="listitem" style="list-style-type: disc">What can we do with OpenCV and what are the various modules available in OpenCV that can be used to achieve those things?</li><li class="listitem" style="list-style-type: disc">How to install OpenCV on Windows, Linux, and Mac OS X?</li></ul></div><div class="section" title="Understanding the human visual system"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec08"/>Understanding the human visual system</h1></div></div></div><p>Before we jump into<a id="id0" class="indexterm"/> OpenCV functionalities, we need to understand why those functions were built in the first place. It's important to understand how the human visual system works so that you can develop the right algorithms. The goal of the Computer Vision algorithms is to understand the content of images and videos. Humans seem to do it effortlessly! So, how do we get machines to do it with the same accuracy?</p><p>Let's consider the following figure:</p><div class="mediaobject"><img src="graphics/B04283_01_01.jpg" alt="Understanding the human visual system"/></div><p>The human eye captures<a id="id1" class="indexterm"/> all the information that comes along such as color, shapes, brightness, and so on. In the preceding image, the human eye captures all the information about the two main objects and stores it in a certain way. Once we understand how our system works, we can take advantage of this to achieve what we want. For example, here are a few things we need to know:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Our visual system is more sensitive to low frequency content than high frequency content. Low frequency content refers to planar regions where pixel values don't change rapidly and high frequency content refers to regions with corners and edges, where pixel values fluctuate a lot. You will have noticed that we can easily see if there are blotches on a planar surface, but it's difficult to spot something like that on a highly textured surface.</li><li class="listitem" style="list-style-type: disc">The human eye is more sensitive to changes in brightness as compared to changes in color.</li><li class="listitem" style="list-style-type: disc">Our visual system is sensitive to motion. We can quickly recognize if something is moving in our field of vision even though we are not directly looking at it.</li><li class="listitem" style="list-style-type: disc">We tend to make a mental note of salient points in our field of vision. Let's consider a white table with four black legs and a red dot at one of the corners of the table surface. When you look at this table, you'll immediately make a mental note that the surface and legs have opposing colors and there is a red dot on one of the corners. Our brain is really smart that way! We do this automatically so that we can immediately recognize it if we encounter it again.</li></ul></div><p>To get an idea <a id="id2" class="indexterm"/>of our field of view, let's take a look at the top view of a human and the angles at which we see various things:</p><div class="mediaobject"><img src="graphics/B04283_01_02.jpg" alt="Understanding the human visual system"/></div><p>Our visual system is actually capable of a lot more things, but this should be good enough to get us started. You can explore further by reading up on Human Visual System Models on the internet.</p></div></div>
<div class="section" title="How do humans understand image content?"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec09"/>How do humans understand image content?</h1></div></div></div><p>If you look around, you <a id="id3" class="indexterm"/>will see a lot of objects. You may encounter many different objects every day, and you recognize them almost instantaneously without any effort. When you see a chair, you don't wait for a few minutes before realizing that it is, in fact, a chair. You just know that it's a chair right away! Now, on the other hand, computers find it very difficult to do this task. Researchers have been working for many years to find out why computers are not as good as we are at this.</p><p>To get an <a id="id4" class="indexterm"/>answer to this question, we need to understand how humans do it. The visual data processing happens in the ventral visual stream. This ventral visual stream refers to the pathway in our visual system that is associated with object recognition. It is basically a hierarchy of areas in our brain that helps us recognize objects. Humans can recognize different objects effortlessly, and we can cluster similar objects together. We can do this because we have developed some sort of invariance toward objects of the same class. When we look at an object, our brain extracts the salient points in such a way that factors such as orientation, size, perspective, and illumination don't matter.</p><p>A chair that is double the normal size and rotated by 45 degrees is still a chair. We can easily recognize it because of the way we process it. Machines cannot do this so easily. Humans tend to remember an object based on its shape and important features. Regardless of how the object is placed, we can still recognize it. In our visual system, we build these hierarchical invariances with respect to position, scale, and viewpoint that help us to be very robust.</p><p>If you look deeper in our system, you will see that humans have cells in their visual cortex that can respond to shapes, such as curves and lines. As we move further along our ventral stream, we will see more complex cells that are trained to respond to more complex objects, such as trees, gates, and so on. The neurons along our ventral stream tend to show an increase in the size of the receptive field. This is coupled with the fact that the complexity of their preferred stimuli increases as well.</p><div class="section" title="Why is it difficult for machines to understand image content?"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec08"/>Why is it difficult for machines to understand image content?</h2></div></div></div><p>We<a id="id5" class="indexterm"/> now understand how visual data enters the human visual system and how our system processes it. The issue is that we still don't completely understand how our brain recognizes and organizes this visual data. We just extract some features from images and ask the computer to learn from them using machine learning algorithms. We still have those variations such as shape, size, perspective, angle, illumination, occlusion, and so on. For example, the same chair looks very different to a machine when you look at it from the side view. Humans can easily recognize that it's a chair regardless of how it's presented to us. So, how do we explain this to our machines?</p><p>One way to do this would be to store all the different variations of an object, including <span class="emphasis"><em>sizes</em></span>, <span class="emphasis"><em>angles</em></span>, <span class="emphasis"><em>perspectives</em></span>, and so on. But this process is cumbersome and time-consuming! Also, it's actually not possible to gather data that can encompass every single variation. The machines will consume a huge amount of memory and a lot of time to build a model that can recognize these objects. Even with all this, if an object is partially occluded, computers still won't be able to recognize it. This is because they think that this is a new object. So, when <a id="id6" class="indexterm"/>we build a Computer Vision library, we need to build the underlying functional blocks that can be combined in many different ways to formulate complex algorithms. OpenCV provides a lot of these functions and they are highly optimized. So, once we understand what OpenCV provides out of the box, we can use it effectively to build interesting applications. Let's go ahead and explore this in the next section.</p></div></div>
<div class="section" title="What can you do with OpenCV?"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec10"/>What can you do with OpenCV?</h1></div></div></div><p>Using OpenCV, you<a id="id7" class="indexterm"/> can pretty much do every Computer Vision task that you <a id="id8" class="indexterm"/>can think of. Real-life problems require you to use many blocks together to achieve the desired result. So, you just need to understand what modules and functions to use to get what you want. Let's understand what OpenCV can do out of the box.</p><div class="section" title="In-built data structures and input/output"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec09"/>In-built data structures and input/output</h2></div></div></div><p>One of <a id="id9" class="indexterm"/>the best things about OpenCV is that it provides a lot of in-built primitives to handle operations related to image processing and Computer Vision. If you have to write something from scratch, you will have to define things, such <a id="id10" class="indexterm"/>as an <span class="emphasis"><em>image</em></span>, <span class="emphasis"><em>point</em></span>, <span class="emphasis"><em>rectangle</em></span>, and so on. These are fundamental to almost any Computer Vision algorithm. OpenCV comes with all these basic structures out of the box, and they are contained in the <code class="literal">core</code> module. Another advantage is that these structures have already been optimized for speed and memory, so you don't have to worry about the implementation details.</p><p>The <code class="literal">imgcodecs</code> module handles reading and writing image files. When you operate on an input image and create an output image, you can save it as a <code class="literal">jpg</code> or a <code class="literal">png</code> file with a simple command. You will be dealing with a lot of video files when you are working with cameras. The <code class="literal">videoio</code> module handles everything related to the input/output of video files. You can easily capture a video from a webcam or read a video file in many different formats. You can even save a bunch of frames as a video file by setting properties such as frames per second, frame size, and so on.</p></div><div class="section" title="Image processing operations"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec10"/>Image processing operations</h2></div></div></div><p>When you <a id="id11" class="indexterm"/>write a Computer Vision algorithm, there are a lot of basic image processing operations that you will use over and over again. Most of these functions are present in the <code class="literal">imgproc</code> module. You can do things such as image filtering, morphological operations, geometric transformations, color conversions, drawing <a id="id12" class="indexterm"/>on images, histograms, shape analysis, motion analysis, feature detection, and so on. Let's consider the following figure:</p><div class="mediaobject"><img src="graphics/B04283_01_03.jpg" alt="Image processing operations"/></div><p>The right-hand side image is a rotated version of the left-hand side image. We can do this transformation with a single line in OpenCV. There is another module called <code class="literal">ximgproc</code> that contains advanced image processing algorithms such as structured forests for edge detection, domain transform filters, adaptive manifold filters, and so on.</p></div><div class="section" title="Building GUI"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec11"/>Building GUI</h2></div></div></div><p>OpenCV provides <a id="id13" class="indexterm"/>a module called <code class="literal">highgui</code> that handles all the high-level user interface operations. Let's say that you are working on a problem and you want to check what the image looks like before you proceed to the next step. This module has functions that can be used to create windows to display images and/or video. There is also a waiting function that will wait until you hit a key on your keyboard before it goes to the next step. There is a function that can detect mouse events as well. This is very useful to develop interactive applications. Using this functionality, you can draw rectangles on these input windows and then proceed based on the selected region. </p><p>Consider the following image:</p><div class="mediaobject"><img src="graphics/B04283_01_04.jpg" alt="Building GUI"/></div><p>As you can see, we <a id="id14" class="indexterm"/>have drawn a green rectangle on the image and applied a <span class="emphasis"><em>negative film</em></span> effect to that region. Once we have the coordinates of this rectangle, we can operate only on that region.</p></div><div class="section" title="Video analysis"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec12"/>Video analysis</h2></div></div></div><p>Video analysis <a id="id15" class="indexterm"/>includes tasks such as analyzing the motion between successive frames in a video, tracking different objects in a video, creating models for video surveillance, and so on. OpenCV provides a module called <code class="literal">video</code> that can handle all of this. There is a module called <code class="literal">videostab</code> that deals with video stabilization. Video stabilization is an important part of video cameras. When you capture videos by holding the camera in your hands, it's hard to keep your hands perfectly steady. If you look at that video as it is, it will look bad and jittery. All modern devices use video stabilization techniques to process the videos before they are presented to the end user.</p></div><div class="section" title="3D reconstruction"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec13"/>3D reconstruction</h2></div></div></div><p>3D reconstruction <a id="id16" class="indexterm"/>is an important topic in Computer Vision. Given a set of 2D images, we can reconstruct the 3D scene using the relevant algorithms. OpenCV provides algorithms that can find the relationship between various objects in these 2D images to compute their 3D positions. We have a module called <code class="literal">calib3d</code> that can handle all this. This module can also handle camera calibration, which is essential to estimate the parameters of the camera. These parameters are basically the internal parameters of any given camera that uses them to transform the captured scene into an image. We need to know these parameters to design algorithms, or else we might get unexpected results. Let's consider the following figure:</p><div class="mediaobject"><img src="graphics/B04283_01_05.jpg" alt="3D reconstruction"/></div><p>As shown in the preceding image, the same object is captured from multiple poses. Our job is to reconstruct <a id="id17" class="indexterm"/>the original object using these 2D images.</p></div><div class="section" title="Feature extraction"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec14"/>Feature extraction</h2></div></div></div><p>As<a id="id18" class="indexterm"/> discussed earlier, the human visual system tends to extract the salient features from a given scene so that it can be retrieved later. To mimic this, people started designing various feature extractors that can extract these salient points from a given image. Some of the popular algorithms include <span class="strong"><strong>SIFT</strong></span> (<span class="strong"><strong>Scale Invariant Feature Transform</strong></span>), <span class="strong"><strong>SURF</strong></span> (<span class="strong"><strong>Speeded Up Robust Features</strong></span>), <span class="strong"><strong>FAST</strong></span> (<span class="strong"><strong>Features from Accelerated Segment Test</strong></span>), and so on. There is a module called <code class="literal">features2d</code> that provides functions to detect and extract all these features. There is another module called <code class="literal">xfeatures2d</code> that provides a few more feature extractors, some of which are still in the experimental phase. You can play around with these if you get a chance. There is also a module called <code class="literal">bioinspired</code> that provides algorithms for biologically inspired Computer Vision models.</p></div><div class="section" title="Object detection"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec15"/>Object detection</h2></div></div></div><p>Object detection <a id="id19" class="indexterm"/>refers to detecting the location of an object in a given image. This process is not concerned with the type of object. If you design a chair detector, it will just tell you the location of the chair in a given image. It will not tell you whether it's a red chair with a high back or a blue chair with a low back. Detecting the location of objects is a very critical step in many Computer Vision systems. Consider the following image:</p><div class="mediaobject"><img src="graphics/B04283_01_06.jpg" alt="Object detection"/></div><p>If you run a <a id="id20" class="indexterm"/>chair detector on this image, it will put a green box around all the chairs. It won't tell you what kind of chair it is! Object detection used to be a computationally intensive task because of the number of calculations required to perform the detection at various scales. To solve this, Paul Viola and Michael Jones came up with a great algorithm in their seminal paper in 2001. You can read it at <a class="ulink" href="https://www.cs.cmu.edu/~efros/courses/LBMV07/Papers/viola-cvpr-01.pdf">https://www.cs.cmu.edu/~efros/courses/LBMV07/Papers/viola-cvpr-01.pdf</a>. They provided a fast way to design an object detector for any object. OpenCV has modules called <code class="literal">objdetect</code> and <code class="literal">xobjdetect</code> that provide the framework to design an object detector. You can use it to develop detectors for random items such as sunglasses, boots, and so on.</p></div><div class="section" title="Machine learning"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec16"/>Machine learning</h2></div></div></div><p>Computer Vision <a id="id21" class="indexterm"/>uses various machine learning algorithms to achieve different things. OpenCV provides a module called <code class="literal">ml</code> that has many machine learning algorithms bundled into it. Some of the algorithms include Bayes Classifier, K-Nearest Neighbors, Support Vector Machines, Decision Trees, Neural Networks, and so on. It also has a module called <code class="literal">flann</code> that contains algorithms for fast-nearest-neighbor searches in large datasets. Machine learning algorithms are used extensively to build systems for object recognition, image classification, face detection, visual searches, and so on.</p></div><div class="section" title="Computational photography"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec17"/>Computational photography</h2></div></div></div><p>Computational photography<a id="id22" class="indexterm"/> refers to using advanced image processing techniques to improve the images captured by cameras. Instead of focusing on optical processes and image capture methods, computational photography uses software to manipulate visual data. Some applications include high dynamic range imaging, panoramic images, image relighting, light field cameras, and so on. </p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip02"/>Tip</h3><p>
<span class="strong"><strong>Downloading the example code</strong></span>
</p><p>You can download the example code files for all Packt books you have purchased from your account at <a class="ulink" href="http://www.packtpub.com">http://www.packtpub.com</a>. If you purchased this book elsewhere, you can visit <a class="ulink" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you. Instructions for running example are available in the <code class="literal">README.md</code> file present in the root folder of each project.</p></div></div><p>Let's take a look at the following image:</p><div class="mediaobject"><img src="graphics/B04283_01_07.jpg" alt="Computational photography"/></div><p>Look at those vivid colors! This is an example of a high dynamic range image and it wouldn't be possible to get this using conventional image capture techniques. To do this, we have to capture the same scene at multiple exposures, register those images with each other, and then blend them nicely to create this image. The <code class="literal">photo</code> and <code class="literal">xphoto</code> modules contain various algorithms that provide algorithms pertaining to computational photography. There is a module called <code class="literal">stitching</code> that provides algorithms to create panoramic images.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note02"/>Note</h3><p>The preceding image can be found at <a class="ulink" href="https://pixabay.com/en/hdr-high-dynamic-range-landscape-806260/">https://pixabay.com/en/hdr-high-dynamic-range-landscape-806260/</a>.</p></div></div></div><div class="section" title="Shape analysis"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec18"/>Shape analysis</h2></div></div></div><p>The <a id="id23" class="indexterm"/>notion of shape is crucial in Computer Vision. We analyze the visual data by recognizing various different shapes in the image. This is actually an important step in many algorithms. Let's say you are trying to identify a particular logo in an image. Now, you know that it can appear in various shapes, orientations, sizes, and so on. One good way to get started is to quantify the characteristics of the shape of the object. The module <code class="literal">shape</code> provides all the algorithms required to extract different shapes, measure similarities between them, transform shapes of objects, and so on.</p></div><div class="section" title="Optical flow algorithms"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec19"/>Optical flow algorithms</h2></div></div></div><p>Optical flow algorithms <a id="id24" class="indexterm"/>are used in videos to track features across successive frames. Let's say you want to track a particular object in a video. Running a feature extractor on each frame would be computationally expensive; hence, the process would be slow. So, you just need to extract the features from the current frame and then track these features in successive frames. Optical flow algorithms are heavily used in video-based applications in Computer Vision. The <code class="literal">optflow</code> module contains a number of algorithms required to perform optical flow. There is also a module called <code class="literal">tracking</code> that contains more algorithms that can be used to track features.</p></div><div class="section" title="Face and object recognition"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec20"/>Face and object recognition</h2></div></div></div><p>Face recognition <a id="id25" class="indexterm"/>refers to identifying the person in a given image. This is not the same as face detection where you identify the location of a face in the given image. So, if you want to build a practical biometric system that can recognize the person in front of the camera, you first need to run the face detector that can identify the location of the face, and then, run a face recognizer that can recognize who that person is. There is a module called <code class="literal">face</code> that deals with face recognition.</p><p>As <a id="id26" class="indexterm"/>discussed earlier, Computer Vision tries to model algorithms based on how humans perceive the visual data. So, it would be helpful to find salient regions and objects in the images that can help different applications, such as object recognition, object detection and tracking, and so on. There is a module called <code class="literal">saliency</code> that's designed for this purpose. It provides algorithms that can detect salient regions in static images and videos.</p></div><div class="section" title="Surface matching"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec21"/>Surface matching</h2></div></div></div><p>We are <a id="id27" class="indexterm"/>increasingly interacting with devices that can capture the 3D structure of the objects around us. These devices basically capture the depth information along with the regular 2D color images. So, it's important for us to build algorithms that can understand and process 3D objects. Kinect is a good example of a device that captures the depth information along with the visual data. The task at hand is to recognize the input 3D object by matching it with one of the models in our database. If we have a <a id="id28" class="indexterm"/>system that can recognize and locate objects, then it can be used for many different applications. There is a module called <code class="literal">surface_matching</code> that contains algorithms for 3D object recognition and a pose estimation algorithm using 3D features.</p></div><div class="section" title="Text detection and recognition"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec22"/>Text detection and recognition</h2></div></div></div><p>Identifying <a id="id29" class="indexterm"/>text in a given scene and recognizing the content is becoming increasingly important. Some applications include nameplate recognition, recognizing road signs for self-driving cars, book scanning to digitize the contents, and so on. There is a module called <code class="literal">text</code> that contains various algorithms to handle text detection and recognition.</p></div></div>
<div class="section" title="Installing OpenCV"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec11"/>Installing OpenCV</h1></div></div></div><p>Let's see <a id="id30" class="indexterm"/>how to get OpenCV up-and-running on various operating systems.</p><div class="section" title="Windows"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec23"/>Windows</h2></div></div></div><p>To keep <a id="id31" class="indexterm"/>things easy, let's<a id="id32" class="indexterm"/> install OpenCV using prebuilt libraries. Let's go to <a class="ulink" href="http://opencv.org">http://opencv.org</a> and download the latest version for Windows. The current version is 3.0.0, and you can go to the OpenCV homepage to get the latest link to download the package.</p><p>You need <a id="id33" class="indexterm"/>to make sure you have admin rights before you proceed. The downloaded file will be an executable file, so just double-click on it to start the installation process. The installer expands the content into a folder. You will be able to choose the installation path and check the installation by inspecting the files.</p><p>Once you are done with the previous step, we need to set the OpenCV environment variables and add it to the system path to complete the installation. We will set up an environment variable that will hold the build directory of the OpenCV library. We will be using this in our projects. Open the terminal and type the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>C:\&gt; setx -m OPENCV_DIR D:\OpenCV\Build\x64\vc11</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note03"/>Note</h3><p>We are assuming that you have a 64-bit machine with Visual Studio 2012 installed. If you have Visual Studio 2010, replace <code class="literal">vc11</code> with <code class="literal">vc10</code> in the preceding command. The path specified earlier is where we will have our OpenCV binaries, and you will see two folders inside this path called <code class="literal">lib</code> and <code class="literal">bin</code>. If you are using Visual Studio 2015, you should be able to compile OpenCV from scratch.</p></div></div><p>Let's go <a id="id34" class="indexterm"/>ahead and add the path to the <code class="literal">bin</code> folder of our system's path. The reason we need to do this is because we will be using the OpenCV library <a id="id35" class="indexterm"/>in the form of <a id="id36" class="indexterm"/>
<span class="strong"><strong>Dynamic Link Libraries</strong></span> (<span class="strong"><strong>DLLs</strong></span>). Basically, all the OpenCV algorithms are stored here, and our operating system will only load them during runtime. In order to do this, our operating system needs to know where they are located. The system's <code class="literal">PATH</code> variable will contain a list of all the folders where it can find the DLLs. So, naturally, we need to add the path to the OpenCV library to this list. Now, why do we need to do all this? Well, the other option is to copy the required DLLs to the same folder as the application's executable file (the <code class="literal">.exe</code> file). This is an unnecessary overhead, especially when we are working with many different projects.</p><p>We need to edit the <code class="literal">PATH</code> variable in order to add it to this folder. You can use software such as <code class="literal">Path Editor</code> to do <a id="id37" class="indexterm"/>this. You can download it from <a class="ulink" href="https://patheditor2.codeplex.com">https://patheditor2.codeplex.com</a>. Once you install it, start it and add the following new entry (you can right-click on the path to insert a new item):</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>%OPENCV_DIR%\bin</strong></span>
</pre></div><p>Go ahead and save it to the registry. We are done!</p></div><div class="section" title="Mac OS X"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec24"/>Mac OS X</h2></div></div></div><p>In this <a id="id38" class="indexterm"/>section, we will see how to install OpenCV on Mac OS X. Precompiled binaries are not available for Mac OS X, so we need to<a id="id39" class="indexterm"/> compile OpenCV from scratch. Before we proceed, we need to install<a id="id40" class="indexterm"/> CMake. If you don't have CMake already installed, you can download it from <a class="ulink" href="https://cmake.org/files/v3.3/cmake-3.3.2-Darwin-x86_64.dmg">https://cmake.org/files/v3.3/cmake-3.3.2-Darwin-x86_64.dmg</a>. It's a <code class="literal">dmg</code> file! So, once you download it, just run the installer.</p><p>Download the latest version of OpenCV from opencv.org. The current version is 3.0.0, and you can download it from <a class="ulink" href="https://github.com/Itseez/opencv/archive/3.0.0.zip">https://github.com/Itseez/opencv/archive/3.0.0.zip</a>.</p><p>Unzip the contents into a folder of your choice. OpenCV 3.0.0 also has a new package called <code class="literal">opencv_contrib</code> that contains user contributions that are not yet considered stable. One thing to keep in mind is that some of the algorithms in the <code class="literal">opencv_contrib</code> package are not freely available for commercial use. Also, installing this package is optional. OpenCV will work just fine if you don't install <code class="literal">opencv_contrib</code>. Since we are installing OpenCV <a id="id41" class="indexterm"/>anyway, it's good to install this package so that you can experiment with it later on (as opposed to going through the whole installation process again). This package is a great way to learn and play around with new algorithms. You can download it from <a class="ulink" href="https://github.com/Itseez/opencv_contrib/archive/3.0.0.zip">https://github.com/Itseez/opencv_contrib/archive/3.0.0.zip</a>.</p><p>Unzip the contents of the ZIP file into a folder of your choice. For convenience, unzip it into the same folder, as mentioned earlier, so that the <code class="literal">opencv-3.0.0</code> and <code class="literal">opencv_contrib-3.0.0</code> folders are in the same main folder.</p><p>We are <a id="id42" class="indexterm"/>now ready to build OpenCV. Open your terminal and navigate to the folder where you unzipped the contents of OpenCV 3.0.0. Run the following commands after substituting the right paths in the commands:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cd /full/path/to/opencv-3.0.0/</strong></span>
<span class="strong"><strong>$ mkdir build</strong></span>
<span class="strong"><strong>$ cd build</strong></span>
<span class="strong"><strong>$ cmake -D CMAKE_BUILD_TYPE=RELEASE -D CMAKE_INSTALL_PREFIX=/full/path/to/opencv-3.0.0/build -D INSTALL_C_EXAMPLES=ON -D BUILD_EXAMPLES=ON -D OPENCV_EXTRA_MODULES_PATH=/full/path/to/opencv_contrib-3.0.0/modules ../</strong></span>
</pre></div><p>It's time to install OpenCV 3.0.0. Go inside the <code class="literal">/full/path/to/opencv-3.0.0/build</code> directory and run the following commands on your terminal:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ make -j4</strong></span>
<span class="strong"><strong>$ make install</strong></span>
</pre></div><p>In the preceding command, the <code class="literal">-j4</code> flag indicates that it is using four cores to install it. It's faster this way! Now, let's set the library path. Open your <code class="literal">~/.profile</code> file in your terminal using the <code class="literal">vi ~/.profile</code> command, and add the following line:</p><div class="informalexample"><pre class="programlisting">export DYLD_LIBRARY_PATH=/full/path/to/opencv-3.0.0/build/lib:$DYLD_LIBRARY_PATH</pre></div><p>We need to copy the <code class="literal">pkg-config</code> file <code class="literal">opencv.pc</code> to <code class="literal">/usr/local/lib/pkgconfig</code> and name it <code class="literal">opencv3.pc</code>. This way, if you already have an existing <code class="literal">OpenCV 2.4.x</code> installation, there will be no conflicts. Let's go ahead and do this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cp /full/path/to/opencv-3.0.0/build/lib/pkgconfig/opencv.pc /usr/local/lib/pkgconfig/opencv3.pc</strong></span>
</pre></div><p>We need to update our <code class="literal">PKG_CONFIG_PATH</code> variable as well. Open your <code class="literal">~/.profile</code> file, and add the following line:</p><div class="informalexample"><pre class="programlisting">export PKG_CONFIG_PATH=/usr/local/lib/pkgconfig/:$PKG_CONFIG_PATH</pre></div><p>Reload your <code class="literal">~/.profile</code> file using the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ source ~/.profile</strong></span>
</pre></div><p>We are <a id="id43" class="indexterm"/>done! Let's see if it's working:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cd /full/path/to/opencv-3.0.0/samples/cpp</strong></span>
<span class="strong"><strong>$ g++ -ggdb 'pkg-config --cflags --libs opencv3' opencv_version.cpp -o /tmp/opencv_version &amp;&amp; /tmp/opencv_version</strong></span>
</pre></div><p>If you see <code class="literal">Welcome to OpenCV 3.0.0</code> printed on your terminal, you are good to go. We will be<a id="id44" class="indexterm"/> using CMake to build our OpenCV projects throughout this book. We will cover this in more detail in the next chapter.</p></div><div class="section" title="Linux"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec25"/>Linux</h2></div></div></div><p>Let's <a id="id45" class="indexterm"/>see how to install OpenCV on Ubuntu. We need<a id="id46" class="indexterm"/> to install some dependencies before we begin. Let's install them using the package manager by running the following command on your terminal:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo apt-get -y install libopencv-dev build-essential cmake libdc1394-22 libdc1394-22-dev libjpeg-dev libpng12-dev libtiff4-dev libjasper-dev libavcodec-dev libavformat-dev libswscale-dev libxine-dev libgstreamer0.10-dev libgstreamer-plugins-base0.10-dev libv4l-dev libtbb-dev libqt4-dev libmp3lame-dev libopencore-amrnb-dev libopencore-amrwb-dev libtheora-dev libvorbis-dev libxvidcore-dev x264 v4l-utils</strong></span>
</pre></div><p>Now that you have installed the dependencies, let's download, build, and install OpenCV:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ wget "https://github.com/Itseez/opencv/archive/3.0.0.zip" -O opencv.zip</strong></span>
<span class="strong"><strong>$ wget "https://github.com/Itseez/opencv_contrib/archive/3.0.0.zip" -O opencv_contrib.zip</strong></span>
<span class="strong"><strong>$ unzip opencv.zip –d .</strong></span>
<span class="strong"><strong>$ unzip opencv_contrib.zip –d .</strong></span>
<span class="strong"><strong>$ cd opencv-3.0.0</strong></span>
<span class="strong"><strong>$ mkdir build</strong></span>
<span class="strong"><strong>$ cd build</strong></span>
<span class="strong"><strong>$ cmake -D CMAKE_BUILD_TYPE=RELEASE -D CMAKE_INSTALL_PREFIX=/full/path/to/opencv-3.0.0/build -D INSTALL_C_EXAMPLES=ON -D BUILD_EXAMPLES=ON -D OPENCV_EXTRA_MODULES_PATH=/full/path/to/opencv_contrib-3.0.0/modules ../</strong></span>
<span class="strong"><strong>$ make –j4</strong></span>
<span class="strong"><strong>$ sudo make install</strong></span>
</pre></div><p>Let's copy the <code class="literal">pkg-config</code> file's <code class="literal">opencv.pc</code> to <code class="literal">/usr/local/lib/pkgconfig</code> and name it <code class="literal">opencv3.pc</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cp /full/path/to/opencv-3.0.0/build/lib/pkgconfig/opencv.pc /usr/local/lib/pkgconfig/opencv3.pc</strong></span>
</pre></div><p>We are done! We<a id="id47" class="indexterm"/> will now be able to use it to compile our OpenCV programs from the command line. Also, if you already have an existing OpenCV 2.4.x installation, there will be no conflicts. Let's check whether the installation is working properly:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cd /full/path/to/opencv-3.0.0/samples/cpp</strong></span>
<span class="strong"><strong>$ g++ -ggdb 'pkg-config --cflags --libs opencv3' opencv_version.cpp -o /tmp/opencv_version &amp;&amp; /tmp/opencv_version</strong></span>
</pre></div><p>If you <a id="id48" class="indexterm"/>see <code class="literal">Welcome to OpenCV 3.0.0</code> printed on your terminal, you are good to go. In the following chapters, you will learn how to use CMake to build your OpenCV projects.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec12"/>Summary</h1></div></div></div><p>In this chapter, we learned how to install OpenCV across various operating systems. We discussed the human visual system and how humans process visual data. We understood why it's difficult for machines to do the same and what we need to consider while designing a Computer Vision library. We learned what can be done using OpenCV and the various modules that can be used to do those tasks.</p><p>In the next chapter, we will discuss how to operate on images and how we can manipulate them using various functions. We will also learn how to build a project structure for our OpenCV applications.</p></div></body></html>