- en: Time Series Analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will take a look at time series analysis and learn several
    ways of observing and capturing an event at different points in time. We will
    introduce the concept of white noise and learn about its detection in a series.
  prefs: []
  type: TYPE_NORMAL
- en: We will take the time series data and compute the differences between the consecutive
    observations, which will lead to the formation of a new series. These concepts
    will help us deep dive into time series analysis and help us build a deeper understanding around
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to time series analysis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: White noise
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Random walk
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Autoregression
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Autocorrelation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stationarity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Differencing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AR model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moving average model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Autoregressive integrated moving average
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimization of parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anomaly detection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to time series analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are several occasions when we might try to observe and capture an event
    at different points in time. Often, we would end up drawing a correlation or association
    between adjacent observations that cannot be handled by an approach that deals
    with data that is independent and identically distributed. The approach that takes
    all of this into consideration in a mathematical and statistical manner is called
    **time series analysis**.
  prefs: []
  type: TYPE_NORMAL
- en: Time series analysis has been used in a number of fields, such as the automotive,
    banking, and retail industries, product development, and so on. There is no boundary
    for its use, and so analysts and data scientists are exploring this area to the
    hilt in order to derive the maximum benefit for organizations.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will go through a few of the concepts around time series
    analysis that will lay the foundation for a deeper understanding in the future.
    Once we have established this foundation, we will jump into modeling.
  prefs: []
  type: TYPE_NORMAL
- en: White noise
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A simple series with a collection of uncorrelated random variables with a mean
    of zero and a standard deviation of *σ²* is called **white noise**. In this, variables
    are independent and identically distributed. All values have the same variance
    of *σ²*. In this case, the series is drawn from Gaussian distribution, and is
    called **Gaussian white noise**.
  prefs: []
  type: TYPE_NORMAL
- en: When the series turns out to be white noise, it implies that the nature of the
    series is totally random and there is no association within the series. As a result,
    the model can't be developed, and prediction is not possible in this scenario.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, when we typically build a time series model with a nonwhite noise
    series, we try to attain a white noise phenomenon within the residuals or errors.
    In simple terms, whenever we try to build a model, the motive is to extract the
    maximum amount of information from the series so that no more information exists
    in the variable. Once we build a model, noise will always be part of it. The equation
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Y[t ]= X[t ]+ Error*'
  prefs: []
  type: TYPE_NORMAL
- en: So the error series should be totally random in nature, which implies that it
    is white noise. If we have got these errors as white noise, then we can go ahead
    and say that we have extracted all the information possible from the series.
  prefs: []
  type: TYPE_NORMAL
- en: Detection of white noise in a series
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can detect white noise by using the following tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Line plot**: Once we have a line plot, we can have an idea of whether the
    series has a constant mean and variance'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Autocorrelation plot**: Having a correlation plot can give us an inkling
    as to whether there is an association among lagged variables'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Summary**: Checking the mean and variance of the series against the mean
    and variance of meaningful contiguous blocks of values in the series'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s do this in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will import all the required libraries as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will set up the white noise series for us to analyze, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take the summary or statistic of it using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c34dd0d9-d796-4882-816c-dee770bd9a29.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, we can see that the mean is approaching zero and the standard deviation
    is close to 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make a line plot now to check out the trend, using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/50887a2b-3c88-4223-9981-e0c20423e3af.png)'
  prefs: []
  type: TYPE_IMG
- en: The line plot looks totally random, and no trend can be observed here.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s time to make an autocorrelation plot. Let''s set one up using the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e38f049f-3af8-46b0-9f7a-97db972126ff.png)'
  prefs: []
  type: TYPE_IMG
- en: Even in an **autocorrelation** function plot, the correlation breaches the band
    of our confidence level. This tells us that it is a white noise series.
  prefs: []
  type: TYPE_NORMAL
- en: Random walk
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Random walk is a time series model where the current observation is equal to
    the previous observations with a random modification. It can be described in the
    following manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '* x[t]= x[t-1 ]+ w[t]*'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding formula, *w[t]*is a white noise series.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, we might come across a series that reflects irregular growth. In
    these cases, the strategy to predict the next level won''t be the correct one.
    Rather, it might be better to try to predict the change that occurs from one period
    to the next—that is, it may be better to look at the first difference of the series
    in order to find out a significant pattern. The following figure shows a random
    walk pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ff0118d8-02d9-447b-91bf-e85f8320c801.png)'
  prefs: []
  type: TYPE_IMG
- en: In each time period, going from left to right, the value of the variable takes
    an independent random step up or down, which is called a **random walk**.
  prefs: []
  type: TYPE_NORMAL
- en: 'It can also be described in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '*y(t)= b[o ]+ b[1]*x[t-1] + w[t]*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following list explains the preceding formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '*y(t)*: Next value in the series'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*b[o]*: Coefficient, which, if set to a number other than zero, means that
    the random walk comes along with a drift'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*b[1]*: Coefficient, which is set to 1'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*w[t]***:** White noise'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Autoregression
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An autoregression is a time series model that typically uses the previous values
    of the same series as an explanatory factor for the regression in order to predict
    the next value. Let''s say that we have measured and kept track of a metric over
    time, called *y[t]*, which is measured at time *t* when this value is regressed
    on previous values from that same time series. For example, *y[t]*on *y[t-1]*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1724339d-2858-4f5d-a54f-5a0f39cad697.png)'
  prefs: []
  type: TYPE_IMG
- en: As shown in the preceding equation, the previous value *y[t-1]* has become the
    predictor here and *y[t]* is the response value that is to be predicted. Also,
    *ε[t]* is normally distributed with a mean of zero and variance of 1. The order
    of the autoregression model is defined by the number of previous values that are
    being used by the model to determine the next value. Therefore, the preceding
    equation is a first-order autoregression, or **AR(1)**. If we have to generalize
    it, a *k*^(*th* )order autoregression, written as **AR(k)**, is a multiple linear
    regression in which the value of the series at any time (*t*) is a (linear) function
    of the values at times *t−1*, *t−2*, …,*t−k.*
  prefs: []
  type: TYPE_NORMAL
- en: 'The following list shows what the following values means for an AR(1) model:'
  prefs: []
  type: TYPE_NORMAL
- en: When *β[1 ]= 0*, *y**t*, itis equivalent to white noise
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When *β[1 ]= 1* and *β[0]= 0*, *y[t]*, it is equivalent to a random walk
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When *β[1 ]= 1* and *β[0 ]≠ 0*, *y[t]*, it is equivalent to a random walk with
    drift
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When *β[1 ]< 1*, *y[t]*, it tends to oscillate between positive and negative
    values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Autocorrelation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Autocorrelation is a measure of the correlation between the lagged values of
    a time series. For example, *r[1]* is the autocorrelation between *y[t ]*and *y[t-1;]* similarly,
    *r[2 ]*is the autocorrelation between *y[t ]*and *y[t-2]*. This can be summarized
    in the following formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a10d9b15-19a3-45ce-bb47-e2c67c544a52.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding formula, *T* is the length of the time series.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, say that we have the correlation coefficients, as shown in the
    following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/46e209e2-3a8f-4332-a0e4-6df905f03963.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To plot it, we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ae116bfd-56ab-48d8-bc93-ff04987c4eda.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following are some observations from this autocorrelation function plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '**r[4]** is higher than other lags, which is mostly because of a seasonal pattern'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The blue lines are the indicators of whether correlations are significantly
    different from zero
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Autocorrelation at lag 0 is always 1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stationarity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A common assumption for a few of the time series models is that data has to
    be stationary. Let's look at what stationarity means regarding time series.
  prefs: []
  type: TYPE_NORMAL
- en: A stationary process is one for which the mean, variance, and autocorrelation
    structure doesn't change over time. What this means is that the data doesn't have
    a trend (increasing or decreasing).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can describe this by using the following formulas:'
  prefs: []
  type: TYPE_NORMAL
- en: '*E(x[t])= μ*, for all *t*'
  prefs: []
  type: TYPE_NORMAL
- en: '*E(x[t]²)= σ*^(*2*), for all *t*'
  prefs: []
  type: TYPE_NORMAL
- en: '*cov(x[t],x[k])= cov(x[t+s], x[k+s])*, for all *t*, *k*, and s'
  prefs: []
  type: TYPE_NORMAL
- en: Detection of stationarity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are multiple methods that can help us in figuring out whether the data
    is stationary, listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Plotting the data**: Having a plot of the data with respect to the time variable
    can help us to see whether it has got a trend. We know from the definition of
    stationarity that a trend in the data means that there is no constant mean and
    variance. Let''s do this in Python. For this example, we are using international
    airline passenger data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'First, let''s load all the required libraries, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/25b20f75-7749-4a04-b737-86f0c5e65b7e.png)'
  prefs: []
  type: TYPE_IMG
- en: It is quite clear from the plot that there is an increasing trend here and that
    it would vindicate our hypothesis that it is a non-stationary series.
  prefs: []
  type: TYPE_NORMAL
- en: '**Dividing the data set and computing the summary**: The next method would
    be to divide the data series into two parts and compute the mean and variance.
    By doing this, we will be able to figure out whether the mean and variance are
    constant. Let''s do this by using the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the mean and variance of series 1 and series 2 are not equal,
    and so we can conclude that the series is not stationary.
  prefs: []
  type: TYPE_NORMAL
- en: '**Augmented Dickey-Fuller test**: The augmented Dickey-Fuller test is a statistical
    test that tends to give an indication with a certain level of confidence as to
    whether the series is stationary. A statistical test takes the data and tests
    our hypothesis about the data using its assumption and process. Eventually, it
    yields the result with a certain degree of confidence, which helps us in taking
    the decision.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This test is nothing but the unit root test, which tries to find out whether
    the time series is influenced by the trend. It makes use of the **autoregressive**
    (**AR**) model and optimizes the information criterion at different lag values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, the null hypothesis is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '***H[o]***: The time series has got the unit root, which implies that the series
    is nonstationary'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The alternate hypothesis is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '***H[1]***: The time series doesn''t have a unit root and, as such, it is stationary'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As we know from the rules of hypothesis testing, if we have chosen a significance
    level of 5% for the test, then the result would be interpreted as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: If *p-value >0.05* =>, then we fail to reject the null hypothesis. That is,
    the series is nonstationary.
  prefs: []
  type: TYPE_NORMAL
- en: If *p-value <0.05* =>, then the null hypothesis is rejected which means that the
    series is stationary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s perform this in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will load the libraries, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we load the data and time plot as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The output can be seen in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a4fd26e4-ca81-4934-9e9c-41d4270d9dc6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We then parse the data as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We then get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/981dfc7c-4087-4ad9-adef-0e20d45ce0ff.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'From this, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c73847fc-b69f-407c-89f7-00a57ed3637d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then we plot the graph, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The output can be seen as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ab3a758d-f7b4-49a8-a902-8698cdd85b52.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s create a function to perform a stationarity test using the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The output can be seen as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5eac6c3a-a6f6-4d71-b144-8c49b23ac8ba.png)'
  prefs: []
  type: TYPE_IMG
- en: Since *p-value > 0.05* and the *t*-statistic is greater than all the critical
    values (1%,5%,10%), *tt* implies that the series is nonstationary as we failed
    to reject the null hypothesis.
  prefs: []
  type: TYPE_NORMAL
- en: So what can be done if the data is nonstationary? We use differencing to make
    the nonstationary data into stationary data.
  prefs: []
  type: TYPE_NORMAL
- en: AR model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An AR model is a part of the stochastic process, wherein specific lagged values
    of *y[t]* are used as predictor variables and regressed on *y[t ]*in order to
    estimate its values. Lagged values are values of the series of the previous period
    that tend to have an impact on the current value of the series. Let's look at
    an example. Say we have to assess and predict tomorrow's weather. We would start
    by thinking of what today's weather is and what yesterday's weather was, as this
    will help us in predicting whether it will be rainy, bright and sunny, or cloudy.
    Subconsciously, we are also cognizant of the fact that the weather of the previous
    day might have an association with today's weather. This is what we call an **AR
    model**.
  prefs: []
  type: TYPE_NORMAL
- en: 'This has a degree of uncertainty that results in less accuracy in the prediction
    of future values. The formula is the same as the formula for a series with *p*
    lag, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2a650119-f373-4979-bbe5-e04705f4def8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the previous equation,* ω* is the white noise term and *α* is the coefficient,
    which can''t be zero. The aggregated equation appears as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/32d5bfdb-35ea-4877-a922-ed08417f2ab5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Occasionally, we might talk about the order of a model. For example, we might
    describe an AR model as being of order *p*. In this case,the *p* represents the
    number of lagged variables used within the model. For example, an AR(2) model
    or second-orderAR model looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/de8924d2-fec8-4208-99eb-c3ee056e35a1.png)'
  prefs: []
  type: TYPE_IMG
- en: Moving average model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A **moving average model** (**MA**) is a linear combination of historic white
    noise error terms. Let''s have a look at the equation of the model:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/69f46d0d-cecc-4cfe-9d4e-337c2cb62b95.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/399ae830-4338-4610-8ede-adeabdc9eb61.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, *ω* is the white noise with *E(ω[t])=0* and variance =* σ²*.
  prefs: []
  type: TYPE_NORMAL
- en: In order to find out the order of the AR model, we need to plot a partial autocorrelation
    function plot, and then look for the lag where the upper confidence level has
    been crossed for the first time.
  prefs: []
  type: TYPE_NORMAL
- en: Autoregressive integrated moving average
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An **autoregressive integrated moving average** (**ARIMA**) model is a combination
    of the following elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Autoregressive operator**: We have already learned what this means; just
    to reiterate, it is the lags of the stationarized series. It is denoted by *p*,
    which is nothing but the number of autoregressive terms. The PACF plot yields
    this component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integration operator**: A series that needs to be differenced to be made
    stationary is said to be an integrated version of a stationary series. It is denoted
    by *d*, which is the amount of differencing that is needed to transform the nonstationary
    time series into a stationary one. This is done by subtracting the observation
    from the current period from the previous one. If this has been done only once
    to the series, it is called **first differenced**. This process eliminates the
    trend out of the series that is growing at a constant rate. In this case, the
    series is growing at an increasing rate, and the differenced series needs another
    round of differencing, which is called **second differencing**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Moving average operator**: The lags of the forecasted errors, which is denoted
    by *q*. It is the number of lagged forecast errors in the equation. The ACF plot
    would yield this component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ARIMA model can only be applied on stationary series. Therefore, before
    applying it, the stationarity condition has to be checked in the series. The ADF
    test can be performed to establish this.
  prefs: []
  type: TYPE_NORMAL
- en: 'The equation of ARIMA turns looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/627d8248-1c5b-4643-85e4-01d8b54e1444.png)'
  prefs: []
  type: TYPE_IMG
- en: The first part of the equation (before the *-* sign) is the autoregressive section,
    and the second part (after the *-* sign)is the MA section.
  prefs: []
  type: TYPE_NORMAL
- en: We can go ahead and add a seasonal component in ARIMA as well, which would be
    ARIMA *(p,d,q)(p,d,q)[s]*. While adding it, we need to perform seasonal differencing,
    which means subtracting the current observation from the seasonal lag.
  prefs: []
  type: TYPE_NORMAL
- en: Let's plot ACF and PACF in order to find out the *p* and *q *parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we take the number of lags as 20 and use the `statsmodel.tsa.stattools `library to
    import the `acf` and `pacf` functions, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we will plot with the help of `matplotlib` using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/daafb80f-b167-4394-8fc0-c8668dffea4d.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, we are measuring the correlation between the time series with a lagged
    version of itself. For instance, at lag 5, ACF would compare the series at time
    instant *t1*, *t2* with the series at instant *t[1-5]*, *…*, *t[2-5]*. It is a
    plot of the coefficients of the correlation with its lagged values.
  prefs: []
  type: TYPE_NORMAL
- en: If we look at the preceding plot carefully, we will see that the upper confidence
    level line has been crossed at lag 2\. Therefore, the order of MA would be *2*
    and *q=2*.
  prefs: []
  type: TYPE_NORMAL
- en: A partial correlation between the series and lagged values is plotted, and it
    gives us a **partial auto correlation functional** (**PACF**) plot. It's a very
    interesting term. If we go on and compute the correlation between a *Y *variable
    and *X*3 while we know that *Y* has a separation association with *X*1 and *X*2,
    the partial correlation addresses that portion of the correlation that is not
    explained by their correlations with *X*1 and *X*2.
  prefs: []
  type: TYPE_NORMAL
- en: Here, the partial correlation is the square root (reduction in variance by adding
    a variable (here, *X*3) while regressing *Y* on the other variables (here *X*1, *X*2)).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of a time series, partial autocorrelation between Y & lagged value
    Y[t-3] will be the value that is not explained by a correlation between *Y* and
    *Y*[*t*-1] and *Y*[*t*-2], as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3736fa84-2505-4317-a0b0-04f9398d23e1.png)'
  prefs: []
  type: TYPE_IMG
- en: If we look at the preceding plot carefully, we will see that the upper confidence
    level line has been crossed at lag 2\. Therefore, the order of AR would be 2 and
    *p=2*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try out an AR model that is of the order *(p=2, d=1, q=0)*. The *d* value
    has been taken as 1, since it is a case of single differencing. The residual sum
    of the square has been calculated as well to judge how good the model is and compare
    it with others, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The output can be seen as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6302a46b-427d-4c32-9ccd-cd4093856311.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we can have a look at the model summary that depicts the coefficients
    of AR1 and AR2 using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/8386ccb1-d258-419f-bfc0-97f4a536f099.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s build an MA model of the order *(p=0,d=1,q=2)* using the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The output can be seen as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/58645090-67c5-41f9-8af7-fa7641911d6b.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s combine these two models and build an ARIMA model using the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/74a2b07b-767b-4f40-93b7-80652cb8c0dc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can experience a dip in the value of RSS from the AR model to ARIMA. Now
    **RSS= 1.0292**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see the coefficients of AR1, AR2, MA1, and MA2, and, if we go by *p *values,
    we can see that all these parameters are significant, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7ef067a9-23ce-4363-9c3d-23505461dc85.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s turn the predicted values into a series using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4798ec69-cfe0-4653-bcdb-0f09b00e7917.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The way to convert the differencing to log scale is to add these differences
    consecutively to the base number. An easy way to do this is to first determine
    the cumulative sum at the index and then add it to the base number. The cumulative
    sum can be found using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'From this, we will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/44bc962a-af3f-4b2f-beaa-329bc598f642.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We will create a series with all values as the base number and add the differences
    to it in order to add to the base series, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The following shows the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4362a7c6-a3ea-48c2-a6bb-82810c433dbb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s now find out the forecast using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The output can be seen as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b958ef4c-0375-49af-8a7e-6d8dcc293d1d.png)'
  prefs: []
  type: TYPE_IMG
- en: Optimization of parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's look at how to optimize the parameters of the models.
  prefs: []
  type: TYPE_NORMAL
- en: AR model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Therefore, our model parameters are `p=2`, `d=2`, and `q=0` in this scenario
    for the AR model, as the AIC for this combination is the least.
  prefs: []
  type: TYPE_NORMAL
- en: ARIMA model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Even for the ARIMA model, we can optimize the parameters by using the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output you get by executing the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The combination with the least **Akaike information criterion** (**AIC**) should
    be chosen.
  prefs: []
  type: TYPE_NORMAL
- en: Anomaly detection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Anomalies are essentially abnormal patterns in a series that are irregular deviations
    from the expected behavior. For example, many of us have watched a cricket match.
    One form of getting out in this game is to be caught out, and before the ball
    travels straight to the hands of a fielder, it has to touch the bat of a batsman.
    If the stadium is very noisy, sometimes it is too difficult for anyone to judge
    whether the ball has touched the bat or not. To solve this problem, umpires use
    a device called the **snickometer** to help them make the call. The snickometer
    uses the sound from the stump mic to generate a plot of the mic's sound. If the
    plot is a straight line, then the ball did not make contact with the bat; otherwise,
    the plot will show a spike. Therefore, a spike is a sign of an anomaly. Another
    example of an anomaly could be the detection of a malignant tumor in a scan.
  prefs: []
  type: TYPE_NORMAL
- en: 'Anomaly detection is a technique that we can use to figure out aberrant behavior.
    An anomaly can also be called an **outlier**. The following list shows several
    different anomalies:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Point anomalies**: A point anomaly is a point that breaches the boundary
    of a threshold that has been assigned to keep the whole system in check. There
    is often a system in place to send an alert when this boundary has been breached
    by a point anomaly. For example, fraud detection in the financial industries can
    use point anomaly detection to check whether a transaction has taken place from
    a different city to the card holder''s usual location.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Contextual anomalies**: Context-specific observations are called **contextual
    anomalies**. For example, it is commonplace to have lots of traffic on weekdays,
    but a holiday falling on a Monday may make it look like an anomaly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Collective anomalies**: A set of collective data instances helps in detecting
    anomalies. Say that someone is unexpectedly trying to copy data form a remote
    machine to a local host. In this case, this anomaly would be flagged as a potential
    cyber attack.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we will focus on contextual anomalies and try to detect them
    with the help of a simple moving average.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s load all the required libraries as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we read the dataset using the following code. We are keeping the same
    dataset—namely, `AirPassenger.csv`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the output as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f9d68dc2-afa6-4892-a030-d439b726a98c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now we will write a function and create a threshold for detecting the anomalies
    using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s introduce anomalies to the series using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s plot it to detect the anomalies introduced using the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The following diagram shows the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7890f46f-ae72-4d05-99ed-1ff3692503b3.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, the introduced anomaly can be seen after 1959 as a dip in the number of
    travelers. It should be noted, however, that this is one of the simpler methods.
    ARIMA and Holt-Winters can also be used in this scenario.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about time series analysis and white noise. We were
    introduced to the concepts of random walk, autoregression, autocorrelation, and
    stationarity, which describes how to figure out whether data is stationary.
  prefs: []
  type: TYPE_NORMAL
- en: We also learned about differencing, taking the time series data and computing
    the differences between consecutive observations that lead to the formation of
    a new series. This chapter also talked about the AR model, which is a part of
    a stochastic process wherein the specific lagged values of *y**[t]*are used as
    predictor variables and regressed on *y**[t ]*in order to estimate the values.
    We also learned two optimization parameters, namely the AR model and ARIMA model.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about natural language processing.
  prefs: []
  type: TYPE_NORMAL
