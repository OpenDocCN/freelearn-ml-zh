- en: Chapter 4. Recommendation Systems for E-Commerce
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章：电子商务推荐系统
- en: In the previous three chapters, we have covered a lot of tips and tricks that
    can be used to build various types of analytics products. In this chapter, we
    are going to build a recommendation engine for the e-commerce domain. Let's go
    over some background of recommendation systems. Then, we will discuss the problem
    statement that we are trying to solve in this chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前三章中，我们介绍了很多可以用来构建各种类型分析产品的技巧和窍门。在本章中，我们将构建电子商务领域的推荐引擎。让我们回顾一下推荐系统的一些背景。然后，我们将讨论本章试图解决的问题陈述。
- en: 'Let''s take a relatable example from real life. We surf videos on YouTube almost
    every day, right? Suppose you saw some videos related to rock music on YouTube
    last night. This morning, when you open your YouTube, you may find that there
    are a couple of suggested YouTube channels with good videos on rock music. YouTube
    actually changes its suggestions based on your watching habits. Do you want to
    know how that algorithm works? Let''s take another example that might be useful
    to us in this chapter. Most of us buy stuff from various e-commerce sites. Suppose
    you are trying to purchase a book from Amazon. When you search for a book there
    is a section that suggests other books in the same genre. The title of this section
    is *Customers who bought this item also bought*; you may find these suggestions
    useful and buy another book as well. Take a look at the following screenshot:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从现实生活中的一个相关例子开始。我们几乎每天都在YouTube上浏览视频，对吧？假设你昨晚在YouTube上看到了一些关于摇滚音乐的视频。今天早上，当你打开YouTube时，你可能会发现有几个推荐的视频频道，它们有关于摇滚音乐的好视频。实际上，YouTube是根据你的观看习惯改变推荐的。你想知道这个算法是如何工作的吗？让我们再举一个可能对我们本章有用的例子。我们中的大多数人都会从各种电子商务网站上购买东西。假设你正在尝试从亚马逊购买一本书。当你搜索书籍时，有一个部分会推荐同一类别的其他书籍。这个部分的标题是*购买此商品的用户还购买了*；你可能觉得这些推荐很有用，并会购买另一本书。看看下面的截图：
- en: '![Recommendation Systems for E-Commerce](img/B08394_04_01.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![电子商务推荐系统](img/B08394_04_01.jpg)'
- en: 'Figure 4.1: Book suggestions on Amazon'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1：亚马逊上的书籍推荐
- en: All these suggestions you find on e-commerce websites use a specific algorithm,
    and this algorithm is referred to as the recommendation algorithm. This chapter
    is all about how to build the recommendation system using different types of Machine
    Learning (ML) algorithms. Other than e-commerce, there are many domains in which
    the recommendation system has been used; for example, Netflix and YouTube use
    the recommendation algorithm to suggest videos we may like, Airbnb provides a
    recommendation based on our activities on their website. The retail banking domain
    too uses the logic of the recommendation engine to offer various types of credit
    cards and offers to their customers. The list is never-ending, so now let's learn
    how to build a recommendation system.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 你在电子商务网站上找到的所有这些推荐都使用特定的算法，这个算法被称为推荐算法。本章全部关于如何使用不同类型的机器学习（ML）算法构建推荐系统。除了电子商务，还有许多领域已经使用了推荐系统；例如，Netflix和YouTube使用推荐算法来推荐我们可能喜欢的视频，Airbnb根据我们在他们网站上的活动提供推荐。这个列表是无穷无尽的，所以现在让我们学习如何构建推荐系统。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Introducing the problem statement
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍问题陈述
- en: Understanding the datasets
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解数据集
- en: 'Building the baseline approach:'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建基线方法：
- en: Understanding the basic concepts
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解基本概念
- en: Implementing the baseline approach
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施基线方法
- en: Understanding the testing matrix
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解测试矩阵
- en: Testing the result of the baseline approach
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试基线方法的结果
- en: Problems with the baseline approach
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基线方法的问题
- en: Optimizing the baseline approach
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化基线方法
- en: 'Building the revised approach:'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建修订后的方法：
- en: Implementing the revised approach
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施修订后的方法
- en: Testing the revised approach
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试修订后的方法
- en: Problems with the revised approach
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修订后方法的问题
- en: Understanding how to improve the revised approach
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解如何改进修订后的方法
- en: 'The best approach:'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最佳方法：
- en: Understanding the key concepts
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解关键概念
- en: Implementing the best approach
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施最佳方法
- en: Summary
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 概述
- en: So let's discuss the problem statement as well as start with the basic concepts
    of the recommendation system.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们讨论问题陈述以及从推荐系统的基本概念开始。
- en: Introducing the problem statement
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍问题陈述
- en: As you know, in this chapter, we are trying to build a recommendation system.
    A domain that mainly uses the recommendation system is e-commerce. So, in our
    basic version of the recommendation engine specifically, we will be building an
    algorithm that can suggest the name of the products based on the category of the
    product. Once we know the basic concepts of the recommendation engine, we will
    build a recommendation engine that can suggest books in the same way as the Amazon
    website.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所知，在本章中，我们试图构建一个推荐系统。主要使用推荐系统的领域是电子商务。因此，在我们的基本推荐引擎版本中，我们将构建一个可以根据产品类别建议产品名称的算法。一旦我们了解了推荐引擎的基本概念，我们将构建一个可以像亚马逊网站一样建议书籍的推荐引擎。
- en: We will be building three versions of the recommendation algorithm. The baseline
    approach is simple but intuitive so that readers can learn what exactly the recommendation
    algorithm is capable of doing. Baseline is easy to implement. In the second and
    third approach, we will be building the book recommendation engine using ML algorithms.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建三个版本的推荐算法。基线方法简单直观，以便读者可以了解推荐算法确切能做什么。基线易于实现。在第二和第三种方法中，我们将使用机器学习算法构建书籍推荐引擎。
- en: 'Let''s look at the basic methods or approaches that are used to build the recommendation
    system. There are two main approaches, which you can find in the following figure:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看构建推荐系统所使用的基本方法或方法。有两种主要方法，您可以在以下图中找到：
- en: '![Introducing the problem statement](img/B08394_04_02.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![介绍问题陈述](img/B08394_04_02.jpg)'
- en: 'Figure 4.2: Approaches for the recommendation engine'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2：推荐引擎的方法
- en: We will be using these two approaches although there are other approaches as
    well, such as a knowledge-based approach or a hybrid approach. But in this chapter,
    we will be focusing on the given two approaches.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管还有其他方法，如基于知识的方法或混合方法，但我们将使用这两种方法。但在本章中，我们将专注于这两种给定方法。
- en: Now let's look at the dataset that we are going to use.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看我们将要使用的数据集。
- en: Understanding the datasets
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解数据集
- en: 'In this chapter, we are using two datasets, as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用以下两个数据集：
- en: E-commerce item data
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子商务商品数据
- en: Book-Crossing dataset
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Book-Crossing数据集
- en: e-commerce Item Data
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 电子商务商品数据
- en: 'This dataset contains data items taken from actual stock keeping units (SKUs).
    It is from an outdoor apparel brand''s product catalog. We are building the recommendation
    engine for this outdoor apparel brand''s product catalog. You can access the dataset
    by using this link: [https://www.kaggle.com/cclark/product-item-data/data](https://www.kaggle.com/cclark/product-item-data/data).'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 此数据集包含从实际库存单位（SKU）中提取的数据项。它来自户外服装品牌的产品目录。我们正在为这个户外服装品牌的产品目录构建推荐引擎。您可以通过使用此链接访问数据集：[https://www.kaggle.com/cclark/product-item-data/data](https://www.kaggle.com/cclark/product-item-data/data)。
- en: This dataset contains 500 data items. There are two columns in the dataset.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 此数据集包含500个数据项。数据集中有两列。
- en: '**ID**: This column indicates the indexing of the data item. In layman''s terms,
    it is the serial number of the dataset.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ID**：此列表示数据项的索引。用通俗的话说，它是数据集的序号。'
- en: '**Description**: This column has all the necessary descriptions about the products,
    and we need to use this data to build the recommendation engine.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**描述**：此列包含有关产品的所有必要描述，我们需要使用这些数据来构建推荐引擎。'
- en: 'You can refer to the following figure:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以参考以下图：
- en: '![e-commerce Item Data](img/B08394_04_03.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![电子商务商品数据](img/B08394_04_03.jpg)'
- en: 'Figure 4.3: Snippet of the e-commerce item data'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3：电子商务商品数据片段
- en: As you can see, the description column has textual data, and we need to process
    this textual dataset in order to build the recommendation engine. Now let's move
    to the next dataset.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，描述列包含文本数据，我们需要处理这个文本数据集以便构建推荐引擎。现在让我们转到下一个数据集。
- en: The Book-Crossing dataset
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Book-Crossing数据集
- en: 'The Book-Crossing dataset is widely used to build recommendation systems. You
    can access it at [http://www2.informatik.uni-freiburg.de/~cziegler/BX/](http://www2.informatik.uni-freiburg.de/~cziegler/BX/).
    This dataset is available in two formats, as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Book-Crossing数据集被广泛用于构建推荐系统。您可以通过[http://www2.informatik.uni-freiburg.de/~cziegler/BX/](http://www2.informatik.uni-freiburg.de/~cziegler/BX/)访问它。此数据集以两种格式提供，如下所示：
- en: SQL dump
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQL转储
- en: CSV dump
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CSV转储
- en: 'We are using the CSV dump of the dataset. Both formats have three tables with
    different data attributes. The names of these three files are as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用数据集的CSV转储。两种格式都有三个表，具有不同的数据属性。这三个文件的名称如下：
- en: '`BX-Book-Ratings.csv`'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BX-Book-Ratings.csv`'
- en: '`BX-Books.csv`'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BX-Books.csv`'
- en: '`BX-Users.csv`'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BX-Users.csv`'
- en: Let's explore the data given in each of the data tables.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索每个数据表中给出的数据。
- en: BX-Book-Ratings.csv
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: BX-Book-Ratings.csv
- en: 'This CSV file contains data related to the rating of the book. This table contains
    three data attributes, which are as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这个CSV文件包含与书籍评分相关的数据。这个表格包含以下三个数据属性：
- en: '**User-ID**: This data attribute indicates the unique user ID. This column
    has a numeric value. The length of the user ID is six.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**User-ID**: 这个数据属性表示唯一的用户ID。这个列具有数值。用户ID的长度为六。'
- en: '**ISBN**: The full form of ISBN is International Standard Book Number. This
    data attribute indicates the unique identification number of the book.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ISBN**: ISBN的全称是国际标准书号。这个数据属性表示书籍的唯一识别号码。'
- en: '**Book rating**: This data attribute indicates the user rating for the book.
    The rating of the book varies from 0 to 10\. 0, with 0 indicating less appreciation
    and 10.0 indicating the highest appreciation.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Book rating**: 这个数据属性表示书籍的用户评分。书籍的评分范围从0到10，0表示不太喜欢，10.0表示最高评价。'
- en: BX-Books.csv
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: BX-Books.csv
- en: 'This file contains all the details regarding the books. The table contains
    the following data attributes:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件包含有关书籍的所有详细信息。该表格包含以下数据属性：
- en: '**ISBN**: The ISBN is provided to identify the book. All invalid ISBNs have
    already been deleted. This data table contains only valid ISBNs.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ISBN**: ISBN用于识别书籍。所有无效的ISBN都已删除。这个数据表只包含有效的ISBN。'
- en: '**Book-Title**: This data attribute contains the name of the book.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Book-Title**: 这个数据属性包含书籍的名称。'
- en: '**Book-Author**: This data attribute contains the name of the author of the
    book.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Book-Author**: 这个数据属性包含书籍作者的姓名。'
- en: '**Year-Of-Publication**: This indicates the year of publication of the book
    and is in the YYYY format.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Year-Of-Publication**: 这表示书籍的出版年份，格式为YYYY。'
- en: '**Publisher**: This data column has the name of the publisher who has published
    the book.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Publisher**: 这个数据列包含出版书籍的出版社名称。'
- en: '**Image-URL-S**: This data attribute has the URL for the image of the book''s
    cover page. S indicates a small size of cover page image.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Image-URL-S**: 这个数据属性包含书籍封面图片的URL。S表示封面图片为小尺寸。'
- en: '**Image-URL-M**: This data attribute has the URL for the image of the book''s
    cover page. M indicates a medium size of cover image.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Image-URL-M**: 这个数据属性包含书籍封面图片的URL。M表示封面图片为中尺寸。'
- en: '**Image-URL-L**: This data attribute has the URL for the image of the book''s
    cover page. L indicates a large size of cover image.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Image-URL-L**: 这个数据属性包含书籍封面图片的URL。L表示封面图片为大尺寸。'
- en: Now let's look at the details of the previous data table.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看上一个数据表的详细信息。
- en: BX-Users.csv
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: BX-Users.csv
- en: This is the third data table of the Book-Crossing dataset. This file contains
    information about the users.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Book-Crossing数据集的第三个数据表。这个文件包含用户信息。
- en: 'This particular data file contains the following data attributes:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特定的数据文件包含以下数据属性：
- en: '**User-ID**: This data column indicates the user ID, which is a six-digit integer
    number.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**User-ID**: 这个数据列表示用户ID，是一个六位数的整数。'
- en: '**Location**: This data is the part of the demographic details regarding the
    user. The location indicates the name and abbreviation of the city. The location
    details for all users are not available, so you will find the `null` value for
    those users whose locations haven''t been found.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Location**: 这个数据是关于用户人口统计细节的一部分。位置表示城市名称和缩写。并非所有用户的位置信息都可用，因此对于那些位置信息未找到的用户，您将找到`null`值。'
- en: '**Age**: This is also a demographic data point. If the user''s age is tracked,
    then it is present in the dataset; if not, then the value of the age is `null`.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Age**: 这也是一个人口统计数据点。如果跟踪了用户的年龄，则它存在于数据集中；如果没有，则年龄的值为`null`。'
- en: We have gathered basic information about the two datasets. We will be moving
    toward building the basic version of the recommendation engine.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经收集了两个数据集的基本信息。我们将继续构建推荐引擎的基本版本。
- en: Building the baseline approach
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建基线方法
- en: 'From this section onward, we will focus on how to build the basic version of
    the recommendation engine (which means the recommendation system in the context
    of this chapter). In order to develop the baseline approach, we will be using
    the content-based approach. These are the topics that we will be covering:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 从本节开始，我们将专注于如何构建推荐引擎的基本版本（在本章的上下文中意味着推荐系统）。为了开发基线方法，我们将使用基于内容的方法。以下是我们将要讨论的主题：
- en: Understanding the basic concepts
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解基本概念
- en: Implementing the baseline approach
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施基线方法
- en: Understanding the testing matrix
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解测试矩阵
- en: Testing the result of the baseline approach
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试基线方法的结果
- en: Problems with the baseline approach
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基线方法的问题
- en: Learning optimization tricks for the baseline approach
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习基于基线方法的优化技巧
- en: Without wasting any time, let's look at how the content-based approach has been
    used to build the recommendation engine.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 不浪费任何时间，让我们看看基于内容的方法是如何被用来构建推荐引擎的。
- en: Understanding the basic concepts
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解基本概念
- en: As I've specified earlier, we are using the content-based approach. You must
    be wondering what this approach is and how I have decided to use it. In order
    to find the answers to these questions, we need to understand the approach first,
    and then we can discuss why I chose it.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前所指定的，我们正在使用基于内容的方法。你可能想知道这种方法是什么，以及我是如何决定使用它的。为了找到这些问题的答案，我们首先需要理解这种方法，然后我们可以讨论为什么我选择了它。
- en: Understanding the content-based approach
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解基于内容的方法
- en: The intuition behind this algorithm is simple. If you are buying or are interested
    in one type of item, then you will probably like a similar product(s) as well.
    Let's take an example. If you are buying a pair of jeans, then there is a high
    chance that you will also like to buy t-shirts or tops, as well as formal trousers
    or other types of trousers. Basically, the recommendation for the products is
    based on the content that you have explored, bought, or are interested in. This
    approach works well when the context and properties of each of the item can be
    determined easily. This kind of recommendation system is used to recommend video
    and audio content to users.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法背后的直觉很简单。如果你在购买或对某一种商品感兴趣，那么你很可能也会喜欢类似的产品。让我们举一个例子。如果你在买一条牛仔裤，那么你很可能也会想买T恤或上衣，以及正装裤或其他类型的裤子。基本上，对产品的推荐是基于你探索过、购买过或感兴趣的内容的。当每个商品的上下文和属性可以轻松确定时，这种方法效果很好。这种类型的推荐系统用于向用户推荐视频和音频内容。
- en: 'When you watch a comedy video on YouTube you might notice there are suggestions
    for other funny clips and comedy videos. This is because there is a high chance
    that you will like similar kinds of content based on your watching and browsing
    history. You can understand this example with the help of the following figure:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在YouTube上观看喜剧视频时，你可能会注意到有其他搞笑片段和喜剧视频的建议。这是因为根据你的观看和浏览历史，你很可能喜欢类似的内容。你可以通过以下图示来理解这个例子：
- en: '![Understanding the content-based approach](img/B08394_04_04.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![理解基于内容的方法](img/B08394_04_04.jpg)'
- en: 'Figure 4.4: Pictorial representation of the idea of the content-based approach'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4：基于内容方法思想的图示
- en: So, when we need to build a system that can recommend items or products that
    are similar to the user's buying pattern or browsing pattern, we use this approach.
    The reason for choosing this approach is that this type of recommendation is not
    influenced by choices of other users. This will provide a personalized experience
    for users. A recommendation is totally based on the items and its features that
    users like. This approach helps the e-commerce company increase their sales with
    less effort. It needs less manual work, which is a good point to note here. We
    can also use products that have been newly introduced by e-commerce platforms.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当我们需要构建一个可以推荐与用户的购买模式或浏览模式相似的物品或产品的系统时，我们使用这种方法。选择这种方法的原因是这种类型的推荐不受其他用户选择的影响。这将为用户提供个性化的体验。推荐完全基于用户喜欢的物品及其特征。这种方法有助于电子商务公司以更少的努力提高销售额。它需要的手动工作较少，这是需要注意的一个好点。我们还可以使用电子商务平台新推出的产品。
- en: In order to implement this approach, we need to focus on the architecture part
    of it as well as look at basic concepts, such as TF-IDF and cosine similarity.
    We will explore all these topics in the next section.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这种方法，我们需要关注其架构部分，并查看基本概念，如TF-IDF和余弦相似度。我们将在下一节中探讨所有这些主题。
- en: Implementing the baseline approach
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现基线方法
- en: 'In this section, we will be designing the architecture of the content-based
    recommendation system. After that, we will look at how we can build a simple recommendation
    system. So, there are two subtopics that we will be covering here:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将设计基于内容的推荐系统架构。之后，我们将探讨如何构建一个简单的推荐系统。因此，我们将涵盖以下两个子主题：
- en: Architecture of the recommendation system
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 推荐系统架构
- en: Steps for implementing the baseline approach
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现基线方法的步骤
- en: Architecture of the recommendation system
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 推荐系统架构
- en: 'In this section, we will cover the basic architecture for the content-based
    recommendation system. Refer to the following figure, which explains the components
    in more detail:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍基于内容的推荐系统的基本架构。参考以下图表，它更详细地解释了组件：
- en: '![Architecture of the recommendation system](img/B08394_04_05.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![推荐系统架构](img/B08394_04_05.jpg)'
- en: 'Figure 4.5: Architecture of the content-based recommendation system'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5：基于内容的推荐系统架构
- en: As you can see, there are a number of components that we need to use in order
    to build the recommendation system. We are using the data source or the information
    source to store details about the items or products. The content analyzer converts
    the item description into a certain format so that the recommendation engine can
    consume this information. We have all the products or item-related information
    with us. Now we need to know what the user is browsing, buying, or searching for
    on the e-commerce platform. This user-related information is used as a training
    example for the recommendation system. These training examples are the input of
    the profile learning module that actual analyzes the age, gender, time spent on
    website, as well as other demographics and user-activity-based information.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们需要使用许多组件来构建推荐系统。我们使用数据源或信息源来存储关于项目或产品的详细信息。内容分析器将项目描述转换为特定格式，以便推荐引擎可以消费这些信息。我们拥有所有产品或与项目相关的信息。现在我们需要知道用户在电子商务平台上浏览、购买或搜索的内容。这类与用户相关的信息被用作推荐系统的训练示例。这些训练示例是配置文件学习模块的输入，该模块实际分析年龄、性别、在网站上的时间以及其他基于人口统计和用户活动信息。
- en: This collective information will be passed on to the filtering component. Based
    on the information of the products available on the e-commerce platform and user's
    activities, we will recommend the list of items to the customer.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这类集体信息将被传递给过滤组件。基于电子商务平台上可用的产品信息和用户活动，我们将向客户推荐项目列表。
- en: The logic of the recommendation engine comes into picture here. We will push
    the recommendations to the active users of the e-commerce platform. Here, active
    users are those who have bought the product in last month or who have browsed
    the platform more frequently. We need to track the activity of the users, which
    acts as the feedback for our recommendation engine.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 推荐引擎的逻辑在这里变得重要。我们将把推荐信息推送给电子商务平台的活跃用户。在这里，活跃用户是指在上个月购买过产品或浏览平台频率较高的用户。我们需要跟踪用户的活动，这些活动作为我们推荐引擎的反馈。
- en: In the feedback, we can track the number of items the user clicked on from the
    list of recommendations. Did they buy any items that were a part of the recommendation
    list? This kind of feedback is useful because based on this feedback, we can fine-tune
    the logic of the recommendation engine. We will send the feedback to the profile
    learner, and using that, we will update the interest area for each user so that
    in future we can give them more suggestions regarding sport clothes, if the person
    previously browsed sport shoes. Now that you understand the components and their
    workings, let's take a look at the step-by-step implementation of the baseline
    approach.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在反馈中，我们可以跟踪用户从推荐列表中点击的项目数量。他们是否购买了推荐列表中的任何项目？这类反馈很有用，因为基于这种反馈，我们可以微调推荐引擎的逻辑。我们将反馈发送给配置文件学习器，并使用它来更新每个用户的兴趣区域，以便在将来，如果某人之前浏览过运动鞋，我们可以给他们提供更多关于运动服的建议。现在您已经了解了组件及其工作原理，让我们来看看基线方法的逐步实现。
- en: Steps for implementing the baseline approach
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实施基线方法的步骤
- en: 'In this section, we will cover the coding of the basic recommendation engine.
    You can refer to the code by using this GitHub link: [https://github.com/jalajthanaki/Basic_Ecommerce_Recomendation_System](https://github.com/jalajthanaki/Basic_Ecommerce_Recomendation_System)'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍基本推荐引擎的编码。你可以通过使用以下GitHub链接来参考代码：[https://github.com/jalajthanaki/Basic_Ecommerce_Recomendation_System](https://github.com/jalajthanaki/Basic_Ecommerce_Recomendation_System)
- en: 'These are the steps that we need to follow:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们需要遵循的步骤：
- en: Loading the dataset
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载数据集
- en: Generating the feature using TF-IDF the cosine similarity matrix
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用TF-IDF生成特征并构建余弦相似度矩阵
- en: Generating the prediction
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成预测
- en: Loading the dataset
  id: totrans-115
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 加载数据集
- en: 'We are using the e-commerce item dataset here. In this dataset, there is an
    item description that we need to use. We will use the `pandas` library to load
    the dataset. You can refer to the following screenshot:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用的是电子商务商品数据集。在这个数据集中，有一个我们需要使用的商品描述。我们将使用`pandas`库来加载数据集。你可以参考以下截图：
- en: '![Loading the dataset](img/B08394_04_06.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![加载数据集](img/B08394_04_06.jpg)'
- en: 'Figure 4.6: Code snippet for loading the dataset'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.6：加载数据集的代码片段
- en: Generating features using TF-IDF
  id: totrans-119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用TF-IDF生成特征
- en: We will be using the concept of TF-IDF, which is a simple but effective statistical
    feature technique. TF-IDF stands for Term Frequency-Inverse Document Frequency.
    I will explain this briefly.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用TF-IDF的概念，这是一种简单但有效的统计特征技术。TF-IDF代表词频-逆文档频率。我将简要解释一下。
- en: 'TF-IDF has two parts: Term Frequency and Inverse Document Frequency. Let''s
    begin with term frequency. The term is self-explanatory, but we will walk through
    the concept anyway. Term frequency indicates the frequency of each of the words
    present in the document or dataset. The equation for TF is given in the following
    formula:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: TF-IDF包含两部分：词频和逆文档频率。让我们从词频开始。术语是自解释的，但我们仍然会解释这个概念。词频表示文档或数据集中每个单词出现的频率。TF的公式如下：
- en: '![Generating features using TF-IDF](img/B08394_04_07.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![使用TF-IDF生成特征](img/B08394_04_07.jpg)'
- en: 'Figure 4.7: Equation for TF'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.7：TF的公式
- en: 'Now let''s talk about inverse document frequency. IDF indicates how important
    the word is to the document. This is because when we calculate TF, we give equal
    importance to every single word. If the word *the* appears in the dataset more
    frequently, then its term frequency (TF) value is high but that word does not
    carry much importance for the document. If the word *the* appears in the document
    100 times, then it means that it does not carry that much information compared
    to words that are less frequent in the dataset. Thus, we need to define some weighing
    down of frequent terms while scaling up the rare ones, which is what decides the
    importance of each word. We will achieve this by using the equation given in the
    following formula:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来谈谈逆文档频率。IDF表示单词对文档的重要性。这是因为当我们计算TF时，我们对每个单词给予同等的重要性。如果一个单词“the”在数据集中出现得更频繁，那么它的词频（TF）值就高，但这个单词对文档的重要性并不大。如果一个单词“the”在文档中出现了100次，那么这意味着它所携带的信息量并不比数据集中出现频率较低的单词多。因此，我们需要对频繁的术语进行一些降权，同时提升罕见术语的权重，这就是决定每个单词重要性的因素。我们将通过以下公式给出的方程来实现这一点：
- en: '![Generating features using TF-IDF](img/B08394_04_08.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![使用TF-IDF生成特征](img/B08394_04_08.jpg)'
- en: 'Figure 4.8: Equation for IDF'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.8：IDF的公式
- en: 'So, the final equation to calculate TF-IDF is given in the following formula:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，计算TF-IDF的最终公式如下：
- en: '![Generating features using TF-IDF](img/B08394_04_09.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![使用TF-IDF生成特征](img/B08394_04_09.jpg)'
- en: 'Figure 4.9: Equation for TF-IDF'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.9：TF-IDF的公式
- en: 'If you want to read this in detail, then I would recommend that you read this
    topic from this book: [Chapter 5](ch05.xhtml "Chapter 5. Sentiment Analysis"),
    *Python Natural Language Processing*. For that, you can refer to this link: [https://www.packtpub.com/big-data-and-business-intelligence/python-natural-language-processing](https://www.packtpub.com/big-data-and-business-intelligence/python-natural-language-processing)'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想详细了解，我建议你阅读这本书中的这个主题：[第5章](ch05.xhtml "第5章. 情感分析")，*Python自然语言处理*。为此，你可以参考以下链接：[https://www.packtpub.com/big-data-and-business-intelligence/python-natural-language-processing](https://www.packtpub.com/big-data-and-business-intelligence/python-natural-language-processing)
- en: 'The practical implementation of this concept is quite easy. We use the scikit-learn
    library to code this up. You can refer to the following screenshot:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念的实际实现相当简单。我们使用scikit-learn库来编写代码。您可以参考以下截图：
- en: '![Generating features using TF-IDF](img/B08394_04_10.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![使用TF-IDF生成特征](img/B08394_04_10.jpg)'
- en: 'Figure 4.10: Code snippet for generating features using TF-IDF'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.10：使用TF-IDF生成特征的代码片段
- en: Here, we have used the `TfidfVectorizer` API and generated the TF-IDF vectors
    for the item description. We have removed the English stop words using the `stop_words`
    parameter. Here, we have provided `ngram_range` from 1 to 3\. Now let's build
    the cosine similarity matrix.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了`TfidfVectorizer` API并为项目描述生成了TF-IDF向量。我们使用`stop_words`参数去除了英语停用词。在这里，我们提供了从1到3的`ngram_range`。现在让我们构建余弦相似度矩阵。
- en: Building the cosine similarity matrix
  id: totrans-135
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 构建余弦相似度矩阵
- en: 'In this section, we will build the cosine similarity matrix, which is actually
    the main step required in order to build the content-based recommendation engine.
    This matrix indicates how similar the description of one product is to the other
    product. Here, we will check the cosine similarity between the TF-IDF vectors
    of all the products. We need to find the angle between two TF-IDF vectors. This
    angle represents how close or how far apart the TF-IDF vectors are. For that,
    we need to obtain the dot product between TF-IDF vectors by using the following
    equation:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将构建余弦相似度矩阵，这是构建基于内容的推荐引擎所需的主要步骤。这个矩阵表示一个产品的描述与其他产品描述的相似程度。在这里，我们将检查所有产品的TF-IDF向量的余弦相似度。我们需要找到两个TF-IDF向量之间的角度。这个角度表示TF-IDF向量之间的接近程度或距离。为此，我们需要使用以下方程来获取TF-IDF向量之间的点积：
- en: '![Building the cosine similarity matrix](img/B08394_04_11.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![构建余弦相似度矩阵](img/B08394_04_11.jpg)'
- en: 'Figure 4.11: Equation for the dot product'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.11：点积的方程
- en: 'Now, with the help of the given cosine equation, we can generate the angle
    between these vectors. You can refer to the equations in the following formula:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，借助给定的余弦方程，我们可以生成这些向量之间的角度。您可以参考以下公式中的方程：
- en: '![Building the cosine similarity matrix](img/B08394_04_12.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![构建余弦相似度矩阵](img/B08394_04_12.jpg)'
- en: 'Figure 4.12: Equation for cosine similarity and norm for vectors'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.12：向量余弦相似度和范数的方程
- en: 'Now let''s look at a basic example so that you can understand the basic math
    behind it. For that, you need to refer to the following equation:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一个基本示例，以便您能够理解其背后的基本数学原理。为此，您需要参考以下方程：
- en: '![Building the cosine similarity matrix](img/B08394_04_13.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![构建余弦相似度矩阵](img/B08394_04_13.jpg)'
- en: 'Figure 4.13: Basic cosine similarity example'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.13：基本的余弦相似度示例
- en: As you can see in the preceding figure, there are two vectors; each of them
    has three elements. First, we calculated their norms and then we performed the
    dot product on them. After that, we used the cosine similarity formula and found
    the angle between these vectors. Note that we can measure the cosine similarity
    for two nonzero vectors. The interval for the cosine angle is *[0,2π)*.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，有两个向量，每个向量有三个元素。首先，我们计算了它们的范数，然后对它们进行了点积运算。之后，我们使用了余弦相似度公式，并找到了这些向量之间的角度。请注意，我们可以测量两个非零向量之间的余弦相似度。余弦角度的区间是*[0,2π)*。
- en: 'The coding implementation for this is pretty easy. You can refer to the code
    snippet shown in the following screenshot:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码实现相当简单。您可以参考以下截图所示的代码片段：
- en: '![Building the cosine similarity matrix](img/B08394_04_14.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![构建余弦相似度矩阵](img/B08394_04_14.jpg)'
- en: 'Figure 4.14: Code snippet for generating the cosine similarity'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.14：生成余弦相似度的代码片段
- en: Here, we have stored all the recommendations in a dictionary, where each item
    and its corresponding recommendation have been stored. There are 500 items in
    our dataset, and for each and every item, we have generated a list of items that
    can be recommended to the users. Now it's time to generate the prediction.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将所有推荐存储在一个字典中，其中每个项目和其对应的推荐都已存储。我们的数据集中有500个项目，并且为每个项目都生成了一组可以推荐给用户的物品列表。现在，是时候生成预测了。
- en: Generating the prediction
  id: totrans-150
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 生成预测
- en: 'In this section, we will be generating the recommendation list for the given
    `item_id`. We need to pass any `item_id` from 1 to 500\. The system will obtain
    five different suggestions, which are referred to as recommended items. These
    recommended items are similar to the item whose `item_id` we have passed to the
    algorithm. You can see the code snippet in the following screenshot:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将为给定的`item_id`生成推荐列表。我们需要传递从1到500的任何`item_id`。系统将获得五个不同的建议，这些建议被称为推荐项目。这些推荐项目与算法中传递的`item_id`的项目相似。您可以在以下截图中的代码片段中看到：
- en: '![Generating the prediction](img/B08394_04_15.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![生成预测](img/B08394_04_15.jpg)'
- en: 'Figure 4.15: Code snippet for generating prediction'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.15：生成预测的代码片段
- en: As you can see, we retrieve the results from the dictionary. We have printed
    the value of cos θ as our scoring values. If the score is close to one, then it
    can be said that these items are more similar and there is a higher chance that
    the user will like the recommendation. If the score is closer to 0 or –1, then
    items appear less attractive to the users. So just note that here, the score indicates
    the value of cos θ and not the angle directly.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们从字典中检索结果。我们已打印出cos θ的值作为我们的评分值。如果分数接近1，则可以说这些项目更相似，用户喜欢推荐的可能性更高。如果分数更接近0或-1，则项目对用户来说不太吸引人。所以请注意，在这里，分数表示cos
    θ的值，而不是角度本身。
- en: Now let's look at the testing matrix, which can help us evaluate this approach
    as well as other approaches that we will be implementing in this chapter.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看测试矩阵，它可以帮助我们评估这种方法以及在本章中我们将要实现的其他方法。
- en: Understanding the testing matrix
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解测试矩阵
- en: In this section, we will be exploring the testing or evolution matrix for the
    content-based recommendation engine. Here, the cosine similarity score is the
    biggest testing score for us. That is because with the help of that score, we
    can easily come to learn whether the algorithm can suggest the items whose cosine
    similarity score is close to 1 close to 0.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨基于内容的推荐引擎的测试或演变矩阵。在这里，余弦相似度分数是我们最大的测试分数。这是因为有了这个分数的帮助，我们可以轻松地了解算法是否可以建议余弦相似度分数接近1或0的项目。
- en: 'For some items, we will obtain a score that is close to 1, and for other items,
    we obtain a score that is close to 0\. So, we need to focus on this cosine score
    in order to get an idea of how well or badly the recommendation engine is doing.
    You can refer to the following figure:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些项目，我们将获得一个接近1的分数，而对于其他项目，我们获得的分数则接近0。因此，我们需要关注这个余弦分数，以便了解推荐引擎表现的好坏。您可以参考以下图表：
- en: '![Understanding the testing matrix](img/B08394_04_16.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![理解测试矩阵](img/B08394_04_16.jpg)'
- en: 'Figure 4.16: Understanding of the cosine similarity score and angle'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.16：余弦相似度分数和角度的理解
- en: As we can see in the preceding figure, we need to use the cosine score in order
    to test this approach. We can perform the following steps for testing. We need
    to count the number of items with more than a certain score, which means that
    we can decide the threshold value for the cosine similarity score and count how
    many items the recommendation engine is suggesting above that threshold value.
    Let me give you an example. Suppose we decide a cut-off score of 0.15\. In this
    case, all items whose cosine score is above 0.15 are considered a good recommendation.
    Here, the trick is that you need to experiment with this threshold value because
    based on the user's activity, you may change it later on. This parameter will
    be a tunable parameter for us. In the next section, we will look at the code for
    the testing.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，我们需要使用余弦分数来测试这种方法。我们可以执行以下步骤进行测试。我们需要计算超过一定分数的项目数量，这意味着我们可以决定余弦相似度分数的阈值，并计算推荐引擎建议超过该阈值的项目数量。让我给您举一个例子。假设我们决定一个截止分数为0.15。在这种情况下，所有余弦分数高于0.15的项目都被认为是良好的推荐。在这里，技巧是您需要对这个阈值进行实验，因为根据用户的活动，您可能稍后会改变它。这个参数将是我们可调整的参数。在下一节中，我们将查看测试的代码。
- en: Testing the result of the baseline approach
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试基线方法的结果
- en: 'In this section, we will see how we can implement the logic of the threshold
    value. After that, we will compare the results for different items. You can refer
    to the code snippet shown in the following screenshot:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将了解如何实现阈值逻辑。之后，我们将比较不同项目的结果。您可以参考以下截图所示的代码片段：
- en: '![Testing the result of the baseline approach](img/B08394_04_17.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![测试基线方法的结果](img/B08394_04_17.jpg)'
- en: 'Figure 4.17: Code snippet for testing'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.17：测试代码片段
- en: 'Now you can see the results for different `item_ids`. You can find the result
    of the three items. I have picked up `item_id` randomly. Take a look at the following
    screenshot:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以看到不同`item_ids`的结果。你可以找到三个项目的结果。我随机选择了`item_id`。看一下下面的屏幕截图：
- en: '![Testing the result of the baseline approach](img/B08394_04_18.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![测试基线方法的结果](img/B08394_04_18.jpg)'
- en: 'Figure 4.18: Result of items'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.18：项目结果
- en: 'Take a look at the following code snippet:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下下面的代码片段：
- en: '![Testing the result of the baseline approach](img/B08394_04_19.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![测试基线方法的结果](img/B08394_04_19.jpg)'
- en: 'Figure 4.19: Analysis based on useful recommendations'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.19：基于有用建议的分析
- en: As you can see in the preceding figure, this approach gives us useful recommendations
    69.8% of the time, and it provides four useful suggestions 7.2% of the time. After
    looking at the analysis of the result, we can say that the baseline approach is
    doing well, and we can definitely improve the results with the help of the other
    approach.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，这种方法有69.8%的时间提供了有用的建议，有7.2%的时间提供了四个有用的建议。在查看结果分析后，我们可以说基线方法表现良好，我们肯定可以通过其他方法来提高结果。
- en: In the next section, we will discuss the problems this baseline approach has
    and how we can solve them.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论这种基线方法存在的问题以及我们如何解决这些问题。
- en: Problems with the baseline approach
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基线方法的问题
- en: 'In this section, we will be discussing the problems that are a part of the
    baseline approach. We need to understand the problems so that we can take care
    of them in the revised approach. The problems with this approach are as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论基线方法中存在的问题。我们需要了解这些问题，以便在修订方法中注意它们。这个方法的问题如下：
- en: '**Limited content analysis**: If we do not have enough information in order
    to differentiate the items more accurately, then the recommendation engine won''t
    be giving useful or more precise suggestions.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内容分析有限**：如果我们没有足够的信息来更准确地区分项目，那么推荐引擎就不会提供有用或更精确的建议。'
- en: '**Over-specialization**: Content-based systems are based on the user profile
    and the items they are browsing, so the user will get the same kind of suggestion
    if they are browsing the same thing again and again. There is no different or
    novel item that the user can find. This is bad because if we provide the same
    recommendation more often, then there is no element of surprise for the user and
    they won''t be motivated to buy things. This problem is called over-specialization.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过度专业化**：基于内容的方法基于用户资料和他们正在浏览的项目，因此如果用户反复浏览相同的内容，他们将得到相同类型的建议。用户找不到不同或新颖的项目。这是不好的，因为如果我们更频繁地提供相同的推荐，那么用户就没有惊喜元素，他们也不会有购买东西的动力。这个问题被称为过度专业化。'
- en: '**New-user**: If there is a new user who is exploring the e-commerce platform
    and we have a very limited amount of information about the user, then we cannot
    give them a good recommendation initially. This situation occurs due to the lack
    of a solid profile.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**新用户**：如果一个新用户正在探索电子商务平台，而我们对其信息非常有限，那么我们最初无法给他们提供好的推荐。这种情况是由于缺乏稳固的资料。'
- en: All the preceding problems are well known for their content-based recommendation
    engine. In order to solve these problems, we can try out some other approach.
    The details related to this are given in the next section.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 所有上述问题都是基于内容推荐引擎的已知问题。为了解决这些问题，我们可以尝试其他方法。有关这些的详细信息将在下一节中给出。
- en: Optimizing the baseline approach
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优化基线方法
- en: Here, we will have an overview of how we can resolve the problems that we encountered
    in the previous section. In the baseline approach, we are basically dependent
    on the user profile and the item description, but this approach did not turn out
    well. In order to improve that we will be using two approaches. In the revised
    approach, we will be using the correction-based approach. After that, we will
    try the collaborative-filtering-based approach.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将概述我们如何解决上一节中遇到的问题。在基线方法中，我们基本上依赖于用户资料和项目描述，但这种方法并没有取得好的效果。为了改进这一点，我们将使用两种方法。在修订的方法中，我们将使用基于校正的方法。之后，我们将尝试基于协同过滤的方法。
- en: This correlation-based approach depends on the users' activities and is not
    dependent on the content or the description of the item. This helps us resolve
    the issues of new users, over-specialization, and limited content analysis. We
    are using a correlation coefficient to build the recommendation engine. This is
    a simple statistical technique that can be quite helpful. The basic concepts that
    are important for implementation will be described as and when we start building
    the revised approach.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这种基于相关性的方法依赖于用户的活动，而不是依赖于项目的内容或描述。这有助于我们解决新用户、过度专业化和内容分析有限等问题。我们正在使用相关系数来构建推荐引擎。这是一种简单的统计技术，可以非常有帮助。对于实现来说，重要的基本概念将在我们开始构建改进方法时进行描述。
- en: So let's build the revised approach.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们构建改进的方法。
- en: Building the revised approach
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建改进的方法
- en: In this iteration, we will be building the recommendation engine using a statistical
    concept called correlation. We will be looking at how users' activities and choices
    are correlated to one another. We try to find out the pattern from the users'
    activities and behavior on the e-commerce platform.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次迭代中，我们将使用一个称为相关性的统计概念来构建推荐引擎。我们将研究用户的活动和选择是如何相互关联的。我们试图从用户在电子商务平台上的活动和行为中找出模式。
- en: Here, we will be using the Book-Crossing dataset. One of the critical parameters
    for building the recommendation system is the book rating attribute. I will explain
    the concepts along with the implementation part, so it will be easy for you to
    understand.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将使用Book-Crossing数据集。构建推荐系统的一个关键参数是书籍评分属性。我将结合实现部分解释这些概念，这样你就可以更容易地理解。
- en: Implementing the revised approach
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现改进的方法
- en: 'In order to implement the revised approach, we will need to perform the following
    steps. You can refer to the code on GitHub at: [https://github.com/jalajthanaki/Book_recommendation_system/blob/master/correlation_based_recommendation_system.ipynb](https://github.com/jalajthanaki/Book_recommendation_system/blob/master/correlation_based_recommendation_system.ipynb)'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现改进的方法，我们需要执行以下步骤。你可以在GitHub上的代码中参考：[https://github.com/jalajthanaki/Book_recommendation_system/blob/master/correlation_based_recommendation_system.ipynb](https://github.com/jalajthanaki/Book_recommendation_system/blob/master/correlation_based_recommendation_system.ipynb)
- en: Loading the dataset
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载数据集
- en: '**Exploratory Data Analysis** (**EDA**) of book-rating datafile'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**书籍评分数据文件的探索性数据分析**（EDA）'
- en: Exploring the book datafile
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 探索书籍数据文件
- en: EDA of user datafile
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户数据文件的EDA（探索性数据分析）
- en: Implementing the logic of correlation for the recommendation engine
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现推荐引擎的相关逻辑
- en: Loading dataset
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加载数据集
- en: 'As a first step, we will use the `pandas` library to load our Book-Crossing
    dataset. As you already know, this dataset has three datafiles. We are loading
    all of them. You can refer to the following code snippet:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一步，我们将使用`pandas`库来加载我们的Book-Crossing数据集。正如你所知，这个数据集有三个数据文件。我们正在加载所有这些文件。你可以参考以下代码片段：
- en: '![Loading dataset](img/B08394_04_20.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![加载数据集](img/B08394_04_20.jpg)'
- en: 'Figure 4.20: Code snippet for loading the data'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.20：加载数据的代码片段
- en: Our data separator is a semicolon, and we are using latin-1 as encoding. We
    have defined three `pandas` dataframes.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数据分隔符是分号，我们使用latin-1作为编码。我们定义了三个`pandas`数据框。
- en: Now let's jump to the next step, which is the EDA step for all three datafiles.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们跳到下一步，即对所有三个数据文件进行EDA步骤。
- en: EDA of the book-rating datafile
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 书籍评分数据文件的EDA
- en: 'For this datafile, we have generated the ratings dataframe. We need to know
    what kind of data distribution this datafile has. That means we need to check
    how many books are getting a 10 out of 10 score, how many books are getting a
    5 out of 10 score, and how many books do not have any rating at all. Refer to
    the following code snippet to generate this information for us:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个数据文件，我们已经生成了评分数据框。我们需要知道这个数据文件的数据分布类型。这意味着我们需要检查有多少本书得到了10分（满分），有多少本书得到了5分，以及有多少本书没有任何评分。请参考以下代码片段以生成这些信息：
- en: '![EDA of the book-rating datafile](img/B08394_04_21.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![书籍评分数据文件的EDA](img/B08394_04_21.jpg)'
- en: 'Figure 4.21: Code snippet for EDA of book-rating datafile'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.21：书籍评分数据文件的EDA代码片段
- en: 'You can find the bar chart for this in the following figure:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下图中找到这个条形图：
- en: '![EDA of the book-rating datafile](img/B08394_04_22.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![书籍评分数据文件的EDA](img/B08394_04_22.jpg)'
- en: 'Figure 4.22: Bar chart for book-rating score distribution'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.22：书籍评分分数分布的条形图
- en: As we can see, there are 7,16,109 books with a zero rating, whereas 1,03,736
    books have a rating of eight. Based on this analysis, we can deduce that there
    are many books whose rating is zero, so the data distribution is biased here.
    We need to keep this point in mind.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，有7,16,109本书的评分为零，而1,03,736本书的评分为八。基于这种分析，我们可以推断出有很多书的评分为零，因此数据分布存在偏差。我们需要记住这一点。
- en: Exploring the book datafile
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 探索书籍数据文件
- en: 'In this section, we will perform the EDA of the book datafile. We also need
    to check the data attributes and format the data. No other trick needs to be applied
    for this datafile. Take a look at the code snippet shown in the following screenshot:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将对书籍数据文件进行EDA分析。我们还需要检查数据属性并格式化数据。对于这个数据文件，不需要应用其他技巧。请查看以下截图中的代码片段：
- en: '![Exploring the book datafile](img/B08394_04_23.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![探索书籍数据文件](img/B08394_04_23.jpg)'
- en: 'Figure 4.23: Code snippet for exploring the book datafile'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.23：探索书籍数据文件的代码片段
- en: You can see that we have checked the shape and columns list for the book datafile.
    There is nothing that critical we need to consider in order to build the recommendation
    engine.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，我们已经检查了书籍数据文件的形状和列列表。在构建推荐引擎时，我们没有需要考虑的任何关键问题。
- en: EDA of the user datafile
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用户数据文件的EDA分析
- en: 'Here, we need to perform an analysis of the users'' datafile. This datafile
    is important as we will be using it often to derive some important facts for this
    approach. First, we need to obtain the age distribution. The age distribution
    is one of the critical data points when we are building a recommendation system
    because users of a similar age group have similar reading patterns, and if we
    obtain this pattern, then we can generate more effective recommendations for our
    users. You can refer to the code snippet shown in the following screenshot:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们需要对用户的数据文件进行分析。这个数据文件很重要，因为我们经常使用它来获取一些重要的事实。首先，我们需要获取年龄分布。当我们构建推荐系统时，年龄分布是关键数据点之一，因为相似年龄组的用户有相似的阅读模式，如果我们获得这种模式，那么我们可以为我们的用户提供更有效的推荐。您可以参考以下截图中的代码片段：
- en: '![EDA of the user datafile](img/B08394_04_24.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![用户数据文件的EDA分析](img/B08394_04_24.jpg)'
- en: 'Figure 4.24: Code snippet for generating the age distribution'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.24：生成年龄分布的代码片段
- en: 'You can refer to the box chart, which indicates the age distribution shown
    in the following figure:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以参考箱形图，它显示了以下图中的年龄分布：
- en: '![EDA of the user datafile](img/B08394_04_25.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![用户数据文件的EDA分析](img/B08394_04_25.jpg)'
- en: 'Figure 4.25: Box graph for the age distribution'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.25：年龄分布的箱形图
- en: Based on the distribution, we can derive the fact that we have a majority of
    the users whose age falls between 20 and 40\. So if we focus on their reading
    and browsing pattern, then our work will get easier.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 根据分布，我们可以得出结论，大多数用户的年龄在20到40岁之间。因此，如果我们关注他们的阅读和浏览模式，那么我们的工作将更容易。
- en: Implementing the logic of correlation for the recommendation engine
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现推荐引擎的相关性逻辑
- en: 'In this section, we will cover the core logic of the recommendation engine.
    The logic can be divided into two parts:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍推荐引擎的核心逻辑。逻辑可以分为两部分：
- en: Recommendations based on the rating of the books
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于书籍评分的推荐
- en: Recommendations based on correlations
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于相关性的推荐
- en: So let's start!
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们开始吧！
- en: Recommendations based on the rating of the books
  id: totrans-226
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 基于书籍评分的推荐
- en: 'In order to build a book recommendation system that is based on the rating
    of the book, all the ratings are provided by the readers. So, for the implementation
    of this approach, we will be extracting the top five books with the highest ratings,
    which means we need to obtain a list of the books with the most ratings from the
    reader. The code snippet for that is shown in the following figure:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建一个基于书籍评分的推荐系统，所有评分都由读者提供。因此，为了实现这种方法，我们需要提取评分最高的前五本书，这意味着我们需要从读者那里获得评分最高的书籍列表。相应的代码片段如下所示：
- en: '![Recommendations based on the rating of the books](img/B08394_04_26.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![基于书籍评分的推荐](img/B08394_04_26.jpg)'
- en: 'Figure 4.26: Code snippet for generating the top five books based on book rating'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.26：基于书籍评分生成前五本书的代码片段
- en: 'We have generated the ISBN of the top five books on the book rating count,
    but we also need to check what those books'' names are and what the average rating
    for each of them is. You can find the name of the books by merging the book and
    book-rating data frame. You can see the code for this in the following screenshot:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经生成了根据书籍评分计数排名前五的书籍的ISBN，但我们还需要检查这些书籍的名称以及每本书的平均评分。你可以通过合并书籍和书籍评分数据框来找到书籍的名称。你可以在下面的屏幕截图中看到这段代码：
- en: '![Recommendations based on the rating of the books](img/B08394_04_27.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![基于书籍评分的推荐](img/B08394_04_27.jpg)'
- en: 'Figure 4.27: Code snippet for generating the names of the top 5 books'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.27：生成前5本书名称的代码片段
- en: Now, you may wonder what the benefit of this approach is. Let me tell you, we
    have a list of the books in descending order based on the book rating. If a user
    buys the book based on the rating of the book, then we can suggest other books
    that have the same rating. This way, users get suggestions that are more accurate
    than the previous approach.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可能想知道这种方法的益处是什么。让我告诉你，我们根据书籍评分的顺序列出了一个书籍列表。如果一个用户根据书籍的评分购买书籍，那么我们可以推荐其他具有相同评分的书籍。这样，用户会得到比之前方法更准确的建议。
- en: 'If you look at the results of the top five books, then you will learn that
    the maximum rating is for Rich Shapero''s book `Wild Animus`. All five books are
    novels. If someone wants to buy `Wild Animus`, then the user may also buy `The
    Lovely Bones: A Novel`. That is the reason this approach makes sense.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '如果你查看前五本书的结果，那么你会了解到评分最高的是Rich Shapero的书籍《Wild Animus》。这五本书都是小说。如果有人想购买《Wild
    Animus》，那么用户也可能购买《The Lovely Bones: A Novel》。这就是为什么这种方法是有道理的。'
- en: Now let's see the correlation-based recommendation engine.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看基于相关性的推荐引擎。
- en: Recommendations based on correlations
  id: totrans-236
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 基于相关性的推荐
- en: 'We are using the bivariant correlation and the **Pearson correlation coefficient**
    (**PCC**). This is also referred to as `Person''s r`. This correlation provides
    a measure of the linear correction between the two variables `a and b`. Here,
    we are considering the rating of two books and applying the PCC technique to them.
    The value of Person''s `r` is in the range of `+1` to `–1`. The interpretation
    for this correlation value is as follows:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用双变量相关性和皮尔逊相关系数（**PCC**）。这也被称为“皮尔逊r”。这种相关性提供了两个变量`a和b`之间线性相关性的度量。在这里，我们考虑了两本书的评分，并将PCC技术应用于它们。皮尔逊r的值在`+1`到`-1`之间。这个相关值的解释如下：
- en: '**+1**: This value indicates the total positive linear correlation. This means
    that if there is an increment in the value of the variable 1, then variable 2
    is incremented as well.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**+1**：这个值表示完全正线性相关性。这意味着如果变量1的值增加，那么变量2的值也会增加。'
- en: '**0**: This value indicates that there is no linear correlation. This means
    that the two variables are not related.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**0**：这个值表示没有线性相关性。这意味着两个变量之间没有关系。'
- en: '**-1**: This value indicates that there is a total negative linear correlation.
    This means that if there is an increment in the value of variable 1, then variable
    2 is decremented.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-1**：这个值表示存在完全负线性相关性。这意味着如果变量1的值增加，那么变量2的值会减少。'
- en: 'The equation for the PCC is shown in the following equation:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: PCC的公式如下所示：
- en: '![Recommendations based on correlations](img/B08394_04_28.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![基于相关性的推荐](img/B08394_04_28.jpg)'
- en: 'Figure 4.28: Equation for PCC or Person''s r'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.28：PCC或皮尔逊相关系数的公式
- en: 'Let''s consider a simple math example so you know how we have calculated Person''s
    r. Take a look at the following equation:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个简单的数学例子，这样你就知道我们是如何计算皮尔逊r的。看看下面的公式：
- en: '![Recommendations based on correlations](img/B08394_04_29.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![基于相关性的推荐](img/B08394_04_29.jpg)'
- en: 'Figure 4.29: Math example for Person''s r'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.29：皮尔逊r的数学示例
- en: Note
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Note: we are considering the ratings of the two books in order to find the
    correlation between them.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：我们正在考虑两本书的评分，以找到它们之间的相关性。
- en: 'First of all, we need to obtain the average rating for all books. The code
    snippet is given in the following screenshot:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要获取所有书籍的平均评分。代码片段如下面的屏幕截图所示：
- en: '![Recommendations based on correlations](img/B08394_04_30.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![基于相关性的推荐](img/B08394_04_30.jpg)'
- en: 'Figure 4.30: Code snippet for generating an average book rating'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.30：生成平均书籍评分的代码片段
- en: Note that the books that received the most rating counts are not the ones that
    are highly rated. This means there are some books for which readers share their
    feedback more often, but that doesn't mean those books are highly rated. Maybe
    some books were rated by 100 users but the score for the book is 4.3\. This is
    the most important point that I need to highlight because this is where mistakes
    can happen. For making a better system, we need to consider the book-rating count
    and the book-rating score.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，获得最多评分的书籍并不一定是评分最高的。这意味着有些书籍读者更频繁地分享他们的反馈，但这并不意味着这些书籍的评分很高。也许有些书籍被100个用户评分，但书籍的评分是4.3。这是我最需要强调的重要观点，因为错误可能就发生在这里。为了构建一个更好的系统，我们需要考虑书籍的评分数量和评分分数。
- en: 'Here, we will be excluding users who have provided less than 200 ratings as
    well as books that have received less than 100 ratings. This means we are setting
    up a threshold so that we can make a better system. We can achieve this by using
    the code snippet given in the following screenshot:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将排除那些提供少于200个评分的用户以及那些获得少于100个评分的书籍。这意味着我们正在设置一个阈值，以便构建一个更好的系统。我们可以通过以下截图中的代码片段来实现这一点：
- en: '![Recommendations based on correlations](img/B08394_04_31.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![基于相关性的推荐](img/B08394_04_31.jpg)'
- en: 'Figure 4.31: Code snippet for setting up threshold for considering users and
    books'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.31：为考虑用户和书籍设置阈值的代码片段
- en: 'Now we are converting the ratings dataframe into a 2D matrix. This matrix is
    a sparse matrix because not every user has provided a rating for every book. You
    can see the code in the following screenshot:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们正在将评分数据框转换为2D矩阵。这个矩阵是一个稀疏矩阵，因为并非每个用户都对每本书进行了评分。你可以在以下截图中的代码中看到：
- en: '![Recommendations based on correlations](img/B08394_04_32.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![基于相关性的推荐](img/B08394_04_32.jpg)'
- en: 'Figure 4.32: Code snippet for generating a sparse matrix for rating'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.32：生成评分稀疏矩阵的代码片段
- en: 'We have completed some basic work, now it''s time to find out about books that
    correlate with the second most-rated book, *The Lovely Bones: A Novel.* I want
    to quote the summary of this book, which is taken from Wikipedia: [https://en.wikipedia.org/wiki/The_Lovely_Bones](https://en.wikipedia.org/wiki/The_Lovely_Bones)'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了一些基本工作，现在是时候找出与第二高评分书籍《可爱的骨头：一部小说》相关的书籍了。我想引用这本书的摘要，该摘要来自维基百科：[https://en.wikipedia.org/wiki/The_Lovely_Bones](https://en.wikipedia.org/wiki/The_Lovely_Bones)
- en: '"It is the story of a teenage girl who, after being raped and murdered, watches
    from her personal Heaven as her family and friends struggle to move on with their
    lives while she comes to terms with her own death".'
  id: totrans-260
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “这是一个关于一个少女的故事，她在被强奸和谋杀后，从她个人的天堂看着她的家人和朋友努力继续他们的生活，同时她也在接受自己的死亡”。
- en: 'Now we need to obtain a book that can be recommended to a user if they are
    trying to buy this book. The code that can help us get the recommendation is given
    in the following screenshot:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要找到一本可以向用户推荐的书籍，如果他们正在尝试购买这本书。帮助我们获取推荐的代码在下面的截图中有展示：
- en: '![Recommendations based on correlations](img/B08394_04_33.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![基于相关性的推荐](img/B08394_04_33.jpg)'
- en: 'Figure 4.33: Code snippet for generating a correlation-based recommendation'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.33：基于相关性生成推荐的代码片段
- en: 'Here, you can see that we are using a sparse matrix and have applied the `corrwith`
    API to generate a correlation. There may be some runtime warnings. They are related
    to the float data type. Apart from that, we have coded the condition we need in
    order to recommend books that have received more than or equal to 300 user-rating
    counts. We have obtained the ISBN using the preceding code. So, we need to obtain
    the names of the books as well. For that, we need to use the code snippet given
    in the following screenshot:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到我们正在使用稀疏矩阵，并应用了`corrwith` API来生成相关性。可能会有一些运行时警告。它们与浮点数据类型有关。除此之外，我们已经编写了所需的条件，以便推荐那些获得超过或等于300个用户评分的书籍。我们使用前面的代码获取了ISBN。因此，我们还需要获取书籍的名称。为此，我们需要使用以下截图中的代码片段：
- en: '![Recommendations based on correlations](img/B08394_04_34.jpg)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![基于相关性的推荐](img/B08394_04_34.jpg)'
- en: 'Figure 4.34: Code snippet for generating the name of the book'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.34：生成书籍名称的代码片段
- en: 'Let''s select the top three recommendations for the book, which are, *The Nanny
    Diaries: A Novel*, *The Pilot''s Wife: A Novel*, *and 1st to Die: A Novel*. The
    Nanny Diaries criticizes the upper-class society of Manhattan as seen through
    the eyes of their children''s caregivers. The Pilot''s Wife: A Novel is written
    by the same author who wrote The Lovely Bones. 1st to Die is the first book of
    a women''s murder club series.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们选择这本书的前三个推荐，它们是，《The Nanny Diaries: A Novel》（保姆日记：一部小说），《The Pilot''s Wife:
    A Novel》（飞行员妻子：一部小说），以及《1st to Die: A Novel》（第一死：一部小说）。《保姆日记：一部小说》通过孩子们的保育员视角批评了曼哈顿的上层社会。《飞行员妻子：一部小说》是由写了《美好骨头》的同一作者所写。《第一死》是女性谋杀俱乐部系列的第一本书。'
- en: If you actually look at the content of these three books, then we can see that
    all these recommendations make sense.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你实际查看这三本书的内容，那么我们可以看到所有这些推荐都是有意义的。
- en: Testing the revised approach
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试修订后的方法
- en: We have already obtained the recommendation, and if we check the suggested books
    using this revised approach, then we see that this simple correlation-based approach
    works rather well. We performed manual testing and evaluated the quality of the
    recommendations and the suggestions were surprisingly more sensible and useful
    for the users.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经获得了推荐，如果我们使用这种修订后的方法检查建议的书籍，那么我们可以看到这种基于简单相关性的方法工作得相当好。我们进行了手动测试并评估了推荐的品质，建议出乎意料地更加合理和有用。
- en: In the next section, we will be discussing the problems with this approach and
    how we can improvise the approach further. Before implementing optimization, we
    need to discuss the points on which we will be focusing. So, let's list down all
    the problems or areas of improvements.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论这种方法的问题以及我们如何进一步改进方法。在实施优化之前，我们需要讨论我们将关注的要点。因此，让我们列出所有的问题或改进领域。
- en: Problems with the revised approach
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修订后方法的问题
- en: 'In this section, we need to list down the problems or areas of improvement
    so that we can improve the revised approach. Here are the points for areas of
    improvement:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们需要列出问题或改进领域，以便我们可以改进修订后的方法。以下是改进领域的要点：
- en: The correlation-based approach is not generalized for all kinds of situations,
    so we need a more sophisticated approach. Basically, the correlation-based approach
    performs really well if the model has seen a similar kind of data example during
    training. For unseen data examples, it may not generate good results.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于相关性的方法并没有适用于所有情况，因此我们需要一个更复杂的方法。基本上，如果模型在训练期间看到了类似的数据示例，基于相关性的方法表现非常好。对于未见过的数据示例，它可能不会产生好的结果。
- en: We can't always do manual testing, so we need a recommendation engine that is
    easy to develop, build, and test. The new approach can also adopt future changes,
    which means new approaches should be easy for us to change or modify as and when
    required.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不能总是进行手动测试，因此我们需要一个易于开发、构建和测试的推荐引擎。新的方法也可以适应未来的变化，这意味着新的方法应该易于我们根据需要更改或修改。
- en: Now let's see how we can improve this revised approach.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看我们如何改进这种修订后的方法。
- en: Understanding how to improve the revised approach
  id: totrans-277
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解如何改进修订后的方法
- en: In order to improve the revised approach, we will be using the well-known recommendation
    algorithm, collaborative filtering (CF). We will be using the Machine Learning
    (ML) algorithm K-nearest neighbors (KNN). This is a basic outline for how we can
    improve the revised approach.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 为了改进修订后的方法，我们将使用众所周知的推荐算法，协同过滤（CF）。我们将使用机器学习（ML）算法K最近邻（KNN）。这是我们如何改进修订后方法的基本概述。
- en: With the help of the CF algorithm and the ML algorithm, it will be easy for
    us to test the algorithm as well as modify the algorithm based on our requirements.
    You may know how KNN works, so we are not going to dive into the KNN algorithm
    in detail, but we will definitely try to understand the intuition behind the KNN
    algorithm. We will also understand how the CF-based recommendation engine works
    in detail so that all your concepts are clear during the implementation. With
    the help of these algorithms, we will build the best possible book recommendation
    system. We will compare the results of our algorithm with Amazon.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在CF算法和ML算法的帮助下，我们将很容易测试算法以及根据我们的要求修改算法。你可能知道KNN是如何工作的，所以我们不会深入探讨KNN算法的细节，但我们将努力理解KNN算法背后的直觉。我们还将详细了解基于CF的推荐引擎的工作原理，以确保在实施过程中所有概念都清晰。借助这些算法，我们将构建最佳可能的书籍推荐系统。我们将比较我们算法的结果与亚马逊。
- en: In the next section, we will cover the algorithms first and then start implementing
    our approach.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将首先介绍算法，然后开始实现我们的方法。
- en: The best approach
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最佳方法
- en: 'In this section, we are trying to build the best possible recommendation engine.
    There are two parts to this section:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们试图构建最好的推荐引擎。本节有两个部分：
- en: Understanding the key concepts
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解关键概念
- en: Implementing the best approach
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施最佳方法
- en: Our first part covers the basic concepts, such as how the CF and KNN algorithms
    work, what kind of features we need to choose, and so on. In the second part,
    we will be implementing the recommendation engine using the KNN and CF algorithm.
    We will generate the accuracy score as well as the recommendation for books. So
    let's begin!
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一部分涵盖了基本概念，例如CF和KNN算法是如何工作的，我们需要选择什么样的特征，等等。在第二部分，我们将使用KNN和CF算法实现推荐引擎。我们将生成准确度分数以及书籍推荐。那么，让我们开始吧！
- en: Understanding the key concepts
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解关键概念
- en: In this section, we will understand the concepts of collaborative filtering.
    This covers a lot of aspects of the recommendation system. So, let's explore CF.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将了解协同过滤的概念。这涵盖了推荐系统的许多方面。那么，让我们来探索CF。
- en: Collaborative filtering
  id: totrans-288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 协同过滤
- en: 'There are two main types of collaborative filtering, as follows:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 协同过滤主要有两种类型，如下所示：
- en: 'Memory-based CF:'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于记忆的CF：
- en: User-user collaborative filtering
  id: totrans-291
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户-用户协同过滤
- en: Item-item collaborative filtering
  id: totrans-292
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目-项目协同过滤
- en: 'Model-based CF:'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于模型的CF：
- en: Matrix-factorization-based algorithms
  id: totrans-294
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于矩阵分解的算法
- en: Deep learning
  id: totrans-295
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深度学习
- en: We will begin with memory-based CF and then move on to the model-based CF.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先介绍基于记忆的CF，然后转向基于模型的CF。
- en: Memory-based CF
  id: totrans-297
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 基于记忆的CF
- en: Memory-based CF is further divided into two sections. I have defined these sections
    earlier. Refer to the *Introducing the problem statement* section. Here, we need
    to understand the concepts. We will begin with user-user CF and then look into
    item-item CF.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 基于记忆的CF进一步分为两个部分。我之前已经定义了这些部分。请参阅*介绍问题陈述*部分。在这里，我们需要理解这些概念。我们将从用户-用户CF开始，然后探讨项目-项目CF。
- en: User-user collaborative filtering
  id: totrans-299
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 用户-用户协同过滤
- en: 'In user-user CF, we consider a particular user. Now we need to find users that
    are similar to our particular user. We find similar users by observing their buying
    pattern and rating pattern for the items. Based on the similarity in the ratings
    and buying patterns, we recommend products to similar types of users. In order
    to understand user-user CF, you can refer to the following figure:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在用户-用户CF中，我们考虑一个特定的用户。现在我们需要找到与我们的特定用户相似的用户。我们通过观察他们对项目的购买模式和评分模式来找到相似用户。基于评分和购买模式中的相似性，我们向类似类型的用户推荐产品。为了理解用户-用户CF，您可以参考以下图示：
- en: '![User-user collaborative filtering](img/B08394_04_35.jpg)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
  zh: '![用户-用户协同过滤](img/B08394_04_35.jpg)'
- en: 'Figure 4.35: Pictorial representation of user-user CF'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.35：用户-用户CF的图示表示
- en: Item-item CF works differently, however.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，项目-项目CF的工作方式不同。
- en: Item-item collaborative filtering
  id: totrans-304
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 项目-项目协同过滤
- en: 'In item-item CF, we consider items. We find users who like a particular item
    and other items that the user or similar users also liked and bought. So, we recommend
    the item along with the particular item the user is looking for. Here, we need
    to take items as the input and generate the list of items as a recommendation.
    You can refer to the following figure:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目-项目CF中，我们考虑项目。我们找到喜欢特定项目以及其他用户或类似用户也喜欢并购买的项目。因此，我们推荐与用户正在寻找的特定项目一起的项目。在这里，我们需要以项目作为输入，生成推荐项目列表。您可以参考以下图示：
- en: '![Item-item collaborative filtering](img/B08394_04_36.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![项目-项目协同过滤](img/B08394_04_36.jpg)'
- en: 'Figure 4.36: Image representing item-item CF'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.36：表示项目-项目CF的图像
- en: 'These two approaches can be summarized as follows:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法可以总结如下：
- en: '**Item-item CF**: We consider users who have liked x item as well as y'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**项目-项目CF**：我们考虑喜欢x项目和y项目的用户'
- en: '**User-user CF**: We consider users who, similar to you, also liked x and y
    items'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户-用户CF**：我们考虑与您相似，也喜欢x和y项目的用户'
- en: Memory-based models use similarity-based techniques. In this approach, there
    are no optimization techniques, such as a gradient descent, involved so it will
    be easy to implement. We can use the KNN ML algorithm as it doesn't use a gradient
    descent-based optimization strategy. So, during the implementation, we will be
    using the KNN algorithm.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 基于记忆的模型使用基于相似度的技术。在这个方法中，没有涉及优化技术，例如梯度下降，因此它将很容易实现。我们可以使用KNN机器学习算法，因为它不使用基于梯度的优化策略。因此，在实现过程中，我们将使用KNN算法。
- en: 'The idea behind the KNN algorithm is simple. We need to obtain the weight for
    each user or item. We can generate this weight by a cosine similarity or a person''s
    correlation coefficient. We use the similarity values, but we need to limit the
    number of similar users because we cannot consider all users to be similar. This
    number is denoted by K. Here, K indicates the number of similar neighbors or users
    we need to consider. This is the reason why the algorithm is called K-nearest
    neighbors (KNN). If you want more details on the KNN algorithm, then you can refer
    to this article: [https://www.analyticsvidhya.com/blog/2018/03/introduction-k-neighbours-algorithm-clustering/](https://www.analyticsvidhya.com/blog/2018/03/introduction-k-neighbours-algorithm-clustering/)'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: KNN算法背后的思想很简单。我们需要为每个用户或物品获得权重。我们可以通过余弦相似度或人的相关系数来生成这个权重。我们使用相似度值，但我们需要限制相似用户的数量，因为我们不能认为所有用户都是相似的。这个数字用K表示。在这里，K表示我们需要考虑的相似邻居或用户的数量。这就是为什么算法被称为K近邻（KNN）。如果您想了解更多关于KNN算法的细节，可以参考这篇文章：[https://www.analyticsvidhya.com/blog/2018/03/introduction-k-neighbours-algorithm-clustering/](https://www.analyticsvidhya.com/blog/2018/03/introduction-k-neighbours-algorithm-clustering/)
- en: Model-based CF
  id: totrans-313
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 基于模型的CF
- en: In this approach, we will be using ML-based techniques to predict the recommendation
    for users, especially for those items that are unrated. For that, we can use the
    matrix factorization method or the Deep-Learning-based approach. We will focus
    on the matrix factorization method here.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们将使用基于机器学习的技巧来预测用户的推荐，特别是对于那些未评分的项目。为此，我们可以使用矩阵分解方法或基于深度学习的途径。我们将重点关注矩阵分解方法。
- en: So, let's look at matrix factorization.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们来看看矩阵分解。
- en: Matrix-factorization-based algorithms
  id: totrans-316
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 基于矩阵分解的算法
- en: The main idea behind the matrix-factorization-based algorithm is that preferences
    of the user can be determined by the matrix operation. We need to define the small
    number of hidden or latent factors. We can refer to this matrix as factors or
    embeddings. Let's take an example to understand it better.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵分解算法背后的主要思想是用户的偏好可以通过矩阵运算来确定。我们需要定义少数几个隐藏或潜在因素。我们可以将这个矩阵称为因素或嵌入。让我们通过一个例子来更好地理解它。
- en: We need to define the embedding matrix. Here, the values are randomly initialized
    and then we perform a dot product of this embedding matrix and the book embedding
    matrix. The resultant matrix is generated in such a way that we can predict which
    book can be recommended to which user. For matrix factorization, we need nonnegative
    elements in our resultant matrix. We will use singular value decomposition (SVD)
    models to identify latent factors. There are some other techniques that can be
    used as well, such as probabilistic matrix factorization, nonnegative matrix factorization,
    and so on. We will implement this matrix factorization technique.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要定义嵌入矩阵。在这里，值是随机初始化的，然后我们执行嵌入矩阵和书籍嵌入矩阵的点积。生成的矩阵是以一种方式生成的，我们可以预测哪本书可以推荐给哪个用户。对于矩阵分解，我们需要在结果矩阵中使用非负元素。我们将使用奇异值分解（SVD）模型来识别潜在因素。还有一些其他技术也可以使用，例如概率矩阵分解、非负矩阵分解等。我们将实现这种矩阵分解技术。
- en: Difference between memory-based CF and model-based CF
  id: totrans-319
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 基于记忆的CF与基于模型的CF之间的区别
- en: The main difference between memory-based CF and model-based CF is that in the
    memory-based approach, there are no optimization techniques involved, whereas
    in the model-based approach, there is an optimization strategy and other optimization
    functions involved that improve accuracy of the model over a period of time. Now
    we will implement the CF-based approach.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 基于记忆的CF与基于模型的CF之间的主要区别在于，在基于记忆的方法中，没有涉及优化技术，而在基于模型的方法中，有一个优化策略和其他优化函数涉及其中，这些函数可以在一段时间内提高模型的准确性。现在我们将实现基于CF的方法。
- en: Implementing the best approach
  id: totrans-321
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实施最佳方法
- en: 'We will be implementing this approach by using the following steps. You can
    refer to the code on GitHub at: [https://github.com/jalajthanaki/Book_recommendation_system/blob/master/KNN_based_recommendation_system.ipynb](https://github.com/jalajthanaki/Book_recommendation_system/blob/master/KNN_based_recommendation_system.ipynb).'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过以下步骤实现这一方法。您可以在GitHub上查看代码：[https://github.com/jalajthanaki/Book_recommendation_system/blob/master/KNN_based_recommendation_system.ipynb](https://github.com/jalajthanaki/Book_recommendation_system/blob/master/KNN_based_recommendation_system.ipynb)。
- en: Loading the aset
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载aset
- en: Merging the data frames
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 合并数据框
- en: EDA for the merged data frame
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对合并的数据框进行EDA分析
- en: Filtering data based on geolocation
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据地理位置过滤数据
- en: Applying the KNN algorithm
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用KNN算法
- en: Recommendation using the KNN algorithm
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用KNN算法进行推荐
- en: Applying matrix factorization
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用矩阵分解
- en: Recommendation using matrix factorization
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用矩阵分解进行推荐
- en: Loading the dataset
  id: totrans-331
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加载数据集
- en: 'Just like we loaded the dataset in the revised approach, we need to implement
    it here as well. Take a look at the following screenshot:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在改进的方法中加载数据集一样，我们在这里也需要实现它。请看以下截图：
- en: '![Loading the dataset](img/B08394_04_37.jpg)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
  zh: '![加载数据集](img/B08394_04_37.jpg)'
- en: 'Figure 4.37: Code snippet for loading the dataset'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.37：加载数据集代码片段
- en: Merging the data frames
  id: totrans-335
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 合并数据框
- en: 'We need to merge the books and ratings data frames. We will be generating the
    total rating each book has received to date. The code snippet for this is as follows:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要合并书籍和评分数据框。我们将生成每本书至今收到的总评分。以下代码片段显示了这一过程：
- en: '![Merging the data frames](img/B08394_04_38.jpg)'
  id: totrans-337
  prefs: []
  type: TYPE_IMG
  zh: '![合并数据框](img/B08394_04_38.jpg)'
- en: 'Figure 4.38: Code snippet for generating the rating count'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.38：生成评分计数代码片段
- en: 'After that, we will be generating the book-rating score as well. Refer to the
    following screenshot:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们还将生成书籍评分。请参考以下截图：
- en: '![Merging the data frames](img/B08394_04_39.jpg)'
  id: totrans-340
  prefs: []
  type: TYPE_IMG
  zh: '![合并数据框](img/B08394_04_39.jpg)'
- en: 'Figure 4.39: Code snippet for generating the book-rating score'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.39：生成书籍评分代码片段
- en: EDA for the merged data frames
  id: totrans-342
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对合并的数据框进行EDA分析
- en: 'Here, we will perform data analysis for the total rating count. After that,
    we need to obtain the quantile value for the rating of the book. That quantile
    value gives us a good idea about the data distribution. You can refer to the code
    snippet shown in the following screenshot:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将对总评分计数进行数据分析。之后，我们需要获取书籍评分的量数值。这个量数值能给我们关于数据分布的良好概念。您可以在以下截图所示的代码片段中参考：
- en: '![EDA for the merged data frames](img/B08394_04_40.jpg)'
  id: totrans-344
  prefs: []
  type: TYPE_IMG
  zh: '![对合并的数据框进行EDA分析](img/B08394_04_40.jpg)'
- en: 'Figure 4.40: Code snippet for EDA on total-book-rating'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.40：对总书籍评分进行EDA的代码片段
- en: As you can see, only 1% of the books received a user rating of 50 or more. There
    are many books in this dataset, but we will consider only 1% of these books. The
    total number of unique books is 2,713.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，只有1%的书籍获得了50或以上的用户评分。在这个数据集中有很多书籍，但我们只考虑这些书籍中的1%。独特书籍的总数是2,713。
- en: Filtering data based on geolocation
  id: totrans-347
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 根据地理位置过滤数据
- en: 'We will limit our user data to the USA and Canada regions. This filter speeds
    up the computation. We need to combine the user data and the total book-rating
    count data. For that, the code is shown in the following screenshot:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将限制我们的用户数据仅限于美国和加拿大地区。这个过滤器可以加快计算速度。我们需要合并用户数据和总书籍评分计数数据。以下截图显示了相应的代码：
- en: '![Filtering data based on geolocation](img/B08394_04_41.jpg)'
  id: totrans-349
  prefs: []
  type: TYPE_IMG
  zh: '![基于地理位置过滤数据](img/B08394_04_41.jpg)'
- en: 'Figure 4.41: Code snippet for geolocation-based filtering'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.41：基于地理位置过滤的代码片段
- en: As you can see, now we have users that are from the USA and Canada.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，现在我们有来自美国和加拿大的用户。
- en: Applying the KNN algorithm
  id: totrans-352
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用KNN算法
- en: 'It''s time to apply the main logic. We will be applying the KNN algorithm using
    the `sklearn` library. Our main goal is to determine the closeness of the data
    instances. You can take a look at the code snippet shown in the following screenshot:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候应用主要逻辑了。我们将使用`sklearn`库应用KNN算法。我们的主要目标是确定数据实例的接近程度。您可以在以下截图所示的代码片段中查看：
- en: '![Applying the KNN algorithm](img/B08394_04_42.jpg)'
  id: totrans-354
  prefs: []
  type: TYPE_IMG
  zh: '![应用KNN算法](img/B08394_04_42.jpg)'
- en: 'Figure 4.42: Code snippet for implementing the KNN algorithm'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.42：实现KNN算法的代码片段
- en: We have used cosine similarity as the KNN matric parameter and we are considering
    the five nearest neighbors. This means that the value for K=5\. After the model
    is trained, we need to obtain the recommendation using them.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已使用余弦相似度作为KNN矩阵参数，并考虑了五个最近的邻居。这意味着K=5的值。在模型训练后，我们需要使用它们来获取推荐。
- en: Recommendation using the KNN algorithm
  id: totrans-357
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用KNN算法进行推荐
- en: 'Here, we need to obtain the recommendation using the KNN algorithm that has
    been trained just now. The code is shown in the following screenshot:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们需要使用刚刚训练好的KNN算法来获取推荐。代码显示在以下截图：
- en: '![Recommendation using the KNN algorithm](img/B08394_04_43.jpg)'
  id: totrans-359
  prefs: []
  type: TYPE_IMG
  zh: '![使用KNN算法进行推荐](img/B08394_04_43.jpg)'
- en: 'Figure 4.43: Code snippet for obtaining a recommendation using KNN'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.43：使用KNN获取推荐的代码片段
- en: For recommendation purposes, we have chosen the value of K = 6, which means
    we are considering the six nearest neighbors to recommend the book to any user.
    Here, we have chosen the book randomly from the `us_canada_user_rating_pivot`
    data frame.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 为了推荐的目的，我们选择了K=6的值，这意味着我们在为任何用户推荐书籍时考虑了最近的六个邻居。在这里，我们从`us_canada_user_rating_pivot`数据框中随机选择了这本书。
- en: The suggestions look great. All of The Green Mile series books are recommended
    here.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 这些建议看起来很棒。这里推荐了《绿里奇迹》系列的所有书籍。
- en: Applying matrix factorization
  id: totrans-363
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用矩阵分解
- en: 'Now let''s implement the matrix factorization method. We will convert the USA
    and Canada user rating data frame into a 2D matrix. This matrix is also referred
    to as a utility matrix. We have replaced the missing value with 0\. You can refer
    to the code given in the following screenshot:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来实现矩阵分解方法。我们将把美国和加拿大用户评分数据框转换成一个二维矩阵。这个矩阵也被称为效用矩阵。我们用0替换了缺失值。您可以参考以下截图中的代码：
- en: '![Applying matrix factorization](img/B08394_04_44.jpg)'
  id: totrans-365
  prefs: []
  type: TYPE_IMG
  zh: '![应用矩阵分解](img/B08394_04_44.jpg)'
- en: 'Figure 4.44: Code snippet for generating the utility matrix'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.44：生成效用矩阵的代码片段
- en: 'Now we need to transpose the utility matrix. The `bookTitles` become rows and
    `userID` is converted into columns. After that, we will apply `TruncatedSVD` for
    dimensionality reduction. This operation is performed on columns—on `userID`—because
    we need to use the book''s title afterward. You can refer to the code shown in
    the following screenshot:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要转置效用矩阵。`bookTitles`变成行，`userID`转换为列。之后，我们将应用`TruncatedSVD`进行降维。这个操作是在列——在`userID`上——执行的，因为我们之后需要使用书籍的标题。您可以参考以下截图中的代码：
- en: '![Applying matrix factorization](img/B08394_04_45.jpg)'
  id: totrans-368
  prefs: []
  type: TYPE_IMG
  zh: '![应用矩阵分解](img/B08394_04_45.jpg)'
- en: 'Figure 4.45: Code snippet for SVD dimensionality reduction'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.45：SVD降维的代码片段
- en: Here, we have chosen the value of `n_components` as 12\. So as you can see,
    the dimensionality of our data frame has reduced a lot. Earlier, the dimensions
    of the data frame were 40017 x 2442, which has now become 2442 x 12.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们选择了`n_components`的值为12。所以如您所见，我们数据框的维度已经大大减少。之前，数据框的维度是40017 x 2442，现在变成了2442
    x 12。
- en: Now we perform Pearson's correlation coefficient for every book pair in our
    final matrix. We will compare the results with the KNN algorithm. Basically, we
    should get the suggestion we got previously using the KNN algorithm for this approach
    as well.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对最终矩阵中的每一对书籍执行皮尔逊相关系数。我们将比较这些结果与KNN算法。基本上，我们应该使用这种方法以及KNN算法得到之前得到的建议。
- en: Recommendation using matrix factorization
  id: totrans-372
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用矩阵分解进行推荐
- en: 'Here, we need to generate a recommendation using the matrix factorization technique.
    We will list down all the recommendations for The Green Mile: Night Journey (Green
    Mile Series). The algorithm should suggest highly correlated books. We have applied
    a threshold for the correlation. Only those books that have a correlation score
    of more than 0.9 to less than 1 are listed using this approach. You can refer
    to the code snippet given in the following screenshot:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们需要使用矩阵分解技术生成一个推荐。我们将列出《绿里奇迹：夜行》（绿里奇迹系列）的所有推荐。算法应该建议高度相关的书籍。我们已应用了一个相关性阈值。只有那些相关性得分在0.9到1之间的书籍才使用这种方法列出。您可以参考以下截图中的代码片段：
- en: '![Recommendation using matrix factorization](img/B08394_04_46.jpg)'
  id: totrans-374
  prefs: []
  type: TYPE_IMG
  zh: '![使用矩阵分解进行推荐](img/B08394_04_46.jpg)'
- en: 'Figure 4.46: Code snippet for generating a recommendation using matrix factorization'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.46：使用矩阵分解生成推荐的代码片段
- en: 'As you can see, the recommendation for all the books that have been recommended
    using the KNN-based approach appear here as well. So, this CF-based recommendation
    system works in the best manner. You can find the same kind of recommendations
    on Amazon as well. Refer to the following screenshot:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，使用基于KNN方法推荐的所有书籍的推荐也在这里列出。因此，这个基于CF的推荐系统工作得最好。你同样可以在亚马逊上找到类似的推荐。请参考以下截图：
- en: '![Recommendation using matrix factorization](img/B08394_04_47.jpg)'
  id: totrans-377
  prefs: []
  type: TYPE_IMG
  zh: '![使用矩阵分解的推荐](img/B08394_04_47.jpg)'
- en: 'Figure 4.47: Recommendation on Amazon'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.47：亚马逊上的推荐
- en: We can confirm that our recommendation engine works well.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以确认我们的推荐引擎工作得很好。
- en: Summary
  id: totrans-380
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This is the last chapter of the analytics domain. So far, you have learned a
    lot of concepts that can help us build amazing analytics applications. In this
    chapter, you learned how to make a recommendation engine for an e-commerce product.
    In the baseline approach, we used the concept of TF-IDF and cosine similarity.
    In the revised approach, we built a book recommendation system that used the concept
    of correlation. In the best approach, we used the KNN algorithm to build a recommendation
    engine that used a collaborative-filtering-based approach. We looked at the advantages
    and disadvantages of all the approaches. You also learned about the architecture
    of the recommendation system. All these topics will help you understand and build
    your own recommendation system. You can also build a computer vision-based recommendation
    engine. This kind of recommendation engine really changes the way content is recommended
    to the users. So don't hesitate to build new types of recommendation systems.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 这是分析领域的最后一章。到目前为止，你已经学到了很多可以帮助我们构建令人惊叹的分析应用的概念。在本章中，你学习了如何为电子商务产品制作推荐引擎。在基线方法中，我们使用了TF-IDF和余弦相似度的概念。在修订方法中，我们构建了一个使用相关性的概念的书本推荐系统。在最佳方法中，我们使用了KNN算法构建了一个基于协同过滤方法的推荐引擎。我们探讨了所有方法的优缺点。你还学习了推荐系统的架构。所有这些主题都将帮助你理解和构建你自己的推荐系统。你也可以构建一个基于计算机视觉的推荐引擎。这种类型的推荐引擎真正改变了内容推荐给用户的方式。所以，不要犹豫去构建新的推荐系统类型。
- en: From the next chapter onward, we will be addressing the applications that belong
    to the natural language processing domain or the natural language generation domain.
    The next chapter is all about sentiment analysis, which is a well-known and simple
    NLP application. We will be using a variety of Machine Learning algorithms to
    achieve the best possible result.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 从下一章开始，我们将讨论属于自然语言处理领域或自然语言生成领域的应用。下一章全部关于情感分析，这是一个众所周知且简单的NLP应用。我们将使用各种机器学习算法来达到最佳结果。
