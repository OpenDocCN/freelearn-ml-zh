<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis">
<head>
  <meta charset="UTF-8"/>
  <title>Designing a GUI for a Robot Using Qt and Python</title>
  <link type="text/css" rel="stylesheet" media="all" href="style.css"/>
  <link type="text/css" rel="stylesheet" media="all" href="core.css"/>
</head>
<body>
  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Designing a GUI for a Robot Using Qt and Python</h1>
                </header>
            
            <article>
                
<p>In the last chapter, we discussed the integration of robotic hardware components and software packages for performing autonomous navigation. After the integration, the next step is to build a GUI to control the robot. We are building a GUI that can act as a trigger for the underlying ROS commands. Instead of running all the commands on the Terminal, the user can work with the GUI buttons. The GUI we are going to design is for a typical hotel room with nine tables. The user can set a table position in the map of the hotel room and command the robot to go to a particular table to deliver food. After delivering the food, the user can command the robot to go to its home position.</p>
<p>The following topics will be covered in the chapter:</p>
<ul>
<li>Installing Qt on Ubuntu</li>
<li>Introduction to PyQt and PySide</li>
<li>Introduction to Qt Designer</li>
<li>Qt signals and slots</li>
<li>Converting a Qt UI file to a Python file</li>
<li>Working with the ChefBot GUI application</li>
<li>Introduction to rqt and its features</li>
</ul>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>To test the application and code in this chapter, you need an Ubuntu 16.04 LTS PC/laptop with ROS Kinetic installed.</p>
<p>You need to know Qt, PyQt, and rqt installed.</p>
<p>Two of the most popular GUI frameworks currently available are Qt (<a href="http://qt.digia.com"><span class="URLPACKT">http://qt.digia.com</span></a>) and GTK+ (<a href="http://www.gtk.org/"><span class="URLPACKT">http://www.gtk.org/</span></a>).Qt and GTK+ are open source, cross-platform user interface toolkits and development platforms. These two software frameworks are widely used in Linux desktop environments, such as GNOME and KDE.</p>
<p>In this chapter, we will be using Python binding of the Qt framework to implement the GUI because Python binding of Qt is easier to develop compared to other methods. We will look at how to develop a GUI from scratch and program it using Python. After discussing basic Python and Qt programming, we will discuss ROS interfaces of Qt and Python, which are already available in ROS. We will first look at what the Qt UI framework is and how to install it on our PC.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Installing Qt on Ubuntu 16.04 LTS</h1>
                </header>
            
            <article>
                
<p>Qt is a cross-platform application framework that is widely used to develop application software with a GUI interface as well as command line tools. Qt is available in almost all operating systems, such as Windows, macOS X, Android, and so on. The main programming language used for developing Qt applications is C++ but there are bindings available for languages such as Python, Ruby, Java, and so on. Let's take a look at how to install Qt SDK on Ubuntu 16.04. We will install Qt from the <strong>Advance Packaging Tool</strong> (<strong>APT</strong>) in Ubuntu. The APT already comes with Ubuntu installation. So, for installing Qt/Qt SDK, we can simply use the following command, which will install Qt SDK and its required dependencies from the Ubuntu package repository. We can install Qt version 4 using the following command:</p>
<pre>    <strong>$ sudo apt-get install qt-sdk</strong>  </pre>
<p>This command will install the entire Qt SDK and its libraries required for our project. The packages available on Ubuntu repositories may not be the latest versions. To get the latest version of Qt, we can download the online or offline installer of Qt for various OS platforms from the following link:</p>
<p><a href="http://qt-project.org/downloads"><span class="URLPACKT">http://qt-project.org/downloads</span></a></p>
<p>After installing Qt on our system, we will see how we can develop GUI using Qt and interface with Python.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Working with Python bindings of Qt</h1>
                </header>
            
            <article>
                
<p>Let's see how we can interface Python and Qt. In general, there are two modules available in Python for connecting to the Qt user interface. The two most popular frameworks are:</p>
<ul>
<li>PyQt</li>
<li>PySide</li>
</ul>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">PyQt</h1>
                </header>
            
            <article>
                
<p><strong>PyQt</strong> is one of the most popular Python bindings for Qt cross-platform. PyQt is developed and maintained by Riverbank Computing Limited. It provides binding for Qt version 4 and Qt version 5 and comes with GPL (version 2 or 3) along with a commercial license. PyQt is available for Qt version 4 and 5, called PyQt4 and PyQt5, respectively. These two modules are compatible with Python versions 2 and 3. PyQt contains more than 620 classes that cover the user interface, XML, network communication, web, and so on.</p>
<p>PyQt is available in Windows, Linux, and macOS X. It is a prerequisite to install Qt SDK and Python in order to install PyQt. The binaries for Windows and macOS X are available at the following link:</p>
<p><a href="http://www.riverbankcomputing.com/software/pyqt/download"><span class="URLPACKT">http://www.riverbankcomputing.com/software/pyqt/download</span></a></p>
<p>We will see how to install PyQt4 on Ubuntu 16.04 using Python 2.7.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Installing PyQt in Ubuntu 16.04 LTS</h1>
                </header>
            
            <article>
                
<p>If you want to install PyQt on Ubuntu/Linux, use the following command. This command will install the PyQt library, its dependencies, and some Qt tools:</p>
<pre>    <strong>$ sudo apt-get install python-qt4 pyqt4-dev-tools</strong></pre>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">PySide</h1>
                </header>
            
            <article>
                
<p><strong>PySide</strong> is an open source software project that provides Python binding for the Qt framework. The PySide project was initiated by Nokia and offers a full set of Qt binding for multiple platforms. The technique used in PySide to wrap the Qt library is different from PyQt, but the API of both is similar. PySide is currently not supported on Qt 5. PySide is available for Windows, Linux, and macOS X. The following link will guide you to set up PySide on Windows and macOS X:</p>
<p><a href="http://qt-project.org/wiki/Category:LanguageBindings::PySide::Downloads"><span class="URLPACKT">http://qt-project.org/wiki/Category:LanguageBindings::PySide::Downloads</span></a></p>
<p>The prerequisites of PySide are the same as PyQt. Let's see how we can install PySide on Ubuntu 16.04 LTS.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Installing PySide on Ubuntu 16.04 LTS</h1>
                </header>
            
            <article>
                
<p>The PySide package is available on the Ubuntu package repository. The following command will install the PySide module and Qt tools on Ubuntu:</p>
<pre>    <strong>$ sudo apt-get install python-pyside pyside-tools</strong>  </pre>
<p>Let's work with both modules and see the differences between both.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Working with PyQt and PySide</h1>
                </header>
            
            <article>
                
<p>After installing the PyQt and PySide packages, we will look at how to write an <span class="packt_screen">Hello World</span> GUI using PyQt and PySide. The main difference between PyQt and PySide is only in some commands; most of the steps are the same. Let's see how to make a Qt GUI and convert it into Python code.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Introducing Qt Designer</h1>
                </header>
            
            <article>
                
<p>Qt Designer is the tool for designing and inserting control into the Qt GUI. The Qt GUI is basically an XML file that contains the information of its components and controls. The first step to work with the GUI relates to its design. The Qt Designer tool provides various options to make excellent GUIs.</p>
<p>Start Qt Designer by entering the <kbd>designer-qt4</kbd> command on the Terminal. The following screenshot shows what you will be able to see after running this command:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="images/79d339d8-e7cf-4e57-8570-7632032b932b.png"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">Qt 4 Designer</div>
<p>The preceding screenshot shows the Qt Designer interface. Select the <span class="packt_screen">Widget</span> option from the <span class="packt_screen">New Form</span> window and click on the <span class="packt_screen">Create</span> button. This will create an empty widget; we can drag various GUI controls from the left-hand side of Qt 4 Designer to the empty widget. Qt widgets are the basic building blocks of the Qt GUI. The following screenshot shows a form with a <span class="packt_screen">PushButton</span> dragged from the left-hand side window of Qt Designer:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="images/4c5fde11-b827-46ef-9b6f-9a4b73be38d8.png"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">Qt Designer widget form</div>
<p>The <span class="packt_screen">Hello World</span> application that we are going to build will have a <span class="packt_screen">PushButton</span>. When we click on the <span class="packt_screen">PushButton</span>, an <span class="packt_screen">Hello World</span> message will be printed on the Terminal. Before building the <span class="packt_screen">Hello World</span> application, we need to understand what Qt signals and slots are, because we have to use these features for building the <span class="packt_screen">Hello World</span> application.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Qt signals and slots</h1>
                </header>
            
            <article>
                
<p>In Qt, GUI events are handled using the signals and slots features. A signal is emitted from the GUI when an event occurs. Qt widgets have many predefined signals, and users can add custom signals for GUI events. A slot is a function that is called in response to a particular signal. In this example, we are using the <kbd>clicked()</kbd> signal of <span class="packt_screen">PushButton</span> and creating a custom slot for this signal.</p>
<p>We can write our own code inside this custom function. Let's see how we can create a button, connect a signal to a slot, and convert the entire GUI to Python. Here are the steps involved in creating the <span class="packt_screen">Hello World</span> GUI application:</p>
<ol>
<li>Drag and create a <span class="packt_screen">PushButton</span> from Qt Designer to the empty <span class="packt_screen">Form</span>.</li>
<li>Assign a slot for the button clicked event, which emits a signal called <kbd>clicked()</kbd>.</li>
<li>Save the designed UI file in the <kbd>.ui</kbd> extension.</li>
<li>Convert UI files to Python.</li>
<li>Write the definition of the custom slot.</li>
<li>Print the <span class="packt_screen">Hello World</span> message inside the defined slot/function.</li>
</ol>
<p>We have already dragged a button from Qt Designer to an empty <span class="packt_screen">Form</span>. Press the <span class="KeyPACKT">F4</span> key to insert a slot on the button. When we press <span class="KeyPACKT">F4</span>, the <span class="packt_screen">PushButton</span> turns red, and we can drag a line from the button and place the ground symbol in the main window. This is shown in the following screenshot:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="images/ea1eb77a-605e-4063-a50d-ac83c58213bb.png"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">Assigning slots and signals in Qt 4 Designer</div>
<p>Select the <span class="packt_screen">clicked()</span> signal from the left-hand side and click on the <span class="packt_screen">Edit...</span> button to create a new custom slot. When we click on the <span class="packt_screen">Edit...</span> button, another window will pop up to create a custom function. You can create a custom function by clicking on the <span class="packt_screen">+</span> symbol. We created a custom slot called <span class="packt_screen">message()</span>, as shown in the following screenshot:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="images/ae0a6675-d42b-413b-8a7c-f7c3a82622ba.png"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">Assigning slots and signals in Qt 4 Designer</div>
<p>Click on the <span class="packt_screen">OK</span> button, save the UI file as <kbd>hello_world.ui</kbd>, and quit Qt Designer. After saving the UI file, let's see how we can convert a Qt UI file into a Python file.</p>
<p>Read more about Qt Signals and slots from the following link</p>
<p>https://doc.qt.io/qt-5/signalsandslots.html</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Converting a UI file into Python code</h1>
                </header>
            
            <article>
                
<p>After designing the UI file, we can convert the UI file into its equivalent Python code. The conversion is done using a <kbd>pyuic</kbd> compiler. We have already installed this tool while installing PyQt/PySide. The following are the commands to convert a Qt UI file into a Python file.</p>
<p>We have to use different commands for PyQt and PySide. The following command is to convert the UI into its PyQt equivalent file:</p>
<pre>    <strong>$ pyuic4 -x hello_world.ui -o hello_world.py</strong>  </pre>
<p>The <kbd>pyuic4</kbd> is a UI compiler to convert a UI file into its equivalent Python code. We need to mention the UI filename after the <kbd>-x</kbd> argument and mention the output filename after the <kbd>-o</kbd> argument.</p>
<p>There are not many changes to the PySide command. Instead of <kbd>pyuic4</kbd>, PySide uses <kbd>pyside-uic</kbd> to convert UI files into Python files. The remaining arguments are the same:</p>
<pre>    <strong>$ pyside-uic -x hello_world.ui -o hello_world.py</strong>  </pre>
<p>The preceding command will generate an equivalent Python code for the UI file. This will create a Python class that has the GUI components. The generated script will not have the definition of the custom function <kbd>message()</kbd>. We should add this custom function to generate the code. The following procedure will guide you to add the custom function; so when you click on the button, the custom function <kbd>message()</kbd> will be executed.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Adding a slot definition to PyQt code</h1>
                </header>
            
            <article>
                
<p>The generated Python code from PyQt is given here. The code generated by <kbd>pyuic4</kbd> and <kbd>pyside-uic</kbd> are the same, except in importing module names. All other parts are the same. The explanation of the code generated using PyQt is also applicable to PySide code. The code generated from the preceding conversion is as follows. The code structure and parameters can change according to the UI file that you have designed:</p>
<pre>from PyQt4 import QtCore, QtGui 
 
try: 
    _fromUtf8 = QtCore.QString.fromUtf8 
except AttributeError: 
    _fromUtf8 = lambda s: s 
 
class Ui_Form(object): 
 
    def setupUi(self, Form): 
        Form.setObjectName(_fromUtf8("Form")) 
        Form.resize(514, 355) 
 
        self.pushButton = QtGui.QPushButton(Form) 
        self.pushButton.setGeometry(QtCore.QRect(150, 80, 191, 61)) 
        self.pushButton.setObjectName(_fromUtf8("pushButton")) 
 
        self.retranslateUi(Form) 
        QtCore.QObject.connect(self.pushButton, QtCore.SIGNAL(_fromUtf8("clicked()")), Form.message) 
        QtCore.QMetaObject.connectSlotsByName(Form) 
 
 
 
    def retranslateUi(self, Form): 
        Form.setWindowTitle(QtGui.QApplication.translate("Form", "Form", None, QtGui.QApplication.UnicodeUTF8)) 
       self.pushButton.setText( QtGui.QApplication.translate("Form", "Press", None, QtGui.QApplication.UnicodeUTF8)) 
 
#This following code should be added manually 
if __name__ == "__main__": 
   import sys 
    app = QtGui.QApplication(sys.argv) 
    Form = QtGui.QWidget() 
    ui = Ui_Form() 
    ui.setupUi(Form) 
    Form.show() 
    sys.exit(app.exec_()) </pre>
<p>The preceding code is the equivalent Python script of the Qt UI file that we designed in the Qt Designer application. Here is the step-by-step procedure of the working of this code:</p>
<ol>
<li>The code will start executing from <kbd>if __name__ == "__main__":</kbd>. The first thing in the PyQt code is to create a <kbd>QApplication</kbd> object. A <kbd>QApplication</kbd> class manages the GUI application's control flow and main settings. The <kbd>QApplication</kbd> class contains the main event loop, where all events from the Windows system and other sources are processed and dispatched. It also handles initialization and finalization of an application. The <kbd>QApplication</kbd> class is inside the <kbd>QtGui</kbd> module. This code creates an object of <kbd>QApplication</kbd> called <kbd>app</kbd>. We have to add the main code manually.</li>
<li>The <kbd>Form = QtGui.QWidget()</kbd> line creates an object called <kbd>Form</kbd> of the <kbd>QWidget</kbd> class that is present inside the <kbd>QtGui</kbd> module. The <kbd>QWidget</kbd> class is the base class of all user interface objects of Qt. It can receive the mouse and keyboard event from the main Windows system.</li>
</ol>
<ol start="3">
<li>The <kbd>ui = Ui_Form()</kbd> line creates an object called <kbd>ui</kbd> of the <kbd>Ui_Form()</kbd> class defined in the code. The <kbd>Ui_Form()</kbd> object can accept the <kbd>QWidget</kbd> class that we created in the previous line and it can add buttons, text, button control, and other UI components into this <kbd>QWidget</kbd> object. The <kbd>Ui_Form()</kbd> class contains two functions: <kbd>setupUi()</kbd> and <kbd>retranslateUi()</kbd>. We can pass the <kbd>QWidget</kbd> object to the function called <kbd>setupUi()</kbd>. This function will add UI components on this widget object, such as buttons, assigning slots for signals, and so on. The <kbd>retranslateUi()</kbd> function will translate the language of the UI to other languages if needed. For example, if we need translation from English to Spanish, we can mention the corresponding Spanish word in this function.</li>
<li>The <kbd>Form.show()</kbd> line displays the final window with buttons and text.</li>
</ol>
<p>The next thing is to create the slot function, which prints the <span class="packt_screen">Hello World</span> message. The slot definition is created inside the <kbd>Ui_Form()</kbd> class. The following steps insert the slot called <kbd>message()</kbd> into the <kbd>Ui_Form()</kbd> class.</p>
<p>The <kbd>message()</kbd> function definition is as follows:</p>
<pre>    def message(self): 
    print "Hello World" </pre>
<p>This should be inserted as a function inside the <kbd>Ui_Form()</kbd> class. Also, change the following line in the <kbd>setupUi()</kbd> function inside the <kbd>Ui_Form()</kbd> class:</p>
<pre>QtCore.QObject.connect(self.pushButton, QtCore.SIGNAL(_fromUtf8("clicked()")), Form.message) </pre>
<p>The <kbd>Form.message</kbd> parameter should be replaced with the <kbd>self.message</kbd> parameter. The preceding line connects the <span class="packt_screen">PushBbutton</span> signal, <kbd>clicked(),</kbd> to the <kbd>self.message()</kbd> slot that we already inserted in the <kbd>Ui_Form()</kbd> class.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Operation of the Hello World GUI application</h1>
                </header>
            
            <article>
                
<p>After replacing the <kbd>Form.message</kbd> parameter with the <kbd>self.message</kbd> parameter, we can execute the code and the output will look like this:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="images/b2c93c15-f076-430b-b5f3-308ab5a216bb.png" style="width:51.25em;height:20.17em;"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">Running Pyqt4 application</div>
<p>When we click on the <span class="packt_screen">Press</span> the button, it will print the <span class="packt_screen">Hello world</span> message. This is all about setting a custom GUI with Python and Qt.</p>
<p>In the next section, we will see the actual GUI that we are designing for the robot.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Working with ChefBot's control GUI</h1>
                </header>
            
            <article>
                
<p>After completing the <span class="packt_screen">Hello World</span> application in PyQt, we will now discuss a GUI for controlling ChefBot. The main use of building a GUI is to create an easier way to control the robot. For example, if the robot is deployed in a hotel to serve food, the person who controls this robot need not have knowledge about the complex commands to start and stop this robot; so, building a GUI for ChefBot can reduce the complexity and make it easier for the user. We are planning to build a GUI using PyQt, ROS, and the Python interface. The ChefBot ROS package is available on GitHub at the following link: <a href="https://github.com/qboticslabs/learning_robotics_2nd_ed"><span class="URLPACKT">https://github.com/qboticslabs/learning_robotics_2nd_ed</span></a></p>
<p>If you haven't cloned the code yet, you can do so now using following command:</p>
<pre>    <strong>$ git clone <span class="URLPACKT">https://github.com/qboticslabs/learning_robotics_2nd_ed</span>.git</strong></pre>
<p>The GUI code named <kbd>robot_gui.py</kbd> is placed in the <kbd>scripts</kbd> folder, which is inside the <kbd>chefbot_bringup</kbd> package.</p>
<p>The following screenshot shows the GUI that we have designed for ChefBot:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="images/a5ce585c-4d5b-424b-b6d9-45e81d1bd871.png" style="width:18.75em;height:18.50em;"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">Running Pyqt4 application</div>
<p>The GUI has the following features:</p>
<ul>
<li>It can monitor the robot battery status and robot status. The robot status indicates the working status of the robot. For example, if the robot encounters an error, it will indicate the error on this GUI.</li>
<li>It can command the robot to move into a table position for delivering food. There is a spin box widget on the GUI to input the table position. Currently, we are planning this GUI for a room with nine tables, but we may expand it to any number according to the requirement. After inputting the table number, we can command the robot to go to that table by clicking on the <span class="packt_screen">Go</span> button; the robot will get into that position. If we want to return the robot to the initial position, we can click on the <span class="packt_screen">Home</span> button. If we want to cancel the current robot movement, click on <span class="packt_screen">Cancel</span> to stop the robot. The working of this GUI application is as follows:</li>
</ul>
<p>When we have to deploy ChefBot in a hotel, the first procedure that we have to do is to create a map of the room. After mapping the entire room properly, we have to save the map on the robot PC. The robot does the mapping only once. After mapping, we can run the localization and navigation routines and command the robot to get into a position on the map. The ChefBot ROS package comes with a map and simulation model of a hotel-like environment. We can now run this simulation and localization for testing the GUI and in the next chapter, we will discuss how to control the hardware using the GUI. If you install the ChefBot ROS packages on your local system, we can simulate a hotel environment and test the GUI.</p>
<p>Start the ChefBot simulation in a hotel-like arrangement using the following command:</p>
<pre>    <strong>$roslaunch chefbot_gazebo chefbot_hotel_world.launch</strong>  </pre>
<p>After starting the ChefBot simulation, we can run the localization and navigation routines using an already built map. The map is placed in the <kbd>chefbot_bringup</kbd> package. We can see a <kbd>map</kbd> folder inside this package. Here, we will use this map for performing this test. We can load the localization and navigation routine using the following command:</p>
<pre>    <strong>$ roslaunch chefbot_gazebo amcl_demo.launch <br/> map_file:=/home/&lt;user_name&gt;/catkin_ws/src/chefbot/chefbot_bringup/map/hotel1.yaml</strong>  </pre>
<p>The path of the map file can change in different systems, so use the path in your system instead of this path.</p>
<p>If the path mentioned is correct, it will start running the ROS navigation stack. If we want to see the robot position on the map or manually set the initial position of the robot, we can use RViz using the following command:</p>
<pre>    <strong>$ roslaunch chefbot_bringup view_navigation.launch</strong>  </pre>
<p>In RViz, we can command the robot to go to any map coordinates using the <span class="packt_screen">2D Nav Goal</span> button.</p>
<p>We can command the robot to go to any map coordinates using programming too. The ROS navigation stack works using the ROS <kbd>actionlib</kbd> library. The ROS <kbd>actionlib</kbd> library is for performing preemptable tasks; it is similar to ROS services. An advantage over ROS services is that we can cancel the request if we don't want it at that time.</p>
<p>In the GUI, we can command the robot to go to a map coordinate using the Python <kbd>actionlib</kbd> library. We can get the table position on the map using the following technique.</p>
<p>After starting the simulator and AMCL nodes, launch the keyboard teleoperation and move the robot near each table. Use the following command to get the translation and rotation of the robot:</p>
<pre>    <strong>$ rosrun tf tf_echo /map /base_link</strong>  </pre>
<p>When we click on the <span class="packt_screen">Go</span> button, the position is fed to the navigation stack and the robot plans its path and reaches its goal. We can even cancel the task at any time. So, the ChefBot GUI acts as an <kbd>actionlib</kbd> client, which sends map coordinates to the <kbd>actionlib</kbd> server; that is, the navigation stack.</p>
<p>We can now run the robot GUI to control the robot using the following command:</p>
<pre>    <strong>$ rosrun chefbot_bringup robot_gui.py</strong>  </pre>
<p>We can select a table number and click on the <span class="packt_screen">Go</span> button for moving the robot to each table.</p>
<p>Assuming that you cloned the files and got the <kbd>robot_gui.py</kbd> file, we will discuss the main slots we added into the <kbd>Ui_Form()</kbd> class for the <kbd>actionlib</kbd> client and to get values of the battery and robot status.</p>
<p>We need to import the following Python modules for this GUI application:</p>
<pre>import rospy 
import actionlib 
from move_base_msgs.msg import * 
import time 
from PyQt4 import QtCore, QtGui </pre>
<p>The additional modules we require are the ROS Python client <kbd>rospy</kbd>, and the <kbd>actionlib</kbd> module to send values to the navigation stack. The <kbd>move_base_msgs</kbd> module contains the message definition of the goal that needs to be sent to the navigation stack.</p>
<p>The robot position near each table is mentioned in a Python dictionary. The following code shows hardcode values of the robot's position near each table:</p>
<pre>table_position = dict() 
table_position[0] = (-0.465, 0.37, 0.010, 0, 0, 0.998, 0.069) 
table_position[1] = (0.599, 1.03, 0.010, 0, 0, 1.00, -0.020) 
table_position[2] = (4.415, 0.645, 0.010, 0, 0, -0.034, 0.999) 
table_position[3] = (7.409, 0.812, 0.010, 0, 0, -0.119, 0.993) 
table_position[4] = (1.757, 4.377, 0.010, 0, 0, -0.040, 0.999) 
table_position[5] = (1.757, 4.377, 0.010, 0, 0, -0.040, 0.999) 
table_position[6] = (1.757, 4.377, 0.010, 0, 0, -0.040, 0.999) 
table_position[7] = (1.757, 4.377, 0.010, 0, 0, -0.040, 0.999) 
table_position[8] = (1.757, 4.377, 0.010, 0, 0, -0.040, 0.999) 
table_position[9] = (1.757, 4.377, 0.010, 0, 0, -0.040, 0.999) </pre>
<p>We can access the position of the robot near each table by accessing this dictionary.</p>
<p>Currently, we have inserted only four values for the purpose of demonstration. You can add more values by finding the position of other tables.</p>
<p>We are assigning some variables to handle the table number, position of the robot, and the <kbd>actionlib</kbd> client inside the <kbd>Ui_Form()</kbd> class:</p>
<pre>#Handle table number from spin box 
self.table_no = 0 
#Stores current table robot position 
self.current_table_position = 0 
#Creating Actionlib client 
self.client = actionlib.SimpleActionClient('move_base',MoveBaseAction) 
#Creating goal message definition 
self.goal = MoveBaseGoal() 
#Start this function for updating battery and robot status 
self.update_values() </pre>
<p>The following code shows the signals and slots assignment in this code for buttons and spin box widgets:</p>
<pre>#Handle spinbox signal and assign to slot set_table_number() 
QtCore.QObject.connect(self.spinBox, QtCore.SIGNAL(_fromUtf8("valueChanged(int)")), self.set_table_number) 
 
#Handle Home button signal and assign to slot Home() 
QtCore.QObject.connect(self.pushButton_3, QtCore.SIGNAL(_fromUtf8("clicked()")), self.Home) 
 
#Handle Go button signal and assign to slot Go() 
QtCore.QObject.connect(self.pushButton, QtCore.SIGNAL(_fromUtf8("clicked()")), self.Go) 
 
#Handle Cancel button signal and assign to slot Cancel() 
QtCore.QObject.connect(self.pushButton_2, QtCore.SIGNAL(_fromUtf8("clicked()")), self.Cancel)</pre>
<p>The following slot handles the spin box value from the UI and assigns a table number. Also, it converts the table number to the corresponding robot position:</p>
<pre>def set_table_number(self): 
  self.table_no = self.spinBox.value() 
  self.current_table_position = table_position[self.table_no] </pre>
<p>Here is the definition of the <span class="packt_screen">Go</span> slot for the <span class="packt_screen">Go</span> button. This function will insert the robot position of the selected table in a goal message header and send it into the navigation stack:</p>
<pre>def Go(self): 
 
  #Assigning x,y,z pose and orientation to target_pose message 
  self.goal.target_pose.pose.position.x=float(self.current_table  _position[0]) 
 
  self.goal.target_pose.pose.position.y=float(self.current_table  _position[1]) 
  self.goal.target_pose.pose.position.z=float(self.current_table  _position[2]) 
 
  self.goal.target_pose.pose.orientation.x =     float(self.current_table_position[3]) 
  self.goal.target_pose.pose.orientation.y=   float(self.current_table_position[4]) 
  self.goal.target_pose.pose.orientation.z=   float(self.current_table_position[5]) 
 
  #Frame id 
  self.goal.target_pose.header.frame_id= 'map' 
 
  #Time stamp 
  self.goal.target_pose.header.stamp = rospy.Time.now() 
 
  #Sending goal to navigation stack 
  self.client.send_goal(self.goal) </pre>
<p>The following code is the <kbd>Cancel()</kbd> slot definition. This will cancel all the robot paths that it was planning to perform at that time:</p>
<pre>def Cancel(self): 
  self.client.cancel_all_goals()</pre>
<p>The following code is the definition of <kbd>Home()</kbd>. This will set the table position to zero, and call the <kbd>Go()</kbd> function. The table at position zero is the home position of the robot:</p>
<pre>def Home(self): 
  self.current_table_position = table_position[0] 
  self.Go() </pre>
<p>The following definitions are for the <kbd>update_values()</kbd> and <kbd>add()</kbd> functions. The <kbd>update_values()</kbd> method will start updating the battery level and robot status in a thread. The <kbd>add()</kbd> function will retrieve the ROS parameters of the battery status and robot status, and set them to the progress bar and label, respectively:</p>
<pre>def update_values(self): 
    self.thread = WorkThread() 
    QtCore.QObject.connect( self.thread,    QtCore.SIGNAL("update(QString)"), self.add ) 
    self.thread.start() 
def add(self,text): 
  battery_value = rospy.get_param("battery_value") 
  robot_status = rospy.get_param("robot_status") 
   self.progressBar.setProperty("value", battery_value) 
     self.label_4.setText(_fromUtf8(robot_status)) </pre>
<p>The <kbd>WorkThread()</kbd> class used in the preceding function is given here. The <kbd>WorkThread()</kbd> class is inherited from <kbd>QThread</kbd> provided by Qt for threading. The thread simply emits the signal <kbd>update(Qstring)</kbd> with a particular delay. In the preceding function, <kbd>update_values()</kbd>, the <kbd>update(QString)</kbd> signal is connected to the <kbd>self.add()</kbd> slot; so when a signal <kbd>update(QString)</kbd> is emitted from the thread, it will call the <kbd>add()</kbd> slot and update the battery and status value:</p>
<pre>class WorkThread(QtCore.QThread): 
  def __init__(self): 
    QtCore.QThread.__init__(self) 
   def __del__(self): 
    self.wait() 
   def run(self): 
    while True: 
      time.sleep(0.3) # artificial time delay 
      self.emit( QtCore.SIGNAL('update(QString)'), " " ) 
      return </pre>
<p>We have discussed how to make a GUI for ChefBot, but this GUI is only for the user who controls ChefBot. If someone wants to debug and inspect the robot data, we may have to go for other tools. ROS provides an excellent debugging tool to visualize data from the robot.</p>
<p>The rqt tool is a popular ROS tool. It is based on a Qt-based framework for GUI development for ROS. Let's discuss the rqt tool, installation procedure, and how we can inspect the sensor data from the robot.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Installing and working with rqt in Ubuntu 16.04 LTS</h1>
                </header>
            
            <article>
                
<p><strong>rqt</strong> is a software framework in ROS, which implements various GUI tools in the form of plugins. We can add plugins as dockable windows in rqt.</p>
<p>Installing rqt in Ubuntu 16.04 can be done using the following command. Before installing rqt, ensure that you have the full installation of ROS Indigo.</p>
<pre>    <strong>$ sudo apt-get install ros-&lt;ros_version&gt;-rqt</strong>  </pre>
<p>After installing the rqt packages, we can access the GUI implementation of rqt, called <kbd>rqt_gui</kbd>, in which we can dock <kbd>rqt plugins</kbd> in a single window.</p>
<p>Let's start using <kbd>rqt_gui</kbd>.</p>
<p>Run the <kbd>roscore</kbd> command before running <kbd>rqt_gui</kbd>:</p>
<pre>    <strong>$ roscore</strong>  </pre>
<p>Run the following command to start <kbd>rqt_gui</kbd>:</p>
<pre>    <strong>$ rosrun rqt_gui rqt_gui</strong>  </pre>
<p>We will get the following window if the commands work fine:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="images/e961dbae-41f4-4d68-aabc-a1841a13c0ed.png" style="width:22.58em;height:19.42em;"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">Running rqt</div>
<p>We can load and unload plugins at runtime. To analyze the ROS message log, we can load the <span class="packt_screen">Console</span> plugin from <span class="packt_screen">Plugins</span> | <span class="packt_screen">Logging</span> | <span class="packt_screen">Console</span>. In the following example, we load the <span class="packt_screen">Console</span> plugin and run a talker node inside <kbd>rospy_tutorials</kbd>, which will send an <span class="packt_screen">Hello World</span> message to a topic called <kbd>/chatter</kbd>.</p>
<p>Run the following command to start the node <kbd>talker.py</kbd>:</p>
<pre>    <strong>$rosrun rospy_tutorials talker.py</strong>  </pre>
<p>In the following screenshot, <kbd>rqt_gui</kbd> is loaded with two plugins named <span class="packt_screen">Console</span> and <span class="packt_screen">Topic Monitor</span>. The <span class="packt_screen">Topic Monitor</span> plugin can be loaded from <span class="packt_screen">Plugins</span> | <span class="packt_screen">Topics</span> | <span class="packt_screen">Topic Monitor</span>. The <span class="packt_screen">Console</span> plugin monitors the messages printing on each node and their severity. It is very useful for debugging purposes. In the following screenshot, the left section of <kbd>rqt_gui</kbd> is loaded with the <span class="packt_screen">Console</span> plugin and the right side is loaded with the <span class="packt_screen">Topic Monitor</span>. The <span class="packt_screen">Topic Monitor</span> will list the topics available and will monitor its values.</p>
<p>In the following screenshot, the <span class="packt_screen">Console</span> plugin monitors the <kbd>talker.py</kbd> node's messages and their severity level and the <span class="packt_screen">Topic Monitor</span> monitors the value inside the <kbd>/chatter</kbd> topic:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="images/6fbb4413-7100-4866-8ed2-e38d1fe16381.png"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">Running rqt with different plugins</div>
<p>We can also visualize data such as images and plot graphs on <kbd>rqt_gui</kbd>. For the robot's navigation and its inspection, there are plugins for embedding RViz on <kbd>rqt_gui</kbd>. The <span class="packt_screen">Navigation viewer</span> plugin views from the <kbd>/map</kbd> topic. The visualization plugins are available in <span class="packt_screen">Plugin</span> | <span class="packt_screen">Visualization</span>.</p>
<p>We can also create the GUI using rqt. The instructions to create rqt plugins that can load in to rqt_gui can be found at:</p>
<p><a href="http://wiki.ros.org/rqt/Tutorials/Create%20your%20new%20rqt%20plugin">http://wiki.ros.org/rqt/Tutorials/Create%20your%20new%20rqt%20plugin</a></p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we discussed creating a GUI for ChefBot that can be used by an ordinary user who doesn't have any idea about the internal workings of a robot. We used Python binding of Qt called PyQt to create this GUI. Before we looked at the main GUI design, we looked at an <span class="packt_screen">Hello World</span> application to get an easier understanding of PyQt. The UI design was done using the Qt Designer tool and the UI file was converted into its equivalent Python script using the Python UI compiler. After designing the main GUI in Qt Designer, we converted the UI file into Python script and inserted the necessary slots in the generated script. The ChefBot GUI can start the robot, select a table number, and command the robot to get into that position. The position of each table comes from the generated map where we hardcoded the positions in this Python script for testing. When a table is selected, we set a goal position on the map, and when we click on the <span class="packt_screen">Go</span> button, the robot will move into the intended position. The user can cancel the operation at any time and command the robot to come to the home position. The GUI can also receive the real-time status of the robot and its battery status. After discussing the robot GUI, we looked at the debugging GUI tool in ROS, called rqt. We saw some plugins used for debugging the data from the robot. In the next chapter, we will see the complete testing and calibration of the robot.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>What are the popular UI toolkits available on the Linux platform?</li>
<li>What are the differences between PyQt and PySide Qt bindings?</li>
<li>How do you convert a Qt UI file into Python script?</li>
<li>What are Qt signals and slots?</li>
<li>What is rqt and what are its main applications?</li>
</ol>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<p>Read more about robotic vision packages in ROS at the following links:</p>
<ul>
<li><a href="http://wiki.ros.org/rqt/UserGuide">http://wiki.ros.org/rqt/UserGuide</a></li>
<li><a href="http://wiki.ros.org/rqt/Tutorials">http://wiki.ros.org/rqt/Tutorials</a></li>
</ul>


            </article>

            
        </section>
    </div>
</body>
</html>