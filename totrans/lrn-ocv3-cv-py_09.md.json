["```py\nimport cv2\nimport numpy as np\n\nann = cv2.ml.ANN_MLP_create()\nann.setLayerSizes(np.array([9, 5, 9], dtype=np.uint8))\nann.setTrainMethod(cv2.ml.ANN_MLP_BACKPROP)\n\nann.train(np.array([[1.2, 1.3, 1.9, 2.2, 2.3, 2.9, 3.0, 3.2, 3.3]], dtype=np.float32),\n  cv2.ml.ROW_SAMPLE,\n  np.array([[0, 0, 0, 0, 0, 1, 0, 0, 0]], dtype=np.float32))\n\nprint ann.predict(np.array([[1.4, 1.5, 1.2, 2., 2.5, 2.8, 3., 3.1, 3.8]], dtype=np.float32))\n```", "```py\nann = cv2.ml.ANN_MLP_create()\n```", "```py\nann.setLayerSizes(np.array([9, 5, 9], dtype=np.uint8))\nann.setTrainMethod(cv2.ml.ANN_MLP_BACKPROP)\n```", "```py\nann.train(np.array([[1.2, 1.3, 1.9, 2.2, 2.3, 2.9, 3.0, 3.2, 3.3]], dtype=np.float32),\n  cv2.ml.ROW_SAMPLE,\n  np.array([[0, 0, 0, 0, 0, 1, 0, 0, 0]], dtype=np.float32))\n```", "```py\nann.train(np.array([[1.2, 1.3, 1.9, 2.2, 2.3, 2.9, 3.0, 3.2, 3.3]], dtype=np.float32),\n  cv2.ml.ROW_SAMPLE,\n    np.array([[0, 0, 0, 0, 0, 1, 0, 0, 0]], dtype=np.float32))\n```", "```py\nprint ann.predict(np.array([[1.4, 1.5, 1.2, 2., 2.5, 2.8, 3., 3.1, 3.8]], dtype=np.float32))\n```", "```py\n(5.0, array([[-0.06419383, -0.13360272, -0.1681568 , -0.18708915,  0.0970564 ,\n  0.89237726,  0.05093023,  0.17537238,  0.13388439]], dtype=float32))\n```", "```py\nimport cv2\nimport numpy as np\nfrom random import randint\n\nanimals_net = cv2.ml.ANN_MLP_create()\nanimals_net.setTrainMethod(cv2.ml.ANN_MLP_RPROP | cv2.ml.ANN_MLP_UPDATE_WEIGHTS)\nanimals_net.setActivationFunction(cv2.ml.ANN_MLP_SIGMOID_SYM)\nanimals_net.setLayerSizes(np.array([3, 8, 4]))\nanimals_net.setTermCriteria(( cv2.TERM_CRITERIA_EPS | cv2.TERM_CRITERIA_COUNT, 10, 1 ))\n\n\"\"\"Input arrays\nweight, length, teeth\n\"\"\"\n\n\"\"\"Output arrays\ndog, eagle, dolphin and dragon\n\"\"\"\n\ndef dog_sample():\n  return [randint(5, 20), 1, randint(38, 42)]\n\ndef dog_class():\n  return [1, 0, 0, 0]\n\ndef condor_sample():\n  return [randint(3,13), 3, 0]\n\ndef condor_class():\n  return [0, 1, 0, 0]\n\ndef dolphin_sample():\n  return [randint(30, 190), randint(5, 15), randint(80, 100)]\n\ndef dolphin_class():\n  return [0, 0, 1, 0]\n\ndef dragon_sample():\n  return [randint(1200, 1800), randint(15, 40), randint(110, 180)]\n\ndef dragon_class():\n  return [0, 0, 0, 1]\n\nSAMPLES = 5000\nfor x in range(0, SAMPLES):\n  print \"Samples %d/%d\" % (x, SAMPLES)\n  animals_net.train(np.array([dog_sample()], dtype=np.float32), cv2.ml.ROW_SAMPLE, np.array([dog_class()], dtype=np.float32))\n  animals_net.train(np.array([condor_sample()], dtype=np.float32), cv2.ml.ROW_SAMPLE, np.array([condor_class()], dtype=np.float32))\n  animals_net.train(np.array([dolphin_sample()], dtype=np.float32), cv2.ml.ROW_SAMPLE, np.array([dolphin_class()], dtype=np.float32))\n  animals_net.train(np.array([dragon_sample()], dtype=np.float32), cv2.ml.ROW_SAMPLE, np.array([dragon_class()], dtype=np.float32))\n\nprint animals_net.predict(np.array([dog_sample()], dtype=np.float32))\nprint animals_net.predict(np.array([condor_sample()], dtype=np.float32))\nprint animals_net.predict(np.array([dragon_sample()], dtype=np.float32))\n```", "```py\nimport cv2\nimport numpy as np\nfrom random import randint\n```", "```py\nanimals_net = cv2.ml.ANN_MLP_create()\nanimals_net.setTrainMethod(cv2.ml.ANN_MLP_RPROP | cv2.ml.ANN_MLP_UPDATE_WEIGHTS)\nanimals_net.setActivationFunction(cv2.ml.ANN_MLP_SIGMOID_SYM)\nanimals_net.setLayerSizes(np.array([3, 8, 4]))\n```", "```py\nanimals_net.setTermCriteria(( cv2.TERM_CRITERIA_EPS | cv2.TERM_CRITERIA_COUNT, 10, 1 ))\n```", "```py\n\"\"\"Input arrays\nweight, length, teeth\n\"\"\"\n\n\"\"\"Output arrays\ndog, eagle, dolphin and dragon\n\"\"\"\n\ndef dog_sample():\n  return [randint(5, 20), 1, randint(38, 42)]\n\ndef dog_class():\n  return [1, 0, 0, 0]\n\ndef condor_sample():\n  return [randint(3,13), 3, 0]\n\ndef condor_class():\n  return [0, 1, 0, 0]\n\ndef dolphin_sample():\n  return [randint(30, 190), randint(5, 15), randint(80, 100)]\n\ndef dolphin_class():\n  return [0, 0, 1, 0]\n\ndef dragon_sample():\n  return [randint(1200, 1800), randint(15, 40), randint(110, 180)]\n\ndef dragon_class():\n  return [0, 0, 0, 1]\n```", "```py\nSAMPLES = 5000\nfor x in range(0, SAMPLES):\n  print \"Samples %d/%d\" % (x, SAMPLES)\n  animals_net.train(np.array([dog_sample()], dtype=np.float32), cv2.ml.ROW_SAMPLE, np.array([dog_class()], dtype=np.float32))\nanimals_net.train(np.array([condor_sample()], dtype=np.float32), cv2.ml.ROW_SAMPLE, np.array([condor_class()], dtype=np.float32))\n  animals_net.train(np.array([dolphin_sample()], dtype=np.float32), cv2.ml.ROW_SAMPLE, np.array([dolphin_class()], dtype=np.float32))\n        animals_net.train(np.array([dragon_sample()], dtype=np.float32),        cv2.ml.ROW_SAMPLE, np.array([dragon_class()], dtype=np.float32))\n```", "```py\n(1.0, array([[ 1.49817729,  1.60551953, -1.56444871, -0.04313202]], dtype=float32))\n(1.0, array([[ 1.49817729,  1.60551953, -1.56444871, -0.04313202]], dtype=float32))\n(3.0, array([[-1.54576635, -1.68725526,  1.6469276 ,  2.23223686]], dtype=float32))\n```", "```py\ndef record(sample, classification):\n  return (np.array([sample], dtype=np.float32), np.array([classification], dtype=np.float32))\n\nrecords = []\nRECORDS = 5000\nfor x in range(0, RECORDS):\n  records.append(record(dog_sample(), dog_class()))\n  records.append(record(condor_sample(), condor_class()))\n  records.append(record(dolphin_sample(), dolphin_class()))\n  records.append(record(dragon_sample(), dragon_class()))\n\nEPOCHS = 5\nfor e in range(0, EPOCHS):\n  print \"Epoch %d:\" % e\n  for t, c in records:\n    animals_net.train(t, cv2.ml.ROW_SAMPLE, c)\n```", "```py\ndog_results = 0\nfor x in range(0, 100):\n  clas = int(animals_net.predict(np.array([dog_sample()], dtype=np.float32))[0])\n  print \"class: %d\" % clas\n  if (clas) == 0:\n    dog_results += 1\n```", "```py\nprint \"Dog accuracy: %f\" % (dog_results)\nprint \"condor accuracy: %f\" % (condor_results)\nprint \"dolphin accuracy: %f\" % (dolphin_results)\nprint \"dragon accuracy: %f\" % (dragon_results)\n```", "```py\nDog accuracy: 100.000000%\ncondor accuracy: 0.000000%\ndolphin accuracy: 0.000000%\ndragon accuracy: 92.000000%\n```", "```py\nimport cv2\nimport cPickle\nimport numpy as np\nimport gzip\n\ndef load_data():\n  mnist = gzip.open('./data/mnist.pkl.gz', 'rb')\n  training_data, classification_data, test_data = cPickle.load(mnist)\n  mnist.close()\n  return (training_data, classification_data, test_data)\n\ndef wrap_data():\n  tr_d, va_d, te_d = load_data()\n  training_inputs = [np.reshape(x, (784, 1)) for x in tr_d[0]]\n  training_results = [vectorized_result(y) for y in tr_d[1]]\n  training_data = zip(training_inputs, training_results)\n  validation_inputs = [np.reshape(x, (784, 1)) for x in va_d[0]]\n  validation_data = zip(validation_inputs, va_d[1])\n  test_inputs = [np.reshape(x, (784, 1)) for x in te_d[0]]\n  test_data = zip(test_inputs, te_d[1])\n  return (training_data, validation_data, test_data)\n\ndef vectorized_result(j):\n  e = np.zeros((10, 1))\n  e[j] = 1.0\n  return e\n\ndef create_ANN(hidden = 20):\n  ann = cv2.ml.ANN_MLP_create()\n  ann.setLayerSizes(np.array([784, hidden, 10]))\n  ann.setTrainMethod(cv2.ml.ANN_MLP_RPROP)\n  ann.setActivationFunction(cv2.ml.ANN_MLP_SIGMOID_SYM)\n  ann.setTermCriteria(( cv2.TERM_CRITERIA_EPS | cv2.TERM_CRITERIA_COUNT, 20, 1 ))\n  return ann\n\ndef train(ann, samples = 10000, epochs = 1):\n  tr, val, test = wrap_data()\n\n  for x in xrange(epochs):\n    counter = 0\n    for img in tr:\n\n      if (counter > samples):\n        break\n      if (counter % 1000 == 0):\n        print \"Epoch %d: Trained %d/%d\" % (x, counter, samples)\n      counter += 1\n      data, digit = img\n      ann.train(np.array([data.ravel()], dtype=np.float32), cv2.ml.ROW_SAMPLE, np.array([digit.ravel()], dtype=np.float32))\n    print \"Epoch %d complete\" % x\n  return ann, test\n\ndef test(ann, test_data):\n  sample = np.array(test_data[0][0].ravel(), dtype=np.float32).reshape(28, 28)\n  cv2.imshow(\"sample\", sample)\n  cv2.waitKey()\n  print ann.predict(np.array([test_data[0][0].ravel()], dtype=np.float32))\n\ndef predict(ann, sample):\n  resized = sample.copy()\n  rows, cols = resized.shape\n  if (rows != 28 or cols != 28) and rows * cols > 0:\n    resized = cv2.resize(resized, (28, 28), interpolation = cv2.INTER_CUBIC)\n  return ann.predict(np.array([resized.ravel()], dtype=np.float32))\n```", "```py\ndef create_ANN(hidden = 20):\n  ann = cv2.ml.ANN_MLP_create()\n  ann.setLayerSizes(np.array([784, hidden, 10]))\n  ann.setTrainMethod(cv2.ml.ANN_MLP_RPROP)\n  ann.setActivationFunction(cv2.ml.ANN_MLP_SIGMOID_SYM)\n  ann.setTermCriteria(( cv2.TERM_CRITERIA_EPS | cv2.TERM_CRITERIA_COUNT, 20, 1 ))\n  return ann\n```", "```py\ndef train(ann, samples = 10000, epochs = 1):\n  tr, val, test = wrap_data()\n\n  for x in xrange(epochs):\n    counter = 0\n    for img in tr:\n\n      if (counter > samples):\n        break\n      if (counter % 1000 == 0):\n        print \"Epoch %d: Trained %d/%d\" % (x, counter, samples)\n      counter += 1\n      data, digit = img\n      ann.train(np.array([data.ravel()], dtype=np.float32), cv2.ml.ROW_SAMPLE, np.array([digit.ravel()], dtype=np.float32))\n    print \"Epoch %d complete\" % x\n  return ann, test\n```", "```py\ndata = [[ 1, 2, 3], [4, 5, 6], [7, 8, 9]]\n```", "```py\n      [1, 2, 3, 4, 5, 6, 7, 8, 9] \n```", "```py\ndef predict(ann, sample):\n  resized = sample.copy()\n  rows, cols = resized.shape\n  if (rows != 28 or cols != 28) and rows * cols > 0:\n    resized = cv2.resize(resized, (28, 28), interpolation = cv2.INTER_CUBIC)\n  return ann.predict(np.array([resized.ravel()], dtype=np.float32))\n```", "```py\nimport cv2\nimport numpy as np\nimport digits_ann as ANN\n\ndef inside(r1, r2):\n  x1,y1,w1,h1 = r1\n  x2,y2,w2,h2 = r2\n  if (x1 > x2) and (y1 > y2) and (x1+w1 < x2+w2) and (y1+h1 < y2 + h2):\n    return True\n  else:\n    return False\n\ndef wrap_digit(rect):\n  x, y, w, h = rect\n  padding = 5\n  hcenter = x + w/2\n  vcenter = y + h/2\n  if (h > w):\n    w = h\n    x = hcenter - (w/2)\n  else:\n    h = w\n    y = vcenter - (h/2)\n  return (x-padding, y-padding, w+padding, h+padding)\n\nann, test_data = ANN.train(ANN.create_ANN(56), 20000)\nfont = cv2.FONT_HERSHEY_SIMPLEX\n\npath = \"./images/numbers.jpg\"\nimg = cv2.imread(path, cv2.IMREAD_UNCHANGED)\nbw = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\nbw = cv2.GaussianBlur(bw, (7,7), 0)\nret, thbw = cv2.threshold(bw, 127, 255, cv2.THRESH_BINARY_INV)\nthbw = cv2.erode(thbw, np.ones((2,2), np.uint8), iterations = 2)\nimage, cntrs, hier = cv2.findContours(thbw.copy(), cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)\n\nrectangles = []\n\nfor c in cntrs:\n  r = x,y,w,h = cv2.boundingRect(c)\n  a = cv2.contourArea(c)\n  b = (img.shape[0]-3) * (img.shape[1] - 3)\n\n  is_inside = False\n  for q in rectangles:\n    if inside(r, q):\n      is_inside = True\n      break\n  if not is_inside:\n    if not a == b:\n      rectangles.append(r)\n\nfor r in rectangles:\n  x,y,w,h = wrap_digit(r) \n  cv2.rectangle(img, (x,y), (x+w, y+h), (0, 255, 0), 2)\n  roi = thbw[y:y+h, x:x+w]\n\n  try:\n    digit_class = int(ANN.predict(ann, roi.copy())[0])\n  except:\n    continue\n  cv2.putText(img, \"%d\" % digit_class, (x, y-1), font, 1, (0, 255, 0))\n\ncv2.imshow(\"thbw\", thbw)\ncv2.imshow(\"contours\", img)\ncv2.imwrite(\"sample.jpg\", img)\ncv2.waitKey()\n```", "```py\ndef inside(r1, r2):\n  x1,y1,w1,h1 = r1\n  x2,y2,w2,h2 = r2\n  if (x1 > x2) and (y1 > y2) and (x1+w1 < x2+w2) and (y1+h1 < y2 + h2):\n    return True\n  else:\n    return False\n```", "```py\ndef wrap_digit(rect):\n  x, y, w, h = rect\n  padding = 5\n  hcenter = x + w/2\n  vcenter = y + h/2\n  if (h > w):\n    w = h\n    x = hcenter - (w/2)\n  else:\n    h = w\n    y = vcenter - (h/2)\n  return (x-padding, y-padding, w+padding, h+padding)\n```", "```py\nann, test_data = ANN.train(ANN.create_ANN(58), 20000)\n```", "```py\nann, test_data = ANN.train(ANN.create_ANN(100), 50000, 30)\n```", "```py\npath = \"./images/numbers.jpg\"\nimg = cv2.imread(path, cv2.IMREAD_UNCHANGED)\nbw = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\nbw = cv2.GaussianBlur(bw, (7,7), 0)\n```", "```py\nret, thbw = cv2.threshold(bw, 127, 255, cv2.THRESH_BINARY_INV)\nthbw = cv2.erode(thbw, np.ones((2,2), np.uint8), iterations = 2)\n```", "```py\nimage, cntrs, hier = cv2.findContours(thbw.copy(), cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)\n```", "```py\nrectangles = []\n\nfor c in cntrs:\n  r = x,y,w,h = cv2.boundingRect(c)\n  a = cv2.contourArea(c)\n  b = (img.shape[0]-3) * (img.shape[1] - 3)\n\n  is_inside = False\n  for q in rectangles:\n    if inside(r, q):\n      is_inside = True\n      break\n  if not is_inside:\n    if not a == b:\n      rectangles.append(r)\n```", "```py\nfor r in rectangles:\n  x,y,w,h = wrap_digit(r) \n```", "```py\n  cv2.rectangle(img, (x,y), (x+w, y+h), (0, 255, 0), 2)\n  roi = thbw[y:y+h, x:x+w]\n\n  try:\n    digit_class = int(ANN.predict(ann, roi.copy())[0])\n  except:\n    continue\n  cv2.putText(img, \"%d\" % digit_class, (x, y-1), font, 1, (0, 255, 0))\n```", "```py\ncv2.imshow(\"thbw\", thbw)\ncv2.imshow(\"contours\", img)\ncv2.imwrite(\"sample.jpg\", img)\ncv2.waitKey()\n```"]