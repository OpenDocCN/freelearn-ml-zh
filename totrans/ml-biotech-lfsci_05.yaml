- en: 'Chapter 4: Visualizing Data with Python'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章：使用Python可视化数据
- en: 'Regardless of the field of work you operate in, the career path you''ve chosen,
    or the specific project you are working on, the ability to effectively communicate
    information to others will always be useful. In fact, exactly one hundred years
    ago, in 1921, Frederick R. Barnard first said something which has become a phrase
    you have probably heard countless times: *A picture is worth a thousand words*.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你从事哪个领域的工作，你选择的职业道路，或者你正在从事的具体项目，有效地向他人传达信息的能力始终是有用的。事实上，正好一百年前，在1921年，弗雷德里克·R·巴纳德首次说出了你可能无数次听过的短语：*一张图片胜过千言万语*。
- en: 'With the many new technologies that have emerged in the realm of machine learning
    in recent years, the amount of data being structured, processed, and analyzed
    has grown exponentially. The ability to take data in its raw form and translate
    it to a meaningful and communicative diagram is one of the most sought-after skill
    sets in the industry today. Most decisions made in large companies and corporations
    are generally data-driven, and the best way to start a conversation about an area
    you care about is to create a meaningful visualization about it. Consider the
    following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，在机器学习领域涌现出许多新技术，结构化、处理和分析的数据量呈指数增长。将原始数据转化为有意义的、易于传达的图表的能力是当今行业中最受欢迎的技能组合之一。大多数大型公司和企业的决策通常都是数据驱动的，而开始关于你关心的领域的对话的最佳方式是创建关于它的有意义的可视化。考虑以下内容：
- en: The human brain is able to process visualizations 60,000 times faster than text.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 人类大脑处理可视化比文本快60,000倍。
- en: Nearly 90% of all information processed by the human brain is done visually.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 人类大脑处理的信息中，近90%是通过视觉完成的。
- en: Visualizations are 30 times more likely to be read than even simple text.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可视化比即使是简单的文本更容易被阅读，概率高达30倍。
- en: Visualizations are not always about driving a conversation or convincing an
    opposing party to agree on something – they are often used as a means to investigate
    and explore data for the purposes of uncovering hidden insights. In almost every
    machine learning project you undertake, a significant amount of effort will be
    devoted to exploring data to uncover its hidden **features** through a process
    known as **Exploratory Data Analysis** (**EDA**). EDA is normally done prior to
    any type of machine learning project in order to better understand the data, its
    features, and its limits. One of the best ways to explore data in this fashion
    is in a visual form, allowing you to uncover much more than the numerical values
    alone.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 可视化并不总是关于推动对话或说服对立的一方同意某事——它们通常被用作调查和探索数据以揭示隐藏洞察力的手段。在几乎每一个机器学习项目中，你都将投入大量精力来探索数据，通过称为**探索性数据分析**（**EDA**）的过程来揭示其隐藏的**特征**。EDA通常在任何类型的机器学习项目之前进行，以便更好地理解数据、其特征及其限制。以这种方式探索数据最好的方式是将其以视觉形式呈现，这样你可以揭示比单纯的数值更多的内容。
- en: Over the course of the following chapter, we will look over some useful steps
    to follow to develop a robust visual for a given dataset. We will also explore
    some of the most common visualization libraries used in the **Python** community
    today. Finally, we will explore several datasets and learn how to develop some
    of the most common visualizations for them.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将探讨一些有用的步骤，以开发针对特定数据集的稳健可视化。我们还将探索目前在**Python**社区中使用的最常见可视化库。最后，我们将探索几个数据集，并学习如何为它们开发一些最常见的可视化。
- en: 'Within this chapter, we will cover the following main topics:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Exploring the six steps of data visualization
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索数据可视化的六个步骤
- en: Commonly used visualization libraries
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常用的可视化库
- en: Tutorial – visualizing data in Python
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 教程 - 在Python中可视化数据
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In this chapter, we will apply our understanding of Python and `pip` installer
    demonstrated in [*Chapter 2*](B17761_02_Final_JM_ePub.xhtml#_idTextAnchor023),
    *Introducing Python and the Command Line*. Recall that the process of installing
    a library is done via the command line:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将应用我们在[*第二章*](B17761_02_Final_JM_ePub.xhtml#_idTextAnchor023)中展示的Python和`pip`安装程序的理解，即*介绍Python和命令行*。回想一下，安装库的过程是通过命令行完成的：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: So, now that we are set up, let's begin!
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们已经准备好了，让我们开始吧！
- en: Exploring the six steps of data visualization
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索数据可视化的六个步骤
- en: 'When it comes to effectively communicating key trends in your data, the method
    in which it is presented will always be important. When presenting any type of
    data to an audience, there are two main considerations: first, selecting the correct
    segment of data for the argument; second, selecting the most effective visualization
    for the argument. When working on a new visualization, there are six steps you
    can follow to help guide you:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到有效地传达数据中的关键趋势时，数据呈现的方式始终非常重要。在向观众展示任何类型的数据时，有两个主要考虑因素：首先，选择正确的数据段来支持论点；其次，选择最有效的可视化方式来支持论点。在制作新的可视化时，你可以遵循以下六个步骤来帮助你：
- en: '**Acquire**: Obtain the data from its source.'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**获取**: 从其来源处获取数据。'
- en: '**Understand**: Learn about the data and understand its categories and features.'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**理解**: 了解数据并理解其类别和特征。'
- en: '`NaN` values, and corrupt entries.'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`NaN`值和损坏的条目。'
- en: '**Mine**: Identify patterns or engineer new features.'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**我的任务**: 识别模式或设计新的功能。'
- en: '**Condense**: Isolate the most useful features.'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**浓缩**: 隔离最有用的特征。'
- en: '**Represent**: Select a representation for these features.'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**表示**: 为这些功能选择一个表示方式。'
- en: Let's look at each step in detail.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细看看每个步骤。
- en: The first step is to *acquire* your data from its source. This source may be
    a simple CSV file, a relational database, or even a **NoSQL** database.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是从其来源处获取你的数据。这个来源可能是一个简单的CSV文件，一个关系型数据库，甚至是一个**NoSQL**数据库。
- en: Second, it is important to *understand* the context of the data as well as its
    content. As a data scientist, your objective is to place yourself in the shoes
    of your stakeholders and understand their data as best you can. Often, a simple
    conversation with a **Subject Matter Expert** (**SME**) can save you hours by
    highlighting facts about the data that you otherwise would not have known.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 第二步，理解数据的内容及其上下文非常重要。作为一名数据科学家，你的目标是站在利益相关者的角度，尽可能好地理解他们的数据。通常，与**主题专家**（SME）的简单交谈可以节省你数小时的时间，因为它会突出显示关于数据的你原本不知道的事实。
- en: Third, *filtering* your data will always be crucial. Most real-world applications
    of data science rarely involve ready-to-use datasets. Often, data in its raw form
    will be the main data source, and it is up to data scientists and developers to
    ensure that any missing values and corrupt entries are taken care of. Data scientists
    often refer to this step as **preprocessing**, and we will explore this in more
    detail in [*Chapter 5*](B17761_05_Final_JM_ePub.xhtml#_idTextAnchor082), *Understanding
    Machine Learning*.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，**过滤**数据始终至关重要。大多数数据科学在现实世界中的应用很少涉及现成的数据集。通常，原始数据将是主要的数据来源，而数据科学家和开发人员需要确保任何缺失值和损坏的条目得到处理。数据科学家通常将这一步骤称为**预处理**，我们将在[*第五章*](B17761_05_Final_JM_ePub.xhtml#_idTextAnchor082)中更详细地探讨，*理解机器学习*。
- en: With the data preprocessed, our next objective is to *mine* the data in an attempt
    to identify patterns or engineer new features. In simple datasets, values can
    often be quickly visualized as either increasing or decreasing, allowing us to
    easily understand the trend. In multidimensional datasets, these trends are often
    more difficult to uncover. For example, a time-series graph may show you an increasing
    *trend*, however, the first derivative of this graph may expose *trends* relating
    to *seasonality*.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 数据预处理完成后，我们的下一个目标是**挖掘**数据，试图识别模式或设计新的功能。在简单的数据集中，值通常可以快速可视化为增加或减少，使我们能够轻松理解趋势。在多维数据集中，这些趋势往往更难以发现。例如，时间序列图可能显示一个增加的趋势，然而，这个图的第一次导数可能会暴露与**季节性**相关的趋势。
- en: Once a trend of interest is identified, the data representing that trend is
    often *isolated* from the rest of the data. And finally, this trend is *represented*
    using a visualization that complements it.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦确定了感兴趣的趋势，代表该趋势的数据通常会被从其他数据中**隔离**出来。最后，使用与之相匹配的可视化来**表示**这个趋势。
- en: It is important to understand that these steps are by no means hard rules, but
    they should be thought of as useful guidelines to assist you in generating effective
    visualizations. Not every visualization will require every step! In fact, some
    visualizations may require other steps, perhaps sometimes in a different order.
    We will go through a number of these steps to generate some visualizations later
    in the *Tutorial – Visualizing data in Python* section within this chapter. When
    we do, try to recall these steps and see if you can identify them.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解，这些步骤绝对不是硬性规定，而应该被视为有用的指南，以帮助您生成有效的可视化。并非每个可视化都需要每个步骤！实际上，某些可视化可能需要其他步骤，有时顺序可能不同。我们将在本章的“*教程
    – 在 Python 中可视化数据*”部分中通过一系列步骤来生成一些可视化。当我们这样做的时候，尝试回忆这些步骤，看看您是否能识别出它们。
- en: Before we begin generating some interesting visuals, let's talk about some of
    the libraries we will need.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始生成一些有趣的视觉效果之前，让我们谈谈我们将需要的库。
- en: Commonly used visualization libraries
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常用可视化库
- en: 'There are countless **visualization libraries** available in Python, and more
    are being published every day. Visualization libraries can be divided into two
    main categories: **static visualization** libraries and **interactive visualization**
    libraries. Static visualizations are images consisting of plotted values that
    cannot be clicked by the user. On the other hand, interactive visualizations are
    not just images but representations that can be clicked on, reshaped, moved around,
    and scaled in a particular direction. Static visualizations are often destined
    for email communications, printed publications, or slide decks, as they are visualizations
    that you do not intend others to change. However, interactive visualizations are
    generally destined for dashboards and websites (such as **AWS** or **Heroku**)
    in anticipation of users interacting with them and exploring the data as permitted.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中有无数的可视化库可用，每天都有新的库发布。可视化库可以分为两大类：**静态可视化**库和**交互式可视化**库。静态可视化是由绘制的值组成的图像，用户无法点击。另一方面，交互式可视化不仅仅是图像，而是可以点击、变形、移动和按特定方向缩放的表示。静态可视化通常用于电子邮件通信、印刷出版物或演示文稿，因为它们是你不希望他人更改的视觉内容。然而，交互式可视化通常用于仪表板和网站（如
    **AWS** 或 **Heroku**），预期用户将与之交互并按允许的方式探索数据。
- en: 'The following open source libraries are currently some of the most popular
    in the industry. Each of them has its own advantages and disadvantages, which
    are detailed in the following table:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 以下开源库目前在行业中非常受欢迎。每个库都有其自身的优缺点，具体细节如下表所示：
- en: '![Figure 4.1 – A list of the most common visualization libraries in Python
    ](img/B17761_04_001.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.1 – Python 中最常见的可视化库列表](img/B17761_04_001.jpg)'
- en: Figure 4.1 – A list of the most common visualization libraries in Python
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 – Python 中最常见的可视化库列表
- en: Now that we know about visualization libraries, let's move on to the next section!
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了可视化库，让我们继续下一节！
- en: Tutorial – visualizing data in Python
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 教程 – 在 Python 中可视化数据
- en: Over the course of this tutorial, we will be retrieving a few different datasets
    from a range of sources and exploring them through various kinds of visualizations.
    To create these visuals, we will implement many of the visualization steps in
    conjunction with some of the open source visualization libraries. Let's get started!
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程的过程中，我们将从各种来源检索几个不同的数据集，并通过各种类型的可视化来探索它们。为了创建这些视觉效果，我们将结合使用一些开源可视化库来实现许多可视化步骤。让我们开始吧！
- en: Getting data
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取数据
- en: 'Recall that, in [*Chapter 3*](B17761_03_Final_JM_ePub.xhtml#_idTextAnchor050),
    *Getting Started with SQL and Relational Databases*, we used AWS to create and
    deploy a database to the cloud, allowing us to query data using `sqlalchemy`:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，在 [*第 3 章*](B17761_03_Final_JM_ePub.xhtml#_idTextAnchor050) “*SQL 和关系型数据库入门*”中，我们使用
    AWS 创建并部署了一个数据库到云端，使我们能够使用 `sqlalchemy` 查询数据：
- en: 'Let''s query that dataset directly from `endpoint`, `username`, and `password`
    values generated in the previous chapter. Go ahead and list these as variables
    in Python:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从上一章生成的 `endpoint`、`username` 和 `password` 值中直接查询该数据集。请将这些值作为 Python 中的变量列出：
- en: '[PRE1]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'With the variables populated with your respective parameters, we can now query
    this data using `sqlalchemy`. Since we are interested in the dataset as a whole,
    we can simply run a `SELECT * FROM dataset_toxicity_sd` command:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当变量被各自的参数填充后，我们现在可以使用 `sqlalchemy` 查询这些数据。由于我们对整个数据集感兴趣，我们可以简单地运行一个 `SELECT
    * FROM dataset_toxicity_sd` 命令：
- en: '[PRE2]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Alternatively, you can simply import the same dataset as a CSV file using the
    `read_csv()` function:'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 或者，您也可以简单地使用 `read_csv()` 函数将相同的数据集作为 CSV 文件导入：
- en: '[PRE3]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can take a quick look at the dataset to understand its content using the
    `head()` function. Recall that we can choose to reduce the columns by specifying
    the names of the ones we are interested in by using double square brackets (`[[]]`):'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用 `head()` 函数快速查看数据集以了解其内容。回想一下，我们可以通过使用双中括号 (`[[ ]]`) 指定我们感兴趣的列名来选择性地减少列的数量：
- en: '[PRE4]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This gives us the following output:'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这给出了以下输出：
- en: '![Figure 4.2 – A DataFrame representation of selected columns from the toxicity
    dataset ](img/B17761_04_002.jpg)'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图 4.2 – 来自毒性数据集选定列的 DataFrame 表示](img/B17761_04_002.jpg)'
- en: Figure 4.2 – A DataFrame representation of selected columns from the toxicity
    dataset
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.2 – 来自毒性数据集选定列的 DataFrame 表示
- en: If you recall, there are quite a few columns within this dataset, ranging from
    general data such as the primary key (`ID`) to the structure (`smiles`) and the
    toxicity (`toxic`). In addition, there are many features that describe and represent
    the dataset, ranging from the total polar surface area (`TPSA`) all the way to
    lipophilicity (`LogP`).
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '如果您还记得，这个数据集中有很多列，从一般数据如主键 (`ID`) 到结构 (`smiles`) 和毒性 (`toxic`)，应有尽有。此外，还有许多描述和表示数据集的特征，从总的极性表面积
    (`TPSA`) 到亲脂性 (`LogP`)。 '
- en: 'We can also get a sense of some of the general statistics behind this dataset
    – such as the maximum, minimum, and averages relating to each column – by using
    the `describe()` function in `pandas`:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以通过使用 `pandas` 中的 `describe()` 函数来了解这个数据集背后的一些一般统计信息 – 例如，与每个列相关的最大值、最小值和平均值：
- en: '[PRE5]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This results in the following table:'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这导致了以下表格：
- en: '![Figure 4.3 – Some general statistics of selected columns from the toxicity
    dataset ](img/B17761_04_003.jpg)'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图 4.3 – 来自毒性数据集选定列的一些一般统计信息](img/B17761_04_003.jpg)'
- en: Figure 4.3 – Some general statistics of selected columns from the toxicity dataset
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.3 – 来自毒性数据集选定列的一些一般统计信息
- en: Immediately, we notice that the `FormalCharge` and `LogP`) having negative values.
    So, this real-world dataset is quite diverse and spread out.
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 立即，我们注意到 `FormalCharge` 和 `LogP` 具有负值。因此，这个现实世界的数据集非常多样且分布广泛。
- en: 'Before we can explore the dataset further, we will need to ensure that there
    are no missing values. To do this, we can run a quick check using the `isna()`
    function provided by the `pandas` library. We can chain this with the `sum()`
    function to get a sum of all of the missing values for each column:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们进一步探索数据集之前，我们需要确保没有缺失值。为此，我们可以使用 `pandas` 库提供的 `isna()` 函数进行快速检查。我们可以将其与
    `sum()` 函数链式使用，以获取每个列的缺失值总和：
- en: '[PRE6]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The result is shown in *Figure 4.4*:'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 结果如 *图 4.4* 所示：
- en: '![Figure 4.4 – The list of missing values within the DataFrame ](img/B17761_04_004.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.4 – DataFrame 中缺失值的列表](img/B17761_04_004.jpg)'
- en: Figure 4.4 – The list of missing values within the DataFrame
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4 – DataFrame 中缺失值的列表
- en: Thankfully, there are no missing values from this particular dataset, so we
    are free to move forward with creating a few plots and visuals.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，这个特定数据集中没有缺失值，因此我们可以自由地继续创建一些图表和视觉元素。
- en: Important note
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: '`dropna()` function. Another option is to replace any missing value with a
    common value using the `fillna()` or `replace()` functions. Finally, you can also
    replace missing values with the mean of all the other values using the `mean()`
    function. The method you select will be highly dependent on the identity and meaning
    of the column.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`dropna()` 函数。另一个选项是使用 `fillna()` 或 `replace()` 函数将任何缺失值替换为常用值。最后，您还可以使用 `mean()`
    函数将缺失值替换为所有其他值的平均值。您选择的方法将高度依赖于列的标识和含义。'
- en: Summarizing data with bar plots
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用条形图总结数据
- en: '**Bar plots** or **bar charts** are often used to describe *categorical data*
    in which the lengths or heights of the bars are proportional to the values of
    the categories they represent. Bar plots provide a visual estimate of the central
    tendency of a dataset with the uncertainty of the estimate represented by error
    bars.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**条形图**或**条形图**通常用于描述*分类数据*，其中条形的长度或高度与它们所代表的类别值成比例。条形图提供了对数据集中心趋势的视觉估计，估计的不确定性由误差线表示。'
- en: So, let's create our first bar plot. We will be using the `seaborn` library
    for this particular task. There are a number of different ways to style your graphs.
    For the purposes of this tutorial, we will use the `darkgrid` style from `seaborn`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们创建我们的第一个条形图。我们将使用`seaborn`库来完成这个特定的任务。有几种不同的方式来设置你的图表样式。在本教程的目的上，我们将使用`seaborn`的`darkgrid`样式。
- en: 'Let''s plot the `TPSA` feature relative to the `FormalCharge` feature to get
    a sense of the relationship between them:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们绘制`TPSA`特征相对于`FormalCharge`特征，以了解它们之间的关系：
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Our initial results are shown in *Figure 4.5*:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最初的结果显示在*图4.5*中：
- en: '![Figure 4.5 – A bar plot of the TPSA and FormalCharge features ](img/B17761_04_005.png.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图4.5 – TPSA和FormalCharge特征的条形图](img/B17761_04_005.png.jpg)'
- en: Figure 4.5 – A bar plot of the TPSA and FormalCharge features
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5 – TPSA和FormalCharge特征的条形图
- en: 'Immediately, we can see an interesting relationship between the two, in the
    sense that the `TPSA` feature tends to increase when the absolute value of `FormalCharge`
    is further away from zero. If you are following along with the provided `HDonors`)
    instead of `TPSA`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 立即，我们可以看到两者之间有趣的关系，即在`TPSA`特征倾向于增加，当`FormalCharge`的绝对值远离零时。如果你正在跟随提供的`HDonors`而不是`TPSA`：
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can see the subsequent output in *Figure 4.6*:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在*图4.6*中看到后续的输出：
- en: '![Figure 4.6 – A bar plot of the HDonors and FormalCharge features ](img/B17761_04_006.png.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图4.6 – HDonors和FormalCharge特征的条形图](img/B17761_04_006.png.jpg)'
- en: Figure 4.6 – A bar plot of the HDonors and FormalCharge features
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.6 – HDonors和FormalCharge特征的条形图
- en: 'Taking a look at the plot, we do not see as strong a relationship between the
    two variables. The highest and lowest formal charges do in fact show higher hydrogen
    donors. Let''s compare this to `HAcceptors` – a similar feature in this dataset.
    We could either plot this feature individually, as we did with the hydrogen donors,
    or we could combine them both into one diagram. We can do this by *isolating*
    the features of interest (do you remember the name of this step?) and then *reshaping*
    the dataset. DataFrames within Python are often **reshaped** using four common
    functions:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 观察图表，我们并没有看到两个变量之间强烈的关联。最高和最低的正式电荷实际上显示了更高的氢供体。让我们将其与`HAcceptors`进行比较——在这个数据集中类似的一个特征。我们可以单独绘制这个特征，就像我们处理氢供体一样，或者我们可以将它们两个合并到一个图表中。我们可以通过*隔离*感兴趣的特征（你还记得这个步骤的名称吗？）然后*重塑*数据集。Python中的DataFrames通常使用四个常见的函数进行**重塑**：
- en: '![Figure 4.7 – Four of the most common DataFrame reshaping functions ](img/B17761_04_007.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图4.7 – 四个最常见的DataFrame重塑函数](img/B17761_04_007.jpg)'
- en: Figure 4.7 – Four of the most common DataFrame reshaping functions
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.7 – 四个最常见的DataFrame重塑函数
- en: Each of these functions serves to reshape the data in a specific way. The `pivot()`
    function is often used to reshape a DataFrame organized by its index. The `stack()`
    function is often used with multi-index DataFrames – this allows you to *stack*
    your data, making the table *long and narrow* instead of *wide and short*. The
    `melt()` function is similar to the `stack()` function in the sense that it also
    *stacks* your data, but the difference between them is that `stack()` will insert
    the compressed columns into the inner index, whereas `melt()` will create a new
    column called `Variable`. Finally, `unstack()` is simply the opposite of `stack()`,
    in the sense that data is converted from *long* to *wide*.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 每个函数都用于以特定方式重塑数据。`pivot()`函数通常用于重塑按其索引组织的DataFrame。`stack()`函数通常与多索引DataFrame一起使用——这允许你*堆叠*你的数据，使表格变得*长而窄*而不是*宽而短*。`melt()`函数在意义上与`stack()`函数相似，因为它也*堆叠*你的数据，但它们之间的区别在于`stack()`会将压缩的列插入到内部索引中，而`melt()`将创建一个名为`Variable`的新列。最后，`unstack()`是`stack()`的简单相反，即数据从*长*转换为*宽*。
- en: 'For the purposes of comparing the hydrogen donors and acceptors, we will be
    using the `melt()` function, which you can see in *Figure 4.8*. Note that two
    new columns are created in the process: `Variable` and `Value`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 为了比较氢供体和受体，我们将使用`melt()`函数，你可以在*图4.8*中看到它。请注意，在这个过程中创建了两个新列：`Variable`和`Value`：
- en: '![Figure 4.8 – A graphical representation of the melt() function ](img/B17761_04_008.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图4.8 – melt()函数的图形表示](img/B17761_04_008.jpg)'
- en: Figure 4.8 – A graphical representation of the melt() function
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.8 – melt()函数的图形表示
- en: 'First, we create a variable called `df_iso` to represent the isolated DataFrame,
    and then we use the `melt()` function to *melt* its data and assign it to a new
    variable called `df_melt`. We can also print the shape of the data to prove to
    ourselves that the columns *stack* correctly if they exactly *double* in length.
    Recall that you can also check the data using the `head()` function:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个名为`df_iso`的变量来表示独立的DataFrame，然后我们使用`melt()`函数将其数据*熔化*并分配给一个新的变量`df_melt`。我们还可以打印数据的形状来证明如果列的长度正好*加倍*，则列*堆叠*是正确的。回想一下，你也可以使用`head()`函数来检查数据：
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Finally, with the data ordered correctly, we can go ahead and plot this data,
    specifying the x-axis as `FormalCharge`, and the y-axis as `value`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当数据正确排序后，我们可以继续绘制这些数据，指定x轴为`FormalCharge`，y轴为`value`：
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Upon executing this line of code, we will get the following figure:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 执行这一行代码后，我们将得到以下图形：
- en: '![Figure 4.9 – A bar plot of two features relative to FormalCharge ](img/B17761_04_009.png.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图4.9 – 相对于FormalCharge的两个特征的条形图](img/B17761_04_009.png.jpg)'
- en: Figure 4.9 – A bar plot of two features relative to FormalCharge
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.9 – 相对于FormalCharge的两个特征的条形图
- en: As you begin to explore the many functions and classes within the `seaborn`
    library, referring to the documentation as you write your code can help you to
    debug errors and also uncover new functionality that you may not have known about.
    You can view the Seaborn documentation at [https://seaborn.pydata.org/api.html](https://seaborn.pydata.org/api.html).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始探索`seaborn`库中的众多函数和类时，在编写代码时参考文档可以帮助你调试错误，并发现你可能不知道的新功能。你可以在[https://seaborn.pydata.org/api.html](https://seaborn.pydata.org/api.html)查看Seaborn文档。
- en: Working with distributions and histograms
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理分布和直方图
- en: '`40`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`40`：'
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We can see the output of this code in *Figure 4.10*:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在*图4.10*中看到此代码的输出：
- en: '![Figure 4.10 – A histogram of molecular weight with a bin size of 40 ](img/B17761_04_010.png.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图4.10 – 分子量直方图，分组大小为40](img/B17761_04_010.png.jpg)'
- en: Figure 4.10 – A histogram of molecular weight with a bin size of 40
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.10 – 分子量直方图，分组大小为40
- en: 'As you explore more visualization methods in Python, you will notice that most
    libraries offer a number of quick functions that have already been developed and
    optimized to perform a specific task. We could go through the same process of
    reshaping our data for each feature and iterate through them to plot a histogram
    for each of the features, or we could simply use the `hist()` function for them
    collectively:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当你探索Python中的更多可视化方法时，你会注意到大多数库都提供了一些已经开发并优化以执行特定任务的快速函数。我们可以对每个特征进行相同的数据重塑过程，并通过它们迭代来为每个特征绘制直方图，或者我们可以简单地使用`hist()`函数对它们进行集体处理：
- en: '[PRE12]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The subsequent output can be seen in *Figure 4.11*:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 后续输出可以在*图4.11*中看到：
- en: '![Figure 4.11 – A series of histograms for various features automated using
    the hist() function ](img/B17761_04_011.png.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图4.11 – 使用hist()函数自动化的各种特征的系列直方图](img/B17761_04_011.png.jpg)'
- en: Figure 4.11 – A series of histograms for various features automated using the
    hist() function
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.11 – 使用hist()函数自动化的各种特征的系列直方图
- en: 'Histograms can also be overlayed in order to showcase two features on the same
    plot. When doing this, we would need to give the plots a degree of transparency
    by using the `alpha` parameter:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 直方图也可以叠加，以便在同一张图上展示两个特征。当这样做时，我们需要通过使用`alpha`参数给图表一定的透明度：
- en: '[PRE13]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can see the output of the preceding command in *Figure 4.12*:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在*图4.12*中看到前一个命令的输出：
- en: '![Figure 4.12 – An overlay of two histograms where their opacity was reduced
    ](img/B17761_04_012.png.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图4.12 – 两个直方图的叠加，其透明度已降低](img/B17761_04_012.png.jpg)'
- en: Figure 4.12 – An overlay of two histograms where their opacity was reduced
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.12 – 两个直方图的叠加，其透明度已降低
- en: Histograms are wonderful ways to summarize and visualize data in large quantities,
    especially when the functionality is as easy as using the `hist()` function. You
    will find that most libraries – such as `pandas` and `numpy` – have numerous functions
    with similar functionality.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 直方图是总结和可视化大量数据的绝佳方式，尤其是当使用 `hist()` 函数的功能如此简单时。你会发现大多数库，如 `pandas` 和 `numpy`，都有许多具有类似功能的功能。
- en: Visualizing features with scatter plots
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用散点图可视化特征
- en: '**Scatter plots** are representations based on *Cartesian coordinates* that
    allow for visualizations to be created in both two- and three-dimensional spaces.
    Scatter plots consist of an x-axis and a y-axis and are normally accompanied by
    an additional feature that allows for separation within the data. Scatter plots
    are best used when accompanied by a third feature that can be represented either
    by color or shape, depending on the data type available. Let''s look at a simple
    example:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**散点图**是基于*笛卡尔坐标系*的表示，允许在二维和三维空间中创建可视化。散点图由x轴和y轴组成，通常还伴随着一个额外的特征，允许在数据内部进行分离。当与第三个特征结合使用时，散点图最为有效，该特征可以通过颜色或形状表示，具体取决于可用的数据类型。让我们来看一个简单的例子：'
- en: 'We''ll take a look at an example of a simple scatter plot showing `TPSA` relative
    to the `HeavyAtoms` feature:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将查看一个简单的散点图示例，展示 `TPSA` 相对于 `HeavyAtoms` 特征：
- en: '[PRE14]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The output for the preceding code can be seen in *Figure 4.13*:'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前述代码的输出可以在*图 4.13*中看到：
- en: '![Figure 4.13 – A scatter plot of the TPSA and HeavyAtoms features ](img/B17761_04_013.png.jpg)'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图 4.13 – TPSA 和 HeavyAtoms 特征的散点图](img/B17761_04_013.png.jpg)'
- en: Figure 4.13 – A scatter plot of the TPSA and HeavyAtoms features
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.13 – TPSA 和 HeavyAtoms 特征的散点图
- en: Immediately, we notice that there is some dependency between the two features,
    as shown by the slight positive correlation.
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 立即，我们注意到这两个特征之间存在一些依赖关系，如轻微的正相关性所示。
- en: 'We can take a look at a third feature, such as `MolWt`, by changing the color
    and size using the `hue` and `size` arguments, respectively. This gives us the
    ability to plot three or four features on the same graph, giving us an excellent
    interpretation of the dataset. We can see some trending among `TPSA` relative
    to `HeavyAtoms`, and increasing `MolWt`:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过使用 `hue` 和 `size` 参数分别改变颜色和大小来查看第三个特征，例如 `MolWt`。这使我们能够在同一张图上绘制三个或四个特征，从而对数据集进行出色的解释。我们可以看到
    `TPSA` 相对于 `HeavyAtoms` 的一些趋势，以及 `MolWt` 的增加：
- en: '[PRE15]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The output of the preceding code can be seen in *Figure 4.14*:'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前述代码的输出可以在*图 4.14*中看到：
- en: '![Figure 4.14 – A scatter plot of two features, with a third represented by
    size and color ](img/B17761_04_014.png.jpg)'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图 4.14 – 两个特征的散点图，第三个特征通过大小和颜色表示](img/B17761_04_014.png.jpg)'
- en: Figure 4.14 – A scatter plot of two features, with a third represented by size
    and color
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.14 – 两个特征的散点图，第三个特征通过大小和颜色表示
- en: 'As an alternative to 2D scatter plots, we can use 3D scatter plots to introduce
    another feature in the form of a new dimension. We can take advantage of the `Plotly`
    library to implement some 3D functionality. To do this, we can define a `fig`
    object using the `scatter_3d` function, and subsequently, we define the source
    of our data and the axes of interest:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为二维散点图的替代，我们可以使用三维散点图来引入以新维度形式存在的另一个特征。我们可以利用 `Plotly` 库来实现一些三维功能。为此，我们可以使用
    `scatter_3d` 函数定义一个 `fig` 对象，然后定义我们数据源和感兴趣的轴：
- en: '[PRE16]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The output of this code will result in *Figure 4.15*:'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此代码的输出将生成*图 4.15*：
- en: '![Figure 4.15 – A 3D scatter plot of three features, colored by toxicity ](img/B17761_04_015.jpg)'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图 4.15 – 以毒性着色的三个特征的 3D 散点图](img/B17761_04_015.jpg)'
- en: Figure 4.15 – A 3D scatter plot of three features, colored by toxicity
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.15 – 以毒性着色的三个特征的 3D 散点图
- en: 'Instead of adding more features, we can add some more elements to the scatter
    plot to help interpret the two features on the x and y coordinates. We noticed
    earlier that there was a slight correlation within the dataset that seems ripe
    for exploration. It would be interesting to see if this correlation holds true
    for both toxic and non-toxic compounds. We can get a sense of the correlation
    using the `lmplot()` function, which allows us to graphically represent the correlation
    as a *linear regression* within the scatter plot:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不是增加更多功能，而是可以向散点图添加一些更多元素来帮助解释x和y坐标上的两个特征。我们之前注意到数据集中存在轻微的相关性，这似乎非常适合探索。很有趣的是，看看这种相关性是否对有毒和非有毒化合物都成立。我们可以使用`lmplot()`函数来感知这种相关性，该函数允许我们在散点图中以*线性回归*的形式图形化地表示相关性：
- en: '[PRE17]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The subsequent output can be seen in *Figure 4.16*:'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 后续输出可以在*图4.16*中看到：
- en: '![Figure 4.16 – A scatter plot of two features and their associated correlations
    ](img/B17761_04_016.png.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图4.16 – 两个特征及其相关性的散点图](img/B17761_04_016.png.jpg)'
- en: Figure 4.16 – A scatter plot of two features and their associated correlations
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.16 – 两个特征及其相关性的散点图
- en: Scatter plots are great ways to portray data relationships and begin to understand
    any dependencies or correlations they may have. Plotting regressions or lines
    of best fit can give you some insight into any possible relationships. We will
    explore this in greater detail in the following section.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 散点图是描绘数据关系和开始理解它们可能具有的任何依赖关系或相关性的绝佳方式。绘制回归或最佳拟合线可以让你对任何可能的关系有所了解。我们将在下一节中更详细地探讨这一点。
- en: Identifying correlations with heat maps
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用热图识别相关性
- en: 'Now that we have established a correlation between two molecular features within
    our dataset, let''s investigate to see if there are any others. We can easily
    go through each set of features, plot them, and look at their respective regressions
    to determine whether or not a correlation may exist. In Python, automating whenever
    possible is advised, and luckily for us, this task has already been automated!
    So, let''s take a look:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在我们数据集中的两个分子特征之间建立了相关性，让我们调查看看是否还有其他的相关性。我们可以轻松地遍历每一组特征，绘制它们，并查看它们各自的回归来确定是否存在相关性。在Python中，建议尽可能自动化，幸运的是，这项任务已经自动化了！所以，让我们来看看：
- en: 'Using the `pairplot()` function will take your dataset as input and return
    a figure of all the scatter plots for all of the features within your dataset.
    To fit the figure within the confines of this page, only the most interesting
    features were selected. However, I challenge you to run the code in the provided
    Jupyter notebook to see if there are any other interesting trends:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`pairplot()`函数将接受你的数据集作为输入，并返回一个包含你数据集中所有特征的散点图的图形。为了将图形放入本页的范围内，只选择了最有趣的特征。然而，我挑战你运行提供的Jupyter笔记本中的代码，看看是否有其他有趣的趋势：
- en: '[PRE18]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The results are presented in the form of numerous smaller graphs, as shown
    in *Figure 4.17*:'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 结果以许多较小的图形的形式呈现，如*图4.17*所示：
- en: '![Figure 4.17 – A pairplot() graphic of the toxicity dataset for selected features
    ](img/B17761_04_017.jpg)'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图4.17 – 显示所选特征的毒性数据集的pairplot()图形](img/B17761_04_017.jpg)'
- en: Figure 4.17 – A pairplot() graphic of the toxicity dataset for selected features
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.17 – 显示所选特征的毒性数据集的pairplot()图形
- en: 'Alternatively, we can capture the *Pearson correlation* for each of the feature
    pairs using the `corr()` function in conjunction with the DataFrame itself:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 或者，我们可以使用`corr()`函数与DataFrame本身结合来捕获每个特征对的*皮尔逊相关系数*：
- en: '[PRE19]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We can review these correlations as a DataFrame in *Figure 4.18*:'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以在*图4.18*中以DataFrame的形式回顾这些相关性：
- en: '![Figure 4.18 – A DataFrame showing the correlations between selected features
    ](img/B17761_04_018.jpg)'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图4.18 – 显示所选特征之间相关性的DataFrame](img/B17761_04_018.jpg)'
- en: Figure 4.18 – A DataFrame showing the correlations between selected features
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.18 – 显示所选特征之间相关性的DataFrame
- en: 'For a more visually appealing result, we can *wrap* our data within a `heatmap()`
    function and apply a color map to show dark colors for strong correlations and
    light colors for weaker ones:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了得到更吸引人的结果，我们可以在`heatmap()`函数中包裹我们的数据，并应用颜色图来显示强相关性的深色和弱相关性的浅色：
- en: '[PRE20]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Some of the code we have written so far has become a little complicated as
    we begin to *chain* multiple functions together. To provide some clarity of the
    syntax and structure, let''s take a closer look at the following function. We
    begin by calling the main `heatmap` class within the `seaborn` library (recall
    that we give this the alias `sns`). We then add our dataset, containing the sliced
    set of the features of interest. We then apply the correlation function to get
    the respective correlations, and finally add some additional arguments to style
    and color the plot:'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们之前编写的一些代码随着我们开始将多个函数**串联**在一起而变得有些复杂。为了提供一些关于语法和结构的清晰度，让我们更仔细地看看以下函数。我们首先在`seaborn`库中调用主`heatmap`类（记住我们给它取了别名`sns`）。然后我们添加我们的数据集，包含感兴趣特征的切片集。然后我们应用相关函数以获取相应的相关性，并最终添加一些额外的参数来调整图表的样式和颜色：
- en: '![Figure 4.19 – A heat map showing the correlation between selected features
    ](img/B17761_04_019.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图4.19 – 展示所选特征之间相关性的热图](img/B17761_04_019.jpg)'
- en: Figure 4.19 – A heat map showing the correlation between selected features
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.19 – 展示所选特征之间相关性的热图
- en: Identifying correlations within datasets will always be useful, regardless of
    whether you are analyzing data or preparing a predictive model. You will find
    that `corr()` and many of its derivatives are commonly used in the machine learning
    space.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您是在分析数据还是准备预测模型，识别数据集中的相关性总是有用的。您会发现`corr()`及其许多衍生函数在机器学习领域中被广泛使用。
- en: Displaying sequential and time-series plots
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示序列和时间序列图
- en: 'The datasets and features we have explored so far have all been provided in
    a *structured* and *tabular* form, existing as rows and columns within DataFrames.
    These rows are fully independent of each other. This is not always the case in
    all datasets, and *dependence* (especially *time-based dependence*) is sometimes
    a factor we need to consider. For example, take a **Fast All** (**FASTA**) sequence
    – that is, a text-based format often used in the realm of bioinformatics for representing
    nucleotide or amino acid sequences via letter codes. In molecular biology and
    genetics, a parameter known as **Guanine-Cytosine** (**GC**) **content** is a
    metric used to determine the percent of nitrogenous bases within DNA or RNA molecules.
    Let''s explore plotting this sequential data using a FASTA file for COVID-19 data:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止探索的数据集和特征都是以**结构化**和**表格化**的形式提供的，存在于DataFrame的行和列中。这些行之间是完全独立的。并非所有数据集都是这种情况，**依赖性**（尤其是**基于时间的依赖性**）有时是我们需要考虑的因素。例如，考虑一个**Fast
    All**（**FASTA**）序列——即一种基于文本的格式，常用于生物信息学领域，通过字母代码表示核苷酸或氨基酸序列。在分子生物学和遗传学中，**鸟嘌呤-胞嘧啶**（**GC**）**含量**是一个用于确定DNA或RNA分子中氮碱基百分比的指标。让我们通过使用COVID-19数据的FASTA文件来探索绘制这种序列数据的图表：
- en: 'We will begin the process by importing the dataset using the `wget` library:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将开始使用`wget`库导入数据集的过程：
- en: '[PRE21]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Next, we can calculate the GC content using the `Biopython` (also called `Bio`)
    library – one of the most commonly utilized Python libraries in the computational
    molecular biology space. The documentation and tutorials for the `Biopython` library
    can be found at [http://biopython.org/DIST/docs/tutorial/Tutorial.html](http://biopython.org/DIST/docs/tutorial/Tutorial.html).
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们可以使用`Biopython`（也称为`Bio`）库来计算GC含量——这是计算分子生物学领域中最常用的Python库之一。`Biopython`库的文档和教程可以在[http://biopython.org/DIST/docs/tutorial/Tutorial.html](http://biopython.org/DIST/docs/tutorial/Tutorial.html)找到。
- en: 'We will then parse the file using the `SeqIO` and `GC` classes and write the
    results to the `gc_values_covid` variable:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用`SeqIO`和`GC`类解析文件，并将结果写入`gc_values_covid`变量：
- en: '[PRE22]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Please note that the path to the file in the preceding code may change depending
    on which directory the file was saved in.
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请注意，前述代码中文件的路径可能会根据文件保存的目录而改变。
- en: 'Finally, we can go ahead and plot the results using either `pylab` or `matplotlib`:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以使用`pylab`或`matplotlib`来绘制结果：
- en: '[PRE23]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The subsequent output can be seen in *Figure 4.20*:'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 后续输出可以在*图4.20*中看到：
- en: '![Figure 4.20 – A plot showing the GC content of the COVID-19 sequence ](img/B17761_04_020.png.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![图4.20 – 展示COVID-19序列GC含量的图表](img/B17761_04_020.png.jpg)'
- en: Figure 4.20 – A plot showing the GC content of the COVID-19 sequence
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.20 – 展示COVID-19序列GC含量的图表
- en: 'While there are many non-time-based sequential datasets such as `text`, `images`,
    and `audio`, there are also time-based datasets such as `stock prices` and `manufacturing
    processes`. Within the laboratory space, there are many pieces of equipment that
    also utilize time series-based approaches, such as those relating to chromatography.
    For example, take `time-series` dataset and overlay `Temperature` and `Pressure`
    together over time:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有许多非基于时间的顺序数据集，如 `text`、`images` 和 `audio`，但也有基于时间的数据集，如 `stock prices` 和
    `manufacturing processes`。在实验室空间中，也有许多设备也利用基于时间序列的方法，例如与色谱相关的方法。例如，考虑 `time-series`
    数据集，并在时间上叠加 `Temperature` 和 `Pressure`：
- en: '[PRE24]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The output of this code can be seen in *Figure 4.21*:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码的输出可以在 *图 4.21* 中看到：
- en: '![Figure 4.21 – A time-series plot showing the temperature and pressure of
    a failed LCMS run ](img/B17761_04_021.png.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.21 – 显示失败 LCMS 运行的温度和压力的时间序列图](img/B17761_04_021.png.jpg)'
- en: Figure 4.21 – A time-series plot showing the temperature and pressure of a failed
    LCMS run
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.21 – 显示失败 LCMS 运行的温度和压力的时间序列图
- en: We notice that within the first 5 minutes of this graph, the temperature and
    pressure parameters are increasing quite quickly. A dip of some sort occurs within
    the 6.5-minute range, and the system keeps increasing for a moment, then both
    parameters begin to plummet downward and level out at their respective ranges.
    This is an example of an instrument failure, and it is a situation that a finely
    tuned machine learning model would be able to detect relative to its successful
    counterpart. We will explore the development of this anomaly detection model in
    greater detail in [*Chapter 7*](B17761_07_Final_JM_ePub.xhtml#_idTextAnchor101),
    *Supervised Machine Learning*.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注意到，在这张图的最初 5 分钟内，温度和压力参数增加得相当快。在 6.5 分钟范围内出现某种下降，系统保持了一段时间的增加，然后两个参数开始急剧下降并稳定在其各自的范围内。这是一个仪器故障的例子，而且这是一个一个精细调校的机器学习模型能够相对于其成功的对应物检测到的情形。我们将在[*第
    7 章*](B17761_07_Final_JM_ePub.xhtml#_idTextAnchor101) *监督机器学习*中更详细地探讨这个异常检测模型的发展。
- en: Emphasizing flows with Sankey diagrams
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用桑基图强调流程
- en: 'A popular form of visualization in data science is the **Sankey diagram** –
    made famous by Minard''s classic depiction of Napoleon''s army during the invasion
    of Russia. The main purpose of a Sankey diagram is to visualize a magnitude in
    terms of its proportional width on a flow diagram:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 数据科学中的一种流行可视化形式是 **桑基图** – 由米纳德对拿破仑入侵俄罗斯的军队的经典描绘而闻名。桑基图的主要目的是在流程图上以比例宽度来可视化一个量的大小：
- en: '![Figure 4.22 – A Sankey diagram by Charles Joseph Minard depicting Napoleon''s
    march to Russia ](img/B17761_04_022.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.22 – 查尔斯·约瑟夫·米纳德绘制的桑基图，描绘了拿破仑的俄国远征](img/B17761_04_022.jpg)'
- en: Figure 4.22 – A Sankey diagram by Charles Joseph Minard depicting Napoleon's
    march to Russia
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.22 – 查尔斯·约瑟夫·米纳德绘制的桑基图，描绘了拿破仑的俄国远征
- en: 'Sankey diagrams are often used to depict many applications across various sectors.
    Biotechnology and health sector applications of Sankey diagrams include the following:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 桑基图常用于描绘各个领域的许多应用。桑基图在生物技术和健康领域的应用包括以下内容：
- en: Depictions of drug candidates during clinical trials
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 临床试验期间的药物候选描述
- en: Process flow diagrams for synthetic molecules
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 合成分子的工艺流程图
- en: Process flow diagrams for microbial fermentation
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微生物发酵的工艺流程图
- en: Project flow diagrams and success rates
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目流程图和成功率
- en: Financial diagrams depicting costs within an organization
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述组织内部成本的财务图
- en: 'Let''s visualize a simple example of a company''s drug candidate pipeline.
    We''ll take the total number of candidates, their classification by phase, and
    finally, their designation by modality as small or large molecules. We can take
    advantage of the `Plotly` library to assist us with this:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们可视化一个公司药物候选管道的简单示例。我们将考虑候选人的总数，按阶段进行分类，最后按小分子或大分子进行指定。我们可以利用 `Plotly` 库来帮助我们完成这项工作：
- en: '[PRE25]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This segment of code is quite long and complex – let''s try to break this down.
    The `figure` object consists of several arguments we need to take into account.
    The first is `pad`, which describes the spacing between the *nodes* of the visualization.
    The second describes the `thickness` value of the node''s bars. The third sets
    the `color` and `width` values of the lines. The fourth contains the `label` names
    of the nodes. And finally, we arrive at the data, which has been structured in
    a slightly different way to how we are accustomed. In this case, the dataset is
    divided into a `source` array (or origin), the `target` array, and the `value`
    array associated with it. Starting on the left-hand side, we see that the first
    value of `source` is node `0`, which goes to the `target` of node `1`, with a
    `value` of `15`. Reading the process in this fashion makes the flow of the data
    a little clearer to the user or developer. Finally, we can go ahead and plot the
    image using `show()`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码相当长且复杂，让我们尝试将其分解。`figure`对象包含我们需要考虑的几个参数。第一个是`pad`，它描述了可视化中`*节点*`之间的间距。第二个描述了节点的`thickness`值。第三个设置了线的`color`和`width`值。第四个包含节点的`label`名称。最后，我们到达了数据，其结构与我们习惯的方式略有不同。在这种情况下，数据集被分为一个`source`数组（或起源），一个`target`数组，以及与之相关的`value`数组。从左侧开始，我们看到`source`的第一个值是节点`0`，它流向节点`1`的`target`，`value`为`15`。以这种方式阅读过程使数据流对用户或开发者更清晰。最后，我们可以使用`show()`继续绘制图像：
- en: '[PRE26]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The following diagram displays the output of the preceding code:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了前面代码的输出：
- en: '![Figure 4.23 – A Sankey diagram representing a company''s pipeline ](img/B17761_04_023.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![图4.23 – 表示公司流程的桑基图](img/B17761_04_023.jpg)'
- en: Figure 4.23 – A Sankey diagram representing a company's pipeline
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.23 – 表示公司流程的桑基图
- en: Sankey diagrams are a great way to show the flow or transfer of information
    over time or by category. In the preceding example, we looked at its application
    in terms of small and large molecules within a pipeline. Let's now take a look
    at how we can visualize these molecules.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 桑基图是展示随时间或按类别信息流动或转移的绝佳方式。在上一个例子中，我们探讨了其在管道中小分子和大分子中的应用。现在让我们看看我们如何可视化这些分子。
- en: Visualizing small molecules
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可视化小分子
- en: 'When it comes to small molecules, there are a number of ways we can visualize
    them using various software platforms and online services. Luckily, there exists
    an excellent library commonly utilized for `rdkit` library can be installed using
    `pip`:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到小分子时，我们可以使用各种软件平台和在线服务以多种方式可视化它们。幸运的是，存在一个优秀的库，通常用于`rdkit`库，可以使用`pip`安装：
- en: '[PRE27]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We can parse the DataFrame we imported earlier in this tutorial and extract
    a sample `smiles` string via indexing. We can then create a molecule object using
    the `MolFromSmiles()` function within the `Chem` class of `rdkit` using the `smiles`
    string as the single argument:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以解析在本教程中较早导入的DataFrame，并通过索引提取一个示例`smiles`字符串。然后，我们可以使用`rdkit`库中的`Chem`类的`MolFromSmiles()`函数，以`smiles`字符串作为单一参数来创建分子对象：
- en: '[PRE28]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The output of this variable can be seen in *Figure 4.24*:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这个变量的输出可以在*图4.24*中看到：
- en: '![Figure 4.24 – A representation of a small molecule ](img/B17761_04_024.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![图4.24 – 小分子的表示](img/B17761_04_024.jpg)'
- en: Figure 4.24 – A representation of a small molecule
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.24 – 小分子的表示
- en: 'We can check the structure of another molecule by looking at a different index
    value:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过查看不同的索引值来检查另一个分子的结构：
- en: '[PRE29]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This time, our output is as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们的输出如下：
- en: '![Figure 4.25 – A representation of a small molecule ](img/B17761_04_025.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![图4.25 – 小分子的表示](img/B17761_04_025.jpg)'
- en: Figure 4.25 – A representation of a small molecule
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.25 – 小分子的表示
- en: 'In addition to rendering print-ready depictions of small molecules, the `rdkit`
    library also supports a wide variety of functions related to the analysis, prediction,
    and calculation of small molecule properties. In addition, the library also supports
    the use of charge calculations, as well as similarity maps:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 除了渲染小分子的打印版描述外，`rdkit`库还支持与小型分子分析、预测和计算相关的广泛功能。此外，该库还支持使用电荷计算以及相似性图：
- en: '[PRE30]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The output of the preceding code can be seen in *Figure 4.26*:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码的输出可以在*图4.26*中看到：
- en: '![Figure 4.26 – A representation of a small molecule''s charge ](img/B17761_04_026.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![图4.26 – 小分子电荷的表示](img/B17761_04_026.jpg)'
- en: Figure 4.26 – A representation of a small molecule's charge
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.26 – 小分子电荷的表示
- en: Now that we have gained an idea of how we can use RDKit to represent small molecules,
    let's look at an application of this for large molecules instead.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Visualizing large molecules
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a number of Python libraries designed for the visualization, simulation,
    and analysis of large molecules for the purposes of research and development.
    Currently, one of the most common libraries is `py3Dmol`. Exclusively used for
    the purposes of 3D visualization within a Jupyter Notebook setting, this library
    allows for the creation of publication-ready visuals of 3D proteins. The library
    can be easily downloaded using the `pip` framework.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: 'At the time of writing, the world is still in the midst of dealing with the
    COVID-19 virus that originated in Wuhan, China and spread throughout the world.
    On July 8, 2020, a 1.7 Å resolution structure of the *SARS-CoV-2 3CL* protease
    was released in the `pdb = 6XMK`. Let''s go ahead and use this protein as an example
    in the following visualizations:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: 'We can begin the development of this visual using the `py3dmol` library and
    querying the protein structure directly within the following function:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'With the library imported, a new variable object called `lm` can be specified
    using the `view` class in `py3Dmol`. This function takes three main arguments.
    The first is the identity of the protein of interest, namely `6xmk`. The second
    and third arguments are the width and height of the display window, respectively.
    For more information about PDB files, visit the `stick` argument:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Upon executing this line of code, we get the following image of the molecule:'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.27 – A representation of a large molecule or protein in ball-stick
    form ](img/B17761_04_027.jpg)'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 4.27 – A representation of a large molecule or protein in ball-stick
    form
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Notice that we added a `stick` argument that displayed the last structure.
    We can change this argument to `cartoon` to see a cartoon representation of this
    protein based on its *secondary structure*:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'When executing this line of code, we get the following image of the molecule:'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.28 – A representation of a large molecule or protein''s secondary
    structure ](img/B17761_04_028.jpg)'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 4.28 – A representation of a large molecule or protein's secondary structure
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'There are a number of other changes and arguments that can be added to custom
    fit this visualization to a user''s particular aims. One of these changes is the
    addition of a **Van der Waals surface**, which allows for the illustration of
    the area through which a molecular interaction might occur. We will add this surface
    to only one of the two chains on this protein:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We can see the output of this code in *Figure 4.29*:'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.29 – A representation of a large molecule or protein''s secondary
    structure with a Van der Waals surface on one of the chains](img/B17761_04_029.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
- en: Figure 4.29 – A representation of a large molecule or protein's secondary structure
    with a Van der Waals surface on one of the chains
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: The study of large molecules, or **biologics**, have shown tremendous growth
    in the biotechnology sector in recent years. Within this chapter, we briefly introduced
    one of the many methods used to visualize these complex molecules – an important
    first step for any bioinformatics project.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，对大分子，或称**生物制品**的研究，在生物技术领域显示出巨大的增长。在本章中，我们简要介绍了用于可视化这些复杂分子的许多方法之一——这是任何生物信息学项目的重要第一步。
- en: Summary
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Visualizations can be useful, powerful, and convincing tools to help illustrate
    points and drive conversations in specific directions. To create a proper visualization,
    there are certain steps and techniques that need to be taken to ensure your diagram
    is correct and effective.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 可视化可以是有用的、强大的、令人信服的工具，有助于说明观点并引导特定方向的对话。为了创建适当的可视化，需要采取某些步骤和技术，以确保您的图表正确且有效。
- en: Within this chapter, we explored the six main steps to follow when creating
    a proper visualization. We also explored many different methods and libraries
    within the scope of Python to help you create and style visuals for your specific
    aims. We explored some of the more basic visuals, such as bar plots, histograms,
    and scatter plots to analyze a few features at a time. We also explored more complex
    visualizations such as pair plots, heat maps, Sankey diagrams, and molecular representations,
    with which we can explore many more features.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了创建适当可视化时需要遵循的六个主要步骤。我们还探讨了在Python范围内许多不同的方法和库，以帮助您为特定的目标创建和设计可视化。我们探讨了某些基本可视化，如条形图、直方图和散点图，以一次分析几个特征。我们还探讨了更复杂可视化，如配对图、热图、桑基图和分子表示，通过这些我们可以探索更多特征。
- en: We also touched on the concept of *correlation* and how certain features can
    have relationships with others – a concept we will cover in greater detail as
    we turn our attention to **machine learning** in the next chapter.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还提到了**相关性**的概念以及某些特征如何与其他特征建立关系——这是一个我们将在下一章关注**机器学习**时更详细探讨的概念。
