["```py\ncmake_minimum_required (VERSION 3.0)\n\nPROJECT(Chapter4_Phototool)\n\nset (CMAKE_CXX_STANDARD 11)\n\n# Requires OpenCV\nFIND_PACKAGE( OpenCV 4.0.0 REQUIRED )\nMESSAGE(\"OpenCV version : ${OpenCV_VERSION}\")\n\ninclude_directories(${OpenCV_INCLUDE_DIRS})\nlink_directories(${OpenCV_LIB_DIR})\n\nADD_EXECUTABLE(${PROJECT_NAME} main.cpp)\nTARGET_LINK_LIBRARIES(${PROJECT_NAME} ${OpenCV_LIBS})\n```", "```py\ncmake_minimum_required (VERSION 3.0)\n\nPROJECT(Chapter4_Phototool)\n\nset (CMAKE_CXX_STANDARD 11)\n```", "```py\n# Requires OpenCV \nFIND_PACKAGE( OpenCV 4.0.0 REQUIRED ) \nMESSAGE(\"OpenCV version : ${OpenCV_VERSION}\") \n```", "```py\ninclude_directories(${OpenCV_INCLUDE_DIRS}) \nlink_directories(${OpenCV_LIB_DIR})\n```", "```py\nADD_EXECUTABLE(${PROJECT_NAME} main.cpp) \nTARGET_LINK_LIBRARIES(${PROJECT_NAME} ${OpenCV_LIBS})\n```", "```py\n// OpenCV includes \n#include \"opencv2/core/utility.hpp\" \n#include \"opencv2/imgproc.hpp\" \n#include \"opencv2/highgui.hpp\" \nusing namespace cv; \n// OpenCV command line parser functions \n// Keys accepted by command line parser \nconst char* keys = \n{ \n   \"{help h usage ? | | print this message}\" \n    \"{@image | | Image to process}\" \n}; \n```", "```py\nint main(int argc, const char** argv) \n{ \n   CommandLineParser parser(argc, argv, keys); \n    parser.about(\"Chapter 4\\. PhotoTool v1.0.0\"); \n    //If requires help show \n    if (parser.has(\"help\")) \n   { \n       parser.printMessage(); \n       return 0; \n   } \n```", "```py\nString imgFile= parser.get<String>(0); \n\n// Check if params are correctly parsed in his variables \nif (!parser.check()) \n{ \n    parser.printErrors(); \n    return 0; \n}\n```", "```py\n// Load image to process \nMat img= imread(imgFile); \n\n// Create window \nnamedWindow(\"Input\"); \n```", "```py\n// Create UI buttons \ncreateButton(\"Show histogram\", showHistoCallback, NULL, QT_PUSH_BUTTON, 0); \ncreateButton(\"Equalize histogram\", equalizeCallback, NULL, QT_PUSH_BUTTON, 0); \ncreateButton(\"Lomography effect\", lomoCallback, NULL, QT_PUSH_BUTTON, 0); \ncreateButton(\"Cartoonize effect\", cartoonCallback, NULL, QT_PUSH_BUTTON, 0); \n```", "```py\n// Show image \nimshow(\"Input\", img); \n\nwaitKey(0); \nreturn 0; \n```", "```py\nvoid showHistoCallback(int state, void* userData) \n{ \n    // Separate image in BRG \n    vector<Mat> bgr; \n    split(img, bgr); \n\n    // Create the histogram for 256 bins \n    // The number of possibles values [0..255] \n    int numbins= 256; \n\n    /// Set the ranges for B,G,R last is not included \n    float range[] = { 0, 256 } ; \n    const float* histRange = { range }; \n\n    Mat b_hist, g_hist, r_hist; \n\n    calcHist(&bgr[0], 1, 0, Mat(), b_hist, 1, &numbins, &histRange); \n    calcHist(&bgr[1], 1, 0, Mat(), g_hist, 1, &numbins, &histRange); \n    calcHist(&bgr[2], 1, 0, Mat(), r_hist, 1, &numbins, &histRange); \n\n    // Draw the histogram \n    // We go to draw lines for each channel \n    int width= 512; \n    int height= 300; \n    // Create image with gray base \n    Mat histImage(height, width, CV_8UC3, Scalar(20,20,20)); \n\n    // Normalize the histograms to height of image \n    normalize(b_hist, b_hist, 0, height, NORM_MINMAX); \n    normalize(g_hist, g_hist, 0, height, NORM_MINMAX); \n    normalize(r_hist, r_hist, 0, height, NORM_MINMAX); \n\n    int binStep= cvRound((float)width/(float)numbins); \n    for(int i=1; i< numbins; i++) \n    { \n        line(histImage,  \n                Point( binStep*(i-1), height-cvRound(b_hist.at<float>(i-1) )), \n                Point( binStep*(i), height-cvRound(b_hist.at<float>(i) )), \n                Scalar(255,0,0) \n            ); \n        line(histImage,  \n                Point(binStep*(i-1), height-cvRound(g_hist.at<float>(i-1))), \n                Point(binStep*(i), height-cvRound(g_hist.at<float>(i))), \n                Scalar(0,255,0) \n            ); \n        line(histImage,  \n                Point(binStep*(i-1), height-cvRound(r_hist.at<float>(i-1))), \n                Point(binStep*(i), height-cvRound(r_hist.at<float>(i))), \n                Scalar(0,0,255) \n            ); \n    } \n\n    imshow(\"Histogram\", histImage); \n\n} \n```", "```py\n// Separate image in BRG \n    vector<Mat> bgr; \n    split(img, bgr); \n```", "```py\nint numbins= 256; \n```", "```py\n/// Set the ranges for B,G,R \nfloat range[] = {0, 256} ; \nconst float* histRange = {range}; \n\nMat b_hist, g_hist, r_hist;\n```", "```py\ncalcHist(&bgr[0], 1, 0, Mat(), b_hist, 1, &numbins, &histRange ); \ncalcHist(&bgr[1], 1, 0, Mat(), g_hist, 1, &numbins, &histRange ); \ncalcHist(&bgr[2], 1, 0, Mat(), r_hist, 1, &numbins, &histRange ); \n```", "```py\n// Draw the histogram \n// We go to draw lines for each channel \nint width= 512; \nint height= 300; \n// Create image with gray base \nMat histImage(height, width, CV_8UC3, Scalar(20,20,20)); \n```", "```py\n// Normalize the histograms to height of image \nnormalize(b_hist, b_hist, 0, height, NORM_MINMAX); \nnormalize(g_hist, g_hist, 0, height, NORM_MINMAX); \nnormalize(r_hist, r_hist, 0, height, NORM_MINMAX);\n```", "```py\nint binStep= cvRound((float)width/(float)numbins); \n    for(int i=1; i< numbins; i++) \n    { \n        line(histImage,  \n                Point(binStep*(i-1), height-cvRound(b_hist.at<float>(i-1))), \n                Point(binStep*(i), height-cvRound(b_hist.at<float>(i))), \n                Scalar(255,0,0) \n            ); \n        line(histImage,  \n                Point(binStep*(i-1), height-cvRound(g_hist.at<float>(i-1))), \n                Point( binStep*(i), height-cvRound(g_hist.at<float>(i))), \n                Scalar(0,255,0) \n            ); \n        line(histImage,  \n                Point(binStep*(i-1), height-cvRound(r_hist.at<float>(i-1))), \n                Point( binStep*(i), height-cvRound(r_hist.at<float>(i))), \n                Scalar(0,0,255) \n            ); \n    } \n```", "```py\n    imshow(\"Histogram\", histImage); \n```", "```py\nvoid equalizeCallback(int state, void* userData)\n{ \n    Mat result; \n    // Convert BGR image to YCbCr \n    Mat ycrcb; \n    cvtColor(img, ycrcb, COLOR_BGR2YCrCb); \n\n    // Split image into channels \n    vector<Mat> channels; \n    split(ycrcb, channels); \n\n    // Equalize the Y channel only \n    equalizeHist(channels[0], channels[0]); \n\n    // Merge the result channels \n    merge(channels, ycrcb); \n\n    // Convert color ycrcb to BGR \n    cvtColor(ycrcb, result, COLOR_YCrCb2BGR); \n\n    // Show image \n    imshow(\"Equalized\", result); \n} \n```", "```py\nMat result; \n// Convert BGR image to YCbCr \nMat ycrcb; \ncvtColor(img, ycrcb, COLOR_BGR2YCrCb); \n```", "```py\n// Split image into channels \nvector<Mat> channels; \nsplit(ycrcb, channels); \n```", "```py\n// Equalize the Y channel only \nequalizeHist(channels[0], channels[0]); \n```", "```py\n// Merge the result channels \nmerge(channels, ycrcb); \n\n// Convert color ycrcb to BGR \ncvtColor(ycrcb, result, COLOR_YCrCb2BGR); \n\n// Show image \nimshow(\"Equalized\", result);\n```", "```py\nvoid lomoCallback(int state, void* userData) \n{ \n    Mat result; \n\n    const double exponential_e = std::exp(1.0); \n    // Create Look-up table for color curve effect \n    Mat lut(1, 256, CV_8UC1); \n    for (int i=0; i<256; i++) \n    { \n        float x= (float)i/256.0;  \n        lut.at<uchar>(i)= cvRound( 256 * (1/(1 + pow(exponential_e, -((x-0.5)/0.1)) )) ); \n    } \n\n    // Split the image channels and apply curve transform only to red channel \n    vector<Mat> bgr; \n    split(img, bgr); \n    LUT(bgr[2], lut, bgr[2]); \n    // merge result \n    merge(bgr, result); \n\n    // Create image for halo dark \n    Mat halo(img.rows, img.cols, CV_32FC3, Scalar(0.3,0.3,0.3) ); \n    // Create circle  \n    circle(halo, Point(img.cols/2, img.rows/2), img.cols/3, Scalar(1,1,1), -1);  \n    blur(halo, halo, Size(img.cols/3, img.cols/3)); \n\n    // Convert the result to float to allow multiply by 1 factor \n    Mat resultf; \n    result.convertTo(resultf, CV_32FC3); \n\n    // Multiply our result with halo \n    multiply(resultf, halo, resultf); \n\n    // convert to 8 bits \n    resultf.convertTo(result, CV_8UC3); \n\n    // show result \n    imshow(\"Lomography\", result); \n} \n```", "```py\nconst double exponential_e = std::exp(1.0); \n// Create look-up table for color curve effect \nMat lut(1, 256, CV_8UC1); \nUchar* plut= lut.data; \nfor (int i=0; i<256; i++) \n{ \n    double x= (double)i/256.0;  \n    plut[i]= cvRound( 256.0 * (1.0/(1.0 + pow(exponential_e, -((x-0.5)/0.1)) )) ); \n} \n```", "```py\n// Split the image channels and apply curve transform only to red channel \nvector<Mat> bgr; \nsplit(img, bgr); \n```", "```py\nLUT(bgr[2], lut, bgr[2]); \n```", "```py\n// merge result \nmerge(bgr, result);\n```", "```py\n // Create image for halo dark \n Mat halo(img.rows, img.cols, CV_32FC3, Scalar(0.3,0.3,0.3)); \n // Create circle  \n circle(halo, Point(img.cols/2, img.rows/2), img.cols/3, Scalar(1,1,1), -1);  \n```", "```py\nblur(halo, halo, Size(img.cols/3, img.cols/3)); \n```", "```py\n// Convert the result to float to allow multiply by 1 factor \nMat resultf; \nresult.convertTo(resultf, CV_32FC3); \n```", "```py\n// Multiply our result with halo \nmultiply(resultf, halo, resultf); \n```", "```py\n// convert to 8 bits \nresultf.convertTo(result, CV_8UC3); \n\n// show result \nimshow(\"Lomograpy\", result); \n```", "```py\nvoid cartoonCallback(int state, void* userData) \n{ \n    /** EDGES **/ \n    // Apply median filter to remove possible noise \n    Mat imgMedian; \n    medianBlur(img, imgMedian, 7); \n\n    // Detect edges with canny \n    Mat imgCanny; \n    Canny(imgMedian, imgCanny, 50, 150); \n\n    // Dilate the edges \n    Mat kernel= getStructuringElement(MORPH_RECT, Size(2,2)); \n    dilate(imgCanny, imgCanny, kernel); \n\n    // Scale edges values to 1 and invert values \n    imgCanny= imgCanny/255; \n    imgCanny= 1-imgCanny; \n\n    // Use float values to allow multiply between 0 and 1 \n    Mat imgCannyf; \n    imgCanny.convertTo(imgCannyf, CV_32FC3); \n\n    // Blur the edgest to do smooth effect \n    blur(imgCannyf, imgCannyf, Size(5,5)); \n\n    /** COLOR **/ \n    // Apply bilateral filter to homogenizes color \n    Mat imgBF; \n    bilateralFilter(img, imgBF, 9, 150.0, 150.0); \n\n    // truncate colors \n    Mat result= imgBF/25; \n    result= result*25; \n\n    /** MERGES COLOR + EDGES **/ \n    // Create a 3 channles for edges \n    Mat imgCanny3c; \n    Mat cannyChannels[]={ imgCannyf, imgCannyf, imgCannyf}; \n    merge(cannyChannels, 3, imgCanny3c); \n\n    // Convert color result to float  \n    Mat resultf; \n    result.convertTo(resultf, CV_32FC3); \n\n    // Multiply color and edges matrices \n    multiply(resultf, imgCanny3c, resultf); \n\n    // convert to 8 bits color \n    resultf.convertTo(result, CV_8UC3); \n\n    // Show image \n    imshow(\"Result\", result); \n\n} \n```", "```py\nMat imgMedian; \nmedianBlur(img, imgMedian, 7); \n```", "```py\n// Detect edges with canny \nMat imgCanny; \nCanny(imgMedian, imgCanny, 50, 150); \n```", "```py\n// Dilate the edges \nMat kernel= getStructuringElement(MORPH_RECT, Size(2,2)); \ndilate(imgCanny, imgCanny, kernel); \n```", "```py\n// Scale edges values to 1 and invert values \nimgCanny= imgCanny/255; \nimgCanny= 1-imgCanny; \n```", "```py\n// Use float values to allow multiply between 0 and 1 \nMat imgCannyf; \nimgCanny.convertTo(imgCannyf, CV_32FC3); \n```", "```py\n// Blur the edgest to do smooth effect \nblur(imgCannyf, imgCannyf, Size(5,5)); \n```", "```py\n// Apply bilateral filter to homogenizes color \nMat imgBF; \nbilateralFilter(img, imgBF, 9, 150.0, 150.0); \n```", "```py\n// truncate colors \nMat result= imgBF/25; \nresult= result*25; \n```", "```py\n// Create a 3 channles for edges \nMat imgCanny3c; \nMat cannyChannels[]={ imgCannyf, imgCannyf, imgCannyf}; \nmerge(cannyChannels, 3, imgCanny3c); \n```", "```py\n// Convert color result to float  \nMat resultf; \nresult.convertTo(resultf, CV_32FC3); \n\n// Multiply color and edges matrices \nmultiply(resultf, imgCanny3c, resultf); \n```", "```py\n// convert to 8 bits color \nresultf.convertTo(result, CV_8UC3); \n\n// Show image \nimshow(\"Result\", result); \n```"]