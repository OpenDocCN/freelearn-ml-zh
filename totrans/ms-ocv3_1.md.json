["```py\n    int cameraNumber = 0; \n    if (argc> 1) \n    cameraNumber = atoi(argv[1]); \n\n    // Get access to the camera. \n    cv::VideoCapture camera; \n    camera.open(cameraNumber); \n    if (!camera.isOpened()) { \n      std::cerr<<\"ERROR: Could not access the camera or video!\"<< \n      std::endl; \n      exit(1); \n    } \n\n    // Try to set the camera resolution. \n    camera.set(cv::CV_CAP_PROP_FRAME_WIDTH, 640); \n    camera.set(cv::CV_CAP_PROP_FRAME_HEIGHT, 480);\n\n```", "```py\n     while (true) { \n      // Grab the next camera frame. \n      cv::Mat cameraFrame; \n      camera>>cameraFrame; \n      if (cameraFrame.empty()) { \n        std::cerr<<\"ERROR: Couldn't grab a camera frame.\"<< \n        std::endl; \n        exit(1); \n      } \n      // Create a blank output image, that we will draw onto. \n      cv::Mat displayedFrame(cameraFrame.size(), cv::CV_8UC3); \n\n      // Run the cartoonifier filter on the camera frame. \n      cartoonifyImage(cameraFrame, displayedFrame); \n\n      // Display the processed image onto the screen. \n      imshow(\"Cartoonifier\", displayedFrame); \n\n      // IMPORTANT: Wait for atleast 20 milliseconds, \n      // so that the image can be displayed on the screen! \n      // Also checks if a key was pressed in the GUI window. \n      // Note that it should be a \"char\" to support Linux. \n      char keypress = cv::waitKey(20);  // Needed to see anything! \n      if (keypress == 27) {   // Escape Key \n        // Quit the program! \n        break; \n      } \n    }//end while\n\n```", "```py\n    // Include OpenCV's C++ Interface \n    #include \"opencv2/opencv.hpp\" \n\n    using namespace cv; \n    using namespace std;\n\n```", "```py\n    Mat gray; \n    cvtColor(srcColor, gray, CV_BGR2GRAY); \n    const int MEDIAN_BLUR_FILTER_SIZE = 7; \n    medianBlur(gray, gray, MEDIAN_BLUR_FILTER_SIZE); \n    Mat edges; \n    const int LAPLACIAN_FILTER_SIZE = 5; \n Laplacian(gray, edges, CV_8U, LAPLACIAN_FILTER_SIZE);\n\n```", "```py\n    Mat mask; \n    const int EDGES_THRESHOLD = 80; \n threshold(edges, mask, EDGES_THRESHOLD, 255, THRESH_BINARY_INV);\n\n```", "```py\n    Size size = srcColor.size(); \n    Size smallSize; \n    smallSize.width = size.width/2; \n    smallSize.height = size.height/2; \n    Mat smallImg = Mat(smallSize, CV_8UC3); \n resize(srcColor, smallImg, smallSize, 0,0, INTER_LINEAR);\n\n```", "```py\n    Mat tmp = Mat(smallSize, CV_8UC3); \n    int repetitions = 7;  // Repetitions for strong cartoon effect. \n    for (int i=0; i<repetitions; i++) { \n      int ksize = 9;     // Filter size. Has large effect on speed.  \n      double sigmaColor = 9;    // Filter color strength. \n      double sigmaSpace = 7;    // Spatial strength. Affects speed. \n bilateralFilter(smallImg, tmp, ksize, sigmaColor, sigmaSpace); bilateralFilter(tmp, smallImg, ksize, sigmaColor, sigmaSpace); \n    }\n\n```", "```py\n    Mat bigImg; \n    resize(smallImg, bigImg, size, 0,0, INTER_LINEAR); \n    dst.setTo(0); \n bigImg.copyTo(dst, mask);\n\n```", "```py\n    Mat gray;\n    cvtColor(srcColor, gray, CV_BGR2GRAY);\n    const int MEDIAN_BLUR_FILTER_SIZE = 7;\n    medianBlur(gray, gray, MEDIAN_BLUR_FILTER_SIZE);\n    Mat edges, edges2;\n    Scharr(srcGray, edges, CV_8U, 1, 0);\n    Scharr(srcGray, edges2, CV_8U, 1, 0, -1);\n    edges += edges2;\n    // Combine the x & y edges together.\n    const int EVIL_EDGE_THRESHOLD = 12\n    threshold(edges, mask, EVIL_EDGE_THRESHOLD, 255,\n    THRESH_BINARY_INV);\n    medianBlur(mask, mask, 3)\n\n```", "```py\n    // Draw the color face onto a black background. \n    Mat faceOutline = Mat::zeros(size, CV_8UC3); \n    Scalar color = CV_RGB(255,255,0);    // Yellow. \n    int thickness = 4; \n\n    // Use 70% of the screen height as the face height. \n    int sw = size.width; \n    int sh = size.height; \n    int faceH = sh/2 * 70/100;  // \"faceH\" is radius of the ellipse. \n\n    // Scale the width to be the same nice shape for any screen width.   \n    int faceW = faceH * 72/100; \n    // Draw the face outline. \n    ellipse(faceOutline, Point(sw/2, sh/2), Size(faceW, faceH), \n 0, 0, 360, color, thickness, CV_AA);\n\n```", "```py\n    // Draw the eye outlines, as 2 arcs per eye. \n    int eyeW = faceW * 23/100; \n    int eyeH = faceH * 11/100; \n    int eyeX = faceW * 48/100; \n    int eyeY = faceH * 13/100; \n    Size eyeSize = Size(eyeW, eyeH); \n\n    // Set the angle and shift for the eye half ellipses. \n    int eyeA = 15; // angle in degrees. \n    int eyeYshift = 11; \n\n    // Draw the top of the right eye. \n    ellipse(faceOutline, Point(sw/2 - eyeX, sh/2 -eyeY), \n    eyeSize, 0, 180+eyeA, 360-eyeA, color, thickness, CV_AA); \n\n    // Draw the bottom of the right eye. \n    ellipse(faceOutline, Point(sw/2 - eyeX, sh/2 - eyeY-eyeYshift), \n    eyeSize, 0, 0+eyeA, 180-eyeA, color, thickness, CV_AA); \n\n    // Draw the top of the left eye. \n    ellipse(faceOutline, Point(sw/2 + eyeX, sh/2 - eyeY), \n    eyeSize, 0, 180+eyeA, 360-eyeA, color, thickness, CV_AA); \n\n    // Draw the bottom of the left eye. \n    ellipse(faceOutline, Point(sw/2 + eyeX, sh/2 - eyeY-eyeYshift), \n eyeSize, 0, 0+eyeA, 180-eyeA, color, thickness, CV_AA);\n\n```", "```py\n    // Draw the bottom lip of the mouth. \n    int mouthY = faceH * 48/100; \n    int mouthW = faceW * 45/100; \n    int mouthH = faceH * 6/100; \n    ellipse(faceOutline, Point(sw/2, sh/2 + mouthY), Size(mouthW, \n mouthH), 0, 0, 180, color, thickness, CV_AA);\n\n```", "```py\n    // Draw anti-aliased text. \n    int fontFace = FONT_HERSHEY_COMPLEX; \n    float fontScale = 1.0f; \n    int fontThickness = 2; \n    char *szMsg = \"Put your face here\"; \n    putText(faceOutline, szMsg, Point(sw * 23/100, sh * 10/100), \n fontFace, fontScale, color, fontThickness, CV_AA);\n\n```", "```py\n    addWeighted(dst, 1.0, faceOutline, 0.7, 0, dst, CV_8UC3);\n\n```", "```py\n    Mat yuv = Mat(smallSize, CV_8UC3); \n cvtColor(smallImg, yuv, CV_BGR2YCrCb);\n\n```", "```py\n    int sw = smallSize.width; \n    int sh = smallSize.height; \n    Mat mask, maskPlusBorder; \n maskPlusBorder = Mat::zeros(sh+2, sw+2, CV_8UC1);\n mask = maskPlusBorder(Rect(1,1,sw,sh));\n // mask is now in maskPlusBorder.\n    resize(edges, mask, smallSize);     // Put edges in both of them.\n\n```", "```py\n    const int EDGES_THRESHOLD = 80; \n    threshold(mask, mask, EDGES_THRESHOLD, 255, THRESH_BINARY); \n    dilate(mask, mask, Mat()); \n    erode(mask, mask, Mat());\n\n```", "```py\n    int const NUM_SKIN_POINTS = 6; \n    Point skinPts[NUM_SKIN_POINTS]; \n    skinPts[0] = Point(sw/2,          sh/2 - sh/6); \n    skinPts[1] = Point(sw/2 - sw/11,  sh/2 - sh/6); \n    skinPts[2] = Point(sw/2 + sw/11,  sh/2 - sh/6); \n    skinPts[3] = Point(sw/2,          sh/2 + sh/16); \n    skinPts[4] = Point(sw/2 - sw/9,   sh/2 + sh/16); \n    skinPts[5] = Point(sw/2 + sw/9,   sh/2 + sh/16);\n\n```", "```py\n    const int LOWER_Y = 60; \n    const int UPPER_Y = 80; \n    const int LOWER_Cr = 25; \n    const int UPPER_Cr = 15; \n    const int LOWER_Cb = 20; \n    const int UPPER_Cb = 15; \n    Scalar lowerDiff = Scalar(LOWER_Y, LOWER_Cr, LOWER_Cb); \n    Scalar upperDiff = Scalar(UPPER_Y, UPPER_Cr, UPPER_Cb);\n\n```", "```py\n    const int CONNECTED_COMPONENTS = 4;  // To fill diagonally, use 8\\.       \n    const int flags = CONNECTED_COMPONENTS | FLOODFILL_FIXED_RANGE  \n      | FLOODFILL_MASK_ONLY; \n    Mat edgeMask = mask.clone();    // Keep a copy of the edge mask. \n    // \"maskPlusBorder\" is initialized with edges to block floodFill(). \n    for (int i = 0; i < NUM_SKIN_POINTS; i++) { \n      floodFill(yuv, maskPlusBorder, skinPts[i], Scalar(), NULL, \n        lowerDiff, upperDiff, flags); \n    }\n\n```", "```py\n    mask -= edgeMask;\n\n```", "```py\n    int Red = 0; \n    int Green = 70; \n    int Blue = 0; \n add(smallImgBGR, CV_RGB(Red, Green, Blue), smallImgBGR, mask);\n\n```", "```py\n    void removePepperNoise(Mat &mask) \n    { \n      for (int y=2; y<mask.rows-2; y++) { \n        // Get access to each of the 5 rows near this pixel. \n        uchar *pUp2 = mask.ptr(y-2); \n        uchar *pUp1 = mask.ptr(y-1); \n        uchar *pThis = mask.ptr(y); \n        uchar *pDown1 = mask.ptr(y+1); \n        uchar *pDown2 = mask.ptr(y+2); \n\n        // Skip the first (and last) 2 pixels on each row. \n        pThis += 2; \n        pUp1 += 2; \n        pUp2 += 2; \n        pDown1 += 2; \n        pDown2 += 2; \n        for (int x=2; x<mask.cols-2; x++) { \n          uchar value = *pThis;  // Get pixel value (0 or 255). \n          // Check if it's a black pixel surrounded bywhite \n          // pixels (ie: whether it is an \"island\" of black). \n          if (value == 0) { \n            bool above, left, below, right, surroundings; \n            above = *(pUp2 - 2) && *(pUp2 - 1) && *(pUp2) && \n            *(pUp2 + 1) && *(pUp2 + 2); \n            left = *(pUp1 - 2) && *(pThis - 2) && *(pDown1 - 2); \n            below = *(pDown2 - 2) && *(pDown2 - 1) && *(pDown2) \n              &&*(pDown2 + 1) && *(pDown2 + 2); \n            right = *(pUp1 + 2) && *(pThis + 2) && *(pDown1 + 2); \n            surroundings = above && left && below && right; \n            if (surroundings == true) { \n              // Fill the whole 5x5 block as white. Since we  \n              // knowthe 5x5 borders are already white, we just \n              // need tofill the 3x3 inner region. \n              *(pUp1 - 1) = 255; \n              *(pUp1 + 0) = 255; \n              *(pUp1 + 1) = 255; \n              *(pThis - 1) = 255; \n              *(pThis + 0) = 255; \n              *(pThis + 1) = 255; \n              *(pDown1 - 1) = 255; \n              *(pDown1 + 0) = 255; \n              *(pDown1 + 1) = 255; \n              // Since we just covered the whole 5x5 block with \n              // white, we know the next 2 pixels won't be \n              // black,so skip the next 2 pixels on the right. \n              pThis += 2; \n              pUp1 += 2; \n              pUp2 += 2; \n              pDown1 += 2; \n              pDown2 += 2; \n            } \n          } \n          // Move to the next pixel on the right. \n          pThis++; \n          pUp1++; \n          pUp2++; \n          pDown1++; \n          pDown2++; \n        } \n      } \n    }\n\n```", "```py\n sudo apt-get purge -y wolfram-engine\n\n```", "```py\n      sudo apt-get -y update\n sudo apt-get -y upgrade\n sudo apt-get -y dist-upgrade\n sudo reboot\n\n```", "```py\n      hostname -I\n\n```", "```py\n      ssh-X pi@192.168.2.101\n\n```", "```py\n      nano ~/.bashrc\n\n```", "```py\n PS1=\"[e[0;44m]u@h: w ($?) $[e[0m] \"\n\n```", "```py\n      source ~/.bashrc\n\n```", "```py\n      sudo nano /etc/lightdm/lightdm.conf\n\n```", "```py\n    sudo reboot\n\n```", "```py\n    sudo apt-get install libopencv-dev\n\n```", "```py\n    chmod +x install_opencv_from_source.sh\n./install_opencv_from_source.sh\n\n```", "```py\ncd ~/opencv-3.*/samples/cpp\ng++ edge.cpp -lopencv_core -lopencv_imgproc -lopencv_highgui \n-o edge\n/usr/bin/ld: /tmp/ccDqLWSz.o: undefined reference to symbol '_ZN2cv6imreadERKNS_6StringEi'\n/usr/local/lib/libopencv_imgcodecs.so.3.1: error adding symbols: DSO missing from command line\ncollect2: error: ld returned 1 exit status\n\n```", "```py\ncd ~/opencv-3.*/samples/cpp\ng++ edge.cpp -lopencv_core -lopencv_imgproc -lopencv_highgui \n-lopencv_imgcodecs -o edge\n\n```", "```py\n    ./edge\n\n```", "```py\n    DISPLAY=:0 ./edge\n\n```", "```py\ng++ starter_video.cpp -lopencv_core -lopencv_imgproc\n-lopencv_highgui -lopencv_imgcodecs -lopencv_videoio \\\n-o starter_video\nDISPLAY=:0 ./starter_video 0\n\n```", "```py\n    DISPLAY=:0 ./starter_video ../data/768x576.avi\n\n```", "```py\ncd ~/Cartoonifier\nexport OpenCV_DIR=\"~/opencv-3.1.0/build\"\nmkdir build\ncd build\ncmake -D OpenCV_DIR=$OpenCV_DIR ..\nmake\n\n```", "```py\nDISPLAY=:0 ./Cartoonifier\n\n```", "```py\n    sudo modprobe bcm2835-v4l2\n\n```", "```py\nsudo nano /etc/modules\n# Load the Raspberry Pi Camera Module v4l2 driver on bootup:\nbcm2835-v4l2\n\n```", "```py\n    cd ~/opencv-3.*/samples/cpp\nDISPLAY=:0 ./starter_video 0\n\n```", "```py\n    cd ~/Cartoonifier\nDISPLAY=:0 ./Cartoonifier 0\n\n```", "```py\n// Create a fullscreen GUI window for display on the screen.\nnamedWindow(windowName, WINDOW_NORMAL);\nsetWindowProperty(windowName, WND_PROP_FULLSCREEN,\nCV_WINDOW_FULLSCREEN);\n\n```", "```py\nsudo apt-get install -y xdotool\ncd ~/Cartoonifier/build\nnano runCartoonifier.sh\n#!/bin/sh\n# Move the mouse cursor to the screen's bottom-right pixel.\nxdotoolmousemove 3000 3000\n# Run Cartoonifier with any arguments given.\n/home/pi/Cartoonifier/build/Cartoonifier \"$@\"\n\n```", "```py\nchmod +x runCartoonifier.sh\n\n```", "```py\nDISPLAY=:0 ./runCartoonifier.sh\n\n```", "```py\n    mkdir ~/.config/autostart\nnano ~/.config/autostart/Cartoonifier.desktop\n [Desktop Entry]\n Type=Application\n Exec=/home/pi/Cartoonifier/build/runCartoonifier.sh\n X-GNOME-Autostart-enabled=true\n\n```", "```py\n curl http://www.linux-projects.org/listing/uv4l_repo/lrkey.asc sudo apt-key add -\n sudo su\n echo \"# UV4L camera streaming repo:\">> /etc/apt/sources.list\n echo \"deb http://www.linux-   \n        projects.org/listing/uv4l_repo/raspbian/jessie main\">> \n        /etc/apt/sources.list\n exit\n sudo apt-get update\n sudo apt-get install uv4l uv4l-raspicam uv4l-server\n\n```", "```py\n      sudo killall uv4l\nsudo LD_PRELOAD=/usr/lib/uv4l/uv4lext/armv6l/libuv4lext.so \nuv4l -v7 -f --sched-rr --mem-lock --auto-video_nr\n--driverraspicam --encoding mjpeg\n--width 640 --height 480 --framerate15\n\n```", "```py\n      sudo apt-get install uv4l-raspicam-extras\n\n```", "```py\n      sudo nano /etc/uv4l/uv4l-raspicam.conf\n drop-bad-frames = yes \n nopreview = yes\n width = 640\n height = 480\n framerate = 24\n sudo reboot\n\n```", "```py\n      ./Cartoonifier http://192.168.2.101:8080/stream/video.mjpeg\n\n```", "```py\n    DECLARE_TIMING(myFilter); \n\n    void myImageFunction(Mat img) { \n      printMatInfo(img, \"input\"); \n\n      START_TIMING(myFilter); \n      bilateralFilter(img, ...); \n      STOP_TIMING(myFilter); \n      SHOW_TIMING(myFilter, \"My Filter\"); \n    }\n\n```", "```py\n    input: 800w600h 3ch 8bpp, range[19,255][17,243][47,251] \n    My Filter: time: 213ms (ave=215ms min=197ms max=312ms, across 57 runs).\n\n```"]