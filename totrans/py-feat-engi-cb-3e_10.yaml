- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Creating Features from a Time Series with tsfresh
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 tsfresh 从时间序列创建特征
- en: Throughout this book, we’ve discussed feature engineering methods and tools
    tailored for tabular and relational datasets. In this chapter, we will shift our
    focus to time-series data. A time series is a sequence of observations taken sequentially
    over time. Examples include energy generation and demand, temperature, air pollutant
    concentration, stock prices, and sales revenue. Each of these examples represents
    a variable and their values change over time.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的整个过程中，我们讨论了针对表格和关系数据集定制的特征工程方法和工具。在本章中，我们将把我们的重点转向时间序列数据。时间序列是在时间上按顺序连续观察到的观察值的序列。例如包括能源生产和需求、温度、空气污染物浓度、股价和销售收入。这些示例中的每一个都代表一个变量，它们的值随时间变化。
- en: The widespread availability of affordable sensors capable of measuring motion,
    movement, humidity, glucose, and other parameters has significantly increased
    the amount of temporally annotated data. These time series can be utilized in
    various classification tasks. For instance, by analyzing the electricity usage
    pattern of a household at a given time interval, we can infer whether a particular
    appliance was being used. Similarly, the signal of an ultrasound sensor can help
    determine the probability of a (gas) pipeline failure, and the characteristics
    of a sound wavelength can help predict whether a listener will like a song. Time-series
    data is also valuable for regression tasks. For example, signals from machinery
    sensors can be used to predict the remaining useful life of the device.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 便宜且能够测量运动、移动、湿度、葡萄糖和其他参数的传感器的广泛应用，显著增加了时间标注数据的数量。这些时间序列可以用于各种分类任务。例如，通过分析在特定时间间隔内家庭的电力使用模式，我们可以推断出是否使用了特定的电器。同样，超声波传感器的信号可以帮助确定（气体）管道故障的概率，而声音波长的特征可以帮助预测听众是否会喜欢一首歌。时间序列数据对于回归任务也很有价值。例如，机械设备传感器的信号可以用来预测设备的剩余使用寿命。
- en: To use time series with traditional supervised machine learning models, such
    as linear and logistic regression, or decision-tree-based algorithms, we need
    to map each time series into a well-defined feature vector that captures its characteristics.
    Time-series patterns, including trends, seasonality, and periodicity, among other
    things, can be captured by a combination of simple and complex mathematical operations.
    Simple calculations include, for instance, taking the mean and the standard deviation
    of the time series. More complex methods include determining correlation or entropy,
    for example. In addition, we can apply non-linear time-series analysis functions
    to decompose the time-series signal, for example, Fourier or wavelet transformations,
    and use the parameters of these functions as features of the supervised models.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用时间序列与传统的监督机器学习模型，如线性回归、逻辑回归或基于决策树的算法，我们需要将每个时间序列映射到一个定义良好的特征向量，以捕捉其特征。时间序列模式，包括趋势、季节性和周期性等，可以通过简单和复杂的数学运算的组合来捕捉。简单的计算包括，例如，计算时间序列的平均值和标准差。更复杂的方法包括确定相关性或熵，例如。此外，我们可以应用非线性时间序列分析函数来分解时间序列信号，例如傅里叶变换或小波变换，并使用这些函数的参数作为监督模型的特征。
- en: Creating features from time series can be very time-consuming; we need to apply
    various signal processing and time-series analysis algorithms to identify and
    extract meaningful features. The `tsfresh` Python package, which stands for `tsfresh`
    includes a feature selection algorithm that identifies the most predictive features
    for a given time series. By automating the application of complex time-series
    methods, `tsfresh` bridges the gap between signal-processing experts and machine
    learning practitioners, making it easier to extract valuable features from time-series
    data.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 从时间序列中创建特征可能非常耗时；我们需要应用各种信号处理和时间序列分析算法来识别和提取有意义的特征。`tsfresh` Python 包，代表 `tsfresh`，包含一个特征选择算法，该算法可以识别给定时间序列的最具预测性的特征。通过自动化复杂时间序列方法的应用，`tsfresh`弥合了信号处理专家和机器学习实践者之间的差距，使得从时间序列数据中提取有价值特征变得更加容易。
- en: In this chapter, we will learn how to automatically create hundreds of features
    from time-series data by utilizing `tsfresh`. Following that, we will discuss
    how to fine-tune this feature creation process by selecting the most relevant
    features, extracting different features from different time series, and integrating
    the feature creation process into a scikit-learn pipeline to classify time-series
    data.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何通过利用 `tsfresh` 自动从时间序列数据中创建数百个特征。随后，我们将讨论如何通过选择最相关的特征、从不同的时间序列中提取不同的特征以及将特征创建过程集成到
    scikit-learn 流程中来对时间序列数据进行分类。
- en: 'In this chapter, we will go through the following recipes:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Extracting hundreds of features automatically from a time series
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从时间序列中自动提取数百个特征
- en: Automatically creating and selecting predictive features from time-series data
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从时间序列数据中自动创建和选择预测特征
- en: Extracting different features from different time series
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从不同的时间序列中提取不同的特征
- en: Creating a subset of features identified through feature selection
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过特征选择创建特征子集
- en: Embedding feature creation into a scikit-learn pipeline
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将特征创建嵌入到 scikit-learn 流程中
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this chapter, we will use the open source `tsfresh` Python library. You can
    install `tsfresh` with `pip` by executing `pip` `install tsfresh`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用开源的 `tsfresh` Python 库。您可以通过执行 `pip install tsfresh` 来使用 `pip` 安装
    `tsfresh`。
- en: Note
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you have an old Microsoft operating system, you may need to update the Microsoft
    C++ build tools to proceed with the `tsfresh` package’s installation. Follow the
    steps in this thread to do so: [https://stackoverflow.com/questions/64261546/how-to-solve-error-microsoft-visual-c-14-0-or-greater-is-required-when-inst](https://stackoverflow.com/questions/64261546/how-to-solve-error-microsoft-visual-c-14-0-or-greater-is-required-when-inst).'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是旧版 Microsoft 操作系统，您可能需要更新 Microsoft C++ 编译工具，以便继续安装 `tsfresh` 包。请按照此线程中的步骤进行操作：[https://stackoverflow.com/questions/64261546/how-to-solve-error-microsoft-visual-c-14-0-or-greater-is-required-when-inst](https://stackoverflow.com/questions/64261546/how-to-solve-error-microsoft-visual-c-14-0-or-greater-is-required-when-inst)。
- en: 'We will work with the **Occupancy Detection** dataset from the UCI Machine
    Learning Repository, available at [http://archive.ics.uci.edu/ml/datasets/Occupancy+Detection](http://archive.ics.uci.edu/ml/datasets/Occupancy+Detection)
    and licensed under a Creative Commons Attribution 4.0 International (CC BY 4.0)
    license: [https://creativecommons.org/licenses/by/4.0/legalcode](https://creativecommons.org/licenses/by/4.0/legalcode).
    The corresponding citation for this data is as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用来自 UCI 机器学习仓库的 **Occupancy Detection** 数据集，该数据集可在 [http://archive.ics.uci.edu/ml/datasets/Occupancy+Detection](http://archive.ics.uci.edu/ml/datasets/Occupancy+Detection)
    找到，并受 Creative Commons Attribution 4.0 国际 (CC BY 4.0) 许可协议的许可：[https://creativecommons.org/licenses/by/4.0/legalcode](https://creativecommons.org/licenses/by/4.0/legalcode)。该数据的相应引用如下：
- en: Candanedo, Luis. (2016). Occupancy Detection. UCI Machine Learning Repository.
    [https://doi.org/10.24432/C5X01N](https://doi.org/10.24432/C5X01N).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Candanedo, Luis. (2016). Occupancy Detection. UCI Machine Learning Repository.
    [https://doi.org/10.24432/C5X01N](https://doi.org/10.24432/C5X01N)。
- en: 'I downloaded and modified the data as shown in this notebook: [https://github.com/PacktPublishing/Python-Feature-engineering-Cookbook-Third-Edition/blob/main/ch10-tsfresh/prepare-occupancy-dataset.ipynb](https://github.com/PacktPublishing/Python-Feature-engineering-Cookbook-Third-Edition/blob/main/ch10-tsfresh/prepare-occupancy-dataset.ipynb)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我已下载并修改了如本笔记本所示的数据：[https://github.com/PacktPublishing/Python-Feature-engineering-Cookbook-Third-Edition/blob/main/ch10-tsfresh/prepare-occupancy-dataset.ipynb](https://github.com/PacktPublishing/Python-Feature-engineering-Cookbook-Third-Edition/blob/main/ch10-tsfresh/prepare-occupancy-dataset.ipynb)
- en: 'For a copy of the modified dataset and a target variable, check out the files
    called `occupancy.csv` and `occupancy_target.csv`, available at the following
    link: [https://github.com/PacktPublishing/Python-Feature-engineering-Cookbook-Third-Edition/blob/main/ch10-tsfresh](https://github.com/PacktPublishing/Python-Feature-engineering-Cookbook-Third-Edition/blob/main/ch10-tsfresh)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取修改后的数据集和目标变量，请查看以下链接中的文件 `occupancy.csv` 和 `occupancy_target.csv`：[https://github.com/PacktPublishing/Python-Feature-engineering-Cookbook-Third-Edition/blob/main/ch10-tsfresh](https://github.com/PacktPublishing/Python-Feature-engineering-Cookbook-Third-Edition/blob/main/ch10-tsfresh)
- en: The Occupancy Detection dataset contains time-series data taken over 135 hours
    at one-minute intervals. The variables measure the temperature, humidity, ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>C</mml:mi><mml:mi>O</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:math>](img/38.png)
    level, and light consumption in an office. Camera footage was used to determine
    whether someone was in the office. The target variable shows whether the office
    was occupied at any one hour. If the target takes the value `1`, it means that
    the office was occupied during that hour; otherwise, it takes the value `0`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 占用检测数据集包含在每分钟间隔内采集了135小时的时间序列数据。变量测量了温度、湿度、![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>C</mml:mi><mml:mi>O</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:math>](img/38.png)
    级别和办公室的能耗。使用摄像头录像来确定是否有人在办公室。目标变量显示办公室在任意一小时是否被占用。如果目标值为 `1`，则表示该小时办公室被占用；否则，值为
    `0`。
- en: The dataset with the time series and that with the target variable have different
    numbers of rows. The time-series dataset contains 135 hours of records at one-minute
    intervals – that is, 8,100 rows. The target has only 135 rows, with a label indicating
    whether the office was occupied at each of the 135 hours.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 时间序列数据集和目标变量数据集的行数不同。时间序列数据集包含每分钟间隔的135小时记录，即8,100行。目标变量只有135行，每个标签指示在135小时中的每个小时办公室是否被占用。
- en: Note
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Check out the notebook in this book’s GitHub repository for plots of the different
    time series to become familiar with the dataset: [https://github.com/PacktPublishing/Python-Feature-Engineering-Cookbook-Third-Edition/blob/main/ch10-tsfresh/prepare-occupancy-dataset.ipynb](https://github.com/PacktPublishing/Python-Feature-Engineering-Cookbook-Third-Edition/blob/main/ch10-tsfresh/prepare-occupancy-dataset.ipynb)'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 查看本书GitHub仓库中的笔记本，以熟悉数据集的不同时间序列的绘图：[https://github.com/PacktPublishing/Python-Feature-Engineering-Cookbook-Third-Edition/blob/main/ch10-tsfresh/prepare-occupancy-dataset.ipynb](https://github.com/PacktPublishing/Python-Feature-Engineering-Cookbook-Third-Edition/blob/main/ch10-tsfresh/prepare-occupancy-dataset.ipynb)
- en: Extracting hundreds of features automatically from a time series
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从时间序列中自动提取数百个特征
- en: Time series are data points indexed in time order. Analyzing time-series sequences
    allows us to make various predictions. For example, sensor data can be used to
    predict pipeline failures, sound data can help identify music genres, health history
    or personal measurements such as glucose levels can indicate whether a person
    is sick, and, as we will show in this recipe, patterns of light usage, humidity,
    and ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>C</mml:mi><mml:mi>O</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:math>](img/39.png)
    levels can determine whether an office is occupied.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 时间序列是按时间顺序索引的数据点。分析时间序列序列使我们能够做出各种预测。例如，传感器数据可以用来预测管道故障，声音数据可以帮助识别音乐类型，健康历史或个人测量，如血糖水平，可以指示一个人是否生病，正如我们将在这个菜谱中展示的，光照使用模式、湿度和![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>C</mml:mi><mml:mi>O</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:math>](img/39.png)
    级别可以确定办公室是否被占用。
- en: 'To train regression and classification models using traditional machine learning
    algorithms, such as linear regression or random forests, we require a dataset
    of size *M x N*, where M is the number of rows and N is the number of features
    or columns. However, with time-series data, what we have is a collection of *M*
    time series, and each time series has multiple rows indexed chronologically. To
    use time series in supervised learning models, each time series needs to be mapped
    into a well-defined feature vector, *N*, as shown in the following diagram:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 使用传统的机器学习算法，如线性回归或随机森林来训练回归和分类模型，我们需要一个大小为 *M x N* 的数据集，其中 M 是行数，N 是特征数或列数。然而，对于时间序列数据，我们拥有的是
    *M* 个时间序列的集合，每个时间序列都有多个按时间顺序索引的行。要在监督学习模型中使用时间序列，每个时间序列都需要映射到一个定义良好的特征向量 *N*，如下面的图所示：
- en: '![Figure 10.1 – Diagram showing the process of feature creation from a time
    series for classification or regression](img/B22396_10_01.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图10.1 – 显示从时间序列创建特征过程以进行分类或回归的图](img/B22396_10_01.jpg)'
- en: Figure 10.1 – Diagram showing the process of feature creation from a time series
    for classification or regression
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1 – 显示从时间序列创建特征以进行分类或回归的过程的图表
- en: These feature vectors, which are represented as ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math>](img/40.png),
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:math>](img/41.png),
    and ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:msub></mml:math>](img/42.png)
    in *Figure 10**.1*, should capture the characteristics of the time series. For
    example, ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math>](img/43.png)could
    be the mean value of the time series and ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:math>](img/44.png)its
    variance. We can create many features to characterize the time series concerning
    the distribution of data points, correlation properties, stationarity, or entropy,
    among others. Therefore, the feature vector, N, can be constructed by applying
    a series of **characterization methods** that take a time series as input and
    return one or more scalars as output. The mean, or the sum, takes the time-series
    sequence as input and returns a single scalar as output, with the mean value of
    the time series or the sum of its values. We can also fit a linear trend to the
    time-series sequence, which will return two scalars – one with the slope and one
    with the intercept.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这些特征向量，如图10.1.1所示，表示为![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math>](img/40.png)，![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:math>](img/41.png)，和![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:msub></mml:math>](img/42.png)，应该捕捉时间序列的特征。例如，![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math>](img/43.png)可能是时间序列的均值，而![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:math>](img/44.png)是其方差。我们可以创建许多特征来描述数据点的分布、相关性、平稳性或熵等时间序列的特性。因此，特征向量N可以通过应用一系列**特征化方法**来构建，这些方法以时间序列作为输入，并返回一个或多个标量作为输出。均值或总和将时间序列序列作为输入，并返回一个标量作为输出，即时间序列的均值或其值的总和。我们还可以将线性趋势拟合到时间序列序列中，这将返回两个标量——一个表示斜率，另一个表示截距。
- en: '`tsfresh` applies 63 characterization methods to a time series, each of which
    returns one or more scalars, therefore resulting in more than 750 features for
    any given time series. In this recipe, we will use `tsfresh` to transform time-series
    data into an M x N feature table, which we will then use to predict office occupancy.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`tsfresh`对时间序列应用63种特征化方法，每种方法返回一个或多个标量，因此对于任何给定的时间序列，都会产生超过750个特征。在本配方中，我们将使用`tsfresh`将时间序列数据转换为M
    x N特征表，然后我们将使用该特征表来预测办公室占用情况。'
- en: Getting ready
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In this recipe, we will use the Occupancy Detection dataset described in the
    *Technical requirements* section. This dataset contains measurements of temperature,
    humidity, ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>C</mml:mi><mml:mi>O</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:math>](img/45.png)
    level, and light consumption in an office taken at one-minute intervals. There
    are 135 hours of measurements, and each hour is flagged with a unique identifier.
    There is also a dataset with a target variable that indicates in which of these
    135 hours the office was occupied. Let’s load the data and make some plots to
    understand its patterns:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将使用*技术要求*部分中描述的**占用检测**数据集。此数据集包含在办公室内每分钟间隔的温度、湿度、![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>C</mml:mi><mml:mi>O</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:math>](img/45.png)水平和照明消耗的测量值。共有135小时的测量数据，每小时都有一个唯一的标识符。还有一个包含目标变量的数据集，该变量指示在135小时中的哪一小时办公室是有人使用的。让我们加载数据并绘制一些图表来了解其模式：
- en: 'Let’s load `pandas` and `matplotlib`:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们加载`pandas`和`matplotlib`：
- en: '[PRE0]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Load the dataset and display the first five rows:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载数据集并显示前五行：
- en: '[PRE1]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the following figure, we can see the dataset containing a unique identifier,
    followed by the date and time of the measurements and values for five time series
    capturing temperature, humidity, lights, and ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>C</mml:mi><mml:mi>O</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:math>](img/39.png)
    levels in the office:'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在以下图中，我们可以看到包含唯一标识符的数据集，随后是测量日期和时间以及五个时间序列的值，这些时间序列捕捉了温度、湿度、灯光和![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>C</mml:mi><mml:mi>O</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:math>](img/39.png)水平：
- en: '![Figure 10.2 – DataFrame with the time-series data](img/B22396_10_02.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图10.2 – 包含时间序列数据的DataFrame](img/B22396_10_02.jpg)'
- en: Figure 10.2 – DataFrame with the time-series data
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2 – 包含时间序列数据的DataFrame
- en: 'Let’s create a function to plot the time series from *step 2* at a given hour
    (the `id` column is a unique identifier for each of the 135 hours of records):'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个函数来绘制给定小时（`id`列是135小时记录中每一小时的唯一标识符）的*步骤2*中的时间序列图：
- en: '[PRE2]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let’s plot the time series corresponding to an hour when the office was not
    occupied:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们绘制一个小时办公室无人使用时的时间序列图：
- en: '[PRE3]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the following figure, we can see the time-series values during the second
    hour of records, when the office was empty:'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在以下图中，我们可以看到记录的第二小时的时间序列值，当时办公室是空的：
- en: "![Figure 10.3 – Time-series values during the second hour of data collection\
    \ when the office was empt\uFEFFy](img/B22396_10_03.jpg)"
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图10.3 – 数据收集第二小时办公室空时的时间序列值](img/B22396_10_03.jpg)'
- en: Figure 10.3 – Time-series values during the second hour of data collection when
    the office was empty
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3 – 数据收集第二小时办公室空时的时间序列值
- en: Note that the lights were off, and that is why we see the flat line at 0 in
    the plot of `light` consumption in the top-right corner.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到灯光是关闭的，这就是为什么我们在右上角`light`消耗的图表中看到一条平坦的直线。
- en: 'Now, let’s plot the time-series data corresponding to an hour when the office
    was occupied:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们绘制一个小时办公室有人使用时的时间序列数据：
- en: '[PRE4]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the following figure, we can see the time-series values during the fifteenth
    hour of records, when the office was occupied:'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在以下图中，我们可以看到记录的第十五小时的时间序列值，当时办公室是有人使用的：
- en: '![Figure 10.4 – Time-series values during the fifteenth hour of data collection,
    when the office was occupied](img/B22396_10_04.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图10.4 – 数据收集第十五小时办公室有人使用时的时间序列值](img/B22396_10_04.jpg)'
- en: Figure 10.4 – Time-series values during the fifteenth hour of data collection,
    when the office was occupied
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4 – 数据收集第十五小时办公室有人使用时的时间序列值
- en: Notice that the lights were on this time (top-right panel).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这次灯光是开着的（右上角面板）。
- en: In this recipe, we will extract features from each of these one-hour windows
    of time-series data, capturing various aspects of their characteristics. From
    each of these 60-minute time-series segments, we will automatically generate more
    than 750 features using `tsfresh`, ensuring a comprehensive representation of
    the data’s properties.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将从这些每个时间序列数据的一小时窗口中提取特征，捕捉它们特性的各个方面。从每个这些60分钟的时间序列段中，我们将使用`tsfresh`自动生成超过750个特征，确保数据的属性得到全面表示。
- en: How to do it...
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'We will begin by automatically creating hundreds of features from one time
    series, `lights`, and then use those features to predict whether the office was
    occupied at any given hour:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先自动从单个时间序列`lights`创建数百个特征，然后使用这些特征来预测办公室在任意给定小时是否被占用：
- en: 'Let’s import the required Python libraries and functions:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们导入所需的Python库和函数：
- en: '[PRE5]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Load the dataset described in the *Technical* *requirements* section:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载*技术要求*部分中描述的数据集：
- en: '[PRE6]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Load the target variable into a `pandas` Series:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将目标变量加载到`pandas` Series中：
- en: '[PRE7]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let’s create hundreds of features automatically for each hour of light records
    using `tsfresh`. To create features from the `light` variable, we pass the DataFrame
    containing this variable and the unique identifier for each time series to the
    `extract_features` function from `tsfresh`:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用`tsfresh`为每个小时的能耗记录自动创建数百个特征。要从`light`变量创建特征，我们将包含此变量的DataFrame和每个时间序列的唯一标识符传递给`tsfresh`的`extract_features`函数：
- en: '[PRE8]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If we execute `features.shape`, we’ll obtain `(135, 789)` corresponding to the
    size of the resulting DataFrame, where each row represents an hour of records
    and each column one of the features created by `tsfresh`. There are 789 features
    that characterize light consumption at any given hour. Go ahead and execute `features.head()`
    to get a view of the resulting DataFrame. For space reasons, we can’t display
    the entire DataFrame in the book. So, instead, we will explore some of the features.
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们执行`features.shape`，我们会得到`(135, 789)`，这对应于结果DataFrame的大小，其中每一行代表一个小时的记录，每一列代表由`tsfresh`创建的一个特征。有789个特征可以描述任意给定小时的能耗。现在执行`features.head()`来查看结果DataFrame的概览。由于空间限制，我们无法在书中展示整个DataFrame，所以我们将探索一些特征。
- en: 'Let’s capture the names of five of the created features in an array:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将创建的五个特征的名称存储在一个数组中：
- en: '[PRE9]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If we execute `feats`, we’ll see the names of five features corresponding to
    the mean, length, standard deviation, coefficient of variation, and variance of
    the light consumption per hour:'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们执行`feats`，我们会看到五个特征的名称，分别对应每小时能耗的平均值、长度、标准差、变异系数和方差：
- en: '[PRE10]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, let’s display the values of the features from *step 5* for the first five
    hours:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们显示*步骤5*中前五个小时的特征值：
- en: '[PRE11]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the following DataFrame, we see the features extracted from the time series
    for the first five hours of light consumption:'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在下面的DataFrame中，我们看到从前五个小时的能耗时间序列中提取的特征：
- en: '![Figure 10.5 – Features created for each hour of light consumption](img/B22396_10_05.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图10.5 – 为每小时能耗创建的特征](img/B22396_10_05.jpg)'
- en: Figure 10.5 – Features created for each hour of light consumption
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5 – 为每小时能耗创建的特征
- en: Looking at the mean value of light consumption in *Figure 10**.4*, we can see
    that the lights were on during the first hour, and then off in the following four
    hours. The length of the time series is 60 because we have 60 minutes of records
    per hour.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在**图10.4**.4中查看平均能耗值，我们可以看到前一个小时灯是亮着的，接下来的四个小时则是关闭的。时间序列的长度为60，因为我们每小时有60分钟的记录。
- en: Note
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '`tsfresh` applies 63 feature creation methods to a time series. Based on the
    characteristics of the time series, such as its length or its variability, some
    of the methods will return missing values or infinite values. For example, in
    *Figure 10**.4*, we see that the variation coefficient could not be calculated
    for those hours where the light consumption is constant. And the variance is also
    `0` in those cases. In fact, for our dataset, many of the resulting features contain
    only `NaN` values, or are constant, like the length, and are therefore not useful
    for training machine learning models.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`tsfresh`对时间序列应用63种特征创建方法。根据时间序列的特性，如长度或其变异性，某些方法可能会返回缺失值或无穷大值。例如，在**图10.4**.4中，我们看到在能耗恒定的那些小时无法计算变异系数。在这些情况下，方差也是`0`。实际上，对于我们的数据集，许多生成的特征只包含`NaN`值，或者像长度一样是常数，因此对于训练机器学习模型没有用。'
- en: '`tsfresh` includes an imputation function to impute features that contain `NaN`
    values. Let’s go ahead and impute our features:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`tsfresh` 包含一个插补函数，用于插补包含 `NaN` 值的特征。让我们继续插补我们的特征：'
- en: '[PRE12]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `impute` function from `tsfresh` replaces `NaN`, `-Inf`, and `Inf` values
    with the variable’s median, minimum, or maximum values, respectively.
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`tsfresh` 的 `impute` 函数将 `NaN`、`-Inf` 和 `Inf` 值分别替换为变量的中位数、最小值或最大值。'
- en: Let’s use these features to train a logistic regression model and predict whether
    the office was occupied.
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们使用这些特征来训练一个逻辑回归模型并预测办公室是否被占用。
- en: 'Let’s begin by separating the dataset into training and test sets:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先分离数据集为训练集和测试集：
- en: '[PRE13]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, let’s set up and train a logistic regression model, and then evaluate
    its performance:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们设置并训练一个逻辑回归模型，然后评估其性能：
- en: '[PRE14]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the following output, we see the values of evaluation metrics that are commonly
    used for classification analysis, which suggests that the created features are
    useful for predicting office occupancy:'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在以下输出中，我们看到用于分类分析的常用评估指标值，这表明创建的特征对预测办公室占用情况是有用的：
- en: '[PRE15]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To keep the recipe simple, I have not optimized the model hyperparameters or
    tuned the probability threshold – things that we normally do to ensure our models
    are accurate.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持食谱简单，我没有优化模型超参数或调整概率阈值——这些是我们通常为了确保模型准确而做的事情。
- en: 'To finish off, let’s extract features from every time series, that is, `light`,
    `temperature`, `humidity`, and `co2`, and this time, we will impute the features
    right after the extraction:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们从每个时间序列中提取特征，即 `light`、`temperature`、`humidity` 和 `co2`，这次，我们将在提取后立即插补特征：
- en: '[PRE16]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In *step 10*, we indicated that we want to sort our time series based on the
    timestamp containing the time and date of the measurement, by passing the `date`
    variable to the `column_sort` parameter. This is useful when our time series are
    not equidistant or not ordered chronologically. If we leave this parameter set
    to `None`, `tsfresh` assumes that the time series are ordered and equidistant.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤 10* 中，我们指出我们想要根据包含测量时间和日期的时间戳对时间序列进行排序，通过将 `date` 变量传递给 `column_sort`
    参数。当我们的时间序列不是等距的或不是按时间顺序排列时，这很有用。如果我们将此参数设置为 `None`，`tsfresh` 假设时间序列是有序且等距的。
- en: The output of *step 10* consists of a DataFrame with 135 rows, containing 3,945
    features (execute `features.shape` to check that out) that characterize the five
    original time series – temperature, light, humidity and its ratio, and ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>C</mml:mi><mml:mi>O</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:math>](img/47.png)
    in the office. These features were imputed in *step 10*, so you can go ahead and
    use this DataFrame to train another logistic regression model to predict office
    occupancy.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤 10* 的输出是一个包含 135 行的 DataFrame，包含 3,945 个特征（执行 `features.shape` 检查），这些特征描述了五个原始时间序列——温度、光照、湿度及其比率，以及
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>C</mml:mi><mml:mi>O</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:math>](img/47.png)
    办公室。这些特征在 *步骤 10* 中进行了插补，因此您可以继续使用此 DataFrame 来训练另一个逻辑回归模型以预测办公室占用情况。'
- en: How it works...
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we used `tsfresh` to automatically create hundreds of features
    from five time series, and then used those features to train a logistic regression
    model to predict whether the office was occupied.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们使用了 `tsfresh` 从五个时间序列自动创建数百个特征，然后使用这些特征来训练一个逻辑回归模型以预测办公室是否被占用。
- en: Note
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To create features with `tsfresh`, the time-series interval from which we want
    to extract features must be marked with a `id` variable.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `tsfresh` 创建特征，我们需要从其中提取特征的时间序列间隔必须用 `id` 变量标记。
- en: To create features from time series, we used the `extract_features` function
    from `tsfresh`. This function takes the DataFrame containing the time series and
    the unique identifier as input and returns a DataFrame containing the extracted
    features as output.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要从时间序列创建特征，我们使用了 `tsfresh` 的 `extract_features` 函数。此函数接受包含时间序列的唯一标识符的 DataFrame
    作为输入，并返回包含提取特征的 DataFrame 作为输出。
- en: '`extract_features` has three key parameters: `column_id`, `column_sort`, and
    `impute_function`. `column_id` receives the name of the column with the unique
    identifier for each sequence that’ll be used to extract features. `column_sort`
    is used to reorder the time series before extracting features. When `column_sort`
    is left to `None`, `tsfresh` assumes that the data is ordered chronologically
    and that the timestamps are equidistant. In *step 10*, we passed the `date` variable
    as the sorting variable, which informs `tsfresh` how to sort the data before extracting
    the features.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`extract_features` 有三个关键参数：`column_id`、`column_sort` 和 `impute_function`。`column_id`
    接收用于提取特征的每个序列的唯一标识符列的名称。`column_sort` 用于在提取特征之前重新排序时间序列。当 `column_sort` 设置为 `None`
    时，`tsfresh` 假设数据是按时间顺序排列的，并且时间戳是等距的。在 *步骤 10* 中，我们传递了 `date` 变量作为排序变量，这告诉 `tsfresh`
    在提取特征之前如何排序数据。'
- en: Note
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In our dataset, leaving `column_sort` set to `None` or passing the `date` variable
    made no difference, because our time series were already ordered chronologically
    and the timestamps were equidistant. If this is not the case in your time series,
    use this parameter to create features correctly.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的数据集中，将 `column_sort` 设置为 `None` 或传递 `date` 变量没有区别，因为我们的时间序列已经按时间顺序排列，并且时间戳是等距的。如果您的时序不是这种情况，请使用此参数正确创建特征。
- en: Finally, `extract_features` also accepts the `impute` function through the `impute_function`
    parameter, to automatically remove infinite and `NaN` values from the created
    features. Will discuss additional parameters of `extract_features` in the coming
    recipes.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`extract_features` 函数也通过 `impute_function` 参数接受 `impute` 函数，以自动从创建的特征中移除无限和
    `NaN` 值。将在接下来的菜谱中讨论 `extract_features` 的其他参数。
- en: Note
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For more details about the `extract_features` function, visit [https://tsfresh.readthedocs.io/en/latest/api/tsfresh.feature_extraction.html#module-tsfresh.feature_extraction.extraction](https://tsfresh.readthedocs.io/en/latest/api/tsfresh.feature_extraction.html#module-tsfresh.feature_extraction.extraction).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于 `extract_features` 函数的详细信息，请访问 [https://tsfresh.readthedocs.io/en/latest/api/tsfresh.feature_extraction.html#module-tsfresh.feature_extraction.extraction](https://tsfresh.readthedocs.io/en/latest/api/tsfresh.feature_extraction.html#module-tsfresh.feature_extraction.extraction)。
- en: The `impute` function, which can be used independently, as we did in *step 7*,
    or within the `extract_features` function, as we did in *step 10*, replaced `NAN`,
    `-Inf`, and `Inf` values with the variable’s median, minimum, or maximum values,
    respectively. If the feature contains only `NaN` values, they are replaced by
    zeroes. The imputation occurs in place – that is, in the same DataFrame that is
    being imputed.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`impute` 函数，它可以独立使用，就像我们在 *步骤 7* 中做的那样，或者在我们 *步骤 10* 中做的那样，在 `extract_features`
    函数内部使用，分别用变量的中位数、最小值或最大值替换 `NAN`、`-Inf` 和 `Inf` 值。如果特征只包含 `NaN` 值，则它们被零替换。插补是在原地发生的——也就是说，在正在插补的同一个
    DataFrame 中。'
- en: The `extract_features` function returns a DataFrame containing as many rows
    as unique identifiers in the data. In our case, it returned a DataFrame with 135
    rows. The columns of the resulting DataFrame correspond to the 789 values that
    were returned by 63 characterization methods applied to each of the 135 60-minute
    time series.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`extract_features` 函数返回一个包含数据中唯一标识符行数的 DataFrame。在我们的例子中，它返回了一个包含 135 行的 DataFrame。结果
    DataFrame 的列对应于应用于每个 135 个 60 分钟时间序列的 63 种表征方法返回的 789 个值。'
- en: In *step 5*, we explored some of the resulting features, which captured the
    time series mean, variance, and coefficient of variation, as well as their length.
    Let’s explore a few more of the resulting features.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤 5* 中，我们探索了一些结果特征，这些特征捕捉了时间序列的均值、方差和变异系数，以及它们的长度。让我们再探索一些结果特征。
- en: Some of the created variables are self-explanatory. For example, the `'light__skewness'`
    and `'light__kurtosis'` variables contain the skewness and kurtosis coefficients,
    which characterize the data distribution. The `'light__has_duplicate_max'`, `'light__has_duplicate_min'`,
    and `'light__has_duplicate'` variables indicate whether the time series has duplicated
    values or duplicated minimum or maximum values within the time interval. The `'light__quantile__q_0.1'`,
    `'light__quantile__q_0.2'`, and `'light__quantile__q_0.3'` variables display the
    different quantile values of the time series. Finally, the `'light__autocorrelation__lag_0'`,
    `'light__autocorrelation__lag_1'`, and `'light__autocorrelation__lag_2'` variables
    show the autocorrelation of the time series with its past values, lagged by 0,
    1, or 2 steps – information that is generally useful in forecasting.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 一些创建的变量是自我解释的。例如，`'light__skewness'` 和 `'light__kurtosis'` 变量包含偏度和峰度系数，这些系数表征了数据分布。`'light__has_duplicate_max'`，`'light__has_duplicate_min'`
    和 `'light__has_duplicate'` 变量指示时间序列是否在时间间隔内有重复值或重复的最小值或最大值。`'light__quantile__q_0.1'`，`'light__quantile__q_0.2'`
    和 `'light__quantile__q_0.3'` 变量显示了时间序列的不同分位数。最后，`'light__autocorrelation__lag_0'`，`'light__autocorrelation__lag_1'`
    和 `'light__autocorrelation__lag_2'` 变量显示了时间序列与其过去值的自相关，滞后0，1或2步——这些信息通常对预测很有用。
- en: Other characterization methods return features obtained from signal processing
    algorithms, such as the continuous wavelet transform for the Ricker wavelet, which
    returns the `'light__cwt_coefficients__coeff_0__w_2__widths_(2, 5, 10, 20)'`,
    `'light__cwt_coefficients__coeff_0__w_5__widths_(2, 5, 10, 20)'`, `'light__cwt_coefficients__coeff_0__w_10__widths_(2,
    5, 10, 20)'`, and `'light__cwt_coefficients__coeff_0__w_20__widths_(2, 5, 10,
    20)'` features, among others.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 其他特征化方法返回的是从信号处理算法中获取的特征，例如，对于Ricker小波，连续小波变换返回的 `'light__cwt_coefficients__coeff_0__w_2__widths_(2,
    5, 10, 20)'`, `'light__cwt_coefficients__coeff_0__w_5__widths_(2, 5, 10, 20)'`,
    `'light__cwt_coefficients__coeff_0__w_10__widths_(2, 5, 10, 20)'`, 和 `'light__cwt_coefficients__coeff_0__w_20__widths_(2,
    5, 10, 20)'` 等特征。
- en: Note
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We can’t discuss each of these feature characterization methods or their outputs
    in detail in this book because there are too many. You can find more details about
    the transformations supported by `tsfresh` and their formulation at [https://tsfresh.readthedocs.io/en/latest/api/tsfresh.feature_extraction.html](https://tsfresh.readthedocs.io/en/latest/api/tsfresh.feature_extraction.html).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 由于方法众多，我们无法在本书中详细讨论每种特征化方法及其输出。您可以在 [https://tsfresh.readthedocs.io/en/latest/api/tsfresh.feature_extraction.html](https://tsfresh.readthedocs.io/en/latest/api/tsfresh.feature_extraction.html)
    找到关于 `tsfresh` 支持的转换及其公式的更多详细信息。
- en: Some of the features that are automatically created by `tsfresh` may not make
    sense or even be possible to calculate for some time series because they require
    a certain length or data variability, or the time series must meet certain distribution
    assumptions. Therefore, the suitability of the features will depend on the nature
    of the time series.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 一些由 `tsfresh` 自动创建的特征可能对于某些时间序列来说没有意义，甚至无法计算，因为它们需要一定的长度或数据变异性，或者时间序列必须满足某些分布假设。因此，特征的适用性将取决于时间序列的性质。
- en: Note
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can decide which features to extract from your time series based on domain
    knowledge, or by creating all possible features and then applying feature selection
    algorithms or following up with data analysis. In fact, from our dataset, many
    of the resulting features were either constant or contained only missing data.
    Hence, we can reduce the feature space to informative features by taking those
    features out of the data.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以根据领域知识决定从您的时间序列中提取哪些特征，或者通过创建所有可能的特征，然后应用特征选择算法或进行数据分析来决定。实际上，从我们的数据集中，许多生成的特征要么是常数，要么只包含缺失数据。因此，我们可以通过从数据中去除这些特征来减少特征空间到信息特征。
- en: See also
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考资料链接
- en: For more details about `tsfresh`, check out the article Christ M., Braun N.,
    , Neuffer J., and Kempa-Liehr A., (2018). *Time Series FeatuRe Extraction on basis
    of Scalable Hypothesis tests (tsfresh – A Python package). Neurocomputing 307
    (2018). Pages* *72-77.* [https://dl.acm.org/doi/10.1016/j.neucom.2018.03.067](https://dl.acm.org/doi/10.1016/j.neucom.2018.03.067).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 想要了解更多关于 `tsfresh` 的详细信息，请参阅文章 Christ M.，Braun N.，Neuffer J.，和 Kempa-Liehr A.
    (2018). *基于可扩展假设检验的时间序列特征提取 (tsfresh – 一个Python包). Neurocomputing 307 (2018).
    页码 *72-77.* [https://dl.acm.org/doi/10.1016/j.neucom.2018.03.067](https://dl.acm.org/doi/10.1016/j.neucom.2018.03.067)。
- en: Automatically creating and selecting predictive features from time-series data
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从时间序列数据自动创建和选择预测特征
- en: In the previous recipe, we automatically extracted several hundred features
    from time-series variables using `tsfresh`. If we have more than one time-series
    variable, we can easily end up with a dataset containing thousands of features.
    In addition, many of the resulting features had only missing data or were constant
    and were therefore not useful for training machine learning models.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的菜谱中，我们使用`tsfresh`自动从时间序列变量中提取了数百个特征。如果我们有多个时间序列变量，我们很容易得到一个包含数千个特征的数据库。此外，许多生成的特征只有缺失数据或常数，因此对训练机器学习模型没有用。
- en: When we create classiﬁcation and regression models to solve real-life problems,
    we often want our models to take a small number of relevant features as input
    to produce interpretable machine learning outputs. Simpler models have many advantages.
    First, their output is easier to interpret. Second, simpler models are cheaper
    to store and faster to train. They also return their outputs faster.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建分类和回归模型来解决现实生活中的问题时，我们通常希望我们的模型只输入少量相关特征以产生可解释的机器学习输出。简单的模型有很多优点。首先，它们的输出更容易解释。其次，简单的模型存储成本更低，训练速度更快。它们也能更快地返回输出。
- en: '`tsfresh` includes a highly parallelizable feature selection algorithm based
    on non-parametric statistical hypothesis tests, which can be executed at the back
    of the feature creation procedure to quickly remove irrelevant features. The feature
    selection procedure utilizes different tests for different features.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`tsfresh`包含一个基于非参数统计假设检验的高度可并行化的特征选择算法，该算法可以在特征创建过程的后面执行，以快速去除无关特征。特征选择过程使用不同的测试针对不同的特征。'
- en: '`tsfresh` uses the following tests to select features:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`tsfresh`使用以下测试来选择特征：'
- en: Fisher’s exact test of independence, if both the feature and the target are
    binary
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果特征和目标都是二元的，则使用费舍尔精确检验独立性
- en: Kolmogorov-Smirnov test, if either the feature or the target is binary
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果特征或目标中任一个是二元的，则使用柯尔莫哥洛夫-斯米尔诺夫检验
- en: Kendall rank test, if neither the feature nor the target is binary
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果特征或目标都不是二元的，则使用肯德尔秩检验
- en: The advantage of these tests is that they are non-parametric, and thus make
    no assumptions on the underlying distribution of the variables being tested.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测试的优势在于它们是非参数的，因此不对被测试变量的潜在分布做出假设。
- en: The result of these tests is a vector of p-values that measures the significance
    of the association between each feature and the target. These p-values are then
    evaluated based on the Benjamini-Yekutieli procedure to decide which features
    to keep.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测试的结果是一个p值向量，衡量每个特征与目标之间的关联显著性。然后根据Benjamini-Yekutieli过程评估这些p值，以决定保留哪些特征。
- en: Note
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For more details about `tsfresh`’s feature selection procedure, check out the
    article Christ, Kempa-Liehr, and Feindt, *Distributed and parallel time series
    feature extraction for industrial big data applications*. Asian Machine Learning
    Conference (ACML) 2016, Workshop on Learning on Big Data (WLBD), Hamilton (New
    Zealand), arXiv, [https://arxiv.org/abs/1610.07717v1](https://arxiv.org/abs/1610.07717v1).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`tsfresh`的特征选择过程的更多详细信息，请参阅文章Christ, Kempa-Liehr, and Feindt，*分布式和并行时间序列特征提取用于工业大数据应用*。亚洲机器学习会议（ACML）2016，大数据学习研讨会（WLBD），汉密尔顿（新西兰），arXiv，[https://arxiv.org/abs/1610.07717v1](https://arxiv.org/abs/1610.07717v1)。
- en: In this recipe, we will automatically create hundreds of features from various
    time series, and then select the most relevant features by utilizing `tsfresh`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将自动从各种时间序列中创建数百个特征，然后利用`tsfresh`选择最相关的特征。
- en: How to do it...
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We will begin by automatically creating and selecting features from one time
    series, `lights`, and then we will automate the procedure for multiple time series:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先自动从一条时间序列，`照明`，创建和选择特征，然后我们将自动化处理多条时间序列：
- en: 'Let’s import the required Python libraries and functions:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们导入所需的Python库和函数：
- en: '[PRE17]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Load the dataset and the target variable described in the *Technical* *requirements*
    section:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载数据集和目标变量，如*技术* *要求*部分所述：
- en: '[PRE18]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let’s create hundreds of features automatically for each hour of `light` use
    records and impute the resulting features:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们为每个小时的`照明`使用记录自动创建数百个特征，并对生成的特征进行插补：
- en: '[PRE19]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The output of the previous step is a DataFrame with 135 rows and 789 columns,
    corresponding to the features created from each hour of light consumption.
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上一步的输出是一个包含135行和789列的DataFrame，对应于从每个小时的照明消耗中创建的特征。
- en: Note
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For more details about *step 3*, or the Occupancy Detection dataset, check out
    the *Extracting hundreds of features automatically from a time* *series* recipe.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 有关*步骤 3*或占用检测数据集的更多详细信息，请查看*从时间序列自动提取数百个特征*菜谱。
- en: 'Now, let’s select the features based on the non-parametric tests that we mentioned
    in the introduction of this recipe:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们根据我们在本菜谱介绍中提到的非参数测试来选择特征：
- en: '[PRE20]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If we execute `len(features)`, we’ll see the value `135`, which means that from
    the 789 features created in *step 3*, only 135 are statistically significant.
    Go ahead and execute `features.head()` to display the first five rows of the resulting
    DataFrame.
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们执行`len(features)`，我们将看到值`135`，这意味着在*步骤 3*中创建的789个特征中，只有135个具有统计学意义。继续执行`features.head()`以显示结果的
    DataFrame 的前五行。
- en: 'For space reasons, we will only display the first five features:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于空间原因，我们只显示前五个特征：
- en: '[PRE21]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the following DataFrame, we see the values of the first five features for
    the first five hours of light consumption:'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在以下 DataFrame 中，我们可以看到前五个小时光消耗的前五个特征的价值：
- en: '![Figure 10.6 – DataFrame with five of the selected features created from each
    hour of light consumption](img/B22396_10_06.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.6 – 从每小时的光消耗中创建的五个选定特征的 DataFrame](img/B22396_10_06.jpg)'
- en: Figure 10.6 – DataFrame with five of the selected features created from each
    hour of light consumption
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.6 – 从每小时的光消耗中创建的五个选定特征的 DataFrame
- en: Check the discussion in the *How it works…* section for a more detailed analysis
    of the DataFrame resulting from *step 4*.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看“*如何工作…*”部分，以获取对*步骤 4*生成的 DataFrame 的更详细分析。
- en: 'Now, we will use the features from *step 4* to train a logistic regression
    model and predict whether the office was occupied. Let’s begin by separating the
    dataset into training and test sets:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将使用*步骤 4*中的特征来训练一个逻辑回归模型并预测办公室是否被占用。让我们首先将数据集分为训练集和测试集：
- en: '[PRE22]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let’s set up and train a logistic regression model and then evaluate its performance:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们设置并训练一个逻辑回归模型，然后评估其性能：
- en: '[PRE23]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In the following output, we see the values of commonly used evaluation metrics
    for classification analysis. These suggest that the selected features are useful
    for predicting office occupancy:'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在以下输出中，我们可以看到分类分析中常用评估指标的价值。这些表明选定的特征对预测办公室占用是有用的：
- en: '[PRE24]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: features = extract_relevant_features(
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: features = extract_relevant_features(
- en: X,
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: X,
- en: y,
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: y,
- en: column_id="id",
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: column_id="id",
- en: column_sort="date",
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: column_sort="date",
- en: )
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: )
- en: '[PRE25]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The parameters of `extract_relevant_features` are very similar to those of `extract_features`.
    Note, however, that the former will automatically perform imputation to be able
    to proceed with the feature selection. We discussed the parameters of `extract_features`
    in the *Extracting hundreds of features automatically from time* *series* recipe.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`extract_relevant_features`的参数与`extract_features`的参数非常相似。请注意，然而，前者将自动执行插补以能够进行特征选择。我们在*从时间序列自动提取数百个特征*菜谱中讨论了`extract_features`的参数。'
- en: The output of *step 8* consists of a DataFrame with 135 rows and 968 features,
    from the original 3,945 that are returned by default by `tsfresh` (you can check
    that out by executing `features.shape`). Go ahead and use this DataFrame to train
    another logistic regression model to predict office occupancy.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤 8*的输出是一个包含 135 行和 968 个特征的 DataFrame，来自`tsfresh`默认返回的原始 3,945 个特征（您可以通过执行`features.shape`来检查这一点）。继续使用此
    DataFrame 来训练另一个逻辑回归模型以预测办公室占用。'
- en: How it works...
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作...
- en: In this recipe, we created hundreds of features from a time series and then
    selected the most relevant features based on non-parametric statistical tests.
    The feature creation and selection procedures were carried out automatically by
    `tsfresh`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们从时间序列中创建了数百个特征，然后根据非参数统计测试选择了最相关的特征。特征创建和选择过程由`tsfresh`自动执行。
- en: To create the features, we used `tsfresh`’s `extract_features` function, which
    we described in detail in the *Extracting hundreds of features automatically from
    a time* *series* recipe.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建特征，我们使用了`tsfresh`的`extract_features`函数，我们在*从时间序列自动提取数百个特征*菜谱中对其进行了详细描述。
- en: To select features, we used the `select_features` function, also from `tsfresh`.
    This function applies different statistical tests, depending on the nature of
    the feature and the target. Briefly, if the feature and target are binary, it
    tests their relationship with Fisher’s exact test. If either the feature or the
    target is binary, and the other variable is continuous, it tests their relationship
    by using the Kolmogorov-Smirnov test. If neither the features nor the target is
    binary, it uses the Kendall rank test.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 为了选择特征，我们使用了来自 `tsfresh` 的 `select_features` 函数。这个函数根据特征和目标的不同性质应用不同的统计测试。简而言之，如果特征和目标是二元的，它通过费舍尔精确检验测试它们之间的关系。如果特征或目标是二元的，而另一个变量是连续的，它通过使用
    Kolmogorov-Smirnov 检验测试它们之间的关系。如果特征和目标都不是二元的，它使用 Kendall 排序检验。
- en: The result of these tests is a vector with one p-value per feature. Next, `tsfresh`
    applies the Benjamini-Yekutieli procedure, which aims to reduce the false discovery
    rate, to select which features to keep based on the p-values. This feature selection
    procedure has some advantages, the main one being that statistical tests are fast
    to compute, and therefore the selection algorithm is scalable and can be parallelized.
    Another advantage is that the tests are non-parametric and hence suitable for
    linear and non-linear models.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测试的结果是一个向量，每个特征都有一个 p 值。接下来，`tsfresh` 应用 Benjamini-Yekutieli 程序，旨在降低假发现率，根据
    p 值选择要保留的特征。这个特征选择程序有一些优点，主要优点是统计测试计算速度快，因此选择算法可扩展且可并行化。另一个优点是测试是非参数的，因此适用于线性和非线性模型。
- en: However, feature selection methods that evaluate each feature individually are
    unable to remove redundant features. In fact, many of the features automatically
    created by `tsfresh` will be highly correlated, like those capturing the different
    quantiles of light consumption. Hence, they will show similar p-values and be
    retained. But in practice, we only need one or a few of them to capture the information
    of the time series. I’d recommend following up the `tsfresh` selection procedure
    with alternative feature selection methods that are able to pick up feature interactions.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，评估每个特征单独的特征选择方法无法移除冗余特征。实际上，`tsfresh` 自动创建的许多特征将高度相关，例如那些捕捉到不同量级的光消费的特征。因此，它们将显示相似的
    p 值并被保留。但在实践中，我们只需要一个或少数几个来捕捉时间序列的信息。我建议在 `tsfresh` 选择程序之后跟进其他能够识别特征交互的特征选择方法。
- en: Finally, in *step 8*, we combined the feature creation step (*step 3*) with
    the feature selection step (*step 4*) by using the `extract_relevant_features`
    function. `extract_relevant_features` applies the `extract_features` function
    to create the features from each time series and imputes them. Next, it applies
    the `select_features` function to return a DataFrame containing one row per unique
    identifier, and the features that were selected for each time series. Note that
    different features can be selected for different time series.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在 *步骤 8* 中，我们通过使用 `extract_relevant_features` 函数将特征创建步骤 (*步骤 3*) 与特征选择步骤
    (*步骤 4*) 结合起来。`extract_relevant_features` 函数将 `extract_features` 函数应用于每个时间序列以创建特征，并进行插补。接下来，它应用
    `select_features` 函数以返回一个包含每个唯一标识符的行和一个为每个时间序列选择的特征的 DataFrame。请注意，对于不同的时间序列，可以选择不同的特征。
- en: See also
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The selection algorithm from `tsfresh` offers a quick method to remove irrelevant
    features. However, it does not find the best feature subset for the classification
    or regression task. Other feature selection methods can be applied at the back
    of `tsfresh`’s algorithm to reduce the feature space further.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`tsfresh` 中的选择算法提供了一种快速的方法来移除无关特征。然而，它并不能找到分类或回归任务的最佳特征子集。可以在 `tsfresh` 算法之后应用其他特征选择方法来进一步减少特征空间。'
- en: 'For more details on feature selection algorithms, check out the book *Feature
    Selection in Machine Learning with Python* by Soledad Galli on Leanpub: [https://leanpub.com/feature-selection-in-machine-learning/](https://leanpub.com/feature-selection-in-machine-learning/).'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 想要了解更多关于特征选择算法的细节，请查看 Soledad Galli 在 Leanpub 上出版的书籍《Python 机器学习中的特征选择》：[https://leanpub.com/feature-selection-in-machine-learning/](https://leanpub.com/feature-selection-in-machine-learning/)。
- en: Extracting different features from different time series
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从不同的时间序列中提取不同的特征
- en: '`tsfresh` extracts many features based on the time-series characteristics and
    distribution, such as their correlation properties, stationarity, and entropy.
    It also applies non-linear time-series analysis functions, which decompose the
    time-series signal through, for example, Fourier or wavelet transformations. Depending
    on the nature of the time series, some of these transformations make more sense
    than others. For example, wavelength decomposition methods can make sense for
    time series resulting from signals or sensors but are not always useful for time
    series representing sales or stock prices.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`tsfresh` 基于时间序列的特征和分布提取许多特征，例如它们的关联属性、平稳性和熵。它还应用非线性时间序列分析函数，例如通过傅里叶或小波变换分解时间序列信号。根据时间序列的性质，这些变换中的一些比其他的有意义。例如，波长分解方法对于由信号或传感器产生的时间序列可能是有意义的，但并不总是对表示销售或股价的时间序列有用。'
- en: In this recipe, we will discuss how to optimize the feature extraction procedure
    to extract specific features from each time series, and then use these features
    to predict office occupancy.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将讨论如何优化特征提取过程，从每个时间序列中提取特定特征，然后使用这些特征来预测办公室的占用情况。
- en: How to do it...
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: '`tsfresh` accesses the methods that will be used to create features through
    a dictionary that contains the method names as keys and, if they need a parameter,
    it has the parameter as a value. `tsfresh` includes some predefined dictionaries
    as well. We’ll explore these predefined dictionaries first, which can be accessed
    through the `settings` module:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`tsfresh` 通过包含方法名称作为键的字典访问将用于创建特征的函数，如果它们需要参数，则参数作为值。`tsfresh` 还包含一些预定义的字典。我们将首先探索这些预定义的字典，这些字典可以通过
    `settings` 模块访问：'
- en: 'Let’s import the required Python libraries and functions and the `settings`
    module:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们导入所需的 Python 库、函数和 `settings` 模块：
- en: '[PRE26]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Load the dataset and the target variable described in the *Technical* *requirements*
    section:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载数据集和 *技术要求* 部分中描述的目标变量：
- en: '[PRE27]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '`tsfresh` includes three main dictionaries that control the feature creation
    output: `settings.ComprehensiveFCParameters`, `settings.EfficientFCParameters`,
    and `settings.MinimalFCParameters`. Here, we’ll explore the dictionary that returns
    the fewest features. You can repeat the steps to explore the additional dictionaries.'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`tsfresh` 包含三个主要的字典来控制特征创建输出：`settings.ComprehensiveFCParameters`、`settings.EfficientFCParameters`
    和 `settings.MinimalFCParameters`。在这里，我们将探索返回最少特征的字典。您可以重复这些步骤来探索其他字典。'
- en: 'Display the feature creation methods that will be applied when using the dictionary
    that returns the fewest features:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示在字典返回最少特征时将应用的特征创建方法：
- en: '[PRE28]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In the output of *step 3*, we see a dictionary with the feature extraction
    method names as keys, and the parameters used by those methods, if any, as values:'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 *步骤 3* 的输出中，我们看到一个以特征提取方法名称为键，以这些方法使用的参数（如果有）为值的字典：
- en: '[PRE29]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Go ahead and explore the other two predefined dictionaries, `settings.ComprehensiveFCParameters`
    and `settings.EfficientFCParameters`, by adapting the code from *step 3*.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，通过调整 *步骤 3* 中的代码，继续探索其他两个预定义的字典，`settings.ComprehensiveFCParameters` 和 `settings.EfficientFCParameters`。
- en: 'Now, let’s use the dictionary from *step 3* to extract only those features
    from the `light` time series and then display the shape of the resulting DataFrame:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们使用 *步骤 3* 中的字典从 `light` 时间序列中提取仅这些特征，然后显示生成的 DataFrame 的形状：
- en: '[PRE30]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The output of *step 4* is `(135, 10)`, which means that only 10 features were
    created for each of the 135 hours of light consumption data.
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*步骤 4* 的输出是 `(135, 10)`，这意味着为 135 小时的光照消耗数据中每个数据点只创建了 10 个特征。'
- en: 'Let’s display the resulting DataFrame:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们显示生成的 DataFrame：
- en: '[PRE31]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We see the values of the resulting features for the first five hours of light
    consumption in the following DataFrame:'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在以下 DataFrame 中，我们看到前五小时光照消耗生成的特征值：
- en: "![Figure 10.7 – DataFrame with the features created \uFEFFfor each hour of\
    \ light consumption](img/B22396_10_07.jpg)"
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.7 – 为每小时光照消耗创建的 DataFrame](img/B22396_10_07.jpg)'
- en: Figure 10.7 – DataFrame with the features created for each hour of light consumption
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.7 – 为每小时光照消耗创建的 DataFrame
- en: Now, we will use these features to train a logistic regression model to predict
    whether the office was occupied.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用这些特征来训练一个逻辑回归模型，以预测办公室是否被占用。
- en: 'Let’s begin by separating the dataset into training and test sets:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先从将数据集分为训练集和测试集开始：
- en: '[PRE32]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, let’s set up and train a logistic regression model, and then evaluate
    its performance:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们设置并训练一个逻辑回归模型，然后评估其性能：
- en: '[PRE33]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In the following output, we see the evaluation metrics that are commonly used
    for classification analysis. These suggest that the selected features are useful
    for predicting office occupancy:'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在以下输出中，我们看到的是用于分类分析的常用评估指标。这些指标表明所选特征对预测办公室占用率是有用的：
- en: '[PRE34]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Because light consumption is a very good indicator of office occupancy, with
    very simple features, we can obtain a predictive logistic regression model.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 因为光照消耗是办公室占用率的一个非常好的指标，通过非常简单的特征，我们可以获得一个预测性的逻辑回归模型。
- en: Now, let’s learn how to specify the creation of different features for different
    time series.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们学习如何为不同的时间序列指定创建不同特征的方法。
- en: 'Let’s create a dictionary with the names of the methods that we want to use
    to create features from the `light` time series. We enter the method’s names as
    keys, and if the methods take a parameter, we pass it as an additional dictionary
    to the corresponding key; otherwise, we pass `None` as the values:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个包含我们想要用于从`light`时间序列创建特征的名称的字典。我们将方法名称作为键，如果方法需要参数，我们将它作为额外的字典传递给相应的键；否则，我们传递`None`作为值：
- en: '[PRE35]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, let’s create a dictionary with the features that we want to create from
    the `co2` time series:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个包含从`co2`时间序列创建的特征的字典：
- en: '[PRE36]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Let’s combine these dictionaries into a new dictionary:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将这些字典合并到一个新的字典中：
- en: '[PRE37]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Finally, let’s use the dictionary from *step 10* to create the features from
    both time series:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们使用第10步的字典从两个时间序列中创建特征：
- en: '[PRE38]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The output of *step 11* consists of a DataFrame with 135 rows and 8 features.
    If we execute `features.columns`, we will see the names of the created features:'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第11步的输出是一个包含135行和8个特征的DataFrame。如果我们执行`features.columns`，我们将看到创建的特征的名称：
- en: '[PRE39]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Note that in the output from *step 11*, different variables have been created
    from each of the `light` and `co2` time series.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在第11步的输出中，从`light`和`co2`时间序列中分别创建了不同的变量。
- en: How it works...
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we extracted specific features from our time-series data. First,
    we created features based on a predefined dictionary that comes with `tsfresh`.
    Next, we created our own dictionary, specifying the creation of different features
    for different time series.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们从我们的时间序列数据中提取了特定的特征。首先，我们根据`tsfresh`附带的一个预定义字典创建了特征。接下来，我们创建了自己的字典，指定为不同的时间序列创建不同的特征。
- en: The `tsfresh` package comes with some predefined dictionaries that can be accessed
    through the `settings` module. The `MinimalFCParameters` dictionary is used to
    create 10 simple features based on basic statistical parameters of the time-series
    distribution, such as the mean, median, standard deviation, variance, sum of its
    values, count (or length), and minimum and maximum values. In *step 3*, we displayed
    the dictionary, with the method names as keys, and, as these methods do not require
    additional parameters, each key had `None` as the value.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`tsfresh`包附带了一些预定义的字典，可以通过`settings`模块访问。`MinimalFCParameters`字典用于根据时间序列分布的基本统计参数（如平均值、中位数、标准差、方差、值的总和、计数（或长度）、最小值和最大值）创建10个简单特征。在第3步中，我们展示了这个字典，其中方法名称作为键，由于这些方法不需要额外的参数，每个键的值都是`None`。'
- en: '`tsfresh` has two additional predefined dictionaries. `EfficientFCParameters`
    is used to apply methods that are fast to compute, whereas `ComprehensiveFCParameters`
    returns all possible features and is the one used by default by the `extract_features`
    function.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`tsfresh`有两个额外的预定义字典。`EfficientFCParameters`用于应用计算速度快的方法，而`ComprehensiveFCParameters`返回所有可能的特征，并且是`extract_features`函数默认使用的。'
- en: Note
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'For more details about the predefined dictionaries, check out `tsfresh`’s documentation:
    [https://tsfresh.readthedocs.io/en/latest/text/feature_extraction_settings.html](https://tsfresh.readthedocs.io/en/latest/text/feature_extraction_settings.html)'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于预定义字典的详细信息，请查看`tsfresh`的文档：[https://tsfresh.readthedocs.io/en/latest/text/feature_extraction_settings.html](https://tsfresh.readthedocs.io/en/latest/text/feature_extraction_settings.html)
- en: By using these predefined dictionaries in the `default_fc_parameters` parameter
    of `tsfresh`’s `extract_features` function, we can create specific features from
    one or more time series, as we did in *step 4*. Note that `default_fc_parameters`
    instructs `extract_features` to create the same features from *all* the time series.
    What if we want to extract different features from different time series?
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在 `tsfresh` 的 `extract_features` 函数的 `default_fc_parameters` 参数中使用这些预定义的字典，我们可以从一个或多个时间序列中创建特定特征，就像我们在
    *步骤 4* 中做的那样。请注意，`default_fc_parameters` 指示 `extract_features` 从 *所有* 时间序列中创建相同的特征。如果我们想从不同的时间序列中提取不同的特征怎么办？
- en: To create different features for different time series, we can use the `kind_to_fc_parameters`
    parameter of `tsfresh`’s `extract_features` function. This parameter takes a dictionary
    of dictionaries, specifying the methods to apply to each time series.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 为了为不同的时间序列创建不同的特征，我们可以使用 `tsfresh` 的 `extract_features` 函数的 `kind_to_fc_parameters`
    参数。该参数接受一个字典的字典，指定应用于每个时间序列的方法。
- en: In *step 8*, we created a dictionary to specify the creation of specific features
    from the `light` time series. Note that the `"sum_values"` and `"mean"` methods
    take `None` as values, but the `quantile` method needs additional parameters corresponding
    to the quantiles that should be returned from the time series. In *step 9*, we
    created a dictionary to specify the creation of features from the `co2` time series.
    In *step 10*, we combined both dictionaries into one that takes the name of the
    time series as the key and the feature creation dictionaries as values. Then,
    we passed this dictionary to the `kind_to_fc_parameters` parameter of `tsfresh`’s
    `extract_features` function. This way of specifying features is suitable if we
    use domain knowledge to create the features, or if we only create a small number
    of features.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤 8* 中，我们创建了一个字典来指定从 `light` 时间序列创建特定特征。请注意，`"sum_values"` 和 `"mean"` 方法使用
    `None` 作为值，但 `quantile` 方法需要额外的参数，对应于应从时间序列返回的分位数。在 *步骤 9* 中，我们创建了一个字典来指定从 `co2`
    时间序列创建特征。在 *步骤 10* 中，我们将这两个字典合并为一个，以时间序列的名称作为键，特征创建字典作为值。然后，我们将这个字典传递给 `tsfresh`
    的 `extract_features` 函数的 `kind_to_fc_parameters` 参数。如果使用领域知识创建特征，或者只创建少量特征，这种方式指定特征是合适的。
- en: Do we need to type each method by hand into a dictionary if we want to create
    multiple features for various time series? Not really. In the following recipe,
    we will learn how to specify which features to create based on features selected
    by Lasso.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想为各种时间序列创建多个特征，是否需要手动将每个方法键入字典中？实际上并不需要。在下面的食谱中，我们将学习如何根据 Lasso 选定的特征指定要创建哪些特征。
- en: Creating a subset of features identified through feature selection
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建通过特征选择识别的特征子集
- en: In the *Automatically creating and selecting predictive features from time-series
    data* recipe, we learned how to select relevant features using `tsfresh`. We also
    discussed the limitations of `tsfresh`’s selection procedures and suggested following
    up with alternative feature selection methods to identify predictive features
    while avoiding redundancy.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *从时间序列数据自动创建和选择预测特征* 食谱中，我们学习了如何使用 `tsfresh` 选择相关特征。我们还讨论了 `tsfresh` 选择过程的局限性，并建议采用替代特征选择方法来识别预测特征，同时避免冗余。
- en: In this recipe, we will create and select features using `tsfresh`. Following
    that, we will reduce the feature space further by utilizing Lasso regularization.
    Then, we will learn how to create a dictionary from the selected feature names
    to trigger the creation of those features *only* from future time series.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将使用 `tsfresh` 创建和选择特征。之后，我们将通过利用 Lasso 正则化进一步减少特征空间。然后，我们将学习如何从选定的特征名称创建字典，以触发仅从未来的时间序列创建这些特征。
- en: How to do it...
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let’s begin by importing the necessary libraries and getting the dataset ready:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先导入必要的库并准备数据集：
- en: 'Let’s import the required libraries and functions:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们导入所需的库和函数：
- en: '[PRE40]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Load the Occupancy Detection dataset described in the *Technical* *requirements*
    section:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载在 *技术要求* 部分描述的 *占用检测* 数据集：
- en: '[PRE41]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Create and select features from our five time series and then display the shape
    of the resulting DataFrame:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从我们的五个时间序列中创建和选择特征，然后显示结果 DataFrame 的形状：
- en: '[PRE42]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The output of *step 3* is `(135, 968)`, indicating that 968 features were returned
    from the five original time series, for each hour of records.
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*步骤 3* 的输出是 `(135, 968)`，表示从五个原始时间序列中返回了 968 个特征，对应于每小时的记录。'
- en: Note
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We discussed the function from *step 3* in the *Automatically creating and selecting
    predictive features from time-series* *data* recipe.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 *从时间序列数据自动创建和选择预测特征* 菜谱中讨论了 *步骤 3* 的函数。
- en: Let’s reduce the feature space further by selecting features with Lasso regularization.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过选择具有 Lasso 正则化的特征进一步减少特征空间。
- en: 'Set up logistic regression with Lasso regularization, which is the `"l1"` penalty.
    I also set some additional parameters arbitrarily:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置具有 Lasso 正则化的逻辑回归，这是 `"l1"` 惩罚。我还随意设置了一些额外的参数：
- en: '[PRE43]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Let’s set up a transformer to retain those features whose logistic regression
    coefficients are different from 0:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们设置一个转换器来保留那些逻辑回归系数不等于 0 的特征：
- en: '[PRE44]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Train the logistic regression model and select the features:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 训练逻辑回归模型并选择特征：
- en: '[PRE45]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now, capture the selected features in a variable:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将所选特征捕获到一个变量中：
- en: '[PRE46]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'If we execute `features`, we’ll see the names of the selected features:'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们执行 `features`，我们将看到所选特征的名字：
- en: '[PRE47]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'To extract just the features from *step 6* from the time series, we need to
    capture the feature creation method name and corresponding parameters in a dictionary.
    We can do this automatically from the feature names with `tsfresh`:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了只从时间序列中提取 *步骤 6* 的特征，我们需要在字典中捕获特征创建方法名称和相应的参数。我们可以使用 `tsfresh` 自动完成此操作：
- en: '[PRE48]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'If we execute `kind_to_fc_parameters`, we’ll see the dictionary that was created
    from the names of the features from *step 6*:'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们执行 `kind_to_fc_parameters`，我们将看到从 *步骤 6* 的特征名称创建的字典：
- en: '[PRE49]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now, we can use the dictionary from *step 8* together with the `extract_features`
    function to create only those features from our dataset:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用 *步骤 8* 的字典与 `extract_features` 函数一起创建我们数据集中的特征：
- en: '[PRE50]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The new DataFrame, which can be displayed by executing `features.head()`, only
    contains the 12 features that were selected by Lasso. Go ahead and corroborate
    the result on your computer.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 DataFrame，可以通过执行 `features.head()` 来显示，仅包含由 Lasso 选出的 12 个特征。请在你自己的计算机上验证这个结果。
- en: How it works...
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we created 968 features from 5 time series. Next, we reduced
    the feature space to 12 features by using Lasso regularization. Finally, we captured
    the specifications of the selected features in a dictionary so that, looking forward,
    we only created those features from our time series.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们从 5 个时间序列创建了 968 个特征。接下来，我们使用 Lasso 正则化将特征空间减少到 12 个特征。最后，我们在字典中捕获了所选特征的规格，以便在未来的操作中，我们只创建来自我们时间序列的特征。
- en: To automatically create and select features with `tsfresh`, we used the `extract_relevant_features`
    function, which we described in detail in the *Automatically creating and selecting
    predictive features from time-series* *data* recipe.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 要自动创建和选择 `tsfresh` 的特征，我们使用了 `extract_relevant_features` 函数，我们已在 *从时间序列数据自动创建和选择预测特征*
    菜谱中详细描述了该函数。
- en: Lasso regularization has the intrinsic ability to reduce some of the coefficients
    of the logistic regression model to 0\. The contribution of the features whose
    coefficient is 0 to the prediction of office occupancy is null and can therefore
    be removed. The `SelectFromModel()` class can identify and remove those features.
    We set up an instance of `SelectFromModel()` with a logistic regression model
    that used Lasso regularization to find the model coefficients. With `fit()`, `SelectFromModel()`
    trained the logistic regression model using the 968 features created from our
    time series and identified those whose coefficients were different from 0\. Then,
    with the `get_feature_names_out()` method, we captured the names of the selected
    features in a new variable.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: Lasso 正则化具有将逻辑回归模型的一些系数减少到 0 的内在能力。系数为 0 的特征对办公室占用预测的贡献为零，因此可以被移除。`SelectFromModel()`
    类可以识别并移除这些特征。我们使用具有 Lasso 正则化的逻辑回归模型设置了一个 `SelectFromModel()` 实例来找到模型系数。通过 `fit()`，`SelectFromModel()`
    使用我们从时间序列创建的 968 个特征训练了逻辑回归模型，并识别了那些系数不等于 0 的特征。然后，通过 `get_feature_names_out()`
    方法，我们在一个新变量中捕获了所选特征的名字。
- en: To create only the 12 features selected by Lasso regularization, we created
    a dictionary from the variable names by using the `from_columns()` function from
    `tsfresh`. This function returned a dictionary with the variables from which features
    were selected as keys. The values were additional dictionaries, containing the
    methods used to create features as keys, and the parameters used, if any, as values.
    To create the new features, we used this dictionary together with the `extract_features`
    function.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 为了只创建由Lasso正则化选择的12个特征，我们使用`tsfresh`的`from_columns()`函数从变量名创建了一个字典。此函数返回一个字典，其中的键是从中选择了特征的变量，值是包含用于创建特征的方法的键和（如果有的话）参数的值。为了创建新特征，我们使用此字典与`extract_features`函数一起。
- en: Note
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In *step 9*, we passed the entire dataset to the `extract_features` function.
    The resulting features only contained features extracted from three of the five
    time series. The additional two time series were ignored.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤 9*中，我们将整个数据集传递给了`extract_features`函数。结果特征只包含从五个时间序列中的三个提取的特征。另外两个时间序列被忽略了。
- en: Embedding feature creation into a scikit-learn pipeline
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将特征创建嵌入到scikit-learn管道中
- en: Throughout this chapter, we’ve discussed how to automatically create and select
    features from time-series data by utilizing `tsfresh`. Then, we used these features
    to train a classification model to predict whether an office was occupied at any
    given hour.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了如何通过利用`tsfresh`自动创建和选择时间序列数据中的特征。然后，我们使用这些特征来训练一个分类模型，以预测在任何给定小时办公室是否被占用。
- en: '`tsfresh` includes *wrapper* classes around its main functions, `extract_features`
    and `extract_relevant_features`, to make the creation and selection of features
    compatible with the scikit-learn pipeline.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '`tsfresh`在其主要函数`extract_features`和`extract_relevant_features`周围包含*包装器*类，以便特征创建和选择与scikit-learn管道兼容。'
- en: In this recipe, we will set up a scikit-learn pipeline that extracts features
    from time series using `tsfresh` and then trains a logistic regression model with
    those features to predict office occupancy.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将设置一个scikit-learn管道，使用`tsfresh`从时间序列中提取特征，然后使用这些特征训练一个逻辑回归模型来预测办公室的占用情况。
- en: How to do it...
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let’s begin by importing the necessary libraries and getting the dataset ready:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先导入必要的库并准备好数据集：
- en: 'Let’s import the required libraries and functions:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们导入所需的库和函数：
- en: '[PRE51]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Load the Occupancy Detection dataset described in the *Technical* *requirements*
    section:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载*技术要求*部分中描述的占用检测数据集：
- en: '[PRE52]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Create an empty DataFrame that contains the index of the target variable:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含目标变量索引的空DataFrame：
- en: '[PRE53]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now, let’s split the DataFrame from *step 3* and the target from *step 2* into
    training and test sets:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们将*步骤 3*中的DataFrame和*步骤 2*中的目标分割成训练集和测试集：
- en: '[PRE54]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Note
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '`X_train` and `X_test` will be used as containers to store the features created
    by `tsfresh`. They are needed for the functionality of `RelevantFeatureAugmenter()`
    that we will discuss in the coming steps.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '`X_train`和`X_test`将用作容器来存储`tsfresh`创建的特征。它们对于我们将要讨论的`RelevantFeatureAugmenter()`的功能是必需的。'
- en: 'Let’s create a dictionary specifying the features to extract from each time
    series (I defined the following features arbitrarily):'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个字典，指定从每个时间序列中提取的特征（我任意定义了以下特征）：
- en: '[PRE55]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: We discussed the parameters of this dictionary in the *Extracting different
    features from different time* *series* recipe.
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们在*从不同时间序列提取不同特征*菜谱中讨论了此字典的参数。
- en: 'Let’s set up `RelevantFeatureAugmenter()`, which is a wrapper around the `extract_relevant_features`
    function, to create the features specified in *step 5*:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们设置`RelevantFeatureAugmenter()`，这是一个围绕`extract_relevant_features`函数的包装器，以创建*步骤
    5*中指定的特征：
- en: '[PRE56]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Note
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To create all possible features, use the `FeatureAugmenter()` class instead
    in *step 6*.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建所有可能的特征，请在*步骤 6*中使用`FeatureAugmenter()`类。
- en: 'Let’s combine the feature creation instance from *step 6* with a logistic regression
    model in a scikit-learn pipeline:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将*步骤 6*中的特征创建实例与逻辑回归模型结合到一个scikit-learn管道中：
- en: '[PRE57]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Now, let’s tell `RelevantFeatureAugmenter()` which dataset it needs to use
    to create the features:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们告诉`RelevantFeatureAugmenter()`它需要使用哪个数据集来创建特征：
- en: '[PRE58]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Let’s fit the pipeline, which will trigger the feature creation process, followed
    by the training of the logistic regression model:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们拟合管道，这将触发特征创建过程，然后训练逻辑回归模型：
- en: '[PRE59]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Now, let’s obtain predictions using the time series in the test set and evaluate
    the model’s performance through a classification report:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们使用测试集中的时间序列来获取预测，并通过分类报告评估模型性能：
- en: '[PRE60]'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We can see the output of *step* *10* here:'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以在这里看到*步骤* *10*的输出：
- en: '[PRE61]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The values of the classification report suggest that the extracted features
    are suitable for predicting whether the office is occupied at any given hour.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 分类报告的值表明，提取的特征适合预测在任何给定小时办公室是否被占用。
- en: How it works...
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we combined creating features from a time series with `tsfresh`
    with training a machine learning algorithm from the scikit-learn library in a
    pipeline.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将从时间序列创建特征与使用scikit-learn库训练机器学习算法的管道结合起来。
- en: The `tsfresh` library includes two wrapper classes around its main functions
    to make the feature creation process compatible with the scikit-learn pipeline.
    In this recipe, we used the `RelevantFeatureAugmenter()` class, which wraps the
    `extract_relevant_features` function to create and then select features from a
    time series.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '`tsfresh`库在其主要函数周围包含两个包装类，以使特征创建过程与scikit-learn管道兼容。在这个配方中，我们使用了`RelevantFeatureAugmenter()`类，它包装了`extract_relevant_features`函数，用于从时间序列创建并选择特征。'
- en: '`RelevantFeatureAugmenter()` works as follows; with `fit()`, it creates and
    selects features by using `extract_relevant_features`. The names of the selected
    features are then stored internally in the transformer. With `transform()`, `RelevantFeatureAugmenter()`
    creates the selected features from the time series.'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '`RelevantFeatureAugmenter()`的工作方式如下；使用`fit()`，它通过`extract_relevant_features`创建并选择特征。所选特征的名称随后存储在转换器内部。使用`transform()`，`RelevantFeatureAugmenter()`从时间序列创建所选特征。'
- en: We overrode the default functionality of `RelevantFeatureAugmenter()` by passing
    a dictionary with the features we wanted to create to its `kind_to_fc_parameters`
    parameter. Therefore, with `transform()`, `RelevantFeatureAugmenter()` created
    the indicated features from the time series.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过传递一个包含我们想要创建的特征的字典到其`kind_to_fc_parameters`参数，覆盖了`RelevantFeatureAugmenter()`的默认功能。因此，使用`transform()`，`RelevantFeatureAugmenter()`从时间序列创建了指定的特征。
- en: To create all features from the time series, `tsfresh` includes the `FeatureAugmenter()`
    class, which has the same functionality as `RelevantFeatureAugmenter()`, but without
    the feature selection step.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 要从时间序列创建所有特征，`tsfresh`包括`FeatureAugmenter()`类，它具有与`RelevantFeatureAugmenter()`相同的功能，但没有特征选择步骤。
- en: Both `RelevantFeatureAugmenter()` and `FeatureAugmenter()` need two DataFrames
    to work. The first DataFrame contains the time-series data and the unique identifiers
    (we loaded this DataFrame in *step 2*). The second DataFrame should be empty and
    contain the unique identifiers *in its index* (we created this DataFrame in *step
    3*). The features are extracted from the first DataFrame with the time series
    (when applying `transform()`) and subsequently added to the second DataFrame,
    which is then used to train the logistic regression or obtain its predictions.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '`RelevantFeatureAugmenter()`和`FeatureAugmenter()`都需要两个DataFrame来工作。第一个DataFrame包含时间序列数据和唯一标识符（我们在*步骤2*中加载了这个DataFrame）。第二个DataFrame应该是空的，并包含其索引中的唯一标识符（我们在*步骤3*中创建了此DataFrame）。特征是从包含时间序列的第一个DataFrame中提取的（在应用`transform()`时），然后添加到第二个DataFrame中，然后用于训练逻辑回归或获取其预测。'
- en: Note
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The index of the empty DataFrame is used by `RelevantFeatureAugmenter()` and
    `FeatureAugmenter()` to identify the time series from which to extract the features.
    Hence, when applying `fit()` while passing `X_train`, features were extracted
    from time series whose `id` value was in the training set. After that, the model
    was evaluated by observing predictions made using the test set, which triggered
    the creation of features from time series whose `id` value was in `X_test`.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 空DataFrame的索引被`RelevantFeatureAugmenter()`和`FeatureAugmenter()`用于识别从中提取特征的时间序列。因此，在传递`X_train`时应用`fit()`，从`id`值在训练集中的时间序列中提取了特征。之后，通过观察使用测试集做出的预测来评估模型，这触发了从`id`值在`X_test`中的时间序列创建特征。
- en: When we used `fit()` on the pipeline, we created features from our raw time
    series and trained a logistic regression model with the resulting features. With
    the `predict()` method, we created features from the test set and obtained the
    predictions of the logistic regression based on those features.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在管道上使用`fit()`时，我们从原始时间序列创建了特征，并使用这些特征训练了一个逻辑回归模型。使用`predict()`方法，我们从测试集创建了特征，并基于这些特征获得了逻辑回归的预测。
- en: See also
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'For more details about the classes and procedures used in this recipe, visit
    the following links:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 如需了解此配方中使用的类和程序的更多详细信息，请访问以下链接：
- en: 'The `tsfresh` documentation: [https://tsfresh.readthedocs.io/en/latest/api/tsfresh.transformers.html#tsfresh.transformers.relevant_feature_augmenter.RelevantFeatureAugmenter](https://tsfresh.readthedocs.io/en/latest/api/tsfresh.transformers.html#tsfresh.transformers.relevant_feature_augmenter.RelevantFeatureAugmenter)'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tsfresh` 文档：[https://tsfresh.readthedocs.io/en/latest/api/tsfresh.transformers.html#tsfresh.transformers.relevant_feature_augmenter.RelevantFeatureAugmenter](https://tsfresh.readthedocs.io/en/latest/api/tsfresh.transformers.html#tsfresh.transformers.relevant_feature_augmenter.RelevantFeatureAugmenter)'
- en: 'A Jupyter notebook with a demo: [https://github.com/blue-yonder/tsfresh/blob/main/notebooks/02%20sklearn%20Pipeline.ipynb](https://github.com/blue-yonder/tsfresh/blob/main/notebooks/02%20sklearn%20Pipeline.ipynb)'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有演示的 Jupyter 笔记本：[https://github.com/blue-yonder/tsfresh/blob/main/notebooks/02%20sklearn%20Pipeline.ipynb](https://github.com/blue-yonder/tsfresh/blob/main/notebooks/02%20sklearn%20Pipeline.ipynb)
