<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Miscellaneous Patterns</h1>
                </header>
            
            <article>
                
<p class="mce-root">This chapter will cover a few miscellaneous design patterns that are quite useful in building larger applications. These patterns provide additional tools that we can leverage apart of the major patterns that we have seen so far from previous chapters. In a nutshell, we will explore three patterns, as follows:</p>
<ul>
<li class="mce-root"><span>The singleton type dispatch pattern</span></li>
<li class="mce-root"><span>The stubbing/mocking pattern</span></li>
<li><span>The functional pipes pattern</span></li>
</ul>
<p><span>The singleton type dispatch pattern leverages Julia's multiple dispatch feature, which allows you to add new functionalities without having to modify existing code. </span></p>
<p>The stubbing/mocking pattern can be utilized to test software components in isolation. It's also possible to test external dependencies without actually using them. It makes automated testing a lot easier.</p>
<p><span>The functional pipes pattern makes use of the pipe operator to represent a linear flow of execution. It is a way of programming that is adopted in many data processing pipelines. Some people find this concept of linear execution more intuitive. We will explore some examples about they may well with this pattern.</span></p>
<p><em>Let's get started!</em></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>The sample source code for this chapter is located at <a href="https://github.com/PacktPublishing/Hands-on-Design-Patterns-and-Best-Practices-with-Julia/tree/master/Chapter09">https://github.com/PacktPublishing/Hands-on-Design-Patterns-and-Best-Practices-with-Julia/tree/master/Chapter09</a>.</p>
<p>The code in this chapter has been tested in a Julia 1.3.0 environment.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Singleton type dispatch pattern</h1>
                </header>
            
            <article>
                
<p>Julia supports dynamic dispatch, which is a specific feature of its multiple dispatch system. Dynamic dispatch allows the program to dispatch to the proper function based on the type of the function arguments at runtime. If you are familiar with polymorphism in terms of object-oriented programming languages, then this concept is similar. In this section, we will explain what singleton types are and how they can be used to implement dynamic dispatch.</p>
<p>To begin, let's consider a desktop application use case where the system responds to user click events. Here is what the <strong>graphical user interface</strong> (<strong>GUI</strong>) may look like:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/976936e4-7904-447f-ab73-2015b753ec97.png" style="width:15.25em;height:11.83em;"/></p>
<p>We will try to implement the processing function with simple logic first and then see how it can be improved using the singleton type dispatch pattern.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Developing a command processor</h1>
                </header>
            
            <article>
                
<p>Our first attempt to implement a command process that may look similar to the following:</p>
<pre>function process_command(command::String, args)<br/>    if command == "open"<br/>        # open a file<br/>    elseif command == "close"<br/>        # close current file<br/>    elseif command == "exit"<br/>        # exit program<br/>    elseif command == "help"<br/>        # pops up a help dialog<br/>    else<br/>        error("bug - this should have never happened.")<br/>    end<br/>end</pre>
<p>The <kbd>process_command</kbd> function simply takes the command as a string. Then, depending on the value of the string, it will call the respective function. The <kbd>args</kbd> argument may be passed by the GUI code for additional information; for example, the path of the file that is being opened or closed.</p>
<p>There is nothing wrong with this code from a logical perspective, but it can be improved, as follows:</p>
<ul>
<li>The code contains a list of if-then-else statements. In this example, we only have to support four functions. In practice, we will probably have to handle many more functions. Having such a large if-then-else block makes the code very ugly and hard to maintain. </li>
<li>Whenever we need to add a new command, we have to modify this function to include a new condition.</li>
</ul>
<p>Fortunately, we can make it better using singleton types and dynamic dispatch. We'll go over that next.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding singleton types</h1>
                </header>
            
            <article>
                
<p>A singleton type is just a data type that is designed to have a single instance. In Julia, it can be implemented easily by defining a type without any field:</p>
<pre>struct OpenCommand end</pre>
<p>To create a single instance of such a data type, we can use the following default constructor:</p>
<pre>OpenCommand()</pre>
<p>Unlike in some object-oriented programming languages, this constructor returns exactly the same instance, even if you call it multiple times. In other words, it is already a singleton. We can prove this like so:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/95b2889b-a5f9-4df4-9277-c1b672422565.png" style="width:14.17em;height:9.42em;"/></p>
<p>After creating two instances of <kbd>OpenCommand</kbd>, we compare them using the <kbd>===</kbd> operator, which tells us that these two instances are indeed referring to the same object. Hence, we have achieved the creation of a singleton.</p>
<p>Moving on, we can take the same approach and create a singleton types for each command, that is, <kbd>CloseCommand</kbd>, <kbd>ExitCommand</kbd>, <kbd>HelpCommand</kbd>, and so on. Furthermore, we can also create a new abstract type called <kbd>AbstractCommand</kbd>, which can serve as the supertype for all these command types.</p>
<p>It seems exhaustively verbose that we have to create a new type for each command. A better way to handle this situation is to use parametric types. Since it's a fairly common use case, Julia predefines a type called <kbd>Val</kbd>. Let's take a look at it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using the Val parametric data type</h1>
                </header>
            
            <article>
                
<p><kbd>Val</kbd> is a parametric data type that is defined in the Julia Base package. Its purpose is to provide us with an easy way to dispatch using singleton types. The <kbd>Val</kbd> type is defined as follows:</p>
<pre>struct Val{x} end</pre>
<p class="mce-root">How do we create a singleton object? We can use the <kbd>Val</kbd> constructor and pass it any value. For example, we can create a singleton type that embeds a value of 1, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/d03674fd-7f84-4a68-bef0-c3bdc0a4dde2.png" style="width:8.17em;height:2.92em;"/></p>
<p>Let's confirm the data type of such an object:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/617825ba-704a-48c4-924b-19f835d9721d.png" style="width:11.33em;height:5.42em;"/></p>
<p>Here, we can see that <kbd>Val(1)</kbd> and <kbd>Val(2)</kbd> have their own types <span>–</span> <kbd>Val{1}</kbd> and <kbd>Val{2}</kbd>, respectively. Interestingly, the value being passed to the constructor ends up in the type signature. Again, we can prove that these are indeed singletons by calling the <kbd>Val</kbd> constructor twice and comparing their identities:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/66e95cb6-912d-47c4-805a-8373b30d7256.png" style="width:15.17em;height:5.92em;"/></p>
<p>As you can see, the <kbd>Val</kbd> constructor function can also accept a symbol as an argument. Note that <kbd>Val</kbd> can only accept data that is a bit type because it goes to the type signature. Most use cases involve the <kbd>Val</kbd> type with integers and symbols in the type parameter. If we try to create new <kbd>Val</kbd> objects with non-bits type, then we get an error, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/8efc1c0a-2188-4587-b5da-627cd0d6cc4c.png" style="width:36.25em;height:2.83em;"/></p>
<p>You may be wondering why we go through so much to talk about singleton types. This is because singleton types can be used for dynamic dispatch. Now that we know how to create singletons, let's learn how to utilize them for dispatch.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using singleton types with dynamic dispatch</h1>
                </header>
            
            <article>
                
<p>In Julia, function calls are dispatched according to the type of the arguments when the function is called. For a quick introduction to this mechanism, please refer to <a href="6c453014-3590-4a63-9d39-9bdd735185d5.xhtml">Chapter 3</a>, <em>Designing Functions and Interfaces.</em></p>
<p>Let's recall the use case that we presented earlier in this chapter about a command processor function. With a naive implementation, we have a large if-then-else block that dispatch to different functions according to the command string. Let's try to implement the same feature using singleton types.</p>
<p>For each command, we can define a function that takes a singleton type. For example, the signatures of the functions for the <kbd>Open</kbd> and <kbd>Close</kbd> events are as follows:</p>
<pre>function process_command(::Val{:open}, filename) <br/>    println("opening file $filename")<br/>end<br/><br/>function process_command(::Val{:close}, filename) <br/>    println("closing file $filename")<br/>end</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>We didn't have to specify any name for the first argument because we don't need to use it. However, we do specify the type of the first argument to be <kbd>Val{:open}</kbd> or <kbd>Val{:close}</kbd>. Given such a function signature, we can handle the <kbd>Open</kbd> event as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/c5b252b1-cce3-4177-b36e-c070da2415ad.png" style="width:21.00em;height:2.33em;"/></p>
<p>Basically, we create a singleton and pass it to the function. Because the type signature matches, Julia will dispatch to the function we just defined in the preceding screenshot. Now, assuming that we have defined all other functions, we can write the code for the main dispatcher as follows:</p>
<pre>function process_command(command::String, args...)<br/>    process_command(Val(Symbol(command)), args...)<br/>end</pre>
<p>Here, we simply convert the command into a symbol and then create a singleton type object by passing it to the <kbd>Val</kbd> constructor. At runtime, the proper <kbd>process_command</kbd> functions will be dispatched accordingly. Let's quickly test that out:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/84106eb5-0204-449a-838d-5ff6158c230b.png" style="width:19.92em;height:5.33em;"/></p>
<p><em>Fabulous!</em> Now, let's pause for a moment and think about what we have just achieved. In particular, we can make two observations:</p>
<ul>
<li>The main dispatcher function in the preceding screenshot no longer has an if-then-else block. It just utilizes dynamic dispatch to figure out which underlying function to call.</li>
<li>Whenever we need to add a new command, we can just define a new <kbd>process_command</kbd> <span>function with a new</span> <kbd>Val</kbd> <span>singleton. There is no change to the main dispatcher function anymore.</span></li>
</ul>
<p>It is possible to create your own parametric type rather than using the standard <kbd>Val</kbd> type. This can be achieved quite simply, as follows:</p>
<pre># A parametric type that represents a specific command<br/>struct Command{T} end<br/><br/># Constructor function to create a new Command instance from a string<br/>Command(s::AbstractString) = Command{Symbol(s)}()</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>The constructor function takes a string and creates a <kbd>Command</kbd> singleton object with a <kbd>Symbol</kbd> type parameter that is converted from the string. Having such a singleton type, we can define our dispatcher function and corresponding actions as follows:</p>
<pre># Dispatcher function<br/>function process_command(command::String, args...)<br/>    process_command(Command(command), args...)<br/>end<br/><br/># Actions<br/>function process_command(::Command{:open}, filename) <br/>    println("opening file $filename")<br/>end<br/><br/>function process_command(::Command{:close}, filename) <br/>    println("closing file $filename")<br/>end</pre>
<p>This style of code is fairly idiomatic in Julia programming <span>–</span> there is no conditional branch anymore since it is replaced by function dispatch. In addition, you also extend the functionality of a system by defining new functions, without the need to modify any existing code. This is a fairly useful characteristic when we need to extend functions from a third-party library. </p>
<p>Next, we will do some experiments and measure the performance of dynamic dispatch.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding the performance benefits of dispatch</h1>
                </header>
            
            <article>
                
<p>Using a singleton type is nice because we can avoid writing conditional branches. Another side benefit is that performance can be greatly improved. An interesting example can be found in the <kbd>ntuple</kbd> function from Julia's Base package.</p>
<p>The <kbd>ntuple</kbd> function is used to create a tuple of N elements by applying a function over the sequence of 1 to N. For example, we can create a tuple of even numbers as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/edba9bf7-adba-4e1c-8afe-decf81c3ecdd.png" style="width:18.83em;height:2.83em;"/></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The first argument is an anonymous function that doubles the value. Since we specified 10 in the second argument, it mapped over the range of 1 to 10 and gave us 2, 4, 6, ... 20. If we take a peek into the source code, we will find this interesting definition:</p>
<pre>function ntuple(f::F, n::Integer) where F<br/>    t = n == 0 ? () :<br/>        n == 1 ? (f(1),) :<br/>        n == 2 ? (f(1), f(2)) :<br/>        n == 3 ? (f(1), f(2), f(3)) :<br/>        n == 4 ? (f(1), f(2), f(3), f(4)) :<br/>        n == 5 ? (f(1), f(2), f(3), f(4), f(5)) :<br/>        n == 6 ? (f(1), f(2), f(3), f(4), f(5), f(6)) :<br/>        n == 7 ? (f(1), f(2), f(3), f(4), f(5), f(6), f(7)) :<br/>        n == 8 ? (f(1), f(2), f(3), f(4), f(5), f(6), f(7), f(8)) :<br/>        n == 9 ? (f(1), f(2), f(3), f(4), f(5), f(6), f(7), f(8), f(9)) :<br/>        n == 10 ? (f(1), f(2), f(3), f(4), f(5), f(6), f(7), f(8), f(9), f(10)) :<br/>        _ntuple(f, n)<br/>    return t<br/>end</pre>
<p>While the code is indented quite nicely, we can clearly see that it supports up to 10 elements by hard coding the short-circuit branches with the <kbd>?</kbd> and <kbd>:</kbd> ternary operators. If it's more than 10, then it calls another function to create the tuple:</p>
<pre>function _ntuple(f, n)<br/>    @_noinline_meta<br/>    (n &gt;= 0) || throw(ArgumentError(string("tuple length should be ≥ 0, got ", n)))<br/>    ([f(i) for i = 1:n]...,)<br/>end</pre>
<p>This <kbd>_ntuple</kbd> function is expected to perform poorly because it creates an array using comprehension and then the result is splatted into a new tuple. You may be very surprised by the performance benchmarking result when we compare the case of creating a 10-element tuple versus an 11-element tuple:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/d37679bc-bcb4-4bf7-9af2-e0fb7c398352.png" style="width:21.08em;height:8.50em;"/></p>
<p class="mce-root"/>
<p>The <kbd>ntuple</kbd> function is designed to perform optimally when the number of elements is small, that is, for 10 or fewer elements. It would be possible to change the <kbd>ntuple</kbd> function to hardcode more, but it would be too tedious to write the code, and the resulting code would be extremely ugly.</p>
<p>Perhaps a little more surprisingly, Julia actually comes with another variation of the same function while using the <kbd>Val</kbd> singleton type, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/0a146254-a816-4277-9f65-161d4f3b2dee.png" style="width:18.25em;height:8.67em;"/></p>
<p>There is literally no difference between 10 and 11 elements. In fact, even with 100 elements, the performance is quite reasonable (17 nanoseconds) compared to the non-<kbd>Val</kbd> version (820 nanoseconds). Let's take a look at how it is implemented. The following has been taken from the Julia source code:</p>
<pre># Using singleton type dynamic dispatch<br/># inferrable ntuple (enough for bootstrapping)<br/>ntuple(f, ::Val{0}) = ()<br/>ntuple(f, ::Val{1}) = (@_inline_meta; (f(1),))<br/>ntuple(f, ::Val{2}) = (@_inline_meta; (f(1), f(2)))<br/>ntuple(f, ::Val{3}) = (@_inline_meta; (f(1), f(2), f(3)))<br/><br/>@inline function ntuple(f::F, ::Val{N}) where {F,N}<br/>    N::Int<br/>    (N &gt;= 0) || throw(ArgumentError(string("tuple length should be ≥ 0, got ", N)))<br/>    if @generated<br/>        quote<br/>            @nexprs $N i -&gt; t_i = f(i)<br/>            @ncall $N tuple t<br/>        end<br/>    else<br/>        Tuple(f(i) for i = 1:N)<br/>    end<br/>end</pre>
<p>From the preceding code, we can see that there are a few functions being defined for tuples that have fewer than four elements. After that, the function uses a meta-programming technique to generate code on the fly. In this case, it uses a special construct that allows the compiler to choose between code generation and its generic implementation, which is represented in if-blocks and else-blocks in the code. Looking at how the <kbd>@generated</kbd>, <kbd>@nexprs</kbd>, and <kbd>@ncalls</kbd> macros work is out of the scope of this section, but you are encouraged to find out more from the Julia reference manual. </p>
<p>According to our preceding performance test, calling <kbd>ntuple</kbd> with <kbd>Val(100)</kbd> was quite fast, so it appears that the compiler has chosen the code generation path.</p>
<p>To summarize, we have learned how to use parametric types to create new singletons and create functions that are dispatched by these singleton types. We can apply this pattern whenever we need to handle such conditional branches.</p>
<p>Next, we will learn how to develop automated testing code effectively using stubs and mocks.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Stubbing/Mocking pattern</h1>
                </header>
            
            <article>
                
<p>Julia comes with excellent tools for building automated unit tests. When the programmer follows good design patterns and best practices, the software is likely going to be composed of many small functions that can be tested individually.</p>
<p>Unfortunately, certain test cases are more difficult to handle. They usually involve testing components that have specific dependencies that are awkward to be included in automated tests. Common issues include the following:</p>
<ul>
<li><strong>Performance</strong>: The dependency may be a time-consuming process.</li>
<li><strong>Cost</strong>: The dependency may incur a financial cost every time it is invoked.</li>
<li><strong>Randomness</strong>: The dependency may produce a different result every time it is invoked.</li>
</ul>
<p>Stubbing/Mocking is a common strategy to address these issues. In this section, we will look into how to apply stubs and mocks while testing Julia code.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">What are testing doubles?</h1>
                </header>
            
            <article>
                
<p>Before we get into the specifics about stubbing/mocking, it would be helpful to go over some industry-standard terminology. First of all, there is the concept of <em>testing doubles</em>. Interestingly, the term comes from a movie-making technique that's related to how stunts are filmed. When performing dangerous acts, a stuntman or stuntwoman replaces the actor or actress to perform the job. From a viewer's perspective, it would look like the original actor or actress was performing. Testing doubles are the same in the sense that a fake component is used in place of the real thing during testing.</p>
<p>There are multiple types of testing doubles, but the most useful ones are <em>stubs</em> and <em>mocks</em>, which we will focus on in this section. In object-oriented programming, these concepts are expressed in terms of classes and objects. In Julia, we will leverage the same terminology for functions. One benefit of working with functions is that we can focus all of our effort on testing a single thing.</p>
<p>A <strong>stub</strong> is a fake function that imitates the real function, also known as the <em>collaborator function</em>. Depending on what is required from the testing objectives, they can be as dumb as returning the same result all the time, or they can be a little smarter and return different values, depending on the input arguments. Regardless of how smart they are, return values are almost always hardcoded for consistency reasons. During testing, stubs replace the collaborator function when the <strong>function under test</strong> (<strong>FUT</strong>) is being exercised. When the FUT finishes its execution, we can determine the correctness of the returned value. This is called <em>state verification</em>. The interaction between these functions can be depicted as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/83731e39-751b-414f-a05c-d6d91115f015.png" style="width:35.08em;height:11.00em;"/></p>
<p>A <strong>mock</strong> is also a fake function that imitates the collaborator function. The difference between mocks and stubs is that a mock focuses on behavior verification. Rather than just examining the state of the FUT, mocks keep track of all the calls being made. It can be used to verify behavior, such as how many times the mock is expected to be called, the types and values of the arguments that the mock expected to be passed, <span>and so on</span>. This is called <em>behavior verification</em>. At the end of their execution, we can perform both state verification and behavior verification. <span>This is depicted as follows:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/f0022792-8675-41c0-a4da-970a06c2352f.png" style="width:32.83em;height:10.33em;"/></p>
<p>In the upcoming sections, we will focus on how to apply stubs and mocks in testing.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introducing the credit approval use case</h1>
                </header>
            
            <article>
                
<p>In this section, we'll introduce a sample use case related to credit approval. Suppose that you are developing a system that has the ability to open a new credit card account for a customer upon a successful background check. You may create a Julia module that has the following structure:</p>
<pre>module CreditApproval<br/><br/># primary function to open an account<br/>function open_account(first_name, last_name, email) end<br/><br/># supportive functions <br/>function check_background(first_name, last_name) end<br/>function create_account(first_name, last_name, email) end<br/>function notify_downstream(account_number) end<br/><br/>end</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Now, let's implement each of the functions. We'll start with the <kbd>check_background</kbd> function, which just logs the event and returns true, meaning that the background check is successful. Consider the following code:</p>
<pre># Background check. <br/># In practice, we would call a remote service for this.<br/># For this example, we just return true.<br/>function check_background(first_name, last_name)<br/>    println("Doing background check for $first_name $last_name")<br/>    return true<br/>end</pre>
<p>The <kbd>create_account</kbd> function is similar to this. In this case, the expected behavior is to return an account number, that is, an integer value that refers to the account that has just been created. For this example, we just return a hardcoded value of 1, as follows:</p>
<pre># Create an account.<br/># In practice, we would actually create a record in database.<br/># For this example, we return an account number of 1.<br/>function create_account(first_name, last_name, email)<br/>    println("Creating an account for $first_name $last_name")<br/>    return 1<br/>end</pre>
<p>The <kbd>notify_customer</kbd> function is supposed to send an email to the customer. For testing purposes, we will just log the event; nothing needs to be returned:</p>
<pre># Notify downstream system by sending a message.<br/># For this example, we just print to console and returns nothing.<br/>function notify_downstream(account_number)<br/>    println("Notifying downstream system about new account $account_number")<br/>    return nothing<br/>end</pre>
<p>Finally, the <kbd>open_account</kbd> function is as follows:</p>
<pre># Open a new account. <br/># Returns `:success` if account is created successfully.<br/># Returns `:failure` if background check fails.<br/>function open_account(first_name, last_name, email)<br/>    check_background(first_name, last_name) || return :failure<br/>    account_number = create_account(first_name, last_name, email)<br/>    notify_downstream(account_number)<br/>    return :success<br/>end</pre>
<p><span>This is the FUT in our example. The logic involves checking the background for a customer and creating an account and notifying downstream about the new account if the background check is successful.</span></p>
<p>Let's think about how to test the <kbd>open_account</kbd> function. The obvious thing that needs our attention is the background check code. More specifically, we expect two possible execution paths <span>–</span> when the background check is successful and when the background check fails. If we need to cover both cases, then we need to be able to simulate the different return values of the <kbd>check_background</kbd> function. We will do that next with a stub.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Performing state verification using stubs</h1>
                </header>
            
            <article>
                
<p>Our goal is to test the <kbd>open_account</kbd> function with two scenarios, where the <kbd>check_background</kbd> function returns either true or false. When a background check is successful, we expect <kbd>open_account</kbd> to return <kbd>:success</kbd>. Otherwise, it should return <kbd>:failure</kbd>.</p>
<p>Using our terminology, <kbd>open_account</kbd> is the function under test, while <kbd>check_background</kbd> is the collaborator function. It is a bit unfortunate that we can't really control how the collaborator function behaves. In practice, this function may even reach out to a background check service, the working of which we have little influence on. As a matter of fact, we would not want to call the remote service every single time that we test our software.</p>
<p><span>Now that we have copied from the original <kbd>CreditApproval</kbd> module to a new module called <kbd>CreditApprovalStub</kbd>, we can move on.</span></p>
<p>Since we are smart programmers, we can just create a stub that replaces the collaborator function. As functions are first-class in Julia, we can refactor the <kbd>open_account</kbd> function so that it can take any background check function from a keyword argument, as follows:</p>
<pre>function open_account(first_name, last_name, email; checker = check_background)<br/>    checker(first_name, last_name) || return :failure<br/>    account_number = create_account(first_name, last_name, email)<br/>    notify_downstream(account_number)<br/>    return :success<br/>end</pre>
<p>The new <kbd>checker</kbd> keyword argument takes a function that is used to perform a background check for a customer. We have set the default value to the original <kbd>check_background</kbd> function, so it should behave the same as before. Now, the function is more testable.</p>
<p>In our test suite, we can now exercise both execution paths, as follows:</p>
<pre>@testset "CreditApprovalStub.jl" begin<br/><br/># stubs<br/>check_background_success(first_name, last_name) = true<br/>check_background_failure(first_name, last_name) = false<br/><br/># testing<br/>let first_name = "John", last_name = "Doe", email = "jdoe@julia-is-awesome.com"<br/>    @test open_account(first_name, last_name, email, checker = check_background_success) == :success<br/>    @test open_account(first_name, last_name, email, checker = check_background_failure) == :failure<br/>end</pre>
<p>Here, we have created two stubs for background checks: <kbd>check_background_success</kbd> and <kbd>check_background_failure</kbd>. They return true and false to simulate a successful and failed background check, respectively. Then, when we need to test the <kbd>open_account</kbd> function, we can just pass these stub functions via the <kbd>checker</kbd> keyword argument.</p>
<p>Let's run the test now:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/3167bd6e-aff8-4ad0-8535-7952bbd8e10f.png" style="width:36.08em;height:13.25em;"/></p>
<p class="mce-root"/>
<p>At this point, we have only enabled the <kbd>check_background</kbd> function for stubbing in the <kbd>open_account</kbd> function. What if we want to do the same for the <kbd>create_account</kbd> and <kbd>notify_downstream</kbd> functions? It would be just as easy if we created two more keyword arguments and called it done. This isn't a bad option. However, you may not be very satisfied with the fact that we need to keep changing the code to make new tests. Furthermore, these keyword arguments were added merely for the sake of testing, rather than being a part of the call interface.</p>
<p>In the next section, we will explore the use of the Mocking package, which is an excellent tool for applying stubs and mocks without messing too much with the source code. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing stubs with the Mocking package</h1>
                </header>
            
            <article>
                
<p>A good alternative to implementing stubs is the Mocking package. This package is fairly straightforward to use. We will quickly go over how to use Mocking to apply the same stubs that we applied earlier. </p>
<p>In order to follow this exercise, you can copy the code from the original <kbd>CreditApproval</kbd> module to a new module called <kbd>CreditApprovalMockingStub</kbd>. Now, follow these steps:</p>
<ol>
<li>First, make sure that the Mocking package is installed. Then, modify the function under test, as follows:</li>
</ol>
<pre style="padding-left: 60px">using Mocking<br/><br/>function open_account(first_name, last_name, email)<br/>    @mock(check_background(first_name, last_name)) || return :failure<br/>    account_number = create_account(first_name, last_name, email)<br/>    notify_downstream(account_number)<br/>    return :success<br/>end </pre>
<p style="padding-left: 60px">The <kbd>@mock</kbd> macro creates an injection point where a stub can be applied, replacing the existing call to the collaborator function, that is, <kbd>check_background</kbd>. Under normal execution conditions, the <kbd>@mock</kbd> macro simply calls the collaborator function. </p>
<ol start="2">
<li>During testing, however, a stub can be applied. To achieve such behavior, we need to activate mocking at the top of the test script, as follows:</li>
</ol>
<pre style="padding-left: 60px">using Mocking<br/>Mocking.activate()</pre>
<ol start="3">
<li>Next, we can define stub functions using the <kbd>@patch</kbd> macro:</li>
</ol>
<pre style="padding-left: 60px">check_background_success_patch = <br/>    @patch function check_background(first_name, last_name)<br/>        println("check_background stub ==&gt; simulating success")<br/>        return true<br/>    end<br/><br/>check_background_failure_patch =<br/>    @patch function check_background(first_name, last_name)<br/>        println("check_background stub ==&gt; simulating failure")<br/>        return false<br/>    end</pre>
<p style="padding-left: 60px">The <kbd>@patch</kbd> macro can be placed right in front of a function definition. The function name must match the original collaborator function name. Likewise, the function arguments should match as well.</p>
<ol start="4">
<li>The <kbd>@patch</kbd> macro returns an anonymous function that can be applied to the call site in the FUT. To apply a patch, we use the <kbd>apply</kbd> function, as follows:</li>
</ol>
<pre style="padding-left: 60px"># test background check failure case<br/>apply(check_background_failure_patch) do <br/>    @test open_account("john", "doe", "jdoe@julia-is-awesome.com") == :failure<br/>end<br/><br/># test background check successful case<br/>apply(check_background_success_patch) do <br/>    @test open_account("peter", "doe", "pdoe@julia-is-awesome.com") == :success<br/>end</pre>
<p class="mce-root"/>
<ol start="5">
<li>The <kbd>apply</kbd> function takes the stub and applies it to everywhere that the collaborator function is called, as identified by the <kbd>@mock</kbd> macro in the function under test. Let's run the test from the REPL:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/f6b663ef-9c64-4867-aaf4-f0506f33e17f.png" style="width:31.00em;height:13.83em;"/></p>
<ol start="6">
<li>Now, let's make sure that the stubs are not applied under normal execution conditions. From the REPL, we can call the function directly:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/f8d540fc-ed9d-44e7-bf76-e8fa5ca204e4.png" style="width:35.75em;height:6.50em;"/></p>
<p><em>Fabulous!</em><em> </em>From the preceding output, we can see that the original collaborator function, <kbd>check_background</kbd>, was called. </p>
<p>Next, we will expand on the same idea and apply multiple stubs to the same function.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Applying multiple stubs to the same function</h1>
                </header>
            
            <article>
                
<p>In our example, the <kbd>open_account</kbd> function calls several dependent functions. It performs background checks for a customer, creates the account, and notifies downstream systems. Practically speaking, we may want to create stubs for all of them. How do we apply multiple stubs? The Mocking package supports this feature.</p>
<p>As usual, we would need to decorate the <kbd>open_account</kbd> function with a <kbd>@mock</kbd> macro for every function that we want to apply to our stubs. The following code shows this:</p>
<pre>function open_account(first_name, last_name, email)<br/>    @mock(check_background(first_name, last_name)) || return :failure<br/>    account_number = @mock(create_account(first_name, last_name, email))<br/>    @mock(notify_downstream(account_number))<br/>    return :success<br/>end</pre>
<p>Now, we're all set to create more stubs. For demonstration purpose, we will define another stub for the <kbd>create_account</kbd> function, as follows:</p>
<pre>create_account_patch = <br/>    @patch function create_account(first_name, last_name, email)<br/>        println("create_account stub is called")<br/>        return 314<br/>    end</pre>
<p>As part of its design, this stub function must return an account number. Therefore, we are just returning a fake value of 314. To test the scenario where both <kbd>check_background_success_patch</kbd> and <kbd>create_account_patch</kbd> are applied, we can pass them as an array to the <kbd>apply</kbd> function:</p>
<pre>apply([check_background_success_patch, create_account_patch]) do<br/>    @test open_account("peter", "doe", "pdoe@julia-is-awesome.com") == :success<br/>end</pre>
<p>Note that we have not provided any stub for the <kbd>notify_downstream</kbd> function. When a stub is not provided, the original collaborator function is used. Hence, we have all the flexibility we want in applying stub functions in our test suite. In the <kbd>open_account</kbd> function, since we have placed <kbd>@mock</kbd> in three different injection points, we can technically test eight different scenarios, for which each stub is enabled or disabled.</p>
<div class="packt_tip">The complexity of tests for the FUT increases exponentially by the number of branches and functions that are used inside the function. This is also one of the reasons why we want to write small functions. Due to this, it is a good idea to break down large functions into smaller ones so that they can be tested independently.</div>
<p>Using stubs, we can easily verify the expected return value for a function. A different approach is mocking, which shifts the focus to verifying the behavior of the FUT and its collaboration functions. We will look into that next. </p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Performing behavior verification using mocks</h1>
                </header>
            
            <article>
                
<p>Mocks are different from stubs <span>–</span> rather than just testing the return value of a function, we focus on testing expectations from the collaborator functions' perspective. What kind of activities does a collaborator function expect? Here are some examples for our use case:</p>
<ul>
<li>From the <kbd>check_background</kbd> function's perspective, was it called only once for each <kbd>open_account</kbd> call?</li>
<li>From the <kbd>create_account</kbd> function's perspective, was it called when a background check was successful?</li>
<li>From the <span><kbd>create_account</kbd> function's perspective, was it not called when the background check failed?</span></li>
<li>From the <kbd>notify_account</kbd> function's perspective, was it called with an account number that is greater than 0?</li>
</ul>
<p>The process to set up a mock-enabled test involves four main steps:</p>
<ol>
<li>Set up the mock functions that will be used during the test.</li>
<li>Establish the expectations for the collaborator functions.</li>
<li>Run the tests.</li>
<li>Verify the expectations that we set earlier.</li>
</ol>
<p>Now, let's try to develop our own mock test. Here, we will exercise the success path for opening a new account. In this case, we can expect the <kbd>check_background</kbd>, <kbd>create_account</kbd>, and <kbd>notify_downstream</kbd> functions to be called exactly once. Also, we can expect that the account number being passed to the <kbd>notify_downstream</kbd> function should be a number greater than 1. Keeping this information in mind, we will create a let-block with bound variables to track everything that we want to test against our expectations:</p>
<pre>let check_background_call_count  = 0,<br/>    create_account_call_count    = 0,<br/>    notify_downstream_call_count = 0,<br/>    notify_downstream_received_proper_account_number = false<br/><br/>    # insert more code here...<br/>end</pre>
<p>The first three variables will be used to track the number of calls to the three mocks that we are about to create. Also, the last variable will be used to record whether the <kbd>notify_downstream</kbd> function received a proper account number during the test. Within this let-block, we will implement the four steps we outlined previously. Let's define the mock functions first:</p>
<pre>check_background_success_patch = <br/>    @patch function check_background(first_name, last_name)<br/>        check_background_call_count += 1<br/>        println("check_background mock is called, simulating success")<br/>        return true<br/>    end</pre>
<p>Here, we just increment the <kbd>check_background_call_count</kbd> counter within the mock function so that we can keep track of how many times the mock function is called. Similarly, we can define the <kbd>create_account_patch</kbd> mock function in the same way:</p>
<pre>create_account_patch = <br/>    @patch function create_account(first_name, last_name, email)<br/>        create_account_call_count += 1<br/>        println("create account_number mock is called")<br/>        return 314<br/>    end</pre>
<p>The last mock function, <kbd>notify_downstream_patch</kbd>, covers two expectations. Not only does it keep track of the number of calls, but it also verifies that the account number being passed is proper and, if so, updates the Boolean flag. The following code shows this:</p>
<pre>notify_downstream_patch = <br/>    @patch function notify_downstream(account_number)<br/>        notify_downstream_call_count += 1<br/>        if account_number &gt; 0<br/>            notify_downstream_received_proper_account_number = true<br/>        end<br/>        println("notify downstream mock is called")<br/>        return nothing<br/>    end</pre>
<p>The second step is to establish our expectation formally. This can be defined as a simple function, as follows:</p>
<pre>function verify()<br/>    @test check_background_call_count  == 1<br/>    @test create_account_call_count    == 1<br/>    @test notify_downstream_call_count == 1<br/>    @test notify_downstream_received_proper_account_number<br/>end</pre>
<p>The <kbd>verify</kbd> function includes a set of expectations, formally defined as regular Julia tests. Now, we are ready to exercise our test by applying all three mock functions:</p>
<pre>apply([check_background_success_patch, create_account_patch, notify_downstream_patch]) do<br/>    @test open_account("peter", "doe", "pdoe@julia-is-awesome.com") == :success<br/>end</pre>
<p>Finally, as the very last step, we will test against our expectation. It is simply a call to the <kbd>verify</kbd> function that we defined earlier:</p>
<pre>verify()</pre>
<p>Now, we are ready to run the mock test. The respective results are as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/cf26ccee-e303-4386-88c2-d76e934bee99.png" style="width:27.00em;height:10.92em;"/></p>
<p>The result statistics show five test cases in total and all of them passed. Four out of the five tests came from the <kbd>verify</kbd> function for behavior verification, while one came from the state verification for the return value of the <kbd>open_account</kbd> function.</p>
<p>As you can see, mocks are quite different from stub because they are used to perform both behavior and state verifications. </p>
<p>Next, we will look into a pattern that's related to how data pipelines can be built more intuitively.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Functional pipes pattern</h1>
                </header>
            
            <article>
                
<p>Sometimes, when building an application, we face a large problem that requires complex calculations and data transformation. Using structured programming techniques, we can<span> </span>often break down the large problem into medium-sized problems and then break these down further into small-sized problems. When a problem is small enough, we can write functions to tackle each problem individually. </p>
<p class="mce-root"/>
<p>Of course, these functions do not work in isolation <span>–</span> it is more likely that the results of one function will feed into another function. In this section, we will explore the functional pipes pattern, which allows data to be passed seamlessly through a data pipeline. This is not uncommon in functional programming languages but is seen less in Julia. Nevertheless, we will take a look and see how it can be done.</p>
<p>First, we will go over a sample use case related to downloading recent Hacker News stories for analysis. Then, we will progressively refactor the code into using the functional pipes pattern. Let's go!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introducing the Hacker News analysis use case</h1>
                </header>
            
            <article>
                
<p class="mce-root">Hacker News is a popular online forum that's used by software developers. The topics on this forum are usually related to technology, but not always. The stories are ranked according to the number of votes by users, respective timeliness, and other factors. Every story has a score associated with it.</p>
<p>In this section, we will develop a program that retrieves the top stories from Hacker News and calculates an average score of those stories. More information about the Hacker News API can be found in the following GitHub repository: <a href="https://github.com/HackerNews/API">https://github.com/HackerNews/API</a>. Here, you can quickly go over the process of retrieving stories and details about each story.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Fetching top story IDs on Hacker News</h1>
                </header>
            
            <article>
                
<p>First, we will create a module called <kbd>HackerNewsAnalysis</kbd>. The very first function is going to retrieve the top stories from Hacker News. The code for this is as follows:</p>
<pre>using HTTP<br/>using JSON3<br/><br/>function fetch_top_stories()<br/>    url = "https://hacker-news.firebaseio.com/v0/topstories.json"<br/>    response = HTTP.request("GET", url)<br/>    return JSON3.read(String(response.body))<br/>end</pre>
<p>How does it work? Let's try it out:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/11d3946d-238d-48c9-8b75-665dafb60b92.png" style="width:33.00em;height:14.25em;"/></p>
<p>Let's take several steps and dissect the logic in this function. The top stories can be retrieved from a fixed URL. Here, we have used the HTTP package for fetching data from web services. The <kbd>HTTP.request</kbd> function call, if successful, returns an <kbd>HTTP.Message.Response</kbd> object. It is easy to verify from the REPL:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/b969a9a6-2a41-4438-a89d-f56e27943147.png" style="width:34.17em;height:9.00em;"/></p>
<p>So, how do we get the content from the <kbd>Response</kbd> object? It is available from the <kbd>body</kbd> field. As it turns out, the <kbd>body</kbd> field is just a byte array. To understand what the data means, we can convert it into a <kbd>String</kbd>, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/df1b8b94-11b8-47e7-8cba-c22c6f14acbe.png" style="width:34.75em;height:13.50em;"/></p>
<p>Judging from the output, we can see that it is in JSON format. We can also verify the same by visiting the web URL from a browser. From the API documentation, we know that the numbers represent story IDs from Hacker News. To parse the data into usable Julia data types, we can leverage the <kbd>JSON3</kbd><span> package:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/d256434e-2e77-4bad-ad88-f14c3eb11456.png" style="width:32.83em;height:14.75em;"/></p>
<p>The <kbd>JSON3.Array</kbd> object is a lazy version of an array. By design, JSON3 does not extract the value until you ask for it. We can use it as if it were a regular Julia array. For more information, you are encouraged to visit JSON3's documentation on GitHub: <a href="https://github.com/quinnj/JSON3.jl/blob/master/README.md">https://github.com/quinnj/JSON3.jl/blob/master/README.md</a>.</p>
<p>Now that we have an array of story IDs, we will develop the function for retrieving detailed information about a Hacker News story.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Fetching details about a story</h1>
                </header>
            
            <article>
                
<p>Given a story ID, we can retrieve information about the story using the <kbd>item</kbd> endpoint of the Hacker News API. Before we write the function, let's define a type to store the data:</p>
<pre>struct Story<br/>    by::String<br/>    descendants::Union{Nothing,Int}<br/>    score::Int<br/>    time::Int<br/>    id::Int<br/>    title::String<br/>    kids::Union{Nothing,Vector{Int}}<br/>    url::Union{Nothing,String}<br/>end</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The fields of a <kbd>Story</kbd> are designed according to the JSON schema documented on the Hacker News API website. Sometimes, a field may be unavailable for certain story types, in which case we will leave them as <kbd>nothing</kbd> in the object. These optional fields include <kbd>descendants</kbd>, <kbd>kids</kbd>, and <kbd>url</kbd>. Lastly, every story comes with a unique identifier <kbd>id</kbd>. </p>
<p>We need a constructor to create <kbd>Story</kbd> objects. Because JSON3 returns a dictionary-like object, we can just extract individual fields and pass them to the constructor. The constructor's function can be defined as follows:</p>
<pre># Construct a Story from a Dict (or Dict-compatible) object<br/>function Story(obj)<br/>    value = (x) -&gt; get(obj, x, nothing)<br/>    return Story(<br/>        obj[:by], <br/>        value(:descendants), <br/>        obj[:score], <br/>        obj[:time],<br/>        obj[:id], <br/>        obj[:title], <br/>        value(:kids), <br/>        value(:url))<br/>end</pre>
<p>Generally, we can extract the field from a <kbd>Dict</kbd> object using the index operator (square brackets). However, we need to handle the fact that some fields may be unavailable in the object. To avoid an unexpected <kbd>KeyError</kbd>, we can define a closure function called <kbd>value</kbd> for extracting a field or returning <kbd>nothing</kbd> when the key is not found in the object.</p>
<p>Now, let's take a look at the function for retrieving the details of a single story:</p>
<pre>function fetch_story(id)<br/>    url = "https://hacker-news.firebaseio.com/v0/item/$(id).json"<br/>    response = HTTP.request("GET", url)<br/>    return Story(JSON3.read(response.body))<br/>end</pre>
<p>Again, we retrieve the data using <kbd>HTTP.request</kbd>. After we receive the response, we can parse the data using JSON3 and construct a <kbd>Story</kbd> object accordingly. Here's how it works:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/4e8dfc3f-df1d-4b92-be7b-43656a6713d3.png" style="width:30.42em;height:6.75em;"/></p>
<p>Next, we will go over the main program for calculating the average score for the top N stories from Hacker News.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Calculating the average score for the top N stories</h1>
                </header>
            
            <article>
                
<p>Now that we have the ability to find the top stories and retrieve details about each story, we can create a new function to calculate an average score from the top N stories.</p>
<p>The <kbd>average_score</kbd> function is as follows:</p>
<pre>using Statistics: mean<br/><br/>function average_score(n = 10)<br/>    story_ids = fetch_top_stories()<br/>    println(now(), " Found ", length(story_ids), " stories")<br/><br/>    top_stories = [fetch_story(id) for id in story_ids[1:min(n,end)]]<br/>    println(now(), " Fetched ", n, " story details")<br/><br/>    avg_top_scores = mean(s.score for s in top_stories)<br/>    println(now(), " Average score = ", avg_top_scores)<br/><br/>    return avg_top_scores<br/>end</pre>
<p>There are three parts to this function:</p>
<ol>
<li>The first part finds the story IDs for top stories using the <kbd>fetch_top_stories</kbd> function. </li>
<li>Then, it retrieves details of the first <kbd>n</kbd> stories using the <kbd>fetch_story</kbd> function.</li>
<li>Finally, it calculates the average score from just those stories. Then, the average score is returned to the caller.</li>
</ol>
<p>In order to get the top <kbd>n</kbd> story IDs, we have chosen to use the index operator with the range <kbd>1:min(n,end)</kbd>. The <kbd>min</kbd> function is used to handle the case when <kbd>n</kbd> is greater than the size of the array.</p>
<p>Let's run the function and see what happens:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/58abdc3a-b34c-4f72-a864-1e982c6181cd.png" style="width:28.33em;height:6.83em;"/></p>
<p>From the result, we can see that the top <kbd>n</kbd> stories from Hacker News have an average score of 125.4. Note that you may get a different result since this number changes in real time as Hacker News users vote on their favorite stories.</p>
<p>Now that the use case has been established, we will leap forward and experiment with a different way of writing the same program. We call this style of programming <em>functional pipes</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding functional pipes</h1>
                </header>
            
            <article>
                
<p>In Julia, there is a pipe operator that can be used to pass data from one function to another. The concept is very simple. First, let's take a look at some examples.</p>
<p>In the previous section, we developed a <kbd>fetch_top_stories</kbd> function that's used to retrieve the current top stories from Hacker News. The return value is a <kbd>JSON3.Array</kbd> object that looks like an array of integers. Let's say we want to find the first story ID from the array. To do this, we can create a pipe operation, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/229a17c3-b359-4565-8ac5-a52df569fcea.png" style="width:16.92em;height:2.25em;"/></p>
<p>The pipe operator <kbd>|&gt;</kbd> is actually defined as a regular function in Julia, just like how <kbd>+</kbd> is defined as a function. Note that the preceding code is syntactically equivalent to the following:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a552b267-2943-49a1-b204-cde7e323d37f.png" style="width:17.17em;height:2.42em;"/></p>
<p>In addition, we can use multiple pipe operators in an expression. For example, we can retrieve the details of the first story by appending the <kbd>fetch_story</kbd> function at the end of the pipe:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a132a714-c648-4b1d-b6ee-276278dab5d3.png" style="width:35.42em;height:7.83em;"/></p>
<p>Because the data naturally flows from left to right, this is called a functional pipe pattern. This can be seen in the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/27f8a457-078e-41db-9389-2e0797fd83a6.png" style="width:43.33em;height:6.83em;"/></p>
<p>Note that every function that follows the piping operator must accept a single argument. In the preceding example, we can see the following:</p>
<ul>
<li>The <kbd>first</kbd> function takes an array and returns the first element.</li>
<li>The <kbd>fetch_story</kbd> function takes an integer of the story ID and returns a <kbd>Story</kbd> object.</li>
</ul>
<p>This is a very important point, so let me say this once again <span>–</span> <em>a functional pipe only feeds data to single-argument functions</em>. </p>
<p>We will learn about how to deal with this constraint later. For now, we will talk about a similar pattern where the syntax is written in reverse compared to functional pipes. This concept is called composability, and is a design technique that leads to highly reusable code.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Designing composable functions</h1>
                </header>
            
            <article>
                
<p>Sometimes, you may hear other Julia programmers talk about composability. What does that mean? </p>
<p>Composability is used to describe how easily functions can be assembled in different ways to achieve different results. Let's look at an analogy. I would say that Lego has a highly composable design. This is because almost every piece of Lego can be combined with any other piece of Lego, even if they have different shapes. For that reason, any kid can use Lego to build almost anything imaginable.</p>
<p>When it comes to system design, we can also keep composability in mind. If we could build our functions so that they can be composed easily, then we would have the flexibility to build many different things as well. In Julia, we can compose functions quite easily.</p>
<p class="mce-root"/>
<p>Let's use the same example from the previous section. We will create a new function called <kbd>top_story_id</kbd> that retrieves the first story ID from Hacker News:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/71baa434-d1e6-41b1-a26c-b6d9e27af910.png" style="width:23.58em;height:2.67em;"/></p>
<p>From the preceding code, we can see that the <kbd>top_story_id</kbd> function is defined as an anonymous function. The Unicode circle symbol (<kbd>∘</kbd>, input as <kbd>\circ</kbd>) is the compose operator in Julia. Unlike the pipe operator, we read the order of composed functions from right to left. In this case, we apply the <kbd>fetch_top_stories</kbd> function first and then apply the <kbd>first</kbd> function. Intuitively, we can use the <kbd>top_story_id</kbd> function as usual:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/9779ab10-0cc4-453a-a454-f61e49b7b1bf.png" style="width:10.67em;height:2.50em;"/></p>
<p>We can also compose multiple functions. To get the top story details, we can compose a new function called <kbd>top_story</kbd>, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/939b8ad1-ba1b-44b2-9bd4-162a7f7d8342.png" style="width:37.42em;height:11.83em;"/></p>
<p><em>This is great!</em> We have taken three random Lego blocks and built a new thing out of them. The <kbd>top_story</kbd> function is a new thing that is composed of three smaller blocks:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/ee9e6815-8318-412d-818f-e2d3ef5a1fe5.png" style="width:37.00em;height:9.17em;"/></p>
<p class="mce-root"/>
<p>Let's go one step further and create a new function to retrieve the title of the top story. Now, we run into a little trouble. No function that returns the story title from a <kbd>Story</kbd> object has been defined. However, we can solve this problem by utilizing the Accessors Pattern, which we described in <a href="6b565339-641f-444c-ad42-f8ff7998001b.xhtml">Chapter 8</a>, <em>Robustness Patterns</em>.</p>
<p>Let's define an accessor for the title field and then compose a new <kbd>top_story_title</kbd> function, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/6f93e148-a75d-446a-9543-3d52cb7e52fa.png" style="width:34.58em;height:5.67em;"/></p>
<p>This new function works beautifully, as expected:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/6045db13-c177-4561-a5ad-d1ea102a83d9.png" style="width:19.25em;height:2.75em;"/></p>
<p>The compose operator allows us to create a new function that is composed of several other functions. It is slightly more convenient than the pipe operator in the sense that the composed function doesn't need to be executed right away.  </p>
<p>Similar to functional pipes, the compose operator also expects single-argument functions. Having said that, it is also the reason why single-argument functions are more composable.</p>
<p>Next, we will go back and revisit the Hacker News <kbd>average_score</kbd> function and see how we can refactor the code into the functional pipe style.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Developing a functional pipe for the average score function</h1>
                </header>
            
            <article>
                
<p>First, let's recap on how the <kbd>average_score</kbd> function was written:</p>
<pre>function average_score(n = 10)<br/>    story_ids = fetch_top_stories()<br/>    println(now(), " Found ", length(story_ids), " stories")<br/><br/>    top_stories = [fetch_story(id) for id in story_ids[1:min(n,end)]]<br/>    println(now(), " Fetched ", n, " story details")<br/><br/>    avg_top_scores = mean(s.score for s in top_stories)<br/>    println(now(), " Average score = ", avg_top_scores)<br/><br/>    return avg_top_scores<br/>end</pre>
<p>Although the code looks quite decent and simple to understand, let me point out some potential issues:</p>
<ul>
<li>The top stories are retrieved via array comprehension syntax. The logic is a little busy and we won't be able to test this part of the code independently from the <kbd>average_score</kbd> function.</li>
<li>The <kbd>println</kbd> function is used for logging, but we seem to be replicating the code to display the current timestamp.</li>
</ul>
<p>Now, we will refactor the code. The logic is largely linear, which makes it a good candidate for functional pipes. Conceptually, this is what we think about the computation:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/c8f6a9fa-b301-47d9-b72e-17ba0d97f58b.png" style="width:50.50em;height:9.67em;"/></p>
<p>It would be nice to design a function that works like this:</p>
<pre>average_score2(n = 10) = <br/>    fetch_top_stories() |&gt; <br/>    take(n) |&gt; <br/>    fetch_story_details |&gt; <br/>    calculate_average_score</pre>
<p>This is our second version of the same function, so we have named it <kbd>average_score2</kbd>.</p>
<p>For now, we just ignore the logging aspect to keep it simple. We will come back to this later. Since we have already defined the <kbd>fetch_top_stories</kbd> function, we just have to develop the other three functions, as follows:</p>
<pre>take(n::Int) = xs -&gt; xs[1:min(n,end)]<br/><br/>fetch_story_details(ids::Vector{Int}) = fetch_story.(ids)<br/><br/>calculate_average_score(stories::Vector{Story}) = mean(s.score for s in stories)</pre>
<p class="mce-root"/>
<p>From the preceding code, we can see the following:</p>
<ul>
<li>The <kbd>take</kbd> function takes an integer, <kbd>n</kbd>, and returns an anonymous function that returns the first <kbd>n</kbd> elements from an array.</li>
<li>The <kbd>min</kbd> <span>function is used to ensure that it will take no more than the actual size of the array. </span></li>
<li>The <kbd>fetch_story_details</kbd> <span>function takes an array of story IDs and broadcasts the</span> <kbd>fetch_story</kbd> <span>function over them using the dot notation. </span></li>
<li>The <kbd>calculate_average_score</kbd> <span>function takes an array of <kbd>Story</kbd> objects and calculates the mean of the scores.</span></li>
</ul>
<p><span>As a quick reminder, all of these functions accept a single argument as input so that they can participate in the functional pipe operation.</span></p>
<p>Now, let's get back to logging. Logging plays a funny role in functional pipes. It is designed to produce side effects and do not affect the result of computation. It is <em>slippery</em> in the sense that it just returns the same data that it received from its input. Since the standard <kbd>println</kbd> function returns nothing, we cannot use it directly in a piping operation. Instead, we must create a logging function that is smart enough to print what we want and yet returns the same data that it was passed.</p>
<p>In addition, we want to be able to format the output using the data that passes through the system. For that reason, we can utilize the <kbd>Formatting</kbd> package. It contains a flexible and efficient formatting facility. Let's build our own logging function, as follows:</p>
<pre>using Formatting: printfmtln<br/><br/>logx(fmt::AbstractString, f::Function = identity) = x -&gt; begin<br/>    let y = f(x)<br/>        print(now(), " ")<br/>        printfmtln(fmt, y)<br/>    end<br/>    return x<br/>end</pre>
<p>The <kbd>logx</kbd> function takes a format string and a possible transformer function, <kbd>f</kbd>. It returns an anonymous function that passes the transformed value to the <kbd>printfmln</kbd> function. It also automatically prefixes the log with the current timestamp. Most importantly, this anonymous function returns the original value of the argument.</p>
<p>To see how this logging function works, we can play with a few examples:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/badbdf09-9008-486e-9c28-5178db123ad0.png" style="width:24.67em;height:11.08em;"/></p>
<p>In the first example shown in the preceding screenshot, the <kbd>logx</kbd> function was called with just a format string, so the input coming via the pipe will be used as-is in the log. The second example passes the <kbd>length</kbd> function as the second argument of <kbd>logx</kbd>. The <kbd>length</kbd> function is then used to transform the input value for logging purposes.</p>
<p>Putting this all together, we can introduce logging to our functional pipe in our new <kbd>average_score3</kbd> function, as follows:</p>
<pre>average_score3(n = 10) = <br/>    fetch_top_stories()                        |&gt; <br/>    logx("Number of top stories = {}", length) |&gt;<br/>    take(n)                                    |&gt; <br/>    logx("Limited number of stories = $n")     |&gt;<br/>    fetch_story_details                        |&gt; <br/>    logx("Fetched story details")              |&gt;<br/>    calculate_average_score                    |&gt; <br/>    logx("Average score = {}")</pre>
<p>Occasionally, functional pipes can make the code easier to understand. Because conditional statements are not allowed in a piping operation, the logic is always linear.</p>
<p>You may be wondering how to handle conditional logic in functional pipe design. We'll learn about this in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing conditional logic in functional pipes</h1>
                </header>
            
            <article>
                
<p>Since the logical flow is quite linear, how do we deal with conditional logic?</p>
<p class="mce-root"/>
<p>Suppose we want to determine the hotness of top stories by checking the average score against a threshold. If the average score is higher than 100, then it would be considered high; otherwise, it would be considered low. So, literally, we need an if-statement that determines what to execute next.</p>
<p>We can use dynamic dispatch to solve this problem. We are going to build this function from the bottom-up, as follows.</p>
<ol>
<li>Create the <kbd>hotness</kbd> function, which determines the hotness of the Hacker News site by score. It returns an instance of the <kbd>Val{:high}</kbd> or <kbd>Val{:low}</kbd> parametric type. The built-in <kbd>Val</kbd> data type is a convenient way to create new parametric types that can be used for dispatch purposes:</li>
</ol>
<pre style="padding-left: 60px">hotness(score) = score &gt; 100 ? Val(:high) : Val(:low)</pre>
<ol start="2">
<li>Create two <kbd>celebrate</kbd> functions with respect to the <kbd>Val</kbd> parametric types. They simply use the <kbd>logx</kbd> function to print some text. We call it with the value of <kbd>v</kbd> so that the hotness argument is passed downstream if we ever want to do more work after celebration:</li>
</ol>
<pre style="padding-left: 60px">celebrate(v::Val{:high}) = logx("Woohoo! Lots of hot topics!")(v)<br/>celebrate(v::Val{:low}) = logx("It's just a normal day...")(v)</pre>
<ol start="3">
<li>Build the <kbd>check_hotness</kbd> function, which uses a functional pipe pattern. It uses the <kbd>average_score3</kbd> function to calculate the average score. Then, it uses the <kbd>hotness</kbd> function to determine how to change the execution path. Finally, it calls the <kbd>celebrate</kbd> function via the multiple dispatch mechanism:</li>
</ol>
<pre style="padding-left: 60px">check_hotness(n = 10) =<br/>    average_score3(n) |&gt; hotness |&gt; celebrate</pre>
<p>Let's test this out:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/374a2225-7a96-4ded-8ff8-1cb54906358f.png" style="width:29.50em;height:8.75em;"/></p>
<p>This simple example demonstrates how conditional logic can be implemented in functional pipe design. Of course, in reality, we would have more complex logic than just printing something to the screen. </p>
<p>An important observation is that functional pipes only handle linear execution. Hence, whenever the execution splits conditionally, we would form a new pipe for each possible path. The following diagram depicts how an execution path may be designed with functional pipes. Each split of execution is enabled by dispatching over the type of a single argument:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/eea27711-3695-463d-8b04-e66e43f2f0e4.png" style="width:37.92em;height:18.00em;"/></p>
<p>Functional pipes look fairly simple and straightforward from a conceptual point of view. However, they are sometimes criticized for having to pass intermediate data between each component in the pipe, causing unnecessary memory allocation and slowness. In the next section, we will go over how to use broadcasting to overcome this issue.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Broadcasting along functional pipes</h1>
                </header>
            
            <article>
                
<p>In a data processing pipeline, we may encounter a situation where the functions can be fused together into a single loop. This is called <em>broadcasting </em>and it can be conveniently enabled by using the dot notation. Using broadcasting may make a huge performance difference for data-intensive applications.</p>
<p>Consider the following scenario, where two vectorized functions have already been defined, as follows:</p>
<pre>add1v(xs) = [x + 1 for x in xs]<br/>mul2v(xs) = [2x for x in xs]</pre>
<p>The <kbd>add1v</kbd> function takes a vector and increments all the elements by 1. Likewise, the <kbd>mul2v</kbd> function takes a vector and multiplies every element by 2. Now, we can combine the functions to create a new one that takes a vector and sends it down the pipe to <kbd>add1v</kbd> and subsequently <kbd>mul2v</kbd>:</p>
<pre>add1mul2v(xs) = xs |&gt; add1v |&gt; mul2v</pre>
<p>However, the <kbd>add1mul2v</kbd> function is not optimal from a performance perspective. The reason for this is that each operation must be fully completed and then passed to the next function. The intermediate result, while only needed temporarily, must be allocated in memory:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/c5a64914-0132-490a-bd82-f55aae4c0fcc.png" style="width:35.42em;height:6.42em;"/></p>
<p>As depicted in the preceding diagram, besides the input vector and the output vector, an intermediate vector must be allocated to hold the results from the <kbd>add1v</kbd> function.</p>
<p>In order to avoid the allocation of the intermediate results, we can utilize broadcasting. Let's create another set of functions that operate on individual elements rather than arrays, as follows:</p>
<pre>add1(x) = x + 1<br/>mul2(x) = 2x</pre>
<p>Our original problem still requires taking a vector, adding 1, and multiplying by 2 for every element. So, we can define such a function using the dot notation, as follows:</p>
<pre>add1mul2(xs) = xs .|&gt; add1 .|&gt; mul2</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The dot character right before the pipe operator indicates that the elements in <kbd>xs</kbd> will be broadcast to the <kbd>add1</kbd> and <kbd>mul2</kbd> functions, fusing the whole operation into a single loop. The data flow now looks more like the following:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/170e5aeb-9ac8-430c-ba2a-accbeb830d8a.png" style="width:34.67em;height:10.42em;"/></p>
<p>Here, the intermediate result becomes a single integer, eliminating the need for the temporary array. To appreciate the performance improvement we get from broadcasting, we can run a performance benchmark for the two functions, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/35b7e0a6-5e15-468b-a5f4-e2ff5a4f4a42.png" style="width:21.08em;height:10.83em;"/></p>
<p>As you can see, the broadcasting version ran twice as fast as the vectorized version in this scenario.</p>
<p>In the next section, we will review some considerations about using functional pipes.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Considerations about using functional pipes</h1>
                </header>
            
            <article>
                
<p>Before you get too excited about functional pipes, let's make sure that we understand the pros and cons of using functional pipes.</p>
<p>From a readability perspective, functional pipes can possibly make the code easier to read and easier to follow. This is because the logic has to be linear. On the contrary, some people may find it less intuitive and harder to read because the direction of computation is reversed as compared to nested function calls.</p>
<p class="mce-root"/>
<p>Functional pipes require single-argument functions, for which they can be easily composed with other functions. When it comes to functions that require multiple arguments, the general solution is to create <em>curried functions</em> <span>–</span> higher-order functions that fix an argument. Previously, we defined a <kbd>take</kbd> function that takes the first few elements from a collection:</p>
<pre>take(n::Int) = xs -&gt; xs[1:min(n,end)]</pre>
<p>The <kbd>take</kbd> function is a curried function made out of the <kbd>getindex</kbd> function (with a convenient syntax of using square brackets). The <kbd>getindex</kbd> function takes two arguments: a collection and a range. Because the number of arguments has been reduced to 1, it can now participate in the functional pipe.</p>
<p>On the flip side, we cannot utilize multiple dispatch for single-argument functions. This could be a huge disadvantage when you are handling logic that requires consideration of multiple arguments.</p>
<div class="packt_tip">While functions can only accept single arguments, it is possible to work around the issue by using tuples. Tuples have a composite type signature that can be used for dispatch. However, it's not recommended because it is quite awkward to define functions that take a single tuple argument rather than multiple arguments.</div>
<p>Nevertheless, functional pipes can be a useful pattern under certain circumstances. Any data-processing task that fits into a linear process style could be a good fit.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we learned about several patterns that can be quite useful in application design.</p>
<p>We started with the singleton type dispatch pattern. Using a command processor example, we successfully refactored the code from using if-then-else conditional statements to utilizing dynamic dispatch. We learned how to create new singleton types using the standard <kbd>Val</kbd> type or rolling our own parametric type.</p>
<p>Then, we switched gears and discussed how to implement automated testing effectively using the stubbing/mocking pattern. We took a simple use case of a credit approval process and experimented with a simple way to inject stubs using keyword arguments. We weren't very satisfied with the need to change the API for testing, so we leaned on the Mocking package for a more seamless approach. We then learned how to replace function calls with stubs and mocks in our test suite and how they work differently.</p>
<p class="mce-root"/>
<p>Finally, we learned about the functional pipes pattern and how it can make the code easier to read and follow. We learned about composability and how the compose operator works similarly to the pipe operator. We went over how to develop efficient code using functional pipes and broadcasting. Finally, we discussed the pros and cons of using functional pipes and other related considerations.</p>
<p><span>In the next chapter, we will turn around and look at some anti-patterns of Julia programming.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>What predefined data type can be used to conveniently create new singleton types?</li>
<li>What are the benefits of using singleton type dispatch?</li>
<li>Why do we want to create stubs?</li>
<li>What is the difference between mocking and stubbing?</li>
<li>What does composability mean?</li>
<li>What is the primary constraint of using functional pipes?</li>
<li>How are functional pipes useful?</li>
</ol>


            </article>

            
        </section>
    </body></html>