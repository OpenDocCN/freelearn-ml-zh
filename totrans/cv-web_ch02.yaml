- en: Chapter 2. Turn Your Browser into Photoshop
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章：将您的浏览器变成Photoshop
- en: It is likely that you have used Photoshop or at least heard about it. With a
    few clicks, you can easily modify an image, enhance it, or do some sort of preprocessing.
    Actually, it is not that hard to do using JavaScript. For most of the functions,
    you need only a couple lines of code. This chapter is mostly about filters and
    image segmentation. Here, we will discuss many popular techniques and their applications.
    Moreover, we will introduce a new JavaScript library—tracking.js ([http://trackingjs.com](http://trackingjs.com)).
    It is mostly used for object tracking applications, but there are many utilties,
    which are relevant to the topic. It is interesting to know how to use both JSFeat,
    which we introduced in the first chapter, and tracking.js libraries together.
    We will see how to do this. Besides, we will compare their advantages in terms
    of image filtering. We will start from the installation of the new library and
    then follow the filter examples from the easiest to the most exciting ones.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能你已经使用过Photoshop或者至少听说过它。只需几点击，你就可以轻松地修改图像、增强它或者进行某种预处理。实际上，使用JavaScript来做并不难。对于大多数功能，你只需要几行代码。这一章主要关于滤波和图像分割。在这里，我们将讨论许多流行的技术和它们的应用。此外，我们将介绍一个新的JavaScript库——tracking.js
    ([http://trackingjs.com](http://trackingjs.com))。它主要用于对象跟踪应用，但也有许多与主题相关的实用工具。了解如何同时使用我们在第一章中介绍的JSFeat库和tracking.js库是非常有趣的。我们将看到如何做到这一点。此外，我们还将比较它们在图像滤波方面的优势。我们将从新库的安装开始，然后从最简单的到最令人兴奋的滤波示例进行讲解。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Introducing the tracking.js library
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍tracking.js库
- en: What is filtering and how to use it
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 滤波是什么以及如何使用它
- en: Basic edge detection
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本边缘检测
- en: Advanced image processing
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级图像处理
- en: Introducing the tracking.js library
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍tracking.js库
- en: Let me give you a quick review of the tracking.js library. It is a great library
    that helps you with object detection, tracking, and image filtering. You can download
    it from [http://trackingjs.com](http://trackingjs.com). In this section, we will
    focus on the the installation of the library and how both JSFeat and tracking.js
    libraries can be used together.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我快速回顾一下tracking.js库。这是一个伟大的库，可以帮助你进行对象检测、跟踪和图像滤波。你可以从[http://trackingjs.com](http://trackingjs.com)下载它。在本节中，我们将关注库的安装以及如何同时使用JSFeat和tracking.js库。
- en: Installation and image loading
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装和图像加载
- en: 'Actually, the installation of a JavaScript library is straightforward. You
    just need to add a script file to your `<head>` tag:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，JavaScript库的安装非常直接。你只需要将一个脚本文件添加到你的`<head>`标签中：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The image loading is done using the context, just like we did in the previous
    chapter:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 图像加载是通过上下文完成的，就像我们在上一章中做的那样：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In contrast to the JSFeat library, tracking.js works with arrays and it does
    not create a new object for images (as you remember, it is the `matrix_t` function
    for JSFeat). In that case, how do we apply a simple operation? Here is an example
    of how to convert a colored image to grayscale:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 与JSFeat库相比，tracking.js使用数组，并且不会为图像创建新对象（如你所记得的，对于JSFeat来说，它是`matrix_t`函数）。在这种情况下，我们如何应用一个简单的操作？以下是将彩色图像转换为灰度的示例：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The last parameter indicates whether you need to return the array in the RGBA
    format (`true`) or just in one channel grayscale (`false`). In that case, we receive
    a `Uint8ClampedArray`, which we can easily convert to the `ImageData` constructor
    and put it to the canvas context:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个参数表示你是否需要以RGBA格式（`true`）返回数组，或者只以单通道灰度（`false`）返回。在这种情况下，我们收到一个`Uint8ClampedArray`，我们可以轻松地将其转换为`ImageData`构造函数并将其放入画布上下文：
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Simple, isn't it? The only thing we should mention is that for most operations,
    tracking.js returns `Float32Array`. Generally, you can cast it to the unsigned
    byte array without losing any information.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 简单，不是吗？我们唯一应该提到的是，对于大多数操作，tracking.js返回`Float32Array`。通常，你可以将其转换为无符号字节数组而不会丢失任何信息。
- en: Conversion between JSFeat and tracking.js image formats
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JSFeat和tracking.js图像格式之间的转换
- en: 'In some cases JSFeat and tracking.js libraries complement each other. To benefit
    from using them together, you will probably need to convert a JSFeat matrix to
    an array and vice versa. The critical difference is that, even for a grayscale
    data, tracking.js sometimes uses four array elements: R, G, B, A.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，JSFeat和tracking.js库可以相互补充。为了从它们一起使用中受益，你可能需要将JSFeat矩阵转换为数组，反之亦然。关键的区别是，即使是灰度数据，tracking.js有时也会使用四个数组元素：R、G、B、A。
- en: 'To use a matrix as an array, we just need to get `mat.data` from a matrix.
    In the following code, we load matrix from the `ImageData` constructor and pass
    `mat.data` to the tracking.js grayscale function:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要将矩阵用作数组，我们只需从矩阵中获取`mat.data`。在下面的代码中，我们从`ImageData`构造函数中加载矩阵，并将`mat.data`传递给tracking.js的灰度函数：
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Since the `mat` variable consists of four channels, we do not need to convert
    it to a different format. But what if we want to use the gray variable as a matrix?
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`mat`变量包含四个通道，我们不需要将其转换为不同的格式。但如果我们想将灰度变量用作矩阵呢？
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In that case, we skip G, B, A elements and add only R elements to the buffer.
    With that buffer, we then populate the one channel matrix.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们跳过G、B、A元素，只将R元素添加到缓冲区中。有了这个缓冲区，我们就可以填充一个通道矩阵。
- en: As you can see, the conversion process is simple, just keep in mind that tracking.js
    usually uses 4-channel data.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，转换过程很简单，只需记住tracking.js通常使用4通道数据。
- en: What is filtering and how to use it?
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是滤波以及如何使用它？
- en: Image filtering is always a powerful tool to use in your Computer Vision applications.
    It allows you to apply many exciting effects on your photos, such as image correction,
    noise reduction, embossing, and many more. Image filtering is actually a huge
    subpart of an image processing area. In this section, we will discuss the concepts
    of image filtering and talk about a basic operation—convolution, which is widely
    used in all Computer Vision applications. Furthermore, we will see how different
    effects, such as blurring, are achieved.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图像滤波始终是您在计算机视觉应用中使用的一个强大工具。它允许您在照片上应用许多令人兴奋的效果，例如图像校正、噪声减少、浮雕效果等。实际上，图像滤波是图像处理领域的一个巨大子部分。在本节中，我们将讨论图像滤波的概念，并讨论一个基本操作——卷积，它在所有计算机视觉应用中都被广泛使用。此外，我们将看到如何实现不同的效果，如模糊等。
- en: Image convolution
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图像卷积
- en: The core of most filtering operations is image convolution. With its understanding
    you will have the power to make your own image filters.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数滤波操作的核心是图像卷积。对其理解将赋予您制作自己图像滤波器的力量。
- en: The image convolution idea is that you want to apply to each pixel of the original
    image a transformation which is based on neighboring pixels. For this, you have
    a kernel—a simple 2D matrix, this is our transformation matrix. For each pixel
    of the original image, we take the sum of products, each product is just a new
    value of a resulting image. To compute it, each element of the kernel should be
    multiplied with the corresponding image pixel, where the center of the kernel
    must be multiplied with the current pixel of an image. The whole process is called
    convolution.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图像卷积的思路是您希望将基于邻近像素的变换应用到原始图像的每个像素上。为此，您有一个核——一个简单的2D矩阵，这是我们变换矩阵。对于原始图像的每个像素，我们取乘积之和，每个乘积只是结果图像的新值。为了计算它，核的每个元素应该乘以相应的图像像素，其中核的中心必须乘以图像的当前像素。整个过程称为卷积。
- en: To see a practical example of convolution, we should move to one of the most
    popular filters, it uses the **Gaussian kernel**. The filter itself is called
    a Gaussian filter (or Gaussian blur), and it is used for image smoothing, noise
    removing, and for edge detection. Most of the edge detection algorithms are sensitive
    to noise, using the Gaussian filter before the edge detection helps to remove
    unnecessary noise.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要看到一个卷积的实际例子，我们应该转向最受欢迎的过滤器之一，它使用**高斯核**。这个过滤器本身被称为高斯滤波器（或高斯模糊），它用于图像平滑、噪声去除以及边缘检测。大多数边缘检测算法对噪声敏感，在使用边缘检测之前使用高斯滤波有助于去除不必要的噪声。
- en: 'In the following figure, we present an example of convolution using the Gaussian
    kernel:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的图中，我们展示了使用高斯核进行卷积的例子：
- en: '![Image convolution](img/image00101.jpeg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图像卷积](img/image00101.jpeg)'
- en: 'From left to right: the Gaussian kernel, original matrix, and result matrix.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 从左到右：高斯核、原始矩阵和结果矩阵。
- en: 'To compute a value in the `(2, 2)` position of the result matrix, we do the
    convolution:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算结果矩阵中`(2, 2)`位置的值，我们进行卷积：
- en: '*(1*0 + 2*1 + 1*3 + 2*2 + 4*1 + 2*2 + 1*4 + 2*3 + 1*5) / 16 = 2*'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*(1*0 + 2*1 + 1*3 + 2*2 + 4*1 + 2*2 + 1*4 + 2*3 + 1*5) / 16 = 2*'
- en: See how the neighbors of the original matrix affect the result? Simply, a kernel
    matrix represents weights for the transformation process.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 看看原始矩阵的邻居如何影响结果？简单来说，核矩阵代表了变换过程的权重。
- en: The 2D convolution requires four loops to compute so, in that case, it is better
    not to use big kernels; otherwise, our filtering process will be too slow. Usually,
    in image processing, the kernels from *3x3* to *7x7* are used and, as we already
    mentioned, the kernel should have a center and the dimensions should be odd. There
    are methods to improve the performance of the convolution operation, and we will
    analyze one of them in the next section.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 2D卷积需要四个循环来计算，所以在这种情况下，最好不要使用大的核；否则，我们的滤波过程会太慢。通常，在图像处理中，使用的核大小从*3x3*到*7x7*，而且，正如我们已经提到的，核应该有一个中心，并且维度应该是奇数。有方法可以提高卷积操作的性能，我们将在下一节分析其中一种方法。
- en: The Gaussian filter and separate convolution
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高斯滤波和分离卷积
- en: 'Normally, we do not want to use heavy processing methods, such as applying
    a 2D kernel on an image. To speed up the computation, we can use a different approach.
    For most of the Computer Vision applications, we need only some sort of blurring
    and edge detection methods. In that case, the 2D kernels which are used there
    may be presented as two separate 1D kernels. This type of operation states that
    you can get the same result by applying two separate filters for rows and columns.
    The process is called separate convolution. Here is an example of the Gaussian
    kernel:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们不想使用像在图像上应用2D核这样重的处理方法。为了加快计算速度，我们可以使用不同的方法。对于大多数计算机视觉应用，我们只需要某种模糊和边缘检测方法。在这种情况下，那里使用的2D核可能表示为两个独立的1D核。这种操作表明，通过应用两个独立的行和列滤波器，你可以得到相同的结果。这个过程被称为分离卷积。以下是一个高斯核的例子：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The 2D matrix is separable if it can be presented as the outer product of two
    vectors.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个2D矩阵可以表示为两个向量的外积，那么这个2D矩阵是可分离的。
- en: Enough of the theory! We did not even see the Gaussian filter in work. Moreover,
    it is a good point to combine both JSFeat and tracking.js libraries.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 理论就到这里吧！我们甚至都没有在代码中看到高斯滤波的应用。此外，将JSFeat和tracking.js库结合起来是一个很好的点。
- en: 'To get a Gaussian kernel, we will use JSFeat:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取高斯核，我们将使用JSFeat：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You can get different sizes of a Gaussian kernel. The larger the size, the
    more blurry the image will be. Previously, we saw kernels only for the size of
    3 elements. Next, sigma specifies how wide your blur will be. If you set it to
    0, then the function calculates the optimal value for the given kernel size itself.
    The result is written to the `kernelArray` variable and, of course, the data type
    is float, since we are working with floating point operations. After executing
    the function, `kernelArray` will contain the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以得到不同大小的高斯核。核的大小越大，图像就会越模糊。之前，我们看到了只有3个元素大小的核。接下来，sigma指定了你的模糊宽度。如果你将其设置为0，那么函数会根据给定的核大小本身计算最优值。结果将写入`kernelArray`变量，当然，数据类型是浮点型，因为我们正在执行浮点运算。函数执行后，`kernelArray`将包含以下内容：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To get a full 2D kernel, we can use the `multiply` function, which we saw in
    the previous chapter:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取完整的2D核，我们可以使用之前章节中提到的`multiply`函数：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You can print `C` to see that it represents the Gaussian kernel.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以按`C`键来查看它代表高斯核。
- en: 'To use 1D kernels, we need to apply filters one by one to the original image.
    Unfortunately, JSFeat library does not provide you with such functionality. But
    tracking.js does! We will do this as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用1D核，我们需要逐个将滤波器应用到原始图像上。不幸的是，JSFeat库并没有提供这样的功能。但tracking.js提供了！我们将如下操作：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Remember that you need to set the last parameter to `true` if you want to return
    an RGBA array. Using the preceding code, we receive a blurred image, but what
    if we apply each filter separately? To see a clearer result, we need to choose
    a larger kernel size:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，如果你想返回一个RGBA数组，你需要将最后一个参数设置为`true`。使用前面的代码，我们得到了一个模糊的图像，但如果我们单独应用每个滤波器会怎样？为了得到更清晰的结果，我们需要选择一个更大的核大小：
- en: '![The Gaussian filter and separate convolution](img/image00102.jpeg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![高斯滤波和分离卷积](img/image00102.jpeg)'
- en: From left to right, we see a gray image and then we see a horizontal filter
    applied to it followed by a vertical filter for the the same gray image. Finally,
    if we apply both filters to the original image, as we did in the code, we will
    receive a blurred image like the last one. Eventually, the separate convolution
    works! It is really great to use that when you can present a 2D kernel as two
    1D kernels.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 从左到右，我们看到一个灰度图像，然后我们看到了对其应用的水平滤波器，接着是对同一灰度图像的垂直滤波器。最后，如果我们对原始图像应用这两个滤波器，就像我们在代码中所做的那样，我们将收到一个像最后一个那样的模糊图像。最终，分离卷积是有效的！当你能够将一个2D核表示为两个1D核时，使用它是非常棒的。
- en: 'It is worth mentioning that you can apply a Gaussian filter without using separate
    filters. For JSFeat library, see the following code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，你可以不使用单独的过滤器应用高斯滤波器。对于JSFeat库，请参阅以下代码：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'For the tracking.js, see the following code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 对于tracking.js，请参阅以下代码：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: For the last one, the result returns `Float32Array`. So if you want to display
    it properly, you need to convert it to the `Uint8ClampedArray` type. In addition,
    this is the first function you see which returns RGBA values, you cannot return
    only one channel array here.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 对于最后一个，结果返回`Float32Array`。所以如果你想正确显示它，你需要将其转换为`Uint8ClampedArray`类型。此外，这是你看到的第一个返回RGBA值的函数，你在这里不能只返回一个通道数组。
- en: 'Here are the examples with different kernel sizes:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是不同核大小的示例：
- en: '![The Gaussian filter and separate convolution](img/image00103.jpeg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![高斯滤波器和分离卷积](img/image00103.jpeg)'
- en: As you can see, the bigger the kernel size we take, the less the information
    we receive from an image and the blurrier it becomes.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们选择的核大小越大，从图像中获得的信息就越少，模糊效果也就越明显。
- en: The Gaussian filter is very useful when you need to reduce the image noise and
    reduce its details. Besides, it is commonly used to reduce the size of an image
    to get a better image approximation for a small size.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要减少图像噪声和细节时，高斯滤波器非常有用。此外，它通常用于减小图像大小，以获得小尺寸的更好图像近似。
- en: The box blur
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 盒式模糊
- en: There is a different blur method that needs to be discussed. Sometimes, you
    just need a rough approximation for the Gaussian Blur operation, a filter which
    is faster than Gaussian. Furthermore, you can sacrifice some blur quality. In
    that case, you can use the box blur filter.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种不同的模糊方法需要讨论。有时，你只需要对高斯模糊操作进行粗略的近似，一个比高斯更快的过滤器。此外，你可以牺牲一些模糊质量。在这种情况下，你可以使用盒式模糊过滤器。
- en: 'This is just a regular mean operation. It has a simple kernel for a diameter
    of 3 elements:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个常规的均值操作。它有一个简单的核，直径为3个元素：
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'So, for a diameter = *d* it will be like the following:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于直径 = *d* 它将如下所示：
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Where, *n = d * d* is the number of elements in a kernel.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，*n = d * d* 是核中元素的数量。
- en: 'It is simpler than Gaussian blur, but produces worse results. It is usually
    used as an approximation of a Gaussian blur. With the JSFeat library, it can be
    applied as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 它比高斯模糊简单，但产生的结果更差。它通常用作高斯模糊的近似。使用JSFeat库，它可以如下应用：
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here, we use a `kernelRadius` parameter instead of a diameter (matrix size).
    The same result can be achieved if you use the following:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们使用`kernelRadius`参数而不是直径（矩阵大小）。如果你使用以下方法，可以得到相同的结果：
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Separate filter vector with tracking.js library. Actually, a close result to
    the Gaussian filter can be achieved if you apply box blur three times with a three
    times smaller kernel. For example, if the Gaussian kernel size is equal to 33
    values, then the kernel size for the box blur should be 11 (or with radius = 5):'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 使用tracking.js库分离过滤器向量。实际上，如果你使用三倍较小的核进行三次盒式模糊，可以得到与高斯滤波器非常接近的结果。例如，如果高斯核大小等于33个值，那么盒式模糊的核大小应该是11（或半径
    = 5）：
- en: '![The box blur](img/image00104.jpeg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![盒式模糊](img/image00104.jpeg)'
- en: The first image has the Gaussian filter applied, the next has the box blur,
    which was applied thrice, and the last has the box blur with the same kernel size
    as the Gaussian kernel. Can you tell the difference between the first two images?
    It is really impossible to point it out. In addition, we see that the box blur
    for the last image removed more details and it produced an even worse result.
    Use the box blur filter only when you need to speed up the computation. But why
    is it so fast? There is magic in computing an integral image.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 第一张图像应用了高斯滤波器，下一张应用了三次盒式模糊，最后一张具有与高斯核相同核大小的盒式模糊。你能说出前两张图像之间的区别吗？这真的是不可能指出。此外，我们看到最后一张图像的盒式模糊去除了更多细节，并产生了更差的结果。只有在你需要加快计算速度时才使用盒式模糊过滤器。但为什么它这么快呢？计算积分图像中有着魔法。
- en: The integral image
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 整数图像
- en: Integrals are really useful when you need to compute image parameters quickly.
    For example, you can compute a filtered image for the box blur filter using the
    same amount of processing time for any kernel size. Isn't this amazing? Furthermore,
    it is also used for object detection.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要快速计算图像参数时，积分非常有用。例如，你可以使用任何核大小相同的时间量来计算盒式模糊过滤器的滤波图像。这不是很神奇吗？此外，它还用于对象检测。
- en: 'Computing the integral image is just a simple algorithm that generates sums
    of values in rectangular subsets of a matrix. For the JSFeat library, it can be
    computed like this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 计算积分图像只是一个简单的算法，它生成矩阵矩形子集中的值的总和。对于JSFeat库，它可以这样计算：
- en: '[PRE17]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The first matrix will contain the integral image or regular sums of image subsets,
    the next matrix will contain squares of those sums, and the last will contain
    the tilted integral image. The dimensions of all input matrices should be 1 pixel
    larger than the original. To display the result, we need to normalize it, for
    example, the bottom-right element will contain the sum of all pixel values in
    a matrix. We cannot display the result matrix because the largest possible pixel
    value of an image is 255\. We need to divide each pixel by the maximum value in
    a matrix and multiply it by 255\. Here is the result:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个矩阵将包含积分图像或图像子集的常规总和，下一个矩阵将包含这些总和的平方，最后一个将包含倾斜的积分图像。所有输入矩阵的尺寸应该比原始图像大1像素。为了显示结果，我们需要对其进行归一化，例如，右下角的元素将包含矩阵中所有像素值的总和。我们无法显示结果矩阵，因为图像可能的最大像素值是255。我们需要将每个像素除以矩阵中的最大值，并将其乘以255。以下是结果：
- en: '![The integral image](img/image00105.jpeg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![积分图像](img/image00105.jpeg)'
- en: We got what we expected—the maximum value is situated in the bottom-right corner
    for the first two matrices and the tilted result is presented in the last.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了预期的结果——对于前两个矩阵，最大值位于右下角，倾斜的结果在最后一个矩阵中呈现。
- en: 'You can apply a box blur using integrals by yourself! Here is a simple explanation
    of how to do this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以自己应用积分进行盒式模糊！以下是如何做到这一点的简单解释：
- en: '![The integral image](img/image00106.jpeg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![积分图像](img/image00106.jpeg)'
- en: 'We need to compute the sum in the ABCD rectangle. From the integral image,
    we know which sums are stored in *A*, *B*, *C*, and *D* positions. The sum of
    the rectangle can be computed using the following formula:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要计算ABCD矩形的总和。从积分图像中，我们知道哪些总和存储在 *A*、*B*、*C* 和 *D* 位置。矩形的总和可以使用以下公式计算：
- en: '*S = value in C – value in B – value in D + value in A*'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '*S = C中的值 – B中的值 – D中的值 + A中的值*'
- en: This can be applied to any size of the box blur filter, and this is why it is
    that fast. First, we need to compute an integral image, which is done in one loop
    over all pixel values and then we just calculate *S* for each pixel.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以应用于任何大小的盒式模糊过滤器，这也是它为什么这么快的原因。首先，我们需要计算一个积分图像，这是通过一次遍历所有像素值来完成的，然后我们只需为每个像素计算
    *S*。
- en: Basic edge detection
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本边缘检测
- en: For most Computer Vision applications, you process an image but you do not actually
    need to get all the information from it. For example, sometimes you just need
    to get the shape information to find an appropriate object. There is a huge topic
    in the field of image processing called **edge detection**. Methods related to
    that topic, search for points where pixel brightness changes dramatically. The
    extracted information aims to capture changes in the properties of an image. To
    understand the concept better and to see how the basic edge information can be
    extracted from an image, we will discuss different edge filters (or operators)
    starting with the Sobel filter.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数计算机视觉应用，你处理一个图像，但你实际上并不需要从它那里获取所有信息。例如，有时你只需要获取形状信息以找到合适的目标。在图像处理领域有一个巨大的主题叫做**边缘检测**。与该主题相关的方法，搜索像素亮度发生剧烈变化的位置。提取的信息旨在捕捉图像属性的变化。为了更好地理解这个概念，并看到如何从图像中提取基本边缘信息，我们将从Sobel滤波器开始讨论不同的边缘滤波器（或算子）。
- en: The Sobel filter
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Sobel滤波器
- en: The Sobel operator or Sobel filter is common and widely used. It helps to detect
    edges and transitions in images. The Sobel operator uses two kernels during the
    processing—one for horizontal changes in brightness and another for vertical changes.
    Its kernel values are focused not on the current pixel, but on it neighboring
    pixels.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Sobel算子或Sobel滤波器是常见且广泛使用的。它有助于检测图像中的边缘和过渡。Sobel算子在使用过程中使用两个核——一个用于亮度水平变化，另一个用于垂直变化。它的核值不是集中在当前像素上，而是集中在它的相邻像素上。
- en: 'Typical Sobel kernels look like this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的Sobel核看起来像这样：
- en: '[PRE18]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'As you see, the kernels can be decomposed of two separate filters, which is
    good in terms of processing time. You can run this filter in different ways in
    the libraries. Since tracking.js provides more functionality with separable filters,
    let''s see some of its examples:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，核可以分解为两个独立的过滤器，这在处理时间上是有好处的。你可以在库中以不同的方式运行这个过滤器。由于tracking.js提供了更多可分离过滤器的功能，让我们看看它的几个例子：
- en: '[PRE19]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This is another way of applying separable filters in tracking.js library. We
    use the `separableConvolve` function, whereas for the fourth and fifth parameters,
    it uses Sobel vectors.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一种在tracking.js库中应用可分离滤波器的方法。我们使用`separableConvolve`函数，而对于第四和第五个参数，它使用Sobel向量。
- en: 'The results are usually called derivatives, since they measure the change in
    values. We can compute these derivatives in JSFeat as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这些结果通常被称为导数，因为它们测量了值的改变。我们可以在JSFeat中如下计算这些导数：
- en: '[PRE20]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Where `imgGxGy` returns a 2-channel matrix, the first channel represents horizontal
    derivatives and the second represents vertical derivatives.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 其中`imgGxGy`返回一个2通道矩阵，第一个通道表示水平导数，第二个通道表示垂直导数。
- en: 'To get the result of a Sobel filter, we need to combine those two results;
    this is done using the following equation:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要得到Sobel滤波器的结果，我们需要将这两个结果结合起来；这是通过以下方程完成的：
- en: '[PRE21]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, the value variable is the value of each pixel and it is computed using
    pixel values from horizontal and vertical derivatives.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，value变量是每个像素的值，它是通过使用水平和垂直导数的像素值来计算的。
- en: 'To run the Sobel operator on an image directly you may prefer to use the following
    tracking.js function:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要直接在图像上运行Sobel算子，你可能更喜欢使用以下tracking.js函数：
- en: '[PRE22]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You need to remember that it returns an RGBA array and you need to normalize
    it, since it contains values larger than 255.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要记住它返回一个RGBA数组，并且你需要对其进行归一化，因为它包含大于255的值。
- en: 'The final result will look like this:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果将看起来像这样：
- en: '![The Sobel filter](img/image00107.jpeg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![Sobel滤波器](img/image00107.jpeg)'
- en: From left to right, we see the horizontal derivative, followed by the vertical
    derivative, and finally, the result after applying the Sobel filter. As you can
    see, the edges of the image have a good visualization. To get edges, not just
    changes in image pixels, we need to go a bit deeper. But let's discuss several
    other useful operators that you may want to use in edge detection.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 从左到右，我们看到水平导数，然后是垂直导数，最后是应用Sobel滤波器后的结果。正如你所见，图像的边缘有很好的可视化。要获取边缘，不仅仅是图像像素的变化，我们需要深入一点。但让我们讨论几个你可能想在边缘检测中使用的其他有用的算子。
- en: Other operators
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他算子
- en: 'You need to keep in mind that in Computer Vision, there is usually no perfect
    way for doing things. There are several operators that need to be mentioned; in
    some cases, they can produce better results than the Sobel filter. For example,
    the Prewitt operator:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要记住在计算机视觉中，通常没有做事情的最佳方式。有几个算子需要提及；在某些情况下，它们可以产生比Sobel滤波器更好的结果。例如，Prewitt算子：
- en: '[PRE23]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Sometimes, it is a good point to start from, but it averages the result value
    too much, remember the box blur filter? Compare it with the Gaussian Blur, where
    the center of a kernel has more weight. If we want to do that, the Sobel filter
    is preferred. However, sometimes you need to save just a bit more information
    for the center. And if you need that, you can use the Scharr filter:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，这是一个很好的起点，但它对结果值的平均太多，还记得盒子模糊滤镜吗？与高斯模糊相比，核的中心权重更大。如果我们想那样做，Sobel滤波器是首选。然而，有时你需要为中心保存更多一点的信息。如果你需要，你可以使用Scharr滤波器：
- en: '[PRE24]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: See, the centre has more weight now. Actually, it is difficult to see the difference
    between Prewitt, Sobel and Sharr operators, which is why we don't have visual
    examples here. It is better to perform some experiments and check which filter
    you need exactly.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 看看，中心现在权重更大了。实际上，很难区分Prewitt、Sobel和Sharr算子之间的差异，这就是为什么我们没有在这里提供视觉示例。最好是进行一些实验并检查你确切需要哪个滤波器。
- en: Advanced image processing
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级图像处理
- en: We talked about filters a lot, but they usually require only some sort of a
    matrix kernel and that is it. If you think that there should be more cool stuff
    in image filtering, you are totally right! First, we will see how to apply edge
    detection and how it works. In the final part, we will review the histogram equalization
    algorithm, which you probably use a lot if you have Photoshop.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们谈了很多关于滤镜的内容，但它们通常只需要某种矩阵核，就是这样。如果你认为图像滤波中应该有更多酷的东西，你完全正确！首先，我们将看到如何应用边缘检测以及它是如何工作的。在最后一部分，我们将回顾直方图均衡化算法，如果你经常使用Photoshop，你可能很熟悉它。
- en: The Canny edge detector
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Canny边缘检测器
- en: 'Let''s be curious; what if we threshold an image after the Sobel filter? Thresholding
    is done by iterating over all pixels of a grayscale image and checking whether
    the value exceeds the threshold value:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们保持好奇心；如果在Sobel滤波器之后对图像进行阈值处理会怎样？阈值处理是通过迭代灰度图像的所有像素并检查其值是否超过阈值值来完成的：
- en: '[PRE25]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This is what the threshold looks like. Just set the value to `255` if it is
    higher than the threshold and to `0` when it is not.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是阈值的样子。如果它高于阈值，就将其设置为`255`，如果不高于阈值，就设置为`0`。
- en: 'Here are several examples of different thresholds, each image having a higher
    threshold value than the previous:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些不同阈值的示例，每个图像的较高阈值值都比前一个高：
- en: '![The Canny edge detector](img/image00108.jpeg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![Canny边缘检测器](img/image00108.jpeg)'
- en: See? The higher the threshold we set, the fewer the edges we get. This is the
    first step of the Canny edge detection algorithm.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 看看？我们设置的阈值越高，得到的边缘就越少。这是Canny边缘检测算法的第一步。
- en: When you need to process only the most important information from images (it
    is usually shape information), and you need to remove unnecessary data without
    losing the important structural properties of an image, it is really smart to
    use an edge detector. Nowadays, the Canny edge detector is used most commonly.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要从图像中仅处理最重要的信息（通常是形状信息），并且需要在不丢失图像重要结构属性的情况下移除不必要的数据时，使用边缘检测器是非常聪明的。如今，Canny边缘检测器被最广泛使用。
- en: 'You can run the whole algorithm using the JSFeat library:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用JSFeat库运行整个算法：
- en: '[PRE26]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Before the start of a Canny algorithm we usually apply the Gaussian Blur to
    reduce the noise. The larger you choose the kernel size, the fewer edges and less
    noise you get. Lower and higher thresholds are usually chosen empirically.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始Canny算法之前，我们通常应用高斯模糊以减少噪声。您选择的核大小越大，得到的边缘和噪声就越少。通常情况下，会根据经验选择较低和较高的阈值。
- en: 'Under the lower threshold, all pixels (weak pixels) are removed (or suppressed)
    by the algorithm, as we did while playing with the Sobel filter thresholding.
    Pixels with a value larger than the higher threshold are marked as strong pixels.
    At the last stage, in addition to weak pixels, the algorithm suppress all pixels
    that are not connected to those strong pixels. As a rule of thumb, the smaller
    your lower threshold is, the more noise you get; the larger your higher threshold
    is, the fewer the object edges you receive. This is shown in the following figure:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在较低阈值下，算法会移除（或抑制）所有像素（弱像素），就像我们在玩Sobel滤波器阈值时做的那样。值大于较高阈值的像素被标记为强像素。在最后阶段，除了弱像素外，算法还会抑制所有未连接到那些强像素的像素。一般来说，您的较低阈值越小，您得到的噪声就越多；您的较高阈值越大，您得到的对象边缘就越少。这如图所示：
- en: '![The Canny edge detector](img/image00109.jpeg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![Canny边缘检测器](img/image00109.jpeg)'
- en: The algorithm detects object boundaries or edges. For the first image, we picked
    50 and 300 as the lower and higher thresholds, respectively, and we did not use
    the Gaussian Blur. For the second image, we applied the Gaussian filter. As a
    result, many noise edges were removed. If we increase the lower threshold to 100,
    then we will get the result from the third image. In that case, much of the noise
    data from the ground is removed. After increasing the higher threshold, we get
    fewer object edges, which can be seen in the fourth image. You can play with parameters;
    just remember that when you increase any of the thresholds, you receive less information.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法检测对象边界或边缘。对于第一张图像，我们分别选择了50和300作为较低和较高的阈值，并且没有使用高斯模糊。对于第二张图像，我们应用了高斯滤波器。结果，许多噪声边缘被移除。如果我们把较低阈值提高到100，那么我们将得到第三张图像的结果。在这种情况下，从地面移除了大部分噪声数据。在提高较高阈值后，我们得到较少的对象边缘，这在第四张图像中可以看到。您可以调整参数；只需记住，当您提高任何阈值时，您将获得较少的信息。
- en: The Canny filter returns only 0 for background and 255 for edges. The thickness
    of the edges is 1 pixel, which is really important when you need to find an object.
    The Canny edge detector is included in many Computer Vision frameworks and its
    application is very wide. It is adaptive to various environment conditions and
    it is very robust.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Canny滤波器只返回背景为`0`和边缘为`255`。边缘的厚度为1像素，这在需要找到对象时非常重要。Canny边缘检测器包含在许多计算机视觉框架中，其应用非常广泛。它对各种环境条件具有适应性，并且非常鲁棒。
- en: Histogram equalization
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 直方图均衡化
- en: 'Sometimes, you may want to improve the contrast of an image. It helps to see
    the details better when the important data is represented by close contrast values.
    The help comes from methods that operate with image histograms. An image histogram
    presents the number of pixels for each tonal value. Suppose you have an array,
    as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，您可能想要提高图像的对比度。当重要数据由接近的对比度值表示时，这有助于更好地查看细节。这种帮助来自于操作图像直方图的方法。图像直方图显示了每个色调值对应的像素数量。假设您有一个数组，如下所示：
- en: '[PRE27]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'You may want to redistribute values in case they have a better spreading of
    their intensity values. Let''s use the histogram equalization method which is
    provided by JSFeat:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想要重新分配值，如果它们有更好的强度值分布。让我们使用JSFeat提供的直方图均衡化方法：
- en: '[PRE28]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Histogram equalization is just a usual function. The first parameter indicates
    the input matrix, the second indicates the output equalized matrix. With our array,
    we receive as a result of equalization `equalized.data`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 直方图均衡化只是一个普通的函数。第一个参数表示输入矩阵，第二个参数表示输出均衡化矩阵。使用我们的数组，均衡化的结果是`equalized.data`：
- en: '[PRE29]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The histogram for the original (left) and equalized (right) arrays will look
    like this:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 原始（左）和均衡化（右）数组的直方图将看起来像这样：
- en: '[PRE30]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The equalize histogram function maps old values to the new ones, performing
    a better spread over the whole range of values, 0-255\. In the preceding example,
    most of the values were situated in the first part of the range, after the redistribution,
    the difference between values was increased. Visually, it helps to distinguish
    separate image objects.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 直方图均衡化函数将旧值映射到新值，在整个值域0-255上实现更好的分布。在先前的例子中，大多数值都位于值域的第一部分，重新分配后，值之间的差异增加了。从视觉上看，这有助于区分图像中的不同对象。
- en: 'Here is how it looks with an image:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是使用图像的示例：
- en: '![Histogram equalization](img/image00110.jpeg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![直方图均衡化](img/image00110.jpeg)'
- en: Left – the original grayscale image, and right – the image after equalization.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 左边 – 原始灰度图像，右边 – 均衡化后的图像。
- en: 'As you can see, the contrast is much better now and the image itself looks
    more impressive. The grass and plants got much darker and the constructions are
    brighter. The histograms for the input and output images are as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，对比度现在好多了，图像本身看起来也更引人注目。草地和植物变得更暗，建筑更亮。输入和输出图像的直方图如下：
- en: '![Histogram equalization](img/image00111.jpeg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![直方图均衡化](img/image00111.jpeg)'
- en: As a consequence of better spreading, histogram equalization makes the histogram
    a bit more flat, so the histogram values do not have such a clear center.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 由于更好的分布，直方图均衡化使得直方图略微平坦，因此直方图值没有如此清晰的中心。
- en: Histogram equalization can be used not only for a better image view, but also
    for extracting better image information. It is usually useful when an image background
    and foreground do not have high contrast. The biggest drawback that you should
    know is that this function may increase image noise. Anyway, histogram equalization
    is really useful, for example, in medical imaging and photo correction.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 直方图均衡化不仅可以用于更好的图像查看，还可以用于提取更好的图像信息。通常，当图像的背景和前景没有高对比度时很有用。你应该知道的最大缺点是，此函数可能会增加图像噪声。无论如何，直方图均衡化确实非常有用，例如在医学成像和照片校正中。
- en: Summary
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you first learned how to install tracking.js and how to use
    it with JSFeat. Now you know how to create your own image filters using the image
    convolution operation. Moreover, with separable convolutions, you can create much
    faster implementations of regular filters. When you need to reduce the noise,
    you will commonly use the Gaussian filter or the box blur filter when you need
    a faster algorithm. Edge detection? No problem, you can implement it and use it
    in your applications for both cases, when you need only the edges or the whole
    information about a change in image brightness. Last but not least, you now know
    how to improve the image contrast using histogram equalization. Look at how much
    we have covered in such a small chapter! There are many more topics on image processing
    and filtering, we just discussed a small portion of it. Eventually, we will be
    ready to use this knowledge in object detection.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你首先学习了如何安装tracking.js以及如何使用JSFeat。现在你知道如何使用图像卷积操作创建自己的图像过滤器。此外，通过可分离卷积，你可以创建常规滤波器的更快实现。当你需要减少噪声时，你通常会使用高斯滤波器或方框模糊滤波器，当你需要一个更快的算法时。边缘检测？没问题，你可以实现它并在你的应用程序中使用它，无论是你需要边缘还是整个关于图像亮度变化的详细信息。最后但同样重要的是，你现在知道如何使用直方图均衡化来提高图像对比度。看看我们在这样一个小章节中涵盖了多少内容！关于图像处理和滤波还有很多主题，我们只是讨论了其中的一小部分。最终，我们将准备好在目标检测中使用这些知识。
- en: In the next chapter, you will learn how to detect various objects using different
    tracking techniques, such as color detection and feature estimation. In addition,
    we will be able to create our own tracker. See you there!
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习如何使用不同的跟踪技术检测各种对象，例如颜色检测和特征估计。此外，我们还将能够创建自己的跟踪器。那里见！
