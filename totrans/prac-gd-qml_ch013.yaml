- en: Chapter 5
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第五章
- en: 'QAOA: Quantum Approximate Optimization Algorithm'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: QAOA：量子近似优化算法
- en: '*True optimization is the revolutionary contribution of modern* *research to
    decision processes.*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*真正的优化是现代研究对决策过程的革命性贡献。*'
- en: — George Dantzig
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: ——乔治·丹齐格
- en: The techniques that we have introduced in the two previous chapters already
    allow us to solve combinatorial optimization problems on quantum computers. Specifically,
    we have studied how to write problems using the QUBO formalism and how to use
    quantum annealers to sample approximate solutions. This is an important approach
    to quantum optimization, but it is not the only one.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前两章中介绍的技术已经使我们能够在量子计算机上解决组合优化问题。具体来说，我们已经研究了如何使用QUBO形式化来编写问题，以及如何使用量子退火器来采样近似解。这是量子优化的重要方法，但并非唯一的方法。
- en: In this chapter, we are going to show how the ideas that we have already explored
    can also be used on digital quantum computers. We will be using our beloved quantum
    circuits — with all their qubits, quantum gates, and measurements — to solve combinatorial
    optimization problems formulated in the QUBO framework.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将展示我们已探索的想法也可以用于数字量子计算机。我们将使用我们钟爱的量子电路——包括所有它们的量子比特、量子门和测量——来解决在QUBO框架中表述的组合优化问题。
- en: More concretely, we will be studying the famous **Quantum Approximate** **Optimization
    Algorithm** (**QAOA**), which is a gate-based algorithm that can be understood
    to be the counterpart to quantum annealing in the quantum circuit model. We will
    start by introducing all the theoretical concepts that are needed in order to
    understand this algorithm, then we will study the kind of circuits used in its
    implementation, and finally, we will explain how to run QAOA with both Qiskit
    and PennyLane.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，我们将研究著名的**量子近似** **优化算法**（**QAOA**），这是一个基于门的算法，可以理解为量子电路模型中量子退火的对应物。我们将首先介绍理解此算法所需的所有理论概念，然后研究其实施中使用的电路类型，最后解释如何使用Qiskit和PennyLane运行QAOA。
- en: After reading this chapter, you will understand how QAOA works, you will know
    how to design the circuits used in the algorithm, and you will be able to solve
    your own combinatorial optimization problems using QAOA in Qiskit and PennyLane.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读完本章后，您将了解QAOA的工作原理，您将知道如何设计算法中使用的电路，您将能够使用Qiskit和PennyLane中的QAOA来解决您自己的组合优化问题。
- en: 'The topics that we will cover in this chapter are the following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: From adiabatic computing to QAOA
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从绝热计算到QAOA
- en: Using QAOA with Qiskit
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Qiskit进行QAOA
- en: Using QAOA with PennyLane
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用PennyLane进行QAOA
- en: 5.1 From adiabatic computing to QAOA
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.1 从绝热计算到QAOA
- en: In this first section, we will introduce all the theoretical concepts that will
    allow us to understand QAOA in depth. But before that, we will give an intuitive
    idea of how QAOA works by studying its relationship with quantum annealing. Sounds
    interesting? Then keep on reading, because here we go!
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的第一部分，我们将介绍所有将使我们深入理解QAOA的理论概念。但在那之前，我们将通过研究其与量子退火的关系，给出QAOA工作原理的直观理解。听起来很有趣吗？那么继续阅读，因为这就开始了！
- en: 5.1.1 Discretizing adiabatic quantum computing
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.1.1 绝热量子计算的离散化
- en: 'In the previous chapter, we studied adiabatic quantum computing and its practical
    realization, quantum annealing, and we learned how to use them in order to obtain
    approximate solutions to combinatorial optimization problems. Both of these techniques
    relied on the adiabatic theorem. When we applied them, we used a time-dependent
    Hamiltonian that induced a continuous transformation of the state of a quantum
    system: from an initial state to a final state that — hopefully — has a big overlap
    with the solution to our problem.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们研究了绝热量子计算及其实际实现——量子退火，并学习了如何使用它们来获得组合优化问题的近似解。这两种技术都依赖于绝热定理。当我们应用它们时，我们使用了一个随时间变化的哈密顿量，它引起了一个量子系统状态的连续变换：从一个初始状态到一个最终状态——希望——与我们的问题的解有大的重叠。
- en: A natural question to ask is whether there is any sort of analog to this way
    of solving optimization problems for circuit-based quantum computers. At first
    sight, there is an apparent difficulty in this idea, because in the quantum circuit
    model we apply *instantaneous* operations — quantum gates — that change the state
    vector in discrete steps. How can we resolve this ”tension” between these discrete
    operations and the continuous evolution that we rely on for adiabatic quantum
    computing?
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一个自然的问题是要问是否存在某种类似的方法来解决基于电路的量子计算机的优化问题。乍一看，这个想法存在一个明显的困难，因为在量子电路模型中，我们应用**瞬时**操作——量子门——以离散步骤改变状态向量。我们如何解决这些离散操作和我们所依赖的绝热量子计算中的连续演化之间的“张力”呢？
- en: 'The answer is that we may **discretize** any continuous evolution, approximating
    it with a sequence of small, discrete changes. This process, sometimes called
    **Trotterization**, is the inspiration for the topic to which this chapter is
    devoted: the Quantum Approximate Optimization Algorithm — QAOA, for short.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是我们可能**离散化**任何连续演化，通过一系列小而离散的变化来近似它。这个过程有时被称为**Trotter化**，是本章所讨论的主题的灵感来源：量子近似优化算法——简称QAOA。
- en: QAOA was initially proposed [[37](ch030.xhtml#Xfarhi2014quantum)] as a **discretization**
    or Trotterization of adiabatic quantum computing with the goal of approximating
    the optimal solutions to combinatorial optimization problems. As you surely remember,
    the Hamiltonian that is used in adiabatic quantum computing — and in quantum annealing
    — is of the form
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: QAOA最初被提出[[37](ch030.xhtml#Xfarhi2014quantum)]作为一种**离散化**或Trotter化绝热量子计算的方法，目的是近似组合优化问题的最优解。正如你肯定记得的，在绝热量子计算——以及量子退火中——所使用的哈密顿量形式为
- en: '![H(t) = A(t)H_{0} + B(t)H_{1},](img/file546.png "H(t) = A(t)H_{0} + B(t)H_{1},")'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![H(t) = A(t)H_{0} + B(t)H_{1},](img/file546.png "H(t) = A(t)H_{0} + B(t)H_{1},")'
- en: with ![H_{0}](img/file545.png "H_{0}") and ![H_{1}](img/file544.png "H_{1}")
    two fixed Hamiltonians and ![A(t)](img/file623.png "A(t)") and ![B(t)](img/file624.png
    "B(t)") functions satisfying ![A(0) = B(T) = 1](img/file548.png "A(0) = B(T) =
    1") and ![A(T) = B(0) = 0](img/file549.png "A(T) = B(0) = 0"), where ![T](img/file74.png
    "T") is the total time of the process. It turns out that the evolution of the
    quantum system is governed by the famous time-dependent Schrödinger equation,
    and if you can solve it, you will have an expression for the state vector of your
    system at any moment ![t](img/file48.png "t") between ![0](img/file12.png "0")
    and ![T](img/file74.png "T").
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 其中![H_{0}](img/file545.png "H_{0}")和![H_{1}](img/file544.png "H_{1}")是两个固定的哈密顿量，![A(t)](img/file623.png
    "A(t)")和![B(t)](img/file624.png "B(t)")是满足![A(0) = B(T) = 1](img/file548.png "A(0)
    = B(T) = 1")和![A(T) = B(0) = 0](img/file549.png "A(T) = B(0) = 0")的函数，其中![T](img/file74.png
    "T")是整个过程的总时间。结果是，量子系统的演化由著名的时变薛定谔方程控制，如果你能解出它，你将得到在任何时刻![t](img/file48.png "t")（在![0](img/file12.png
    "0")和![T](img/file74.png "T")之间）的系统状态向量的表达式。
- en: However, to understand QAOA we don’t need to learn how to solve the Schrödinger
    equation — that was close, but we managed to dodge the bullet! All that we need
    to know is that, applying discretization, we can express the solution as a product
    of operators of the form
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，要理解QAOA，我们不需要学习如何解薛定谔方程——那几乎就是了，但我们设法避开了这个子弹！我们只需要知道的是，应用离散化，我们可以将解表示为形式为操作符的乘积
- en: '![e^{i\Delta t{({A(t_{c})H_{0} + B(t_{c})H_{1}})}}](img/file625.png "e^{i\Delta
    t{({A(t_{c})H_{0} + B(t_{c})H_{1}})}}")'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![e^{i\Delta t{({A(t_{c})H_{0} + B(t_{c})H_{1}})}}](img/file625.png "e^{i\Delta
    t{({A(t_{c})H_{0} + B(t_{c})H_{1}})}}")'
- en: applied to the initial state. Here, ![i](img/file49.png "i") is the imaginary
    unit, ![t_{c}](img/file626.png "t_{c}") is a fixed time point in ![\lbrack 0,T\rbrack](img/file547.png
    "\lbrack 0,T\rbrack"), and ![\Delta t](img/file627.png "\Delta t") is a small
    amount of time. The key idea is that in the interval ![\lbrack t_{c},t_{c} + \Delta
    t\rbrack](img/file628.png "\lbrack t_{c},t_{c} + \Delta t\rbrack") we assume that
    the Hamiltonian is constant and equal to ![H(t_{c}) = A(t_{c})H_{0} + B(t_{c})H_{1}](img/file629.png
    "H(t_{c}) = A(t_{c})H_{0} + B(t_{c})H_{1}"). Of course, the smaller ![\Delta t](img/file627.png
    "\Delta t") is, the better this approximation will be. It is also important to
    notice that ![e^{i\Delta t{({A(t_{c})H_{0} + B(t_{c})H_{1}})}}](img/file630.png
    "e^{i\Delta t{({A(t_{c})H_{0} + B(t_{c})H_{1}})}}") is a unitary transformation,
    just like the ones we studied in *Chapter* * [*1*](ch008.xhtml#x1-180001), *Foundations
    of Quantum Computing*. In fact, you surely remember that some of the quantum gates
    that we introduced in that chapter, such as ![R_{X}](img/file118.png "R_{X}"),
    ![R_{Y}](img/file119.png "R_{Y}"), and ![R_{Z}](img/file120.png "R_{Z}"), are
    also exponentials of some matrices. Using this discretization technique, if ![\left|
    \psi_{0} \right\rangle](img/file631.png "\left| \psi_{0} \right\rangle") is the
    initial state, then the final state can be approximated by*
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 应用于初始状态。在这里，![i](img/file49.png "i")是虚数单位，![t_{c}](img/file626.png "t_{c}")是![\lbrack
    0,T\rbrack](img/file547.png "\lbrack 0,T\rbrack")中的一个固定时间点，而![\Delta t](img/file627.png
    "\Delta t")是一小段时间。关键思想是在![\lbrack t_{c},t_{c} + \Delta t\rbrack](img/file628.png
    "\lbrack t_{c},t_{c} + \Delta t\rbrack")这个区间内，我们假设哈密顿量是常数，并且等于![H(t_{c}) = A(t_{c})H_{0}
    + B(t_{c})H_{1}](img/file629.png "H(t_{c}) = A(t_{c})H_{0} + B(t_{c})H_{1}")。当然，![\Delta
    t](img/file627.png "\Delta t")越小，这个近似越好。同样重要的是要注意，![e^{i\Delta t{({A(t_{c})H_{0}
    + B(t_{c})H_{1}})}}](img/file630.png "e^{i\Delta t{({A(t_{c})H_{0} + B(t_{c})H_{1}})}}")是一个幺正变换，就像我们在*第*
    * [*1*](ch008.xhtml#x1-180001)，*量子计算基础*这一章中研究的那样。实际上，你肯定记得我们在这章中介绍的一些量子门，例如![R_{X}](img/file118.png
    "R_{X}"), ![R_{Y}](img/file119.png "R_{Y}"), 和![R_{Z}](img/file120.png "R_{Z}"),也是某些矩阵的指数。使用这种离散化技术，如果![\left|
    \psi_{0} \right\rangle](img/file631.png "\left| \psi_{0} \right\rangle")是初始状态，那么最终状态可以近似为*
- en: '*![\left( {\prod\limits_{m = 0}^{p}e^{i\Delta t{({A(t_{m})H_{0} + B(t_{m})H_{1}})}}}
    \right)\left| \psi_{0} \right\rangle,](img/file632.png "\left( {\prod\limits_{m
    = 0}^{p}e^{i\Delta t{({A(t_{m})H_{0} + B(t_{m})H_{1}})}}} \right)\left| \psi_{0}
    \right\rangle,")'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*![\left( {\prod\limits_{m = 0}^{p}e^{i\Delta t{({A(t_{m})H_{0} + B(t_{m})H_{1}})}}}
    \right)\left| \psi_{0} \right\rangle,](img/file632.png "\left( {\prod\limits_{m
    = 0}^{p}e^{i\Delta t{({A(t_{m})H_{0} + B(t_{m})H_{1}})}}} \right)\left| \psi_{0}
    \right\rangle,")'
- en: where ![t_{m} = m\frac{\Delta t}{T}](img/file633.png "t_{m} = m\frac{\Delta
    t}{T}") and ![p = \frac{T}{\Delta t}](img/file634.png "p = \frac{T}{\Delta t}").
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 其中![t_{m} = m\frac{\Delta t}{T}](img/file633.png "t_{m} = m\frac{\Delta t}{T}")和![p
    = \frac{T}{\Delta t}](img/file634.png "p = \frac{T}{\Delta t}").
- en: In order to compute this state with a quantum circuit, we just need an additional
    approximation. As you know, for any real numbers ![a](img/file16.png "a") and
    ![b](img/file17.png "b"), it holds that ![e^{a + b} = e^{a}e^{b}](img/file635.png
    "e^{a + b} = e^{a}e^{b}"). The analogous identity for exponentials of matrices
    does not hold in general — unless the matrices commute. However, if ![\Delta t](img/file627.png
    "\Delta t") is small, then
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了用量子电路计算这个状态，我们只需要一个额外的近似。正如你所知，对于任何实数![a](img/file16.png "a")和![b](img/file17.png
    "b")，都成立![e^{a + b} = e^{a}e^{b}](img/file635.png "e^{a + b} = e^{a}e^{b}")。对于矩阵指数的类似恒等式通常不成立——除非矩阵对易。然而，如果![\Delta
    t](img/file627.png "\Delta t")很小，那么
- en: '![e^{i\Delta t{({A(t_{c})H_{0} + B(t_{c})H_{1}})}} \approx e^{i\Delta tA(t_{c})H_{0}}e^{i\Delta
    tB(t_{c})H_{1}},](img/file636.png "e^{i\Delta t{({A(t_{c})H_{0} + B(t_{c})H_{1}})}}
    \approx e^{i\Delta tA(t_{c})H_{0}}e^{i\Delta tB(t_{c})H_{1}},")'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![e^{i\Delta t{({A(t_{c})H_{0} + B(t_{c})H_{1}})}} \approx e^{i\Delta tA(t_{c})H_{0}}e^{i\Delta
    tB(t_{c})H_{1}},](img/file636.png "e^{i\Delta t{({A(t_{c})H_{0} + B(t_{c})H_{1}})}}
    \approx e^{i\Delta tA(t_{c})H_{0}}e^{i\Delta tB(t_{c})H_{1}},")'
- en: which is known as the **Lie-Trotter formula**.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是所谓的**李-特罗特公式**。
- en: Putting it all together, the final state of the adiabatic evolution can be approximated
    by
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有这些放在一起，绝热演化的最终状态可以近似为
- en: '![\prod\limits_{m = 0}^{p}e^{i\Delta tA(t_{m})H_{0}}e^{i\Delta tB(t_{m})H_{1}}\left|
    \psi_{0} \right\rangle,](img/file637.png "\prod\limits_{m = 0}^{p}e^{i\Delta tA(t_{m})H_{0}}e^{i\Delta
    tB(t_{m})H_{1}}\left| \psi_{0} \right\rangle,")'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![\prod\limits_{m = 0}^{p}e^{i\Delta tA(t_{m})H_{0}}e^{i\Delta tB(t_{m})H_{1}}\left|
    \psi_{0} \right\rangle,](img/file637.png "\prod\limits_{m = 0}^{p}e^{i\Delta tA(t_{m})H_{0}}e^{i\Delta
    tB(t_{m})H_{1}}\left| \psi_{0} \right\rangle,")'
- en: which is the inspiration for QAOA, as we will see in the next subsection.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是QAOA的灵感来源，我们将在下一小节中看到。
- en: '5.1.2 QAOA: The algorithm'
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.1.2 QAOA：算法
- en: The starting point and goal of QAOA are exactly the same as those of quantum
    annealing. We begin with a combinatorial optimization problem that we want to
    solve, and we encode it, as we learned in *Chapter* *[*3*](ch011.xhtml#x1-590003),
    *Working with Quadratic* *Unconstrained Binary Optimization Problems*, into an
    Ising Hamiltonian ![H_{1}](img/file544.png "H_{1}"). In order to find its ground
    state and solve our problem, we seek to apply a quantum state evolution similar
    to that of quantum annealing, but using a quantum circuit instead of a quantum
    annealer.*
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: QAOA 的起点和目标与量子退火完全相同。我们从一个我们想要解决的组合优化问题开始，正如我们在 *第* *[*3*](ch011.xhtml#x1-590003)，*处理二次无约束二进制优化问题*
    中所学的那样，将其编码成一个 Ising 哈密顿量 ![H_{1}](img/file544.png "H_{1}"). 为了找到其基态并解决我们的问题，我们寻求应用类似于量子退火的量子状态演化，但使用量子线路而不是量子退火器。
- en: '*In light of the discretization of adiabatic evolution that we obtained at
    the end of the previous subsection, the idea behind QAOA is simple. In order to
    simulate with a quantum circuit the evolution of a state under a time-dependent
    Hamiltonian, you only need to take an initial state ![\left| \psi_{0} \right\rangle](img/file631.png
    "\left| \psi_{0} \right\rangle") and then alternate for ![p](img/file141.png "p")
    times the application of the operators ![e^{i\gamma H_{1}}](img/file638.png "e^{i\gamma
    H_{1}}") and ![e^{i\beta H_{0}}](img/file639.png "e^{i\beta H_{0}}") for some
    values of ![\gamma](img/file127.png "\gamma") and ![\beta](img/file126.png "\beta").
    In the next subsection, by the way, we will see that the unitary transformations
    ![e^{i\gamma H_{1}}](img/file638.png "e^{i\gamma H_{1}}") and ![e^{i\beta H_{0}}](img/file639.png
    "e^{i\beta H_{0}}") can be implemented with just one-qubit and two-qubit quantum
    gates.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*鉴于我们在上一小节末获得的绝热演化的离散化，QAOA 的理念很简单。为了用量子线路模拟在时变哈密顿量下的状态演化，你只需要取一个初始状态 ![\left|
    \psi_{0} \right\rangle](img/file631.png "\left| \psi_{0} \right\rangle")，然后交替应用
    ![p](img/file141.png "p") 次操作符 ![e^{i\gamma H_{1}}](img/file638.png "e^{i\gamma
    H_{1}}") 和 ![e^{i\beta H_{0}}](img/file639.png "e^{i\beta H_{0}}")，其中 ![gamma](img/file127.png
    "\gamma") 和 ![beta](img/file126.png "\beta") 取某些值。顺便说一下，在下一小节中，我们将看到单位变换 ![e^{i\gamma
    H_{1}}](img/file638.png "e^{i\gamma H_{1}}") 和 ![e^{i\beta H_{0}}](img/file639.png
    "e^{i\beta H_{0}}") 可以仅用单量子比特和双量子比特量子门来实现。'
- en: What we are doing is, then, using a quantum circuit to prepare a state of the
    form
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的是，然后，使用量子线路来制备一种形式的状态
- en: '![e^{i\beta_{p}H_{0}}e^{i\gamma_{p}H_{1}}\ldots e^{i\beta_{2}H_{0}}e^{i\gamma_{2}H_{1}}e^{i\beta_{1}H_{0}}e^{i\gamma_{1}H_{1}}\left|
    \psi_{0} \right\rangle,](img/file640.png "e^{i\beta_{p}H_{0}}e^{i\gamma_{p}H_{1}}\ldots
    e^{i\beta_{2}H_{0}}e^{i\gamma_{2}H_{1}}e^{i\beta_{1}H_{0}}e^{i\gamma_{1}H_{1}}\left|
    \psi_{0} \right\rangle,")'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![e^{i\beta_{p}H_{0}}e^{i\gamma_{p}H_{1}}\ldots e^{i\beta_{2}H_{0}}e^{i\gamma_{2}H_{1}}e^{i\beta_{1}H_{0}}e^{i\gamma_{1}H_{1}}\left|
    \psi_{0} \right\rangle,](img/file640.png "e^{i\beta_{p}H_{0}}e^{i\gamma_{p}H_{1}}\ldots
    e^{i\beta_{2}H_{0}}e^{i\gamma_{2}H_{1}}e^{i\beta_{1}H_{0}}e^{i\gamma_{1}H_{1}}\left|
    \psi_{0} \right\rangle,")'
- en: where ![p \geq 1](img/file641.png "p \geq 1"). Usually, we collect all the coefficients
    in the exponents in two tuples ![\mathbf{\beta} = (\beta_{1},\ldots,\beta_{p})](img/file642.png
    "\mathbf{\beta} = (\beta_{1},\ldots,\beta_{p})") and ![\mathbf{\gamma} = (\gamma_{1},\ldots,\gamma_{p})](img/file643.png
    "\mathbf{\gamma} = (\gamma_{1},\ldots,\gamma_{p})") and we denote the whole state
    by ![\left| {\mathbf{\beta},\mathbf{\gamma}} \right\rangle](img/file644.png "\left|
    {\mathbf{\beta},\mathbf{\gamma}} \right\rangle").
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 ![p \geq 1](img/file641.png "p \geq 1"). 通常，我们将指数中的所有系数收集在两个元组 ![\mathbf{\beta}
    = (\beta_{1},\ldots,\beta_{p})](img/file642.png "\mathbf{\beta} = (\beta_{1},\ldots,\beta_{p})")
    和 ![\mathbf{\gamma} = (\gamma_{1},\ldots,\gamma_{p})](img/file643.png "\mathbf{\gamma}
    = (\gamma_{1},\ldots,\gamma_{p})") 中，并用 ![\left| {\mathbf{\beta},\mathbf{\gamma}}
    \right\rangle](img/file644.png "\left| {\mathbf{\beta},\mathbf{\gamma}} \right\rangle")
    表示整个状态。
- en: In QAOA, we choose a fixed value of ![p](img/file141.png "p") and we have some
    values for ![\mathbf{\beta}](img/file645.png "\mathbf{\beta}") and ![\mathbf{\gamma}](img/file646.png
    "\mathbf{\gamma}"). Instead of thinking of the values for ![\mathbf{\beta}](img/file645.png
    "\mathbf{\beta}") and ![\mathbf{\gamma}](img/file646.png "\mathbf{\gamma}") as
    small increments of time multiplied by intensity coefficients given by the functions
    ![A](img/file183.png "A") and ![B](img/file184.png "B"), as we did in the previous
    subsection, we’ll just consider them to be ”plain real numbers.” And this is where
    the magic kicks in. Since we are now free to choose their values as we see fit…why
    not choose the *best* possible values for them?
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在QAOA中，我们选择一个固定的![p](img/file141.png "p")值，并且我们有![\mathbf{\beta}](img/file645.png
    "\mathbf{\beta}")和![\mathbf{\gamma}](img/file646.png "\mathbf{\gamma}")的一些值。与我们在前一小节中那样，将![\mathbf{\beta}](img/file645.png
    "\mathbf{\beta}")和![\mathbf{\gamma}](img/file646.png "\mathbf{\gamma}")的值视为由函数![A](img/file183.png
    "A")和![B](img/file184.png "B")给出的强度系数乘以小时间增量，我们现在将它们视为“普通的实数”。这正是魔法开始发挥作用的地方。既然我们现在可以自由地选择它们的值，为什么不尽可能选择它们的最优值呢？
- en: 'But what does *best* mean here? Remember that we are just trying to find the
    ground state of ![H_{1}](img/file544.png "H_{1}"), so, for us, the lower the value
    of the energy ![\left\langle {\mathbf{\beta},\mathbf{\gamma}} \right|H_{1}\left|
    {\mathbf{\beta},\mathbf{\gamma}} \right\rangle](img/file647.png "\left\langle
    {\mathbf{\beta},\mathbf{\gamma}} \right|H_{1}\left| {\mathbf{\beta},\mathbf{\gamma}}
    \right\rangle"), the better. In this way, we have transformed our optimization
    problem into another one: finding the values ![\mathbf{\beta}](img/file645.png
    "\mathbf{\beta}") and ![\mathbf{\gamma}](img/file646.png "\mathbf{\gamma}") that
    minimize'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 但在这里，“**最佳**”意味着什么？请记住，我们只是在尝试找到![H_{1}](img/file544.png "H_{1}")的基态，因此，对我们来说，能量![\left\langle
    {\mathbf{\beta},\mathbf{\gamma}} \right|H_{1}\left| {\mathbf{\beta},\mathbf{\gamma}}
    \right\rangle](img/file647.png "\left\langle {\mathbf{\beta},\mathbf{\gamma}}
    \right|H_{1}\left| {\mathbf{\beta},\mathbf{\gamma}} \right\rangle")的值越低越好。这样，我们就将我们的优化问题转化为另一个问题：找到![\mathbf{\beta}](img/file645.png
    "\mathbf{\beta}")和![\mathbf{\gamma}](img/file646.png "\mathbf{\gamma}")的值，以使它们最小化。
- en: '![E(\mathbf{\beta},\mathbf{\gamma}) = \left\langle {\mathbf{\beta},\mathbf{\gamma}}
    \right|H_{1}\left| {\mathbf{\beta},\mathbf{\gamma}} \right\rangle.](img/file648.png
    "E(\mathbf{\beta},\mathbf{\gamma}) = \left\langle {\mathbf{\beta},\mathbf{\gamma}}
    \right|H_{1}\left| {\mathbf{\beta},\mathbf{\gamma}} \right\rangle.")'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![E(\mathbf{\beta},\mathbf{\gamma}) = \left\langle {\mathbf{\beta},\mathbf{\gamma}}
    \right|H_{1}\left| {\mathbf{\beta},\mathbf{\gamma}} \right\rangle.](img/file648.png
    "E(\mathbf{\beta},\mathbf{\gamma}) = \left\langle {\mathbf{\beta},\mathbf{\gamma}}
    \right|H_{1}\left| {\mathbf{\beta},\mathbf{\gamma}} \right\rangle.")'
- en: Notice that, since the values ![\mathbf{\beta}](img/file645.png "\mathbf{\beta}")
    and ![\mathbf{\gamma}](img/file646.png "\mathbf{\gamma}") are real and so is the
    energy ![E(\mathbf{\beta},\mathbf{\gamma})](img/file649.png "E(\mathbf{\beta},\mathbf{\gamma})"),
    what we have in our hands is the old problem of finding a minimum for a real-valued
    function with real inputs. There are many algorithms that we can apply for this,
    for instance, the famous **gradient descent algorithm**, which we will be using
    to train machine learning models in *Part* * [*III*](ch016.xhtml#x1-138000III),
    *A Match Made in Heaven:* *Quantum Machine Learning*, of this book. However, there
    is an important twist. As we know, the number of amplitudes needed to describe
    a state like ![\left| {\mathbf{\beta},\mathbf{\gamma}} \right\rangle](img/file644.png
    "\left| {\mathbf{\beta},\mathbf{\gamma}} \right\rangle") is exponential in the
    number of qubits that we are using. Thus, computing ![E(\mathbf{\beta},\mathbf{\gamma})](img/file649.png
    "E(\mathbf{\beta},\mathbf{\gamma})") may be difficult with just a classical computer.*
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于![\mathbf{\beta}](img/file645.png "\mathbf{\beta}")和![\mathbf{\gamma}](img/file646.png
    "\mathbf{\gamma}")是实数，能量![E(\mathbf{\beta},\mathbf{\gamma})](img/file649.png "E(\mathbf{\beta},\mathbf{\gamma})")也是实数，所以我们手头上的问题是寻找一个具有实数输入的实值函数的最小值的老问题。我们可以应用许多算法来解决这个问题，例如著名的**梯度下降算法**，我们将在本书的**第三部分**[*III*](ch016.xhtml#x1-138000III)，“天作之合：量子机器学习”中用它来训练机器学习模型。然而，这里有一个重要的转折。正如我们所知，描述像![\left|
    {\mathbf{\beta},\mathbf{\gamma}} \right\rangle](img/file644.png "\left| {\mathbf{\beta},\mathbf{\gamma}}
    \right\rangle")这样的状态的振幅数量是我们所使用的量子比特数量的指数级。因此，仅用经典计算机计算![E(\mathbf{\beta},\mathbf{\gamma})](img/file649.png
    "E(\mathbf{\beta},\mathbf{\gamma})")可能很困难。
- en: '*But it turns out that estimating values of ![E(\mathbf{\beta},\mathbf{\gamma})](img/file649.png
    "E(\mathbf{\beta},\mathbf{\gamma})") is something that we can do very efficiently
    with a quantum computer — at least when the number of terms in ![H_{1}](img/file544.png
    "H_{1}") is polynomial in the number of qubits, something that is usually the
    case in the problems we are interested in. In the next subsection, we will explain
    in detail how to compute that kind of estimation, but for now just keep in mind
    that, given some values ![\mathbf{\beta}](img/file645.png "\mathbf{\beta}") and
    ![\mathbf{\gamma}](img/file646.png "\mathbf{\gamma}"), we can rely on the quantum
    computer to compute ![E(\mathbf{\beta},\mathbf{\gamma})](img/file649.png "E(\mathbf{\beta},\mathbf{\gamma})").'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*但是，结果证明，使用量子计算机来估算![E(\mathbf{\beta},\mathbf{\gamma})](img/file649.png "E(\mathbf{\beta},\mathbf{\gamma})")的值是非常高效的——至少当![H_{1}](img/file544.png
    "H_{1}")中的项数是量子比特数的多项式时，这种情况通常是我们感兴趣的问题中的情况。在下一个小节中，我们将详细解释如何计算这种估算，但到目前为止，只需记住，给定一些![\mathbf{\beta}](img/file645.png
    "\mathbf{\beta}")和![\mathbf{\gamma}](img/file646.png "\mathbf{\gamma}")的值，我们可以依赖量子计算机来计算![E(\mathbf{\beta},\mathbf{\gamma})](img/file649.png
    "E(\mathbf{\beta},\mathbf{\gamma})")。*'
- en: Then, we can take any classical algorithm for function minimization and, whenever
    it needs to compute a value of the ![E](img/file327.png "E") function, we use
    a quantum computer to estimate it and we give that value back to the classical
    algorithm until it needs another of value ![E](img/file327.png "E"). At that moment,
    we again use the quantum computer to obtain it and so on and so forth, all until
    we meet the stopping criteria of the classical algorithm. This is what we call
    a **hybrid algorithm**, one where the classical and the quantum computer work
    in tandem to solve a problem. We will see this kind of interaction many more times
    throughout the book.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用任何用于函数最小化的经典算法，每当它需要计算![E](img/file327.png "E")函数的值时，我们就使用量子计算机来估算它，并将该值返回给经典算法，直到它需要另一个![E](img/file327.png
    "E")的值。在那个时刻，我们再次使用量子计算机来获得它，以此类推，直到我们遇到经典算法的停止标准。这就是我们所说的**混合算法**，在这种算法中，经典计算机和量子计算机协同工作来解决一个问题。在整个书中，我们将看到这种交互的许多例子。
- en: Once we have obtained the optimal values ![\mathbf{\beta^{\ast}}](img/file650.png
    "\mathbf{\beta^{\ast}}") and ![\mathbf{\gamma^{\ast}}](img/file651.png "\mathbf{\gamma^{\ast}}")
    for ![\mathbf{\beta}](img/file645.png "\mathbf{\beta}") and ![\mathbf{\gamma}](img/file646.png
    "\mathbf{\gamma}") — or, at least, an estimation of them — we can use the quantum
    computer once more in order to prepare the state ![\left| {\mathbf{\beta^{\ast}},\mathbf{\gamma^{\ast}}}
    \right\rangle](img/file652.png "\left| {\mathbf{\beta^{\ast}},\mathbf{\gamma^{\ast}}}
    \right\rangle"). This state should have a sizeable overlap with the ground state
    of ![H_{1}](img/file544.png "H_{1}"), so when we measure it in the computational
    basis, we will have a good chance of obtaining a string of zeros and ones that
    is a good solution to our original problem — the one encoded in ![H_{1}](img/file544.png
    "H_{1}") by using the techniques of *Chapter* * [*3*](ch011.xhtml#x1-590003),
    *Working with Quadratic Unconstrained* *Binary Optimization Problems*.*
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们获得了![\mathbf{\beta}](img/file645.png "\mathbf{\beta}")和![\mathbf{\gamma}](img/file646.png
    "\mathbf{\gamma}")的最优值![\mathbf{\beta^{\ast}}](img/file650.png "\mathbf{\beta^{\ast}}")和![\mathbf{\gamma^{\ast}}](img/file651.png
    "\mathbf{\gamma^{\ast}}")——或者至少是它们的估算值——我们就可以再次使用量子计算机来准备![\left| {\mathbf{\beta^{\ast}},\mathbf{\gamma^{\ast}}}
    \right\rangle](img/file652.png "\left| {\mathbf{\beta^{\ast}},\mathbf{\gamma^{\ast}}}
    \right\rangle")状态。这种状态应该与![H_{1}](img/file544.png "H_{1}")的基态有相当大的重叠，因此当我们以计算基对其进行测量时，我们有很大的机会获得一串零和一，这将是解决我们原始问题——使用*第*
    *3* *章* *[*3*](ch011.xhtml#x1-590003)*，*处理二次无约束* *二进制优化问题* *的技术编码在![H_{1}](img/file544.png
    "H_{1}")中*的一个很好的解决方案。
- en: '*We now have all the pieces of the puzzle, so let’s put them all together.
    The input to QAOA is an Ising Hamiltonian ![H_{1}](img/file544.png "H_{1}"), the
    ground state of which we wish to approximate because it encodes the solution to
    a certain combinatorial optimization problem. To that end, we consider the energy
    function ![E(\mathbf{\beta},\mathbf{\gamma})](img/file649.png "E(\mathbf{\beta},\mathbf{\gamma})")
    as defined before and we proceed to minimize it. For that, we choose ![p \geq
    1](img/file641.png "p \geq 1") and some initial values ![\mathbf{\beta_{0}}](img/file653.png
    "\mathbf{\beta_{0}}") and ![\mathbf{\gamma_{0}}](img/file654.png "\mathbf{\gamma_{0}}")
    that we shall use as the starting point for some classical minimization algorithm.
    Then, we run the minimization algorithm and, whenever it requests an evaluation
    of ![E](img/file327.png "E") on some points ![\mathbf{\beta}](img/file645.png
    "\mathbf{\beta}") and ![\mathbf{\gamma}](img/file646.png "\mathbf{\gamma}"), we
    use the quantum computer to prepare the state ![\left| {\mathbf{\beta},\mathbf{\gamma}}
    \right\rangle](img/file644.png "\left| {\mathbf{\beta},\mathbf{\gamma}} \right\rangle")
    and estimate its energy, and we return the value to the classical algorithm. We
    continue this process until the classical minimization algorithm stops, returning
    some optimal values ![\mathbf{\beta^{\ast}}](img/file650.png "\mathbf{\beta^{\ast}}")
    and ![\mathbf{\gamma^{\ast}}](img/file651.png "\mathbf{\gamma^{\ast}}"). As a
    final step, we use the quantum computer to prepare ![\left| {\mathbf{\beta^{\ast}},\mathbf{\gamma^{\ast}}}
    \right\rangle](img/file652.png "\left| {\mathbf{\beta^{\ast}},\mathbf{\gamma^{\ast}}}
    \right\rangle"). When we measure it, we obtain a — hopefully, good — approximate
    solution to our combinatorial problem.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们现在已经拥有了拼图的全部碎片，让我们把它们全部放在一起。QAOA的输入是一个伊辛哈密顿量 ![H_{1}](img/file544.png "H_{1}"),
    我们希望近似其基态，因为它编码了解决某个组合优化问题的解。为此，我们考虑之前定义的能量函数 ![E(\mathbf{\beta},\mathbf{\gamma})](img/file649.png
    "E(\mathbf{\beta},\mathbf{\gamma})") 并着手最小化它。为此，我们选择 ![p \geq 1](img/file641.png
    "p \geq 1") 和一些初始值 ![\mathbf{\beta_{0}}](img/file653.png "\mathbf{\beta_{0}}")
    和 ![\mathbf{\gamma_{0}}](img/file654.png "\mathbf{\gamma_{0}}")，我们将它们用作某些经典最小化算法的起点。然后，我们运行最小化算法，每当它请求在某个点
    ![E](img/file327.png "E") 和 ![\mathbf{\beta}](img/file645.png "\mathbf{\beta}")
    以及 ![\mathbf{\gamma}](img/file646.png "\mathbf{\gamma}") 上进行评估时，我们使用量子计算机来准备状态
    ![左| {\mathbf{\beta},\mathbf{\gamma}} \right\rangle](img/file644.png "\left| {\mathbf{\beta},\mathbf{\gamma}}
    \right\rangle") 并估计其能量，并将该值返回给经典算法。我们继续这个过程，直到经典最小化算法停止，返回一些最优值 ![\mathbf{\beta^{\ast}}](img/file650.png
    "\mathbf{\beta^{\ast}}") 和 ![\mathbf{\gamma^{\ast}}](img/file651.png "\mathbf{\gamma^{\ast}}")。作为最后一步，我们使用量子计算机来准备
    ![左| {\mathbf{\beta^{\ast}},\mathbf{\gamma^{\ast}}} \right\rangle](img/file652.png
    "\left| {\mathbf{\beta^{\ast}},\mathbf{\gamma^{\ast}}} \right\rangle")。当我们测量它时，我们获得一个——希望是——好的组合问题的近似解。'
- en: We have collected all these steps as pseudocode in the following algorithm.
    Notice that there are just two points at which the quantum computer is required.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这些步骤收集为以下算法的伪代码。请注意，只有在两个点上需要量子计算机。
- en: '**Algorithm 5.1** (QAOA)**.**'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**算法 5.1** (QAOA)**.**'
- en: Choose a value for ![p](img/file141.png "p")
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为 ![p](img/file141.png "p") 选择一个值
- en: Choose a starting set of values ![\mathbf{\beta} = (\beta_{1},\ldots,\beta_{p})](img/file642.png
    "\mathbf{\beta} = (\beta_{1},\ldots,\beta_{p})") and ![\mathbf{\gamma} = (\gamma_{1},\ldots,\gamma_{p})](img/file643.png
    "\mathbf{\gamma} = (\gamma_{1},\ldots,\gamma_{p})")
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 选择一组起始值 ![\mathbf{\beta} = (\beta_{1},\ldots,\beta_{p})](img/file642.png "\mathbf{\beta}
    = (\beta_{1},\ldots,\beta_{p})") 和 ![\mathbf{\gamma} = (\gamma_{1},\ldots,\gamma_{p})](img/file643.png
    "\mathbf{\gamma} = (\gamma_{1},\ldots,\gamma_{p})")
- en: '**while** the stopping criteria are not met **do**'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**当**停止条件未满足时 **do**'
- en: Prepare state ![\left| {\mathbf{\beta},\mathbf{\gamma}} \right\rangle](img/file644.png
    "\left| {\mathbf{\beta},\mathbf{\gamma}} \right\rangle")    ![\vartriangleright](img/file655.png
    "\vartriangleright") *This* *is done on the quantum computer!*
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 准备状态 ![左| {\mathbf{\beta},\mathbf{\gamma}} \right\rangle](img/file644.png "\left|
    {\mathbf{\beta},\mathbf{\gamma}} \right\rangle")    ![\vartriangleright](img/file655.png
    "\vartriangleright") *这是在量子计算机上完成的！*
- en: From measurements of ![\left| {\mathbf{\beta},\mathbf{\gamma}} \right\rangle](img/file644.png
    "\left| {\mathbf{\beta},\mathbf{\gamma}} \right\rangle"), estimate ![E(\mathbf{\beta},\mathbf{\gamma})](img/file649.png
    "E(\mathbf{\beta},\mathbf{\gamma})")
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 从 ![左| {\mathbf{\beta},\mathbf{\gamma}} \right\rangle](img/file644.png "\left|
    {\mathbf{\beta},\mathbf{\gamma}} \right\rangle") 的测量中估计 ![E(\mathbf{\beta},\mathbf{\gamma})](img/file649.png
    "E(\mathbf{\beta},\mathbf{\gamma})")
- en: Update ![\mathbf{\beta}](img/file645.png "\mathbf{\beta}") and ![\mathbf{\gamma}](img/file646.png
    "\mathbf{\gamma}") according to the minimization algorithm
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 根据最小化算法更新![β](img/file645.png "![β]")和![γ](img/file646.png "![γ]")
- en: '-'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '-'
- en: Obtain the optimal values ![\mathbf{\beta^{\ast}}](img/file650.png "\mathbf{\beta^{\ast}}")
    and ![\mathbf{\gamma^{\ast}}](img/file651.png "\mathbf{\gamma^{\ast}}") returned
    by the minimization algorithm
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 获得最小化算法返回的最优值![β^{*}](img/file650.png "![β^{*}"])和![γ^{*}](img/file651.png "![γ^{*}"])
- en: Prepare state ![\left| {\mathbf{\beta^{\ast}},\mathbf{\gamma^{\ast}}} \right\rangle](img/file652.png
    "\left| {\mathbf{\beta^{\ast}},\mathbf{\gamma^{\ast}}} \right\rangle")    ![\vartriangleright](img/file655.png
    "\vartriangleright") *This* *is done on the quantum computer!*
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 准备状态![左| {β^{*},γ^{*}} >](img/file652.png "![左| {β^{*},γ^{*}} >")    ![\vartriangleright](img/file655.png
    "![\vartriangleright]") *这是在量子计算机上完成的！*
- en: Measure the state to obtain an approximate solution
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 测量状态以获得一个近似解
- en: To learn more…
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多...
- en: Just before bringing this subsection to an end, we thought this could be a good
    time for us to share a historical fact with you.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束本小节之前，我们认为这是一个与我们分享一个历史事实的好时机。
- en: When it was introduced in a 2014 paper [[37](ch030.xhtml#Xfarhi2014quantum)],
    QAOA provided a better ratio of approximation for the Max-Cut problem than any
    existing classical algorithm that would run on polynomial time. And we say that
    it *provided* because, soon after, this claim was challenged by a paper [[11](ch030.xhtml#Xbarak2015beating)]
    that presented a classical algorithm that could beat QAOA.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当它在2014年的一篇论文[[37](ch030.xhtml#Xfarhi2014quantum)]中提出时，QAOA为Max-Cut问题提供了比任何现有经典算法更好的近似比率，这些经典算法将在多项式时间内运行。我们说它是“提供”的，因为不久之后，这一主张被一篇论文[[11](ch030.xhtml#Xbarak2015beating)]所挑战，该论文提出了一种能够击败QAOA的经典算法。
- en: What can we say? Sometimes classics refuse to die!
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能说什么呢？有时候经典的东西是不愿意消亡的！
- en: The description of QAOA that we have discussed may seem a little bit abstract.
    But don’t worry. In the next subsection, we will make all of this much more concrete,
    because we will be studying in detail the quantum circuits that are needed to
    implement the parts of the algorithm that run on quantum computers.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所讨论的QAOA描述可能显得有些抽象。但不用担心。在下一个小节中，我们将使所有这些内容更加具体，因为我们将会详细研究实现量子计算机上运行的算法部分的量子电路。
- en: 5.1.3 Circuits for QAOA
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.1.3 QAOA电路
- en: As we have just seen, quantum computers are only used at certain steps in QAOA.
    And, in fact, those steps always involve the preparation of a state of the form
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们刚才看到的，量子计算机只在QAOA的某些步骤中使用。实际上，这些步骤总是涉及准备一种形式的状态
- en: '![\left| {\mathbf{\beta},\mathbf{\gamma}} \right\rangle = e^{i\beta_{p}H_{0}}e^{i\gamma_{p}H_{1}}\ldots
    e^{i\beta_{2}H_{0}}e^{i\gamma_{2}H_{1}}e^{i\beta_{1}H_{0}}e^{i\gamma_{1}H_{1}}\left|
    \psi_{0} \right\rangle,](img/file656.png "\left| {\mathbf{\beta},\mathbf{\gamma}}
    \right\rangle = e^{i\beta_{p}H_{0}}e^{i\gamma_{p}H_{1}}\ldots e^{i\beta_{2}H_{0}}e^{i\gamma_{2}H_{1}}e^{i\beta_{1}H_{0}}e^{i\gamma_{1}H_{1}}\left|
    \psi_{0} \right\rangle,")'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![左| {β,γ} > = e^{iβ_{p}H_{0}}e^{iγ_{p}H_{1}}...e^{iβ_{2}H_{0}}e^{iγ_{2}H_{1}}e^{iβ_{1}H_{0}}e^{iγ_{1}H_{1}}|ψ_{0}
    >](img/file656.png "|左| {β,γ} > = e^{iβ_{p}H_{0}}e^{iγ_{p}H_{1}}...e^{iβ_{2}H_{0}}e^{iγ_{2}H_{1}}e^{iβ_{1}H_{0}}e^{iγ_{1}H_{1}}|ψ_{0}
    >")'
- en: where ![\left| \psi_{0} \right\rangle](img/file631.png "\left| \psi_{0} \right\rangle")
    is the ground state of ![H_{0}](img/file545.png "H_{0}"). Of course, we need to
    prepare the state with adequate quantum gates on a quantum circuit, so let’s analyze
    the operations that we need to perform. A crucial observation is that the Hamiltonians
    ![H_{0}](img/file545.png "H_{0}") and ![H_{1}](img/file544.png "H_{1}") take a
    very specific form. As we studied in the previous chapter, ![H_{0}](img/file545.png
    "H_{0}") is usually taken to be ![- {\sum}_{j = 0}^{n - 1}X_{j}](img/file657.png
    "- {\sum}_{j = 0}^{n - 1}X_{j}"), while ![H_{1}](img/file544.png "H_{1}") is an
    Ising Hamiltonian of the form
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 其中![左| ψ_{0} >](img/file631.png "![左| ψ_{0} >"])是![H_{0}](img/file545.png "![H_{0}]")的基态。当然，我们需要在量子电路中准备足够的状态，因此让我们分析我们需要执行的操作。一个关键的观察是，哈密顿量![H_{0}](img/file545.png
    "![H_{0}}")和![H_{1}](img/file544.png "![H_{1}}")具有一个非常特定的形式。正如我们在上一章所研究的，![H_{0}](img/file545.png
    "![H_{0}}")通常被取为![- {\sum}_{j = 0}^{n - 1}X_{j}](img/file657.png "![- {\sum}_{j
    = 0}^{n - 1}X_{j}"])，而![H_{1}](img/file544.png "![H_{1}]")是一个形式为Ising哈密顿量的
- en: '![- \sum\limits_{j,k}J_{jk}Z_{j}Z_{k} - \sum\limits_{j}h_{j}Z_{j},](img/file554.png
    "- \sum\limits_{j,k}J_{jk}Z_{j}Z_{k} - \sum\limits_{j}h_{j}Z_{j},")'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
- en: where the coefficients ![J_{jk}](img/file342.png "J_{jk}") and ![h_{j}](img/file343.png
    "h_{j}") are real numbers.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: 'The ground state of ![H_{0}](img/file545.png "H_{0}") is ![{\otimes}_{i = 0}^{n
    - 1}\left| + \right\rangle](img/file557.png "{\otimes}_{i = 0}^{n - 1}\left| +
    \right\rangle"), as you proved in *Exercise* * [*4.2*](ch012.xhtml#x1-77004x4.2).
    This state can be easily prepared: starting from ![\left| 0 \right\rangle](img/file6.png
    "\left| 0 \right\rangle"), you just need to use a Hadamard gate on each qubit
    of the circuit.*'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '*That was easy, so let’s now focus on the operations of the form ![e^{i\beta_{k}H_{0}}](img/file658.png
    "e^{i\beta_{k}H_{0}}"), with ![\beta_{j}](img/file659.png "\beta_{j}") a real
    number. Notice that ![H_{0} = - {\sum}_{j = 0}^{n - 1}X_{j}](img/file555.png "H_{0}
    = - {\sum}_{j = 0}^{n - 1}X_{j}") and that all the ![X_{j}](img/file556.png "X_{j}")
    matrices commute with each other, so we can replace the exponential of the sum
    with the product of the exponentials. Therefore, it holds that'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '![e^{i\beta_{k}H_{0}} = e^{- i\beta_{k}\sum\limits_{j = 0}^{n - 1}X_{j}} =
    \prod\limits_{j = 0}^{n - 1}e^{- i\beta_{k}X_{j}}.](img/file660.png "e^{i\beta_{k}H_{0}}
    = e^{- i\beta_{k}\sum\limits_{j = 0}^{n - 1}X_{j}} = \prod\limits_{j = 0}^{n -
    1}e^{- i\beta_{k}X_{j}}.")'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
- en: But ![e^{- i\beta X_{j}}](img/file661.png "e^{- i\beta X_{j}}") is the expression
    for the rotation gate ![R_{X}(2\beta)](img/file662.png "R_{X}(2\beta)"), so this
    means that we just need to apply this gate to each of the qubits in our circuit.
    Neat, isn’t it?
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: The last type of operation that we need to translate into quantum gates is ![e^{i\gamma_{l}H_{1}}](img/file663.png
    "e^{i\gamma_{l}H_{1}}") for any real coefficient ![\gamma_{l}](img/file664.png
    "\gamma_{l}"). We know that ![H_{1}](img/file544.png "H_{1}") is a sum of terms
    of the form ![J_{jk}Z_{j}Z_{k}](img/file665.png "J_{jk}Z_{j}Z_{k}") and ![h_{j}Z_{j}](img/file666.png
    "h_{j}Z_{j}"). Again, these matrices commute with each other, so we get
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '![e^{i\gamma_{l}H_{1}} = e^{- i\gamma_{l}(\sum\limits_{j,k}J_{jk}Z_{j}Z_{k}
    + \sum\limits_{j}h_{j}Z_{j})} = \prod\limits_{j,k}e^{- i\gamma_{l}J_{jk}Z_{j}Z_{k}}\prod\limits_{j}e^{-
    i\gamma_{l}h_{j}Z_{j}}.](img/file667.png "e^{i\gamma_{l}H_{1}} = e^{- i\gamma_{l}(\sum\limits_{j,k}J_{jk}Z_{j}Z_{k}
    + \sum\limits_{j}h_{j}Z_{j})} = \prod\limits_{j,k}e^{- i\gamma_{l}J_{jk}Z_{j}Z_{k}}\prod\limits_{j}e^{-
    i\gamma_{l}h_{j}Z_{j}}.")'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
- en: Similar to the case of ![H_{0}](img/file545.png "H_{0}"), the operations of
    the form ![e^{- i\gamma_{l}h_{j}Z_{j}}](img/file668.png "e^{- i\gamma_{l}h_{j}Z_{j}}")
    can be carried out with rotation gates ![R_{Z}](img/file120.png "R_{Z}"). Thus,
    we only need to learn how to implement ![e^{- i\gamma_{l}J_{jk}Z_{j}Z_{k}}](img/file669.png
    "e^{- i\gamma_{l}J_{jk}Z_{j}Z_{k}}"). To keep things simple, let’s denote the
    real number ![\gamma_{l}J_{jk}](img/file670.png "\gamma_{l}J_{jk}") by ![a](img/file16.png
    "a"). Notice that ![e^{- iaZ_{j}Z_{k}}](img/file671.png "e^{- iaZ_{j}Z_{k}}")
    is the exponential of a diagonal matrix, because ![Z_{j}Z_{k}](img/file363.png
    "Z_{j}Z_{k}") is the tensor product of diagonal matrices. In fact, it holds that
    if ![\left| x \right\rangle](img/file267.png "\left| x \right\rangle") is a computational
    basis state in which qubits ![j](img/file258.png "j") and ![k](img/file317.png
    "k") have the same value, then
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '![e^{- iaZ_{j}Z_{k}}\left| x \right\rangle = e^{- ia}\left| x \right\rangle.](img/file672.png
    "e^{- iaZ_{j}Z_{k}}\left| x \right\rangle = e^{- ia}\left| x \right\rangle.")'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
- en: On the other hand, if qubits ![j](img/file258.png "j") and ![k](img/file317.png
    "k") have different values, then
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '![e^{- iaZ_{j}Z_{k}}\left| x \right\rangle = e^{ia}\left| x \right\rangle.](img/file673.png
    "e^{- iaZ_{j}Z_{k}}\left| x \right\rangle = e^{ia}\left| x \right\rangle.")'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
- en: This unitary action is implemented by the circuit in *Figure* *[*5.1*](#Figure5.1),
    where, for simplicity, we have only depicted qubits ![j](img/file258.png "j")
    and ![k](img/file317.png "k") — the action on the rest of the qubits would be
    the identity gate.*
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '*![Figure 5.1: Implementation of e^{- iaZ_{j}Z_{k}}](img/file674.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '**Figure 5.1**: Implementation of ![e^{- iaZ_{j}Z_{k}}](img/file671.png "e^{-
    iaZ_{j}Z_{k}}")'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: We now have all the elements in place, so let’s illustrate them with an example.
    Imagine that the Ising Hamiltonian of your problem is ![3Z_{0}Z_{2} - Z_{1}Z_{2}
    + 2Z_{0}](img/file675.png "3Z_{0}Z_{2} - Z_{1}Z_{2} + 2Z_{0}"). Then, the circuit
    used by QAOA to prepare ![\left| {\mathbf{\beta},\mathbf{\gamma}} \right\rangle](img/file644.png
    "\left| {\mathbf{\beta},\mathbf{\gamma}} \right\rangle") with ![p = 1](img/file676.png
    "p = 1") is the one shown in *Figure* * [*5.2*](#Figure5.2).*
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '*![Figure 5.2: QAOA circuit with p = 1](img/file677.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '**Figure 5.2**: QAOA circuit with ![p = 1](img/file676.png "p = 1")'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Notice how we first prepare the ground state of ![H_{0}](img/file545.png "H_{0}")
    with a column of Hadamard gates. Then, we have the implementation of ![e^{- i3\gamma_{1}Z_{0}Z_{2}}](img/file678.png
    "e^{- i3\gamma_{1}Z_{0}Z_{2}}") with a CNOT gate between qubits ![0](img/file12.png
    "0") and ![2](img/file302.png "2"), an ![R_{Z}](img/file120.png "R_{Z}") gate
    on qubit ![2](img/file302.png "2"), and another CNOT gate between qubits ![0](img/file12.png
    "0") and ![2](img/file302.png "2"). The implementation of ![e^{i\gamma_{1}Z_{1}Z_{2}}](img/file679.png
    "e^{i\gamma_{1}Z_{1}Z_{2}}") is similar, but on qubits ![1](img/file13.png "1")
    and ![2](img/file302.png "2"). Then, we use an ![R_{Z}](img/file120.png "R_{Z}")
    gate on qubit ![0](img/file12.png "0") to implement ![e^{- i2\gamma_{1}Z_{0}}](img/file680.png
    "e^{- i2\gamma_{1}Z_{0}}"). Finally, a column of ![R_{X}](img/file118.png "R_{X}")
    gates implements ![e^{- i\beta_{1}{\sum}_{j}X_{j}}](img/file681.png "e^{- i\beta_{1}{\sum}_{j}X_{j}}").
    If we increased the number of **layers** ![p](img/file141.png "p"), the circuit
    would grow by repeating for another ![p - 1](img/file682.png "p - 1") times the
    very same circuit structure shown in *Figure* * [*5.2*](#Figure5.2) except for
    the initial Hadamard gates. Additionally, we would have to replace the parameters
    ![\gamma_{1}](img/file683.png "\gamma_{1}") and ![\beta_{1}](img/file684.png "\beta_{1}")
    by ![\gamma_{2}](img/file685.png "\gamma_{2}") and ![\beta_{2}](img/file686.png
    "\beta_{2}") in the second layer, by ![\gamma_{3}](img/file687.png "\gamma_{3}")
    and ![\beta_{3}](img/file688.png "\beta_{3}") in the third, and so on and so forth.*
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '*Exercise 5.1'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Obtain the QAOA circuit for ![Z_{1}Z_{3} + Z_{0}Z_{2} - 2Z_{1} + 3Z_{2}](img/file689.png
    "Z_{1}Z_{3} + Z_{0}Z_{2} - 2Z_{1} + 3Z_{2}") with ![p = 1](img/file676.png "p
    = 1").
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know all the circuits that we need for QAOA, let’s study how to
    use them in order to estimate the energy of the states ![\left| {\mathbf{\beta},\mathbf{\gamma}}
    \right\rangle](img/file644.png "\left| {\mathbf{\beta},\mathbf{\gamma}} \right\rangle").
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 5.1.4 Estimating the energy
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The circuits that we have just studied allow us to prepare any state of the
    form ![\left| {\mathbf{\beta},\mathbf{\gamma}} \right\rangle](img/file644.png
    "\left| {\mathbf{\beta},\mathbf{\gamma}} \right\rangle"). But we are not interested
    in the states themselves. What we need is their energy with respect to ![H_{1}](img/file544.png
    "H_{1}"), because that is the quantity that we want to minimize. That is, we need
    to evaluate ![\left\langle {\mathbf{\beta},\mathbf{\gamma}} \right|H_{1}\left|
    {\mathbf{\beta},\mathbf{\gamma}} \right\rangle](img/file647.png "\left\langle
    {\mathbf{\beta},\mathbf{\gamma}} \right|H_{1}\left| {\mathbf{\beta},\mathbf{\gamma}}
    \right\rangle"), but, of course, we don’t have access to the state vector because
    we are preparing the state with a quantum computer. So, what can we do?
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: The key observation here is that we already know how to evaluate efficiently
    ![\left\langle x \right|H_{1}\left| x \right\rangle](img/file690.png "\left\langle
    x \right|H_{1}\left| x \right\rangle") for any basis state ![\left| x \right\rangle](img/file267.png
    "\left| x \right\rangle"). In fact, ![\left\langle x \right|H_{1}\left| x \right\rangle](img/file690.png
    "\left\langle x \right|H_{1}\left| x \right\rangle") is the value of ![x](img/file269.png
    "x") in the cost function of our combinatorial optimization problem, because we
    derived ![H_{1}](img/file544.png "H_{1}") from it. So, for instance, if we are
    trying to solve a Max-Cut problem, each ![\left| x \right\rangle](img/file267.png
    "\left| x \right\rangle") represents a cut and we can easily compute — with a
    classical computer — the cost of that cut, as we did in *Section* * [*3.1.2*](ch011.xhtml#x1-620003.1.2).*
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '*What is more, we can also evaluate ![\left\langle x \right|H_{1}\left| x \right\rangle](img/file690.png
    "\left\langle x \right|H_{1}\left| x \right\rangle") directly from the expression
    of the Hamiltonian. We only need to notice that ![\left\langle x \right|Z_{j}\left|
    x \right\rangle = 1](img/file691.png "\left\langle x \right|Z_{j}\left| x \right\rangle
    = 1") if the ![j](img/file258.png "j")-th bit of ![x](img/file269.png "x") is
    ![0](img/file12.png "0") and that ![\left\langle x \right|Z_{j}\left| x \right\rangle
    = - 1](img/file692.png "\left\langle x \right|Z_{j}\left| x \right\rangle = -
    1") otherwise. In a similar way, ![\left\langle x \right|Z_{j}Z_{k}\left| x \right\rangle
    = 1](img/file693.png "\left\langle x \right|Z_{j}Z_{k}\left| x \right\rangle =
    1") if the ![j](img/file258.png "j")-th and ![k](img/file317.png "k")-th bits
    of ![x](img/file269.png "x") are equal and ![\left\langle x \right|Z_{j}Z_{k}\left|
    x \right\rangle = - 1](img/file694.png "\left\langle x \right|Z_{j}Z_{k}\left|
    x \right\rangle = - 1") if they are different.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Then, by linearity, we can easily evaluate ![\left\langle x \right|H_{1}\left|
    x \right\rangle](img/file690.png "\left\langle x \right|H_{1}\left| x \right\rangle").
    For instance, if ![H_{1} = 3Z_{0}Z_{2} - Z_{1}Z_{2} + 2Z_{0}](img/file695.png
    "H_{1} = 3Z_{0}Z_{2} - Z_{1}Z_{2} + 2Z_{0}"), we will have
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '![\left\langle {101} \right|H_{1}\left| {101} \right\rangle = 3\left\langle
    {101} \right|Z_{0}Z_{2}\left| {101} \right\rangle - \left\langle {101} \right|Z_{1}Z_{2}\left|
    {101} \right\rangle + 2\left\langle {101} \right|Z_{0}\left| {101} \right\rangle
    = 3 + 1 - 2 = 4.](img/file696.png "\left\langle {101} \right|H_{1}\left| {101}
    \right\rangle = 3\left\langle {101} \right|Z_{0}Z_{2}\left| {101} \right\rangle
    - \left\langle {101} \right|Z_{1}Z_{2}\left| {101} \right\rangle + 2\left\langle
    {101} \right|Z_{0}\left| {101} \right\rangle = 3 + 1 - 2 = 4.")'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
- en: Exercise 5.2
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Evaluate ![\left\langle {100} \right|H_{1}\left| {100} \right\rangle](img/file697.png
    "\left\langle {100} \right|H_{1}\left| {100} \right\rangle") with ![H_{1} = 3Z_{0}Z_{2}
    - Z_{1}Z_{2} + 2Z_{0}](img/file695.png "H_{1} = 3Z_{0}Z_{2} - Z_{1}Z_{2} + 2Z_{0}").
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: We also know that we can always write ![\left| {\mathbf{\beta},\mathbf{\gamma}}
    \right\rangle](img/file644.png "\left| {\mathbf{\beta},\mathbf{\gamma}} \right\rangle")
    as a linear combination of basis states. Namely, we have
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '![\left| {\mathbf{\beta},\mathbf{\gamma}} \right\rangle = \sum\limits_{x}a_{x}\left|
    x \right\rangle](img/file698.png "\left| {\mathbf{\beta},\mathbf{\gamma}} \right\rangle
    = \sum\limits_{x}a_{x}\left| x \right\rangle")'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
- en: for certain amplitudes ![a_{x}](img/file699.png "a_{x}") such that ![{\sum}_{x}\left|
    a_{x} \right|^{2} = 1](img/file371.png "{\sum}_{x}\left| a_{x} \right|^{2} = 1").
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: But then it holds that
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '![\left\langle {\mathbf{\beta},\mathbf{\gamma}} \right|H_{1}\left| {\mathbf{\beta},\mathbf{\gamma}}
    \right\rangle = \left( {\sum\limits_{y}a_{y}^{\ast}\left\langle y \right|} \right)H_{1}\left(
    {\sum\limits_{x}a_{x}\left| x \right\rangle} \right) = \sum\limits_{y}\sum\limits_{x}a_{y}^{\ast}a_{x}\left\langle
    y \right|H_{1}\left| x \right\rangle = \sum\limits_{x}\left| a_{x} \right|^{2}\left\langle
    x \right|H_{1}\left| x \right\rangle,](img/file700.png "\left\langle {\mathbf{\beta},\mathbf{\gamma}}
    \right|H_{1}\left| {\mathbf{\beta},\mathbf{\gamma}} \right\rangle = \left( {\sum\limits_{y}a_{y}^{\ast}\left\langle
    y \right|} \right)H_{1}\left( {\sum\limits_{x}a_{x}\left| x \right\rangle} \right)
    = \sum\limits_{y}\sum\limits_{x}a_{y}^{\ast}a_{x}\left\langle y \right|H_{1}\left|
    x \right\rangle = \sum\limits_{x}\left| a_{x} \right|^{2}\left\langle x \right|H_{1}\left|
    x \right\rangle,")'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
- en: because ![H_{1}\left| x \right\rangle](img/file701.png "H_{1}\left| x \right\rangle")
    is always a multiple of ![\left| x \right\rangle](img/file267.png "\left| x \right\rangle")
    (just notice that ![H_{1}](img/file544.png "H_{1}") is a diagonal matrix because
    it is a sum of diagonal matrices), because ![\left\langle y \middle| x \right\rangle
    = 0](img/file366.png "\left\langle y \middle| x \right\rangle = 0") when ![y \neq
    x](img/file702.png "y \neq x"), and because ![a_{x}^{\ast}a_{x} = \left| a_{x}
    \right|^{2}](img/file369.png "a_{x}^{\ast}a_{x} = \left| a_{x} \right|^{2}").
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Now, since we can compute ![\left\langle x \right|H_{1}\left| x \right\rangle](img/file690.png
    "\left\langle x \right|H_{1}\left| x \right\rangle") easily with the classical
    computer, we have reduced our problem to computing the values ![\left| a_{x} \right|^{2}](img/file372.png
    "\left| a_{x} \right|^{2}"). But ![\left| a_{x} \right|^{2}](img/file372.png "\left|
    a_{x} \right|^{2}") is the probability of measuring ![\left| x \right\rangle](img/file267.png
    "\left| x \right\rangle") when the state ![\left| {\mathbf{\beta},\mathbf{\gamma}}
    \right\rangle](img/file644.png "\left| {\mathbf{\beta},\mathbf{\gamma}} \right\rangle")
    is prepared — this is the reason why, back in *Chapter* * [*3*](ch011.xhtml#x1-590003),
    *Working with Quadratic* *Unconstrained Binary Optimization Problems*, we referred
    to expressions of the form ![\left\langle \psi \right|H_{1}\left| \psi \right\rangle](img/file703.png
    "\left\langle \psi \right|H_{1}\left| \psi \right\rangle") as expectation values;
    they are indeed the expected or average energy under ![H_{1}](img/file544.png
    "H_{1}") when we measure the state ![\left| \psi \right\rangle](img/file43.png
    "\left| \psi \right\rangle")!*
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '*From this observation, it follows that we can use the quantum computer to
    prepare ![\left| {\mathbf{\beta},\mathbf{\gamma}} \right\rangle](img/file644.png
    "\left| {\mathbf{\beta},\mathbf{\gamma}} \right\rangle") and measure it ![M](img/file704.png
    "M") times to make the estimation'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '![\left\langle {\mathbf{\beta},\mathbf{\gamma}} \right|H_{1}\left| {\mathbf{\beta},\mathbf{\gamma}}
    \right\rangle \approx \sum\limits_{x}\frac{m_{x}}{M}\left\langle x \right|H_{1}\left|
    x \right\rangle,](img/file705.png "\left\langle {\mathbf{\beta},\mathbf{\gamma}}
    \right|H_{1}\left| {\mathbf{\beta},\mathbf{\gamma}} \right\rangle \approx \sum\limits_{x}\frac{m_{x}}{M}\left\langle
    x \right|H_{1}\left| x \right\rangle,")'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
- en: where ![m_{x}](img/file706.png "m_{x}") is the number of times that ![x](img/file269.png
    "x") was measured. Of course, the higher the value of ![M](img/file704.png "M"),
    the better this approximation will be.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: In the process of estimating the energies of all the different states prepared
    with quantum computers, we will compute the cost, for our optimization problem,
    of many binary strings ![x](img/file269.png "x"). Of course, it would be wise
    for us to always keep the best ![x](img/file269.png "x") seen during the optimization
    process. Occasionally, it might be even better than the ones we obtain when measuring
    the final state ![\left| {\mathbf{\beta}^{\ast},\mathbf{\gamma}^{\ast}} \right\rangle](img/file707.png
    "\left| {\mathbf{\beta}^{\ast},\mathbf{\gamma}^{\ast}} \right\rangle").
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now covered all that we needed to know about the inner workings of QAOA.
    Before we move on to show how to implement and use this algorithm with Qiskit
    and PennyLane, we will introduce a little perk that we get from the fact that
    we are no longer using quantum annealers, but universal quantum computers instead.
    This will help us in formulating some problems in a more natural way, as we will
    show in the next subsection.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: 5.1.5 QUBO and HOBO
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Up to this point, we have only considered problems that can be written under
    the QUBO formalism. That is, minimization problems in which the cost function
    is a quadratic polynomial on binary variables that had no constraints on the values
    they could take. This is less restricting than it may seem, because QUBO is ![NP](img/file2.png
    "NP")-hard and there are many important problems that we can rewrite via reductions,
    as we saw in *Section* * [*3.4*](ch011.xhtml#x1-680003.4).*
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '*However, consider a problem like the famous **satisfiability** or **SAT**.
    In it, we are given a Boolean formula on binary variables and we have to determine
    whether there is any assignment of values that makes the formula true. For example,
    we may receive'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '![(x_{0} \vee \neg x_{1} \vee x_{2}) \land (\neg x_{0} \vee x_{1} \vee \neg
    x_{2}) \land (x_{0} \vee x_{1} \vee x_{2}),](img/file708.png "(x_{0} \vee \neg
    x_{1} \vee x_{2}) \land (\neg x_{0} \vee x_{1} \vee \neg x_{2}) \land (x_{0} \vee
    x_{1} \vee x_{2}),")'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
- en: which is **satisfiable** (by assigning *true* to all the variables, for instance).
    Or we can be given
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '![x_{0} \land \neg x_{0},](img/file709.png "x_{0} \land \neg x_{0},")'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
- en: which is clearly **unsatisfiable**.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: SAT is easily seen to be in ![NP](img/file2.png "NP") (and, in fact, it is ![NP](img/file2.png
    "NP")-complete — see *Section 7.4* in Sipser’s book [[90](ch030.xhtml#Xsipser2012introduction)]).
    Then, we know that there must be a way of rewriting any SAT instance in the QUBO
    formalism. But the task becomes much easier if we relax the conditions in the
    QUBO formulation by allowing binary polynomials of *any order*. Let’s see why!
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Let us consider, for the sake of an example, the formula ![(x_{0} \vee \neg
    x_{1} \vee x_{2}) \land (\neg x_{0} \vee x_{1} \vee \neg x_{2}) \land (x_{0} \vee
    x_{1} \vee x_{2})](img/file710.png "(x_{0} \vee \neg x_{1} \vee x_{2}) \land (\neg
    x_{0} \vee x_{1} \vee \neg x_{2}) \land (x_{0} \vee x_{1} \vee x_{2})"). We’ll
    show how it can be represented as the polynomial
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '![p(x_{0},x_{1},x_{2}) = (1 - x_{0})x_{1}(1 - x_{2}) + x_{0}(1 - x_{1})x_{2}
    + (1 - x_{0})(1 - x_{1})(1 - x_{2}),](img/file711.png "p(x_{0},x_{1},x_{2}) =
    (1 - x_{0})x_{1}(1 - x_{2}) + x_{0}(1 - x_{1})x_{2} + (1 - x_{0})(1 - x_{1})(1
    - x_{2}),")'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
- en: on the binary variables ![x_{0}](img/file443.png "x_{0}"), ![x_{1}](img/file712.png
    "x_{1}"), and ![x_{2}](img/file444.png "x_{2}"). Let’s say that we consider some
    assignment of truth values for the variables in the original formula, and we set
    ![x_{i} = 1](img/file713.png "x_{i} = 1") in the polynomial if ![x_{i}](img/file714.png
    "x_{i}") is true and ![x_{i} = 0](img/file715.png "x_{i} = 0") if ![x_{i}](img/file714.png
    "x_{i}") is false. It’s easy to see that the original formula will be true under
    this assignment if and only if ![p(x_{0},x_{1},x_{2}) = 0](img/file716.png "p(x_{0},x_{1},x_{2})
    = 0"), and that it will be false if and only if ![p(x_{0},x_{1},x_{2}) > 0](img/file717.png
    "p(x_{0},x_{1},x_{2}) > 0"). Thus, if the polynomial ![p](img/file141.png "p")
    is ![0](img/file12.png "0") for some values of its variables, then the original
    formula must be satisfiable. Otherwise, it has to be unsatisfiable.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we can rewrite our original problem as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '![\begin{array}{rlrl} {\text{Minimize~}\quad} & {(1 - x_{0})x_{1}(1 - x_{2})
    + x_{0}(1 - x_{1})x_{2} + (1 - x_{0})(1 - x_{1})(1 - x_{2})\qquad} & & \qquad
    \\ {\text{subject~to~}\quad} & {x_{j} \in \{ 0,1\},\qquad j = 0,1,2.\qquad} &
    & \qquad \\ & \qquad & & \\ \end{array}](img/file718.png "\begin{array}{rlrl}
    {\text{Minimize~}\quad} & {(1 - x_{0})x_{1}(1 - x_{2}) + x_{0}(1 - x_{1})x_{2}
    + (1 - x_{0})(1 - x_{1})(1 - x_{2})\qquad} & & \qquad \\ {\text{subject~to~}\quad}
    & {x_{j} \in \{ 0,1\},\qquad j = 0,1,2.\qquad} & & \qquad \\  & \qquad & & \\
    \end{array}")'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
- en: If the minimum of the polynomial is ![0](img/file12.png "0"), then the formula
    will be satisfiable. Otherwise, the formula will be unsatisfiable.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: With a simple transformation, we have been able to reformulate our problem as
    something that looks very much like a QUBO instance. But wait! This is *not* a
    QUBO problem. The reason is that the degree of the binary polynomial is ![3](img/file472.png
    "3") and not ![2](img/file302.png "2"), as you can easily check by expanding its
    expression. These optimization problems in which we are asked to minimize a binary
    polynomial — of any degree — with no additional restrictions are called **Higher
    Order Binary Optimization** (**HOBO**) or **Polynomial Unconstrained Binary Optimization**
    (**PUBO**) problems, for obvious reasons.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: The method that we have applied is quite general. In fact, it is easy to see
    that we can apply it to any Boolean formula that is given as conjunctions of disjunctions
    of variables and negations of variables. Something like, for instance, ![(x_{0}
    \vee \neg x_{1} \vee x_{2}) \land (\neg x_{0} \vee x_{1} \vee \neg x_{2}) \land
    (x_{0} \vee x_{1} \vee x_{2})](img/file710.png "(x_{0} \vee \neg x_{1} \vee x_{2})
    \land (\neg x_{0} \vee x_{1} \vee \neg x_{2}) \land (x_{0} \vee x_{1} \vee x_{2})")
    or ![(x_{0} \vee x_{1} \vee \neg x_{2} \vee x_{3}) \land (\neg x_{0} \vee x_{1}
    \vee x_{2} \vee x_{3}) \land (\neg x_{0} \vee x_{1} \vee \neg x_{2} \vee \neg
    x_{3})](img/file719.png "(x_{0} \vee x_{1} \vee \neg x_{2} \vee x_{3}) \land (\neg
    x_{0} \vee x_{1} \vee x_{2} \vee x_{3}) \land (\neg x_{0} \vee x_{1} \vee \neg
    x_{2} \vee \neg x_{3})"). We say that these formulas are in **conjunctive normal
    form** or **CNF**. In this case, we can just obtain an associated polynomial consisting
    of a sum of products. Each product will correspond to one of the disjunctions
    of the formula. If a variable ![x](img/file269.png "x") appears negated in the
    disjunction, it will appear as ![x](img/file269.png "x") in the product. If it
    appears in positive form, it will appear as ![1 - x](img/file720.png "1 - x")
    in the product.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 5.3
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Write the HOBO version of the SAT problem with the Boolean formula
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '![(x_{0} \vee x_{1} \vee \neg x_{2} \vee x_{3}) \land (\neg x_{0} \vee x_{1}
    \vee x_{2} \vee x_{3}) \land (\neg x_{0} \vee x_{1} \vee \neg x_{2} \vee \neg
    x_{3}).](img/file721.png "(x_{0} \vee x_{1} \vee \neg x_{2} \vee x_{3}) \land
    (\neg x_{0} \vee x_{1} \vee x_{2} \vee x_{3}) \land (\neg x_{0} \vee x_{1} \vee
    \neg x_{2} \vee \neg x_{3}).")'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
- en: And what about Boolean formulas that are not in CNF? In this case, we can apply
    a method, called the **Tseitin transformation**, that runs in polynomial time
    and gives us a formula in CNF that is satisfiable if and only if the original
    formula was satisfiable (see [[17](ch030.xhtml#Xbiere2009handbook), Chapter 2]
    for more details). In fact, the resulting formula will be in **3-CNF**, meaning
    that the disjunctions will involve at most three variables or negations of variables.
    This is very convenient, because it guarantees that the process of expanding the
    polynomial to obtain the coefficients will be efficient.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: But enough about satisfiability. Let’s come back to HOBO problems. How can we
    solve them? One way of doing this is by transforming them into QUBO problems.
    There are different techniques for rewriting HOBO problems as QUBO instances by
    introducing auxiliary variables. For example, you can substitute products ![xy](img/file722.png
    "xy") by a new binary variable ![z](img/file81.png "z") as long as you introduce
    a penalty term ![xy - 2xz - 2yz + 3z](img/file723.png "xy - 2xz - 2yz + 3z"),
    which is ![0](img/file12.png "0") if and only if ![xy = z](img/file724.png "xy
    = z"). In this way, you can reduce a term of order ![m + 1](img/file725.png "m
    + 1") such as ![x_{0}x_{1}\cdots x_{m}](img/file726.png "x_{0}x_{1}\cdots x_{m}")
    to a term of order ![m](img/file259.png "m") of the form ![zx_{2}\cdots x_{m}](img/file727.png
    "zx_{2}\cdots x_{m}") and a quadratic penalty term on ![x_{0},x_{1}](img/file728.png
    "x_{0},x_{1}"), and ![z](img/file81.png "z"). By repeating this process as many
    times as needed, you can obtain an equivalent problem in which the objective function
    is a binary quadratic polynomial. Transformations of this kind are used in D-Wave’s
    Ocean, where you can find `BinaryPolynomial` objects that you can reduce to polynomials
    of degree ![2](img/file302.png "2") with the `make_quadratic` function.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: However, if you are using QAOA, you can deal with HOBO problems directly. We
    can consider a binary polynomial of any degree and transform it using the techniques
    of *Section* *[*3.3*](ch011.xhtml#x1-670003.3). We will end up having a Hamiltonian
    that is a sum of tensor products of ![Z_{j}](img/file384.png "Z_{j}") matrices.
    The only difference is that, now, these products can involve more than just one
    or two ![Z_{j}](img/file384.png "Z_{j}") matrices.*
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '*This implies that, when we set out to create a circuit for ![e^{- i\gamma_{l}H_{1}}](img/file729.png
    "e^{- i\gamma_{l}H_{1}}"), we may need to implement unitary operations of the
    form ![e^{- iaZ_{j_{1}}Z_{j_{2}}\cdots Z_{j_{m}}}](img/file730.png "e^{- iaZ_{j_{1}}Z_{j_{2}}\cdots
    Z_{j_{m}}}"), with ![m > 2](img/file731.png "m > 2"). But that is not much more
    difficult than implementing ![e^{- iaZ_{j}Z_{k}}](img/file671.png "e^{- iaZ_{j}Z_{k}}").
    In fact, we can almost repeat the argument in *Section* * [*5.1.3*](#x1-980005.1.3),
    because both ![Z_{j_{1}}Z_{j_{2}}\cdots Z_{j_{m}}](img/file732.png "Z_{j_{1}}Z_{j_{2}}\cdots
    Z_{j_{m}}") and ![e^{- iaZ_{j_{1}}Z_{j_{2}}\cdots Z_{j_{m}}}](img/file730.png
    "e^{- iaZ_{j_{1}}Z_{j_{2}}\cdots Z_{j_{m}}}") are diagonal matrices. In fact,
    if ![\left| x \right\rangle](img/file267.png "\left| x \right\rangle") is a basis
    state, then*'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '*![e^{- iaZ_{j_{1}}Z_{j_{2}}\cdots Z_{j_{m}}}\left| x \right\rangle = e^{-
    ia}\left| x \right\rangle](img/file733.png "e^{- iaZ_{j_{1}}Z_{j_{2}}\cdots Z_{j_{m}}}\left|
    x \right\rangle = e^{- ia}\left| x \right\rangle")'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: if the sum of the bits of ![x](img/file269.png "x") in positions ![j_{1},j_{2},\ldots,j_{m}](img/file734.png
    "j_{1},j_{2},\ldots,j_{m}") is even, and
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '![e^{- iaZ_{j_{1}}Z_{j_{2}}\cdots Z_{j_{m}}}\left| x \right\rangle = e^{ia}\left|
    x \right\rangle](img/file735.png "e^{- iaZ_{j_{1}}Z_{j_{2}}\cdots Z_{j_{m}}}\left|
    x \right\rangle = e^{ia}\left| x \right\rangle")'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
- en: if the sum is odd.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: This unitary action can be implemented by using consecutive CNOT gates with
    control qubits in ![j_{1},j_{2},\ldots,j_{m - 1}](img/file736.png "j_{1},j_{2},\ldots,j_{m
    - 1}") and targets in ![j_{m}](img/file737.png "j_{m}"), then an ![R_{Z}](img/file120.png
    "R_{Z}") gate with parameter ![2a](img/file738.png "2a") on qubit ![j_{m}](img/file737.png
    "j_{m}") and, again, consecutive CNOT gates with control qubits in ![j_{m - 1},j_{m
    - 2},\ldots,j_{1}](img/file739.png "j_{m - 1},j_{m - 2},\ldots,j_{1}") and targets
    in ![j_{m}](img/file737.png "j_{m}"). *Figure* * [*5.3*](#Figure5.3) illustrates
    this procedure for the case of ![e^{- iaZ_{0}Z_{1}Z_{3}}](img/file740.png "e^{-
    iaZ_{0}Z_{1}Z_{3}}"), under the assumption that we only have four qubits.*
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '*![Figure 5.3: Implementation of e^{- iaZ_{0}Z_{1}Z_{3}}](img/file741.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '**Figure 5.3**: Implementation of ![e^{- iaZ_{0}Z_{1}Z_{3}}](img/file740.png
    "e^{- iaZ_{0}Z_{1}Z_{3}}")'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Of course, this operation would be just one part in the implementation of ![e^{-
    i\gamma_{l}H_{1}}](img/file729.png "e^{- i\gamma_{l}H_{1}}") and we would need
    to repeat a similar process for each term of the Hamiltonian.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 5.4
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Implement, in a circuit with 5 qubits, the operation ![e^{- i\frac{\pi}{4}Z_{0}Z_{2}Z_{4}}](img/file742.png
    "e^{- i\frac{\pi}{4}Z_{0}Z_{2}Z_{4}}").
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we can also estimate the energy of a Hamiltonian ![H_{1}](img/file544.png
    "H_{1}") that includes tensor products of ![Z](img/file8.png "Z") matrices in
    a way that is very similar to the one that we explained in *Section* * [*5.1.4*](#x1-990005.1.4).
    The key fact is that, for any basis state ![\left| x \right\rangle](img/file267.png
    "\left| x \right\rangle"), it holds that*
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '*![\left\langle x \right|Z_{j_{1}}Z_{j_{2}}\cdots Z_{j_{m}}\left| x \right\rangle
    = 1](img/file743.png "\left\langle x \right|Z_{j_{1}}Z_{j_{2}}\cdots Z_{j_{m}}\left|
    x \right\rangle = 1")'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: if the sum of the bits of ![x](img/file269.png "x") in positions ![j_{1},j_{2},\ldots,j_{m}](img/file734.png
    "j_{1},j_{2},\ldots,j_{m}") is even, and
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '![\left\langle x \right|Z_{j_{1}}Z_{j_{2}}\cdots Z_{j_{m}}\left| x \right\rangle
    = - 1](img/file744.png "\left\langle x \right|Z_{j_{1}}Z_{j_{2}}\cdots Z_{j_{m}}\left|
    x \right\rangle = - 1")'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
- en: otherwise. By linearity, we can then evaluate ![\left\langle x \right|H_{1}\left|
    x \right\rangle](img/file690.png "\left\langle x \right|H_{1}\left| x \right\rangle")
    and, from that, we can estimate ![\left\langle \psi \right|H_{1}\left| \psi \right\rangle](img/file703.png
    "\left\langle \psi \right|H_{1}\left| \psi \right\rangle") by measuring ![\left|
    \psi \right\rangle](img/file43.png "\left| \psi \right\rangle") a number of times,
    exactly as we did in *Section* * [*5.1.4*](#x1-990005.1.4).*
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '*Exercise 5.5'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Evaluate ![\left\langle {100} \right|H_{1}\left| {100} \right\rangle](img/file697.png
    "\left\langle {100} \right|H_{1}\left| {100} \right\rangle") with ![H_{1} = Z_{0}Z_{1}Z_{2}
    + 3Z_{0}Z_{2} - Z_{1}Z_{2} + 2Z_{0}](img/file745.png "H_{1} = Z_{0}Z_{1}Z_{2}
    + 3Z_{0}Z_{2} - Z_{1}Z_{2} + 2Z_{0}").
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: We have now covered all the necessary concepts to understand QAOA in all its
    glory. In the next two sections, we will show how to implement and run this algorithm
    with both Qiskit and PennyLane.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 5.2 Using QAOA with Qiskit
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With everything that we have learned in the previous sections of this chapter
    and what we already know about Qiskit from *Chapter* *[*2*](ch009.xhtml#x1-400002),
    *The* *Tools of the Trade in Quantum Computing*, and *Section* *[*3.2.2*](ch011.xhtml#x1-660003.2.2),
    we could implement our own Qiskit version of QAOA. However, there is no need for
    that! As we shall show in this section, the Qiskit Optimization package provides
    all that is necessary to run QAOA on both quantum simulators and actual quantum
    computers. Moreover, it includes a set of tools to work directly with problems
    written under the QUBO formalism. As a matter of fact, in this section, we will
    also see how, underneath the hood, Qiskit uses the very same mathematical concepts
    that we have been studying.**
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '**Let’s start by explaining how to work with QAOA in Qiskit when we already
    have the problem Hamiltonian.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 5.2.1 Using QAOA with Hamiltonians
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we have the Hamiltonian ![H_{1}](img/file544.png "H_{1}") that encodes our
    optimization problem, it is very easy to use Qiskit’s QAOA implementation to approximate
    its ground state. Let’s start with a simple example in which we have ![H_{1} =
    Z_{0}Z_{1}](img/file746.png "H_{1} = Z_{0}Z_{1}"). We can create this Hamiltonian
    and prepare the corresponding QAOA circuit with the following lines of code:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As a result, we will obtain the circuit shown in *Figure* *[*5.4*](#Figure5.4).
    We can see how it starts with two Hadamard gates, which are then followed by the
    exponential of ![H_{1}](img/file544.png "H_{1}") and then the exponential of ![H_{0}](img/file545.png
    "H_{0}") (because ![H_{0} = X_{0}X_{1} = X_{0}I + IX_{1}](img/file747.png "H_{0}
    = X_{0}X_{1} = X_{0}I + IX_{1}")). This is exactly the circuit that we derived
    in the first part of the chapter.*
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '*![Figure 5.4: QAOA circuit for H_{1} = Z_{0}Z_{1}](img/file748.png)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '**Figure 5.4**: QAOA circuit for ![H_{1} = Z_{0}Z_{1}](img/file746.png "H_{1}
    = Z_{0}Z_{1}")'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: In order to create the circuit, in addition to `H1`, we’ve passed `[1,2]` to
    the method called `construct_circuit`. This list contains the ![\mathbf{\beta}](img/file645.png
    "\mathbf{\beta}") and ![\mathbf{\gamma}](img/file646.png "\mathbf{\gamma}") parameters
    that we want to use. In *Figure* * [*5.4*](#Figure5.4), this is indicated by the
    numbers below the exponentials in the gate boxes. Notice that this means that
    the first element in `[1,2]` is what we call ![\beta_{1}](img/file684.png "\beta_{1}")
    and the second is ![\gamma_{1}](img/file683.png "\gamma_{1}"). Also notice that
    we have used `[0]` after the call to `construct_circuit`. This is because this
    method, in general, returns a list of several circuits — but in this case, there
    is only one, which is the one that we pick.*
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '*We can visualize the circuit in more detail by decomposing the exponentials
    — that is, transforming them into simpler gates — a couple of times. For that,
    we may use'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: to get the circuit shown in *Figure* *[*5.5*](#Figure5.5). The sequence of gates
    in that circuit is exactly the one that we would expect from our derivations earlier
    in this chapter, because ![\left. U(\pi\slash 2,0,\pi) = H \right.](img/file749.png
    "\left. U(\pi\slash 2,0,\pi) = H \right."), as you can easily check from the definition
    that we gave in *Section* * [*1.3.4*](ch008.xhtml#x1-250001.3.4) (![U_{3}](img/file750.png
    "U_{3}") is Qiskit’s name for our ![U](img/file51.png "U") gate).**
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '**![Figure 5.5: QAOA circuit for H_{1} = Z_{0}Z_{1}, more detailed](img/file751.png)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '**Figure 5.5**: QAOA circuit for ![H_{1} = Z_{0}Z_{1}](img/file746.png "H_{1}
    = Z_{0}Z_{1}"), more detailed'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the value of ![p](img/file141.png "p") for QAOA in Qiskit is ![1](img/file13.png
    "1"). However, we can change it by using the `reps` parameter when calling the
    class constructor. For instance, the following code can be used to obtain the
    QAOA circuit for ![Z_{0}Z_{1}](img/file352.png "Z_{0}Z_{1}") with ![p = 2](img/file752.png
    "p = 2"), ![\beta_{1} = 1](img/file753.png "\beta_{1} = 1"), ![\beta_{2} = 2](img/file754.png
    "\beta_{2} = 2"), ![\gamma_{1} = 3](img/file755.png "\gamma_{1} = 3"), and ![\gamma_{2}
    = 4](img/file756.png "\gamma_{2} = 4"):'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The result of the execution is the circuit shown in *Figure* *[*5.6*](#Figure5.6).*
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '*![Figure 5.6: QAOA circuit for H_{1} = Z_{0}Z_{1} with p = 2](img/file757.png)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '**Figure 5.6**: QAOA circuit for ![H_{1} = Z_{0}Z_{1}](img/file746.png "H_{1}
    = Z_{0}Z_{1}") with ![p = 2](img/file752.png "p = 2")'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: All this is well and good, but we haven’t yet solved any optimization problems!
    For that, we need to pass two additional parameters when creating a `QAOA` object.
    The first one is a `QuantumInstance`. That is, some backend capable of executing
    the QAOA quantum circuit to evaluate the energy of the ![\left| {\mathbf{\beta},\mathbf{\gamma}}
    \right\rangle](img/file644.png "\left| {\mathbf{\beta},\mathbf{\gamma}} \right\rangle")
    states. The second one is a classical optimizer, which will set initial values
    for ![\mathbf{\beta}](img/file645.png "\mathbf{\beta}") and ![\mathbf{\gamma}](img/file646.png
    "\mathbf{\gamma}"), use the `QuantumInstance` to evaluate state energies, and
    update the ![\mathbf{\beta}](img/file645.png "\mathbf{\beta}") and ![\mathbf{\gamma}](img/file646.png
    "\mathbf{\gamma}") parameters in order to optimize them, until some stopping criterion
    is met.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: To learn more…
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: The choice of classical optimizer can have a big impact on the execution time
    and quality of the solutions obtained with QAOA.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: For some insights into this, you can refer to [[39](ch030.xhtml#Xfernandez2022study)].
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following piece of code, we give an example of how to create the quantum
    instance and the classical minimizer objects, and of how to use them with QAOA
    to solve a simple problem:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, we are relying on the previous definition of `H1` as `Z``^``Z`, running
    the circuit on the `Aer` simulator with ![10](img/file161.png "10") shots, and
    using `COBYLA` as the classical optimizer — for an updated list of minimizers,
    please refer to Qiskit’s documentation at [https://qiskit.org/documentation/stubs/qiskit.algorithms.optimizers.html](https://qiskit.org/documentation/stubs/qiskit.algorithms.optimizers.html).
    We are also setting seeds for those processes that require random numbers, in
    order to obtain reproducible results.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run the preceding instructions, you will obtain the following output:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '@empty'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'That is quite a lot of information! Let’s try to explain the most relevant
    pieces. The first thing that we need to understand is that this result refers
    to the final state ![\left| {\mathbf{\beta}^{\ast},\mathbf{\gamma}^{\ast}} \right\rangle](img/file707.png
    "\left| {\mathbf{\beta}^{\ast},\mathbf{\gamma}^{\ast}} \right\rangle") obtained
    by QAOA, not to the solutions that we would obtain if we measured it. In fact,
    this state is reconstructed from ![10](img/file161.png "10") measurements — because
    our simulator is using ![10](img/file161.png "10") shots — but those measurements
    are not given as part of the output. Instead, we get the `eigenstate` field, which
    shows that we have ![\left| {01} \right\rangle](img/file199.png "\left| {01} \right\rangle")
    with an amplitude roughly ![0.5477](img/file758.png "0.5477") and ![\left| {10}
    \right\rangle](img/file200.png "\left| {10} \right\rangle") with an amplitude
    about ![0.8367](img/file759.png "0.8367"). These numbers are, in fact, ![\sqrt{\left.
    3\slash 10 \right.}](img/file760.png "\sqrt{\left. 3\slash 10 \right.}") and ![\sqrt{\left.
    7\slash 10 \right.}](img/file761.png "\sqrt{\left. 7\slash 10 \right.}"), which
    means that, once the state with the optimal parameters found by the minimizer
    was prepared and measured, `01` was obtained ![3](img/file472.png "3") out of
    ![10](img/file161.png "10") times and `10` was obtained the remaining ![7](img/file465.png
    "7") times. This state can be prepared with the QAOA circuit by using the optimal
    parameters reported in the result: ![\beta_{1} \approx 6.7648](img/file762.png
    "\beta_{1} \approx 6.7648") and ![\gamma_{1} \approx - 0.8472](img/file763.png
    "\gamma_{1} \approx - 0.8472").'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Notice that, with respect to the ![Z_{0}Z_{1}](img/file352.png "Z_{0}Z_{1}")
    Hamiltonian, both ![\left| {01} \right\rangle](img/file199.png "\left| {01} \right\rangle")
    and ![\left| {10} \right\rangle](img/file200.png "\left| {10} \right\rangle")
    have an expected value of ![- 1](img/file312.png "- 1"), which is the optimal
    energy. This means that we have been able to find an optimal solution — two of
    them, in fact — with QAOA! To get to this result, QAOA evaluated the energy function
    — by preparing a circuit with some values of ![\beta_{1}](img/file684.png "\beta_{1}")
    and ![\gamma_{1}](img/file683.png "\gamma_{1}") and measuring it to estimate its
    expectation value — 20 times, as indicated by the `cost_function_evals` field,
    and it used about ![0.08](img/file764.png "0.08") seconds of computing time —
    your running time will most surely be different from ours, though.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: All this has been done with the Aer simulator. If we wanted to use a real quantum
    computer, we could just replace the `backend` in the instantiation of the `QuantumInstance`
    object and use some of the quantum devices provided by IBM, as we showed in *Section*
    *[*2.2.4*](ch009.xhtml#x1-510002.2.4). However, this is not the best way to proceed.
    The problem with this straightforward approach is that you will be running the
    classical part of the algorithm locally. Then, each time that an energy estimation
    is required, a new job will be submitted to the quantum computer and you will
    have to wait on the queue if other users have also sent jobs to execute. This
    can be quite slow, not because of the process itself, but because of the queue
    waiting times.*
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '*Fortunately, Qiskit has recently introduced a new module called Runtime that
    allows us to reduce the execution time for hybrid algorithms such as QAOA. Instead
    of submitting each circuit individually, with Runtime you can submit a **program**
    that includes both the classical and the quantum part of the algorithm. The program
    is then queued just once, greatly speeding up the whole execution.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 'Using Runtime with QAOA is very easy. In fact, we just need to specify the
    same elements that we have used with the `QAOA` class, but in a slightly different
    way. The following piece of code shows an example of how to do this:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This will create and run a QAOA Runtime job whose quantum part will be executed
    in the quantum computer that we have specified in the `options``[``"``backend_name``"``]`
    field — in our case, `ibmq_belem`. We have used the ![Z_{0}Z_{1}](img/file352.png
    "Z_{0}Z_{1}") Hamiltonian, COBYLA as the optimizer, a value of ![p = 1](img/file676.png
    "p = 1") (specified with the `reps` variable), and ![1024](img/file291.png "1024")
    shots.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: We have also chosen the initial values of ![\beta_{1}](img/file684.png "\beta_{1}")
    and ![\gamma_{1}](img/file683.png "\gamma_{1}") to be ![0](img/file12.png "0")
    with the `initial_point` field. If this field is not used, the initial values
    are chosen at random.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the program has finished running (you can keep track of its execution
    using `job``.``status``()`), the result can be retrieved with `job``.``result``()`.
    We can access some of its parameters with the following instructions:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In our case, running those lines of code offered the following result:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can appreciate, the results are slightly worse than with the simulator,
    due to the influence of noise. But the two optimal basis states — ![01](img/file159.png
    "01") and ![10](img/file161.png "10") — are still the most probable ones and,
    therefore, if we prepare and measure the final state several times, we will have
    a very high probability of finding an optimal solution.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: So now we know how to solve problems with QAOA using Qiskit, both with simulators
    and with actual quantum computers. However, so far, we’ve had to prepare the Hamiltonian
    of the problem ourselves, and that is not ideal. As we learned in *Chapter* *[*3*](ch011.xhtml#x1-590003),
    *Working with Quadratic Unconstrained* *Binary Optimization Problems*, for many
    problems, it is more convenient to work with a QUBO formulation or even to write
    the problem as a binary linear program. Would it be possible to use those formalisms
    directly with QAOA in Qiskit? Absolutely! We’ll show you how in the next subsection.*
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '*## 5.2.2 Solving QUBO problems with QAOA in Qiskit'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Qiskit provides tools to work with quadratic problems, both with and without
    constraints, which are similar to the ones that we studied when working with Ocean
    in *Chapter* *[*4*](ch012.xhtml#x1-750004), *Quantum Adiabatic Computing and Quantum
    Annealing*. For example, we can define a simple binary program with the following
    piece of code:*
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '*[PRE8]'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, we are defining a quadratic problem with three binary variables,
    a function to minimize that has a linear and a quadratic part, and a linear constraint
    in the binary variables. When we run these instructions, we obtain the following
    output:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The problem has exactly the elements that we specified. The only detail that
    may deserve a small explanation is why the quadratic part of the objective function
    is represented as ![\left. (4xy - 8yz)\slash 2 \right.](img/file765.png "\left.
    (4xy - 8yz)\slash 2 \right.") instead of ![2xy - 4yz](img/file766.png "2xy - 4yz").
    The reason for this seemingly odd choice is that, in this way, the matrix with
    the quadratic coefficients can be made symmetric. Instead of having ![2](img/file302.png
    "2") for the ![xy](img/file722.png "xy") coefficient and ![0](img/file12.png "0")
    for the ![yx](img/file767.png "yx") product, the value is duplicated and both
    terms will have ![2](img/file302.png "2") as their coefficient — but then we need
    to divide by ![2](img/file302.png "2") so that the total coefficient remains as
    in the original specification.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: To learn more…
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: 'The internal representation of these quadratic problems is the one used by
    CPLEX, an IBM package that is used to solve optimization problems with classical
    methods. You can learn more about CPLEX on its web page: [https://www.ibm.com/products/ilog-cplex-optimization-studio](https://www.ibm.com/products/ilog-cplex-optimization-studio).'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have a `QuadraticProgram` object, we can solve it with one of the algorithms
    provided by Qiskit. To achieve this, we can use `MinimumEigenOptimizer` together
    with a concrete solver. For example, we can use a classical exact solver, which
    tries every possible solution and selects the optimal one. In Qiskit, this is
    as simple as using the following instructions:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The result of the execution is as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you can see, we obtain the optimal assignment (![x = 0](img/file768.png "x
    = 0"), ![y = 1](img/file769.png "y = 1") and ![z = 1](img/file770.png "z = 1")),
    the optimal value of the function (in this case, ![- 5](img/file591.png "- 5")),
    and whether the assignment satisfies the constraints, indicated by the `SUCCESS`
    value, or not — if there were no assignments satisfying the constraints, we would
    obtain `INFEASIBLE` as the value for `status`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: 'In a similar way, we can use QAOA to solve the problem with the following instructions:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In this case, the result will be the same one that we obtained with `NumPyMinimumEigensolver`.
    But we can also obtain additional information with the following instructions:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The result will be something like the following:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: First, we have printed the order of variables, to more easily interpret the
    assignments considered by the solver. Then, we have a listing of the different
    solutions that are part of the final, optimal state found by QAOA. Each item of
    the list includes the assignment, the energy or function value, the probability
    of obtaining the corresponding basis state when measuring the QAOA state, and
    whether the solution is feasible or not — `status``=<``OptimizationResultStatus``.``SUCCESS``:`
    `0>` indicates that the solution is feasible, while `status``=<``OptimizationResultStatus``.``INFEASIBLE``:`
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '`2>` indicates that it is not.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 5.6
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the code that we have just run to make the results reproducible. *Hint*:
    you can set seeds in the same way that we did in *Section* *[*5.2.1*](#x1-1020005.2.1).*'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '*We can also obtain full information about the QAOA execution by using the
    following:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We would obtain something like the following (where we have truncated part
    of the output):'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '@empty'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Notice, however, that these assignments include the auxiliary variables used
    in the transformation from constrained to unconstrained problem, as in the procedure
    that we studied in *Chapter* *[*3*](ch011.xhtml#x1-590003), *Working with Quadratic
    Unconstrained* *Binary Optimization Problems*, and the function values are also
    the ones taken in the transformed problem. In fact, you can obtain the corresponding
    QUBO problem with the following code:*
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '*[PRE17]'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: 'The output will be the following:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you can see, this is now a QUBO problem in which slack variables and penalty
    terms have been introduced, exactly as we did in *Chapter* *[*3*](ch011.xhtml#x1-590003),
    *Working* *with Quadratic Unconstrained Binary Optimization Problems*.*
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '*To learn more…'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: In the `qiskit_optimization``.` `converters` module, you can also find the functions
    `InequalityToEquality`, `IntegerToBinary`, and `LinearEqualityToPenalty`. The
    `QuadraticProgramToQubo` function calls them to convert quadratic programs with
    constraints into QUBO instances, by first introducing slack variables to transform
    inequalities into equalities, then transforming the integer slack variables into
    binary ones, and finally, replacing the equality constraints with penalty terms.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: You may now be wondering how to use `MinimumEigenOptimizer` with a quantum computer
    instead of with a simulator. Of course, when defining the `quantum_instance` parameter
    to use with the `QAOA` object, you can simply declare a real quantum device. But,
    as we have already mentioned, that would imply entering the device queue many
    times, with the consequent delay.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: 'As you surely remember from the previous subsection, if you have a Hamiltonian,
    you can use it directly in a QAOA Runtime program in order to submit your problem
    to the queue just once. So, is it possible to obtain the Hamiltonian of our problem?
    It sure is! You can run the following code to further transform the QUBO problem
    into an equivalent Hamiltonian:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You can then use `H1` to solve the problem with the QAOA Runtime program and
    even recover the energy by adding back the `offset` term. But... that seems like
    a lot of work, doesn’t it? What’s more, you would need to deal with all those
    ugly slack variables that were introduced to transform the quadratic program into
    QUBO form. Surely, there has to be a simpler way.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, the Qiskit developers are very thoughtful, and they have enabled
    us to use Qiskit Runtime directly with `MinimumEigenOptimizer`. To do that, though,
    you need something called the `QAOAClient`, which will take care of running everything
    smoothly with Runtime once you plug it into `MinimumEigenOptimizer`. Using it
    is as simple as selecting a device with enough qubits. We need at least ![6](img/file576.png
    "6"), so we have selected `ibm_lagos`, which has ![7](img/file465.png "7"); if
    you don’t have access to a big enough device, you can always use `ibmq_qasm_simulator`,
    which supports up to ![32](img/file771.png "32"). And once we have a device, we
    can just run the following instructions:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This will yield the following output:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: And, of course, you can obtain further information about the execution, as we
    did in previous examples, by accessing and using the values of the variables `result``.``variables`,
    `result``.``samples`, and `result``.``min_eigen_solver_result`. Very convenient,
    right?
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: We have now learned how to work with QAOA in Qiskit and how to manage and solve
    our problems in many different ways. It is time for us to turn back to PennyLane
    and see what it can offer in order to solve our beloved QUBO problems.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 5.3 Using QAOA with PennyLane
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we mentioned in *Chapter* *[*2*](ch009.xhtml#x1-400002), *The Tools of the
    Trade in Quantum Computing*, PennyLane is a quantum programming library focused
    mainly on quantum machine learning. As such, it doesn’t include as many tools
    for quantum optimization algorithms — such as QAOA — as Qiskit does. However,
    it does provide some interesting features such as automatic differentiation —
    that is, analytical computation of gradients — that may make it an appealing alternative
    to Qiskit in some circumstances.*
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '*Let’s begin by explaining how to declare and work with Hamiltonians in PennyLane.
    For that, we will use the `Hamiltonian` class. It provides a constructor that
    accepts a list of coefficients and a list of products of Pauli matrices. For instance,
    if you want to define ![2Z_{0}Z_{1} - Z_{0}Z_{2} + 3.5Z_{1}](img/file772.png "2Z_{0}Z_{1}
    - Z_{0}Z_{2} + 3.5Z_{1}"), you will pass `[2,-1,3.5]` as the first argument and
    `[``PauliZ``(0)``@PauliZ``(1),``PauliZ``(0)``@PauliZ``(2),``PauliZ``(1)]` as the
    second one. As we know from *Chapter* * [*2*](ch009.xhtml#x1-400002), *The Tools
    of the Trade in Quantum Computing*, `PauliZ` is the ![Z](img/file8.png "Z") matrix
    in PennyLane. We are also using the `@` operator, which is PennyLane’s symbol
    for the tensor product operation. Putting it all together, we get the following
    instructions:*'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '*[PRE22]'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: 'The output when we execute that code will be the following:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'As you can see, we have constructed exactly the Hamiltonian that we wanted.
    We can also obtain its matrix by using `print``(``qml``.``matrix``(``H``))`, which
    would give us the following output:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'As expected, this is a diagonal matrix. We can visualize it in a more compact
    way by executing the following instructions, which will give us only the non-zero
    elements:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The result will be the following:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You can also define Hamiltonians in a more compact manner by specifying them
    in a mathematical expression like the following one:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If you print `H`, you will find that this definition is equivalent to the one
    that was introduced previously.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 5.7
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: Use PennyLane to define the ![- 3Z_{0}Z_{1}Z_{2} + 2Z_{1}Z_{2} - Z_{2}](img/file773.png
    "- 3Z_{0}Z_{1}Z_{2} + 2Z_{1}Z_{2} - Z_{2}") Hamiltonian in two different ways.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to define Hamiltonians, we can use them to create QAOA
    circuits with PennyLane. To this end, we will import the `qaoa` module, which
    will give us access to the `cost_layer` and `mixer_layer` functions. We will need
    a cost Hamiltonian — the one that encodes our optimization problem — to use with
    `cost_layer` and we will use ![{\sum}_{j}X_{j}](img/file774.png "{\sum}_{j}X_{j}")
    with `mixer_layer` (in the QAOA literature, our ![H_{0}](img/file545.png "H_{0}")
    Hamiltonian is sometimes called the **mixer Hamiltonian**, hence the name of the
    function). With them, we can create a function that constructs the QAOA circuit
    and that computes the energy of the state prepared by the circuit with respect
    to ![H_{1}](img/file544.png "H_{1}"). This latter part is very easy to accomplish
    with PennyLane, because it provides the `expval` function, which computes exactly
    that, and it can be used instead of the types of measurements that we introduced
    in *Section* * [*2.3.1*](ch009.xhtml#x1-530002.3.1).*
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '*We can, thus, define a function that computes the energy of parameters with
    the following piece of code:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: There are several details that we need to explain here. First, we are working
    with a simple problem in which we want to find the ground state of ![Z_{0}Z_{1}](img/file352.png
    "Z_{0}Z_{1}"). We have defined our ![H_{0}](img/file545.png "H_{0}") Hamiltonian
    as ![X_{0} + X_{1}](img/file775.png "X_{0} + X_{1}") with `H0` `=` `qml``.``PauliX``(0)`
    `+` `qml``.``PauliX``(1)`. For ![H_{1}](img/file544.png "H_{1}"), we have used
    `1.0*``qml``.``PauliZ``(0)` `@` `qml``.``PauliZ``(1)` instead of just `qml``.``PauliZ``(0)`
    `@` `qml``.``PauliZ``(1)`. If you do not include the `1.0` coefficient, the tensor
    product will not be converted to a `Hamiltonian` object, so you should be careful
    with that. Another important detail is that the `energy` function only receives
    as parameters the angles for the rotations in the QAOA circuit and we have declared
    `p` as a global variable. This is because we later want to optimize `energy` with
    respect to its parameters, and `p` is not something that we want to optimize,
    but a fixed value — in this case, we are setting it to ![2](img/file302.png "2").
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, notice that the exponentials for ![H_{1}](img/file544.png "H_{1}")
    and ![H_{0}](img/file545.png "H_{0}") receive their parameters from the `angles`
    list alternating between ![H_{0}](img/file545.png "H_{0}") and ![H_{1}](img/file544.png
    "H_{1}"): first for the ![H_{0}](img/file545.png "H_{0}") exponential (which is
    implemented by `mixer_layer`), then for the ![H_{1}](img/file544.png "H_{1}")
    exponential (implemented by `cost_layer`), then again for the ![H_{0}](img/file545.png
    "H_{0}") exponential, and so on. In the notation that we have been using throughout
    this chapter, if `angles` is `[1.0,2.0.3.0,4.0]`, then we would have ![\beta_{1}
    = 1](img/file753.png "\beta_{1} = 1"), ![\gamma_{1} = 2](img/file776.png "\gamma_{1}
    = 2"), ![\beta_{2} = 3](img/file777.png "\beta_{2} = 3"), and ![\gamma_{2} = 4](img/file756.png
    "\gamma_{2} = 4"). Now we are ready to run the optimization process. To do that,
    we can use the following code:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We are using `GradientDescentOptimizer` as the classical minimizer. It uses
    the famous gradient descent algorithm — we will study this method in detail in
    *Part* *[*III*](ch016.xhtml#x1-138000III) of the book — by taking advantage of
    the fact that PennyLane implements automatic differentiation to compute all the
    required derivatives. That is why we use `requires_grad``=``True` when defining
    the initial angles, to inform PennyLane that these are parameters for which we
    will need to compute gradients. We run the process for 10 steps and…voilá! We
    obtain some (close to) optimal parameters. In this case, `[0.78178403` `0.7203965`
    `1.17250771`*
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '*`1.27995423]` was the answer found by the optimizer. The angles and energy
    that you find can be highly dependent on the initial parameters, so it is advisable
    to run your code with several different choices of initial angles.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: 'In any case, we can now sample from the QAOA circuit with the parameters that
    we have found in order to obtain candidate solutions to our problem. We just need
    to modify slightly the `energy` function that we defined previously. We can do
    it, for instance, as follows:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The output when you run these instructions will be something like the following:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The five samples are, indeed, ground states of ![Z_{0}Z_{1}](img/file352.png
    "Z_{0}Z_{1}"). Once more, we have been able to use QAOA to solve the problem,
    this time with PennyLane!
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: You surely have noticed that we have run our code on the `default``.``qubit`
    device, which is a simulator. Of course, you can replace it with a quantum device,
    as we learned to do in *Section* *[*2.3.2*](ch009.xhtml#x1-540002.3.2). However,
    this will mean that you will have to wait on the quantum computer execution queue
    every time the optimizer needs to evaluate the energy of some parameters.*
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '*Unfortunately, at the time of writing, PennyLane does not yet include an option
    to run QAOA programs using Qiskit Runtime. However, do not despair! As we will
    learn in *Chapter* *[*7*](ch015.xhtml#x1-1190007)*, VQE: Variational Quantum*
    *Solver*, there is a PennyLane implementation of Runtime programs for some other
    algorithms. Hopefully, QAOA will receive the same treatment soon.*'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '*With this, we have now concluded our study of QAOA. In the next chapter, we
    will study a different method for finding solutions to optimization problems,
    and it will be based on one of the most famous of all quantum algorithms ever:
    Grover’s algorithm.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you have learned about QAOA, one of the most popular quantum
    algorithms used to solve optimization problems with gate-based quantum computers.
    You now know that QAOA is derived as a discretization of quantum annealing and
    that it is implemented as a hybrid method that uses both a classical and a quantum
    computer to achieve its goal.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: You also understand how to construct circuits for all the operations needed
    in the quantum part of the algorithm. In particular, you know how to use these
    circuits to estimate expectation values in an efficient way.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: You have also mastered the tools that Qiskit provides in order to implement
    QAOA instances and to run them on both quantum simulators and quantum computers.
    You even know how to accelerate the process of running your code on quantum devices
    by using Qiskit Runtime. And, should you need to use QAOA with PennyLane, you
    also know how to do it with the help of some predefined utilities and PennyLane
    capabilities for automatic differentiation. This gives you the flexibility to
    solve optimization problems with QAOA in a number of different ways, depending
    on your needs and on the resources at your disposal.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: Our next stop will be **Grover’s Adaptive Search**, also known as **GAS**, a
    quite different quantum method that you can use to solve optimization problems,
    which we’ll cover in the next chapter.***********************************
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
