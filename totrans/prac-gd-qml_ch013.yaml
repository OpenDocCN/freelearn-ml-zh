- en: Chapter 5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'QAOA: Quantum Approximate Optimization Algorithm'
  prefs: []
  type: TYPE_NORMAL
- en: '*True optimization is the revolutionary contribution of modern* *research to
    decision processes.*'
  prefs: []
  type: TYPE_NORMAL
- en: — George Dantzig
  prefs: []
  type: TYPE_NORMAL
- en: The techniques that we have introduced in the two previous chapters already
    allow us to solve combinatorial optimization problems on quantum computers. Specifically,
    we have studied how to write problems using the QUBO formalism and how to use
    quantum annealers to sample approximate solutions. This is an important approach
    to quantum optimization, but it is not the only one.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are going to show how the ideas that we have already explored
    can also be used on digital quantum computers. We will be using our beloved quantum
    circuits — with all their qubits, quantum gates, and measurements — to solve combinatorial
    optimization problems formulated in the QUBO framework.
  prefs: []
  type: TYPE_NORMAL
- en: More concretely, we will be studying the famous **Quantum Approximate** **Optimization
    Algorithm** (**QAOA**), which is a gate-based algorithm that can be understood
    to be the counterpart to quantum annealing in the quantum circuit model. We will
    start by introducing all the theoretical concepts that are needed in order to
    understand this algorithm, then we will study the kind of circuits used in its
    implementation, and finally, we will explain how to run QAOA with both Qiskit
    and PennyLane.
  prefs: []
  type: TYPE_NORMAL
- en: After reading this chapter, you will understand how QAOA works, you will know
    how to design the circuits used in the algorithm, and you will be able to solve
    your own combinatorial optimization problems using QAOA in Qiskit and PennyLane.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics that we will cover in this chapter are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: From adiabatic computing to QAOA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using QAOA with Qiskit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using QAOA with PennyLane
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5.1 From adiabatic computing to QAOA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this first section, we will introduce all the theoretical concepts that will
    allow us to understand QAOA in depth. But before that, we will give an intuitive
    idea of how QAOA works by studying its relationship with quantum annealing. Sounds
    interesting? Then keep on reading, because here we go!
  prefs: []
  type: TYPE_NORMAL
- en: 5.1.1 Discretizing adiabatic quantum computing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous chapter, we studied adiabatic quantum computing and its practical
    realization, quantum annealing, and we learned how to use them in order to obtain
    approximate solutions to combinatorial optimization problems. Both of these techniques
    relied on the adiabatic theorem. When we applied them, we used a time-dependent
    Hamiltonian that induced a continuous transformation of the state of a quantum
    system: from an initial state to a final state that — hopefully — has a big overlap
    with the solution to our problem.'
  prefs: []
  type: TYPE_NORMAL
- en: A natural question to ask is whether there is any sort of analog to this way
    of solving optimization problems for circuit-based quantum computers. At first
    sight, there is an apparent difficulty in this idea, because in the quantum circuit
    model we apply *instantaneous* operations — quantum gates — that change the state
    vector in discrete steps. How can we resolve this ”tension” between these discrete
    operations and the continuous evolution that we rely on for adiabatic quantum
    computing?
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer is that we may **discretize** any continuous evolution, approximating
    it with a sequence of small, discrete changes. This process, sometimes called
    **Trotterization**, is the inspiration for the topic to which this chapter is
    devoted: the Quantum Approximate Optimization Algorithm — QAOA, for short.'
  prefs: []
  type: TYPE_NORMAL
- en: QAOA was initially proposed [[37](ch030.xhtml#Xfarhi2014quantum)] as a **discretization**
    or Trotterization of adiabatic quantum computing with the goal of approximating
    the optimal solutions to combinatorial optimization problems. As you surely remember,
    the Hamiltonian that is used in adiabatic quantum computing — and in quantum annealing
    — is of the form
  prefs: []
  type: TYPE_NORMAL
- en: '![H(t) = A(t)H_{0} + B(t)H_{1},](img/file546.png "H(t) = A(t)H_{0} + B(t)H_{1},")'
  prefs: []
  type: TYPE_IMG
- en: with ![H_{0}](img/file545.png "H_{0}") and ![H_{1}](img/file544.png "H_{1}")
    two fixed Hamiltonians and ![A(t)](img/file623.png "A(t)") and ![B(t)](img/file624.png
    "B(t)") functions satisfying ![A(0) = B(T) = 1](img/file548.png "A(0) = B(T) =
    1") and ![A(T) = B(0) = 0](img/file549.png "A(T) = B(0) = 0"), where ![T](img/file74.png
    "T") is the total time of the process. It turns out that the evolution of the
    quantum system is governed by the famous time-dependent Schrödinger equation,
    and if you can solve it, you will have an expression for the state vector of your
    system at any moment ![t](img/file48.png "t") between ![0](img/file12.png "0")
    and ![T](img/file74.png "T").
  prefs: []
  type: TYPE_NORMAL
- en: However, to understand QAOA we don’t need to learn how to solve the Schrödinger
    equation — that was close, but we managed to dodge the bullet! All that we need
    to know is that, applying discretization, we can express the solution as a product
    of operators of the form
  prefs: []
  type: TYPE_NORMAL
- en: '![e^{i\Delta t{({A(t_{c})H_{0} + B(t_{c})H_{1}})}}](img/file625.png "e^{i\Delta
    t{({A(t_{c})H_{0} + B(t_{c})H_{1}})}}")'
  prefs: []
  type: TYPE_IMG
- en: applied to the initial state. Here, ![i](img/file49.png "i") is the imaginary
    unit, ![t_{c}](img/file626.png "t_{c}") is a fixed time point in ![\lbrack 0,T\rbrack](img/file547.png
    "\lbrack 0,T\rbrack"), and ![\Delta t](img/file627.png "\Delta t") is a small
    amount of time. The key idea is that in the interval ![\lbrack t_{c},t_{c} + \Delta
    t\rbrack](img/file628.png "\lbrack t_{c},t_{c} + \Delta t\rbrack") we assume that
    the Hamiltonian is constant and equal to ![H(t_{c}) = A(t_{c})H_{0} + B(t_{c})H_{1}](img/file629.png
    "H(t_{c}) = A(t_{c})H_{0} + B(t_{c})H_{1}"). Of course, the smaller ![\Delta t](img/file627.png
    "\Delta t") is, the better this approximation will be. It is also important to
    notice that ![e^{i\Delta t{({A(t_{c})H_{0} + B(t_{c})H_{1}})}}](img/file630.png
    "e^{i\Delta t{({A(t_{c})H_{0} + B(t_{c})H_{1}})}}") is a unitary transformation,
    just like the ones we studied in *Chapter* * [*1*](ch008.xhtml#x1-180001), *Foundations
    of Quantum Computing*. In fact, you surely remember that some of the quantum gates
    that we introduced in that chapter, such as ![R_{X}](img/file118.png "R_{X}"),
    ![R_{Y}](img/file119.png "R_{Y}"), and ![R_{Z}](img/file120.png "R_{Z}"), are
    also exponentials of some matrices. Using this discretization technique, if ![\left|
    \psi_{0} \right\rangle](img/file631.png "\left| \psi_{0} \right\rangle") is the
    initial state, then the final state can be approximated by*
  prefs: []
  type: TYPE_NORMAL
- en: '*![\left( {\prod\limits_{m = 0}^{p}e^{i\Delta t{({A(t_{m})H_{0} + B(t_{m})H_{1}})}}}
    \right)\left| \psi_{0} \right\rangle,](img/file632.png "\left( {\prod\limits_{m
    = 0}^{p}e^{i\Delta t{({A(t_{m})H_{0} + B(t_{m})H_{1}})}}} \right)\left| \psi_{0}
    \right\rangle,")'
  prefs: []
  type: TYPE_NORMAL
- en: where ![t_{m} = m\frac{\Delta t}{T}](img/file633.png "t_{m} = m\frac{\Delta
    t}{T}") and ![p = \frac{T}{\Delta t}](img/file634.png "p = \frac{T}{\Delta t}").
  prefs: []
  type: TYPE_NORMAL
- en: In order to compute this state with a quantum circuit, we just need an additional
    approximation. As you know, for any real numbers ![a](img/file16.png "a") and
    ![b](img/file17.png "b"), it holds that ![e^{a + b} = e^{a}e^{b}](img/file635.png
    "e^{a + b} = e^{a}e^{b}"). The analogous identity for exponentials of matrices
    does not hold in general — unless the matrices commute. However, if ![\Delta t](img/file627.png
    "\Delta t") is small, then
  prefs: []
  type: TYPE_NORMAL
- en: '![e^{i\Delta t{({A(t_{c})H_{0} + B(t_{c})H_{1}})}} \approx e^{i\Delta tA(t_{c})H_{0}}e^{i\Delta
    tB(t_{c})H_{1}},](img/file636.png "e^{i\Delta t{({A(t_{c})H_{0} + B(t_{c})H_{1}})}}
    \approx e^{i\Delta tA(t_{c})H_{0}}e^{i\Delta tB(t_{c})H_{1}},")'
  prefs: []
  type: TYPE_IMG
- en: which is known as the **Lie-Trotter formula**.
  prefs: []
  type: TYPE_NORMAL
- en: Putting it all together, the final state of the adiabatic evolution can be approximated
    by
  prefs: []
  type: TYPE_NORMAL
- en: '![\prod\limits_{m = 0}^{p}e^{i\Delta tA(t_{m})H_{0}}e^{i\Delta tB(t_{m})H_{1}}\left|
    \psi_{0} \right\rangle,](img/file637.png "\prod\limits_{m = 0}^{p}e^{i\Delta tA(t_{m})H_{0}}e^{i\Delta
    tB(t_{m})H_{1}}\left| \psi_{0} \right\rangle,")'
  prefs: []
  type: TYPE_IMG
- en: which is the inspiration for QAOA, as we will see in the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: '5.1.2 QAOA: The algorithm'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The starting point and goal of QAOA are exactly the same as those of quantum
    annealing. We begin with a combinatorial optimization problem that we want to
    solve, and we encode it, as we learned in *Chapter* *[*3*](ch011.xhtml#x1-590003),
    *Working with Quadratic* *Unconstrained Binary Optimization Problems*, into an
    Ising Hamiltonian ![H_{1}](img/file544.png "H_{1}"). In order to find its ground
    state and solve our problem, we seek to apply a quantum state evolution similar
    to that of quantum annealing, but using a quantum circuit instead of a quantum
    annealer.*
  prefs: []
  type: TYPE_NORMAL
- en: '*In light of the discretization of adiabatic evolution that we obtained at
    the end of the previous subsection, the idea behind QAOA is simple. In order to
    simulate with a quantum circuit the evolution of a state under a time-dependent
    Hamiltonian, you only need to take an initial state ![\left| \psi_{0} \right\rangle](img/file631.png
    "\left| \psi_{0} \right\rangle") and then alternate for ![p](img/file141.png "p")
    times the application of the operators ![e^{i\gamma H_{1}}](img/file638.png "e^{i\gamma
    H_{1}}") and ![e^{i\beta H_{0}}](img/file639.png "e^{i\beta H_{0}}") for some
    values of ![\gamma](img/file127.png "\gamma") and ![\beta](img/file126.png "\beta").
    In the next subsection, by the way, we will see that the unitary transformations
    ![e^{i\gamma H_{1}}](img/file638.png "e^{i\gamma H_{1}}") and ![e^{i\beta H_{0}}](img/file639.png
    "e^{i\beta H_{0}}") can be implemented with just one-qubit and two-qubit quantum
    gates.'
  prefs: []
  type: TYPE_NORMAL
- en: What we are doing is, then, using a quantum circuit to prepare a state of the
    form
  prefs: []
  type: TYPE_NORMAL
- en: '![e^{i\beta_{p}H_{0}}e^{i\gamma_{p}H_{1}}\ldots e^{i\beta_{2}H_{0}}e^{i\gamma_{2}H_{1}}e^{i\beta_{1}H_{0}}e^{i\gamma_{1}H_{1}}\left|
    \psi_{0} \right\rangle,](img/file640.png "e^{i\beta_{p}H_{0}}e^{i\gamma_{p}H_{1}}\ldots
    e^{i\beta_{2}H_{0}}e^{i\gamma_{2}H_{1}}e^{i\beta_{1}H_{0}}e^{i\gamma_{1}H_{1}}\left|
    \psi_{0} \right\rangle,")'
  prefs: []
  type: TYPE_IMG
- en: where ![p \geq 1](img/file641.png "p \geq 1"). Usually, we collect all the coefficients
    in the exponents in two tuples ![\mathbf{\beta} = (\beta_{1},\ldots,\beta_{p})](img/file642.png
    "\mathbf{\beta} = (\beta_{1},\ldots,\beta_{p})") and ![\mathbf{\gamma} = (\gamma_{1},\ldots,\gamma_{p})](img/file643.png
    "\mathbf{\gamma} = (\gamma_{1},\ldots,\gamma_{p})") and we denote the whole state
    by ![\left| {\mathbf{\beta},\mathbf{\gamma}} \right\rangle](img/file644.png "\left|
    {\mathbf{\beta},\mathbf{\gamma}} \right\rangle").
  prefs: []
  type: TYPE_NORMAL
- en: In QAOA, we choose a fixed value of ![p](img/file141.png "p") and we have some
    values for ![\mathbf{\beta}](img/file645.png "\mathbf{\beta}") and ![\mathbf{\gamma}](img/file646.png
    "\mathbf{\gamma}"). Instead of thinking of the values for ![\mathbf{\beta}](img/file645.png
    "\mathbf{\beta}") and ![\mathbf{\gamma}](img/file646.png "\mathbf{\gamma}") as
    small increments of time multiplied by intensity coefficients given by the functions
    ![A](img/file183.png "A") and ![B](img/file184.png "B"), as we did in the previous
    subsection, we’ll just consider them to be ”plain real numbers.” And this is where
    the magic kicks in. Since we are now free to choose their values as we see fit…why
    not choose the *best* possible values for them?
  prefs: []
  type: TYPE_NORMAL
- en: 'But what does *best* mean here? Remember that we are just trying to find the
    ground state of ![H_{1}](img/file544.png "H_{1}"), so, for us, the lower the value
    of the energy ![\left\langle {\mathbf{\beta},\mathbf{\gamma}} \right|H_{1}\left|
    {\mathbf{\beta},\mathbf{\gamma}} \right\rangle](img/file647.png "\left\langle
    {\mathbf{\beta},\mathbf{\gamma}} \right|H_{1}\left| {\mathbf{\beta},\mathbf{\gamma}}
    \right\rangle"), the better. In this way, we have transformed our optimization
    problem into another one: finding the values ![\mathbf{\beta}](img/file645.png
    "\mathbf{\beta}") and ![\mathbf{\gamma}](img/file646.png "\mathbf{\gamma}") that
    minimize'
  prefs: []
  type: TYPE_NORMAL
- en: '![E(\mathbf{\beta},\mathbf{\gamma}) = \left\langle {\mathbf{\beta},\mathbf{\gamma}}
    \right|H_{1}\left| {\mathbf{\beta},\mathbf{\gamma}} \right\rangle.](img/file648.png
    "E(\mathbf{\beta},\mathbf{\gamma}) = \left\langle {\mathbf{\beta},\mathbf{\gamma}}
    \right|H_{1}\left| {\mathbf{\beta},\mathbf{\gamma}} \right\rangle.")'
  prefs: []
  type: TYPE_IMG
- en: Notice that, since the values ![\mathbf{\beta}](img/file645.png "\mathbf{\beta}")
    and ![\mathbf{\gamma}](img/file646.png "\mathbf{\gamma}") are real and so is the
    energy ![E(\mathbf{\beta},\mathbf{\gamma})](img/file649.png "E(\mathbf{\beta},\mathbf{\gamma})"),
    what we have in our hands is the old problem of finding a minimum for a real-valued
    function with real inputs. There are many algorithms that we can apply for this,
    for instance, the famous **gradient descent algorithm**, which we will be using
    to train machine learning models in *Part* * [*III*](ch016.xhtml#x1-138000III),
    *A Match Made in Heaven:* *Quantum Machine Learning*, of this book. However, there
    is an important twist. As we know, the number of amplitudes needed to describe
    a state like ![\left| {\mathbf{\beta},\mathbf{\gamma}} \right\rangle](img/file644.png
    "\left| {\mathbf{\beta},\mathbf{\gamma}} \right\rangle") is exponential in the
    number of qubits that we are using. Thus, computing ![E(\mathbf{\beta},\mathbf{\gamma})](img/file649.png
    "E(\mathbf{\beta},\mathbf{\gamma})") may be difficult with just a classical computer.*
  prefs: []
  type: TYPE_NORMAL
- en: '*But it turns out that estimating values of ![E(\mathbf{\beta},\mathbf{\gamma})](img/file649.png
    "E(\mathbf{\beta},\mathbf{\gamma})") is something that we can do very efficiently
    with a quantum computer — at least when the number of terms in ![H_{1}](img/file544.png
    "H_{1}") is polynomial in the number of qubits, something that is usually the
    case in the problems we are interested in. In the next subsection, we will explain
    in detail how to compute that kind of estimation, but for now just keep in mind
    that, given some values ![\mathbf{\beta}](img/file645.png "\mathbf{\beta}") and
    ![\mathbf{\gamma}](img/file646.png "\mathbf{\gamma}"), we can rely on the quantum
    computer to compute ![E(\mathbf{\beta},\mathbf{\gamma})](img/file649.png "E(\mathbf{\beta},\mathbf{\gamma})").'
  prefs: []
  type: TYPE_NORMAL
- en: Then, we can take any classical algorithm for function minimization and, whenever
    it needs to compute a value of the ![E](img/file327.png "E") function, we use
    a quantum computer to estimate it and we give that value back to the classical
    algorithm until it needs another of value ![E](img/file327.png "E"). At that moment,
    we again use the quantum computer to obtain it and so on and so forth, all until
    we meet the stopping criteria of the classical algorithm. This is what we call
    a **hybrid algorithm**, one where the classical and the quantum computer work
    in tandem to solve a problem. We will see this kind of interaction many more times
    throughout the book.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have obtained the optimal values ![\mathbf{\beta^{\ast}}](img/file650.png
    "\mathbf{\beta^{\ast}}") and ![\mathbf{\gamma^{\ast}}](img/file651.png "\mathbf{\gamma^{\ast}}")
    for ![\mathbf{\beta}](img/file645.png "\mathbf{\beta}") and ![\mathbf{\gamma}](img/file646.png
    "\mathbf{\gamma}") — or, at least, an estimation of them — we can use the quantum
    computer once more in order to prepare the state ![\left| {\mathbf{\beta^{\ast}},\mathbf{\gamma^{\ast}}}
    \right\rangle](img/file652.png "\left| {\mathbf{\beta^{\ast}},\mathbf{\gamma^{\ast}}}
    \right\rangle"). This state should have a sizeable overlap with the ground state
    of ![H_{1}](img/file544.png "H_{1}"), so when we measure it in the computational
    basis, we will have a good chance of obtaining a string of zeros and ones that
    is a good solution to our original problem — the one encoded in ![H_{1}](img/file544.png
    "H_{1}") by using the techniques of *Chapter* * [*3*](ch011.xhtml#x1-590003),
    *Working with Quadratic Unconstrained* *Binary Optimization Problems*.*
  prefs: []
  type: TYPE_NORMAL
- en: '*We now have all the pieces of the puzzle, so let’s put them all together.
    The input to QAOA is an Ising Hamiltonian ![H_{1}](img/file544.png "H_{1}"), the
    ground state of which we wish to approximate because it encodes the solution to
    a certain combinatorial optimization problem. To that end, we consider the energy
    function ![E(\mathbf{\beta},\mathbf{\gamma})](img/file649.png "E(\mathbf{\beta},\mathbf{\gamma})")
    as defined before and we proceed to minimize it. For that, we choose ![p \geq
    1](img/file641.png "p \geq 1") and some initial values ![\mathbf{\beta_{0}}](img/file653.png
    "\mathbf{\beta_{0}}") and ![\mathbf{\gamma_{0}}](img/file654.png "\mathbf{\gamma_{0}}")
    that we shall use as the starting point for some classical minimization algorithm.
    Then, we run the minimization algorithm and, whenever it requests an evaluation
    of ![E](img/file327.png "E") on some points ![\mathbf{\beta}](img/file645.png
    "\mathbf{\beta}") and ![\mathbf{\gamma}](img/file646.png "\mathbf{\gamma}"), we
    use the quantum computer to prepare the state ![\left| {\mathbf{\beta},\mathbf{\gamma}}
    \right\rangle](img/file644.png "\left| {\mathbf{\beta},\mathbf{\gamma}} \right\rangle")
    and estimate its energy, and we return the value to the classical algorithm. We
    continue this process until the classical minimization algorithm stops, returning
    some optimal values ![\mathbf{\beta^{\ast}}](img/file650.png "\mathbf{\beta^{\ast}}")
    and ![\mathbf{\gamma^{\ast}}](img/file651.png "\mathbf{\gamma^{\ast}}"). As a
    final step, we use the quantum computer to prepare ![\left| {\mathbf{\beta^{\ast}},\mathbf{\gamma^{\ast}}}
    \right\rangle](img/file652.png "\left| {\mathbf{\beta^{\ast}},\mathbf{\gamma^{\ast}}}
    \right\rangle"). When we measure it, we obtain a — hopefully, good — approximate
    solution to our combinatorial problem.'
  prefs: []
  type: TYPE_NORMAL
- en: We have collected all these steps as pseudocode in the following algorithm.
    Notice that there are just two points at which the quantum computer is required.
  prefs: []
  type: TYPE_NORMAL
- en: '**Algorithm 5.1** (QAOA)**.**'
  prefs: []
  type: TYPE_NORMAL
- en: Choose a value for ![p](img/file141.png "p")
  prefs: []
  type: TYPE_NORMAL
- en: Choose a starting set of values ![\mathbf{\beta} = (\beta_{1},\ldots,\beta_{p})](img/file642.png
    "\mathbf{\beta} = (\beta_{1},\ldots,\beta_{p})") and ![\mathbf{\gamma} = (\gamma_{1},\ldots,\gamma_{p})](img/file643.png
    "\mathbf{\gamma} = (\gamma_{1},\ldots,\gamma_{p})")
  prefs: []
  type: TYPE_NORMAL
- en: '**while** the stopping criteria are not met **do**'
  prefs: []
  type: TYPE_NORMAL
- en: Prepare state ![\left| {\mathbf{\beta},\mathbf{\gamma}} \right\rangle](img/file644.png
    "\left| {\mathbf{\beta},\mathbf{\gamma}} \right\rangle")    ![\vartriangleright](img/file655.png
    "\vartriangleright") *This* *is done on the quantum computer!*
  prefs: []
  type: TYPE_NORMAL
- en: From measurements of ![\left| {\mathbf{\beta},\mathbf{\gamma}} \right\rangle](img/file644.png
    "\left| {\mathbf{\beta},\mathbf{\gamma}} \right\rangle"), estimate ![E(\mathbf{\beta},\mathbf{\gamma})](img/file649.png
    "E(\mathbf{\beta},\mathbf{\gamma})")
  prefs: []
  type: TYPE_NORMAL
- en: Update ![\mathbf{\beta}](img/file645.png "\mathbf{\beta}") and ![\mathbf{\gamma}](img/file646.png
    "\mathbf{\gamma}") according to the minimization algorithm
  prefs: []
  type: TYPE_NORMAL
- en: '-'
  prefs: []
  type: TYPE_NORMAL
- en: Obtain the optimal values ![\mathbf{\beta^{\ast}}](img/file650.png "\mathbf{\beta^{\ast}}")
    and ![\mathbf{\gamma^{\ast}}](img/file651.png "\mathbf{\gamma^{\ast}}") returned
    by the minimization algorithm
  prefs: []
  type: TYPE_NORMAL
- en: Prepare state ![\left| {\mathbf{\beta^{\ast}},\mathbf{\gamma^{\ast}}} \right\rangle](img/file652.png
    "\left| {\mathbf{\beta^{\ast}},\mathbf{\gamma^{\ast}}} \right\rangle")    ![\vartriangleright](img/file655.png
    "\vartriangleright") *This* *is done on the quantum computer!*
  prefs: []
  type: TYPE_NORMAL
- en: Measure the state to obtain an approximate solution
  prefs: []
  type: TYPE_NORMAL
- en: To learn more…
  prefs: []
  type: TYPE_NORMAL
- en: Just before bringing this subsection to an end, we thought this could be a good
    time for us to share a historical fact with you.
  prefs: []
  type: TYPE_NORMAL
- en: When it was introduced in a 2014 paper [[37](ch030.xhtml#Xfarhi2014quantum)],
    QAOA provided a better ratio of approximation for the Max-Cut problem than any
    existing classical algorithm that would run on polynomial time. And we say that
    it *provided* because, soon after, this claim was challenged by a paper [[11](ch030.xhtml#Xbarak2015beating)]
    that presented a classical algorithm that could beat QAOA.
  prefs: []
  type: TYPE_NORMAL
- en: What can we say? Sometimes classics refuse to die!
  prefs: []
  type: TYPE_NORMAL
- en: The description of QAOA that we have discussed may seem a little bit abstract.
    But don’t worry. In the next subsection, we will make all of this much more concrete,
    because we will be studying in detail the quantum circuits that are needed to
    implement the parts of the algorithm that run on quantum computers.
  prefs: []
  type: TYPE_NORMAL
- en: 5.1.3 Circuits for QAOA
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we have just seen, quantum computers are only used at certain steps in QAOA.
    And, in fact, those steps always involve the preparation of a state of the form
  prefs: []
  type: TYPE_NORMAL
- en: '![\left| {\mathbf{\beta},\mathbf{\gamma}} \right\rangle = e^{i\beta_{p}H_{0}}e^{i\gamma_{p}H_{1}}\ldots
    e^{i\beta_{2}H_{0}}e^{i\gamma_{2}H_{1}}e^{i\beta_{1}H_{0}}e^{i\gamma_{1}H_{1}}\left|
    \psi_{0} \right\rangle,](img/file656.png "\left| {\mathbf{\beta},\mathbf{\gamma}}
    \right\rangle = e^{i\beta_{p}H_{0}}e^{i\gamma_{p}H_{1}}\ldots e^{i\beta_{2}H_{0}}e^{i\gamma_{2}H_{1}}e^{i\beta_{1}H_{0}}e^{i\gamma_{1}H_{1}}\left|
    \psi_{0} \right\rangle,")'
  prefs: []
  type: TYPE_IMG
- en: where ![\left| \psi_{0} \right\rangle](img/file631.png "\left| \psi_{0} \right\rangle")
    is the ground state of ![H_{0}](img/file545.png "H_{0}"). Of course, we need to
    prepare the state with adequate quantum gates on a quantum circuit, so let’s analyze
    the operations that we need to perform. A crucial observation is that the Hamiltonians
    ![H_{0}](img/file545.png "H_{0}") and ![H_{1}](img/file544.png "H_{1}") take a
    very specific form. As we studied in the previous chapter, ![H_{0}](img/file545.png
    "H_{0}") is usually taken to be ![- {\sum}_{j = 0}^{n - 1}X_{j}](img/file657.png
    "- {\sum}_{j = 0}^{n - 1}X_{j}"), while ![H_{1}](img/file544.png "H_{1}") is an
    Ising Hamiltonian of the form
  prefs: []
  type: TYPE_NORMAL
- en: '![- \sum\limits_{j,k}J_{jk}Z_{j}Z_{k} - \sum\limits_{j}h_{j}Z_{j},](img/file554.png
    "- \sum\limits_{j,k}J_{jk}Z_{j}Z_{k} - \sum\limits_{j}h_{j}Z_{j},")'
  prefs: []
  type: TYPE_IMG
- en: where the coefficients ![J_{jk}](img/file342.png "J_{jk}") and ![h_{j}](img/file343.png
    "h_{j}") are real numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ground state of ![H_{0}](img/file545.png "H_{0}") is ![{\otimes}_{i = 0}^{n
    - 1}\left| + \right\rangle](img/file557.png "{\otimes}_{i = 0}^{n - 1}\left| +
    \right\rangle"), as you proved in *Exercise* * [*4.2*](ch012.xhtml#x1-77004x4.2).
    This state can be easily prepared: starting from ![\left| 0 \right\rangle](img/file6.png
    "\left| 0 \right\rangle"), you just need to use a Hadamard gate on each qubit
    of the circuit.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*That was easy, so let’s now focus on the operations of the form ![e^{i\beta_{k}H_{0}}](img/file658.png
    "e^{i\beta_{k}H_{0}}"), with ![\beta_{j}](img/file659.png "\beta_{j}") a real
    number. Notice that ![H_{0} = - {\sum}_{j = 0}^{n - 1}X_{j}](img/file555.png "H_{0}
    = - {\sum}_{j = 0}^{n - 1}X_{j}") and that all the ![X_{j}](img/file556.png "X_{j}")
    matrices commute with each other, so we can replace the exponential of the sum
    with the product of the exponentials. Therefore, it holds that'
  prefs: []
  type: TYPE_NORMAL
- en: '![e^{i\beta_{k}H_{0}} = e^{- i\beta_{k}\sum\limits_{j = 0}^{n - 1}X_{j}} =
    \prod\limits_{j = 0}^{n - 1}e^{- i\beta_{k}X_{j}}.](img/file660.png "e^{i\beta_{k}H_{0}}
    = e^{- i\beta_{k}\sum\limits_{j = 0}^{n - 1}X_{j}} = \prod\limits_{j = 0}^{n -
    1}e^{- i\beta_{k}X_{j}}.")'
  prefs: []
  type: TYPE_IMG
- en: But ![e^{- i\beta X_{j}}](img/file661.png "e^{- i\beta X_{j}}") is the expression
    for the rotation gate ![R_{X}(2\beta)](img/file662.png "R_{X}(2\beta)"), so this
    means that we just need to apply this gate to each of the qubits in our circuit.
    Neat, isn’t it?
  prefs: []
  type: TYPE_NORMAL
- en: The last type of operation that we need to translate into quantum gates is ![e^{i\gamma_{l}H_{1}}](img/file663.png
    "e^{i\gamma_{l}H_{1}}") for any real coefficient ![\gamma_{l}](img/file664.png
    "\gamma_{l}"). We know that ![H_{1}](img/file544.png "H_{1}") is a sum of terms
    of the form ![J_{jk}Z_{j}Z_{k}](img/file665.png "J_{jk}Z_{j}Z_{k}") and ![h_{j}Z_{j}](img/file666.png
    "h_{j}Z_{j}"). Again, these matrices commute with each other, so we get
  prefs: []
  type: TYPE_NORMAL
- en: '![e^{i\gamma_{l}H_{1}} = e^{- i\gamma_{l}(\sum\limits_{j,k}J_{jk}Z_{j}Z_{k}
    + \sum\limits_{j}h_{j}Z_{j})} = \prod\limits_{j,k}e^{- i\gamma_{l}J_{jk}Z_{j}Z_{k}}\prod\limits_{j}e^{-
    i\gamma_{l}h_{j}Z_{j}}.](img/file667.png "e^{i\gamma_{l}H_{1}} = e^{- i\gamma_{l}(\sum\limits_{j,k}J_{jk}Z_{j}Z_{k}
    + \sum\limits_{j}h_{j}Z_{j})} = \prod\limits_{j,k}e^{- i\gamma_{l}J_{jk}Z_{j}Z_{k}}\prod\limits_{j}e^{-
    i\gamma_{l}h_{j}Z_{j}}.")'
  prefs: []
  type: TYPE_IMG
- en: Similar to the case of ![H_{0}](img/file545.png "H_{0}"), the operations of
    the form ![e^{- i\gamma_{l}h_{j}Z_{j}}](img/file668.png "e^{- i\gamma_{l}h_{j}Z_{j}}")
    can be carried out with rotation gates ![R_{Z}](img/file120.png "R_{Z}"). Thus,
    we only need to learn how to implement ![e^{- i\gamma_{l}J_{jk}Z_{j}Z_{k}}](img/file669.png
    "e^{- i\gamma_{l}J_{jk}Z_{j}Z_{k}}"). To keep things simple, let’s denote the
    real number ![\gamma_{l}J_{jk}](img/file670.png "\gamma_{l}J_{jk}") by ![a](img/file16.png
    "a"). Notice that ![e^{- iaZ_{j}Z_{k}}](img/file671.png "e^{- iaZ_{j}Z_{k}}")
    is the exponential of a diagonal matrix, because ![Z_{j}Z_{k}](img/file363.png
    "Z_{j}Z_{k}") is the tensor product of diagonal matrices. In fact, it holds that
    if ![\left| x \right\rangle](img/file267.png "\left| x \right\rangle") is a computational
    basis state in which qubits ![j](img/file258.png "j") and ![k](img/file317.png
    "k") have the same value, then
  prefs: []
  type: TYPE_NORMAL
- en: '![e^{- iaZ_{j}Z_{k}}\left| x \right\rangle = e^{- ia}\left| x \right\rangle.](img/file672.png
    "e^{- iaZ_{j}Z_{k}}\left| x \right\rangle = e^{- ia}\left| x \right\rangle.")'
  prefs: []
  type: TYPE_IMG
- en: On the other hand, if qubits ![j](img/file258.png "j") and ![k](img/file317.png
    "k") have different values, then
  prefs: []
  type: TYPE_NORMAL
- en: '![e^{- iaZ_{j}Z_{k}}\left| x \right\rangle = e^{ia}\left| x \right\rangle.](img/file673.png
    "e^{- iaZ_{j}Z_{k}}\left| x \right\rangle = e^{ia}\left| x \right\rangle.")'
  prefs: []
  type: TYPE_IMG
- en: This unitary action is implemented by the circuit in *Figure* *[*5.1*](#Figure5.1),
    where, for simplicity, we have only depicted qubits ![j](img/file258.png "j")
    and ![k](img/file317.png "k") — the action on the rest of the qubits would be
    the identity gate.*
  prefs: []
  type: TYPE_NORMAL
- en: '*![Figure 5.1: Implementation of e^{- iaZ_{j}Z_{k}}](img/file674.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Figure 5.1**: Implementation of ![e^{- iaZ_{j}Z_{k}}](img/file671.png "e^{-
    iaZ_{j}Z_{k}}")'
  prefs: []
  type: TYPE_NORMAL
- en: We now have all the elements in place, so let’s illustrate them with an example.
    Imagine that the Ising Hamiltonian of your problem is ![3Z_{0}Z_{2} - Z_{1}Z_{2}
    + 2Z_{0}](img/file675.png "3Z_{0}Z_{2} - Z_{1}Z_{2} + 2Z_{0}"). Then, the circuit
    used by QAOA to prepare ![\left| {\mathbf{\beta},\mathbf{\gamma}} \right\rangle](img/file644.png
    "\left| {\mathbf{\beta},\mathbf{\gamma}} \right\rangle") with ![p = 1](img/file676.png
    "p = 1") is the one shown in *Figure* * [*5.2*](#Figure5.2).*
  prefs: []
  type: TYPE_NORMAL
- en: '*![Figure 5.2: QAOA circuit with p = 1](img/file677.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Figure 5.2**: QAOA circuit with ![p = 1](img/file676.png "p = 1")'
  prefs: []
  type: TYPE_NORMAL
- en: Notice how we first prepare the ground state of ![H_{0}](img/file545.png "H_{0}")
    with a column of Hadamard gates. Then, we have the implementation of ![e^{- i3\gamma_{1}Z_{0}Z_{2}}](img/file678.png
    "e^{- i3\gamma_{1}Z_{0}Z_{2}}") with a CNOT gate between qubits ![0](img/file12.png
    "0") and ![2](img/file302.png "2"), an ![R_{Z}](img/file120.png "R_{Z}") gate
    on qubit ![2](img/file302.png "2"), and another CNOT gate between qubits ![0](img/file12.png
    "0") and ![2](img/file302.png "2"). The implementation of ![e^{i\gamma_{1}Z_{1}Z_{2}}](img/file679.png
    "e^{i\gamma_{1}Z_{1}Z_{2}}") is similar, but on qubits ![1](img/file13.png "1")
    and ![2](img/file302.png "2"). Then, we use an ![R_{Z}](img/file120.png "R_{Z}")
    gate on qubit ![0](img/file12.png "0") to implement ![e^{- i2\gamma_{1}Z_{0}}](img/file680.png
    "e^{- i2\gamma_{1}Z_{0}}"). Finally, a column of ![R_{X}](img/file118.png "R_{X}")
    gates implements ![e^{- i\beta_{1}{\sum}_{j}X_{j}}](img/file681.png "e^{- i\beta_{1}{\sum}_{j}X_{j}}").
    If we increased the number of **layers** ![p](img/file141.png "p"), the circuit
    would grow by repeating for another ![p - 1](img/file682.png "p - 1") times the
    very same circuit structure shown in *Figure* * [*5.2*](#Figure5.2) except for
    the initial Hadamard gates. Additionally, we would have to replace the parameters
    ![\gamma_{1}](img/file683.png "\gamma_{1}") and ![\beta_{1}](img/file684.png "\beta_{1}")
    by ![\gamma_{2}](img/file685.png "\gamma_{2}") and ![\beta_{2}](img/file686.png
    "\beta_{2}") in the second layer, by ![\gamma_{3}](img/file687.png "\gamma_{3}")
    and ![\beta_{3}](img/file688.png "\beta_{3}") in the third, and so on and so forth.*
  prefs: []
  type: TYPE_NORMAL
- en: '*Exercise 5.1'
  prefs: []
  type: TYPE_NORMAL
- en: Obtain the QAOA circuit for ![Z_{1}Z_{3} + Z_{0}Z_{2} - 2Z_{1} + 3Z_{2}](img/file689.png
    "Z_{1}Z_{3} + Z_{0}Z_{2} - 2Z_{1} + 3Z_{2}") with ![p = 1](img/file676.png "p
    = 1").
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know all the circuits that we need for QAOA, let’s study how to
    use them in order to estimate the energy of the states ![\left| {\mathbf{\beta},\mathbf{\gamma}}
    \right\rangle](img/file644.png "\left| {\mathbf{\beta},\mathbf{\gamma}} \right\rangle").
  prefs: []
  type: TYPE_NORMAL
- en: 5.1.4 Estimating the energy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The circuits that we have just studied allow us to prepare any state of the
    form ![\left| {\mathbf{\beta},\mathbf{\gamma}} \right\rangle](img/file644.png
    "\left| {\mathbf{\beta},\mathbf{\gamma}} \right\rangle"). But we are not interested
    in the states themselves. What we need is their energy with respect to ![H_{1}](img/file544.png
    "H_{1}"), because that is the quantity that we want to minimize. That is, we need
    to evaluate ![\left\langle {\mathbf{\beta},\mathbf{\gamma}} \right|H_{1}\left|
    {\mathbf{\beta},\mathbf{\gamma}} \right\rangle](img/file647.png "\left\langle
    {\mathbf{\beta},\mathbf{\gamma}} \right|H_{1}\left| {\mathbf{\beta},\mathbf{\gamma}}
    \right\rangle"), but, of course, we don’t have access to the state vector because
    we are preparing the state with a quantum computer. So, what can we do?
  prefs: []
  type: TYPE_NORMAL
- en: The key observation here is that we already know how to evaluate efficiently
    ![\left\langle x \right|H_{1}\left| x \right\rangle](img/file690.png "\left\langle
    x \right|H_{1}\left| x \right\rangle") for any basis state ![\left| x \right\rangle](img/file267.png
    "\left| x \right\rangle"). In fact, ![\left\langle x \right|H_{1}\left| x \right\rangle](img/file690.png
    "\left\langle x \right|H_{1}\left| x \right\rangle") is the value of ![x](img/file269.png
    "x") in the cost function of our combinatorial optimization problem, because we
    derived ![H_{1}](img/file544.png "H_{1}") from it. So, for instance, if we are
    trying to solve a Max-Cut problem, each ![\left| x \right\rangle](img/file267.png
    "\left| x \right\rangle") represents a cut and we can easily compute — with a
    classical computer — the cost of that cut, as we did in *Section* * [*3.1.2*](ch011.xhtml#x1-620003.1.2).*
  prefs: []
  type: TYPE_NORMAL
- en: '*What is more, we can also evaluate ![\left\langle x \right|H_{1}\left| x \right\rangle](img/file690.png
    "\left\langle x \right|H_{1}\left| x \right\rangle") directly from the expression
    of the Hamiltonian. We only need to notice that ![\left\langle x \right|Z_{j}\left|
    x \right\rangle = 1](img/file691.png "\left\langle x \right|Z_{j}\left| x \right\rangle
    = 1") if the ![j](img/file258.png "j")-th bit of ![x](img/file269.png "x") is
    ![0](img/file12.png "0") and that ![\left\langle x \right|Z_{j}\left| x \right\rangle
    = - 1](img/file692.png "\left\langle x \right|Z_{j}\left| x \right\rangle = -
    1") otherwise. In a similar way, ![\left\langle x \right|Z_{j}Z_{k}\left| x \right\rangle
    = 1](img/file693.png "\left\langle x \right|Z_{j}Z_{k}\left| x \right\rangle =
    1") if the ![j](img/file258.png "j")-th and ![k](img/file317.png "k")-th bits
    of ![x](img/file269.png "x") are equal and ![\left\langle x \right|Z_{j}Z_{k}\left|
    x \right\rangle = - 1](img/file694.png "\left\langle x \right|Z_{j}Z_{k}\left|
    x \right\rangle = - 1") if they are different.'
  prefs: []
  type: TYPE_NORMAL
- en: Then, by linearity, we can easily evaluate ![\left\langle x \right|H_{1}\left|
    x \right\rangle](img/file690.png "\left\langle x \right|H_{1}\left| x \right\rangle").
    For instance, if ![H_{1} = 3Z_{0}Z_{2} - Z_{1}Z_{2} + 2Z_{0}](img/file695.png
    "H_{1} = 3Z_{0}Z_{2} - Z_{1}Z_{2} + 2Z_{0}"), we will have
  prefs: []
  type: TYPE_NORMAL
- en: '![\left\langle {101} \right|H_{1}\left| {101} \right\rangle = 3\left\langle
    {101} \right|Z_{0}Z_{2}\left| {101} \right\rangle - \left\langle {101} \right|Z_{1}Z_{2}\left|
    {101} \right\rangle + 2\left\langle {101} \right|Z_{0}\left| {101} \right\rangle
    = 3 + 1 - 2 = 4.](img/file696.png "\left\langle {101} \right|H_{1}\left| {101}
    \right\rangle = 3\left\langle {101} \right|Z_{0}Z_{2}\left| {101} \right\rangle
    - \left\langle {101} \right|Z_{1}Z_{2}\left| {101} \right\rangle + 2\left\langle
    {101} \right|Z_{0}\left| {101} \right\rangle = 3 + 1 - 2 = 4.")'
  prefs: []
  type: TYPE_IMG
- en: Exercise 5.2
  prefs: []
  type: TYPE_NORMAL
- en: Evaluate ![\left\langle {100} \right|H_{1}\left| {100} \right\rangle](img/file697.png
    "\left\langle {100} \right|H_{1}\left| {100} \right\rangle") with ![H_{1} = 3Z_{0}Z_{2}
    - Z_{1}Z_{2} + 2Z_{0}](img/file695.png "H_{1} = 3Z_{0}Z_{2} - Z_{1}Z_{2} + 2Z_{0}").
  prefs: []
  type: TYPE_NORMAL
- en: We also know that we can always write ![\left| {\mathbf{\beta},\mathbf{\gamma}}
    \right\rangle](img/file644.png "\left| {\mathbf{\beta},\mathbf{\gamma}} \right\rangle")
    as a linear combination of basis states. Namely, we have
  prefs: []
  type: TYPE_NORMAL
- en: '![\left| {\mathbf{\beta},\mathbf{\gamma}} \right\rangle = \sum\limits_{x}a_{x}\left|
    x \right\rangle](img/file698.png "\left| {\mathbf{\beta},\mathbf{\gamma}} \right\rangle
    = \sum\limits_{x}a_{x}\left| x \right\rangle")'
  prefs: []
  type: TYPE_IMG
- en: for certain amplitudes ![a_{x}](img/file699.png "a_{x}") such that ![{\sum}_{x}\left|
    a_{x} \right|^{2} = 1](img/file371.png "{\sum}_{x}\left| a_{x} \right|^{2} = 1").
  prefs: []
  type: TYPE_NORMAL
- en: But then it holds that
  prefs: []
  type: TYPE_NORMAL
- en: '![\left\langle {\mathbf{\beta},\mathbf{\gamma}} \right|H_{1}\left| {\mathbf{\beta},\mathbf{\gamma}}
    \right\rangle = \left( {\sum\limits_{y}a_{y}^{\ast}\left\langle y \right|} \right)H_{1}\left(
    {\sum\limits_{x}a_{x}\left| x \right\rangle} \right) = \sum\limits_{y}\sum\limits_{x}a_{y}^{\ast}a_{x}\left\langle
    y \right|H_{1}\left| x \right\rangle = \sum\limits_{x}\left| a_{x} \right|^{2}\left\langle
    x \right|H_{1}\left| x \right\rangle,](img/file700.png "\left\langle {\mathbf{\beta},\mathbf{\gamma}}
    \right|H_{1}\left| {\mathbf{\beta},\mathbf{\gamma}} \right\rangle = \left( {\sum\limits_{y}a_{y}^{\ast}\left\langle
    y \right|} \right)H_{1}\left( {\sum\limits_{x}a_{x}\left| x \right\rangle} \right)
    = \sum\limits_{y}\sum\limits_{x}a_{y}^{\ast}a_{x}\left\langle y \right|H_{1}\left|
    x \right\rangle = \sum\limits_{x}\left| a_{x} \right|^{2}\left\langle x \right|H_{1}\left|
    x \right\rangle,")'
  prefs: []
  type: TYPE_IMG
- en: because ![H_{1}\left| x \right\rangle](img/file701.png "H_{1}\left| x \right\rangle")
    is always a multiple of ![\left| x \right\rangle](img/file267.png "\left| x \right\rangle")
    (just notice that ![H_{1}](img/file544.png "H_{1}") is a diagonal matrix because
    it is a sum of diagonal matrices), because ![\left\langle y \middle| x \right\rangle
    = 0](img/file366.png "\left\langle y \middle| x \right\rangle = 0") when ![y \neq
    x](img/file702.png "y \neq x"), and because ![a_{x}^{\ast}a_{x} = \left| a_{x}
    \right|^{2}](img/file369.png "a_{x}^{\ast}a_{x} = \left| a_{x} \right|^{2}").
  prefs: []
  type: TYPE_NORMAL
- en: Now, since we can compute ![\left\langle x \right|H_{1}\left| x \right\rangle](img/file690.png
    "\left\langle x \right|H_{1}\left| x \right\rangle") easily with the classical
    computer, we have reduced our problem to computing the values ![\left| a_{x} \right|^{2}](img/file372.png
    "\left| a_{x} \right|^{2}"). But ![\left| a_{x} \right|^{2}](img/file372.png "\left|
    a_{x} \right|^{2}") is the probability of measuring ![\left| x \right\rangle](img/file267.png
    "\left| x \right\rangle") when the state ![\left| {\mathbf{\beta},\mathbf{\gamma}}
    \right\rangle](img/file644.png "\left| {\mathbf{\beta},\mathbf{\gamma}} \right\rangle")
    is prepared — this is the reason why, back in *Chapter* * [*3*](ch011.xhtml#x1-590003),
    *Working with Quadratic* *Unconstrained Binary Optimization Problems*, we referred
    to expressions of the form ![\left\langle \psi \right|H_{1}\left| \psi \right\rangle](img/file703.png
    "\left\langle \psi \right|H_{1}\left| \psi \right\rangle") as expectation values;
    they are indeed the expected or average energy under ![H_{1}](img/file544.png
    "H_{1}") when we measure the state ![\left| \psi \right\rangle](img/file43.png
    "\left| \psi \right\rangle")!*
  prefs: []
  type: TYPE_NORMAL
- en: '*From this observation, it follows that we can use the quantum computer to
    prepare ![\left| {\mathbf{\beta},\mathbf{\gamma}} \right\rangle](img/file644.png
    "\left| {\mathbf{\beta},\mathbf{\gamma}} \right\rangle") and measure it ![M](img/file704.png
    "M") times to make the estimation'
  prefs: []
  type: TYPE_NORMAL
- en: '![\left\langle {\mathbf{\beta},\mathbf{\gamma}} \right|H_{1}\left| {\mathbf{\beta},\mathbf{\gamma}}
    \right\rangle \approx \sum\limits_{x}\frac{m_{x}}{M}\left\langle x \right|H_{1}\left|
    x \right\rangle,](img/file705.png "\left\langle {\mathbf{\beta},\mathbf{\gamma}}
    \right|H_{1}\left| {\mathbf{\beta},\mathbf{\gamma}} \right\rangle \approx \sum\limits_{x}\frac{m_{x}}{M}\left\langle
    x \right|H_{1}\left| x \right\rangle,")'
  prefs: []
  type: TYPE_IMG
- en: where ![m_{x}](img/file706.png "m_{x}") is the number of times that ![x](img/file269.png
    "x") was measured. Of course, the higher the value of ![M](img/file704.png "M"),
    the better this approximation will be.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: In the process of estimating the energies of all the different states prepared
    with quantum computers, we will compute the cost, for our optimization problem,
    of many binary strings ![x](img/file269.png "x"). Of course, it would be wise
    for us to always keep the best ![x](img/file269.png "x") seen during the optimization
    process. Occasionally, it might be even better than the ones we obtain when measuring
    the final state ![\left| {\mathbf{\beta}^{\ast},\mathbf{\gamma}^{\ast}} \right\rangle](img/file707.png
    "\left| {\mathbf{\beta}^{\ast},\mathbf{\gamma}^{\ast}} \right\rangle").
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now covered all that we needed to know about the inner workings of QAOA.
    Before we move on to show how to implement and use this algorithm with Qiskit
    and PennyLane, we will introduce a little perk that we get from the fact that
    we are no longer using quantum annealers, but universal quantum computers instead.
    This will help us in formulating some problems in a more natural way, as we will
    show in the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: 5.1.5 QUBO and HOBO
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Up to this point, we have only considered problems that can be written under
    the QUBO formalism. That is, minimization problems in which the cost function
    is a quadratic polynomial on binary variables that had no constraints on the values
    they could take. This is less restricting than it may seem, because QUBO is ![NP](img/file2.png
    "NP")-hard and there are many important problems that we can rewrite via reductions,
    as we saw in *Section* * [*3.4*](ch011.xhtml#x1-680003.4).*
  prefs: []
  type: TYPE_NORMAL
- en: '*However, consider a problem like the famous **satisfiability** or **SAT**.
    In it, we are given a Boolean formula on binary variables and we have to determine
    whether there is any assignment of values that makes the formula true. For example,
    we may receive'
  prefs: []
  type: TYPE_NORMAL
- en: '![(x_{0} \vee \neg x_{1} \vee x_{2}) \land (\neg x_{0} \vee x_{1} \vee \neg
    x_{2}) \land (x_{0} \vee x_{1} \vee x_{2}),](img/file708.png "(x_{0} \vee \neg
    x_{1} \vee x_{2}) \land (\neg x_{0} \vee x_{1} \vee \neg x_{2}) \land (x_{0} \vee
    x_{1} \vee x_{2}),")'
  prefs: []
  type: TYPE_IMG
- en: which is **satisfiable** (by assigning *true* to all the variables, for instance).
    Or we can be given
  prefs: []
  type: TYPE_NORMAL
- en: '![x_{0} \land \neg x_{0},](img/file709.png "x_{0} \land \neg x_{0},")'
  prefs: []
  type: TYPE_IMG
- en: which is clearly **unsatisfiable**.
  prefs: []
  type: TYPE_NORMAL
- en: SAT is easily seen to be in ![NP](img/file2.png "NP") (and, in fact, it is ![NP](img/file2.png
    "NP")-complete — see *Section 7.4* in Sipser’s book [[90](ch030.xhtml#Xsipser2012introduction)]).
    Then, we know that there must be a way of rewriting any SAT instance in the QUBO
    formalism. But the task becomes much easier if we relax the conditions in the
    QUBO formulation by allowing binary polynomials of *any order*. Let’s see why!
  prefs: []
  type: TYPE_NORMAL
- en: Let us consider, for the sake of an example, the formula ![(x_{0} \vee \neg
    x_{1} \vee x_{2}) \land (\neg x_{0} \vee x_{1} \vee \neg x_{2}) \land (x_{0} \vee
    x_{1} \vee x_{2})](img/file710.png "(x_{0} \vee \neg x_{1} \vee x_{2}) \land (\neg
    x_{0} \vee x_{1} \vee \neg x_{2}) \land (x_{0} \vee x_{1} \vee x_{2})"). We’ll
    show how it can be represented as the polynomial
  prefs: []
  type: TYPE_NORMAL
- en: '![p(x_{0},x_{1},x_{2}) = (1 - x_{0})x_{1}(1 - x_{2}) + x_{0}(1 - x_{1})x_{2}
    + (1 - x_{0})(1 - x_{1})(1 - x_{2}),](img/file711.png "p(x_{0},x_{1},x_{2}) =
    (1 - x_{0})x_{1}(1 - x_{2}) + x_{0}(1 - x_{1})x_{2} + (1 - x_{0})(1 - x_{1})(1
    - x_{2}),")'
  prefs: []
  type: TYPE_IMG
- en: on the binary variables ![x_{0}](img/file443.png "x_{0}"), ![x_{1}](img/file712.png
    "x_{1}"), and ![x_{2}](img/file444.png "x_{2}"). Let’s say that we consider some
    assignment of truth values for the variables in the original formula, and we set
    ![x_{i} = 1](img/file713.png "x_{i} = 1") in the polynomial if ![x_{i}](img/file714.png
    "x_{i}") is true and ![x_{i} = 0](img/file715.png "x_{i} = 0") if ![x_{i}](img/file714.png
    "x_{i}") is false. It’s easy to see that the original formula will be true under
    this assignment if and only if ![p(x_{0},x_{1},x_{2}) = 0](img/file716.png "p(x_{0},x_{1},x_{2})
    = 0"), and that it will be false if and only if ![p(x_{0},x_{1},x_{2}) > 0](img/file717.png
    "p(x_{0},x_{1},x_{2}) > 0"). Thus, if the polynomial ![p](img/file141.png "p")
    is ![0](img/file12.png "0") for some values of its variables, then the original
    formula must be satisfiable. Otherwise, it has to be unsatisfiable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we can rewrite our original problem as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![\begin{array}{rlrl} {\text{Minimize~}\quad} & {(1 - x_{0})x_{1}(1 - x_{2})
    + x_{0}(1 - x_{1})x_{2} + (1 - x_{0})(1 - x_{1})(1 - x_{2})\qquad} & & \qquad
    \\ {\text{subject~to~}\quad} & {x_{j} \in \{ 0,1\},\qquad j = 0,1,2.\qquad} &
    & \qquad \\ & \qquad & & \\ \end{array}](img/file718.png "\begin{array}{rlrl}
    {\text{Minimize~}\quad} & {(1 - x_{0})x_{1}(1 - x_{2}) + x_{0}(1 - x_{1})x_{2}
    + (1 - x_{0})(1 - x_{1})(1 - x_{2})\qquad} & & \qquad \\ {\text{subject~to~}\quad}
    & {x_{j} \in \{ 0,1\},\qquad j = 0,1,2.\qquad} & & \qquad \\  & \qquad & & \\
    \end{array}")'
  prefs: []
  type: TYPE_IMG
- en: If the minimum of the polynomial is ![0](img/file12.png "0"), then the formula
    will be satisfiable. Otherwise, the formula will be unsatisfiable.
  prefs: []
  type: TYPE_NORMAL
- en: With a simple transformation, we have been able to reformulate our problem as
    something that looks very much like a QUBO instance. But wait! This is *not* a
    QUBO problem. The reason is that the degree of the binary polynomial is ![3](img/file472.png
    "3") and not ![2](img/file302.png "2"), as you can easily check by expanding its
    expression. These optimization problems in which we are asked to minimize a binary
    polynomial — of any degree — with no additional restrictions are called **Higher
    Order Binary Optimization** (**HOBO**) or **Polynomial Unconstrained Binary Optimization**
    (**PUBO**) problems, for obvious reasons.
  prefs: []
  type: TYPE_NORMAL
- en: The method that we have applied is quite general. In fact, it is easy to see
    that we can apply it to any Boolean formula that is given as conjunctions of disjunctions
    of variables and negations of variables. Something like, for instance, ![(x_{0}
    \vee \neg x_{1} \vee x_{2}) \land (\neg x_{0} \vee x_{1} \vee \neg x_{2}) \land
    (x_{0} \vee x_{1} \vee x_{2})](img/file710.png "(x_{0} \vee \neg x_{1} \vee x_{2})
    \land (\neg x_{0} \vee x_{1} \vee \neg x_{2}) \land (x_{0} \vee x_{1} \vee x_{2})")
    or ![(x_{0} \vee x_{1} \vee \neg x_{2} \vee x_{3}) \land (\neg x_{0} \vee x_{1}
    \vee x_{2} \vee x_{3}) \land (\neg x_{0} \vee x_{1} \vee \neg x_{2} \vee \neg
    x_{3})](img/file719.png "(x_{0} \vee x_{1} \vee \neg x_{2} \vee x_{3}) \land (\neg
    x_{0} \vee x_{1} \vee x_{2} \vee x_{3}) \land (\neg x_{0} \vee x_{1} \vee \neg
    x_{2} \vee \neg x_{3})"). We say that these formulas are in **conjunctive normal
    form** or **CNF**. In this case, we can just obtain an associated polynomial consisting
    of a sum of products. Each product will correspond to one of the disjunctions
    of the formula. If a variable ![x](img/file269.png "x") appears negated in the
    disjunction, it will appear as ![x](img/file269.png "x") in the product. If it
    appears in positive form, it will appear as ![1 - x](img/file720.png "1 - x")
    in the product.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 5.3
  prefs: []
  type: TYPE_NORMAL
- en: Write the HOBO version of the SAT problem with the Boolean formula
  prefs: []
  type: TYPE_NORMAL
- en: '![(x_{0} \vee x_{1} \vee \neg x_{2} \vee x_{3}) \land (\neg x_{0} \vee x_{1}
    \vee x_{2} \vee x_{3}) \land (\neg x_{0} \vee x_{1} \vee \neg x_{2} \vee \neg
    x_{3}).](img/file721.png "(x_{0} \vee x_{1} \vee \neg x_{2} \vee x_{3}) \land
    (\neg x_{0} \vee x_{1} \vee x_{2} \vee x_{3}) \land (\neg x_{0} \vee x_{1} \vee
    \neg x_{2} \vee \neg x_{3}).")'
  prefs: []
  type: TYPE_IMG
- en: And what about Boolean formulas that are not in CNF? In this case, we can apply
    a method, called the **Tseitin transformation**, that runs in polynomial time
    and gives us a formula in CNF that is satisfiable if and only if the original
    formula was satisfiable (see [[17](ch030.xhtml#Xbiere2009handbook), Chapter 2]
    for more details). In fact, the resulting formula will be in **3-CNF**, meaning
    that the disjunctions will involve at most three variables or negations of variables.
    This is very convenient, because it guarantees that the process of expanding the
    polynomial to obtain the coefficients will be efficient.
  prefs: []
  type: TYPE_NORMAL
- en: But enough about satisfiability. Let’s come back to HOBO problems. How can we
    solve them? One way of doing this is by transforming them into QUBO problems.
    There are different techniques for rewriting HOBO problems as QUBO instances by
    introducing auxiliary variables. For example, you can substitute products ![xy](img/file722.png
    "xy") by a new binary variable ![z](img/file81.png "z") as long as you introduce
    a penalty term ![xy - 2xz - 2yz + 3z](img/file723.png "xy - 2xz - 2yz + 3z"),
    which is ![0](img/file12.png "0") if and only if ![xy = z](img/file724.png "xy
    = z"). In this way, you can reduce a term of order ![m + 1](img/file725.png "m
    + 1") such as ![x_{0}x_{1}\cdots x_{m}](img/file726.png "x_{0}x_{1}\cdots x_{m}")
    to a term of order ![m](img/file259.png "m") of the form ![zx_{2}\cdots x_{m}](img/file727.png
    "zx_{2}\cdots x_{m}") and a quadratic penalty term on ![x_{0},x_{1}](img/file728.png
    "x_{0},x_{1}"), and ![z](img/file81.png "z"). By repeating this process as many
    times as needed, you can obtain an equivalent problem in which the objective function
    is a binary quadratic polynomial. Transformations of this kind are used in D-Wave’s
    Ocean, where you can find `BinaryPolynomial` objects that you can reduce to polynomials
    of degree ![2](img/file302.png "2") with the `make_quadratic` function.
  prefs: []
  type: TYPE_NORMAL
- en: However, if you are using QAOA, you can deal with HOBO problems directly. We
    can consider a binary polynomial of any degree and transform it using the techniques
    of *Section* *[*3.3*](ch011.xhtml#x1-670003.3). We will end up having a Hamiltonian
    that is a sum of tensor products of ![Z_{j}](img/file384.png "Z_{j}") matrices.
    The only difference is that, now, these products can involve more than just one
    or two ![Z_{j}](img/file384.png "Z_{j}") matrices.*
  prefs: []
  type: TYPE_NORMAL
- en: '*This implies that, when we set out to create a circuit for ![e^{- i\gamma_{l}H_{1}}](img/file729.png
    "e^{- i\gamma_{l}H_{1}}"), we may need to implement unitary operations of the
    form ![e^{- iaZ_{j_{1}}Z_{j_{2}}\cdots Z_{j_{m}}}](img/file730.png "e^{- iaZ_{j_{1}}Z_{j_{2}}\cdots
    Z_{j_{m}}}"), with ![m > 2](img/file731.png "m > 2"). But that is not much more
    difficult than implementing ![e^{- iaZ_{j}Z_{k}}](img/file671.png "e^{- iaZ_{j}Z_{k}}").
    In fact, we can almost repeat the argument in *Section* * [*5.1.3*](#x1-980005.1.3),
    because both ![Z_{j_{1}}Z_{j_{2}}\cdots Z_{j_{m}}](img/file732.png "Z_{j_{1}}Z_{j_{2}}\cdots
    Z_{j_{m}}") and ![e^{- iaZ_{j_{1}}Z_{j_{2}}\cdots Z_{j_{m}}}](img/file730.png
    "e^{- iaZ_{j_{1}}Z_{j_{2}}\cdots Z_{j_{m}}}") are diagonal matrices. In fact,
    if ![\left| x \right\rangle](img/file267.png "\left| x \right\rangle") is a basis
    state, then*'
  prefs: []
  type: TYPE_NORMAL
- en: '*![e^{- iaZ_{j_{1}}Z_{j_{2}}\cdots Z_{j_{m}}}\left| x \right\rangle = e^{-
    ia}\left| x \right\rangle](img/file733.png "e^{- iaZ_{j_{1}}Z_{j_{2}}\cdots Z_{j_{m}}}\left|
    x \right\rangle = e^{- ia}\left| x \right\rangle")'
  prefs: []
  type: TYPE_NORMAL
- en: if the sum of the bits of ![x](img/file269.png "x") in positions ![j_{1},j_{2},\ldots,j_{m}](img/file734.png
    "j_{1},j_{2},\ldots,j_{m}") is even, and
  prefs: []
  type: TYPE_NORMAL
- en: '![e^{- iaZ_{j_{1}}Z_{j_{2}}\cdots Z_{j_{m}}}\left| x \right\rangle = e^{ia}\left|
    x \right\rangle](img/file735.png "e^{- iaZ_{j_{1}}Z_{j_{2}}\cdots Z_{j_{m}}}\left|
    x \right\rangle = e^{ia}\left| x \right\rangle")'
  prefs: []
  type: TYPE_IMG
- en: if the sum is odd.
  prefs: []
  type: TYPE_NORMAL
- en: This unitary action can be implemented by using consecutive CNOT gates with
    control qubits in ![j_{1},j_{2},\ldots,j_{m - 1}](img/file736.png "j_{1},j_{2},\ldots,j_{m
    - 1}") and targets in ![j_{m}](img/file737.png "j_{m}"), then an ![R_{Z}](img/file120.png
    "R_{Z}") gate with parameter ![2a](img/file738.png "2a") on qubit ![j_{m}](img/file737.png
    "j_{m}") and, again, consecutive CNOT gates with control qubits in ![j_{m - 1},j_{m
    - 2},\ldots,j_{1}](img/file739.png "j_{m - 1},j_{m - 2},\ldots,j_{1}") and targets
    in ![j_{m}](img/file737.png "j_{m}"). *Figure* * [*5.3*](#Figure5.3) illustrates
    this procedure for the case of ![e^{- iaZ_{0}Z_{1}Z_{3}}](img/file740.png "e^{-
    iaZ_{0}Z_{1}Z_{3}}"), under the assumption that we only have four qubits.*
  prefs: []
  type: TYPE_NORMAL
- en: '*![Figure 5.3: Implementation of e^{- iaZ_{0}Z_{1}Z_{3}}](img/file741.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Figure 5.3**: Implementation of ![e^{- iaZ_{0}Z_{1}Z_{3}}](img/file740.png
    "e^{- iaZ_{0}Z_{1}Z_{3}}")'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, this operation would be just one part in the implementation of ![e^{-
    i\gamma_{l}H_{1}}](img/file729.png "e^{- i\gamma_{l}H_{1}}") and we would need
    to repeat a similar process for each term of the Hamiltonian.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 5.4
  prefs: []
  type: TYPE_NORMAL
- en: Implement, in a circuit with 5 qubits, the operation ![e^{- i\frac{\pi}{4}Z_{0}Z_{2}Z_{4}}](img/file742.png
    "e^{- i\frac{\pi}{4}Z_{0}Z_{2}Z_{4}}").
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we can also estimate the energy of a Hamiltonian ![H_{1}](img/file544.png
    "H_{1}") that includes tensor products of ![Z](img/file8.png "Z") matrices in
    a way that is very similar to the one that we explained in *Section* * [*5.1.4*](#x1-990005.1.4).
    The key fact is that, for any basis state ![\left| x \right\rangle](img/file267.png
    "\left| x \right\rangle"), it holds that*
  prefs: []
  type: TYPE_NORMAL
- en: '*![\left\langle x \right|Z_{j_{1}}Z_{j_{2}}\cdots Z_{j_{m}}\left| x \right\rangle
    = 1](img/file743.png "\left\langle x \right|Z_{j_{1}}Z_{j_{2}}\cdots Z_{j_{m}}\left|
    x \right\rangle = 1")'
  prefs: []
  type: TYPE_NORMAL
- en: if the sum of the bits of ![x](img/file269.png "x") in positions ![j_{1},j_{2},\ldots,j_{m}](img/file734.png
    "j_{1},j_{2},\ldots,j_{m}") is even, and
  prefs: []
  type: TYPE_NORMAL
- en: '![\left\langle x \right|Z_{j_{1}}Z_{j_{2}}\cdots Z_{j_{m}}\left| x \right\rangle
    = - 1](img/file744.png "\left\langle x \right|Z_{j_{1}}Z_{j_{2}}\cdots Z_{j_{m}}\left|
    x \right\rangle = - 1")'
  prefs: []
  type: TYPE_IMG
- en: otherwise. By linearity, we can then evaluate ![\left\langle x \right|H_{1}\left|
    x \right\rangle](img/file690.png "\left\langle x \right|H_{1}\left| x \right\rangle")
    and, from that, we can estimate ![\left\langle \psi \right|H_{1}\left| \psi \right\rangle](img/file703.png
    "\left\langle \psi \right|H_{1}\left| \psi \right\rangle") by measuring ![\left|
    \psi \right\rangle](img/file43.png "\left| \psi \right\rangle") a number of times,
    exactly as we did in *Section* * [*5.1.4*](#x1-990005.1.4).*
  prefs: []
  type: TYPE_NORMAL
- en: '*Exercise 5.5'
  prefs: []
  type: TYPE_NORMAL
- en: Evaluate ![\left\langle {100} \right|H_{1}\left| {100} \right\rangle](img/file697.png
    "\left\langle {100} \right|H_{1}\left| {100} \right\rangle") with ![H_{1} = Z_{0}Z_{1}Z_{2}
    + 3Z_{0}Z_{2} - Z_{1}Z_{2} + 2Z_{0}](img/file745.png "H_{1} = Z_{0}Z_{1}Z_{2}
    + 3Z_{0}Z_{2} - Z_{1}Z_{2} + 2Z_{0}").
  prefs: []
  type: TYPE_NORMAL
- en: We have now covered all the necessary concepts to understand QAOA in all its
    glory. In the next two sections, we will show how to implement and run this algorithm
    with both Qiskit and PennyLane.
  prefs: []
  type: TYPE_NORMAL
- en: 5.2 Using QAOA with Qiskit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With everything that we have learned in the previous sections of this chapter
    and what we already know about Qiskit from *Chapter* *[*2*](ch009.xhtml#x1-400002),
    *The* *Tools of the Trade in Quantum Computing*, and *Section* *[*3.2.2*](ch011.xhtml#x1-660003.2.2),
    we could implement our own Qiskit version of QAOA. However, there is no need for
    that! As we shall show in this section, the Qiskit Optimization package provides
    all that is necessary to run QAOA on both quantum simulators and actual quantum
    computers. Moreover, it includes a set of tools to work directly with problems
    written under the QUBO formalism. As a matter of fact, in this section, we will
    also see how, underneath the hood, Qiskit uses the very same mathematical concepts
    that we have been studying.**
  prefs: []
  type: TYPE_NORMAL
- en: '**Let’s start by explaining how to work with QAOA in Qiskit when we already
    have the problem Hamiltonian.'
  prefs: []
  type: TYPE_NORMAL
- en: 5.2.1 Using QAOA with Hamiltonians
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we have the Hamiltonian ![H_{1}](img/file544.png "H_{1}") that encodes our
    optimization problem, it is very easy to use Qiskit’s QAOA implementation to approximate
    its ground state. Let’s start with a simple example in which we have ![H_{1} =
    Z_{0}Z_{1}](img/file746.png "H_{1} = Z_{0}Z_{1}"). We can create this Hamiltonian
    and prepare the corresponding QAOA circuit with the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As a result, we will obtain the circuit shown in *Figure* *[*5.4*](#Figure5.4).
    We can see how it starts with two Hadamard gates, which are then followed by the
    exponential of ![H_{1}](img/file544.png "H_{1}") and then the exponential of ![H_{0}](img/file545.png
    "H_{0}") (because ![H_{0} = X_{0}X_{1} = X_{0}I + IX_{1}](img/file747.png "H_{0}
    = X_{0}X_{1} = X_{0}I + IX_{1}")). This is exactly the circuit that we derived
    in the first part of the chapter.*
  prefs: []
  type: TYPE_NORMAL
- en: '*![Figure 5.4: QAOA circuit for H_{1} = Z_{0}Z_{1}](img/file748.png)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Figure 5.4**: QAOA circuit for ![H_{1} = Z_{0}Z_{1}](img/file746.png "H_{1}
    = Z_{0}Z_{1}")'
  prefs: []
  type: TYPE_NORMAL
- en: In order to create the circuit, in addition to `H1`, we’ve passed `[1,2]` to
    the method called `construct_circuit`. This list contains the ![\mathbf{\beta}](img/file645.png
    "\mathbf{\beta}") and ![\mathbf{\gamma}](img/file646.png "\mathbf{\gamma}") parameters
    that we want to use. In *Figure* * [*5.4*](#Figure5.4), this is indicated by the
    numbers below the exponentials in the gate boxes. Notice that this means that
    the first element in `[1,2]` is what we call ![\beta_{1}](img/file684.png "\beta_{1}")
    and the second is ![\gamma_{1}](img/file683.png "\gamma_{1}"). Also notice that
    we have used `[0]` after the call to `construct_circuit`. This is because this
    method, in general, returns a list of several circuits — but in this case, there
    is only one, which is the one that we pick.*
  prefs: []
  type: TYPE_NORMAL
- en: '*We can visualize the circuit in more detail by decomposing the exponentials
    — that is, transforming them into simpler gates — a couple of times. For that,
    we may use'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: to get the circuit shown in *Figure* *[*5.5*](#Figure5.5). The sequence of gates
    in that circuit is exactly the one that we would expect from our derivations earlier
    in this chapter, because ![\left. U(\pi\slash 2,0,\pi) = H \right.](img/file749.png
    "\left. U(\pi\slash 2,0,\pi) = H \right."), as you can easily check from the definition
    that we gave in *Section* * [*1.3.4*](ch008.xhtml#x1-250001.3.4) (![U_{3}](img/file750.png
    "U_{3}") is Qiskit’s name for our ![U](img/file51.png "U") gate).**
  prefs: []
  type: TYPE_NORMAL
- en: '**![Figure 5.5: QAOA circuit for H_{1} = Z_{0}Z_{1}, more detailed](img/file751.png)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Figure 5.5**: QAOA circuit for ![H_{1} = Z_{0}Z_{1}](img/file746.png "H_{1}
    = Z_{0}Z_{1}"), more detailed'
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the value of ![p](img/file141.png "p") for QAOA in Qiskit is ![1](img/file13.png
    "1"). However, we can change it by using the `reps` parameter when calling the
    class constructor. For instance, the following code can be used to obtain the
    QAOA circuit for ![Z_{0}Z_{1}](img/file352.png "Z_{0}Z_{1}") with ![p = 2](img/file752.png
    "p = 2"), ![\beta_{1} = 1](img/file753.png "\beta_{1} = 1"), ![\beta_{2} = 2](img/file754.png
    "\beta_{2} = 2"), ![\gamma_{1} = 3](img/file755.png "\gamma_{1} = 3"), and ![\gamma_{2}
    = 4](img/file756.png "\gamma_{2} = 4"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The result of the execution is the circuit shown in *Figure* *[*5.6*](#Figure5.6).*
  prefs: []
  type: TYPE_NORMAL
- en: '*![Figure 5.6: QAOA circuit for H_{1} = Z_{0}Z_{1} with p = 2](img/file757.png)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Figure 5.6**: QAOA circuit for ![H_{1} = Z_{0}Z_{1}](img/file746.png "H_{1}
    = Z_{0}Z_{1}") with ![p = 2](img/file752.png "p = 2")'
  prefs: []
  type: TYPE_NORMAL
- en: All this is well and good, but we haven’t yet solved any optimization problems!
    For that, we need to pass two additional parameters when creating a `QAOA` object.
    The first one is a `QuantumInstance`. That is, some backend capable of executing
    the QAOA quantum circuit to evaluate the energy of the ![\left| {\mathbf{\beta},\mathbf{\gamma}}
    \right\rangle](img/file644.png "\left| {\mathbf{\beta},\mathbf{\gamma}} \right\rangle")
    states. The second one is a classical optimizer, which will set initial values
    for ![\mathbf{\beta}](img/file645.png "\mathbf{\beta}") and ![\mathbf{\gamma}](img/file646.png
    "\mathbf{\gamma}"), use the `QuantumInstance` to evaluate state energies, and
    update the ![\mathbf{\beta}](img/file645.png "\mathbf{\beta}") and ![\mathbf{\gamma}](img/file646.png
    "\mathbf{\gamma}") parameters in order to optimize them, until some stopping criterion
    is met.
  prefs: []
  type: TYPE_NORMAL
- en: To learn more…
  prefs: []
  type: TYPE_NORMAL
- en: The choice of classical optimizer can have a big impact on the execution time
    and quality of the solutions obtained with QAOA.
  prefs: []
  type: TYPE_NORMAL
- en: For some insights into this, you can refer to [[39](ch030.xhtml#Xfernandez2022study)].
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following piece of code, we give an example of how to create the quantum
    instance and the classical minimizer objects, and of how to use them with QAOA
    to solve a simple problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are relying on the previous definition of `H1` as `Z``^``Z`, running
    the circuit on the `Aer` simulator with ![10](img/file161.png "10") shots, and
    using `COBYLA` as the classical optimizer — for an updated list of minimizers,
    please refer to Qiskit’s documentation at [https://qiskit.org/documentation/stubs/qiskit.algorithms.optimizers.html](https://qiskit.org/documentation/stubs/qiskit.algorithms.optimizers.html).
    We are also setting seeds for those processes that require random numbers, in
    order to obtain reproducible results.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run the preceding instructions, you will obtain the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '@empty'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'That is quite a lot of information! Let’s try to explain the most relevant
    pieces. The first thing that we need to understand is that this result refers
    to the final state ![\left| {\mathbf{\beta}^{\ast},\mathbf{\gamma}^{\ast}} \right\rangle](img/file707.png
    "\left| {\mathbf{\beta}^{\ast},\mathbf{\gamma}^{\ast}} \right\rangle") obtained
    by QAOA, not to the solutions that we would obtain if we measured it. In fact,
    this state is reconstructed from ![10](img/file161.png "10") measurements — because
    our simulator is using ![10](img/file161.png "10") shots — but those measurements
    are not given as part of the output. Instead, we get the `eigenstate` field, which
    shows that we have ![\left| {01} \right\rangle](img/file199.png "\left| {01} \right\rangle")
    with an amplitude roughly ![0.5477](img/file758.png "0.5477") and ![\left| {10}
    \right\rangle](img/file200.png "\left| {10} \right\rangle") with an amplitude
    about ![0.8367](img/file759.png "0.8367"). These numbers are, in fact, ![\sqrt{\left.
    3\slash 10 \right.}](img/file760.png "\sqrt{\left. 3\slash 10 \right.}") and ![\sqrt{\left.
    7\slash 10 \right.}](img/file761.png "\sqrt{\left. 7\slash 10 \right.}"), which
    means that, once the state with the optimal parameters found by the minimizer
    was prepared and measured, `01` was obtained ![3](img/file472.png "3") out of
    ![10](img/file161.png "10") times and `10` was obtained the remaining ![7](img/file465.png
    "7") times. This state can be prepared with the QAOA circuit by using the optimal
    parameters reported in the result: ![\beta_{1} \approx 6.7648](img/file762.png
    "\beta_{1} \approx 6.7648") and ![\gamma_{1} \approx - 0.8472](img/file763.png
    "\gamma_{1} \approx - 0.8472").'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that, with respect to the ![Z_{0}Z_{1}](img/file352.png "Z_{0}Z_{1}")
    Hamiltonian, both ![\left| {01} \right\rangle](img/file199.png "\left| {01} \right\rangle")
    and ![\left| {10} \right\rangle](img/file200.png "\left| {10} \right\rangle")
    have an expected value of ![- 1](img/file312.png "- 1"), which is the optimal
    energy. This means that we have been able to find an optimal solution — two of
    them, in fact — with QAOA! To get to this result, QAOA evaluated the energy function
    — by preparing a circuit with some values of ![\beta_{1}](img/file684.png "\beta_{1}")
    and ![\gamma_{1}](img/file683.png "\gamma_{1}") and measuring it to estimate its
    expectation value — 20 times, as indicated by the `cost_function_evals` field,
    and it used about ![0.08](img/file764.png "0.08") seconds of computing time —
    your running time will most surely be different from ours, though.
  prefs: []
  type: TYPE_NORMAL
- en: All this has been done with the Aer simulator. If we wanted to use a real quantum
    computer, we could just replace the `backend` in the instantiation of the `QuantumInstance`
    object and use some of the quantum devices provided by IBM, as we showed in *Section*
    *[*2.2.4*](ch009.xhtml#x1-510002.2.4). However, this is not the best way to proceed.
    The problem with this straightforward approach is that you will be running the
    classical part of the algorithm locally. Then, each time that an energy estimation
    is required, a new job will be submitted to the quantum computer and you will
    have to wait on the queue if other users have also sent jobs to execute. This
    can be quite slow, not because of the process itself, but because of the queue
    waiting times.*
  prefs: []
  type: TYPE_NORMAL
- en: '*Fortunately, Qiskit has recently introduced a new module called Runtime that
    allows us to reduce the execution time for hybrid algorithms such as QAOA. Instead
    of submitting each circuit individually, with Runtime you can submit a **program**
    that includes both the classical and the quantum part of the algorithm. The program
    is then queued just once, greatly speeding up the whole execution.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using Runtime with QAOA is very easy. In fact, we just need to specify the
    same elements that we have used with the `QAOA` class, but in a slightly different
    way. The following piece of code shows an example of how to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This will create and run a QAOA Runtime job whose quantum part will be executed
    in the quantum computer that we have specified in the `options``[``"``backend_name``"``]`
    field — in our case, `ibmq_belem`. We have used the ![Z_{0}Z_{1}](img/file352.png
    "Z_{0}Z_{1}") Hamiltonian, COBYLA as the optimizer, a value of ![p = 1](img/file676.png
    "p = 1") (specified with the `reps` variable), and ![1024](img/file291.png "1024")
    shots.
  prefs: []
  type: TYPE_NORMAL
- en: We have also chosen the initial values of ![\beta_{1}](img/file684.png "\beta_{1}")
    and ![\gamma_{1}](img/file683.png "\gamma_{1}") to be ![0](img/file12.png "0")
    with the `initial_point` field. If this field is not used, the initial values
    are chosen at random.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the program has finished running (you can keep track of its execution
    using `job``.``status``()`), the result can be retrieved with `job``.``result``()`.
    We can access some of its parameters with the following instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In our case, running those lines of code offered the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As you can appreciate, the results are slightly worse than with the simulator,
    due to the influence of noise. But the two optimal basis states — ![01](img/file159.png
    "01") and ![10](img/file161.png "10") — are still the most probable ones and,
    therefore, if we prepare and measure the final state several times, we will have
    a very high probability of finding an optimal solution.
  prefs: []
  type: TYPE_NORMAL
- en: So now we know how to solve problems with QAOA using Qiskit, both with simulators
    and with actual quantum computers. However, so far, we’ve had to prepare the Hamiltonian
    of the problem ourselves, and that is not ideal. As we learned in *Chapter* *[*3*](ch011.xhtml#x1-590003),
    *Working with Quadratic Unconstrained* *Binary Optimization Problems*, for many
    problems, it is more convenient to work with a QUBO formulation or even to write
    the problem as a binary linear program. Would it be possible to use those formalisms
    directly with QAOA in Qiskit? Absolutely! We’ll show you how in the next subsection.*
  prefs: []
  type: TYPE_NORMAL
- en: '*## 5.2.2 Solving QUBO problems with QAOA in Qiskit'
  prefs: []
  type: TYPE_NORMAL
- en: Qiskit provides tools to work with quadratic problems, both with and without
    constraints, which are similar to the ones that we studied when working with Ocean
    in *Chapter* *[*4*](ch012.xhtml#x1-750004), *Quantum Adiabatic Computing and Quantum
    Annealing*. For example, we can define a simple binary program with the following
    piece of code:*
  prefs: []
  type: TYPE_NORMAL
- en: '*[PRE8]'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, we are defining a quadratic problem with three binary variables,
    a function to minimize that has a linear and a quadratic part, and a linear constraint
    in the binary variables. When we run these instructions, we obtain the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The problem has exactly the elements that we specified. The only detail that
    may deserve a small explanation is why the quadratic part of the objective function
    is represented as ![\left. (4xy - 8yz)\slash 2 \right.](img/file765.png "\left.
    (4xy - 8yz)\slash 2 \right.") instead of ![2xy - 4yz](img/file766.png "2xy - 4yz").
    The reason for this seemingly odd choice is that, in this way, the matrix with
    the quadratic coefficients can be made symmetric. Instead of having ![2](img/file302.png
    "2") for the ![xy](img/file722.png "xy") coefficient and ![0](img/file12.png "0")
    for the ![yx](img/file767.png "yx") product, the value is duplicated and both
    terms will have ![2](img/file302.png "2") as their coefficient — but then we need
    to divide by ![2](img/file302.png "2") so that the total coefficient remains as
    in the original specification.
  prefs: []
  type: TYPE_NORMAL
- en: To learn more…
  prefs: []
  type: TYPE_NORMAL
- en: 'The internal representation of these quadratic problems is the one used by
    CPLEX, an IBM package that is used to solve optimization problems with classical
    methods. You can learn more about CPLEX on its web page: [https://www.ibm.com/products/ilog-cplex-optimization-studio](https://www.ibm.com/products/ilog-cplex-optimization-studio).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have a `QuadraticProgram` object, we can solve it with one of the algorithms
    provided by Qiskit. To achieve this, we can use `MinimumEigenOptimizer` together
    with a concrete solver. For example, we can use a classical exact solver, which
    tries every possible solution and selects the optimal one. In Qiskit, this is
    as simple as using the following instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of the execution is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we obtain the optimal assignment (![x = 0](img/file768.png "x
    = 0"), ![y = 1](img/file769.png "y = 1") and ![z = 1](img/file770.png "z = 1")),
    the optimal value of the function (in this case, ![- 5](img/file591.png "- 5")),
    and whether the assignment satisfies the constraints, indicated by the `SUCCESS`
    value, or not — if there were no assignments satisfying the constraints, we would
    obtain `INFEASIBLE` as the value for `status`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a similar way, we can use QAOA to solve the problem with the following instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the result will be the same one that we obtained with `NumPyMinimumEigensolver`.
    But we can also obtain additional information with the following instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The result will be something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: First, we have printed the order of variables, to more easily interpret the
    assignments considered by the solver. Then, we have a listing of the different
    solutions that are part of the final, optimal state found by QAOA. Each item of
    the list includes the assignment, the energy or function value, the probability
    of obtaining the corresponding basis state when measuring the QAOA state, and
    whether the solution is feasible or not — `status``=<``OptimizationResultStatus``.``SUCCESS``:`
    `0>` indicates that the solution is feasible, while `status``=<``OptimizationResultStatus``.``INFEASIBLE``:`
  prefs: []
  type: TYPE_NORMAL
- en: '`2>` indicates that it is not.'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 5.6
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the code that we have just run to make the results reproducible. *Hint*:
    you can set seeds in the same way that we did in *Section* *[*5.2.1*](#x1-1020005.2.1).*'
  prefs: []
  type: TYPE_NORMAL
- en: '*We can also obtain full information about the QAOA execution by using the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We would obtain something like the following (where we have truncated part
    of the output):'
  prefs: []
  type: TYPE_NORMAL
- en: '@empty'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Notice, however, that these assignments include the auxiliary variables used
    in the transformation from constrained to unconstrained problem, as in the procedure
    that we studied in *Chapter* *[*3*](ch011.xhtml#x1-590003), *Working with Quadratic
    Unconstrained* *Binary Optimization Problems*, and the function values are also
    the ones taken in the transformed problem. In fact, you can obtain the corresponding
    QUBO problem with the following code:*
  prefs: []
  type: TYPE_NORMAL
- en: '*[PRE17]'
  prefs: []
  type: TYPE_NORMAL
- en: 'The output will be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this is now a QUBO problem in which slack variables and penalty
    terms have been introduced, exactly as we did in *Chapter* *[*3*](ch011.xhtml#x1-590003),
    *Working* *with Quadratic Unconstrained Binary Optimization Problems*.*
  prefs: []
  type: TYPE_NORMAL
- en: '*To learn more…'
  prefs: []
  type: TYPE_NORMAL
- en: In the `qiskit_optimization``.` `converters` module, you can also find the functions
    `InequalityToEquality`, `IntegerToBinary`, and `LinearEqualityToPenalty`. The
    `QuadraticProgramToQubo` function calls them to convert quadratic programs with
    constraints into QUBO instances, by first introducing slack variables to transform
    inequalities into equalities, then transforming the integer slack variables into
    binary ones, and finally, replacing the equality constraints with penalty terms.
  prefs: []
  type: TYPE_NORMAL
- en: You may now be wondering how to use `MinimumEigenOptimizer` with a quantum computer
    instead of with a simulator. Of course, when defining the `quantum_instance` parameter
    to use with the `QAOA` object, you can simply declare a real quantum device. But,
    as we have already mentioned, that would imply entering the device queue many
    times, with the consequent delay.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you surely remember from the previous subsection, if you have a Hamiltonian,
    you can use it directly in a QAOA Runtime program in order to submit your problem
    to the queue just once. So, is it possible to obtain the Hamiltonian of our problem?
    It sure is! You can run the following code to further transform the QUBO problem
    into an equivalent Hamiltonian:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: You can then use `H1` to solve the problem with the QAOA Runtime program and
    even recover the energy by adding back the `offset` term. But... that seems like
    a lot of work, doesn’t it? What’s more, you would need to deal with all those
    ugly slack variables that were introduced to transform the quadratic program into
    QUBO form. Surely, there has to be a simpler way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, the Qiskit developers are very thoughtful, and they have enabled
    us to use Qiskit Runtime directly with `MinimumEigenOptimizer`. To do that, though,
    you need something called the `QAOAClient`, which will take care of running everything
    smoothly with Runtime once you plug it into `MinimumEigenOptimizer`. Using it
    is as simple as selecting a device with enough qubits. We need at least ![6](img/file576.png
    "6"), so we have selected `ibm_lagos`, which has ![7](img/file465.png "7"); if
    you don’t have access to a big enough device, you can always use `ibmq_qasm_simulator`,
    which supports up to ![32](img/file771.png "32"). And once we have a device, we
    can just run the following instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This will yield the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: And, of course, you can obtain further information about the execution, as we
    did in previous examples, by accessing and using the values of the variables `result``.``variables`,
    `result``.``samples`, and `result``.``min_eigen_solver_result`. Very convenient,
    right?
  prefs: []
  type: TYPE_NORMAL
- en: We have now learned how to work with QAOA in Qiskit and how to manage and solve
    our problems in many different ways. It is time for us to turn back to PennyLane
    and see what it can offer in order to solve our beloved QUBO problems.
  prefs: []
  type: TYPE_NORMAL
- en: 5.3 Using QAOA with PennyLane
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we mentioned in *Chapter* *[*2*](ch009.xhtml#x1-400002), *The Tools of the
    Trade in Quantum Computing*, PennyLane is a quantum programming library focused
    mainly on quantum machine learning. As such, it doesn’t include as many tools
    for quantum optimization algorithms — such as QAOA — as Qiskit does. However,
    it does provide some interesting features such as automatic differentiation —
    that is, analytical computation of gradients — that may make it an appealing alternative
    to Qiskit in some circumstances.*
  prefs: []
  type: TYPE_NORMAL
- en: '*Let’s begin by explaining how to declare and work with Hamiltonians in PennyLane.
    For that, we will use the `Hamiltonian` class. It provides a constructor that
    accepts a list of coefficients and a list of products of Pauli matrices. For instance,
    if you want to define ![2Z_{0}Z_{1} - Z_{0}Z_{2} + 3.5Z_{1}](img/file772.png "2Z_{0}Z_{1}
    - Z_{0}Z_{2} + 3.5Z_{1}"), you will pass `[2,-1,3.5]` as the first argument and
    `[``PauliZ``(0)``@PauliZ``(1),``PauliZ``(0)``@PauliZ``(2),``PauliZ``(1)]` as the
    second one. As we know from *Chapter* * [*2*](ch009.xhtml#x1-400002), *The Tools
    of the Trade in Quantum Computing*, `PauliZ` is the ![Z](img/file8.png "Z") matrix
    in PennyLane. We are also using the `@` operator, which is PennyLane’s symbol
    for the tensor product operation. Putting it all together, we get the following
    instructions:*'
  prefs: []
  type: TYPE_NORMAL
- en: '*[PRE22]'
  prefs: []
  type: TYPE_NORMAL
- en: 'The output when we execute that code will be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we have constructed exactly the Hamiltonian that we wanted.
    We can also obtain its matrix by using `print``(``qml``.``matrix``(``H``))`, which
    would give us the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'As expected, this is a diagonal matrix. We can visualize it in a more compact
    way by executing the following instructions, which will give us only the non-zero
    elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The result will be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also define Hamiltonians in a more compact manner by specifying them
    in a mathematical expression like the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: If you print `H`, you will find that this definition is equivalent to the one
    that was introduced previously.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 5.7
  prefs: []
  type: TYPE_NORMAL
- en: Use PennyLane to define the ![- 3Z_{0}Z_{1}Z_{2} + 2Z_{1}Z_{2} - Z_{2}](img/file773.png
    "- 3Z_{0}Z_{1}Z_{2} + 2Z_{1}Z_{2} - Z_{2}") Hamiltonian in two different ways.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to define Hamiltonians, we can use them to create QAOA
    circuits with PennyLane. To this end, we will import the `qaoa` module, which
    will give us access to the `cost_layer` and `mixer_layer` functions. We will need
    a cost Hamiltonian — the one that encodes our optimization problem — to use with
    `cost_layer` and we will use ![{\sum}_{j}X_{j}](img/file774.png "{\sum}_{j}X_{j}")
    with `mixer_layer` (in the QAOA literature, our ![H_{0}](img/file545.png "H_{0}")
    Hamiltonian is sometimes called the **mixer Hamiltonian**, hence the name of the
    function). With them, we can create a function that constructs the QAOA circuit
    and that computes the energy of the state prepared by the circuit with respect
    to ![H_{1}](img/file544.png "H_{1}"). This latter part is very easy to accomplish
    with PennyLane, because it provides the `expval` function, which computes exactly
    that, and it can be used instead of the types of measurements that we introduced
    in *Section* * [*2.3.1*](ch009.xhtml#x1-530002.3.1).*
  prefs: []
  type: TYPE_NORMAL
- en: '*We can, thus, define a function that computes the energy of parameters with
    the following piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: There are several details that we need to explain here. First, we are working
    with a simple problem in which we want to find the ground state of ![Z_{0}Z_{1}](img/file352.png
    "Z_{0}Z_{1}"). We have defined our ![H_{0}](img/file545.png "H_{0}") Hamiltonian
    as ![X_{0} + X_{1}](img/file775.png "X_{0} + X_{1}") with `H0` `=` `qml``.``PauliX``(0)`
    `+` `qml``.``PauliX``(1)`. For ![H_{1}](img/file544.png "H_{1}"), we have used
    `1.0*``qml``.``PauliZ``(0)` `@` `qml``.``PauliZ``(1)` instead of just `qml``.``PauliZ``(0)`
    `@` `qml``.``PauliZ``(1)`. If you do not include the `1.0` coefficient, the tensor
    product will not be converted to a `Hamiltonian` object, so you should be careful
    with that. Another important detail is that the `energy` function only receives
    as parameters the angles for the rotations in the QAOA circuit and we have declared
    `p` as a global variable. This is because we later want to optimize `energy` with
    respect to its parameters, and `p` is not something that we want to optimize,
    but a fixed value — in this case, we are setting it to ![2](img/file302.png "2").
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, notice that the exponentials for ![H_{1}](img/file544.png "H_{1}")
    and ![H_{0}](img/file545.png "H_{0}") receive their parameters from the `angles`
    list alternating between ![H_{0}](img/file545.png "H_{0}") and ![H_{1}](img/file544.png
    "H_{1}"): first for the ![H_{0}](img/file545.png "H_{0}") exponential (which is
    implemented by `mixer_layer`), then for the ![H_{1}](img/file544.png "H_{1}")
    exponential (implemented by `cost_layer`), then again for the ![H_{0}](img/file545.png
    "H_{0}") exponential, and so on. In the notation that we have been using throughout
    this chapter, if `angles` is `[1.0,2.0.3.0,4.0]`, then we would have ![\beta_{1}
    = 1](img/file753.png "\beta_{1} = 1"), ![\gamma_{1} = 2](img/file776.png "\gamma_{1}
    = 2"), ![\beta_{2} = 3](img/file777.png "\beta_{2} = 3"), and ![\gamma_{2} = 4](img/file756.png
    "\gamma_{2} = 4"). Now we are ready to run the optimization process. To do that,
    we can use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We are using `GradientDescentOptimizer` as the classical minimizer. It uses
    the famous gradient descent algorithm — we will study this method in detail in
    *Part* *[*III*](ch016.xhtml#x1-138000III) of the book — by taking advantage of
    the fact that PennyLane implements automatic differentiation to compute all the
    required derivatives. That is why we use `requires_grad``=``True` when defining
    the initial angles, to inform PennyLane that these are parameters for which we
    will need to compute gradients. We run the process for 10 steps and…voilá! We
    obtain some (close to) optimal parameters. In this case, `[0.78178403` `0.7203965`
    `1.17250771`*
  prefs: []
  type: TYPE_NORMAL
- en: '*`1.27995423]` was the answer found by the optimizer. The angles and energy
    that you find can be highly dependent on the initial parameters, so it is advisable
    to run your code with several different choices of initial angles.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In any case, we can now sample from the QAOA circuit with the parameters that
    we have found in order to obtain candidate solutions to our problem. We just need
    to modify slightly the `energy` function that we defined previously. We can do
    it, for instance, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The output when you run these instructions will be something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The five samples are, indeed, ground states of ![Z_{0}Z_{1}](img/file352.png
    "Z_{0}Z_{1}"). Once more, we have been able to use QAOA to solve the problem,
    this time with PennyLane!
  prefs: []
  type: TYPE_NORMAL
- en: You surely have noticed that we have run our code on the `default``.``qubit`
    device, which is a simulator. Of course, you can replace it with a quantum device,
    as we learned to do in *Section* *[*2.3.2*](ch009.xhtml#x1-540002.3.2). However,
    this will mean that you will have to wait on the quantum computer execution queue
    every time the optimizer needs to evaluate the energy of some parameters.*
  prefs: []
  type: TYPE_NORMAL
- en: '*Unfortunately, at the time of writing, PennyLane does not yet include an option
    to run QAOA programs using Qiskit Runtime. However, do not despair! As we will
    learn in *Chapter* *[*7*](ch015.xhtml#x1-1190007)*, VQE: Variational Quantum*
    *Solver*, there is a PennyLane implementation of Runtime programs for some other
    algorithms. Hopefully, QAOA will receive the same treatment soon.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*With this, we have now concluded our study of QAOA. In the next chapter, we
    will study a different method for finding solutions to optimization problems,
    and it will be based on one of the most famous of all quantum algorithms ever:
    Grover’s algorithm.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you have learned about QAOA, one of the most popular quantum
    algorithms used to solve optimization problems with gate-based quantum computers.
    You now know that QAOA is derived as a discretization of quantum annealing and
    that it is implemented as a hybrid method that uses both a classical and a quantum
    computer to achieve its goal.
  prefs: []
  type: TYPE_NORMAL
- en: You also understand how to construct circuits for all the operations needed
    in the quantum part of the algorithm. In particular, you know how to use these
    circuits to estimate expectation values in an efficient way.
  prefs: []
  type: TYPE_NORMAL
- en: You have also mastered the tools that Qiskit provides in order to implement
    QAOA instances and to run them on both quantum simulators and quantum computers.
    You even know how to accelerate the process of running your code on quantum devices
    by using Qiskit Runtime. And, should you need to use QAOA with PennyLane, you
    also know how to do it with the help of some predefined utilities and PennyLane
    capabilities for automatic differentiation. This gives you the flexibility to
    solve optimization problems with QAOA in a number of different ways, depending
    on your needs and on the resources at your disposal.
  prefs: []
  type: TYPE_NORMAL
- en: Our next stop will be **Grover’s Adaptive Search**, also known as **GAS**, a
    quite different quantum method that you can use to solve optimization problems,
    which we’ll cover in the next chapter.***********************************
  prefs: []
  type: TYPE_NORMAL
