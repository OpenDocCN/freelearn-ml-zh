- en: Chapter 5
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第五章
- en: 'QAOA: Quantum Approximate Optimization Algorithm'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: QAOA：量子近似优化算法
- en: '*True optimization is the revolutionary contribution of modern* *research to
    decision processes.*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*真正的优化是现代研究对决策过程的革命性贡献。*'
- en: — George Dantzig
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: ——乔治·丹齐格
- en: The techniques that we have introduced in the two previous chapters already
    allow us to solve combinatorial optimization problems on quantum computers. Specifically,
    we have studied how to write problems using the QUBO formalism and how to use
    quantum annealers to sample approximate solutions. This is an important approach
    to quantum optimization, but it is not the only one.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前两章中介绍的技术已经使我们能够在量子计算机上解决组合优化问题。具体来说，我们已经研究了如何使用QUBO形式化来编写问题，以及如何使用量子退火器来采样近似解。这是量子优化的重要方法，但并非唯一的方法。
- en: In this chapter, we are going to show how the ideas that we have already explored
    can also be used on digital quantum computers. We will be using our beloved quantum
    circuits — with all their qubits, quantum gates, and measurements — to solve combinatorial
    optimization problems formulated in the QUBO framework.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将展示我们已探索的想法也可以用于数字量子计算机。我们将使用我们钟爱的量子电路——包括所有它们的量子比特、量子门和测量——来解决在QUBO框架中表述的组合优化问题。
- en: More concretely, we will be studying the famous **Quantum Approximate** **Optimization
    Algorithm** (**QAOA**), which is a gate-based algorithm that can be understood
    to be the counterpart to quantum annealing in the quantum circuit model. We will
    start by introducing all the theoretical concepts that are needed in order to
    understand this algorithm, then we will study the kind of circuits used in its
    implementation, and finally, we will explain how to run QAOA with both Qiskit
    and PennyLane.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，我们将研究著名的**量子近似** **优化算法**（**QAOA**），这是一个基于门的算法，可以理解为量子电路模型中量子退火的对应物。我们将首先介绍理解此算法所需的所有理论概念，然后研究其实施中使用的电路类型，最后解释如何使用Qiskit和PennyLane运行QAOA。
- en: After reading this chapter, you will understand how QAOA works, you will know
    how to design the circuits used in the algorithm, and you will be able to solve
    your own combinatorial optimization problems using QAOA in Qiskit and PennyLane.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读完本章后，您将了解QAOA的工作原理，您将知道如何设计算法中使用的电路，您将能够使用Qiskit和PennyLane中的QAOA来解决您自己的组合优化问题。
- en: 'The topics that we will cover in this chapter are the following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: From adiabatic computing to QAOA
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从绝热计算到QAOA
- en: Using QAOA with Qiskit
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Qiskit进行QAOA
- en: Using QAOA with PennyLane
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用PennyLane进行QAOA
- en: 5.1 From adiabatic computing to QAOA
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.1 从绝热计算到QAOA
- en: In this first section, we will introduce all the theoretical concepts that will
    allow us to understand QAOA in depth. But before that, we will give an intuitive
    idea of how QAOA works by studying its relationship with quantum annealing. Sounds
    interesting? Then keep on reading, because here we go!
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的第一部分，我们将介绍所有将使我们深入理解QAOA的理论概念。但在那之前，我们将通过研究其与量子退火的关系，给出QAOA工作原理的直观理解。听起来很有趣吗？那么继续阅读，因为这就开始了！
- en: 5.1.1 Discretizing adiabatic quantum computing
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.1.1 绝热量子计算的离散化
- en: 'In the previous chapter, we studied adiabatic quantum computing and its practical
    realization, quantum annealing, and we learned how to use them in order to obtain
    approximate solutions to combinatorial optimization problems. Both of these techniques
    relied on the adiabatic theorem. When we applied them, we used a time-dependent
    Hamiltonian that induced a continuous transformation of the state of a quantum
    system: from an initial state to a final state that — hopefully — has a big overlap
    with the solution to our problem.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们研究了绝热量子计算及其实际实现——量子退火，并学习了如何使用它们来获得组合优化问题的近似解。这两种技术都依赖于绝热定理。当我们应用它们时，我们使用了一个随时间变化的哈密顿量，它引起了一个量子系统状态的连续变换：从一个初始状态到一个最终状态——希望——与我们的问题的解有大的重叠。
- en: A natural question to ask is whether there is any sort of analog to this way
    of solving optimization problems for circuit-based quantum computers. At first
    sight, there is an apparent difficulty in this idea, because in the quantum circuit
    model we apply *instantaneous* operations — quantum gates — that change the state
    vector in discrete steps. How can we resolve this ”tension” between these discrete
    operations and the continuous evolution that we rely on for adiabatic quantum
    computing?
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一个自然的问题是要问是否存在某种类似的方法来解决基于电路的量子计算机的优化问题。乍一看，这个想法存在一个明显的困难，因为在量子电路模型中，我们应用**瞬时**操作——量子门——以离散步骤改变状态向量。我们如何解决这些离散操作和我们所依赖的绝热量子计算中的连续演化之间的“张力”呢？
- en: 'The answer is that we may **discretize** any continuous evolution, approximating
    it with a sequence of small, discrete changes. This process, sometimes called
    **Trotterization**, is the inspiration for the topic to which this chapter is
    devoted: the Quantum Approximate Optimization Algorithm — QAOA, for short.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是我们可能**离散化**任何连续演化，通过一系列小而离散的变化来近似它。这个过程有时被称为**Trotter化**，是本章所讨论的主题的灵感来源：量子近似优化算法——简称QAOA。
- en: QAOA was initially proposed [[37](ch030.xhtml#Xfarhi2014quantum)] as a **discretization**
    or Trotterization of adiabatic quantum computing with the goal of approximating
    the optimal solutions to combinatorial optimization problems. As you surely remember,
    the Hamiltonian that is used in adiabatic quantum computing — and in quantum annealing
    — is of the form
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: QAOA最初被提出[[37](ch030.xhtml#Xfarhi2014quantum)]作为一种**离散化**或Trotter化绝热量子计算的方法，目的是近似组合优化问题的最优解。正如你肯定记得的，在绝热量子计算——以及量子退火中——所使用的哈密顿量形式为
- en: '![H(t) = A(t)H_{0} + B(t)H_{1},](img/file546.png "H(t) = A(t)H_{0} + B(t)H_{1},")'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![H(t) = A(t)H_{0} + B(t)H_{1},](img/file546.png "H(t) = A(t)H_{0} + B(t)H_{1},")'
- en: with ![H_{0}](img/file545.png "H_{0}") and ![H_{1}](img/file544.png "H_{1}")
    two fixed Hamiltonians and ![A(t)](img/file623.png "A(t)") and ![B(t)](img/file624.png
    "B(t)") functions satisfying ![A(0) = B(T) = 1](img/file548.png "A(0) = B(T) =
    1") and ![A(T) = B(0) = 0](img/file549.png "A(T) = B(0) = 0"), where ![T](img/file74.png
    "T") is the total time of the process. It turns out that the evolution of the
    quantum system is governed by the famous time-dependent Schrödinger equation,
    and if you can solve it, you will have an expression for the state vector of your
    system at any moment ![t](img/file48.png "t") between ![0](img/file12.png "0")
    and ![T](img/file74.png "T").
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 其中![H_{0}](img/file545.png "H_{0}")和![H_{1}](img/file544.png "H_{1}")是两个固定的哈密顿量，![A(t)](img/file623.png
    "A(t)")和![B(t)](img/file624.png "B(t)")是满足![A(0) = B(T) = 1](img/file548.png "A(0)
    = B(T) = 1")和![A(T) = B(0) = 0](img/file549.png "A(T) = B(0) = 0")的函数，其中![T](img/file74.png
    "T")是整个过程的总时间。结果是，量子系统的演化由著名的时变薛定谔方程控制，如果你能解出它，你将得到在任何时刻![t](img/file48.png "t")（在![0](img/file12.png
    "0")和![T](img/file74.png "T")之间）的系统状态向量的表达式。
- en: However, to understand QAOA we don’t need to learn how to solve the Schrödinger
    equation — that was close, but we managed to dodge the bullet! All that we need
    to know is that, applying discretization, we can express the solution as a product
    of operators of the form
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，要理解QAOA，我们不需要学习如何解薛定谔方程——那几乎就是了，但我们设法避开了这个子弹！我们只需要知道的是，应用离散化，我们可以将解表示为形式为操作符的乘积
- en: '![e^{i\Delta t{({A(t_{c})H_{0} + B(t_{c})H_{1}})}}](img/file625.png "e^{i\Delta
    t{({A(t_{c})H_{0} + B(t_{c})H_{1}})}}")'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![e^{i\Delta t{({A(t_{c})H_{0} + B(t_{c})H_{1}})}}](img/file625.png "e^{i\Delta
    t{({A(t_{c})H_{0} + B(t_{c})H_{1}})}}")'
- en: applied to the initial state. Here, ![i](img/file49.png "i") is the imaginary
    unit, ![t_{c}](img/file626.png "t_{c}") is a fixed time point in ![\lbrack 0,T\rbrack](img/file547.png
    "\lbrack 0,T\rbrack"), and ![\Delta t](img/file627.png "\Delta t") is a small
    amount of time. The key idea is that in the interval ![\lbrack t_{c},t_{c} + \Delta
    t\rbrack](img/file628.png "\lbrack t_{c},t_{c} + \Delta t\rbrack") we assume that
    the Hamiltonian is constant and equal to ![H(t_{c}) = A(t_{c})H_{0} + B(t_{c})H_{1}](img/file629.png
    "H(t_{c}) = A(t_{c})H_{0} + B(t_{c})H_{1}"). Of course, the smaller ![\Delta t](img/file627.png
    "\Delta t") is, the better this approximation will be. It is also important to
    notice that ![e^{i\Delta t{({A(t_{c})H_{0} + B(t_{c})H_{1}})}}](img/file630.png
    "e^{i\Delta t{({A(t_{c})H_{0} + B(t_{c})H_{1}})}}") is a unitary transformation,
    just like the ones we studied in *Chapter* * [*1*](ch008.xhtml#x1-180001), *Foundations
    of Quantum Computing*. In fact, you surely remember that some of the quantum gates
    that we introduced in that chapter, such as ![R_{X}](img/file118.png "R_{X}"),
    ![R_{Y}](img/file119.png "R_{Y}"), and ![R_{Z}](img/file120.png "R_{Z}"), are
    also exponentials of some matrices. Using this discretization technique, if ![\left|
    \psi_{0} \right\rangle](img/file631.png "\left| \psi_{0} \right\rangle") is the
    initial state, then the final state can be approximated by*
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 应用于初始状态。在这里，![i](img/file49.png "i")是虚数单位，![t_{c}](img/file626.png "t_{c}")是![\lbrack
    0,T\rbrack](img/file547.png "\lbrack 0,T\rbrack")中的一个固定时间点，而![\Delta t](img/file627.png
    "\Delta t")是一小段时间。关键思想是在![\lbrack t_{c},t_{c} + \Delta t\rbrack](img/file628.png
    "\lbrack t_{c},t_{c} + \Delta t\rbrack")这个区间内，我们假设哈密顿量是常数，并且等于![H(t_{c}) = A(t_{c})H_{0}
    + B(t_{c})H_{1}](img/file629.png "H(t_{c}) = A(t_{c})H_{0} + B(t_{c})H_{1}")。当然，![\Delta
    t](img/file627.png "\Delta t")越小，这个近似越好。同样重要的是要注意，![e^{i\Delta t{({A(t_{c})H_{0}
    + B(t_{c})H_{1}})}}](img/file630.png "e^{i\Delta t{({A(t_{c})H_{0} + B(t_{c})H_{1}})}}")是一个幺正变换，就像我们在*第*
    * [*1*](ch008.xhtml#x1-180001)，*量子计算基础*这一章中研究的那样。实际上，你肯定记得我们在这章中介绍的一些量子门，例如![R_{X}](img/file118.png
    "R_{X}"), ![R_{Y}](img/file119.png "R_{Y}"), 和![R_{Z}](img/file120.png "R_{Z}"),也是某些矩阵的指数。使用这种离散化技术，如果![\left|
    \psi_{0} \right\rangle](img/file631.png "\left| \psi_{0} \right\rangle")是初始状态，那么最终状态可以近似为*
- en: '*![\left( {\prod\limits_{m = 0}^{p}e^{i\Delta t{({A(t_{m})H_{0} + B(t_{m})H_{1}})}}}
    \right)\left| \psi_{0} \right\rangle,](img/file632.png "\left( {\prod\limits_{m
    = 0}^{p}e^{i\Delta t{({A(t_{m})H_{0} + B(t_{m})H_{1}})}}} \right)\left| \psi_{0}
    \right\rangle,")'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*![\left( {\prod\limits_{m = 0}^{p}e^{i\Delta t{({A(t_{m})H_{0} + B(t_{m})H_{1}})}}}
    \right)\left| \psi_{0} \right\rangle,](img/file632.png "\left( {\prod\limits_{m
    = 0}^{p}e^{i\Delta t{({A(t_{m})H_{0} + B(t_{m})H_{1}})}}} \right)\left| \psi_{0}
    \right\rangle,")'
- en: where ![t_{m} = m\frac{\Delta t}{T}](img/file633.png "t_{m} = m\frac{\Delta
    t}{T}") and ![p = \frac{T}{\Delta t}](img/file634.png "p = \frac{T}{\Delta t}").
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 其中![t_{m} = m\frac{\Delta t}{T}](img/file633.png "t_{m} = m\frac{\Delta t}{T}")和![p
    = \frac{T}{\Delta t}](img/file634.png "p = \frac{T}{\Delta t}").
- en: In order to compute this state with a quantum circuit, we just need an additional
    approximation. As you know, for any real numbers ![a](img/file16.png "a") and
    ![b](img/file17.png "b"), it holds that ![e^{a + b} = e^{a}e^{b}](img/file635.png
    "e^{a + b} = e^{a}e^{b}"). The analogous identity for exponentials of matrices
    does not hold in general — unless the matrices commute. However, if ![\Delta t](img/file627.png
    "\Delta t") is small, then
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了用量子电路计算这个状态，我们只需要一个额外的近似。正如你所知，对于任何实数![a](img/file16.png "a")和![b](img/file17.png
    "b")，都成立![e^{a + b} = e^{a}e^{b}](img/file635.png "e^{a + b} = e^{a}e^{b}")。对于矩阵指数的类似恒等式通常不成立——除非矩阵对易。然而，如果![\Delta
    t](img/file627.png "\Delta t")很小，那么
- en: '![e^{i\Delta t{({A(t_{c})H_{0} + B(t_{c})H_{1}})}} \approx e^{i\Delta tA(t_{c})H_{0}}e^{i\Delta
    tB(t_{c})H_{1}},](img/file636.png "e^{i\Delta t{({A(t_{c})H_{0} + B(t_{c})H_{1}})}}
    \approx e^{i\Delta tA(t_{c})H_{0}}e^{i\Delta tB(t_{c})H_{1}},")'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![e^{i\Delta t{({A(t_{c})H_{0} + B(t_{c})H_{1}})}} \approx e^{i\Delta tA(t_{c})H_{0}}e^{i\Delta
    tB(t_{c})H_{1}},](img/file636.png "e^{i\Delta t{({A(t_{c})H_{0} + B(t_{c})H_{1}})}}
    \approx e^{i\Delta tA(t_{c})H_{0}}e^{i\Delta tB(t_{c})H_{1}},")'
- en: which is known as the **Lie-Trotter formula**.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是所谓的**李-特罗特公式**。
- en: Putting it all together, the final state of the adiabatic evolution can be approximated
    by
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有这些放在一起，绝热演化的最终状态可以近似为
- en: '![\prod\limits_{m = 0}^{p}e^{i\Delta tA(t_{m})H_{0}}e^{i\Delta tB(t_{m})H_{1}}\left|
    \psi_{0} \right\rangle,](img/file637.png "\prod\limits_{m = 0}^{p}e^{i\Delta tA(t_{m})H_{0}}e^{i\Delta
    tB(t_{m})H_{1}}\left| \psi_{0} \right\rangle,")'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![\prod\limits_{m = 0}^{p}e^{i\Delta tA(t_{m})H_{0}}e^{i\Delta tB(t_{m})H_{1}}\left|
    \psi_{0} \right\rangle,](img/file637.png "\prod\limits_{m = 0}^{p}e^{i\Delta tA(t_{m})H_{0}}e^{i\Delta
    tB(t_{m})H_{1}}\left| \psi_{0} \right\rangle,")'
- en: which is the inspiration for QAOA, as we will see in the next subsection.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是QAOA的灵感来源，我们将在下一小节中看到。
- en: '5.1.2 QAOA: The algorithm'
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.1.2 QAOA：算法
- en: The starting point and goal of QAOA are exactly the same as those of quantum
    annealing. We begin with a combinatorial optimization problem that we want to
    solve, and we encode it, as we learned in *Chapter* *[*3*](ch011.xhtml#x1-590003),
    *Working with Quadratic* *Unconstrained Binary Optimization Problems*, into an
    Ising Hamiltonian ![H_{1}](img/file544.png "H_{1}"). In order to find its ground
    state and solve our problem, we seek to apply a quantum state evolution similar
    to that of quantum annealing, but using a quantum circuit instead of a quantum
    annealer.*
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: QAOA 的起点和目标与量子退火完全相同。我们从一个我们想要解决的组合优化问题开始，正如我们在 *第* *[*3*](ch011.xhtml#x1-590003)，*处理二次无约束二进制优化问题*
    中所学的那样，将其编码成一个 Ising 哈密顿量 ![H_{1}](img/file544.png "H_{1}"). 为了找到其基态并解决我们的问题，我们寻求应用类似于量子退火的量子状态演化，但使用量子线路而不是量子退火器。
- en: '*In light of the discretization of adiabatic evolution that we obtained at
    the end of the previous subsection, the idea behind QAOA is simple. In order to
    simulate with a quantum circuit the evolution of a state under a time-dependent
    Hamiltonian, you only need to take an initial state ![\left| \psi_{0} \right\rangle](img/file631.png
    "\left| \psi_{0} \right\rangle") and then alternate for ![p](img/file141.png "p")
    times the application of the operators ![e^{i\gamma H_{1}}](img/file638.png "e^{i\gamma
    H_{1}}") and ![e^{i\beta H_{0}}](img/file639.png "e^{i\beta H_{0}}") for some
    values of ![\gamma](img/file127.png "\gamma") and ![\beta](img/file126.png "\beta").
    In the next subsection, by the way, we will see that the unitary transformations
    ![e^{i\gamma H_{1}}](img/file638.png "e^{i\gamma H_{1}}") and ![e^{i\beta H_{0}}](img/file639.png
    "e^{i\beta H_{0}}") can be implemented with just one-qubit and two-qubit quantum
    gates.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*鉴于我们在上一小节末获得的绝热演化的离散化，QAOA 的理念很简单。为了用量子线路模拟在时变哈密顿量下的状态演化，你只需要取一个初始状态 ![\left|
    \psi_{0} \right\rangle](img/file631.png "\left| \psi_{0} \right\rangle")，然后交替应用
    ![p](img/file141.png "p") 次操作符 ![e^{i\gamma H_{1}}](img/file638.png "e^{i\gamma
    H_{1}}") 和 ![e^{i\beta H_{0}}](img/file639.png "e^{i\beta H_{0}}")，其中 ![gamma](img/file127.png
    "\gamma") 和 ![beta](img/file126.png "\beta") 取某些值。顺便说一下，在下一小节中，我们将看到单位变换 ![e^{i\gamma
    H_{1}}](img/file638.png "e^{i\gamma H_{1}}") 和 ![e^{i\beta H_{0}}](img/file639.png
    "e^{i\beta H_{0}}") 可以仅用单量子比特和双量子比特量子门来实现。'
- en: What we are doing is, then, using a quantum circuit to prepare a state of the
    form
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的是，然后，使用量子线路来制备一种形式的状态
- en: '![e^{i\beta_{p}H_{0}}e^{i\gamma_{p}H_{1}}\ldots e^{i\beta_{2}H_{0}}e^{i\gamma_{2}H_{1}}e^{i\beta_{1}H_{0}}e^{i\gamma_{1}H_{1}}\left|
    \psi_{0} \right\rangle,](img/file640.png "e^{i\beta_{p}H_{0}}e^{i\gamma_{p}H_{1}}\ldots
    e^{i\beta_{2}H_{0}}e^{i\gamma_{2}H_{1}}e^{i\beta_{1}H_{0}}e^{i\gamma_{1}H_{1}}\left|
    \psi_{0} \right\rangle,")'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![e^{i\beta_{p}H_{0}}e^{i\gamma_{p}H_{1}}\ldots e^{i\beta_{2}H_{0}}e^{i\gamma_{2}H_{1}}e^{i\beta_{1}H_{0}}e^{i\gamma_{1}H_{1}}\left|
    \psi_{0} \right\rangle,](img/file640.png "e^{i\beta_{p}H_{0}}e^{i\gamma_{p}H_{1}}\ldots
    e^{i\beta_{2}H_{0}}e^{i\gamma_{2}H_{1}}e^{i\beta_{1}H_{0}}e^{i\gamma_{1}H_{1}}\left|
    \psi_{0} \right\rangle,")'
- en: where ![p \geq 1](img/file641.png "p \geq 1"). Usually, we collect all the coefficients
    in the exponents in two tuples ![\mathbf{\beta} = (\beta_{1},\ldots,\beta_{p})](img/file642.png
    "\mathbf{\beta} = (\beta_{1},\ldots,\beta_{p})") and ![\mathbf{\gamma} = (\gamma_{1},\ldots,\gamma_{p})](img/file643.png
    "\mathbf{\gamma} = (\gamma_{1},\ldots,\gamma_{p})") and we denote the whole state
    by ![\left| {\mathbf{\beta},\mathbf{\gamma}} \right\rangle](img/file644.png "\left|
    {\mathbf{\beta},\mathbf{\gamma}} \right\rangle").
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 ![p \geq 1](img/file641.png "p \geq 1"). 通常，我们将指数中的所有系数收集在两个元组 ![\mathbf{\beta}
    = (\beta_{1},\ldots,\beta_{p})](img/file642.png "\mathbf{\beta} = (\beta_{1},\ldots,\beta_{p})")
    和 ![\mathbf{\gamma} = (\gamma_{1},\ldots,\gamma_{p})](img/file643.png "\mathbf{\gamma}
    = (\gamma_{1},\ldots,\gamma_{p})") 中，并用 ![\left| {\mathbf{\beta},\mathbf{\gamma}}
    \right\rangle](img/file644.png "\left| {\mathbf{\beta},\mathbf{\gamma}} \right\rangle")
    表示整个状态。
- en: In QAOA, we choose a fixed value of ![p](img/file141.png "p") and we have some
    values for ![\mathbf{\beta}](img/file645.png "\mathbf{\beta}") and ![\mathbf{\gamma}](img/file646.png
    "\mathbf{\gamma}"). Instead of thinking of the values for ![\mathbf{\beta}](img/file645.png
    "\mathbf{\beta}") and ![\mathbf{\gamma}](img/file646.png "\mathbf{\gamma}") as
    small increments of time multiplied by intensity coefficients given by the functions
    ![A](img/file183.png "A") and ![B](img/file184.png "B"), as we did in the previous
    subsection, we’ll just consider them to be ”plain real numbers.” And this is where
    the magic kicks in. Since we are now free to choose their values as we see fit…why
    not choose the *best* possible values for them?
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在QAOA中，我们选择一个固定的![p](img/file141.png "p")值，并且我们有![\mathbf{\beta}](img/file645.png
    "\mathbf{\beta}")和![\mathbf{\gamma}](img/file646.png "\mathbf{\gamma}")的一些值。与我们在前一小节中那样，将![\mathbf{\beta}](img/file645.png
    "\mathbf{\beta}")和![\mathbf{\gamma}](img/file646.png "\mathbf{\gamma}")的值视为由函数![A](img/file183.png
    "A")和![B](img/file184.png "B")给出的强度系数乘以小时间增量，我们现在将它们视为“普通的实数”。这正是魔法开始发挥作用的地方。既然我们现在可以自由地选择它们的值，为什么不尽可能选择它们的最优值呢？
- en: 'But what does *best* mean here? Remember that we are just trying to find the
    ground state of ![H_{1}](img/file544.png "H_{1}"), so, for us, the lower the value
    of the energy ![\left\langle {\mathbf{\beta},\mathbf{\gamma}} \right|H_{1}\left|
    {\mathbf{\beta},\mathbf{\gamma}} \right\rangle](img/file647.png "\left\langle
    {\mathbf{\beta},\mathbf{\gamma}} \right|H_{1}\left| {\mathbf{\beta},\mathbf{\gamma}}
    \right\rangle"), the better. In this way, we have transformed our optimization
    problem into another one: finding the values ![\mathbf{\beta}](img/file645.png
    "\mathbf{\beta}") and ![\mathbf{\gamma}](img/file646.png "\mathbf{\gamma}") that
    minimize'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 但在这里，“**最佳**”意味着什么？请记住，我们只是在尝试找到![H_{1}](img/file544.png "H_{1}")的基态，因此，对我们来说，能量![\left\langle
    {\mathbf{\beta},\mathbf{\gamma}} \right|H_{1}\left| {\mathbf{\beta},\mathbf{\gamma}}
    \right\rangle](img/file647.png "\left\langle {\mathbf{\beta},\mathbf{\gamma}}
    \right|H_{1}\left| {\mathbf{\beta},\mathbf{\gamma}} \right\rangle")的值越低越好。这样，我们就将我们的优化问题转化为另一个问题：找到![\mathbf{\beta}](img/file645.png
    "\mathbf{\beta}")和![\mathbf{\gamma}](img/file646.png "\mathbf{\gamma}")的值，以使它们最小化。
- en: '![E(\mathbf{\beta},\mathbf{\gamma}) = \left\langle {\mathbf{\beta},\mathbf{\gamma}}
    \right|H_{1}\left| {\mathbf{\beta},\mathbf{\gamma}} \right\rangle.](img/file648.png
    "E(\mathbf{\beta},\mathbf{\gamma}) = \left\langle {\mathbf{\beta},\mathbf{\gamma}}
    \right|H_{1}\left| {\mathbf{\beta},\mathbf{\gamma}} \right\rangle.")'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![E(\mathbf{\beta},\mathbf{\gamma}) = \left\langle {\mathbf{\beta},\mathbf{\gamma}}
    \right|H_{1}\left| {\mathbf{\beta},\mathbf{\gamma}} \right\rangle.](img/file648.png
    "E(\mathbf{\beta},\mathbf{\gamma}) = \left\langle {\mathbf{\beta},\mathbf{\gamma}}
    \right|H_{1}\left| {\mathbf{\beta},\mathbf{\gamma}} \right\rangle.")'
- en: Notice that, since the values ![\mathbf{\beta}](img/file645.png "\mathbf{\beta}")
    and ![\mathbf{\gamma}](img/file646.png "\mathbf{\gamma}") are real and so is the
    energy ![E(\mathbf{\beta},\mathbf{\gamma})](img/file649.png "E(\mathbf{\beta},\mathbf{\gamma})"),
    what we have in our hands is the old problem of finding a minimum for a real-valued
    function with real inputs. There are many algorithms that we can apply for this,
    for instance, the famous **gradient descent algorithm**, which we will be using
    to train machine learning models in *Part* * [*III*](ch016.xhtml#x1-138000III),
    *A Match Made in Heaven:* *Quantum Machine Learning*, of this book. However, there
    is an important twist. As we know, the number of amplitudes needed to describe
    a state like ![\left| {\mathbf{\beta},\mathbf{\gamma}} \right\rangle](img/file644.png
    "\left| {\mathbf{\beta},\mathbf{\gamma}} \right\rangle") is exponential in the
    number of qubits that we are using. Thus, computing ![E(\mathbf{\beta},\mathbf{\gamma})](img/file649.png
    "E(\mathbf{\beta},\mathbf{\gamma})") may be difficult with just a classical computer.*
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于![\mathbf{\beta}](img/file645.png "\mathbf{\beta}")和![\mathbf{\gamma}](img/file646.png
    "\mathbf{\gamma}")是实数，能量![E(\mathbf{\beta},\mathbf{\gamma})](img/file649.png "E(\mathbf{\beta},\mathbf{\gamma})")也是实数，所以我们手头上的问题是寻找一个具有实数输入的实值函数的最小值的老问题。我们可以应用许多算法来解决这个问题，例如著名的**梯度下降算法**，我们将在本书的**第三部分**[*III*](ch016.xhtml#x1-138000III)，“天作之合：量子机器学习”中用它来训练机器学习模型。然而，这里有一个重要的转折。正如我们所知，描述像![\left|
    {\mathbf{\beta},\mathbf{\gamma}} \right\rangle](img/file644.png "\left| {\mathbf{\beta},\mathbf{\gamma}}
    \right\rangle")这样的状态的振幅数量是我们所使用的量子比特数量的指数级。因此，仅用经典计算机计算![E(\mathbf{\beta},\mathbf{\gamma})](img/file649.png
    "E(\mathbf{\beta},\mathbf{\gamma})")可能很困难。
- en: '*But it turns out that estimating values of ![E(\mathbf{\beta},\mathbf{\gamma})](img/file649.png
    "E(\mathbf{\beta},\mathbf{\gamma})") is something that we can do very efficiently
    with a quantum computer — at least when the number of terms in ![H_{1}](img/file544.png
    "H_{1}") is polynomial in the number of qubits, something that is usually the
    case in the problems we are interested in. In the next subsection, we will explain
    in detail how to compute that kind of estimation, but for now just keep in mind
    that, given some values ![\mathbf{\beta}](img/file645.png "\mathbf{\beta}") and
    ![\mathbf{\gamma}](img/file646.png "\mathbf{\gamma}"), we can rely on the quantum
    computer to compute ![E(\mathbf{\beta},\mathbf{\gamma})](img/file649.png "E(\mathbf{\beta},\mathbf{\gamma})").'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*但是，结果证明，使用量子计算机来估算![E(\mathbf{\beta},\mathbf{\gamma})](img/file649.png "E(\mathbf{\beta},\mathbf{\gamma})")的值是非常高效的——至少当![H_{1}](img/file544.png
    "H_{1}")中的项数是量子比特数的多项式时，这种情况通常是我们感兴趣的问题中的情况。在下一个小节中，我们将详细解释如何计算这种估算，但到目前为止，只需记住，给定一些![\mathbf{\beta}](img/file645.png
    "\mathbf{\beta}")和![\mathbf{\gamma}](img/file646.png "\mathbf{\gamma}")的值，我们可以依赖量子计算机来计算![E(\mathbf{\beta},\mathbf{\gamma})](img/file649.png
    "E(\mathbf{\beta},\mathbf{\gamma})")。*'
- en: Then, we can take any classical algorithm for function minimization and, whenever
    it needs to compute a value of the ![E](img/file327.png "E") function, we use
    a quantum computer to estimate it and we give that value back to the classical
    algorithm until it needs another of value ![E](img/file327.png "E"). At that moment,
    we again use the quantum computer to obtain it and so on and so forth, all until
    we meet the stopping criteria of the classical algorithm. This is what we call
    a **hybrid algorithm**, one where the classical and the quantum computer work
    in tandem to solve a problem. We will see this kind of interaction many more times
    throughout the book.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用任何用于函数最小化的经典算法，每当它需要计算![E](img/file327.png "E")函数的值时，我们就使用量子计算机来估算它，并将该值返回给经典算法，直到它需要另一个![E](img/file327.png
    "E")的值。在那个时刻，我们再次使用量子计算机来获得它，以此类推，直到我们遇到经典算法的停止标准。这就是我们所说的**混合算法**，在这种算法中，经典计算机和量子计算机协同工作来解决一个问题。在整个书中，我们将看到这种交互的许多例子。
- en: Once we have obtained the optimal values ![\mathbf{\beta^{\ast}}](img/file650.png
    "\mathbf{\beta^{\ast}}") and ![\mathbf{\gamma^{\ast}}](img/file651.png "\mathbf{\gamma^{\ast}}")
    for ![\mathbf{\beta}](img/file645.png "\mathbf{\beta}") and ![\mathbf{\gamma}](img/file646.png
    "\mathbf{\gamma}") — or, at least, an estimation of them — we can use the quantum
    computer once more in order to prepare the state ![\left| {\mathbf{\beta^{\ast}},\mathbf{\gamma^{\ast}}}
    \right\rangle](img/file652.png "\left| {\mathbf{\beta^{\ast}},\mathbf{\gamma^{\ast}}}
    \right\rangle"). This state should have a sizeable overlap with the ground state
    of ![H_{1}](img/file544.png "H_{1}"), so when we measure it in the computational
    basis, we will have a good chance of obtaining a string of zeros and ones that
    is a good solution to our original problem — the one encoded in ![H_{1}](img/file544.png
    "H_{1}") by using the techniques of *Chapter* * [*3*](ch011.xhtml#x1-590003),
    *Working with Quadratic Unconstrained* *Binary Optimization Problems*.*
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们获得了![\mathbf{\beta}](img/file645.png "\mathbf{\beta}")和![\mathbf{\gamma}](img/file646.png
    "\mathbf{\gamma}")的最优值![\mathbf{\beta^{\ast}}](img/file650.png "\mathbf{\beta^{\ast}}")和![\mathbf{\gamma^{\ast}}](img/file651.png
    "\mathbf{\gamma^{\ast}}")——或者至少是它们的估算值——我们就可以再次使用量子计算机来准备![\left| {\mathbf{\beta^{\ast}},\mathbf{\gamma^{\ast}}}
    \right\rangle](img/file652.png "\left| {\mathbf{\beta^{\ast}},\mathbf{\gamma^{\ast}}}
    \right\rangle")状态。这种状态应该与![H_{1}](img/file544.png "H_{1}")的基态有相当大的重叠，因此当我们以计算基对其进行测量时，我们有很大的机会获得一串零和一，这将是解决我们原始问题——使用*第*
    *3* *章* *[*3*](ch011.xhtml#x1-590003)*，*处理二次无约束* *二进制优化问题* *的技术编码在![H_{1}](img/file544.png
    "H_{1}")中*的一个很好的解决方案。
- en: '*We now have all the pieces of the puzzle, so let’s put them all together.
    The input to QAOA is an Ising Hamiltonian ![H_{1}](img/file544.png "H_{1}"), the
    ground state of which we wish to approximate because it encodes the solution to
    a certain combinatorial optimization problem. To that end, we consider the energy
    function ![E(\mathbf{\beta},\mathbf{\gamma})](img/file649.png "E(\mathbf{\beta},\mathbf{\gamma})")
    as defined before and we proceed to minimize it. For that, we choose ![p \geq
    1](img/file641.png "p \geq 1") and some initial values ![\mathbf{\beta_{0}}](img/file653.png
    "\mathbf{\beta_{0}}") and ![\mathbf{\gamma_{0}}](img/file654.png "\mathbf{\gamma_{0}}")
    that we shall use as the starting point for some classical minimization algorithm.
    Then, we run the minimization algorithm and, whenever it requests an evaluation
    of ![E](img/file327.png "E") on some points ![\mathbf{\beta}](img/file645.png
    "\mathbf{\beta}") and ![\mathbf{\gamma}](img/file646.png "\mathbf{\gamma}"), we
    use the quantum computer to prepare the state ![\left| {\mathbf{\beta},\mathbf{\gamma}}
    \right\rangle](img/file644.png "\left| {\mathbf{\beta},\mathbf{\gamma}} \right\rangle")
    and estimate its energy, and we return the value to the classical algorithm. We
    continue this process until the classical minimization algorithm stops, returning
    some optimal values ![\mathbf{\beta^{\ast}}](img/file650.png "\mathbf{\beta^{\ast}}")
    and ![\mathbf{\gamma^{\ast}}](img/file651.png "\mathbf{\gamma^{\ast}}"). As a
    final step, we use the quantum computer to prepare ![\left| {\mathbf{\beta^{\ast}},\mathbf{\gamma^{\ast}}}
    \right\rangle](img/file652.png "\left| {\mathbf{\beta^{\ast}},\mathbf{\gamma^{\ast}}}
    \right\rangle"). When we measure it, we obtain a — hopefully, good — approximate
    solution to our combinatorial problem.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们现在已经拥有了拼图的全部碎片，让我们把它们全部放在一起。QAOA的输入是一个伊辛哈密顿量 ![H_{1}](img/file544.png "H_{1}"),
    我们希望近似其基态，因为它编码了解决某个组合优化问题的解。为此，我们考虑之前定义的能量函数 ![E(\mathbf{\beta},\mathbf{\gamma})](img/file649.png
    "E(\mathbf{\beta},\mathbf{\gamma})") 并着手最小化它。为此，我们选择 ![p \geq 1](img/file641.png
    "p \geq 1") 和一些初始值 ![\mathbf{\beta_{0}}](img/file653.png "\mathbf{\beta_{0}}")
    和 ![\mathbf{\gamma_{0}}](img/file654.png "\mathbf{\gamma_{0}}")，我们将它们用作某些经典最小化算法的起点。然后，我们运行最小化算法，每当它请求在某个点
    ![E](img/file327.png "E") 和 ![\mathbf{\beta}](img/file645.png "\mathbf{\beta}")
    以及 ![\mathbf{\gamma}](img/file646.png "\mathbf{\gamma}") 上进行评估时，我们使用量子计算机来准备状态
    ![左| {\mathbf{\beta},\mathbf{\gamma}} \right\rangle](img/file644.png "\left| {\mathbf{\beta},\mathbf{\gamma}}
    \right\rangle") 并估计其能量，并将该值返回给经典算法。我们继续这个过程，直到经典最小化算法停止，返回一些最优值 ![\mathbf{\beta^{\ast}}](img/file650.png
    "\mathbf{\beta^{\ast}}") 和 ![\mathbf{\gamma^{\ast}}](img/file651.png "\mathbf{\gamma^{\ast}}")。作为最后一步，我们使用量子计算机来准备
    ![左| {\mathbf{\beta^{\ast}},\mathbf{\gamma^{\ast}}} \right\rangle](img/file652.png
    "\left| {\mathbf{\beta^{\ast}},\mathbf{\gamma^{\ast}}} \right\rangle")。当我们测量它时，我们获得一个——希望是——好的组合问题的近似解。'
- en: We have collected all these steps as pseudocode in the following algorithm.
    Notice that there are just two points at which the quantum computer is required.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这些步骤收集为以下算法的伪代码。请注意，只有在两个点上需要量子计算机。
- en: '**Algorithm 5.1** (QAOA)**.**'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**算法 5.1** (QAOA)**.**'
- en: Choose a value for ![p](img/file141.png "p")
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为 ![p](img/file141.png "p") 选择一个值
- en: Choose a starting set of values ![\mathbf{\beta} = (\beta_{1},\ldots,\beta_{p})](img/file642.png
    "\mathbf{\beta} = (\beta_{1},\ldots,\beta_{p})") and ![\mathbf{\gamma} = (\gamma_{1},\ldots,\gamma_{p})](img/file643.png
    "\mathbf{\gamma} = (\gamma_{1},\ldots,\gamma_{p})")
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 选择一组起始值 ![\mathbf{\beta} = (\beta_{1},\ldots,\beta_{p})](img/file642.png "\mathbf{\beta}
    = (\beta_{1},\ldots,\beta_{p})") 和 ![\mathbf{\gamma} = (\gamma_{1},\ldots,\gamma_{p})](img/file643.png
    "\mathbf{\gamma} = (\gamma_{1},\ldots,\gamma_{p})")
- en: '**while** the stopping criteria are not met **do**'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**当**停止条件未满足时 **do**'
- en: Prepare state ![\left| {\mathbf{\beta},\mathbf{\gamma}} \right\rangle](img/file644.png
    "\left| {\mathbf{\beta},\mathbf{\gamma}} \right\rangle")    ![\vartriangleright](img/file655.png
    "\vartriangleright") *This* *is done on the quantum computer!*
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 准备状态 ![左| {\mathbf{\beta},\mathbf{\gamma}} \right\rangle](img/file644.png "\left|
    {\mathbf{\beta},\mathbf{\gamma}} \right\rangle")    ![\vartriangleright](img/file655.png
    "\vartriangleright") *这是在量子计算机上完成的！*
- en: From measurements of ![\left| {\mathbf{\beta},\mathbf{\gamma}} \right\rangle](img/file644.png
    "\left| {\mathbf{\beta},\mathbf{\gamma}} \right\rangle"), estimate ![E(\mathbf{\beta},\mathbf{\gamma})](img/file649.png
    "E(\mathbf{\beta},\mathbf{\gamma})")
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 从 ![左| {\mathbf{\beta},\mathbf{\gamma}} \right\rangle](img/file644.png "\left|
    {\mathbf{\beta},\mathbf{\gamma}} \right\rangle") 的测量中估计 ![E(\mathbf{\beta},\mathbf{\gamma})](img/file649.png
    "E(\mathbf{\beta},\mathbf{\gamma})")
- en: Update ![\mathbf{\beta}](img/file645.png "\mathbf{\beta}") and ![\mathbf{\gamma}](img/file646.png
    "\mathbf{\gamma}") according to the minimization algorithm
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 根据最小化算法更新![β](img/file645.png "![β]")和![γ](img/file646.png "![γ]")
- en: '-'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '-'
- en: Obtain the optimal values ![\mathbf{\beta^{\ast}}](img/file650.png "\mathbf{\beta^{\ast}}")
    and ![\mathbf{\gamma^{\ast}}](img/file651.png "\mathbf{\gamma^{\ast}}") returned
    by the minimization algorithm
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 获得最小化算法返回的最优值![β^{*}](img/file650.png "![β^{*}"])和![γ^{*}](img/file651.png "![γ^{*}"])
- en: Prepare state ![\left| {\mathbf{\beta^{\ast}},\mathbf{\gamma^{\ast}}} \right\rangle](img/file652.png
    "\left| {\mathbf{\beta^{\ast}},\mathbf{\gamma^{\ast}}} \right\rangle")    ![\vartriangleright](img/file655.png
    "\vartriangleright") *This* *is done on the quantum computer!*
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 准备状态![左| {β^{*},γ^{*}} >](img/file652.png "![左| {β^{*},γ^{*}} >")    ![\vartriangleright](img/file655.png
    "![\vartriangleright]") *这是在量子计算机上完成的！*
- en: Measure the state to obtain an approximate solution
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 测量状态以获得一个近似解
- en: To learn more…
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多...
- en: Just before bringing this subsection to an end, we thought this could be a good
    time for us to share a historical fact with you.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束本小节之前，我们认为这是一个与我们分享一个历史事实的好时机。
- en: When it was introduced in a 2014 paper [[37](ch030.xhtml#Xfarhi2014quantum)],
    QAOA provided a better ratio of approximation for the Max-Cut problem than any
    existing classical algorithm that would run on polynomial time. And we say that
    it *provided* because, soon after, this claim was challenged by a paper [[11](ch030.xhtml#Xbarak2015beating)]
    that presented a classical algorithm that could beat QAOA.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当它在2014年的一篇论文[[37](ch030.xhtml#Xfarhi2014quantum)]中提出时，QAOA为Max-Cut问题提供了比任何现有经典算法更好的近似比率，这些经典算法将在多项式时间内运行。我们说它是“提供”的，因为不久之后，这一主张被一篇论文[[11](ch030.xhtml#Xbarak2015beating)]所挑战，该论文提出了一种能够击败QAOA的经典算法。
- en: What can we say? Sometimes classics refuse to die!
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能说什么呢？有时候经典的东西是不愿意消亡的！
- en: The description of QAOA that we have discussed may seem a little bit abstract.
    But don’t worry. In the next subsection, we will make all of this much more concrete,
    because we will be studying in detail the quantum circuits that are needed to
    implement the parts of the algorithm that run on quantum computers.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所讨论的QAOA描述可能显得有些抽象。但不用担心。在下一个小节中，我们将使所有这些内容更加具体，因为我们将会详细研究实现量子计算机上运行的算法部分的量子电路。
- en: 5.1.3 Circuits for QAOA
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.1.3 QAOA电路
- en: As we have just seen, quantum computers are only used at certain steps in QAOA.
    And, in fact, those steps always involve the preparation of a state of the form
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们刚才看到的，量子计算机只在QAOA的某些步骤中使用。实际上，这些步骤总是涉及准备一种形式的状态
- en: '![\left| {\mathbf{\beta},\mathbf{\gamma}} \right\rangle = e^{i\beta_{p}H_{0}}e^{i\gamma_{p}H_{1}}\ldots
    e^{i\beta_{2}H_{0}}e^{i\gamma_{2}H_{1}}e^{i\beta_{1}H_{0}}e^{i\gamma_{1}H_{1}}\left|
    \psi_{0} \right\rangle,](img/file656.png "\left| {\mathbf{\beta},\mathbf{\gamma}}
    \right\rangle = e^{i\beta_{p}H_{0}}e^{i\gamma_{p}H_{1}}\ldots e^{i\beta_{2}H_{0}}e^{i\gamma_{2}H_{1}}e^{i\beta_{1}H_{0}}e^{i\gamma_{1}H_{1}}\left|
    \psi_{0} \right\rangle,")'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![左| {β,γ} > = e^{iβ_{p}H_{0}}e^{iγ_{p}H_{1}}...e^{iβ_{2}H_{0}}e^{iγ_{2}H_{1}}e^{iβ_{1}H_{0}}e^{iγ_{1}H_{1}}|ψ_{0}
    >](img/file656.png "|左| {β,γ} > = e^{iβ_{p}H_{0}}e^{iγ_{p}H_{1}}...e^{iβ_{2}H_{0}}e^{iγ_{2}H_{1}}e^{iβ_{1}H_{0}}e^{iγ_{1}H_{1}}|ψ_{0}
    >")'
- en: where ![\left| \psi_{0} \right\rangle](img/file631.png "\left| \psi_{0} \right\rangle")
    is the ground state of ![H_{0}](img/file545.png "H_{0}"). Of course, we need to
    prepare the state with adequate quantum gates on a quantum circuit, so let’s analyze
    the operations that we need to perform. A crucial observation is that the Hamiltonians
    ![H_{0}](img/file545.png "H_{0}") and ![H_{1}](img/file544.png "H_{1}") take a
    very specific form. As we studied in the previous chapter, ![H_{0}](img/file545.png
    "H_{0}") is usually taken to be ![- {\sum}_{j = 0}^{n - 1}X_{j}](img/file657.png
    "- {\sum}_{j = 0}^{n - 1}X_{j}"), while ![H_{1}](img/file544.png "H_{1}") is an
    Ising Hamiltonian of the form
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 其中![左| ψ_{0} >](img/file631.png "![左| ψ_{0} >"])是![H_{0}](img/file545.png "![H_{0}]")的基态。当然，我们需要在量子电路中准备足够的状态，因此让我们分析我们需要执行的操作。一个关键的观察是，哈密顿量![H_{0}](img/file545.png
    "![H_{0}}")和![H_{1}](img/file544.png "![H_{1}}")具有一个非常特定的形式。正如我们在上一章所研究的，![H_{0}](img/file545.png
    "![H_{0}}")通常被取为![- {\sum}_{j = 0}^{n - 1}X_{j}](img/file657.png "![- {\sum}_{j
    = 0}^{n - 1}X_{j}"])，而![H_{1}](img/file544.png "![H_{1}]")是一个形式为Ising哈密顿量的
- en: '![- \sum\limits_{j,k}J_{jk}Z_{j}Z_{k} - \sum\limits_{j}h_{j}Z_{j},](img/file554.png
    "- \sum\limits_{j,k}J_{jk}Z_{j}Z_{k} - \sum\limits_{j}h_{j}Z_{j},")'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![- \sum\limits_{j,k}J_{jk}Z_{j}Z_{k} - \sum\limits_{j}h_{j}Z_{j},](img/file554.png
    "- \sum\limits_{j,k}J_{jk}Z_{j}Z_{k} - \sum\limits_{j}h_{j}Z_{j},")'
- en: where the coefficients ![J_{jk}](img/file342.png "J_{jk}") and ![h_{j}](img/file343.png
    "h_{j}") are real numbers.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 其中系数 ![J_{jk}](img/file342.png "J_{jk}") 和 ![h_{j}](img/file343.png "h_{j}")
    是实数。
- en: 'The ground state of ![H_{0}](img/file545.png "H_{0}") is ![{\otimes}_{i = 0}^{n
    - 1}\left| + \right\rangle](img/file557.png "{\otimes}_{i = 0}^{n - 1}\left| +
    \right\rangle"), as you proved in *Exercise* * [*4.2*](ch012.xhtml#x1-77004x4.2).
    This state can be easily prepared: starting from ![\left| 0 \right\rangle](img/file6.png
    "\left| 0 \right\rangle"), you just need to use a Hadamard gate on each qubit
    of the circuit.*'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '![H_{0}](img/file545.png "H_{0}") 的基态是 ![{\otimes}_{i = 0}^{n - 1}\left| +
    \right\rangle](img/file557.png "{\otimes}_{i = 0}^{n - 1}\left| + \right\rangle")，正如你在
    *练习* * [*4.2*](ch012.xhtml#x1-77004x4.2) 中所证明的那样。这个状态可以很容易地制备：从 ![\left| 0 \right\rangle](img/file6.png
    "\left| 0 \right\rangle") 开始，你只需要在每个量子比特上使用一个哈达玛门（Hadamard gate）。'
- en: '*That was easy, so let’s now focus on the operations of the form ![e^{i\beta_{k}H_{0}}](img/file658.png
    "e^{i\beta_{k}H_{0}}"), with ![\beta_{j}](img/file659.png "\beta_{j}") a real
    number. Notice that ![H_{0} = - {\sum}_{j = 0}^{n - 1}X_{j}](img/file555.png "H_{0}
    = - {\sum}_{j = 0}^{n - 1}X_{j}") and that all the ![X_{j}](img/file556.png "X_{j}")
    matrices commute with each other, so we can replace the exponential of the sum
    with the product of the exponentials. Therefore, it holds that'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*这很简单，那么现在让我们专注于形式为 ![e^{i\beta_{k}H_{0}}](img/file658.png "e^{i\beta_{k}H_{0}}")
    的操作，其中 ![\beta_{j}](img/file659.png "\beta_{j}") 是一个实数。注意 ![H_{0} = - {\sum}_{j
    = 0}^{n - 1}X_{j}](img/file555.png "H_{0} = - {\sum}_{j = 0}^{n - 1}X_{j}") 并且所有
    ![X_{j}](img/file556.png "X_{j}") 矩阵彼此交换，因此我们可以用指数的乘积代替和的指数。因此，它成立'
- en: '![e^{i\beta_{k}H_{0}} = e^{- i\beta_{k}\sum\limits_{j = 0}^{n - 1}X_{j}} =
    \prod\limits_{j = 0}^{n - 1}e^{- i\beta_{k}X_{j}}.](img/file660.png "e^{i\beta_{k}H_{0}}
    = e^{- i\beta_{k}\sum\limits_{j = 0}^{n - 1}X_{j}} = \prod\limits_{j = 0}^{n -
    1}e^{- i\beta_{k}X_{j}}.")'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![e^{i\beta_{k}H_{0}} = e^{- i\beta_{k}\sum\limits_{j = 0}^{n - 1}X_{j}} =
    \prod\limits_{j = 0}^{n - 1}e^{- i\beta_{k}X_{j}}.](img/file660.png "e^{i\beta_{k}H_{0}}
    = e^{- i\beta_{k}\sum\limits_{j = 0}^{n - 1}X_{j}} = \prod\limits_{j = 0}^{n -
    1}e^{- i\beta_{k}X_{j}}.")'
- en: But ![e^{- i\beta X_{j}}](img/file661.png "e^{- i\beta X_{j}}") is the expression
    for the rotation gate ![R_{X}(2\beta)](img/file662.png "R_{X}(2\beta)"), so this
    means that we just need to apply this gate to each of the qubits in our circuit.
    Neat, isn’t it?
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 但是 ![e^{- i\beta X_{j}}](img/file661.png "e^{- i\beta X_{j}}") 是旋转门 ![R_{X}(2\beta)](img/file662.png
    "R_{X}(2\beta)") 的表达式，这意味着我们只需要将这个门应用到我们电路中的每个量子比特上。真不错，不是吗？
- en: The last type of operation that we need to translate into quantum gates is ![e^{i\gamma_{l}H_{1}}](img/file663.png
    "e^{i\gamma_{l}H_{1}}") for any real coefficient ![\gamma_{l}](img/file664.png
    "\gamma_{l}"). We know that ![H_{1}](img/file544.png "H_{1}") is a sum of terms
    of the form ![J_{jk}Z_{j}Z_{k}](img/file665.png "J_{jk}Z_{j}Z_{k}") and ![h_{j}Z_{j}](img/file666.png
    "h_{j}Z_{j}"). Again, these matrices commute with each other, so we get
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要转换成量子门的最后一种操作是任何实系数 ![\gamma_{l}](img/file664.png "\gamma_{l}") 的 ![e^{i\gamma_{l}H_{1}}](img/file663.png
    "e^{i\gamma_{l}H_{1}}")。我们知道 ![H_{1}](img/file544.png "H_{1}") 是形式为 ![J_{jk}Z_{j}Z_{k}](img/file665.png
    "J_{jk}Z_{j}Z_{k}") 和 ![h_{j}Z_{j}](img/file666.png "h_{j}Z_{j}") 的项的和。同样，这些矩阵彼此交换，所以我们得到
- en: '![e^{i\gamma_{l}H_{1}} = e^{- i\gamma_{l}(\sum\limits_{j,k}J_{jk}Z_{j}Z_{k}
    + \sum\limits_{j}h_{j}Z_{j})} = \prod\limits_{j,k}e^{- i\gamma_{l}J_{jk}Z_{j}Z_{k}}\prod\limits_{j}e^{-
    i\gamma_{l}h_{j}Z_{j}}.](img/file667.png "e^{i\gamma_{l}H_{1}} = e^{- i\gamma_{l}(\sum\limits_{j,k}J_{jk}Z_{j}Z_{k}
    + \sum\limits_{j}h_{j}Z_{j})} = \prod\limits_{j,k}e^{- i\gamma_{l}J_{jk}Z_{j}Z_{k}}\prod\limits_{j}e^{-
    i\gamma_{l}h_{j}Z_{j}}.")'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![e^{i\gamma_{l}H_{1}} = e^{- i\gamma_{l}(\sum\limits_{j,k}J_{jk}Z_{j}Z_{k}
    + \sum\limits_{j}h_{j}Z_{j})} = \prod\limits_{j,k}e^{- i\gamma_{l}J_{jk}Z_{j}Z_{k}}\prod\limits_{j}e^{-
    i\gamma_{l}h_{j}Z_{j}}.](img/file667.png "e^{i\gamma_{l}H_{1}} = e^{- i\gamma_{l}(\sum\limits_{j,k}J_{jk}Z_{j}Z_{k}
    + \sum\limits_{j}h_{j}Z_{j})} = \prod\limits_{j,k}e^{- i\gamma_{l}J_{jk}Z_{j}Z_{k}}\prod\limits_{j}e^{-
    i\gamma_{l}h_{j}Z_{j}}.")'
- en: Similar to the case of ![H_{0}](img/file545.png "H_{0}"), the operations of
    the form ![e^{- i\gamma_{l}h_{j}Z_{j}}](img/file668.png "e^{- i\gamma_{l}h_{j}Z_{j}}")
    can be carried out with rotation gates ![R_{Z}](img/file120.png "R_{Z}"). Thus,
    we only need to learn how to implement ![e^{- i\gamma_{l}J_{jk}Z_{j}Z_{k}}](img/file669.png
    "e^{- i\gamma_{l}J_{jk}Z_{j}Z_{k}}"). To keep things simple, let’s denote the
    real number ![\gamma_{l}J_{jk}](img/file670.png "\gamma_{l}J_{jk}") by ![a](img/file16.png
    "a"). Notice that ![e^{- iaZ_{j}Z_{k}}](img/file671.png "e^{- iaZ_{j}Z_{k}}")
    is the exponential of a diagonal matrix, because ![Z_{j}Z_{k}](img/file363.png
    "Z_{j}Z_{k}") is the tensor product of diagonal matrices. In fact, it holds that
    if ![\left| x \right\rangle](img/file267.png "\left| x \right\rangle") is a computational
    basis state in which qubits ![j](img/file258.png "j") and ![k](img/file317.png
    "k") have the same value, then
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 与![H_{0}](img/file545.png "H_{0}")的情况类似，形式为![e^{- i\gamma_{l}h_{j}Z_{j}}](img/file668.png
    "e^{- i\gamma_{l}h_{j}Z_{j}}")的操作可以使用旋转门![R_{Z}](img/file120.png "R_{Z}")执行。因此，我们只需要学习如何实现![e^{-
    i\gamma_{l}J_{jk}Z_{j}Z_{k}}](img/file669.png "e^{- i\gamma_{l}J_{jk}Z_{j}Z_{k}}")。为了简化问题，让我们用![a](img/file16.png
    "a")表示实数![\gamma_{l}J_{jk}](img/file670.png "\gamma_{l}J_{jk}")。请注意，![e^{- iaZ_{j}Z_{k}}](img/file671.png
    "e^{- iaZ_{j}Z_{k}}")是对角矩阵的指数，因为![Z_{j}Z_{k}](img/file363.png "Z_{j}Z_{k}")是对角矩阵的张量积。实际上，如果![\left|
    x \right\rangle](img/file267.png "\left| x \right\rangle")是计算基态，其中量子位![j](img/file258.png
    "j")和![k](img/file317.png "k")具有相同的值，那么
- en: '![e^{- iaZ_{j}Z_{k}}\left| x \right\rangle = e^{- ia}\left| x \right\rangle.](img/file672.png
    "e^{- iaZ_{j}Z_{k}}\left| x \right\rangle = e^{- ia}\left| x \right\rangle.")'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![e^{- iaZ_{j}Z_{k}}\left| x \right\rangle = e^{- ia}\left| x \right\rangle.](img/file672.png
    "e^{- iaZ_{j}Z_{k}}\left| x \right\rangle = e^{- ia}\left| x \right\rangle.")'
- en: On the other hand, if qubits ![j](img/file258.png "j") and ![k](img/file317.png
    "k") have different values, then
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果量子位![j](img/file258.png "j")和![k](img/file317.png "k")具有不同的值，那么
- en: '![e^{- iaZ_{j}Z_{k}}\left| x \right\rangle = e^{ia}\left| x \right\rangle.](img/file673.png
    "e^{- iaZ_{j}Z_{k}}\left| x \right\rangle = e^{ia}\left| x \right\rangle.")'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![e^{- iaZ_{j}Z_{k}}\left| x \right\rangle = e^{ia}\left| x \right\rangle.](img/file673.png
    "e^{- iaZ_{j}Z_{k}}\left| x \right\rangle = e^{ia}\left| x \right\rangle.")'
- en: This unitary action is implemented by the circuit in *Figure* *[*5.1*](#Figure5.1),
    where, for simplicity, we have only depicted qubits ![j](img/file258.png "j")
    and ![k](img/file317.png "k") — the action on the rest of the qubits would be
    the identity gate.*
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这种幺正操作通过*图* *[*5.1*](#Figure5.1)中的电路实现，其中，为了简单起见，我们只描绘了量子位![j](img/file258.png
    "j")和![k](img/file317.png "k") — 对其余量子位的作用将是恒等门。
- en: '*![Figure 5.1: Implementation of e^{- iaZ_{j}Z_{k}}](img/file674.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '*![图5.1：e^{- iaZ_{j}Z_{k}}的实现](img/file674.jpg)'
- en: '**Figure 5.1**: Implementation of ![e^{- iaZ_{j}Z_{k}}](img/file671.png "e^{-
    iaZ_{j}Z_{k}}")'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**图5.1**：![e^{- iaZ_{j}Z_{k}}](img/file671.png "e^{- iaZ_{j}Z_{k}}")的实现'
- en: We now have all the elements in place, so let’s illustrate them with an example.
    Imagine that the Ising Hamiltonian of your problem is ![3Z_{0}Z_{2} - Z_{1}Z_{2}
    + 2Z_{0}](img/file675.png "3Z_{0}Z_{2} - Z_{1}Z_{2} + 2Z_{0}"). Then, the circuit
    used by QAOA to prepare ![\left| {\mathbf{\beta},\mathbf{\gamma}} \right\rangle](img/file644.png
    "\left| {\mathbf{\beta},\mathbf{\gamma}} \right\rangle") with ![p = 1](img/file676.png
    "p = 1") is the one shown in *Figure* * [*5.2*](#Figure5.2).*
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经有了所有必要的元素，让我们用一个例子来说明它们。假设你问题的伊辛哈密顿量为![3Z_{0}Z_{2} - Z_{1}Z_{2} + 2Z_{0}](img/file675.png
    "3Z_{0}Z_{2} - Z_{1}Z_{2} + 2Z_{0}")。那么，QAOA用来准备![\left| {\mathbf{\beta},\mathbf{\gamma}}
    \right\rangle](img/file644.png "\left| {\mathbf{\beta},\mathbf{\gamma}} \right\rangle")且![p
    = 1](img/file676.png "p = 1")的电路如图*图* *[*5.2*](#Figure5.2)所示。
- en: '*![Figure 5.2: QAOA circuit with p = 1](img/file677.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*![图5.2：p = 1的QAOA电路](img/file677.jpg)'
- en: '**Figure 5.2**: QAOA circuit with ![p = 1](img/file676.png "p = 1")'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**图5.2**：![p = 1](img/file676.png "p = 1")的QAOA电路'
- en: Notice how we first prepare the ground state of ![H_{0}](img/file545.png "H_{0}")
    with a column of Hadamard gates. Then, we have the implementation of ![e^{- i3\gamma_{1}Z_{0}Z_{2}}](img/file678.png
    "e^{- i3\gamma_{1}Z_{0}Z_{2}}") with a CNOT gate between qubits ![0](img/file12.png
    "0") and ![2](img/file302.png "2"), an ![R_{Z}](img/file120.png "R_{Z}") gate
    on qubit ![2](img/file302.png "2"), and another CNOT gate between qubits ![0](img/file12.png
    "0") and ![2](img/file302.png "2"). The implementation of ![e^{i\gamma_{1}Z_{1}Z_{2}}](img/file679.png
    "e^{i\gamma_{1}Z_{1}Z_{2}}") is similar, but on qubits ![1](img/file13.png "1")
    and ![2](img/file302.png "2"). Then, we use an ![R_{Z}](img/file120.png "R_{Z}")
    gate on qubit ![0](img/file12.png "0") to implement ![e^{- i2\gamma_{1}Z_{0}}](img/file680.png
    "e^{- i2\gamma_{1}Z_{0}}"). Finally, a column of ![R_{X}](img/file118.png "R_{X}")
    gates implements ![e^{- i\beta_{1}{\sum}_{j}X_{j}}](img/file681.png "e^{- i\beta_{1}{\sum}_{j}X_{j}}").
    If we increased the number of **layers** ![p](img/file141.png "p"), the circuit
    would grow by repeating for another ![p - 1](img/file682.png "p - 1") times the
    very same circuit structure shown in *Figure* * [*5.2*](#Figure5.2) except for
    the initial Hadamard gates. Additionally, we would have to replace the parameters
    ![\gamma_{1}](img/file683.png "\gamma_{1}") and ![\beta_{1}](img/file684.png "\beta_{1}")
    by ![\gamma_{2}](img/file685.png "\gamma_{2}") and ![\beta_{2}](img/file686.png
    "\beta_{2}") in the second layer, by ![\gamma_{3}](img/file687.png "\gamma_{3}")
    and ![\beta_{3}](img/file688.png "\beta_{3}") in the third, and so on and so forth.*
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们首先使用一系列 Hadamard 门准备 ![H_{0}](img/file545.png "H_{0}") 的基态。然后，我们通过在量子位 ![0](img/file12.png
    "0") 和 ![2](img/file302.png "2") 之间使用 CNOT 门，在量子位 ![2](img/file302.png "2") 上使用
    ![R_{Z}](img/file120.png "R_{Z}") 门，以及在量子位 ![0](img/file12.png "0") 和 ![2](img/file302.png
    "2") 之间再次使用 CNOT 门来实现 ![e^{- i3\gamma_{1}Z_{0}Z_{2}}](img/file678.png "e^{- i3\gamma_{1}Z_{0}Z_{2}}")。![e^{i\gamma_{1}Z_{1}Z_{2}}](img/file679.png
    "e^{i\gamma_{1}Z_{1}Z_{2}}") 的实现类似，但是在量子位 ![1](img/file13.png "1") 和 ![2](img/file302.png
    "2") 上。然后，我们在量子位 ![0](img/file12.png "0") 上使用 ![R_{Z}](img/file120.png "R_{Z}")
    门来实现 ![e^{- i2\gamma_{1}Z_{0}}](img/file680.png "e^{- i2\gamma_{1}Z_{0}}")。最后，一列
    ![R_{X}](img/file118.png "R_{X}") 门实现了 ![e^{- i\beta_{1}{\sum}_{j}X_{j}}](img/file681.png
    "e^{- i\beta_{1}{\sum}_{j}X_{j}}")。如果我们增加了 **层** ![p](img/file141.png "p") 的数量，电路将通过重复
    *图* * [*5.2*](#Figure5.2) 中显示的相同电路结构（除了初始的 Hadamard 门）来增长。此外，我们还需要在第二层将参数 ![\gamma_{1}](img/file683.png
    "\gamma_{1}") 和 ![\beta_{1}](img/file684.png "\beta_{1}") 替换为 ![\gamma_{2}](img/file685.png
    "\gamma_{2}") 和 ![\beta_{2}](img/file686.png "\beta_{2}")，在第三层替换为 ![\gamma_{3}](img/file687.png
    "\gamma_{3}") 和 ![\beta_{3}](img/file688.png "\beta_{3}")，依此类推。*
- en: '*Exercise 5.1'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '*练习 5.1'
- en: Obtain the QAOA circuit for ![Z_{1}Z_{3} + Z_{0}Z_{2} - 2Z_{1} + 3Z_{2}](img/file689.png
    "Z_{1}Z_{3} + Z_{0}Z_{2} - 2Z_{1} + 3Z_{2}") with ![p = 1](img/file676.png "p
    = 1").
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 获取 ![Z_{1}Z_{3} + Z_{0}Z_{2} - 2Z_{1} + 3Z_{2}](img/file689.png "Z_{1}Z_{3}
    + Z_{0}Z_{2} - 2Z_{1} + 3Z_{2}") 的 QAOA 电路，其中 ![p = 1](img/file676.png "p = 1")。
- en: Now that we know all the circuits that we need for QAOA, let’s study how to
    use them in order to estimate the energy of the states ![\left| {\mathbf{\beta},\mathbf{\gamma}}
    \right\rangle](img/file644.png "\left| {\mathbf{\beta},\mathbf{\gamma}} \right\rangle").
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了 QAOA 所需的所有电路，让我们研究如何使用它们来估算状态 ![\left| {\mathbf{\beta},\mathbf{\gamma}}
    \right\rangle](img/file644.png "\left| {\mathbf{\beta},\mathbf{\gamma}} \right\rangle")
    的能量。
- en: 5.1.4 Estimating the energy
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.1.4 估算能量
- en: The circuits that we have just studied allow us to prepare any state of the
    form ![\left| {\mathbf{\beta},\mathbf{\gamma}} \right\rangle](img/file644.png
    "\left| {\mathbf{\beta},\mathbf{\gamma}} \right\rangle"). But we are not interested
    in the states themselves. What we need is their energy with respect to ![H_{1}](img/file544.png
    "H_{1}"), because that is the quantity that we want to minimize. That is, we need
    to evaluate ![\left\langle {\mathbf{\beta},\mathbf{\gamma}} \right|H_{1}\left|
    {\mathbf{\beta},\mathbf{\gamma}} \right\rangle](img/file647.png "\left\langle
    {\mathbf{\beta},\mathbf{\gamma}} \right|H_{1}\left| {\mathbf{\beta},\mathbf{\gamma}}
    \right\rangle"), but, of course, we don’t have access to the state vector because
    we are preparing the state with a quantum computer. So, what can we do?
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚研究的电路使我们能够准备任何形式为 ![\left| {\mathbf{\beta},\mathbf{\gamma}} \right\rangle](img/file644.png
    "\left| {\mathbf{\beta},\mathbf{\gamma}} \right\rangle") 的状态。但我们并不对状态本身感兴趣。我们需要的是它们相对于
    ![H_{1}](img/file544.png "H_{1}") 的能量，因为这是我们想要最小化的量。也就是说，我们需要评估 ![\left\langle
    {\mathbf{\beta},\mathbf{\gamma}} \right|H_{1}\left| {\mathbf{\beta},\mathbf{\gamma}}
    \right\rangle](img/file647.png "\left\langle {\mathbf{\beta},\mathbf{\gamma}}
    \right|H_{1}\left| {\mathbf{\beta},\mathbf{\gamma}} \right\rangle")，但当然，我们无法访问状态向量，因为我们正在使用量子计算机来准备状态。那么，我们能做什么呢？
- en: The key observation here is that we already know how to evaluate efficiently
    ![\left\langle x \right|H_{1}\left| x \right\rangle](img/file690.png "\left\langle
    x \right|H_{1}\left| x \right\rangle") for any basis state ![\left| x \right\rangle](img/file267.png
    "\left| x \right\rangle"). In fact, ![\left\langle x \right|H_{1}\left| x \right\rangle](img/file690.png
    "\left\langle x \right|H_{1}\left| x \right\rangle") is the value of ![x](img/file269.png
    "x") in the cost function of our combinatorial optimization problem, because we
    derived ![H_{1}](img/file544.png "H_{1}") from it. So, for instance, if we are
    trying to solve a Max-Cut problem, each ![\left| x \right\rangle](img/file267.png
    "\left| x \right\rangle") represents a cut and we can easily compute — with a
    classical computer — the cost of that cut, as we did in *Section* * [*3.1.2*](ch011.xhtml#x1-620003.1.2).*
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这里关键观察点是，我们已知如何高效地评估任何基态![\left\langle x \right|H_{1}\left| x \right\rangle](img/file690.png
    "\left\langle x \right|H_{1}\left| x \right\rangle")。实际上，![\left\langle x \right|H_{1}\left|
    x \right\rangle](img/file690.png "\left\langle x \right|H_{1}\left| x \right\rangle")是组合优化问题代价函数中![x](img/file269.png
    "x")的值，因为我们正是从它推导出![H_{1}](img/file544.png "H_{1}")的。因此，例如，如果我们试图解决最大切割问题，每个![\left|
    x \right\rangle](img/file267.png "\left| x \right\rangle")代表一个切割，我们可以很容易地——使用经典计算机——计算出这个切割的成本，就像我们在*第3.1.2节*（[ch011.xhtml#x1-620003.1.2](ch011.xhtml#x1-620003.1.2)）中所做的那样。
- en: '*What is more, we can also evaluate ![\left\langle x \right|H_{1}\left| x \right\rangle](img/file690.png
    "\left\langle x \right|H_{1}\left| x \right\rangle") directly from the expression
    of the Hamiltonian. We only need to notice that ![\left\langle x \right|Z_{j}\left|
    x \right\rangle = 1](img/file691.png "\left\langle x \right|Z_{j}\left| x \right\rangle
    = 1") if the ![j](img/file258.png "j")-th bit of ![x](img/file269.png "x") is
    ![0](img/file12.png "0") and that ![\left\langle x \right|Z_{j}\left| x \right\rangle
    = - 1](img/file692.png "\left\langle x \right|Z_{j}\left| x \right\rangle = -
    1") otherwise. In a similar way, ![\left\langle x \right|Z_{j}Z_{k}\left| x \right\rangle
    = 1](img/file693.png "\left\langle x \right|Z_{j}Z_{k}\left| x \right\rangle =
    1") if the ![j](img/file258.png "j")-th and ![k](img/file317.png "k")-th bits
    of ![x](img/file269.png "x") are equal and ![\left\langle x \right|Z_{j}Z_{k}\left|
    x \right\rangle = - 1](img/file694.png "\left\langle x \right|Z_{j}Z_{k}\left|
    x \right\rangle = - 1") if they are different.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*更重要的是，我们还可以直接从哈密顿量的表达式中评估![\left\langle x \right|H_{1}\left| x \right\rangle](img/file690.png
    "\left\langle x \right|H_{1}\left| x \right\rangle")。我们只需要注意到，如果![x](img/file269.png
    "x")的第![j](img/file258.png "j")位是![0](img/file12.png "0")，则![\left\langle x \right|Z_{j}\left|
    x \right\rangle = 1](img/file691.png "\left\langle x \right|Z_{j}\left| x \right\rangle
    = 1")；否则，![\left\langle x \right|Z_{j}\left| x \right\rangle = - 1](img/file692.png
    "\left\langle x \right|Z_{j}\left| x \right\rangle = - 1")。以类似的方式，如果![x](img/file269.png
    "x")的第![j](img/file258.png "j")位和第![k](img/file317.png "k")位相等，则![\left\langle
    x \right|Z_{j}Z_{k}\left| x \right\rangle = 1](img/file693.png "\left\langle x
    \right|Z_{j}Z_{k}\left| x \right\rangle = 1")；如果它们不相等，则![\left\langle x \right|Z_{j}Z_{k}\left|
    x \right\rangle = - 1](img/file694.png "\left\langle x \right|Z_{j}Z_{k}\left|
    x \right\rangle = - 1")。'
- en: Then, by linearity, we can easily evaluate ![\left\langle x \right|H_{1}\left|
    x \right\rangle](img/file690.png "\left\langle x \right|H_{1}\left| x \right\rangle").
    For instance, if ![H_{1} = 3Z_{0}Z_{2} - Z_{1}Z_{2} + 2Z_{0}](img/file695.png
    "H_{1} = 3Z_{0}Z_{2} - Z_{1}Z_{2} + 2Z_{0}"), we will have
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过线性关系，我们可以轻松地评估![\left\langle x \right|H_{1}\left| x \right\rangle](img/file690.png
    "\left\langle x \right|H_{1}\left| x \right\rangle")。例如，如果![H_{1} = 3Z_{0}Z_{2}
    - Z_{1}Z_{2} + 2Z_{0}](img/file695.png "H_{1} = 3Z_{0}Z_{2} - Z_{1}Z_{2} + 2Z_{0}"),
    我们将得到
- en: '![\left\langle {101} \right|H_{1}\left| {101} \right\rangle = 3\left\langle
    {101} \right|Z_{0}Z_{2}\left| {101} \right\rangle - \left\langle {101} \right|Z_{1}Z_{2}\left|
    {101} \right\rangle + 2\left\langle {101} \right|Z_{0}\left| {101} \right\rangle
    = 3 + 1 - 2 = 4.](img/file696.png "\left\langle {101} \right|H_{1}\left| {101}
    \right\rangle = 3\left\langle {101} \right|Z_{0}Z_{2}\left| {101} \right\rangle
    - \left\langle {101} \right|Z_{1}Z_{2}\left| {101} \right\rangle + 2\left\langle
    {101} \right|Z_{0}\left| {101} \right\rangle = 3 + 1 - 2 = 4.")'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![\left\langle {101} \right|H_{1}\left| {101} \right\rangle = 3\left\langle
    {101} \right|Z_{0}Z_{2}\left| {101} \right\rangle - \left\langle {101} \right|Z_{1}Z_{2}\left|
    {101} \right\rangle + 2\left\langle {101} \right|Z_{0}\left| {101} \right\rangle
    = 3 + 1 - 2 = 4.](img/file696.png "\left\langle {101} \right|H_{1}\left| {101}
    \right\rangle = 3\left\langle {101} \right|Z_{0}Z_{2}\left| {101} \right\rangle
    - \left\langle {101} \right|Z_{1}Z_{2}\left| {101} \right\rangle + 2\left\langle
    {101} \right|Z_{0}\left| {101} \right\rangle = 3 + 1 - 2 = 4.")'
- en: Exercise 5.2
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 练习5.2
- en: Evaluate ![\left\langle {100} \right|H_{1}\left| {100} \right\rangle](img/file697.png
    "\left\langle {100} \right|H_{1}\left| {100} \right\rangle") with ![H_{1} = 3Z_{0}Z_{2}
    - Z_{1}Z_{2} + 2Z_{0}](img/file695.png "H_{1} = 3Z_{0}Z_{2} - Z_{1}Z_{2} + 2Z_{0}").
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 评估 ![leftlangle {100} right|H_{1}left| {100} rightrangle](img/file697.png "leftlangle
    {100} right|H_{1}left| {100} rightrangle")，其中 ![H_{1} = 3Z_{0}Z_{2} - Z_{1}Z_{2}
    + 2Z_{0}](img/file695.png "H_{1} = 3Z_{0}Z_{2} - Z_{1}Z_{2} + 2Z_{0}").
- en: We also know that we can always write ![\left| {\mathbf{\beta},\mathbf{\gamma}}
    \right\rangle](img/file644.png "\left| {\mathbf{\beta},\mathbf{\gamma}} \right\rangle")
    as a linear combination of basis states. Namely, we have
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还知道，我们总是可以将 ![left| {β,γ} rightrangle](img/file644.png "left| {β,γ} rightrangle")
    写作基态的线性组合。也就是说，我们有
- en: '![\left| {\mathbf{\beta},\mathbf{\gamma}} \right\rangle = \sum\limits_{x}a_{x}\left|
    x \right\rangle](img/file698.png "\left| {\mathbf{\beta},\mathbf{\gamma}} \right\rangle
    = \sum\limits_{x}a_{x}\left| x \right\rangle")'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![left| {β,γ} rightrangle = sumlimits_{x}a_{x}left| x rightrangle](img/file698.png
    "left| {β,γ} rightrangle = sumlimits_{x}a_{x}left| x rightrangle")'
- en: for certain amplitudes ![a_{x}](img/file699.png "a_{x}") such that ![{\sum}_{x}\left|
    a_{x} \right|^{2} = 1](img/file371.png "{\sum}_{x}\left| a_{x} \right|^{2} = 1").
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些振幅 ![a_{x}](img/file699.png "a_{x}") 使得 ![sum_{x}|a_{x}|^{2} = 1](img/file371.png
    "sum_{x}|a_{x}|^{2} = 1").
- en: But then it holds that
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 但此时成立
- en: '![\left\langle {\mathbf{\beta},\mathbf{\gamma}} \right|H_{1}\left| {\mathbf{\beta},\mathbf{\gamma}}
    \right\rangle = \left( {\sum\limits_{y}a_{y}^{\ast}\left\langle y \right|} \right)H_{1}\left(
    {\sum\limits_{x}a_{x}\left| x \right\rangle} \right) = \sum\limits_{y}\sum\limits_{x}a_{y}^{\ast}a_{x}\left\langle
    y \right|H_{1}\left| x \right\rangle = \sum\limits_{x}\left| a_{x} \right|^{2}\left\langle
    x \right|H_{1}\left| x \right\rangle,](img/file700.png "\left\langle {\mathbf{\beta},\mathbf{\gamma}}
    \right|H_{1}\left| {\mathbf{\beta},\mathbf{\gamma}} \right\rangle = \left( {\sum\limits_{y}a_{y}^{\ast}\left\langle
    y \right|} \right)H_{1}\left( {\sum\limits_{x}a_{x}\left| x \right\rangle} \right)
    = \sum\limits_{y}\sum\limits_{x}a_{y}^{\ast}a_{x}\left\langle y \right|H_{1}\left|
    x \right\rangle = \sum\limits_{x}\left| a_{x} \right|^{2}\left\langle x \right|H_{1}\left|
    x \right\rangle,")'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![左langle {β,γ} right|H_{1}left| {β,γ} rightrangle = (sumlimits_{y}a_{y}^{*}leftlangle
    y right|)H_{1}(sumlimits_{x}a_{x}left| x rightrangle) = sumlimits_{y}sumlimits_{x}a_{y}^{*}a_{x}leftlangle
    y right|H_{1}left| x rightrangle = sumlimits_{x}|a_{x}|^{2}leftlangle x right|H_{1}left|
    x rightrangle,](img/file700.png "左langle {β,γ} right|H_{1}left| {β,γ} rightrangle
    = (sumlimits_{y}a_{y}^{*}leftlangle y right|)H_{1}(sumlimits_{x}a_{x}left| x rightrangle)
    = sumlimits_{y}sumlimits_{x}a_{y}^{*}a_{x}leftlangle y right|H_{1}left| x rightrangle
    = sumlimits_{x}|a_{x}|^{2}leftlangle x right|H_{1}left| x rightrangle,")'
- en: because ![H_{1}\left| x \right\rangle](img/file701.png "H_{1}\left| x \right\rangle")
    is always a multiple of ![\left| x \right\rangle](img/file267.png "\left| x \right\rangle")
    (just notice that ![H_{1}](img/file544.png "H_{1}") is a diagonal matrix because
    it is a sum of diagonal matrices), because ![\left\langle y \middle| x \right\rangle
    = 0](img/file366.png "\left\langle y \middle| x \right\rangle = 0") when ![y \neq
    x](img/file702.png "y \neq x"), and because ![a_{x}^{\ast}a_{x} = \left| a_{x}
    \right|^{2}](img/file369.png "a_{x}^{\ast}a_{x} = \left| a_{x} \right|^{2}").
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 ![H_{1}left| x rightrangle](img/file701.png "H_{1}left| x rightrangle") 总是
    ![left| x rightrangle](img/file267.png "left| x rightrangle") 的倍数（只需注意 ![H_{1}](img/file544.png
    "H_{1}") 是对角矩阵，因为它是对角矩阵之和），因为当 ![y ≠ x](img/file702.png "y ≠ x") 时 ![leftlangle
    y | x rightrangle = 0](img/file366.png "leftlangle y | x rightrangle = 0")，以及因为
    ![a_{x}^{*}a_{x} = |a_{x}|^{2}](img/file369.png "a_{x}^{*}a_{x} = |a_{x}|^{2}").
- en: Now, since we can compute ![\left\langle x \right|H_{1}\left| x \right\rangle](img/file690.png
    "\left\langle x \right|H_{1}\left| x \right\rangle") easily with the classical
    computer, we have reduced our problem to computing the values ![\left| a_{x} \right|^{2}](img/file372.png
    "\left| a_{x} \right|^{2}"). But ![\left| a_{x} \right|^{2}](img/file372.png "\left|
    a_{x} \right|^{2}") is the probability of measuring ![\left| x \right\rangle](img/file267.png
    "\left| x \right\rangle") when the state ![\left| {\mathbf{\beta},\mathbf{\gamma}}
    \right\rangle](img/file644.png "\left| {\mathbf{\beta},\mathbf{\gamma}} \right\rangle")
    is prepared — this is the reason why, back in *Chapter* * [*3*](ch011.xhtml#x1-590003),
    *Working with Quadratic* *Unconstrained Binary Optimization Problems*, we referred
    to expressions of the form ![\left\langle \psi \right|H_{1}\left| \psi \right\rangle](img/file703.png
    "\left\langle \psi \right|H_{1}\left| \psi \right\rangle") as expectation values;
    they are indeed the expected or average energy under ![H_{1}](img/file544.png
    "H_{1}") when we measure the state ![\left| \psi \right\rangle](img/file43.png
    "\left| \psi \right\rangle")!*
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，由于我们可以轻松地使用经典计算机计算![\left\langle x \right|H_{1}\left| x \right\rangle](img/file690.png
    "\left\langle x \right|H_{1}\left| x \right\rangle")，我们已经将问题简化为计算![\left| a_{x}
    \right|^{2}](img/file372.png "\left| a_{x} \right|^{2}")的值。但![\left| a_{x} \right|^{2}](img/file372.png
    "\left| a_{x} \right|^{2}")是当状态![\left| {\mathbf{\beta},\mathbf{\gamma}} \right\rangle](img/file644.png
    "\left| {\mathbf{\beta},\mathbf{\gamma}} \right\rangle")被准备时测量![\left| x \right\rangle](img/file267.png
    "\left| x \right\rangle")的概率——这就是为什么，在*第* * [*3*](ch011.xhtml#x1-590003)，*与二次无约束二进制优化问题一起工作*
    *中，我们称形式为![\left\langle \psi \right|H_{1}\left| \psi \right\rangle](img/file703.png
    "\left\langle \psi \right|H_{1}\left| \psi \right\rangle")的表达式为期望值；它们确实是在测量状态![\left|
    \psi \right\rangle](img/file43.png "\left| \psi \right\rangle")!时![H_{1}](img/file544.png
    "H_{1}")的期望或平均能量；*
- en: '*From this observation, it follows that we can use the quantum computer to
    prepare ![\left| {\mathbf{\beta},\mathbf{\gamma}} \right\rangle](img/file644.png
    "\left| {\mathbf{\beta},\mathbf{\gamma}} \right\rangle") and measure it ![M](img/file704.png
    "M") times to make the estimation'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '*从这个观察结果可以得出，我们可以使用量子计算机来准备![\left| {\mathbf{\beta},\mathbf{\gamma}} \right\rangle](img/file644.png
    "\left| {\mathbf{\beta},\mathbf{\gamma}} \right\rangle")并测量它![M](img/file704.png
    "M")次，以进行估计'
- en: '![\left\langle {\mathbf{\beta},\mathbf{\gamma}} \right|H_{1}\left| {\mathbf{\beta},\mathbf{\gamma}}
    \right\rangle \approx \sum\limits_{x}\frac{m_{x}}{M}\left\langle x \right|H_{1}\left|
    x \right\rangle,](img/file705.png "\left\langle {\mathbf{\beta},\mathbf{\gamma}}
    \right|H_{1}\left| {\mathbf{\beta},\mathbf{\gamma}} \right\rangle \approx \sum\limits_{x}\frac{m_{x}}{M}\left\langle
    x \right|H_{1}\left| x \right\rangle,")'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![\left\langle {\mathbf{\beta},\mathbf{\gamma}} \right|H_{1}\left| {\mathbf{\beta},\mathbf{\gamma}}
    \right\rangle \approx \sum\limits_{x}\frac{m_{x}}{M}\left\langle x \right|H_{1}\left|
    x \right\rangle,](img/file705.png "\left\langle {\mathbf{\beta},\mathbf{\gamma}}
    \right|H_{1}\left| {\mathbf{\beta},\mathbf{\gamma}} \right\rangle \approx \sum\limits_{x}\frac{m_{x}}{M}\left\langle
    x \right|H_{1}\left| x \right\rangle,")'
- en: where ![m_{x}](img/file706.png "m_{x}") is the number of times that ![x](img/file269.png
    "x") was measured. Of course, the higher the value of ![M](img/file704.png "M"),
    the better this approximation will be.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 其中![m_{x}](img/file706.png "m_{x}")是![x](img/file269.png "x")被测量的次数。当然，![M](img/file704.png
    "M")的值越高，这个近似就越好。
- en: Important note
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: In the process of estimating the energies of all the different states prepared
    with quantum computers, we will compute the cost, for our optimization problem,
    of many binary strings ![x](img/file269.png "x"). Of course, it would be wise
    for us to always keep the best ![x](img/file269.png "x") seen during the optimization
    process. Occasionally, it might be even better than the ones we obtain when measuring
    the final state ![\left| {\mathbf{\beta}^{\ast},\mathbf{\gamma}^{\ast}} \right\rangle](img/file707.png
    "\left| {\mathbf{\beta}^{\ast},\mathbf{\gamma}^{\ast}} \right\rangle").
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用量子计算机估计所有不同状态的能量过程中，我们将计算优化问题中许多二进制字符串![x](img/file269.png "x")的成本。当然，在优化过程中始终保留所见到的最佳![x](img/file269.png
    "x")是明智的。偶尔，它甚至可能比我们在测量最终状态![\left| {\mathbf{\beta}^{\ast},\mathbf{\gamma}^{\ast}}
    \right\rangle](img/file707.png "\left| {\mathbf{\beta}^{\ast},\mathbf{\gamma}^{\ast}}
    \right\rangle")时获得的结果更好。
- en: We’ve now covered all that we needed to know about the inner workings of QAOA.
    Before we move on to show how to implement and use this algorithm with Qiskit
    and PennyLane, we will introduce a little perk that we get from the fact that
    we are no longer using quantum annealers, but universal quantum computers instead.
    This will help us in formulating some problems in a more natural way, as we will
    show in the next subsection.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经了解了关于QAOA内部工作原理所需的所有知识。在我们继续展示如何使用Qiskit和PennyLane实现和使用此算法之前，我们将介绍一个好处，那就是我们不再使用量子退火器，而是使用通用量子计算机。这将帮助我们以更自然的方式提出一些问题，正如我们将在下一小节中展示的那样。
- en: 5.1.5 QUBO and HOBO
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.1.5 QUBO和HOBO
- en: Up to this point, we have only considered problems that can be written under
    the QUBO formalism. That is, minimization problems in which the cost function
    is a quadratic polynomial on binary variables that had no constraints on the values
    they could take. This is less restricting than it may seem, because QUBO is ![NP](img/file2.png
    "NP")-hard and there are many important problems that we can rewrite via reductions,
    as we saw in *Section* * [*3.4*](ch011.xhtml#x1-680003.4).*
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只考虑了可以用QUBO形式表示的问题。也就是说，成本函数是二进制变量的二次多项式，对这些变量可以取的值没有任何约束。这比看起来要宽松，因为QUBO是![NP](img/file2.png
    "NP")-难问题，而且有许多重要的问题我们可以通过约简来重写，正如我们在*第3.4节*中看到的。
- en: '*However, consider a problem like the famous **satisfiability** or **SAT**.
    In it, we are given a Boolean formula on binary variables and we have to determine
    whether there is any assignment of values that makes the formula true. For example,
    we may receive'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '*然而，考虑一个像著名的**可满足性**或**SAT**这样的问题。在其中，我们被给出一个关于二进制变量的布尔公式，我们必须确定是否存在任何赋值可以使公式为真。例如，我们可能会收到'
- en: '![(x_{0} \vee \neg x_{1} \vee x_{2}) \land (\neg x_{0} \vee x_{1} \vee \neg
    x_{2}) \land (x_{0} \vee x_{1} \vee x_{2}),](img/file708.png "(x_{0} \vee \neg
    x_{1} \vee x_{2}) \land (\neg x_{0} \vee x_{1} \vee \neg x_{2}) \land (x_{0} \vee
    x_{1} \vee x_{2}),")'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![(x_{0} \vee \neg x_{1} \vee x_{2}) \land (\neg x_{0} \vee x_{1} \vee \neg
    x_{2}) \land (x_{0} \vee x_{1} \vee x_{2}),](img/file708.png "(x_{0} \vee \neg
    x_{1} \vee x_{2}) \land (\neg x_{0} \vee x_{1} \vee \neg x_{2}) \land (x_{0} \vee
    x_{1} \vee x_{2}),")'
- en: which is **satisfiable** (by assigning *true* to all the variables, for instance).
    Or we can be given
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这在赋值所有变量为*true*的情况下是**可满足的**）。或者我们可以被给出
- en: '![x_{0} \land \neg x_{0},](img/file709.png "x_{0} \land \neg x_{0},")'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![x_{0} \land \neg x_{0},](img/file709.png "x_{0} \land \neg x_{0},")'
- en: which is clearly **unsatisfiable**.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这显然是**不可满足的**。
- en: SAT is easily seen to be in ![NP](img/file2.png "NP") (and, in fact, it is ![NP](img/file2.png
    "NP")-complete — see *Section 7.4* in Sipser’s book [[90](ch030.xhtml#Xsipser2012introduction)]).
    Then, we know that there must be a way of rewriting any SAT instance in the QUBO
    formalism. But the task becomes much easier if we relax the conditions in the
    QUBO formulation by allowing binary polynomials of *any order*. Let’s see why!
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易看出SAT属于![NP](img/file2.png "NP")（实际上，它是![NP](img/file2.png "NP")-完全的——参见Sipser的书中*第7.4节*
    [[90](ch030.xhtml#Xsipser2012introduction)]）。那么，我们知道必须有一种方法可以将任何SAT实例重写为QUBO形式。但如果我们通过允许任何阶的二进制多项式来放宽QUBO公式的条件，这项任务就会变得容易得多。让我们看看为什么！
- en: Let us consider, for the sake of an example, the formula ![(x_{0} \vee \neg
    x_{1} \vee x_{2}) \land (\neg x_{0} \vee x_{1} \vee \neg x_{2}) \land (x_{0} \vee
    x_{1} \vee x_{2})](img/file710.png "(x_{0} \vee \neg x_{1} \vee x_{2}) \land (\neg
    x_{0} \vee x_{1} \vee \neg x_{2}) \land (x_{0} \vee x_{1} \vee x_{2})"). We’ll
    show how it can be represented as the polynomial
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 为了举例说明，让我们考虑公式 ![(x_{0} \vee \neg x_{1} \vee x_{2}) \land (\neg x_{0} \vee x_{1}
    \vee \neg x_{2}) \land (x_{0} \vee x_{1} \vee x_{2})](img/file710.png "(x_{0}
    \vee \neg x_{1} \vee x_{2}) \land (\neg x_{0} \vee x_{1} \vee \neg x_{2}) \land
    (x_{0} \vee x_{1} \vee x_{2})")。我们将展示它如何表示为多项式
- en: '![p(x_{0},x_{1},x_{2}) = (1 - x_{0})x_{1}(1 - x_{2}) + x_{0}(1 - x_{1})x_{2}
    + (1 - x_{0})(1 - x_{1})(1 - x_{2}),](img/file711.png "p(x_{0},x_{1},x_{2}) =
    (1 - x_{0})x_{1}(1 - x_{2}) + x_{0}(1 - x_{1})x_{2} + (1 - x_{0})(1 - x_{1})(1
    - x_{2}),")'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![p(x_{0},x_{1},x_{2}) = (1 - x_{0})x_{1}(1 - x_{2}) + x_{0}(1 - x_{1})x_{2}
    + (1 - x_{0})(1 - x_{1})(1 - x_{2}),](img/file711.png "p(x_{0},x_{1},x_{2}) =
    (1 - x_{0})x_{1}(1 - x_{2}) + x_{0}(1 - x_{1})x_{2} + (1 - x_{0})(1 - x_{1})(1
    - x_{2}),")'
- en: on the binary variables ![x_{0}](img/file443.png "x_{0}"), ![x_{1}](img/file712.png
    "x_{1}"), and ![x_{2}](img/file444.png "x_{2}"). Let’s say that we consider some
    assignment of truth values for the variables in the original formula, and we set
    ![x_{i} = 1](img/file713.png "x_{i} = 1") in the polynomial if ![x_{i}](img/file714.png
    "x_{i}") is true and ![x_{i} = 0](img/file715.png "x_{i} = 0") if ![x_{i}](img/file714.png
    "x_{i}") is false. It’s easy to see that the original formula will be true under
    this assignment if and only if ![p(x_{0},x_{1},x_{2}) = 0](img/file716.png "p(x_{0},x_{1},x_{2})
    = 0"), and that it will be false if and only if ![p(x_{0},x_{1},x_{2}) > 0](img/file717.png
    "p(x_{0},x_{1},x_{2}) > 0"). Thus, if the polynomial ![p](img/file141.png "p")
    is ![0](img/file12.png "0") for some values of its variables, then the original
    formula must be satisfiable. Otherwise, it has to be unsatisfiable.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在二进制变量 ![x_{0}](img/file443.png "x_{0}"), ![x_{1}](img/file712.png "x_{1}"),
    和 ![x_{2}](img/file444.png "x_{2}") 上。假设我们考虑原始公式中变量的某些真值赋值，并在多项式中将 ![x_{i} = 1](img/file713.png
    "x_{i} = 1") 设置为![x_{i}](img/file714.png "x_{i}")为真，![x_{i} = 0](img/file715.png
    "x_{i} = 0")如果![x_{i}](img/file714.png "x_{i}")为假。很容易看出，在这种情况下，原始公式将是真的，当且仅当 ![p(x_{0},x_{1},x_{2})
    = 0](img/file716.png "p(x_{0},x_{1},x_{2}) = 0")，并且它将是假的，当且仅当 ![p(x_{0},x_{1},x_{2})
    > 0](img/file717.png "p(x_{0},x_{1},x_{2}) > 0")。因此，如果多项式 ![p](img/file141.png
    "p") 对于其变量的某些值是 ![0](img/file12.png "0")，那么原始公式必须是可满足的。否则，它必须是不满足的。
- en: 'Then, we can rewrite our original problem as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以将我们的原始问题重新表述如下：
- en: '![\begin{array}{rlrl} {\text{Minimize~}\quad} & {(1 - x_{0})x_{1}(1 - x_{2})
    + x_{0}(1 - x_{1})x_{2} + (1 - x_{0})(1 - x_{1})(1 - x_{2})\qquad} & & \qquad
    \\ {\text{subject~to~}\quad} & {x_{j} \in \{ 0,1\},\qquad j = 0,1,2.\qquad} &
    & \qquad \\ & \qquad & & \\ \end{array}](img/file718.png "\begin{array}{rlrl}
    {\text{Minimize~}\quad} & {(1 - x_{0})x_{1}(1 - x_{2}) + x_{0}(1 - x_{1})x_{2}
    + (1 - x_{0})(1 - x_{1})(1 - x_{2})\qquad} & & \qquad \\ {\text{subject~to~}\quad}
    & {x_{j} \in \{ 0,1\},\qquad j = 0,1,2.\qquad} & & \qquad \\  & \qquad & & \\
    \end{array}")'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![最小化~\quad](img/file718.png "\begin{array}{rlrl} {\text{Minimize~}\quad} &
    {(1 - x_{0})x_{1}(1 - x_{2}) + x_{0}(1 - x_{1})x_{2} + (1 - x_{0})(1 - x_{1})(1
    - x_{2})\qquad} & & \qquad \\ {\text{subject~to~}\quad} & {x_{j} \in \{ 0,1\},\qquad
    j = 0,1,2.\qquad} & & \qquad \\ & \qquad & & \\ \end{array}") 是受诺贝尔物理奖获得者**理查德·费曼**启发的。'
- en: If the minimum of the polynomial is ![0](img/file12.png "0"), then the formula
    will be satisfiable. Otherwise, the formula will be unsatisfiable.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果多项式的最小值为 ![0](img/file12.png "0")，则该公式将是可满足的。否则，该公式将不可满足。
- en: With a simple transformation, we have been able to reformulate our problem as
    something that looks very much like a QUBO instance. But wait! This is *not* a
    QUBO problem. The reason is that the degree of the binary polynomial is ![3](img/file472.png
    "3") and not ![2](img/file302.png "2"), as you can easily check by expanding its
    expression. These optimization problems in which we are asked to minimize a binary
    polynomial — of any degree — with no additional restrictions are called **Higher
    Order Binary Optimization** (**HOBO**) or **Polynomial Unconstrained Binary Optimization**
    (**PUBO**) problems, for obvious reasons.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 通过简单的转换，我们已经能够将我们的问题重新表述为类似于QUBO实例的东西。但是等等！这**不是**一个QUBO问题。原因是二进制多项式的次数是 ![3](img/file472.png
    "3") 而不是 ![2](img/file302.png "2")，这可以通过展开其表达式轻松检查出来。这些优化问题，其中我们被要求最小化一个任意次数的二进制多项式——没有任何额外限制，被称为**高阶二进制优化**（**HOBO**）或**多项式无约束二进制优化**（**PUBO**）问题，原因很明显。
- en: The method that we have applied is quite general. In fact, it is easy to see
    that we can apply it to any Boolean formula that is given as conjunctions of disjunctions
    of variables and negations of variables. Something like, for instance, ![(x_{0}
    \vee \neg x_{1} \vee x_{2}) \land (\neg x_{0} \vee x_{1} \vee \neg x_{2}) \land
    (x_{0} \vee x_{1} \vee x_{2})](img/file710.png "(x_{0} \vee \neg x_{1} \vee x_{2})
    \land (\neg x_{0} \vee x_{1} \vee \neg x_{2}) \land (x_{0} \vee x_{1} \vee x_{2})")
    or ![(x_{0} \vee x_{1} \vee \neg x_{2} \vee x_{3}) \land (\neg x_{0} \vee x_{1}
    \vee x_{2} \vee x_{3}) \land (\neg x_{0} \vee x_{1} \vee \neg x_{2} \vee \neg
    x_{3})](img/file719.png "(x_{0} \vee x_{1} \vee \neg x_{2} \vee x_{3}) \land (\neg
    x_{0} \vee x_{1} \vee x_{2} \vee x_{3}) \land (\neg x_{0} \vee x_{1} \vee \neg
    x_{2} \vee \neg x_{3})"). We say that these formulas are in **conjunctive normal
    form** or **CNF**. In this case, we can just obtain an associated polynomial consisting
    of a sum of products. Each product will correspond to one of the disjunctions
    of the formula. If a variable ![x](img/file269.png "x") appears negated in the
    disjunction, it will appear as ![x](img/file269.png "x") in the product. If it
    appears in positive form, it will appear as ![1 - x](img/file720.png "1 - x")
    in the product.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用的方法相当通用。实际上，很容易看出我们可以将其应用于任何以变量的析取和变量的否定为合取的布尔公式。例如，像这样的公式，![（x_{0} ∨ ¬x_{1}
    ∨ x_{2}）∧（¬x_{0} ∨ x_{1} ∨ ¬x_{2}）∧（x_{0} ∨ x_{1} ∨ x_{2}）](img/file710.png "（x_{0}
    ∨ ¬x_{1} ∨ x_{2}）∧（¬x_{0} ∨ x_{1} ∨ ¬x_{2}）∧（x_{0} ∨ x_{1} ∨ x_{2}）") 或 ![（x_{0}
    ∨ x_{1} ∨ ¬x_{2} ∨ x_{3}）∧（¬x_{0} ∨ x_{1} ∨ x_{2} ∨ x_{3}）∧（¬x_{0} ∨ x_{1} ∨ ¬x_{2}
    ∨ ¬x_{3}）](img/file719.png "（x_{0} ∨ x_{1} ∨ ¬x_{2} ∨ x_{3}）∧（¬x_{0} ∨ x_{1} ∨
    x_{2} ∨ x_{3}）∧（¬x_{0} ∨ x_{1} ∨ ¬x_{2} ∨ ¬x_{3}）")。我们称这些公式为**合取范式**或**CNF**。在这种情况下，我们只需获得一个由乘积之和组成的关联多项式。每个乘积将对应于公式中的一个析取。如果一个变量
    ![x](img/file269.png "x") 在析取中以否定形式出现，它将作为 ![x](img/file269.png "x") 出现在乘积中。如果它以正形式出现，它将作为
    ![1 - x](img/file720.png "1 - x") 出现在乘积中。
- en: Exercise 5.3
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 5.3
- en: Write the HOBO version of the SAT problem with the Boolean formula
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 将SAT问题用布尔公式写成HOBO版本
- en: '![(x_{0} \vee x_{1} \vee \neg x_{2} \vee x_{3}) \land (\neg x_{0} \vee x_{1}
    \vee x_{2} \vee x_{3}) \land (\neg x_{0} \vee x_{1} \vee \neg x_{2} \vee \neg
    x_{3}).](img/file721.png "(x_{0} \vee x_{1} \vee \neg x_{2} \vee x_{3}) \land
    (\neg x_{0} \vee x_{1} \vee x_{2} \vee x_{3}) \land (\neg x_{0} \vee x_{1} \vee
    \neg x_{2} \vee \neg x_{3}).")'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![（x_{0} ∨ x_{1} ∨ ¬x_{2} ∨ x_{3}）∧（¬x_{0} ∨ x_{1} ∨ x_{2} ∨ x_{3}）∧（¬x_{0}
    ∨ x_{1} ∨ ¬x_{2} ∨ ¬x_{3}）.](img/file721.png "（x_{0} ∨ x_{1} ∨ ¬x_{2} ∨ x_{3}）∧（¬x_{0}
    ∨ x_{1} ∨ x_{2} ∨ x_{3}）∧（¬x_{0} ∨ x_{1} ∨ ¬x_{2} ∨ ¬x_{3}）.")'
- en: And what about Boolean formulas that are not in CNF? In this case, we can apply
    a method, called the **Tseitin transformation**, that runs in polynomial time
    and gives us a formula in CNF that is satisfiable if and only if the original
    formula was satisfiable (see [[17](ch030.xhtml#Xbiere2009handbook), Chapter 2]
    for more details). In fact, the resulting formula will be in **3-CNF**, meaning
    that the disjunctions will involve at most three variables or negations of variables.
    This is very convenient, because it guarantees that the process of expanding the
    polynomial to obtain the coefficients will be efficient.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 那么关于不是CNF（合取范式）的布尔公式怎么办呢？在这种情况下，我们可以应用一种称为**Tseitin变换**的方法，该方法在多项式时间内运行，并给我们一个CNF形式的公式，该公式只有在原始公式可满足时才可满足（更多细节请参见
    [[17](ch030.xhtml#Xbiere2009handbook)，第二章]）。实际上，得到的公式将是**3-CNF**，这意味着析取将涉及最多三个变量或变量的否定。这非常方便，因为它保证了将多项式展开以获得系数的过程将是高效的。
- en: But enough about satisfiability. Let’s come back to HOBO problems. How can we
    solve them? One way of doing this is by transforming them into QUBO problems.
    There are different techniques for rewriting HOBO problems as QUBO instances by
    introducing auxiliary variables. For example, you can substitute products ![xy](img/file722.png
    "xy") by a new binary variable ![z](img/file81.png "z") as long as you introduce
    a penalty term ![xy - 2xz - 2yz + 3z](img/file723.png "xy - 2xz - 2yz + 3z"),
    which is ![0](img/file12.png "0") if and only if ![xy = z](img/file724.png "xy
    = z"). In this way, you can reduce a term of order ![m + 1](img/file725.png "m
    + 1") such as ![x_{0}x_{1}\cdots x_{m}](img/file726.png "x_{0}x_{1}\cdots x_{m}")
    to a term of order ![m](img/file259.png "m") of the form ![zx_{2}\cdots x_{m}](img/file727.png
    "zx_{2}\cdots x_{m}") and a quadratic penalty term on ![x_{0},x_{1}](img/file728.png
    "x_{0},x_{1}"), and ![z](img/file81.png "z"). By repeating this process as many
    times as needed, you can obtain an equivalent problem in which the objective function
    is a binary quadratic polynomial. Transformations of this kind are used in D-Wave’s
    Ocean, where you can find `BinaryPolynomial` objects that you can reduce to polynomials
    of degree ![2](img/file302.png "2") with the `make_quadratic` function.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 但关于可满足性问题就说到这里。让我们回到HOBO问题。我们如何解决它们？一种方法是将它们转换成QUBO问题。通过引入辅助变量，有不同的技术可以将HOBO问题重写为QUBO实例。例如，只要引入惩罚项[![xy
    - 2xz - 2yz + 3z](img/file723.png "xy - 2xz - 2yz + 3z")](img/file723.png "xy
    - 2xz - 2yz + 3z")，你就可以用新的二进制变量[![z](img/file81.png "z")](img/file81.png "z")替换乘积[![xy](img/file722.png
    "xy")](img/file722.png "xy")，其中[![xy - 2xz - 2yz + 3z](img/file723.png "xy - 2xz
    - 2yz + 3z")](img/file723.png "xy - 2xz - 2yz + 3z")等于[![0](img/file12.png "0")]当且仅当[![xy
    = z](img/file724.png "xy = z")](img/file724.png "xy = z")。这样，你可以将阶数为[![m + 1](img/file725.png
    "m + 1")](img/file725.png "m + 1")的项，如[![x_{0}x_{1}\cdots x_{m}](img/file726.png
    "x_{0}x_{1}\cdots x_{m}")](img/file726.png "x_{0}x_{1}\cdots x_{m}")，简化为阶数为[![m](img/file259.png
    "m")](img/file259.png "m")的项[![zx_{2}\cdots x_{m}](img/file727.png "zx_{2}\cdots
    x_{m}")](img/file727.png "zx_{2}\cdots x_{m}")，以及一个关于[![x_{0},x_{1}](img/file728.png
    "x_{0},x_{1}")](img/file728.png "x_{0},x_{1}")和[![z](img/file81.png "z")](img/file81.png
    "z")的二次惩罚项。通过重复此过程所需次数，你可以得到一个等价问题，其中目标函数是一个二进制二次多项式。这种类型的转换在D-Wave的Ocean中使用，在那里你可以找到可以将其简化为度数为[![2](img/file302.png
    "2")](img/file302.png "2")的多项式的`BinaryPolynomial`对象，你可以使用`make_quadratic`函数实现。
- en: However, if you are using QAOA, you can deal with HOBO problems directly. We
    can consider a binary polynomial of any degree and transform it using the techniques
    of *Section* *[*3.3*](ch011.xhtml#x1-670003.3). We will end up having a Hamiltonian
    that is a sum of tensor products of ![Z_{j}](img/file384.png "Z_{j}") matrices.
    The only difference is that, now, these products can involve more than just one
    or two ![Z_{j}](img/file384.png "Z_{j}") matrices.*
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你使用QAOA，你可以直接处理HOBO问题。我们可以考虑任何度数的二项式，并使用**第3.3节**中的技术对其进行转换。[![Z_{j}](img/file384.png
    "Z_{j}")](img/file384.png "Z_{j}")矩阵的张量积之和将构成哈密顿量。唯一的区别是，现在这些乘积可以涉及一个以上的[![Z_{j}](img/file384.png
    "Z_{j}")](img/file384.png "Z_{j}")矩阵。
- en: '*This implies that, when we set out to create a circuit for ![e^{- i\gamma_{l}H_{1}}](img/file729.png
    "e^{- i\gamma_{l}H_{1}}"), we may need to implement unitary operations of the
    form ![e^{- iaZ_{j_{1}}Z_{j_{2}}\cdots Z_{j_{m}}}](img/file730.png "e^{- iaZ_{j_{1}}Z_{j_{2}}\cdots
    Z_{j_{m}}}"), with ![m > 2](img/file731.png "m > 2"). But that is not much more
    difficult than implementing ![e^{- iaZ_{j}Z_{k}}](img/file671.png "e^{- iaZ_{j}Z_{k}}").
    In fact, we can almost repeat the argument in *Section* * [*5.1.3*](#x1-980005.1.3),
    because both ![Z_{j_{1}}Z_{j_{2}}\cdots Z_{j_{m}}](img/file732.png "Z_{j_{1}}Z_{j_{2}}\cdots
    Z_{j_{m}}") and ![e^{- iaZ_{j_{1}}Z_{j_{2}}\cdots Z_{j_{m}}}](img/file730.png
    "e^{- iaZ_{j_{1}}Z_{j_{2}}\cdots Z_{j_{m}}}") are diagonal matrices. In fact,
    if ![\left| x \right\rangle](img/file267.png "\left| x \right\rangle") is a basis
    state, then*'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，当我们着手创建[![e^{- i\gamma_{l}H_{1}}](img/file729.png "e^{- i\gamma_{l}H_{1}}")](img/file729.png
    "e^{- i\gamma_{l}H_{1}}")的电路时，我们可能需要实现形式为[![e^{- iaZ_{j_{1}}Z_{j_{2}}\cdots Z_{j_{m}}}](img/file730.png
    "e^{- iaZ_{j_{1}}Z_{j_{2}}\cdots Z_{j_{m}}}")](img/file730.png "e^{- iaZ_{j_{1}}Z_{j_{2}}\cdots
    Z_{j_{m}}}")的幺正操作，其中[![m > 2](img/file731.png "m > 2")]。但这并不比实现[![e^{- iaZ_{j}Z_{k}}](img/file671.png
    "e^{- iaZ_{j}Z_{k}}")](img/file671.png "e^{- iaZ_{j}Z_{k}}")更困难。事实上，我们可以几乎重复**第5.1.3节**中的论点，因为[![Z_{j_{1}}Z_{j_{2}}\cdots
    Z_{j_{m}}](img/file732.png "Z_{j_{1}}Z_{j_{2}}\cdots Z_{j_{m}}")](img/file732.png
    "Z_{j_{1}}Z_{j_{2}}\cdots Z_{j_{m}}")和[![e^{- iaZ_{j_{1}}Z_{j_{2}}\cdots Z_{j_{m}}}](img/file730.png
    "e^{- iaZ_{j_{1}}Z_{j_{2}}\cdots Z_{j_{m}}}")](img/file730.png "e^{- iaZ_{j_{1}}Z_{j_{2}}\cdots
    Z_{j_{m}}}")都是对角矩阵。实际上，如果[![\left| x \right\rangle](img/file267.png "\left| x
    \right\rangle")](img/file267.png "\left| x \right\rangle")是一个基态，那么
- en: '*![e^{- iaZ_{j_{1}}Z_{j_{2}}\cdots Z_{j_{m}}}\left| x \right\rangle = e^{-
    ia}\left| x \right\rangle](img/file733.png "e^{- iaZ_{j_{1}}Z_{j_{2}}\cdots Z_{j_{m}}}\left|
    x \right\rangle = e^{- ia}\left| x \right\rangle")'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '[![e^{- iaZ_{j_{1}}Z_{j_{2}}\cdots Z_{j_{m}}}\left| x \right\rangle = e^{-
    ia}\left| x \right\rangle](img/file733.png "e^{- iaZ_{j_{1}}Z_{j_{2}}\cdots Z_{j_{m}}}\left|
    x \right\rangle = e^{- ia}\left| x \right\rangle")'
- en: if the sum of the bits of ![x](img/file269.png "x") in positions ![j_{1},j_{2},\ldots,j_{m}](img/file734.png
    "j_{1},j_{2},\ldots,j_{m}") is even, and
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果![x](img/file269.png "x")在位置![j_{1},j_{2},\ldots,j_{m}](img/file734.png "j_{1},j_{2},\ldots,j_{m}")上的比特之和是偶数的话，并且
- en: '![e^{- iaZ_{j_{1}}Z_{j_{2}}\cdots Z_{j_{m}}}\left| x \right\rangle = e^{ia}\left|
    x \right\rangle](img/file735.png "e^{- iaZ_{j_{1}}Z_{j_{2}}\cdots Z_{j_{m}}}\left|
    x \right\rangle = e^{ia}\left| x \right\rangle")'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![e^{- iaZ_{j_{1}}Z_{j_{2}}\cdots Z_{j_{m}}}\left| x \right\rangle = e^{ia}\left|
    x \right\rangle](img/file735.png "e^{- iaZ_{j_{1}}Z_{j_{2}}\cdots Z_{j_{m}}}\left|
    x \right\rangle = e^{ia}\left| x \right\rangle")'
- en: if the sum is odd.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果和是奇数的话。
- en: This unitary action can be implemented by using consecutive CNOT gates with
    control qubits in ![j_{1},j_{2},\ldots,j_{m - 1}](img/file736.png "j_{1},j_{2},\ldots,j_{m
    - 1}") and targets in ![j_{m}](img/file737.png "j_{m}"), then an ![R_{Z}](img/file120.png
    "R_{Z}") gate with parameter ![2a](img/file738.png "2a") on qubit ![j_{m}](img/file737.png
    "j_{m}") and, again, consecutive CNOT gates with control qubits in ![j_{m - 1},j_{m
    - 2},\ldots,j_{1}](img/file739.png "j_{m - 1},j_{m - 2},\ldots,j_{1}") and targets
    in ![j_{m}](img/file737.png "j_{m}"). *Figure* * [*5.3*](#Figure5.3) illustrates
    this procedure for the case of ![e^{- iaZ_{0}Z_{1}Z_{3}}](img/file740.png "e^{-
    iaZ_{0}Z_{1}Z_{3}}"), under the assumption that we only have four qubits.*
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这个幺正操作可以通过使用控制量子比特在![j_{1},j_{2},\ldots,j_{m - 1}](img/file736.png "j_{1},j_{2},\ldots,j_{m
    - 1}")和目标在![j_{m}](img/file737.png "j_{m}")上的连续CNOT门来实现，然后在量子比特![j_{m}](img/file737.png
    "j_{m}")上使用参数为![2a](img/file738.png "2a")的![R_{Z}](img/file120.png "R_{Z}")门，再次使用控制量子比特在![j_{m
    - 1},j_{m - 2},\ldots,j_{1}](img/file739.png "j_{m - 1},j_{m - 2},\ldots,j_{1}")和目标在![j_{m}](img/file737.png
    "j_{m}")上的连续CNOT门。*图* * [*5.3*](#Figure5.3)展示了在只有四个量子比特的假设下，![e^{- iaZ_{0}Z_{1}Z_{3}}](img/file740.png
    "e^{- iaZ_{0}Z_{1}Z_{3}}")的情况下的这个过程。
- en: '*![Figure 5.3: Implementation of e^{- iaZ_{0}Z_{1}Z_{3}}](img/file741.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*![图5.3：e^{- iaZ_{0}Z_{1}Z_{3}}的实现](img/file741.jpg)'
- en: '**Figure 5.3**: Implementation of ![e^{- iaZ_{0}Z_{1}Z_{3}}](img/file740.png
    "e^{- iaZ_{0}Z_{1}Z_{3}}")'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**图5.3**：![e^{- iaZ_{0}Z_{1}Z_{3}}](img/file740.png "e^{- iaZ_{0}Z_{1}Z_{3}}")的实现'
- en: Of course, this operation would be just one part in the implementation of ![e^{-
    i\gamma_{l}H_{1}}](img/file729.png "e^{- i\gamma_{l}H_{1}}") and we would need
    to repeat a similar process for each term of the Hamiltonian.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这个操作只是![e^{- i\gamma_{l}H_{1}}](img/file729.png "e^{- i\gamma_{l}H_{1}}")实现的一部分，我们需要对哈密顿量的每一项重复类似的过程。
- en: Exercise 5.4
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 练习5.4
- en: Implement, in a circuit with 5 qubits, the operation ![e^{- i\frac{\pi}{4}Z_{0}Z_{2}Z_{4}}](img/file742.png
    "e^{- i\frac{\pi}{4}Z_{0}Z_{2}Z_{4}}").
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个包含5个量子比特的电路中实现操作![e^{- i\frac{\pi}{4}Z_{0}Z_{2}Z_{4}}](img/file742.png "e^{-
    i\frac{\pi}{4}Z_{0}Z_{2}Z_{4}}")。
- en: Notice that we can also estimate the energy of a Hamiltonian ![H_{1}](img/file544.png
    "H_{1}") that includes tensor products of ![Z](img/file8.png "Z") matrices in
    a way that is very similar to the one that we explained in *Section* * [*5.1.4*](#x1-990005.1.4).
    The key fact is that, for any basis state ![\left| x \right\rangle](img/file267.png
    "\left| x \right\rangle"), it holds that*
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们也可以用与我们在*第5.1.4节*中解释的非常相似的方式估计包含![Z](img/file8.png "Z")矩阵张量的哈密顿量![H_{1}](img/file544.png
    "H_{1}")的能量。关键事实是，对于任何基态![\left| x \right\rangle](img/file267.png "\left| x \right\rangle")，都成立。
- en: '*![\left\langle x \right|Z_{j_{1}}Z_{j_{2}}\cdots Z_{j_{m}}\left| x \right\rangle
    = 1](img/file743.png "\left\langle x \right|Z_{j_{1}}Z_{j_{2}}\cdots Z_{j_{m}}\left|
    x \right\rangle = 1")'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '*![\left\langle x \right|Z_{j_{1}}Z_{j_{2}}\cdots Z_{j_{m}}\left| x \right\rangle
    = 1](img/file743.png "\left\langle x \right|Z_{j_{1}}Z_{j_{2}}\cdots Z_{j_{m}}\left|
    x \right\rangle = 1")'
- en: if the sum of the bits of ![x](img/file269.png "x") in positions ![j_{1},j_{2},\ldots,j_{m}](img/file734.png
    "j_{1},j_{2},\ldots,j_{m}") is even, and
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果![x](img/file269.png "x")在位置![j_{1},j_{2},\ldots,j_{m}](img/file734.png "j_{1},j_{2},\ldots,j_{m}")上的比特之和是偶数的话，并且
- en: '![\left\langle x \right|Z_{j_{1}}Z_{j_{2}}\cdots Z_{j_{m}}\left| x \right\rangle
    = - 1](img/file744.png "\left\langle x \right|Z_{j_{1}}Z_{j_{2}}\cdots Z_{j_{m}}\left|
    x \right\rangle = - 1")'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![\left\langle x \right|Z_{j_{1}}Z_{j_{2}}\cdots Z_{j_{m}}\left| x \right\rangle
    = - 1](img/file744.png "\left\langle x \right|Z_{j_{1}}Z_{j_{2}}\cdots Z_{j_{m}}\left|
    x \right\rangle = - 1")'
- en: otherwise. By linearity, we can then evaluate ![\left\langle x \right|H_{1}\left|
    x \right\rangle](img/file690.png "\left\langle x \right|H_{1}\left| x \right\rangle")
    and, from that, we can estimate ![\left\langle \psi \right|H_{1}\left| \psi \right\rangle](img/file703.png
    "\left\langle \psi \right|H_{1}\left| \psi \right\rangle") by measuring ![\left|
    \psi \right\rangle](img/file43.png "\left| \psi \right\rangle") a number of times,
    exactly as we did in *Section* * [*5.1.4*](#x1-990005.1.4).*
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: otherwise. 通过线性，我们可以评估![\left\langle x \right|H_{1}\left| x \right\rangle](img/file690.png
    "\left\langle x \right|H_{1}\left| x \right\rangle")，并从那里通过测量![\left| \psi \right\rangle](img/file43.png
    "\left| \psi \right\rangle")多次来估计![\left\langle \psi \right|H_{1}\left| \psi \right\rangle](img/file703.png
    "\left\langle \psi \right|H_{1}\left| \psi \right\rangle")，这与我们在*第5.1.4节* *[*5.1.4*](#x1-990005.1.4)中所做的方法完全相同。
- en: '*Exercise 5.5'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '*练习5.5'
- en: Evaluate ![\left\langle {100} \right|H_{1}\left| {100} \right\rangle](img/file697.png
    "\left\langle {100} \right|H_{1}\left| {100} \right\rangle") with ![H_{1} = Z_{0}Z_{1}Z_{2}
    + 3Z_{0}Z_{2} - Z_{1}Z_{2} + 2Z_{0}](img/file745.png "H_{1} = Z_{0}Z_{1}Z_{2}
    + 3Z_{0}Z_{2} - Z_{1}Z_{2} + 2Z_{0}").
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 使用![H_{1} = Z_{0}Z_{1}Z_{2} + 3Z_{0}Z_{2} - Z_{1}Z_{2} + 2Z_{0}](img/file745.png
    "H_{1} = Z_{0}Z_{1}Z_{2} + 3Z_{0}Z_{2} - Z_{1}Z_{2} + 2Z_{0}")来评估![\left\langle
    {100} \right|H_{1}\left| {100} \right\rangle](img/file697.png "\left\langle {100}
    \right|H_{1}\left| {100} \right\rangle")。
- en: We have now covered all the necessary concepts to understand QAOA in all its
    glory. In the next two sections, we will show how to implement and run this algorithm
    with both Qiskit and PennyLane.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经涵盖了理解QAOA所需的所有必要概念。在接下来的两个部分中，我们将展示如何使用Qiskit和PennyLane实现并运行此算法。
- en: 5.2 Using QAOA with Qiskit
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.2 使用Qiskit进行QAOA
- en: With everything that we have learned in the previous sections of this chapter
    and what we already know about Qiskit from *Chapter* *[*2*](ch009.xhtml#x1-400002),
    *The* *Tools of the Trade in Quantum Computing*, and *Section* *[*3.2.2*](ch011.xhtml#x1-660003.2.2),
    we could implement our own Qiskit version of QAOA. However, there is no need for
    that! As we shall show in this section, the Qiskit Optimization package provides
    all that is necessary to run QAOA on both quantum simulators and actual quantum
    computers. Moreover, it includes a set of tools to work directly with problems
    written under the QUBO formalism. As a matter of fact, in this section, we will
    also see how, underneath the hood, Qiskit uses the very same mathematical concepts
    that we have been studying.**
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前几节中我们已经学到的内容，以及我们从*第2章* *[*2*](ch009.xhtml#x1-400002)，*量子计算中的工具*和*第3.2.2节*
    *[*3.2.2*](ch011.xhtml#x1-660003.2.2)中了解到的Qiskit知识，我们可以实现我们自己的Qiskit版本QAOA。然而，没有必要这么做！正如我们将在本节中展示的，Qiskit优化包提供了在量子模拟器和实际量子计算机上运行QAOA所需的一切。此外，它还包括一套直接与QUBO形式化下编写的问题进行工作的工具。实际上，在本节中，我们还将看到Qiskit在底层是如何使用我们一直在研究的相同数学概念的。**
- en: '**Let’s start by explaining how to work with QAOA in Qiskit when we already
    have the problem Hamiltonian.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**首先，我们来解释一下，当我们已经拥有问题哈密顿量时，如何在Qiskit中与QAOA进行交互**。'
- en: 5.2.1 Using QAOA with Hamiltonians
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.2.1 使用哈密顿量进行QAOA
- en: 'If we have the Hamiltonian ![H_{1}](img/file544.png "H_{1}") that encodes our
    optimization problem, it is very easy to use Qiskit’s QAOA implementation to approximate
    its ground state. Let’s start with a simple example in which we have ![H_{1} =
    Z_{0}Z_{1}](img/file746.png "H_{1} = Z_{0}Z_{1}"). We can create this Hamiltonian
    and prepare the corresponding QAOA circuit with the following lines of code:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有编码优化问题的哈密顿量![H_{1}](img/file544.png "H_{1}")，使用Qiskit的QAOA实现来近似其基态是非常容易的。让我们从一个简单的例子开始，其中我们有![H_{1}
    = Z_{0}Z_{1}](img/file746.png "H_{1} = Z_{0}Z_{1}")。我们可以使用以下代码行创建这个哈密顿量并准备相应的QAOA电路：
- en: '[PRE0]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As a result, we will obtain the circuit shown in *Figure* *[*5.4*](#Figure5.4).
    We can see how it starts with two Hadamard gates, which are then followed by the
    exponential of ![H_{1}](img/file544.png "H_{1}") and then the exponential of ![H_{0}](img/file545.png
    "H_{0}") (because ![H_{0} = X_{0}X_{1} = X_{0}I + IX_{1}](img/file747.png "H_{0}
    = X_{0}X_{1} = X_{0}I + IX_{1}")). This is exactly the circuit that we derived
    in the first part of the chapter.*
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 结果，我们将获得*图* *[*5.4*](#Figure5.4)中所示的电路。我们可以看到它从两个Hadamard门开始，然后是![H_{1}](img/file544.png
    "H_{1}")的指数，然后是![H_{0}](img/file545.png "H_{0}")的指数（因为![H_{0} = X_{0}X_{1} = X_{0}I
    + IX_{1}](img/file747.png "H_{0} = X_{0}X_{1} = X_{0}I + IX_{1}"))。这正是我们在本章第一部分推导出的电路。
- en: '*![Figure 5.4: QAOA circuit for H_{1} = Z_{0}Z_{1}](img/file748.png)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '*![图5.4：H_{1} = Z_{0}Z_{1}的QAOA电路](img/file748.png)'
- en: '**Figure 5.4**: QAOA circuit for ![H_{1} = Z_{0}Z_{1}](img/file746.png "H_{1}
    = Z_{0}Z_{1}")'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '**图5.4**：![H_{1} = Z_{0}Z_{1}](img/file746.png "H_{1} = Z_{0}Z_{1}")的QAOA电路'
- en: In order to create the circuit, in addition to `H1`, we’ve passed `[1,2]` to
    the method called `construct_circuit`. This list contains the ![\mathbf{\beta}](img/file645.png
    "\mathbf{\beta}") and ![\mathbf{\gamma}](img/file646.png "\mathbf{\gamma}") parameters
    that we want to use. In *Figure* * [*5.4*](#Figure5.4), this is indicated by the
    numbers below the exponentials in the gate boxes. Notice that this means that
    the first element in `[1,2]` is what we call ![\beta_{1}](img/file684.png "\beta_{1}")
    and the second is ![\gamma_{1}](img/file683.png "\gamma_{1}"). Also notice that
    we have used `[0]` after the call to `construct_circuit`. This is because this
    method, in general, returns a list of several circuits — but in this case, there
    is only one, which is the one that we pick.*
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建电路，除了 `H1` 之外，我们还向 `construct_circuit` 方法传递了 `[1,2]`。这个列表包含我们想要使用的 ![\mathbf{\beta}](img/file645.png
    "\mathbf{\beta}") 和 ![\mathbf{\gamma}](img/file646.png "\mathbf{\gamma}") 参数。在
    *图 5.4* 中，这通过门框下方的数字表示。请注意，这意味着 `[1,2]` 中的第一个元素就是我们所说的 ![\beta_{1}](img/file684.png
    "\beta_{1}")，第二个是 ![\gamma_{1}](img/file683.png "\gamma_{1}")。另外请注意，我们在 `construct_circuit`
    调用之后使用了 `[0]`。这是因为这个方法通常返回多个电路的列表——但在这个情况下，只有一个，就是我们选择的那个。*
- en: '*We can visualize the circuit in more detail by decomposing the exponentials
    — that is, transforming them into simpler gates — a couple of times. For that,
    we may use'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过分解指数——即，将它们转换为更简单的门——来更详细地可视化电路，这要做几次。为此，我们可以使用
- en: '[PRE1]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: to get the circuit shown in *Figure* *[*5.5*](#Figure5.5). The sequence of gates
    in that circuit is exactly the one that we would expect from our derivations earlier
    in this chapter, because ![\left. U(\pi\slash 2,0,\pi) = H \right.](img/file749.png
    "\left. U(\pi\slash 2,0,\pi) = H \right."), as you can easily check from the definition
    that we gave in *Section* * [*1.3.4*](ch008.xhtml#x1-250001.3.4) (![U_{3}](img/file750.png
    "U_{3}") is Qiskit’s name for our ![U](img/file51.png "U") gate).**
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 以获得图 *[*5.5*](#Figure5.5) 中所示的电路。该电路中的门序列正是我们在此章早期推导中期望的，因为 ![U(\pi\slash 2,0,\pi)
    = H](img/file749.png "\left. U(\pi\slash 2,0,\pi) = H \right.")，正如你可以从我们在 *第 1.3.4
    节* ([*1.3.4*](ch008.xhtml#x1-250001.3.4)) 中给出的定义中轻松检查到的（![U_{3}](img/file750.png
    "U_{3}") 是 Qiskit 对我们 ![U](img/file51.png "U") 门的命名）。**
- en: '**![Figure 5.5: QAOA circuit for H_{1} = Z_{0}Z_{1}, more detailed](img/file751.png)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '**![图 5.5：H_{1} = Z_{0}Z_{1} 的 QAOA 电路，更详细](img/file751.png)'
- en: '**Figure 5.5**: QAOA circuit for ![H_{1} = Z_{0}Z_{1}](img/file746.png "H_{1}
    = Z_{0}Z_{1}"), more detailed'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 5.5**：![H_{1} = Z_{0}Z_{1}](img/file746.png "H_{1} = Z_{0}Z_{1}") 的 QAOA
    电路，更详细'
- en: 'By default, the value of ![p](img/file141.png "p") for QAOA in Qiskit is ![1](img/file13.png
    "1"). However, we can change it by using the `reps` parameter when calling the
    class constructor. For instance, the following code can be used to obtain the
    QAOA circuit for ![Z_{0}Z_{1}](img/file352.png "Z_{0}Z_{1}") with ![p = 2](img/file752.png
    "p = 2"), ![\beta_{1} = 1](img/file753.png "\beta_{1} = 1"), ![\beta_{2} = 2](img/file754.png
    "\beta_{2} = 2"), ![\gamma_{1} = 3](img/file755.png "\gamma_{1} = 3"), and ![\gamma_{2}
    = 4](img/file756.png "\gamma_{2} = 4"):'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Qiskit 中 QAOA 的 ![p](img/file141.png "p") 的值为 ![1](img/file13.png "1")。然而，我们可以通过在调用类构造函数时使用
    `reps` 参数来更改它。例如，以下代码可以用来获取 ![Z_{0}Z_{1}](img/file352.png "Z_{0}Z_{1}") 的 QAOA
    电路，其中 ![p = 2](img/file752.png "p = 2")，![\beta_{1} = 1](img/file753.png "\beta_{1}
    = 1")，![\beta_{2} = 2](img/file754.png "\beta_{2} = 2")，![\gamma_{1} = 3](img/file755.png
    "\gamma_{1} = 3")，和 ![\gamma_{2} = 4](img/file756.png "\gamma_{2} = 4")：
- en: '[PRE2]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The result of the execution is the circuit shown in *Figure* *[*5.6*](#Figure5.6).*
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 执行结果是图 *[*5.6*](#Figure5.6) 中所示的电路。
- en: '*![Figure 5.6: QAOA circuit for H_{1} = Z_{0}Z_{1} with p = 2](img/file757.png)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '*![图 5.6：H_{1} = Z_{0}Z_{1} 的 QAOA 电路，p = 2](img/file757.png)'
- en: '**Figure 5.6**: QAOA circuit for ![H_{1} = Z_{0}Z_{1}](img/file746.png "H_{1}
    = Z_{0}Z_{1}") with ![p = 2](img/file752.png "p = 2")'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 5.6**：![H_{1} = Z_{0}Z_{1}](img/file746.png "H_{1} = Z_{0}Z_{1}") 的 QAOA
    电路，![p = 2](img/file752.png "p = 2")'
- en: All this is well and good, but we haven’t yet solved any optimization problems!
    For that, we need to pass two additional parameters when creating a `QAOA` object.
    The first one is a `QuantumInstance`. That is, some backend capable of executing
    the QAOA quantum circuit to evaluate the energy of the ![\left| {\mathbf{\beta},\mathbf{\gamma}}
    \right\rangle](img/file644.png "\left| {\mathbf{\beta},\mathbf{\gamma}} \right\rangle")
    states. The second one is a classical optimizer, which will set initial values
    for ![\mathbf{\beta}](img/file645.png "\mathbf{\beta}") and ![\mathbf{\gamma}](img/file646.png
    "\mathbf{\gamma}"), use the `QuantumInstance` to evaluate state energies, and
    update the ![\mathbf{\beta}](img/file645.png "\mathbf{\beta}") and ![\mathbf{\gamma}](img/file646.png
    "\mathbf{\gamma}") parameters in order to optimize them, until some stopping criterion
    is met.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都很好，但我们还没有解决任何优化问题！为了做到这一点，我们需要在创建 `QAOA` 对象时传递两个额外的参数。第一个是一个 `QuantumInstance`。也就是说，一些能够执行
    QAOA 量子电路以评估 ![\left| {\mathbf{\beta},\mathbf{\gamma}} \right\rangle](img/file644.png
    "\left| {\mathbf{\beta},\mathbf{\gamma}} \right\rangle") 状态能量的后端。第二个是一个经典优化器，它将为
    ![\mathbf{\beta}](img/file645.png "\mathbf{\beta}") 和 ![\mathbf{\gamma}](img/file646.png
    "\mathbf{\gamma}") 设置初始值，使用 `QuantumInstance` 评估状态能量，并更新 ![\mathbf{\beta}](img/file645.png
    "\mathbf{\beta}") 和 ![\mathbf{\gamma}](img/file646.png "\mathbf{\gamma}") 参数以优化它们，直到满足某些停止标准。
- en: To learn more…
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多……
- en: The choice of classical optimizer can have a big impact on the execution time
    and quality of the solutions obtained with QAOA.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 经典优化器的选择可能会对 QAOA 获得的解决方案的执行时间和质量产生重大影响。
- en: For some insights into this, you can refer to [[39](ch030.xhtml#Xfernandez2022study)].
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这方面的见解，你可以参考 [[39](ch030.xhtml#Xfernandez2022study)]。
- en: 'In the following piece of code, we give an example of how to create the quantum
    instance and the classical minimizer objects, and of how to use them with QAOA
    to solve a simple problem:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码片段中，我们给出了如何创建量子实例和经典最小化器对象，以及如何使用它们与 QAOA 解决简单问题的示例：
- en: '[PRE3]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, we are relying on the previous definition of `H1` as `Z``^``Z`, running
    the circuit on the `Aer` simulator with ![10](img/file161.png "10") shots, and
    using `COBYLA` as the classical optimizer — for an updated list of minimizers,
    please refer to Qiskit’s documentation at [https://qiskit.org/documentation/stubs/qiskit.algorithms.optimizers.html](https://qiskit.org/documentation/stubs/qiskit.algorithms.optimizers.html).
    We are also setting seeds for those processes that require random numbers, in
    order to obtain reproducible results.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们依赖于 `H1` 的先前定义 `Z``^``Z`，在 `Aer` 模拟器上运行电路，使用 ![10](img/file161.png "10")
    次射击，并使用 `COBYLA` 作为经典优化器——有关最小化器的更新列表，请参阅 Qiskit 的文档 [https://qiskit.org/documentation/stubs/qiskit.algorithms.optimizers.html](https://qiskit.org/documentation/stubs/qiskit.algorithms.optimizers.html)。我们还为需要随机数的那些过程设置了种子，以便获得可重复的结果。
- en: 'If you run the preceding instructions, you will obtain the following output:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行前面的指令，你将获得以下输出：
- en: '@empty'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '@empty'
- en: '[PRE4]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'That is quite a lot of information! Let’s try to explain the most relevant
    pieces. The first thing that we need to understand is that this result refers
    to the final state ![\left| {\mathbf{\beta}^{\ast},\mathbf{\gamma}^{\ast}} \right\rangle](img/file707.png
    "\left| {\mathbf{\beta}^{\ast},\mathbf{\gamma}^{\ast}} \right\rangle") obtained
    by QAOA, not to the solutions that we would obtain if we measured it. In fact,
    this state is reconstructed from ![10](img/file161.png "10") measurements — because
    our simulator is using ![10](img/file161.png "10") shots — but those measurements
    are not given as part of the output. Instead, we get the `eigenstate` field, which
    shows that we have ![\left| {01} \right\rangle](img/file199.png "\left| {01} \right\rangle")
    with an amplitude roughly ![0.5477](img/file758.png "0.5477") and ![\left| {10}
    \right\rangle](img/file200.png "\left| {10} \right\rangle") with an amplitude
    about ![0.8367](img/file759.png "0.8367"). These numbers are, in fact, ![\sqrt{\left.
    3\slash 10 \right.}](img/file760.png "\sqrt{\left. 3\slash 10 \right.}") and ![\sqrt{\left.
    7\slash 10 \right.}](img/file761.png "\sqrt{\left. 7\slash 10 \right.}"), which
    means that, once the state with the optimal parameters found by the minimizer
    was prepared and measured, `01` was obtained ![3](img/file472.png "3") out of
    ![10](img/file161.png "10") times and `10` was obtained the remaining ![7](img/file465.png
    "7") times. This state can be prepared with the QAOA circuit by using the optimal
    parameters reported in the result: ![\beta_{1} \approx 6.7648](img/file762.png
    "\beta_{1} \approx 6.7648") and ![\gamma_{1} \approx - 0.8472](img/file763.png
    "\gamma_{1} \approx - 0.8472").'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实是一大堆信息！让我们尝试解释其中最相关的部分。首先，我们需要理解的是，这个结果指的是QAOA获得的最终状态![\left| {\mathbf{\beta}^{\ast},\mathbf{\gamma}^{\ast}}
    \right\rangle](img/file707.png "\left| {\mathbf{\beta}^{\ast},\mathbf{\gamma}^{\ast}}
    \right\rangle")，而不是如果我们测量它我们会得到的解。实际上，这个状态是通过![10](img/file161.png "10")次测量重建的——因为我们的模拟器使用了![10](img/file161.png
    "10")次射击——但这些测量并没有作为输出的一部分给出。相反，我们得到了`eigenstate`字段，它显示我们有一个![\left| {01} \right\rangle](img/file199.png
    "\left| {01} \right\rangle")的振幅大约为![0.5477](img/file758.png "0.5477")和![\left|
    {10} \right\rangle](img/file200.png "\left| {10} \right\rangle")的振幅大约为![0.8367](img/file759.png
    "0.8367")。这些数字实际上是![\sqrt{\left. 3\slash 10 \right.}](img/file760.png "\sqrt{\left.
    3\slash 10 \right.}")和![\sqrt{\left. 7\slash 10 \right.}](img/file761.png "\sqrt{\left.
    7\slash 10 \right.}")，这意味着，一旦通过最小化器找到的最佳参数状态被准备并测量，`01`在![10](img/file161.png
    "10")次测量中出现了![3](img/file472.png "3")次，而`10`在剩余的![7](img/file465.png "7")次测量中出现。这个状态可以通过使用结果中报告的最佳参数![\beta_{1}
    \approx 6.7648](img/file762.png "\beta_{1} \approx 6.7648")和![\gamma_{1} \approx
    - 0.8472](img/file763.png "\gamma_{1} \approx - 0.8472")来使用QAOA电路进行准备。
- en: Notice that, with respect to the ![Z_{0}Z_{1}](img/file352.png "Z_{0}Z_{1}")
    Hamiltonian, both ![\left| {01} \right\rangle](img/file199.png "\left| {01} \right\rangle")
    and ![\left| {10} \right\rangle](img/file200.png "\left| {10} \right\rangle")
    have an expected value of ![- 1](img/file312.png "- 1"), which is the optimal
    energy. This means that we have been able to find an optimal solution — two of
    them, in fact — with QAOA! To get to this result, QAOA evaluated the energy function
    — by preparing a circuit with some values of ![\beta_{1}](img/file684.png "\beta_{1}")
    and ![\gamma_{1}](img/file683.png "\gamma_{1}") and measuring it to estimate its
    expectation value — 20 times, as indicated by the `cost_function_evals` field,
    and it used about ![0.08](img/file764.png "0.08") seconds of computing time —
    your running time will most surely be different from ours, though.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到，对于![Z_{0}Z_{1}](img/file352.png "Z_{0}Z_{1}")哈密顿量，![\left| {01} \right\rangle](img/file199.png
    "\left| {01} \right\rangle")和![\left| {10} \right\rangle](img/file200.png "\left|
    {10} \right\rangle")的期望值均为![ - 1](img/file312.png "- 1")，这是最佳能量。这意味着我们已经能够找到一个最佳解——实际上是有两个——通过QAOA！为了得到这个结果，QAOA评估了能量函数——通过准备一个包含![\beta_{1}](img/file684.png
    "\beta_{1}")和![\gamma_{1}](img/file683.png "\gamma_{1}")某些值的电路，并测量它以估计其期望值——20次，如`cost_function_evals`字段所示，并且它使用了大约![0.08](img/file764.png
    "0.08")秒的计算机时间——尽管你的运行时间肯定与我们不同。
- en: All this has been done with the Aer simulator. If we wanted to use a real quantum
    computer, we could just replace the `backend` in the instantiation of the `QuantumInstance`
    object and use some of the quantum devices provided by IBM, as we showed in *Section*
    *[*2.2.4*](ch009.xhtml#x1-510002.2.4). However, this is not the best way to proceed.
    The problem with this straightforward approach is that you will be running the
    classical part of the algorithm locally. Then, each time that an energy estimation
    is required, a new job will be submitted to the quantum computer and you will
    have to wait on the queue if other users have also sent jobs to execute. This
    can be quite slow, not because of the process itself, but because of the queue
    waiting times.*
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都是在Aer模拟器上完成的。如果我们想使用真实的量子计算机，我们只需在`QuantumInstance`对象的实例化中替换`backend`，并使用IBM提供的某些量子设备，就像我们在*第*
    *[*2.2.4*](ch009.xhtml#x1-510002.2.4) *节中展示的那样。然而，这并不是最佳的做法。这种直接方法的缺点是您将在本地运行算法的经典部分。然后，每次需要能量估计时，都会向量子计算机提交一个新的作业，并且如果您有其他用户也提交了作业以执行，您将不得不等待队列。这可能会相当慢，不是因为过程本身，而是因为队列等待时间。
- en: '*Fortunately, Qiskit has recently introduced a new module called Runtime that
    allows us to reduce the execution time for hybrid algorithms such as QAOA. Instead
    of submitting each circuit individually, with Runtime you can submit a **program**
    that includes both the classical and the quantum part of the algorithm. The program
    is then queued just once, greatly speeding up the whole execution.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '*幸运的是，Qiskit最近引入了一个名为Runtime的新模块，允许我们减少像QAOA这样的混合算法的执行时间。与逐个提交每个电路不同，使用Runtime，您可以提交一个包含算法的经典和量子部分的**程序**。程序随后只排队一次，大大加快了整个执行过程。'
- en: 'Using Runtime with QAOA is very easy. In fact, we just need to specify the
    same elements that we have used with the `QAOA` class, but in a slightly different
    way. The following piece of code shows an example of how to do this:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 使用QAOA与Runtime结合非常简单。实际上，我们只需要指定与`QAOA`类相同的元素，但方式略有不同。以下代码片段展示了如何进行此操作：
- en: '[PRE5]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This will create and run a QAOA Runtime job whose quantum part will be executed
    in the quantum computer that we have specified in the `options``[``"``backend_name``"``]`
    field — in our case, `ibmq_belem`. We have used the ![Z_{0}Z_{1}](img/file352.png
    "Z_{0}Z_{1}") Hamiltonian, COBYLA as the optimizer, a value of ![p = 1](img/file676.png
    "p = 1") (specified with the `reps` variable), and ![1024](img/file291.png "1024")
    shots.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建并运行一个QAOA Runtime作业，其量子部分将在我们在`options["backend_name"]`字段中指定的量子计算机上执行——在我们的案例中，是`ibmq_belem`。我们使用了![Z_{0}Z_{1}](img/file352.png
    "Z_{0}Z_{1}")哈密顿量，COBYLA作为优化器，一个![p = 1](img/file676.png "p = 1")的值（通过`reps`变量指定），以及![1024](img/file291.png
    "1024")次射击。
- en: We have also chosen the initial values of ![\beta_{1}](img/file684.png "\beta_{1}")
    and ![\gamma_{1}](img/file683.png "\gamma_{1}") to be ![0](img/file12.png "0")
    with the `initial_point` field. If this field is not used, the initial values
    are chosen at random.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还选择了![\beta_{1}](img/file684.png "\beta_{1}")和![\gamma_{1}](img/file683.png
    "\gamma_{1}")的初始值为![0](img/file12.png "0")，使用`initial_point`字段。如果此字段未使用，初始值将随机选择。
- en: 'Once the program has finished running (you can keep track of its execution
    using `job``.``status``()`), the result can be retrieved with `job``.``result``()`.
    We can access some of its parameters with the following instructions:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦程序运行完成（您可以使用`job.status()`跟踪其执行），结果可以通过`job.result()`检索。我们可以使用以下指令访问其一些参数：
- en: '[PRE6]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In our case, running those lines of code offered the following result:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，运行这些代码行得到了以下结果：
- en: '[PRE7]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can appreciate, the results are slightly worse than with the simulator,
    due to the influence of noise. But the two optimal basis states — ![01](img/file159.png
    "01") and ![10](img/file161.png "10") — are still the most probable ones and,
    therefore, if we prepare and measure the final state several times, we will have
    a very high probability of finding an optimal solution.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所欣赏，由于噪声的影响，结果略逊于模拟器。但两个最优基态——![01](img/file159.png "01")和![10](img/file161.png
    "10")——仍然是可能性最大的，因此，如果我们多次准备和测量最终状态，我们找到最优解的概率将非常高。
- en: So now we know how to solve problems with QAOA using Qiskit, both with simulators
    and with actual quantum computers. However, so far, we’ve had to prepare the Hamiltonian
    of the problem ourselves, and that is not ideal. As we learned in *Chapter* *[*3*](ch011.xhtml#x1-590003),
    *Working with Quadratic Unconstrained* *Binary Optimization Problems*, for many
    problems, it is more convenient to work with a QUBO formulation or even to write
    the problem as a binary linear program. Would it be possible to use those formalisms
    directly with QAOA in Qiskit? Absolutely! We’ll show you how in the next subsection.*
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在知道了如何使用 Qiskit 解决 QAOA 问题，无论是使用模拟器还是实际量子计算机。然而，到目前为止，我们不得不自己准备问题的哈密顿量，这并不理想。正如我们在
    *第* *[*3*](ch011.xhtml#x1-590003)，*“与二次无约束* *二进制优化问题一起工作”* 这一章节中学到的，对于许多问题，使用
    QUBO 公式或甚至将问题写成二进制线性规划会更方便。在 Qiskit 中直接使用这些公式的可能性如何？绝对可以！我们将在下一小节中向您展示。
- en: '*## 5.2.2 Solving QUBO problems with QAOA in Qiskit'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '*## 5.2.2 在 Qiskit 中使用 QAOA 解决 QUBO 问题'
- en: Qiskit provides tools to work with quadratic problems, both with and without
    constraints, which are similar to the ones that we studied when working with Ocean
    in *Chapter* *[*4*](ch012.xhtml#x1-750004), *Quantum Adiabatic Computing and Quantum
    Annealing*. For example, we can define a simple binary program with the following
    piece of code:*
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: Qiskit 提供了处理二次问题的工具，无论是带约束还是不带约束，这些工具与我们研究 Ocean 时使用的类似，在 *第* *[*4*](ch012.xhtml#x1-750004)，*“量子绝热计算和量子退火”*
    这一章节中。例如，我们可以使用以下代码定义一个简单的二进制程序：
- en: '*[PRE8]'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE8]'
- en: 'As you can see, we are defining a quadratic problem with three binary variables,
    a function to minimize that has a linear and a quadratic part, and a linear constraint
    in the binary variables. When we run these instructions, we obtain the following
    output:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们正在定义一个具有三个二进制变量的二次问题，一个具有线性部分和二次部分的要最小化的函数，以及一个在二进制变量中的线性约束。当我们运行这些指令时，我们获得以下输出：
- en: '[PRE9]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The problem has exactly the elements that we specified. The only detail that
    may deserve a small explanation is why the quadratic part of the objective function
    is represented as ![\left. (4xy - 8yz)\slash 2 \right.](img/file765.png "\left.
    (4xy - 8yz)\slash 2 \right.") instead of ![2xy - 4yz](img/file766.png "2xy - 4yz").
    The reason for this seemingly odd choice is that, in this way, the matrix with
    the quadratic coefficients can be made symmetric. Instead of having ![2](img/file302.png
    "2") for the ![xy](img/file722.png "xy") coefficient and ![0](img/file12.png "0")
    for the ![yx](img/file767.png "yx") product, the value is duplicated and both
    terms will have ![2](img/file302.png "2") as their coefficient — but then we need
    to divide by ![2](img/file302.png "2") so that the total coefficient remains as
    in the original specification.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 问题恰好包含我们指定的元素。可能需要稍作解释的细节是，为什么目标函数的二次部分被表示为 ![\left. (4xy - 8yz)\slash 2 \right.](img/file765.png
    "\left. (4xy - 8yz)\slash 2 \right.") 而不是 ![2xy - 4yz](img/file766.png "2xy -
    4yz")。这种看似奇怪的选择的原因是，这样可以使具有二次系数的矩阵变得对称。而不是将 ![xy](img/file722.png "xy") 系数的值设为
    ![2](img/file302.png "2") 和 ![yx](img/file767.png "yx") 乘积的值设为 ![0](img/file12.png
    "0")，值被重复，两个项都将有 ![2](img/file302.png "2") 作为它们的系数——但这样我们就需要除以 ![2](img/file302.png
    "2")，以便总系数保持与原始规范一致。
- en: To learn more…
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多…
- en: 'The internal representation of these quadratic problems is the one used by
    CPLEX, an IBM package that is used to solve optimization problems with classical
    methods. You can learn more about CPLEX on its web page: [https://www.ibm.com/products/ilog-cplex-optimization-studio](https://www.ibm.com/products/ilog-cplex-optimization-studio).'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这些二次问题的内部表示是 CPLEX 所使用的，CPLEX 是一个 IBM 包，用于使用经典方法解决优化问题。您可以在其网页上了解更多关于 CPLEX
    的信息：[https://www.ibm.com/products/ilog-cplex-optimization-studio](https://www.ibm.com/products/ilog-cplex-optimization-studio)。
- en: 'Once we have a `QuadraticProgram` object, we can solve it with one of the algorithms
    provided by Qiskit. To achieve this, we can use `MinimumEigenOptimizer` together
    with a concrete solver. For example, we can use a classical exact solver, which
    tries every possible solution and selects the optimal one. In Qiskit, this is
    as simple as using the following instructions:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有一个 `QuadraticProgram` 对象，我们就可以使用 Qiskit 提供的算法之一来解决问题。为了实现这一点，我们可以使用 `MinimumEigenOptimizer`
    与一个具体的求解器一起。例如，我们可以使用一个经典的精确求解器，它尝试每一个可能的解并选择最优解。在 Qiskit 中，这就像使用以下指令一样简单：
- en: '[PRE10]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The result of the execution is as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 执行的结果如下：
- en: '[PRE11]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you can see, we obtain the optimal assignment (![x = 0](img/file768.png "x
    = 0"), ![y = 1](img/file769.png "y = 1") and ![z = 1](img/file770.png "z = 1")),
    the optimal value of the function (in this case, ![- 5](img/file591.png "- 5")),
    and whether the assignment satisfies the constraints, indicated by the `SUCCESS`
    value, or not — if there were no assignments satisfying the constraints, we would
    obtain `INFEASIBLE` as the value for `status`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们获得了最佳分配 (![x = 0](img/file768.png "x = 0")、![y = 1](img/file769.png
    "y = 1") 和 ![z = 1](img/file770.png "z = 1"))，函数的最佳值（在这种情况下，![- 5](img/file591.png
    "- 5")），以及分配是否满足约束，由 `SUCCESS` 值表示，或者不满足——如果没有分配满足约束，我们将会获得 `INFEASIBLE` 作为 `status`
    的值。
- en: 'In a similar way, we can use QAOA to solve the problem with the following instructions:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 以类似的方式，我们可以使用 QAOA 通过以下指令解决问题：
- en: '[PRE12]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In this case, the result will be the same one that we obtained with `NumPyMinimumEigensolver`.
    But we can also obtain additional information with the following instructions:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，结果将与使用 `NumPyMinimumEigensolver` 获得的结果相同。但我们可以通过以下指令获得更多信息：
- en: '[PRE13]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The result will be something like the following:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将类似于以下内容：
- en: '[PRE14]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: First, we have printed the order of variables, to more easily interpret the
    assignments considered by the solver. Then, we have a listing of the different
    solutions that are part of the final, optimal state found by QAOA. Each item of
    the list includes the assignment, the energy or function value, the probability
    of obtaining the corresponding basis state when measuring the QAOA state, and
    whether the solution is feasible or not — `status``=<``OptimizationResultStatus``.``SUCCESS``:`
    `0>` indicates that the solution is feasible, while `status``=<``OptimizationResultStatus``.``INFEASIBLE``:`
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们打印了变量的顺序，以便更容易解释求解器考虑的分配。然后，我们列出了 QAOA 找到的最终最优状态中的不同解决方案。列表中的每一项包括分配、能量或函数值、测量
    QAOA 状态时获得相应基态的概率，以及解决方案是否可行——`status``=<``OptimizationResultStatus``.``SUCCESS``:`
    `0>` 表示解决方案是可行的，而 `status``=<``OptimizationResultStatus``.``INFEASIBLE``:`
- en: '`2>` indicates that it is not.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`2>` 表示它不是。'
- en: Exercise 5.6
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 5.6
- en: 'Modify the code that we have just run to make the results reproducible. *Hint*:
    you can set seeds in the same way that we did in *Section* *[*5.2.1*](#x1-1020005.2.1).*'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 修改我们刚刚运行的代码，以便结果可重复。*提示*：你可以像我们在 *第 5.2.1 节* 中所做的那样设置种子。
- en: '*We can also obtain full information about the QAOA execution by using the
    following:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们还可以通过以下方式获得 QAOA 执行的完整信息：'
- en: '[PRE15]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We would obtain something like the following (where we have truncated part
    of the output):'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将获得类似以下内容（其中我们已截断部分输出）：
- en: '@empty'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '@empty'
- en: '[PRE16]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Notice, however, that these assignments include the auxiliary variables used
    in the transformation from constrained to unconstrained problem, as in the procedure
    that we studied in *Chapter* *[*3*](ch011.xhtml#x1-590003), *Working with Quadratic
    Unconstrained* *Binary Optimization Problems*, and the function values are also
    the ones taken in the transformed problem. In fact, you can obtain the corresponding
    QUBO problem with the following code:*
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，然而，这些分配包括在从约束问题到无约束问题的转换中使用的辅助变量，正如我们在 *第 3 章* 中研究的过程，*处理二次无约束二进制优化问题*，函数值也是转换问题中采用的值。实际上，你可以使用以下代码获得相应的
    QUBO 问题：
- en: '*[PRE17]'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE17]'
- en: 'The output will be the following:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE18]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you can see, this is now a QUBO problem in which slack variables and penalty
    terms have been introduced, exactly as we did in *Chapter* *[*3*](ch011.xhtml#x1-590003),
    *Working* *with Quadratic Unconstrained Binary Optimization Problems*.*
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，这现在是一个 QUBO 问题，其中引入了松弛变量和惩罚项，正如我们在 *第 3 章* 中所做的那样，*处理二次无约束二进制优化问题*。
- en: '*To learn more…'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '*了解更多...'
- en: In the `qiskit_optimization``.` `converters` module, you can also find the functions
    `InequalityToEquality`, `IntegerToBinary`, and `LinearEqualityToPenalty`. The
    `QuadraticProgramToQubo` function calls them to convert quadratic programs with
    constraints into QUBO instances, by first introducing slack variables to transform
    inequalities into equalities, then transforming the integer slack variables into
    binary ones, and finally, replacing the equality constraints with penalty terms.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `qiskit_optimization` 的 `converters` 模块中，你还可以找到 `InequalityToEquality`、`IntegerToBinary`
    和 `LinearEqualityToPenalty` 函数。`QuadraticProgramToQubo` 函数通过首先引入松弛变量将不等式转换为等式，然后将整数松弛变量转换为二进制变量，最后用惩罚项替换等式约束，将具有约束的二次规划转换为
    QUBO 实例。
- en: You may now be wondering how to use `MinimumEigenOptimizer` with a quantum computer
    instead of with a simulator. Of course, when defining the `quantum_instance` parameter
    to use with the `QAOA` object, you can simply declare a real quantum device. But,
    as we have already mentioned, that would imply entering the device queue many
    times, with the consequent delay.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能现在想知道如何使用 `MinimumEigenOptimizer` 与量子计算机而不是与模拟器一起使用。当然，当定义与 `QAOA` 对象一起使用的
    `quantum_instance` 参数时，你可以简单地声明一个真实的量子设备。但是，正如我们已经提到的，那将意味着多次进入设备队列，从而导致延迟。
- en: 'As you surely remember from the previous subsection, if you have a Hamiltonian,
    you can use it directly in a QAOA Runtime program in order to submit your problem
    to the queue just once. So, is it possible to obtain the Hamiltonian of our problem?
    It sure is! You can run the following code to further transform the QUBO problem
    into an equivalent Hamiltonian:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 你肯定还记得从上一个子节中，如果你有一个哈密顿量，你可以在 QAOA 运行时程序中直接使用它，以便一次性将你的问题提交到队列中。那么，我们能否获得我们问题的哈密顿量呢？当然可以！你可以运行以下代码，将
    QUBO 问题进一步转换为等价的哈密顿量：
- en: '[PRE19]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You can then use `H1` to solve the problem with the QAOA Runtime program and
    even recover the energy by adding back the `offset` term. But... that seems like
    a lot of work, doesn’t it? What’s more, you would need to deal with all those
    ugly slack variables that were introduced to transform the quadratic program into
    QUBO form. Surely, there has to be a simpler way.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以使用 `H1` 通过 QAOA 运行时程序解决问题，甚至可以通过添加 `offset` 项来恢复能量。但是……这看起来好像要做很多工作，不是吗？更重要的是，你需要处理所有那些引入来将二次规划转换为
    QUBO 形式的丑陋松弛变量。肯定有更简单的方法。
- en: 'Fortunately, the Qiskit developers are very thoughtful, and they have enabled
    us to use Qiskit Runtime directly with `MinimumEigenOptimizer`. To do that, though,
    you need something called the `QAOAClient`, which will take care of running everything
    smoothly with Runtime once you plug it into `MinimumEigenOptimizer`. Using it
    is as simple as selecting a device with enough qubits. We need at least ![6](img/file576.png
    "6"), so we have selected `ibm_lagos`, which has ![7](img/file465.png "7"); if
    you don’t have access to a big enough device, you can always use `ibmq_qasm_simulator`,
    which supports up to ![32](img/file771.png "32"). And once we have a device, we
    can just run the following instructions:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Qiskit 开发者非常周到，他们已经使我们能够直接使用 Qiskit Runtime 与 `MinimumEigenOptimizer` 一起使用。不过，为了做到这一点，你需要一个叫做
    `QAOAClient` 的东西，它将确保一旦连接到 `MinimumEigenOptimizer`，一切运行顺畅。使用它就像选择一个具有足够量子位的设备一样简单。我们需要至少
    ![6](img/file576.png "6")，所以我们选择了 `ibm_lagos`，它有 ![7](img/file465.png "7")；如果你没有足够大的设备，你总是可以使用
    `ibmq_qasm_simulator`，它支持多达 ![32](img/file771.png "32")。一旦我们有了设备，我们就可以运行以下指令：
- en: '[PRE20]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This will yield the following output:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '[PRE21]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: And, of course, you can obtain further information about the execution, as we
    did in previous examples, by accessing and using the values of the variables `result``.``variables`,
    `result``.``samples`, and `result``.``min_eigen_solver_result`. Very convenient,
    right?
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以通过访问和使用变量 `result``.``variables`、`result``.``samples` 和 `result``.``min_eigen_solver_result`
    的值来获取有关执行情况的更多信息，就像我们在之前的示例中所做的那样。非常方便，对吧？
- en: We have now learned how to work with QAOA in Qiskit and how to manage and solve
    our problems in many different ways. It is time for us to turn back to PennyLane
    and see what it can offer in order to solve our beloved QUBO problems.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经学会了如何在 Qiskit 中使用 QAOA，以及如何以许多不同的方式管理和解决我们的问题。现在是时候回到 PennyLane，看看它能为解决我们心爱的
    QUBO 问题提供什么了。
- en: 5.3 Using QAOA with PennyLane
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.3 使用 PennyLane 的 QAOA
- en: As we mentioned in *Chapter* *[*2*](ch009.xhtml#x1-400002), *The Tools of the
    Trade in Quantum Computing*, PennyLane is a quantum programming library focused
    mainly on quantum machine learning. As such, it doesn’t include as many tools
    for quantum optimization algorithms — such as QAOA — as Qiskit does. However,
    it does provide some interesting features such as automatic differentiation —
    that is, analytical computation of gradients — that may make it an appealing alternative
    to Qiskit in some circumstances.*
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 *第* *[*2*](ch009.xhtml#x1-400002) *章* *[*2*](ch009.xhtml#x1-400002) 中提到的，*量子计算中的工具*，PennyLane
    是一个主要关注量子机器学习的量子编程库。因此，它不像 Qiskit 那样包含许多量子优化算法（如 QAOA）的工具。然而，它确实提供了一些有趣的功能，例如自动微分——即梯度的解析计算——这可能在某些情况下使其成为
    Qiskit 的一个有吸引力的替代品。
- en: '*Let’s begin by explaining how to declare and work with Hamiltonians in PennyLane.
    For that, we will use the `Hamiltonian` class. It provides a constructor that
    accepts a list of coefficients and a list of products of Pauli matrices. For instance,
    if you want to define ![2Z_{0}Z_{1} - Z_{0}Z_{2} + 3.5Z_{1}](img/file772.png "2Z_{0}Z_{1}
    - Z_{0}Z_{2} + 3.5Z_{1}"), you will pass `[2,-1,3.5]` as the first argument and
    `[``PauliZ``(0)``@PauliZ``(1),``PauliZ``(0)``@PauliZ``(2),``PauliZ``(1)]` as the
    second one. As we know from *Chapter* * [*2*](ch009.xhtml#x1-400002), *The Tools
    of the Trade in Quantum Computing*, `PauliZ` is the ![Z](img/file8.png "Z") matrix
    in PennyLane. We are also using the `@` operator, which is PennyLane’s symbol
    for the tensor product operation. Putting it all together, we get the following
    instructions:*'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '*[PRE22]'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: 'The output when we execute that code will be the following:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'As you can see, we have constructed exactly the Hamiltonian that we wanted.
    We can also obtain its matrix by using `print``(``qml``.``matrix``(``H``))`, which
    would give us the following output:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'As expected, this is a diagonal matrix. We can visualize it in a more compact
    way by executing the following instructions, which will give us only the non-zero
    elements:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The result will be the following:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You can also define Hamiltonians in a more compact manner by specifying them
    in a mathematical expression like the following one:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If you print `H`, you will find that this definition is equivalent to the one
    that was introduced previously.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 5.7
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: Use PennyLane to define the ![- 3Z_{0}Z_{1}Z_{2} + 2Z_{1}Z_{2} - Z_{2}](img/file773.png
    "- 3Z_{0}Z_{1}Z_{2} + 2Z_{1}Z_{2} - Z_{2}") Hamiltonian in two different ways.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to define Hamiltonians, we can use them to create QAOA
    circuits with PennyLane. To this end, we will import the `qaoa` module, which
    will give us access to the `cost_layer` and `mixer_layer` functions. We will need
    a cost Hamiltonian — the one that encodes our optimization problem — to use with
    `cost_layer` and we will use ![{\sum}_{j}X_{j}](img/file774.png "{\sum}_{j}X_{j}")
    with `mixer_layer` (in the QAOA literature, our ![H_{0}](img/file545.png "H_{0}")
    Hamiltonian is sometimes called the **mixer Hamiltonian**, hence the name of the
    function). With them, we can create a function that constructs the QAOA circuit
    and that computes the energy of the state prepared by the circuit with respect
    to ![H_{1}](img/file544.png "H_{1}"). This latter part is very easy to accomplish
    with PennyLane, because it provides the `expval` function, which computes exactly
    that, and it can be used instead of the types of measurements that we introduced
    in *Section* * [*2.3.1*](ch009.xhtml#x1-530002.3.1).*
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '*We can, thus, define a function that computes the energy of parameters with
    the following piece of code:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: There are several details that we need to explain here. First, we are working
    with a simple problem in which we want to find the ground state of ![Z_{0}Z_{1}](img/file352.png
    "Z_{0}Z_{1}"). We have defined our ![H_{0}](img/file545.png "H_{0}") Hamiltonian
    as ![X_{0} + X_{1}](img/file775.png "X_{0} + X_{1}") with `H0` `=` `qml``.``PauliX``(0)`
    `+` `qml``.``PauliX``(1)`. For ![H_{1}](img/file544.png "H_{1}"), we have used
    `1.0*``qml``.``PauliZ``(0)` `@` `qml``.``PauliZ``(1)` instead of just `qml``.``PauliZ``(0)`
    `@` `qml``.``PauliZ``(1)`. If you do not include the `1.0` coefficient, the tensor
    product will not be converted to a `Hamiltonian` object, so you should be careful
    with that. Another important detail is that the `energy` function only receives
    as parameters the angles for the rotations in the QAOA circuit and we have declared
    `p` as a global variable. This is because we later want to optimize `energy` with
    respect to its parameters, and `p` is not something that we want to optimize,
    but a fixed value — in this case, we are setting it to ![2](img/file302.png "2").
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, notice that the exponentials for ![H_{1}](img/file544.png "H_{1}")
    and ![H_{0}](img/file545.png "H_{0}") receive their parameters from the `angles`
    list alternating between ![H_{0}](img/file545.png "H_{0}") and ![H_{1}](img/file544.png
    "H_{1}"): first for the ![H_{0}](img/file545.png "H_{0}") exponential (which is
    implemented by `mixer_layer`), then for the ![H_{1}](img/file544.png "H_{1}")
    exponential (implemented by `cost_layer`), then again for the ![H_{0}](img/file545.png
    "H_{0}") exponential, and so on. In the notation that we have been using throughout
    this chapter, if `angles` is `[1.0,2.0.3.0,4.0]`, then we would have ![\beta_{1}
    = 1](img/file753.png "\beta_{1} = 1"), ![\gamma_{1} = 2](img/file776.png "\gamma_{1}
    = 2"), ![\beta_{2} = 3](img/file777.png "\beta_{2} = 3"), and ![\gamma_{2} = 4](img/file756.png
    "\gamma_{2} = 4"). Now we are ready to run the optimization process. To do that,
    we can use the following code:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We are using `GradientDescentOptimizer` as the classical minimizer. It uses
    the famous gradient descent algorithm — we will study this method in detail in
    *Part* *[*III*](ch016.xhtml#x1-138000III) of the book — by taking advantage of
    the fact that PennyLane implements automatic differentiation to compute all the
    required derivatives. That is why we use `requires_grad``=``True` when defining
    the initial angles, to inform PennyLane that these are parameters for which we
    will need to compute gradients. We run the process for 10 steps and…voilá! We
    obtain some (close to) optimal parameters. In this case, `[0.78178403` `0.7203965`
    `1.17250771`*
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '*`1.27995423]` was the answer found by the optimizer. The angles and energy
    that you find can be highly dependent on the initial parameters, so it is advisable
    to run your code with several different choices of initial angles.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: 'In any case, we can now sample from the QAOA circuit with the parameters that
    we have found in order to obtain candidate solutions to our problem. We just need
    to modify slightly the `energy` function that we defined previously. We can do
    it, for instance, as follows:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，我们现在可以从我们找到的参数的QAOA电路中进行采样，以获得我们问题的候选解决方案。我们只需要稍微修改一下之前定义的`energy`函数。例如，我们可以这样做：
- en: '[PRE30]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The output when you run these instructions will be something like the following:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这些指令的输出将类似于以下内容：
- en: '[PRE31]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The five samples are, indeed, ground states of ![Z_{0}Z_{1}](img/file352.png
    "Z_{0}Z_{1}"). Once more, we have been able to use QAOA to solve the problem,
    this time with PennyLane!
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这五个样本确实是![Z_{0}Z_{1}](img/file352.png "Z_{0}Z_{1}")的基态。再一次，我们能够使用QAOA解决这个问题，这次是使用PennyLane！
- en: You surely have noticed that we have run our code on the `default``.``qubit`
    device, which is a simulator. Of course, you can replace it with a quantum device,
    as we learned to do in *Section* *[*2.3.2*](ch009.xhtml#x1-540002.3.2). However,
    this will mean that you will have to wait on the quantum computer execution queue
    every time the optimizer needs to evaluate the energy of some parameters.*
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 你肯定已经注意到，我们已经在`default`的`qubit`设备上运行了我们的代码，这是一个模拟器。当然，你可以用我们学到的在*第* *[*2.3.2*](ch009.xhtml#x1-540002.3.2)
    *节中做的那样，用量子设备来替换它。然而，这意味着每次优化器需要评估某些参数的能量时，你将不得不在量子计算机执行队列上等待。
- en: '*Unfortunately, at the time of writing, PennyLane does not yet include an option
    to run QAOA programs using Qiskit Runtime. However, do not despair! As we will
    learn in *Chapter* *[*7*](ch015.xhtml#x1-1190007)*, VQE: Variational Quantum*
    *Solver*, there is a PennyLane implementation of Runtime programs for some other
    algorithms. Hopefully, QAOA will receive the same treatment soon.*'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '*不幸的是，在撰写本文时，PennyLane还没有包括使用Qiskit Runtime运行QAOA程序的功能。然而，不要绝望！正如我们将在*第* *[*7*](ch015.xhtml#x1-1190007)
    *章中学习到的，VQE：变分量子* *求解器*，PennyLane为一些其他算法提供了一种Runtime程序的实现。希望QAOA很快也会得到同样的待遇。*'
- en: '*With this, we have now concluded our study of QAOA. In the next chapter, we
    will study a different method for finding solutions to optimization problems,
    and it will be based on one of the most famous of all quantum algorithms ever:
    Grover’s algorithm.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '*通过这一点，我们现在已经完成了对QAOA的研究。在下一章中，我们将研究一种不同的方法来寻找优化问题的解决方案，它将基于所有最著名的量子算法之一：Grover算法。'
- en: Summary
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you have learned about QAOA, one of the most popular quantum
    algorithms used to solve optimization problems with gate-based quantum computers.
    You now know that QAOA is derived as a discretization of quantum annealing and
    that it is implemented as a hybrid method that uses both a classical and a quantum
    computer to achieve its goal.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了QAOA，这是用于解决基于门量子计算机的优化问题的最流行的量子算法之一。你现在知道QAOA是从量子退火离散化得到的，并且它被实现为一个混合方法，该方法使用经典计算机和量子计算机来实现其目标。
- en: You also understand how to construct circuits for all the operations needed
    in the quantum part of the algorithm. In particular, you know how to use these
    circuits to estimate expectation values in an efficient way.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 你还理解了如何构建算法量子部分的所需所有操作的电路。特别是，你知道如何使用这些电路以有效的方式估计期望值。
- en: You have also mastered the tools that Qiskit provides in order to implement
    QAOA instances and to run them on both quantum simulators and quantum computers.
    You even know how to accelerate the process of running your code on quantum devices
    by using Qiskit Runtime. And, should you need to use QAOA with PennyLane, you
    also know how to do it with the help of some predefined utilities and PennyLane
    capabilities for automatic differentiation. This gives you the flexibility to
    solve optimization problems with QAOA in a number of different ways, depending
    on your needs and on the resources at your disposal.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经掌握了Qiskit提供的工具，以便实现QAOA实例并在量子模拟器和量子计算机上运行它们。你甚至知道如何使用Qiskit Runtime加速在量子设备上运行你的代码的过程。而且，如果你需要使用PennyLane来执行QAOA，你也知道如何通过一些预定义的实用工具和PennyLane的自动微分能力来实现。这让你可以根据需要和可用的资源以多种不同的方式解决优化问题。
- en: Our next stop will be **Grover’s Adaptive Search**, also known as **GAS**, a
    quite different quantum method that you can use to solve optimization problems,
    which we’ll cover in the next chapter.***********************************
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一步将是**Grover的自适应搜索**，也称为**GAS**，这是一种相当不同的量子方法，你可以用它来解决优化问题，我们将在下一章中介绍。***********************************
