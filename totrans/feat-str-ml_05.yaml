- en: 'Chapter 3: Feature Store Fundamentals, Terminology, and Usage'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter, we discussed the need to bring features into production
    and different ways of doing so, along with a look at common issues with these
    approaches and how feature stores can solve them. We have built up a lot of expectations
    about feature stores, and it's time to understand how they work. As mentioned
    in the last chapter, a feature store is different from a traditional database
    – it is a data storage service for managing machine learning features, a hybrid
    system that can be used for storage and retrieval of historical features for model
    training. It can also serve the latest features at low latency for real-time prediction,
    and at sub-second latency for batch prediction.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will discuss what a feature store is, how it works, and
    the range of terminology used in the feature store world. For this chapter, we
    will use one of the most widely used open source feature stores, called **Feast**.
    The goal of this chapter is for you to understand the basic usage of Feast feature
    store terms and APIs along with gaining a brief understanding of how it works
    internally.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will discuss the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Feast and installation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Feast terminology and definitions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Feast initialization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Feast usage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Feast behind the scenes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To follow the code examples in this chapter, all you need is familiarity with
    Python and any notebook environment, which could be a local setup such as Jupyter
    or an online notebook environment such as Google Colab or Kaggle. You can download
    the code examples for this chapter from the following GitHub link: [https://github.com/PacktPublishing/Feature-Store-for-Machine-Learning/tree/main/Chapter03](https://github.com/PacktPublishing/Feature-Store-for-Machine-Learning/tree/main/Chapter03).'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Feast and installation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Feast** is an open source feature management system for serving and managing
    ML features. It was a collaboration between *Google* and *Gojek*, which was then
    adopted by *Linux Foundation AI and Data*. Feast was initially built for **Google
    Cloud Platform (GCP)**, then extended to run on other cloud platforms like **Amazon
    Web Services (AWS)** and **Microsoft Azure**. Today, you can run Feast on **on-premise**
    infrastructure as well. Cloud agnosticism is the biggest advantage Feast offers
    over other feature stores.'
  prefs: []
  type: TYPE_NORMAL
- en: However, Feast is a self-managed infrastructure. Depending on your organization
    structure, you need a team to create and manage the infrastructure for Feast.
    Another key thing to note here is Feast moved from **Service-Oriented Architecture
    (SOA)** to an **Software Development Kit (SDK)/Command Line Interface (CLI)**
    basis. This enables small teams to quickly install, run, and experiment with Feast
    for projects without spending a lot of time in its initial setup, only to then
    realize Feast isn't the right fit. However, for production environments, engineering
    teams might have to manage multiple infrastructures to run their set of projects.
    There are alternatives to Feast if you are not a fan of self-managed infrastructures.
    These include *Tecton*, which is one of the main contributors to Feast today,
    *SageMaker Feature Store* which is an AWS-managed feature store, *Databricks Feature
    Store,* and more.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we briefly know what Feast is, let's look at the installation. Unlike
    other feature stores that require you to run the service on the cloud or register
    with a cloud provider, Feast can be installed in a notebook environment without
    having to set up any additional services.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command installs the latest version of Feast in your notebook
    environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Yes, that's all you need to do to install and run Feast if you want to try it
    out. However, to collaborate with a team, developer, stage, and production environment,
    the setup involves some additional steps. We will get there in the next set of
    chapters. For now, this is enough to look at the APIs, terminology, and project
    structure.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, let's look at Feast terminology, initialization, and a
    few APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Feast terminology and definitions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: New discoveries in software applications often give birth to new terms or redefine
    some existing terms in the context of the new software. For example, **Directed
    Acyclic Graph (DAG)** in general means a type of graph; whereas in the context
    of Airflow (assuming you're familiar with it), it means defining a collection
    of tasks and their dependencies. Similarly, Feast and the wider feature store
    context have a set of terms that are used frequently. Let's learn what they are
    in this section.
  prefs: []
  type: TYPE_NORMAL
- en: '**Entity**: *An entity is a collection of semantically related features*. Entities
    are domain objects to which the features can be mapped. In a ride-hailing service,
    *customer* and *driver* could be the entities, and features can then be grouped
    with their corresponding entities.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code block is an example of entity definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Entities are part of a feature view, which acts as a primary key in the feature
    ingestion and retrieval process. **Point-in-time** joins and feature lookups can
    be done on primary keys during model training and prediction, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '**Feature**: *A feature is individual measurable property*. *It is typically
    a property observed on a specific entity but does not have to be associated with
    an entity.* For instance, the average time a customer spends on the website could
    be a feature. A non-associated feature could be the number of new customers on
    the website today. The following code block is an example feature definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Features represent the columns of the underlying feature data. As you can see
    in the preceding example, it has `name` and `dtype` properties.
  prefs: []
  type: TYPE_NORMAL
- en: '**Data source**: The data source represents the underlying data. Feast supports
    a range of data sources including **FileSource** (local, S3, GCS), **BigQuery**,
    and **Redshift**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot is an example data source:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – Data source'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18024_03_001.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.1 – Data source
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the preceding figure, the dataset has a `driver_id` entity,
    `trips_today` and `rating` features, and a `timestamp` column. The structure of
    the data in the table you see in *Figure 3.1* is a *Feature view*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Feature view**: A feature view is like a database table, it represents the
    structure of the feature data at its source. A feature view consists of entities,
    one or more features, and the data source. A feature view is generally modeled
    around a domain object similar to databases objects. There are cases where a feature
    view can be entity-less.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code block is an example `FeatureView` definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding code block, `FeatureView` has a `driver` entity,
    `trips_today` and `rating` features, and `BigQuerySource` as the data source.
    Depending on the feature store, Feature view has other synonyms. For instance,
    in SageMaker Feature Store, it is called **Feature Group**, in Databricks Feature
    Store, it is called **Feature Table**, in the older version of Feast, it was called
    a **Feature Set** and **Feature Table**.
  prefs: []
  type: TYPE_NORMAL
- en: '`timestamp` column stores the information of when a particular event occurred
    (that is, when a particular event was produced in the system). Along with this,
    feature stores offer flexibility to add additional columns such as *creation time*,
    *ingest API invocation time*, and more. This enables data scientists and data
    engineers to reproduce the state of a system at any time in the past. To reproduce
    the state in past, the system performs **point-in-time joins**. In Feast, this
    capability is available out of the box as an API. In others, users might have
    to write code for it.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at an example of a point-in-time join in practice. The following
    dataset has a schema that matches the `FeatureView` defined in *Figure 3.1*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – Point-in-time join dataset'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18024_03_002.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.2 – Point-in-time join dataset
  prefs: []
  type: TYPE_NORMAL
- en: 'As you will see in the later section, to fetch historical data you need an
    entity DataFrame like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – Point-in-time join entity DataFrame'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18024_03_003.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.3 – Point-in-time join entity DataFrame
  prefs: []
  type: TYPE_NORMAL
- en: When the user invokes `store.get_historical_features()`, with the entity DataFrame
    in *Figure 3.3* and a feature list, Feast performs a `2022-01-01 23:52:20`. The
    **point-in-time join** looks for the driver features with the latest timestamp.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the **point-in-time join** in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – Point-in-time join'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18024_03_004.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.4 – Point-in-time join
  prefs: []
  type: TYPE_NORMAL
- en: The `FeatureView` is 2 hours. This indicates that features live only for 2 hours
    from the time an event occurs (`event_timestamp + 2 hours` window). The logic
    for point-in-time joins is `timestamp_in_data >= timestamp_in_entity_dataframe`
    and `timestamp_in_entity_dataframe <= timestamp_in_data + ttl (2 hours)`. As you
    can see in *Figure 3.4*, the first row doesn't have a matching window in the data,
    whereas the second, third, and fourth rows of the entity DataFrame have a matching
    window for the events that occurred at `2022-01-02 1:00:00`, `2022-01-01 4:00:00`,
    and `2022-01-01 5:00:00` respectively. Following the same logic, the last row
    in the entity DataFrame doesn't have any matching window in the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output DataFrame of the point-in-time join is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5 – Point-in-time join output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18024_03_005.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.5 – Point-in-time join output
  prefs: []
  type: TYPE_NORMAL
- en: As seen in *Figure 3.5*, for the rows that don't have matching windows, the
    feature values are `NULL`, and for the rows with matching windows, the features
    are available.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, let's learn how to initialize a Feast project, what its
    contents are, and basic API usage.
  prefs: []
  type: TYPE_NORMAL
- en: Feast initialization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s open a new notebook and install a specific version of `feast` and the
    `Pygments` library to get a more nicely formatted view when we look at the files.
    The following code installs the required libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s initialize the Feast project and look through the folder structure and
    files. The following code block initializes a Feast project called `demo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will output the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Let's ignore the warning message in the first line. In the second line, you
    can see where the Feast repo is initialized. If you are using Google Colab you
    will see a similar path, `/content/<repo_name>`; if not, the repo will be created
    in the current working directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand what the `feast init` command did in the background, we need
    to look through the folder that the command created. You can use the left navigation
    bar on Google Colab to look through the files or use the CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.6 – Folder structure'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18024_03_006.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.6 – Folder structure
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 3.6* is the snapshot from Google Colab. As you can see, the `feast
    init` command created a sample project repo for starters. There is a `driver_stats.parquet`
    file in the `data` folder, and a `example.py`, and `feature_store.yaml` file.
    Let''s go through the files and see what''s in them. The simplest file to understand
    is the `driver_stats.parquet` file in the `data` folder. As the folder says, it
    contains sample data for the demo project.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code block loads the dataset in `driver_stats.parquet` and displays
    the first ten rows from it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code block produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.7 – Sample dataset'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18024_03_007.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.7 – Sample dataset
  prefs: []
  type: TYPE_NORMAL
- en: The `driver_stats.parquet` file is a sample feature dataset, as you can see
    in *Figure 3.7*. It contains driver features such as `conv_rate` and `avg_daily_trips`.
    It also has additional columns, such as `event_timestamp` and `created`. These
    are special columns used for performing point-in-time joins, as discussed in the
    previous section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the `feature_store.yaml` file next. The following command prints
    the file content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command outputs the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The `feature_store.yaml` file contains the following variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '`project`: This is the project name. It uses the input of the `feast init`
    command as the project name. We ran `feast init demo`, hence the project name
    is `demo`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`registry`: This variable stores the feature registry path for the project.
    The registry stores all the metadata for the project including `FeatureView`,
    `Entity`, `DataSources`, and more. As you can see, the `registry.db` file doesn''t
    yet exist in the `data` folder. It gets created when we run the `apply` command;
    we will look at it in the *Feast usage* section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`provider`: This variable defines where the feature store is going to run.
    The value is set to `local`, which indicates the infrastructure will be run on
    the local system. The other possible values are `aws`, `gcp`, and more. For `aws`
    and `gcp` providers, additional dependencies need to be installed and additional
    params need to be passed to the `feast init` command.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`online_store`: As the name of the `online_store` param indicates, it is used
    for storing and serving features at low latency. By default, it uses SQLite, but
    Feast offers a variety of options for the online store, from *DynamoDB* to a *custom
    store*. The following page lists the supported options for online stores: [https://docs.feast.dev/roadmap](https://docs.feast.dev/roadmap).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`offline_store`: You don''t see this variable in the `feature_store.yaml` file.
    However, this is another important parameter that is used to set *historical stores*
    from the available options. Again, Feast offers a lot of flexibility here: you
    can choose anything from *file store* to *Snowflake*. The link in the preceding
    bullet has the information on supported offline stores.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other than the ones mentioned previously, each of the variables might include
    some additional setup based on what is chosen for that option. For example, if
    Snowflake is chosen as the offline store, it needs additional inputs like the
    schema name, table name, Snowflake URL, and more.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at what the `example.py` file consists of. The following command
    prints the contents of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command is very lengthy, so instead of looking
    at all the content at once, we''ll break it down into parts. The following code
    block contains the first part of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding block, there are a couple of imports from the installed libraries,
    but what follows the imports is of particular interest to us. The code defines
    a data source of type `FileSource` and provides the path to the sample data in
    *Figure 3.7*. As mentioned earlier, the `event_timestamp_column` and `created_timestamp_column`
    columns are special columns, which indicate when a particular event (row in the
    data) occurred and when the row was ingested into the data source, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code block contains the second part of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code block, a `driver_id` entity is defined along with its
    value type and description.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code block contains the last part of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding block contains a `FeatureView`. The definition contains three
    features, `conv_rate`, `acc_rate`, and `avg_daily_trips`, and uses the `driver_id`
    entity defined in the second part of the file and the `driver_hourly_stats` batch
    source defined in the first part of the file. Apart from these, there are additional
    variables: `ttl`, `online`, and `tags`.  `ttl` defines how long the features live.
    For instance, if you set `ttl` to 60 seconds, it will appear in the retrieval
    for only 60 seconds from the event time. After that, it is considered as an expired
    feature. The `online` variable indicates if the online store is enabled for `FeatureView`
    or not. `Tags` are used to store additional information about `FeatureView` such
    as the team, owner, and more, which may be usable in feature discovery.'
  prefs: []
  type: TYPE_NORMAL
- en: In short, the `example.py` file consists of the entities, feature views, and
    data sources of the `demo` project. This is just a starter template for a demo.
    We can add additional entities, feature views, and data sources.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand the fundamentals and basic project structure, let's familiarize
    ourselves with Feast APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Feast usage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, let's continue in the same notebook in which we initialized
    the `demo` project previously, register the feature view and entities, and use
    the Feast API to retrieve features.
  prefs: []
  type: TYPE_NORMAL
- en: Register feature definitions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following code block registers all the entities and feature views defined
    in the `example.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The output message is straightforward except the last line, where it says `online=True`
    set in the `FeatureView`. The `apply` command creates the `registry.db` and `online_store.db`
    files, which have been set in `feature_store.yaml`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that entities and feature views have been registered, we can connect to
    the feature store and browse through the existing definitions.
  prefs: []
  type: TYPE_NORMAL
- en: Browsing the feature store
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following code connects to the feature store and lists all the entities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code block looks for the `feature_store.yaml` file in the current
    directory and uses the `store.list_entities()` API to get all the entities. Similarly,
    the `store.list_feature_views()` API can be used to get all the available feature
    views. I will leave that as an exercise for you.
  prefs: []
  type: TYPE_NORMAL
- en: Let's add a new entity and feature view to the feature store.
  prefs: []
  type: TYPE_NORMAL
- en: Adding an entity and FeatureView
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To add a new entity and feature view, we need a feature dataset. For now, let's
    produce a synthetic dataset using the `numpy` library and use that as the new
    features for which the entity and feature view need to be defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code generates the synthetic feature data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code generates a dataset with four columns and writes the dataset
    to `/content/demo/data/`. If you are running this on a local system, set the path
    accordingly for the `customer_features.to_parquet` API call, which is highlighted
    in the preceding code block.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding code produces the dataset as shown in *Figure 3.8*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.8 – Synthetic customer data'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18024_03_008.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.8 – Synthetic customer data
  prefs: []
  type: TYPE_NORMAL
- en: The definitions of `Entity` and `FeatureView` for the dataset in *Figure 3.4*
    can be added to the existing `example.py` file, or you can create a new Python
    file and add the lines in the following code block.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code block defines the required `Entity`, `DataSource`, and `FeatureView`
    for the dataset in *Figure 3.8*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: Like the `example.py` file we encountered, this file has the definition for
    the `customer_features` data source, the `customer` entity, and `customer_features_view`.
    Upload the newly created file or updated  `example.py` file to the project root
    directory (the same directory as that of the existing `example.py` file).
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: Don't remove `example.py` or replace the contents, but append new entities to
    the file or upload the new file. After running `feast apply`, you should have
    two entities, `driver_id` and `customer_id`, and two feature views, `driver_hourly_stats`
    and `customer_features`.
  prefs: []
  type: TYPE_NORMAL
- en: 'After uploading/copying the file to the root directory, run the following command
    to apply new definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code block produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: Similar to the output of the previous `apply` command, the output is straightforward.
    If you browse through the feature store again, you will see the updated definitions.
    We will leave that as an exercise for you.
  prefs: []
  type: TYPE_NORMAL
- en: Generate training data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After running the `apply` command in the previous section, the feature store
    contains two entities: `driver_id` and `customer_id`, and two feature views: `driver_hourly_stats`
    and `customer_features`. We can generate training data by querying the historical
    store for either or both of the feature views using the corresponding entities.
    In this example, we will query for the `driver_hourly_stats` feature view. Feel
    free to try out the `get_historical_features` API on `customer_features`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To generate the training data, an entity DataFrame is required. The entity
    DataFrame must have the following two columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '`entity_id`: This is the id of the entity defined in the feature store. For
    instance, to fetch the driver features, you need the `driver_id` column and the
    list of values for which the historical features are required.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`event_timestamp`: A timestamp for each `driver_id` for the point-in-time join.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code block produces an entity DataFrame to fetch driver features:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code produces the following entity DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.9 – Entity DataFrame'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18024_03_009.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.9 – Entity DataFrame
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the entity DataFrame, it is straightforward to fetch the data
    from the historical store. All that is required to do is connect to feature store
    and invoke the `store.get_historical_features()` API with the entity DataFrame
    created in the preceding code block and the list of required features.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code block connects to the feature store and fetches historical
    features for the entities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: You may notice that one of the inputs to the API is a list of features. The
    format of the elements in the list is `<FeatureViewName>:<FeatureName>`. For instance,
    to fetch the `conv_rate` feature, which is part of the `driver_hourly_stats` FeatureView,
    the element in the list would be `driver_hourly_stats:conv_rate`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding code block produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.10 – Get the historical features output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18024_03_010.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.10 – Get the historical features output
  prefs: []
  type: TYPE_NORMAL
- en: Load features to the online store
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The historical data source is used for generating a training dataset, which
    can also be used for prediction in batch models. However, we already know that
    for online models, low-latency feature serving is required. To enable that, it
    is required to fetch the latest features from the historical data source and load
    the features into the online store. This can be done with a single command in
    Feast.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command loads the latest features to the online store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: The command takes a timestamp as one of the inputs, fetches the latest features
    at the time of the input timestamp, and loads the features to the online store.
    In this example, it is a SQLite database.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding line of code outputs the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.11 – Feast materializing the output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18024_03_011.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.11 – Feast materializing the output
  prefs: []
  type: TYPE_NORMAL
- en: Now that the features are available in the online store, they can be fetched
    during model prediction at low latency. The online store can be queried using
    `store.get_online_features()` and passing the features list in the same format
    as that of the list passed for querying historical data.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The `feast materialize-incremental` command will sync all the existing feature
    views to the online store (in this case, SQLite). In the output shown in *Figure
    3.11*, you can see two feature views: `driver_hourly_stats` and `customer_features`.
    You can query either of them. In this example, we are querying `driver_hourly_stats`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code block fetches `conv_rate` and `avg_daily_trips` for drivers
    with `id` values of `1001` and `1004`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code block produces the following output. If the value for a
    specific entity row doesn''t exist, it will return `NULL` values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have learned the Feast fundamentals, it is time to understand briefly
    what's going on behind the scenes to make it work. In the next section, let's
    look at the Feast components and set the stage for incorporating Feast in a project.
  prefs: []
  type: TYPE_NORMAL
- en: Feast behind the scenes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following diagram shows different components that make up the architecture
    of Feast:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.12 – Feast architecture (v0.18)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18024_03_012.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.12 – Feast architecture (v0.18)
  prefs: []
  type: TYPE_NORMAL
- en: 'As seen in the preceding diagram, there are a lot of components involved in
    Feast. Let''s break it down one by one:'
  prefs: []
  type: TYPE_NORMAL
- en: '`data` folder is optional; the `feature_store.yml` file that defines the feature
    store configuration and the `example.py` file that defines the feature definitions
    constitute a feature repo.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`feast apply`), loading features from the offline to the online store (`feast
    materialize`), and providing a great set of APIs for users to browse through Feast
    and query online and offline stores. We used some of the Feast SDK APIs in the
    usage section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Feast Registry**: The Feast registry uses the object store to persist the
    feature definitions, which can be browsed through using the Feast SDK.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Online store**: The online store is a low-latency database used for serving
    the latest features for model prediction. Users can load the latest features or
    query the online store using the Feast SDK. A streaming source can also be used
    for loading features into the online store.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Offline store**: The offline store is used for the storage and retrieval
    of historical data. It is also used for model training and batch scoring. In Feast,
    data in the offline store is user-managed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data flow in Feast
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following steps give an example of the data flow in Feast:'
  prefs: []
  type: TYPE_NORMAL
- en: Data engineers build ETL/data pipelines to generate features and load them to
    an offline store supported by Feast.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Feature definitions are created, the Feast store configuration is defined, and
    the `feast apply` command is run.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Important Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Feature store configuration involves defining the infrastructure details, hence
    it might also involve the creation of the infrastructure as well.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Using the Feast SDK, the data scientist/data engineer connects to the Feast
    repo and generates training data for the model. The model is trained, and if it
    doesn't meet the acceptance criteria, new features may be generated by adding
    an additional data pipeline.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Steps *1-3* will be executed again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Important Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In *step 2*, only new entities and feature definitions need to be added.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Features are loaded from the offline to the online store using the `feast materialize`
    command. This command may be run on schedule to load the latest features using
    an orchestration tool such as **Airflow**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The trained model is packaged along with the Feast SDK code to fetch the required
    feature for model scoring during prediction. The packaged model is deployed to
    production.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: During prediction, the model fetches the required features using the Feast SDK,
    runs the prediction, and returns the results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The offline store can be monitored for data drift to determine whether it's
    time to retrain the model.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's summarize what we learned in this chapter next and move on to using Feast
    in our actual project next.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed the terminology used in the feature store world,
    specifically terminology that relate to *Feast*. However, keep in mind that many
    of the existing feature stores use similar terminology, so if you are familiar
    with one, it is easy to understand the others. We also discussed how the *point-in-time
    join* works in Feast, along with the Feast fundamentals such as installation,
    initialization, project structure, and API usage. Finally, we explored the components
    of Feast and how the operationalization of a model works with Feast.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll use Feast in the model we built in [*Chapter 1*](B18024_01_ePub.xhtml#_idTextAnchor014),
    *An Overview of the Machine Learning Life Cycle*, learn how it changes the way
    data scientists and engineers work, and see how it opens the door to new opportunities
    in feature sharing, monitoring, and easy productionization of our ML models.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Introduction to Feast*: [https://docs.feast.dev/](https://docs.feast.dev/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Overview of Feast*: [https://github.com/feast-dev/feast/blob/v0.18.1/examples/quickstart/quickstart.ipynb](https://github.com/feast-dev/feast/blob/v0.18.1/examples/quickstart/quickstart.ipynb)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
