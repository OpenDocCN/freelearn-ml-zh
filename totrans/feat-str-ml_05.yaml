- en: 'Chapter 3: Feature Store Fundamentals, Terminology, and Usage'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章：特征存储基础、术语和用法
- en: In the last chapter, we discussed the need to bring features into production
    and different ways of doing so, along with a look at common issues with these
    approaches and how feature stores can solve them. We have built up a lot of expectations
    about feature stores, and it's time to understand how they work. As mentioned
    in the last chapter, a feature store is different from a traditional database
    – it is a data storage service for managing machine learning features, a hybrid
    system that can be used for storage and retrieval of historical features for model
    training. It can also serve the latest features at low latency for real-time prediction,
    and at sub-second latency for batch prediction.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了将特征引入生产的需求以及实现这一目标的不同方式，同时审视了这些方法中常见的常见问题以及特征存储如何解决这些问题。我们对特征存储有了很多期望，现在是时候了解它们是如何工作的了。正如上一章所述，特征存储与传统数据库不同——它是一个用于管理机器学习特征的数据存储服务，一个可以用于存储和检索历史特征的混合系统，用于模型训练。它还可以以低延迟提供最新特征进行实时预测，以及以亚秒级延迟进行批量预测。
- en: In this chapter, we will discuss what a feature store is, how it works, and
    the range of terminology used in the feature store world. For this chapter, we
    will use one of the most widely used open source feature stores, called **Feast**.
    The goal of this chapter is for you to understand the basic usage of Feast feature
    store terms and APIs along with gaining a brief understanding of how it works
    internally.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论特征存储是什么，它是如何工作的，以及特征存储领域使用的术语范围。对于本章，我们将使用最广泛使用的开源特征存储之一，称为**Feast**。本章的目标是让你了解Feast特征存储术语和API的基本用法，并简要了解其内部工作原理。
- en: 'In this chapter, we will discuss the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: Introduction to Feast and installation
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Feast简介和安装
- en: Feast terminology and definitions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Feast术语和定义
- en: Feast initialization
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Feast初始化
- en: Feast usage
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Feast使用
- en: Feast behind the scenes
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Feast幕后
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow the code examples in this chapter, all you need is familiarity with
    Python and any notebook environment, which could be a local setup such as Jupyter
    or an online notebook environment such as Google Colab or Kaggle. You can download
    the code examples for this chapter from the following GitHub link: [https://github.com/PacktPublishing/Feature-Store-for-Machine-Learning/tree/main/Chapter03](https://github.com/PacktPublishing/Feature-Store-for-Machine-Learning/tree/main/Chapter03).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随本章中的代码示例，你只需要熟悉Python和任何笔记本环境，这可以是本地设置，如Jupyter，或者在线笔记本环境，如Google Colab或Kaggle。你可以从以下GitHub链接下载本章的代码示例：[https://github.com/PacktPublishing/Feature-Store-for-Machine-Learning/tree/main/Chapter03](https://github.com/PacktPublishing/Feature-Store-for-Machine-Learning/tree/main/Chapter03)。
- en: Introduction to Feast and installation
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Feast简介和安装
- en: '**Feast** is an open source feature management system for serving and managing
    ML features. It was a collaboration between *Google* and *Gojek*, which was then
    adopted by *Linux Foundation AI and Data*. Feast was initially built for **Google
    Cloud Platform (GCP)**, then extended to run on other cloud platforms like **Amazon
    Web Services (AWS)** and **Microsoft Azure**. Today, you can run Feast on **on-premise**
    infrastructure as well. Cloud agnosticism is the biggest advantage Feast offers
    over other feature stores.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**Feast**是一个开源的特征管理系统，用于提供和管理机器学习特征。它是*Google*和*Gojek*之间的合作成果，随后被*Linux Foundation
    AI and Data*采用。Feast最初是为**Google Cloud Platform (GCP)**构建的，后来扩展到可以在其他云平台如**Amazon
    Web Services (AWS)**和**Microsoft Azure**上运行。如今，你还可以在**本地**基础设施上运行Feast。云无关性是Feast相较于其他特征存储提供的最大优势。'
- en: However, Feast is a self-managed infrastructure. Depending on your organization
    structure, you need a team to create and manage the infrastructure for Feast.
    Another key thing to note here is Feast moved from **Service-Oriented Architecture
    (SOA)** to an **Software Development Kit (SDK)/Command Line Interface (CLI)**
    basis. This enables small teams to quickly install, run, and experiment with Feast
    for projects without spending a lot of time in its initial setup, only to then
    realize Feast isn't the right fit. However, for production environments, engineering
    teams might have to manage multiple infrastructures to run their set of projects.
    There are alternatives to Feast if you are not a fan of self-managed infrastructures.
    These include *Tecton*, which is one of the main contributors to Feast today,
    *SageMaker Feature Store* which is an AWS-managed feature store, *Databricks Feature
    Store,* and more.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Feast 是一个自管理的基础设施。根据您的组织结构，您需要一个团队来创建和管理 Feast 的基础设施。在此需要注意的是，Feast 从 **面向服务的架构（SOA**）转变为基于
    **软件开发工具包（SDK）/命令行界面（CLI**）。这使得小型团队能够快速安装、运行和实验 Feast，而无需花费大量时间在初始设置上，结果却发现 Feast
    并不适合。然而，对于生产环境，工程团队可能需要管理多个基础设施来运行其项目集。如果您不喜欢自管理基础设施，Feast 有其他替代方案。这包括 *Tecton*，它是
    Feast 当前的主要贡献者之一，*SageMaker Feature Store*，这是一个 AWS 管理的功能存储，*Databricks Feature
    Store* 以及更多。
- en: Now that we briefly know what Feast is, let's look at the installation. Unlike
    other feature stores that require you to run the service on the cloud or register
    with a cloud provider, Feast can be installed in a notebook environment without
    having to set up any additional services.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们简要了解了 Feast 是什么，让我们看看安装过程。与其他需要您在云上运行服务或注册云提供商的其他功能存储不同，Feast 可以在笔记本环境中安装，无需设置任何额外的服务。
- en: 'The following command installs the latest version of Feast in your notebook
    environment:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令将在您的笔记本环境中安装 Feast 的最新版本：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Yes, that's all you need to do to install and run Feast if you want to try it
    out. However, to collaborate with a team, developer, stage, and production environment,
    the setup involves some additional steps. We will get there in the next set of
    chapters. For now, this is enough to look at the APIs, terminology, and project
    structure.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，如果您想尝试它，安装和运行 Feast 您只需做这么多。然而，要与团队、开发者、预发布环境和生产环境协作，设置将涉及一些额外的步骤。我们将在下一组章节中介绍。现在，查看
    API、术语和项目结构已经足够了。
- en: In the next section, let's look at Feast terminology, initialization, and a
    few APIs.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨 Feast 术语、初始化和一些 API。
- en: Feast terminology and definitions
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Feast 术语和定义
- en: New discoveries in software applications often give birth to new terms or redefine
    some existing terms in the context of the new software. For example, **Directed
    Acyclic Graph (DAG)** in general means a type of graph; whereas in the context
    of Airflow (assuming you're familiar with it), it means defining a collection
    of tasks and their dependencies. Similarly, Feast and the wider feature store
    context have a set of terms that are used frequently. Let's learn what they are
    in this section.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件应用的新发现中，常常会诞生新的术语，或者在新的软件背景下重新定义一些现有的术语。例如，**有向无环图（DAG**）在一般情况下意味着一种图类型；而在
    Airflow 的背景下（假设您已经熟悉它），它意味着定义一组任务及其依赖关系。同样，Feast 和更广泛的功能存储背景下有一系列常用的术语。让我们在本节中学习它们是什么。
- en: '**Entity**: *An entity is a collection of semantically related features*. Entities
    are domain objects to which the features can be mapped. In a ride-hailing service,
    *customer* and *driver* could be the entities, and features can then be grouped
    with their corresponding entities.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**实体**：*实体是一组语义相关的特征集合*。实体是特征可以映射到的域对象。在打车服务中，*客户*和*司机*可以是实体，然后特征可以与相应的实体分组。'
- en: 'The following code block is an example of entity definition:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块是实体定义的示例：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Entities are part of a feature view, which acts as a primary key in the feature
    ingestion and retrieval process. **Point-in-time** joins and feature lookups can
    be done on primary keys during model training and prediction, respectively.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 实体是功能视图的一部分，在功能摄取和检索过程中充当主键。在模型训练和预测期间，可以在主键上执行**时间点**连接和特征查找。
- en: '**Feature**: *A feature is individual measurable property*. *It is typically
    a property observed on a specific entity but does not have to be associated with
    an entity.* For instance, the average time a customer spends on the website could
    be a feature. A non-associated feature could be the number of new customers on
    the website today. The following code block is an example feature definition:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**特征**：*特征是一个可测量的单个属性*。*它通常是观察特定实体的属性，但不必与实体相关联*。例如，客户在网站上平均花费的时间可以是一个特征。一个非关联的特征可以是今天网站上新增客户的数量。以下代码块是一个特征定义的示例：'
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Features represent the columns of the underlying feature data. As you can see
    in the preceding example, it has `name` and `dtype` properties.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 特征代表底层特征数据的列。如您在前面的示例中看到的，它有 `name` 和 `dtype` 属性。
- en: '**Data source**: The data source represents the underlying data. Feast supports
    a range of data sources including **FileSource** (local, S3, GCS), **BigQuery**,
    and **Redshift**.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据源**：数据源代表底层数据。Feast 支持一系列数据源，包括 **FileSource**（本地、S3、GCS）、**BigQuery**
    和 **Redshift**。'
- en: 'The following screenshot is an example data source:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图是一个数据源的示例：
- en: '![Figure 3.1 – Data source'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.1 – 数据源'
- en: '](img/B18024_03_001.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18024_03_001.jpg)'
- en: Figure 3.1 – Data source
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1 – 数据源
- en: As you can see in the preceding figure, the dataset has a `driver_id` entity,
    `trips_today` and `rating` features, and a `timestamp` column. The structure of
    the data in the table you see in *Figure 3.1* is a *Feature view*.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在前面的图中看到的，数据集有一个 `driver_id` 实体，`trips_today` 和 `rating` 特征，以及一个 `timestamp`
    列。您在 *图 3.1* 中看到的表格数据结构是一个 *特征视图*。
- en: '**Feature view**: A feature view is like a database table, it represents the
    structure of the feature data at its source. A feature view consists of entities,
    one or more features, and the data source. A feature view is generally modeled
    around a domain object similar to databases objects. There are cases where a feature
    view can be entity-less.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**特征视图**：特征视图类似于数据库表，它表示特征数据在其源处的结构。特征视图由实体、一个或多个特征和数据源组成。特征视图通常围绕一个类似于数据库对象的领域对象进行建模。在某些情况下，特征视图可以是无实体的。'
- en: 'The following code block is an example `FeatureView` definition:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块是一个 `FeatureView` 定义的示例：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you can see in the preceding code block, `FeatureView` has a `driver` entity,
    `trips_today` and `rating` features, and `BigQuerySource` as the data source.
    Depending on the feature store, Feature view has other synonyms. For instance,
    in SageMaker Feature Store, it is called **Feature Group**, in Databricks Feature
    Store, it is called **Feature Table**, in the older version of Feast, it was called
    a **Feature Set** and **Feature Table**.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在前面的代码块中看到的，`FeatureView` 有一个 `driver` 实体，`trips_today` 和 `rating` 特征，以及 `BigQuerySource`
    作为数据源。根据特征存储库的不同，特征视图有其他同义词。例如，在 SageMaker Feature Store 中，它被称为 **Feature Group**，在
    Databricks Feature Store 中，它被称为 **Feature Table**，在 Feast 的旧版本中，它被称为 **Feature
    Set** 和 **Feature Table**。
- en: '`timestamp` column stores the information of when a particular event occurred
    (that is, when a particular event was produced in the system). Along with this,
    feature stores offer flexibility to add additional columns such as *creation time*,
    *ingest API invocation time*, and more. This enables data scientists and data
    engineers to reproduce the state of a system at any time in the past. To reproduce
    the state in past, the system performs **point-in-time joins**. In Feast, this
    capability is available out of the box as an API. In others, users might have
    to write code for it.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`timestamp` 列存储特定事件发生的信息（即，特定事件在系统中产生的时间）。此外，特征存储库提供灵活性，可以添加额外的列，如 *创建时间*、*摄取
    API 调用时间* 等。这使得数据科学家和数据工程师能够在过去任何时间重现系统的状态。为了在过去重现状态，系统执行 **时刻点连接**。在 Feast 中，此功能作为
    API 原生提供。在其他系统中，用户可能需要编写代码来实现它。'
- en: Let's look at an example of a point-in-time join in practice. The following
    dataset has a schema that matches the `FeatureView` defined in *Figure 3.1*.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个实际中时刻点连接的例子。以下数据集的模式与 *图 3.1* 中定义的 `FeatureView` 匹配。
- en: '![Figure 3.2 – Point-in-time join dataset'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.2 – 时刻点连接数据集'
- en: '](img/B18024_03_002.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18024_03_002.jpg)'
- en: Figure 3.2 – Point-in-time join dataset
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2 – 时刻点连接数据集
- en: 'As you will see in the later section, to fetch historical data you need an
    entity DataFrame like the following:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在后面的部分中，您将看到，要获取历史数据，您需要一个类似于以下内容的实体 DataFrame：
- en: '![Figure 3.3 – Point-in-time join entity DataFrame'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.3 – 时刻点连接实体 DataFrame'
- en: '](img/B18024_03_003.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18024_03_003.jpg)'
- en: Figure 3.3 – Point-in-time join entity DataFrame
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3 – 时刻点连接实体 DataFrame
- en: When the user invokes `store.get_historical_features()`, with the entity DataFrame
    in *Figure 3.3* and a feature list, Feast performs a `2022-01-01 23:52:20`. The
    **point-in-time join** looks for the driver features with the latest timestamp.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户调用 `store.get_historical_features()` 时，带有 *图 3.3* 中的实体 DataFrame 和特征列表，Feast
    执行 `2022-01-01 23:52:20` 的操作。**时刻点连接** 寻找具有最新时间戳的驾驶员特征。
- en: 'The following screenshot shows the **point-in-time join** in action:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了 **时刻点连接** 的实际操作：
- en: '![Figure 3.4 – Point-in-time join'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.4 – 时刻点连接'
- en: '](img/B18024_03_004.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18024_03_004.jpg)'
- en: Figure 3.4 – Point-in-time join
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4 – 时刻点连接
- en: The `FeatureView` is 2 hours. This indicates that features live only for 2 hours
    from the time an event occurs (`event_timestamp + 2 hours` window). The logic
    for point-in-time joins is `timestamp_in_data >= timestamp_in_entity_dataframe`
    and `timestamp_in_entity_dataframe <= timestamp_in_data + ttl (2 hours)`. As you
    can see in *Figure 3.4*, the first row doesn't have a matching window in the data,
    whereas the second, third, and fourth rows of the entity DataFrame have a matching
    window for the events that occurred at `2022-01-02 1:00:00`, `2022-01-01 4:00:00`,
    and `2022-01-01 5:00:00` respectively. Following the same logic, the last row
    in the entity DataFrame doesn't have any matching window in the data.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`FeatureView` 的有效期为 2 小时。这表示特征从事件发生时起（`event_timestamp + 2 hours` 窗口）只存活 2
    小时。时刻点连接的逻辑是 `timestamp_in_data >= timestamp_in_entity_dataframe` 和 `timestamp_in_entity_dataframe
    <= timestamp_in_data + ttl (2 hours)`。如 *图 3.4* 所示，第一行在数据中没有匹配的窗口，而实体 DataFrame
    的第二、三、四行分别对应于 `2022-01-02 1:00:00`、`2022-01-01 4:00:00` 和 `2022-01-01 5:00:00`
    发生的事件的匹配窗口。按照相同的逻辑，实体 DataFrame 的最后一行在数据中没有匹配的窗口。'
- en: 'The output DataFrame of the point-in-time join is as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 时刻点连接的输出 DataFrame 如下：
- en: '![Figure 3.5 – Point-in-time join output'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.5 – 时刻点连接输出'
- en: '](img/B18024_03_005.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18024_03_005.jpg)'
- en: Figure 3.5 – Point-in-time join output
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5 – 时刻点连接输出
- en: As seen in *Figure 3.5*, for the rows that don't have matching windows, the
    feature values are `NULL`, and for the rows with matching windows, the features
    are available.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如 *图 3.5* 所见，对于没有匹配窗口的行，特征值是 `NULL`，而对于有匹配窗口的行，特征是可用的。
- en: In the next section, let's learn how to initialize a Feast project, what its
    contents are, and basic API usage.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何初始化一个 Feast 项目，了解其内容以及基本 API 使用。
- en: Feast initialization
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Feast 初始化
- en: 'Let''s open a new notebook and install a specific version of `feast` and the
    `Pygments` library to get a more nicely formatted view when we look at the files.
    The following code installs the required libraries:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开一个新的笔记本，安装 `feast` 和 `Pygments` 库的特定版本，以便在查看文件时获得更美观的格式。以下代码安装所需的库：
- en: '[PRE17]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let''s initialize the Feast project and look through the folder structure and
    files. The following code block initializes a Feast project called `demo`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们初始化 Feast 项目并查看文件夹结构和文件。以下代码块初始化了一个名为 `demo` 的 Feast 项目：
- en: '[PRE19]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The preceding code will output the following lines:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将输出以下行：
- en: '[PRE20]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Let's ignore the warning message in the first line. In the second line, you
    can see where the Feast repo is initialized. If you are using Google Colab you
    will see a similar path, `/content/<repo_name>`; if not, the repo will be created
    in the current working directory.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们忽略第一行的警告信息。在第二行，你可以看到 Feast 仓库的初始化位置。如果你使用 Google Colab，你会看到类似的路径，`/content/<repo_name>`；如果不是，仓库将创建在当前工作目录中。
- en: 'To understand what the `feast init` command did in the background, we need
    to look through the folder that the command created. You can use the left navigation
    bar on Google Colab to look through the files or use the CLI:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解 `feast init` 命令在后台执行了什么，我们需要查看该命令创建的文件夹。你可以使用 Google Colab 的左侧导航栏查看文件或使用
    CLI：
- en: '![Figure 3.6 – Folder structure'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.6 – 文件夹结构'
- en: '](img/B18024_03_006.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18024_03_006.jpg)'
- en: Figure 3.6 – Folder structure
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.6 – 文件夹结构
- en: '*Figure 3.6* is the snapshot from Google Colab. As you can see, the `feast
    init` command created a sample project repo for starters. There is a `driver_stats.parquet`
    file in the `data` folder, and a `example.py`, and `feature_store.yaml` file.
    Let''s go through the files and see what''s in them. The simplest file to understand
    is the `driver_stats.parquet` file in the `data` folder. As the folder says, it
    contains sample data for the demo project.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3.6* 是Google Colab的快照。正如你所见，`feast init`命令为初学者创建了一个示例项目仓库。`data`文件夹中有一个`driver_stats.parquet`文件，以及一个`example.py`和一个`feature_store.yaml`文件。让我们查看这些文件，看看它们里面有什么。最容易理解的文件是`data`文件夹中的`driver_stats.parquet`文件。正如文件夹所说，它包含演示项目的示例数据。'
- en: 'The following code block loads the dataset in `driver_stats.parquet` and displays
    the first ten rows from it:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块加载了`driver_stats.parquet`中的数据集，并显示其前十行：
- en: '[PRE22]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The preceding code block produces the following output:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个代码块产生了以下输出：
- en: '![Figure 3.7 – Sample dataset'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.7 – 示例数据集'
- en: '](img/B18024_03_007.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B18024_03_007.jpg]'
- en: Figure 3.7 – Sample dataset
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.7 – 示例数据集
- en: The `driver_stats.parquet` file is a sample feature dataset, as you can see
    in *Figure 3.7*. It contains driver features such as `conv_rate` and `avg_daily_trips`.
    It also has additional columns, such as `event_timestamp` and `created`. These
    are special columns used for performing point-in-time joins, as discussed in the
    previous section.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`driver_stats.parquet`文件是一个示例特征数据集，正如你在*图 3.7* 中所见。它包含驾驶员特征，如`conv_rate`和`avg_daily_trips`。它还有额外的列，如`event_timestamp`和`created`。这些是用于执行点时间连接的特殊列，如前所述。'
- en: 'Let''s look at the `feature_store.yaml` file next. The following command prints
    the file content:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看下一个`feature_store.yaml`文件。以下命令会打印文件内容：
- en: '[PRE25]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The preceding command outputs the following:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个命令输出了以下内容：
- en: '[PRE26]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `feature_store.yaml` file contains the following variables:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`feature_store.yaml`文件包含以下变量：'
- en: '`project`: This is the project name. It uses the input of the `feast init`
    command as the project name. We ran `feast init demo`, hence the project name
    is `demo`.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`project`：这是项目名称。它使用`feast init`命令的输入作为项目名称。我们运行了`feast init demo`，因此项目名称是`demo`。'
- en: '`registry`: This variable stores the feature registry path for the project.
    The registry stores all the metadata for the project including `FeatureView`,
    `Entity`, `DataSources`, and more. As you can see, the `registry.db` file doesn''t
    yet exist in the `data` folder. It gets created when we run the `apply` command;
    we will look at it in the *Feast usage* section.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`registry`：这个变量存储了项目的特征注册表路径。注册表存储了项目的所有元数据，包括`FeatureView`、`Entity`、`DataSources`等。正如你所见，`registry.db`文件在`data`文件夹中尚未存在。它在运行`apply`命令时创建；我们将在*Feast使用*部分查看它。'
- en: '`provider`: This variable defines where the feature store is going to run.
    The value is set to `local`, which indicates the infrastructure will be run on
    the local system. The other possible values are `aws`, `gcp`, and more. For `aws`
    and `gcp` providers, additional dependencies need to be installed and additional
    params need to be passed to the `feast init` command.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`provider`：这个变量定义了特征存储将要运行的位置。值设置为`local`，表示基础设施将在本地系统上运行。其他可能的值包括`aws`、`gcp`等。对于`aws`和`gcp`提供者，需要安装额外的依赖项，并且需要向`feast
    init`命令传递额外的参数。'
- en: '`online_store`: As the name of the `online_store` param indicates, it is used
    for storing and serving features at low latency. By default, it uses SQLite, but
    Feast offers a variety of options for the online store, from *DynamoDB* to a *custom
    store*. The following page lists the supported options for online stores: [https://docs.feast.dev/roadmap](https://docs.feast.dev/roadmap).'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`online_store`：正如`online_store`参数的名称所暗示的，它用于以低延迟存储和提供特征。默认情况下，它使用SQLite，但Feast为在线存储提供了各种选项，从*DynamoDB*到*自定义存储*。以下页面列出了在线存储的支持选项：[https://docs.feast.dev/roadmap](https://docs.feast.dev/roadmap)。'
- en: '`offline_store`: You don''t see this variable in the `feature_store.yaml` file.
    However, this is another important parameter that is used to set *historical stores*
    from the available options. Again, Feast offers a lot of flexibility here: you
    can choose anything from *file store* to *Snowflake*. The link in the preceding
    bullet has the information on supported offline stores.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`offline_store`：你不会在`feature_store.yaml`文件中看到这个变量。然而，这是另一个重要的参数，用于从提供的选项中设置*历史存储*。同样，Feast在这里提供了很多灵活性：你可以从*文件存储*到*Snowflake*中选择任何东西。上一个项目符号中的链接包含了关于支持离线存储的信息。'
- en: Other than the ones mentioned previously, each of the variables might include
    some additional setup based on what is chosen for that option. For example, if
    Snowflake is chosen as the offline store, it needs additional inputs like the
    schema name, table name, Snowflake URL, and more.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 除了之前提到的之外，每个变量可能还包括基于所选选项的一些额外设置。例如，如果选择 Snowflake 作为离线存储，则需要额外的输入，如模式名称、表名称、Snowflake
    URL 等。
- en: 'Let''s look at what the `example.py` file consists of. The following command
    prints the contents of the file:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `example.py` 文件包含什么。以下命令打印了文件的内容：
- en: '[PRE31]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The output of the preceding command is very lengthy, so instead of looking
    at all the content at once, we''ll break it down into parts. The following code
    block contains the first part of the file:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 前述命令的输出非常长，所以我们不会一次性查看所有内容，而是将其分解成几个部分。以下代码块包含了文件的第一个部分：
- en: '[PRE32]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In the preceding block, there are a couple of imports from the installed libraries,
    but what follows the imports is of particular interest to us. The code defines
    a data source of type `FileSource` and provides the path to the sample data in
    *Figure 3.7*. As mentioned earlier, the `event_timestamp_column` and `created_timestamp_column`
    columns are special columns, which indicate when a particular event (row in the
    data) occurred and when the row was ingested into the data source, respectively.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，有一些来自已安装库的导入，但导入之后的部分对我们特别感兴趣。代码定义了一个类型为 `FileSource` 的数据源，并提供了 *图
    3.7* 中样本数据的路径。如前所述，`event_timestamp_column` 和 `created_timestamp_column` 列是特殊列，分别指示特定事件（数据中的行）发生的时间和行被摄入数据源的时间。
- en: 'The following code block contains the second part of the file:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块包含了文件的第二个部分：
- en: '[PRE41]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In the preceding code block, a `driver_id` entity is defined along with its
    value type and description.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，定义了一个 `driver_id` 实体及其值类型和描述。
- en: 'The following code block contains the last part of the file:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块包含了文件的最后一部分：
- en: '[PRE45]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The preceding block contains a `FeatureView`. The definition contains three
    features, `conv_rate`, `acc_rate`, and `avg_daily_trips`, and uses the `driver_id`
    entity defined in the second part of the file and the `driver_hourly_stats` batch
    source defined in the first part of the file. Apart from these, there are additional
    variables: `ttl`, `online`, and `tags`.  `ttl` defines how long the features live.
    For instance, if you set `ttl` to 60 seconds, it will appear in the retrieval
    for only 60 seconds from the event time. After that, it is considered as an expired
    feature. The `online` variable indicates if the online store is enabled for `FeatureView`
    or not. `Tags` are used to store additional information about `FeatureView` such
    as the team, owner, and more, which may be usable in feature discovery.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码块包含一个 `FeatureView`。定义包含三个特征，`conv_rate`、`acc_rate` 和 `avg_daily_trips`，并使用文件第二部分中定义的
    `driver_id` 实体和文件第一部分中定义的 `driver_hourly_stats` 批次源。除此之外，还有额外的变量：`ttl`、`online`
    和 `tags`。`ttl` 定义了特征存活的时间长度。例如，如果你将 `ttl` 设置为 60 秒，它将从事件时间开始只出现在检索中 60 秒。之后，它被视为已过期的特征。`online`
    变量指示是否为 `FeatureView` 启用了在线存储。`Tags` 用于存储有关 `FeatureView` 的额外信息，如团队、所有者等，这些信息可能在特征发现中可用。
- en: In short, the `example.py` file consists of the entities, feature views, and
    data sources of the `demo` project. This is just a starter template for a demo.
    We can add additional entities, feature views, and data sources.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，`example.py` 文件包含了 `demo` 项目的实体、特征视图和数据源。这只是一个用于演示的起始模板。我们可以添加额外的实体、特征视图和数据源。
- en: Now that we understand the fundamentals and basic project structure, let's familiarize
    ourselves with Feast APIs.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了基础知识以及基本项目结构，让我们熟悉一下 Feast API。
- en: Feast usage
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Feast 使用
- en: In this section, let's continue in the same notebook in which we initialized
    the `demo` project previously, register the feature view and entities, and use
    the Feast API to retrieve features.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，让我们继续在之前初始化 `demo` 项目的同一个笔记本中，注册特征视图和实体，并使用 Feast API 检索特征。
- en: Register feature definitions
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注册特征定义
- en: 'The following code block registers all the entities and feature views defined
    in the `example.py` file:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块注册了在 `example.py` 文件中定义的所有实体和特征视图：
- en: '[PRE60]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The preceding code produces the following output:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码产生以下输出：
- en: '[PRE62]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The output message is straightforward except the last line, where it says `online=True`
    set in the `FeatureView`. The `apply` command creates the `registry.db` and `online_store.db`
    files, which have been set in `feature_store.yaml`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 输出信息很简单，除了最后一行，它说在`FeatureView`中设置了`online=True`。`apply`命令创建了`registry.db`和`online_store.db`文件，这些文件已在`feature_store.yaml`中设置。
- en: Now that entities and feature views have been registered, we can connect to
    the feature store and browse through the existing definitions.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在实体和特征视图已经注册，我们可以连接到特征存储并浏览现有的定义。
- en: Browsing the feature store
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 浏览特征存储
- en: 'The following code connects to the feature store and lists all the entities:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码连接到特征存储并列出所有实体：
- en: '[PRE66]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The preceding code block looks for the `feature_store.yaml` file in the current
    directory and uses the `store.list_entities()` API to get all the entities. Similarly,
    the `store.list_feature_views()` API can be used to get all the available feature
    views. I will leave that as an exercise for you.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码块在当前目录中查找`feature_store.yaml`文件，并使用`store.list_entities()` API获取所有实体。同样，可以使用`store.list_feature_views()`
    API获取所有可用的特征视图。我将把这留给你作为练习。
- en: Let's add a new entity and feature view to the feature store.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在特征存储中添加一个新的实体和特征视图。
- en: Adding an entity and FeatureView
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加实体和特征视图
- en: To add a new entity and feature view, we need a feature dataset. For now, let's
    produce a synthetic dataset using the `numpy` library and use that as the new
    features for which the entity and feature view need to be defined.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加一个新的实体和特征视图，我们需要一个特征数据集。目前，让我们使用`numpy`库生成一个合成数据集，并将其作为需要定义实体和特征视图的新特征。
- en: 'The following code generates the synthetic feature data:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码生成合成特征数据：
- en: '[PRE70]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: The preceding code generates a dataset with four columns and writes the dataset
    to `/content/demo/data/`. If you are running this on a local system, set the path
    accordingly for the `customer_features.to_parquet` API call, which is highlighted
    in the preceding code block.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码生成一个包含四个列的数据集，并将数据集写入`/content/demo/data/`。如果你在本地系统上运行此代码，请相应地设置`customer_features.to_parquet`
    API调用的路径，该路径在上述代码块中被突出显示。
- en: 'The preceding code produces the dataset as shown in *Figure 3.8*:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码生成了*图3.8*中所示的数据集：
- en: '![Figure 3.8 – Synthetic customer data'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.8 – 合成客户数据'
- en: '](img/B18024_03_008.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18024_03_008.jpg)'
- en: Figure 3.8 – Synthetic customer data
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.8 – 合成客户数据
- en: The definitions of `Entity` and `FeatureView` for the dataset in *Figure 3.4*
    can be added to the existing `example.py` file, or you can create a new Python
    file and add the lines in the following code block.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3.4*中数据集的`Entity`和`FeatureView`的定义可以添加到现有的`example.py`文件中，或者你可以创建一个新的Python文件并添加以下代码块中的行。'
- en: 'The following code block defines the required `Entity`, `DataSource`, and `FeatureView`
    for the dataset in *Figure 3.8*:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块定义了*图3.8*中数据集所需的`Entity`、`DataSource`和`FeatureView`：
- en: '[PRE88]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Like the `example.py` file we encountered, this file has the definition for
    the `customer_features` data source, the `customer` entity, and `customer_features_view`.
    Upload the newly created file or updated  `example.py` file to the project root
    directory (the same directory as that of the existing `example.py` file).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们遇到的`example.py`文件一样，这个文件包含了`customer_features`数据源、`customer`实体和`customer_features_view`的定义。上传新创建的文件或更新的`example.py`文件到项目根目录（与现有`example.py`文件相同的目录）。
- en: Important Note
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Don't remove `example.py` or replace the contents, but append new entities to
    the file or upload the new file. After running `feast apply`, you should have
    two entities, `driver_id` and `customer_id`, and two feature views, `driver_hourly_stats`
    and `customer_features`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 不要删除`example.py`或替换其内容，但向文件中追加新实体或上传新文件。运行`feast apply`后，你应该有两个实体`driver_id`和`customer_id`，以及两个特征视图`driver_hourly_stats`和`customer_features`。
- en: 'After uploading/copying the file to the root directory, run the following command
    to apply new definitions:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 将文件上传/复制到根目录后，运行以下命令以应用新定义：
- en: '[PRE114]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'The preceding code block produces the following output:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码块生成了以下输出：
- en: '[PRE115]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: Similar to the output of the previous `apply` command, the output is straightforward.
    If you browse through the feature store again, you will see the updated definitions.
    We will leave that as an exercise for you.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一个`apply`命令的输出类似，输出很简单。如果你再次浏览特征存储，你会看到更新的定义。我们将把这留给你作为练习。
- en: Generate training data
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成训练数据
- en: 'After running the `apply` command in the previous section, the feature store
    contains two entities: `driver_id` and `customer_id`, and two feature views: `driver_hourly_stats`
    and `customer_features`. We can generate training data by querying the historical
    store for either or both of the feature views using the corresponding entities.
    In this example, we will query for the `driver_hourly_stats` feature view. Feel
    free to try out the `get_historical_features` API on `customer_features`.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节运行 `apply` 命令后，特征存储包含两个实体：`driver_id` 和 `customer_id`，以及两个特征视图：`driver_hourly_stats`
    和 `customer_features`。我们可以通过查询历史存储中的任一或两个特征视图来生成训练数据，使用相应的实体。在本例中，我们将查询 `driver_hourly_stats`
    特征视图。请随意尝试使用 `get_historical_features` API 在 `customer_features` 上。
- en: 'To generate the training data, an entity DataFrame is required. The entity
    DataFrame must have the following two columns:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成训练数据，需要一个实体 DataFrame。实体 DataFrame 必须有以下两个列：
- en: '`entity_id`: This is the id of the entity defined in the feature store. For
    instance, to fetch the driver features, you need the `driver_id` column and the
    list of values for which the historical features are required.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`entity_id`：这是在特征存储中定义的实体的 id。例如，要获取司机特征，你需要 `driver_id` 列以及需要的历史特征的值列表。'
- en: '`event_timestamp`: A timestamp for each `driver_id` for the point-in-time join.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`event_timestamp`：每个 `driver_id` 的点时间戳，用于点时间戳连接。'
- en: 'The following code block produces an entity DataFrame to fetch driver features:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块产生一个实体 DataFrame 以获取司机特征：
- en: '[PRE118]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'The preceding code produces the following entity DataFrame:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 上一代码块产生以下实体 DataFrame：
- en: '![Figure 3.9 – Entity DataFrame'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.9 – 实体 DataFrame'
- en: '](img/B18024_03_009.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18024_03_009.jpg)'
- en: Figure 3.9 – Entity DataFrame
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.9 – 实体 DataFrame
- en: Once you have the entity DataFrame, it is straightforward to fetch the data
    from the historical store. All that is required to do is connect to feature store
    and invoke the `store.get_historical_features()` API with the entity DataFrame
    created in the preceding code block and the list of required features.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了实体 DataFrame，从历史存储中获取数据就很简单了。所需做的只是连接到特征存储，并使用在上一代码块中创建的实体 DataFrame 和所需特征的列表调用
    `store.get_historical_features()` API。
- en: 'The following code block connects to the feature store and fetches historical
    features for the entities:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块连接到特征存储并获取实体的历史特征：
- en: '[PRE133]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: You may notice that one of the inputs to the API is a list of features. The
    format of the elements in the list is `<FeatureViewName>:<FeatureName>`. For instance,
    to fetch the `conv_rate` feature, which is part of the `driver_hourly_stats` FeatureView,
    the element in the list would be `driver_hourly_stats:conv_rate`.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到 API 的一个输入是一个特征列表。列表中元素的格式是 `<FeatureViewName>:<FeatureName>`。例如，要获取
    `conv_rate` 特征，它是 `driver_hourly_stats` 特征视图的一部分，列表中的元素将是 `driver_hourly_stats:conv_rate`。
- en: 'The preceding code block produces the following output:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块产生以下输出：
- en: '![Figure 3.10 – Get the historical features output'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.10 – 获取历史特征输出'
- en: '](img/B18024_03_010.jpg)'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18024_03_010.jpg)'
- en: Figure 3.10 – Get the historical features output
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.10 – 获取历史特征输出
- en: Load features to the online store
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将特征加载到在线商店
- en: The historical data source is used for generating a training dataset, which
    can also be used for prediction in batch models. However, we already know that
    for online models, low-latency feature serving is required. To enable that, it
    is required to fetch the latest features from the historical data source and load
    the features into the online store. This can be done with a single command in
    Feast.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 历史数据源用于生成训练数据集，这也可以用于批量模型的预测。然而，我们已经知道对于在线模型，需要低延迟的特征服务。为了启用这一点，需要从历史数据源获取最新特征并将特征加载到在线商店。这可以通过
    Feast 的单个命令完成。
- en: 'The following command loads the latest features to the online store:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令将最新特征加载到在线商店：
- en: '[PRE143]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: The command takes a timestamp as one of the inputs, fetches the latest features
    at the time of the input timestamp, and loads the features to the online store.
    In this example, it is a SQLite database.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 命令接受一个时间戳作为输入之一，获取输入时间戳时的最新特征，并将特征加载到在线商店。在本例中，它是一个 SQLite 数据库。
- en: 'The preceding line of code outputs the following information:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 上一行代码输出以下信息：
- en: '![Figure 3.11 – Feast materializing the output'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.11 – Feast 实现输出'
- en: '](img/B18024_03_011.jpg)'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18024_03_011.jpg)'
- en: Figure 3.11 – Feast materializing the output
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.11 – Feast 实现输出
- en: Now that the features are available in the online store, they can be fetched
    during model prediction at low latency. The online store can be queried using
    `store.get_online_features()` and passing the features list in the same format
    as that of the list passed for querying historical data.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 现在特征已在线存储中可用，它们可以在模型预测期间以低延迟进行检索。可以使用`store.get_online_features()`查询在线存储，并传递与查询历史数据时传递的列表格式相同的特征列表。
- en: Important Note
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'The `feast materialize-incremental` command will sync all the existing feature
    views to the online store (in this case, SQLite). In the output shown in *Figure
    3.11*, you can see two feature views: `driver_hourly_stats` and `customer_features`.
    You can query either of them. In this example, we are querying `driver_hourly_stats`.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '`feast materialize-incremental`命令将所有现有的特征视图同步到在线存储（在这种情况下，SQLite）。在*图3.11*的输出中，你可以看到两个特征视图：`driver_hourly_stats`和`customer_features`。你可以查询其中的任何一个。在这个例子中，我们正在查询`driver_hourly_stats`。'
- en: 'The following code block fetches `conv_rate` and `avg_daily_trips` for drivers
    with `id` values of `1001` and `1004`:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块检索具有`id`值为`1001`和`1004`的司机的`conv_rate`和`avg_daily_trips`：
- en: '[PRE144]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '[PRE152]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '[PRE154]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[PRE155]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'The preceding code block produces the following output. If the value for a
    specific entity row doesn''t exist, it will return `NULL` values:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码块产生以下输出。如果特定实体行的值不存在，它将返回`NULL`值：
- en: '[PRE156]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '[PRE157]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[PRE158]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: Now that we have learned the Feast fundamentals, it is time to understand briefly
    what's going on behind the scenes to make it work. In the next section, let's
    look at the Feast components and set the stage for incorporating Feast in a project.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了Feast的基本知识，是时候简要了解幕后发生的事情以使其工作。在下一节中，我们将查看Feast组件并为在项目中集成Feast做好准备。
- en: Feast behind the scenes
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Feast幕后
- en: 'The following diagram shows different components that make up the architecture
    of Feast:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了构成Feast架构的不同组件：
- en: '![Figure 3.12 – Feast architecture (v0.18)'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.12 – Feast架构（v0.18）'
- en: '](img/B18024_03_012.jpg)'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18024_03_012.jpg)'
- en: Figure 3.12 – Feast architecture (v0.18)
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.12 – Feast架构（v0.18）
- en: 'As seen in the preceding diagram, there are a lot of components involved in
    Feast. Let''s break it down one by one:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，Feast中涉及许多组件。让我们逐一分析：
- en: '`data` folder is optional; the `feature_store.yml` file that defines the feature
    store configuration and the `example.py` file that defines the feature definitions
    constitute a feature repo.'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data`文件夹是可选的；定义特征存储配置的`feature_store.yml`文件和定义特征定义的`example.py`文件构成了一个特征仓库。'
- en: '`feast apply`), loading features from the offline to the online store (`feast
    materialize`), and providing a great set of APIs for users to browse through Feast
    and query online and offline stores. We used some of the Feast SDK APIs in the
    usage section.'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`feast apply`（从离线存储加载特征到在线存储），以及提供一套优秀的API供用户浏览Feast和查询在线和离线存储。我们在使用部分使用了Feast
    SDK的一些API。
- en: '**Feast Registry**: The Feast registry uses the object store to persist the
    feature definitions, which can be browsed through using the Feast SDK.'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Feast注册表**：Feast注册表使用对象存储来持久化特征定义，这些定义可以通过Feast SDK进行浏览。'
- en: '**Online store**: The online store is a low-latency database used for serving
    the latest features for model prediction. Users can load the latest features or
    query the online store using the Feast SDK. A streaming source can also be used
    for loading features into the online store.'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在线存储**：在线存储是一个低延迟数据库，用于为模型预测提供最新特征。用户可以使用Feast SDK加载最新特征或查询在线存储。也可以使用流源将特征加载到在线存储中。'
- en: '**Offline store**: The offline store is used for the storage and retrieval
    of historical data. It is also used for model training and batch scoring. In Feast,
    data in the offline store is user-managed.'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**离线存储**：离线存储用于存储和检索历史数据。它还用于模型训练和批量评分。在Feast中，离线存储中的数据由用户管理。'
- en: Data flow in Feast
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Feast中的数据流
- en: 'The following steps give an example of the data flow in Feast:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤给出了Feast中的数据流示例：
- en: Data engineers build ETL/data pipelines to generate features and load them to
    an offline store supported by Feast.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据工程师构建ETL/数据管道以生成特征并将它们加载到Feast支持的离线存储中。
- en: Feature definitions are created, the Feast store configuration is defined, and
    the `feast apply` command is run.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建特征定义，定义Feast存储配置，并运行`feast apply`命令。
- en: Important Note
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 重要提示
- en: Feature store configuration involves defining the infrastructure details, hence
    it might also involve the creation of the infrastructure as well.
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 特征存储配置涉及定义基础设施细节，因此也可能涉及基础设施的创建。
- en: Using the Feast SDK, the data scientist/data engineer connects to the Feast
    repo and generates training data for the model. The model is trained, and if it
    doesn't meet the acceptance criteria, new features may be generated by adding
    an additional data pipeline.
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Feast SDK，数据科学家/数据工程师连接到Feast仓库，并为模型生成训练数据。模型被训练，如果它不符合接受标准，可以通过添加额外的数据管道生成新特征。
- en: Steps *1-3* will be executed again.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 步骤 *1-3* 将会再次执行。
- en: Important Note
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 重要提示
- en: In *step 2*, only new entities and feature definitions need to be added.
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 *步骤 2* 中，只需添加新的实体和特征定义。
- en: Features are loaded from the offline to the online store using the `feast materialize`
    command. This command may be run on schedule to load the latest features using
    an orchestration tool such as **Airflow**.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `feast materialize` 命令将特征从离线存储加载到在线存储。此命令可以安排在计划中运行，以使用如 **Airflow** 这样的编排工具加载最新特征。
- en: The trained model is packaged along with the Feast SDK code to fetch the required
    feature for model scoring during prediction. The packaged model is deployed to
    production.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 训练好的模型与Feast SDK代码一起打包，以便在预测期间获取模型评分所需的特征。打包的模型被部署到生产环境中。
- en: During prediction, the model fetches the required features using the Feast SDK,
    runs the prediction, and returns the results.
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在预测期间，模型使用Feast SDK获取所需的特征，运行预测，并返回结果。
- en: The offline store can be monitored for data drift to determine whether it's
    time to retrain the model.
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以监控离线存储以确定是否是重新训练模型的时候了。
- en: Let's summarize what we learned in this chapter next and move on to using Feast
    in our actual project next.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们接下来总结本章所学的内容，并继续在我们的实际项目中使用Feast。
- en: Summary
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed the terminology used in the feature store world,
    specifically terminology that relate to *Feast*. However, keep in mind that many
    of the existing feature stores use similar terminology, so if you are familiar
    with one, it is easy to understand the others. We also discussed how the *point-in-time
    join* works in Feast, along with the Feast fundamentals such as installation,
    initialization, project structure, and API usage. Finally, we explored the components
    of Feast and how the operationalization of a model works with Feast.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了特征存储世界中使用的术语，特别是与 *Feast* 相关的术语。然而，请注意，许多现有的特征存储使用类似的术语，所以如果你熟悉其中一个，理解其他的就很容易了。我们还讨论了Feast中的
    *时间点连接* 如何工作，以及Feast的基本知识，如安装、初始化、项目结构和API使用。最后，我们探讨了Feast的组件以及模型在Feast中的操作化工作原理。
- en: In the next chapter, we'll use Feast in the model we built in [*Chapter 1*](B18024_01_ePub.xhtml#_idTextAnchor014),
    *An Overview of the Machine Learning Life Cycle*, learn how it changes the way
    data scientists and engineers work, and see how it opens the door to new opportunities
    in feature sharing, monitoring, and easy productionization of our ML models.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将使用我们在 [*第1章*](B18024_01_ePub.xhtml#_idTextAnchor014) 中构建的模型，即 *机器学习生命周期概述*，学习它如何改变数据科学家和工程师的工作方式，并看看它如何为特征共享、监控以及我们ML模型的简单生产化打开新的大门。
- en: Further reading
  id: totrans-335
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Introduction to Feast*: [https://docs.feast.dev/](https://docs.feast.dev/)'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Feast简介*: [https://docs.feast.dev/](https://docs.feast.dev/)'
- en: '*Overview of Feast*: [https://github.com/feast-dev/feast/blob/v0.18.1/examples/quickstart/quickstart.ipynb](https://github.com/feast-dev/feast/blob/v0.18.1/examples/quickstart/quickstart.ipynb)'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Feast概述*: [https://github.com/feast-dev/feast/blob/v0.18.1/examples/quickstart/quickstart.ipynb](https://github.com/feast-dev/feast/blob/v0.18.1/examples/quickstart/quickstart.ipynb)'
