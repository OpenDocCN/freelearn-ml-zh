["```py\nimport cv2\nimport numpy as np\n\nimg = cv2.imread('input.jpg')\nrows, cols = img.shape[:2]\n\nkernel_identity = np.array([[0,0,0], [0,1,0], [0,0,0]])\nkernel_3x3 = np.ones((3,3), np.float32) / 9.0\nkernel_5x5 = np.ones((5,5), np.float32) / 25.0\n\ncv2.imshow('Original', img)\n\noutput = cv2.filter2D(img, -1, kernel_identity)\ncv2.imshow('Identity filter', output)\n\noutput = cv2.filter2D(img, -1, kernel_3x3)\ncv2.imshow('3x3 filter', output)\n\noutput = cv2.filter2D(img, -1, kernel_5x5)\ncv2.imshow('5x5 filter', output)\n\ncv2.waitKey(0)\n```", "```py\noutput = cv2.blur(img, (3,3))\n```", "```py\nimport cv2\nimport numpy as np\n\nimg = cv2.imread('input_shapes.png', cv2.IMREAD_GRAYSCALE)\nrows, cols = img.shape\n\nsobel_horizontal = cv2.Sobel(img, cv2.CV_64F, 1, 0, ksize=5)\nsobel_vertical = cv2.Sobel(img, cv2.CV_64F, 0, 1, ksize=5)\n\ncv2.imshow('Original', img)\ncv2.imshow('Sobel horizontal', sobel_horizontal)\ncv2.imshow('Sobel vertical', sobel_vertical)\n\ncv2.waitKey(0)\n```", "```py\nlaplacian = cv2.Laplacian(img, cv2.CV_64F)\n```", "```py\ncanny = cv2.Canny(img, 50, 240)\n```", "```py\nimport cv2\nimport numpy as np\n\nimg = cv2.imread('input.jpg')\ncv2.imshow('Original', img)\n\nsize = 15\n\n# generating the kernel\nkernel_motion_blur = np.zeros((size, size))\nkernel_motion_blur[int((size-1)/2), :] = np.ones(size)\nkernel_motion_blur = kernel_motion_blur / size\n\n# applying the kernel to the input image\noutput = cv2.filter2D(img, -1, kernel_motion_blur)\n\ncv2.imshow('Motion Blur', output)\ncv2.waitKey(0)\n```", "```py\nimport cv2\nimport numpy as np\n\nimg = cv2.imread('input.jpg')\ncv2.imshow('Original', img)\n\n# generating the kernels\nkernel_sharpen_1 = np.array([[-1,-1,-1], [-1,9,-1], [-1,-1,-1]])\nkernel_sharpen_2 = np.array([[1,1,1], [1,-7,1], [1,1,1]])\nkernel_sharpen_3 = np.array([[-1,-1,-1,-1,-1],\n                             [-1,2,2,2,-1],\n                             [-1,2,8,2,-1],\n                             [-1,2,2,2,-1],\n                             [-1,-1,-1,-1,-1]]) / 8.0\n\n# applying different kernels to the input image\noutput_1 = cv2.filter2D(img, -1, kernel_sharpen_1)\noutput_2 = cv2.filter2D(img, -1, kernel_sharpen_2)\noutput_3 = cv2.filter2D(img, -1, kernel_sharpen_3)\n\ncv2.imshow('Sharpening', output_1)\ncv2.imshow('Excessive Sharpening', output_2)\ncv2.imshow('Edge Enhancement', output_3)\ncv2.waitKey(0)\n```", "```py\nimport cv2\nimport numpy as np\n\nimg_emboss_input = cv2.imread('input.jpg')\n\n# generating the kernels\nkernel_emboss_1 = np.array([[0,-1,-1],\n                            [1,0,-1],\n                            [1,1,0]])\nkernel_emboss_2 = np.array([[-1,-1,0],\n                            [-1,0,1],\n                            [0,1,1]])\nkernel_emboss_3 = np.array([[1,0,0],\n                            [0,0,0],\n                            [0,0,-1]])\n\n# converting the image to grayscale\ngray_img = cv2.cvtColor(img_emboss_input,cv2.COLOR_BGR2GRAY)\n\n# applying the kernels to the grayscale image and adding the offset\noutput_1 = cv2.filter2D(gray_img, -1, kernel_emboss_1) + 128\noutput_2 = cv2.filter2D(gray_img, -1, kernel_emboss_2) + 128\noutput_3 = cv2.filter2D(gray_img, -1, kernel_emboss_3) + 128\n\ncv2.imshow('Input', img_emboss_input)\ncv2.imshow('Embossing - South West', output_1)\ncv2.imshow('Embossing - South East', output_2)\ncv2.imshow('Embossing - North West', output_3)\ncv2.waitKey(0)\n```", "```py\nimport cv2\nimport numpy as np\n\nimg = cv2.imread('input.png', 0)\n\nkernel = np.ones((5,5), np.uint8)\n\nimg_erosion = cv2.erode(img, kernel, iterations=1)\nimg_dilation = cv2.dilate(img, kernel, iterations=1)\n\ncv2.imshow('Input', img)\ncv2.imshow('Erosion', img_erosion)\ncv2.imshow('Dilation', img_dilation)\n\ncv2.waitKey(0)\n```", "```py\nimport cv2\nimport numpy as np\n\nimg = cv2.imread('input.jpg')\nrows, cols = img.shape[:2]\n\n# generating vignette mask using Gaussian kernels\nkernel_x = cv2.getGaussianKernel(cols,200)\nkernel_y = cv2.getGaussianKernel(rows,200)\nkernel = kernel_y * kernel_x.T\nmask = 255 * kernel / np.linalg.norm(kernel)\noutput = np.copy(img)\n\n# applying the mask to each channel in the input image\nfor i in range(3):\n    output[:,:,i] = output[:,:,i] * mask\n\ncv2.imshow('Original', img)\ncv2.imshow('Vignette', output)\ncv2.waitKey(0)\n```", "```py\n mask = 255 * kernel / np.linalg.norm(kernel)\n```", "```py\nimport cv2\nimport numpy as np\n\nimg = cv2.imread('input.jpg')\nrows, cols = img.shape[:2]\n\n# generating vignette mask using Gaussian kernels\nkernel_x = cv2.getGaussianKernel(int(1.5*cols),200)\nkernel_y = cv2.getGaussianKernel(int(1.5*rows),200)\nkernel = kernel_y * kernel_x.T\nmask = 255 * kernel / np.linalg.norm(kernel)\nmask = mask[int(0.5*rows):, int(0.5*cols):]\noutput = np.copy(img)\n\n# applying the mask to each channel in the input image\nfor i in range(3):\n    output[:,:,i] = output[:,:,i] * mask\n\ncv2.imshow('Input', img)\ncv2.imshow('Vignette with shifted focus', output)\n\ncv2.waitKey(0)\n```", "```py\nimport cv2\nimport numpy as np\n\nimg = cv2.imread('input.jpg', 0)\n\n# equalize the histogram of the input image\nhisteq = cv2.equalizeHist(img)\n\ncv2.imshow('Input', img)\ncv2.imshow('Histogram equalized', histeq)\ncv2.waitKey(0)\n```", "```py\nimport cv2\nimport numpy as np\n\nimg = cv2.imread('input.jpg')\n\nimg_yuv = cv2.cvtColor(img, cv2.COLOR_BGR2YUV)\n\n# equalize the histogram of the Y channel\nimg_yuv[:,:,0] = cv2.equalizeHist(img_yuv[:,:,0])\n\n# convert the YUV image back to RGB format\nimg_output = cv2.cvtColor(img_yuv, cv2.COLOR_YUV2BGR)\n\ncv2.imshow('Color input image', img)\ncv2.imshow('Histogram equalized', img_output)\n\ncv2.waitKey(0)\n```"]