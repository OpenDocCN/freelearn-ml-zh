["```py\nMat src1 = imread(\"stuff.jpg\", CV_LOAD_IMAGE_GRAYSCALE);\nuchar pixel1=src1.at<uchar>(0,0);\ncout << \"First pixel: \" << (unsigned int)pixel1 << endl;\nMat src2 = imread(\"stuff.jpg\", CV_LOAD_IMAGE_COLOR);\nVec3b pixel2 = src2.at<Vec3b>(0,0);\ncout << \"First pixel (B):\" << (unsigned int)pixel2[0] << endl;\ncout << \"First pixel (G):\" << (unsigned int)pixel2[1] << endl;\ncout << \"First pixel (R):\" << (unsigned int)pixel2[2] << endl;\n```", "```py\nSize siz=src.size();\ncout << \"width: \" << siz.width << endl;\ncout << \"height: \" << siz.height << endl;\n```", "```py\nint nc=src.channels();\n```", "```py\nint d=src.depth();\n```", "```py\nsrc.setTo(0); //for one-channel src\n```", "```py\nsrc.setTo(Scalar(b,g,r)); // for three-channel src\n```", "```py\nMat dst=src.clone();\n```", "```py\nsrc.copy(dst, mask);\n```", "```py\nMat dst=src(Range(r1,r2),Range(c1,c2));\n```", "```py\nRect roi(r1,c2, width, height);\nMat dst=src(roi).clone();\n```", "```py\n#include \"opencv2/imgproc/imgproc.hpp\" // a dedicated include file\n#include \"opencv2/highgui/highgui.hpp\"\n#include <iostream>\n\nusing namespace cv;\nusing namespace std;\n\nint main( int argc, char *argv[])\n{\n    int histSize = 255;\n\n    long int dim;\n    Mat hist, image;\n\n    //Read original image\n    Mat src = imread( \"fruits.jpg\");\n\n    //Convert color image to gray level image\n    cvtColor(src, image, CV_RGB2GRAY);\n\n    //Create three windows\n    namedWindow(\"Source\", 0);\n    namedWindow(\"Gray Level Image\", 0);\n    namedWindow(\"Histogram\", WINDOW_AUTOSIZE);\n\n    imshow(\"Source\", src);\n    imshow(\"Gray Level Image\", image);\n\n calcHist(&image, 1, 0, Mat(), hist, 1, &histSize, 0);\n\n    dim=image.rows *image.cols;\n    Mat histImage = Mat::ones(255, 255, CV_8U)*255;\n\n    normalize(hist, hist, 0, histImage.rows, CV_MINMAX, CV_32F);\n\n    histImage = Scalar::all(255);\n    int binW = cvRound((double)histImage.cols/histSize);\n\n    for( int i = 0; i < histSize; i++ )\n    rectangle( histImage, Point(i*binW, histImage.rows), Point((i+1)*binW, histImage.rows – cvRound(hist.at<float>(i))), Scalar::all(0), -1, 8, 0 );\n    imshow(\"Histogram\", histImage);\n\n    cout << \"Press any key to exit...\\n\";\n    waitKey(); // Wait for key press\n    return 0;\n}\n```", "```py\n#include \"opencv2/highgui/highgui.hpp\"\n#include \"opencv2/imgproc/imgproc.hpp\"\n#include <iostream>\n#include <stdio.h>\n\nusing namespace cv;\nusing namespace std;\n\nint main( int, char *argv[] )\n{\n  Mat src, image, hist;\n  int histSize = 255;\n  long int dim;\n\n  //Read original image\n  src = imread( \"fruits.jpg\");\n\n  //Convert to grayscale\n  cvtColor( src, src, COLOR_BGR2GRAY );\n\n  //Apply Histogram Equalization\n equalizeHist( src, image );\n\n  //Display results\n  namedWindow(\"Source image\", 0 );\n  namedWindow(\"Equalized Image\", 0 );\n\n  imshow( \"Source image\", src );\n  imshow( \"Equalized Image\", image );\n\n  //Calculate Histogram of the Equalized Image and display\n  calcHist(&image, 1, 0, Mat(), hist, 1, &histSize, 0);\n  dim=image.rows *image.cols;\n  Mat histImage = Mat::ones(255, 255, CV_8U)*255;\n  normalize(hist, hist, 0, histImage.rows, CV_MINMAX, CV_32F);\n  histImage = Scalar::all(255);\n  int binW = cvRound((double)histImage.cols/histSize);\n\n  for( int i = 0; i < histSize; i++ )\n  rectangle( histImage, Point(i*binW, histImage.rows), Point((i+1)*binW, histImage.rows – cvRound(hist.at<float>(i))), Scalar::all(0), -1, 8, 0 );\n\n  namedWindow(\"Histogram Equalized Image\", WINDOW_AUTOSIZE);\n  imshow(\"Histogram Equalized Image\", histImage);\n\n  waitKey();// Exits the program\n  return 0;\n}\n```", "```py\n#include \"opencv2/imgproc/imgproc.hpp\"\n#include \"opencv2/highgui/highgui.hpp\"\n\n#include <iostream>\n\nusing namespace cv;\nusing namespace std;\n\nint init_brightness  = 100;\nint init_contrast = 100;\n\nMat image;\n\n/* brightness and contrast function to highlight the image*/\nvoid updateBrightnessContrast(int, void* )\n{\n    int histSize = 255;\n    int var_brightness = init_brightness  - 100;\n    int var_contrast = init_contrast - 100;\n\n    double a, b;\n    if( var_contrast > 0 )\n    {\n        double delta = 127.*var_contrast/100;\n        a = 255./(255\\. - delta*2);\n        b = a*(var_brightness - delta);\n    }\n    else\n    {\n        double delta = -128.*var_contrast/100;\n        a = (256.-delta*2)/255.;\n        b = a*var_brightness + delta;\n    }\n\n    Mat dst, hist;\n\n    image.convertTo(dst, CV_8U, a, b);\n\n    imshow(\"image\", dst);\n\n    calcHist(&dst, 1, 0, Mat(), hist, 1, &histSize, 0);\n    Mat histImage = Mat::ones(200, 320, CV_8U)*255;\n\n    normalize(hist, hist, 0, histImage.rows, CV_MINMAX, CV_32F);\n\n    histImage = Scalar::all(255);\n    int binW = cvRound((double)histImage.cols/histSize);\n\n    for( int i = 0; i < histSize; i++ )\n        rectangle( histImage, Point(i*binW, histImage.rows), Point((i+1)*binW, histImage.rows – cvRound(hist.at<float>(i))), Scalar::all(0), -1, 8, 0 );\n       imshow(\"histogram\", histImage);\n   }\n\nconst char* keys = {\n    \"{1| |fruits.jpg|input image file}\"\n};\n\nint main( int argc, const char** argv )\n    {\n        CommandLineParser parser(argc, argv, keys);\n        string inputImage = parser.get<string>(\"1\");\n\n        //Read the input image.\n        image = imread( inputImage, 0 );\n        namedWindow(\"image\", 0);\n        namedWindow(\"histogram\", 0);\n\n        createTrackbar(\"brightness\", \"image\", &init_brightness , 200, updateBrightnessContrast);\n        createTrackbar(\"contrast\", \"image\", &init_contrast, 200, updateBrightnessContrast);\n\n        updateBrightnessContrast(0, 0);\n\n    waitKey();\n    return 0;\n}\n```", "```py\n#include \"opencv2/opencv.hpp\"\n#include <iostream>\n\nusing namespace std;\nusing namespace cv;\n\nvoid histMatch(const Mat &reference, const Mat &target, Mat &result){\n    float const HISTMATCH = 0.000001;\n    double min, max;\n\n    vector<Mat> ref_channels;\n    split(reference, ref_channels);\n    vector<Mat> tgt_channels;\n    split(target, tgt_channels);\n\n    int histSize = 256;\n    float range[] = {0, 256};\n    const float* histRange = { range };\n    bool uniform = true;\n\n    //For every channel (B, G, R)\n    for ( int i=0 ; i<3 ; i++ )\n    {\n         Mat ref_hist, tgt_hist;\n         Mat ref_hist_accum, tgt_hist_accum;\n\n        //Calculate histograms\n calcHist(&ref_channels[i], 1, 0, Mat(), ref_hist, 1, &histSize, &histRange, uniform, false);\n calcHist(&tgt_channels[i], 1, 0, Mat(), tgt_hist, 1, &histSize, &histRange, uniform, false);\n\n        //Normalize histograms\n        minMaxLoc(ref_hist, &min, &max);\n        if (max==0) continue;\n        ref_hist = ref_hist / max;\n        minMaxLoc(tgt_hist, &min, &max);\n        if (max==0) continue;\n        tgt_hist = tgt_hist / max;\n\n        //Calculate accumulated histograms\n        ref_hist.copyTo(ref_hist_accum);\n        tgt_hist.copyTo(tgt_hist_accum);\n\n        float * src_cdf_data = ref_hist_accum.ptr<float>();\n        float * dst_cdf_data = tgt_hist_accum.ptr<float>();\n\n        for ( int j=1 ; j < 256 ; j++ )\n        {\n            src_cdf_data[j] = src_cdf_data[j] + src_cdf_data[j-1];\n            dst_cdf_data[j] = dst_cdf_data[j] + dst_cdf_data[j-1];\n        }\n        //Normalize accumulated\n        minMaxLoc(ref_hist_accum, &min, &max);\n        ref_hist_accum = ref_hist_accum / max;\n        minMaxLoc(tgt_hist_accum, &min, &max);\n        tgt_hist_accum = tgt_hist_accum / max;\n\n        //Result max\n        Mat Mv(1, 256, CV_8UC1);\n        uchar * M = Mv.ptr<uchar>();\n        uchar last = 0;\n        for ( int j=0 ; j < tgt_hist_accum.rows ; j++ )\n        {\n            float F1 = dst_cdf_data[j];\n\n            for ( uchar k=last ; k < ref_hist_accum.rows ; k++ )\n            {\n                float F2 = src_cdf_data[k];\n                if ( std::abs(F2 - F1) < HISTMATCH ||  F2 > F1 )\n                {\n                    M[j] = k;\n                    last = k;\n                    break;\n                }\n            }\n        }\n        Mat lut(1, 256, CV_8UC1, M);\n        LUT(tgt_channels[i], lut, tgt_channels[i]);\n    }\n\n    //Merge the three channels into the result image\n    merge(tgt_channels, result);\n}\n\nint main(int argc, char *argv[])\n{\n    //Read original image and clone it to contain results\n    Mat ref = imread(\"baboon.jpg\", CV_LOAD_IMAGE_COLOR );\n    Mat tgt = imread(\"lena.jpg\", CV_LOAD_IMAGE_COLOR );\n    Mat dst = tgt.clone();\n\n    //Create three windows\n    namedWindow(\"Reference\", WINDOW_AUTOSIZE);\n    namedWindow(\"Target\", WINDOW_AUTOSIZE);\n    namedWindow(\"Result\", WINDOW_AUTOSIZE);\n    imshow(\"Reference\", ref);\n    imshow(\"Target\", tgt);\n\n    histMatch(ref, tgt, dst);\n    imshow(\"Result\", dst);\n\n    // Position windows on screen\n    moveWindow(\"Reference\", 0,0);\n    moveWindow(\"Target\", ref.cols,0);\n    moveWindow(\"Result\", ref.cols+tgt.cols,0);\n\n    waitKey(); // Wait for key press\n    return 0;\n}\n```", "```py\n#include \"opencv2/highgui/highgui.hpp\"\n#include \"opencv2/imgproc/imgproc.hpp\"\n\nusing namespace cv;\nusing namespace std;\n\nint main( ){\n    Mat image, HSV, Luv, Lab, YCrCb, XYZ;\n\n    //Read image\n    image = imread(\"HappyFish.jpg\", CV_LOAD_IMAGE_COLOR);\n\n    //Convert RGB image to different color spaces\n cvtColor(image, HSV, CV_RGB2HSV);\n cvtColor(image, Luv, CV_RGB2Luv);\n cvtColor(image, Lab, CV_RGB2Lab);\n cvtColor(image, YCrCb, CV_RGB2YCrCb);\n cvtColor(image, XYZ, CV_RGB2XYZ);\n\n    //Create windows and display results\n    namedWindow( \"Source Image\", 0 );\n    namedWindow( \"Result HSV Image\", 0 );\n    namedWindow( \"Result Luv Image\", 0 );\n    namedWindow( \"Result Lab Image\", 0 );\n    namedWindow( \"Result YCrCb Image\", 0 );\n    namedWindow( \"Result XYZ Image\", 0 );\n\n    imshow( \"Source Image\", image );\n    imshow( \"Result HSV Image\",  HSV );\n    imshow( \"Result Luv Image\", Luv );\n    imshow( \"Result Lab Image\", Lab);\n    imshow( \"Result YCrCb Image\", YCrCb );\n    imshow( \"Result XYZ Image\", XYZ );\n\n    waitKey(); //Wait for key press\n    return 0;  //End the program\n}\n```", "```py\n#include \"opencv2/opencv.hpp\"\nusing namespace cv;\nusing namespace std;\nint main(int argc, char* argv[])\n{\n    //Declare input image and retina output buffers\n    Mat src, retinaOutput_parvo, retinaOutput_magno;\n\n    src =  imread(\"starry_night.jpg\", 1); // load image in RGB\n\n    //Create a retina instance with default parameters setup\n    Ptr< Retina> myRetina;\n\n    //Allocate \"classical\" retina :\n myRetina = new  Retina(src.size());\n\n    //Save default retina parameters file\n    myRetina->write(\"RetinaDefaultParameters.xml\");\n\n    //The retina parameters may be reload using method \"setup\"\n    //Uncomment to load parameters if file exists\n    //myRetina->setup(\"RetinaSpecificParameters.xml\");\n    myRetina->clearBuffers();\n\n    //Several iteration of the filter may be done\n    for( int iter = 1; iter < 6; iter++ ){\n        // run retina filter\n myRetina->run(src);\n\n        // Retrieve and display retina output\n myRetina->getParvo(retinaOutput_parvo);\n myRetina->getMagno(retinaOutput_magno);\n\n        //Create windows and display results\n        namedWindow(\"Source Image\", 0 );\n        namedWindow(\"Retina Parvo\", 0 );\n        namedWindow(\"Retina Magno\", 0 );\n\n        imshow(\"Source Image\", src);\n        imshow(\"Retina Parvo\", retinaOutput_parvo);\n        imshow(\"Retina Magno\", retinaOutput_magno);\n    }\n    cout<<\"Retina demo end\"<< endl;   // Program end message\n    waitKey();\n    return 0;\n}\n```", "```py\n#include \"opencv2/highgui/highgui.hpp\"\n\nusing namespace cv;\nusing namespace std;\n\nint main()\n{\n    double alpha = 0.5, beta, input;\n    Mat src1, src2, dst;\n\n    //Read images (same size and type )\n    src1 = imread(\"baboon.jpg\");\n    src2 = imread(\"lena.jpg\");\n     //Create windows\n    namedWindow(\"Final Linear Blend\", CV_WINDOW_AUTOSIZE );\n\n    //Perform a loop with 101 iteration for linear blending\n    for(int k = 0; k <= 100; ++k ){\n        alpha = (double)k/100;\n        beta  = 1 - alpha;\n\n addWeighted( src2, alpha, src1, beta, 0.0, dst );\n\n        imshow( \"Final Linear Blend\", dst );\n        cvWaitKey(50);\n    }\n    namedWindow(\"Original Image 1\", CV_WINDOW_AUTOSIZE );\n    namedWindow(\"Original Image 2\", CV_WINDOW_AUTOSIZE );\n    imshow( \"Original Image 1\", src1 );\n    imshow( \"Original Image 2\", src2 );\n\n    cvWaitKey(); // Wait for key press\n    return 0;   // End\n}\n```", "```py\n#include \"opencv2/highgui/highgui.hpp\"\n#include \"opencv2/imgproc/imgproc.hpp\"\n#include <iostream>\n#include <stdio.h>\n\nusing namespace cv;\nusing namespace std;\n\nPoint2f centerpoint(0,0);\n\nPoint2f computeIntersect(Vec4i a,Vec4i b){\n    int x1 = a[0], y1 = a[1], x2 = a[2], y2 = a[3], x3 = b[0], y3 = b[1], x4 = b[2], y4 = b[3];\n\n    if (float d = ((float)(x1 - x2) * (y3 - y4)) - ((y1 - y2) * (x3 - x4)))\n    {\n        Point2f pnt;\n        pnt.x = ((x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4)) / d;\n        pnt.y = ((x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4)) / d;\n        return pnt;\n    }\n    else\n    return Point2f(-1, -1);\n}\n\nvoid sortCorners(vector<Point2f>& corner_points, Point2f centerpoint)\n{\n    vector<Point2f> top, bot;\n\n    for (int i = 0; i < corner_points.size(); i++)\n    {\n        if (corner_points[i].y < centerpoint.y)\n        top.push_back(corner_points[i]);\n        else\n        bot.push_back(corner_points[i]);\n    }\n\n    Point2f tl = top[0].x > top[1].x ? top[1] : top[0];\n    Point2f tr = top[0].x > top[1].x ? top[0] : top[1];\n    Point2f bl = bot[0].x > bot[1].x ? bot[1] : bot[0];\n    Point2f br = bot[0].x > bot[1].x ? bot[0] : bot[1];\n\n    corner_points.clear();\n    corner_points.push_back(tl);\n    corner_points.push_back(tr);\n    corner_points.push_back(br);\n    corner_points.push_back(bl);\n}\n\nint main(){\n    Mat src = imread(\"img.jpg\");\n    if (src.empty())\n    return -1;\n\n    Mat dst = src.clone();\n\n    Mat bw;\n    cvtColor(src, bw, CV_BGR2GRAY);\n\n    Canny(bw, bw, 100, 100, 3);\n    vector<Vec4i> lines;\n    HoughLinesP(bw, lines, 1, CV_PI/180, 70, 30, 10);\n\n    vector<Point2f> corner_points;\n    for (int i = 0; i < lines.size(); i++)\n    {\n        for (int j = i+1; j < lines.size(); j++)\n        {\n            Point2f pnt = computeIntersect(lines[i], lines[j]);\n            if (pnt.x >= 0 && pnt.y >= 0)\n            corner_points.push_back(pnt);\n        }\n    }\n\n    vector<Point2f> approx;\n    approxPolyDP(Mat(corner_points), approx, arcLength(Mat(corner_points), true) * 0.02, true);\n\n    if (approx.size() != 4)\n    {\n        cout << \"The object is not quadrilateral!\" << endl;\n        return -1;\n    }\n\n    //Get center point\n    for (int i = 0; i < corner_points.size(); i++)\n    centerpoint += corner_points[i];\n    centerpoint *= (1\\. / corner_points.size());\n\n    sortCorners(corner_points, centerpoint);\n\n    //Draw lines\n    for (int i = 0; i < lines.size(); i++)\n    {\n        Vec4i v = lines[i];\n        line(dst, Point(v[0], v[1]), Point(v[2], v[3]), CV_RGB(0,255,0));\n    }\n\n    //Draw corner points\n    circle(dst, corner_points[0], 3, CV_RGB(255,0,0), 2);\n    circle(dst, corner_points[1], 3, CV_RGB(0,255,0), 2);\n    circle(dst, corner_points[2], 3, CV_RGB(0,0,255), 2);\n    circle(dst, corner_points[3], 3, CV_RGB(255,255,255), 2);\n\n    //Draw mass center points\n    circle(dst, centerpoint, 3, CV_RGB(255,255,0), 2);\n\n    //Calculate corresponding points for corner points\n    Mat quad = Mat::zeros(src.rows, src.cols/2, CV_8UC3);\n\n    vector<Point2f> quad_pnts;\n    quad_pnts.push_back(Point2f(0, 0));\n    quad_pnts.push_back(Point2f(quad.cols, 0));\n    quad_pnts.push_back(Point2f(quad.cols, quad.rows));\n    quad_pnts.push_back(Point2f(0, quad.rows));\n\n    // Draw corresponding points\n    circle(dst, quad_pnts[0], 3, CV_RGB(255,0,0), 2);\n    circle(dst, quad_pnts[1], 3, CV_RGB(0,255,0), 2);\n    circle(dst, quad_pnts[2], 3, CV_RGB(0,0,255), 2);\n    circle(dst, quad_pnts[3], 3, CV_RGB(255,255,255), 2);\n\n Mat transmtx = getPerspectiveTransform(corner_points, quad_pnts);\n warpPerspective(src, quad, transmtx, quad.size());\n\n    //Create windows and display results\n    namedWindow(\"Original Image\", CV_WINDOW_AUTOSIZE );\n    namedWindow(\"Selected Points\", CV_WINDOW_AUTOSIZE );\n    namedWindow(\"Corrected Perspertive\", CV_WINDOW_AUTOSIZE );\n\n    imshow(\"Original Image\", src);\n    imshow(\"Selected Points\", dst);\n    imshow(\"Corrected Perspertive\", quad);\n\n    waitKey(); //Wait for key press\n    return 0;  //End\n}\n```"]