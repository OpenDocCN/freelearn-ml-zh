- en: Chapter 4. Step 1 – Data Exploration and Feature Engineering
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。步骤1 – 数据探索和特征工程
- en: There are different kinds of problems that require a machine learning solution.
    For instance, our target can be forecasting future outcomes or identifying patterns
    from the data. The starting point is a set of objects (for example, items) or
    people (for example, customers of a supermarket). In most situations, a machine
    learning technique identifies the solution, starting from some features that describe
    objects/people. The features are numeric and/or categorical attributes, and they
    are the base of the machine learning model. Having the right features will improve
    the performance and accuracy of the model, so it is extremely important to define
    some features that are relevant to the problem.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 有不同类型的问题需要机器学习解决方案。例如，我们的目标可以是预测未来的结果或从数据中识别模式。起点是一组对象（例如，商品）或人（例如，超市的顾客）。在大多数情况下，机器学习技术从描述对象/人的某些特征开始识别解决方案。特征是数值和/或分类属性，它们是机器学习模型的基础。拥有正确的特征将提高模型的表现力和准确性，因此定义与问题相关的某些特征非常重要。
- en: 'In this chapter, you will:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将：
- en: Build machine learning solutions
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建机器学习解决方案
- en: Build a feature data
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建特征数据
- en: Clean the data
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清洗数据
- en: Explore the defined features
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索定义的特征
- en: Modify the features
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改特征
- en: Rank the features using a filter
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用过滤器对特征进行排序
- en: Building a machine learning solution
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建机器学习解决方案
- en: 'In which stage of a machine learning solution are we defining the features?
    Let''s look at an overview of the whole procedure of building the solution. We
    can divide the approach into three steps:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在机器学习解决方案的哪个阶段我们正在定义特征？让我们看一下构建解决方案整个过程的概述。我们可以将方法分为三个步骤：
- en: Define the features that we will be using.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义我们将要使用的特征。
- en: Apply one or more techniques to solve the problem.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用一个或多个技术来解决问题。
- en: Evaluate the result and optimize the performance.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 评估结果并优化性能。
- en: In the first step, we can evaluate the relevance of each feature by using a
    filter and selecting the most relevant feature. We can also define a combination
    of some features that are good for describing the data.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一步，我们可以通过使用过滤器来评估每个特征的相关性，并选择最相关的特征。我们还可以定义一些特征组合，这些特征组合有助于描述数据。
- en: In the second step, when we build a model, we can use some techniques (embedded
    methods) that rank the features and identify the most relevant feature automatically.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二步，当我们构建模型时，我们可以使用一些技术（嵌入方法）来对特征进行排序并自动识别最相关的特征。
- en: The last step is very important since we have more information, allowing us
    to identify a more proper feature set. For instance, we can use the same model
    with different sets of features and evaluate which feature combination performs
    better. An option is to use a wrapper that consists of building a model with a
    chosen set of features, iteratively add (or remove) a feature, and retain the
    change if it improves the accuracy of the model.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步非常重要，因为我们有更多信息，这使我们能够识别更合适的特征集。例如，我们可以使用具有不同特征集的相同模型，并评估哪种特征组合表现更好。一个选项是使用一个包装器，该包装器包括使用所选特征集构建模型，迭代地添加（或删除）一个特征，如果它提高了模型准确性，则保留这种变化。
- en: 'In conclusion, a feature selection is a cycle rather than a step, and it takes
    place in each part of the procedure. This chapter shows the feature engineering
    process, which consists of defining the features, transforming them, and identifying
    their ranking. The steps are:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，特征选择是一个循环而不是一个步骤，它发生在过程的每个部分。本章展示了特征工程过程，该过程包括定义特征、转换它们以及确定它们的排名。步骤如下：
- en: Exploring the data
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索数据
- en: Defining/transforming new features
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义/转换新特征
- en: Identifying the most relevant features
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别最相关的特征
- en: Although exploring the data is always at the beginning, all the steps can be
    repeated until we find a satisfying solution, so they don't always follow the
    same order. For instance, after identifying the most relevant features, we can
    explore the data, identify new patterns, and consequently define some new features.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管探索数据始终在开始时，但所有步骤都可以重复，直到我们找到令人满意的解决方案，因此它们不一定总是遵循相同的顺序。例如，在确定最相关的特征后，我们可以探索数据，识别新的模式，从而定义一些新的特征。
- en: The process of feature selection is related to the model, and in this chapter,
    we identify some features that are suitable for many models.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 特征选择的过程与模型相关，在本章中，我们确定了一些适合许多模型的特征。
- en: This chapter shows an example of flags. Based on the flag of a country, our
    target is to determine the country's language. Assuming that we know the flags
    of all the countries and the language of only some of them, the model will estimate
    the language of the others.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 本章展示了国旗的示例。基于一个国家的国旗，我们的目标是确定该国的语言。假设我们知道所有国家的国旗和其中一些国家的语言，模型将估计其他国家的语言。
- en: Building the feature data
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建特征数据
- en: 'This section shows how we can structure the raw data to build the features.
    For each country, the data is:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 本节展示了我们如何构建原始数据以构建特征。对于每个国家，数据包括：
- en: A picture of the flag
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 国旗的图片
- en: Some geographical data such as continent, geographic quadrant, area, and population
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些地理数据，例如大陆、地理象限、面积和人口
- en: The language and religion of the country
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该国的语言和宗教
- en: The target is to build a model that predicts a country language starting from
    its flag. Most of the models can deal with numeric and/or categorical data, so
    we can't use the image of the flag as a feature for the model. The solution is
    to define some features, for instance the number of colors, that describe each
    flag. In this way, we start from a table whose rows correspond to the countries
    and whose columns correspond to the flag features.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是构建一个从国旗预测国家语言的模型。大多数模型可以处理数值和/或分类数据，因此我们不能将国旗图片作为模型的特征。解决方案是定义一些特征，例如颜色的数量，来描述每个国旗。这样，我们就从一张表格开始，该表格的行对应国家，列对应国旗特征。
- en: It would take a lot of time to build the matrix with the flag attributes based
    on the pictures. Fortunately, we can use a dataset that contains some features.
    The data that we have is still a bit messy, so we need to clean and transform
    it to build a feature table in the *right format*.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 基于图片构建具有国旗属性的矩阵将花费很多时间。幸运的是，我们可以使用包含一些特征的数据库。我们拥有的数据仍然有些杂乱，因此我们需要对其进行清理和转换，以构建一个格式正确的特征表。
- en: 'The features contained in the dataset display some information about:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 数据集中的特征显示了一些关于的信息：
- en: The colors in the flag
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 国旗上的颜色
- en: The patterns in the flag
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 国旗上的图案
- en: Some additional elements in the flag, such as text or some stars
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 国旗中的一些附加元素，如文本或一些星星
- en: Some geographical data, such as continent, geographic quadrant, area, and population
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些地理数据，例如大陆、地理象限、面积和人口
- en: The language and religion of the country
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该国的语言和宗教
- en: 'The steps to lead the table in the right format are as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 将表格以正确格式引导的步骤如下：
- en: Download the dataset and the related information from [https://archive.ics.uci.edu/ml/machine-learning-databases/flags/](https://archive.ics.uci.edu/ml/machine-learning-databases/flags/)
    and download `flag.data`.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[https://archive.ics.uci.edu/ml/machine-learning-databases/flags/](https://archive.ics.uci.edu/ml/machine-learning-databases/flags/)下载数据集和相关信息，并下载`flag.data`。
- en: 'Open RStudio and set the working directory to the folder that contains the
    data:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开RStudio并将工作目录设置为包含数据的文件夹：
- en: '[PRE0]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Load the data into the R environment:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将数据加载到R环境中：
- en: '[PRE1]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, we can see the structure of `dfFlag` using `str`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用`str`查看`dfFlag`的结构：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `dfFlag` object contains 30 columns whose names are not defined. We have
    documentation that describes the data contained in `flag.description.txt`, which
    allows us to define the column names. The first seven columns contain some attributes
    that are not related to the flag. Let''s start defining some vectors that contain
    the feature names. The first column is the name of the country. These are the
    steps to define the names:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`dfFlag`对象包含30列，其名称未定义。我们有描述`flag.description.txt`中数据的文档，这允许我们定义列名。前七列包含一些与国旗无关的属性。让我们开始定义一些包含特征名称的向量。第一列是国家的名称。以下是定义名称的步骤：'
- en: 'Define the country name:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义国家名称：
- en: '[PRE3]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Define the names of three geographic features: `continent`, `zone`, and `area`:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义三个地理特征名称：`continent`、`zone`和`area`：
- en: '[PRE4]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Define the names of three features of the countries'' citizens, including their
    language:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义包括语言在内的该国公民的三个特征名称：
- en: '[PRE5]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Define a unique vector that contains the seven attributes in the right order:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个包含七个属性且顺序正确的唯一向量：
- en: '[PRE6]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Define the names of the features defining the number of `bars`, `stripes`,
    and `colors`:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义描述条形、条纹和颜色的特征名称：
- en: '[PRE7]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'For some colors, there is a variable that displays `1` if the flag contains
    the color and `0` otherwise. Define their names:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于某些颜色，有一个变量，如果国旗包含该颜色则显示`1`，否则显示`0`。定义它们的名称：
- en: '[PRE8]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Define the name of the predominant color:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义主要颜色的名称：
- en: '[PRE9]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Define the name of the attributes that display how many patterns/drawings (for
    instance, a shape, a picture, or a text) are contained in the flag:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义显示包含在国旗中的图案/绘画（例如，一个形状、一张图片或一段文字）数量的属性名称：
- en: '[PRE10]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Dangles: the color in two out of the four angles:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 悬挂：四个角中的两个角的颜色：
- en: '[PRE11]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Define `namesFlag` that contains all the names in the right order:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义包含所有名称且顺序正确的 `namesFlag`：
- en: '[PRE12]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Set the `dfFlag` column names that bind `namesAttributes` and `namesFlag`:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置绑定 `namesAttributes` 和 `namesFlag` 的 `dfFlag` 列名：
- en: '[PRE13]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, the data frame has the right column names. However, some columns, such
    as `language` contain numbers instead of the attribute name, and the documentation
    shows what the numbers stand for. For instance, for language, 1 corresponds to
    English and 2 to Spanish. We can build a data table that has the data in the right
    format using the following steps:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，数据框具有正确的列名。然而，一些列，如 `language`，包含数字而不是属性名称，文档显示了这些数字的含义。例如，对于语言，`1` 对应英语，`2`
    对应西班牙语。我们可以使用以下步骤构建一个具有正确格式的数据表：
- en: 'Convert `dfFlag` into the `dtFlag` data table:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `dfFlag` 转换为 `dtFlag` 数据表：
- en: '[PRE14]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Display the `continent` column:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示 `continent` 列：
- en: '[PRE15]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `continent` column contains a number between `1` and `6` and the documentation
    shows `1=N.America`, `2=S.America`, `3=Europe`, `4=Africa`, `5=Asia`, `6=Oceania`.
    Then, we define a vector that contains the continents:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`continent` 列包含介于 `1` 和 `6` 之间的数字，文档显示 `1=N.America`、`2=S.America`、`3=Europe`、`4=Africa`、`5=Asia`、`6=Oceania`。然后，我们定义一个包含大陆的向量：'
- en: '[PRE16]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Convert `continent` into `factor` whose levels are `vectorContinents`:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `continent` 转换为 `factor` 类型，其级别为 `vectorContinents`：
- en: '[PRE17]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Similar to `continent`, convert `zone` into `factor`:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与 `continent` 类似，将 `zone` 转换为 `factor`：
- en: '[PRE18]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Convert `language` into `factor`:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `language` 转换为 `factor`：
- en: '[PRE19]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Convert `religion` into `factor`:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `religion` 转换为 `factor`：
- en: '[PRE20]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let''s take a look at `dtFlag`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看 `dtFlag`：
- en: '[PRE21]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The data is in the right format. Although we had to transform the data properly,
    it still took much less time than defining the features manually.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 数据格式正确。尽管我们不得不正确地转换数据，但它仍然比手动定义特征花费的时间少得多。
- en: Exploring and visualizing the features
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索和可视化特征
- en: After having defined the features, we can explore them and identify how they
    are related to the problem. In this section, you will see how to explore the data
    and define some simple charts.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了特征之后，我们可以探索它们并确定它们与问题的关系。在本节中，您将了解如何探索数据并定义一些简单的图表。
- en: 'Let''s start with a feature, for instance, `mainhue`, which displays the predominant
    color of a flag. We want to identify the most common predominant colors, and for
    that purpose, we can use `table` to count the number of occurrences of each possible
    value. We can extract the `mainhue` column from `dtFlag` and apply `table` to
    it:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从特征开始，例如，`mainhue`，它显示国旗的主要颜色。我们想要识别最常见的颜色，为此，我们可以使用 `table` 来计算每个可能值的出现次数。我们可以从
    `dtFlag` 中提取 `mainhue` 列并对其应用 `table`：
- en: '[PRE22]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The three most common predominant colors are red, blue, and green. Please note
    that we could have put `table` inside the square brackets, obtaining the same
    result with cleaner code: `dtFlag[, table(mainhue)]`.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的三种主要颜色是红色、蓝色和绿色。请注意，我们可以在方括号内放置 `table`，以获得相同的结果，但代码更简洁：`dtFlag[, table(mainhue)]`。
- en: 'How can we perform the same operation over any other column? First, let''s
    define a string called `nameCol` that contains the name of the column that we
    want to analyze. In order to access the column, we can use `get(nameCol)` inside
    the square brackets of `dtFlag`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何对任何其他列执行相同的操作？首先，让我们定义一个名为 `nameCol` 的字符串，它包含我们想要分析的列的名称。为了访问该列，我们可以在 `dtFlag`
    的方括号中使用 `get(nameCol)`：
- en: '[PRE23]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This notation is very useful because we can easily include it inside a function
    using the name string, visualizing the same results for all the other columns:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这种表示法非常有用，因为我们可以很容易地使用名称字符串将其包含在函数中，从而可视化其他所有列的相同结果：
- en: '[PRE24]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'What if we want to build a chart instead? We can build a histogram using `barplot`.
    Let''s first extract the table with each value of frequency:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想制作一个图表呢？我们可以使用 `barplot` 制作直方图。让我们首先提取具有每个频率值的表格：
- en: '[PRE25]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `freqValues` method contains the number of countries that speak any language
    in the list. We can extract a language vector using `names`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`freqValues` 方法包含说列表中任何语言的国家的数量。我们可以使用 `names` 提取一个语言向量：'
- en: '[PRE26]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, we have all the necessary data to build a histogram (see the documentation
    of `barplot` if you haven''t read [Chapter 3](ch03.html "Chapter 3. A Simple Machine
    Learning Analysis"), *A Simple Machine Learning Analysis*). In addition, we can
    define the colors using `rainbow`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经拥有了构建直方图所需的所有必要数据（如果你还没有阅读[第3章](ch03.html "第3章。简单机器学习分析")，请参阅`barplot`的文档）。此外，我们可以使用`rainbow`定义颜色：
- en: '[PRE27]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The histogram obtained is as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 获得的直方图如下：
- en: '![Exploring and visualizing the features](img/7740OS_04_01.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![探索和可视化特征](img/7740OS_04_01.jpg)'
- en: 'This chart is very useful if we want to explore an attribute. In order to do
    this using just one line of code, we can define a function that builds this chart
    for a generic column, `nameCol`. In addition, we can add `legend` that displays
    the percentage. In order to display `legend`, we compute `percValues`, which contains
    the percentage of rows that display that value, and use it as the `legend.text`
    argument, as shown:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要探索一个属性，这个图表非常有用。为了仅用一行代码完成此操作，我们可以定义一个函数，为通用列`nameCol`构建此图表。此外，我们可以添加`legend`来显示百分比。为了显示`legend`，我们计算`percValues`，它包含显示该值的行百分比，并将其用作`legend.text`参数，如下所示：
- en: '[PRE28]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Let''s apply the function to another column, for instance `stripes`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将函数应用于另一列，例如`stripes`：
- en: '[PRE29]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '![Exploring and visualizing the features](img/7740OS_04_02.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![探索和可视化特征](img/7740OS_04_02.jpg)'
- en: 'Using a `for` loop, we can generate the same chart for each flag attribute.
    We need time to see the result between, each chart and the following, so we stop
    the program using `readline`. The script pauses until we press *Enter* in the
    console. In this way, we can explore all the features very quickly, shown as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`for`循环，我们可以为每个标志属性生成相同的图表。我们需要时间在每张图表和下一张图表之间查看结果，所以我们使用`readline`停止程序。脚本会暂停，直到我们在控制台中按下*Enter*。这样，我们可以非常快速地探索所有特征，如下所示：
- en: '[PRE30]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: With these few lines of code, we have observed how frequent the values of each
    feature are.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这几行代码，我们已经观察到了每个特征的值出现的频率。
- en: 'Another quick exploration is, given a color, counting the number of flags that
    contain the color. For instance, let''s count the flags that have a red part.
    There is an attribute called `red` whose value is `1` if the flag contains a red
    part and `0` otherwise. If we sum up all the column values, we will obtain the
    total number of flags that contain a red part, as shown:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种快速探索是，给定一种颜色，计算包含该颜色的标志数量。例如，让我们计算包含红色部分的标志。有一个名为`red`的属性，其值为`1`表示标志包含红色部分，否则为`0`。如果我们对所有列值求和，我们将获得包含红色部分的标志总数，如下所示：
- en: '[PRE31]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'As we have seen earlier, we can use `get` inside the square brackets. How can
    we do the same for all the common colors? The `namesColors` vector contains the
    name of all the color attributes, as shown:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所见，我们可以在方括号内使用`get`。我们如何为所有常见的颜色做同样的事情？`namesColors`向量包含了所有颜色属性的名称，如下所示：
- en: '[PRE32]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The first element of `namesColors` is `red`, so we can use it to count the
    flags that contain red:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`namesColors`的第一个元素是`red`，因此我们可以用它来计算包含红色的标志：'
- en: '[PRE33]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We can use `sapply` (see the documentation) to apply a function over each element
    of `namesColors`. In this case, the function counts the number of flags that contain
    a specific color:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`sapply`（请参阅文档）在`namesColors`的每个元素上应用一个函数。在这种情况下，该函数计算包含特定颜色的标志的数量：
- en: '[PRE34]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The most common colors are red and green.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的颜色是红色和绿色。
- en: Until now, we have explored the flag's features; the next step is to see how
    they are related to the country's language. A fast way is to use a decision tree
    (see [Chapter 3](ch03.html "Chapter 3. A Simple Machine Learning Analysis"), *A
    Simple Machine Learning Analysis*).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经探索了标志的特征；下一步是看看它们如何与国家的语言相关。一种快速的方法是使用决策树（请参阅[第3章](ch03.html "第3章。简单机器学习分析")，*简单机器学习分析*）。
- en: 'First, let''s import the packages to generate and visualize the decision tree:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们导入生成和可视化决策树的包：
- en: '[PRE35]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The decision tree model requires a formula object that defines the relationship
    between the variables. In this case, the formula is *language ~ feature1 + feature2
    + …*. We can build the formula by adding all the names contained in `namesFlag`
    using a `for` loop, as shown:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 决策树模型需要一个公式对象，用于定义变量之间的关系。在这种情况下，公式是`language ~ feature1 + feature2 + …`。我们可以通过添加`namesFlag`中包含的所有名称来构建公式，如下所示：
- en: '[PRE36]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We can build the model using `rpart` and visualize the tree using `prp`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`rpart`构建模型，并使用`prp`可视化树：
- en: '[PRE37]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '![Exploring and visualizing the features](img/7740OS_04_03.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![探索和可视化特征](img/7740OS_04_03.jpg)'
- en: Some nodes of the tree are not clear to read. For instance, `saltires` displays
    `1` if the flag has a saltire, and `0` otherwise. The first tree node expresses
    the **saltires >= 0.5** condition, so the flags on the left have a saltire. This
    reflects the fact that the features are not in the appropriate format, so the
    next step will be to transform the feature.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 树的一些节点不易阅读。例如，`saltires` 如果旗帜上有十字，则显示 `1`，否则显示 `0`。第一个树节点表示 **saltires >= 0.5**
    条件，因此左侧的旗帜上有十字。这反映了特征格式不正确的事实，因此下一步将是转换特征。
- en: 'First, let''s define a new data table called `dtFeatures`, which contains the
    features and the outcome. From now, we will modify `dtFeatures` until all the
    features are in the right format, as shown:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们定义一个新的数据表 `dtFeatures`，其中包含特征和结果。从现在起，我们将修改 `dtFeatures`，直到所有特征都处于正确的格式，如下所示：
- en: '[PRE38]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Let''s define a function to visualize the table. We will reuse this function
    to keep track of progress during the feature transformation, as shown:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一个函数来可视化表格。我们将重用此函数来跟踪特征转换过程中的进度，如下所示：
- en: '[PRE39]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The chart is exactly the same as before.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图表与之前完全相同。
- en: So far, we have seen some techniques to explore the features. The data exploration
    allowed us to investigate the data nature, and it's the starting point to clean
    the current features and define some others. In addition, we have built some functions
    that allow us to generate some charts using just one line of code. We can use
    these functions to keep track of the feature transformation.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了一些探索特征的技术。数据探索使我们能够调查数据性质，这是清理当前特征和定义其他特征的开端。此外，我们构建了一些函数，允许我们仅用一行代码生成一些图表。我们可以使用这些函数来跟踪特征转换。
- en: Modifying the features
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改特征
- en: Our features are attributes that describe the flag, and some of them might not
    be in the right format. In this section, we will take a look at each feature and
    transform it if necessary.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的特性是描述旗帜的属性，其中一些可能不在正确的格式中。在本节中，我们将查看每个特征，并在必要时对其进行转换。
- en: 'In order to keep track of which features we have already processed, let''s
    start defining an empty vector `namesProcessed`, which contains the features that
    we have already processed. When we transform a feature, we add the feature name
    into `namesProcessed`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟踪我们已经处理过的特征，让我们开始定义一个空向量 `namesProcessed`，其中包含我们已经处理过的特征。当我们转换一个特征时，我们将特征名称添加到
    `namesProcessed` 中：
- en: '[PRE40]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Let''s start with the numeric columns, such as `red`, which have two possible
    outcomes: `0`, in case the flag contains red and `1` otherwise. The `red` variable
    defines an attribute, so it should be categorical instead of numeric. Then, we
    can convert `red` into a feature that is `yes` if the color is red and `no` otherwise.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从数值列开始，例如 `red`，它有两种可能的结果：`0`，如果旗帜包含红色，否则为 `1`。`red` 变量定义了一个属性，因此它应该是分类的而不是数值的。然后，我们可以将
    `red` 转换为特征，如果颜色是红色，则为 `yes`，否则为 `no`。
- en: 'If we take a look at the charts of each feature, we notice that some of them
    display only two values that are always `0` and `1`. In order to convert each
    of them into the `yes` and `no` format, we can use a `for` loop. For each feature
    in `namesFlag`, we check if there are only two possible values. If so, we convert
    the feature into a factor. Let''s start with `red`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看每个特征的图表，我们会注意到其中一些只显示两个值，总是 `0` 和 `1`。为了将每个值转换为 `yes` 和 `no` 格式，我们可以使用一个
    `for` 循环。对于 `namesFlag` 中的每个特征，我们检查是否存在两种可能的值。如果是这样，我们将特征转换为因子。让我们从 `red` 开始：
- en: '[PRE41]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We can check if `nameFeat` displays two values:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以检查 `nameFeat` 是否显示两个值：
- en: '[PRE42]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In this case, the answer is `TRUE`, so we can generate a vector that contains
    the same column with `no` and `yes` for `0` and `1` respectively. For this purpose,
    we use `factor`, which specifies that the labels are `no` and `yes`, as shown:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，答案是 `TRUE`，因此我们可以生成一个包含相同列的向量，对于 `0` 和 `1` 分别用 `no` 和 `yes` 表示。为此，我们使用
    `factor`，指定标签为 `no` 和 `yes`，如下所示：
- en: '[PRE43]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now, we can convert each feature that displays two possible outcomes using
    a `for` loop. For each feature, we check whether it has only two values using
    `if`. After we generate `vectorFactor`, we override the old column using `eval`
    inside the square brackets. Doing `dtFeatures[, eval(''red'') := vectorFactor]`
    is the same as `dtFeatures[, red := vectorFactor]`, shown as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用`for`循环将每个显示两种可能结果的特性进行转换。对于每个特性，我们使用`if`检查它是否只有两个值。在生成`vectorFactor`后，我们使用方括号内的`eval`覆盖旧列。执行`dtFeatures[,
    eval('red') := vectorFactor]`与`dtFeatures[, red := vectorFactor]`相同，如下所示：
- en: '[PRE44]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Let''s take a look at the features that we haven''t transformed yet. The `namesFlag`
    feature contains all the initial features, and `namesProcessed` contains the ones
    that we have already transformed. In order to visualize the features that are
    not in `namesProcessed`, we can use `setdiff`, which is a function that gives
    the elements that are in the first vector and not in the second, as shown:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们还没有转换的特征。`namesFlag`特征包含所有初始特征，而`namesProcessed`包含我们已经转换的特征。为了可视化不在`namesProcessed`中的特征，我们可以使用`setdiff`函数，该函数给出第一个向量中存在而第二个向量中不存在的元素，如下所示：
- en: '[PRE45]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'There are still many features that we haven''t analyzed yet. For instance,
    `bars` is a numeric attribute that displays the number of vertical bars in a flag.
    If we use `bars` as a numeric feature, the model will identify a relationship
    between the language and the model. All flags of the Spanish-speaking countries
    contain zero or three bars, so model can learn something like "the language can
    be Spanish only if we have less than four bars." However, there is no Spanish-speaking
    country whose flag has 1 or 2 bars. A solution is to group the countries on the
    basis of the number of bars, as shown:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多特征我们还没有分析。例如，`bars`是一个显示旗帜中垂直横杠数量的数值属性。如果我们使用`bars`作为数值特征，模型将识别语言和模型之间的关系。所有讲西班牙语国家的旗帜都包含零个或三个横杠，因此模型可以学习到“如果横杠少于四个，那么语言只能是西班牙语”这样的东西。然而，没有讲西班牙语的国家其旗帜有1个或2个横杠。一种解决方案是根据横杠的数量将国家分组，如下所示：
- en: '[PRE46]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '![Modifying the features](img/7740OS_04_04.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![修改特征](img/7740OS_04_04.jpg)'
- en: 'The chart shows that the groups with a significant number of flags are the
    **0** and **3** bars. Therefore, the groups can be as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图表显示，具有显著数量旗帜的组是**0**和**3**横杠。因此，组可以如下所示：
- en: Flags with no bars
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有横杠的旗帜
- en: Flags with three bars
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有三个横杠的旗帜
- en: All the other flags
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有其他旗帜
- en: 'We can define a new column named `nBars0`, which is equal to `TRUE` if the
    flag has no vertical bars:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以定义一个名为`nBars0`的新列，如果旗帜没有垂直横杠，则等于`TRUE`：
- en: '[PRE47]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Similarly, we define `nBars3`, which is `TRUE` for the flags with three bars.
    We don''t need to define a column with the remaining flags because they can already
    be identified by checking that `nBars0` and `nBars3` are `FALSE`:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们定义`nBars3`，对于有三个横杠的旗帜，它为`TRUE`。我们不需要为剩余的旗帜定义一个列，因为它们可以通过检查`nBars0`和`nBars3`是否为`FALSE`来识别：
- en: '[PRE48]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Let''s remove the initial `bars` column and add `bars` to `namesProcessed`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们删除初始的`bars`列并将`bars`添加到`namesProcessed`中：
- en: '[PRE49]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The operation that we performed is called **discretization** because we generated
    some discrete features, starting from a numeric one.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们执行的操作被称为**离散化**，因为我们从数值特征生成了一些离散特征。
- en: 'Similarly, we can transform `stripes` and `colors`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以转换`stripes`和`colors`：
- en: '[PRE50]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Let''s take a look at the features contained in `namesDrawings` that we haven''t
    processed yet:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`namesDrawings`中我们还没有处理过的特征：
- en: '[PRE51]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '![Modifying the features](img/7740OS_04_05.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![修改特征](img/7740OS_04_05.jpg)'
- en: 'In all these features, most of the flags display `0`. Therefore, we can group
    the flags into two categories: `0` and the rest. We are defining a new categorical
    variable that is `yes` if the value is greater than `0` and `no` otherwise. The
    process is called **binarization** because we transform some numeric features
    into categorical features that display two values only, as shown:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些特征中，大多数旗帜显示`0`。因此，我们可以将旗帜分为两类：`0`和其余部分。我们正在定义一个新的分类变量，如果值大于`0`则为`yes`，否则为`no`。这个过程被称为**二值化**，因为我们把一些数值特征转换成了只显示两个值的分类特征，如下所示：
- en: '[PRE52]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Let''s explore the remaining features, as shown in the following code:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索以下代码中显示的剩余特征：
- en: '[PRE53]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The chart obtained is as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 得到的图表如下：
- en: '![Modifying the features](img/7740OS_04_06.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![修改特征](img/7740OS_04_06.jpg)'
- en: 'The three remaining features are `topleft`, `botright`, and `mainhue`. They
    are all categorical and display more than two possible values. For instance, there
    are eight options for `mainhue`. However, only a few flags have `black`, `brown`,
    or `orange` as their main color. We don''t have enough information to take into
    account the less common colors. In this case, we can define a new categorical
    variable called `dummy variable` for each of them. We can decide to define a dummy
    variable for each possible color with at least 15 flags. The situation is similar
    for `topleft` and `botright`, so we can transform all of them in the same way,
    as shown:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的三个特征是`topleft`、`botright`和`mainhue`。它们都是分类的，并且显示超过两个可能的值。例如，`mainhue`有八个选项。然而，只有少数标志以`black`、`brown`或`orange`为主要颜色。我们没有足够的信息来考虑不太常见的颜色。在这种情况下，我们可以为每个它们定义一个新的分类变量，称为`虚拟变量`。我们可以决定为至少有15个标志的每个可能颜色定义一个虚拟变量。对于`topleft`和`botright`的情况也是类似的，因此我们可以以相同的方式转换所有这些特征，如下所示：
- en: '[PRE54]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now, we have transformed all the features. However, some of the new columns
    that we have defined are of the `logical` class. It''s better to visualize them
    as categorical attributes that display `yes` or `no`, so it''s best to transform
    them, as shown:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经转换了所有特征。然而，我们定义的一些新列属于`逻辑`类别。最好将它们可视化为主要显示`yes`或`no`的分类属性，因此最好将它们转换，如下所示：
- en: '[PRE55]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Let''s see how the decision tree has changed using the following code:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下代码如何改变决策树：
- en: '[PRE56]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The chart obtained is as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 得到的图表如下：
- en: '![Modifying the features](img/7740OS_04_07.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![修改特征](img/7740OS_04_07.jpg)'
- en: The decision tree is similar to the earlier tree. However, each node of the
    decision tree is checking a condition whose outcomes are `yes` and `no`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 决策树与之前的树相似。然而，决策树的每个节点都在检查一个结果为`yes`和`no`的条件。
- en: 'In this chapter, we have seen three ways of transforming the features:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了三种转换特征的方法：
- en: '**Discretization**: Starting from a numeric variable, we group all the possible
    values in sets. Then, for each set, we define a new variable that displays `yes`
    if the numeric variable belongs to the set and `no` otherwise.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**离散化**：从一个数值变量开始，我们将所有可能的值分组到集合中。然后，对于每个集合，我们定义一个新的变量，如果数值变量属于该集合则显示`yes`，否则显示`no`。'
- en: '**Binarization**: Starting from a numeric variable, we discretize a numeric
    variable by defining two sets only. We define a threshold and we check whether
    the variable is above or below the threshold.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**二值化**：从一个数值变量开始，我们通过定义两个集合来离散化一个数值变量。我们定义一个阈值，并检查变量是否高于或低于该阈值。'
- en: '**Dummy**: Starting from a categorical variable, we identify the most common
    outcomes. Then, for each common outcome, we define a new variable that displays
    `yes` if the variable is equal to the value and `no` otherwise.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**虚拟变量**：从一个分类变量开始，我们识别最常见的输出。然后，对于每个常见输出，我们定义一个新的变量，如果变量等于该值则显示`yes`，否则显示`no`。'
- en: Ranking the features using a filter or a dimensionality reduction
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用过滤器或降维对特征进行排序
- en: In the previous section, we defined different features. But are all of them
    really relevant to the problem? There are some techniques called **embedded models**
    that automatically select the most relevant features. We can also build the same
    machine learning model using different sets of features and pick the set whose
    performance is better. Both the options are good, although they require a lot
    of computational power.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们定义了不同的特征。但它们是否真的与问题相关？有一些称为**嵌入式模型**的技术可以自动选择最相关的特征。我们也可以使用不同的特征集构建相同的机器学习模型，并选择性能更好的集合。这两种选择都很好，尽管它们需要大量的计算能力。
- en: An alternative is to use filters that are techniques that identify the most
    relevant features. We use filters before applying any machine learning model,
    and in this way, we cut a lot of the computational cost of the algorithms. Some
    filters take account of each feature separately and are very computationally efficient.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是使用过滤器，这是一种识别最相关特征的技术。我们在应用任何机器学习模型之前使用过滤器，这样我们就能大幅减少算法的计算成本。一些过滤器会单独考虑每个特征，并且计算效率非常高。
- en: A simple filter is the **Pearson correlation coefficient**, which is a measure
    of the linear relationship between variables. The correlation is a number between
    -1 and 1, and these two extreme values express a clear linear relationship between
    the two variables. When drawing a chart, all the points lie on the same line.
    A correlation of 0 expresses that there is no linear dependence between the two
    variables. The higher the correlation module, the stronger the linear relationship.
    In our case, we can measure the correlation between each flag attribute and the
    language, and pick the attributes whose correlation module is higher.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的过滤器是**皮尔逊相关系数**，它是衡量变量之间线性关系的度量。相关系数是一个介于-1和1之间的数字，这两个极端值表示两个变量之间存在清晰的线性关系。当绘制图表时，所有点都位于同一条线上。相关系数为0表示两个变量之间没有线性依赖关系。相关系数的绝对值越高，线性关系越强。在我们的案例中，我们可以测量每个标志属性与语言之间的相关性，并选择相关性系数较高的属性。
- en: Another technique that takes account of each feature separately is the information-gain
    ratio. Let's suppose that we want to build a model without knowing anything about
    the flags. In this case, the best we can do is to identify the most common language
    and assume that each country speaks that language. What if we know only which
    flags contain the color red? The model will definitely be better than not having
    any information. How much better? The information-gain ratio of a feature is an
    index that quantifies the improvement that comes from adding the feature.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种考虑每个特征的技术是信息增益率。假设我们想要构建一个模型，但我们对标志一无所知。在这种情况下，我们能做的最好的事情就是识别最常见的语言，并假设每个国家都说那种语言。如果我们只知道哪些旗帜包含红色呢？模型肯定会比没有任何信息要好。好多少呢？一个特征的信息增益率是一个指数，它量化了添加该特征所带来的改进。
- en: The correlation and information-gain ratio take account of each feature separately,
    so they completely ignore the interaction between them. For instance, we can have
    two features that have a high impact on the language and are so strongly related
    with each other that they contain the same information. Let's suppose that we
    have already included one of the two features in the model. Adding the other won't
    provide any further information, although it would be highly relevant by itself.
    If the relationship between the two features is linear, we talk about **multicollinearity**.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 相关性和信息增益率分别考虑每个特征，因此它们完全忽略了它们之间的相互作用。例如，我们可以有两个对语言有重大影响的特征，并且它们之间关系非常紧密，以至于它们包含相同的信息。假设我们已经在模型中包含了一个这两个特征中的一个。添加另一个不会提供任何更多信息，尽管它本身可能非常相关。如果两个特征之间的关系是线性的，我们谈论的是**多重共线性**。
- en: In other situations, we have two features that have a little relevance if taken
    separately and have a big impact if taken together. If we rank the features using
    this kind of filter, we will exclude both of them, losing some useful information.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他情况下，我们有两个特征，如果单独考虑，它们的相关性很小，但如果一起考虑，则具有很大的影响。如果我们使用这种类型的过滤器对特征进行排序，我们将排除这两个特征，从而丢失一些有用的信息。
- en: An alternative to ranking the features is identifying relevant feature combinations.
    A technique is the **Principal** **component analysis** (**PCA**), and it is based
    on the correlation between features. Starting from the features, the PCA defines
    a set of variables called principal components, which are linearly independent
    of each other. The number of principal components is equal to or less than the
    number of features and the components are ranked by variance. Then, it's possible
    to select a subset of components that have high variances. However, PCA has limitations
    since it is based on linear relationships only, and it doesn't take account of
    the attribute to predict things (language, in our example).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 对特征进行排序的另一种方法是识别相关的特征组合。一种技术是**主成分分析**（PCA），它基于特征之间的相关性。从特征开始，PCA定义了一组称为主成分的变量，它们彼此线性独立。主成分的数量等于或小于特征的数量，并且这些成分按方差排序。然后，可以选择具有高方差的成分子集。然而，PCA有其局限性，因为它仅基于线性关系，并且它没有考虑到预测事物的属性（在我们的例子中是语言）。
- en: 'There are different techniques, and the one that we use in this chapter is
    the **information gain ratio** as it is simple and meaningful. R provides us with
    the `FSelector` package that contains different tools for the feature selection.
    The package requires you to have JRE installed on your computer, as shown:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 有不同的技术，我们在这章中使用的是**信息增益比**，因为它简单且有意义。R为我们提供了`FSelector`包，其中包含用于特征选择的工具。该包要求你在计算机上安装JRE，如下所示：
- en: '[PRE57]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Let''s build the `namesFeatures` vector that contains the name of all the features.
    Then, we can compute their information gain ratio using the `information.gain`
    function, as shown:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建一个包含所有特征名称的`namesFeatures`向量。然后，我们可以使用`information.gain`函数计算它们的信息增益比，如下所示：
- en: '[PRE58]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The `dfGains` method is a data frame with a field named `attr_importance`.
    The feature names are the row names, so let''s add another column that contains
    the names:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`dfGains`方法是一个具有名为`attr_importance`字段的DataFrame。特征名称是行名称，所以让我们添加另一个包含名称的列：'
- en: '[PRE59]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Let''s convert the data frame into a data table:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将数据框转换为数据表：
- en: '[PRE60]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'In order to see the most relevant features, we can sort them by relevance:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到最相关的特征，我们可以按相关性对它们进行排序：
- en: '[PRE61]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The `blue` and `saltires` features define very relevant attributes. In order
    to visualize the most relevant features, we can build a chart with the top 12
    attributes, as shown:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`blue`和`saltires`特征定义了非常相关的属性。为了可视化最相关的特征，我们可以构建一个包含前12个属性的图表，如下所示：'
- en: '[PRE62]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The histogram obtained is as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 获得直方图如下：
- en: '![Ranking the features using a filter or a dimensionality reduction](img/7740OS_04_08.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![使用过滤器或降维来排序特征](img/7740OS_04_08.jpg)'
- en: Now that we have defined feature ranking, we are able to build a model from
    the most relevant features. We can either include all the features whose relevance
    is above a chosen threshold, or pick a defined number of features starting from
    the top. However, we are still not taking into account the interaction between
    the features. For instance, among the top features, we have `the flag contains
    the blue`, `blue is the main color`, and `the bottom right is blue`. Although
    they are all very relevant, they are all about `blue`, so they are redundant and
    we can exclude one of them.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了特征排序，我们能够从最相关的特征构建模型。我们可以包括所有相关性高于所选阈值的特征，或者从顶部开始选择一定数量的特征。然而，我们还没有考虑到特征之间的交互。例如，在顶级特征中，我们有`旗帜包含蓝色`、`蓝色是主要颜色`和`右下角是蓝色`。尽管它们都非常相关，但它们都是关于`蓝色`的，所以它们是冗余的，我们可以排除其中一个。
- en: In conclusion, the filters are fast and useful methods to rank the features,
    but we have to be very careful about using them when we build the model.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，过滤器是快速且有用的方法来排序特征，但当我们构建模型时，我们必须非常小心地使用它们。
- en: Summary
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to perform feature selection. After having
    loaded and explored the features, you saw how to transform them using discretization
    and binarization. You also converted categoric features into dummy variables.
    You understood the importance of feature selection and ranked the features using
    the information gain ratio. In the next chapter, we will predict the language
    using machine learning techniques.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何进行特征选择。在加载和探索特征之后，你看到了如何使用离散化和二值化来转换它们。你还把分类特征转换为虚拟变量。你理解了特征选择的重要性，并使用信息增益比对特征进行了排序。在下一章中，我们将使用机器学习技术来预测语言。
