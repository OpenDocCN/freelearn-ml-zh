<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Time Series Forecasting</h1>
                </header>
            
            <article>
                
<p class="calibre2">In the previous chapter, we learned how to handle date and time with Julia. This allowed us to understand the very important concept of time series data. Now, we are ready to discuss yet another highly important data science topic—time series analysis.</p>
<p class="calibre2">Time series analysis and forecasting represents a key strategic and decisive component of any organization, from understanding top sales periods to end of season intervals and discounts, scheduling employees' time off, budgets, fiscal years, product release cycles, increased demand in raw materials, and many, many other aspects. Understanding and predicting the evolution of various business indicators over time is a necessary part of doing business, whether we're talking about a school, a billion dollar corporation, a hotel, a supermarket, or a government.</p>
<p class="calibre2">However, time series data analysis is one of the most fairly complex tasks of data science. The nature and particularities of chronological events led to the development of specialized algorithms and methodologies.</p>
<p class="calibre2">In this chapter, we'll study the basics of time series analysis and forecasting using Julia. Although a fairly young language, Julia already has good support for handling time-related data. In the previous chapter, we've learned about the Dates module and about the <kbd class="calibre12">TimeSeries</kbd> package. In this chapter, we'll dive deeper and apply what we have previously studied. We'll also learn about more advanced <kbd class="calibre12">TimeSeries</kbd> methods and about a few other packages for working with temporal data. We will be covering the following topics:</p>
<ul class="calibre10">
<li class="calibre11">Exploratory data analysis of the unemployment figures of the <strong class="calibre1">European Union</strong> (<strong class="calibre1">EU</strong>)</li>
<li class="calibre11">Trends, cycles, seasonality, and errors—components of a time series</li>
<li class="calibre11">Time series decomposition</li>
<li class="calibre11">Stationarity, differencing, and autocorrelation of time series data</li>
<li class="calibre11">Learning to apply simple forecasting techniques</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p class="calibre2">The Julia package ecosystem is under continuous development and new package versions are released on a daily basis. Most of the times this is great news, as new releases bring new features and bug fixes. However, since many of the packages are still in beta (version 0.x), any new release can introduce breaking changes. As a result, the code presented in the book can stop working. In order to ensure that your code will produce the same results as described in the book, it is recommended to use the same package versions. Here are the external packages used in this chapter and their specific versions:</p>
<pre class="calibre17">CSV@v0.4.3<br class="title-page-name"/>DataFrames@v0.15.2<br class="title-page-name"/>IJulia@v1.14.1<br class="title-page-name"/>Plots@v0.22.0<br class="title-page-name"/>TimeSeries@v0.14.0</pre>
<p class="calibre2">In order to install a specific version of a package you need to run:</p>
<pre class="calibre17"><strong class="calibre1">pkg&gt; add PackageName@vX.Y.Z</strong> </pre>
<p class="calibre2">For example:</p>
<pre class="calibre17"><strong class="calibre1">pkg&gt; add IJulia@v1.14.1</strong></pre>
<p class="calibre2">Alternatively you can install all the used packages by downloading the <kbd class="calibre12">Project.toml</kbd> file provided with the chapter and using <kbd class="calibre12">pkg&gt;</kbd> instantiate as follows:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; download("https://raw.githubusercontent.com/PacktPublishing/Julia-Programming-Projects/master/Chapter10/Project.toml", "Project.toml")</strong><br class="title-page-name"/><strong class="calibre1">pkg&gt; activate . </strong><br class="title-page-name"/><strong class="calibre1">pkg&gt; instantiate</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">A quick look at our data</h1>
                </header>
            
            <article>
                
<p class="calibre2">In this chapter, we will use some real-life data provided by Eurostat, the official EU office for statistics. Eurostat has a wealth of databases available on its website. For our learning project, we'll take a look at the unemployment numbers—with the EU's economy growing after a long recession, these stats should be quite interesting. Various EU employment and unemployment figures can be downloaded from <a href="http://ec.europa.eu/eurostat/web/lfs/data/database" class="calibre9"><span>http://ec.europa.eu/eurostat/web/lfs/data/database</span></a>. We'll be using the <strong class="calibre4">Unemployment by sex and age <span class="calibre5">–</span> monthly average</strong> dataset.</p>
<p class="calibre2">You don't need to download this because a better structured dataset is provided in this chapter's support files. However, if you're curious and want to take a look, you can get the raw data from under the <span class="calibre5">Employment and unemployment (Labour force survey)</span> category | <span class="calibre5">LFS main indicators</span> subcategory | <span class="calibre5">Unemployment - LFS adjusted series</span> folder.</p>
<p class="calibre2">I've also customized the data by using <em class="calibre16">thousand persons</em> for the unit of measure (the default is <em class="calibre16">percentage of active population</em>), and unadjusted data (neither seasonally, nor calendar). I've also kept the numbers for the EU only (no individual countries). Finally, I've included all the data from January 2005 to December 2017. You can make all of these adjustments in the data explorer and then download the table as TSV file. As for the TSV formatting, I went with these options:</p>
<p class="CDPAlignCenter"><img src="assets/a03e7928-781a-4f72-b4cb-e037fb87381a.png" class="calibre171"/></p>
<p class="calibre2">Visualized in the Eurostat data explorer tool, the data looks like this:</p>
<p class="CDPAlignCenter"><img src="assets/b2f003d7-0f72-40fa-a01a-5de76cb059d0.png" class="calibre18"/></p>
<p class="calibre2">We can see a list of geographical areas in the first column and unemployment numbers on a monthly basis in the rest of the columns. This dataset is structured in a different way than what we require. For starters, <kbd class="calibre12">TimeSeries</kbd> requires the matrix to be transposed (as in, the dates should become rows instead of columns). Additionally, dates are formatted in a non-standard way, for example, <kbd class="calibre12">2017M01</kbd> designates January 2017. Finally, the numbers are formatted as strings, with spaces for thousand separators. You can download this raw data file from this chapter's support files, which are hosted at <a href="https://github.com/PacktPublishing/Julia-Programming-Projects/blob/master/Chapter10/data/une_rt_m_1.tsv" class="calibre9">https://github.com/PacktPublishing/Julia-Programming-Projects/blob/master/Chapter10/data/une_rt_m_1.tsv</a>.</p>
<p class="calibre2">Such issues are a common occurrence when working with real-life data—differences in standards regarding structure and formatting make data sanitization and transformation a key first step, and usually also a time-consuming one, in any data science project. For the sake of brevity, I have prepared a simplified dataset that's already been transformed for seamless usage with <kbd class="calibre12">TimeSeries</kbd><span class="calibre5">, which you can download from this chapter's support files.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Data processing</h1>
                </header>
            
            <article>
                
<p class="calibre2">If you would like to follow along, here is how I processed the raw data using Julia:</p>
<pre class="calibre17"><strong class="calibre1"># load the raw data file as a DataFrame 
julia&gt; using CSV, DataFrames </strong><br class="title-page-name"/><strong class="calibre1">julia&gt; df = CSV.read("une_rt_m_1.tsv", header = true, delim = '\t') 
1×157 DataFrames.DataFrame. Omitted printing of 148 columns</strong> </pre>
<p class="calibre2">This is what it looks like in a Jupyter Notebook:</p>
<p class="CDPAlignCenter"><img src="assets/cf8de08e-56ce-4d2a-92fd-9705b747b76e.png" class="calibre18"/></p>
<p class="calibre2">In the next step, we will extract the values by selecting a <kbd class="calibre12">DataFrame</kbd> composed of 1 row and 2 columns to <kbd class="calibre12">end</kbd> and converting it into an <kbd class="calibre12">Array</kbd>:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; values = convert(Array, df[1, 2:end]) 1×156 Array{Union{Missing, String},2}: "21 974" "22 303" "22 085" "21 036" "20 849" ... # output omitted</strong> </pre>
<p class="calibre2">Now, we can parse the previously extracted string values and convert them into integers. The new integer values are stored in a vector as well:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; values = map(x -&gt; parse(Int, replace(x, " "=&gt;"")), values)[:] 
156-element Array{Int64,1}: 
 21974 
 22303 
 22085 
 21036 
# output omitted</strong> </pre>
<p class="calibre2">Great—our values are ready! We can now focus on the headers. Our goal is to extract the date information contained in the labels. As a first step, we pull the names of the columns into a vector, as follows:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; dates = names(df)[2:end] 
156-element Array{Symbol,1}: 
 Symbol("2005M01") 
 Symbol("2005M02") 
 Symbol("2005M03") 
 Symbol("2005M04") 
 Symbol("2005M05") 
# output omitted</strong> </pre>
<p class="calibre2">Now, let's transform the symbols to bring them closer to what we need—that is, something resembling a standard date format. We'll replace the "<kbd class="calibre12">M</kbd>" with a dash, and in the process, we'll convert the symbol into a <kbd class="calibre12">String</kbd>, as replacing does not work on symbols:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; dates = map(x -&gt; replace(string(x), "M"=&gt;"-"), dates) 
156-element Array{String,1}: 
 "2005-01" 
 "2005-02" 
 "2005-03" 
 "2005-04" 
 "2005-05" 
# output omitted</strong> </pre>
<p class="calibre2">Excellent! Now, we can define a <kbd class="calibre12">DateFormat</kbd> matching our strings—year plus dash plus month, with the month as a numeric value with a leading zero. We'll use this to convert the strings to proper date objects:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; using Dates 
julia&gt; dateformat = DateFormat("y-m") 
dateformat"y-m" 
 
julia&gt; dates = map(x -&gt; Date(x, dateformat), dates) 
156-element Array{Date,1}: 
 2005-01-01 
 2005-02-01 
 2005-03-01 
 2005-04-01 
 2005-05-01 
# output omitted</strong> </pre>
<p class="calibre2">We're getting closer! To safely persist the data to a file, I created a new <kbd class="calibre12">DataFrame</kbd>, this time using the proper dates and the original values, as follows:</p>
<pre class="calibre17"><strong class="calibre1"># store the extracted data in a new DataFrame 
julia&gt; df2 = DataFrame(Dates = dates, Values = values) 
156×2 DataFrames.DataFrame 
│ Row │ Dates      │ Values │ 
│ 1   │ 2005-01-01 │ 21974  │ 
│ 2   │ 2005-02-01 │ 22303  │ 
│ 3   │ 2005-03-01 │ 22085  │ 
│ 4   │ 2005-04-01 │ 21036  │ 
│ 5   │ 2005-05-01 │ 20849  │ 
# output omitted</strong> </pre>
<p class="calibre2">We can use <kbd class="calibre12">CSV.write</kbd> to store the snapshot of our data to file by using the following code:</p>
<pre class="calibre17"><strong class="calibre1"># write DataFrame to file 
julia&gt; CSV.write("UE-unemployment.tsv", df2)</strong> </pre>
<p class="calibre2">We can now load the data as a <kbd class="calibre12">TimeArray</kbd> from the TSV file:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; using TimeSeries</strong><br class="title-page-name"/><strong class="calibre1">julia&gt; unemployment_data = readtimearray("UE-unemployment.tsv")</strong><br class="title-page-name"/><strong class="calibre1">156x1 TimeArray{Float64,2,Date,Array{Float64,2}} 2005-01-01 to 2017-12-01</strong></pre>
<div class="packttip">If you would like to directly convert from <kbd class="calibre24">DataFrame</kbd> to <kbd class="calibre24">TimeSeries</kbd> data, without resorting to loading a TSV file, you can use the <kbd class="calibre24">IterableTables</kbd> package. <kbd class="calibre24">IterableTables</kbd> provides a wealth of converter methods between different table types in Julia. You can read more in the package's README at <span><a href="https://github.com/davidanthoff/IterableTables.jl" class="calibre19">https://github.com/davidanthoff/IterableTables.jl</a>.</span></div>
<p class="calibre2">Our time series data was correctly loaded—<span class="calibre5">there are</span> 156 entries between January 2005 and December 2017. It will look like this:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; TimeSeries.head(unemployment_data, 10) 
10x1 TimeArray{Float64,2,Date,Array{Float64,2}} 2005-01-01 to 2005-10-01</strong> </pre>
<p class="calibre2">The output is as follows:</p>
<p class="CDPAlignCenter"><img src="assets/25a87a47-e73d-41bb-8a57-ce3362ff049c.png" class="calibre172"/></p>
<div class="packttip">We had to use the fully qualified name of the head function, <kbd class="calibre24">TimeSeries.head</kbd>, because both <kbd class="calibre24">TimeSeries</kbd> and <kbd class="calibre24">DataFrames</kbd> export a <kbd class="calibre24">head</kbd> method, and both packages are loaded into the current scope.</div>
<p class="calibre2">Attempting to call the head function without the module's name would result in an error:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; head(unemployment_data, 10) 
WARNING: both TimeSeries and DataFrames export "head"; uses of it in module Main must be qualified 
ERROR: UndefVarError: head not defined</strong> </pre>
<p class="calibre2">The best way to get a quick insight into our data is to render a plot. We'll use the <kbd class="calibre12">Plots</kbd> package with the <kbd class="calibre12">PyPlot</kbd> backend—we installed them both in <a href="11df7c94-2e9a-4cc5-aba1-b9c9c93800a0.xhtml" class="calibre9">Chapter 9</a>, <em class="calibre16">Working with Dates, Time, and Time Series</em>:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; using Plots 
julia&gt; pyplot()</strong> </pre>
<div class="packttip">The <kbd class="calibre24">PyPlot</kbd> backend has complex dependencies, so if you run into problems executing the indicated code, please follow the instructions provided by the warnings and errors.</div>
<p class="calibre2">For instance, at some point, I had to install two extra packages by hand:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; using Pkg 
julia&gt; pkg"add PyCall LaTeXStrings"</strong></pre>
<p class="calibre2">Now, we can plot the unemployment numbers:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; plot(unemployment_data)</strong> </pre>
<p class="calibre2">Julia will render the following plot:</p>
<p class="CDPAlignCenter"><img src="assets/7cde553e-2ac8-4d28-be71-883a2d5e664b.png" class="calibre173"/></p>
<p class="calibre2">We can easily see that the number of unemployed people had been steadily decreasing since 2005, reaching a historical minimum in the second half of 2008. From there, over a couple of months, it skyrocketed to levels unknown since 2005. This was the moment when the recession hit the EU's economy. From that point on, unemployment numbers continued to grow, until they finally reached a peak at the beginning of 2013. The maximum number of people without a job was reached in February 2013, after which the European economy began to recover, with the unemployment numbers rapidly declining and approaching pre-recession levels.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding time series components</h1>
                </header>
            
            <article>
                
<p class="calibre2">There are three components of time series that are key to understanding time-related data. They are <em class="calibre16">trend</em>, <em class="calibre16">seasonality</em>, and <em class="calibre16">noise</em>. Let's look at each of them in the context of our EU unemployment data.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Trend</h1>
                </header>
            
            <article>
                
<p class="calibre2">The trend can be defined as the long-term tendency of the time series data—the fact that, on average, the values tend to increase or decrease over a period of time. Looking at our plot, we can identify three distinct trends:</p>
<p class="CDPAlignCenter"><img src="assets/51311f42-6866-4abf-9d4a-c408ed5670cf.png" class="calibre174"/></p>
<p class="calibre2">A downward trend from 2005 until 2008 (less people unemployed on a year-on-year basis); an upward trend starting in 2008 and manifesting until 2013 (unemployment rose on average); and again, a downward trend between 2013, all the way until the end of 2017 (the number of people without work constantly decreased).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Seasonality</h1>
                </header>
            
            <article>
                
<p class="calibre2">Seasonality is a regularly repeating pattern of highs and lows that is related to calendar time; that is, it's directly influenced by seasons, quarters, months, and so on. Think, for instance, about the electricity usage in a city—we'll probably see increases in consumption during the summer due to air conditioning, and in wintertime due to needing to heat the houses instead. In a similar manner, by looking at a hotel at the seaside, we'll see a significant increase in bookings during the summer, followed by a decrease in the winter.</p>
<p class="calibre2">Thus, seasonality generates effects that are reasonably stable with respect to timing, direction, and magnitude. The most common calendar-related influences are natural conditions (the weather), business and administrative procedures (fiscal year), and social and cultural behaviors (bank holidays due to national and religious holidays, key dates like Christmas, Valentine's Day, and so on). It also includes effects that are caused by calendar events, which are recurrent but not fixed in terms of date (such as Easter, whose date falls on a certain Sunday each year, but the actual date varies).</p>
<p class="calibre2">Unemployment data suffers a strong seasonal influence—during the summer months, more people are employed. These seem to be temporary jobs, probably in tourism, to help hotels and restaurants cope with the influx of holiday goers—but maybe also in the office and retail sectors to cover for the regular employees' time off. We can clearly identify this on our plot—the summer months bring the lowest unemployment figures for the year, with the values beginning to go up again in autumn:</p>
<p class="CDPAlignCenter"><img src="assets/b023cc8b-d96f-42e9-a2b5-9a6ca9e4aa77.png" class="calibre175"/></p>
<p class="calibre2">During the three summer months in the middle of the year, unemployment reaches the lowest levels. Once the peak of the season passes, unemployment steeply rises once more.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Random noise</h1>
                </header>
            
            <article>
                
<p class="calibre2">The default assumption when analyzing time series data is that we can identify an underlying pattern (as defined by its trend and seasonality components). However, when there is such a systematic pattern in the data (some time series data is completely random, for example, earthquake incidence), it will also be accompanied by variances—fluctuations in the data that are categorized as random noise, errors, or irregularities. They make the task of identifying the patterns more difficult, and for this reason, data scientists will use some form of noise filtering.</p>
<p class="calibre2">In other words, this irregular component is what remains after the seasonal and trend components have been computed and removed. They are short-term fluctuations, and are neither systematic nor predictable.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Cyclicity</h1>
                </header>
            
            <article>
                
<p class="calibre2"><strong class="calibre4">Cyclicity</strong> is similar to seasonality in a way, and for this reason, the two are often confused. However, they are two different things, and the distinction is important. Cyclical periods represent larger swathes of time where we can identify recurring patterns in the data (periods of growth or decline) and which can't be explained away by calendar patterns. They are usually larger, spanning a few years, and do not overlap with calendar events. Such cyclical elements can be introduced by product release cycles (the release of a car model, or a new version of an operating system, or an upgrade to a line of laptops), election cycles (for government budgeting or companies working with government contracts), and so on.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Time series decomposition</h1>
                </header>
            
            <article>
                
<p class="calibre2">We can thus say that any value in a time series can be represented through a function of the four components we discussed earlier—trend, seasonality, error, and cycle. The relationship between the four components can be either <em class="calibre16">additive</em> or <em class="calibre16">multiplicative</em>.</p>
<p class="calibre2">The additive model is used when the seasonal variation stays about the same across time. The trend may be upward or downward, but the seasonality stays more or less the same. A plot of such data will look very similar to this:</p>
<p class="CDPAlignCenter"><img src="assets/ea8d4fed-7b41-4c10-a529-d9b90858a7a0.png" class="calibre176"/></p>
<p class="calibre2">If we draw two imaginary lines between the yearly maximums and the yearly minimums, the lines will be pretty much parallel.</p>
<p class="calibre2">For an additive time series model, the four components are summed up to produce the values in the series. Thus, a time series <em class="calibre16">Y</em> can be decomposed into <em class="calibre16">Y</em> = <em class="calibre16">Trend</em> + <em class="calibre16">Cycle</em> + <em class="calibre16">Seasonality</em> + <em class="calibre16">Noise</em>.</p>
<p class="calibre2">A multiplicative model should be used with a time series where the seasonal variability increases over time. For example, a typical multiplicative time series is represented by the international airline passenger data between January 1949 and January 1960:</p>
<p class="CDPAlignCenter"><img src="assets/82d97bc1-6063-4aa7-8287-519ef0a86000.png" class="calibre177"/></p>
<p class="calibre2">We can see how the variation in the seasonal pattern is correlated with the level of the time series: the more passengers we have, the higher the variation. A multiplicative time series <em class="calibre16">Y</em> can be represented as <em class="calibre16">Y</em> = <em class="calibre16">Trend</em> * <em class="calibre16">Cycle</em> * <em class="calibre16">Seasonality</em> * <em class="calibre16">Noise</em>.</p>
<div class="packtinfobox">As a side note, we can convert a multiplicative model into an additive model by transforming the data until it becomes stable over time, for example, by means of log transformations—<em class="calibre55">Y</em> = <em class="calibre55">Trend</em> * <em class="calibre55">Cycle</em> * <em class="calibre55">Seasonality</em> * <em class="calibre55">Noise</em> is equivalent to <em class="calibre55">log Y</em> = <em class="calibre55">log Trend</em> + <em class="calibre55">log Cycle</em> + <em class="calibre55">log Seasonality</em> + <em class="calibre55">log Noise</em>.</div>
<p class="calibre2">Splitting a time series into its components is a widely employed technique for time data analysis. This is known as<strong class="calibre4"> time series decomposition</strong>, and it also represents the foundation of time series forecasting.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Explaining data – an additive approach or multiplicative approach?</h1>
                </header>
            
            <article>
                
<p class="calibre2">This is the question—which of the two approaches does a better job of explaining our data? One way to answer this question is to look at the cycle-by-cycle values and see if there is significant variation. As we're dealing with yearly cycles, let's extract and plot the year on year values as follows:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; plot() 
julia&gt; for y in 2005:2017 
           TimeSeries.values(when(unemployment_data, year, y))[:] |&gt; plot! 
           gui() 
       end</strong> </pre>
<p class="calibre2">First, we render an empty plot. Then, we iterate over a range corresponding to our years, between 2005 and 2017, and then we use the <kbd class="calibre12">TimeSeries.when</kbd> method to filter our data by year. We extract the resulting <kbd class="calibre12">TimeArray</kbd> values and append them to the plot by using the <kbd class="calibre12">plot!</kbd> function. However, this is not enough—we also have to call the <kbd class="calibre12">Plots.gui</kbd> method to actually render the updated plot. This is a very important point, per the official documentation:</p>
<div class="mce-root1">"A plot is only displayed when returned (a semicolon will suppress the return), or if explicitly displayed with <kbd class="calibre24">display(plt)</kbd>, <kbd class="calibre24">gui()</kbd>, or by adding <kbd class="calibre24">show = true</kbd> to your plot command."</div>
<div class="packttip">You can read more about outputting plots at <a href="http://docs.juliaplots.org/latest/output/" class="calibre19"><span>http://docs.juliaplots.org/latest/output/</span></a>.</div>
<p class="calibre2">Here's what we get:</p>
<p class="CDPAlignCenter"><img src="assets/faa8bea1-d57f-452c-9a64-107b4d1dd029.png" class="calibre178"/></p>
<p class="calibre2">We can see that there is consistent year-after-year variation, which means that we should use the multiplicative model.</p>
<p class="calibre2">Eyeballing the components using <kbd class="calibre12">plots</kbd> is a common way of recognizing patterns in a time series. In our case, it is pretty easy to tell that there's both trend and seasonality. Also, we can deduce that the data does not exhibit any cyclical pattern.</p>
<p class="calibre2">Remember that the multiplicative model holds that <em class="calibre16">Y = Trend * Cyclicity * Seasonality * Noise</em>. We can write this shorter as <em class="calibre16">Y = TCSN</em>. Since we just established that our data does not present any cycles, we're going to leave out the cyclicity component, and so <em class="calibre16">Y = TSN</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Extracting the trend</h1>
                </header>
            
            <article>
                
<p class="calibre2">The first step in decomposing a time series is to extract the trend component. A widely used technique for computing the trend is called <strong class="calibre4">smoothing</strong>. As the name suggests, it <em class="calibre16">smooths out</em> the values by removing the noise and blurring the seasonality so that we can identify the trend.</p>
<p class="calibre2">One way of performing smoothing is through moving averages. In financial applications, the simple moving average is the unweighted mean of the previous <em class="calibre16">n</em> points of data. It's like applying a moving window on top of our time series and performing the calculation using the visible data. Then, we slide the window by one position and repeat the calculation. To smooth out seasonal data, the window should be the size of the seasonal period—in our case, 12 months. So, to apply simple moving average smoothing to our data, we'll start by taking the first 12 month period (the year 2005), sum up the values, and then divide them by 12 to get their average. Then, we'll slide our window by one month and repeat the computation. As a result, we eliminate the effect of the seasonal component and cancel out the impact of the noise.</p>
<p class="calibre2">The <kbd class="calibre12">TimeSeries</kbd> package provides a series of <em class="calibre16">apply methods</em> that implement common transformations of time series data. One of them is the <kbd class="calibre12">moving</kbd> method, which can be used to compute the moving average of a series. Let's compute the moving average for a 12 month interval in order to smooth out the seasonality component:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; using Statistics 
julia&gt; moving_avg = moving(mean, unemployment_data, 12) 
145×1 TimeArray{Float64,2,Date,Array{Float64,2}} 2005-12-01 to 2017-12-01</strong> </pre>
<p class="calibre2">The result is as follows:</p>
<p class="CDPAlignCenter"><img src="assets/db85a03f-60fd-4570-bada-64b584638829.png" class="calibre179"/></p>
<p class="calibre2">As we can see, the result is a new time series that contains the mean of 12-month periods in our original time series. The first 12 values of the original series are consumed by this operation so that our new series starts with December 2005. If you wish to keep the initial values, the <kbd class="calibre12">moving</kbd> function takes an additional keyword argument, <kbd class="calibre12">padding</kbd>. By default, <kbd class="calibre12">padding</kbd> is <kbd class="calibre12">false</kbd>, but if set to <kbd class="calibre12">true</kbd>, the consumed timestamps will be kept and their values will be set to <kbd class="calibre12">NaN</kbd>:</p>
<pre class="calibre17"><strong class="calibre1"> julia&gt; moving(mean, unemployment_data, 12, padding = true)</strong><br class="title-page-name"/><strong class="calibre1"> 156×1 TimeArray{Float64,2,Date,Array{Float64,2}} 2005-01-01 to 2017-12-01</strong></pre>
<p class="calibre2">This will produce the following output:</p>
<p class="CDPAlignCenter"><img src="assets/8a396e00-49a3-4849-8fe5-571002e8c806.png" class="calibre180"/></p>
<p class="calibre2">Plotting the smoothed values on top of the original data indicates the trend:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; plot(unemployment_data) 
julia&gt; plot!(moving_avg)</strong> </pre>
<p class="calibre2">Here is our plot:</p>
<p class="CDPAlignCenter"><img src="assets/9d7e2491-e3b8-46f8-ab08-24a3632989f5.png" class="calibre181"/></p>
<p class="calibre2">The first call to the <kbd class="calibre12">plot</kbd> method renders the raw EU unemployment figures, while the subsequent call of the <kbd class="calibre12">plot!</kbd> method mutates the plot, overlaying the moving average that corresponds to the trend.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Computing the seasonality</h1>
                </header>
            
            <article>
                
<p class="calibre2">Now that we have extracted the trend, we can remove it from the initial time series. This is done by division. We will be left with the product of the seasonal and noise components. Thus, <em class="calibre16">SN = Y/T</em>.</p>
<p class="calibre2">To calculate the fraction between <kbd class="calibre12">TimeArray</kbd> objects, we'll use the element-wise division operator, <kbd class="calibre12">./</kbd>:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; sn = unemployment_data ./ moving_avg 
145×1 TimeArray{Float64,2,Date,Array{Float64,2}} 2005-12-01 to 2017-12-01 </strong> </pre>
<p class="calibre2">We will get the following result:</p>
<p class="CDPAlignCenter"><img src="assets/f41594b9-1cfb-465f-a546-b049443ec16f.png" class="calibre182"/></p>
<p class="calibre2">Plotting the resulting <kbd class="calibre12">TimeArray</kbd> will give us a clearer image of the product of the seasonality and noise components:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; plot(sn)</strong> </pre>
<p class="calibre2">This results in the following plot:</p>
<p class="CDPAlignCenter"><img src="assets/062eaaec-3351-479f-aa72-f2911041b9b0.png" class="calibre183"/></p>
<p class="calibre2">The next step is calculating the sum over years of these values for the same month. That is, we'll sum the value for all of the months of January throughout all the years; then, we will do the same for February, March, and so on. We'll get the average over all the years, for each calendar month. This will lead to the minimization of the noise:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; month_avg = Float64[] 
0-element Array{Float64,1} </strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">julia&gt; for m in 1:12 
            md = when(sn, month, m) 
            push!(month_avg, mean(TimeSeries.values(md)[:]))  
       end</strong> </pre>
<p class="calibre2">First, we instantiate a <kbd class="calibre12">Vector</kbd> of <kbd class="calibre12">Float64</kbd> values. Then, we iterate over a range between <kbd class="calibre12">1</kbd> and <kbd class="calibre12">12</kbd>, which represents the months. Within the loop, we apply the <kbd class="calibre12">when</kbd> method to filter the values for the currently iterated month (all the January values for all the years, then all the February values for all the years, then March, and so on), and then we push the mean of these values into the <kbd class="calibre12">month_avg</kbd> array. At the end of the loop, we collect these values in <kbd class="calibre12">month_avg</kbd>, where the first is the average value for the month of January across all the years, the second for February, then March, and so on. It will look like this:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; month_avg 
12-element Array{Float64,1}: 
 1.0376512639850295 
 1.0466377033754193 
 1.0301198608484736 
 1.0014842494206564 
 0.9830320492870818 
 0.9705256323692862 
 0.9630153389575429 
 0.9634443756458616 
 0.9763782494700372 
 0.9893785521401298 
 0.9987100016253194 
 0.9913489915307253</strong> </pre>
<p class="calibre2">Theoretically, these values should add up to <kbd class="calibre12">12</kbd>. In practice, that doesn't happen (although we're pretty close). We can easily sum up all of the elements of an array using the <kbd class="calibre12">sum</kbd> function:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; s = sum(month_avg) 
11.951726268655563</strong> </pre>
<p class="calibre2">As a consequence, we need to normalize the averages so that they <em class="calibre16">do</em> sum up to <kbd class="calibre12">12</kbd>. This is achieved by multiplying each seasonal factor by <kbd class="calibre12">12</kbd> and then dividing each factor by their sum:</p>
<pre class="calibre17">julia&gt; norm_month_avg = map(m -&gt; 12m/s, month_avg) </pre>
<p class="calibre2">We used the <kbd class="calibre12">map</kbd> function to iterate over each item in <kbd class="calibre12">month_avg</kbd> as <kbd class="calibre12">m</kbd> and applied an anonymous function so that <kbd class="calibre12">m = 12m/s</kbd>:</p>
<pre class="calibre17">12-element Array{Float64,1}: 
 1.0418423989910408 
 1.0508651351431808 
 1.0342805760704734 
 1.0055293037095092 
 0.9870025740450584 
 0.9744456429674838 
 0.9669050150351592 
 0.9673357846281114 
 0.9803218991358666 
 0.993374710799588  
 1.0027438505627655 
 0.9953531089117633 </pre>
<p class="calibre2">Let's check the sum again:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; sum(norm_month_avg) 
12.0</strong> </pre>
<p class="calibre2">Perfection!</p>
<p class="calibre2">Now that we have calculated the monthly seasonal factor, we can perform the seasonal adjustment on our original time series by dividing it by the seasonal factor. This way, we'll get the reminder, which represents the product of trend and noise—<em class="calibre16">Y/S = TN</em>. To compute this in Julia, we have to divide each value of <kbd class="calibre12">unemployment_data</kbd> by the corresponding monthly seasonal factor.</p>
<p class="calibre2">To keep things clean and tidy, let's copy our original time series into a different object:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; adj_unemployment_data = deepcopy(unemployment_data) 
156×1 TimeArray{Float64,2,Date,Array{Float64,2}} 2005-01-01 to 2017-12-01</strong> </pre>
<p class="calibre2">The <kbd class="calibre12">deepcopy</kbd> function creates a deep copy of the object, given as an argument. A deep copy means that everything is copied recursively, resulting in a fully independent object.</p>
<p class="calibre2">Next, we can use the <kbd class="calibre12">map</kbd> function to modify the <kbd class="calibre12">TimeArray</kbd> in place by recursively applying a function that divides the original value by the seasonality:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; map(adj_unemployment_data) do d,v 
           v[1] /= norm_month_avg[month(d)] 
           d,v 
       end 
156×1 TimeArray{Float64,2,Date,Array{Float64,2}} 2005-01-01 to 2017-12-01</strong> </pre>
<p class="calibre2">The result is as follows:</p>
<p class="CDPAlignCenter"><img src="assets/a22f7a94-52c1-4941-9ac4-ffb36a8af057.png" class="calibre184"/></p>
<p class="calibre2">The <kbd class="calibre12">adj_unemployment_data</kbd> variable represents the seasonally adjusted time series.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">TimeSeries operators</h1>
                </header>
            
            <article>
                
<p class="calibre2">Performing operations between <kbd class="calibre12">TimeArray</kbd> objects—or rather between the elements contained in them—is a common occurrence in time series analysis. The <kbd class="calibre12">TimeSeries</kbd> package exposes a complete set of element-wise operators for mathematical, comparison, and logical operations.</p>
<p class="calibre2">As we have already seen when doing division between two <kbd class="calibre12">TimeArray</kbd> objects, the mathematical operators create a new <kbd class="calibre12">TimeArray</kbd> instance by using the values with common timestamps. Operations between a single <kbd class="calibre12">TimeArray</kbd> and <kbd class="calibre12">Int</kbd> or <kbd class="calibre12">Float</kbd> are also supported. The following operators are available:</p>
<ul class="calibre10">
<li class="calibre11"><kbd class="calibre12">.+</kbd>: Arithmetic element-wise addition</li>
<li class="calibre11"><kbd class="calibre12">.-</kbd>: Arithmetic element-wise subtraction</li>
<li class="calibre11"><kbd class="calibre12">.*</kbd>: Arithmetic element-wise multiplication</li>
<li class="calibre11"><kbd class="calibre12">./</kbd>: Arithmetic element-wise division</li>
<li class="calibre11"><kbd class="calibre12">.^</kbd>: Arithmetic element-wise exponentiation</li>
<li class="calibre11"><kbd class="calibre12">.%</kbd>: Arithmetic element-wise remainder</li>
</ul>
<p class="calibre2">Similar to mathematical operators, in the case of comparison ones, when two <kbd class="calibre12">TimeArray</kbd> instances are provided, the values are compared on shared timestamps too. However, the difference, in this case, is that the result will be a time array of type <kbd class="calibre12">Bool</kbd>.</p>
<p class="calibre2">These are the available comparison operators:</p>
<ul class="calibre10">
<li class="calibre11"><kbd class="calibre12">.&gt;</kbd>: Element-wise greater-than comparison</li>
<li class="calibre11"><kbd class="calibre12">.&lt;</kbd>: Element-wise less-than comparison</li>
<li class="calibre11"><kbd class="calibre12">.==</kbd>: Element-wise equivalent comparison</li>
</ul>
<ul class="calibre10">
<li class="calibre11"><kbd class="calibre12">.&gt;=</kbd>: Element-wise greater-than or equal comparison</li>
<li class="calibre11"><kbd class="calibre12">.&lt;=</kbd>: Element-wise less-than or equal comparison</li>
<li class="calibre11"><kbd class="calibre12">.!=</kbd>: Element-wise not-equivalent comparison</li>
</ul>
<p class="calibre2">Let's look at an example. First, let's create a <kbd class="calibre12">TimeArray</kbd> spreading between a week ago and today and fill it with random values. Your timestamps will be different as you'll run the code sometime in the future, and so the output will be different compared to mine, but the logic will be the same. Don't forget to execute <kbd class="calibre12">using Dates</kbd> if the module is not already in scope:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; using Dates 
julia&gt; ts1 = TimeArray(Date(today()) - Week(1):Day(1):Date(today()) |&gt; collect, rand(8)) 
8×1 TimeArray{Float64,1,Date,Array{Float64,1}} 2018-11-06 to 2018-11-13</strong> </pre>
<p class="calibre2">This is what we get:</p>
<p class="CDPAlignCenter"><img src="assets/780158c5-3bc1-49b3-84fd-b1c21f1ec1a7.png" class="calibre185"/></p>
<p class="calibre2">Now, we'll do the same for the second array:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; ts2 = TimeArray(Date(today()) - Week(1):Day(1):Date(today()) |&gt; collect, rand(8)) 
8x1 TimeSeries.TimeArray{Float64,1,Date,Array{Float64,1}} 2018-01-31 to 2018-02-07</strong> </pre>
<p class="calibre2">This is what we get:</p>
<p class="CDPAlignCenter"><img src="assets/3b641102-005b-4c98-b97d-b34e2cd7160b.png" class="calibre186"/></p>
<p class="calibre2">Now, we can compare the two objects, for instance:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; tsc = ts1 .&gt; ts2 
8×1 TimeArray{Bool,1,Date,BitArray{1}} 2018-11-06 to 2018-11-13</strong> </pre>
<p class="calibre2">The output is as follows:</p>
<p class="CDPAlignCenter"><img src="assets/12cafc14-56f4-43e9-834f-867a24c27ec6.png" class="calibre187"/></p>
<p class="calibre2">Comparisons between a single <kbd class="calibre12">TimeArray</kbd> and <kbd class="calibre12">Int</kbd>, <kbd class="calibre12">Float</kbd>, or <kbd class="calibre12">Bool</kbd> values are supported too:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; tsc .== false 
8×1 TimeArray{Bool,1,Date,BitArray{1}} 2018-11-06 to 2018-11-13</strong>  </pre>
<p class="calibre2">Now, the output is as follows:</p>
<p class="CDPAlignCenter"><img src="assets/08bf2425-0ad4-450b-b506-39c5a376347b.png" class="calibre188"/></p>
<p class="calibre2">Finally, we can use the following logic operators:</p>
<ul class="calibre10">
<li class="calibre11"><kbd class="calibre12">.&amp;</kbd> element-wise logical <kbd class="calibre12">AND</kbd></li>
<li class="calibre11"><kbd class="calibre12">.|</kbd> element-wise logical <kbd class="calibre12">OR</kbd></li>
<li class="calibre11"><kbd class="calibre12">.!</kbd>, <kbd class="calibre12">.~</kbd> element-wise logical <kbd class="calibre12">NOT</kbd></li>
<li class="calibre11"><kbd class="calibre12">.</kbd><kbd class="calibre12">⊻</kbd> element-wise logical <kbd class="calibre12">XOR</kbd></li>
</ul>
<p class="calibre2">They are defined for <kbd class="calibre12">TimeArrays</kbd> of type <kbd class="calibre12">Bool</kbd> and return a <kbd class="calibre12">TimeArray</kbd> of type <kbd class="calibre12">Bool</kbd>. Values are computed on common timestamps when two <kbd class="calibre12">TimeArray</kbd> objects are the operands and operations between a single <kbd class="calibre12">TimeArray</kbd> and a <kbd class="calibre12">Bool</kbd> are supported.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Time series stationarity</h1>
                </header>
            
            <article>
                
<p class="calibre2">A time series is considered stationary if its statistical properties such as mean, variance, autocorrelation, and so on, are constant over time. <strong class="calibre4">Stationarity</strong> is important because most forecasting models run on the assumption that the time series is stationary or can be rendered (approximately) stationary using transformations. The reason for this approach is that values in a stationary time series are much easier to predict—if its properties are constant, we can simply state that they will be in the future as they were in the past. Once we forecast future values based on stationary time series, we can then reverse the process and the transformations to compute the values that would match the original series.</p>
<p class="calibre2">Thus, the properties of a stationary time series do not depend on the time when the series is observed. Implicitly, this means that time series that present seasonality or trends are not stationary. In this context, again, we must be careful of the difference between seasonality and cyclicity—cyclic time series that do not expose seasonal or trending patterns <em class="calibre16">are</em> stationary.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Differencing a time series</h1>
                </header>
            
            <article>
                
<p class="calibre2">One way to make a time series stationary is by <em class="calibre16">differencing</em>. This means computing the difference between consecutive values. In this technique, we calculate the difference between a value at a certain point in time and the one at the previous instant.</p>
<p class="calibre2">This can be easily computed by using the <kbd class="calibre12">diff</kbd> method that's provided by <kbd class="calibre12">TimeSeries</kbd>. Differentiating a time series calculates the finite difference between two consecutive points in the time series. By default, the difference is by one day. Consider the following, for instance:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; diffts = diff(unemployment_data) 
155×1 TimeArray{Float64,2,Date,Array{Float64,2}} 2005-02-01 to 2017-12-01</strong> </pre>
<p class="calibre2">One day from the original series is lost as part of the operation, with the resulting <kbd class="calibre12">TimeArray</kbd> beginning on January 2, 2005, resulting in the following:</p>
<p class="CDPAlignCenter"><img src="assets/ce2a54b2-d31c-4df3-85b4-e0a2b09d7af7.png" class="calibre189"/></p>
<p class="calibre2">We can render the result as a bar plot:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; bar(diffts)</strong></pre>
<p class="calibre2">We get the following result:</p>
<p class="CDPAlignCenter"><img src="assets/a1735f08-90c2-416a-a1a2-95557449f6d6.png" class="calibre190"/></p>
<p class="calibre2">Changes in the values are clearly visible throughout the entire dataset, meaning that the variance is relatively constant.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Autocorrelation</h1>
                </header>
            
            <article>
                
<p class="calibre2">Autocorrelation represents the degree of similarity of a time series and a lagged version of itself over successive time intervals. It is a very important concept as it measures the relationship between a current value and a corresponding past value. Thus, it has many valuable applications in time series forecasting; for example, to match trends and relationships in prices, stocks, returns, and so on.</p>
<p class="calibre2">We want to use autocorrelation to determine if we can reliably identify causality and trend <span class="calibre5">–</span> or if, on the contrary, we're dealing with a random walk model. A random walk would imply that the values in the time series are randomly defined, and this would imply that there's no relationship between past and present values. The random walk model is common, especially for financial and economic data. For a random walk model, forecasting the next value is done by taking the last value in the series. This is due to the fact that future movements are unpredictable—they are equally likely to be increasing or decreasing. Thus, the random walk model underpins naïve forecasts.</p>
<p class="calibre2">We can compute autocorrelation by using a combination of two functions—<kbd class="calibre12">TimeSeries.lag</kbd> and <kbd class="calibre12">xcorr</kbd>. The <kbd class="calibre12">lag</kbd> method works by shifting the values of the time series. For instance, let's use our previously defined <kbd class="calibre12">ts1</kbd>:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; ts1 
8×1 TimeArray{Float64,1,Date,Array{Float64,1}} 2018-11-06 to 2018-11-13</strong> </pre>
<p class="calibre2">We get the following result:</p>
<p class="CDPAlignCenter"><img src="assets/e8490e06-5b4f-4177-972a-5dcdc07db0c5.png" class="calibre191"/></p>
<p class="calibre2">We can apply the <kbd class="calibre12">lag</kbd> function as follows:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; lag(ts1) 
7×1 TimeArray{Float64,1,Date,Array{Float64,1}} 2018-11-07 to 2018-11-13 </strong></pre>
<p class="calibre2">This will cause the first value to be assigned to the next timestamp. In my case, the value <kbd class="calibre12">0.3903</kbd>, which was initially corresponding to <kbd class="calibre12">2018-11-06</kbd>, now corresponds to <kbd class="calibre12">2018-11-07</kbd>:</p>
<p class="CDPAlignCenter"><img src="assets/5abd220a-976f-49e5-a274-89dcabea6cf3.png" class="calibre192"/></p>
<div class="packttip">Remember that if you run the code in parallel, your data will be different (the actual dates and values are different since we're using random values), but the behavior will be the same.</div>
<p class="calibre2">We can experiment with lagging the unemployment data by <kbd class="calibre12">12</kbd> intervals (12 months) to account for the yearly seasonality:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; lagged = lag(unemployment_data, 12) 
144×1 TimeArray{Float64,2,Date,Array{Float64,2}} 2006-01-01 to 2017-12-01</strong> </pre>
<p class="calibre2">The output is as follows:</p>
<p class="CDPAlignCenter"><img src="assets/0b7d22d0-a167-4ee3-ac10-a6bff223918a.png" class="calibre193"/></p>
<p class="calibre2">The values have been shifted and the resulting <kbd class="calibre12">TimeArray</kbd> starts on the January 1, 2006. We can now use <kbd class="calibre12">TimeSeries.merge</kbd> to join the two series on the common timestamps:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; common = merge(unemployment_data, lagged) 
144×2 TimeArray{Float64,2,Date,Array{Float64,2}} 2006-01-01 to 2017-12-01</strong> </pre>
<p class="calibre2">This results in the following output:</p>
<p class="CDPAlignCenter"><img src="assets/0daad74d-3e4d-4a16-a170-baafee8259e2.png" class="calibre194"/></p>
<p class="calibre2">If we plot the original unemployment data together with the one year lagged series, we can see that the data is positively correlated, indicating strong yearly seasonality:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; plot(unemployment_data) julia&gt; plot!(lagged)</strong> </pre>
<p class="calibre2"> </p>
<p class="calibre2">The output is as follows:</p>
<p class="CDPAlignCenter"/>
<p class="CDPAlignCenter"><img src="assets/d7a5dcd7-fc92-41bc-b099-dd7965beacc5.png" class="calibre195"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Time series forecasting</h1>
                </header>
            
            <article>
                
<p class="calibre2">Forecasting implies identifying models that fit the historical data and using them to predict future values. When forecasting time series data, decomposition plays a very important part, helping to make predictions more accurate. The underlying assumption is that we can be more precise if we forecast each component individually, using the best-suited method, and then sum or multiply the parts (depending on whether the model is additive or multiplicative) to compute the final value.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Naïve</h1>
                </header>
            
            <article>
                
<p class="calibre2">This is the simplest method, stating that the forecasted value is equal to the last value in the series. As mentioned previously, this is used with random walk models, where future movements are unpredictable. For example, to predict the value for the first unknown month, January 2018, using the na<span class="calibre5">ï</span>ve model, we can take the seasonally adjusted value from December 2017 and add (multiply) the seasonal component of the month of January:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; update(unemployment_data, Date(2018, 1, 1), </strong><br class="title-page-name"/><strong class="calibre1">            TimeSeries.values(adj_unemployment_data[end])[:][end] * norm_month_avg[1] |&gt; round) 
157×1 TimeArray{Float64,2,Date,Array{Float64,2}} 2005-01-01 to 2018-01-01</strong> </pre>
<p class="calibre2">We use the <kbd class="calibre12">TimeSeries.update</kbd> method to append a new item for January 2018. Its value is the seasonality adjusted value of December 2017, multiplied by the normalized seasonality of the month of January:</p>
<p class="CDPAlignCenter"><img src="assets/d18a8e40-afba-409f-9f2c-8bdecb9a5dc2.png" class="calibre196"/></p>
<p class="calibre2">Notice that we also assume that the seasonal component is unchanged, which means that we're using the seasonal naïve method for the seasonal component.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Simple average</h1>
                </header>
            
            <article>
                
<p class="calibre2">A method that is slightly more advanced involves computing the mean of the previous data points to forecast the next value. It's a basic approach but in some situations, it can be a good fit. To compute it, we can apply the <kbd class="calibre12">mean</kbd> function to the underlying array of values:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; mean(TimeSeries.values(adj_unemployment_data)[:]) 
21589.641025641027</strong> </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Moving average</h1>
                </header>
            
            <article>
                
<p class="calibre2">We covered the moving average in detail when we extracted the trend component of our time series. It can also be employed for forecasting, using the result of the computation to fill up the next value. It is important to pick the right window size by understanding the series' seasonality, for example, by using autocorrelation plots.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Linear regression</h1>
                </header>
            
            <article>
                
<p class="calibre2">We can use linear regression on the seasonally adjusted time series to forecast the next value. Let's take a closer look at this since it presents some good opportunities to dive into interesting Julia code. Since our data presents three trends (down, up, and down again), let's focus only on the last segment, where the current downward trend can be observed:</p>
<p class="CDPAlignCenter"><img src="assets/8d5c2dbe-ff7c-4bb9-be65-b4b45d903353.png" class="calibre197"/></p>
<p class="calibre2"/>
<p class="calibre2">We can see that the current trend had started with an unemployment peak, so all we have to do is look for the maximum value in the series:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; findall(adj_unemployment_data[:Values] .==  </strong><br class="title-page-name"/><strong class="calibre1">            maximum(TimeSeries.values(adj_unemployment_data)[:])) 
1-element Array{Int64,1}: 
 98 </strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">julia&gt; adj_unemployment_data[98] 
1×1 TimeArray{Float64,2,Date,Array{Float64,2}} 2013-02-01 to 2013-02-01 </strong></pre>
<p class="calibre2">We get the following value:</p>
<p class="CDPAlignCenter"><img src="assets/3ee71ee6-5f1e-4d1a-96a3-3a637f89e3e5.png" class="calibre198"/></p>
<p class="calibre2">The downward trend started in February 2013. Let's extract all the data from that moment onward, all the way until the end of the series:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; last_trend = from(adj_unemployment_data, Date(2013, 2, 1)) 
59×1 TimeArray{Float64,2,Date,Array{Float64,2}} 2013-02-01 to 2017-12-01</strong> </pre>
<p class="calibre2">The result is as follows:</p>
<p class="CDPAlignCenter"><img src="assets/7aeb19dc-f5f8-4506-bdb1-74066968866b.png" class="calibre199"/></p>
<p class="calibre2">We can now compute the linear regression—it will summarize the relationship between the unemployment numbers and the passing of time, allowing us to forecast the next value in the series. We have our unemployment numbers on the <em class="calibre16">y</em>-axis of the plot and the time on the <em class="calibre16">x</em>-axis. In this case, we can express <kbd class="calibre12">y</kbd> with the formula <kbd class="calibre12">y = a+b*x</kbd>, where <kbd class="calibre12">a</kbd> and <kbd class="calibre12">b</kbd> correspond to the linear regression. We'll compute the linear regression for the trend series to get <kbd class="calibre12">a</kbd> and <kbd class="calibre12">b</kbd>, and we'll calculate the next value of <kbd class="calibre12">y</kbd> (the unemployment forecast), corresponding to the next value of <kbd class="calibre12">x</kbd> (January 2018). Let's go through this, step by step.</p>
<p class="calibre2">The first thing we need to do is convert the timestamps in the time series into a simple integer series that we can use in our equation:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; x = 1:length(last_trend) 
1:59 </strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">julia&gt; y = values(last_trend)[:] 
59-element Array{Float64,1}: 
 27790.0 
 27292.0 
# output truncated </strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">julia&gt; linreg(x, y) = reverse([x ones(length(x))]\y) </strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">julia&gt; a, b = linreg(x, y) 
2-element Array{Float64,1}: 
 27522.02805376972 
  -161.58229105786072 </strong> </pre>
<p class="calibre2">On the <em class="calibre16">x</em>-axis, we use integer values from <kbd class="calibre12">1</kbd> to <kbd class="calibre12">59</kbd>, instead of the actual dates. In this line of thought, the next value, the one we want to forecast, will be <kbd class="calibre12">x = 60</kbd>, which means that our next <kbd class="calibre12">y</kbd> (the forecasted unemployment value) will be <em class="calibre16">27,608.61 + (-167.13 * 60)</em>:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; y = a+b*60 
17827.09059029808</strong> </pre>
<p class="calibre2">Like we did previously, we need to add the seasonality for the month of January:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; y = y * norm_month_avg[1] |&gt; round 
18573.0</strong> </pre>
<p class="calibre2">Now, we can append it to our unemployment data and plot it:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; update(unemployment_data, Date(2018, 1, 1), y) |&gt; plot 
julia&gt; plot!(unemployment_data)</strong> </pre>
<p class="calibre2">The result is the following plot:</p>
<p class="CDPAlignCenter"><img src="assets/f48963a1-5285-4091-91ac-a9e9ba0cbf6c.png" class="calibre200"/></p>
<p class="calibre2">Our forecasted value has shown up on the plot.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Closing thoughts</h1>
                </header>
            
            <article>
                
<p class="calibre2">It should be mentioned that the preceding sections represent only a few of the simplest forecasting methods available. We focused on gaining a good understanding of time series decomposition, which is a key tool for both analysis and forecasting. However, more powerful and more complex forecasting algorithms are available, for example, <strong class="calibre4">autoregressive integrated moving average</strong> (<strong class="calibre4">ARIMA</strong>), <strong class="calibre4">artificial neural networks</strong> (<strong class="calibre4">ANN</strong>), and Holt-Winters. These are recommended for business-critical predictions. We have now set the foundation for understanding them, but their implementations are more involved and would go beyond the technical expertise assumed by this chapter—especially as Julia's package ecosystem, at the time of writing, does not provide any libraries that implement these algorithms, and we'd have to write them from scratch.</p>
<p class="calibre2">For instance, one commonly-used time series forecasting technique is the Holt-Winters method, also called <strong class="calibre4">Triple exponential smoothing</strong>. It is based on weighted moving averages and exponential smoothing, both of which have been covered already. You can read more about these at <a href="https://www.otexts.org/fpp/7/2" class="calibre9"><span>https://www.otexts.org/fpp/7/2</span></a> and <a href="https://www.otexts.org/fpp/7/5" class="calibre9"><span>https://www.otexts.org/fpp/7/5</span></a>.</p>
<p class="calibre2">ARIMA models are yet another very popular forecasting algorithm. They don't use the trend and seasonality components, instead focusing on autocorrelations in the data. If you're curious, a good starting point to learn about ARIMA models is <a href="https://www.otexts.org/fpp/8" class="calibre9"><span>https://www.otexts.org/fpp/8</span></a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p class="calibre2">Time series are a very common type of data—they can be used to represent key business metrics such as financial prices, resource usage (energy, water, raw materials, and so on), weather patterns, or macroeconomic trends—and the list could go on and on. The particularity of time series is that the data has to be collected at regular intervals, and the key aspect of time series analysis is exploring ways that allow us to understand past values so that we can predict future ones.</p>
<p class="calibre2">One powerful approach is to decompose a time series into a combination of trend, cycle, seasonality, and irregular (also called <strong class="calibre4">error</strong> or <strong class="calibre4">noise</strong>). We learned how to do this in this chapter while we analysed the EU's unemployment data. We started by learning to compute the trend component by means of moving averages. Then, we applied multiplicative series decomposition formulas to calculate seasonality and error, and we also applied basic forecasting methods to predict future values. In the process, we learned about more advanced <kbd class="calibre12">TimeSeries</kbd> methods and we experimented further with <kbd class="calibre12">Plots</kbd>. That was quite a ride—congratulations!</p>
<p class="calibre2">In the next chapter, we will look at a few more advanced topics, including package development, benchmarking techniques for measuring and improving performance, generating documentation, and registering packages. How exciting—see you in the next chapter!</p>


            </article>

            
        </section>
    </body></html>