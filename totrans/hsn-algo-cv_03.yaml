- en: Array and Matrix Operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we're past the first part of the book and the introductions and fundamental
    concepts in computer vision, we can start with the computer vision algorithms
    and functions provided by the OpenCV library, which more or less cover any computer
    vision topic that comes to mind, with optimized implementations. As we learned
    in the previous chapters, OpenCV uses a modular structure to categorize the computer
    vision functionalities contained in it. We'll move forward with the topics in
    this book with a similar structure in mind, so that the skills learned are related
    to each other in each chapter, not just from a theoretical point of view, but
    also from a hands-on perspective.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, we learned about the relationship between images and
    matrices, and covered the most crucial functionalities of the `Mat` class, such
    as constructing it using a given width, height, and type. We also learned how
    to read images from disk, a network feed, video files, or cameras. During the
    process, we learned how to access pixels in an image using various methods. We
    can now start with actual image- and pixel-modification and manipulation functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we're going to learn about a large number of functions and
    algorithms that are used to deal with images, either for calculating a value that
    might be useful in another process or for directly modifying the values of the
    pixels in an image. Almost all of the algorithms presented in this chapter are
    based on the fact that images are essentially matrices, and also the fact that
    matrices are implemented using arrays of data, hence the name of this chapter!
  prefs: []
  type: TYPE_NORMAL
- en: We'll start this chapter by covering the functionalities within the `Mat` class
    itself, which are few, but quite important when it comes to the creation of initial
    matrices and so on. Then, we'll move on to learn about a large number of per-element
    (or element-wise) algorithms. These algorithms, as we'll learn by going through
    many hands-on examples, apply a specific operation on each individual element
    of a matrix and they are not concerned with any other element (or pixel). Finally,
    we'll learn about matrix and array operations that are not element-wise and the
    result may depend on the whole image or groups of elements. This will all clear
    up as we move forward with the algorithms in this chapter. It's important to note
    that all of the algorithms and functions in this chapter are contained within
    the core module of OpenCV library.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you''ll have a better understanding of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Operations contained in the `Mat` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Element-wise matrix operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Matrix and array-wise operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An IDE to develop C++ or Python applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The OpenCV library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refer to [Chapter 2](part0030.html#SJGS0-15c05657f8254d318ea883ef10fc67f4),
    *Getting Started with OpenCV*, for more information about how to set up a personal
    computer and make it ready for developing computer vision applications using OpenCV
    library.
  prefs: []
  type: TYPE_NORMAL
- en: You can use the following URL to download the source codes and examples for
    this chapter: [https://github.com/PacktPublishing/Hands-On-Algorithms-for-Computer-Vision/tree/master/Chapter03](https://github.com/PacktPublishing/Hands-On-Algorithms-for-Computer-Vision/tree/master/Chapter03)
  prefs: []
  type: TYPE_NORMAL
- en: Operations contained in the Mat class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we're going to go through the set of mathematical and other
    operations that are contained inside the `Mat` class itself. Even though there
    is no general pattern of usage for the functions in the `Mat` class, most of them
    are related to creating a new matrix, whether it is using an existing one or from
    scratch. So, let's start.
  prefs: []
  type: TYPE_NORMAL
- en: During the course of the book, the words image, matrix, the `Mat` class, and
    so on will be used interchangeably, and they all mean the same thing, unless explicitly
    stated. Take this chance to get used to the idea of thinking about images in terms
    of matrices, just like a computer vision expert would do.
  prefs: []
  type: TYPE_NORMAL
- en: Cloning a matrix
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can use `Mat::clone` to create a completely independent clone of a `Mat`
    object. Note that this function creates a full copy of the image with its own
    allocated space in memory. Here''s how it''s used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use the `copyTo` function to do the same, as seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In both of the preceding code examples, `image` is the original matrix (or image)
    that is read from an image, camera, or produced in any possible way prior to performing
    the cloning operation. From now on, and in all of the examples in this and upcoming
    chapters, `image` is simply a `Mat` object that is the source of our operations,
    unless otherwise stated.
  prefs: []
  type: TYPE_NORMAL
- en: Calculating the cross-product
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can use `Mat::cross` to calculate the cross-product of two `Mat` objects
    that have three floating-point elements, as seen in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Obviously, `AxB` is not the same as `BxA` in the cross-product of two vectors.
  prefs: []
  type: TYPE_NORMAL
- en: Extracting a diagonal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Mat::diag` can be used to extract a diagonal from a `Mat` object, as seen
    in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This function accepts an index parameter that can be used to extract additional
    diagonals beside the main diagonal, as depicted in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00019.gif)'
  prefs: []
  type: TYPE_IMG
- en: If **D=0**, then the extracted diagonal will contain **1**, **6**, **11**, and
    **16**, which is the main diagonal. But depending on the value of **D**, the extracted
    diagonal will be above or below the main diagonal, as seen in the preceding diagram.
  prefs: []
  type: TYPE_NORMAL
- en: Calculating the dot product
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To calculate the dot product, or scalar product, or inner product of two matrices,
    you can use the `Mat::dot` function, as seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this, `A` and `B` are both OpenCV `Mat` objects.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about the identity matrix
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Identity matrices are created using the `Mat::eye` function in OpenCV. Here''s
    an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In case you need a value other than the ones in the identity matrix diagonal,
    you can use a `scale` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Another way of creating an identity matrix is by using the `setIdentity` function.
    Make sure to check the OpenCV documentation for more information about this function.
  prefs: []
  type: TYPE_NORMAL
- en: Matrix inversion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can use the `Mat::inv` function to invert a matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note that you can supply a matrix decomposition type to the `inv` function,
    which can be an entry in the `cv::DecompTypes` enum.
  prefs: []
  type: TYPE_NORMAL
- en: Element-wise matrix multiplication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Mat::mul` can be used to perform an element-wise multiplication of two `Mat`
    objects. Needless to say, this same function can also be used for element-wise
    division. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also supply an additional `scale` parameter that will be used to scale
    the result. Here''s another example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The ones and zeroes matrix
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Mat::ones` and `Mat::zeroes` can be used to create a matrix of a given size
    with all of its elements set to one or zero, respectively. These matrices are
    usually used to create initializer matrices. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In case you need to create a matrix that is filled with a value other than
    ones, you can use something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Transposing a matrix
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can use `Mat::t` to transpose a matrix. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s an example that demonstrates the transposition of an image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00020.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The image on the left is the original image and the image on the right is the
    transpose of the original image. As you can see, the result is a rotated (clockwise)
    and flipped (vertically) version of the original image. As you'll learn later
    in this chapter, `transpose`, or the `Mat::t` function, can be used in conjunction
    with the `flip` function to rotate or flip/mirror an image in all possible directions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Transposing a transpose matrix is the same as the original matrix, and running
    the following code will result in the original image itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Mat org = image.t().t();`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way of calculating the transpose of a matrix is by using the `transpose`
    function. Here''s an example of how this function is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In which `mat` and `trp` are both `Mat` objects.
  prefs: []
  type: TYPE_NORMAL
- en: Reshaping a Mat object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A `Mat` object can be reshaped using the `Mat::reshape` function. Note that
    reshaping, in this sense, means changing the number of channels and rows of an
    image. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note that passing a value of zero as the number of channels means that the number
    of channels will stay the same as the source. Similarly, passing a value of zero
    as the number of rows means the number of rows in the image will stay the same.
  prefs: []
  type: TYPE_NORMAL
- en: Note that `Mat::resize` is another useful function for reshaping a matrix, but
    it only allows changing the number of rows in an image. Another function that
    can come in handy when reshaping matrices or dealing with the number of elements
    in a matrix, is the `Mat::total` function, which returns the total number of elements
    in an image.
  prefs: []
  type: TYPE_NORMAL
- en: That's about it for the functionalities embedded into the `Mat` class itself.
    Make sure to go through the `Mat` class documentation and familiarize yourself
    with possible variants of the methods you just learned in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Element-wise matrix operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Per-element or element-wise matrix operations are mathematical functions and
    algorithms in computer vision that work on individual elements of a matrix or,
    in other words, pixels of an image. It's important to note that element-wise operations
    can be parallelized, which fundamentally means that the order in which the elements
    of a matrix are processed is not important. This specification is the most important
    feature that separates the functions and algorithms in this section and the upcoming
    sections of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Basic operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OpenCV provides all the necessary functions and overloaded operators that you
    need to perform all four basic operations of addition, subtraction, multiplication,
    and division between two matrices or a matrix and a scalar.
  prefs: []
  type: TYPE_NORMAL
- en: The addition operation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `add` function and the `+` operator can be used to add the elements of
    two matrices, or a matrix and a scalar, as seen in the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'You can replace the last line in the preceding code with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The following image demonstrates the resulting image of an add operation of
    two images:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00021.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In case, you want to add a single scalar value to all elements of a `Mat` object,
    you can simply use something similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'If the preceding code is executed on a grayscale image, the result will be
    brighter than the source image. Note that if the image has three channels, you
    must use a three-item vector instead of a single value. For instance, to be able
    to make an RGB image brighter, you can use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s an image depicting the brighter result image, when the preceding code
    is executed on it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00022.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding example codes, simply increase the added value to get an even
    brighter image.
  prefs: []
  type: TYPE_NORMAL
- en: Weighted addition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Besides the simple addition of two images, you can also use the weighted addition
    function to consider a weight for each of the two images that are being added.
    Think of it as setting an opacity level for each of the participants in an `add`
    operation. To perform a weighted addition, you can use the `addWeighted` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If executed on the sample pictures from the previous section with the add example,
    the result would be similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00023.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Notice the transparent text that is similar to the watermark usually applied
    by photo-editing applications. Notice the comments in the code regarding the `alpha`,
    `beta`, and `gamma` values? Obviously, providing a `beta` value of `1.0` would
    have made this example exactly the same as a regular `add` function with no transparency
    for the overlay text.
  prefs: []
  type: TYPE_NORMAL
- en: The subtraction operation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Similar to adding two `Mat` objects to each other, you can also subtract all
    elements of one image from another using the `subtract` function or the `-` operator.
    Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The last line in the preceding code can also be replaced with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the result of the subtraction operation if we used the same two images
    from the previous examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00024.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Notice how the subtraction of higher pixel values (brighter pixels) from the
    source image results in the dark color of the overlay text. Also note that the
    subtraction operation depends on the order of its operands, unlike addition. Try
    swapping the operands and see what happens for yourself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like addition, it''s also possible to multiply a constant number with
    all of the pixels of an image. You can guess that subtraction of a constant value
    from all pixels will result in a darker image (depending on the subtracted value)
    which is the opposite of the addition operation. Here''s an example of making
    an image darker with a simple subtraction operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In case the source image is a three-channel RGB image, you need to use a vector
    as the second operand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The multiplication and division operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to addition and subtraction, you can also multiply all elements of a
    `Mat` object with all elements of another `Mat` object. The same can be done with
    the division operation. Again, both operations can be performed with a matrix
    and a scalar. Multiplication can be done using OpenCV's `multiply` function (similar
    to the `Mat::mul` function), while division can be performed using the `divide`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '`scale` in the preceding code is an additional parameter that can be supplied
    to the `multiply` and `divide` functions to scale all of the elements in the result
    `Mat` object. You can also perform multiplication or division with a scalar, as
    seen in the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Obviously, the preceding code will produce two images, one that is five times
    brighter and one that is five times darker than the original image. The important
    thing to note here is that, unlike addition and subtraction, the resulting image
    will not be homogeneously brighter or darker, and you'll notice that brighter
    areas become much brighter and vice versa. The reason for this is obviously the
    effect of multiplication and division operations, in which the value of brighter
    pixels grows or drops much faster than smaller values after the operation. It's
    interesting to note that this same technique is used in most photo-editing applications
    to brighten or darken the bright areas of an image.
  prefs: []
  type: TYPE_NORMAL
- en: Bitwise logical operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just like basic operations, you can also perform bitwise logical operations
    on all of the elements of two matrices or a matrix and a scalar. For this reason,
    you can use the following functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`bitwise_not`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bitwise_and`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bitwise_or`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bitwise_xor`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It''s immediately recognizable from their names that these functions can perform
    `Not`, `And`, `Or`, and `Exclusive OR` operations, but let''s see how they''re
    used in detail with some hands-on examples:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First things first, the `bitwise_not` function is used to invert all the bits
    of all pixels in an image. This function has the same effect as the inversion
    operation that can be found in most photo editing applications. Here''s how it''s
    used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code can be replaced with the following too, which uses an overloaded
    bitwise `not` operator (`~`) in C++:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'If the image is a monochrome black and white image, the result will contain
    an image with all white pixels replaced with black and vice versa. In case the
    image is an RGB color image, the result will be inverted (in the sense of its
    binary pixel values), which is depicted in the following example image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00025.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `bitwise_and` function, or the `&` operator, is used to perform a bitwise
    `And` operation on pixels from two images or pixels from an image and a scalar.
    Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'You can simply use the `&` operator and write the following instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The `bitwise_and` function can be easily used to mask and extract certain areas
    in images. For instance, the following image is a demonstration of how `bitwise_and`
    results in an image that passes the white pixels and removes the black pixels:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00026.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Besides masking certain areas of an image, the bitwise `And` operation can
    be used to filter out a channel altogether. To be able to do this, you need to
    use the second form of the `&` operator, which takes a matrix and a scalar and
    performs the `And` operation between all pixels and that value. Here is an example
    code that can be used to mask (zero out) the green color channel in an RGB color
    image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s move on to the next bitwise operation, the `Or` operation. The `bitwise_or`
    and `|` operators can both be used to perform a bitwise `Or` operation on two
    images, or an image and a scalar. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to the bitwise `And` operation, you can use the `|` operator in the `Or`
    operation and simply write the following instead of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'If the `And` operation was used to pass through the non-zero pixels (or non-black
    pixels), then it can be said that the `Or` operation is used to pass through the
    pixel with the higher value (or brighter) in any of its input images. Here''s
    the result of performing the bitwise `Or` operation on the previous example images:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00027.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Similar to bitwise `And` operation, you can also use bitwise `Or` operation
    to update an individual channel or all the pixels of an image. Here is an example
    code that shows how you can update only the green channel in an RGB image to have
    the maximum possible value (which is 255, or hexadecimal `FF`) in all of its pixels
    and leave the other channels as they are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you can use `bitwise_xor`, or the `^` operator to perform an `Exclusive
    Or` between the pixels of two images, or an image and a scalar. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Or simply use the `^` operator and write the following instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the resulting image, if the `Exclusive Or` operation is performed on
    the example image from the preceding section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00028.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Notice how this operation leads to the inversion of the pixels in the masked
    area? Think about the reason behind this by writing down the pixel values on a
    paper and trying to calculate the result by yourself. `Exclusive Or`, and all
    bitwise operations, can be used for many other computer vision tasks if their
    behavior is clearly understood.
  prefs: []
  type: TYPE_NORMAL
- en: The comparison operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Comparing two images with each other (or given values) can be quite useful,
    especially for producing masks that can be used in various other algorithms, whether
    it is for tracking some object of interest in an image or performing an operation
    on an isolated (masked) region of an image. OpenCV provides a handful of functions
    to perform element-wise comparisons. For instance, the `compare` function can
    be used to compare two images with each other. Here''s how:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The first two parameters are the first and second image that will participate
    in the comparison. The `result` will be saved into a third `Mat` object, and the
    last parameter, which must be an entry from the `CmpTypes` enum, is used to select
    the type of comparison, which can be any of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CMP_EQ`: Means that the first image equals the second image'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CMP_GT`: Means that the first image is greater than the second image'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CMP_GE`: Means that the first image is greater than or equal to the second
    image'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CMP_LT`: Means that the first image is less than the second image'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CMP_LE`: Means that the first image is less than or equal to the second image'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CMP_NE`: Means that the first image is not equal to the second image'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that we are still talking about element-wise operations, so when we say
    *first image is less than or equal to the second image*, what we actually mean
    is *each individual pixel in the first image contains a value less than or equal
    to its exact corresponding pixel in the second image*, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that you can also use the overloaded C++ operators to achieve the same
    goal as the `compare` function. Here is how, for each individual comparison type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The `inRange` function, which is another useful comparison function in OpenCV,
    can be used to find the pixels that have a value between a certain lower bound,
    and higher bound values. You can use any existing image as the boundary value
    matrices, or you can create them by yourself. Here''s an example code that can
    be used to find the pixel values between `0` and `50` in a grayscale image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Note that `lb` and `hb` are both `Mat` objects of the same size and type of
    source image, except `lb` is filled with zeroes and `hb` is filled with the value
    of `50`. This way, when `inRange` is called, it checks each individual pixel in
    the source image with their corresponding pixels in `lb` and `hb` and sets the
    corresponding pixel in the result to white if the value fits between the provided
    boundaries.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image depicts the result of the `inRange` function when it is
    executed on our example image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00029.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'The `min` and `max` functions, as it can be easily guessed from their names,
    are two other comparison functions that can be used to compare two images (element-wise)
    and find out the minimum or maximum pixel values. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Or you can use `max` to find the maximum:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Simply put, these two functions compare the pixels of two images of the same
    size and type and set the corresponding pixel in the result matrix to the minimum
    or maximum pixel value from the input images.
  prefs: []
  type: TYPE_NORMAL
- en: The mathematical operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Besides the functions we've learned about so far, OpenCV also provides a number
    of functions to deal with element-wise mathematical operations. In this section,
    we're going to go through them briefly, but you can, and you should experiment
    with them by yourself to make sure that you're familiar with them, and you can
    comfortably use them in your projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The element-wise mathematical functions in OpenCV are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `absdiff` function can be used to calculate the absolute difference between
    the pixels of two images of the same size and type or an image and a scalar. Here''s
    an example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, `image1`, `image2`, and `result` are all `Mat` objects,
    and each element in the result represents the absolute difference between corresponding
    pixels in `image1` and `image2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `exp` function can be used to calculate the exponential of all elements
    in a matrix:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The `log` function can be used to calculate the natural logarithm of every
    element in a matrix:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '`pow` can be used to raise all of the elements in a matrix to a given power.
    This function requires a matrix and a `double` value that will be the power value.
    Here''s an example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The `sqrt` function is used to calculate the square root of all elements in
    a matrix, and it''s used as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Functions such as `log` and `pow` should not be confused with the functions
    of the same name in standard C++ libraries. For better readability of your code,
    consider using the `cv` namespace before the function name in your C++ code. For
    instance, you can call the `pow` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cv::pow(image1, 3.0, result);`'
  prefs: []
  type: TYPE_NORMAL
- en: Matrix and array-wise operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unlike the functions and algorithms that we've seen so far in this chapter,
    the algorithms in this section perform an atomic and complete operation on the
    image (or matrix) itself and are not considered element-wise operations in the
    sense that has been described so far. If you recall, the rule of thumb for element-wise
    operations was that they can be easily parallelized since the resulting matrix
    is dependent on corresponding pixels of two images, whereas the functions and
    algorithms we'll learn about in this chapter are not easily parallelizable, or
    the resulting pixels and values might have little or nothing at all to do with
    their corresponding source pixels, or quite the opposite, the resulting pixels
    might depend on some or all of the input pixels at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: Making borders for extrapolation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you'll see in this and upcoming chapters, one of the most important issues
    to handle when dealing with many computer vision algorithms is extrapolation,
    or to put it simply, the assumption of the non-existing pixels outside of an image.
    You might be wondering, why would I need to think about the non-existing pixels,
    and the simplest answer is that there are many computer vision algorithms that
    work with not just a single pixel, but also with their surrounding pixels. In
    such cases, when the pixel is in the middle of an image, there are no issues.
    But for the pixels at the borders of the image (for instance, in the topmost row),
    some of the surrounding pixels will fall outside of the image. That is exactly
    where you need to think about extrapolation and the assumption of non-existing
    pixels. Are you going to simply assume those pixels have zero values? Maybe it's
    better to assume they have the same value as the border pixels? These questions
    are all taken care of in an OpenCV function called `copyMakeBorder`.
  prefs: []
  type: TYPE_NORMAL
- en: '`copyMakeBorder` allows us to form borders outside an image and provides enough
    customizations to deal with all possible scenarios. Let''s see how `copyMakeBorder`
    is used with a couple of simple examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'As seen in the preceding example, `copyMakeBorder` accepts an input image and
    produces a `result` image, just like most of the OpenCV functions we''ve learned
    about so far. In addition, this function must be provided with four integer values
    that represent the number of pixels that are added to the `top`, `bottom`, `left`,
    and `right` side of the image. However, the most important parameter that must
    be provided here is the `border` type parameter, which must be an entry of the
    `BorderTypes` enum. Here are a few of the most commonly used `BorderType` values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`BORDER_CONSTANT`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`` `BORDER_REPLICATE` ``'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BORDER_REFLECT`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BORDER_WRAP`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Note that when `BORDER_CONSTANT` is used as the border type parameter, an additional
    scalar parameter must be provided to the `copyMakeBorder` function, which represents
    the constant color value of the created border. If this value is omitted, zero
    (or black) is assumed. The following image demonstrates the output of the `copyMakeBorder`
    function when it is executed on our example image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00030.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '`copyMakeBorder`, and many other OpenCV functions, use the `borderInterpolate`
    function, internally, to calculate the position of the donor pixel used for the
    extrapolation and creating the non-existing pixels. You won''t need to call this
    function directly yourself, so we''ll leave it for you to explore and discover
    on your own.'
  prefs: []
  type: TYPE_NORMAL
- en: Flipping (mirroring) and rotating images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can use the `flip` function to flip or mirror an image. This function can
    be used to flip an image around the *x* or *y* axes, or both, depending on the
    provided flip `code`. Here''s how this function is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: If `code` is zero, the input image will be flipped/mirrored vertically (around
    the *x* axis), if `code` is a positive value, the input image will be flipped/mirrored
    horizontally (around the *y* axis), and if `code` is a negative value, the input
    image will be flipped/mirrored around both the *x* and *y* axes at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, to rotate an image, you can use the `rotate` function. What
    you need to take care of, when calling the `rotate` function, is providing a correct
    rotation flag, as seen in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The `RotateFlag` enum can be one of the following self-explanatory constant
    values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ROTATE_90_CLOCKWISE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ROTATE_180`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ROTATE_90_COUNTERCLOCKWISE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s an image that depicts all possible results of the `flip` and `rotate`
    functions. Notice that the result of flip around both axes is the same as a 180-degree
    rotation in the following resulting images:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00031.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As mentioned previously in this chapter, `Mat::t`, or the transpose of a matrix,
    can also be used to rotate an image when used in conjunction with the `flip` function.
  prefs: []
  type: TYPE_NORMAL
- en: Working with channels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OpenCV provides a handful of functions to deal with channels, whether we need
    to merge, split, or perform various actions on them. In this section, we're going
    to learn how to split an image to its consisting channels or make a multi-channel
    image using multiple single-channel images. So, let's start.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the `merge` function to merge a number of single-channel `Mat`
    objects and create a new multi-channel `Mat` object, as seen in the following
    sample code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, `ch1`, `ch2`, and `ch3` are all single-channel images
    of the same size. The result will be a three-channel `Mat` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use the `insertChannel` function to insert a new channel into
    an image. Here''s how:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, `ch` is a single channel `Mat` object, `image` is the
    matrix we want to add an additional channel into it, and `idx` refers to the zero-based
    index number of the position where the channel will be inserted.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `split` function can be used to perform exactly the opposite of the `merge`
    function, which is splitting a multi-channel image to create a number of single-channel
    images. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The `channels` array in the preceding code will contain three single-channel
    images of the same size that correspond to each individual channel in the image.
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to extract a single channel from an image, you can use the `extractChannel`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, quite obviously, the channel at position `idx` will be
    extracted from the image and saved in `ch`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even though `merge`, `split`, `insertChannel`, and `extractChannel` are enough
    for most use cases, you still might need a more complex shuffling, extraction,
    or manipulation of the channels in an image. For this reason, OpenCV provides
    a function called `mixChannels`, which allows a much more advanced way of handling
    channels. Let''s see how `mixChannels` is used with an example case. Let''s say
    we want to shift all of the channels of an image to the right. To be able to perform
    such a task, we can use the following sample code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The only important piece of code in the preceding example is the `fromTo` vector,
    which must contain pairs of values that correspond to the channel number in the
    source and destination. The channels are, as always, 0-index based, so 0, 1 means
    the first channel in the source image will be copied to the second channel in
    the result and so on.
  prefs: []
  type: TYPE_NORMAL
- en: It's worth noting that all previous functions in this section (merge, split,
    and so on), are a partial case of the `mixChannels` function.
  prefs: []
  type: TYPE_NORMAL
- en: Mathematical functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The functions and algorithms that we'll learn about in this section are solely
    used for mathematical calculations of a non-element-wise nature, as opposed to
    what we saw earlier on in this chapter. They include simple functions, such as
    `mean` or `sum` or more complex operations, such as the discrete Fourier transform.
    Let's browse through some of the most important ones with hands-on examples.
  prefs: []
  type: TYPE_NORMAL
- en: Matrix inversion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `invert` function can be used to calculate the inverse of a matrix. This
    should not to be confused with the `bitwise_not` function, which inverts each
    and every bit in the pixels of an image. The `invert` function is not an element-wise
    function, and the inversion method needs to be provided as a parameter to this
    function. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The `DecompTypes` enum contains all possible entries that can be used in the
    `invert` function as the decomposition type. Here they are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`DECOMP_LU`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DECOMP_SVD`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DECOMP_EIG`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DECOMP_CHOLESKY`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DECOMP_QR`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refer to the OpenCV documentation for the `DecompTypes` enum if you're interested
    in a detailed description of each and every decomposition method.
  prefs: []
  type: TYPE_NORMAL
- en: Mean and sum of elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can calculate the mean, or the average value of the elements in a matrix,
    by using the `mean` function. Here is an example that shows how to read an image
    and calculate and display the mean value of all of its individual channels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use the `sum` function exactly the same way, to calculate the sum of
    elements in a matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'OpenCV also includes a `meanStdDev` function that can be used to calculate
    the mean and standard deviation of all elements in the matrix at the same time.
    Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Similar to the `mean` function, the `meanStdDev` function also calculates the
    results for each individual channel separately.
  prefs: []
  type: TYPE_NORMAL
- en: Discrete Fourier transformation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A discrete Fourier transformation of a 1D or 2D array, or in other words—an
    image, is one of the many ways to analyze an image in computer vision. The interpretation
    of the result depends completely on the field it is being used for and that is
    not what we are concerned with in this book, however, how to perform a discrete
    Fourier transformation is what we're going to learn in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Simply put, you can use the `dft` function to calculate the Fourier transformation
    of an image. However, there are some preparations needed before the `dft` function
    can be safely called. The same applies to the result of the Fourier transformation.
    Let's break this down with an example code, and by calculating and displaying
    the Fourier transformation of our example image used in the previous sections.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `dft` function can process matrices of certain sizes (powers of 2, such
    as 2, 4, and 8) a lot more efficiently, that is why it is always best to increase
    the size of our matrix to the nearest optimum size and pad it with zeroes before
    calling the `dft` function. This can be done by using the `getOptimalDFTSize`
    function. Assuming that `image` is the input image that we want to calculate its
    discrete Fourier transformation, we can write the following code to calculate
    and resize it to the optimum size for the `dft` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `getOptimalDFTSize` function must be called twice, for rows
    and columns separately. You are already familiar with the `copyMakeBorder` function.
    Resizing an image and padding the new pixels with zeroes (or any other desired
    value) is one of countless example use cases for the `copyMakeBorder` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rest is quite easy, we need to form a two-channel image and pass it to
    the `dft` function and get the complex (real and imaginary) result in the same
    matrix. This will later simplify the process of displaying the result. Here''s
    how it''s done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'We have already learned how to use the `merge` function. The only important
    thing to note in the preceding code is the fact that the result is saved into
    the same image as the input. `complexImage` now contains two channels, one for
    the real and the other for the imaginary part of the discrete Fourier transformation.
    That''s it! We now have our result, however, to be able to display it, we must
    calculate the magnitude of the result. Here''s how it''s done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we have split the complex result into its consisting
    channels and then calculated the magnitude using the `magnitude` function. Theoretically,
    `mag` is a displayable result, but in reality, it contains values much higher
    than what is displayable using OpenCV, so we need to perform a couple of conversions
    before being able to display it. First, we need to make sure the result is in
    the logarithmic scale, by performing the following conversion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we must make sure the result values are scaled and normalized to fit
    between `0.0` and `1.0`, to be displayable by the `imshow` function in OpenCV.
    You need to use the `normalize` function for this reason:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now try to display the result using the `imshow` function. Here''s
    an example that displays the result of the discrete Fourier transformation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00032.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'The problem with this result is that the quadrants need to be swapped before
    the origin of the result is at the center of the image. The following image depicts
    how the four quadrants of the result must be swapped before the result has an
    origin point at the center:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00033.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following is the code needed to swap the four quadrants of the Fourier
    transform result. Notice how we first find the center of the result, then create
    four **region of interest** (**ROI**) matrices, and then swap them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The `dft` function accepts an additional parameter that can be used to further
    customize its behavior. This parameter can be a combination of values from the `DftFlags`
    enum. For instance, to perform an inverse Fourier transformation, you need to
    call the `dft` function with the `DFT_INVERSE` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'This can also be done by using the `idft` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Make sure to check out the `DftFlags` enum and the `dft` function documentation
    for more information about how the discrete Fourier transform is implemented in
    OpenCV.
  prefs: []
  type: TYPE_NORMAL
- en: Generating random numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Random number generation is one of the most widely used algorithms in computer
    vision, especially when it comes to testing an existing algorithm with random
    values between given ranges. When using the OpenCV library, you can use the following
    functions to produce values or matrices containing random values:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `randn` function can be used to fill a matrix or an array with random numbers
    with a given mean value and standard deviation. Here''s how this function is used:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The `randu` function, similar to the `randn` function, is used to fill an array
    with random values, however, instead of mean and standard deviation, this function
    uses a lower band and higher band (both inclusive) for the produced random values.
    Here''s an example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The `randShuffle` function, as it can be guessed from its title, is used to
    randomly shuffle the contents of an array or matrix. It is used as simply as it
    is depicted in the following example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: The search and locate functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When working on your computer vision projects, you'll be faced with countless
    scenarios and cases in which you'll need to look for certain pixels, or the maximum
    values (brightest point), and so on. The OpenCV library contains a number of functions
    that can be used for this same purpose, and they are the subject of this section.
  prefs: []
  type: TYPE_NORMAL
- en: Locating non-zero elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Locating, or counting, non-zero elements can come in quite handy, especially
    when looking for specific regions in an image after a threshold operation, or
    when looking for the area covered by a specific color. OpenCV contains the `findNonZero`
    and `countNonZero` functions, which simply allow you to find or count the pixels
    with non-zero (or bright) values in an image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example that depicts how you can use the `findNonZero` function
    to find the first non-black pixel in a grayscale image and print its position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is another example code that shows how you can find the percentage of
    black pixels in a grayscale image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Locating minimum and maximum elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Locating the brightest (maximum) and darkest (minimum) points in an image or
    matrix are two of the most important types of searches within images in computer
    vision, especially after performing certain types of thresholding algorithms,
    or template-matching functions (which we''ll learn about in the upcoming chapters).
    OpenCV provides the following two functions to locate global minimum and maximum
    values, along with their positions is a matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '`minMaxIdx`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`minMaxLoc`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `minMaxLoc` function searches the whole image (only single-channel images)
    for the brightest and darkest points and returns the value of the brightest and
    darkest pixel, along with their positions, whereas the `minMaxIdx` function returns
    a pointer to the found minimum and maximum position, instead of a position (the
    `Point` object with *x* and *y*). Here''s how the `minMaxLoc` function is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'This is an example of using the `minMaxIdx` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Lookup table transformation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In computer vision, replacing pixels with new values based on their value from
    a given table that contains the required replacement is called **lookup table
    transformation**. This might sound a bit confusing at first but it's a very powerful
    and simple method for modifying images using lookup tables. Let's see how it's
    done with a hands-on example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume we have an example image and we need to replace the bright pixels
    (with a value greater than `175`) with absolute white, dark pixels (with a value
    less than `125`) with absolute black, and leave the rest of the pixels as they
    are. To perform such a task, we can simply use a lookup table `Mat` object along
    with the `LUT` function in OpenCV:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'The following image depicts the result of this lookup table transformation
    when it is executed on our example image. As you can see, the lookup table transformation
    can be executed on both color (on the right) and grayscale (on the left) images:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00034.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Using the `LUT` function wisely can lead to many creative solutions for computer
    vision problems where replacing pixels with a given value is desired.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What we saw in this chapter was a taste of what can be done using matrix and
    array operations in computer vision with the OpenCV library. We started the chapter
    with nothing but a firm background in the fundamental concepts of computer vision
    from the previous chapters, and we ended up learning about lots of algorithms
    and functions using hands-on examples. We learned about ones, zeroes, identity
    matrix, transpose, and other functions embedded into the heart of the `Mat` class.
    Then, we continued on to learn about many element-wise algorithms. We are now
    totally capable of performing element-wise matrix operations, such as basic operations,
    comparisons, and bitwise operations. Finally, we learned about the non-element-wise
    operations in the OpenCV core module. Making borders, modifying channels, and
    discrete Fourier transformation were among the many algorithms we learned to use
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we're going to learn about computer vision algorithms used
    for filtering, drawing, and other functions. Topics covered in the upcoming chapter
    are essential before you step into the world of advanced computer vision development
    and algorithms used for highly complex tasks, such as face or object detection
    and tracking.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which of the element-wise mathematical operations and bitwise operations would
    produce the exact same results?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the purpose of the `gemm` function in OpenCV? What is the equivalent
    of `A*B` with the `gemm` function?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `borderInterpolate` function to calculate the value of a non-existing
    pixel at point `(-10, 50)`, with a border type of `BORDER_REPLICATE`. What is
    the function call required for such a calculation?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the same identity matrix as in the *Learning about the dentity matrix*
    section of this chapter, but use the `setIdentity` function instead of the `Mat::eye`
    function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a program using the `LUT` function (lookup table transformation) that
    performs the same task as `bitwise_not` (invert colors) when executed on grayscale
    and color (RGB) images.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Besides normalizing the values of a matrix, the `normalize` function can be
    used to brighten or darken images. Write the required function call to darken
    and brighten a grayscale image using the `normalize` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove the blue channel (first channel) from an image (BGR image created using
    the `imread` function) using the `merge` and `split` functions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
