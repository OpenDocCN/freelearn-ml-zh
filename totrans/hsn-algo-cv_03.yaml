- en: Array and Matrix Operations
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组和矩阵操作
- en: Now that we're past the first part of the book and the introductions and fundamental
    concepts in computer vision, we can start with the computer vision algorithms
    and functions provided by the OpenCV library, which more or less cover any computer
    vision topic that comes to mind, with optimized implementations. As we learned
    in the previous chapters, OpenCV uses a modular structure to categorize the computer
    vision functionalities contained in it. We'll move forward with the topics in
    this book with a similar structure in mind, so that the skills learned are related
    to each other in each chapter, not just from a theoretical point of view, but
    also from a hands-on perspective.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了本书的第一部分，以及计算机视觉的介绍和基本概念，我们可以开始学习OpenCV库提供的计算机视觉算法和函数，这些算法和函数几乎涵盖了所有可以想到的计算机视觉主题，并且有优化的实现。正如我们在前面的章节中学到的，OpenCV使用模块化结构来分类其中包含的计算机视觉功能。我们将带着类似的思路继续本书的主题，这样学到的技能在每一章中都是相互关联的，不仅从理论角度来看，而且从实践角度来看。
- en: In the previous chapter, we learned about the relationship between images and
    matrices, and covered the most crucial functionalities of the `Mat` class, such
    as constructing it using a given width, height, and type. We also learned how
    to read images from disk, a network feed, video files, or cameras. During the
    process, we learned how to access pixels in an image using various methods. We
    can now start with actual image- and pixel-modification and manipulation functionalities.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了图像和矩阵之间的关系，并介绍了`Mat`类最关键的功能，例如使用给定的宽度、高度和类型来构建它。我们还学习了如何从磁盘、网络流、视频文件或摄像头中读取图像。在这个过程中，我们学习了如何使用各种方法访问图像中的像素。现在，我们可以开始实际进行图像和像素的修改和操作功能了。
- en: In this chapter, we're going to learn about a large number of functions and
    algorithms that are used to deal with images, either for calculating a value that
    might be useful in another process or for directly modifying the values of the
    pixels in an image. Almost all of the algorithms presented in this chapter are
    based on the fact that images are essentially matrices, and also the fact that
    matrices are implemented using arrays of data, hence the name of this chapter!
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个章节中，我们将学习大量用于处理图像的函数和算法，这些算法要么用于计算可能在其他过程中有用的值，要么用于直接修改图像中像素的值。本章中展示的几乎所有算法都是基于这样一个事实：图像本质上是由矩阵组成的，而且矩阵是通过数据数组实现的，因此本章的名称就是这样！
- en: We'll start this chapter by covering the functionalities within the `Mat` class
    itself, which are few, but quite important when it comes to the creation of initial
    matrices and so on. Then, we'll move on to learn about a large number of per-element
    (or element-wise) algorithms. These algorithms, as we'll learn by going through
    many hands-on examples, apply a specific operation on each individual element
    of a matrix and they are not concerned with any other element (or pixel). Finally,
    we'll learn about matrix and array operations that are not element-wise and the
    result may depend on the whole image or groups of elements. This will all clear
    up as we move forward with the algorithms in this chapter. It's important to note
    that all of the algorithms and functions in this chapter are contained within
    the core module of OpenCV library.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从这个章节开始，介绍`Mat`类本身的功能，这些功能虽然不多，但在创建初始矩阵等方面却非常重要。然后，我们将继续学习大量的按元素（或逐元素）算法。通过许多实际案例的学习，我们将了解到这些算法对矩阵的每个单独元素执行特定操作，并且它们不关心任何其他元素（或像素）。最后，我们将学习那些不是逐元素操作的矩阵和数组操作，其结果可能取决于整个图像或元素组。随着我们在这个章节中继续学习算法，这一切都将变得清晰。需要注意的是，这个章节中所有的算法和函数都包含在OpenCV库的核心模块中。
- en: 'By the end of this chapter, you''ll have a better understanding of the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 到这个章节结束时，你将更好地理解以下内容：
- en: Operations contained in the `Mat` class
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Mat`类中包含的操作'
- en: Element-wise matrix operations
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逐元素矩阵操作
- en: Matrix and array-wise operations
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 矩阵和数组操作
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: An IDE to develop C++ or Python applications
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于开发C++或Python应用程序的IDE
- en: The OpenCV library
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenCV库
- en: Refer to [Chapter 2](part0030.html#SJGS0-15c05657f8254d318ea883ef10fc67f4),
    *Getting Started with OpenCV*, for more information about how to set up a personal
    computer and make it ready for developing computer vision applications using OpenCV
    library.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 有关如何设置个人计算机并使其准备好使用 OpenCV 库开发计算机视觉应用程序的更多信息，请参阅[第 2 章](part0030.html#SJGS0-15c05657f8254d318ea883ef10fc67f4)，*OpenCV
    入门*。
- en: You can use the following URL to download the source codes and examples for
    this chapter: [https://github.com/PacktPublishing/Hands-On-Algorithms-for-Computer-Vision/tree/master/Chapter03](https://github.com/PacktPublishing/Hands-On-Algorithms-for-Computer-Vision/tree/master/Chapter03)
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下网址下载本章的源代码和示例：[https://github.com/PacktPublishing/Hands-On-Algorithms-for-Computer-Vision/tree/master/Chapter03](https://github.com/PacktPublishing/Hands-On-Algorithms-for-Computer-Vision/tree/master/Chapter03)
- en: Operations contained in the Mat class
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Mat` 类包含的操作'
- en: In this section, we're going to go through the set of mathematical and other
    operations that are contained inside the `Mat` class itself. Even though there
    is no general pattern of usage for the functions in the `Mat` class, most of them
    are related to creating a new matrix, whether it is using an existing one or from
    scratch. So, let's start.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍 `Mat` 类本身包含的数学和其他操作集。尽管 `Mat` 类中的函数没有通用的使用模式，但它们大多数都与创建新矩阵有关，无论是使用现有的矩阵还是从头开始创建。所以，让我们开始吧。
- en: During the course of the book, the words image, matrix, the `Mat` class, and
    so on will be used interchangeably, and they all mean the same thing, unless explicitly
    stated. Take this chance to get used to the idea of thinking about images in terms
    of matrices, just like a computer vision expert would do.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的整个过程中，单词图像、矩阵、`Mat` 类等将可以互换使用，并且它们都表示相同的意思，除非有明确的说明。利用这个机会，习惯于像计算机视觉专家那样从矩阵的角度思考图像。
- en: Cloning a matrix
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 克隆矩阵
- en: 'You can use `Mat::clone` to create a completely independent clone of a `Mat`
    object. Note that this function creates a full copy of the image with its own
    allocated space in memory. Here''s how it''s used:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `Mat::clone` 来创建一个完全独立的 `Mat` 对象的克隆。请注意，此函数创建了一个完整的图像副本，并在内存中为其分配了空间。以下是它的用法：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You can also use the `copyTo` function to do the same, as seen here:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以使用 `copyTo` 函数来完成相同的功能，如下所示：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In both of the preceding code examples, `image` is the original matrix (or image)
    that is read from an image, camera, or produced in any possible way prior to performing
    the cloning operation. From now on, and in all of the examples in this and upcoming
    chapters, `image` is simply a `Mat` object that is the source of our operations,
    unless otherwise stated.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的两个代码示例中，`image` 是在执行克隆操作之前从图像、摄像头或以任何可能的方式产生的原始矩阵（或图像）。从现在开始，在本章和即将到来的所有章节中，除非另有说明，`image`
    简单地是一个 `Mat` 对象，它是我们操作的数据源。
- en: Calculating the cross-product
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算叉积
- en: 'You can use `Mat::cross` to calculate the cross-product of two `Mat` objects
    that have three floating-point elements, as seen in the following example:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `Mat::cross` 来计算具有三个浮点元素的两个 `Mat` 对象的叉积，如下面的示例所示：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Obviously, `AxB` is not the same as `BxA` in the cross-product of two vectors.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，在两个向量的叉积中，`AxB` 与 `BxA` 是不同的。
- en: Extracting a diagonal
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提取对角线
- en: '`Mat::diag` can be used to extract a diagonal from a `Mat` object, as seen
    in the following example:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`Mat::diag` 可以用来从一个 `Mat` 对象中提取对角线，如下面的示例所示：'
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This function accepts an index parameter that can be used to extract additional
    diagonals beside the main diagonal, as depicted in the following diagram:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数接受一个索引参数，可以用来提取主对角线以外的其他对角线，如下面的图所示：
- en: '![](img/00019.gif)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00019.gif)'
- en: If **D=0**, then the extracted diagonal will contain **1**, **6**, **11**, and
    **16**, which is the main diagonal. But depending on the value of **D**, the extracted
    diagonal will be above or below the main diagonal, as seen in the preceding diagram.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 **D=0**，则提取的对角线将包含 **1**、**6**、**11** 和 **16**，这是主对角线。但根据 **D** 的值，提取的对角线将位于主对角线之上或之下，如前图所示。
- en: Calculating the dot product
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算点积
- en: 'To calculate the dot product, or scalar product, or inner product of two matrices,
    you can use the `Mat::dot` function, as seen here:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算两个矩阵的点积、标量积或内积，您可以使用 `Mat::dot` 函数，如下所示：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this, `A` and `B` are both OpenCV `Mat` objects.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`A` 和 `B` 都是 OpenCV 的 `Mat` 对象。
- en: Learning about the identity matrix
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习单位矩阵
- en: 'Identity matrices are created using the `Mat::eye` function in OpenCV. Here''s
    an example:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 OpenCV 中的 `Mat::eye` 函数创建单位矩阵。以下是一个示例：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In case you need a value other than the ones in the identity matrix diagonal,
    you can use a `scale` parameter:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要一个不同于单位矩阵对角线上的值，你可以使用一个 `scale` 参数：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Another way of creating an identity matrix is by using the `setIdentity` function.
    Make sure to check the OpenCV documentation for more information about this function.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 创建单位矩阵的另一种方法是使用 `setIdentity` 函数。请确保查看 OpenCV 文档以获取有关此函数的更多信息。
- en: Matrix inversion
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 矩阵求逆
- en: 'You can use the `Mat::inv` function to invert a matrix:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `Mat::inv` 函数来求逆一个矩阵：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note that you can supply a matrix decomposition type to the `inv` function,
    which can be an entry in the `cv::DecompTypes` enum.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你可以向 `inv` 函数提供一个矩阵分解类型，这可以是 `cv::DecompTypes` 枚举中的一个条目。
- en: Element-wise matrix multiplication
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 元素级矩阵乘法
- en: '`Mat::mul` can be used to perform an element-wise multiplication of two `Mat`
    objects. Needless to say, this same function can also be used for element-wise
    division. Here''s an example:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`Mat::mul` 可以用来执行两个 `Mat` 对象的元素级乘法。不用说，此函数也可以用于元素级除法。以下是一个示例：'
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You can also supply an additional `scale` parameter that will be used to scale
    the result. Here''s another example:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以提供一个额外的 `scale` 参数，该参数将用于缩放结果。以下是一个另一个示例：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The ones and zeroes matrix
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 全1和全0矩阵
- en: '`Mat::ones` and `Mat::zeroes` can be used to create a matrix of a given size
    with all of its elements set to one or zero, respectively. These matrices are
    usually used to create initializer matrices. Here are some examples:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`Mat::ones` 和 `Mat::zeroes` 可以用来创建一个给定大小的矩阵，其中所有元素分别设置为1或0。这些矩阵通常用于创建初始化矩阵。以下是一些示例：'
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In case you need to create a matrix that is filled with a value other than
    ones, you can use something like the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要创建一个填充了除了1以外的值的矩阵，你可以使用以下类似的方法：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Transposing a matrix
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转置矩阵
- en: 'You can use `Mat::t` to transpose a matrix. Here''s an example:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `Mat::t` 来转置一个矩阵。以下是一个示例：
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here''s an example that demonstrates the transposition of an image:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个演示图像转置的示例：
- en: '![](img/00020.jpeg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00020.jpeg)'
- en: The image on the left is the original image and the image on the right is the
    transpose of the original image. As you can see, the result is a rotated (clockwise)
    and flipped (vertically) version of the original image. As you'll learn later
    in this chapter, `transpose`, or the `Mat::t` function, can be used in conjunction
    with the `flip` function to rotate or flip/mirror an image in all possible directions.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧的图像是原始图像，右侧的图像是原始图像的转置。正如你将在本章后面学到的那样，`transpose` 或 `Mat::t` 函数可以与 `flip`
    函数结合使用，以在所有可能的方向上旋转或翻转/镜像图像。
- en: 'Transposing a transpose matrix is the same as the original matrix, and running
    the following code will result in the original image itself:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 转置一个转置矩阵与原始矩阵相同，运行以下代码将得到原始图像本身：
- en: '`Mat org = image.t().t();`'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`Mat org = image.t().t();`'
- en: 'Another way of calculating the transpose of a matrix is by using the `transpose`
    function. Here''s an example of how this function is used:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 计算矩阵转置的另一种方法是使用 `transpose` 函数。以下是如何使用此函数的示例：
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In which `mat` and `trp` are both `Mat` objects.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`mat` 和 `trp` 都是 `Mat` 对象。
- en: Reshaping a Mat object
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调整 Mat 对象的形状
- en: 'A `Mat` object can be reshaped using the `Mat::reshape` function. Note that
    reshaping, in this sense, means changing the number of channels and rows of an
    image. Here''s an example:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `Mat::reshape` 函数调整 `Mat` 对象的形状。请注意，在这个意义上，调整形状意味着改变图像的通道数和行数。以下是一个示例：
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note that passing a value of zero as the number of channels means that the number
    of channels will stay the same as the source. Similarly, passing a value of zero
    as the number of rows means the number of rows in the image will stay the same.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，将通道数设置为0的值意味着通道数将与源保持相同。同样，将行数设置为0的值意味着图像的行数将保持不变。
- en: Note that `Mat::resize` is another useful function for reshaping a matrix, but
    it only allows changing the number of rows in an image. Another function that
    can come in handy when reshaping matrices or dealing with the number of elements
    in a matrix, is the `Mat::total` function, which returns the total number of elements
    in an image.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`Mat::resize`是另一个用于重塑矩阵的有用函数，但它只允许改变图像中的行数。在重塑矩阵或处理矩阵中的元素数量时，另一个有用的函数是`Mat::total`函数，它返回图像中的元素总数。
- en: That's about it for the functionalities embedded into the `Mat` class itself.
    Make sure to go through the `Mat` class documentation and familiarize yourself
    with possible variants of the methods you just learned in this section.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`Mat`类本身嵌入的功能就到这里。请确保阅读`Mat`类的文档，并熟悉你在这节中学到的方法的可能变体。
- en: Element-wise matrix operations
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逐元素矩阵操作
- en: Per-element or element-wise matrix operations are mathematical functions and
    algorithms in computer vision that work on individual elements of a matrix or,
    in other words, pixels of an image. It's important to note that element-wise operations
    can be parallelized, which fundamentally means that the order in which the elements
    of a matrix are processed is not important. This specification is the most important
    feature that separates the functions and algorithms in this section and the upcoming
    sections of this chapter.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 元素级或逐元素矩阵操作是计算机视觉中的数学函数和算法，它们作用于矩阵的各个单独元素，换句话说，就是图像的像素。需要注意的是，逐元素操作可以并行化，这意味着矩阵元素的处理顺序并不重要。这个特性是本节和本章后续部分中函数和算法之间最重要的区别。
- en: Basic operations
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本操作
- en: OpenCV provides all the necessary functions and overloaded operators that you
    need to perform all four basic operations of addition, subtraction, multiplication,
    and division between two matrices or a matrix and a scalar.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV提供了所有必要的函数和重载运算符，用于执行两个矩阵或一个矩阵与一个标量之间的所有四个基本操作：加法、减法、乘法和除法。
- en: The addition operation
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加法操作
- en: 'The `add` function and the `+` operator can be used to add the elements of
    two matrices, or a matrix and a scalar, as seen in the following examples:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`add`函数和`+`运算符可以用来添加两个矩阵的元素，或者一个矩阵和一个标量，如下面的例子所示：'
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You can replace the last line in the preceding code with the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将前面代码中的最后一行替换为以下代码：
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The following image demonstrates the resulting image of an add operation of
    two images:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图片展示了两个图像加法操作的结果图像：
- en: '![](img/00021.jpeg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00021.jpeg)'
- en: 'In case, you want to add a single scalar value to all elements of a `Mat` object,
    you can simply use something similar to the following:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想将单个标量值添加到`Mat`对象的全部元素中，你可以简单地使用以下类似的方法：
- en: '[PRE17]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If the preceding code is executed on a grayscale image, the result will be
    brighter than the source image. Note that if the image has three channels, you
    must use a three-item vector instead of a single value. For instance, to be able
    to make an RGB image brighter, you can use the following:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果前面的代码在灰度图像上执行，结果会比源图像更亮。注意，如果图像有三个通道，你必须使用一个三项向量而不是单个值。例如，为了使RGB图像更亮，你可以使用以下代码：
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here''s an image depicting the brighter result image, when the preceding code
    is executed on it:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一张图片，展示了当在它上执行前面的代码时，得到的更亮的结果图像：
- en: '![](img/00022.jpeg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00022.jpeg)'
- en: In the preceding example codes, simply increase the added value to get an even
    brighter image.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例代码中，只需简单地增加加数值，就可以得到更亮的图像。
- en: Weighted addition
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加权加法
- en: 'Besides the simple addition of two images, you can also use the weighted addition
    function to consider a weight for each of the two images that are being added.
    Think of it as setting an opacity level for each of the participants in an `add`
    operation. To perform a weighted addition, you can use the `addWeighted` function:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 除了简单的两个图像相加外，你还可以使用加权加法函数来考虑被加的两个图像的权重。将其视为在`add`操作中为每个参与者设置不透明度级别。要执行加权加法，你可以使用`addWeighted`函数：
- en: '[PRE19]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If executed on the sample pictures from the previous section with the add example,
    the result would be similar to the following:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在上一节中的示例图片上执行加法操作，结果将类似于以下内容：
- en: '![](img/00023.jpeg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00023.jpeg)'
- en: Notice the transparent text that is similar to the watermark usually applied
    by photo-editing applications. Notice the comments in the code regarding the `alpha`,
    `beta`, and `gamma` values? Obviously, providing a `beta` value of `1.0` would
    have made this example exactly the same as a regular `add` function with no transparency
    for the overlay text.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到与通常由照片编辑应用程序应用的水印类似的透明文本。注意代码中关于 `alpha`、`beta` 和 `gamma` 值的注释？显然，提供一个 `beta`
    值为 `1.0` 将会使此示例与没有任何透明度的常规 `add` 函数完全相同。
- en: The subtraction operation
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 减法运算
- en: 'Similar to adding two `Mat` objects to each other, you can also subtract all
    elements of one image from another using the `subtract` function or the `-` operator.
    Here''s an example:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 与将两个 `Mat` 对象相加类似，你也可以使用 `subtract` 函数或 `-` 运算符从一幅图像中减去另一幅图像的所有元素。以下是一个示例：
- en: '[PRE20]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The last line in the preceding code can also be replaced with this:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码中的最后一行也可以替换为以下内容：
- en: '[PRE21]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Here''s the result of the subtraction operation if we used the same two images
    from the previous examples:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用前面示例中的相同两幅图像进行减法运算，以下是结果：
- en: '![](img/00024.jpeg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00024.jpeg)'
- en: Notice how the subtraction of higher pixel values (brighter pixels) from the
    source image results in the dark color of the overlay text. Also note that the
    subtraction operation depends on the order of its operands, unlike addition. Try
    swapping the operands and see what happens for yourself.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 注意从源图像中减去较高像素值（较亮像素）的结果会导致叠加文本的暗色。还要注意，减法运算依赖于其操作数的顺序，这与加法不同。尝试交换操作数，看看会发生什么。
- en: 'Just like addition, it''s also possible to multiply a constant number with
    all of the pixels of an image. You can guess that subtraction of a constant value
    from all pixels will result in a darker image (depending on the subtracted value)
    which is the opposite of the addition operation. Here''s an example of making
    an image darker with a simple subtraction operation:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 就像加法一样，你也可以将一个常数与图像的所有像素相乘。你可以猜到，从所有像素中减去一个常数将导致图像变暗（取决于减去的值），这与加法运算相反。以下是一个使用简单的减法运算使图像变暗的示例：
- en: '[PRE22]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In case the source image is a three-channel RGB image, you need to use a vector
    as the second operand:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果源图像是一个三通道 RGB 图像，你需要使用一个向量作为第二个操作数：
- en: '[PRE23]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The multiplication and division operations
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 乘法和除法运算
- en: Similar to addition and subtraction, you can also multiply all elements of a
    `Mat` object with all elements of another `Mat` object. The same can be done with
    the division operation. Again, both operations can be performed with a matrix
    and a scalar. Multiplication can be done using OpenCV's `multiply` function (similar
    to the `Mat::mul` function), while division can be performed using the `divide`
    function.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 与加法和减法类似，你也可以将一个 `Mat` 对象的所有元素与另一个 `Mat` 对象的所有元素相乘。同样，也可以进行除法运算。再次强调，这两种运算都可以使用矩阵和标量进行。乘法可以使用
    OpenCV 的 `multiply` 函数（类似于 `Mat::mul` 函数）进行，而除法可以使用 `divide` 函数进行。
- en: 'Here are some examples:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些示例：
- en: '[PRE24]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '`scale` in the preceding code is an additional parameter that can be supplied
    to the `multiply` and `divide` functions to scale all of the elements in the result
    `Mat` object. You can also perform multiplication or division with a scalar, as
    seen in the following examples:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码中的 `scale` 是可以提供给 `multiply` 和 `divide` 函数的附加参数，用于缩放结果 `Mat` 对象中的所有元素。你还可以像以下示例中那样使用标量进行乘法或除法运算：
- en: '[PRE25]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Obviously, the preceding code will produce two images, one that is five times
    brighter and one that is five times darker than the original image. The important
    thing to note here is that, unlike addition and subtraction, the resulting image
    will not be homogeneously brighter or darker, and you'll notice that brighter
    areas become much brighter and vice versa. The reason for this is obviously the
    effect of multiplication and division operations, in which the value of brighter
    pixels grows or drops much faster than smaller values after the operation. It's
    interesting to note that this same technique is used in most photo-editing applications
    to brighten or darken the bright areas of an image.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，前面的代码将生成两个图像，一个比原始图像亮五倍，另一个比原始图像暗五倍。这里需要注意的是，与加法和减法不同，生成的图像不会均匀地变亮或变暗，你会注意到较亮区域变得非常亮，反之亦然。显然，这是乘法和除法运算的效果，在这些运算中，较亮像素的值在运算后增长或下降的速度比较小的值快得多。值得注意的是，这种相同的技术在大多数照片编辑应用程序中用于调整图像的亮暗区域。
- en: Bitwise logical operations
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 位运算逻辑
- en: 'Just like basic operations, you can also perform bitwise logical operations
    on all of the elements of two matrices or a matrix and a scalar. For this reason,
    you can use the following functions:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 就像基本操作一样，您也可以对两个矩阵的所有元素或一个矩阵和一个标量的所有元素执行位逻辑运算。因此，您可以使用以下函数：
- en: '`bitwise_not`'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bitwise_not`'
- en: '`bitwise_and`'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bitwise_and`'
- en: '`bitwise_or`'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bitwise_or`'
- en: '`bitwise_xor`'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bitwise_xor`'
- en: 'It''s immediately recognizable from their names that these functions can perform
    `Not`, `And`, `Or`, and `Exclusive OR` operations, but let''s see how they''re
    used in detail with some hands-on examples:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 从它们的名字就可以立即看出，这些函数可以执行 `Not`、`And`、`Or` 和 `Exclusive OR` 操作，但让我们通过一些实际示例来详细看看它们是如何使用的：
- en: 'First things first, the `bitwise_not` function is used to invert all the bits
    of all pixels in an image. This function has the same effect as the inversion
    operation that can be found in most photo editing applications. Here''s how it''s
    used:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`bitwise_not` 函数用于反转图像中所有像素的所有位。此函数与大多数照片编辑应用中可以找到的翻转操作具有相同的效果。以下是它的使用方法：
- en: '[PRE26]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The preceding code can be replaced with the following too, which uses an overloaded
    bitwise `not` operator (`~`) in C++:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码也可以替换为以下代码，它使用了 C++ 中的重载位运算 `not` 操作符 (`~`)：
- en: '[PRE27]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If the image is a monochrome black and white image, the result will contain
    an image with all white pixels replaced with black and vice versa. In case the
    image is an RGB color image, the result will be inverted (in the sense of its
    binary pixel values), which is depicted in the following example image:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果图像是单色黑白图像，结果将包含一个所有白色像素被替换为黑色，反之亦然的图像。如果图像是 RGB 颜色图像，结果将是反转的（在二进制像素值的意义上），以下是一个示例图像：
- en: '![](img/00025.jpeg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00025.jpeg)'
- en: 'The `bitwise_and` function, or the `&` operator, is used to perform a bitwise
    `And` operation on pixels from two images or pixels from an image and a scalar.
    Here is an example:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`bitwise_and` 函数，或 `&` 操作符，用于对两个图像的像素或一个图像和一个标量的像素执行位运算 `And`。以下是一个示例：'
- en: '[PRE28]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You can simply use the `&` operator and write the following instead:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以直接使用 `&` 操作符，并写成以下内容：
- en: '[PRE29]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `bitwise_and` function can be easily used to mask and extract certain areas
    in images. For instance, the following image is a demonstration of how `bitwise_and`
    results in an image that passes the white pixels and removes the black pixels:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`bitwise_and` 函数可以很容易地用来遮罩和提取图像中的某些区域。例如，以下图像展示了 `bitwise_and` 如何导致一个只通过白色像素并移除黑色像素的图像：'
- en: '![](img/00026.jpeg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00026.jpeg)'
- en: 'Besides masking certain areas of an image, the bitwise `And` operation can
    be used to filter out a channel altogether. To be able to do this, you need to
    use the second form of the `&` operator, which takes a matrix and a scalar and
    performs the `And` operation between all pixels and that value. Here is an example
    code that can be used to mask (zero out) the green color channel in an RGB color
    image:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 除了遮罩图像的某些区域外，位运算 `And` 还可以用来完全过滤掉一个通道。要执行此操作，您需要使用 `&` 操作符的第二种形式，它接受一个矩阵和一个标量，并对所有像素和该值执行
    `And` 运算。以下是一个示例代码，可以用来遮罩（置零）RGB 颜色图像中的绿色颜色通道：
- en: '[PRE30]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, let''s move on to the next bitwise operation, the `Or` operation. The `bitwise_or`
    and `|` operators can both be used to perform a bitwise `Or` operation on two
    images, or an image and a scalar. Here is an example:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续到下一个位运算，即 `Or` 运算。`bitwise_or` 和 `|` 操作符都可以用来对两个图像或一个图像和一个标量执行位运算 `Or`。以下是一个示例：
- en: '[PRE31]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Similar to the bitwise `And` operation, you can use the `|` operator in the `Or`
    operation and simply write the following instead of the preceding code:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 与位运算 `And` 类似，您可以在 `Or` 运算中使用 `|` 操作符，并简单地写成以下代码代替前面的代码：
- en: '[PRE32]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If the `And` operation was used to pass through the non-zero pixels (or non-black
    pixels), then it can be said that the `Or` operation is used to pass through the
    pixel with the higher value (or brighter) in any of its input images. Here''s
    the result of performing the bitwise `Or` operation on the previous example images:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用 `And` 运算来通过非零像素（或非黑色像素），那么可以说 `Or` 运算用于通过任何输入图像中的像素值较高的像素（或较亮的像素）。以下是执行位运算
    `Or` 的前例图像的结果：
- en: '![](img/00027.jpeg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00027.jpeg)'
- en: 'Similar to bitwise `And` operation, you can also use bitwise `Or` operation
    to update an individual channel or all the pixels of an image. Here is an example
    code that shows how you can update only the green channel in an RGB image to have
    the maximum possible value (which is 255, or hexadecimal `FF`) in all of its pixels
    and leave the other channels as they are:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 与位运算的 `And` 操作类似，你也可以使用位运算的 `Or` 操作来更新单个通道或图像的所有像素。以下是一个示例代码，展示了如何仅更新 RGB 图像中的绿色通道，使其所有像素的值达到最大可能值（即
    255，或十六进制 `FF`），而其他通道保持不变：
- en: '[PRE33]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Finally, you can use `bitwise_xor`, or the `^` operator to perform an `Exclusive
    Or` between the pixels of two images, or an image and a scalar. Here is an example:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以使用 `bitwise_xor` 或 `^` 操作符在两个图像的像素之间，或图像与标量之间执行 `Exclusive Or` 操作。以下是一个示例：
- en: '[PRE34]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Or simply use the `^` operator and write the following instead:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 或者简单地使用 `^` 操作符，并写成以下内容：
- en: '[PRE35]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Here is the resulting image, if the `Exclusive Or` operation is performed on
    the example image from the preceding section:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在上一节中的示例图像上执行 `Exclusive Or` 操作，以下是结果图像：
- en: '![](img/00028.jpeg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00028.jpeg)'
- en: Notice how this operation leads to the inversion of the pixels in the masked
    area? Think about the reason behind this by writing down the pixel values on a
    paper and trying to calculate the result by yourself. `Exclusive Or`, and all
    bitwise operations, can be used for many other computer vision tasks if their
    behavior is clearly understood.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这个操作如何导致掩码区域的像素反转？通过在纸上写下像素值并尝试自己计算结果来思考这个原因。如果清楚地理解其行为，`Exclusive Or` 以及所有位运算都可以用于许多其他计算机视觉任务。
- en: The comparison operations
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较操作
- en: 'Comparing two images with each other (or given values) can be quite useful,
    especially for producing masks that can be used in various other algorithms, whether
    it is for tracking some object of interest in an image or performing an operation
    on an isolated (masked) region of an image. OpenCV provides a handful of functions
    to perform element-wise comparisons. For instance, the `compare` function can
    be used to compare two images with each other. Here''s how:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 比较两个图像（或给定值）非常有用，特别是用于生成可以在各种其他算法中使用的掩码，无论是用于跟踪图像中的某个感兴趣对象，还是在图像的孤立（掩码）区域执行操作。OpenCV
    提供了一些函数来执行逐元素比较。例如，`compare` 函数可以用于比较两个图像。以下是方法：
- en: '[PRE36]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The first two parameters are the first and second image that will participate
    in the comparison. The `result` will be saved into a third `Mat` object, and the
    last parameter, which must be an entry from the `CmpTypes` enum, is used to select
    the type of comparison, which can be any of the following:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个参数是参与比较的第一个和第二个图像。`result` 将保存到第三个 `Mat` 对象中，最后一个参数必须是从 `CmpTypes` 枚举中的一项，用于选择比较类型，可以是以下任何一种：
- en: '`CMP_EQ`: Means that the first image equals the second image'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMP_EQ`：表示第一个图像等于第二个图像'
- en: '`CMP_GT`: Means that the first image is greater than the second image'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMP_GT`：表示第一个图像大于第二个图像'
- en: '`CMP_GE`: Means that the first image is greater than or equal to the second
    image'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMP_GE`：表示第一个图像大于或等于第二个图像'
- en: '`CMP_LT`: Means that the first image is less than the second image'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMP_LT`：表示第一个图像小于第二个图像'
- en: '`CMP_LE`: Means that the first image is less than or equal to the second image'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMP_LE`：表示第一个图像小于或等于第二个图像'
- en: '`CMP_NE`: Means that the first image is not equal to the second image'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMP_NE`：表示第一个图像不等于第二个图像'
- en: Note that we are still talking about element-wise operations, so when we say
    *first image is less than or equal to the second image*, what we actually mean
    is *each individual pixel in the first image contains a value less than or equal
    to its exact corresponding pixel in the second image*, and so on.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们仍在讨论逐元素操作，所以当我们说“第一个图像小于或等于第二个图像”时，我们实际上是指“第一个图像中的每个单独像素的值小于或等于第二个图像中其对应像素的值”，依此类推。
- en: 'Note that you can also use the overloaded C++ operators to achieve the same
    goal as the `compare` function. Here is how, for each individual comparison type:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你还可以使用重载的 C++ 操作符来实现与 `compare` 函数相同的目标。以下是每个单独比较类型的方法：
- en: '[PRE37]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `inRange` function, which is another useful comparison function in OpenCV,
    can be used to find the pixels that have a value between a certain lower bound,
    and higher bound values. You can use any existing image as the boundary value
    matrices, or you can create them by yourself. Here''s an example code that can
    be used to find the pixel values between `0` and `50` in a grayscale image:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`inRange` 函数是 OpenCV 中的另一个有用的比较函数，可以用来找到具有特定下限和上限值的像素。你可以使用任何现有的图像作为边界值矩阵，或者你可以自己创建它们。以下是一个示例代码，可以用来在灰度图像中找到介于
    `0` 和 `50` 之间的像素值：'
- en: '[PRE38]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Note that `lb` and `hb` are both `Mat` objects of the same size and type of
    source image, except `lb` is filled with zeroes and `hb` is filled with the value
    of `50`. This way, when `inRange` is called, it checks each individual pixel in
    the source image with their corresponding pixels in `lb` and `hb` and sets the
    corresponding pixel in the result to white if the value fits between the provided
    boundaries.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`lb` 和 `hb` 都是与源图像大小和类型相同的 `Mat` 对象，除了 `lb` 被填充为零，而 `hb` 被填充为 `50` 的值。这样，当调用
    `inRange` 时，它会检查源图像中的每个像素及其对应的 `lb` 和 `hb` 中的像素，如果值在提供的边界之间，则将结果中的对应像素设置为白色。
- en: 'The following image depicts the result of the `inRange` function when it is
    executed on our example image:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像展示了在示例图像上执行 `inRange` 函数的结果：
- en: '![](img/00029.gif)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00029.gif)'
- en: 'The `min` and `max` functions, as it can be easily guessed from their names,
    are two other comparison functions that can be used to compare two images (element-wise)
    and find out the minimum or maximum pixel values. Here''s an example:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`min` 和 `max` 函数，从它们的名字可以轻易猜出，是另外两个可以用来比较两张图像（逐元素）并找出最小或最大像素值的比较函数。以下是一个示例：'
- en: '[PRE39]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Or you can use `max` to find the maximum:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 或者你可以使用 `max` 来找到最大值：
- en: '[PRE40]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Simply put, these two functions compare the pixels of two images of the same
    size and type and set the corresponding pixel in the result matrix to the minimum
    or maximum pixel value from the input images.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，这两个函数比较了相同大小和类型的两张图像的像素，并将结果矩阵中对应的像素设置为输入图像中的最小或最大像素值。
- en: The mathematical operations
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数学运算
- en: Besides the functions we've learned about so far, OpenCV also provides a number
    of functions to deal with element-wise mathematical operations. In this section,
    we're going to go through them briefly, but you can, and you should experiment
    with them by yourself to make sure that you're familiar with them, and you can
    comfortably use them in your projects.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们之前学过的函数之外，OpenCV 还提供了一些处理逐元素数学运算的函数。在本节中，我们将简要介绍它们，但你可以，也应该亲自实验它们，以确保你熟悉它们，并且可以在你的项目中舒适地使用它们。
- en: 'The element-wise mathematical functions in OpenCV are as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV 中的逐元素数学函数如下：
- en: 'The `absdiff` function can be used to calculate the absolute difference between
    the pixels of two images of the same size and type or an image and a scalar. Here''s
    an example:'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用 `absdiff` 函数来计算相同大小和类型的两张图像或图像和标量的像素之间的绝对差值。以下是一个示例：
- en: '[PRE41]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In the preceding code, `image1`, `image2`, and `result` are all `Mat` objects,
    and each element in the result represents the absolute difference between corresponding
    pixels in `image1` and `image2`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`image1`、`image2` 和 `result` 都是 `Mat` 对象，结果中的每个元素代表 `image1` 和 `image2`
    中对应像素的绝对差值。
- en: 'The `exp` function can be used to calculate the exponential of all elements
    in a matrix:'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用 `exp` 函数来计算矩阵中所有元素的指数：
- en: '[PRE42]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The `log` function can be used to calculate the natural logarithm of every
    element in a matrix:'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用 `log` 函数来计算矩阵中每个元素的自然对数：
- en: '[PRE43]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '`pow` can be used to raise all of the elements in a matrix to a given power.
    This function requires a matrix and a `double` value that will be the power value.
    Here''s an example:'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pow` 函数可以用来将矩阵中的所有元素提升到给定的幂。此函数需要一个矩阵和一个 `double` 类型的值，该值将是幂值。以下是一个示例：'
- en: '[PRE44]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The `sqrt` function is used to calculate the square root of all elements in
    a matrix, and it''s used as follows:'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sqrt` 函数用于计算矩阵中所有元素的平方根，其用法如下：'
- en: '[PRE45]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Functions such as `log` and `pow` should not be confused with the functions
    of the same name in standard C++ libraries. For better readability of your code,
    consider using the `cv` namespace before the function name in your C++ code. For
    instance, you can call the `pow` function as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 函数如 `log` 和 `pow` 不应与标准 C++ 库中同名的函数混淆。为了提高你代码的可读性，考虑在 C++ 代码中在函数名之前使用 `cv` 命名空间。例如，你可以这样调用
    `pow` 函数：
- en: '`cv::pow(image1, 3.0, result);`'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`cv::pow(image1, 3.0, result);`'
- en: Matrix and array-wise operations
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 矩阵和数组操作
- en: Unlike the functions and algorithms that we've seen so far in this chapter,
    the algorithms in this section perform an atomic and complete operation on the
    image (or matrix) itself and are not considered element-wise operations in the
    sense that has been described so far. If you recall, the rule of thumb for element-wise
    operations was that they can be easily parallelized since the resulting matrix
    is dependent on corresponding pixels of two images, whereas the functions and
    algorithms we'll learn about in this chapter are not easily parallelizable, or
    the resulting pixels and values might have little or nothing at all to do with
    their corresponding source pixels, or quite the opposite, the resulting pixels
    might depend on some or all of the input pixels at the same time.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 与本章中我们迄今为止看到的函数和算法不同，本节中的算法对图像（或矩阵）本身执行原子和完整的操作，并且不被视为迄今为止所描述的逐元素操作。如果你还记得，逐元素操作的规则是它们可以很容易地并行化，因为结果矩阵依赖于两个图像对应的像素，而本章我们将学习的函数和算法不易并行化，或者结果像素和值可能与其对应的源像素几乎没有关系，或者恰恰相反，结果像素可能同时依赖于一些或所有输入像素。
- en: Making borders for extrapolation
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为外推制作边界
- en: As you'll see in this and upcoming chapters, one of the most important issues
    to handle when dealing with many computer vision algorithms is extrapolation,
    or to put it simply, the assumption of the non-existing pixels outside of an image.
    You might be wondering, why would I need to think about the non-existing pixels,
    and the simplest answer is that there are many computer vision algorithms that
    work with not just a single pixel, but also with their surrounding pixels. In
    such cases, when the pixel is in the middle of an image, there are no issues.
    But for the pixels at the borders of the image (for instance, in the topmost row),
    some of the surrounding pixels will fall outside of the image. That is exactly
    where you need to think about extrapolation and the assumption of non-existing
    pixels. Are you going to simply assume those pixels have zero values? Maybe it's
    better to assume they have the same value as the border pixels? These questions
    are all taken care of in an OpenCV function called `copyMakeBorder`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你将在本节和即将到来的章节中看到的那样，在处理许多计算机视觉算法时，最重要的处理问题之一是外推，或者简单地说，假设图像之外的像素不存在。你可能想知道，为什么我需要考虑不存在的像素，最简单的答案是，有许多计算机视觉算法不仅与单个像素工作，还与周围的像素工作。在这种情况下，当像素位于图像中间时，没有问题。但对于图像边缘的像素（例如，在最顶行），一些周围的像素将超出图像范围。这正是你需要考虑外推和非存在像素假设的地方。你会简单地假设这些像素为零值吗？也许假设它们与边界像素具有相同的值会更好？所有这些问题都在
    OpenCV 中的一个名为 `copyMakeBorder` 的函数中得到了解决。
- en: '`copyMakeBorder` allows us to form borders outside an image and provides enough
    customizations to deal with all possible scenarios. Let''s see how `copyMakeBorder`
    is used with a couple of simple examples:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`copyMakeBorder` 允许我们在图像外部形成边界，并提供足够的定制选项来处理所有可能的场景。让我们通过几个简单的例子来看看 `copyMakeBorder`
    的用法：'
- en: '[PRE46]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'As seen in the preceding example, `copyMakeBorder` accepts an input image and
    produces a `result` image, just like most of the OpenCV functions we''ve learned
    about so far. In addition, this function must be provided with four integer values
    that represent the number of pixels that are added to the `top`, `bottom`, `left`,
    and `right` side of the image. However, the most important parameter that must
    be provided here is the `border` type parameter, which must be an entry of the
    `BorderTypes` enum. Here are a few of the most commonly used `BorderType` values:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如前例所示，`copyMakeBorder` 接受一个输入图像并生成一个 `result` 图像，就像我们迄今为止所学的 OpenCV 函数中的大多数一样。此外，此函数必须提供四个整数值，这些值代表添加到图像的
    `top`（顶部）、`bottom`（底部）、`left`（左侧）和 `right`（右侧）边的像素数。然而，这里必须提供的最重要的参数是 `border`
    类型参数，它必须是 `BorderTypes` 枚举的一个条目。以下是一些最常用的 `BorderType` 值：
- en: '`BORDER_CONSTANT`'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BORDER_CONSTANT`'
- en: '`` `BORDER_REPLICATE` ``'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`` `BORDER_REPLICATE` ``'
- en: '`BORDER_REFLECT`'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BORDER_REFLECT`'
- en: '`BORDER_WRAP`'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BORDER_WRAP`'
- en: 'Note that when `BORDER_CONSTANT` is used as the border type parameter, an additional
    scalar parameter must be provided to the `copyMakeBorder` function, which represents
    the constant color value of the created border. If this value is omitted, zero
    (or black) is assumed. The following image demonstrates the output of the `copyMakeBorder`
    function when it is executed on our example image:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当使用 `BORDER_CONSTANT` 作为边界类型参数时，必须向 `copyMakeBorder` 函数提供一个额外的标量参数，该参数表示创建的边界的常量颜色值。如果省略此值，则假定为零（或黑色）。以下图像显示了在执行
    `copyMakeBorder` 函数时在示例图像上的输出：
- en: '![](img/00030.jpeg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00030.jpeg)'
- en: '`copyMakeBorder`, and many other OpenCV functions, use the `borderInterpolate`
    function, internally, to calculate the position of the donor pixel used for the
    extrapolation and creating the non-existing pixels. You won''t need to call this
    function directly yourself, so we''ll leave it for you to explore and discover
    on your own.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`copyMakeBorder` 以及许多其他 OpenCV 函数，在内部使用 `borderInterpolate` 函数来计算用于外推和创建非现有像素的捐赠像素的位置。您不需要直接调用此函数，所以我们将其留给您自己探索和发现。'
- en: Flipping (mirroring) and rotating images
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 翻转（镜像）和旋转图像
- en: 'You can use the `flip` function to flip or mirror an image. This function can
    be used to flip an image around the *x* or *y* axes, or both, depending on the
    provided flip `code`. Here''s how this function is used:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `flip` 函数翻转或镜像图像。此函数可以用于围绕 *x* 或 *y* 轴翻转图像，或者两者同时翻转，具体取决于提供的翻转 `code`。以下是此函数的使用方法：
- en: '[PRE47]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: If `code` is zero, the input image will be flipped/mirrored vertically (around
    the *x* axis), if `code` is a positive value, the input image will be flipped/mirrored
    horizontally (around the *y* axis), and if `code` is a negative value, the input
    image will be flipped/mirrored around both the *x* and *y* axes at the same time.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `code` 为零，输入图像将垂直翻转/镜像（围绕 *x* 轴），如果 `code` 是正值，输入图像将水平翻转/镜像（围绕 *y* 轴），如果
    `code` 是负值，输入图像将同时围绕 *x* 和 *y* 轴翻转/镜像。
- en: 'On the other hand, to rotate an image, you can use the `rotate` function. What
    you need to take care of, when calling the `rotate` function, is providing a correct
    rotation flag, as seen in the following example:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，要旋转图像，您可以使用 `rotate` 函数。在调用 `rotate` 函数时，您需要注意提供正确的旋转标志，如下面的示例所示：
- en: '[PRE48]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The `RotateFlag` enum can be one of the following self-explanatory constant
    values:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`RotateFlag` 枚举可以是以下自解释的常量值之一：'
- en: '`ROTATE_90_CLOCKWISE`'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ROTATE_90_CLOCKWISE`'
- en: '`ROTATE_180`'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ROTATE_180`'
- en: '`ROTATE_90_COUNTERCLOCKWISE`'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ROTATE_90_COUNTERCLOCKWISE`'
- en: 'Here''s an image that depicts all possible results of the `flip` and `rotate`
    functions. Notice that the result of flip around both axes is the same as a 180-degree
    rotation in the following resulting images:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像展示了 `flip` 和 `rotate` 函数的所有可能结果。请注意，围绕两个轴翻转的结果与以下结果图像中的 180 度旋转相同：
- en: '![](img/00031.jpeg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00031.jpeg)'
- en: As mentioned previously in this chapter, `Mat::t`, or the transpose of a matrix,
    can also be used to rotate an image when used in conjunction with the `flip` function.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章前面所述，`Mat::t`，即矩阵的转置，也可以与 `flip` 函数结合使用来旋转图像。
- en: Working with channels
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理通道
- en: OpenCV provides a handful of functions to deal with channels, whether we need
    to merge, split, or perform various actions on them. In this section, we're going
    to learn how to split an image to its consisting channels or make a multi-channel
    image using multiple single-channel images. So, let's start.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV 提供了一些函数来处理通道，无论我们需要合并、拆分还是对它们执行各种操作。在本节中，我们将学习如何将图像拆分为其组成通道或使用多个单通道图像创建多通道图像。那么，让我们开始吧。
- en: 'You can use the `merge` function to merge a number of single-channel `Mat`
    objects and create a new multi-channel `Mat` object, as seen in the following
    sample code:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `merge` 函数合并多个单通道 `Mat` 对象并创建一个新的多通道 `Mat` 对象，如下面的示例代码所示：
- en: '[PRE49]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In the preceding code, `ch1`, `ch2`, and `ch3` are all single-channel images
    of the same size. The result will be a three-channel `Mat` object.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`ch1`、`ch2` 和 `ch3` 都是相同大小的单通道图像。结果将是一个三通道的 `Mat` 对象。
- en: 'You can also use the `insertChannel` function to insert a new channel into
    an image. Here''s how:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用 `insertChannel` 函数向图像中插入新通道。以下是方法：
- en: '[PRE50]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In the preceding code, `ch` is a single channel `Mat` object, `image` is the
    matrix we want to add an additional channel into it, and `idx` refers to the zero-based
    index number of the position where the channel will be inserted.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`ch`是一个单通道`Mat`对象，`image`是我们想要在其中添加额外通道的矩阵，而`idx`指的是通道将被插入的位置的零基于索引号。
- en: 'The `split` function can be used to perform exactly the opposite of the `merge`
    function, which is splitting a multi-channel image to create a number of single-channel
    images. Here''s an example:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`split`函数来执行与`merge`函数相反的操作，即将多通道图像分割成多个单通道图像。以下是一个示例：
- en: '[PRE51]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The `channels` array in the preceding code will contain three single-channel
    images of the same size that correspond to each individual channel in the image.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码中的`channels`数组将包含三个大小相同的单通道图像，分别对应于图像中的每个单独的通道。
- en: 'To be able to extract a single channel from an image, you can use the `extractChannel`
    function:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 要从图像中提取单个通道，可以使用`extractChannel`函数：
- en: '[PRE52]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: In the preceding code, quite obviously, the channel at position `idx` will be
    extracted from the image and saved in `ch`.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，很明显，位置`idx`的通道将从图像中提取并保存到`ch`中。
- en: 'Even though `merge`, `split`, `insertChannel`, and `extractChannel` are enough
    for most use cases, you still might need a more complex shuffling, extraction,
    or manipulation of the channels in an image. For this reason, OpenCV provides
    a function called `mixChannels`, which allows a much more advanced way of handling
    channels. Let''s see how `mixChannels` is used with an example case. Let''s say
    we want to shift all of the channels of an image to the right. To be able to perform
    such a task, we can use the following sample code:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 即使`merge`、`split`、`insertChannel`和`extractChannel`对于大多数用例已经足够，你仍然可能需要更复杂的通道打乱、提取或操作。因此，OpenCV提供了一个名为`mixChannels`的函数，它允许以更高级的方式处理通道。让我们通过一个示例案例来看看`mixChannels`是如何使用的。假设我们想要将图像的所有通道向右移动。为了能够执行这样的任务，我们可以使用以下示例代码：
- en: '[PRE53]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The only important piece of code in the preceding example is the `fromTo` vector,
    which must contain pairs of values that correspond to the channel number in the
    source and destination. The channels are, as always, 0-index based, so 0, 1 means
    the first channel in the source image will be copied to the second channel in
    the result and so on.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，唯一重要的代码片段是`fromTo`向量，它必须包含对应于源图像和目标图像中通道号的值对。通道号，如往常一样，是基于0的索引，所以0,
    1表示源图像中的第一个通道将被复制到结果中的第二个通道，依此类推。
- en: It's worth noting that all previous functions in this section (merge, split,
    and so on), are a partial case of the `mixChannels` function.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，本节中所有之前的函数（合并、分割等）都是`mixChannels`函数的部分情况。
- en: Mathematical functions
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数学函数
- en: The functions and algorithms that we'll learn about in this section are solely
    used for mathematical calculations of a non-element-wise nature, as opposed to
    what we saw earlier on in this chapter. They include simple functions, such as
    `mean` or `sum` or more complex operations, such as the discrete Fourier transform.
    Let's browse through some of the most important ones with hands-on examples.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中我们将学习的函数和算法仅用于非元素级数学计算，这与我们在本章前面所看到的不同。这包括简单的函数，如`mean`或`sum`，或更复杂的操作，如离散傅里叶变换。让我们通过一些实例来浏览其中一些最重要的函数。
- en: Matrix inversion
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 矩阵求逆
- en: 'The `invert` function can be used to calculate the inverse of a matrix. This
    should not to be confused with the `bitwise_not` function, which inverts each
    and every bit in the pixels of an image. The `invert` function is not an element-wise
    function, and the inversion method needs to be provided as a parameter to this
    function. Here''s an example:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`invert`函数来计算矩阵的逆。这不应与`bitwise_not`函数混淆，后者会反转图像像素中的每个比特。`invert`函数不是元素级函数，并且需要将反转方法作为参数传递给此函数。以下是一个示例：
- en: '[PRE54]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The `DecompTypes` enum contains all possible entries that can be used in the
    `invert` function as the decomposition type. Here they are:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`DecompTypes`枚举包含可以在`invert`函数中用作分解类型的所有可能条目。以下是它们：'
- en: '`DECOMP_LU`'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DECOMP_LU`'
- en: '`DECOMP_SVD`'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DECOMP_SVD`'
- en: '`DECOMP_EIG`'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DECOMP_EIG`'
- en: '`DECOMP_CHOLESKY`'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DECOMP_CHOLESKY`'
- en: '`DECOMP_QR`'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DECOMP_QR`'
- en: Refer to the OpenCV documentation for the `DecompTypes` enum if you're interested
    in a detailed description of each and every decomposition method.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对每个分解方法的详细描述感兴趣，请参阅OpenCV文档中的`DecompTypes`枚举。
- en: Mean and sum of elements
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 元素的均值和总和
- en: 'You can calculate the mean, or the average value of the elements in a matrix,
    by using the `mean` function. Here is an example that shows how to read an image
    and calculate and display the mean value of all of its individual channels:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`mean`函数来计算矩阵中元素的均值，或者说是平均值。以下是一个示例，展示了如何读取图像并计算并显示其所有单独通道的均值：
- en: '[PRE55]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'You can use the `sum` function exactly the same way, to calculate the sum of
    elements in a matrix:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`sum`函数以完全相同的方式，来计算矩阵中元素的求和：
- en: '[PRE56]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'OpenCV also includes a `meanStdDev` function that can be used to calculate
    the mean and standard deviation of all elements in the matrix at the same time.
    Here is an example:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV还包括一个`meanStdDev`函数，可以用来同时计算矩阵中所有元素的均值和标准差。以下是一个示例：
- en: '[PRE57]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Similar to the `mean` function, the `meanStdDev` function also calculates the
    results for each individual channel separately.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 与`mean`函数类似，`meanStdDev`函数也会分别计算每个单独通道的结果。
- en: Discrete Fourier transformation
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 离散傅里叶变换
- en: A discrete Fourier transformation of a 1D or 2D array, or in other words—an
    image, is one of the many ways to analyze an image in computer vision. The interpretation
    of the result depends completely on the field it is being used for and that is
    not what we are concerned with in this book, however, how to perform a discrete
    Fourier transformation is what we're going to learn in this section.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 一维或二维数组的离散傅里叶变换，或者说图像的离散傅里叶变换，是计算机视觉中分析图像的许多方法之一。结果的理解完全取决于其应用的领域，而这本书中我们并不关心这一点，然而，在本节中我们将学习如何执行离散傅里叶变换。
- en: Simply put, you can use the `dft` function to calculate the Fourier transformation
    of an image. However, there are some preparations needed before the `dft` function
    can be safely called. The same applies to the result of the Fourier transformation.
    Let's break this down with an example code, and by calculating and displaying
    the Fourier transformation of our example image used in the previous sections.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，你可以使用`dft`函数来计算图像的傅里叶变换。然而，在安全调用`dft`函数之前，需要做一些准备工作。傅里叶变换的结果也是如此。让我们用一个示例代码来分解这个过程，并通过计算和显示之前章节中使用的示例图像的傅里叶变换来展示。
- en: 'The `dft` function can process matrices of certain sizes (powers of 2, such
    as 2, 4, and 8) a lot more efficiently, that is why it is always best to increase
    the size of our matrix to the nearest optimum size and pad it with zeroes before
    calling the `dft` function. This can be done by using the `getOptimalDFTSize`
    function. Assuming that `image` is the input image that we want to calculate its
    discrete Fourier transformation, we can write the following code to calculate
    and resize it to the optimum size for the `dft` function:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`dft`函数可以更高效地处理特定大小的矩阵（如2的幂，例如2、4和8），这就是为什么在调用`dft`函数之前，最好将矩阵的大小增加到最接近的优化大小，并用零填充。这可以通过使用`getOptimalDFTSize`函数来完成。假设`image`是我们想要计算其离散傅里叶变换的输入图像，我们可以编写以下代码来计算并调整其大小以适应`dft`函数的优化大小：'
- en: '[PRE58]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: As you can see, the `getOptimalDFTSize` function must be called twice, for rows
    and columns separately. You are already familiar with the `copyMakeBorder` function.
    Resizing an image and padding the new pixels with zeroes (or any other desired
    value) is one of countless example use cases for the `copyMakeBorder` function.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，必须分别对行和列调用`getOptimalDFTSize`函数两次。您已经熟悉`copyMakeBorder`函数。调整图像大小并用零（或任何其他所需值）填充新像素是`copyMakeBorder`函数无数用例之一。
- en: 'The rest is quite easy, we need to form a two-channel image and pass it to
    the `dft` function and get the complex (real and imaginary) result in the same
    matrix. This will later simplify the process of displaying the result. Here''s
    how it''s done:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 其余部分相当简单，我们需要形成一个双通道图像，并将其传递给`dft`函数，以在同一个矩阵中获得复数（实部和虚部）的结果。这将简化后续的显示过程。以下是具体操作方法：
- en: '[PRE59]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We have already learned how to use the `merge` function. The only important
    thing to note in the preceding code is the fact that the result is saved into
    the same image as the input. `complexImage` now contains two channels, one for
    the real and the other for the imaginary part of the discrete Fourier transformation.
    That''s it! We now have our result, however, to be able to display it, we must
    calculate the magnitude of the result. Here''s how it''s done:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了如何使用`merge`函数。在前面的代码中需要注意的唯一重要的事情是结果被保存到了与输入相同的图像中。`complexImage`现在包含两个通道，一个用于离散傅里叶变换的实部，另一个用于虚部。就是这样！我们现在有了结果，然而，为了能够显示它，我们必须计算结果的大小。下面是如何操作的：
- en: '[PRE60]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'In the preceding code, we have split the complex result into its consisting
    channels and then calculated the magnitude using the `magnitude` function. Theoretically,
    `mag` is a displayable result, but in reality, it contains values much higher
    than what is displayable using OpenCV, so we need to perform a couple of conversions
    before being able to display it. First, we need to make sure the result is in
    the logarithmic scale, by performing the following conversion:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们将复数结果分解为其组成通道，然后使用`magnitude`函数计算幅度。理论上，`mag`是一个可显示的结果，但在现实中，它包含的值远高于使用OpenCV可显示的值，因此我们需要在显示之前进行几个转换。首先，我们需要确保结果是按对数尺度，通过执行以下转换：
- en: '[PRE61]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Next, we must make sure the result values are scaled and normalized to fit
    between `0.0` and `1.0`, to be displayable by the `imshow` function in OpenCV.
    You need to use the `normalize` function for this reason:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须确保结果值被缩放并归一化，以便在`0.0`和`1.0`之间，以便由OpenCV的`imshow`函数显示。你需要使用`normalize`函数来完成这个任务：
- en: '[PRE62]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'You can now try to display the result using the `imshow` function. Here''s
    an example that displays the result of the discrete Fourier transformation:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以尝试使用`imshow`函数显示结果。以下是一个显示离散傅里叶变换结果的示例：
- en: '![](img/00032.gif)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00032.gif)'
- en: 'The problem with this result is that the quadrants need to be swapped before
    the origin of the result is at the center of the image. The following image depicts
    how the four quadrants of the result must be swapped before the result has an
    origin point at the center:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结果的问题在于，在结果的原点位于图像中心之前，需要交换四个象限。以下图像展示了在结果有一个位于中心的起点之前，必须如何交换四个结果象限：
- en: '![](img/00033.jpeg)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00033.jpeg)'
- en: 'The following is the code needed to swap the four quadrants of the Fourier
    transform result. Notice how we first find the center of the result, then create
    four **region of interest** (**ROI**) matrices, and then swap them:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码用于交换傅里叶变换结果的四个象限。注意我们首先找到结果中心，然后创建四个**感兴趣区域**（ROI）矩阵，然后交换它们：
- en: '[PRE63]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The `dft` function accepts an additional parameter that can be used to further
    customize its behavior. This parameter can be a combination of values from the `DftFlags`
    enum. For instance, to perform an inverse Fourier transformation, you need to
    call the `dft` function with the `DFT_INVERSE` parameter:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`dft`函数接受一个额外的参数，可以用来进一步自定义其行为。此参数可以是来自`DftFlags`枚举的值的组合。例如，要执行逆傅里叶变换，你需要使用`DFT_INVERSE`参数调用`dft`函数：'
- en: '[PRE64]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'This can also be done by using the `idft` function:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这也可以通过使用`idft`函数来完成：
- en: '[PRE65]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Make sure to check out the `DftFlags` enum and the `dft` function documentation
    for more information about how the discrete Fourier transform is implemented in
    OpenCV.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 确保查看`DftFlags`枚举和`dft`函数文档，以获取有关OpenCV中离散傅里叶变换实现方式的更多信息。
- en: Generating random numbers
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成随机数
- en: 'Random number generation is one of the most widely used algorithms in computer
    vision, especially when it comes to testing an existing algorithm with random
    values between given ranges. When using the OpenCV library, you can use the following
    functions to produce values or matrices containing random values:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 随机数生成是计算机视觉中最广泛使用的算法之一，尤其是在测试给定范围内的随机值时。当使用OpenCV库时，你可以使用以下函数来生成包含随机值的值或矩阵：
- en: 'The `randn` function can be used to fill a matrix or an array with random numbers
    with a given mean value and standard deviation. Here''s how this function is used:'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`randn`函数可以用来填充一个矩阵或数组，使其包含具有给定平均值和标准差的随机数。以下是此函数的使用方法：'
- en: '[PRE66]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The `randu` function, similar to the `randn` function, is used to fill an array
    with random values, however, instead of mean and standard deviation, this function
    uses a lower band and higher band (both inclusive) for the produced random values.
    Here''s an example:'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`randu` 函数与 `randn` 函数类似，用于用随机值填充数组，然而，这个函数使用的是下限和上限（两者都包含）来生成随机值。以下是一个示例：'
- en: '[PRE67]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The `randShuffle` function, as it can be guessed from its title, is used to
    randomly shuffle the contents of an array or matrix. It is used as simply as it
    is depicted in the following example:'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`randShuffle` 函数，从其标题可以猜到，用于随机打乱数组或矩阵的内容。它就像以下示例中展示的那样简单使用：'
- en: '[PRE68]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The search and locate functions
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 搜索和定位函数
- en: When working on your computer vision projects, you'll be faced with countless
    scenarios and cases in which you'll need to look for certain pixels, or the maximum
    values (brightest point), and so on. The OpenCV library contains a number of functions
    that can be used for this same purpose, and they are the subject of this section.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在计算机视觉项目中工作时，你将面临无数的场景和案例，在这些场景和案例中，你需要寻找特定的像素，或者最大值（最亮点），等等。OpenCV 库包含许多可用于此目的的函数，这些函数是本节的主题。
- en: Locating non-zero elements
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定位非零元素
- en: Locating, or counting, non-zero elements can come in quite handy, especially
    when looking for specific regions in an image after a threshold operation, or
    when looking for the area covered by a specific color. OpenCV contains the `findNonZero`
    and `countNonZero` functions, which simply allow you to find or count the pixels
    with non-zero (or bright) values in an image.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 定位或计数非零元素可能会非常有用，尤其是在对图像进行阈值操作后寻找特定区域，或者寻找特定颜色覆盖的区域时。OpenCV 包含 `findNonZero`
    和 `countNonZero` 函数，这些函数可以简单地让你找到或计数图像中具有非零（或明亮）值的像素。
- en: 'Here is an example that depicts how you can use the `findNonZero` function
    to find the first non-black pixel in a grayscale image and print its position:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个示例，展示了如何使用 `findNonZero` 函数在灰度图像中找到第一个非黑色像素并打印其位置：
- en: '[PRE69]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Here is another example code that shows how you can find the percentage of
    black pixels in a grayscale image:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是另一个示例代码，展示了如何找到灰度图像中黑色像素的百分比：
- en: '[PRE70]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Locating minimum and maximum elements
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定位最小和最大元素
- en: 'Locating the brightest (maximum) and darkest (minimum) points in an image or
    matrix are two of the most important types of searches within images in computer
    vision, especially after performing certain types of thresholding algorithms,
    or template-matching functions (which we''ll learn about in the upcoming chapters).
    OpenCV provides the following two functions to locate global minimum and maximum
    values, along with their positions is a matrix:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在图像或矩阵中定位最亮（最大）和最暗（最小）点是计算机视觉中图像搜索的最重要类型之一，尤其是在执行某些类型的阈值算法或模板匹配函数（我们将在接下来的章节中学习）之后。OpenCV
    提供以下两个函数来定位矩阵中的全局最小和最大值及其位置：
- en: '`minMaxIdx`'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`minMaxIdx`'
- en: '`minMaxLoc`'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`minMaxLoc`'
- en: 'The `minMaxLoc` function searches the whole image (only single-channel images)
    for the brightest and darkest points and returns the value of the brightest and
    darkest pixel, along with their positions, whereas the `minMaxIdx` function returns
    a pointer to the found minimum and maximum position, instead of a position (the
    `Point` object with *x* and *y*). Here''s how the `minMaxLoc` function is used:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '`minMaxLoc` 函数在整个图像（仅单通道图像）中搜索最亮和最暗的点，并返回最亮和最暗像素的值，以及它们的位置，而 `minMaxIdx` 函数返回找到的最小和最大位置的指针，而不是位置（带有
    *x* 和 *y* 的 `Point` 对象）。以下是 `minMaxLoc` 函数的使用方法：'
- en: '[PRE71]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'This is an example of using the `minMaxIdx` function:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用 `minMaxIdx` 函数的示例：
- en: '[PRE72]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Lookup table transformation
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找表转换
- en: In computer vision, replacing pixels with new values based on their value from
    a given table that contains the required replacement is called **lookup table
    transformation**. This might sound a bit confusing at first but it's a very powerful
    and simple method for modifying images using lookup tables. Let's see how it's
    done with a hands-on example.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机视觉中，根据给定表中包含的所需替换值替换像素称为 **查找表转换**。一开始这可能听起来有些令人困惑，但它是一种非常强大且简单的方法，用于使用查找表修改图像。让我们通过一个实际示例来看看它是如何实现的。
- en: 'Let''s assume we have an example image and we need to replace the bright pixels
    (with a value greater than `175`) with absolute white, dark pixels (with a value
    less than `125`) with absolute black, and leave the rest of the pixels as they
    are. To perform such a task, we can simply use a lookup table `Mat` object along
    with the `LUT` function in OpenCV:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个示例图像，我们需要将亮度像素（值大于`175`）替换为绝对白色，暗像素（值小于`125`）替换为绝对黑色，其余像素保持不变。为了执行此类任务，我们可以简单地使用查找表`Mat`对象以及OpenCV中的`LUT`函数：
- en: '[PRE73]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The following image depicts the result of this lookup table transformation
    when it is executed on our example image. As you can see, the lookup table transformation
    can be executed on both color (on the right) and grayscale (on the left) images:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像展示了当在示例图像上执行此查找表转换时的结果。正如你所见，查找表转换可以在彩色（在右侧）和灰度（在左侧）图像上执行：
- en: '![](img/00034.jpeg)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00034.jpeg)'
- en: Using the `LUT` function wisely can lead to many creative solutions for computer
    vision problems where replacing pixels with a given value is desired.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 聪明地使用`LUT`函数可以为计算机视觉问题中的许多创意解决方案带来帮助，其中需要用给定值替换像素。
- en: Summary
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: What we saw in this chapter was a taste of what can be done using matrix and
    array operations in computer vision with the OpenCV library. We started the chapter
    with nothing but a firm background in the fundamental concepts of computer vision
    from the previous chapters, and we ended up learning about lots of algorithms
    and functions using hands-on examples. We learned about ones, zeroes, identity
    matrix, transpose, and other functions embedded into the heart of the `Mat` class.
    Then, we continued on to learn about many element-wise algorithms. We are now
    totally capable of performing element-wise matrix operations, such as basic operations,
    comparisons, and bitwise operations. Finally, we learned about the non-element-wise
    operations in the OpenCV core module. Making borders, modifying channels, and
    discrete Fourier transformation were among the many algorithms we learned to use
    in this chapter.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中我们所看到的是使用OpenCV库在计算机视觉中进行矩阵和数组操作所能做到的一小部分。我们从对前几章中计算机视觉基本概念有坚实的背景知识开始，最终通过实际示例学习了大量算法和函数。我们学习了ones、zeroes、单位矩阵、转置以及其他嵌入到`Mat`类核心中的函数。然后，我们继续学习许多逐元素算法。我们现在完全能够执行逐元素矩阵运算，如基本运算、比较和位运算。最后，我们学习了OpenCV核心模块中的非逐元素操作。创建边界、修改通道和离散傅里叶变换是我们在本章中学到的许多算法之一。
- en: In the next chapter, we're going to learn about computer vision algorithms used
    for filtering, drawing, and other functions. Topics covered in the upcoming chapter
    are essential before you step into the world of advanced computer vision development
    and algorithms used for highly complex tasks, such as face or object detection
    and tracking.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习用于过滤、绘制和其他功能的计算机视觉算法。即将到来的章节中涵盖的主题是在你步入高级计算机视觉开发世界以及用于高度复杂任务（如人脸或物体检测和跟踪）的算法之前所必需的。
- en: Questions
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Which of the element-wise mathematical operations and bitwise operations would
    produce the exact same results?
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪些逐元素数学运算和位运算会产生完全相同的结果？
- en: What is the purpose of the `gemm` function in OpenCV? What is the equivalent
    of `A*B` with the `gemm` function?
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: OpenCV中的`gemm`函数的目的是什么？使用`gemm`函数，`A*B`的等价是什么？
- en: Use the `borderInterpolate` function to calculate the value of a non-existing
    pixel at point `(-10, 50)`, with a border type of `BORDER_REPLICATE`. What is
    the function call required for such a calculation?
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`borderInterpolate`函数计算点`(-10, 50)`处不存在像素的值，边框类型为`BORDER_REPLICATE`。进行此类计算所需的函数调用是什么？
- en: Create the same identity matrix as in the *Learning about the dentity matrix*
    section of this chapter, but use the `setIdentity` function instead of the `Mat::eye`
    function.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建与本章*学习单位矩阵*部分相同的单位矩阵，但使用`setIdentity`函数而不是`Mat::eye`函数。
- en: Write a program using the `LUT` function (lookup table transformation) that
    performs the same task as `bitwise_not` (invert colors) when executed on grayscale
    and color (RGB) images.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个使用`LUT`函数（查找表转换）的程序，当在灰度图像和彩色（RGB）图像上执行时，与`bitwise_not`（颜色反转）执行相同的任务。
- en: Besides normalizing the values of a matrix, the `normalize` function can be
    used to brighten or darken images. Write the required function call to darken
    and brighten a grayscale image using the `normalize` function.
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除了对矩阵的值进行归一化外，`normalize`函数还可以用来调整图像的亮度或暗度。请编写所需的函数调用，使用`normalize`函数来使灰度图像变暗和变亮。
- en: Remove the blue channel (first channel) from an image (BGR image created using
    the `imread` function) using the `merge` and `split` functions.
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`merge`和`split`函数从图像（使用`imread`函数创建的BGR图像）中移除蓝色通道（第一个通道）。
