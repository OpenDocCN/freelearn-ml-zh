- en: Assessments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Chapter 1, Introduction to Computer Vision
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 1\. Name two industries besides the ones mentioned in this chapter that can
    significantly benefit from computer vision.
  prefs: []
  type: TYPE_NORMAL
- en: The sports industry can use computer vision for better analysis of matches.
  prefs: []
  type: TYPE_NORMAL
- en: The food industry can use computer vision for quality control of products.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. What would be an example of a computer vision application used for security
    purposes? (Think about an idea for an application that you haven't come across.)
  prefs: []
  type: TYPE_NORMAL
- en: A very random example would be an application that uses face recognition for
    ticket checks on trains, flights, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 3\. What would be an example of a computer vision application used for productivity
    reasons? (Again, think about an idea for an application that you haven't come
    across, even though you might suspect that it exists.)
  prefs: []
  type: TYPE_NORMAL
- en: An application that uses its camera to help visually impaired people.
  prefs: []
  type: TYPE_NORMAL
- en: 4\. How many megabytes would be needed to store a 1920 x 1080 image with four
    channels and a depth of 32-bits?
  prefs: []
  type: TYPE_NORMAL
- en: 'Approximately 31.64 megabytes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00112.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 5\. Ultra-HD images, also known as 4K, or 8K images are quite common nowadays,
    but how many megapixels does an Ultra-HD image contain?
  prefs: []
  type: TYPE_NORMAL
- en: 'This mostly depends on the aspect ratio. For a common 16:9 aspect ratio, here
    are the answers:'
  prefs: []
  type: TYPE_NORMAL
- en: '**4K**: 8.3 megapixels'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**8K**: 33.2 megapixels'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Have a look at this link for more info:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Ultra-high-definition_television](https://en.wikipedia.org/wiki/Ultra-high-definition_television)'
  prefs: []
  type: TYPE_NORMAL
- en: 6\. Name two commonly used color spaces besides the ones mentioned in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: YUV and LUV color spaces
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/List_of_color_spaces_and_their_uses](https://en.wikipedia.org/wiki/List_of_color_spaces_and_their_uses)'
  prefs: []
  type: TYPE_NORMAL
- en: 7\. Compare OpenCV libraries with computer vision tools in MATLAB. What are
    the pros and cons of each one, when compared?
  prefs: []
  type: TYPE_NORMAL
- en: In general, MATLAB is best used when a computer vision application needs to
    be simulated and prototyped, while OpenCV is more straightforward when it comes
    to real-life scenarios and applications where speed and full control over the
    end product is needed.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 2, Getting Started with OpenCV
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 1\. Name three Extra OpenCV modules, along with their usage.
  prefs: []
  type: TYPE_NORMAL
- en: The `xfeatures2d` module can be used to access additional feature detection
    algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: The `face` module can be used to include face analysis algorithms in OpenCV.
  prefs: []
  type: TYPE_NORMAL
- en: The `text` module can be used to add OCR functionalities (Tesseract OCR) to
    OpenCV.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. What is the effect of building OpenCV 3 with the `BUILD_opencv_world` flag
    turned on?
  prefs: []
  type: TYPE_NORMAL
- en: Building OpenCV 3 with the `BUILD_opencv_world` flag will combine all binary
    library files, such as `core`, `imcodecs`, and `highgui`, into a single world
    library.
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Using the ROI pixel access method described in this chapter, how can we
    construct a `Mat` class that can access the middle pixel, plus all of its neighboring
    pixels (the middle nine pixels) in another image?
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example code that can achieve this goal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 4\. Name another pixel access method of the `Mat` class, besides the ones mentioned
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 5\. Write a program, only using the `Mat` method and a `for` loop, that creates
    three separate color images, each one containing only one channel of an RGB image
    read from disk.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00113.gif)![](img/00114.gif)![](img/00115.gif)'
  prefs: []
  type: TYPE_IMG
- en: 6\. Using STL-like iterators, calculate the average pixel value of a grayscale
    image.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 7\. Write a program using `VideoCapture`, `waitKey`, and `imwrite`, that displays
    your webcam and saves the visible image when the *S* key is pressed. This program
    will stop the webcam and exit if the spacebar is pressed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Chapter 3, Array and Matrix Operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 1\. Which of the element-wise mathematical operations and bitwise operations
    would produce the exact same results?
  prefs: []
  type: TYPE_NORMAL
- en: The `bitwise_xor` and `absdiff` functions would produce the same result.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. What is the purpose of the `gemm` function in OpenCV? What is the equivalent
    of *A*x*B* with the `gemm` function?
  prefs: []
  type: TYPE_NORMAL
- en: 'The `gemm` function is the generalized multiplication function in OpenCV. Here''s
    the `gemm` function call equivalent to the simple multiplication of two matrices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 3\. Use the `borderInterpolate` function to calculate the value of a non-existing
    pixel at point (-10, 50), with a border type of `BORDER_REPLICATE`. What is the
    function call required for such a calculation?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 4\. Create the same identity matrix in the *Identity matrix* section of this
    chapter, but use the `setIdentity` function instead of the `Mat::eye` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 5\. Write a program using the `LUT` function (a look-up table transformation)
    that performs the same task as `bitwise_not` (invert colors) when executed on
    grayscale and color (RGB) images.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 6\. Besides normalizing the values of a matrix, the `normalize` function can
    be used to brighten or darken images. Write the required function call to darken
    and brighten a grayscale image using the `normalize` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 7\. Remove the blue channel (the first channel) from an image (a BGR image created
    using the `imread` function) using the `merge` and `split` functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Chapter 4, Drawing, Filtering, and Transformation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 1\. Write a program that draws a cross over the whole image, with a thickness
    of 3 pixels and a red color.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 2\. Create a window with a trackbar to change the `ksize` of a `medianBlur`
    function. The range for the `kszise` value should be between 3 and 99.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 3\. Perform a gradient morphological operation on an image, considering a kernel
    size of 7 and a rectangle morphological shape for the structuring element.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00116.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 4\. Using `cvtColor`, convert a color image to grayscale and make sure only
    the darkest 100 shades of gray are filtered out using the `threshold` function.
    Make sure the filtered pixels are set to white in the resulting image, and the
    rest of the pixels are set to black.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00117.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 5\. Use the `remap` function to resize an image to half of its original width
    and height, thus preserving the aspect ratio of the original image. Use a default
    border type for the extrapolation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00118.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 6\. a) Use colormaps to convert an image to grayscale. b) How about converting
    an image to grayscale and inverting its pixels at the same time?
  prefs: []
  type: TYPE_NORMAL
- en: a)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: b)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 7\. Did you read about perspective transformation functions? Which OpenCV function
    covers all similar transformations in one function?
  prefs: []
  type: TYPE_NORMAL
- en: The `findHomography` function.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 5, Back-Projection and Histograms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 1\. Calculate the histogram of the second channel in a three-channel image.
    Use an optional bin size and a range of 0 to 100 for possible values of the second
    channel.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 2\. Create a histogram that can be used with `calcBackProject` function to extract
    the darkest pixels from a grayscale image. Consider the darkest 25% possible pixel
    values as the grayscale intensities we are looking to extract.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 3\. In the previous question, what if we needed the darkest and brightest 25%
    to be excluded, instead of extracted in a mask?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 4\. What is the hue value of the red color? How much should it be shifted to
    get the blue color?
  prefs: []
  type: TYPE_NORMAL
- en: 0 and 360 are the hue values for the red color. Shifting it by 240 would result
    in the blue color.
  prefs: []
  type: TYPE_NORMAL
- en: 5\. Create a hue histogram that can be used to extract red colored pixels from
    an image. Consider an offset of 50 for pixels that are considered red. Finally,
    visualize the created hue histogram.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00119.gif)'
  prefs: []
  type: TYPE_IMG
- en: 6\. Calculate the integral of a histogram.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 7\. Perform histogram equalization on a color image. Note that the `equalizeHist`
    function only supports histogram equalization of single-channel 8-bit grayscale
    images.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Chapter 6, Video Analysis – Motion Detection and Tracking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 1\. All the examples in this chapter that deal with cameras return when there
    is a single failed or corrupted frame that leads to the detection of an empty
    frame. What type of modification is needed to allow a predefined number of retries
    before stopping the process?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 2\. How can we call the `meanShift` function to perform the Mean Shift algorithm
    with 10 iterations and an epsilon value of 0.5?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 3\. How do you visualize the hue histogram of the tracked object? Assume that `CamShift`
    is used for tracking.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We can call the following right after the `CamShift` function call to visualize
    the hue of the detected object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 4\. Set the process noise covariance in the `KalmanFilter` class so that the
    filtered and measured values overlap. Assume that only process noise covariance
    is set of all the available matrices for the `KalmanFilter` class's behavior control.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00120.gif)'
  prefs: []
  type: TYPE_IMG
- en: 5\. Let's assume that the *Y* position of the mouse on a window is used to describe
    the height of a filled rectangle that starts from the top-left corner of the window
    and has a width that equals the window's width. Write a Kalman filter that can
    be used to correct the height of the rectangle (single value) and remove noise
    in the mouse's movement, resulting in a visually smooth resizing of the filled
    rectangle.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 6\. Create a `BackgroundSubtractorMOG2` object to extract the foreground image's
    contents while avoiding the shadow changes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 7\. Write a program to display the current (as opposed to sampled) background
    image using a background segmentation algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Chapter 7, Object Detection – Features and Descriptors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 1\. The template matching algorithm is not scale- and rotation-invariant by
    itself. How can we make it so for a) double the scale of the template image, and
    b) a 90 degrees rotated version of the template image?
  prefs: []
  type: TYPE_NORMAL
- en: 'a) Use the `resize` function to scale the template image, and then call the `matchTemplate`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'b) Rotate the template by 90 degrees and then call the `matchTemplate` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 2\. Use the `GFTTDetector` class to detect the keypoints with the Harris corner-detection
    algorithm. You can set any values for the corner-detection algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 3\. The Hough transformation can also be used to detect circles in an image
    using the `HoughCircles` function. Search for it in the OpenCV documentation and
    write a program to detect circles in an image.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 4\. Detect and draw the convex contours in an image.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 5\. Use the `ORB` class to detect keypoints in two images, extract their descriptors,
    and match them.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 6\. Which feature descriptor matching algorithm is incompatible with the ORB
    algorithm, and why?
  prefs: []
  type: TYPE_NORMAL
- en: You cannot use the FLANN-based matching algorithm with descriptors that have
    a bit string type, such as ORB.
  prefs: []
  type: TYPE_NORMAL
- en: 7\. You can use the following OpenCV functions and the sample to calculate the
    time required to run any number of lines of code. Use it to calculate the time
    it takes for the matching algorithms on your computer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Chapter 8, Machine Learning in Computer Vision
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 1\. What is the difference between the `train` and `trainAuto` methods in the
    `SVM` class?
  prefs: []
  type: TYPE_NORMAL
- en: The `trainAuto` method chooses the optimal values for the SVM parameters, such
    as `C`, `Gamma` and so on, and trains the model, while the `train` method simply
    uses any given parameters. (Read the `SVM` class documentation for more details
    about the `trainAuto` function and how exactly the optimization happens.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Demonstrate the difference between linear and histogram intersection.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can set the kernel type to `LINEAR` using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the result of the classification (segmentation) if we have displayed
    groups of black, white, and gray dots:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00121.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'Similarly, we can use the following code to set the kernel type to histogram
    intersection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the result of the same data segmented with the histogram intersection
    kernel:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00122.gif)'
  prefs: []
  type: TYPE_IMG
- en: 3\. How do you calculate the `HOGdescriptor` size for a HOG window size of 128
    by 96 pixels? (The rest of the HOG parameters are untouched.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 4\. How do you update an existing trained `ANN_MLP`, instead of training from
    scratch?
  prefs: []
  type: TYPE_NORMAL
- en: 'You do this by setting the `UPDATE_WEIGHTS` flag during the training. Here''s
    an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 5\. What is the required command (by using `opencv_createsamples`) you need
    to use to create a positive samples vector from a single image of a company logo?
    Assume you want to have 1,000 samples with a width of 24 and a height of 32, and
    by using default parameters for rotations and inversions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 6\. What is the command required to train an LBP cascade classifier for the
    company logo from the previous question?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 7\. What is the default number of stages for training a cascade classifier in
    `opencv_traincascade`? How can we change it? What is the downside of increasing
    and decreasing the number of stages far beyond its default value?
  prefs: []
  type: TYPE_NORMAL
- en: The default number of stages when training a classifier is 20, which is enough
    for most use cases. You can set it to any other value you want by using the `numStages`
    parameter. Increasing the number of stages too much can lead to overtraining the
    classifier and far more time is then required to train it, and vice versa.
  prefs: []
  type: TYPE_NORMAL
