<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer020">&#13;
			<h1 id="_idParaDest-33" class="chapter-number"><a id="_idTextAnchor032"/>2</h1>&#13;
			<h1 id="_idParaDest-34"><a id="_idTextAnchor033"/>Data Processing with dplyr</h1>&#13;
			<p>In the previous chapter, we covered the basics of the R language itself. Grasping these fundamentals will help us better tackle the challenges in the most common task in data science projects: <strong class="bold">data processing</strong>. Data processing <a id="_idIndexMarker124"/>refers to a series of data wrangling and massaging steps that transform the data into its intended format for downstream analysis and modeling. We can consider it as a function that accepts the raw data and outputs the desired data. However, we need to explicitly specify how the function executes the cooking recipe and processes <span class="No-Break">the data.</span></p>&#13;
			<p>By the end of this chapter, you will be able to perform common data wrangling steps such as filtering, selection, grouping, and aggregation using <strong class="source-inline">dplyr</strong>, one of the most widely used data processing libraries <span class="No-Break">in R.</span></p>&#13;
			<p>In this chapter, we will cover the <span class="No-Break">following topics:</span></p>&#13;
			<ul>&#13;
				<li>Introducing <strong class="source-inline">tidyverse</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">dplyr</strong></span></li>&#13;
				<li>Data transformation <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">dplyr</strong></span></li>&#13;
				<li>Data aggregation <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">dplyr</strong></span></li>&#13;
				<li>Data merging <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">dplyr</strong></span></li>&#13;
				<li>Case study – working with the Stack <span class="No-Break">Overflow dataset</span></li>&#13;
			</ul>&#13;
			<h1 id="_idParaDest-35"><a id="_idTextAnchor034"/>Technical requirements</h1>&#13;
			<p>To complete the exercises in this chapter, you will need <span class="No-Break">the following:</span></p>&#13;
			<ul>&#13;
				<li>The latest version of the <strong class="source-inline">tidyverse</strong> package, which is 1.3.1 at the time <span class="No-Break">of writing</span></li>&#13;
			</ul>&#13;
			<p>All the code and data for this chapter is available <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/The-Statistics-and-Machine-Learning-with-R-Workshop/tree/main/Chapter_2"><span class="No-Break">https://github.com/PacktPublishing/The-Statistics-and-Machine-Learning-with-R-Workshop/tree/main/Chapter_2</span></a><span class="No-Break">.</span></p>&#13;
			<h1 id="_idParaDest-36"><a id="_idTextAnchor035"/>Introducing tidyverse and dplyr</h1>&#13;
			<p>One of the most widely used R libraries that contains a set of individual packages is <strong class="source-inline">tidyverse</strong>; it <a id="_idIndexMarker125"/>includes <strong class="source-inline">dplyr</strong> and <strong class="source-inline">ggplot2</strong> (to be covered in <a href="B18680_04.xhtml#_idTextAnchor077"><span class="No-Break"><em class="italic">Chapter 4</em></span></a>). It can support most data<a id="_idIndexMarker126"/> processing and visualization needs and comes with an easy and fast implementation compared to base R commands. Therefore, it is recommended to outsource a specific data processing or visualization task to <strong class="source-inline">tidyverse</strong> instead of implementing <span class="No-Break">it ourselves.</span></p>&#13;
			<p>Before we dive into the world of data processing, there is one more data structure that’s used in the ecosystem of <strong class="source-inline">tidyverse</strong>: <strong class="source-inline">tibble</strong>. A <strong class="source-inline">tibble</strong> is an <a id="_idIndexMarker127"/>advanced version of a DataFrame and offers much better format control, leading to clean expressions in code. It is the central data structure in <strong class="source-inline">tidyverse</strong>. A DataFrame can be converted into a <strong class="source-inline">tibble</strong> object and vice versa. Let’s go through an exercise <span class="No-Break">on this.</span></p>&#13;
			<h3>Exercise 2.01 – converting between tibble and a DataFrame</h3>&#13;
			<p>First, we<a id="_idIndexMarker128"/> will explore the <strong class="source-inline">tidyverse</strong> ecosystem by installing<a id="_idIndexMarker129"/> this package and then <a id="_idIndexMarker130"/>converting the <strong class="source-inline">iris</strong> DataFrame into <span class="No-Break"><strong class="source-inline">tibble</strong></span><span class="No-Break"> format:</span></p>&#13;
			<ol>&#13;
				<li>Install the <strong class="source-inline">tidyverse</strong> package and load the <span class="No-Break"><strong class="source-inline">dplyr</strong></span><span class="No-Break"> package:</span><pre class="source-code">&#13;
install.packages("tidyverse")&#13;
library(dplyr)</pre><p class="list-inset">Installing the <strong class="source-inline">tidyverse</strong> package will automatically install <strong class="source-inline">dplyr</strong>, which can be loaded into our working environment via the <span class="No-Break"><strong class="source-inline">library()</strong></span><span class="No-Break"> function.</span></p></li>				<li>Load the <strong class="source-inline">iris</strong> dataset and check its <span class="No-Break">data structure:</span><pre class="source-code">&#13;
&gt;&gt;&gt; data("iris")&#13;
&gt;&gt;&gt; class(iris)&#13;
"data.frame"</pre><p class="list-inset">The <strong class="source-inline">data()</strong> function loads the <strong class="source-inline">iris</strong> dataset, a default dataset provided by base R, and a DataFrame that’s checked using the <span class="No-Break"><strong class="source-inline">class()</strong></span><span class="No-Break"> function.</span></p></li>				<li>Convert<a id="_idIndexMarker131"/> the dataset into <strong class="source-inline">tibble</strong> format and verify its <span class="No-Break">data structure:</span><pre class="source-code">&#13;
&gt;&gt;&gt; iris_tbl = as_tibble(iris)&#13;
&gt;&gt;&gt; class(iris_tbl)&#13;
"tbl_df"     "tbl"        "data.frame"</pre><p class="list-inset">There are <a id="_idIndexMarker132"/>three class attributes in <strong class="source-inline">iris_tbl</strong>, which means that the object can be used as both a <strong class="source-inline">tibble</strong> and a DataFrame. Having<a id="_idIndexMarker133"/> multiple class attributes in one object supports better compatibility since we can treat <span class="No-Break">it differently.</span></p><p class="list-inset">A <strong class="source-inline">tibble</strong> object also supports smart printing by listing the top few rows, the shape of the dataset (150 rows and 5 columns), and the data type of each column. On the other hand, a DataFrame would just display all its contents to the console <span class="No-Break">when printed:</span></p><pre class="source-code">&gt;&gt;&gt; iris_tbl&#13;
# A tibble: 150 x 5&#13;
   Sepal.Length Sepal.Width Petal.Length Petal.Width Species&#13;
          &lt;dbl&gt;       &lt;dbl&gt;        &lt;dbl&gt;       &lt;dbl&gt; &lt;fct&gt;&#13;
 1          5.1         3.5          1.4         0.2 setosa&#13;
 2          4.9         3            1.4         0.2 setosa&#13;
 3          4.7         3.2          1.3         0.2 setosa&#13;
 4          4.6         3.1          1.5         0.2 setosa&#13;
 5          5           3.6          1.4         0.2 setosa&#13;
 6          5.4         3.9          1.7         0.4 setosa&#13;
 7          4.6         3.4          1.4         0.3 setosa&#13;
 8          5           3.4          1.5         0.2 setosa&#13;
 9          4.4         2.9          1.4         0.2 setosa&#13;
10          4.9         3.1          1.5         0.1 setosa&#13;
# … with 140 more rows</pre></li>			</ol>&#13;
			<p>Multiple <a id="_idIndexMarker134"/>utility functions for data transformation<a id="_idIndexMarker135"/> are provided by <strong class="source-inline">tidyverse</strong> and <strong class="source-inline">dplyr</strong>. Let’s <a id="_idIndexMarker136"/>look at a few commonly used functions, such as <strong class="source-inline">filter()</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">arrange()</strong></span><span class="No-Break">.</span></p>&#13;
			<h1 id="_idParaDest-37"><a id="_idTextAnchor036"/>Data transformation with dplyr</h1>&#13;
			<p><strong class="bold">Data transformation</strong> refers <a id="_idIndexMarker137"/>to a collection of techniques for performing row-level treatment on the raw data using <strong class="source-inline">dplyr</strong> functions. In this section, we will cover five <a id="_idIndexMarker138"/>fundamental functions for data transformation: <strong class="source-inline">filter()</strong>, <strong class="source-inline">arrange()</strong>, <strong class="source-inline">mutate()</strong>, <strong class="source-inline">select()</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">top_n()</strong></span><span class="No-Break">.</span></p>&#13;
			<h2 id="_idParaDest-38"><a id="_idTextAnchor037"/>Slicing the dataset using the filter() function</h2>&#13;
			<p>One of <a id="_idIndexMarker139"/>the biggest highlights of the <strong class="source-inline">tidyverse</strong> ecosystem is the <strong class="bold">pipe operator</strong>, <strong class="source-inline">%&gt;%</strong>, which provides the statement before it as the contextual input for the statement after it. Using the pipe operator gives us better clarity in terms of code structuring, besides saving the need to type multiple repeated contextual statements. Let’s go through an exercise on how to use the pipe operator to slice the <strong class="source-inline">iris</strong> dataset using the <span class="No-Break"><strong class="source-inline">filter()</strong></span><span class="No-Break"> function.</span></p>&#13;
			<h3>Exercise 2.02 – filtering using the pipe operator</h3>&#13;
			<p>For this exercise, we <a id="_idIndexMarker140"/>have been asked<a id="_idIndexMarker141"/> to keep only the <strong class="source-inline">setosa</strong> species in the <strong class="source-inline">iris</strong> dataset using the pipe operator and the <span class="No-Break"><strong class="source-inline">filter()</strong></span><span class="No-Break"> function:</span></p>&#13;
			<ol>&#13;
				<li>Print all unique species in the <span class="No-Break"><strong class="source-inline">iris</strong></span><span class="No-Break"> dataset:</span><pre class="source-code">&#13;
&gt;&gt;&gt; unique(iris_tbl$Species)&#13;
setosa     versicolor virginica&#13;
Levels: setosa versicolor virginica</pre><p class="list-inset">The result shows that the <strong class="source-inline">Species</strong> column is a factor with <span class="No-Break">three levels.</span></p></li>				<li>Keep only the <strong class="source-inline">"setosa"</strong> species in <strong class="source-inline">iris_tbl</strong> using <strong class="source-inline">filter()</strong> and save the result <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">iris_tbl_subset</strong></span><span class="No-Break">:</span><pre class="source-code">&#13;
iris_tbl_subset = iris_tbl %&gt;%&#13;
  filter(Species == "setosa")&#13;
&gt;&gt;&gt; iris_tbl_subset&#13;
# A tibble: 50 x 5&#13;
   Sepal.Length Sepal.Width Petal.Length Petal.Width Species&#13;
          &lt;dbl&gt;       &lt;dbl&gt;        &lt;dbl&gt;       &lt;dbl&gt; &lt;fct&gt;&#13;
 1          5.1         3.5          1.4         0.2 setosa&#13;
 2          4.9         3            1.4         0.2 setosa&#13;
 3          4.7         3.2          1.3         0.2 setosa&#13;
 4          4.6         3.1          1.5         0.2 setosa&#13;
 5          5           3.6          1.4         0.2 setosa&#13;
 6          5.4         3.9          1.7         0.4 setosa&#13;
 7          4.6         3.4          1.4         0.3 setosa&#13;
 8          5           3.4          1.5         0.2 setosa&#13;
 9          4.4         2.9          1.4         0.2 setosa&#13;
10          4.9         3.1          1.5         0.1 setosa&#13;
# … with 40 more rows</pre><p class="list-inset">The <a id="_idIndexMarker142"/>pipe operator indicates<a id="_idIndexMarker143"/> that the following filtering operation is applied to the <strong class="source-inline">iris_tbl</strong> object. Given this context, we could directly reference the <strong class="source-inline">Species</strong> column (instead of using <strong class="source-inline">iris_tbl$Species</strong>) and use the <strong class="source-inline">==</strong> logical operator to set the equality condition to be evaluated row-wise. The result shows a total of 50 rows stored <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">iris_tbl_subset</strong></span><span class="No-Break">.</span></p></li>				<li>To double-check the filtering result, we could print out the unique species <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">iris_tbl_subset</strong></span><span class="No-Break">:</span><pre class="source-code">&#13;
&gt;&gt;&gt; unique(iris_tbl_subset$Species)&#13;
setosa&#13;
Levels: setosa versicolor virginica</pre></li>				<li>Now, the dataset only contains the <strong class="source-inline">"setosa"</strong> species. However, the <strong class="source-inline">Species</strong> column still encodes the previous information as a factor that has three levels. This is a <a id="_idIndexMarker144"/>unique feature for the factor data type, where information about the total levels is encoded in all individual elements of a factor-typed column. We can remove such information by converting it into a character, <span class="No-Break">as follows:</span><pre class="source-code">&#13;
&gt;&gt;&gt; unique(as.character(iris_tbl_subset$Species))&#13;
"setosa"</pre><p class="list-inset">Note that we are chaining together two functions that are evaluated from the innermost <strong class="source-inline">as.character()</strong> to the <span class="No-Break">outermost </span><span class="No-Break"><strong class="source-inline">unique()</strong></span><span class="No-Break">.</span></p></li>			</ol>&#13;
			<p>The <strong class="source-inline">filter()</strong> function <a id="_idIndexMarker145"/>makes it easy to add multiple filtering conditions by separating them using a comma. For example, we can add another condition to set the maximum value of <strong class="source-inline">Sepal.Length</strong> as <strong class="source-inline">5</strong>, <span class="No-Break">as follows:</span></p>&#13;
			<pre class="source-code">&#13;
iris_tbl_subset = iris_tbl %&gt;%&#13;
  filter(Species == "setosa",&#13;
         Sepal.Length &lt;= 5)&#13;
&gt;&gt;&gt; max(iris_tbl_subset$Sepal.Length)&#13;
5&#13;
&gt;&gt;&gt; dim(iris_tbl_subset)&#13;
28  5</pre>			<p>The result shows that the maximum <strong class="source-inline">Sepal.Length</strong> is now <strong class="source-inline">5</strong> and there are <strong class="source-inline">28</strong> rows left out of the <span class="No-Break">original 150.</span></p>&#13;
			<p>Next, we will look at how to sort a <strong class="source-inline">tibble</strong> object (or a DataFrame) based on a <span class="No-Break">specific column(s).</span></p>&#13;
			<h2 id="_idParaDest-39"><a id="_idTextAnchor038"/>Sorting the dataset using the arrange() function</h2>&#13;
			<p>Another <a id="_idIndexMarker146"/>common data<a id="_idIndexMarker147"/> transformation operation is sorting, which leads to a dataset with one or multiple columns arranged in increasing or decreasing order. This can be achieved via the <strong class="source-inline">arrange()</strong> function, which is provided by <strong class="source-inline">dplyr</strong>. Let’s go through an exercise to look at different ways of sorting <span class="No-Break">a dataset.</span></p>&#13;
			<h3>Exercise 2.03 – sorting using the arrange() function</h3>&#13;
			<p>In this exercise, we will<a id="_idIndexMarker148"/> look at how to sort columns of a dataset in either ascending or descending order, as well as combine the sorting operation with filtering via the <span class="No-Break">pipe operator:</span></p>&#13;
			<ol>&#13;
				<li>Sort the <strong class="source-inline">Sepal.Length</strong> column of the <strong class="source-inline">iris</strong> dataset in ascending order <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">arrange()</strong></span><span class="No-Break">:</span><pre class="source-code">&#13;
iris_tbl_sorted = iris_tbl %&gt;%&#13;
  arrange(Sepal.Length)&#13;
&gt;&gt;&gt; iris_tbl_sorted&#13;
# A tibble: 150 x 5&#13;
   Sepal.Length Sepal.Width Petal.Length Petal.Width Species&#13;
          &lt;dbl&gt;       &lt;dbl&gt;        &lt;dbl&gt;       &lt;dbl&gt; &lt;fct&gt;&#13;
 1          4.3         3            1.1         0.1 setosa&#13;
 2          4.4         2.9          1.4         0.2 setosa&#13;
 3          4.4         3            1.3         0.2 setosa&#13;
 4          4.4         3.2          1.3         0.2 setosa&#13;
 5          4.5         2.3          1.3         0.3 setosa&#13;
 6          4.6         3.1          1.5         0.2 setosa&#13;
 7          4.6         3.4          1.4         0.3 setosa&#13;
 8          4.6         3.6          1           0.2 setosa&#13;
 9          4.6         3.2          1.4         0.2 setosa&#13;
10          4.7         3.2          1.3         0.2 setosa&#13;
# … with 140 more rows</pre><p class="list-inset">The result<a id="_idIndexMarker149"/> shows that the <strong class="source-inline">arrange()</strong> function sorts the specific column in ascending order by default. Now, let’s look at how to sort in <span class="No-Break">descending order.</span></p></li>				<li>Sort the<a id="_idIndexMarker150"/> same column in <span class="No-Break">descending order:</span><pre class="source-code">&#13;
iris_tbl_sorted = iris_tbl %&gt;%&#13;
  arrange(desc(Sepal.Length))&#13;
&gt;&gt;&gt; iris_tbl_sorted&#13;
# A tibble: 150 x 5&#13;
   Sepal.Length Sepal.Width Petal.Length Petal.Width Species&#13;
          &lt;dbl&gt;       &lt;dbl&gt;        &lt;dbl&gt;       &lt;dbl&gt; &lt;fct&gt;&#13;
 1          7.9         3.8          6.4         2   virginica&#13;
 2          7.7         3.8          6.7         2.2 virginica&#13;
 3          7.7         2.6          6.9         2.3 virginica&#13;
 4          7.7         2.8          6.7         2   virginica&#13;
 5          7.7         3            6.1         2.3 virginica&#13;
 6          7.6         3            6.6         2.1 virginica&#13;
 7          7.4         2.8          6.1         1.9 virginica&#13;
 8          7.3         2.9          6.3         1.8 virginica&#13;
 9          7.2         3.6          6.1         2.5 virginica&#13;
10          7.2         3.2          6           1.8 virginica&#13;
# … with 140 more rows</pre><p class="list-inset">Adding <a id="_idIndexMarker151"/>the <strong class="source-inline">desc()</strong> function to the column before passing in <strong class="source-inline">arrange()</strong>can flip the ordering and achieve sorting in descending order. We can also pass in<a id="_idIndexMarker152"/> multiple columns to sort <span class="No-Break">them sequentially.</span></p><p class="list-inset">Besides this, the <strong class="source-inline">arrange()</strong> function can also be used together with other data processing steps, such <span class="No-Break">as filtering.</span></p></li>				<li>Sort both <strong class="source-inline">Sepal.Length</strong> and <strong class="source-inline">Sepal.Width</strong> in descending order after keeping <strong class="source-inline">Species</strong> set to <strong class="source-inline">"setosa"</strong> only and <strong class="source-inline">Sepal.Length</strong> up to a maximum value <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">5</strong></span><span class="No-Break">:</span><pre class="source-code">&#13;
iris_tbl_subset_sorted = iris_tbl %&gt;%&#13;
  filter(Species == "setosa",&#13;
         Sepal.Length &lt;= 5) %&gt;%&#13;
  arrange(desc(Sepal.Length),desc(Sepal.Width))&#13;
&gt;&gt;&gt; iris_tbl_subset_sorted&#13;
# A tibble: 28 x 5&#13;
   Sepal.Length Sepal.Width Petal.Length Petal.Width Species&#13;
          &lt;dbl&gt;       &lt;dbl&gt;        &lt;dbl&gt;       &lt;dbl&gt; &lt;fct&gt;&#13;
 1          5           3.6          1.4         0.2 setosa&#13;
 2          5           3.5          1.3         0.3 setosa&#13;
 3          5           3.5          1.6         0.6 setosa&#13;
 4          5           3.4          1.5         0.2 setosa&#13;
 5          5           3.4          1.6         0.4 setosa&#13;
 6          5           3.3          1.4         0.2 setosa&#13;
 7          5           3.2          1.2         0.2 setosa&#13;
 8          5           3            1.6         0.2 setosa&#13;
 9          4.9         3.6          1.4         0.1 setosa&#13;
10          4.9         3.1          1.5         0.1 setosa&#13;
# … with 18 more rows</pre><p class="list-inset">The<a id="_idIndexMarker153"/> result <a id="_idIndexMarker154"/>shows a two-layer sorting, where for the same value of <strong class="source-inline">Sepal.Length</strong>, <strong class="source-inline">Sepal.Width</strong> is further sorted in descending order. These two sorting criteria are separated by a comma, just like separating multiple conditions <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">filter()</strong></span><span class="No-Break">.</span></p><p class="list-inset">In addition, the pipe operator connects and evaluates multiple functions sequentially. In this case, we start by setting the context for working with <strong class="source-inline">iris_tbl</strong>, followed by filtering and then sorting, both of which are connected via the <span class="No-Break">pipe operator.</span></p></li>			</ol>&#13;
			<h2 id="_idParaDest-40"><a id="_idTextAnchor039"/>Adding or changing a column using the mutate() function</h2>&#13;
			<p>A <strong class="source-inline">tibble</strong> object or DataFrame<a id="_idIndexMarker155"/> essentially consists of multiple columns stored together as a list of lists. We may <a id="_idIndexMarker156"/>want<a id="_idIndexMarker157"/> to edit an existing column by changing its contents, type, or format; such editing could also make us end up with a new column appended to the original dataset. Column-level editing can be achieved via the <strong class="source-inline">mutate()</strong> function. Let’s go through an example of how to use this function in conjunction with <span class="No-Break">other functions.</span></p>&#13;
			<h3>Exercise 2.04 – changing and adding columns using the mutate() function</h3>&#13;
			<p>In this exercise, we will look at how to change the type of an existing column and add a new column to support the <span class="No-Break">filtering operation:</span></p>&#13;
			<ol>&#13;
				<li>Change the <strong class="source-inline">Species</strong> column to the <span class="No-Break"><strong class="source-inline">character</strong></span><span class="No-Break"> type:</span><pre class="source-code">&#13;
&gt;&gt;&gt; paste("Before:", class(iris_tbl$Species))&#13;
iris_tbl = iris_tbl %&gt;%&#13;
  mutate(Species = as.character(Species))&#13;
&gt;&gt;&gt; paste("After:", class(iris_tbl$Species))&#13;
"Before: factor"&#13;
"After: character"</pre><p class="list-inset">Here, we used the <strong class="source-inline">mutate()</strong> function to change the type of <strong class="source-inline">Species</strong>, which is referenced <a id="_idIndexMarker158"/>directly within the context of the <strong class="source-inline">iris_tbl</strong> object via the <span class="No-Break">pipe operator.</span></p></li>				<li>Create a <a id="_idIndexMarker159"/>column <a id="_idIndexMarker160"/>called <strong class="source-inline">ind</strong> to indicate whether <strong class="source-inline">Sepal.Width</strong> is bigger <span class="No-Break">than </span><span class="No-Break"><strong class="source-inline">Petal.Length</strong></span><span class="No-Break">:</span><pre class="source-code">&#13;
iris_tbl = iris_tbl %&gt;%&#13;
  mutate(ind = Sepal.Width &gt; Petal.Length)&#13;
&gt;&gt;&gt; iris_tbl&#13;
# A tibble: 150 x 6&#13;
   Sepal.Length Sepal.Width Petal.Length Petal.Width Species ind&#13;
          &lt;dbl&gt;       &lt;dbl&gt;        &lt;dbl&gt;       &lt;dbl&gt; &lt;chr&gt;   &lt;lgl&gt;&#13;
 1          5.1         3.5          1.4         0.2 setosa  TRUE&#13;
 2          4.9         3            1.4         0.2 setosa  TRUE&#13;
 3          4.7         3.2          1.3         0.2 setosa  TRUE&#13;
 4          4.6         3.1          1.5         0.2 setosa  TRUE&#13;
 5          5           3.6          1.4         0.2 setosa  TRUE&#13;
 6          5.4         3.9          1.7         0.4 setosa  TRUE&#13;
 7          4.6         3.4          1.4         0.3 setosa  TRUE&#13;
 8          5           3.4          1.5         0.2 setosa  TRUE&#13;
 9          4.4         2.9          1.4         0.2 setosa  TRUE&#13;
10          4.9         3.1          1.5         0.1 setosa  TRUE&#13;
# … with 140 more rows</pre><p class="list-inset">The <a id="_idIndexMarker161"/>result shows that we have added an indicator column with logical values. We<a id="_idIndexMarker162"/> can get the counts of <strong class="source-inline">TRUE</strong> and <strong class="source-inline">FALSE</strong> values via the <span class="No-Break"><strong class="source-inline">table()</strong></span><span class="No-Break"> function:</span></p><pre class="source-code">&gt;&gt;&gt; table(iris_tbl$ind)&#13;
FALSE  TRUE&#13;
100    50</pre></li>				<li>Keep<a id="_idIndexMarker163"/> only rows whose <strong class="source-inline">Sepal.Width</strong> is bigger <span class="No-Break">than </span><span class="No-Break"><strong class="source-inline">Petal.Length</strong></span><span class="No-Break">:</span><pre class="source-code">&#13;
iris_tbl_subset = iris_tbl %&gt;%&#13;
  filter(ind==TRUE)&#13;
&gt;&gt;&gt; table(iris_tbl_subset$ind)&#13;
TRUE&#13;
50</pre><p class="list-inset">Since we are essentially performing a filtering operation, this two-step process of first creating an indicator column and then filtering could be combined into a single step by directly setting the filtering condition within the <span class="No-Break"><strong class="source-inline">filter()</strong></span><span class="No-Break"> function:</span></p><pre class="source-code">iris_tbl_subset2 = iris_tbl %&gt;%&#13;
  filter(Sepal.Width &gt; Petal.Length)&#13;
&gt;&gt;&gt; nrow(iris_tbl_subset2)&#13;
50</pre><p class="list-inset">The<a id="_idIndexMarker164"/> result<a id="_idIndexMarker165"/> is <a id="_idIndexMarker166"/>the same as the <span class="No-Break">two-step approach.</span></p></li>			</ol>&#13;
			<p>Now, let’s cover the last commonly used utility function – <span class="No-Break"><strong class="source-inline">select()</strong></span><span class="No-Break">.</span></p>&#13;
			<h2 id="_idParaDest-41"><a id="_idTextAnchor040"/>Selecting columns using the select() function</h2>&#13;
			<p>The <strong class="source-inline">select()</strong> function<a id="_idIndexMarker167"/> works by selecting the columns specified by the input argument, a vector of strings<a id="_idIndexMarker168"/> representing one or multiple columns. When using <strong class="source-inline">select()</strong> in the context of the pipe operator, it means that all the following statements are evaluated based on the selected columns. When the <strong class="source-inline">select</strong> statement comes last, it returns the selected columns as the output <span class="No-Break"><strong class="source-inline">tibble</strong></span><span class="No-Break"> object.</span></p>&#13;
			<p>Let’s go through an exercise on different ways of selecting columns from <span class="No-Break">a dataset.</span></p>&#13;
			<h3>Exercise 2.05 – selecting columns using select()</h3>&#13;
			<p>In this exercise, we will look at different ways of selecting columns from a <span class="No-Break"><strong class="source-inline">tibble</strong></span><span class="No-Break"> dataset:</span></p>&#13;
			<ol>&#13;
				<li>Select the first three columns from the <span class="No-Break"><strong class="source-inline">iris</strong></span><span class="No-Break"> dataset:</span><pre class="source-code">&#13;
rst = iris_tbl %&gt;%&#13;
  select(Sepal.Length, Sepal.Width, Petal.Length)&#13;
&gt;&gt;&gt; rst&#13;
# A tibble: 150 x 3&#13;
   Sepal.Length Sepal.Width Petal.Length&#13;
          &lt;dbl&gt;       &lt;dbl&gt;        &lt;dbl&gt;&#13;
 1          5.1         3.5          1.4&#13;
 2          4.9         3            1.4&#13;
 3          4.7         3.2          1.3&#13;
 4          4.6         3.1          1.5&#13;
 5          5           3.6          1.4&#13;
 6          5.4         3.9          1.7&#13;
 7          4.6         3.4          1.4&#13;
 8          5           3.4          1.5&#13;
 9          4.4         2.9          1.4&#13;
10          4.9         3.1          1.5&#13;
# … with 140 more rows</pre><p class="list-inset">When<a id="_idIndexMarker169"/> you <a id="_idIndexMarker170"/>need to increase the number of columns to be selected, typing them one by one would become tedious. Another way to do this is to pass the first and last columns separated by a colon (<strong class="source-inline">:</strong>), <span class="No-Break">as follows:</span></p><pre class="source-code">rst = iris_tbl %&gt;%&#13;
  select(Sepal.Length:Petal.Length)&#13;
&gt;&gt;&gt; rst&#13;
# A tibble: 150 x 3&#13;
   Sepal.Length Sepal.Width Petal.Length&#13;
          &lt;dbl&gt;       &lt;dbl&gt;        &lt;dbl&gt;&#13;
 1          5.1         3.5          1.4&#13;
 2          4.9         3            1.4&#13;
 3          4.7         3.2          1.3&#13;
 4          4.6         3.1          1.5&#13;
 5          5           3.6          1.4&#13;
 6          5.4         3.9          1.7&#13;
 7          4.6         3.4          1.4&#13;
 8          5           3.4          1.5&#13;
 9          4.4         2.9          1.4&#13;
10          4.9         3.1          1.5&#13;
# … with 140 more rows</pre><p class="list-inset">This approach selects all columns contained between <strong class="source-inline">Sepal.Length</strong> and <strong class="source-inline">Petal.Length</strong>. Using <a id="_idIndexMarker171"/>a colon helps us select multiple consecutive columns in one shot. Besides, we can also combine it with other individual columns via the <span class="No-Break"><strong class="source-inline">c()</strong></span><span class="No-Break"> function.</span></p></li>				<li>Select <a id="_idIndexMarker172"/>columns that <span class="No-Break">contain </span><span class="No-Break"><strong class="source-inline">"length"</strong></span><span class="No-Break">:</span><pre class="source-code">&#13;
rst = iris_tbl %&gt;%&#13;
  select(contains("length"))&#13;
&gt;&gt;&gt; rst&#13;
# A tibble: 150 x 2&#13;
   Sepal.Length Petal.Length&#13;
          &lt;dbl&gt;        &lt;dbl&gt;&#13;
 1          5.1          1.4&#13;
 2          4.9          1.4&#13;
 3          4.7          1.3&#13;
 4          4.6          1.5&#13;
 5          5            1.4&#13;
 6          5.4          1.7&#13;
 7          4.6          1.4&#13;
 8          5            1.5&#13;
 9          4.4          1.4&#13;
10          4.9          1.5&#13;
# … with 140 more rows</pre><p class="list-inset">Here, we used the <strong class="source-inline">contains()</strong> function to perform a case-insensitive string match. Other utility functions that support string matching include <strong class="source-inline">starts_with()</strong> and <strong class="source-inline">ends_with()</strong>. Let’s look at <span class="No-Break">an example.</span></p></li>				<li>Select <a id="_idIndexMarker173"/>columns<a id="_idIndexMarker174"/> that start <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">"petal"</strong></span><span class="No-Break">:</span><pre class="source-code">&#13;
rst = iris_tbl %&gt;%&#13;
  select(starts_with("petal"))&#13;
&gt;&gt;&gt; rst&#13;
# A tibble: 150 x 2&#13;
   Petal.Length Petal.Width&#13;
          &lt;dbl&gt;       &lt;dbl&gt;&#13;
 1          1.4         0.2&#13;
 2          1.4         0.2&#13;
 3          1.3         0.2&#13;
 4          1.5         0.2&#13;
 5          1.4         0.2&#13;
 6          1.7         0.4&#13;
 7          1.4         0.3&#13;
 8          1.5         0.2&#13;
 9          1.4         0.2&#13;
10          1.5         0.1&#13;
# … with 140 more rows</pre></li>			</ol>&#13;
			<p>Next, we will look at selecting the top rows using the <strong class="source-inline">top_n()</strong> function, which comes in handy when we want to examine a few rows after sorting the DataFrame based on a <span class="No-Break">specific column.</span></p>&#13;
			<h2 id="_idParaDest-42"><a id="_idTextAnchor041"/>Selecting the top rows using the top_n() function</h2>&#13;
			<p>The <strong class="source-inline">top_n()</strong> function <a id="_idIndexMarker175"/>can be<a id="_idIndexMarker176"/> helpful when we are interested in the top few observations for a particular column. It<a id="_idIndexMarker177"/> expects two input arguments: the number of top observations (implicitly sorted in descending order) returned and the specific column sorted. The mechanism would be the same if we were to sort a column in descending order using <strong class="source-inline">arrange()</strong> and return the top few rows using <strong class="source-inline">head()</strong>. Let’s try <span class="No-Break">it out.</span></p>&#13;
			<h3>Exercise 2.06 – selecting the top rows using top_n()</h3>&#13;
			<p>In this exercise, we will demonstrate how to use <strong class="source-inline">top_n()</strong> in combination with <span class="No-Break">other verbs:</span></p>&#13;
			<ol>&#13;
				<li>Return the observation with the <span class="No-Break">biggest </span><span class="No-Break"><strong class="source-inline">Sepal.Length</strong></span><span class="No-Break">:</span><pre class="source-code">&#13;
rst = iris_tbl %&gt;%&#13;
  top_n(1, Sepal.Length)&#13;
&gt;&gt;&gt; rst&#13;
# A tibble: 1 x 6&#13;
  Sepal.Length Sepal.Width Petal.Length Petal.Width Species   ind&#13;
         &lt;dbl&gt;       &lt;dbl&gt;        &lt;dbl&gt;       &lt;dbl&gt; &lt;chr&gt;     &lt;lgl&gt;&#13;
1          7.9         3.8          6.4           2 virginica FALSE</pre><p class="list-inset">We can see that the result is a full row whose <strong class="source-inline">Sepal.Length</strong> is the biggest. This can also be achieved by explicitly sorting the dataset using this column and returning the first row, illustrated <span class="No-Break">as follows:</span></p><pre class="source-code">rst = iris_tbl %&gt;%&#13;
  arrange(desc(Sepal.Length)) %&gt;%&#13;
  head(1)&#13;
&gt;&gt;&gt; rst&#13;
# A tibble: 1 x 6&#13;
  Sepal.Length Sepal.Width Petal.Length Petal.Width Species   ind&#13;
         &lt;dbl&gt;       &lt;dbl&gt;        &lt;dbl&gt;       &lt;dbl&gt; &lt;chr&gt;     &lt;lgl&gt;&#13;
1          7.9         3.8          6.4           2 virginica FALSE</pre><p class="list-inset">We <a id="_idIndexMarker178"/>can also apply <strong class="source-inline">top_n()</strong> in a <strong class="source-inline">group_by()</strong> context, which aggregates the<a id="_idIndexMarker179"/> data into different groups. We will cover more details on data aggregation in the <span class="No-Break">next section.</span></p></li>				<li>Return the biggest <strong class="source-inline">Sepal.Length</strong> for each category <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">Species</strong></span><span class="No-Break">:</span><pre class="source-code">&#13;
rst = iris_tbl %&gt;%&#13;
  group_by(Species) %&gt;%&#13;
  top_n(1, Sepal.Length) %&gt;%&#13;
  select(Species, Sepal.Length)&#13;
&gt;&gt;&gt; rst&#13;
# A tibble: 3 x 2&#13;
# Groups:   Species [3]&#13;
  Species    Sepal.Length&#13;
  &lt;chr&gt;             &lt;dbl&gt;&#13;
1 setosa              5.8&#13;
2 versicolor          7&#13;
3 virginica           7.9</pre><p class="list-inset">We can also use the <strong class="source-inline">max()</strong> function to achieve the <span class="No-Break">same purpose:</span></p><pre class="source-code">rst = iris_tbl %&gt;%&#13;
  group_by(Species) %&gt;%&#13;
  summarize(max_sepal_length = max(Sepal.Length))&#13;
&gt;&gt;&gt; rst&#13;
# A tibble: 3 x 2&#13;
  Species    max_sepal_length&#13;
  &lt;chr&gt;                 &lt;dbl&gt;&#13;
1 setosa                  5.8&#13;
2 versicolor              7&#13;
3 virginica               7.9</pre><p class="list-inset">The <strong class="source-inline">summarize()</strong> function <a id="_idIndexMarker180"/>compresses <a id="_idIndexMarker181"/>the dataset into one row (with the maximum <strong class="source-inline">Sepal.Length</strong>) for each group of <strong class="source-inline">Species</strong>. More on <span class="No-Break">this later.</span></p></li>				<li>Return the biggest <strong class="source-inline">Sepal.Length</strong> and <span class="No-Break">its category:</span><pre class="source-code">&#13;
rst = iris_tbl %&gt;%&#13;
  group_by(Species) %&gt;%&#13;
  summarize(max_sepal_length = max(Sepal.Length)) %&gt;%&#13;
  top_n(1, max_sepal_length)&#13;
&gt;&gt;&gt; rst&#13;
# A tibble: 1 x 2&#13;
  Species   max_sepal_length&#13;
  &lt;chr&gt;                &lt;dbl&gt;&#13;
1 virginica              7.9</pre><p class="list-inset">This <a id="_idIndexMarker182"/>example<a id="_idIndexMarker183"/> shows that we can use <strong class="source-inline">top_n()</strong> in multiple contexts together with <span class="No-Break">other verbs.</span></p></li>			</ol>&#13;
			<p>Now, let’s combine the five verbs we’ve <span class="No-Break">covered here.</span></p>&#13;
			<h2 id="_idParaDest-43"><a id="_idTextAnchor042"/>Combining the five verbs</h2>&#13;
			<p>The five utility functions we have covered so far can be combined, thus offering a flexible and concise way of processing data. Let’s go through an exercise that involves all <span class="No-Break">five functions.</span></p>&#13;
			<h3>Exercise 2.07 – combining the five utility functions</h3>&#13;
			<p>The <a id="_idIndexMarker184"/>example we’ll cover in this<a id="_idIndexMarker185"/> exercise is a somewhat contrived one so that all five verb functions can be used. In this exercise, we have been asked to find the average absolute difference between <strong class="source-inline">Sepal.Length</strong> and <strong class="source-inline">Petal.Length</strong> for the top 100 rows with the highest <strong class="source-inline">Sepal.Length</strong> and whose <strong class="source-inline">Sepal.Width</strong> is bigger <span class="No-Break">than </span><span class="No-Break"><strong class="source-inline">Petal.Length</strong></span><span class="No-Break">.</span></p>&#13;
			<p>When performing a complex query like this one, it is helpful to work through the requirements backward, starting from the conditions for subsetting the dataset and then working on the metric. In this case, we will start by sorting <strong class="source-inline">Sepal.Length</strong> in a descending order using the <strong class="source-inline">arrange()</strong> function and keep the top 100 rows using the <strong class="source-inline">head()</strong> function. Another filtering condition that uses the <strong class="source-inline">filter()</strong> function then comes in to retain the rows whose <strong class="source-inline">Sepal.Width</strong> is bigger than <strong class="source-inline">Petal.Length</strong>. Next, we must create a new column using the <strong class="source-inline">mutate()</strong> function to represent the absolute difference between <strong class="source-inline">Sepal.Length</strong> and <strong class="source-inline">Petal.Length</strong>. Finally, we must apply the <strong class="source-inline">select()</strong> function to focus on the new column and calculate its average. See the following code block for a <span class="No-Break">detailed implementation:</span></p>&#13;
			<pre class="source-code">&#13;
rst = iris_tbl %&gt;%&#13;
  top(80, Sepal.Length) %&gt;%&#13;
  filter(Sepal.Width &gt; Petal.Length) %&gt;%&#13;
  mutate(Diff = abs(Sepal.Length - Petal.Length)) %&gt;%&#13;
  select(Diff) %&gt;%&#13;
  colMeans()&#13;
&gt;&gt;&gt; rst&#13;
Diff&#13;
 4.266667</pre>			<p>Next, we will look <a id="_idIndexMarker186"/>at additional two verbs: <strong class="source-inline">rename()</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">transmute()</strong></span><span class="No-Break">.</span></p>&#13;
			<h2 id="_idParaDest-44"><a id="_idTextAnchor043"/>Introducing other verbs</h2>&#13;
			<p>Two other verbs are also commonly used: <strong class="source-inline">rename()</strong> and <strong class="source-inline">transmute()</strong>. The <strong class="source-inline">rename()</strong> function<a id="_idIndexMarker187"/> changes the name<a id="_idIndexMarker188"/> of a specific column. For example, when using the <strong class="source-inline">count()</strong> function, a column named <strong class="source-inline">n</strong> is automatically created. We can use <strong class="source-inline">rename(Count = n)</strong> within the pipe context to change its default name from <strong class="source-inline">n</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">Count</strong></span><span class="No-Break">.</span></p>&#13;
			<p>There is another way to change the column’s name. When selecting a column of a dataset, we can pass the same statement that we did to <strong class="source-inline">rename()</strong> to the <strong class="source-inline">select()</strong> function. For example, the following code shows selecting the <strong class="source-inline">Sepal.Length</strong> and <strong class="source-inline">Sepal.Width</strong> columns from the <strong class="source-inline">iris</strong> dataset while renaming the second <span class="No-Break">column </span><span class="No-Break"><strong class="source-inline">Sepal_Width</strong></span><span class="No-Break">:</span></p>&#13;
			<pre class="source-code">&#13;
rst = iris_tbl %&gt;%&#13;
  select(Sepal.Length, Sepal_Width=Sepal.Width)&#13;
&gt;&gt;&gt; rst&#13;
# A tibble: 150 x 2&#13;
   Sepal.Length Sepal_Width&#13;
          &lt;dbl&gt;       &lt;dbl&gt;&#13;
 1          5.1         3.5&#13;
 2          4.9         3&#13;
 3          4.7         3.2&#13;
 4          4.6         3.1&#13;
 5          5           3.6&#13;
 6          5.4         3.9&#13;
 7          4.6         3.4&#13;
 8          5           3.4&#13;
 9          4.4         2.9&#13;
10          4.9         3.1&#13;
# … with 140 more rows</pre>			<p>On the other hand, the <strong class="source-inline">transmute()</strong> function is a combination of <strong class="source-inline">select()</strong> and <strong class="source-inline">mutate()</strong>. It will return<a id="_idIndexMarker189"/> a subset of <a id="_idIndexMarker190"/>columns where some could be transformed. For example, suppose we would like to calculate the absolute between <strong class="source-inline">Sepal.Length</strong> and <strong class="source-inline">Petal.Length</strong> and return the result together with <strong class="source-inline">Species</strong>. We can achieve both tasks using <strong class="source-inline">transmute()</strong>, <span class="No-Break">as follows:</span></p>&#13;
			<pre class="source-code">&#13;
rst = iris_tbl %&gt;%&#13;
  transmute(Species, Diff = abs(Sepal.Length - Petal.Length))&#13;
&gt;&gt;&gt; rst&#13;
# A tibble: 150 x 2&#13;
   Species  Diff&#13;
   &lt;chr&gt;   &lt;dbl&gt;&#13;
 1 setosa    3.7&#13;
 2 setosa    3.5&#13;
 3 setosa    3.4&#13;
 4 setosa    3.1&#13;
 5 setosa    3.6&#13;
 6 setosa    3.7&#13;
 7 setosa    3.2&#13;
 8 setosa    3.5&#13;
 9 setosa    3&#13;
10 setosa    3.4&#13;
# … with 140 more rows</pre>			<p>Although these<a id="_idIndexMarker191"/> verbs could be used interchangeably, there are a few technical differences. As shown in <span class="No-Break"><em class="italic">Figure 2</em></span><em class="italic">.1</em>, the <strong class="source-inline">select()</strong> function<a id="_idIndexMarker192"/> returns the specified columns without changing the value of these columns, which can be achieved via either <strong class="source-inline">mutate()</strong> or <strong class="source-inline">transmutate()</strong>. Both <strong class="source-inline">mutate()</strong> and <strong class="source-inline">rename()</strong> keep the original columns in the returned result when creating additional new columns, while <strong class="source-inline">select()</strong> and <strong class="source-inline">transmute()</strong> only return specified columns in <span class="No-Break">the result:</span></p>&#13;
			<p class="IMG---Figure"> </p>&#13;
			<div>&#13;
				<div id="_idContainer018" class="IMG---Figure">&#13;
					<img src="Images/B18680_02_001.jpg" alt="Figure 2.1 – Summarizing the four verbs in terms of their purposes and connections" width="1081" height="597"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.1 – Summarizing the four verbs in terms of their purposes and connections</p>&#13;
			<p>Now that we know<a id="_idIndexMarker193"/> how<a id="_idIndexMarker194"/> to transform the data, we can go a step further to make it more interpretable and presentable via aggregation and summarization. We will cover different ways to aggregate the data in the <span class="No-Break">next section.</span></p>&#13;
			<h1 id="_idParaDest-45"><a id="_idTextAnchor044"/>Data aggregation with dplyr</h1>&#13;
			<p><strong class="bold">Data aggregation</strong> refers<a id="_idIndexMarker195"/> to a set of techniques that summarizes the dataset at an aggregate level and characterizes the original dataset at a higher level. Compared to <a id="_idIndexMarker196"/>data transformation, it operates at the row level for the input and <span class="No-Break">the output.</span></p>&#13;
			<p>We have already encountered a few aggregation functions, such as calculating the mean of a column. This section will cover some of the most widely used aggregation functions provided by <strong class="source-inline">dplyr</strong>. We will start with the <strong class="source-inline">count()</strong> function, which returns the number of observations/rows for each category of the specified <span class="No-Break">input column.</span></p>&#13;
			<h2 id="_idParaDest-46"><a id="_idTextAnchor045"/>Counting observations using the count() function</h2>&#13;
			<p>The <strong class="source-inline">count()</strong> function <a id="_idIndexMarker197"/>automatically groups the dataset into different categories according to the input argument and returns the number of observations for each category. The input argument could include one or more columns of the dataset. Let’s go through an exercise and apply it to the <span class="No-Break"><strong class="source-inline">iris</strong></span><span class="No-Break"> dataset.</span></p>&#13;
			<h3>Exercise 2.08 – counting observations by species</h3>&#13;
			<p>This exercise <a id="_idIndexMarker198"/>will <a id="_idIndexMarker199"/>use the <strong class="source-inline">count()</strong> function to get the number of observations for each unique species, followed by adding filtering conditions using the <span class="No-Break"><strong class="source-inline">filter()</strong></span><span class="No-Break"> function:</span></p>&#13;
			<ol>&#13;
				<li>Count the number of observations for each unique type of species in the <span class="No-Break"><strong class="source-inline">iris</strong></span><span class="No-Break"> dataset:</span><pre class="source-code">&#13;
rst = iris_tbl %&gt;%&#13;
  count(Species)&#13;
&gt;&gt;&gt; rst&#13;
# A tibble: 3 x 2&#13;
  Species        n&#13;
  &lt;chr&gt;      &lt;int&gt;&#13;
1 setosa        50&#13;
2 versicolor    50&#13;
3 virginica     50</pre><p class="list-inset">The output is a <strong class="source-inline">tibble</strong> dataset with two columns, where the first column contains the unique category in <strong class="source-inline">Species</strong> and the second column (named <strong class="source-inline">n</strong> by default) is the corresponding count <span class="No-Break">of rows.</span></p><p class="list-inset">Let’s look at how to perform filtering before the <span class="No-Break">counting operation.</span></p></li>				<li>Perform<a id="_idIndexMarker200"/> the exact counting for those observations whose absolute difference between <strong class="source-inline">Sepal.Length</strong> and <strong class="source-inline">Sepal.Width</strong> is greater than that of <strong class="source-inline">Petal.Length</strong> and <strong class="source-inline">Petal.Width</strong>. Return the result in <span class="No-Break">descending order:</span><pre class="source-code">&#13;
rst = iris_tbl %&gt;%&#13;
  filter(abs(Sepal.Length-Sepal.Width) &gt; abs(Petal.Length-Petal.Width)) %&gt;%&#13;
  count(Species, sort=TRUE)&#13;
&gt;&gt;&gt; rst&#13;
# A tibble: 3 x 2&#13;
  Species        n&#13;
  &lt;chr&gt;      &lt;int&gt;&#13;
1 setosa        45&#13;
2 versicolor    33&#13;
3 virginica     28</pre><p class="list-inset">Here, we <a id="_idIndexMarker201"/>added a filtering condition to keep rows that meet the specified criterion before counting. We enabled the <strong class="source-inline">sort</strong> argument to arrange the results in <span class="No-Break">descending order.</span></p></li>			</ol>&#13;
			<p>The <strong class="source-inline">count()</strong> function essentially combines two steps: grouping by each category of a specified column and then counting the number of observations. It turns out that we can achieve the same task using the <strong class="source-inline">group_by()</strong> and <strong class="source-inline">summarize()</strong> functions, as introduced in the <span class="No-Break">next section.</span></p>&#13;
			<h2 id="_idParaDest-47"><a id="_idTextAnchor046"/>Aggregating data via group_by() and summarize()</h2>&#13;
			<p><strong class="source-inline">count()</strong> is a<a id="_idIndexMarker202"/> helpful way to <a id="_idIndexMarker203"/>aggregate data. However, it is a particular case of two more general aggregation functions, <strong class="source-inline">group_by()</strong> and <strong class="source-inline">summarize()</strong>, which are often used together. The <strong class="source-inline">group_by()</strong> function splits the original dataset into different groups according to one or more columns in the input argument, while the <strong class="source-inline">summarize()</strong> function summarizes and collapses all observations within a specific category into one metric, which could be the count of rows in the case <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">count()</strong></span><span class="No-Break">.</span></p>&#13;
			<p>Multiple summarization<a id="_idIndexMarker204"/> functions <a id="_idIndexMarker205"/>can be used in the <strong class="source-inline">summarize()</strong> function. Typical ones include <span class="No-Break">the following:</span></p>&#13;
			<ul>&#13;
				<li><strong class="source-inline">sum()</strong>: Sums all observations of a <span class="No-Break">particular group</span></li>&#13;
				<li><strong class="source-inline">mean()</strong>: Calculates the average of <span class="No-Break">all observations</span></li>&#13;
				<li><strong class="source-inline">median()</strong>: Calculates the median of <span class="No-Break">all observations</span></li>&#13;
				<li><strong class="source-inline">max()</strong>: Calculates the maximum of <span class="No-Break">all observations</span></li>&#13;
				<li><strong class="source-inline">min()</strong>: Calculates the minimum of <span class="No-Break">all observations</span></li>&#13;
			</ul>&#13;
			<p>Let’s go through an exercise on calculating different summary statistics using <strong class="source-inline">group_by()</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">summarize()</strong></span><span class="No-Break">.</span></p>&#13;
			<h3>Exercise 2.09 – summarizing a dataset using group_by() and summarize()</h3>&#13;
			<p>This<a id="_idIndexMarker206"/> exercise <a id="_idIndexMarker207"/>covers using the <strong class="source-inline">group_by()</strong> and <strong class="source-inline">summarize()</strong> functions to extract the count and mean statistics, combined with some of the verbs introduced earlier, including <strong class="source-inline">filter()</strong>, <strong class="source-inline">mutate()</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">arrange()</strong></span><span class="No-Break">:</span></p>&#13;
			<ol>&#13;
				<li>Get the count of observations for each unique type <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">Species</strong></span><span class="No-Break">:</span><pre class="source-code">&#13;
rst = iris_tbl %&gt;%&#13;
  group_by(Species) %&gt;%&#13;
  summarise(n=n())&#13;
&gt;&gt;&gt; rst&#13;
# A tibble: 3 x 2&#13;
  Species        n&#13;
  &lt;chr&gt;      &lt;int&gt;&#13;
1 setosa        50&#13;
2 versicolor    50&#13;
3 virginica     50</pre><p class="list-inset">In the preceding code, we used the <strong class="source-inline">n()</strong> function to get the number of observations <a id="_idIndexMarker208"/>and assigned the result to a column named <strong class="source-inline">n</strong>. The counting comes after grouping the observations based on the unique type <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">Species</strong></span><span class="No-Break">.</span></p></li>				<li>Add <a id="_idIndexMarker209"/>the same filter as in the previous exercise and sort the result in <span class="No-Break">descending order:</span><pre class="source-code">&#13;
rst = iris_tbl %&gt;%&#13;
  filter(abs(Sepal.Length-Sepal.Width) &gt; abs(Petal.Length-Petal.Width)) %&gt;%&#13;
  group_by(Species) %&gt;%&#13;
  summarise(n=n()) %&gt;%&#13;
  arrange(desc(n))&#13;
&gt;&gt;&gt; rst&#13;
# A tibble: 3 x 2&#13;
  Species        n&#13;
  &lt;chr&gt;      &lt;int&gt;&#13;
1 setosa        45&#13;
2 versicolor    33&#13;
3 virginica     28</pre><p class="list-inset">In this code block, the filtering condition is applied first to limit the grouping operations to a subset of observations. In the <strong class="source-inline">arrange()</strong> function, we directly used the <strong class="source-inline">n</strong> column to sort in <span class="No-Break">descending order.</span></p></li>				<li>Create a<a id="_idIndexMarker210"/> logical column based on the same filter and perform a two-level grouping using <strong class="source-inline">Species</strong>. Then, create a logical column to calculate the <span class="No-Break">average </span><span class="No-Break"><strong class="source-inline">Sepal.Length</strong></span><span class="No-Break">:</span><pre class="source-code">&#13;
rst = iris_tbl %&gt;%&#13;
  mutate(ind = abs(Sepal.Length-Sepal.Width) &gt; abs(Petal.Length-Petal.Width)) %&gt;%&#13;
  group_by(Species, ind) %&gt;%&#13;
  summarise(mean_sepal_length=mean(Sepal.Length))&#13;
&gt;&gt;&gt; rst&#13;
# A tibble: 6 x 3&#13;
# Groups:   Species [3]&#13;
  Species    ind   mean_sepal_length&#13;
  &lt;chr&gt;      &lt;lgl&gt;             &lt;dbl&gt;&#13;
1 setosa     FALSE              5&#13;
2 setosa     TRUE               5.01&#13;
3 versicolor FALSE              5.78&#13;
4 versicolor TRUE               6.02&#13;
5 virginica  FALSE              6.39&#13;
6 virginica  TRUE               6.74</pre><p class="list-inset">We can <a id="_idIndexMarker211"/>put multiple categorical columns in the <strong class="source-inline">group_by()</strong> function to perform a multi-level grouping. Note that the result contains a <strong class="source-inline">Groups</strong> attribute based on <strong class="source-inline">Species</strong>, suggesting that the <strong class="source-inline">tibble</strong> object has a group structure. Let’s learn how to remove <span class="No-Break">the structure.</span></p></li>				<li>Remove<a id="_idIndexMarker212"/> the group structure in the returned <strong class="source-inline">tibble</strong> object <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">ungroup()</strong></span><span class="No-Break">:</span><pre class="source-code">&#13;
rst = iris_tbl %&gt;%&#13;
  mutate(ind = abs(Sepal.Length-Sepal.Width) &gt; abs(Petal.Length-Petal.Width)) %&gt;%&#13;
  group_by(Species, ind) %&gt;%&#13;
  summarise(mean_sepal_length=mean(Sepal.Length)) %&gt;%&#13;
  ungroup()&#13;
&gt;&gt;&gt; rst&#13;
# A tibble: 6 x 3&#13;
  Species    ind   mean_sepal_length&#13;
  &lt;chr&gt;      &lt;lgl&gt;             &lt;dbl&gt;&#13;
1 setosa     FALSE              5&#13;
2 setosa     TRUE               5.01&#13;
3 versicolor FALSE              5.78&#13;
4 versicolor TRUE               6.02&#13;
5 virginica  FALSE              6.39&#13;
6 virginica  TRUE               6.74</pre><p class="list-inset">Now, the <a id="_idIndexMarker213"/>result contains a normal <strong class="source-inline">tibble</strong> object with the average sepal length for each unique combination of <strong class="source-inline">Species</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">ind</strong></span><span class="No-Break">.</span></p></li>			</ol>&#13;
			<p>Now that we know how to transform and aggregate one dataset, we will cover how to work with multiple datasets via merging <span class="No-Break">and joining.</span></p>&#13;
			<h1 id="_idParaDest-48"><a id="_idTextAnchor047"/>Data merging with dplyr</h1>&#13;
			<p>In practical <a id="_idIndexMarker214"/>data analysis, the information we need is not necessarily confined to one table but is spread across multiple tables. Storing data in separate tables is memory-efficient but not analysis-friendly. <strong class="bold">Data merging</strong> is the<a id="_idIndexMarker215"/> process of merging different datasets into one table to facilitate data analysis. When joining two tables, there need to be one or more columns, or <strong class="bold">keys</strong>, that<a id="_idIndexMarker216"/> exist in both tables and serve as the common ground <span class="No-Break">for joining.</span></p>&#13;
			<p>This section will cover different ways to join tables and analyze them in combination, including inner join, left join, right join, and full join. The following list shows the verbs and their definitions for these four types <span class="No-Break">of joining:</span></p>&#13;
			<ul>&#13;
				<li><strong class="source-inline">inner_join()</strong>: Returns <a id="_idIndexMarker217"/>common observations in both tables according to the <span class="No-Break">matching key.</span></li>&#13;
				<li><strong class="source-inline">left_join()</strong>: Returns <a id="_idIndexMarker218"/>all observations from the left table and matched observations from the right table. Note that in the case of a duplicate key value in the right table, an additional row will be automatically created and added to the left table. Empty cells are filled with <strong class="source-inline">NA</strong>. More on this in <span class="No-Break">the exercise.</span></li>&#13;
				<li><strong class="source-inline">right_join()</strong>: Returns<a id="_idIndexMarker219"/> all observations from the right table and matched observations from the left table. Empty cells are filled <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">NA</strong></span><span class="No-Break">.</span></li>&#13;
				<li><strong class="source-inline">full_join()</strong>: Returns<a id="_idIndexMarker220"/> all observations from both tables. Empty cells are filled <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">NA</strong></span><span class="No-Break">.</span></li>&#13;
			</ul>&#13;
			<p><span class="No-Break"><em class="italic">Figure 2</em></span><em class="italic">.2</em> illustrates the four joins using <span class="No-Break">Venn diagrams:</span></p>&#13;
			<p class="IMG---Figure"> </p>&#13;
			<div>&#13;
				<div id="_idContainer019" class="IMG---Figure">&#13;
					<img src="Images/B18680_02_002.jpg" alt="Figure 2.2 – Four different joins commonly used in practice" width="1275" height="953"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.2 – Four different joins commonly used in practice</p>&#13;
			<p>Let’s go through an exercise on these <span class="No-Break">four joins.</span></p>&#13;
			<h3>Exercise 2.10 – joining datasets</h3>&#13;
			<p>This exercise<a id="_idIndexMarker221"/> will create two dummy <strong class="source-inline">tibble</strong> datasets and apply different joining verbs to <span class="No-Break">merge them:</span></p>&#13;
			<ol>&#13;
				<li>Create two dummy datasets by following the steps in this <span class="No-Break">code block:</span><pre class="source-code">&#13;
a = 1:3&#13;
tbl_A = tibble(key_A=a, col_A=2*a)&#13;
tbl_B = tibble(key_B=a+1, col_B=3*a)&#13;
&gt;&gt;&gt; tbl_A&#13;
# A tibble: 3 x 2&#13;
  key_A col_A&#13;
  &lt;int&gt; &lt;dbl&gt;&#13;
1     1     2&#13;
2     2     4&#13;
3     3     6&#13;
&gt;&gt;&gt; tbl_B&#13;
# A tibble: 3 x 2&#13;
  key_B col_B&#13;
  &lt;dbl&gt; &lt;dbl&gt;&#13;
1     2     3&#13;
2     3     6&#13;
3     4     9</pre><p class="list-inset">Both dummy datasets have three rows and two columns, with the first column being the key column to be used <span class="No-Break">for joining.</span></p></li>				<li>Perform <a id="_idIndexMarker222"/>an<a id="_idIndexMarker223"/> inner join of the <span class="No-Break">two datasets:</span><pre class="source-code">&#13;
rst = tbl_A %&gt;%&#13;
  inner_join(tbl_B, by=c("key_A"="key_B"))&#13;
&gt;&gt;&gt; rst&#13;
# A tibble: 2 x 3&#13;
  key_A col_A col_B&#13;
  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;&#13;
1     2     4     3&#13;
2     3     6     6</pre><p class="list-inset">The <a id="_idIndexMarker224"/>preceding code shows that the matching keys are specified in the <strong class="source-inline">by</strong> argument via the <strong class="source-inline">c()</strong> function. Since <strong class="source-inline">"key_A"</strong> and <strong class="source-inline">"key_B"</strong> have only two values in common, the resulting table after the inner join operation is a 2x3 <strong class="source-inline">tibble</strong> that keeps only <strong class="source-inline">"key_A"</strong> as the key column and all other non-key columns from both tables. It only keeps observations that have an exact match and works the same way with either table in <span class="No-Break">either direction.</span></p><p class="list-inset">We can also pass <a id="_idIndexMarker225"/>in additional match keys (on which the tables will be joined) in the <strong class="source-inline">by</strong> argument while following the same format to perform a <span class="No-Break">multi-level merging.</span></p><p class="list-inset">Let’s look at how to perform a <span class="No-Break">left join.</span></p></li>				<li>Perform a<a id="_idIndexMarker226"/> left join of the <span class="No-Break">two datasets:</span><pre class="source-code">&#13;
rst = tbl_A %&gt;%&#13;
  left_join(tbl_B, by=c("key_A"="key_B"))&#13;
&gt;&gt;&gt; rst&#13;
# A tibble: 3 x 3&#13;
  key_A col_A col_B&#13;
  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;&#13;
1     1     2    NA&#13;
2     2     4     3&#13;
3     3     6     6</pre><p class="list-inset">Note that the resulting tables contain the whole <strong class="source-inline">tbl_A</strong> and an additional column, <strong class="source-inline">col_B</strong>, that’s referenced from <strong class="source-inline">tbl_B</strong>. Since <strong class="source-inline">col_B</strong> does not have 1, the corresponding cell in <strong class="source-inline">col_B</strong> shows <strong class="source-inline">NA</strong>. In general, any cell that cannot be matched will assume a value of <strong class="source-inline">NA</strong> in the <span class="No-Break">resulting table.</span></p><p class="list-inset">Note that when<a id="_idIndexMarker227"/> there are multiple rows with duplicate values in <strong class="source-inline">col_B</strong>, the resulting table after a left join will also have a duplicate row automatically created since it is now a one-to-two mapping from left to right. Let’s see <span class="No-Break">an example.</span></p></li>				<li>Create another<a id="_idIndexMarker228"/> table with a duplicate key value and perform a left join <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">tbl_A</strong></span><span class="No-Break">:</span><pre class="source-code">&#13;
tbl_C = tbl_B %&gt;%&#13;
  bind_rows(tbl_B[1,])&#13;
tbl_C[nrow(tbl_C),"col_B"] = 10&#13;
&gt;&gt;&gt; tbl_C&#13;
# A tibble: 4 x 2&#13;
  key_B col_B&#13;
  &lt;dbl&gt; &lt;dbl&gt;&#13;
1     2     3&#13;
2     3     6&#13;
3     4     9&#13;
4     2    10</pre><p class="list-inset">Here, we used the <strong class="source-inline">bind_rows()</strong> function to append a new row with the same value in <strong class="source-inline">"key_B"</strong> as the first row and a different value for <strong class="source-inline">col_B</strong>. Let’s see what happens when we join it <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">tbl_A</strong></span><span class="No-Break">:</span></p><pre class="source-code">rst = tbl_A %&gt;%&#13;
  left_join(tbl_C, by=c("key_A"="key_B"))&#13;
&gt;&gt;&gt; rst&#13;
# A tibble: 4 x 3&#13;
  key_A col_A col_B&#13;
  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;&#13;
1     1     2    NA&#13;
2     2     4     3&#13;
3     2     4    10&#13;
4     3     6     6</pre><p class="list-inset">Having a <a id="_idIndexMarker229"/>duplicate value in the key column <a id="_idIndexMarker230"/>of the right table is a common source of bugs that could be difficult to trace. Seasoned data scientists should pay particular attention to this potential unintended result by checking the dimension of the dataset <em class="italic">before</em> and <em class="italic">after</em> the left join. Now, let’s look at how to perform a <span class="No-Break">right join.</span></p></li>				<li>Perform<a id="_idIndexMarker231"/> a right join of <strong class="source-inline">tbl_A</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">tbl_B</strong></span><span class="No-Break">:</span><pre class="source-code">&#13;
rst = tbl_A %&gt;%&#13;
right_join(tbl_B, by=c("key_A"="key_B"))&#13;
&gt;&gt;&gt; rst&#13;
# A tibble: 3 x 3&#13;
  key_A col_A col_B&#13;
  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;&#13;
1     2     4     3&#13;
2     3     6     6&#13;
3     4    NA     9</pre><p class="list-inset">Similarly, all observations in <strong class="source-inline">tbl_B</strong> are kept and the missing value in <strong class="source-inline">col_A</strong> is filled with <strong class="source-inline">NA</strong>. In addition, the key column is named <strong class="source-inline">"key_A"</strong> instead <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">"key_B"</strong></span><span class="No-Break">.</span></p></li>				<li>Perform a<a id="_idIndexMarker232"/> full join of <strong class="source-inline">tbl_A</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">tbl_B</strong></span><span class="No-Break">:</span><pre class="source-code">&#13;
rst = tbl_A %&gt;%&#13;
  full_join(tbl_B, by=c("key_A"="key_B"))&#13;
&gt;&gt;&gt; rst&#13;
# A tibble: 4 x 3&#13;
  key_A col_A col_B&#13;
  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;&#13;
1     1     2    NA&#13;
2     2     4     3&#13;
3     3     6     6&#13;
4     4    NA     9</pre><p class="list-inset">Using a <a id="_idIndexMarker233"/>full join, all matched results from both tables are maintained, with missing values filled with <strong class="source-inline">NA</strong>. We can use this when we do not want to leave out any observations from the <span class="No-Break">source tables.</span></p></li>			</ol>&#13;
			<p>These four joining statements can be repeatedly used to join multiple tables and combined with any data transformation verbs covered earlier. For example, we can remove the rows with <strong class="source-inline">NA</strong> values and keep only the <strong class="source-inline">complete</strong> rows, which should give us the same result in the inner join. This can be achieved using <strong class="source-inline">drop_na()</strong>, a utility function provided by the <strong class="source-inline">tidyr</strong> package that’s designed specifically for data cleaning within the <span class="No-Break"><strong class="source-inline">tidyverse</strong></span><span class="No-Break"> ecosystem:</span></p>&#13;
			<pre class="source-code">&#13;
library(tidyr)&#13;
rst = tbl_A %&gt;%&#13;
  full_join(tbl_B, by=c("key_A"="key_B")) %&gt;%&#13;
  drop_na()&#13;
&gt;&gt;&gt; rst&#13;
# A tibble: 2 x 3&#13;
  key_A col_A col_B&#13;
  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;&#13;
1     2     4     3&#13;
2     3     6     6</pre>			<p>We may also want to replace <strong class="source-inline">NA</strong> values with 0, which can be achieved via the <strong class="source-inline">replace_na()</strong> function provided by <strong class="source-inline">tidyr</strong>. In the following code, we are specifying the replacement values for each<a id="_idIndexMarker234"/> column of interest and wrapping them in a list to be passed <span class="No-Break">into </span><span class="No-Break"><strong class="source-inline">replace_na()</strong></span><span class="No-Break">:</span></p>&#13;
			<pre class="source-code">&#13;
rst = tbl_A %&gt;%&#13;
  full_join(tbl_B, by=c("key_A"="key_B")) %&gt;%&#13;
  replace_na(list(col_A=0, col_B=0))&#13;
&gt;&gt;&gt; rst&#13;
# A tibble: 4 x 3&#13;
  key_A col_A col_B&#13;
  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;&#13;
1     1     2     0&#13;
2     2     4     3&#13;
3     3     6     6&#13;
4     4     0     9</pre>			<p>Note that there are other merging options, such as the semi-join and the anti-join, which correspond to the <strong class="source-inline">semi_join()</strong> and <strong class="source-inline">anti_join()</strong> functions, respectively. Semi-join returns only the rows from the table in the first argument where there is a match in the second table. Although similar to a full join operation, a semi-join only keeps <em class="italic">the columns in the first table</em>. The anti-join operation, on the other hand, is the opposite of a semi-join, returning only <em class="italic">the unmatched rows in the first table</em>. Since many merging operations, including these two, can be derived using the four basic operations we introduced in this section, we will not cover these slightly more complicated joining operations in detail. Instead, we encourage you to explore using these four fundamental joining functions to achieve complicated operations instead of relying on other shortcut <span class="No-Break">joining functions.</span></p>&#13;
			<p>Next, we will go through a case study and observe how to transform, merge, and aggregate a dataset using the functions we’ve covered in <span class="No-Break">this chapter.</span></p>&#13;
			<h1 id="_idParaDest-49"><a id="_idTextAnchor048"/>Case study – working with the Stack Overflow dataset</h1>&#13;
			<p>This section will<a id="_idIndexMarker235"/> cover an exercise to help you practice different data transformation, aggregation, and merging techniques based on the public Stack Overflow dataset, which contains a set of tables related to technical questions and answers posted on the Stack Overflow platform. The supporting raw data has been uploaded to the accompanying Github repository of this book. We will directly download it from the source GitHub link using the <strong class="source-inline">readr</strong> package, another <strong class="source-inline">tidyverse</strong> offering that provides an easy, fast, and friendly way to read a wide range of data sources, including those from <span class="No-Break">the web.</span></p>&#13;
			<h3>Exercise 2.11 – working with the Stack Overflow dataset</h3>&#13;
			<p>Let’s begin <span class="No-Break">this exercise:</span></p>&#13;
			<ol>&#13;
				<li>Download three data sources on questions, tags, and their mapping table <span class="No-Break">from GitHub:</span><pre class="source-code">&#13;
library(readr)&#13;
df_questions = read_csv("https://raw.githubusercontent.com/PacktPublishing/The-Statistics-and-Machine-Learning-with-R-Workshop/main/Chapter_2/data/questions.csv")&#13;
&gt;&gt;&gt; df_questions&#13;
# A tibble: 294,735 x 3&#13;
         id creation_date score&#13;
      &lt;dbl&gt; &lt;date&gt;        &lt;dbl&gt;&#13;
 1 22557677 2014-03-21        1&#13;
 2 22557707 2014-03-21        2&#13;
 3 22558084 2014-03-21        2&#13;
 4 22558395 2014-03-21        2&#13;
 5 22558613 2014-03-21        0&#13;
 6 22558677 2014-03-21        2&#13;
 7 22558887 2014-03-21        8&#13;
 8 22559180 2014-03-21        1&#13;
 9 22559312 2014-03-21        0&#13;
10 22559322 2014-03-21        2&#13;
# … with 294,725 more rows</pre><p class="list-inset">The <a id="_idIndexMarker236"/>questions dataset contains the question ID, date of creation, and score, which indicates the number of (positive) upvotes and (negative) downvotes. We can examine the range of scores using the <span class="No-Break"><strong class="source-inline">summary()</strong></span><span class="No-Break"> function:</span></p><pre class="source-code">&gt;&gt;&gt; summary(df_questions$score)&#13;
    Min.  1st Qu.   Median     Mean  3rd Qu.     Max.&#13;
 -21.000    0.000    1.000    1.904    2.000 2474.000</pre><p class="list-inset">The range of scores is quite broad. Indeed, many answers wait for excellent and proper questions to be asked. Do remember to ask questions when in doubt and search for similar questions other people <span class="No-Break">have asked.</span></p><p class="list-inset">Let’s import the other two <span class="No-Break">data sources:</span></p><pre class="source-code">df_question_tags = read_csv("https://raw.githubusercontent.com/PacktPublishing/The-Statistics-and-Machine-Learning-with-R-Workshop/main/Chapter_2/data/question_tags.csv")&#13;
&gt;&gt;&gt; df_question_tags&#13;
# A tibble: 497,153 x 2&#13;
   question_id tag_id&#13;
         &lt;dbl&gt;  &lt;dbl&gt;&#13;
 1    22557677     18&#13;
 2    22557677    139&#13;
 3    22557677  16088&#13;
 4    22557677   1672&#13;
 5    22558084   6419&#13;
 6    22558084  92764&#13;
 7    22558395   5569&#13;
 8    22558395    134&#13;
 9    22558395   9412&#13;
10    22558395  18621&#13;
# … with 497,143 more rows</pre><p class="list-inset">This <a id="_idIndexMarker237"/>dataset contains the mapping table between <strong class="source-inline">question_id</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">tag_id</strong></span><span class="No-Break">:</span></p><pre class="source-code">df_tags = read_csv("https://raw.githubusercontent.com/PacktPublishing/The-Statistics-and-Machine-Learning-with-R-Workshop/main/Chapter_2/data/tags.csv")&#13;
&gt;&gt;&gt; df_tags&#13;
# A tibble: 48,299 x 2&#13;
       id tag_name&#13;
    &lt;dbl&gt; &lt;chr&gt;&#13;
 1 124399 laravel-dusk&#13;
 2 124402 spring-cloud-vault-config&#13;
 3 124404 spring-vault&#13;
 4 124405 apache-bahir&#13;
 5 124407 astc&#13;
 6 124408 simulacrum&#13;
 7 124410 angulartics2&#13;
 8 124411 django-rest-viewsets&#13;
 9 124414 react-native-lightbox&#13;
10 124417 java-module&#13;
# … with 48,289 more rows</pre><p class="list-inset">This dataset contains the ID and the content of each tag. To analyze the tags, we need to merge the three datasets into one using the relevant <span class="No-Break">mapping keys.</span></p></li>				<li>Reference<a id="_idIndexMarker238"/> the tag ID from <strong class="source-inline">df_question_tags</strong> into <strong class="source-inline">df_questions</strong> via a <span class="No-Break">left join:</span><pre class="source-code">&#13;
df_all = df_questions %&gt;%&#13;
  left_join(df_question_tags, by=c("id"="question_id"))&#13;
&gt;&gt;&gt; df_all&#13;
# A tibble: 545,694 x 4&#13;
         id creation_date score tag_id&#13;
      &lt;dbl&gt; &lt;date&gt;        &lt;dbl&gt;  &lt;dbl&gt;&#13;
 1 22557677 2014-03-21        1     18&#13;
 2 22557677 2014-03-21        1    139&#13;
 3 22557677 2014-03-21        1  16088&#13;
 4 22557677 2014-03-21        1   1672&#13;
 5 22557707 2014-03-21        2     NA&#13;
 6 22558084 2014-03-21        2   6419&#13;
 7 22558084 2014-03-21        2  92764&#13;
 8 22558395 2014-03-21        2   5569&#13;
 9 22558395 2014-03-21        2    134&#13;
10 22558395 2014-03-21        2   9412&#13;
# … with 545,684 more rows</pre><p class="list-inset">Note that the total number of rows almost doubled when comparing <strong class="source-inline">df_questions</strong> to <strong class="source-inline">df_all</strong>. You may have noticed that this is due to the one-to-many relationship: a question often has multiple tags, so each tag gets appended as a separate row to the left table during the left <span class="No-Break">join operation.</span></p></li>				<li>Let’s continue<a id="_idIndexMarker239"/> to reference the tags <span class="No-Break">from </span><span class="No-Break"><strong class="source-inline">df_tags</strong></span><span class="No-Break">:</span><pre class="source-code">&#13;
df_all = df_all %&gt;%&#13;
  left_join(df_tags, by=c("tag_id"="id"))&#13;
&gt;&gt;&gt; df_all&#13;
# A tibble: 545,694 x 5&#13;
         id creation_date score tag_id tag_name&#13;
      &lt;dbl&gt; &lt;date&gt;        &lt;dbl&gt;  &lt;dbl&gt; &lt;chr&gt;&#13;
 1 22557677 2014-03-21        1     18 regex&#13;
 2 22557677 2014-03-21        1    139 string&#13;
 3 22557677 2014-03-21        1  16088 time-complexity&#13;
 4 22557677 2014-03-21        1   1672 backreference&#13;
 5 22557707 2014-03-21        2     NA NA&#13;
 6 22558084 2014-03-21        2   6419 time-series&#13;
 7 22558084 2014-03-21        2  92764 panel-data&#13;
 8 22558395 2014-03-21        2   5569 function&#13;
 9 22558395 2014-03-21        2    134 sorting&#13;
10 22558395 2014-03-21        2   9412 vectorization&#13;
# … with 545,684 more rows</pre><p class="list-inset">Next, we will do some analysis of the tags, starting with counting <span class="No-Break">their frequency.</span></p></li>				<li>Count the <a id="_idIndexMarker240"/>occurrence of each non-<strong class="source-inline">NA</strong> tag in <span class="No-Break">descending order:</span><pre class="source-code">&#13;
df_all = df_all %&gt;%&#13;
  filter(!is.na(tag_name))&#13;
rst = df_all %&gt;%&#13;
  count(tag_name, sort = TRUE)&#13;
&gt;&gt;&gt; rst&#13;
# A tibble: 7,840 x 2&#13;
   tag_name       n&#13;
   &lt;chr&gt;      &lt;int&gt;&#13;
 1 ggplot2    28228&#13;
 2 dataframe  18874&#13;
 3 shiny      14219&#13;
 4 dplyr      14039&#13;
 5 plot       11315&#13;
 6 data.table  8809&#13;
 7 matrix      6205&#13;
 8 loops       5149&#13;
 9 regex       4912&#13;
10 function    4892&#13;
# … with 7,830 more rows</pre><p class="list-inset">Here, we first used <strong class="source-inline">filter()</strong> to remove rows if <strong class="source-inline">tag_name</strong> was <strong class="source-inline">NA</strong>, then calculated the counts using the <strong class="source-inline">count()</strong> function. The result shows that <strong class="source-inline">dplyr</strong> is among one of the most popular R-related tags on Stack Overflow, which is a good sign as it shows we are learning about something useful <span class="No-Break">and trendy.</span></p></li>				<li>Count the<a id="_idIndexMarker241"/> number of tags in <span class="No-Break">each year:</span><pre class="source-code">&#13;
library(lubridate)&#13;
rst = df_all %&gt;%&#13;
  mutate(year = year(creation_date)) %&gt;%&#13;
  count(year)&#13;
&gt;&gt;&gt; rst&#13;
# A tibble: 12 x 2&#13;
    year     n&#13;
   &lt;dbl&gt; &lt;int&gt;&#13;
 1  2008    18&#13;
 2  2009   874&#13;
 3  2010  3504&#13;
 4  2011  8787&#13;
 5  2012 18251&#13;
 6  2013 34998&#13;
 7  2014 50749&#13;
 8  2015 66652&#13;
 9  2016 76056&#13;
10  2017 90462&#13;
11  2018 96819&#13;
12  2019 49983</pre><p class="list-inset">The result shows an increasing number of tags per year, with 2019 being a special case as the data ends in mid-2019 (verified here). Note that we used the <strong class="source-inline">year()</strong> function from the <strong class="source-inline">lubricate</strong> package from <strong class="source-inline">tidyverse</strong> to convert a date-formatted column into the <span class="No-Break">corresponding year:</span></p><pre class="source-code">&gt;&gt;&gt; max(df_all$creation_date)&#13;
"2019-07-01"</pre></li>				<li>Calculate the average occurrence of tags <span class="No-Break">per month.</span><p class="list-inset">We need to <a id="_idIndexMarker242"/>derive the monthly occurrence of tags to calculate their average. First, we must create two columns to indicate the month and year-month for <span class="No-Break">each tag:</span></p><pre class="source-code">&#13;
df_all = df_all %&gt;%&#13;
  mutate(month = month(creation_date),&#13;
         year_month = format(creation_date, "%Y%m"))&#13;
&gt;&gt;&gt; df_all&#13;
# A tibble: 497,153 x 7&#13;
         id creation_date score tag_id tag_name            month year_month&#13;
      &lt;dbl&gt; &lt;date&gt;        &lt;dbl&gt;  &lt;dbl&gt; &lt;chr&gt;               &lt;dbl&gt; &lt;chr&gt;&#13;
 1 22557677 2014-03-21        1     18 regex                   3 201403&#13;
 2 22557677 2014-03-21        1    139 string                  3 201403&#13;
 3 22557677 2014-03-21        1  16088 time-complexity         3 201403&#13;
 4 22557677 2014-03-21        1   1672 backreference           3 201403&#13;
 5 22558084 2014-03-21        2   6419 time-series             3 201403&#13;
 6 22558084 2014-03-21        2  92764 panel-data              3 201403&#13;
 7 22558395 2014-03-21        2   5569 function                3 201403&#13;
 8 22558395 2014-03-21        2    134 sorting                 3 201403&#13;
 9 22558395 2014-03-21        2   9412 vectorization           3 201403&#13;
10 22558395 2014-03-21        2  18621 operator-precedence     3 201403&#13;
# … with 497,143 more rows</pre><p class="list-inset">Then, we <a id="_idIndexMarker243"/>must count the occurrence of tags per month for <span class="No-Break">each year-month:</span></p><pre class="source-code">rst1 = df_all %&gt;%&#13;
  count(year_month, month)&#13;
&gt;&gt;&gt; rst1&#13;
# A tibble: 130 x 3&#13;
   year_month month     n&#13;
   &lt;chr&gt;      &lt;dbl&gt; &lt;int&gt;&#13;
 1 200809         9    13&#13;
 2 200811        11     4&#13;
 3 200812        12     1&#13;
 4 200901         1     8&#13;
 5 200902         2    10&#13;
 6 200903         3     7&#13;
 7 200904         4    24&#13;
 8 200905         5     3&#13;
 9 200906         6    12&#13;
10 200907         7   100&#13;
# … with 120 more rows</pre><p class="list-inset">Finally, we<a id="_idIndexMarker244"/> must average over all years for <span class="No-Break">each month:</span></p><pre class="source-code">rst2 = rst1 %&gt;%&#13;
  group_by(month) %&gt;%&#13;
  summarise(avg_num_tag = mean(n))&#13;
&gt;&gt;&gt; rst2&#13;
# A tibble: 12 x 2&#13;
   month avg_num_tag&#13;
   &lt;dbl&gt;       &lt;dbl&gt;&#13;
 1     1       3606.&#13;
 2     2       3860.&#13;
 3     3       4389.&#13;
 4     4       4286.&#13;
 5     5       4178.&#13;
 6     6       4133.&#13;
 7     7       3630.&#13;
 8     8       3835.&#13;
 9     9       3249.&#13;
10    10       3988.&#13;
11    11       3628.&#13;
12    12       3125.</pre><p class="list-inset">The result shows that March has the highest occurrence of tags on average. Maybe school just got started and people are actively learning and asking questions more <span class="No-Break">in March.</span></p></li>				<li>Calculate the<a id="_idIndexMarker245"/> count, minimum, average score, and maximum score for each tag and sort the result by count in <span class="No-Break">descending order:</span><pre class="source-code">&#13;
rst = df_all %&gt;%&#13;
  group_by(tag_name) %&gt;%&#13;
  summarise(count = n(),&#13;
            min_score = min(score),&#13;
            mean_score = mean(score),&#13;
            max_score = max(score)) %&gt;%&#13;
  arrange(desc(count))&#13;
&gt;&gt;&gt; rst&#13;
# A tibble: 7,840 x 5&#13;
   tag_name   count min_score mean_score max_score&#13;
   &lt;chr&gt;      &lt;int&gt;     &lt;dbl&gt;      &lt;dbl&gt;     &lt;dbl&gt;&#13;
 1 ggplot2    28228        -9      2.61        666&#13;
 2 dataframe  18874       -11      2.31       1241&#13;
 3 shiny      14219        -7      1.45         79&#13;
 4 dplyr      14039        -9      1.95        685&#13;
 5 plot       11315       -10      2.24        515&#13;
 6 data.table  8809        -8      2.97        685&#13;
 7 matrix      6205       -10      1.66        149&#13;
 8 loops       5149        -8      0.743       180&#13;
 9 regex       4912        -9      2           242&#13;
10 function    4892       -14      1.39        485&#13;
# … with 7,830 more rows</pre><p class="list-inset">Here, we used <a id="_idIndexMarker246"/>multiple summary functions in the <strong class="source-inline">group_by()</strong> and <strong class="source-inline">summarize()</strong> context to calculate <span class="No-Break">the metrics.</span></p></li>			</ol>&#13;
			<h1 id="_idParaDest-50"><a id="_idTextAnchor049"/>Summary</h1>&#13;
			<p>In this chapter, we covered essential functions and techniques for data transformation, aggregation, and merging. For data transformation at the row level, we learned about common utility functions such as <strong class="source-inline">filter()</strong>, <strong class="source-inline">mutate()</strong>, <strong class="source-inline">select()</strong>, <strong class="source-inline">arrange()</strong>, <strong class="source-inline">top_n()</strong>, and <strong class="source-inline">transmute()</strong>. For data aggregation, which summarizes the raw dataset into a smaller and more concise summary view, we introduced functions such as <strong class="source-inline">count()</strong>, <strong class="source-inline">group_by()</strong>, and <strong class="source-inline">summarize()</strong>. For data merging, which combines multiple datasets into one, we learned about different joining methods, including <strong class="source-inline">inner_join()</strong>, <strong class="source-inline">left_join()</strong>, <strong class="source-inline">right_join()</strong>, and <strong class="source-inline">full_join()</strong>. Although there are other more advanced joining functions, the essential tools we covered in our toolkit are enough for us to achieve the same task. Finally, we went through a case study based on the Stack Overflow dataset. The skills we learned in this chapter will come in very handy in many data <span class="No-Break">analysis tasks.</span></p>&#13;
			<p>In the next chapter, we will cover a more advanced topic on natural language processing, taking us one step further to work with textual data <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">tidyverse</strong></span><span class="No-Break">.</span></p>&#13;
		</div>&#13;
	</div></body></html>