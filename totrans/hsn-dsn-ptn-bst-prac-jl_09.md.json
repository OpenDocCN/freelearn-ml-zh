["```py\nvariable = 10\n\nfunction add_using_global_variable(x)\n    return x + variable\nend\n```", "```py\nfunction add_using_function_arg(x, y)\n    return x + y\nend\n```", "```py\nconst constant = 10\n\nfunction add_using_global_constant(x)\n    return constant + x\nend\n```", "```py\nfunction add_using_global_variable_typed(x)\n    return x + variable::Int\nend\n```", "```py\nfunction constant_folding_example()\n    a = 2 * 3\n    b = a + 1\n    return b > 1 ? 10 : 20\nend\n```", "```py\nfunction add_by_passing_global_variable(x, v)\n    return x + v\nend\n```", "```py\n# Initialize a constant Ref object with the value of 10\nconst semi_constant = Ref(10)\n\nfunction add_using_global_semi_constant(x)\n    return x + semi_constant[]\nend\n```", "```py\n# default settings\nconst default_chunk_size = 0\nconst default_verbose_level = 1 \n\nconst magic = [\n         b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" ;\n         b\"\\x00\\x00\\x00\\x00\\xc2\\xea\\x81\\x60\" ;\n         b\"\\xb3\\x14\\x11\\xcf\\xbd\\x92\\x08\\x00\" ;\n         b\"\\x09\\xc7\\x31\\x8c\\x18\\x1f\\x10\\x11\" ]\n\nconst align_1_checker_value = b\"3\"\nconst align_1_offset = 32\nconst align_1_length = 1\nconst align_1_value = 4\n```", "```py\nstruct TripPayment\n    vendor_id::String\n    tpep_pickup_datetime::String\n    tpep_dropoff_datetime::String\n    passenger_count::Int\n    trip_distance::Float64\n    fare_amount::Float64\n    extra::Float64\n    mta_tax::Float64\n    tip_amount::Float64\n    tolls_amount::Float64\n    improvement_surcharge::Float64\n    total_amount::Float64\nend\n```", "```py\nfunction read_trip_payment_file(file)\n    f = CSV.File(file, datarow = 3)\n    records = Vector{TripPayment}(undef, length(f))\n    for (i, row) in enumerate(f)\n        records[i] = TripPayment(row.VendorID,\n                                 row.tpep_pickup_datetime,\n                                 row.tpep_dropoff_datetime,\n                                 row.passenger_count,\n                                 row.trip_distance,\n                                 row.fare_amount,\n                                 row.extra,\n                                 row.mta_tax,\n                                 row.tip_amount,\n                                 row.tolls_amount,\n                                 row.improvement_surcharge,\n                                 row.total_amount)\n    end\n    return records\nend\n```", "```py\nfare_amounts = [r.fare_amount for r in records];\n```", "```py\nstruct TripPaymentColumnarData\n    vendor_id::Vector{Int}\n    tpep_pickup_datetime::Vector{String}\n    tpep_dropoff_datetime::Vector{String}\n    passenger_count::Vector{Int}\n    trip_distance::Vector{Float64}\n    fare_amount::Vector{Float64}\n    extra::Vector{Float64}\n    mta_tax::Vector{Float64}\n    tip_amount::Vector{Float64}\n    tolls_amount::Vector{Float64}\n    improvement_surcharge::Vector{Float64}\n    total_amount::Vector{Float64}\nend\n```", "```py\ncolumar_records = TripPaymentColumnarData(\n    [r.vendor_id for r in records],\n    [r.tpep_pickup_datetime for r in records],\n    [r.tpep_dropoff_datetime for r in records],\n    [r.passenger_count for r in records],\n    [r.trip_distance for r in records],\n    [r.fare_amount for r in records],\n    [r.extra for r in records],\n    [r.mta_tax for r in records],\n    [r.tip_amount for r in records],\n    [r.tolls_amount for r in records],\n    [r.improvement_surcharge for r in records],\n    [r.total_amount for r in records]\n);\n```", "```py\nusing StructArrays\nsa = StructArray(records)\n```", "```py\nstruct TripPayment\n    vendor_id::String\n    tpep_pickup_datetime::String\n    tpep_dropoff_datetime::String\n    passenger_count::Int\n    trip_distance::Float64\n    fare::Fare\nend\n\nstruct Fare\n    fare_amount::Float64\n    extra::Float64\n    mta_tax::Float64\n    tip_amount::Float64\n    tolls_amount::Float64\n    improvement_surcharge::Float64\n    total_amount::Float64\nend\n```", "```py\nfunction read_trip_payment_file(file)\n    f = CSV.File(file, datarow = 3)\n    records = Vector{TripPayment}(undef, length(f))\n    for (i, row) in enumerate(f)\n        records[i] = TripPayment(row.VendorID,\n                                 row.tpep_pickup_datetime,\n                                 row.tpep_dropoff_datetime,\n                                 row.passenger_count,\n                                 row.trip_distance,\n                                 Fare(row.fare_amount,\n                                      row.extra,\n                                      row.mta_tax,\n                                      row.tip_amount,\n                                      row.tolls_amount,\n                                      row.improvement_surcharge,\n                                      row.total_amount))\n    end\n    return records\nend\n```", "```py\nfunction make_data_directories()\n    for i in 0:99 \n        mkdir(\"$i\") \n    end\nend\n```", "```py\nfunction locate_file(index)\n    id = index - 1\n    dir = string(id % 100)\n    joinpath(dir, \"sec$(id).dat\")\nend\n```", "```py\njulia> locate_file.(vcat(1:2, 100:101))\n4-element Array{String,1}:\n \"0/sec0.dat\"\n \"1/sec1.dat\"\n \"99/sec99.dat\"\n \"0/sec100.dat\"\n```", "```py\nfunction generate_test_data(nfiles)\n    for i in 1:nfiles\n        A = rand(10000, 3)\n        file = locate_file(i)\n        open(file, \"w\") do io\n            write(io, A)\n        end\n    end\nend\n```", "```py\nusing Distributed\nusing SharedArrays\n```", "```py\n@everywhere cd(joinpath(ENV[\"HOME\"], \"julia_book_ch06_data\"))\n```", "```py\nnfiles = 100_000\nnstates = 10_000\nnattr = 3\nvaluation = SharedArray{Float64}(nstates, nattr, nfiles)\nload_data!(nfiles, valuation)\n```", "```py\nfunction load_data!(nfiles, dest)\n    @sync @distributed for i in 1:nfiles\n        read_val_file!(i, dest)\n    end\nend\n```", "```py\n# Read a single data file into a segment of the shared array `dest`\n# The segment size is specified as in `dims`. \n@everywhere function read_val_file!(index, dest)\n    filename = locate_file(index)\n    (nstates, nattrs) = size(dest)[1:2]\n    open(filename) do io\n        nbytes = nstates * nattrs * 8\n        buffer = read(io, nbytes)\n        A = reinterpret(Float64, buffer)\n        dest[:, :, index] = A\n    end\nend\n```", "```py\n@everywhere function locate_file(index)\n    id = index - 1\n    dir = string(id % 100)\n    return joinpath(dir, \"sec$(id).dat\")\nend\n```", "```py\nfunction load_data!(nfiles, dest)\n    @sync @distributed for i in 1:nfiles\n        read_val_file!(i, dest)\n    end\nend\n```", "```py\nnfiles = 100_000\nnstates = 10_000\nnattr = 3\nvaluation = SharedArray{Float64}(nstates, nattr, nfiles)\n```", "```py\nusing Statistics: std\n\n# Find standard deviation of each attribute for each security\nfunction std_by_security(valuation)\n    (nstates, nattr, n) = size(valuation)\n    result = zeros(n, nattr)\n    for i in 1:n\n        for j in 1:nattr\n            result[i, j] = std(valuation[:, j, i])\n        end\n    end\n    return result\nend\n```", "```py\n@everywhere using Statistics: std\n```", "```py\nfunction std_by_security2(valuation)\n    (nstates, nattr, n) = size(valuation)\n    result = SharedArray{Float64}(n, nattr)\n    @sync @distributed for i in 1:n\n        for j in 1:nattr\n            result[i, j] = std(valuation[:, j, i])\n        end\n    end\n    return result\nend\n```", "```py\nusing Statistics: std, mean, median\nusing StatsBase: skewness, kurtosis\n\nfunction stats_by_security(valuation, funcs)\n    (nstates, nattr, n) = size(valuation)\n    result = zeros(n, nattr, length(funcs))\n    for i in 1:n\n        for j in 1:nattr\n            for (k, f) in enumerate(funcs)\n                result[i, j, k] = f(valuation[:, j, i])\n            end\n        end\n    end\n    return result\nend\n```", "```py\n@everywhere using Statistics: std, mean, median\n@everywhere using StatsBase: skewness, kurtosis\n\nfunction stats_by_security2(valuation, funcs)\n    (nstates, nattr, n) = size(valuation)\n    result = SharedArray{Float64}((n, nattr, length(funcs)))\n    @sync @distributed for i in 1:n\n        for j in 1:nattr\n            for (k, f) in enumerate(funcs)\n                result[i, j, k] = f(valuation[:, j, i])\n            end\n        end\n    end\n    return result\nend\n```", "```py\n@everywhere my_global_var = whatever_value\n```", "```py\nstruct OrderItem\n    order_id::Int\n    item_id::Int\n    price::Float64\n    quantity::Int\nend\n```", "```py\nstruct Customer\n    name::String\n    age::Int\nend\n```", "```py\nfunction fib(n)\n    if n < 3\n        return (result = 1, counter = 1)\n    else\n        result1, counter1 = fib(n - 1)\n        result2, counter2 = fib(n - 2)\n        return (result = result1 + result2, counter = 1 + counter1 + counter2)\n    end\nend\n```", "```py\nconst fib_cache = Dict()\n\n_fib(n) = n < 3 ? 1 : fib(n-1) + fib(n-2)\n\nfunction fib(n)\n    if haskey(fib_cache, n)\n        return fib_cache[n]\n    else\n        value = _fib(n)\n        fib_cache[n] = value\n        return value\n    end\nend\n```", "```py\nfib = n -> begin\n    println(\"called\")\n    return n < 3 ? 1 : fib(n-1) + fib(n-2)\nend\n```", "```py\nfunction memoize(f)\n    memo = Dict()\n    x -> begin\n        if haskey(memo, x)\n            return memo[x]\n        else\n            value = f(x)\n            memo[x] = value\n            return value\n        end\n    end\nend\n```", "```py\nfib = memoize(fib)\n```", "```py\nfib_fast = memoize(fib)\n```", "```py\nfunction memoize(f)\n    memo = Dict()\n    (args...; kwargs...) -> begin\n        x = (args, kwargs)\n        if haskey(memo, x)\n            return memo[x]\n        else\n            value = f(args...; kwargs...)\n            memo[x] = value\n            return value\n        end\n    end\nend\n```", "```py\n# Simulate a slow function with positional arguments and keyword arguments\nslow_op = (a, b = 2; c = 3, d) -> begin\n    sleep(2)\n    a + b + c + d\nend\n```", "```py\nop = memoize(slow_op)\n```", "```py\n# This is a slow implementation\nslow_sum_abs = (x::AbstractVector{T} where {T <: Real}) -> begin\n    sleep(2)\n    sum(abs(v) for v in x)\nend\n```", "```py\nsum_abs = memoize(slow_sum_abs)\n```", "```py\nfunction memoize(f)\n    memo = Dict()\n    (args...; kwargs...) -> begin\n        x = (args, kwargs)\n        if haskey(memo, x)\n            return memo[x]\n...\n```", "```py\nfunction hash_all_args(args, kwargs)\n    h = 0xed98007bd4471dc2\n    h += hash(args, h)\n    h += hash(kwargs, h)\n    return h\nend\n```", "```py\n@memoize fib(n) = n < 3 ? 1 : fib(n-1) + fib(n-2)\n```", "```py\nfibpoly(n::Int) = _fib_poly(n)\n\nlet myzero = 0, myone = 1, xvar = Polynomials.Poly([myzero,myone]), zerovar = Polynomials.Poly([myzero]), onevar = Polynomials.Poly([myone])\n    global _fib_poly\n    @memoize function _fib_poly(n::Int)\n        if n == 0\n            return zerovar\n        elseif n == 1\n            return onevar\n        else\n            return xvar * _fib_poly(n-1) + _fib_poly(n-2)\n        end\n    end\nend\n```", "```py\n@inline function memapl(rv::RandVar, mω::TaggedΩ)\n  if dontcache(rv)\n    ppapl(rv, proj(mω, rv))\n  elseif haskey(mω.tags.cache, rv.id)\n    mω.tags.cache[rv.id]::(Core.Compiler).return_type(rv, typeof((mω.taggedω,)))\n  else\n    mω.tags.cache[rv.id] = ppapl(rv, proj(mω, rv))\n  end\nend\n```", "```py\nrandom_data(n) = isodd(n) ? rand(Int, n) : rand(Float64, n)\n```", "```py\nfunction double_sum_of_random_data(n)\n    data = random_data(n)\n    total = 0\n    for v in data\n        total += 2 * v\n    end\n    return total\nend\n```", "```py\nfunction double_sum(data)\n    total = 0\n    for v in data\n    total += 2 * v\n    end\n    return total\nend\n```", "```py\nfunction double_sum_of_random_data(n)\n    data = random_data(n)\n    return double_sum(data)\nend\n```", "```py\nfunction double_sum(data)\n    total = zero(eltype(data))\n    for v in data\n        total += 2 * v\n    end\n    return total\nend\n```", "```py\nfunction double_sum(data::AbstractVector{T}) where {T <: Number}\n    total = zero(T)\n    for v in data\n        total += v\n    end\n    return total\nend\n```"]