- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Deep Learning Containers
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深度学习容器
- en: In [*Chapter 2*](B18638_02.xhtml#_idTextAnchor041), *Deep Learning AMIs*, we
    used **AWS Deep Learning AMIs** (**DLAMIs**) to set up an environment inside an
    EC2 instance where we could train and evaluate a deep learning model. In this
    chapter, we will take a closer look at **AWS Deep Learning Containers** (**DLCs**),
    which can run consistently across multiple environments and services. In addition
    to this, we will discuss the similarities and differences between DLAMIs and DLCs.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第二章*](B18638_02.xhtml#_idTextAnchor041)“*深度学习 AMI*”中，我们使用了**AWS Deep Learning
    AMI**（**DLAMIs**）在EC2实例内设置一个环境，在那里我们可以训练和评估深度学习模型。在本章中，我们将更深入地探讨**AWS Deep Learning
    Containers**（**DLCs**），它们可以在多个环境和服务中持续运行。此外，我们还将讨论DLAMIs和DLCs之间的相似之处和不同之处。
- en: The hands-on solutions in this chapter focus on the different ways we can use
    DLCs to solve several pain points when working on **machine learning** (**ML**)
    requirements in the cloud. For example, container technologies such as **Docker**
    allow us to make the most of our running EC2 instances since we’ll be able to
    run different types of applications inside containers, without having to worry
    about whether their dependencies would conflict or not. In addition to this, we
    would have more options and solutions available when trying to manage and reduce
    costs. For one thing, if we were to use the container image support of **AWS Lambda**
    (a serverless compute service that lets us run our custom backend code) to deploy
    our deep learning model inside a serverless function, we would be able to significantly
    reduce the infrastructure costs associated with having an inference endpoint running
    24/7\. At the same time, with a serverless function, all we need to worry about
    is the custom code inside the function since AWS will take care of the infrastructure
    where this function would run.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的动手解决方案侧重于我们如何使用DLCs（深度学习容器）来解决在云中处理**机器学习**（**ML**）需求时的几个痛点。例如，容器技术如**Docker**允许我们在容器内运行不同类型的应用程序，而无需担心它们的依赖项是否会发生冲突。除此之外，在尝试管理和降低成本时，我们会有更多的选择和解决方案。例如，如果我们使用**AWS
    Lambda**（一种无服务器计算服务，允许我们运行自定义后端代码）的容器镜像支持来部署我们的深度学习模型到无服务器函数中，我们就能显著降低与24/7运行的推理端点相关的基础设施成本。同时，使用无服务器函数，我们只需要关注函数内的自定义代码，因为AWS会负责这个函数运行的基础设施。
- en: In the scenario discussed in the *Understanding how AWS pricing works for EC2
    instances* section of the previous chapter, we were able to reduce the cost of
    running a 24/7 inference endpoint to about *$69.12 per month* using an `m6i.large`
    instance. It is important to note that this value would more or less remain constant,
    even if this inference endpoint is not receiving any traffic. In other words,
    we might be paying *$69.12 per month* for a resource that could be either underutilized
    or unused. If we were to set up a staging environment that is configured the same
    as the production environment, this cost would double and it’s pretty much guaranteed
    that the staging environment resources would be severely underutilized. At this
    point, you might be wondering, *Is it possible for us to reduce this cost further?*
    The good news is that this is possible, so long as we can design a more optimal
    architecture using the right set of tools, services, and frameworks.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中“*理解 AWS EC2 实例定价方式*”部分讨论的场景中，我们能够通过使用`m6i.large`实例，将24/7推理端点的运行成本降低到大约*每月69.12美元*。重要的是要注意，即使这个推理端点没有收到任何流量，这个值也大致会保持不变。换句话说，我们可能每个月要支付*69.12美元*，用于可能被低效利用或未使用的资源。如果我们设置一个与生产环境配置相同的预发布环境，这个成本将翻倍，而且几乎可以肯定的是，预发布环境资源将会严重低效。在这个时候，你可能想知道，“我们是否有可能进一步降低这个成本？”好消息是，这是可能的，只要我们能使用正确的一套工具、服务和框架设计出更优的架构。
- en: We will start the hands-on section of this chapter by training a **PyTorch**
    model inside a DLC. This model will be uploaded to a custom container image that
    will then be used to create an **AWS Lambda** function. After that, we will create
    an **API Gateway** HTTP API that accepts an HTTP request and triggers the AWS
    Lambda function with an event containing the input request data. The AWS Lambda
    function will then load the model we trained to perform ML predictions.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从这个章节的动手实践部分开始，在一个 DLC 中训练一个 **PyTorch** 模型。这个模型将被上传到一个自定义容器镜像中，然后用于创建一个
    **AWS Lambda** 函数。之后，我们将创建一个 **API Gateway** HTTP API，它接受一个 HTTP 请求，并使用包含输入请求数据的事件触发
    AWS Lambda 函数。然后，AWS Lambda 函数将加载我们训练的模型以执行机器学习预测。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Getting started with AWS Deep Learning Containers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始使用 AWS 深度学习容器
- en: Essential prerequisites
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必要的先决条件
- en: Using AWS Deep Learning Containers to train an ML model
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 AWS 深度学习容器训练机器学习模型
- en: Serverless ML deployment with Lambda’s container image support
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Lambda 的容器镜像支持进行无服务器机器学习部署
- en: While working on the hands-on solutions of this chapter, we will cover several
    *serverless* services such as AWS Lambda and Amazon API Gateway, which allow us
    to run applications without having to manage the infrastructure ourselves. At
    the same time, the cost of using these resources scales automatically, depending
    on the usage of these resources. In a typical setup, we may have an EC2 instance
    running 24/7 where we will be paying for the running resource, regardless of whether
    it is being used. With AWS Lambda, we only need to pay when the function code
    runs. If it only runs for a few seconds per month, then we may pay close to zero
    for that month!
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理本章的动手解决方案时，我们将涵盖几个 *无服务器* 服务，如 AWS Lambda 和 Amazon API Gateway，这些服务允许我们运行应用程序而无需自己管理基础设施。同时，使用这些资源的成本会根据这些资源的使用情况自动缩放。在一个典型的设置中，我们可能有一个
    24/7 运行的 EC2 实例，我们将为运行资源付费，无论是否在使用。使用 AWS Lambda，我们只有在函数代码运行时才需要付费。如果它每月只运行几秒钟，那么我们可能那个月的费用几乎为零！
- en: With these points in mind, let’s begin this chapter with a quick introduction
    to how AWS DLCs work.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑这些要点的基础上，让我们从本章的快速介绍开始，了解 AWS DLC 的工作原理。
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Before we start, we must have the following ready:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，我们必须准备好以下内容：
- en: A web browser (preferably Chrome or Firefox)
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个网络浏览器（最好是 Chrome 或 Firefox）
- en: Access to the AWS account that was used in the first two chapters of this book
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问本书前两章中使用的 AWS 账户
- en: Access to the Cloud9 environment that you prepared in the *Creating your Cloud9
    environment* and *Increasing the Cloud9 storage* sections of [*Chapter 1*](B18638_01.xhtml#_idTextAnchor017),
    *Introduction to ML Engineering on AWS*
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问您在 [*第 1 章*](B18638_01.xhtml#_idTextAnchor017) 的 *创建您的 Cloud9 环境* 和 *增加 Cloud9
    存储空间* 部分中准备好的 Cloud9 环境
- en: The Jupyter notebooks, source code, and other files used for each chapter are
    available in this book’s GitHub repository at https://github.com/PacktPublishing/Machine-Learning-Engineering-on-AWS.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 每个章节使用的 Jupyter 笔记本、源代码和其他文件都可在本书的 GitHub 仓库中找到，网址为 https://github.com/PacktPublishing/Machine-Learning-Engineering-on-AWS。
- en: Important Note
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: It is recommended that you use an IAM user with limited permissions instead
    of the root account when running the examples in this book. We will discuss this,
    along with other security best practices, in detail in [*Chapter 9*](B18638_09.xhtml#_idTextAnchor187),
    *Security, Governance, and Compliance Strategies*. If you are just starting using
    AWS, you may proceed with using the root account in the meantime.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 建议在运行本书中的示例时，使用具有有限权限的 IAM 用户而不是根账户。我们将在 [*第 9 章*](B18638_09.xhtml#_idTextAnchor187)
    中详细讨论这一点，*安全、治理和合规策略*。如果您刚开始使用 AWS，您可以在同时使用根账户。
- en: Getting started with AWS Deep Learning Containers
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用 AWS 深度学习容器
- en: Containers allow developers, engineers, and system administrators to run processes,
    scripts, and applications inside consistent isolated environments. This consistency
    is guaranteed since these containers are launched from container images, similar
    to how EC2 instances are launched from **Amazon Machine Images** (**AMIs**).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 容器允许开发人员、工程师和系统管理员在一致且隔离的环境中运行进程、脚本和应用程序。这种一致性得到保证，因为这些容器是从容器镜像启动的，类似于 EC2 实例是从
    **Amazon Machine Images**（**AMIs**）启动的。
- en: 'It is important to note that we can run different isolated containers at the
    same time inside an instance. This allows engineering teams to make the most of
    the computing power available to the existing instances and run different types
    of processes and workloads, similar to what we have in the following diagram:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，我们可以在一个实例内同时运行不同的隔离容器。这使得工程团队能够充分利用现有实例的计算能力，并运行不同类型的过程和工作负载，类似于以下图所示：
- en: '![Figure 3.1 – Running multiple containers inside a single EC2 instance ](img/B18638_03_001.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.1 – 在单个 EC2 实例内运行多个容器](img/B18638_03_001.jpg)'
- en: Figure 3.1 – Running multiple containers inside a single EC2 instance
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1 – 在单个 EC2 实例内运行多个容器
- en: One of the most popular container management solutions available is **Docker**.
    It is an open source containerization platform that allows developers and engineers
    to easily build, run, and manage containers. It involves the usage of a **Dockerfile**,
    which is a text document containing instructions on how to build container images.
    These container images are then managed and stored inside container registries
    so that they can be used at a later time.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的最受欢迎的容器管理解决方案之一是 **Docker**。它是一个开源的容器化平台，允许开发者和工程师轻松地构建、运行和管理容器。它涉及使用 **Dockerfile**，这是一个包含如何构建容器镜像的指令的文本文件。然后，这些容器镜像被管理和存储在容器注册库中，以便可以在以后使用。
- en: Note
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Docker images are used to create containers. Docker images are like ZIP files
    that package everything needed to run an application. When a Docker container
    is run from a container image (using the `docker run` command), the container
    acts like a virtual machine, with its environment isolated and separate from the
    server where the container is running.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 镜像用于创建容器。Docker 镜像类似于 ZIP 文件，它打包了运行应用程序所需的一切。当从容器镜像（使用 `docker run` 命令）运行
    Docker 容器时，容器就像一个虚拟机，其环境是隔离的，并且与运行容器的服务器分开。
- en: Now that we have a better idea of how containers and container images work,
    let’s proceed by discussing what DLCs are and how these are used to speed up the
    training and deployment of ML models. One of the key benefits when using AWS DLCs
    is that most of the relevant ML packages, frameworks, and libraries are installed
    in the container images already. This means that ML engineers and data scientists
    no longer need to worry about installing and configuring the ML frameworks, libraries,
    and packages. This allows them to proceed with preparing the custom scripts used
    for training and deploying their deep learning models.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经对容器和容器镜像有了更好的了解，那么让我们继续讨论 DLC（深度学习容器）是什么以及它们是如何被用来加速机器学习模型的训练和部署的。使用 AWS
    DLC 的一个关键好处是，大多数相关的 ML（机器学习）包、框架和库已经预装在容器镜像中。这意味着 ML 工程师和数据科学家不再需要担心安装和配置 ML 框架、库和包。这使他们能够继续准备用于训练和部署他们的深度学习模型的定制脚本。
- en: Since DLC images are simply prebuilt container images, these can be used in
    any AWS service where containers and container images can be used. These AWS services
    include **Amazon EC2**, **Amazon Elastic Container Service** (**ECS**), **Amazon
    Elastic Kubernetes Service (EKS)**, **Amazon SageMaker**, **AWS CodeBuild**, **AWS
    Lambda**, and more.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 DLC 镜像是简单的预构建容器镜像，因此它们可以在任何可以使用容器和容器镜像的 AWS 服务中使用。这些 AWS 服务包括 **Amazon EC2**、**Amazon
    Elastic Container Service**（**ECS**）、**Amazon Elastic Kubernetes Service (EKS**)、**Amazon
    SageMaker**、**AWS CodeBuild**、**AWS Lambda** 以及更多。
- en: With these in mind, let’s proceed with training and deploying a deep learning
    model using AWS Deep Learning Containers!
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这些，让我们继续使用 AWS 深度学习容器来训练和部署深度学习模型！
- en: Essential prerequisites
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 必要的先决条件
- en: 'In this section, we will ensure that the following prerequisites are ready
    before proceeding with the training steps:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将在进行训练步骤之前确保以下先决条件已准备就绪：
- en: We will prepare a Cloud9 environment and ensure it has been set up so that we
    can train the model and build the custom container image.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将准备一个 Cloud9 环境，并确保它已经设置好，以便我们可以训练模型并构建自定义容器镜像。
- en: We will prepare a training dataset that will be used when training the deep
    learning model.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将准备一个训练数据集，该数据集将在训练深度学习模型时使用。
- en: Preparing the Cloud9 environment
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备 Cloud9 环境
- en: 'In the first part of this chapter, we will run our Deep Learning Container
    inside an EC2 instance, similar to what’s shown in the following diagram:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的第一部分，我们将在一个 EC2 实例内部运行我们的深度学习容器，类似于以下图中所示：
- en: '![Figure 3.2 – Running a Deep Learning Container inside an EC2 instance ](img/B18638_03_002.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图3.2 – 在EC2实例内运行深度学习容器](img/B18638_03_002.jpg)'
- en: Figure 3.2 – Running a Deep Learning Container inside an EC2 instance
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 – 在EC2实例内运行深度学习容器
- en: This container will serve as the environment where the ML model is trained using
    a script that utilizes the **PyTorch** framework. Even if PyTorch is not installed
    in the EC2 instance, the training script will still run successfully since it
    will be executed inside the container environment where PyTorch is preinstalled.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这个容器将作为使用**PyTorch**框架的脚本训练机器学习模型的环境。即使PyTorch没有安装在EC2实例上，训练脚本仍然可以成功运行，因为它将在预安装了PyTorch的容器环境中执行。
- en: Note
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you are wondering what PyTorch is, it is one of the most popular open source
    ML frameworks available. You may check out [https://pytorch.org/](https://pytorch.org/)
    for more information.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道PyTorch是什么，它是最受欢迎的开源机器学习框架之一。你可以访问[https://pytorch.org/](https://pytorch.org/)获取更多信息。
- en: 'In the next set of steps, we will make sure that our Cloud9 environment is
    ready:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的步骤中，我们将确保我们的Cloud9环境已准备好：
- en: 'Type `cloud9` in the search bar. Select **Cloud9** from the list of results:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在搜索栏中输入`cloud9`。从结果列表中选择**Cloud9**：
- en: '![Figure 3.3 – Navigating to the Cloud9 console ](img/B18638_03_003.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图3.3 – 导航到Cloud9控制台](img/B18638_03_003.jpg)'
- en: Figure 3.3 – Navigating to the Cloud9 console
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3 – 导航到Cloud9控制台
- en: Here, we can see that the region is currently set to `us-west-2`). Make sure
    that you change this to where you created the Cloud9 instance in [*Chapter 1*](B18638_01.xhtml#_idTextAnchor017),
    *Introduction to ML Engineering on AWS*.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们可以看到当前区域设置为`us-west-2`)。请确保将其更改为你在[*第一章*](B18638_01.xhtml#_idTextAnchor017)“AWS机器学习工程简介”中创建Cloud9实例的位置。
- en: Open the Cloud9 environment you created in the *Creating your Cloud9 environment*
    section of [*Chapter 1*](B18638_01.xhtml#_idTextAnchor017), *Introduction to ML
    Engineering on AWS*, by clicking the `us-west-2`) where the Cloud9 environment
    was created in [*Chapter 1*](B18638_01.xhtml#_idTextAnchor017), *Introduction
    to ML Engineering on AWS*.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击`us-west-2`)，打开你在[*第一章*](B18638_01.xhtml#_idTextAnchor017)“AWS机器学习工程简介”的*创建你的Cloud9环境*部分中创建的Cloud9环境。
- en: Note
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you skipped the first chapter, make sure that you complete the *Creating
    your Cloud9 environment* and *Increasing the Cloud9 storage* sections of that
    chapter before proceeding.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你跳过了第一章，确保在继续之前完成该章节的*创建你的Cloud9环境*和*增加Cloud9存储*部分。
- en: 'In the Terminal of the Cloud9 environment, run the following `bash` commands
    to create the `ch03` directory:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Cloud9环境的终端中，运行以下`bash`命令以创建`ch03`目录：
- en: '[PRE0]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We will use this directory as our current working directory for this chapter.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这个目录作为本章的当前工作目录。
- en: Now that we have our Cloud9 environment ready, let’s proceed with downloading
    the training dataset so that we can train our deep learning model.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了Cloud9环境，接下来让我们开始下载训练数据集，以便我们可以训练我们的深度学习模型。
- en: Downloading the sample dataset
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 下载示例数据集
- en: The training dataset we will use in this chapter is the same dataset we used
    in [*Chapter 2*](B18638_02.xhtml#_idTextAnchor041), *Deep Learning AMIs*. It has
    two columns that correspond to the continuous *x* and *y* variables. Later in
    this chapter, we will also generate a regression model using this dataset. The
    regression model is expected to accept an input *x* value and return a predicted
    *y* value.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们将使用的训练数据集与我们在[*第二章*](B18638_02.xhtml#_idTextAnchor041)“深度学习AMIs”中使用的相同数据集。它包含两列，分别对应连续的*x*和*y*变量。在本章的后面部分，我们还将使用这个数据集生成一个回归模型。这个回归模型预计将接受一个输入*x*值并返回一个预测的*y*值。
- en: 'In the next set of steps, we will download the training dataset into our Cloud9
    environment:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的步骤中，我们将下载训练数据集到我们的Cloud9环境中：
- en: 'Run the following command to create the `data` directory:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令以创建`data`目录：
- en: '[PRE2]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, let’s download the training data CSV file by using the `wget` command:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们使用`wget`命令下载训练数据CSV文件：
- en: '[PRE3]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Use the `head` command to inspect what our training data looks like:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`head`命令检查我们的训练数据看起来像什么：
- en: '[PRE4]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This should give us rows of *(x,y) pairs*, similar to what is shown in the
    following screenshot:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会给我们提供*(x,y)*对，类似于以下截图所示：
- en: '![Figure 3.4 – The first few rows of the training_data.csv file ](img/B18638_03_004.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图3.4 – training_data.csv文件的前几行](img/B18638_03_004.jpg)'
- en: Figure 3.4 – The first few rows of the training_data.csv file
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4 – 训练数据文件training_data.csv的前几行
- en: Since we started this section inside the `ch03` directory, it is important to
    note that the `training_data.csv` file should be inside the `ch03/data` directory.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们是在`ch03`目录内开始这一节的，因此需要注意的是`training_data.csv`文件应该位于`ch03/data`目录内。
- en: Now that we have the prerequisites ready, we can proceed with the training step.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了先决条件，我们可以继续进行训练步骤。
- en: Using AWS Deep Learning Containers to train an ML model
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用AWS深度学习容器训练ML模型
- en: 'At this point, you might be wondering what makes a deep learning model different
    from other ML models. Deep learning models are networks of interconnected nodes
    that communicate with each other, similar to how networks of neurons communicate
    in a human brain. These models make use of multiple layers in the network, similar
    to what we have in the following diagram. Having more layers and more neurons
    per layer gives deep learning models the ability to process and learn complex
    non-linear patterns and relationships:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，您可能想知道是什么让深度学习模型与其他ML模型不同。深度学习模型是由相互连接的节点组成的网络，它们彼此通信，类似于人类大脑中神经元网络的通信方式。这些模型在网络中使用了多个层，类似于以下图示。更多的层和每层的更多神经元赋予了深度学习模型处理和学习复杂非线性模式和关系的能力：
- en: '![Figure 3.5 – Deep learning model ](img/B18638_03_005.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图3.5 – 深度学习模型](img/B18638_03_005.jpg)'
- en: Figure 3.5 – Deep learning model
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5 – 深度学习模型
- en: 'Deep learning has several practical applications in **natural language processing**
    (**NLP**), **computer vision**, and **fraud detection**. In addition to these,
    here are some of its other applications and examples as well:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 深度学习在**自然语言处理**（**NLP**）、**计算机视觉**和**欺诈检测**等领域有几种实际应用。除此之外，这里还有一些其他的应用和示例：
- en: '**Generative Adversarial Networks** (**GANs**): These can be used to generate
    realistic examples from the original dataset, similar to what we had in the *Generating
    a synthetic dataset using a deep learning model* section of [*Chapter 1*](B18638_01.xhtml#_idTextAnchor017),
    *Introduction to ML Engineering on AWS*.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生成对抗网络**（**GANs**）：这些可以用来从原始数据集中生成真实示例，类似于我们在[*第1章*](B18638_01.xhtml#_idTextAnchor017)“在AWS上介绍机器学习工程”中“使用深度学习模型生成合成数据集”部分所做的那样。'
- en: '**Deep Reinforcement Learning**: This utilizes deep neural networks and reinforcement
    learning techniques to solve complex problems in industries such as robotics and
    gaming.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**深度强化学习**：这利用深度神经网络和强化学习技术来解决机器人、游戏等行业的复杂问题。'
- en: These past couple of years, the training and deployment of deep learning models
    have been greatly simplified with deep learning frameworks such as **PyTorch**,
    **TensorFlow**, and **MXNet**. AWS DLCs speed things up further by providing container
    images that already come preinstalled with everything you need to run these ML
    frameworks.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几年中，随着**PyTorch**、**TensorFlow**和**MXNet**等深度学习框架的出现，深度学习模型的训练和部署过程得到了极大的简化。AWS
    DLCs通过提供预装了运行这些ML框架所需所有内容的容器镜像，进一步加快了这一过程。
- en: Note
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can view the list of available DLC images here: [https://github.com/aws/deep-learning-containers/blob/master/available_images.md](https://github.com/aws/deep-learning-containers/blob/master/available_images.md).
    Note that these container images are categorized by (1) the installed ML framework
    (**PyTorch**, **TensorFlow**, or **MXNet**), (2) the job type (*training* or *inference*),
    and (3) the installed Python version.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处查看可用的DLC镜像列表：[https://github.com/aws/deep-learning-containers/blob/master/available_images.md](https://github.com/aws/deep-learning-containers/blob/master/available_images.md)。请注意，这些容器镜像根据以下类别进行分类：（1）安装的ML框架（**PyTorch**、**TensorFlow**或**MXNet**），（2）作业类型（*训练*或*推理*），以及（3）安装的Python版本。
- en: 'In the next set of steps, we will use the DLC image that’s been optimized to
    train PyTorch models:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的步骤中，我们将使用针对训练PyTorch模型进行优化的DLC镜像：
- en: 'Let’s download the `train.py` file by running the following command:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令下载`train.py`文件：
- en: '[PRE5]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Before we proceed, let’s check the contents of the `train.py` file by opening
    it from the `File` tree:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，让我们通过从`File`树中打开它来检查`train.py`文件的内容：
- en: '![Figure 3.6 – Opening the train.py file from the File tree ](img/B18638_03_006.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图3.6 – 从文件树中打开train.py文件](img/B18638_03_006.jpg)'
- en: Figure 3.6 – Opening the train.py file from the File tree
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6 – 从文件树中打开train.py文件
- en: 'We should see a script that makes use of the training data stored in the `data`
    directory to train a deep learning model. This model gets saved in the `model`
    directory after the training step has been completed:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该看到一个脚本，它使用存储在 `data` 目录中的训练数据来训练一个深度学习模型。在训练步骤完成后，该模型被保存在 `model` 目录中：
- en: '![Figure 3.7 – The main() function of the train.py script file ](img/B18638_03_007.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.7 – train.py 脚本文件的 main() 函数](img/B18638_03_007.jpg)'
- en: Figure 3.7 – The main() function of the train.py script file
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.7 – train.py 脚本文件的 main() 函数
- en: 'Here, we can see that the `main()` function of our `train.py` script performs
    the following operations:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们的 `train.py` 脚本的 `main()` 函数执行以下操作：
- en: (1) defines the model using the `prepare_model()` function
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (1) 使用 `prepare_model()` 函数定义模型
- en: (2) loads the training data using the `load_data()` function
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (2) 使用 `load_data()` 函数加载训练数据
- en: (3) performs the training step using the `fit()` method
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (3) 使用 `fit()` 方法执行训练步骤
- en: (4) saves the model artifacts using the `torch.save()` method
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (4) 使用 `torch.save()` 方法保存模型工件
- en: The last block of code in the preceding screenshot simply runs the `main()`
    function if `train.py` is being executed directly as a script.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中的最后一块代码简单地运行了 `main()` 函数，如果 `train.py` 被直接作为脚本执行。
- en: Note
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the complete `train.py` script here: [https://github.com/PacktPublishing/Machine-Learning-Engineering-on-AWS/blob/main/chapter03/train.py](https://github.com/PacktPublishing/Machine-Learning-Engineering-on-AWS/blob/main/chapter03/train.py).'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到完整的 `train.py` 脚本：[https://github.com/PacktPublishing/Machine-Learning-Engineering-on-AWS/blob/main/chapter03/train.py](https://github.com/PacktPublishing/Machine-Learning-Engineering-on-AWS/blob/main/chapter03/train.py)。
- en: 'Next, create the `model` directory using the `mkdir` command:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用 `mkdir` 命令创建 `model` 目录：
- en: '[PRE6]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Later, we will see that the model output gets saved inside this directory.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将看到模型输出被保存在这个目录中。
- en: 'Install the `tree` utility by running the following command:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令安装 `tree` 工具：
- en: '[PRE7]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let’s use the `tree` utility we just installed:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用我们刚刚安装的 `tree` 工具：
- en: '[PRE8]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This should yield a tree-like structure, similar to what we have in the following
    screenshot:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会产生一个类似以下截图中的树状结构：
- en: '![Figure 3.8 – Results after using the tree command ](img/B18638_03_008.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.8 – 使用 tree 命令后的结果](img/B18638_03_008.jpg)'
- en: Figure 3.8 – Results after using the tree command
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.8 – 使用 tree 命令后的结果
- en: It is important to note that the `train.py` script is in the `ch03` directory,
    which is where the `data` and `model` directories are located as well.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，`train.py` 脚本位于 `ch03` 目录中，`data` 和 `model` 目录也位于此处。
- en: 'Download the `train.sh` file using the `wget` command:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `wget` 命令下载 `train.sh` 文件：
- en: '[PRE9]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If we check the contents of the `train.sh` file, we should see the following
    lines:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们检查 `train.sh` 文件的内容，我们应该看到以下几行：
- en: '[PRE10]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `train.sh` script first authenticates with **Amazon Elastic Container Registry**
    (a fully managed Docker container registry where we can store our container images)
    so that we can successfully download the training container image. This container
    image has *PyTorch 1.8.1* and *Python 3.6* preinstalled already.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`train.sh` 脚本首先与 **Amazon Elastic Container Registry**（一个完全管理的 Docker 容器注册表，我们可以在这里存储我们的容器镜像）进行身份验证，以便我们能够成功下载训练容器镜像。这个容器镜像已经预装了
    *PyTorch 1.8.1* 和 *Python 3.6*。'
- en: Important Note
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The code in the `train.sh` script assumes that we will run the training experiment
    inside an EC2 instance (where the Cloud9 environment is running) in the *Oregon*
    (`us-west-2`) region. Make sure that you replace `us-west-2` with the appropriate
    region code. For more information on this topic, feel free to check out https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.xhtml.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`train.sh` 脚本中的代码假设我们将在运行 Cloud9 环境的 EC2 实例（位于 *俄勒冈* (`us-west-2`) 区域）中运行训练实验。请确保将
    `us-west-2` 替换为适当的区域代码。有关此主题的更多信息，请随时查看 https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.xhtml。'
- en: The `docker run` command first downloads the specified container image and creates
    a running container process using that image. After that, the contents of the
    current working directory are “copied” to the container after the current working
    directory (`ch03`) is mounted to the container using the `-v` flag when running
    the `docker run` command. We then set the working directory to where our files
    were mounted (`/env`) inside the container using the `-w` flag. Once all the steps
    are complete, the `train.py` script is executed inside the environment of the
    running container.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker run` 命令首先下载指定的容器镜像，并使用该镜像创建一个运行中的容器进程。之后，当前工作目录的内容在当前工作目录（`ch03`）通过运行
    `docker run` 命令时使用 `-v` 标志挂载到容器中后会被“复制”到容器中。然后我们使用 `-w` 标志将工作目录设置到容器内部我们的文件被挂载的位置（`/env`）。一旦所有步骤完成，`train.py`
    脚本将在运行中的容器环境中执行。'
- en: Note
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Check out [https://docs.docker.com/engine/reference/run/](https://docs.docker.com/engine/reference/run/)
    for more information on how to use the `docker run` command.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 查阅 [https://docs.docker.com/engine/reference/run/](https://docs.docker.com/engine/reference/run/)
    获取更多关于如何使用 `docker run` 命令的信息。
- en: 'Now that we have a better idea of what will happen when we execute the `train.sh`
    file, let’s run it using the following commands:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们对执行 `train.sh` 文件时会发生什么有了更好的了解，让我们使用以下命令运行它：
- en: '[PRE11]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This should yield a set of logs, similar to the following:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会产生一组日志，类似于以下内容：
- en: '![Figure 3.9 – Logs generated while running the train.sh script ](img/B18638_03_009.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.9 – 运行 train.sh 脚本时生成的日志](img/B18638_03_009.jpg)'
- en: Figure 3.9 – Logs generated while running the train.sh script
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.9 – 运行 train.sh 脚本时生成的日志
- en: Here, the `train.sh` script ran a container that invoked the `train.py` (Python)
    script to train the deep learning model. In the preceding screenshot, we can see
    the logs that were generated by the `train.py` script as it iteratively updates
    the weights of the neural network to improve the quality of the output model (that
    is, reducing the loss per iteration so that we can minimize the error). It is
    important to note that this `train.py` script makes use of **PyTorch** to prepare
    and train a sample deep learning model using the data provided.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`train.sh` 脚本运行了一个容器，该容器调用了 `train.py`（Python）脚本来训练深度学习模型。在前面的屏幕截图中，我们可以看到
    `train.py` 脚本在迭代更新神经网络权重以提高输出模型的质量（即减少每次迭代的损失，以便我们可以最小化错误）时生成的日志。需要注意的是，这个 `train.py`
    脚本使用了 **PyTorch** 准备和训练一个使用提供的数据的示例深度学习模型。
- en: This is the reason why we’re using a deep learning container image that has
    *PyTorch 1.8.1* and *Python 3.6* preinstalled already.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们为什么使用已经预装了 *PyTorch 1.8.1* 和 *Python 3.6* 的深度学习容器镜像的原因。
- en: Note
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This step may take 5 to 10 minutes to complete. Feel free to get a cup of coffee
    or tea while waiting!
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这一步可能需要 5 到 10 分钟才能完成。在等待的时候，不妨来一杯咖啡或茶！
- en: 'After the training script has finished running, let’s check whether the `model`
    directory contains a `model.pth` file using the `tree` command:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 训练脚本运行完成后，让我们使用 `tree` 命令检查 `model` 目录是否包含一个 `model.pth` 文件：
- en: '[PRE13]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This should yield a tree-like structure, similar to the following:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会产生一个类似以下的树状结构：
- en: '![Figure 3.10 – Verifying whether the model was saved successfully ](img/B18638_03_010.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.10 – 验证模型是否成功保存](img/B18638_03_010.jpg)'
- en: Figure 3.10 – Verifying whether the model was saved successfully
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.10 – 验证模型是否成功保存
- en: This `model.pth` file contains the serialized model we have trained using the
    `train.py` script. This file was created using the `torch.save()` method after
    the model training step was completed. Feel free to check out [https://pytorch.org/tutorials/beginner/saving_loading_models.xhtml](https://pytorch.org/tutorials/beginner/saving_loading_models.xhtml)
    for more information.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `model.pth` 文件包含我们使用 `train.py` 脚本训练的序列化模型。该文件是在模型训练步骤完成后使用 `torch.save()`
    方法创建的。您可以查阅 [https://pytorch.org/tutorials/beginner/saving_loading_models.xhtml](https://pytorch.org/tutorials/beginner/saving_loading_models.xhtml)
    获取更多信息。
- en: Note
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The generated `model.pth` file allows us to use the parameters of the model
    to make predictions (after the model has been loaded from the file). For example,
    if our model makes use of an equation such as *ax^2 + bxy + cy^2 = 0*, the *a*,
    *b*, and *c* values are the model parameters. With this, if we have *x* (which
    is the independent variable), we can easily compute the value of *y*. That said,
    we can say that determining *a*, *b*, and *c* is the task of the training phase,
    and that determining *y* given *x* (and given *a*, *b*, and *c*) is the task of
    the inference phase. By loading the `model.pth` file, we can proceed with the
    inference phase and compute for the predicted value of *y* given an input *x*
    value.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的 `model.pth` 文件允许我们使用模型的参数进行预测（在模型从文件加载后）。例如，如果我们的模型使用一个如 *ax^2 + bxy + cy^2
    = 0* 的方程，那么 *a*、*b* 和 *c* 的值是模型参数。有了这个，如果我们有 *x*（这是自变量），我们可以轻松地计算 *y* 的值。也就是说，我们可以认为确定
    *a*、*b* 和 *c* 是训练阶段的任务，而确定给定 *x*（以及给定 *a*、*b* 和 *c*）的 *y* 是推理阶段的任务。通过加载 `model.pth`
    文件，我们可以进入推理阶段，并计算给定输入 *x* 值的预测 *y* 值。
- en: Wasn’t that easy? With the training step complete, we will proceed with the
    deployment step in the next section.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 难道不是很简单吗？训练步骤完成后，我们将在下一节进行部署步骤。
- en: Serverless ML deployment with Lambda’s container image support
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Lambda 的容器镜像支持进行无服务器 ML 部署
- en: 'Now that we have the `model.pth` file, what do we do with it? The answer is
    simple: we will deploy this model in a serverless API using an **AWS Lambda**
    function and an **Amazon API Gateway** HTTP API, as shown in the following diagram:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了 `model.pth` 文件，我们该如何处理它？答案是简单的：我们将使用一个 **AWS Lambda** 函数和一个 **Amazon
    API Gateway** HTTP API 在无服务器 API 中部署这个模型，如下面的图所示：
- en: '![Figure 3.11 – Serverless ML deployment with an API Gateway and AWS Lambda
    ](img/B18638_03_011.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.11 – 使用 API Gateway 和 AWS Lambda 的无服务器 ML 部署](img/B18638_03_011.jpg)'
- en: Figure 3.11 – Serverless ML deployment with an API Gateway and AWS Lambda
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.11 – 使用 API Gateway 和 AWS Lambda 的无服务器 ML 部署
- en: As we can see, the HTTP API should be able to accept *GET* requests from “clients”
    such as mobile apps and other web servers that interface with end users. These
    requests then get passed to the AWS Lambda function as input event data. The Lambda
    function then loads the model from the `model.pth` file and uses it to compute
    the predicted *y* value using the *x* value from the input event data.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，HTTP API 应该能够接受来自“客户端”如移动应用和其他与最终用户交互的 Web 服务器的 **GET** 请求。然后这些请求作为输入事件数据传递给
    AWS Lambda 函数。Lambda 函数随后从 `model.pth` 文件中加载模型，并使用它根据输入事件数据中的 *x* 值计算预测的 *y* 值。
- en: Building the custom container image
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建自定义容器镜像
- en: Our AWS Lambda function code needs to utilize **PyTorch** functions and utilities
    to load the model. To get this setup working properly, we will build a custom
    container image from an existing DLC image optimized for **PyTorch** inference
    requirements. This custom container image will be used for the environment where
    our AWS Lambda function code will run through AWS Lambda’s container image support.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 AWS Lambda 函数代码需要利用 **PyTorch** 函数和实用工具来加载模型。为了使这个设置正常工作，我们将从现有的针对 **PyTorch**
    推理需求优化的 DLC 镜像构建一个自定义容器镜像。这个自定义容器镜像将用于我们的 AWS Lambda 函数代码将通过 AWS Lambda 的容器镜像支持运行的环境。
- en: Note
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For more information on AWS Lambda’s container image support, check out https://aws.amazon.com/blogs/aws/new-for-aws-lambda-container-image-support/.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 想了解更多关于 AWS Lambda 的容器镜像支持信息，请查看 https://aws.amazon.com/blogs/aws/new-for-aws-lambda-container-image-support/.
- en: It is important to note that a variety of DLC images are available for us to
    choose from. These images are categorized based on their job type (*training versus
    inference*), installed framework (*PyTorch versus TensorFlow versus MXNet versus
    other options*), and installed Python version (*3.8 versus 3.7 versus 3.6 versus
    other options*). Since we are planning to use a container where a **PyTorch**
    model can be loaded and used to perform predictions, we will be choosing a **PyTorch**
    DLC *optimized for inference* as the base image when building the custom Docker
    image.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，我们有各种 DLC 镜像可供选择。这些镜像根据它们的作业类型（*训练与推理*）、安装的框架（*PyTorch 与 TensorFlow
    与 MXNet 与其他选项*）和安装的 Python 版本（*3.8 与 3.7 与 3.6 与其他选项*）进行分类。由于我们计划在一个可以加载并使用 **PyTorch**
    模型进行预测的容器中，因此当构建自定义 Docker 镜像时，我们将选择一个针对 **PyTorch** 推理优化的 DLC 镜像作为基础镜像。
- en: 'The following steps focus on building a custom container image from an existing
    DLC image:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤专注于从现有的 DLC 镜像构建一个自定义容器镜像：
- en: Make sure you are inside the `ch03` directory by running the `pwd` command in
    the Terminal.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你已经在`ch03`目录内，通过在终端中运行`pwd`命令来检查。
- en: 'Next, run the following commands to download `dlclambda.zip` and extract its
    contents inside the `ch03` directory:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，运行以下命令以下载`dlclambda.zip`并将其内容提取到`ch03`目录中：
- en: '[PRE14]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This ZIP file contains the files and scripts needed to build the custom container
    image.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 此ZIP文件包含构建自定义容器镜像所需的文件和脚本。
- en: 'Use the `tree` command to see what the `ch03` directory looks like:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`tree`命令查看`ch03`目录的结构：
- en: '[PRE16]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This should yield a tree-like structure, similar to the following:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会生成一个类似以下的树状结构：
- en: '![Figure 3.12 – Results after running the tree command ](img/B18638_03_012.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![图3.12 – 执行tree命令后的结果](img/B18638_03_012.jpg)'
- en: Figure 3.12 – Results after running the tree command
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.12 – 执行tree命令后的结果
- en: 'Here, several new files have been extracted from the `dlclambda.zip` file:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，从`dlclambda.zip`文件中提取了几个新文件：
- en: '`Dockerfile`'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Dockerfile`'
- en: '`app/app.py`'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app/app.py`'
- en: '`build.sh`'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`build.sh`'
- en: '`download-rie.sh`'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`download-rie.sh`'
- en: '`invoke.sh`'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`invoke.sh`'
- en: '`run.sh`'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`run.sh`'
- en: We will discuss each of these files in detail as we go through the steps in
    this chapter.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章的步骤中详细讨论这些文件。
- en: 'In the File tree, locate and open the `app.py` file located inside the `ch03/app`
    directory:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件树中，定位并打开位于`ch03/app`目录内的`app.py`文件：
- en: '![Figure 3.13 – app.py Lambda handler implementation ](img/B18638_03_013.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图3.13 – app.py Lambda处理程序实现](img/B18638_03_013.jpg)'
- en: Figure 3.13 – app.py Lambda handler implementation
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.13 – app.py Lambda处理程序实现
- en: This file contains the AWS Lambda handler implementation code, which (1) loads
    the model, (2) extracts the input *x* value from the event data, (3) computes
    for the predicted *y* value using the model, and (4) returns the output *y* value
    as a string.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件包含AWS Lambda处理程序实现代码，该代码（1）加载模型，（2）从事件数据中提取输入*x*值，（3）使用模型计算预测*y*值，（4）以字符串形式返回输出*y*值。
- en: In the *Completing and testing the serverless API setup* section near the end
    of this chapter, we will set up an HTTP API that accepts a value for `x` via the
    URL query string (for example, `https://<URL>/predict?x=42`). Once the request
    comes in, Lambda will call a handler function that contains the code to handle
    the incoming request. It will load the deep learning model and use it to predict
    the value of `y` using the value of *x*.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章末尾附近的*完成和测试无服务器API设置*部分，我们将设置一个HTTP API，该API通过URL查询字符串接受`x`的值（例如，`https://<URL>/predict?x=42`）。一旦请求到来，Lambda将调用一个包含处理传入请求的代码的处理程序函数。它将加载深度学习模型，并使用它来预测`y`的值，使用*x*的值。
- en: Note
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the complete `app/app.py` file here: [https://github.com/PacktPublishing/Machine-Learning-Engineering-on-AWS/blob/main/chapter03/app/app.py](https://github.com/PacktPublishing/Machine-Learning-Engineering-on-AWS/blob/main/chapter03/app/app.p).'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到完整的`app/app.py`文件：[https://github.com/PacktPublishing/Machine-Learning-Engineering-on-AWS/blob/main/chapter03/app/app.py](https://github.com/PacktPublishing/Machine-Learning-Engineering-on-AWS/blob/main/chapter03/app/app.p).
- en: 'Copy the `model.pth` file from the `model` directory into the `app/model` directory
    using the `cp` command:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`cp`命令将`model.pth`文件从`model`目录复制到`app/model`目录：
- en: '[PRE17]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Important Note
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'Make sure that you only load ML models from trusted sources. Inside `app/app.py`,
    we are loading the model using `torch.load()`, which can be exploited by attackers
    with a model containing a malicious payload. Attackers can easily prepare a model
    (with a malicious payload) that, when loaded, would give the attacker access to
    your server or resource running the ML scripts (for example, through a **reverse
    shell**). For more information on this topic, you may check the author’s talk
    on how to hack and secure ML environments and systems: [https://speakerdeck.com/arvslat/pycon-apac-2022-hacking-and-securing-machine-learning-environments-and-systems?slide=8](https://speakerdeck.com/arvslat/pycon-apac-2022-hacking-and-securing-machine-learning-environments-and-systems?slide=8).'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你只从可信来源加载机器学习模型。在`app/app.py`内部，我们使用`torch.load()`加载模型，这可能被包含恶意有效载荷的攻击者利用。攻击者可以轻松准备一个包含恶意有效载荷的模型，当加载时，会给予攻击者访问你的服务器或运行机器学习脚本的资源（例如，通过**反向shell**）。有关此主题的更多信息，你可以查看作者关于如何黑客攻击和确保机器学习环境和系统安全的演讲：[https://speakerdeck.com/arvslat/pycon-apac-2022-hacking-and-securing-machine-learning-environments-and-systems?slide=8](https://speakerdeck.com/arvslat/pycon-apac-2022-hacking-and-securing-machine-learning-environments-and-systems?slide=8).
- en: 'Next, let’s make the `build.sh`, `download-rie.sh`, `invoke.sh`, and `run.sh`
    script files executable using the `chmod` command:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们使用 `chmod` 命令使 `build.sh`、`download-rie.sh`、`invoke.sh` 和 `run.sh` 脚本文件可执行：
- en: '[PRE18]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Before running the `build.sh` command, let’s check the script’s contents using
    the `cat` command:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在运行 `build.sh` 命令之前，让我们使用 `cat` 命令检查脚本的正文：
- en: '[PRE19]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This should yield a single line of code, similar to what we have in the following
    code block:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会产生一行代码，类似于以下代码块中的内容：
- en: '[PRE20]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `docker build` command builds a Docker container image using the instructions
    specified in the Dockerfile in the current directory. *What does this mean?* This
    means that we are building a container image using the relevant files in the directory
    and we’re using the instructions in the Dockerfile to install the necessary packages
    as well. This process is similar to preparing the *DNA* of a container, which
    can be used to create new containers with an environment configured with the desired
    set of tools and packages.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker build` 命令使用当前目录中 Dockerfile 中指定的指令构建 Docker 容器镜像。*这是什么意思？* 这意味着我们正在使用目录中的相关文件构建容器镜像，并且我们正在使用
    Dockerfile 中的指令安装必要的包。这个过程类似于准备容器的 *DNA*，它可以用来创建具有所需工具和包配置的新容器。'
- en: Since we passed `dlclambda` as the argument to the `-t` flag, our custom container
    image will have the `dlclambda:latest` name and tag after the build process completes.
    Note that we can replace the latest tag with a specific version number (for example,
    `dlclambda:3`), but we will stick with using the `latest` tag for now.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将 `dlclambda` 作为 `-t` 标志的参数传递，我们的自定义容器镜像在构建过程完成后将具有 `dlclambda:latest` 的名称和标签。请注意，我们可以用特定的版本号（例如，`dlclambda:3`）替换最新标签，但我们现在将坚持使用
    `latest` 标签。
- en: Note
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For more information on the `docker build` command, feel free to check out https://docs.docker.com/engine/reference/commandline/build/.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如需了解更多关于 `docker build` 命令的信息，请访问 https://docs.docker.com/engine/reference/commandline/build/。
- en: We must check the contents of the Dockerfile as well. What happens when we build
    the container image using this Dockerfile?
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还必须检查 Dockerfile 的内容。当我们使用此 Dockerfile 构建容器镜像时会发生什么？
- en: 'The following DLC image is used as the base image for the two stages of the
    build: `https://763104351884.dkr.ecr.us-west-2.amazonaws.com/pytorch-inference:1.8.1-cpu-py36-ubuntu18.04`.
    It is important to note that this Dockerfile makes use of **multi-stage builds**
    to ensure that the final container does not contain the unused artifacts and files
    from the previous build stages.'
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下 DLC 镜像被用作构建两个阶段的基镜像：`https://763104351884.dkr.ecr.us-west-2.amazonaws.com/pytorch-inference:1.8.1-cpu-py36-ubuntu18.04`。重要的是要注意，此
    Dockerfile 使用 **多阶段构建** 来确保最终容器不包含前一个构建阶段的未使用工件和文件。
- en: Next, the **Lambda Runtime Interface Client** is installed. This allows any
    custom container image to be compatible for use with AWS Lambda.
  id: totrans-189
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，安装 **Lambda 运行时接口客户端**。这允许任何自定义容器镜像与 AWS Lambda 兼容。
- en: The `/function` directory is created. The contents of the `app/` directory (inside
    the `ch03` directory of the Cloud9 environment) are then copied to the `/function`
    directory inside the container.
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建了 `/function` 目录。然后，将 `app/` 目录（位于 Cloud9 环境的 `ch03` 目录内）的内容复制到容器内的 `/function`
    目录。
- en: '`ENTRYPOINT` is set to `/opt/conda/bin/python -m awslambdaric`. `CMD` is then
    set to `app.handler`. The `ENTRYPOINT` and `CMD` instructions define which command
    is executed when the container starts to run.'
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ENTRYPOINT` 设置为 `/opt/conda/bin/python -m awslambdaric`。然后 `CMD` 设置为 `app.handler`。`ENTRYPOINT`
    和 `CMD` 指令定义了容器启动运行时执行的命令。'
- en: Note
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: A `FROM` instructions within a single Dockerfile. Each of these `FROM` instructions
    corresponds to a new build stage where artifacts and files from previous stages
    can be copied. With a multi-stage build, the last build stage produces the final
    image (which ideally does not include the unused files from the previous build
    stages).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 单个 Dockerfile 中的 `FROM` 指令。这些 `FROM` 指令中的每一个都对应一个新的构建阶段，其中可以复制前一个阶段的工件和文件。在多阶段构建中，最后一个构建阶段生成最终镜像（理想情况下不包含前一个构建阶段的未使用文件）。
- en: 'The expected final output would be a container image that can be used to launch
    a container, similar to the following:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 预期的最终输出将是一个可以用来启动容器的容器镜像，类似于以下内容：
- en: '![Figure 3.14 – Lambda Runtime Interface Client ](img/B18638_03_014.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.14 – Lambda 运行时接口客户端](img/B18638_03_014.jpg)'
- en: Figure 3.14 – Lambda Runtime Interface Client
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.14 – Lambda 运行时接口客户端
- en: 'If this container is launched without any additional parameters, the following
    command will execute:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个容器在没有任何额外参数的情况下启动，以下命令将执行：
- en: '[PRE21]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This will run the `handler()` function of our `app.py` file to process AWS Lambda
    events. This `handler()` function will then use the deep learning model we trained
    in the *Using AWS Deep Learning Containers to train an ML model* section to make
    predictions.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这将运行`app.py`文件中的`handler()`函数来处理AWS Lambda事件。然后，`handler()`函数将使用我们在*使用AWS深度学习容器训练ML模型*部分训练的深度学习模型进行预测。
- en: Note
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the Dockerfile here: [https://github.com/PacktPublishing/Machine-Learning-Engineering-on-AWS/blob/main/chapter03/Dockerfile](https://github.com/PacktPublishing/Machine-Learning-Engineering-on-AWS/blob/main/chapter03/Dockerfile).'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下位置找到Dockerfile：[https://github.com/PacktPublishing/Machine-Learning-Engineering-on-AWS/blob/main/chapter03/Dockerfile](https://github.com/PacktPublishing/Machine-Learning-Engineering-on-AWS/blob/main/chapter03/Dockerfile)。
- en: Before running the `build.sh` script, make sure that you replace all instances
    of `us-west-2` in the Dockerfile with the appropriate region code.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行`build.sh`脚本之前，请确保将Dockerfile中的所有`us-west-2`实例替换为适当的区域代码。
- en: 'Now, let’s run the `build.sh` script:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们运行`build.sh`脚本：
- en: '[PRE22]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Finally, we need to check whether the size of the custom container image exceeds
    10 GB using the `docker images` command:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要使用`docker images`命令检查自定义容器镜像的大小是否超过10 GB：
- en: '[PRE23]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We should see that the container image size of `dlclambda` is `4.61GB`. It is
    important to note that there is a 10 GB limit when using container images for
    Lambda functions. The image size of our custom container image needs to be below
    10 GB if we want these to be used in AWS Lambda.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该看到`dlclambda`的容器镜像大小为`4.61GB`。需要注意的是，当使用容器镜像为Lambda函数时，存在10 GB的限制。如果我们要在AWS
    Lambda中使用这些镜像，我们的自定义容器镜像的大小需要低于10 GB。
- en: At this point, our custom container image is ready. The next step is to test
    the container image locally before using it to create an AWS Lambda function.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的自定义容器镜像已经准备好了。下一步是在使用它创建AWS Lambda函数之前，在本地测试容器镜像。
- en: Testing the container image
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试容器镜像
- en: We can test the container image locally using the **Lambda Runtime Interface
    Emulator**. This will help us check whether our container image will run properly
    when it is deployed to AWS Lambda later.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用**Lambda运行时接口模拟器**在本地测试容器镜像。这将帮助我们检查当容器镜像部署到AWS Lambda后是否能够正常运行。
- en: 'In the next couple of steps, we will download and use the Lambda Runtime Interface
    Emulator to check our container image:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几个步骤中，我们将下载并使用Lambda运行时接口模拟器来检查我们的容器镜像：
- en: 'Use the `cat` command to check the contents of `download-rie.sh`:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`cat`命令检查`download-rie.sh`文件的内容：
- en: '[PRE24]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This should print the following block of code as output in the Terminal:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该在终端中输出以下代码块：
- en: '[PRE25]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `download-rie.sh` script simply downloads the Lambda Runtime Interface Emulator
    binary and makes it executable using the `chmod` command.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`download-rie.sh`脚本简单地下载Lambda运行时接口模拟器二进制文件，并使用`chmod`命令使其可执行。'
- en: 'Next, run the `download-rie.sh` script:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，运行`download-rie.sh`脚本：
- en: '[PRE26]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Use the `cat` command to check the contents of `run.sh`:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`cat`命令检查`run.sh`文件的内容：
- en: '[PRE27]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We should see a `docker run` command with several parameter values, similar
    to what we have in the following code block:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该看到一个带有几个参数值的`docker run`命令，类似于以下代码块：
- en: '[PRE28]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Let’s quickly check the parameter values that were passed to each of the flags:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速检查传递给每个标志的参数值：
- en: '`-v`: `~/.aws-lambda-rie` is a directory outside of the running Docker container
    to be mounted to `/aws-lambda` (which is inside the container).'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-v`: `~/.aws-lambda-rie`是一个位于运行中的Docker容器之外的目录，需要将其挂载到容器内的`/aws-lambda`（容器内部）。'
- en: '`-p`: This binds port `8080` of the container to port `9000` of the instance.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-p`: 这将容器中的`8080`端口绑定到实例的`9000`端口。'
- en: '`--entrypoint`: This will override the default `ENTRYPOINT` command that gets
    executed when the container starts.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--entrypoint`: 这将覆盖容器启动时默认执行的`ENTRYPOINT`命令。'
- en: '`[IMAGE]`: `dlclambda:latest.`'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[IMAGE]`: `dlclambda:latest.`'
- en: '`[COMMAND]` `[ARG…]`: `/opt/conda/bin/python -m awslambdaric app.handler.`'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[COMMAND]` `[ARG…]`: `/opt/conda/bin/python -m awslambdaric app.handler.`'
- en: This `docker run` command overrides the default `ENTRYPOINT` command and uses
    the `aws-lambda-rie`, instead of using the `--entrypoint` flag. This will then
    start a local endpoint at `http://localhost:9000/2015-03-31/functions/function/invocations`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`docker run`命令覆盖了默认的`ENTRYPOINT`命令，并使用`aws-lambda-rie`，而不是使用`--entrypoint`标志。这将然后在`http://localhost:9000/2015-03-31/functions/function/invocations`上启动一个本地端点。
- en: Note
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For more information on the `docker run` command, feel free to check out [https://docs.docker.com/engine/reference/commandline/run/](https://docs.docker.com/engine/reference/commandline/run/).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `docker run` 命令的更多信息，您可以自由查看 [https://docs.docker.com/engine/reference/commandline/run/](https://docs.docker.com/engine/reference/commandline/run/)。
- en: 'Now, let’s invoke the `run.sh` script:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们调用 `run.sh` 脚本：
- en: '[PRE29]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Create a new Terminal tab by clicking the plus (**+**) button, as shown in
    the following screenshot:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过单击以下截图所示的加号（**+**）按钮创建一个新的终端标签页：
- en: '![Figure 3.15 – Creating a new Terminal tab ](img/B18638_03_015.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.15 – 创建新的终端标签页](img/B18638_03_015.jpg)'
- en: Figure 3.15 – Creating a new Terminal tab
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.15 – 创建新的终端标签页
- en: Note that the `run.sh` script should be kept running while we are opening a
    **New Terminal** tab.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在我们打开 **新终端** 标签页时，`run.sh` 脚本应该保持运行状态。
- en: 'In the `invoke.sh` script:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `invoke.sh` 脚本中：
- en: '[PRE30]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This should show us what is inside the `invoke.sh` script file. It should contain
    a one-liner script, similar to what we have in the following block of code:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会显示 `invoke.sh` 脚本文件中的内容。它应该包含一个单行脚本，类似于以下代码块：
- en: '[PRE32]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This script simply makes use of the `curl` command to send a sample `POST` request
    containing the `x` input value to the local endpoint that was started by the `run.sh`
    script earlier.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本只是简单地使用 `curl` 命令发送一个包含 `x` 输入值的样本 `POST` 请求到之前由 `run.sh` 脚本启动的本地端点。
- en: 'Now, let’s run the `invoke.sh` script:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们运行 `invoke.sh` 脚本：
- en: '[PRE33]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This should yield a value close to `"42.4586"`. Feel free to change the input
    `x` value in the `invoke.sh` script to see how the output value changes as well.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会得到接近 `"42.4586"` 的值。您可以在 `invoke.sh` 脚本中自由更改输入 `x` 的值，以查看输出值如何变化。
- en: Navigate back to the first tab and press *Ctrl* + *C* to stop the running `run.sh`
    script.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到第一个标签页，并按 *Ctrl* + *C* 停止正在运行的 `run.sh` 脚本。
- en: Given that we were able to successfully invoke the `app.py` Lambda function
    handler inside the custom container image using the **Lambda Runtime Interface
    Emulator**, we can now proceed with pushing our container image to Amazon ECR
    and using it to create an AWS Lambda function.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们能够成功地在自定义容器镜像中使用 **Lambda Runtime Interface Emulator** 调用 `app.py` Lambda
    函数处理程序，我们现在可以继续将容器镜像推送到 Amazon ECR，并使用它来创建 AWS Lambda 函数。
- en: Pushing the container image to Amazon ECR
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将容器镜像推送到 Amazon ECR
- en: '**Amazon Elastic Container Registry** (**ECR**) is a container registry service
    that allows us to store and manage Docker container images. In this section, we
    will create an ECR repository and then push our custom container image to this
    ECR repository.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '**Amazon Elastic Container Registry** (**ECR**) 是一个容器注册服务，允许我们存储和管理 Docker
    容器镜像。在本节中，我们将创建一个 ECR 仓库，然后将我们的自定义容器镜像推送到这个 ECR 仓库。'
- en: 'Let’s start by creating an ECR repository:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先创建一个 ECR 仓库：
- en: 'In the top right-hand corner of the Cloud9 environment, locate and click the
    circle beside the **Share** button, as shown in the following screenshot. Select
    **Go To Dashboard** from the list of options:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Cloud9 环境的右上角找到并单击 **共享** 按钮旁边的圆圈，如图所示。从选项列表中选择 **转到仪表板**：
- en: '![Figure 3.16 – Navigating to the Cloud9 console ](img/B18638_03_016.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.16 – 导航到 Cloud9 控制台](img/B18638_03_016.jpg)'
- en: Figure 3.16 – Navigating to the Cloud9 console
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.16 – 导航到 Cloud9 控制台
- en: This should open the Cloud9 console, where we can find all the created Cloud9
    environments.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会打开 Cloud9 控制台，在那里我们可以找到所有创建的 Cloud9 环境。
- en: Type `registry` in the search bar. Select **Elastic Container Registry** from
    the list of results.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在搜索栏中输入 `registry`。从结果列表中选择 **Elastic Container Registry**。
- en: Locate and click the **Create repository** button in the top right-hand corner
    of the ECR console page.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 ECR 控制台页面的右上角找到并单击 **创建仓库** 按钮。
- en: 'On the `dlclambda`):'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `dlclambda` 上）：
- en: '![Figure 3.17 – Creating an ECR repository ](img/B18638_03_017.jpg)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.17 – 创建 ECR 仓库](img/B18638_03_017.jpg)'
- en: Figure 3.17 – Creating an ECR repository
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.17 – 创建 ECR 仓库
- en: Optionally, you can enable **Tag immutability**, similar to what is shown in
    the preceding screenshot. This will help ensure that we do not accidentally overwrite
    existing container image tags.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 可选地，您可以选择启用 **标签不可变性**，类似于前面截图所示。这将有助于确保我们不会意外覆盖现有的容器镜像标签。
- en: Scroll down to the bottom of the page and then click **Create Repository**.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将页面滚动到最底部，然后单击 **创建仓库**。
- en: 'We should see a success notification, along with the **View push commands**
    button, similar to what we have in the following screenshot:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该会看到一个成功通知，以及与以下截图类似的 **查看推送命令** 按钮：
- en: '![Figure 3.18 – View push commands ](img/B18638_03_018.jpg)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.18 – 查看推送命令](img/B18638_03_018.jpg)'
- en: Figure 3.18 – View push commands
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.18 – 查看推送命令
- en: Click the **View push commands** button to open the **Push commands for <ECR
    repository name>** popup window.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 **查看推送命令** 按钮以打开 **<ECR 仓库名称> 的推送命令** 弹出窗口。
- en: 'Locate the `bash` command inside the gray box under *Step 1*. Copy the command
    to the clipboard by clicking the box button highlighted in the following screenshot:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 *步骤 1* 下的灰色框内找到 `bash` 命令。通过点击以下截图中的高亮框按钮，将命令复制到剪贴板：
- en: '![Figure 3.19 – Push commands ](img/B18638_03_019.jpg)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.19 – 推送命令](img/B18638_03_019.jpg)'
- en: Figure 3.19 – Push commands
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.19 – 推送命令
- en: This command will be used to authenticate the Docker client in our Cloud9 environment
    to Amazon ECR. This will give us permission to push and pull container images
    to Amazon ECR.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将用于在我们的 Cloud9 环境中对 Docker 客户端进行认证到 Amazon ECR。这将赋予我们推送和拉取容器镜像到 Amazon ECR
    的权限。
- en: 'Navigate back to the `bash` command:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到 `bash` 命令：
- en: '![Figure 3.20 – Running the client authentication command ](img/B18638_03_020.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.20 – 运行客户端认证命令](img/B18638_03_020.jpg)'
- en: Figure 3.20 – Running the client authentication command
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.20 – 运行客户端认证命令
- en: We should get a **Login Succeeded** message. Without this step, we wouldn’t
    be able to push and pull container images from Amazon ECR.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该会得到 **登录成功** 的消息。如果没有这一步，我们就无法从 Amazon ECR 推送和拉取容器镜像。
- en: 'Navigate back to the browser tab with the ECR push commands and copy the command
    under *Step 3*, as highlighted in the following screenshot:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到包含 ECR 推送命令的浏览器标签页，并复制 *步骤 3* 下的命令，如以下截图所示：
- en: '![Figure 3.21 – Copying the docker tag command ](img/B18638_03_021.jpg)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.21 – 复制 docker tag 命令](img/B18638_03_021.jpg)'
- en: Figure 3.21 – Copying the docker tag command
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.21 – 复制 docker tag 命令
- en: This time, we will be copying the `docker tag` command from the `docker tag`
    command is used to create and map named references to Docker images.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们将从 `docker tag` 命令复制 `docker tag` 命令用于创建和映射对 Docker 镜像的命名引用。
- en: Note
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 备注
- en: The `docker tag` command is used to specify and add metadata (such as the name
    and the version) to a container image. A container image repository stores different
    versions of a specific image, and the `docker tag` command helps the repository
    identify which version of the image will be updated (or uploaded) when the `docker
    push` command is used. For more information, feel free to check out https://docs.docker.com/engine/reference/commandline/tag/.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker tag` 命令用于指定并添加元数据（如名称和版本）到容器镜像。容器镜像仓库存储特定镜像的不同版本，`docker tag` 命令帮助仓库识别在执行
    `docker push` 命令时将更新（或上传）哪个版本的镜像。更多信息，请查阅 https://docs.docker.com/engine/reference/commandline/tag/。'
- en: 'Back in the browser tab that contains the Cloud9 environment, paste the copied
    `docker tag` command in the Terminal window. Locate the `latest` tag value at
    the end of the command and replace it with `1` instead:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在包含 Cloud9 环境的浏览器标签页中，将复制的 `docker tag` 命令粘贴到终端窗口中。找到命令末尾的 `latest` 标签值，并将其替换为
    `1`：
- en: '[PRE34]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The command should be similar to what we have in the following code block after
    the `latest` tag has been replaced with `1`:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 命令应类似于以下代码块中 `latest` 标签被替换为 `1` 后的内容：
- en: '[PRE35]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Make sure that the `<ACCOUNT ID>` value is correctly set to the account ID of
    the AWS account you are using. The `docker tag` command that you copied from the
    `<ACCOUNT ID>` value set correctly.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 确保将 `<ACCOUNT ID>` 值正确设置为所使用的 AWS 账户的账户 ID。您从 `<ACCOUNT ID>` 值设置的 `docker tag`
    命令已正确复制。
- en: 'Use the `docker images` command to quickly check the container images in our
    Cloud9 environment:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `docker images` 命令快速检查我们的 Cloud9 环境中的容器镜像：
- en: '[PRE36]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This should return all the container images, including the `dlclambda` container
    images, as shown in the following screenshot:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会返回所有容器镜像，包括 `dlclambda` 容器镜像，如下截图所示：
- en: '![Figure 3.22 – Running the docker images command ](img/B18638_03_022.jpg)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.22 – 运行 docker images 命令](img/B18638_03_022.jpg)'
- en: Figure 3.22 – Running the docker images command
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.22 – 运行 docker images 命令
- en: It is important to note that both container image tags shown in the preceding
    screenshot have the same image ID. This means that they point to the same image,
    even if they have different names and tags.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，前一个截图显示的两个容器镜像标签具有相同的镜像 ID。这意味着它们指向相同的镜像，即使它们有不同的名称和标签。
- en: 'Push the container image to the Amazon ECR repository using the `docker push`
    command:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `docker push` 命令将容器镜像推送到 Amazon ECR 仓库：
- en: '[PRE37]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Make sure that you replace the value of `<ACCOUNT ID>` with the account ID of
    the AWS account you are using. You can get the value for `<ACCOUNT ID>` by checking
    the numerical value before `.dkr.ecr.us-west-2.amazonaws.com/dlclambda` after
    running the `docker images` command in the previous step.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 确保将`<ACCOUNT ID>`的值替换为你使用的AWS账户的账户ID。你可以在运行上一步中的`docker images`命令后，检查`.dkr.ecr.us-west-2.amazonaws.com/dlclambda`之前的数值来获取`<ACCOUNT
    ID>`的值。
- en: Note
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Note that the image tag value is a `1` (one) instead of the letter *l* after
    the container image name and the colon.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到镜像标签值是`1`（一个），而不是容器镜像名称和冒号后面的字母*l*。
- en: Navigate back to the browser tab that contains the ECR push commands and click
    the **Close** button.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回包含ECR推送命令的浏览器标签页，并点击**关闭**按钮。
- en: 'Locate and click the name of the ECR repository we created (that is, `dlclambda`)
    under the list of **Private repositories**:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**私有仓库**列表中找到并点击我们创建的ECR仓库的名称（即`dlclambda`）：
- en: '![Figure 3.23 – Private repositories ](img/B18638_03_023.jpg)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![图3.23 – 私有仓库](img/B18638_03_023.jpg)'
- en: Figure 3.23 – Private repositories
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.23 – 私有仓库
- en: 'This should redirect us to the details page, where we can see the different
    image tags, as shown in the following screenshot:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会跳转到详情页面，在那里我们可以看到不同的镜像标签，如下面的截图所示：
- en: '![Figure 3.24 – Repository details page ](img/B18638_03_024.jpg)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![图3.24 – 仓库详情页](img/B18638_03_024.jpg)'
- en: Figure 3.24 – Repository details page
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.24 – 仓库详情页
- en: Once our container image with the specified image tag has been reflected in
    the corresponding Amazon ECR repository details page, we can use it to create
    AWS Lambda functions using Lambda’s container image support.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的带有指定镜像标签的容器镜像反映在相应的Amazon ECR仓库详情页上，我们就可以使用它来创建AWS Lambda函数，利用Lambda的容器镜像支持。
- en: Now that our custom container image has been pushed to **Amazon ECR**, we can
    prepare and configure the serverless API setup!
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们自定义的容器镜像已经推送到**Amazon ECR**，我们可以准备和配置无服务器API设置！
- en: Running ML predictions on AWS Lambda
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在AWS Lambda上运行ML预测
- en: '**AWS Lambda** is a serverless compute service that allows developers and engineers
    to run event-driven code without having to provision or manage infrastructure.
    Lambda functions can be invoked by resources from other AWS services such as **API
    Gateway** (a fully managed service for configuring and managing APIs), **Amazon
    S3** (an object storage service where we can upload and download files), **Amazon
    SQS** (a fully managed message queuing service), and more. These functions are
    executed inside isolated runtime environments that have a defined max execution
    time and max memory limits, similar to what we have in the following diagram:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '**AWS Lambda**是一种无服务器计算服务，允许开发者和工程师在不配置或管理基础设施的情况下运行事件驱动的代码。Lambda函数可以被来自其他AWS服务的资源调用，例如**API
    Gateway**（一个用于配置和管理API的全托管服务）、**Amazon S3**（一个对象存储服务，我们可以上传和下载文件）、**Amazon SQS**（一个全托管的消息队列服务）等。这些函数在具有定义的最大执行时间和最大内存限制的隔离运行环境中执行，类似于以下图表所示：'
- en: '![Figure 3.25 – AWS Lambda isolated runtime environment ](img/B18638_03_025.jpg)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
  zh: '![图3.25 – AWS Lambda隔离运行环境](img/B18638_03_025.jpg)'
- en: Figure 3.25 – AWS Lambda isolated runtime environment
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.25 – AWS Lambda隔离运行环境
- en: 'There are two ways to deploy Lambda function code and its dependencies:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 部署Lambda函数代码及其依赖项有两种方式：
- en: Using a container image as the deployment package.
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用容器镜像作为部署包。
- en: Using a `.zip` file as the deployment package
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`.zip`文件作为部署包
- en: When using a container image as the deployment package, the custom Lambda function
    code can use what is installed and configured inside the container image. That
    said, if we were to use the custom container image that was built from AWS DLC,
    we would be able to use the installed ML framework (that is, **PyTorch**) in our
    function code and run ML predictions inside an AWS Lambda execution environment.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用容器镜像作为部署包时，自定义Lambda函数代码可以使用容器镜像内部安装和配置的内容。也就是说，如果我们使用从AWS DLC构建的自定义容器镜像，我们就能在我们的函数代码中使用安装的ML框架（即**PyTorch**），并在AWS
    Lambda执行环境中运行ML预测。
- en: 'Now that we have a better understanding of how AWS Lambda’s container image
    support works, let’s proceed with creating our AWS Lambda function:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对AWS Lambda的容器镜像支持有了更好的理解，让我们继续创建我们的AWS Lambda函数：
- en: Type `lambda` in the search bar. Select **Lambda** from the list of results
    to navigate to the AWS Lambda console.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在搜索栏中输入`lambda`。从结果列表中选择**Lambda**以导航到AWS Lambda控制台。
- en: Locate and click the **Create function** button found at the top-right of the
    page.
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定位并点击页面右上角的 **创建函数** 按钮。
- en: 'On the `dlclambda`):'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `dlclambda` 上）：
- en: '![Figure 3.26 – Using the container image support of AWS Lambda ](img/B18638_03_026.jpg)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.26 – 使用 AWS Lambda 的容器镜像支持](img/B18638_03_026.jpg)'
- en: Figure 3.26 – Using the container image support of AWS Lambda
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.26 – 使用 AWS Lambda 的容器镜像支持
- en: Selecting the **Container image** option means that we will use a custom container
    image as the deployment package. This deployment package is expected to contain
    the Lambda code, along with its dependencies.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 选择 **容器镜像** 选项意味着我们将使用自定义容器镜像作为部署包。这个部署包预期将包含 Lambda 代码及其依赖项。
- en: 'Under **Container image URI**, click the **Browse Images** button. This will
    open a popup window, similar to the following:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **容器镜像 URI** 下，点击 **浏览镜像** 按钮。这将打开一个弹出窗口，类似于以下内容：
- en: '![Figure 3.27 – Selecting the container image ](img/B18638_03_027.jpg)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.27 – 选择容器镜像](img/B18638_03_027.jpg)'
- en: Figure 3.27 – Selecting the container image
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.27 – 选择容器镜像
- en: Under `dlclambda:1`).
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `dlclambda:1` 下）。
- en: Click the `dlclambda` container image will be used for the deployment package
    of our Lambda function.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击将用于 Lambda 函数部署包的 `dlclambda` 容器镜像。
- en: After that, click **Create function**.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，点击 **创建函数**。
- en: Note
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This step may take 3 to 5 minutes to complete. Feel free to get a cup of coffee
    or tea while waiting!
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 此步骤可能需要 3 到 5 分钟才能完成。在等待时，不妨喝杯咖啡或茶！
- en: 'Navigate to the **Configuration > General configuration** tab and click **Edit**:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 **配置 > 通用配置** 选项卡并点击 **编辑**：
- en: '![Figure 3.28 – Editing the general configuration ](img/B18638_03_028.jpg)'
  id: totrans-330
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.28 – 编辑通用配置](img/B18638_03_028.jpg)'
- en: Figure 3.28 – Editing the general configuration
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.28 – 编辑通用配置
- en: Here, we can see that the AWS Lambda function is configured with a default max
    memory limit of 128 MB and a timeout of 3 seconds. An error is raised if the Lambda
    function exceeds one or more of the configured limits during execution.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到 AWS Lambda 函数已配置为默认最大内存限制为 128 MB 和超时时间为 3 秒。如果在执行过程中 Lambda 函数超出一个或多个配置的限制，则会引发错误。
- en: 'Next, update the `10240` MB since we’re expecting our `1` min and `0` seconds
    as well since the inference step may take longer than the default value of 3 seconds:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，更新 `10240` MB，因为我们预计我们的 `1` 分钟和 `0` 秒也将如此，因为推理步骤可能需要比默认的 3 秒更长的时间：
- en: '![Figure 3.29 – Modifying the memory and timeout settings ](img/B18638_03_029.jpg)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.29 – 修改内存和超时设置](img/B18638_03_029.jpg)'
- en: Figure 3.29 – Modifying the memory and timeout settings
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.29 – 修改内存和超时设置
- en: Note that increasing the memory and timeout limits here will influence the compute
    power and total running time available for the Lambda function, as well as the
    overall cost of running predictions using the service. For now, let’s focus on
    getting the **AWS Lambda** function to work using these current configuration
    values for **Memory** and **Timeout**. Once we can get the initial setup running,
    we can play with different combinations of configuration values to manage the
    performance and cost of our setup.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在此处增加内存和超时限制将影响 Lambda 函数可用的计算能力和总运行时间，以及使用此服务运行预测的整体成本。目前，让我们专注于使用当前的**内存**和**超时**配置值来使
    **AWS Lambda** 函数工作。一旦我们可以使初始设置运行，我们就可以尝试不同的配置值组合来管理我们设置的性能和成本。
- en: Note
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We can use the **AWS Compute Optimizer** to help us optimize the overall performance
    and cost of AWS Lambda functions. For more information on this topic, check out
    [https://aws.amazon.com/blogs/compute/optimizing-aws-lambda-cost-and-performance-using-aws-compute-optimizer/](https://aws.amazon.com/blogs/compute/optimizing-aws-lambda-cost-and-performance-using-aws-compute-optimizer/).
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 **AWS Compute Optimizer** 来帮助我们优化 AWS Lambda 函数的整体性能和成本。有关此主题的更多信息，请参阅[https://aws.amazon.com/blogs/compute/optimizing-aws-lambda-cost-and-performance-using-aws-compute-optimizer/](https://aws.amazon.com/blogs/compute/optimizing-aws-lambda-cost-and-performance-using-aws-compute-optimizer/)。
- en: Click the **Save** button afterward. We should see a notification similar to
    **Updating the function <function name>** while the changes are being applied.
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改后点击 **保存** 按钮。我们应该在应用更改时看到类似于 **正在更新函数 <function name>** 的通知。
- en: Navigate to the **Test** tab.
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 **测试** 选项卡。
- en: 'Under `test`):'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `test` 下）：
- en: '![Figure 3.30 – Configuring the test event ](img/B18638_03_030.jpg)'
  id: totrans-342
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.30 – 配置测试事件](img/B18638_03_030.jpg)'
- en: Figure 3.30 – Configuring the test event
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.30 – 配置测试事件
- en: 'Make sure that you specify the following test event value inside the code editor,
    similar to what is shown in the preceding screenshot:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在代码编辑器中指定以下测试事件值，类似于前面截图所示：
- en: '[PRE38]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This test event value gets passed to the `event` (first) parameter of the AWS
    Lambda `handler()` function when a test execution is performed.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行测试时，此测试事件值被传递到 AWS Lambda `handler()` 函数的 `event`（第一个）参数。
- en: Click **Save**.
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **保存**。
- en: 'Now, let’s test our setup by clicking the **Test** button:'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们通过点击 **测试** 按钮来测试我们的设置：
- en: '![Figure 3.31 – Successful execution result ](img/B18638_03_031.jpg)'
  id: totrans-349
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.31 – 执行成功结果](img/B18638_03_031.jpg)'
- en: Figure 3.31 – Successful execution result
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.31 – 执行成功结果
- en: After a few seconds, we should see that the execution results succeeded, similar
    to what we have in the preceding screenshot.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 几秒钟后，我们应该看到执行结果成功，类似于前面截图中的结果。
- en: In the `x` to `41` and then click the `41.481697`) almost right away.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `x` 到 `41` 然后点击 `41.481697`) 几乎立即。
- en: Important Note
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: During an AWS Lambda function’s first invocation, it may take a few seconds
    for its function code to be downloaded and for its execution environment to be
    prepared. This phenomenon is commonly referred to as a *cold start*. When it is
    invoked a second time (within the same minute, for example), the Lambda function
    runs immediately without the delay associated with the cold start. For example,
    a Lambda function may take around 30 to 40 seconds for its first invocation to
    complete. After that, all succeeding requests would take a second or less. The
    Lambda function completes its execution significantly faster since the execution
    environment that was prepared during the first invocation is frozen and reused
    for succeeding invocations. If the AWS Lambda function is not invoked after some
    time (for example, around 10 to 30 minutes of inactivity), the execution environment
    is deleted and a new one needs to be prepared again the next time the function
    gets invoked. There are different ways to manage this and ensure that the AWS
    Lambda function performs consistently without experiencing the effects of a cold
    start. One of the strategies is to utilize **Provisioned Concurrency**, which
    helps ensure predictable function start times. Check out [https://aws.amazon.com/blogs/compute/operating-lambda-performance-optimization-part-1/](https://aws.amazon.com/blogs/compute/operating-lambda-performance-optimization-part-1/)
    for more information on this topic.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在 AWS Lambda 函数的首次调用期间，其函数代码的下载和执行环境的准备可能需要几秒钟。这种现象通常被称为 *冷启动*。当它在同一分钟内第二次被调用时（例如），Lambda
    函数将立即运行，而无需与冷启动相关的延迟。例如，Lambda 函数可能需要大约 30 到 40 秒才能完成首次调用。之后，所有后续请求都会在 1 秒或更短的时间内完成。由于在首次调用期间准备好的执行环境被冻结并用于后续调用，Lambda
    函数的执行速度会显著加快。如果 AWS Lambda 函数在一段时间内没有被调用（例如，大约 10 到 30 分钟的不活动时间），执行环境将被删除，并且下一次函数被调用时需要重新准备。有不同方法来管理这一点并确保
    AWS Lambda 函数在没有经历冷启动效果的情况下保持一致的性能。其中一种策略是利用 **预置并发**，这有助于确保函数启动时间的可预测性。有关此主题的更多信息，请参阅
    [https://aws.amazon.com/blogs/compute/operating-lambda-performance-optimization-part-1/](https://aws.amazon.com/blogs/compute/operating-lambda-performance-optimization-part-1/)。
- en: With our AWS Lambda function ready to perform ML predictions, we can proceed
    with creating the serverless HTTP API that will trigger our Lambda function.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 AWS Lambda 函数准备好执行机器学习预测后，我们可以继续创建将触发我们的 Lambda 函数的无服务器 HTTP API。
- en: Completing and testing the serverless API setup
  id: totrans-356
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 完成并测试无服务器 API 设置
- en: The AWS Lambda function we created needs to be triggered by an event source.
    One of the possible event sources is an API Gateway HTTP API configured to receive
    an HTTP request. After receiving the request, the HTTP API will pass the request
    data to the AWS Lambda function as an event. Once the Lambda function receives
    the event, it will use the deep learning model to perform inference, and then
    return the predicted output value to the HTTP API. After that, the HTTP API will
    return the HTTP response to the requesting resource.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的 AWS Lambda 函数需要通过事件源来触发。可能的事件源之一是配置为接收 HTTP 请求的 API Gateway HTTP API。在接收到请求后，HTTP
    API 将请求数据作为事件传递给 AWS Lambda 函数。一旦 Lambda 函数接收到事件，它将使用深度学习模型进行推理，然后将预测的输出值返回给 HTTP
    API。之后，HTTP API 将 HTTP 响应返回给请求的资源。
- en: 'There are different ways to create an API Gateway HTTP API. In the next couple
    of steps, we will create this HTTP API directly from the AWS Lambda console:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 API 网关 HTTP API 有不同的方法。在接下来的几个步骤中，我们将直接从 AWS Lambda 控制台创建此 HTTP API：
- en: 'Locate the **Function overview** pane and click **Add trigger**:'
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定位到 **函数概述** 面板并点击 **添加触发器**：
- en: '![Figure 3.32 – Add trigger ](img/B18638_03_032.jpg)'
  id: totrans-360
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.32 – 添加触发器](img/B18638_03_032.jpg)'
- en: Figure 3.32 – Add trigger
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.32 – 添加触发器
- en: The **Add trigger** button should be on the left-hand side of the **Function
    overview** pane, as shown in the preceding screenshot.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '**添加触发器**按钮应位于 **函数概述** 面板的左侧，如前一张截图所示。'
- en: 'Add a new AWS Lambda trigger using the following trigger configuration:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下触发器配置添加一个新的 AWS Lambda 触发器：
- en: '![Figure 3.33 – Trigger configuration ](img/B18638_03_033.jpg)'
  id: totrans-364
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.33 – 触发器配置](img/B18638_03_033.jpg)'
- en: Figure 3.33 – Trigger configuration
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.33 – 触发器配置
- en: 'Here’s the trigger configuration that we have:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的触发器配置：
- en: '**Select a trigger**: **API Gateway**'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选择触发器**：**API 网关**'
- en: '**Create a new API or use an existing one**: **Create an API**'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建新 API 或使用现有 API**：**创建 API**'
- en: '**API type**: **HTTP API**'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**API 类型**：**HTTP API**'
- en: '**Security**: **Open**'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全**：**开放**'
- en: This will create and configure an HTTP API that accepts a request and sends
    the request data as an event to the AWS Lambda function.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建并配置一个接受请求并将请求数据作为事件发送到 AWS Lambda 函数的 HTTP API。
- en: Important Note
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Note that this configuration needs to be secured once we have configured our
    setup for production use. For more information on this topic, check out [https://docs.aws.amazon.com/apigateway/latest/developerguide/security.xhtml](https://docs.aws.amazon.com/apigateway/latest/developerguide/security.xhtml).
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，一旦我们为生产使用配置了设置，此配置需要被安全化。有关此主题的更多信息，请参阅[https://docs.aws.amazon.com/apigateway/latest/developerguide/security.xhtml](https://docs.aws.amazon.com/apigateway/latest/developerguide/security.xhtml)。
- en: Once you have finished configuring the new trigger, click the **Add** button.
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成新触发器的配置后，点击 **添加** 按钮。
- en: Locate the API Gateway trigger we just created under the **Triggers** pane.
    Click the **API Gateway** link (for example, **dlclambda-API**) which should open
    a new tab. Under **Develop** (in the sidebar), click **Integrations**. Under Routes
    for **dlclambda-API**, click **ANY**. Click **Manage Integration** and then click
    **Edit** (located in the **Integration Details** pane). In the **Edit Integration**
    page, update the value of **Payload format version** (under **Advanced Settings**)
    to **2.0** similar to what we have in *Figure 3.34*. Click **Save** afterwards.
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **触发器** 面板下找到我们刚刚创建的 API 网关触发器。点击 **API 网关** 链接（例如，**dlclambda-API**），它应该会打开一个新标签页。在侧边栏的
    **开发** 下，点击 **集成**。在 **dlclambda-API** 的路由下，点击 **ANY**。点击 **管理集成** 然后点击 **编辑**（位于
    **集成详细信息** 面板中）。在 **编辑集成** 页面上，将 **高级设置** 下的 **有效载荷格式版本** 的值更新为 **2.0**，类似于 *图
    3.34* 中的内容。之后点击 **保存**。
- en: '![Figure 3.34 – Updating the Payload format version ](img/B18638_03_034.jpg)'
  id: totrans-376
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.34 – 更新有效载荷格式版本](img/B18638_03_034.jpg)'
- en: Figure 3.34 – Updating the Payload format version
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.34 – 更新有效载荷格式版本
- en: After updating the `x` value in the URL, the Lambda function will use `0` as
    the default `x` value when performing a test inference.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 更新 URL 中的 `x` 值后，Lambda 函数在执行测试推理时将使用 `0` 作为默认的 `x` 值。
- en: Note
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 备注
- en: 'You may want to trigger an exception instead if there is no `x` value specified
    when a request is sent to the API Gateway endpoint. Feel free to change this behavior
    by modifying *line 44* of `app.py`: [https://github.com/PacktPublishing/Machine-Learning-Engineering-on-AWS/blob/main/chapter03/app/app.py](https://github.com/PacktPublishing/Machine-Learning-Engineering-on-AWS/blob/main/chapter03/app/app.py).'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在将请求发送到 API 网关端点时未指定 `x` 值，您可能希望触发一个异常。您可以修改 `app.py` 中的 *line 44* 来更改此行为：[https://github.com/PacktPublishing/Machine-Learning-Engineering-on-AWS/blob/main/chapter03/app/app.py](https://github.com/PacktPublishing/Machine-Learning-Engineering-on-AWS/blob/main/chapter03/app/app.py)。
- en: 'Append `?x=42` to the end of the browser URL, similar to what we have in the
    following URL string:'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `?x=42` 添加到浏览器 URL 的末尾，类似于以下 URL 字符串中的内容：
- en: '[PRE39]'
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Make sure that you press the `42` as the input `x` value:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您按 `42` 作为输入 `x` 值：
- en: '![Figure 3.35 – Testing the API endpoint ](img/B18638_03_035.jpg)'
  id: totrans-384
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.35 – 测试 API 端点](img/B18638_03_035.jpg)'
- en: Figure 3.35 – Testing the API endpoint
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.35 – 测试 API 端点
- en: This should return a value close to `42.4586`, as shown in the preceding screenshot.
    Feel free to test different values for `x` to see how the predicted *y* value
    changes.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该返回一个接近`42.4586`的值，如图所示。你可以自由地测试不同的`x`值，看看预测的*y*值是如何变化的。
- en: Important Note
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Make sure that you delete the AWS Lambda and API Gateway resources once you
    are done configuring and testing the API setup.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你在配置和测试API设置完成后，删除AWS Lambda和API Gateway资源。
- en: At this point, we should be proud of ourselves as we were able to successfully
    deploy our deep learning model in a serverless API using **AWS Lambda** and **Amazon
    API Gateway**! Before the release of AWS Lambda’s container image support, it
    was tricky to set up and maintain serverless ML inference APIs using the same
    tech stack we used in this chapter. Now that we have this initial setup working,
    it should be easier to prepare and configure similar serverless ML-powered APIs.
    Note that we also have the option to create a Lambda function URL to generate
    a unique URL endpoint for the Lambda function.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们应该为自己感到自豪，因为我们能够成功地在无服务器API中使用**AWS Lambda**和**Amazon API Gateway**部署我们的深度学习模型！在AWS
    Lambda容器镜像支持发布之前，使用本章中使用的相同技术栈设置和维护无服务器ML推理API是相当棘手的。现在我们有了这个初始设置，准备和配置类似的、由ML驱动的无服务器API应该会更容易。请注意，我们还有创建Lambda函数URL的选项，以生成Lambda函数的唯一URL端点。
- en: '![Figure 3.36 – Cost of running the serverless API versus an API running inside
    an EC2 instance ](img/B18638_03_036.jpg)'
  id: totrans-390
  prefs: []
  type: TYPE_IMG
  zh: '![图3.36 – 无服务器API运行成本与在EC2实例内部运行的API运行成本的比较](img/B18638_03_036.jpg)'
- en: Figure 3.36 – Cost of running the serverless API versus an API running inside
    an EC2 instance
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.36 – 无服务器API运行成本与在EC2实例内部运行的API运行成本的比较
- en: Before we end this chapter, let’s quickly check what the costs would look like
    if we were to use **AWS Lambda** and **API Gateway** for the ML inference endpoint.
    As shown in the preceding diagram, the expected cost of running this serverless
    API depends on the traffic passing through it. This means that the cost would
    be minimal if no traffic is passing through the API. Once more traffic passes
    through this HTTP API endpoint, the cost would gradually increase as well. Comparing
    this to the chart on the right, the expected cost will be the same, regardless
    of whether there’s traffic passing through the HTTP API that was deployed inside
    an EC2 instance.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束本章之前，让我们快速检查如果我们使用**AWS Lambda**和**API Gateway**作为ML推理端点，成本会是怎样的。如图所示，运行此无服务器API的预期成本取决于通过它的流量。这意味着如果没有流量通过API，成本将是最小的。一旦更多流量通过这个HTTP
    API端点，成本也会逐渐增加。与右侧的图表比较，无论是否通过部署在EC2实例内部的HTTP API有流量通过，预期成本都将相同。
- en: 'Choosing the architecture and setup to use for your API depends on a variety
    of factors. We will not discuss this topic in detail, so feel free to check out
    the resources available here: [https://aws.amazon.com/lambda/resources/](https://aws.amazon.com/lambda/resources/).'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 选择用于你的API的架构和设置取决于多种因素。我们不会详细讨论这个话题，所以你可以自由地查看这里可用的资源：[https://aws.amazon.com/lambda/resources/](https://aws.amazon.com/lambda/resources/)。
- en: Summary
  id: totrans-394
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we were able to take a closer look at **AWS Deep Learning Containers**
    (**DLCs**). Similar to **AWS Deep Learning AMIs** (**DLAMIs**), AWS DLCs already
    have the relevant ML frameworks, libraries, and packages installed. This significantly
    speeds up the process of building and deploying deep learning models. At the same
    time, container environments are guaranteed to be consistent since these are run
    from pre-built container images.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们能够更深入地了解**AWS深度学习容器**（**DLCs**）。与**AWS深度学习AMI**（**DLAMIs**）类似，AWS DLCs已经安装了相关的ML框架、库和包。这显著加快了构建和部署深度学习模型的过程。同时，容器环境保证一致性，因为这些是从预构建的容器镜像运行的。
- en: One of the key differences between DLAMIs and DLCs is that multiple AWS DLCs
    can run inside a single EC2 instance. These containers can also be used in other
    AWS services that support containers. These services include **AWS Lambda**, **Amazon
    ECS**, **Amazon EKS**, and **Amazon EC2**, to name a few.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: DLAMIs和DLCs之间的一个主要区别是，多个AWS DLCs可以运行在单个EC2实例内部。这些容器也可以用于支持容器的其他AWS服务。这些服务包括**AWS
    Lambda**、**Amazon ECS**、**Amazon EKS**和**Amazon EC2**等。
- en: In this chapter, we were able to train a deep learning model using a DLC. We
    then deployed this model to an AWS Lambda function through Lambda’s container
    image support. After that, we tested the Lambda function to see whether it’s able
    to successfully load the deep learning model to perform predictions. To trigger
    this Lambda function from an HTTP endpoint, we created an API Gateway HTTP API.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们能够使用 DLC 训练一个深度学习模型。然后，我们通过 Lambda 的容器镜像支持将该模型部署到 AWS Lambda 函数中。之后，我们测试了
    Lambda 函数，以查看它是否能够成功加载深度学习模型进行预测。为了从 HTTP 端点触发此 Lambda 函数，我们创建了一个 API Gateway
    HTTP API。
- en: 'In the next chapter, we will focus on **serverless data management** and use
    a variety of services to set up and configure a data warehouse and a data lake.
    We will be working with the following AWS services, capabilities, and features:
    **Redshift Serverless**, **AWS Lake Formation**, **AWS Glue**, and **Amazon Athena**.'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将重点关注**无服务器数据管理**，并使用各种服务来设置和配置数据仓库和数据湖。我们将使用以下 AWS 服务、功能和特性：**Redshift
    Serverless**、**AWS Lake Formation**、**AWS Glue**和**Amazon Athena**。
- en: Further reading
  id: totrans-399
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For more information on the topics covered in this chapter, feel free to check
    out the following resources:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 如需了解本章涉及主题的更多信息，请随意查看以下资源：
- en: '*What are Deep Learning Containers?* ([https://docs.aws.amazon.com/deep-learning-containers/latest/devguide/what-is-dlc.xhtml](https://docs.aws.amazon.com/deep-learning-containers/latest/devguide/what-is-dlc.xhtml))'
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*什么是深度学习容器？* ([https://docs.aws.amazon.com/deep-learning-containers/latest/devguide/what-is-dlc.xhtml](https://docs.aws.amazon.com/deep-learning-containers/latest/devguide/what-is-dlc.xhtml))'
- en: '*Security in Amazon API Gateway* (https://docs.aws.amazon.com/apigateway/latest/developerguide/security.xhtml)'
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Amazon API Gateway 中的安全性* ([https://docs.aws.amazon.com/apigateway/latest/developerguide/security.xhtml](https://docs.aws.amazon.com/apigateway/latest/developerguide/security.xhtml))'
- en: '*New for AWS Lambda – Container Image Support* (https://aws.amazon.com/blogs/aws/new-for-aws-lambda-container-image-support/)'
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*AWS Lambda 新增功能 – 容器镜像支持* ([https://aws.amazon.com/blogs/aws/new-for-aws-lambda-container-image-support/](https://aws.amazon.com/blogs/aws/new-for-aws-lambda-container-image-support/))'
- en: '*Issues to Avoid When Implementing Serverless Architecture with AWS Lambda*
    ([https://aws.amazon.com/blogs/architecture/mistakes-to-avoid-when-implementing-serverless-architecture-with-lambda/)](https://aws.amazon.com/blogs/architecture/mistakes-to-avoid-when-implementing-serverless-architecture-with-lambda/)'
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在 AWS Lambda 中实现无服务器架构时需要避免的问题* ([https://aws.amazon.com/blogs/architecture/mistakes-to-avoid-when-implementing-serverless-architecture-with-lambda/](https://aws.amazon.com/blogs/architecture/mistakes-to-avoid-when-implementing-serverless-architecture-with-lambda/))'
- en: Part 2:Solving Data Engineering and Analysis Requirements
  id: totrans-405
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分：解决数据工程和分析需求
- en: In this section, readers will learn how to perform data engineering using a
    variety of solutions and services on AWS.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，读者将学习如何在 AWS 上使用各种解决方案和服务进行数据工程。
- en: 'This section comprises the following chapters:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 本节包括以下章节：
- en: '[*Chapter 4*](B18638_04.xhtml#_idTextAnchor079), *Serverless Data Management
    on AWS*'
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第四章*](B18638_04.xhtml#_idTextAnchor079), *AWS 上的无服务器数据管理*'
- en: '[*Chapter 5*](B18638_05.xhtml#_idTextAnchor105), *Pragmatic Data Processing
    and Analysis*'
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第五章*](B18638_05.xhtml#_idTextAnchor105), *实用数据处理与分析*'
