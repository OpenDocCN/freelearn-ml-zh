<html><head></head><body>
<div id="_idContainer195">
<h1 class="chapter-number" id="_idParaDest-251"><a id="_idTextAnchor252"/><span class="koboSpan" id="kobo.1.1">12</span></h1>
<h1 id="_idParaDest-252"><a id="_idTextAnchor253"/><span class="koboSpan" id="kobo.2.1">Detecting Orientation with an IMU on Raspberry Pi Pico</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Our robot can track how far it’s moved, but what about tracking which direction the robot is facing? </span><span class="koboSpan" id="kobo.3.2">Or how far it has turned? </span><span class="koboSpan" id="kobo.3.3">In this chapter, we will learn about the </span><strong class="bold"><span class="koboSpan" id="kobo.4.1">Inertial Measurement Unit</span></strong><span class="koboSpan" id="kobo.5.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.6.1">IMU</span></strong><span class="koboSpan" id="kobo.7.1">), a device that can track the motion of the robot measured </span><a id="_idIndexMarker665"/><span class="koboSpan" id="kobo.8.1">against gravity and the Earth’s </span><span class="No-Break"><span class="koboSpan" id="kobo.9.1">magnetic field.</span></span></p>
<p><span class="koboSpan" id="kobo.10.1">We’ll look at how to select one of these devices, get it connected and then write code for it on our robot using the PID controller to steer the robot based on the </span><span class="No-Break"><span class="koboSpan" id="kobo.11.1">IMU data.</span></span></p>
<p><span class="koboSpan" id="kobo.12.1">In this chapter, we will cover the following </span><span class="No-Break"><span class="koboSpan" id="kobo.13.1">main topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.14.1">What is an IMU and how to </span><span class="No-Break"><span class="koboSpan" id="kobo.15.1">choose one</span></span></li>
<li><span class="koboSpan" id="kobo.16.1">Connecting the IMU to </span><span class="No-Break"><span class="koboSpan" id="kobo.17.1">the robot</span></span></li>
<li><span class="koboSpan" id="kobo.18.1">Calibrating and </span><span class="No-Break"><span class="koboSpan" id="kobo.19.1">getting readings</span></span></li>
<li><span class="koboSpan" id="kobo.20.1">Always face </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">North behavior</span></span></li>
<li><span class="koboSpan" id="kobo.22.1">Making a known </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">turn behavior</span></span></li>
</ul>
<h1 id="_idParaDest-253"><a id="_idTextAnchor254"/><span class="koboSpan" id="kobo.24.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.25.1">For this chapter, you will require </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.27.1">The robot from </span><a href="B18001_11.xhtml#_idTextAnchor233"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.28.1">Chapter 11</span></em></span></a><span class="koboSpan" id="kobo.29.1">, </span><em class="italic"><span class="koboSpan" id="kobo.30.1">Controlling Motion with Encoders on Raspberry </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.31.1">Pi Pico</span></em></span></li>
<li><span class="koboSpan" id="kobo.32.1">The robot, encoder, and PID code from </span><a href="B18001_11.xhtml#_idTextAnchor233"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.33.1">Chapter 11</span></em></span></a><span class="koboSpan" id="kobo.34.1">, </span><em class="italic"><span class="koboSpan" id="kobo.35.1">Controlling Motion with Encoders on Raspberry </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.36.1">Pi Pico</span></em></span></li>
<li><span class="koboSpan" id="kobo.37.1">A screwdriver, bolts, </span><span class="No-Break"><span class="koboSpan" id="kobo.38.1">and stand-offs</span></span></li>
<li><span class="koboSpan" id="kobo.39.1">Dupont </span><span class="No-Break"><span class="koboSpan" id="kobo.40.1">jumper cables</span></span></li>
<li><span class="koboSpan" id="kobo.41.1">A space where strong magnets can </span><span class="No-Break"><span class="koboSpan" id="kobo.42.1">be avoided</span></span></li>
<li><span class="koboSpan" id="kobo.43.1">A PC </span><span class="No-Break"><span class="koboSpan" id="kobo.44.1">or laptop</span></span></li>
<li><span class="koboSpan" id="kobo.45.1">An Android/iOS smartphone with Bluetooth LE and the Bluefruit LE </span><span class="No-Break"><span class="koboSpan" id="kobo.46.1">Connect app</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.47.1">You can find the code for this chapter </span><span class="No-Break"><span class="koboSpan" id="kobo.48.1">at </span></span><a href="https://github.com/PacktPublishing/Robotics-at-Home-with-Raspberry-Pi-Pico/tree/main/ch-12"><span class="No-Break"><span class="koboSpan" id="kobo.49.1">https://github.com/PacktPublishing/Robotics-at-Home-with-Raspberry-Pi-Pico/tree/main/ch-12</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.50.1">.</span></span></p>
<h1 id="_idParaDest-254"><a id="_idTextAnchor255"/><span class="koboSpan" id="kobo.51.1">What is an IMU and how to choose one</span></h1>
<p><span class="koboSpan" id="kobo.52.1">In this </span><a id="_idIndexMarker666"/><span class="koboSpan" id="kobo.53.1">section, we’ll look at the components of an IMU and what criteria we used to choose the one used in </span><span class="No-Break"><span class="koboSpan" id="kobo.54.1">this robot.</span></span></p>
<h2 id="_idParaDest-255"><a id="_idTextAnchor256"/><span class="koboSpan" id="kobo.55.1">Components of an IMU</span></h2>
<p><span class="koboSpan" id="kobo.56.1">An IMU is </span><a id="_idIndexMarker667"/><span class="koboSpan" id="kobo.57.1">a module that can measure movement. </span><span class="koboSpan" id="kobo.57.2">It uses multiple sensors to achieve this. </span><span class="koboSpan" id="kobo.57.3">In this section, we’ll briefly look at each sensor and how they contribute to the </span><span class="No-Break"><span class="koboSpan" id="kobo.58.1">whole measurement.</span></span></p>
<p><span class="koboSpan" id="kobo.59.1">These </span><a id="_idIndexMarker668"/><span class="koboSpan" id="kobo.60.1">sensors are made using the </span><strong class="bold"><span class="koboSpan" id="kobo.61.1">Micro-Electro-Mechanical-Systems</span></strong><span class="koboSpan" id="kobo.62.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.63.1">MEMS</span></strong><span class="koboSpan" id="kobo.64.1">) process. </span><span class="koboSpan" id="kobo.64.2">They have tiny moving parts embedded into the chips. </span><span class="koboSpan" id="kobo.64.3">We can model them mechanically to understand them. </span><span class="koboSpan" id="kobo.64.4">These parts sense the movement of parts through their magnetic fields and amplify tiny signals. </span><span class="koboSpan" id="kobo.64.5">Let’s look at </span><span class="No-Break"><span class="koboSpan" id="kobo.65.1">the components.</span></span></p>
<h3><span class="koboSpan" id="kobo.66.1">The thermometer</span></h3>
<p><span class="koboSpan" id="kobo.67.1">The mechanical </span><a id="_idIndexMarker669"/><span class="koboSpan" id="kobo.68.1">components of an IMU </span><a id="_idIndexMarker670"/><span class="koboSpan" id="kobo.69.1">will change size, depending on their temperature. </span><span class="koboSpan" id="kobo.69.2">These tiny changes may be enough to change the signals so that the IMU controller can use a temperature measurement to compensate </span><span class="No-Break"><span class="koboSpan" id="kobo.70.1">for this.</span></span></p>
<h3><span class="koboSpan" id="kobo.71.1">The accelerometer</span></h3>
<p><span class="koboSpan" id="kobo.72.1">An </span><strong class="bold"><span class="koboSpan" id="kobo.73.1">accelerometer</span></strong><span class="koboSpan" id="kobo.74.1"> measures </span><a id="_idIndexMarker671"/><span class="koboSpan" id="kobo.75.1">acceleration forces. </span><span class="koboSpan" id="kobo.75.2">It measures this as a vector – a direction </span><a id="_idIndexMarker672"/><span class="koboSpan" id="kobo.76.1">and a size. </span><span class="koboSpan" id="kobo.76.2">The way this is measured is somewhat like a box with a suspended mass, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.77.1">following figure:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer185">
<span class="koboSpan" id="kobo.78.1"><img alt="Figure 12.1 – Accelerometer modeled as a mass with springs " src="image/Figure_12.01_B18001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.79.1">Figure 12.1 – Accelerometer modeled as a mass with springs</span></p>
<p><span class="koboSpan" id="kobo.80.1">The preceding figure shows a mass suspended in a box by springs. </span><span class="koboSpan" id="kobo.80.2">When a force acts on the box, the mass retains its inertia and compresses the spring opposing the force’s direction. </span><span class="koboSpan" id="kobo.80.3">A MEMS accelerometer uses tiny silicon springs and masses and measures the electrical field changes when the </span><span class="No-Break"><span class="koboSpan" id="kobo.81.1">mass moves.</span></span></p>
<p><span class="koboSpan" id="kobo.82.1">While on Earth, gravity pulls the mass down. </span><span class="koboSpan" id="kobo.82.2">This system behaves like a force holding the box up, so an accelerometer registers an upward force. </span><span class="koboSpan" id="kobo.82.3">We can use this measurement to determine what the downward direction is and sense the tilt of a robot. </span></p>
<p><span class="koboSpan" id="kobo.83.1">The accelerometer vector is an absolute orientation (see the </span><em class="italic"><span class="koboSpan" id="kobo.84.1">Absolute and relative sensing</span></em><span class="koboSpan" id="kobo.85.1"> section in </span><a href="B18001_06.xhtml#_idTextAnchor115"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.86.1">Chapter 6</span></em></span></a><span class="koboSpan" id="kobo.87.1">, </span><em class="italic"><span class="koboSpan" id="kobo.88.1">Measuring Movement With Encoders on Raspberry Pi Pico</span></em><span class="koboSpan" id="kobo.89.1">) for up. </span><span class="koboSpan" id="kobo.89.2">Still, other movements cause noise, so it is usually put through a low pass filter, only changing a setting by a percentage of the actual variation. </span><span class="koboSpan" id="kobo.89.3">This filter makes the output slow but stable. </span></p>
<p><span class="koboSpan" id="kobo.90.1">A controller can combine this data with other sensors for a faster and more stable measurement, such as </span><span class="No-Break"><span class="koboSpan" id="kobo.91.1">a gyroscope.</span></span></p>
<h3><span class="koboSpan" id="kobo.92.1">The gyroscope</span></h3>
<p><span class="koboSpan" id="kobo.93.1">A </span><strong class="bold"><span class="koboSpan" id="kobo.94.1">gyroscope</span></strong><span class="koboSpan" id="kobo.95.1"> measures the </span><a id="_idIndexMarker673"/><span class="koboSpan" id="kobo.96.1">rotation speed of a system, typically in degrees or </span><a id="_idIndexMarker674"/><span class="koboSpan" id="kobo.97.1">radians per second in an angle around each axis. </span><span class="koboSpan" id="kobo.97.2">A physical gyroscope model, shown as follows, can be used to help illustrate what </span><span class="No-Break"><span class="koboSpan" id="kobo.98.1">it does:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer186">
<span class="koboSpan" id="kobo.99.1"><img alt="Figure 12.2 – A model of a gyroscope " src="image/Figure_12.02_B18001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.100.1">Figure 12.2 – A model of a gyroscope</span></p>
<p><span class="koboSpan" id="kobo.101.1">The preceding figure shows a traditional gyroscope. </span><span class="koboSpan" id="kobo.101.2">This gyroscope has a spinning mass wheel in the middle, linked to concentric rings –  each ring pivots in one direction – x, y, or </span><em class="italic"><span class="koboSpan" id="kobo.102.1">z</span></em><span class="koboSpan" id="kobo.103.1">. </span><span class="koboSpan" id="kobo.103.2">The net effect is that when you move the handle, the spinning disk preserves its orientation. </span><span class="koboSpan" id="kobo.103.3">Sensors placed at the pivots would detect how much the system has rotated in </span><span class="No-Break"><span class="koboSpan" id="kobo.104.1">each direction.</span></span></p>
<p><span class="koboSpan" id="kobo.105.1">The MEMS version uses a tiny mass that’s moved back and forth in one direction. </span><span class="koboSpan" id="kobo.105.2">If the orientation is changed, the mass will continue vibrating in the original direction, which will change the electrical fields detected by the sensor. </span><span class="koboSpan" id="kobo.105.3">This movement in the original orientation appears </span><a id="_idIndexMarker675"/><span class="koboSpan" id="kobo.106.1">to be a force known as the </span><strong class="bold"><span class="koboSpan" id="kobo.107.1">Coriolis force</span></strong><span class="koboSpan" id="kobo.108.1">. </span><span class="koboSpan" id="kobo.108.2">The gyroscope can measure the magnitude of </span><span class="No-Break"><span class="koboSpan" id="kobo.109.1">this force.</span></span></p>
<p><span class="koboSpan" id="kobo.110.1">It’s essential </span><a id="_idIndexMarker676"/><span class="koboSpan" id="kobo.111.1">to understand the directions </span><a id="_idIndexMarker677"/><span class="koboSpan" id="kobo.112.1">of the gyroscope and how the measurements relate to time. </span><span class="koboSpan" id="kobo.112.2">See the </span><span class="No-Break"><span class="koboSpan" id="kobo.113.1">following diagram:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer187">
<span class="koboSpan" id="kobo.114.1"><img alt="Figure 12.3 – Gyroscope directions and problems with integrating it " src="image/Figure_12.03_B18001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.115.1">Figure 12.3 – Gyroscope directions and problems with integrating it</span></p>
<p><span class="koboSpan" id="kobo.116.1">The left-hand side of the preceding diagram shows the three gyroscope rotations and the coordinate systems that the IMU uses. </span><span class="koboSpan" id="kobo.116.2">This coordinate system takes the robot into account. </span><span class="koboSpan" id="kobo.116.3">Traditionally, the front of the robot is in the positive X direction. </span><span class="koboSpan" id="kobo.116.4">Straight up is positive Z, and to the robot’s left is positive Y. </span><span class="koboSpan" id="kobo.116.5">Rotation around the </span><em class="italic"><span class="koboSpan" id="kobo.117.1">z</span></em><span class="koboSpan" id="kobo.118.1"> axis is known as </span><strong class="bold"><span class="koboSpan" id="kobo.119.1">heading</span></strong><span class="koboSpan" id="kobo.120.1"> (also known as yaw), rotation </span><a id="_idIndexMarker678"/><span class="koboSpan" id="kobo.121.1">around the y axis is pitch, and rotation around the x axis is roll. </span><span class="koboSpan" id="kobo.121.2">This combination of three angles to determine orientation </span><a id="_idIndexMarker679"/><span class="koboSpan" id="kobo.122.1">is known as </span><strong class="bold"><span class="koboSpan" id="kobo.123.1">Euler</span></strong><span class="koboSpan" id="kobo.124.1"> (pronounced </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.125.1">oil-er</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.126.1"> angles</span></span><span class="No-Break"><span class="koboSpan" id="kobo.127.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.128.1">The right-hand side of the diagram shows how a controller can use gyroscope data – it represents a relative change in angle or a speed in angle change over time. </span><span class="koboSpan" id="kobo.128.2">We can convert this into a new angle, but that is estimated. </span><span class="koboSpan" id="kobo.128.3">Multiplying this by time and adding them can give us a whole rotation relative to the starting position, but this will magnify any estimation or </span><span class="No-Break"><span class="koboSpan" id="kobo.129.1">reading errors.</span></span></p>
<p><span class="koboSpan" id="kobo.130.1">A controller should combine this with other sensors, where the gyroscope can provide a fast relative </span><a id="_idIndexMarker680"/><span class="koboSpan" id="kobo.131.1">measurement, and the other sensor </span><a id="_idIndexMarker681"/><span class="koboSpan" id="kobo.132.1">can provide a slower absolute measurement. </span><span class="koboSpan" id="kobo.132.2">However, the accelerometer cannot measure the heading. </span><span class="koboSpan" id="kobo.132.3">For that, we need </span><span class="No-Break"><span class="koboSpan" id="kobo.133.1">a magnetometer.</span></span></p>
<h3><span class="koboSpan" id="kobo.134.1">The magnetometer</span></h3>
<p><span class="koboSpan" id="kobo.135.1">A </span><strong class="bold"><span class="koboSpan" id="kobo.136.1">magnetometer</span></strong><span class="koboSpan" id="kobo.137.1"> is sensitive </span><a id="_idIndexMarker682"/><span class="koboSpan" id="kobo.138.1">to magnetic fields. </span><span class="koboSpan" id="kobo.138.2">It passes electricity </span><a id="_idIndexMarker683"/><span class="koboSpan" id="kobo.139.1">through a material that creates current when exposed to a magnetic field, as </span><span class="No-Break"><span class="koboSpan" id="kobo.140.1">shown here:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer188">
<span class="koboSpan" id="kobo.141.1"><img alt="Figure 12.4 – Diagram of a hall-effect sensor " src="image/Figure_12.04_B18001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.142.1">Figure 12.4 – Diagram of a hall-effect sensor</span></p>
<p><span class="koboSpan" id="kobo.143.1">The preceding figure shows an example of detecting magnetic fields </span><span class="No-Break"><span class="koboSpan" id="kobo.144.1">in action:</span></span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.145.1">The circuit passes an electric current from a source through a conducting plate (the gray rectangle). </span><span class="koboSpan" id="kobo.145.2">The arrows show the flow of electrons (negative charge carriers) moving around the circuit from the top of the plate downwards. </span><span class="koboSpan" id="kobo.145.3">The small circle with a V measures electrical flow across the sides of the plate. </span><span class="koboSpan" id="kobo.145.4">Currently, this reads </span><strong class="source-inline"><span class="koboSpan" id="kobo.146.1">0</span></strong><span class="koboSpan" id="kobo.147.1"> as the flow is </span><span class="No-Break"><span class="koboSpan" id="kobo.148.1">straight down.</span></span></li>
<li><span class="koboSpan" id="kobo.149.1">When we place a magnet above the plate, it deflects electrons to one side. </span><span class="koboSpan" id="kobo.149.2">This deflection creates a small electric flow through the measuring circuit and will show a reading above </span><strong class="source-inline"><span class="koboSpan" id="kobo.150.1">0</span></strong><span class="koboSpan" id="kobo.151.1"> on </span><span class="No-Break"><span class="koboSpan" id="kobo.152.1">the sensor.</span></span></li>
<li><span class="koboSpan" id="kobo.153.1">When we place a magnet below the plate, this deflects the electrons to the other side, creating a small sensor flow in the other direction, and show a reading </span><span class="No-Break"><span class="koboSpan" id="kobo.154.1">below 0.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.155.1">This sensor method is </span><a id="_idIndexMarker684"/><span class="koboSpan" id="kobo.156.1">known as the </span><strong class="bold"><span class="koboSpan" id="kobo.157.1">Hall effect</span></strong><span class="koboSpan" id="kobo.158.1">. </span><span class="koboSpan" id="kobo.158.2">By measuring three plates, you can sense magnetic fields in three dimensions. </span></p>
<p><span class="koboSpan" id="kobo.159.1">The great </span><a id="_idIndexMarker685"/><span class="koboSpan" id="kobo.160.1">thing is that we can use this to </span><a id="_idIndexMarker686"/><span class="koboSpan" id="kobo.161.1">sense the Earth’s magnetic field and magnetic North, although it can be deflected by magnets in objects around the magnetometer. </span><span class="koboSpan" id="kobo.161.2">Being able to sense magnetic North makes it a great way to sense heading. </span></p>
<p><span class="koboSpan" id="kobo.162.1">Because it is subject to other magnets, it can be noisy and may need a low pass filter, but you can pair it with the gyroscope the same way the accelerometer </span><span class="No-Break"><span class="koboSpan" id="kobo.163.1">is paired.</span></span></p>
<p><span class="koboSpan" id="kobo.164.1">Now that you’ve seen the four sensor types that go into an IMU, we can look at how we </span><span class="No-Break"><span class="koboSpan" id="kobo.165.1">choose one.</span></span></p>
<h2 id="_idParaDest-256"><a id="_idTextAnchor257"/><span class="koboSpan" id="kobo.166.1">Choosing an IMU module</span></h2>
<p><span class="koboSpan" id="kobo.167.1">There are </span><a id="_idIndexMarker687"/><span class="koboSpan" id="kobo.168.1">several IMU devices on the market. </span><span class="koboSpan" id="kobo.168.2">The first thing to note is that you want a module or breakout, not a bare chip (at least </span><span class="No-Break"><span class="koboSpan" id="kobo.169.1">not yet).</span></span></p>
<p><span class="koboSpan" id="kobo.170.1">The number </span><a id="_idIndexMarker688"/><span class="koboSpan" id="kobo.171.1">of directions/movements an IMU system can sense is known as </span><strong class="bold"><span class="koboSpan" id="kobo.172.1">degrees of freedom</span></strong><span class="koboSpan" id="kobo.173.1">, or </span><strong class="bold"><span class="koboSpan" id="kobo.174.1">DOF</span></strong><span class="koboSpan" id="kobo.175.1">. </span><span class="koboSpan" id="kobo.175.2">A system with all three types of sensors is known as a 9-DOF because each can produce three axes worth of information. </span><span class="koboSpan" id="kobo.175.3">The temperature sensor isn’t counted in this DOF </span><span class="No-Break"><span class="koboSpan" id="kobo.176.1">count usually.</span></span></p>
<p><span class="koboSpan" id="kobo.177.1">These modules come in a few flavors. </span><span class="koboSpan" id="kobo.177.2">The following diagram illustrates </span><span class="No-Break"><span class="koboSpan" id="kobo.178.1">these flavors:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer189">
<span class="koboSpan" id="kobo.179.1"><img alt="Figure 12.5 – IMU module integration levels " src="image/Figure_12.05_B18001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.180.1">Figure 12.5 – IMU module integration levels</span></p>
<p><span class="koboSpan" id="kobo.181.1">The preceding </span><a id="_idIndexMarker689"/><span class="koboSpan" id="kobo.182.1">diagram shows three </span><a id="_idIndexMarker690"/><span class="koboSpan" id="kobo.183.1">different IMU module integration levels. </span><span class="koboSpan" id="kobo.183.2">They are </span><span class="No-Break"><span class="koboSpan" id="kobo.184.1">as follows:</span></span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.185.1">The simplest has only one of the sensors, and you need to buy three to get the complete orientation. </span><span class="koboSpan" id="kobo.185.2">In addition, they do not have much </span><span class="No-Break"><span class="koboSpan" id="kobo.186.1">helper circuitry.</span></span></li>
<li><span class="koboSpan" id="kobo.187.1">Some modules integrate three or four separate sensor chips to give the full 9-DOF and could be suitable. </span><span class="koboSpan" id="kobo.187.2">These have some support circuitry but might not have </span><span class="No-Break"><span class="koboSpan" id="kobo.188.1">a controller.</span></span></li>
<li><span class="koboSpan" id="kobo.189.1">The devices we will focus on are those based around a single chip that combines the sensors. </span><span class="koboSpan" id="kobo.189.2">These come as modules that integrate power and any additional required components (such as small resistors and capacitors). </span><span class="koboSpan" id="kobo.189.3">These have </span><span class="No-Break"><span class="koboSpan" id="kobo.190.1">onboard controllers.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.191.1">They can also use a few different data buses to communicate. </span><span class="koboSpan" id="kobo.191.2">UART and SPI tie up a whole set of pins; however, I2C allows the device to share a bus with other sensors, so we’ll favor </span><span class="No-Break"><span class="koboSpan" id="kobo.192.1">I2C devices.</span></span></p>
<p><span class="koboSpan" id="kobo.193.1">The next factor in integration is how much calculation the device’s controller can do (if any). </span><span class="koboSpan" id="kobo.193.2">The algorithms to combine all three sensors and account for calibration, along with temperature, are complicated. </span><span class="koboSpan" id="kobo.193.3">Some devices can perform this on board, and some require it on another controller or require specialist code to be uploaded to activate the calculation (such as MPU and ICM TDK series). </span><span class="koboSpan" id="kobo.193.4">We will also favor modules that can do the calculation </span><span class="No-Break"><span class="koboSpan" id="kobo.194.1">on board.</span></span></p>
<p><span class="koboSpan" id="kobo.195.1">The BNO055 </span><a id="_idIndexMarker691"/><span class="koboSpan" id="kobo.196.1">module is a good fit for these requirements. </span><span class="koboSpan" id="kobo.196.2">The BNO055 combines all 9-DOF, a temperature sensor, works over I2C, and has calculations and calibration on board, saving us writing that code on our Raspberry Pi Pico. </span><span class="koboSpan" id="kobo.196.3">They are also widely available, with Adafruit selling them in two variations, and there’s direct CircuitPython support </span><span class="No-Break"><span class="koboSpan" id="kobo.197.1">for them.</span></span></p>
<p><span class="koboSpan" id="kobo.198.1">Let’s look at how we can use a BNO055 module with </span><span class="No-Break"><span class="koboSpan" id="kobo.199.1">our robot.</span></span></p>
<h1 id="_idParaDest-257"><a id="_idTextAnchor258"/><span class="koboSpan" id="kobo.200.1">Connecting the IMU to the robot</span></h1>
<p><span class="koboSpan" id="kobo.201.1">Installing </span><a id="_idIndexMarker692"/><span class="koboSpan" id="kobo.202.1">the BNO055 requires performing a few steps. </span><span class="koboSpan" id="kobo.202.2">In this section, we’ll prepare the module, attach it to the robot rigidly, wire the part into the circuit, and then use some simple code to test that it </span><span class="No-Break"><span class="koboSpan" id="kobo.203.1">is responding.</span></span></p>
<h2 id="_idParaDest-258"><a id="_idTextAnchor259"/><span class="koboSpan" id="kobo.204.1">Preparing the BNO055</span></h2>
<p><span class="koboSpan" id="kobo.205.1">The BNO055 </span><a id="_idIndexMarker693"/><span class="koboSpan" id="kobo.206.1">from Adafruit comes without the headers attached. </span><span class="koboSpan" id="kobo.206.2">You’ll need to solder the headers in, as we have done previously. </span><span class="koboSpan" id="kobo.206.3">Adafruit has a guide for this </span><span class="No-Break"><span class="koboSpan" id="kobo.207.1">at </span></span><a href="https://learn.adafruit.com/adafruit-bno055-absolute-orientation-sensor/assembly"><span class="No-Break"><span class="koboSpan" id="kobo.208.1">https://learn.adafruit.com/adafruit-bno055-absolute-orientation-sensor/assembly</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.209.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.210.1">For this robot, you should solder this part with the headers facing up from the </span><span class="No-Break"><span class="koboSpan" id="kobo.211.1">component side.</span></span></p>
<h2 id="_idParaDest-259"><a id="_idTextAnchor260"/><span class="koboSpan" id="kobo.212.1">Attaching the BNO055</span></h2>
<p><span class="koboSpan" id="kobo.213.1">To attach </span><a id="_idIndexMarker694"/><span class="koboSpan" id="kobo.214.1">the part to the robot, see the </span><span class="No-Break"><span class="koboSpan" id="kobo.215.1">following diagram:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer190">
<span class="koboSpan" id="kobo.216.1"><img alt="Figure 12.6 – Drawing of the shelf with additional holes for the BNO055 module " src="image/Figure_12.06_B18001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.217.1">Figure 12.6 – Drawing of the shelf with additional holes for the BNO055 module</span></p>
<p><span class="koboSpan" id="kobo.218.1">You will need </span><a id="_idIndexMarker695"/><span class="koboSpan" id="kobo.219.1">to attach the IMU rigidly to the robot, so the velcro pad will not be sufficient. </span><span class="koboSpan" id="kobo.219.2">Stand-offs will make a suitable attachment here. </span><span class="koboSpan" id="kobo.219.3">The preceding figure shows where to make some 2.5 mm holes in the shelf in the highlighted area. </span><span class="koboSpan" id="kobo.219.4">You can insert M2 (or M2.5 if you have them) stand-offs to attach it. </span><span class="koboSpan" id="kobo.219.5">You can use stand-offs to gain some separation between the IMU and the metal or magnetic parts of </span><span class="No-Break"><span class="koboSpan" id="kobo.220.1">the robot.</span></span></p>
<p><span class="koboSpan" id="kobo.221.1">You may need to adapt this to the BNO breakout you have. </span><span class="koboSpan" id="kobo.221.2">The following figure shows the part I am using and the orientation it should </span><span class="No-Break"><span class="koboSpan" id="kobo.222.1">be in:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer191">
<span class="koboSpan" id="kobo.223.1"><img alt="Figure 12.7 – The BNO055 part’s orientation " src="image/Figure_12.07_B18001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.224.1">Figure 12.7 – The BNO055 part’s orientation</span></p>
<p><span class="koboSpan" id="kobo.225.1">I’ve made </span><a id="_idIndexMarker696"/><span class="koboSpan" id="kobo.226.1">the holes so that they suit the part shown in the preceding figure. </span><span class="koboSpan" id="kobo.226.2">This figure shows the part with the robot chassis as a reference, with the x, y, and z axes indicated with arrows. </span><span class="koboSpan" id="kobo.226.3">The z in a circle means it runs through this diagram, with the upward direction being positive. </span></p>
<p><span class="koboSpan" id="kobo.227.1">We mount the BNO055 so that its x axis faces the front of the robot. </span><span class="koboSpan" id="kobo.227.2">This is due to the BNO055 defaulting to the Android phone orientation – a minor quirk of the configuration of </span><span class="No-Break"><span class="koboSpan" id="kobo.228.1">this module.</span></span></p>
<p><span class="koboSpan" id="kobo.229.1">While the orientation of this part matters, it can be compensated for in code. </span></p>
<p><span class="koboSpan" id="kobo.230.1">Let’s see how to wire in </span><span class="No-Break"><span class="koboSpan" id="kobo.231.1">this part.</span></span></p>
<h2 id="_idParaDest-260"><a id="_idTextAnchor261"/><span class="koboSpan" id="kobo.232.1">Wiring the BNO055 to Raspberry Pi Pico</span></h2>
<p><span class="koboSpan" id="kobo.233.1">We will </span><a id="_idIndexMarker697"/><span class="koboSpan" id="kobo.234.1">wire the BNO055 using I2C. </span><span class="koboSpan" id="kobo.234.2">See </span><a id="_idIndexMarker698"/><span class="koboSpan" id="kobo.235.1">the following circuit diagram </span><span class="No-Break"><span class="koboSpan" id="kobo.236.1">for details:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer192">
<span class="koboSpan" id="kobo.237.1"><img alt="Figure 12.8 – BNO055 I2C wiring " src="image/Figure_12.08_B18001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.238.1">Figure 12.8 – BNO055 I2C wiring</span></p>
<p><span class="koboSpan" id="kobo.239.1">The top part of the preceding diagram shows the whole circuit diagram. </span><span class="koboSpan" id="kobo.239.2">Since a lot is happening here, the highlighted region has been zoomed in below, showing the specific wiring. </span><span class="koboSpan" id="kobo.239.3">The BNO055 </span><a id="_idIndexMarker699"/><span class="koboSpan" id="kobo.240.1">only needs four pins connected. </span><span class="koboSpan" id="kobo.240.2">It has </span><a id="_idIndexMarker700"/><span class="koboSpan" id="kobo.241.1">power connections for GND and Vin from the 3V3 lines. </span><span class="koboSpan" id="kobo.241.2">The SCL and SDA are connected to I2C0, sharing an I2C bus with one of the </span><span class="No-Break"><span class="koboSpan" id="kobo.242.1">distance sensors.</span></span></p>
<p><span class="koboSpan" id="kobo.243.1">Now that the BNO055 is wired in, let’s try talking </span><span class="No-Break"><span class="koboSpan" id="kobo.244.1">to it.</span></span></p>
<h2 id="_idParaDest-261"><a id="_idTextAnchor262"/><span class="koboSpan" id="kobo.245.1">Setting up the software and connecting</span></h2>
<p><span class="koboSpan" id="kobo.246.1">The CircuitPython </span><a id="_idIndexMarker701"/><span class="koboSpan" id="kobo.247.1">library includes an </span><strong class="source-inline"><span class="koboSpan" id="kobo.248.1">adafruit_BNO055</span></strong><span class="koboSpan" id="kobo.249.1"> module for use with this device. </span><span class="koboSpan" id="kobo.249.2">Copy over or use </span><strong class="bold"><span class="koboSpan" id="kobo.250.1">circup</span></strong><span class="koboSpan" id="kobo.251.1"> to install this. </span><span class="koboSpan" id="kobo.251.2">You </span><a id="_idIndexMarker702"/><span class="koboSpan" id="kobo.252.1">will also need the </span><strong class="source-inline"><span class="koboSpan" id="kobo.253.1">adafruit_bus_device</span></strong><span class="koboSpan" id="kobo.254.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.255.1">adafruit_register</span></strong><span class="koboSpan" id="kobo.256.1">  modules to </span><span class="No-Break"><span class="koboSpan" id="kobo.257.1">be installed.</span></span></p>
<p><span class="koboSpan" id="kobo.258.1">You can now write some code to check if we can get data from the device. </span><span class="koboSpan" id="kobo.258.2">I suggest putting the following code </span><span class="No-Break"><span class="koboSpan" id="kobo.259.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.260.1">bno_connect/code.py</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.261.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.262.1">
import adafruit_bno055
import board
import busio
i2c = busio.I2C(sda=board.GP0, scl=board.GP1)
sensor = adafruit_bno055.BNO055_I2C(i2c)
print("Temperature: {} degrees C".format(sensor.temperature))</span></pre>
<p><span class="koboSpan" id="kobo.263.1">The code starts with imports. </span><span class="koboSpan" id="kobo.263.2">It then creates an I2C bus with the correct pins and constructs the sensor control object on this bus. </span></p>
<p><span class="koboSpan" id="kobo.264.1">The last line fetches the temperature from the sensor and prints it to serial. </span></p>
<p><span class="koboSpan" id="kobo.265.1">Send this to Raspberry Pi Pico as </span><strong class="source-inline"><span class="koboSpan" id="kobo.266.1">code.py</span></strong><span class="koboSpan" id="kobo.267.1">; it should show the temperature on the serial, </span><span class="No-Break"><span class="koboSpan" id="kobo.268.1">as follows:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.269.1">
code.py output:
Temperature: 21 degrees C</span></pre>
<p><span class="koboSpan" id="kobo.270.1">Great! </span><span class="koboSpan" id="kobo.270.2">You have now obtained data from the IMU. </span><span class="koboSpan" id="kobo.270.3">Before exploring more of the available features, let’s troubleshoot </span><span class="No-Break"><span class="koboSpan" id="kobo.271.1">any problems.</span></span></p>
<h2 id="_idParaDest-262"><a id="_idTextAnchor263"/><span class="koboSpan" id="kobo.272.1">Troubleshooting</span></h2>
<p><span class="koboSpan" id="kobo.273.1">If you don’t </span><a id="_idIndexMarker703"/><span class="koboSpan" id="kobo.274.1">see the temperature output (or see errors instead), verify the connections carefully. </span><span class="koboSpan" id="kobo.274.2">Start by powering down the robot, and carefully check the power goes to 3V3, then that GND goes </span><span class="No-Break"><span class="koboSpan" id="kobo.275.1">to ground.</span></span></p>
<p><span class="koboSpan" id="kobo.276.1">If these look correct, verify the SCL and SDA lines – swapping these lines is a common issue. </span><span class="koboSpan" id="kobo.276.2">You can then power the robot again, and you should be able to read </span><span class="No-Break"><span class="koboSpan" id="kobo.277.1">the temperature.</span></span></p>
<p><span class="koboSpan" id="kobo.278.1">With that, you have connected to the IMU. </span><span class="koboSpan" id="kobo.278.2">Now, let’s learn how to get robot orientation information from </span><span class="No-Break"><span class="koboSpan" id="kobo.279.1">this sensor.</span></span></p>
<h1 id="_idParaDest-263"><a id="_idTextAnchor264"/><span class="koboSpan" id="kobo.280.1">Calibrating and getting readings</span></h1>
<p><span class="koboSpan" id="kobo.281.1">When you start up code using an IMU module with a controller, the sensors will not get correct readings. </span><span class="koboSpan" id="kobo.281.2">So, the IMU module will need to determine the sensitivity and correct states of the sensor, a process </span><a id="_idIndexMarker704"/><span class="koboSpan" id="kobo.282.1">known as </span><strong class="bold"><span class="koboSpan" id="kobo.283.1">calibration</span></strong><span class="koboSpan" id="kobo.284.1">. </span><span class="koboSpan" id="kobo.284.2">First, we need some code; then, we’ll need to take the robot through some motions to </span><span class="No-Break"><span class="koboSpan" id="kobo.285.1">perform this.</span></span></p>
<h2 id="_idParaDest-264"><a id="_idTextAnchor265"/><span class="koboSpan" id="kobo.286.1">Calibration code</span></h2>
<p><span class="koboSpan" id="kobo.287.1">Let’s start </span><a id="_idIndexMarker705"/><span class="koboSpan" id="kobo.288.1">with the code. </span><span class="koboSpan" id="kobo.288.2">In a file called </span><strong class="source-inline"><span class="koboSpan" id="kobo.289.1">imu_calibration/code.py</span></strong><span class="koboSpan" id="kobo.290.1">, add </span><span class="No-Break"><span class="koboSpan" id="kobo.291.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.292.1">
import adafruit_bno055
import board
import busio
import time
i2c = busio.I2C(sda=board.GP0, scl=board.GP1)
sensor = adafruit_bno055.BNO055_I2C(i2c)</span></pre>
<p><span class="koboSpan" id="kobo.293.1">This code handles importing the module and setting it up. </span><span class="koboSpan" id="kobo.293.2">We also import </span><strong class="source-inline"><span class="koboSpan" id="kobo.294.1">time</span></strong><span class="koboSpan" id="kobo.295.1"> so that we can use it in loops later. </span></p>
<p><span class="koboSpan" id="kobo.296.1">Next, we must check the calibration state of </span><span class="No-Break"><span class="koboSpan" id="kobo.297.1">the module:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.298.1">
def check_status():
  sys_status, gyro, accel, mag = imu.calibration_status
  print(f"Sys: {sys_status}, Gyro: {gyro}, Accel: {accel}, Mag: {mag}")
  return sys_status == 3</span></pre>
<p><span class="koboSpan" id="kobo.299.1">This code will </span><a id="_idIndexMarker706"/><span class="koboSpan" id="kobo.300.1">print the calibration status for each part of the BNO055. </span><span class="koboSpan" id="kobo.300.2">The BNO055 can self-calibrate when turned on; however, the user needs to make motions with it to help. </span><span class="koboSpan" id="kobo.300.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.301.1">calibration_status</span></strong><span class="koboSpan" id="kobo.302.1"> register holds what parts of the system you have calibrated. </span><span class="koboSpan" id="kobo.302.2">The system status is important for our purposes, but each device has its own status. </span><span class="koboSpan" id="kobo.302.3">Each can go from state </span><strong class="source-inline"><span class="koboSpan" id="kobo.303.1">0</span></strong><span class="koboSpan" id="kobo.304.1"> (uncalibrated) to state </span><strong class="source-inline"><span class="koboSpan" id="kobo.305.1">3</span></strong><span class="koboSpan" id="kobo.306.1"> (fully calibrated). </span><span class="koboSpan" id="kobo.306.2">When you have calibrated them, the system is ready to use. </span><span class="koboSpan" id="kobo.306.3">This code will print them out. </span><span class="koboSpan" id="kobo.306.4">We’ll use this to perform the calibration </span><span class="No-Break"><span class="koboSpan" id="kobo.307.1">process motions.</span></span></p>
<p><span class="koboSpan" id="kobo.308.1">We can check this in </span><span class="No-Break"><span class="koboSpan" id="kobo.309.1">a loop:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.310.1">
while not check_status():
  time.sleep(0.1)</span></pre>
<p><span class="koboSpan" id="kobo.311.1">Once we’ve calibrated it, we can check the data from all the sensors and the </span><span class="No-Break"><span class="koboSpan" id="kobo.312.1">controller itself:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.313.1">
while True:
  data = {"temperature": sensor.temperature, 
          "acceleration": sensor.acceleration, 
          "magnetic": sensor.magnetic, 
          "gyro": sensor.gyro,
          "euler": sensor.euler}
  print(data)
  time.sleep(0.1)</span></pre>
<p><span class="koboSpan" id="kobo.314.1">This code will pull all the sensor data and ask the controller to convert the accelerometer, magnetometer, and gyroscope data into </span><strong class="bold"><span class="koboSpan" id="kobo.315.1">Euler</span></strong><span class="koboSpan" id="kobo.316.1"> absolute orientation. </span><span class="koboSpan" id="kobo.316.2">The code puts this into a dictionary so that when we print it, it will </span><span class="No-Break"><span class="koboSpan" id="kobo.317.1">appear labeled.</span></span></p>
<p><span class="koboSpan" id="kobo.318.1">We can upload </span><a id="_idIndexMarker707"/><span class="koboSpan" id="kobo.319.1">this code and start the calibration process, watching the numbers in the calibration status. </span><span class="koboSpan" id="kobo.319.2">Let’s use it </span><span class="No-Break"><span class="koboSpan" id="kobo.320.1">to calibrate.</span></span></p>
<h2 id="_idParaDest-265"><a id="_idTextAnchor266"/><span class="koboSpan" id="kobo.321.1">The calibration process</span></h2>
<p><span class="koboSpan" id="kobo.322.1">The following movements might look bizarre, but the IMU module is trying to determine the relative </span><a id="_idIndexMarker708"/><span class="koboSpan" id="kobo.323.1">motions for each sensor. </span><span class="koboSpan" id="kobo.323.2">Then, with the hold postures, it is looking at absolute states. </span><span class="koboSpan" id="kobo.323.3">With the magnetometer, there will be offsets and distortions due to the metal on board the robot. </span><span class="koboSpan" id="kobo.323.4">The sensor looks for magnetic field changes and the extent in each direction, which it can use to account for </span><span class="No-Break"><span class="koboSpan" id="kobo.324.1">the distortions.</span></span></p>
<p><span class="koboSpan" id="kobo.325.1">Beware of calibrating near strong magnetic fields such as a laptop – they can make the magnetometer </span><span class="No-Break"><span class="koboSpan" id="kobo.326.1">calibration incorrect.</span></span></p>
<p><span class="koboSpan" id="kobo.327.1">Use the following figure to help the IMU complete </span><span class="No-Break"><span class="koboSpan" id="kobo.328.1">its calibration:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer193">
<span class="koboSpan" id="kobo.329.1"><img alt="Figure 12.9 – IMU calibration steps " src="image/Figure_12.09_B18001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.330.1">Figure 12.9 – IMU calibration steps</span></p>
<p><span class="koboSpan" id="kobo.331.1">The preceding figure shows the calibration steps. </span><span class="koboSpan" id="kobo.331.2">Use a hold time of at least 2 seconds and slow motions for the </span><span class="No-Break"><span class="koboSpan" id="kobo.332.1">following steps:</span></span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.333.1">Start with the robot on a flat surface and hold. </span><span class="koboSpan" id="kobo.333.2">This position will set up </span><span class="No-Break"><span class="koboSpan" id="kobo.334.1">the gyroscope.</span></span></li>
<li><span class="koboSpan" id="kobo.335.1">Make a small, slow figure of 8 motion a few times to calibrate </span><span class="No-Break"><span class="koboSpan" id="kobo.336.1">the magnetometer.</span></span></li>
<li><span class="koboSpan" id="kobo.337.1">Hold the robot on its back, then on </span><span class="No-Break"><span class="koboSpan" id="kobo.338.1">its front.</span></span></li>
<li><span class="koboSpan" id="kobo.339.1">Then, hold the robot on its left, then on </span><span class="No-Break"><span class="koboSpan" id="kobo.340.1">its right.</span></span></li>
<li><span class="koboSpan" id="kobo.341.1">Hold the robot upside down; you should see the accelerometer status </span><span class="No-Break"><span class="koboSpan" id="kobo.342.1">reach 3.</span></span></li>
<li><span class="koboSpan" id="kobo.343.1">Now, rest it back the right way up. </span><span class="koboSpan" id="kobo.343.2">You should be able to see the system status </span><span class="No-Break"><span class="koboSpan" id="kobo.344.1">reach 3.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.345.1">This calibration </span><a id="_idIndexMarker709"/><span class="koboSpan" id="kobo.346.1">may take a few attempts and can get stuck on the accelerometer sometimes; however, the experiments can continue if the system status reaches 3 without </span><span class="No-Break"><span class="koboSpan" id="kobo.347.1">the accelerometer.</span></span></p>
<p><span class="koboSpan" id="kobo.348.1">When you have the system status at 3, the demonstration will start printing data from all four sensors and combine sensor data into Euler angles. </span><span class="koboSpan" id="kobo.348.2">With the robot standing, roll and pitch should be </span><strong class="source-inline"><span class="koboSpan" id="kobo.349.1">0</span></strong><span class="koboSpan" id="kobo.350.1">. </span><span class="koboSpan" id="kobo.350.2">Turning the robot to face North should set the heading to </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.351.1">0</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.352.1"> too.</span></span></p>
<p><span class="koboSpan" id="kobo.353.1">We can now use this with a PID controller to make the robot always </span><span class="No-Break"><span class="koboSpan" id="kobo.354.1">face North.</span></span></p>
<h1 id="_idParaDest-266"><a id="_idTextAnchor267"/><span class="koboSpan" id="kobo.355.1">Always face North behavior</span></h1>
<p><span class="koboSpan" id="kobo.356.1">We’ll build a behavior </span><a id="_idIndexMarker710"/><span class="koboSpan" id="kobo.357.1">with a heading as a set </span><a id="_idIndexMarker711"/><span class="koboSpan" id="kobo.358.1">point for a PID and the IMU Euler heading as feedback. </span><span class="koboSpan" id="kobo.358.2">The error value between these will be how far, in degrees, the robot is facing away from the North heading. </span><span class="koboSpan" id="kobo.358.3">For example, a heading of </span><strong class="source-inline"><span class="koboSpan" id="kobo.359.1">0</span></strong><span class="koboSpan" id="kobo.360.1"> should be North – note that you could pick another heading as needed. </span><span class="koboSpan" id="kobo.360.2">We will use the PID output to control the motor movements, with the output adding to the speed of one motor and subtracting from the other, producing </span><span class="No-Break"><span class="koboSpan" id="kobo.361.1">a turn.</span></span></p>
<p><span class="koboSpan" id="kobo.362.1">Let’s see how this looks as a </span><span class="No-Break"><span class="koboSpan" id="kobo.363.1">block diagram:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer194">
<span class="koboSpan" id="kobo.364.1"><img alt="Figure 12.10 – Face North behavior block diagram " src="image/Figure_12.10_B18001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.365.1">Figure 12.10 – Face North behavior block diagram</span></p>
<p><span class="koboSpan" id="kobo.366.1">The preceding diagram shows the flow of data. </span><span class="koboSpan" id="kobo.366.2">The </span><strong class="bold"><span class="koboSpan" id="kobo.367.1">expected heading</span></strong><span class="koboSpan" id="kobo.368.1"> (or target) with the </span><strong class="bold"><span class="koboSpan" id="kobo.369.1">actual heading</span></strong><span class="koboSpan" id="kobo.370.1"> from the IMU are used to calculate the </span><strong class="bold"><span class="koboSpan" id="kobo.371.1">error</span></strong><span class="koboSpan" id="kobo.372.1">. </span><span class="koboSpan" id="kobo.372.2">This error and </span><strong class="source-inline"><span class="koboSpan" id="kobo.373.1">dt</span></strong><span class="koboSpan" id="kobo.374.1"> (delta time) are </span><a id="_idIndexMarker712"/><span class="koboSpan" id="kobo.375.1">the inputs to the PID. </span><span class="koboSpan" id="kobo.375.2">The </span><a id="_idIndexMarker713"/><span class="koboSpan" id="kobo.376.1">output from the PID, the </span><strong class="bold"><span class="koboSpan" id="kobo.377.1">control signal</span></strong><span class="koboSpan" id="kobo.378.1">, is added for one motor and subtracted for the other. </span><span class="koboSpan" id="kobo.378.2">The motors then result in robot movement, which causes the IMU heading to change, feeding back into the </span><span class="No-Break"><span class="koboSpan" id="kobo.379.1">error value.</span></span></p>
<p><span class="koboSpan" id="kobo.380.1">We can now use this block diagram to build the code for </span><span class="No-Break"><span class="koboSpan" id="kobo.381.1">this behavior.</span></span></p>
<h2 id="_idParaDest-267"><a id="_idTextAnchor268"/><span class="koboSpan" id="kobo.382.1">CircuitPython code for the face North behavior</span></h2>
<p><span class="koboSpan" id="kobo.383.1">We can </span><a id="_idIndexMarker714"/><span class="koboSpan" id="kobo.384.1">now build the code for this </span><a id="_idIndexMarker715"/><span class="koboSpan" id="kobo.385.1">behavior. </span><span class="koboSpan" id="kobo.385.2">We’ll start by putting the IMU initialization in </span><strong class="source-inline"><span class="koboSpan" id="kobo.386.1">robot.py</span></strong><span class="koboSpan" id="kobo.387.1">. </span><span class="koboSpan" id="kobo.387.2">Add the following to the imports at the top </span><span class="No-Break"><span class="koboSpan" id="kobo.388.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.389.1">robot.py</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.390.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.391.1">
import adafruit_bno055</span></pre>
<p><span class="koboSpan" id="kobo.392.1">Since the distance sensors already use the I2C bus, we can use the same initialized I2C bus for </span><span class="No-Break"><span class="koboSpan" id="kobo.393.1">the BNO055:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.394.1">
left_distance = adafruit_vl53l1x.VL53L1X(i2c0)
right_distance = adafruit_vl53l1x.VL53L1X(i2c1)
</span><strong class="bold"><span class="koboSpan" id="kobo.395.1">imu = adafruit_bno055.BNO055_I2C(i2c0)</span></strong></pre>
<p><span class="koboSpan" id="kobo.396.1">The IMU will be available from </span><strong class="source-inline"><span class="koboSpan" id="kobo.397.1">robot.py</span></strong><span class="koboSpan" id="kobo.398.1"> once this has loaded. </span><span class="koboSpan" id="kobo.398.2">We can also add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.399.1">check_status</span></strong><span class="koboSpan" id="kobo.400.1"> calibration function to </span><strong class="source-inline"><span class="koboSpan" id="kobo.401.1">robot.py</span></strong><span class="koboSpan" id="kobo.402.1"> so that we can use that in </span><span class="No-Break"><span class="koboSpan" id="kobo.403.1">other behaviors:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.404.1">
def check_imu_status():
  sys_status, gyro, accel, mag = imu.calibration_status
  uart.write(f"Sys: {sys_status}, Gyro: {gyro}, Accel: {accel}, Mag: {mag}\n".encode())
  return sys_status == 3</span></pre>
<p><span class="koboSpan" id="kobo.405.1">The </span><a id="_idIndexMarker716"/><span class="koboSpan" id="kobo.406.1">changes to </span><strong class="source-inline"><span class="koboSpan" id="kobo.407.1">robot.py</span></strong><span class="koboSpan" id="kobo.408.1"> for this </span><a id="_idIndexMarker717"/><span class="koboSpan" id="kobo.409.1">section </span><span class="No-Break"><span class="koboSpan" id="kobo.410.1">are complete.</span></span></p>
<p><span class="koboSpan" id="kobo.411.1">We will need a new file for the behavior, which I suggest placing in </span><strong class="source-inline"><span class="koboSpan" id="kobo.412.1">face_north/code.py</span></strong><span class="koboSpan" id="kobo.413.1">. </span><span class="koboSpan" id="kobo.413.2">We’ll start with </span><span class="No-Break"><span class="koboSpan" id="kobo.414.1">the imports:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.415.1">
import robot
import pid_controller
import asyncio
import time</span></pre>
<p><span class="koboSpan" id="kobo.416.1">We will then make a controller class for always facing North. </span><span class="koboSpan" id="kobo.416.2">It starts by defining the target as </span><strong class="source-inline"><span class="koboSpan" id="kobo.417.1">0</span></strong><span class="koboSpan" id="kobo.418.1"> for North and setting up a </span><span class="No-Break"><span class="koboSpan" id="kobo.419.1">PID controller:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.420.1">
class FaceNorthController:
    def __init__(self):
        self.pid = pid_controller.PIDController(0.01, 0.010, 0)
        self.target = 0
    def update(self, dt, angle):
        error = self.target - angle
        if error &gt; 180:
            error -= 360
        elif error &lt; -180:
            error += 360
        control_signal = self.pid.calculate(error, dt)
        robot.set_left(control_signal)
        robot.set_right(-control_signal)</span></pre>
<p><span class="koboSpan" id="kobo.421.1">The code here calls the </span><strong class="source-inline"><span class="koboSpan" id="kobo.422.1">update</span></strong><span class="koboSpan" id="kobo.423.1"> method with an </span><strong class="source-inline"><span class="koboSpan" id="kobo.424.1">angle</span></strong><span class="koboSpan" id="kobo.425.1"> and a delta time (</span><strong class="source-inline"><span class="koboSpan" id="kobo.426.1">dt</span></strong><span class="koboSpan" id="kobo.427.1">). </span><span class="koboSpan" id="kobo.427.2">First, it will </span><a id="_idIndexMarker718"/><span class="koboSpan" id="kobo.428.1">calculate the error in degrees. </span><span class="koboSpan" id="kobo.428.2">The </span><a id="_idIndexMarker719"/><span class="koboSpan" id="kobo.429.1">method then checks the error in the range of -180 to 180 degrees. </span><span class="koboSpan" id="kobo.429.2">Otherwise, a robot at 359 degrees (-1 degrees from North) will turn a full circle to adjust itself, and any overshoot would result in </span><span class="No-Break"><span class="koboSpan" id="kobo.430.1">unusable behavior.</span></span></p>
<p><span class="koboSpan" id="kobo.431.1">Then, we pass </span><strong class="source-inline"><span class="koboSpan" id="kobo.432.1">error</span></strong><span class="koboSpan" id="kobo.433.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.434.1">dt</span></strong><span class="koboSpan" id="kobo.435.1"> into the PID </span><strong class="source-inline"><span class="koboSpan" id="kobo.436.1">calculate</span></strong><span class="koboSpan" id="kobo.437.1"> method and send the resulting control signals to </span><span class="No-Break"><span class="koboSpan" id="kobo.438.1">the motors.</span></span></p>
<p><span class="koboSpan" id="kobo.439.1">We can now have an </span><strong class="source-inline"><span class="koboSpan" id="kobo.440.1">async</span></strong><span class="koboSpan" id="kobo.441.1"> task to manage this controller and read the sensor data in </span><span class="No-Break"><span class="koboSpan" id="kobo.442.1">a loop:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.443.1">
async def control_loop():
  controller = FaceNorthController()
  last_time = time.monotonic()
  while True:
    await asyncio.sleep(0.1)
    next_time = time.monotonic()
    dt = next_time - last_time
    last_time = next_time
    angle = robot.imu.euler[0]
    controller.update(dt, angle)
    robot.uart.write(f"{angle}, 0\n".encode())</span></pre>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.444.1">control_loop</span></strong><span class="koboSpan" id="kobo.445.1"> creates an instance of our </span><strong class="source-inline"><span class="koboSpan" id="kobo.446.1">FaceNorthController</span></strong><span class="koboSpan" id="kobo.447.1"> shown previously. </span><span class="koboSpan" id="kobo.447.2">It sleeps and manages the delta time, </span><strong class="source-inline"><span class="koboSpan" id="kobo.448.1">dt</span></strong><span class="koboSpan" id="kobo.449.1">. </span><span class="koboSpan" id="kobo.449.2">Next, it reads the angle from the sensor’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.450.1">euler</span></strong><span class="koboSpan" id="kobo.451.1"> data and passes this to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.452.1">update</span></strong><span class="koboSpan" id="kobo.453.1"> method. </span><span class="koboSpan" id="kobo.453.2">Finally, this method logs the angle through Bluetooth so that we can </span><span class="No-Break"><span class="koboSpan" id="kobo.454.1">plot it.</span></span></p>
<p><span class="koboSpan" id="kobo.455.1">Now, we can make our </span><strong class="source-inline"><span class="koboSpan" id="kobo.456.1">main</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.457.1">async function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.458.1">
async def main():
  while not robot.check_imu_status():
    await asyncio.sleep(0.1)
  robot.uart.write("Ready to go!\n".encode())</span></pre>
<p><span class="koboSpan" id="kobo.459.1">This part </span><a id="_idIndexMarker720"/><span class="koboSpan" id="kobo.460.1">will start a calibration/status loop and print it via Bluetooth when the robot is ready. </span><span class="koboSpan" id="kobo.460.2">Because we don’t </span><a id="_idIndexMarker721"/><span class="koboSpan" id="kobo.461.1">want the robot to start trying to drive out of your hands, we will make it wait for a start signal </span><span class="No-Break"><span class="koboSpan" id="kobo.462.1">from Bluetooth:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.463.1">
  while True:
    if robot.uart.in_waiting:
      command = robot.uart.readline().decode().strip()
      if command == "start":
        break
    await asyncio.sleep(0.1)
  await control_loop()</span></pre>
<p><span class="koboSpan" id="kobo.464.1">The user will see </span><strong class="bold"><span class="koboSpan" id="kobo.465.1">Ready to go</span></strong><span class="koboSpan" id="kobo.466.1"> and then need to send </span><strong class="source-inline"><span class="koboSpan" id="kobo.467.1">start</span></strong><span class="koboSpan" id="kobo.468.1"> to make the robot move. </span><span class="koboSpan" id="kobo.468.2">The code then starts the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.469.1">control_loop</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.470.1"> part.</span></span></p>
<p><span class="koboSpan" id="kobo.471.1">Finally, we can start everything up by starting the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.472.1">main</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.473.1"> task:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.474.1">
asyncio.run(main())</span></pre>
<p><span class="koboSpan" id="kobo.475.1">You should be able to send this to the robot and calibrate it. </span><span class="koboSpan" id="kobo.475.2">Then, when you instruct it to start, the robot will turn to </span><span class="No-Break"><span class="koboSpan" id="kobo.476.1">face North.</span></span></p>
<h2 id="_idParaDest-268"><a id="_idTextAnchor269"/><span class="koboSpan" id="kobo.477.1">Troubleshooting</span></h2>
<p><span class="koboSpan" id="kobo.478.1">The robot may be turning to an angle that is not North. </span><span class="koboSpan" id="kobo.478.2">The common reason for this is that there </span><a id="_idIndexMarker722"/><span class="koboSpan" id="kobo.479.1">is a strong magnetic field where you are testing or calibrating the robot. </span><span class="koboSpan" id="kobo.479.2">In some situations, I have found that I’ve had to turn a sensor 90 degrees for it </span><span class="No-Break"><span class="koboSpan" id="kobo.480.1">to work.</span></span></p>
<p><span class="koboSpan" id="kobo.481.1">If the robot is overshooting, try reducing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.482.1">P</span></strong><span class="koboSpan" id="kobo.483.1"> value. </span><span class="koboSpan" id="kobo.483.2">If it is taking a while to hunt out the actual value, increase the I value a little. </span><span class="koboSpan" id="kobo.483.3">I have found that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.484.1">D</span></strong><span class="koboSpan" id="kobo.485.1"> value doesn’t help in </span><span class="No-Break"><span class="koboSpan" id="kobo.486.1">this situation.</span></span></p>
<p><span class="koboSpan" id="kobo.487.1">Now that we know how to face one way, can we use this to make a fixed turn in any direction? </span><span class="No-Break"><span class="koboSpan" id="kobo.488.1">Let’s see.</span></span></p>
<h1 id="_idParaDest-269"><a id="_idTextAnchor270"/><span class="koboSpan" id="kobo.489.1">Making a known turn behavior</span></h1>
<p><span class="koboSpan" id="kobo.490.1">The known turn behavior is a variation of the always face North behavior. </span><span class="koboSpan" id="kobo.490.2">The idea is to measure the angle at the start of the turn and then make the set point the new </span><span class="No-Break"><span class="koboSpan" id="kobo.491.1">intended angle.</span></span></p>
<p><span class="koboSpan" id="kobo.492.1">We’ll make it so that the whole app will accept a difference in the intended angle, offsetting the last intended angle, with the whole app starting based on the robot’s current heading. </span><span class="koboSpan" id="kobo.492.2">The user can send </span><strong class="source-inline"><span class="koboSpan" id="kobo.493.1">+30</span></strong><span class="koboSpan" id="kobo.494.1"> to turn 30 degrees and </span><strong class="source-inline"><span class="koboSpan" id="kobo.495.1">-90</span></strong><span class="koboSpan" id="kobo.496.1"> to rotate 90 </span><span class="No-Break"><span class="koboSpan" id="kobo.497.1">degrees back.</span></span></p>
<p><span class="koboSpan" id="kobo.498.1">The block diagram is exactly as before, as we only need to manipulate the expected heading. </span><span class="koboSpan" id="kobo.498.2">Make a copy of </span><strong class="source-inline"><span class="koboSpan" id="kobo.499.1">face_north</span></strong><span class="koboSpan" id="kobo.500.1"> in a folder called </span><strong class="source-inline"><span class="koboSpan" id="kobo.501.1">known_turn</span></strong><span class="koboSpan" id="kobo.502.1">. </span><span class="koboSpan" id="kobo.502.2">Let’s rename the </span><span class="No-Break"><span class="koboSpan" id="kobo.503.1">controller </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.504.1">IMUTurnController</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.505.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.506.1">
class </span><strong class="bold"><span class="koboSpan" id="kobo.507.1">IMUTurnController</span></strong><span class="koboSpan" id="kobo.508.1">:
    def __init__(self):
        self.pid = pid_controller.PIDController(0.01, 0.008, 0)
        self.target = 0</span></pre>
<p><span class="koboSpan" id="kobo.509.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.510.1">update</span></strong><span class="koboSpan" id="kobo.511.1"> method doesn’t change, as </span><span class="No-Break"><span class="koboSpan" id="kobo.512.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.513.1">
    def update(self, dt, angle):
        error = self.target – angle
        if error &gt; 180:
            error -= 360
        elif error &lt; -180:
            error += 360
        control_signal = self.pid.calculate(error, dt)
        robot.set_left(control_signal)
        robot.set_right(-control_signal)</span></pre>
<p><span class="koboSpan" id="kobo.514.1">We will need an additional Bluetooth </span><strong class="source-inline"><span class="koboSpan" id="kobo.515.1">command_handler</span></strong><span class="koboSpan" id="kobo.516.1"> for accepting user input for the intended angle. </span><span class="koboSpan" id="kobo.516.2">Add the </span><span class="No-Break"><span class="koboSpan" id="kobo.517.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.518.1">
async def command_handler(turn_controller):
  while True:
    if robot.uart.in_waiting:
      command = robot.uart.readline().decode().strip()
      if command.startswith("-"):
        turn_controller.target -= int(command.lstrip('-'))
      elif command.startswith("+"):
        turn_controller.target += int(command.lstrip('+'))
    await asyncio.sleep(0)</span></pre>
<p><span class="koboSpan" id="kobo.519.1">This handler sets the target (set point) of </span><strong class="source-inline"><span class="koboSpan" id="kobo.520.1">turn_controller</span></strong><span class="koboSpan" id="kobo.521.1"> for dealing with positive and negative number settings. </span></p>
<p><span class="koboSpan" id="kobo.522.1">We can now integrate these into a </span><span class="No-Break"><span class="koboSpan" id="kobo.523.1">modified </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.524.1">control_loop</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.525.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.526.1">
async def control_loop():
  controller = IMUTurnController()
  </span><strong class="bold"><span class="koboSpan" id="kobo.527.1">controller.target = robot.imu.euler[0]</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.528.1">  asyncio.create_task(command_handler(controller))</span></strong><span class="koboSpan" id="kobo.529.1">
  last_time = time.monotonic()
  while True:
    await asyncio.sleep(0.1)
    next_time = time.monotonic()
    dt = next_time - last_time
    last_time = next_time
    angle = robot.imu.euler[0]
    controller.update(dt, angle)
    robot.uart.write(f"{angle}, 0\n".encode())</span></pre>
<p><span class="koboSpan" id="kobo.530.1">This control loop sets the controller target as the current robot’s heading instead of </span><strong class="source-inline"><span class="koboSpan" id="kobo.531.1">0</span></strong><span class="koboSpan" id="kobo.532.1">. </span><span class="koboSpan" id="kobo.532.2">It will also create the command handler async task with the controller as </span><span class="No-Break"><span class="koboSpan" id="kobo.533.1">a parameter.</span></span></p>
<p><span class="koboSpan" id="kobo.534.1">The loop is the same as what we </span><span class="No-Break"><span class="koboSpan" id="kobo.535.1">saw previously.</span></span></p>
<p><span class="koboSpan" id="kobo.536.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.537.1">main</span></strong><span class="koboSpan" id="kobo.538.1"> method for this gets to be much simpler as the robot will not move until we ask </span><span class="No-Break"><span class="koboSpan" id="kobo.539.1">it to:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.540.1">
async def main():
  while not robot.check_imu_status():
    await asyncio.sleep(0.1)
  robot.uart.write("Ready to go!\n".encode())
  await control_loop()
asyncio.run(main())</span></pre>
<p><span class="koboSpan" id="kobo.541.1">Send this to the robot and calibrate it. </span><span class="koboSpan" id="kobo.541.2">Then, when you see </span><strong class="bold"><span class="koboSpan" id="kobo.542.1">Ready to go</span></strong><span class="koboSpan" id="kobo.543.1"> on Bluetooth, you can send back an angle </span><span class="No-Break"><span class="koboSpan" id="kobo.544.1">to turn.</span></span></p>
<p><span class="koboSpan" id="kobo.545.1">The same troubleshooting steps apply </span><span class="No-Break"><span class="koboSpan" id="kobo.546.1">as before.</span></span></p>
<p><span class="koboSpan" id="kobo.547.1">Try </span><strong class="source-inline"><span class="koboSpan" id="kobo.548.1">30</span></strong><span class="koboSpan" id="kobo.549.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.550.1">45</span></strong><span class="koboSpan" id="kobo.551.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.552.1">60</span></strong><span class="koboSpan" id="kobo.553.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.554.1">90</span></strong><span class="koboSpan" id="kobo.555.1">, or small values such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.556.1">5</span></strong><span class="koboSpan" id="kobo.557.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.558.1">10</span></strong><span class="koboSpan" id="kobo.559.1"> degrees. </span><span class="koboSpan" id="kobo.559.2">Do not go above </span><strong class="source-inline"><span class="koboSpan" id="kobo.560.1">179</span></strong><span class="koboSpan" id="kobo.561.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.562.1">-179</span></strong><span class="koboSpan" id="kobo.563.1">, as this can cause the robot to spin until turned off. </span><span class="koboSpan" id="kobo.563.2">You could add code to </span><span class="No-Break"><span class="koboSpan" id="kobo.564.1">limit this.</span></span></p>
<p><span class="koboSpan" id="kobo.565.1">It can be helpful to store the error in </span><strong class="source-inline"><span class="koboSpan" id="kobo.566.1">IMUTurnController</span></strong><span class="koboSpan" id="kobo.567.1"> (as </span><strong class="source-inline"><span class="koboSpan" id="kobo.568.1">self.error</span></strong><span class="koboSpan" id="kobo.569.1">) and plot this data instead of the angle for tuning </span><span class="No-Break"><span class="koboSpan" id="kobo.570.1">the PID.</span></span></p>
<p><span class="koboSpan" id="kobo.571.1">You can now make a </span><span class="No-Break"><span class="koboSpan" id="kobo.572.1">known turn.</span></span></p>
<h1 id="_idParaDest-270"><a id="_idTextAnchor271"/><span class="koboSpan" id="kobo.573.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.574.1">In this chapter, we investigated the IMU and how we can use it to control the heading of our robot. </span><span class="koboSpan" id="kobo.574.2">We learned how to connect the device and </span><span class="No-Break"><span class="koboSpan" id="kobo.575.1">calibrate it.</span></span></p>
<p><span class="koboSpan" id="kobo.576.1">Then, we used data from it to face North by combining the sensor data with a PID controller. </span><span class="koboSpan" id="kobo.576.2">Finally, we built on this example so that it can turn a specified number from the </span><span class="No-Break"><span class="koboSpan" id="kobo.577.1">current heading.</span></span></p>
<p><span class="koboSpan" id="kobo.578.1">In the next chapter, we will build a small arena for the robot and look at how we can combine the encoders and distance sensors to estimate the robot’s position within this arena, improving its estimation as </span><span class="No-Break"><span class="koboSpan" id="kobo.579.1">it moves.</span></span></p>
<h1 id="_idParaDest-271"><a id="_idTextAnchor272"/><span class="koboSpan" id="kobo.580.1">Exercises</span></h1>
<p><span class="koboSpan" id="kobo.581.1">These exercises will deepen your understanding of the topics that were covered in this chapter and make the robot </span><span class="No-Break"><span class="koboSpan" id="kobo.582.1">code better:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.583.1">Combining the preceding behaviors with the menu system for the UART we’ve seen in previous chapters would allow you to tune the PID with the </span><span class="No-Break"><span class="koboSpan" id="kobo.584.1">robot running.</span></span></li>
<li><span class="koboSpan" id="kobo.585.1">Could you use the known turn behavior and straight-line behavior to write a better version of the planned path program from </span><a href="B18001_05.xhtml#_idTextAnchor098"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.586.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.587.1">, </span><em class="italic"><span class="koboSpan" id="kobo.588.1">Driving Motors with Raspberry </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.589.1">Pi Pico</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.590.1">?</span></span></li>
<li><span class="koboSpan" id="kobo.591.1">Experiment with the Euler heading reading – after calibrating, see how the readings change when you bring the robot near objects such as a laptop or kitchen appliances. </span><span class="koboSpan" id="kobo.591.2">This experiment will demonstrate a weakness with this kind </span><span class="No-Break"><span class="koboSpan" id="kobo.592.1">of sensor.</span></span></li>
<li><span class="koboSpan" id="kobo.593.1">An advanced experiment would be to extract the quaternion (instead of Euler data) and write this to </span><span class="No-Break"><span class="koboSpan" id="kobo.594.1">the UART.</span></span></li>
</ul>
<h1 id="_idParaDest-272"><a id="_idTextAnchor273"/><span class="koboSpan" id="kobo.595.1">Further reading</span></h1>
<p><span class="koboSpan" id="kobo.596.1">These further study aids will help you learn more and dive deeper into the PID algorithm and </span><span class="No-Break"><span class="koboSpan" id="kobo.597.1">its quirks:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.598.1">The Adafruit CircuitPythong API guide for the BNO055 shows what else you can do with this sensor: </span><a href="https://docs.circuitpython.org/projects/bno055/en/latest/api.html"><span class="koboSpan" id="kobo.599.1">https://docs.circuitpython.org/projects/bno055/en/latest/api.html</span></a><span class="koboSpan" id="kobo.600.1"> - </span><span class="No-Break"><span class="koboSpan" id="kobo.601.1">BNO055</span></span><span class="No-Break"><span class="koboSpan" id="kobo.602.1">.</span></span></li>
<li><em class="italic"><span class="koboSpan" id="kobo.603.1">Learn Robotics Programming</span></em><span class="koboSpan" id="kobo.604.1"> provides a guide for interfacing a Raspberry Pi device with a different IMU chip, the ICM90248, and writing code to calculate Euler angles, along with interesting ways to visualize this. </span><span class="koboSpan" id="kobo.604.2">It also shows how you can use encoders to make a known turn instead, perhaps when objects distort the </span><span class="No-Break"><span class="koboSpan" id="kobo.605.1">magnetometer readings.</span></span></li>
<li><span class="koboSpan" id="kobo.606.1">Paul McWhorter performs Arduino experiments with the same BNO055 sensor in an intensive video </span><span class="No-Break"><span class="koboSpan" id="kobo.607.1">series: </span></span><a href="https://toptechboy.com/arduino-based-9-axis-inertial-measurement-unit-imu-based-on-bno055-sensor/"><span class="No-Break"><span class="koboSpan" id="kobo.608.1">https://toptechboy.com/arduino-based-9-axis-inertial-measurement-unit-imu-based-on-bno055-sensor/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.609.1">.</span></span></li>
</ul>
</div>
</body></html>