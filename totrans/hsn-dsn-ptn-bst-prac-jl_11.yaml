- en: Robustness Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 健壮性模式
- en: This chapter will cover several patterns that can be used to improve software
    robustness. By robustness, we are referring to the quality aspects, that is, can
    the software perform its functions correctly? Are all possible scenarios handled
    properly? This is an extremely important factor to consider when writing code
    for mission-critical systems.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍几种可以提高软件健壮性的模式。当我们提到健壮性时，我们指的是质量方面，即软件能否正确执行其功能？是否妥善处理了所有可能的场景？这是在编写关键任务系统代码时需要考虑的一个极其重要的因素。
- en: Based on the **Principle of Least Privilege** (**POLP**), we would consider
    hiding unnecessary implementation details to the client of the interface. However,
    Julia's data structure is transparent – all fields are automatically exposed and
    accessible. This poses a potential problem because any improper usage or mutation
    can break the system. Additionally, by accessing the fields directly, the code
    becomes more tightly coupled with the underlying implementation of an object.
    So, what if a field name needs to be changed? What if a field needs to be replaced
    by another one? Therefore, there is a need to apply abstraction and decouple object
    implementation from its official interface. We should adopt the more general definition –
    not only do we want to cover as many lines of code as possible but also every
    possible scenario as well. An increase in code coverage would give us more confidence
    about the correctness of our code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 根据**最小权限原则**（**POLP**），我们会考虑隐藏不必要的实现细节给接口的客户端。然而，Julia的数据结构是透明的——所有字段都自动暴露并可访问。这可能会带来潜在的问题，因为任何不当的使用或修改都可能破坏系统。此外，通过直接访问字段，代码与对象的底层实现耦合得更紧密。那么，如果需要更改字段名怎么办？如果需要用另一个字段替换它怎么办？因此，有必要应用抽象，将对象实现与其官方接口解耦。我们应该采用更通用的定义——不仅希望覆盖尽可能多的代码行，还希望涵盖所有可能的场景。代码覆盖率的提高将使我们更有信心地确保代码的正确性。
- en: 'We have classified these techniques into the following sections:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这些技术分为以下几部分：
- en: Accessor patterns
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问者模式
- en: Property patterns
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性模式
- en: Let block patterns
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码块模式
- en: Exception handling patterns
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常处理模式
- en: By the end of this chapter, you will be able to encapsulate data access by developing
    your own accessor functions and property functions. You will also be able to hide
    away global variables from unexpected access outside of the module. Finally, you
    will also know about various exception handling techniques and understand how
    to retry failed operations.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够通过开发自己的访问器函数和属性函数来封装数据访问。你还将能够隐藏模块外的意外访问的全局变量。最后，你还将了解各种异常处理技术，并理解如何重试失败的操作。
- en: '*Let''s get started!*'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*让我们开始吧！*'
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The example source code for this chapter can be found at [https://github.com/PacktPublishing/Hands-on-Design-Patterns-and-Best-Practices-with-Julia/tree/master/Chapter08](https://github.com/PacktPublishing/Hands-on-Design-Patterns-and-Best-Practices-with-Julia/tree/master/Chapter08).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例源代码可以在[https://github.com/PacktPublishing/Hands-on-Design-Patterns-and-Best-Practices-with-Julia/tree/master/Chapter08](https://github.com/PacktPublishing/Hands-on-Design-Patterns-and-Best-Practices-with-Julia/tree/master/Chapter08)找到。
- en: The code is tested in a Julia 1.3.0 environment.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 代码在Julia 1.3.0环境中进行了测试。
- en: Accessor patterns
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问者模式
- en: Julia objects are transparent. What does that mean? Well, currently, the Julia
    language does not have the ability to apply access control over the fields of
    an object. Therefore, people coming from a C++ or Java background may find it
    a little uneasy. In this section, we will explore a number of ways in which to
    make the language more acceptable for those users who are seeking more access
    control.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Julia对象是透明的。这是什么意思呢？目前，Julia语言没有能力对对象的字段应用访问控制。因此，来自C++或Java背景的人可能会觉得有点不习惯。在本节中，我们将探讨多种方法，使语言更易于那些寻求更多访问控制的用户接受。
- en: 'So, perhaps we should define our requirements first. While we write up the
    requirements, we will also ask ourselves why we want to have them in the first
    place. Let''s just consider any object in a Julia program:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可能首先应该定义我们的需求。在我们编写需求的同时，我们也会问自己为什么一开始就要有这些需求。让我们考虑一下Julia程序中的任何对象：
- en: '**Some fields need to be hidden from the outside world**: Some fields are considered
    to be part of the public interface and are, therefore, fully documented and supported.
    Other fields are considered implementation details, and they may not be used because
    they are subject to change in the future.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一些字段需要对外界隐藏**：一些字段被认为是公共接口的一部分，因此它们被完全文档化和支持。其他字段被认为是实现细节，它们可能不会被使用，因为它们可能会在未来发生变化。'
- en: '**Some fields require validation before being mutated**: Some fields may only accept
    a range of values. For example, an `age` field of a `Person` object may reject
    anything less than 0 or greater than 120! Avoiding invalid data is paramount to
    building robust systems.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一些字段在修改之前需要验证**：一些字段可能只能接受一定范围内的值。例如，一个 `Person` 对象的 `age` 字段可能会拒绝小于 0 或大于
    120 的任何值！避免无效数据对于构建健壮的系统至关重要。'
- en: '**Some fields require a trigger before they can be read**: Some fields may
    be lazily loaded, which means they are not loaded until the value is read. Another
    reason is that some fields may contain sensitive data, and the use of such fields
    must be logged for audit purposes.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一些字段在读取之前需要触发器**：一些字段可能是延迟加载的，这意味着它们只有在读取值时才会被加载。另一个原因是，一些字段可能包含敏感数据，并且为了审计目的，必须记录对这些字段的用途。'
- en: We will now discuss how to address these requirements.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将讨论如何满足这些要求。
- en: Recognizing the implicit interface of an object
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 识别对象的隐含接口
- en: Before we dive into the specific patterns, let's first take a quick detour and
    discuss how and why we have a problem in the first place.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入具体模式之前，让我们先快速地绕道一下，讨论一下我们最初是如何以及为什么会有这个问题。
- en: 'Suppose that we have defined a data type called `Simulation` to keep track
    of some scientific experiment data and related statistics. The syntax for it is
    as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们已经定义了一个名为 `Simulation` 的数据类型，用于跟踪一些科学实验数据和相关的统计信息。它的语法如下：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'A `Simulation` object contains an N-dimensional array of floating-point values
    and a named tuple of statistical values. For demonstration purposes, we will create
    a simple function to perform a simulation and create an object, as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `Simulation` 对象包含一个 N 维浮点值数组和统计值的命名元组。为了演示目的，我们将创建一个简单的函数来执行模拟并创建一个对象，如下所示：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The simulation data called `heatmap` is generated using the `rand` function
    based on a distribution provided by the user. The `dims` argument represents the
    number of dimensions in the array, and the value of `n` represents the size of
    each dimension. Here''s how to simulate a normally distributed 2-dimensional heatmap
    of size 1000 x 1000:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 使用用户提供的分布的 `rand` 函数生成的模拟数据称为 `heatmap`。`dims` 参数表示数组中的维度数，而 `n` 的值表示每个维度的尺寸。以下是如何模拟一个大小为
    1000 x 1000 的正态分布二维热图的示例：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'At this point, we can easily access the `heatmap` and `stats` fields of the
    object as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们可以轻松地访问对象的 `heatmap` 和 `stats` 字段，如下所示：
- en: '![](img/43488f32-78a0-4369-aa45-06c159ccb5ef.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/43488f32-78a0-4369-aa45-06c159ccb5ef.png)'
- en: Let's pause for a second. Is it OK to access the fields directly? We can argue
    here that it is not. The primary reason is that there is an implicit assumption
    that the field names represent the public interface of the object.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们暂停一下。直接访问字段是否可以？我们可以在这里争论说这不行。主要原因是存在一个隐含的假设，即字段名称代表对象的公共接口。
- en: 'Unfortunately, such an assumption can be a little brittle in reality. As any
    seasoned programmer would have pointed out, software is always subject to change. *Always
    to* *change*. The world is not static, and requirements are not set in stone.
    For example, here are some possible changes that will certainly break our programming
    interface:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这样的假设在现实中可能有点脆弱。正如任何经验丰富的程序员都会指出的，软件总是需要改变。*总是需要*改变。世界不是静态的，需求也不是一成不变的。例如，以下是一些肯定会破坏我们的编程接口的可能变化：
- en: Changing the field name of `heatmap` to `heatspace` because the new name is
    better suited for 3-dimensional or higher-dimensional data
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `heatmap` 字段的名称更改为 `heatspace`，因为新的名称更适合三维或更高维度的数据
- en: Changing the data type of `stats` from a named tuple to a new `struct` type
    because it has grown to include more complex statistical measures and we want
    to develop new functions along with that
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `stats` 字段的数据类型从命名元组更改为新的 `struct` 类型，因为它已经增长到包括更复杂的统计度量，并且我们希望随着它开发新的函数
- en: Removing the `stats` field altogether and computing it on the fly
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完全移除 `stats` 字段，并在运行时计算它
- en: As you can see, the programming interface cannot be taken lightly. In order
    to build software that lasts, we need to be clear about every single interface
    and understand how to support them in the future.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，编程接口不能轻率对待。为了构建持久的软件，我们需要对每个接口都清楚，并了解如何在未来支持它们。
- en: One way to provide an interface to an object is to create assessor functions,
    which are sometimes called getters and setters in other programming languages.
    So, in the next sections, let's look at how to use them.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 提供对象接口的一种方法是通过创建评估函数，在其他编程语言中有时称为获取器和设置器。因此，在接下来的几节中，让我们看看如何使用它们。
- en: Implementing getter functions
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现获取器函数
- en: 'In mainstream object-oriented languages, we often implement getters for accessing
    the fields of an object. In Julia, we can also create getter functions. When implementing
    getter functions, we can choose which fields to expose as part of the **application
    programming interface** (**API**). For our example, we will implement getter functions
    for both fields, as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在主流面向对象的语言中，我们经常实现获取器来访问对象的字段。在 Julia 中，我们也可以创建获取器函数。在实现获取器函数时，我们可以选择哪些字段作为**应用程序编程接口**（**API**）的一部分进行暴露。在我们的示例中，我们将为两个字段都实现获取器函数，如下所示：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Our choice of function names here is somewhat non-idiomatic for the Julia language.
    A better convention is to use the nouns directly:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们选择的函数名称对于 Julia 语言来说有些非习惯用法。更好的约定是直接使用名词：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: So, when we read the code that uses the `heatmap` function, we can read it as
    the *heatmap of the simulation*. Likewise, we can read it as the *statistics of
    the simulation* when the `stats` function is used.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当我们阅读使用`heatmap`函数的代码时，我们可以将其视为*模拟的热图*。同样，当使用`stats`函数时，我们可以将其视为*模拟的统计数据*。
- en: These getter functions serve the purpose of defining a formal data retrieval
    interface for the object. If we ever need to change the names (or even the types)
    of the underlying fields, it would be fine as long as the public interface does
    not change. Furthermore, we could even remove the `stats` field and implement
    the statistical calculation directly in the `stats` function. Backward compatibility
    can now be easily maintained for any program that uses this object.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这些获取器函数的目的是为对象定义一个正式的数据检索接口。如果我们需要更改底层字段的名称（甚至类型），只要公共接口不变，那就没问题。此外，我们甚至可以删除`stats`字段，并在`stats`函数中直接实现统计计算。现在，我们可以轻松地维护任何使用此对象的程序的向后兼容性。
- en: Next, we will look at write access for objects.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨对象的写访问权限。
- en: Implementing setter functions
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现设置器函数
- en: 'For mutable types, we may implement setters. The scope would include fields
    that can only ever be mutated. For our simulation project, suppose that we want
    to allow the client program to do some transformation of the heatmap and put it
    back to the object. We can support that use case easily, as shown in the following
    code snippet:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 对于可变类型，我们可能需要实现设置器。其范围包括只能被修改的字段。对于我们的模拟项目，假设我们希望允许客户端程序对热图进行一些转换并将其放回对象中。我们可以轻松地支持这个用例，如下面的代码片段所示：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The setter function, `heatmap!`, accepts a `Simulation` object and a new heatmap
    array. Because the `stats` field contains the statistics of the underlying heatmap,
    we must maintain consistency within the object by recalculating the statistics
    and updating the field. Note that such a guarantee for consistency is only possible
    when we provide a setter function. Otherwise, the object would be in an inconsistent
    state if we ever to allow users to directly mutate the `heatmap` field in the
    object.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 设置器函数`heatmap!`接受一个`Simulation`对象和一个新的热图数组。因为`stats`字段包含底层热图的统计数据，我们必须通过重新计算统计数据并更新字段来在对象内部保持一致性。请注意，这种一致性的保证只有在提供设置器函数时才可能。否则，如果我们允许用户直接修改对象中的`heatmap`字段，对象就会处于不一致的状态。
- en: 'An additional benefit is that we can perform data validation in the setter
    function. For example, we can control the size of the map and throw an error when
    the size of the heatmap contains odd shapes:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个好处是，我们可以在设置器函数中执行数据验证。例如，我们可以控制地图的大小，并在热图的大小包含奇形状时抛出错误：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, we first determine the size of `new_heatmap`, which should be returned
    as a tuple. Then, we find out how many unique values are in this tuple. If there
    is only a single unique number in the tuple, then we know that the array is square,
    cubic, and so on. Otherwise, we just throw an error back to the caller.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先确定 `new_heatmap` 的大小，它应该作为一个元组返回。然后，我们找出这个元组中有多少唯一的值。如果元组中只有一个唯一的数字，那么我们知道数组是正方形、立方体等等。否则，我们只需将错误抛回调用者。
- en: Just like getter functions, setter functions serve as a public interface where
    the data of an object may be mutated. After we have both getter and setter functions,
    we can expect the caller to go through the interfaces. But the original fields
    can still be accessed directly. So, how do we stop that from happening? Let's
    explore that next.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 就像获取函数一样，设置函数充当一个公共接口，其中对象的数據可能会被修改。在我们有了获取和设置函数之后，我们可以期待调用者通过接口进行操作。但原始字段仍然可以直接访问。那么，我们如何阻止这种情况发生呢？让我们在下一节中探讨这个问题。
- en: Discouraging direct field access
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 阻止直接访问字段
- en: While getter and setter functions are convenient, it is easy to forget about
    these functions and so the program ends up accessing the fields directly. That
    would be too bad, as we have just spent all that effort creating getter and setter
    functions and they end up getting bypassed.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然获取和设置函数很方便，但很容易忘记这些函数，所以程序最终会直接访问字段。那会很糟糕，因为我们刚刚花费了所有这些努力创建获取和设置函数，但它们最终被绕过了。
- en: A possible solution is to discourage direct field access by renaming the fields
    to something that looks obviously private. A common convention is to prepend the
    field names with underscores.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 一种可能的解决方案是通过对字段重命名，使其看起来显然是私有的，来阻止直接访问字段。一个常见的约定是在字段名前加上下划线。
- en: 'For our example, we can redefine the struct as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的示例，我们可以将结构体重新定义为以下内容：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: These oddly named fields will then only be used within the implementation of
    the `Simulation` type, and all external usages will avoid them. Such a convention
    discourages the programmer from making the mistake of accessing the fields directly.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这些奇特命名的字段将仅在 `Simulation` 类型的实现中使用，所有外部使用都将避免它们。这样的约定可以阻止程序员直接访问字段。
- en: However, some of us may not be very satisfied with this solution because the
    use of a coding convention is a very weak method for enforcing the proper use
    of the programming interface. Such concern is very valid especially when we hold
    ourselves to a higher standard of software robustness. So, in the next section,
    we will explore a stronger technique that will allow us to control access programmatically.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们中的一些人可能对这种解决方案不太满意，因为使用编码约定来强制正确使用编程接口是一种非常薄弱的方法。这种担忧是非常合理的，尤其是当我们对自己软件的鲁棒性有更高的标准时。因此，在下一节中，我们将探讨一种更强大的技术，这将使我们能够通过编程方式控制访问。
- en: Property patterns
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性模式
- en: In this section, we will take a deep dive and learn how to enforce more granular
    control over the fields of an object by using the property interface. Julia's
    property interface allows you to provide a custom implementation for the dot notation
    used in field access. By overriding the standard behavior, we can apply any kind
    of access control and validation against the field being referenced or assigned.
    To illustrate this concept, we will tackle a new use case here – implementing
    a lazy file loader.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将深入探讨如何通过使用属性接口来对对象的字段实施更细粒度的控制。Julia 的属性接口允许你为字段访问中使用的点符号提供自定义实现。通过覆盖标准行为，我们可以对引用或分配的字段应用任何类型的访问控制和验证。为了说明这个概念，我们将在下面处理一个新的用例——实现懒文件加载器。
- en: Introducing the lazy file loader
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入懒文件加载器
- en: 'Suppose that we are developing a file loading facility that supports lazy loading.
    By lazy, we are talking about not loading a file until the content is required. Let''s
    take a look at the following code:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在开发一个支持懒加载的文件加载功能。这里的“懒”指的是在需要内容之前不加载文件。让我们看看以下代码：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `FileContent` struct contains three fields:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileContent` 结构体包含三个字段：'
- en: '`path`: The location of the file'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`path`: 文件的位置'
- en: '`loaded`: A Boolean value that indicates whether the file has been loaded into
    memory'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loaded`: 一个布尔值，表示文件是否已被加载到内存中'
- en: '`contents`: A byte array that contains the contents of the file'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`contents`: 包含文件内容的字节数组'
- en: 'Here''s the constructor for the same struct:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是该结构体的构造函数：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As with our current design, we pre-allocate memory for the file but we do not
    read the file content until later. The size of the file is determined by a call
    to the `lstat` function. When creating the `FileContent` object, we initialize
    the `loaded` field with a `false` value – an indication that the file has not
    been loaded into memory.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们的当前设计一样，我们预先为文件分配内存，但我们不会在之后读取文件内容。文件的大小由对 `lstat` 函数的调用确定。在创建 `FileContent`
    对象时，我们将 `loaded` 字段初始化为 `false` 值——这表明文件尚未加载到内存中。
- en: 'Eventually, we must load the file content, so we just provide a separate function
    that reads the file into the pre-allocated byte array:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，我们必须加载文件内容，所以我们提供了一个单独的函数来读取文件到预先分配的字节缓冲区：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let''s run a quick test to see how it works:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行一个快速测试来看看它的工作情况：
- en: '![](img/c2055393-41c1-4d8a-981f-29c97ed5b947.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c2055393-41c1-4d8a-981f-29c97ed5b947.png)'
- en: Here, we have just created a new `FileContent` object. Clearly, the `loaded`
    field contains a `false` value because we have not read the file yet. The `content`
    field is also full of zeros.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们刚刚创建了一个新的 `FileContent` 对象。显然，`loaded` 字段包含一个 `false` 值，因为我们还没有读取文件。`content`
    字段也充满了零。
- en: 'Let''s load the file content now:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们加载文件内容：
- en: '![](img/8fba08b6-09a5-48ca-b8ed-81eabeecc8e2.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8fba08b6-09a5-48ca-b8ed-81eabeecc8e2.png)'
- en: Now, the `contents` field contains some real data, and the `loaded` field has
    the value of `true`. Of course, we are just babysitting and running the code manually
    for now. The idea is to implement lazy loading. We need a way to intercept any
    *read* operation into the `contents` field so that the file content can be loaded
    just in time. Ideally, this should happen whenever someone uses the `fc.contents` expression. In
    order to *hijack* the call to get `fc.contents`, we must first understand how
    Julia's dot notation works. Let's take a detour and go over that now.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`contents` 字段包含了一些真实数据，而 `loaded` 字段具有 `true` 的值。当然，我们现在只是照看并手动运行代码。我们的想法是实现懒加载。我们需要一种方法来拦截对
    `contents` 字段的任何 *读取* 操作，以便及时加载文件内容。理想情况下，这应该发生在有人使用 `fc.contents` 表达式时。为了 *劫持*
    获取 `fc.contents` 的调用，我们首先必须理解 Julia 的点符号是如何工作的。让我们现在绕道而行，回顾一下。
- en: Understanding the dot notation for field access
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解字段访问的点符号
- en: 'In general, whenever we need to access a specific field of an object, we can
    conveniently write it as `object.fieldname`. As it turns out, this notation is
    really *syntactic sugar*, that is, some *sweet* syntax, for the `getproperty`
    function call. To be clear, whenever we write the code in the following format:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当我们需要访问对象的特定字段时，我们可以方便地将其写成 `object.fieldname`。实际上，这种表示法是 `getproperty` 函数调用的
    *语法糖*，即一些 *甜蜜* 的语法。为了清楚起见，每当我们在以下格式中编写代码：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'It is translated to a function call to `getproperty`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 它被转换为一个对 `getproperty` 的函数调用：
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: For our lazy file loader example, `fc.path` is really the same as `getproperty(fc,
    :path)`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的懒加载文件示例，`fc.path` 实际上与 `getproperty(fc, :path)` 相同。
- en: 'All that magic is performed automatically by the Julia compiler. A great thing
    about Julia is that this kind of magic is quite transparent. We can actually see
    what the compiler did by using the `Meta.lower` function, as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些魔法都是由 Julia 编译器自动执行的。关于 Julia 的一个好处是这种魔法相当透明。我们可以通过使用 `Meta.lower` 函数来实际看到编译器做了什么，如下所示：
- en: '![](img/48bcbdb0-09a0-4218-be37-12df457b886b.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/48bcbdb0-09a0-4218-be37-12df457b886b.png)'
- en: 'Similarly, when we assign a value to a field of an object, the same kind of
    translation takes place:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，当我们向对象的字段赋值时，也会发生类似的转换：
- en: '![](img/2fc46302-5481-4d5e-a462-ed0a56208428.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2fc46302-5481-4d5e-a462-ed0a56208428.png)'
- en: From the preceding result, we can see when the code assigns a string to `fc.path`,
    it is just translated to a `setproperty!(fc, :path, "/etc/hosts")` function call.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的结果中，我们可以看到当代码将字符串赋值给 `fc.path` 时，它只是转换为一个 `setproperty!(fc, :path, "/etc/hosts")`
    函数调用。
- en: 'Let''s not stop there. What do the `getproperty` and `setproperty!` functions
    do? Well, they happen to be plain Julia functions defined in the `Base` module.
    The best place to understand how they work is by examining the Julia source code
    itself. From the Julia REPL, we can easily bring up the source code as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不要就此止步。`getproperty` 和 `setproperty!` 函数具体是做什么的呢？嗯，它们恰好是定义在 `Base` 模块中的普通
    Julia 函数。理解它们是如何工作的最佳方式是检查 Julia 的源代码本身。从 Julia REPL 中，我们可以轻松地调出源代码，如下所示：
- en: '![](img/383f5807-726f-4091-bc02-ef0fcb6ccf7b.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/383f5807-726f-4091-bc02-ef0fcb6ccf7b.png)'
- en: 'From the preceding code, we can see that the `@edit` macro is used to locate
    the source code of the function being called – in this case, `getproperty`. From
    the REPL terminal, it should open your editor and display the code as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中，我们可以看到`@edit`宏用于定位被调用函数的源代码——在本例中是`getproperty`。从REPL终端，它应该打开你的编辑器并显示如下代码：
- en: '![](img/aaf7c948-9132-43c7-a06d-9642db881eb9.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/aaf7c948-9132-43c7-a06d-9642db881eb9.png)'
- en: '*Aha!* We see that the `getproperty` function just forwards the call to `getfield`,
    which is used to extract the data from the object. The next line in the same source
    file shows the definition of `setproperty!`. The implementation of `setproperty!`
    is a bit more interesting. Besides using the `setfield!` function to mutate the
    field in the object, it also converts the `v` value to the type of the field in
    object `x`, which is determined by a call to `fieldtype`.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*啊哈!* 我们看到`getproperty`函数只是将调用转发到`getfield`，后者用于从对象中提取数据。同一源文件中的下一行显示了`setproperty!`的定义。`setproperty!`的实现稍微有趣一些。除了使用`setfield!`函数来修改对象中的字段外，它还将`v`值转换为对象`x`中字段的类型，这是通过调用`fieldtype`确定的。'
- en: The `getfield` function is a built-in function for getting any field value from
    an existing object. It takes two arguments – an object and a symbol. For example,
    to get the path from a `FileContent` object, we can use `getfield(fc, :path)`.
    Likewise, the `setfield!` function is used to update any field of an existing
    object. Both `getfield` and `setfield!` are low-level functions in the Julia implementation.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`getfield`函数是一个用于从现有对象获取任何字段值的内置函数。它接受两个参数——一个对象和一个符号。例如，要从`FileContent`对象获取路径，我们可以使用`getfield(fc,
    :path)`。同样，`setfield!`函数用于更新现有对象的任何字段。`getfield`和`setfield!`都是Julia实现中的低级函数。'
- en: Type conversion is convenient, especially for numerical types. For example,
    it is quite common for an object to store a `Float64` field but the code happens
    to pass an integer instead. Of course, the conversion logic is more general than
    just numeric types. For custom types, the same auto-conversion process would work
    fine as long as a `convert` function is defined.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 类型转换很方便，尤其是对于数值类型。例如，一个对象存储一个`Float64`字段，但代码恰好传递了一个整数。当然，转换逻辑比仅仅数值类型更通用。对于自定义类型，只要定义了一个`convert`函数，相同的自动转换过程就可以正常工作。
- en: Now that we understand how the dot notation is translated to the `getproperty`
    and `setproperty!` function calls, we can develop the lazy loading feature for
    our file loader.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了点符号是如何转换为`getproperty`和`setproperty!`函数调用的，我们可以为我们的文件加载器开发懒加载功能。
- en: Implementing read access and lazy loading
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现读写访问和懒加载
- en: In order to implement lazy loading, we can extend the `getproperty` function.
    During the call, we can check whether the file content has been loaded yet. If
    not, we just load the file content right before returning the data back to the
    caller.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现懒加载，我们可以扩展`getproperty`函数。在调用过程中，我们可以检查文件内容是否已经加载。如果没有，我们就在返回数据给调用者之前加载文件内容。
- en: 'Extending the `getproperty` function is as easy as simply defining it with
    the `FileContent` type and a symbol as the arguments of the function. The following
    code shows this:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展`getproperty`函数就像简单地使用`FileContent`类型和一个符号作为函数参数来定义它一样简单。以下代码展示了这一点：
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: It is important that we define the function for `Base.getproperty` rather than
    just `getproperty`. That is because the compiler will translate the dot notation
    to `Base.getproperty` rather than the `getproperty` function in your own module.
    If this is unclear, you are encouraged to revisit the namespace concept from the *Understanding
    namespaces, modules, and packages* section in [Chapter 2](48061f6f-db77-4db6-9c92-d7550f4317fe.xhtml),
    *Modules, Packages, and Data Type Concepts*.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是我们定义了`Base.getproperty`函数而不是仅仅`getproperty`。这是因为编译器会将点符号转换为`Base.getproperty`而不是你自己的模块中的`getproperty`函数。如果这还不清楚，你被鼓励回顾第2章中“理解命名空间、模块和包”部分的*理解命名空间、模块和包*。
- en: We have chosen to put `Base` as a prefix to the function name in the definition.
    This style of coding is preferred because it is clear from the function definition
    that we are extending the `getproperty` function from the `Base` package.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择在函数名定义中使用`Base`作为前缀。这种编码风格更受欢迎，因为它从函数定义中可以清楚地看出，我们正在扩展`Base`包中的`getproperty`函数。
- en: 'Another way to extend functions from another package is to first import the
    third-party package. For the preceding example, we could have written it as follows.
    This coding style is not recommended because it is less obvious that the `getproperty`
    function being defined is an extension of the function from `Base`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 从另一个包扩展函数的另一种方法是首先导入第三方包。对于前面的例子，我们可以这样写。这种编码风格不推荐，因为它不太明显地表明正在定义的 `getproperty`
    函数是 `Base` 函数的扩展：
- en: '`import Base: getproperty`'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`import Base: getproperty`'
- en: '`function getproperty(fc::FileContent, s::Symbol)`'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`function getproperty(fc::FileContent, s::Symbol)`'
- en: '` ....`'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '` ....`'
- en: '`end`'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`end`'
- en: 'By contrast, the `getproperty` function must handle all possible property names.
    Let''s first consider the following section of code:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 与之相反，`getproperty` 函数必须处理所有可能的属性名称。让我们首先考虑以下代码段：
- en: '![](img/3536077d-b41a-4f7e-9e81-745554338153.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3536077d-b41a-4f7e-9e81-745554338153.png)'
- en: In this case, we must support `:path` and `:contents`. If the `s` symbol is
    one of those fields that we want to pass through directly, then we just forward
    the call to the `getfield` function.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们必须支持 `:path` 和 `:contents`。如果 `s` 符号是我们想要直接传递的字段之一，那么我们只需将调用转发给 `getfield`
    函数。
- en: 'Now, let''s consider the next section of code:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们考虑下一段代码：
- en: '![](img/29f338e3-569e-4384-8a97-116e021eb3cc.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/29f338e3-569e-4384-8a97-116e021eb3cc.png)'
- en: If the symbol is `:contents`, then we check the value of the `loaded` field.
    If the `loaded` field contains `false`, then we call the `load_contents!` function
    to load the file content into memory.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果符号是 `:contents`，那么我们检查 `loaded` 字段的值。如果 `loaded` 字段包含 `false`，那么我们调用 `load_contents!`
    函数将文件内容加载到内存中。
- en: Note that we have used `getfield` all over the place in this function. If we
    had written the code using the normal dot syntax, for example, `fc.loaded`, then
    it would start calling the `getproperty` function again and we could end up with
    infinite recursion.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在整个函数中到处都使用了 `getfield`。如果我们使用正常的点符号编写代码，例如 `fc.loaded`，那么它将开始调用 `getproperty`
    函数，我们可能会陷入无限递归。
- en: 'If the field name is not one of the supported ones, then we just raise an exception,
    as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果字段名称不是支持的名称之一，那么我们只需抛出一个异常，如下所示：
- en: '![](img/01e12635-9f90-40ff-8a33-cc32779c7fb0.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/01e12635-9f90-40ff-8a33-cc32779c7fb0.png)'
- en: One interesting observation is that we have decided to support two property
    names only – `path` and `contents` – and we have dropped the support for the `loaded`
    property. The reason for this is that the `loaded` field is really used as an
    internal state of the object. There is no reason to expose it as part of the public
    programming interface. As we talk about software robustness in this chapter, we
    can also appreciate developing code that only exposes necessary information.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有趣的观察是，我们决定只支持两个属性名称——`path` 和 `contents`——并且我们放弃了 `loaded` 属性的支持。这样做的原因是
    `loaded` 字段实际上被用作对象的内部状态。没有理由将其作为公共编程接口的一部分暴露出来。正如我们在本章讨论软件健壮性时，我们也可以欣赏只暴露必要信息的代码开发。
- en: An analogy is that data is always *classified* but can be released only on a
    *need-to-know basis, *which is how government officials usually like to describe
    highly sensitive data.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类比是数据总是 *分类* 的，但只能根据 *需要了解* 的原则释放，这是政府官员通常用来描述高度敏感数据的方式。
- en: 'We are almost done. The only remaining piece of work is to refactor the `load_content!`
    function to use `getfield` and `setfield!` instead of the dot notation:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎完成了。唯一剩下的工作是将 `load_content!` 函数重构为使用 `getfield` 和 `setfield!` 而不是点符号：
- en: '[PRE14]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can now test the lazy loading functionality:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以测试懒加载功能：
- en: '![](img/89ea2112-43ec-4f69-9099-3b01caf2ea09.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/89ea2112-43ec-4f69-9099-3b01caf2ea09.png)'
- en: 'Both references to the `path` and `contents` fields are working properly. In
    particular, a reference to `fc.contents` triggered the file load and then returned
    the proper content. So, what happened to the `loaded` field? Let''s try it:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 对 `path` 和 `contents` 字段的两次引用都工作正常。特别是，对 `fc.contents` 的引用触发了文件加载，然后返回了正确的内容。那么
    `loaded` 字段发生了什么？让我们试试：
- en: '![](img/5396a7f5-c50b-4a5d-b3a5-cfc8a107bb6a.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5396a7f5-c50b-4a5d-b3a5-cfc8a107bb6a.png)'
- en: '*Voila!* We have successfully prevented the `loaded` field from being accessed
    directly.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '*Voila!* 我们已经成功阻止了直接访问 `loaded` 字段。'
- en: The property interface has enabled us to manage read access and implement the
    lazy loading feature. Next, we will look at how to manage write access as well.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 属性接口使我们能够管理读访问并实现懒加载功能。接下来，我们将探讨如何管理写访问。
- en: Controlling write access to object fields
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制对象字段的写访问
- en: In order to manage write access to the fields of an object, we can extend the
    `setproperty!` function, in a similar way to how we did for read access.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为了管理对对象字段的写访问，我们可以像控制读访问一样扩展`setproperty!`函数。
- en: 'Let''s recall how the `FileContent` data type was designed:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下`FileContent`数据类型是如何设计的：
- en: '[PRE15]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Suppose that we want to allow the user to switch to a different file by mutating
    the `path` field with a new file location. In addition to this, we want to prevent
    the `loaded` and `contents` fields from being changed directly using dot notation.
    To achieve that, we can extend the `setproperty!` function as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要允许用户通过将`path`字段修改为新文件位置来切换到不同的文件。除此之外，我们还想防止直接使用点符号修改`loaded`和`contents`字段。为了实现这一点，我们可以扩展`setproperty!`函数，如下所示：
- en: '[PRE16]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: To extend the `setproperty!` function, we must use `setfield!` in the function
    definition whenever we need to change any field in the object.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 为了扩展`setproperty!`函数，我们必须在函数定义中每次需要更改对象中的任何字段时使用`setfield!`。
- en: 'In this case, when the user tries to assign a value to the `path` field, we
    can just reinitialize the object like how we did in the constructor function.
    This involves setting the values of the `path` and `loaded` fields, as well as
    pre-allocating memory space for the file content. Let''s go ahead and test it
    now:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，当用户尝试将值赋给`path`字段时，我们只需像在构造函数中做的那样重新初始化对象。这涉及到设置`path`和`loaded`字段的值，以及为文件内容预分配内存空间。让我们现在就进行测试：
- en: '![](img/ea01bf9b-ac31-46f4-af99-35477c418891.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ea01bf9b-ac31-46f4-af99-35477c418891.png)'
- en: 'If the user tries to assign a value to any other field, an error is thrown:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户尝试将值赋给任何其他字段，将会抛出错误：
- en: '![](img/f4271bfb-0dfe-477b-9f92-193da206d57b.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f4271bfb-0dfe-477b-9f92-193da206d57b.png)'
- en: By extending the `setproperty!` function, we have successfully controlled write
    access to any field for any object.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 通过扩展`setproperty!`函数，我们已经成功控制了对任何对象的任何字段的写访问。
- en: While individual field access can be controlled, we cannot prevent additional
    changes to the underlying data of a field. For example, the `contents` property
    is just an array of bytes and the programmer should be able to change the elements
    in the array. If we want to protect the data from being modified, we can return a
    copy of the `contents` byte array from the `getproperty` call.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可以控制对单个字段的访问，但我们无法防止对字段底层数据的额外更改。例如，`contents`属性只是一个字节数组，程序员应该能够更改数组中的元素。如果我们想保护数据不被修改，我们可以在`getproperty`调用中返回`contents`字节数组的副本。
- en: By now, we know how to implement the `getproperty` and `setproperty!` functions
    so that we can control access to the individual fields of an object. Next, we
    will look at how to document what properties are available.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经知道如何实现`getproperty`和`setproperty!`函数，以便我们可以控制对对象各个字段的访问。接下来，我们将探讨如何记录可用的属性。
- en: Reporting accessible fields
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 报告可访问字段
- en: 'A development environment can often help a programmer to enter field names
    correctly. In the Julia REPL, when I press the *Tab* key twice after entering
    the dot character, it will try to autocomplete and display the available field
    names:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 开发环境经常可以帮助程序员正确输入字段名。在Julia的REPL中，当我输入点字符后按两次*Tab*键，它将尝试自动完成并显示可用的字段名：
- en: '![](img/3f5a7e8f-a25b-40a6-ab61-b07108a07048.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3f5a7e8f-a25b-40a6-ab61-b07108a07048.png)'
- en: 'Now that we have implemented the `getproperty` and `setproperty!` functions,
    the list is no longer accurate. More specifically, the `loaded` field should not
    be displayed because it can neither be accessed nor changed. In order to fix this,
    we can simply extend the `propertynames` function, as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经实现了`getproperty`和`setproperty!`函数，列表就不再准确了。更具体地说，`loaded`字段不应显示，因为它既不能被访问也不能被修改。为了修复这个问题，我们可以简单地扩展`propertynames`函数，如下所示：
- en: '[PRE17]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `propertynames` function just needs to return a tuple of valid symbols.
    After the function is defined, the REPL will only display the valid field names,
    as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`propertynames`函数只需返回一个有效符号的元组。函数定义后，REPL将只显示有效的字段名，如下所示：'
- en: '![](img/7f4e81eb-f9a4-491a-ad08-c14147d91c4d.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7f4e81eb-f9a4-491a-ad08-c14147d91c4d.png)'
- en: In this section, we have learned how to leverage Julia's property interface
    to control both read and write access to any field of an object. It is an essential
    technique to write robust programs.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何利用Julia的属性接口来控制对对象任何字段的读和写访问。这是一个编写健壮程序的基本技术。
- en: While the use of the property interface seems to address most of the requirements
    we set forth earlier, it is not bulletproof.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用属性接口似乎满足了我们之前设定的要求的大部分，但它并不是万无一失的。
- en: For example, there is nothing that prevents the program from calling the `getfield`
    and `setfield!` functions directly on any object. It would not be possible to
    completely hide that from the programmer unless the language is updated to support
    granular field access controls. Such a feature may be available in the future.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，没有任何东西阻止程序直接在任何对象上调用`getfield`和`setfield!`函数。除非语言更新以支持粒度字段访问控制，否则不可能完全从程序员那里隐藏这一点。这样的功能可能在将来可用。
- en: Next, we will look at some patterns related to limiting the scope of variables
    so that we can minimize the exposure of private variables to the outside world.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨一些与限制变量作用域相关的模式，这样我们就可以最小化私有变量对外界的暴露。
- en: Let block patterns
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 块模式
- en: The recurring theme in this chapter is to learn how to improve and gain more
    control over the visibility and accessibility of data and functions in the public
    API. By enforcing the access of the programming interface, we can guarantee how
    the program is utilized. Additionally, we can focus on testing the interface as
    *advertised*.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的反复主题是学习如何改进并更多地控制公共API中数据和函数的可见性和可访问性。通过强制编程接口的访问，我们可以保证程序的利用方式。此外，我们可以专注于测试*宣传*的接口。
- en: Currently, Julia provides little help in encapsulating implementation details
    within a module. While we can use the `export` keyword to expose certain functions
    and variables to the other modules, it is not designed to be an access control
    or data encapsulation feature. You can always *peek* into a module and access
    any variable or function even when they are not exported.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，Julia在模块内封装实现细节方面提供的帮助很少。虽然我们可以使用`export`关键字将某些函数和变量暴露给其他模块，但它并不是为了成为一个访问控制或数据封装功能。你总是可以*窥视*模块并访问任何变量或函数，即使它们没有被导出。
- en: In this section, we will continue the trend and go over some strategies that
    we can use to limit access to variables or functions in a module. Here, we will
    use a web crawler use case to illustrate the problem and a possible solution.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将继续这一趋势，并介绍我们可以用来限制模块中变量或函数访问的一些策略。在这里，我们将使用网络爬虫用例来说明问题和可能的解决方案。
- en: Introducing the web crawler use case
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍网络爬虫用例
- en: 'Suppose that we have to build a web crawler that can be used to index content
    from various websites. The process of doing that involves setting up a list of
    target sites and then kicking off the crawler. Let''s create a module with the
    structure, as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们必须构建一个可以用于从各种网站索引内容的网络爬虫。这个过程涉及设置目标网站列表并启动爬虫。让我们创建一个具有以下结构的模块：
- en: '[PRE18]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Our programming interface is quite simple. Let''s see how to do this:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的编程接口相当简单。让我们看看如何做到这一点：
- en: '`Target` is a data type that represents the website being crawled. Then, we
    can use the `add_site!` function to add new target sites to the list.'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Target`是一种表示正在被爬取的网站的数据类型。然后，我们可以使用`add_site!`函数将新的目标网站添加到列表中。'
- en: When ready, we just call the `crawl_sites!` function to visit all sites.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备就绪后，我们只需调用`crawl_sites!`函数来访问所有网站。
- en: For convenience, the `current_sites` function can be used to review the current
    list of target sites and their crawling status.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了方便，可以使用`current_sites`函数来查看当前目标网站列表及其爬取状态。
- en: Finally, the `reset_crawler!` function can be used to reset the state of the
    web crawler.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，可以使用`reset_crawler!`函数来重置网络爬虫的状态。
- en: 'Let''s take a look at the data structure now. The `Target` type is used to
    maintain the URL of the target website. It also contains a Boolean variable regarding
    the status and the time it finished crawling. The struct is defined as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看数据结构。`Target`类型用于维护目标网站的URL。它还包含一个关于状态和完成爬取时间的布尔变量。结构体定义如下：
- en: '[PRE19]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In order to keep track of the current target sites, a global variable is used:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟踪当前的目标网站，使用了一个全局变量：
- en: '[PRE20]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To complete the web crawler implementation, we have the following functions
    defined in the module:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成网络爬虫的实现，我们在模块中定义了以下函数：
- en: '[PRE21]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To use the web crawler, first, we can add some sites, as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用网络爬虫，首先，我们可以添加一些网站，如下所示：
- en: '![](img/903d8a28-7903-4c04-a716-2f2929610f1d.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/903d8a28-7903-4c04-a716-2f2929610f1d.png)'
- en: 'Then, we can just run the crawler and retrieve the results afterward:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们只需运行爬虫并在之后检索结果：
- en: '![](img/18e6b756-5470-49a7-aa26-0067eb9913cf.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](img/18e6b756-5470-49a7-aa26-0067eb9913cf.png)'
- en: 'The current implementation is not bad, but it has the following two access-related
    issues:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的实现并不糟糕，但它有两个与访问相关的问题：
- en: The global variable, `sites`, is visible to the outside world, which means that
    anyone can get a handle of the variable and mess it up, for example, by inserting
    a malicious website.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 全局变量 `sites` 对外部世界可见，这意味着任何人都可以获取变量的控制权并破坏它，例如，通过插入恶意网站。
- en: The `index_site!` function should be considered a private function and should
    not be included as part of the public API.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`index_site!` 函数应被视为私有函数，不应包含在公共 API 中。'
- en: Now that we have set the stage, we will demonstrate how to address these problems
    in the next section.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经设定了场景，我们将在下一节中展示如何解决这些问题。
- en: Using closure to hide private variables and functions away
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用闭包隐藏私有变量和函数
- en: Our goal is to hide the global constant, `sites`, and the helper function, `index_site!`,
    such that they are not visible in the public API. To achieve that, we can utilize
    `let` blocks.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是隐藏全局常量 `sites` 和辅助函数 `index_site!`，以便它们在公共 API 中不可见。为了实现这一点，我们可以利用 `let`
    块。
- en: 'In the body of the module, we can wrap all of the functions inside a `let`
    block, as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在模块的主体中，我们可以将所有函数包裹在一个 `let` 块中，如下所示：
- en: '![](img/44aea611-8f04-4119-ba7d-0db6f3e1c93f.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](img/44aea611-8f04-4119-ba7d-0db6f3e1c93f.png)'
- en: 'Now, let''s see what has been changed:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看都发生了哪些变化：
- en: The `sites` constant has been replaced by a bound variable at the beginning
    of the `let` block. The variables in a `let` block are bound only in the scope
    of the block and are not visible to the outside world.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sites` 常量在 `let` 块的开始处被替换为一个绑定变量。`let` 块中的变量仅在块的作用域内绑定，对外部世界不可见。'
- en: The functions that need to be exposed to the API are prefixed with the `global`
    keyword. This includes `add_site!`, `crawl_sites!`, `current_sites`, and `reset_crawler!`.
    The `index_site!` function is left as-is so that it is not exposed.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要公开给 API 的函数以 `global` 关键字为前缀。这包括 `add_site!`、`crawl_sites!`、`current_sites`
    和 `reset_crawler!`。`index_site!` 函数保持原样，以便它不会被公开。
- en: The `global` keyword allows us to expose the function names to the global scope
    of the module, which can be exported and made accessible from the public API.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`global` 关键字允许我们将函数名称暴露给模块的全局作用域，这样就可以导出并从公共 API 中访问。'
- en: 'After reloading the module, we can confirm that neither `sites` nor `index_site!`
    are available from the API, as shown in the following output:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 重新加载模块后，我们可以确认 `sites` 和 `index_site!` 都不可从 API 中访问，如下面的输出所示：
- en: '![](img/dad2113a-1a01-49e0-8e2e-ae5560cdbd6d.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dad2113a-1a01-49e0-8e2e-ae5560cdbd6d.png)'
- en: As you can see, a `let` block is an effective way to control access to global
    variables or functions in a module. We have the ability to encapsulate functions
    or variables that we want to prevent access from outside of the module.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`let` 块是控制模块中全局变量或函数访问的有效方式。我们有封装函数或变量的能力，以防止它们从模块外部访问。
- en: There may be a performance overhead when wrapping functions within a `let` block.
    You may want to run a performance test before using this pattern in any performance-critical
    section of your code.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `let` 块中包装函数时可能会产生性能开销。在使用此模式之前，您可能想要在代码的任何性能关键部分运行性能测试。
- en: As `let` blocks are quite useful in limiting the scope, we can often use it
    in longer scripts and functions. Next, we will look at how it is used in practice.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `let` 块在限制作用域方面非常有用，我们经常可以在较长的脚本和函数中使用它。接下来，我们将看看它在实际中的应用。
- en: Limiting the variable scope for long scripts or functions
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 限制长脚本或函数的变量作用域
- en: Another usage of the let block is to limit the scope of variables in a long
    Julia script or function. In a long script or function, the code could be difficult
    to follow if we declare a variable at the top and use it throughout the body.
    Instead, we can write a series of let blocks, which operate independently with
    their own bound variables. By limiting the bounded variables in smaller blocks,
    we can follow the code more easily.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`let` 块的另一种用法是在长 Julia 脚本或函数中限制变量的作用域。在一个长脚本或函数中，如果我们声明一个变量在顶部并在整个主体中使用它，代码可能会难以跟踪。相反，我们可以编写一系列
    `let` 块，它们独立操作并拥有自己的绑定变量。通过在较小的块中限制绑定变量，我们可以更容易地跟踪代码。'
- en: 'While writing long script/functions is not a generally recommended practice,
    we can find them occasionally in testing code, which tends to be quite repetitive.
    In test scripts, we may have many test cases that are grouped in the same test
    set. Here is an example from the `GtkUtilities` package:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然编写长脚本/函数通常不是推荐的做法，但在测试代码中偶尔会遇到，这通常相当重复。在测试脚本中，我们可能有多个测试用例被分组在同一个测试集中。以下是从
    `GtkUtilities` 包中的一个示例：
- en: '[PRE22]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We have a few observations here from the preceding code:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中，我们有以下几点观察：
- en: The `c` variable is bound to a new `Canvas` object every time.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`c` 变量每次都会绑定到一个新的 `Canvas` 对象。'
- en: The `win` variable is bound to a new `Window` object having a different title
    every time.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`win` 变量绑定到一个新的 `Window` 对象，每次都会有一个不同的标题。'
- en: The `w`, `h`, `randcol`, and `randnum` variables are local variables that do
    not escape from their respective let blocks.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`w`、`h`、`randcol` 和 `randnum` 变量是局部变量，它们不会从它们各自的 `let` 块中逃逸。'
- en: By using let blocks, it does not matter how long the test script is. Every let
    block maintains its own scope and nothing should leak from one block to the next.
    This kind of programming style immediately provides some comfort to the programmer
    when it comes to the quality of testing code, as each testing unit is independent
    from each other.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `let` 块，测试脚本的长度并不重要。每个 `let` 块都维护自己的作用域，并且不应该有任何东西从一个块泄漏到下一个块。这种编程风格在测试代码的质量方面立即为程序员提供了一些安慰，因为每个测试单元都是相互独立的。
- en: Next, we will go over some exception handling techniques. Although it is more
    fun doing programming projects, exception handling is not something that we want
    to overlook. So, let's take a look at it next.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将介绍一些异常处理技术。虽然做编程项目更有趣，但异常处理并不是我们可以忽视的东西。所以，让我们接下来看看它。
- en: Exception handling patterns
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异常处理模式
- en: Robust software requires robust error handling practice. The fact is that an
    error can be raised at any time, sometimes, unexpectedly. As a responsible programmer,
    we need to ensure that every path of computation is taken care of, including both
    the *happy paths* and *unhappy paths*. Happy paths refer to program execution
    that runs normally as expected. Unhappy paths refer to an unexpected outcome due
    to error conditions.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 稳健的软件需要稳健的错误处理实践。事实上，错误可能在任何时候发生，有时甚至出人意料。作为一个负责任的程序员，我们需要确保计算过程中的每一条路径都得到妥善处理，包括**快乐路径**和**不快乐路径**。快乐路径指的是程序按预期正常运行的情况。不快乐路径则是指由于错误条件导致的意外结果。
- en: In this section, we will explore several ways about to catch exceptions and
    recover from failures effectively.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨几种捕获异常和有效恢复失败的方法。
- en: Catching and handling exceptions
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 捕获和处理异常
- en: 'A general technique to catch exceptions is to enclose any logic in a try-catch
    block. This is the easiest way to ensure that unexpected errors are handled:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获异常的一般技术是将任何逻辑包裹在 `try-catch` 块中。这是确保意外错误得到处理的最简单方法：
- en: '[PRE23]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: A common question, however, is where this `try-catch` block should be placed.
    Of course, we could have just wrapped every single line of code but that would
    be impractical. After all, not every line of code would throw an error.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一个常见的问题是这个 `try-catch` 块应该放在哪里。当然，我们可以将每一行代码都包裹起来，但这并不实用。毕竟，并不是每一行代码都会抛出错误。
- en: We do want to be smart about choosing where to catch exceptions. We know that
    adding exception handling increases the code size. Additionally, every line of
    code requires maintenance. Ironically, the less code we write, the less chance
    of introducing bugs. After all, we should not introduce more problems by trying
    to catch problems, right?
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们确实希望在选择捕获异常的位置时表现得聪明一些。我们知道添加异常处理会增加代码的大小。此外，每一行代码都需要维护。讽刺的是，我们写的代码越少，引入错误的机会就越小。毕竟，我们不应该通过尝试捕获问题来引入更多的问题，对吧？
- en: Next, we will look at what kind of scenarios we should consider doing error
    handling for.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看看我们应该考虑进行错误处理的场景类型。
- en: Dealing with various types of exceptions
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理各种类型的异常
- en: The most obvious places to wrap a try-catch block are in the code blocks that
    we need to acquire network resources, for example, querying a database or connecting
    to a web server. Whenever the network is involved, there is a much higher chance
    of encountering an issue than doing something locally on the same computer.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `try-catch` 块包裹起来的最明显的地方是在我们需要获取网络资源的代码块中，例如查询数据库或连接到网络服务器。每当涉及网络时，遇到问题的可能性比在相同计算机上本地执行某事要高得多。
- en: 'It is important to understand what kind of errors can be thrown. Suppose that
    we continue developing the web crawler use case from the previous section. The
    `index_sites!` function is now implemented using the HTTP library as follows:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 理解可能抛出的错误类型很重要。假设我们继续从上一节开发网络爬虫用例。现在`index_sites!`函数是使用HTTP库实现的，如下所示：
- en: '[PRE24]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `HTTP.get` function is used to retrieve the content from the website. The
    code looks pretty innocent but it does not handle any error condition. For example,
    what happens if the site''s URL is wrong or if the site is down? In those cases,
    we would run into a runtime exception, such as the following:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`HTTP.get`函数用于从网站检索内容。代码看起来很无辜，但它没有处理任何错误条件。例如，如果网站的URL错误或网站关闭，会发生什么？在这些情况下，我们会遇到运行时异常，如下所示：'
- en: '![](img/0e573f56-ac55-4738-a2b9-48b9d2a6876c.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0e573f56-ac55-4738-a2b9-48b9d2a6876c.png)'
- en: 'So, at a minimum, we should handle `IOError`. It turns out that the HTTP library
    actually does more than that. If the remote site returns any HTTP status code
    in the 400- or 500-series, then it also wraps the error code and raises a `StatusError`
    exception, as follows:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，至少我们应该处理`IOError`。实际上，HTTP库做得更多。如果远程网站返回400或500系列中的任何HTTP状态码，它也会包装错误码并抛出`StatusError`异常，如下所示：
- en: '![](img/b84bd933-2d60-4863-9bc1-2d15dd167ce2.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b84bd933-2d60-4863-9bc1-2d15dd167ce2.png)'
- en: 'So, how do we know for sure what kind of errors can ever be thrown? Well, we
    can always *read the fine manual* or so-called RTFM. From the HTTP package''s
    documentation, we can see that the following exceptions may be thrown when making
    HTTP requests:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何确定可能会抛出哪些类型的错误呢？嗯，我们总是可以*阅读详细手册*或所谓的RTFM。从HTTP包的文档中，我们可以看到在发起HTTP请求时可能会抛出以下异常：
- en: '`HTTP.ExceptionRequest.StatusError`'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HTTP.ExceptionRequest.StatusError`'
- en: '`HTTP.Parsers.ParseError`'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HTTP.Parsers.ParseError`'
- en: '`HTTP.IOExtras.IOError`'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HTTP.IOExtras.IOError`'
- en: '`Sockets.DNSError`'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Sockets.DNSError`'
- en: 'In Julia, the try-catch block catches all exceptions regardless of the type
    of exception. So, we should have the ability to handle any other exception even
    when it is unknown to us. Here is an example of a function that handles exceptions
    properly:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在Julia中，try-catch块会捕获所有异常，无论异常类型如何。因此，我们应该有能力处理任何其他异常，即使我们不知道它。以下是一个正确处理异常的函数示例：
- en: '[PRE25]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We can see from the preceding code that, in the body of the `catch` block,
    we can check the type of exception and handle it appropriately. The `else` part
    of the block ensures that all types of exceptions are caught, whether we know
    about them or not.  Let''s hook up the `crawl_site!` function to this new function:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中我们可以看到，在`catch`块的主体中，我们可以检查异常类型并相应地处理它。块的`else`部分确保捕获所有类型的异常，无论我们是否了解它们。让我们将`crawl_site!`函数连接到这个新函数：
- en: '[PRE26]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We can test out the error handling code now:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以测试错误处理代码了：
- en: '![](img/7489805c-9eba-4bae-ae58-5cec05979d27.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7489805c-9eba-4bae-ae58-5cec05979d27.png)'
- en: This works well!
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这效果很好！
- en: So, this is one instance; what other places do we want to inject exception handling
    logic? Let's explore this next.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这是一个实例；我们还想在哪些地方注入异常处理逻辑？让我们接下来探索这个问题。
- en: Handling exceptions at the top level
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在顶层处理异常
- en: Another place where you would normally handle exceptions is at the very top
    level of the program. Why? One reason is that we may want to avoid the program
    from crashing due to an uncaught exception. The top level of the program is the
    very last gate to catch anything, and the program has an option to either recover
    from the failure (such as doing a *soft reset*) or gracefully close all the resources
    and shut down.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个通常处理异常的地方是程序的最高层。为什么？一个原因是我们可能不想让程序因为未捕获的异常而崩溃。程序的最高层是最后一个捕获任何异常的地方，程序有从失败中恢复（例如进行*软重置*）或优雅地关闭所有资源并关闭的选项。
- en: When a computer program finishes execution, it normally returns an exit status
    back to the shell where the program was invoked. In Unix, the usual convention
    is to indicate successful termination with a zero status and unsuccessful termination
    with a nonzero status.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 当计算机程序执行完毕时，它通常会返回一个退出状态给调用程序的那个shell。在Unix中，通常的约定是用零状态表示成功终止，用非零状态表示不成功终止。
- en: 'Consider the following pseudocode:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下伪代码：
- en: '[PRE27]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We can see from the previous code that, by design, we can exit the program with
    a specific status code for different error conditions so that the calling program
    can handle the exception properly.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从之前的代码中看到，按照设计，我们可以为不同的错误条件退出程序并返回一个特定的状态码，这样调用程序就可以正确地处理异常。
- en: Next, we will take a look at how to determine where an exception was originally
    raised from a deeply nested execution frame.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看看如何从深层嵌套的执行帧中确定异常最初是从哪里抛出的。
- en: Walking along the stack frames
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 沿着堆栈帧前进
- en: Often, an exception is raised from a function but it is not handled in the right
    away. The exception then travels to the parent calling function. If that function
    does not catch the exception either, it again travels to the next parent calling
    function. This process continues until a try-catch block catches the exception.
    At this point, the program's current *stack frame –* an execution context of where
    the code is currently running – handles the exception.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，异常是从一个函数中抛出的，但它没有被正确处理。然后异常会传播到父调用函数。如果那个函数也没有捕获异常，它又会传播到下一个父调用函数。这个过程会一直持续，直到一个`try-catch`块捕获了异常。在这个点上，程序当前的*堆栈帧*——即代码当前正在运行的执行上下文——处理了异常。
- en: 'It would be tremendously useful if we can see where the exception was originally
    raised. To do that, let''s first try to understand how to retrieve a stack trace
    that is an array of stack frames. Let''s create a simple set of nested function
    calls such that they throw an error at the end. Consider the following code:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能看到异常最初是在哪里抛出的，那将非常有用。为了做到这一点，让我们首先尝试理解如何检索一个堆栈跟踪，它是一个堆栈帧数组。让我们创建一组简单的嵌套函数调用，这样它们在最后会抛出一个错误。考虑以下代码：
- en: '[PRE28]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, if we execute the `foo1` function, we should get an error, as follows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们执行`foo1`函数，我们应该得到一个错误，如下所示：
- en: '![](img/09030407-9dae-422a-9c0b-12dcd16f0e7a.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/09030407-9dae-422a-9c0b-12dcd16f0e7a.png)'
- en: As you can see, the stack trace shows the execution sequence in reversed order.
    At the top of the stack trace is the `foo3` function. Because we're doing this
    in the REPL, we do not see a source filename; however, the number 2, as in `REPL[17]:2`,
    indicates that an error was thrown from line 2 of the `foo3` function.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，堆栈跟踪显示了执行序列的反向顺序。堆栈跟踪的顶部是`foo3`函数。因为我们是在REPL中做的，所以我们看不到源文件名；然而，数字2，即`REPL[17]:2`，表示错误是从`foo3`函数的第2行抛出的。
- en: 'Let''s introduce the `stacktrace` function now. This function is part of the
    `Base` package and it can be used to obtain the current stack trace. As the `stacktrace`
    function returns an array of `StackFrame`, it would be nice if we could create
    a function to display it nicely. We can define a function to print the stack trace,
    as follows:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们介绍`stacktrace`函数。这个函数是`Base`包的一部分，它可以用来获取当前的堆栈跟踪。由于`stacktrace`函数返回一个`StackFrame`数组，如果能创建一个函数来优雅地显示它那就更好了。我们可以定义一个函数来打印堆栈跟踪，如下所示：
- en: '[PRE29]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'As we want to handle exceptions properly, we will now update the `foo1` function
    by wrapping the call to `foo2` with a `try-catch` block. In the `catch` block,
    we will also print the stack trace so that we can further debug the issue:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们想要正确地处理异常，我们现在将更新`foo1`函数，通过将`foo2`的调用包裹在一个`try-catch`块中来实现。在`catch`块中，我们还将打印堆栈跟踪，这样我们可以进一步调试问题：
- en: '[PRE30]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Let''s run the `foo1` function now:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行`foo1`函数：
- en: '![](img/943390bd-6cfb-4959-a7e3-14e81b21f1f2.png)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/943390bd-6cfb-4959-a7e3-14e81b21f1f2.png)'
- en: '*Oops!* What happened to `foo2` and `foo3`? The exception was thrown from `foo3`
    but we can no longer see them in the stack trace. This is because we have caught
    the exception, and from Julia''s perspective, it is already handled and the current
    execution context is in `foo1` already.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀！`foo2`和`foo3`怎么了？异常是从`foo3`抛出的，但我们已经无法在堆栈跟踪中看到它们了。这是因为我们已经捕获了异常，从Julia的角度来看，它已经被处理，当前的执行上下文已经在`foo1`中。
- en: 'In order to address this issue, there is another function in the `Base` package
    called `catch_backtrace`. It gives us the backtrace of the current exception so
    we know where the exception was originally raised. We just need to update the
    `foo1` function as follows:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，`Base`包中还有一个名为`catch_backtrace`的函数。它给我们提供了当前异常的堆栈跟踪，这样我们就能知道异常最初是在哪里抛出的。我们只需要更新`foo1`函数如下：
- en: '[PRE31]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Then, if we run `foo1` again, we get the following results, where `foo3` and
    `foo2` are back to the stack trace:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，如果我们再次运行`foo1`，我们会得到以下结果，其中`foo3`和`foo2`又回到了堆栈跟踪中：
- en: '![](img/633eeef5-2738-4fd7-be48-9e538be8fd04.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/633eeef5-2738-4fd7-be48-9e538be8fd04.png)'
- en: Note that the use of `catch_backtrace` must be within the `catch` block. If
    it is called outside of a `catch` block, it would return an empty backtrace.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`catch_backtrace`的使用必须在`catch`块内。如果它被调用在`catch`块之外，它将返回一个空的回溯。
- en: Next, we will look at a different aspect of exception handling – performance
    impact.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨异常处理的不同方面——性能影响。
- en: Understanding the performance impact of exception handling
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解异常处理对性能的影响
- en: There is actually a performance overhead to use a try-catch block. In particular,
    if the application is doing something in a tight loop, it would be a bad idea
    to catch exceptions inside the loop. To understand the impact, let's try a simple
    example.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，使用try-catch块会有性能开销。特别是如果应用程序在一个紧密的循环中执行某些操作，那么在循环中捕获异常是一个坏主意。为了理解影响，让我们尝试一个简单的例子。
- en: 'Consider the following code that simply calculates the sum of the square root
    of every number in an array:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码，它简单地计算数组中每个数字的平方根之和：
- en: '[PRE32]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Knowing that `sqrt` may throw `DomainError` for negative numbers, our first
    attempt may be to catch such exceptions inside the loop:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 知道`sqrt`函数对于负数可能会抛出`DomainError`异常，我们的第一次尝试可能是尝试在循环中捕获这样的异常：
- en: '[PRE33]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'What would be the performance impact of doing that? Let''s use the `BenchmarkTools`
    package to measure the performance for both functions:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做会对性能产生什么影响？让我们使用`BenchmarkTools`包来测量这两个函数的性能：
- en: '![](img/1de1690f-ad25-4112-9674-c6ed3713a7cd.png)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1de1690f-ad25-4112-9674-c6ed3713a7cd.png)'
- en: 'It turns out that just wrapping the code around a try-catch block has made
    the loop 5 times slower! Perhaps that is not a very good deal. So, what should
    we do in this case? Well, we can always proactively check the number before calling
    the `sqrt` function and avoid the problem with negative values. Let''s write a
    new `sum_of_sqrt3` function as follows:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，仅仅将代码包裹在try-catch块中已经使循环速度慢了5倍！也许这并不是一个好的交易。那么在这种情况下我们应该怎么做呢？嗯，我们总是可以在调用`sqrt`函数之前主动检查数字，避免负值的问题。让我们编写一个新的`sum_of_sqrt3`函数，如下所示：
- en: '[PRE34]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Let''s measure the performance again:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次测量性能：
- en: '![](img/9c0414ee-741b-4e9b-96af-ad9d8d9af8f9.png)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9c0414ee-741b-4e9b-96af-ad9d8d9af8f9.png)'
- en: '*Fantastic!* We have now restored the performance. The moral of the story is
    that we should be smart about using try-catch blocks, especially when performance
    is a concern. If there is any way to avoid a try-catch block, then it would certainly
    be a better option whenever a higher performance is needed.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '*太棒了!* 我们现在已经恢复了性能。这个故事的意义在于我们应该明智地使用try-catch块，尤其是在性能是一个关注点的时候。如果有可能避免try-catch块，那么在需要更高性能的情况下，这肯定是一个更好的选择。'
- en: Next, we will explore how to perform retries, a commonly-used strategy for recovering
    from failures.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨如何执行重试，这是一种常用的从失败中恢复的策略。
- en: Retrying operations
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重试操作
- en: Sometimes, exceptions are thrown due to unexpected outages or so-called *hiccups*.
    It is not an uncommon scenario for a system that is highly integrated with other
    systems or services. For example, the trading system in a stock exchange may need
    to publish trade execution data to a messaging system for downstream processing.
    But if the messaging system experiences just a momentary outage, then the operation
    could fail. In that case, the most common approach is to sleep for a while and
    then come back and try again. If the retry fails again, then the operation will
    be retried again later, until the system fully recovers.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，异常是由于意外的中断或所谓的*嗝*而抛出的。对于高度集成其他系统或服务的系统来说，这不是一个不常见的场景。例如，证券交易所的交易系统可能需要将交易执行数据发布到消息系统进行下游处理。但如果消息系统只是短暂的中断，那么操作可能会失败。在这种情况下，最常见的方法是等待一段时间，然后回来再次尝试。如果重试再次失败，那么操作将在系统完全恢复后再次重试。
- en: 'Such retry logic is not difficult to write. Here, we will play with an example.
    Suppose that we have a function that fails randomly:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的重试逻辑并不难编写。在这里，我们将玩一个例子。假设我们有一个随机失败的功能：
- en: '[PRE35]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'On a good day, we would see this lovely message:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个美好的日子里，我们会看到这样一条可爱的消息：
- en: '![](img/b0a6a39f-e178-42c1-9184-753bbc6d2f69.png)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b0a6a39f-e178-42c1-9184-753bbc6d2f69.png)'
- en: 'On a bad day, we would get this instead:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个糟糕的日子里，我们可能会得到以下结果：
- en: '![](img/1752398e-b12d-491d-8251-2b578c666f98.png)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1752398e-b12d-491d-8251-2b578c666f98.png)'
- en: 'Naively, we can develop a new function that incorporates the retry logic:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 天真地，我们可以开发一个新的函数，它包含了重试逻辑：
- en: '[PRE36]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This function just calls the `do_something` function. If it encounters an exception,
    it will wait 2 seconds as specified in the `retry_interval` keyword argument and
    try again. It keeps a track of a counter in `retry_count`, and so it will just
    retry up to 3 times by default, as indicated by the `max_retry_count` keyword
    argument:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数只是调用`do_something`函数。如果遇到异常，它将等待2秒，如`retry_interval`关键字参数中指定的那样，然后再次尝试。它会在`retry_count`中跟踪一个计数器，因此默认情况下它将重试最多3次，如`max_retry_count`关键字参数所示：
- en: '![](img/fe6d01e6-df13-453d-bc4b-076bc15dcba1.png)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![图片2](img/fe6d01e6-df13-453d-bc4b-076bc15dcba1.png)'
- en: 'Of course, this code is fairly straightforward and easy to write. But we will
    get bored quickly if we do this over and over again for many functions. It turns
    out that Julia comes with a `retry` function that solves this problem nicely.
    We can achieve the exact same functionality with a single line of code:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这段代码相当直接且易于编写。但如果我们要对许多函数重复这样做，很快就会感到无聊。结果发现，Julia自带一个`retry`函数，可以很好地解决这个问题。我们可以用一行代码实现完全相同的功能：
- en: '[PRE37]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `retry` function takes a function as the first argument. The `delays` keyword
    argument can be any object that supports the iteration interface. In this case,
    we have provided an array of 3 elements, each containing the number of 2.0\. The
    return value of the `retry` function is an anonymous function that takes any number
    of arguments. Those arguments will be *fed* into the original function that needs
    to be called, in this case, `do_something`. Here is how it looks using the `retry`
    function:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '`retry`函数将一个函数作为第一个参数。`delays`关键字参数可以是任何支持迭代接口的对象。在这种情况下，我们提供了一个包含3个元素的数组，每个元素包含数字2.0。`retry`函数的返回值是一个匿名函数，它接受任意数量的参数。这些参数将被*传递*到需要调用的原始函数中，在这种情况下是`do_something`。以下是使用`retry`函数的示例：'
- en: '![](img/bb0f8e8e-da80-40a7-ada7-e1b06359c05b.png)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![图片3](img/bb0f8e8e-da80-40a7-ada7-e1b06359c05b.png)'
- en: Since the `delays` argument can contain any number, we could utilize a different
    strategy that comes back with a different waiting time. A common usage is that
    we would want to retry quickly (that is, sleep less) in the beginning but slow
    down over time. When connecting to a remote system, it is possible that the remote
    system is just having a short hiccup, or perhaps it is undergoing an extended
    outage. In the latter scenario, it does not make sense to flood the system with
    quick requests as it would be a waste of system resources and get the water muddier
    when it is already in a mess.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`delays`参数可以包含任何数字，我们可以利用不同的策略，以不同的等待时间返回。一种常见的用法是，我们希望在开始时快速重试（即睡眠时间短），但随着时间的推移逐渐减慢。在连接到远程系统时，远程系统可能只是出现短暂的故障，或者可能正在进行长时间的停机。在后一种情况下，向系统发送快速请求是没有意义的，因为这会浪费系统资源，并且当系统已经处于混乱状态时，会使问题更加复杂。
- en: 'In fact, the default value for the `delays` argument is `ExponentialBackOff`,
    which iterates by exponentially increasing the delay time. On a very unlucky day,
    using `ExponentialBackOff` yields the following pattern:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`delays`参数的默认值是`ExponentialBackOff`，它会通过指数增加延迟时间进行迭代。在非常不幸的一天，使用`ExponentialBackOff`会产生以下模式：
- en: '![](img/8aa79787-65c4-4daf-acf8-485426df83b0.png)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![图片1](img/8aa79787-65c4-4daf-acf8-485426df83b0.png)'
- en: 'Let''s pay attention to the wait time between retries. The result should match
    the default setting of `ExponentialBackOff` as seen from its signature:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们关注重试之间的等待时间。结果应该与`ExponentialBackOff`的默认设置相匹配，正如其签名所示：
- en: '[PRE38]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The keyword argument, `n`, indicates the number of retries, for which we used
    the value of 10 in the preceding code. The first retry comes after 0.05 seconds.
    Then, for every retry, the time of delay grows by a factor of 5 up until it hits
    a maximum of 10 seconds. The growth rate may be jittered by 10%.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字参数`n`表示重试次数，在前面的代码中我们使用了10这个值。第一次重试在0.05秒后进行。然后，对于每次重试，延迟时间以5的倍数增长，直到达到最大值10秒。增长速率可能会有10%的波动。
- en: The `retry` function is often overlooked but it is a very convenient and powerful
    way to make the system more robust.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '`retry`函数经常被忽视，但它是一种非常方便且强大的方法，可以使系统更加健壮。'
- en: It is easy to throw an exception when something goes wrong. But that's not the
    only way to handle error conditions. In the next section, we will discuss the
    concepts of exceptions versus normal negative conditions.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 当出现问题时很容易抛出异常。但这并不是处理错误条件的唯一方式。在下一节中，我们将讨论异常与正常负面条件的概念。
- en: Choosing nothing over exceptions
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择不抛出异常
- en: Given the powerful features of a try-catch block, it is sometimes tempting to
    handle all negative scenarios with `Exception` types. In practice, we want to
    be very clear about what is truly an exception and what is a normal negative case.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到try-catch块强大的功能，有时会诱使我们用`Exception`类型处理所有负面情况。在实践中，我们想要非常清楚什么是真正的异常，什么只是正常的负面情况。
- en: 'We can turn to the `match` function as an example. The `match` function from
    the `Base` package can be used to match a regular expression against a string.
    If there is a match, then it returns a `RegexMatch` object, which contains the
    captured results. Otherwise, it returns `nothing`. The following example illustrates
    this effect:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将`match`函数作为一个例子。`Base`包中的`match`函数可以用来将正则表达式与字符串匹配。如果找到匹配项，则返回一个包含捕获结果的`RegexMatch`对象，否则返回`nothing`。以下示例说明了这种效果：
- en: '![](img/e20d6812-ac03-463d-bc3c-f0632ff86b94.png)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e20d6812-ac03-463d-bc3c-f0632ff86b94.png)'
- en: The first `match` function call returned a `RegexMatch` object because it found
    that `google.com` ends with `.com`. The second call could not find any match and
    so it returned `nothing`.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个`match`函数调用返回了一个`RegexMatch`对象，因为它发现`google.com`以`.com`结尾。第二个调用没有找到任何匹配项，因此返回了`nothing`。
- en: 'By design, the `match` function does not throw any exception. Why not? One
    reason for this is that the function is frequently used for checking whether a
    string contains another string and then the program decides what to do either
    way. Doing that would require a simple `if` statement; for instance, refer to
    the following code:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 按照设计，`match`函数不会抛出任何异常。为什么？一个原因是因为这个函数经常被用来检查一个字符串是否包含另一个字符串，然后程序决定如何处理。这样做需要一个简单的`if`语句；例如，参考以下代码：
- en: '[PRE39]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'If it were to throw an exception instead, then our code would have to look
    different, as follows:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它抛出一个异常，那么我们的代码将不得不有所不同，如下所示：
- en: '[PRE40]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: As you can see, the code can get very ugly very quickly using a try-catch block.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，使用try-catch块，代码可以很快变得非常丑陋。
- en: When designing a programming interface, we should always think about whether
    an exception is truly an exception or whether it could be just a negative status.
    In the case of the match function, a negative case is effectively represented
    by nothing.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计编程接口时，我们应始终考虑一个异常是否真的是一个异常，或者它是否可能只是负面状态。在匹配函数的情况下，负面情况有效地由`nothing`表示。
- en: In this section, we learned where to place try-catch blocks in our code. Now
    we should be able to properly catch exceptions and examine the stack frames.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了在代码中放置try-catch块的位置。现在我们应该能够正确地捕获异常并检查堆栈帧。
- en: We have come to understand better how performance may be impacted by the exception-handling
    code. Based on our understanding, we should be able to design and develop more
    robust software.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经更好地理解了性能可能受到异常处理代码的影响。基于我们的理解，我们应该能够设计和开发出更健壮的软件。
- en: Summary
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learned about the various patterns and techniques for
    building robust software. While Julia is a great language for quick prototypes
    and research projects, it has all the features to build robust, mission-critical
    systems.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了构建健壮软件的各种模式和技巧。虽然Julia是一种非常适合快速原型和研发项目的语言，但它具有构建健壮、关键任务系统的所有功能。
- en: We began our journey with the idea of encapsulating data with accessor functions,
    which allow us to design a formal API that we can support. We also discussed a
    naming convention that discourages people from accessing the internal state of
    the object.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始我们的旅程，想法是将数据与访问器函数封装起来，这允许我们设计一个我们可以支持的正式API。我们还讨论了一种命名约定，它鼓励人们不要访问对象的内部状态。
- en: We looked at Julia's property interface, which allows us to implement new *meanings*
    whenever the field access dot notation is used. By extending the `getproperty`
    and `setproperty!` functions, we are able to control both read and write access
    to the fields of an object.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们研究了Julia的属性接口，它允许我们在使用字段访问点符号时实现新的*含义*。通过扩展`getproperty`和`setproperty!`函数，我们能够控制对象字段的读写访问。
- en: We also learned how to hide specific variables or functions defined in a module.
    This strategy can be utilized whenever we want to have tighter control of the
    visibility of variables and functions of a module.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学习了如何隐藏模块中定义的特定变量或函数。这种策略可以在我们想要更紧密地控制模块变量和函数可见性时使用。
- en: Finally, we wanted to *take exception handling seriously!* We know robust software
    needs to be able to handle all kinds of exceptions. We dived deep into the try-catch
    process and learned how to determine the stack trace properly. We have proved
    that performance can be negatively impacted by the use of a try-catch block, so
    we need to be diligent about where to apply exception handling logic. We also
    learned how to use the standard `retry` function as a recovery strategy.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们希望认真对待异常处理！我们知道健壮的软件需要能够处理各种异常。我们深入研究了 try-catch 过程，并学会了如何正确地确定堆栈跟踪。我们已经证明，性能可能会因使用
    try-catch 块而受到负面影响，因此我们需要谨慎地考虑在哪里应用异常处理逻辑。我们还学会了如何使用标准的 `retry` 函数作为恢复策略。
- en: In the next chapter, we will go over a few more miscellaneous patterns commonly
    used in the Julia programs.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍一些在 Julia 程序中常用的更多杂项模式。
- en: Questions
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What are the benefits of developing assessor functions?
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开发评估函数的好处是什么？
- en: What would be an easy way to discourage the use of internal fields of an object?
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有什么简单的方法可以阻止使用对象的内部字段？
- en: Which functions may to be extended as part of the property interface?
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪些函数可以作为属性接口的一部分进行扩展？
- en: How can we capture the stack trace from a catch block after an exception has
    been caught?
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何捕获异常被捕获后的捕获块中的堆栈跟踪？
- en: What is the best way to avoid the performance impact of a try-catch block for
    a system that requires optimal performance?
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于需要最佳性能的系统，避免 try-catch 块对性能产生影响的最佳方式是什么？
- en: What is the benefit of using the retry function?
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用重试函数的好处是什么？
- en: How do we hide away global variables and functions that are used internally
    in a module?
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何隐藏模块内部使用的全局变量和函数？
