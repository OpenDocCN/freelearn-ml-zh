- en: Robustness Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 健壮性模式
- en: This chapter will cover several patterns that can be used to improve software
    robustness. By robustness, we are referring to the quality aspects, that is, can
    the software perform its functions correctly? Are all possible scenarios handled
    properly? This is an extremely important factor to consider when writing code
    for mission-critical systems.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍几种可以提高软件健壮性的模式。当我们提到健壮性时，我们指的是质量方面，即软件能否正确执行其功能？是否妥善处理了所有可能的场景？这是在编写关键任务系统代码时需要考虑的一个极其重要的因素。
- en: Based on the **Principle of Least Privilege** (**POLP**), we would consider
    hiding unnecessary implementation details to the client of the interface. However,
    Julia's data structure is transparent – all fields are automatically exposed and
    accessible. This poses a potential problem because any improper usage or mutation
    can break the system. Additionally, by accessing the fields directly, the code
    becomes more tightly coupled with the underlying implementation of an object.
    So, what if a field name needs to be changed? What if a field needs to be replaced
    by another one? Therefore, there is a need to apply abstraction and decouple object
    implementation from its official interface. We should adopt the more general definition –
    not only do we want to cover as many lines of code as possible but also every
    possible scenario as well. An increase in code coverage would give us more confidence
    about the correctness of our code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 根据**最小权限原则**（**POLP**），我们会考虑隐藏不必要的实现细节给接口的客户端。然而，Julia的数据结构是透明的——所有字段都自动暴露并可访问。这可能会带来潜在的问题，因为任何不当的使用或修改都可能破坏系统。此外，通过直接访问字段，代码与对象的底层实现耦合得更紧密。那么，如果需要更改字段名怎么办？如果需要用另一个字段替换它怎么办？因此，有必要应用抽象，将对象实现与其官方接口解耦。我们应该采用更通用的定义——不仅希望覆盖尽可能多的代码行，还希望涵盖所有可能的场景。代码覆盖率的提高将使我们更有信心地确保代码的正确性。
- en: 'We have classified these techniques into the following sections:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这些技术分为以下几部分：
- en: Accessor patterns
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问者模式
- en: Property patterns
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性模式
- en: Let block patterns
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码块模式
- en: Exception handling patterns
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常处理模式
- en: By the end of this chapter, you will be able to encapsulate data access by developing
    your own accessor functions and property functions. You will also be able to hide
    away global variables from unexpected access outside of the module. Finally, you
    will also know about various exception handling techniques and understand how
    to retry failed operations.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够通过开发自己的访问器函数和属性函数来封装数据访问。你还将能够隐藏模块外的意外访问的全局变量。最后，你还将了解各种异常处理技术，并理解如何重试失败的操作。
- en: '*Let''s get started!*'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*让我们开始吧！*'
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The example source code for this chapter can be found at [https://github.com/PacktPublishing/Hands-on-Design-Patterns-and-Best-Practices-with-Julia/tree/master/Chapter08](https://github.com/PacktPublishing/Hands-on-Design-Patterns-and-Best-Practices-with-Julia/tree/master/Chapter08).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例源代码可以在[https://github.com/PacktPublishing/Hands-on-Design-Patterns-and-Best-Practices-with-Julia/tree/master/Chapter08](https://github.com/PacktPublishing/Hands-on-Design-Patterns-and-Best-Practices-with-Julia/tree/master/Chapter08)找到。
- en: The code is tested in a Julia 1.3.0 environment.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 代码在Julia 1.3.0环境中进行了测试。
- en: Accessor patterns
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问者模式
- en: Julia objects are transparent. What does that mean? Well, currently, the Julia
    language does not have the ability to apply access control over the fields of
    an object. Therefore, people coming from a C++ or Java background may find it
    a little uneasy. In this section, we will explore a number of ways in which to
    make the language more acceptable for those users who are seeking more access
    control.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Julia对象是透明的。这是什么意思呢？目前，Julia语言没有能力对对象的字段应用访问控制。因此，来自C++或Java背景的人可能会觉得有点不习惯。在本节中，我们将探讨多种方法，使语言更易于那些寻求更多访问控制的用户接受。
- en: 'So, perhaps we should define our requirements first. While we write up the
    requirements, we will also ask ourselves why we want to have them in the first
    place. Let''s just consider any object in a Julia program:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可能首先应该定义我们的需求。在我们编写需求的同时，我们也会问自己为什么一开始就要有这些需求。让我们考虑一下Julia程序中的任何对象：
- en: '**Some fields need to be hidden from the outside world**: Some fields are considered
    to be part of the public interface and are, therefore, fully documented and supported.
    Other fields are considered implementation details, and they may not be used because
    they are subject to change in the future.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一些字段需要对外界隐藏**：一些字段被认为是公共接口的一部分，因此它们被完全文档化和支持。其他字段被认为是实现细节，它们可能不会被使用，因为它们可能会在未来发生变化。'
- en: '**Some fields require validation before being mutated**: Some fields may only accept
    a range of values. For example, an `age` field of a `Person` object may reject
    anything less than 0 or greater than 120! Avoiding invalid data is paramount to
    building robust systems.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一些字段在修改之前需要验证**：一些字段可能只能接受一定范围内的值。例如，一个 `Person` 对象的 `age` 字段可能会拒绝小于 0 或大于
    120 的任何值！避免无效数据对于构建健壮的系统至关重要。'
- en: '**Some fields require a trigger before they can be read**: Some fields may
    be lazily loaded, which means they are not loaded until the value is read. Another
    reason is that some fields may contain sensitive data, and the use of such fields
    must be logged for audit purposes.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一些字段在读取之前需要触发器**：一些字段可能是延迟加载的，这意味着它们只有在读取值时才会被加载。另一个原因是，一些字段可能包含敏感数据，并且为了审计目的，必须记录对这些字段的用途。'
- en: We will now discuss how to address these requirements.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将讨论如何满足这些要求。
- en: Recognizing the implicit interface of an object
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 识别对象的隐含接口
- en: Before we dive into the specific patterns, let's first take a quick detour and
    discuss how and why we have a problem in the first place.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入具体模式之前，让我们先快速地绕道一下，讨论一下我们最初是如何以及为什么会有这个问题。
- en: 'Suppose that we have defined a data type called `Simulation` to keep track
    of some scientific experiment data and related statistics. The syntax for it is
    as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们已经定义了一个名为 `Simulation` 的数据类型，用于跟踪一些科学实验数据和相关的统计信息。它的语法如下：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'A `Simulation` object contains an N-dimensional array of floating-point values
    and a named tuple of statistical values. For demonstration purposes, we will create
    a simple function to perform a simulation and create an object, as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `Simulation` 对象包含一个 N 维浮点值数组和统计值的命名元组。为了演示目的，我们将创建一个简单的函数来执行模拟并创建一个对象，如下所示：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The simulation data called `heatmap` is generated using the `rand` function
    based on a distribution provided by the user. The `dims` argument represents the
    number of dimensions in the array, and the value of `n` represents the size of
    each dimension. Here''s how to simulate a normally distributed 2-dimensional heatmap
    of size 1000 x 1000:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 使用用户提供的分布的 `rand` 函数生成的模拟数据称为 `heatmap`。`dims` 参数表示数组中的维度数，而 `n` 的值表示每个维度的尺寸。以下是如何模拟一个大小为
    1000 x 1000 的正态分布二维热图的示例：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'At this point, we can easily access the `heatmap` and `stats` fields of the
    object as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们可以轻松地访问对象的 `heatmap` 和 `stats` 字段，如下所示：
- en: '![](img/43488f32-78a0-4369-aa45-06c159ccb5ef.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/43488f32-78a0-4369-aa45-06c159ccb5ef.png)'
- en: Let's pause for a second. Is it OK to access the fields directly? We can argue
    here that it is not. The primary reason is that there is an implicit assumption
    that the field names represent the public interface of the object.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们暂停一下。直接访问字段是否可以？我们可以在这里争论说这不行。主要原因是存在一个隐含的假设，即字段名称代表对象的公共接口。
- en: 'Unfortunately, such an assumption can be a little brittle in reality. As any
    seasoned programmer would have pointed out, software is always subject to change. *Always
    to* *change*. The world is not static, and requirements are not set in stone.
    For example, here are some possible changes that will certainly break our programming
    interface:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这样的假设在现实中可能有点脆弱。正如任何经验丰富的程序员都会指出的，软件总是需要改变。*总是需要*改变。世界不是静态的，需求也不是一成不变的。例如，以下是一些肯定会破坏我们的编程接口的可能变化：
- en: Changing the field name of `heatmap` to `heatspace` because the new name is
    better suited for 3-dimensional or higher-dimensional data
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `heatmap` 字段的名称更改为 `heatspace`，因为新的名称更适合三维或更高维度的数据
- en: Changing the data type of `stats` from a named tuple to a new `struct` type
    because it has grown to include more complex statistical measures and we want
    to develop new functions along with that
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `stats` 字段的数据类型从命名元组更改为新的 `struct` 类型，因为它已经增长到包括更复杂的统计度量，并且我们希望随着它开发新的函数
- en: Removing the `stats` field altogether and computing it on the fly
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完全移除 `stats` 字段，并在运行时计算它
- en: As you can see, the programming interface cannot be taken lightly. In order
    to build software that lasts, we need to be clear about every single interface
    and understand how to support them in the future.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，编程接口不能轻率对待。为了构建持久的软件，我们需要对每个接口都清楚，并了解如何在未来支持它们。
- en: One way to provide an interface to an object is to create assessor functions,
    which are sometimes called getters and setters in other programming languages.
    So, in the next sections, let's look at how to use them.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 提供对象接口的一种方法是通过创建评估函数，在其他编程语言中有时称为获取器和设置器。因此，在接下来的几节中，让我们看看如何使用它们。
- en: Implementing getter functions
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现获取器函数
- en: 'In mainstream object-oriented languages, we often implement getters for accessing
    the fields of an object. In Julia, we can also create getter functions. When implementing
    getter functions, we can choose which fields to expose as part of the **application
    programming interface** (**API**). For our example, we will implement getter functions
    for both fields, as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在主流面向对象的语言中，我们经常实现获取器来访问对象的字段。在 Julia 中，我们也可以创建获取器函数。在实现获取器函数时，我们可以选择哪些字段作为**应用程序编程接口**（**API**）的一部分进行暴露。在我们的示例中，我们将为两个字段都实现获取器函数，如下所示：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Our choice of function names here is somewhat non-idiomatic for the Julia language.
    A better convention is to use the nouns directly:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们选择的函数名称对于 Julia 语言来说有些非习惯用法。更好的约定是直接使用名词：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: So, when we read the code that uses the `heatmap` function, we can read it as
    the *heatmap of the simulation*. Likewise, we can read it as the *statistics of
    the simulation* when the `stats` function is used.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当我们阅读使用`heatmap`函数的代码时，我们可以将其视为*模拟的热图*。同样，当使用`stats`函数时，我们可以将其视为*模拟的统计数据*。
- en: These getter functions serve the purpose of defining a formal data retrieval
    interface for the object. If we ever need to change the names (or even the types)
    of the underlying fields, it would be fine as long as the public interface does
    not change. Furthermore, we could even remove the `stats` field and implement
    the statistical calculation directly in the `stats` function. Backward compatibility
    can now be easily maintained for any program that uses this object.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这些获取器函数的目的是为对象定义一个正式的数据检索接口。如果我们需要更改底层字段的名称（甚至类型），只要公共接口不变，那就没问题。此外，我们甚至可以删除`stats`字段，并在`stats`函数中直接实现统计计算。现在，我们可以轻松地维护任何使用此对象的程序的向后兼容性。
- en: Next, we will look at write access for objects.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨对象的写访问权限。
- en: Implementing setter functions
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现设置器函数
- en: 'For mutable types, we may implement setters. The scope would include fields
    that can only ever be mutated. For our simulation project, suppose that we want
    to allow the client program to do some transformation of the heatmap and put it
    back to the object. We can support that use case easily, as shown in the following
    code snippet:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 对于可变类型，我们可能需要实现设置器。其范围包括只能被修改的字段。对于我们的模拟项目，假设我们希望允许客户端程序对热图进行一些转换并将其放回对象中。我们可以轻松地支持这个用例，如下面的代码片段所示：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The setter function, `heatmap!`, accepts a `Simulation` object and a new heatmap
    array. Because the `stats` field contains the statistics of the underlying heatmap,
    we must maintain consistency within the object by recalculating the statistics
    and updating the field. Note that such a guarantee for consistency is only possible
    when we provide a setter function. Otherwise, the object would be in an inconsistent
    state if we ever to allow users to directly mutate the `heatmap` field in the
    object.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 设置器函数`heatmap!`接受一个`Simulation`对象和一个新的热图数组。因为`stats`字段包含底层热图的统计数据，我们必须通过重新计算统计数据并更新字段来在对象内部保持一致性。请注意，这种一致性的保证只有在提供设置器函数时才可能。否则，如果我们允许用户直接修改对象中的`heatmap`字段，对象就会处于不一致的状态。
- en: 'An additional benefit is that we can perform data validation in the setter
    function. For example, we can control the size of the map and throw an error when
    the size of the heatmap contains odd shapes:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个好处是，我们可以在设置器函数中执行数据验证。例如，我们可以控制地图的大小，并在热图的大小包含奇形状时抛出错误：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, we first determine the size of `new_heatmap`, which should be returned
    as a tuple. Then, we find out how many unique values are in this tuple. If there
    is only a single unique number in the tuple, then we know that the array is square,
    cubic, and so on. Otherwise, we just throw an error back to the caller.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先确定 `new_heatmap` 的大小，它应该作为一个元组返回。然后，我们找出这个元组中有多少唯一的值。如果元组中只有一个唯一的数字，那么我们知道数组是正方形、立方体等等。否则，我们只需将错误抛回调用者。
- en: Just like getter functions, setter functions serve as a public interface where
    the data of an object may be mutated. After we have both getter and setter functions,
    we can expect the caller to go through the interfaces. But the original fields
    can still be accessed directly. So, how do we stop that from happening? Let's
    explore that next.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 就像获取函数一样，设置函数充当一个公共接口，其中对象的数據可能会被修改。在我们有了获取和设置函数之后，我们可以期待调用者通过接口进行操作。但原始字段仍然可以直接访问。那么，我们如何阻止这种情况发生呢？让我们在下一节中探讨这个问题。
- en: Discouraging direct field access
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 阻止直接访问字段
- en: While getter and setter functions are convenient, it is easy to forget about
    these functions and so the program ends up accessing the fields directly. That
    would be too bad, as we have just spent all that effort creating getter and setter
    functions and they end up getting bypassed.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然获取和设置函数很方便，但很容易忘记这些函数，所以程序最终会直接访问字段。那会很糟糕，因为我们刚刚花费了所有这些努力创建获取和设置函数，但它们最终被绕过了。
- en: A possible solution is to discourage direct field access by renaming the fields
    to something that looks obviously private. A common convention is to prepend the
    field names with underscores.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 一种可能的解决方案是通过对字段重命名，使其看起来显然是私有的，来阻止直接访问字段。一个常见的约定是在字段名前加上下划线。
- en: 'For our example, we can redefine the struct as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的示例，我们可以将结构体重新定义为以下内容：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: These oddly named fields will then only be used within the implementation of
    the `Simulation` type, and all external usages will avoid them. Such a convention
    discourages the programmer from making the mistake of accessing the fields directly.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这些奇特命名的字段将仅在 `Simulation` 类型的实现中使用，所有外部使用都将避免它们。这样的约定可以阻止程序员直接访问字段。
- en: However, some of us may not be very satisfied with this solution because the
    use of a coding convention is a very weak method for enforcing the proper use
    of the programming interface. Such concern is very valid especially when we hold
    ourselves to a higher standard of software robustness. So, in the next section,
    we will explore a stronger technique that will allow us to control access programmatically.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们中的一些人可能对这种解决方案不太满意，因为使用编码约定来强制正确使用编程接口是一种非常薄弱的方法。这种担忧是非常合理的，尤其是当我们对自己软件的鲁棒性有更高的标准时。因此，在下一节中，我们将探讨一种更强大的技术，这将使我们能够通过编程方式控制访问。
- en: Property patterns
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性模式
- en: In this section, we will take a deep dive and learn how to enforce more granular
    control over the fields of an object by using the property interface. Julia's
    property interface allows you to provide a custom implementation for the dot notation
    used in field access. By overriding the standard behavior, we can apply any kind
    of access control and validation against the field being referenced or assigned.
    To illustrate this concept, we will tackle a new use case here – implementing
    a lazy file loader.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将深入探讨如何通过使用属性接口来对对象的字段实施更细粒度的控制。Julia 的属性接口允许你为字段访问中使用的点符号提供自定义实现。通过覆盖标准行为，我们可以对引用或分配的字段应用任何类型的访问控制和验证。为了说明这个概念，我们将在下面处理一个新的用例——实现懒文件加载器。
- en: Introducing the lazy file loader
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入懒文件加载器
- en: 'Suppose that we are developing a file loading facility that supports lazy loading.
    By lazy, we are talking about not loading a file until the content is required. Let''s
    take a look at the following code:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在开发一个支持懒加载的文件加载功能。这里的“懒”指的是在需要内容之前不加载文件。让我们看看以下代码：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `FileContent` struct contains three fields:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileContent` 结构体包含三个字段：'
- en: '`path`: The location of the file'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`path`: 文件的位置'
- en: '`loaded`: A Boolean value that indicates whether the file has been loaded into
    memory'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loaded`: 一个布尔值，表示文件是否已被加载到内存中'
- en: '`contents`: A byte array that contains the contents of the file'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`contents`: 包含文件内容的字节数组'
- en: 'Here''s the constructor for the same struct:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是该结构体的构造函数：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As with our current design, we pre-allocate memory for the file but we do not
    read the file content until later. The size of the file is determined by a call
    to the `lstat` function. When creating the `FileContent` object, we initialize
    the `loaded` field with a `false` value – an indication that the file has not
    been loaded into memory.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们的当前设计一样，我们预先为文件分配内存，但我们不会在之后读取文件内容。文件的大小由对 `lstat` 函数的调用确定。在创建 `FileContent`
    对象时，我们将 `loaded` 字段初始化为 `false` 值——这表明文件尚未加载到内存中。
- en: 'Eventually, we must load the file content, so we just provide a separate function
    that reads the file into the pre-allocated byte array:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，我们必须加载文件内容，所以我们提供了一个单独的函数来读取文件到预先分配的字节缓冲区：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let''s run a quick test to see how it works:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行一个快速测试来看看它的工作情况：
- en: '![](img/c2055393-41c1-4d8a-981f-29c97ed5b947.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c2055393-41c1-4d8a-981f-29c97ed5b947.png)'
- en: Here, we have just created a new `FileContent` object. Clearly, the `loaded`
    field contains a `false` value because we have not read the file yet. The `content`
    field is also full of zeros.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们刚刚创建了一个新的 `FileContent` 对象。显然，`loaded` 字段包含一个 `false` 值，因为我们还没有读取文件。`content`
    字段也充满了零。
- en: 'Let''s load the file content now:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们加载文件内容：
- en: '![](img/8fba08b6-09a5-48ca-b8ed-81eabeecc8e2.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8fba08b6-09a5-48ca-b8ed-81eabeecc8e2.png)'
- en: Now, the `contents` field contains some real data, and the `loaded` field has
    the value of `true`. Of course, we are just babysitting and running the code manually
    for now. The idea is to implement lazy loading. We need a way to intercept any
    *read* operation into the `contents` field so that the file content can be loaded
    just in time. Ideally, this should happen whenever someone uses the `fc.contents` expression. In
    order to *hijack* the call to get `fc.contents`, we must first understand how
    Julia's dot notation works. Let's take a detour and go over that now.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`contents` 字段包含了一些真实数据，而 `loaded` 字段具有 `true` 的值。当然，我们现在只是照看并手动运行代码。我们的想法是实现懒加载。我们需要一种方法来拦截对
    `contents` 字段的任何 *读取* 操作，以便及时加载文件内容。理想情况下，这应该发生在有人使用 `fc.contents` 表达式时。为了 *劫持*
    获取 `fc.contents` 的调用，我们首先必须理解 Julia 的点符号是如何工作的。让我们现在绕道而行，回顾一下。
- en: Understanding the dot notation for field access
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解字段访问的点符号
- en: 'In general, whenever we need to access a specific field of an object, we can
    conveniently write it as `object.fieldname`. As it turns out, this notation is
    really *syntactic sugar*, that is, some *sweet* syntax, for the `getproperty`
    function call. To be clear, whenever we write the code in the following format:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当我们需要访问对象的特定字段时，我们可以方便地将其写成 `object.fieldname`。实际上，这种表示法是 `getproperty` 函数调用的
    *语法糖*，即一些 *甜蜜* 的语法。为了清楚起见，每当我们在以下格式中编写代码：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'It is translated to a function call to `getproperty`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 它被转换为一个对 `getproperty` 的函数调用：
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: For our lazy file loader example, `fc.path` is really the same as `getproperty(fc,
    :path)`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的懒加载文件示例，`fc.path` 实际上与 `getproperty(fc, :path)` 相同。
- en: 'All that magic is performed automatically by the Julia compiler. A great thing
    about Julia is that this kind of magic is quite transparent. We can actually see
    what the compiler did by using the `Meta.lower` function, as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些魔法都是由 Julia 编译器自动执行的。关于 Julia 的一个好处是这种魔法相当透明。我们可以通过使用 `Meta.lower` 函数来实际看到编译器做了什么，如下所示：
- en: '![](img/48bcbdb0-09a0-4218-be37-12df457b886b.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/48bcbdb0-09a0-4218-be37-12df457b886b.png)'
- en: 'Similarly, when we assign a value to a field of an object, the same kind of
    translation takes place:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，当我们向对象的字段赋值时，也会发生类似的转换：
- en: '![](img/2fc46302-5481-4d5e-a462-ed0a56208428.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2fc46302-5481-4d5e-a462-ed0a56208428.png)'
- en: From the preceding result, we can see when the code assigns a string to `fc.path`,
    it is just translated to a `setproperty!(fc, :path, "/etc/hosts")` function call.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的结果中，我们可以看到当代码将字符串赋值给 `fc.path` 时，它只是转换为一个 `setproperty!(fc, :path, "/etc/hosts")`
    函数调用。
- en: 'Let''s not stop there. What do the `getproperty` and `setproperty!` functions
    do? Well, they happen to be plain Julia functions defined in the `Base` module.
    The best place to understand how they work is by examining the Julia source code
    itself. From the Julia REPL, we can easily bring up the source code as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不要就此止步。`getproperty` 和 `setproperty!` 函数具体是做什么的呢？嗯，它们恰好是定义在 `Base` 模块中的普通
    Julia 函数。理解它们是如何工作的最佳方式是检查 Julia 的源代码本身。从 Julia REPL 中，我们可以轻松地调出源代码，如下所示：
- en: '![](img/383f5807-726f-4091-bc02-ef0fcb6ccf7b.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/383f5807-726f-4091-bc02-ef0fcb6ccf7b.png)'
- en: 'From the preceding code, we can see that the `@edit` macro is used to locate
    the source code of the function being called – in this case, `getproperty`. From
    the REPL terminal, it should open your editor and display the code as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中，我们可以看到`@edit`宏用于定位被调用函数的源代码——在本例中是`getproperty`。从REPL终端，它应该打开你的编辑器并显示如下代码：
- en: '![](img/aaf7c948-9132-43c7-a06d-9642db881eb9.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/aaf7c948-9132-43c7-a06d-9642db881eb9.png)'
- en: '*Aha!* We see that the `getproperty` function just forwards the call to `getfield`,
    which is used to extract the data from the object. The next line in the same source
    file shows the definition of `setproperty!`. The implementation of `setproperty!`
    is a bit more interesting. Besides using the `setfield!` function to mutate the
    field in the object, it also converts the `v` value to the type of the field in
    object `x`, which is determined by a call to `fieldtype`.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*啊哈!* 我们看到`getproperty`函数只是将调用转发到`getfield`，后者用于从对象中提取数据。同一源文件中的下一行显示了`setproperty!`的定义。`setproperty!`的实现稍微有趣一些。除了使用`setfield!`函数来修改对象中的字段外，它还将`v`值转换为对象`x`中字段的类型，这是通过调用`fieldtype`确定的。'
- en: The `getfield` function is a built-in function for getting any field value from
    an existing object. It takes two arguments – an object and a symbol. For example,
    to get the path from a `FileContent` object, we can use `getfield(fc, :path)`.
    Likewise, the `setfield!` function is used to update any field of an existing
    object. Both `getfield` and `setfield!` are low-level functions in the Julia implementation.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`getfield`函数是一个用于从现有对象获取任何字段值的内置函数。它接受两个参数——一个对象和一个符号。例如，要从`FileContent`对象获取路径，我们可以使用`getfield(fc,
    :path)`。同样，`setfield!`函数用于更新现有对象的任何字段。`getfield`和`setfield!`都是Julia实现中的低级函数。'
- en: Type conversion is convenient, especially for numerical types. For example,
    it is quite common for an object to store a `Float64` field but the code happens
    to pass an integer instead. Of course, the conversion logic is more general than
    just numeric types. For custom types, the same auto-conversion process would work
    fine as long as a `convert` function is defined.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 类型转换很方便，尤其是对于数值类型。例如，一个对象存储一个`Float64`字段，但代码恰好传递了一个整数。当然，转换逻辑比仅仅数值类型更通用。对于自定义类型，只要定义了一个`convert`函数，相同的自动转换过程就可以正常工作。
- en: Now that we understand how the dot notation is translated to the `getproperty`
    and `setproperty!` function calls, we can develop the lazy loading feature for
    our file loader.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了点符号是如何转换为`getproperty`和`setproperty!`函数调用的，我们可以为我们的文件加载器开发懒加载功能。
- en: Implementing read access and lazy loading
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现读写访问和懒加载
- en: In order to implement lazy loading, we can extend the `getproperty` function.
    During the call, we can check whether the file content has been loaded yet. If
    not, we just load the file content right before returning the data back to the
    caller.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现懒加载，我们可以扩展`getproperty`函数。在调用过程中，我们可以检查文件内容是否已经加载。如果没有，我们就在返回数据给调用者之前加载文件内容。
- en: 'Extending the `getproperty` function is as easy as simply defining it with
    the `FileContent` type and a symbol as the arguments of the function. The following
    code shows this:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展`getproperty`函数就像简单地使用`FileContent`类型和一个符号作为函数参数来定义它一样简单。以下代码展示了这一点：
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: It is important that we define the function for `Base.getproperty` rather than
    just `getproperty`. That is because the compiler will translate the dot notation
    to `Base.getproperty` rather than the `getproperty` function in your own module.
    If this is unclear, you are encouraged to revisit the namespace concept from the *Understanding
    namespaces, modules, and packages* section in [Chapter 2](48061f6f-db77-4db6-9c92-d7550f4317fe.xhtml),
    *Modules, Packages, and Data Type Concepts*.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是我们定义了`Base.getproperty`函数而不是仅仅`getproperty`。这是因为编译器会将点符号转换为`Base.getproperty`而不是你自己的模块中的`getproperty`函数。如果这还不清楚，你被鼓励回顾第2章中“理解命名空间、模块和包”部分的*理解命名空间、模块和包*。
- en: We have chosen to put `Base` as a prefix to the function name in the definition.
    This style of coding is preferred because it is clear from the function definition
    that we are extending the `getproperty` function from the `Base` package.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择在函数名定义中使用`Base`作为前缀。这种编码风格更受欢迎，因为它从函数定义中可以清楚地看出，我们正在扩展`Base`包中的`getproperty`函数。
- en: 'Another way to extend functions from another package is to first import the
    third-party package. For the preceding example, we could have written it as follows.
    This coding style is not recommended because it is less obvious that the `getproperty`
    function being defined is an extension of the function from `Base`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 从另一个包扩展函数的另一种方法是首先导入第三方包。对于前面的例子，我们可以这样写。这种编码风格不推荐，因为它不太明显地表明正在定义的 `getproperty`
    函数是 `Base` 函数的扩展：
- en: '`import Base: getproperty`'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`import Base: getproperty`'
- en: '`function getproperty(fc::FileContent, s::Symbol)`'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`function getproperty(fc::FileContent, s::Symbol)`'
- en: '` ....`'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '` ....`'
- en: '`end`'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`end`'
- en: 'By contrast, the `getproperty` function must handle all possible property names.
    Let''s first consider the following section of code:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 与之相反，`getproperty` 函数必须处理所有可能的属性名称。让我们首先考虑以下代码段：
- en: '![](img/3536077d-b41a-4f7e-9e81-745554338153.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3536077d-b41a-4f7e-9e81-745554338153.png)'
- en: In this case, we must support `:path` and `:contents`. If the `s` symbol is
    one of those fields that we want to pass through directly, then we just forward
    the call to the `getfield` function.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们必须支持 `:path` 和 `:contents`。如果 `s` 符号是我们想要直接传递的字段之一，那么我们只需将调用转发给 `getfield`
    函数。
- en: 'Now, let''s consider the next section of code:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们考虑下一段代码：
- en: '![](img/29f338e3-569e-4384-8a97-116e021eb3cc.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/29f338e3-569e-4384-8a97-116e021eb3cc.png)'
- en: If the symbol is `:contents`, then we check the value of the `loaded` field.
    If the `loaded` field contains `false`, then we call the `load_contents!` function
    to load the file content into memory.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果符号是 `:contents`，那么我们检查 `loaded` 字段的值。如果 `loaded` 字段包含 `false`，那么我们调用 `load_contents!`
    函数将文件内容加载到内存中。
- en: Note that we have used `getfield` all over the place in this function. If we
    had written the code using the normal dot syntax, for example, `fc.loaded`, then
    it would start calling the `getproperty` function again and we could end up with
    infinite recursion.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在整个函数中到处都使用了 `getfield`。如果我们使用正常的点符号编写代码，例如 `fc.loaded`，那么它将开始调用 `getproperty`
    函数，我们可能会陷入无限递归。
- en: 'If the field name is not one of the supported ones, then we just raise an exception,
    as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果字段名称不是支持的名称之一，那么我们只需抛出一个异常，如下所示：
- en: '![](img/01e12635-9f90-40ff-8a33-cc32779c7fb0.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/01e12635-9f90-40ff-8a33-cc32779c7fb0.png)'
- en: One interesting observation is that we have decided to support two property
    names only – `path` and `contents` – and we have dropped the support for the `loaded`
    property. The reason for this is that the `loaded` field is really used as an
    internal state of the object. There is no reason to expose it as part of the public
    programming interface. As we talk about software robustness in this chapter, we
    can also appreciate developing code that only exposes necessary information.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有趣的观察是，我们决定只支持两个属性名称——`path` 和 `contents`——并且我们放弃了 `loaded` 属性的支持。这样做的原因是
    `loaded` 字段实际上被用作对象的内部状态。没有理由将其作为公共编程接口的一部分暴露出来。正如我们在本章讨论软件健壮性时，我们也可以欣赏只暴露必要信息的代码开发。
- en: An analogy is that data is always *classified* but can be released only on a
    *need-to-know basis, *which is how government officials usually like to describe
    highly sensitive data.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类比是数据总是 *分类* 的，但只能根据 *需要了解* 的原则释放，这是政府官员通常用来描述高度敏感数据的方式。
- en: 'We are almost done. The only remaining piece of work is to refactor the `load_content!`
    function to use `getfield` and `setfield!` instead of the dot notation:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎完成了。唯一剩下的工作是将 `load_content!` 函数重构为使用 `getfield` 和 `setfield!` 而不是点符号：
- en: '[PRE14]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can now test the lazy loading functionality:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以测试懒加载功能：
- en: '![](img/89ea2112-43ec-4f69-9099-3b01caf2ea09.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/89ea2112-43ec-4f69-9099-3b01caf2ea09.png)'
- en: 'Both references to the `path` and `contents` fields are working properly. In
    particular, a reference to `fc.contents` triggered the file load and then returned
    the proper content. So, what happened to the `loaded` field? Let''s try it:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 对 `path` 和 `contents` 字段的两次引用都工作正常。特别是，对 `fc.contents` 的引用触发了文件加载，然后返回了正确的内容。那么
    `loaded` 字段发生了什么？让我们试试：
- en: '![](img/5396a7f5-c50b-4a5d-b3a5-cfc8a107bb6a.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5396a7f5-c50b-4a5d-b3a5-cfc8a107bb6a.png)'
- en: '*Voila!* We have successfully prevented the `loaded` field from being accessed
    directly.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '*Voila!* 我们已经成功阻止了直接访问 `loaded` 字段。'
- en: The property interface has enabled us to manage read access and implement the
    lazy loading feature. Next, we will look at how to manage write access as well.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 属性接口使我们能够管理读访问并实现懒加载功能。接下来，我们将探讨如何管理写访问。
- en: Controlling write access to object fields
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制对象字段的写访问
- en: In order to manage write access to the fields of an object, we can extend the
    `setproperty!` function, in a similar way to how we did for read access.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为了管理对对象字段的写访问，我们可以像控制读访问一样扩展`setproperty!`函数。
- en: 'Let''s recall how the `FileContent` data type was designed:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下`FileContent`数据类型是如何设计的：
- en: '[PRE15]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Suppose that we want to allow the user to switch to a different file by mutating
    the `path` field with a new file location. In addition to this, we want to prevent
    the `loaded` and `contents` fields from being changed directly using dot notation.
    To achieve that, we can extend the `setproperty!` function as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要允许用户通过将`path`字段修改为新文件位置来切换到不同的文件。除此之外，我们还想防止直接使用点符号修改`loaded`和`contents`字段。为了实现这一点，我们可以扩展`setproperty!`函数，如下所示：
- en: '[PRE16]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: To extend the `setproperty!` function, we must use `setfield!` in the function
    definition whenever we need to change any field in the object.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 为了扩展`setproperty!`函数，我们必须在函数定义中每次需要更改对象中的任何字段时使用`setfield!`。
- en: 'In this case, when the user tries to assign a value to the `path` field, we
    can just reinitialize the object like how we did in the constructor function.
    This involves setting the values of the `path` and `loaded` fields, as well as
    pre-allocating memory space for the file content. Let''s go ahead and test it
    now:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，当用户尝试将值赋给`path`字段时，我们只需像在构造函数中做的那样重新初始化对象。这涉及到设置`path`和`loaded`字段的值，以及为文件内容预分配内存空间。让我们现在就进行测试：
- en: '![](img/ea01bf9b-ac31-46f4-af99-35477c418891.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ea01bf9b-ac31-46f4-af99-35477c418891.png)'
- en: 'If the user tries to assign a value to any other field, an error is thrown:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户尝试将值赋给任何其他字段，将会抛出错误：
- en: '![](img/f4271bfb-0dfe-477b-9f92-193da206d57b.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f4271bfb-0dfe-477b-9f92-193da206d57b.png)'
- en: By extending the `setproperty!` function, we have successfully controlled write
    access to any field for any object.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 通过扩展`setproperty!`函数，我们已经成功控制了对任何对象的任何字段的写访问。
- en: While individual field access can be controlled, we cannot prevent additional
    changes to the underlying data of a field. For example, the `contents` property
    is just an array of bytes and the programmer should be able to change the elements
    in the array. If we want to protect the data from being modified, we can return a
    copy of the `contents` byte array from the `getproperty` call.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可以控制对单个字段的访问，但我们无法防止对字段底层数据的额外更改。例如，`contents`属性只是一个字节数组，程序员应该能够更改数组中的元素。如果我们想保护数据不被修改，我们可以在`getproperty`调用中返回`contents`字节数组的副本。
- en: By now, we know how to implement the `getproperty` and `setproperty!` functions
    so that we can control access to the individual fields of an object. Next, we
    will look at how to document what properties are available.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经知道如何实现`getproperty`和`setproperty!`函数，以便我们可以控制对对象各个字段的访问。接下来，我们将探讨如何记录可用的属性。
- en: Reporting accessible fields
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 报告可访问字段
- en: 'A development environment can often help a programmer to enter field names
    correctly. In the Julia REPL, when I press the *Tab* key twice after entering
    the dot character, it will try to autocomplete and display the available field
    names:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 开发环境经常可以帮助程序员正确输入字段名。在Julia的REPL中，当我输入点字符后按两次*Tab*键，它将尝试自动完成并显示可用的字段名：
- en: '![](img/3f5a7e8f-a25b-40a6-ab61-b07108a07048.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3f5a7e8f-a25b-40a6-ab61-b07108a07048.png)'
- en: 'Now that we have implemented the `getproperty` and `setproperty!` functions,
    the list is no longer accurate. More specifically, the `loaded` field should not
    be displayed because it can neither be accessed nor changed. In order to fix this,
    we can simply extend the `propertynames` function, as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经实现了`getproperty`和`setproperty!`函数，列表就不再准确了。更具体地说，`loaded`字段不应显示，因为它既不能被访问也不能被修改。为了修复这个问题，我们可以简单地扩展`propertynames`函数，如下所示：
- en: '[PRE17]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `propertynames` function just needs to return a tuple of valid symbols.
    After the function is defined, the REPL will only display the valid field names,
    as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`propertynames`函数只需返回一个有效符号的元组。函数定义后，REPL将只显示有效的字段名，如下所示：'
- en: '![](img/7f4e81eb-f9a4-491a-ad08-c14147d91c4d.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7f4e81eb-f9a4-491a-ad08-c14147d91c4d.png)'
- en: In this section, we have learned how to leverage Julia's property interface
    to control both read and write access to any field of an object. It is an essential
    technique to write robust programs.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何利用Julia的属性接口来控制对对象任何字段的读和写访问。这是一个编写健壮程序的基本技术。
- en: While the use of the property interface seems to address most of the requirements
    we set forth earlier, it is not bulletproof.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: For example, there is nothing that prevents the program from calling the `getfield`
    and `setfield!` functions directly on any object. It would not be possible to
    completely hide that from the programmer unless the language is updated to support
    granular field access controls. Such a feature may be available in the future.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will look at some patterns related to limiting the scope of variables
    so that we can minimize the exposure of private variables to the outside world.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Let block patterns
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The recurring theme in this chapter is to learn how to improve and gain more
    control over the visibility and accessibility of data and functions in the public
    API. By enforcing the access of the programming interface, we can guarantee how
    the program is utilized. Additionally, we can focus on testing the interface as
    *advertised*.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Currently, Julia provides little help in encapsulating implementation details
    within a module. While we can use the `export` keyword to expose certain functions
    and variables to the other modules, it is not designed to be an access control
    or data encapsulation feature. You can always *peek* into a module and access
    any variable or function even when they are not exported.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will continue the trend and go over some strategies that
    we can use to limit access to variables or functions in a module. Here, we will
    use a web crawler use case to illustrate the problem and a possible solution.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the web crawler use case
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Suppose that we have to build a web crawler that can be used to index content
    from various websites. The process of doing that involves setting up a list of
    target sites and then kicking off the crawler. Let''s create a module with the
    structure, as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Our programming interface is quite simple. Let''s see how to do this:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '`Target` is a data type that represents the website being crawled. Then, we
    can use the `add_site!` function to add new target sites to the list.'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When ready, we just call the `crawl_sites!` function to visit all sites.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For convenience, the `current_sites` function can be used to review the current
    list of target sites and their crawling status.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, the `reset_crawler!` function can be used to reset the state of the
    web crawler.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s take a look at the data structure now. The `Target` type is used to
    maintain the URL of the target website. It also contains a Boolean variable regarding
    the status and the time it finished crawling. The struct is defined as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In order to keep track of the current target sites, a global variable is used:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To complete the web crawler implementation, we have the following functions
    defined in the module:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To use the web crawler, first, we can add some sites, as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/903d8a28-7903-4c04-a716-2f2929610f1d.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
- en: 'Then, we can just run the crawler and retrieve the results afterward:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/18e6b756-5470-49a7-aa26-0067eb9913cf.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
- en: 'The current implementation is not bad, but it has the following two access-related
    issues:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: The global variable, `sites`, is visible to the outside world, which means that
    anyone can get a handle of the variable and mess it up, for example, by inserting
    a malicious website.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `index_site!` function should be considered a private function and should
    not be included as part of the public API.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we have set the stage, we will demonstrate how to address these problems
    in the next section.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Using closure to hide private variables and functions away
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our goal is to hide the global constant, `sites`, and the helper function, `index_site!`,
    such that they are not visible in the public API. To achieve that, we can utilize
    `let` blocks.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'In the body of the module, we can wrap all of the functions inside a `let`
    block, as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/44aea611-8f04-4119-ba7d-0db6f3e1c93f.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s see what has been changed:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: The `sites` constant has been replaced by a bound variable at the beginning
    of the `let` block. The variables in a `let` block are bound only in the scope
    of the block and are not visible to the outside world.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The functions that need to be exposed to the API are prefixed with the `global`
    keyword. This includes `add_site!`, `crawl_sites!`, `current_sites`, and `reset_crawler!`.
    The `index_site!` function is left as-is so that it is not exposed.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `global` keyword allows us to expose the function names to the global scope
    of the module, which can be exported and made accessible from the public API.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: 'After reloading the module, we can confirm that neither `sites` nor `index_site!`
    are available from the API, as shown in the following output:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dad2113a-1a01-49e0-8e2e-ae5560cdbd6d.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
- en: As you can see, a `let` block is an effective way to control access to global
    variables or functions in a module. We have the ability to encapsulate functions
    or variables that we want to prevent access from outside of the module.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: There may be a performance overhead when wrapping functions within a `let` block.
    You may want to run a performance test before using this pattern in any performance-critical
    section of your code.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: As `let` blocks are quite useful in limiting the scope, we can often use it
    in longer scripts and functions. Next, we will look at how it is used in practice.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Limiting the variable scope for long scripts or functions
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another usage of the let block is to limit the scope of variables in a long
    Julia script or function. In a long script or function, the code could be difficult
    to follow if we declare a variable at the top and use it throughout the body.
    Instead, we can write a series of let blocks, which operate independently with
    their own bound variables. By limiting the bounded variables in smaller blocks,
    we can follow the code more easily.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: 'While writing long script/functions is not a generally recommended practice,
    we can find them occasionally in testing code, which tends to be quite repetitive.
    In test scripts, we may have many test cases that are grouped in the same test
    set. Here is an example from the `GtkUtilities` package:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We have a few observations here from the preceding code:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: The `c` variable is bound to a new `Canvas` object every time.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `win` variable is bound to a new `Window` object having a different title
    every time.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `w`, `h`, `randcol`, and `randnum` variables are local variables that do
    not escape from their respective let blocks.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By using let blocks, it does not matter how long the test script is. Every let
    block maintains its own scope and nothing should leak from one block to the next.
    This kind of programming style immediately provides some comfort to the programmer
    when it comes to the quality of testing code, as each testing unit is independent
    from each other.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will go over some exception handling techniques. Although it is more
    fun doing programming projects, exception handling is not something that we want
    to overlook. So, let's take a look at it next.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Exception handling patterns
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Robust software requires robust error handling practice. The fact is that an
    error can be raised at any time, sometimes, unexpectedly. As a responsible programmer,
    we need to ensure that every path of computation is taken care of, including both
    the *happy paths* and *unhappy paths*. Happy paths refer to program execution
    that runs normally as expected. Unhappy paths refer to an unexpected outcome due
    to error conditions.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will explore several ways about to catch exceptions and
    recover from failures effectively.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Catching and handling exceptions
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A general technique to catch exceptions is to enclose any logic in a try-catch
    block. This is the easiest way to ensure that unexpected errors are handled:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: A common question, however, is where this `try-catch` block should be placed.
    Of course, we could have just wrapped every single line of code but that would
    be impractical. After all, not every line of code would throw an error.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: We do want to be smart about choosing where to catch exceptions. We know that
    adding exception handling increases the code size. Additionally, every line of
    code requires maintenance. Ironically, the less code we write, the less chance
    of introducing bugs. After all, we should not introduce more problems by trying
    to catch problems, right?
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will look at what kind of scenarios we should consider doing error
    handling for.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with various types of exceptions
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most obvious places to wrap a try-catch block are in the code blocks that
    we need to acquire network resources, for example, querying a database or connecting
    to a web server. Whenever the network is involved, there is a much higher chance
    of encountering an issue than doing something locally on the same computer.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: 'It is important to understand what kind of errors can be thrown. Suppose that
    we continue developing the web crawler use case from the previous section. The
    `index_sites!` function is now implemented using the HTTP library as follows:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `HTTP.get` function is used to retrieve the content from the website. The
    code looks pretty innocent but it does not handle any error condition. For example,
    what happens if the site''s URL is wrong or if the site is down? In those cases,
    we would run into a runtime exception, such as the following:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0e573f56-ac55-4738-a2b9-48b9d2a6876c.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
- en: 'So, at a minimum, we should handle `IOError`. It turns out that the HTTP library
    actually does more than that. If the remote site returns any HTTP status code
    in the 400- or 500-series, then it also wraps the error code and raises a `StatusError`
    exception, as follows:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b84bd933-2d60-4863-9bc1-2d15dd167ce2.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
- en: 'So, how do we know for sure what kind of errors can ever be thrown? Well, we
    can always *read the fine manual* or so-called RTFM. From the HTTP package''s
    documentation, we can see that the following exceptions may be thrown when making
    HTTP requests:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '`HTTP.ExceptionRequest.StatusError`'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HTTP.Parsers.ParseError`'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HTTP.IOExtras.IOError`'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Sockets.DNSError`'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In Julia, the try-catch block catches all exceptions regardless of the type
    of exception. So, we should have the ability to handle any other exception even
    when it is unknown to us. Here is an example of a function that handles exceptions
    properly:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We can see from the preceding code that, in the body of the `catch` block,
    we can check the type of exception and handle it appropriately. The `else` part
    of the block ensures that all types of exceptions are caught, whether we know
    about them or not.  Let''s hook up the `crawl_site!` function to this new function:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We can test out the error handling code now:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7489805c-9eba-4bae-ae58-5cec05979d27.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
- en: This works well!
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: So, this is one instance; what other places do we want to inject exception handling
    logic? Let's explore this next.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: Handling exceptions at the top level
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another place where you would normally handle exceptions is at the very top
    level of the program. Why? One reason is that we may want to avoid the program
    from crashing due to an uncaught exception. The top level of the program is the
    very last gate to catch anything, and the program has an option to either recover
    from the failure (such as doing a *soft reset*) or gracefully close all the resources
    and shut down.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: When a computer program finishes execution, it normally returns an exit status
    back to the shell where the program was invoked. In Unix, the usual convention
    is to indicate successful termination with a zero status and unsuccessful termination
    with a nonzero status.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following pseudocode:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We can see from the previous code that, by design, we can exit the program with
    a specific status code for different error conditions so that the calling program
    can handle the exception properly.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will take a look at how to determine where an exception was originally
    raised from a deeply nested execution frame.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: Walking along the stack frames
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Often, an exception is raised from a function but it is not handled in the right
    away. The exception then travels to the parent calling function. If that function
    does not catch the exception either, it again travels to the next parent calling
    function. This process continues until a try-catch block catches the exception.
    At this point, the program's current *stack frame –* an execution context of where
    the code is currently running – handles the exception.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: 'It would be tremendously useful if we can see where the exception was originally
    raised. To do that, let''s first try to understand how to retrieve a stack trace
    that is an array of stack frames. Let''s create a simple set of nested function
    calls such that they throw an error at the end. Consider the following code:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, if we execute the `foo1` function, we should get an error, as follows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/09030407-9dae-422a-9c0b-12dcd16f0e7a.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
- en: As you can see, the stack trace shows the execution sequence in reversed order.
    At the top of the stack trace is the `foo3` function. Because we're doing this
    in the REPL, we do not see a source filename; however, the number 2, as in `REPL[17]:2`,
    indicates that an error was thrown from line 2 of the `foo3` function.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s introduce the `stacktrace` function now. This function is part of the
    `Base` package and it can be used to obtain the current stack trace. As the `stacktrace`
    function returns an array of `StackFrame`, it would be nice if we could create
    a function to display it nicely. We can define a function to print the stack trace,
    as follows:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'As we want to handle exceptions properly, we will now update the `foo1` function
    by wrapping the call to `foo2` with a `try-catch` block. In the `catch` block,
    we will also print the stack trace so that we can further debug the issue:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Let''s run the `foo1` function now:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/943390bd-6cfb-4959-a7e3-14e81b21f1f2.png)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
- en: '*Oops!* What happened to `foo2` and `foo3`? The exception was thrown from `foo3`
    but we can no longer see them in the stack trace. This is because we have caught
    the exception, and from Julia''s perspective, it is already handled and the current
    execution context is in `foo1` already.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to address this issue, there is another function in the `Base` package
    called `catch_backtrace`. It gives us the backtrace of the current exception so
    we know where the exception was originally raised. We just need to update the
    `foo1` function as follows:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Then, if we run `foo1` again, we get the following results, where `foo3` and
    `foo2` are back to the stack trace:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/633eeef5-2738-4fd7-be48-9e538be8fd04.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
- en: Note that the use of `catch_backtrace` must be within the `catch` block. If
    it is called outside of a `catch` block, it would return an empty backtrace.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will look at a different aspect of exception handling – performance
    impact.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the performance impact of exception handling
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is actually a performance overhead to use a try-catch block. In particular,
    if the application is doing something in a tight loop, it would be a bad idea
    to catch exceptions inside the loop. To understand the impact, let's try a simple
    example.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code that simply calculates the sum of the square root
    of every number in an array:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Knowing that `sqrt` may throw `DomainError` for negative numbers, our first
    attempt may be to catch such exceptions inside the loop:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'What would be the performance impact of doing that? Let''s use the `BenchmarkTools`
    package to measure the performance for both functions:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1de1690f-ad25-4112-9674-c6ed3713a7cd.png)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
- en: 'It turns out that just wrapping the code around a try-catch block has made
    the loop 5 times slower! Perhaps that is not a very good deal. So, what should
    we do in this case? Well, we can always proactively check the number before calling
    the `sqrt` function and avoid the problem with negative values. Let''s write a
    new `sum_of_sqrt3` function as follows:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Let''s measure the performance again:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9c0414ee-741b-4e9b-96af-ad9d8d9af8f9.png)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
- en: '*Fantastic!* We have now restored the performance. The moral of the story is
    that we should be smart about using try-catch blocks, especially when performance
    is a concern. If there is any way to avoid a try-catch block, then it would certainly
    be a better option whenever a higher performance is needed.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will explore how to perform retries, a commonly-used strategy for recovering
    from failures.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: Retrying operations
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, exceptions are thrown due to unexpected outages or so-called *hiccups*.
    It is not an uncommon scenario for a system that is highly integrated with other
    systems or services. For example, the trading system in a stock exchange may need
    to publish trade execution data to a messaging system for downstream processing.
    But if the messaging system experiences just a momentary outage, then the operation
    could fail. In that case, the most common approach is to sleep for a while and
    then come back and try again. If the retry fails again, then the operation will
    be retried again later, until the system fully recovers.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: 'Such retry logic is not difficult to write. Here, we will play with an example.
    Suppose that we have a function that fails randomly:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'On a good day, we would see this lovely message:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b0a6a39f-e178-42c1-9184-753bbc6d2f69.png)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
- en: 'On a bad day, we would get this instead:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1752398e-b12d-491d-8251-2b578c666f98.png)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
- en: 'Naively, we can develop a new function that incorporates the retry logic:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This function just calls the `do_something` function. If it encounters an exception,
    it will wait 2 seconds as specified in the `retry_interval` keyword argument and
    try again. It keeps a track of a counter in `retry_count`, and so it will just
    retry up to 3 times by default, as indicated by the `max_retry_count` keyword
    argument:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fe6d01e6-df13-453d-bc4b-076bc15dcba1.png)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
- en: 'Of course, this code is fairly straightforward and easy to write. But we will
    get bored quickly if we do this over and over again for many functions. It turns
    out that Julia comes with a `retry` function that solves this problem nicely.
    We can achieve the exact same functionality with a single line of code:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `retry` function takes a function as the first argument. The `delays` keyword
    argument can be any object that supports the iteration interface. In this case,
    we have provided an array of 3 elements, each containing the number of 2.0\. The
    return value of the `retry` function is an anonymous function that takes any number
    of arguments. Those arguments will be *fed* into the original function that needs
    to be called, in this case, `do_something`. Here is how it looks using the `retry`
    function:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bb0f8e8e-da80-40a7-ada7-e1b06359c05b.png)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
- en: Since the `delays` argument can contain any number, we could utilize a different
    strategy that comes back with a different waiting time. A common usage is that
    we would want to retry quickly (that is, sleep less) in the beginning but slow
    down over time. When connecting to a remote system, it is possible that the remote
    system is just having a short hiccup, or perhaps it is undergoing an extended
    outage. In the latter scenario, it does not make sense to flood the system with
    quick requests as it would be a waste of system resources and get the water muddier
    when it is already in a mess.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, the default value for the `delays` argument is `ExponentialBackOff`,
    which iterates by exponentially increasing the delay time. On a very unlucky day,
    using `ExponentialBackOff` yields the following pattern:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8aa79787-65c4-4daf-acf8-485426df83b0.png)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
- en: 'Let''s pay attention to the wait time between retries. The result should match
    the default setting of `ExponentialBackOff` as seen from its signature:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The keyword argument, `n`, indicates the number of retries, for which we used
    the value of 10 in the preceding code. The first retry comes after 0.05 seconds.
    Then, for every retry, the time of delay grows by a factor of 5 up until it hits
    a maximum of 10 seconds. The growth rate may be jittered by 10%.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: The `retry` function is often overlooked but it is a very convenient and powerful
    way to make the system more robust.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: It is easy to throw an exception when something goes wrong. But that's not the
    only way to handle error conditions. In the next section, we will discuss the
    concepts of exceptions versus normal negative conditions.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: Choosing nothing over exceptions
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Given the powerful features of a try-catch block, it is sometimes tempting to
    handle all negative scenarios with `Exception` types. In practice, we want to
    be very clear about what is truly an exception and what is a normal negative case.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: 'We can turn to the `match` function as an example. The `match` function from
    the `Base` package can be used to match a regular expression against a string.
    If there is a match, then it returns a `RegexMatch` object, which contains the
    captured results. Otherwise, it returns `nothing`. The following example illustrates
    this effect:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e20d6812-ac03-463d-bc3c-f0632ff86b94.png)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
- en: The first `match` function call returned a `RegexMatch` object because it found
    that `google.com` ends with `.com`. The second call could not find any match and
    so it returned `nothing`.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: 'By design, the `match` function does not throw any exception. Why not? One
    reason for this is that the function is frequently used for checking whether a
    string contains another string and then the program decides what to do either
    way. Doing that would require a simple `if` statement; for instance, refer to
    the following code:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'If it were to throw an exception instead, then our code would have to look
    different, as follows:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: As you can see, the code can get very ugly very quickly using a try-catch block.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: When designing a programming interface, we should always think about whether
    an exception is truly an exception or whether it could be just a negative status.
    In the case of the match function, a negative case is effectively represented
    by nothing.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned where to place try-catch blocks in our code. Now
    we should be able to properly catch exceptions and examine the stack frames.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: We have come to understand better how performance may be impacted by the exception-handling
    code. Based on our understanding, we should be able to design and develop more
    robust software.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned about the various patterns and techniques for
    building robust software. While Julia is a great language for quick prototypes
    and research projects, it has all the features to build robust, mission-critical
    systems.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: We began our journey with the idea of encapsulating data with accessor functions,
    which allow us to design a formal API that we can support. We also discussed a
    naming convention that discourages people from accessing the internal state of
    the object.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: We looked at Julia's property interface, which allows us to implement new *meanings*
    whenever the field access dot notation is used. By extending the `getproperty`
    and `setproperty!` functions, we are able to control both read and write access
    to the fields of an object.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: We also learned how to hide specific variables or functions defined in a module.
    This strategy can be utilized whenever we want to have tighter control of the
    visibility of variables and functions of a module.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we wanted to *take exception handling seriously!* We know robust software
    needs to be able to handle all kinds of exceptions. We dived deep into the try-catch
    process and learned how to determine the stack trace properly. We have proved
    that performance can be negatively impacted by the use of a try-catch block, so
    we need to be diligent about where to apply exception handling logic. We also
    learned how to use the standard `retry` function as a recovery strategy.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will go over a few more miscellaneous patterns commonly
    used in the Julia programs.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are the benefits of developing assessor functions?
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What would be an easy way to discourage the use of internal fields of an object?
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which functions may to be extended as part of the property interface?
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we capture the stack trace from a catch block after an exception has
    been caught?
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the best way to avoid the performance impact of a try-catch block for
    a system that requires optimal performance?
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the benefit of using the retry function?
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do we hide away global variables and functions that are used internally
    in a module?
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
