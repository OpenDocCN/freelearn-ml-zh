<html><head></head><body>
		<div id="_idContainer177">
			<h1 id="_idParaDest-249" class="chapter-number"><a id="_idTextAnchor1143"/><st c="0">9</st></h1>
			<h1 id="_idParaDest-250"><a id="_idTextAnchor1144"/><a id="_idTextAnchor1145"/><st c="2">Extracting Features from Relational Data with Featuretools</st></h1>
			<p><st c="60">In previous chapters, we worked with data organized in rows and columns, where the columns are the variables, the rows are the observations, and each observation is independent. </st><st c="239">In this chapter, we will focus on creating features from relational datasets. </st><st c="317">In relational datasets, data is structured across various tables, which can be joined together via unique identifiers. </st><st c="436">These unique identifiers indicate relationships that exist between the </st><span class="No-Break"><st c="507">different tables.</st></span></p>
			<p><st c="524">A classic example of relational data is that held by retail companies. </st><st c="596">One table contains information about customers, such as names and addresses. </st><st c="673">A second table has information about the purchases made by the customers, such as the type and number of items bought per purchase. </st><st c="805">A third table contains information about the customers’ interactions with the company’s website, variables such as session duration, the mobile device used, and pages visited. </st><st c="981">Customers, purchases, and sessions are identified with unique identifiers. </st><st c="1056">These unique identifiers allow us to put these tables together, and in this way, we can get information about customers’ purchases </st><span class="No-Break"><st c="1187">or sessions.</st></span></p>
			<p><st c="1199">If we want to know more about the types of customers we have (that is, customer segmentation) or make predictions about whether they would buy a product, we can create features that aggregate or summarize information across different tables at the customer level. </st><st c="1464">For example, we can create features that capture the maximum amount spent by a customer on a purchase, the number of purchases they have made, the time between sessions, or the average session duration. </st><st c="1667">The number of features we can create and the various ways we can aggregate data across tables are abundant. </st><st c="1775">In this chapter, we will discuss some common ways of creating aggregated views of relational data utilizing the </st><strong class="source-inline"><st c="1887">featuretools</st></strong><st c="1899"> Python library. </st><st c="1916">We will begin by setting up various data tables and their relationships and automatically creating features, and next, we will follow up with more detail on the different features we </st><span class="No-Break"><st c="2099">can create.</st></span></p>
			<p><st c="2110">In this chapter, we will cover the </st><span class="No-Break"><st c="2146">following recipes:</st></span></p>
			<ul>
				<li><st c="2164">Setting up an entity set and creating </st><span class="No-Break"><st c="2203">features automatically</st></span></li>
				<li><st c="2225">Creating features with general and </st><span class="No-Break"><st c="2261">cumulative operations</st></span></li>
				<li><st c="2282">Combining </st><span class="No-Break"><st c="2293">numerical features</st></span></li>
				<li><st c="2311">Extracting features from date </st><span class="No-Break"><st c="2342">and time</st></span></li>
				<li><st c="2350">Extracting features </st><span class="No-Break"><st c="2371">from text</st></span></li>
				<li><st c="2380">Creating features with </st><span class="No-Break"><st c="2404">aggregation primitives</st></span></li>
			</ul>
			<h1 id="_idParaDest-251"><a id="_idTextAnchor1146"/><a id="_idTextAnchor1147"/><st c="2426">Technical requirements</st></h1>
			<p><st c="2449">In this chapter, we will use </st><strong class="source-inline"><st c="2479">pandas</st></strong><st c="2485">, </st><strong class="source-inline"><st c="2487">matplotlib</st></strong><st c="2497">, and </st><strong class="source-inline"><st c="2503">featuretools</st></strong><st c="2515"> open source Python libraries. </st><st c="2546">You can install </st><strong class="source-inline"><st c="2562">featuretools</st></strong> <span class="No-Break"><st c="2574">with </st></span><span class="No-Break"><strong class="source-inline"><st c="2580">pip</st></strong></span><span class="No-Break"><st c="2583">:</st></span></p>
			<pre class="console"><st c="2585">
pip install featuretools</st></pre>			<p><st c="2610">Additionally, you can do so </st><span class="No-Break"><st c="2639">with </st></span><span class="No-Break"><strong class="source-inline"><st c="2644">conda</st></strong></span><span class="No-Break"><st c="2649">:</st></span></p>
			<pre class="console"><st c="2651">
conda install -c conda-forge featuretools</st></pre>			<p><st c="2693">These commands install the basic </st><strong class="source-inline"><st c="2727">featuretools</st></strong><st c="2739"> functionality, but we can install add-ons for </st><a id="_idIndexMarker657"/><st c="2786">creating features with </st><strong class="bold"><st c="2809">natural language processing</st></strong><st c="2836"> (</st><strong class="bold"><st c="2838">NLP</st></strong><st c="2841">) or for using </st><strong class="source-inline"><st c="2857">dask</st></strong><st c="2861"> as the backend instead of </st><strong class="source-inline"><st c="2888">pandas</st></strong><st c="2894">. For more information on how to install </st><strong class="source-inline"><st c="2935">featuretools</st></strong><st c="2947"> add-ons, including </st><strong class="source-inline"><st c="2967">graphviz</st></strong><st c="2975">, check out their documentation </st><span class="No-Break"><st c="3007">here: </st></span><a href="https://docs.featuretools.com/en/v0.16.0/getting_started/install.html"><span class="No-Break"><st c="3013">https://docs.featuretools.com/en/v0.16.0/getting_started/install.html</st></span></a><span class="No-Break"><st c="3082">.</st></span></p>
			<p><st c="3083">We </st><a id="_idIndexMarker658"/><st c="3087">wil</st><a id="_idTextAnchor1148"/><st c="3090">l work with the </st><em class="italic"><st c="3107">Online Retail II</st></em><st c="3123"> dataset from the UCI Machine Learning Repository, which is available at </st><a href="https://archive.ics.uci.edu/ml/datasets/Online+Retail+II"><st c="3196">https://archive.ics.uci.edu/ml/datasets/Online+Retail+II</st></a><st c="3252"> and licensed under a </st><strong class="bold"><st c="3274">Creative Commons Attribution 4.0 International</st></strong><st c="3320"> (</st><strong class="bold"><st c="3322">CC BY 4.0</st></strong><st c="3331">) license: </st><a href="https://creativecommons.org/licenses/by/4.0/legalcode"><st c="3343">https://creativecommons.org/licenses/by/4.0/legalcode</st></a><st c="3396">. The corresponding citation for this data is provided here: </st><em class="italic"><st c="3457">Chen, Daqing</st></em><st c="3469"> (</st><em class="italic"><st c="3471">2019</st></em><st c="3475">). </st><em class="italic"><st c="3479">Online Retail II</st></em><st c="3495">. </st><em class="italic"><st c="3497">UCI Machine Learning </st></em><span class="No-Break"><em class="italic"><st c="3518">Repository</st></em></span><span class="No-Break"><st c="3528"> (</st></span><a href="https://doi.org/10.24432/C5CG6D"><span class="No-Break"><st c="3530">https://doi.org/10.24432/C5CG6D</st></span></a><span class="No-Break"><st c="3561">)</st><a id="_idTextAnchor1149"/><a id="_idTextAnchor1150"/><st c="3563">.</st></span></p>
			<p><st c="3564">I downloaded and modified the data as shown in this </st><span class="No-Break"><st c="3617">notebook: </st></span><a href="https://github.com/PacktPublishing/Python-Feature-engineering-Cookbook-Third-Edition/blob/main/ch09-featuretools/prepare-retail-dataset.ipynb"><span class="No-Break"><st c="3627">https://github.com/PacktPublishing/Python-Feature-engineering-Cookbook-Third-Edition/blob/main/ch09-featuretools/prepare-retail-dataset.ipynb</st></span></a></p>
			<p><st c="3768">You’ll find a copy of the modified dataset in the accompanying GitHub </st><span class="No-Break"><st c="3839">repository: </st></span><a href="https://github.com/PacktPublishing/Python-Feature-engineering-Cookbook-Third-Edition/blob/main/ch09-featuretools/retail.csv"><span class="No-Break"><st c="3851">https://github.com/PacktPublishing/Python-Feature-engineering-Cookbook-Third-Edition/blob/main/ch09-featuretools/retail.csv</st></span></a></p>
			<h1 id="_idParaDest-252"><a id="_idTextAnchor1151"/><st c="3974">Setting up an entity set and creating features automatically</st></h1>
			<p><st c="4035">Relationa</st><a id="_idTextAnchor1152"/><st c="4045">l datasets or databases contain data spread across multiple tables</st><a id="_idTextAnchor1153"/><st c="4112">, and the relationships </st><a id="_idIndexMarker659"/><st c="4136">between tables are dictated by a unique identifier </st><a id="_idIndexMarker660"/><st c="4187">that tells us how we can join those tables. </st><st c="4231">To automate feature creation with </st><strong class="source-inline"><st c="4265">featuretools</st></strong><st c="4277">, we first need to enter the different data tables and establish their relationships within what is called an </st><strong class="bold"><st c="4387">entity set</st></strong><st c="4397">. The entity </st><a id="_idTextAnchor1154"/><st c="4410">set then informs </st><strong class="source-inline"><st c="4427">featuretools</st></strong><st c="4439"> how these tables are connected so that the library can automatically create features based on </st><span class="No-Break"><st c="4534">those relationships.</st></span></p>
			<p><st c="4554">We will w</st><a id="_idTextAnchor1155"/><st c="4564">ork with a dataset containing information about customers, invoices, and products. </st><st c="4648">First, we will set up an entity set highlighting the relationsh</st><a id="_idTextAnchor1156"/><st c="4711">ips between these three items. </st><st c="4743">This entity set will be the starting point for the remaining recipes in this chapter. </st><st c="4829">Next, we will create features automatically by aggregating the data at the customer, invoice, and product levels, utilizing the default parameters </st><span class="No-Break"><st c="4976">from </st></span><span class="No-Break"><strong class="source-inline"><st c="4981">featuretools</st></strong></span><span class="No-Break"><st c="4993">.</st></span></p>
			<p><st c="4994">In this recipe, you will learn how to correctly set up an entity set and extract a bunch of features automatically for each entity. </st><st c="5127">In the upcoming recipes, we will dig deeper into the different types of features that we can create </st><span class="No-Break"><st c="5227">with </st></span><span class="No-Break"><strong class="source-inline"><st c="5232">featuretoo</st><a id="_idTextAnchor1157"/><a id="_idTextAnchor1158"/><st c="5242">ls</st></strong></span><span class="No-Break"><st c="5245">.</st></span></p>
			<h2 id="_idParaDest-253"><a id="_idTextAnchor1159"/><st c="5246">Getting ready</st></h2>
			<p><st c="5260">In this recipe, we will use the </st><em class="italic"><st c="5293">Online Retail II</st></em><st c="5309"> dataset from the UCI Machine Learning Repository. </st><st c="5360">In this table, there are customers, which are businesses that buy in bulk from the retail company. </st><st c="5459">Customers are identified with a </st><strong class="source-inline"><st c="5491">customer_id</st></strong><st c="5502"> unique identifier. </st><st c="5522">Each customer makes one or more purchases, which are flagged by an </st><strong class="source-inline"><st c="5589">invoice</st></strong><st c="5596"> unique identifier, containing the invoice number. </st><st c="5647">In each invoice, there are one or more items that have been bought by the customer. </st><st c="5731">Each item or product sold by the company is also identified with a unique </st><span class="No-Break"><st c="5805">stock code.</st></span></p>
			<p><st c="5816">Thus, the data has the </st><span class="No-Break"><st c="5840">following relation</st><a id="_idTextAnchor1160"/><st c="5858">s:</st></span></p>
			<div>
				<div id="_idContainer165" class="IMG---Figure">
					<img src="image/B22396_09_01.jpg" alt="Figure 9.1 – Diagram showing the relationships in the data"/><st c="5861"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="5960">Figure 9.1 – Diagram showing the relationships in the data</st></p>
			<p><st c="6018">Ea</st><a id="_idTextAnchor1161"/><st c="6021">ch customer made one or more purchases, identified by the invoice number. </st><st c="6096">Each invoice contains one or more items, identifi</st><a id="_idTextAnchor1162"/><st c="6145">ed by the stock code. </st><st c="6168">Each item can be bought by one or more customers and is therefore present in several invoices. </st><st c="6263">With these relationships in mind, let’s proceed to </st><span class="No-Break"><st c="6314">the recip</st><a id="_idTextAnchor1163"/><a id="_idTextAnchor1164"/><st c="6323">e.</st></span></p>
			<h2 id="_idParaDest-254"><a id="_idTextAnchor1165"/><st c="6326">How to do it...</st></h2>
			<p><st c="6342">In this recipe, we will </st><a id="_idIndexMarker661"/><st c="6367">set up an entity set with the data, and then </st><a id="_idIndexMarker662"/><st c="6412">highlight the different relationships in the dataset. </st><st c="6466">Finally, we will create features by aggregating information in the dataset at the customer, invoice, and </st><span class="No-Break"><st c="6571">product levels:</st></span></p>
			<ol>
				<li><st c="6586">Let’s import the </st><span class="No-Break"><st c="6604">required libraries:</st></span><pre class="source-code"><st c="6623">
import pandas as pd
import featuretools as ft
from woodwork.logical_types import Categorical</st></pre></li>				<li><st c="6716">Let’s load the retail dataset described in the </st><em class="italic"><st c="6764">Getting ready</st></em><st c="6777"> section and display its first </st><span class="No-Break"><st c="6808">five rows:</st></span><pre class="source-code"><st c="6818">
df = pd.read_csv(
    «retail.csv», parse_dates=[«invoice_date»])
df.head()</st></pre><p class="list-inset"><st c="6890">In the </st><a id="_idIndexMarker663"/><st c="6898">following screenshot, we see the unique identifiers </st><a id="_idIndexMarker664"/><st c="6950">for customers (</st><strong class="source-inline"><st c="6965">customer_id</st></strong><st c="6977">) and invoices (</st><strong class="source-inline"><st c="6994">invoice</st></strong><st c="7002">), and additional information about the</st><a id="_idTextAnchor1166"/><st c="7042"> items bought in each invoice, s</st><a id="_idTextAnchor1167"/><st c="7074">uch as the item’s code (</st><strong class="source-inline"><st c="7099">stock_code</st></strong><st c="7110">), description, quantity, and unit price, as well as the date of </st><span class="No-Break"><st c="7176">the inv</st><a id="_idTextAnchor1168"/><st c="7183">oice:</st></span></p></li>			</ol>
			<div>
				<div id="_idContainer166" class="IMG---Figure">
					<img src="image/B22396_09_02.jpg" alt="Figure 9.2 – Online Retail II dataset"/><st c="7189"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="7652">Figure 9.2 – Online Retail II dataset</st></p>
			<p class="callout-heading"><st c="7689">Note</st></p>
			<p class="callout"><st c="7694">Use </st><strong class="source-inline"><st c="7699">pandas</st></strong><st c="7705">’ </st><strong class="source-inline"><st c="7708">unique()</st></strong><st c="7716"> function </st><a id="_idIndexMarker665"/><st c="7726">to identify the number of unique items, customers, and invoices – for example, by </st><span class="No-Break"><st c="7808">executing </st></span><span class="No-Break"><strong class="source-inline"><st c="7818">df["customer_id"].nunique()</st></strong></span><span class="No-Break"><st c="7845">.</st></span></p>
			<ol>
				<li value="3"><st c="7846">Let’s initialize an entity set with an arbitrary name, such </st><span class="No-Break"><st c="7907">as </st></span><span class="No-Break"><strong class="source-inline"><st c="7910">data</st></strong></span><span class="No-Break"><st c="7914">:</st></span><pre class="source-code"><st c="7916">
es = ft.EntitySet(id="data")</st></pre></li>				<li><st c="7945">Let’s add a DataFrame to the entity set; we give the DataFrame a name (</st><strong class="source-inline"><st c="8017">data</st></strong><st c="8022">). </st><st c="8026">We need to add a unique identifier for each row, which we call </st><strong class="source-inline"><st c="8089">rows</st></strong><st c="8093">, and since we do not have a unique row identifier in this dataset, we will create it as an additional column by setting </st><strong class="source-inline"><st c="8214">make_index=True</st></strong><st c="8229">. Finally, we indicate that </st><strong class="source-inline"><st c="8257">invoice_date</st></strong><st c="8269"> is of the </st><strong class="source-inline"><st c="8280">datetime</st></strong><st c="8288"> type and </st><strong class="source-inline"><st c="8298">customer_id</st></strong><st c="8309"> should be handled </st><span class="No-Break"><st c="8328">as </st></span><span class="No-Break"><strong class="source-inline"><st c="8331">Categorical</st></strong></span><span class="No-Break"><st c="8342">:</st></span><pre class="source-code"><st c="8344">
es = es.add_dataframe(
    dataframe=df,
    dataframe_name=»data»,
    index="rows",
    make_index=True,
    time_index=»invoice_date»,
    logical_types={ «customer_id»: Categorical},
)</st></pre></li>				<li><st c="8509">Ne</st><a id="_idTextAnchor1169"/><st c="8512">xt, we add </st><a id="_idIndexMarker666"/><st c="8524">the relationship between the original </st><strong class="source-inline"><st c="8562">data</st></strong><st c="8566"> DataFrame </st><a id="_idIndexMarker667"/><st c="8577">and </st><strong class="source-inline"><st c="8581">invoices</st></strong><st c="8589">. To do this, we indicate the original or base DataFram</st><a id="_idTextAnchor1170"/><st c="8644">e, which we called </st><strong class="source-inline"><st c="8664">data</st></strong><st c="8668"> in </st><em class="italic"><st c="8672">step 4</st></em><st c="8678">, we give the new DataFrame a name, </st><strong class="source-inline"><st c="8714">invoices</st></strong><st c="8722">, we add the unique identifier for invoices, and we add the column containing </st><strong class="source-inline"><st c="8800">customer_id</st></strong><st c="8811"> to </st><span class="No-Break"><st c="8815">this DataFrame:</st></span><pre class="source-code"><st c="8830">
es.normalize_dataframe(
    base_dataframe_name=»data»,
    new_dataframe_name=»invoices»,
    index="invoice",
    copy_columns=[«customer_id»],
)</st></pre></li>			</ol>
			<p class="callout-heading"><st c="8962">Note</st></p>
			<p class="callout"><st c="8967">We copy the </st><strong class="source-inline"><st c="8980">customer_id</st></strong><st c="8991"> variable to the </st><strong class="source-inline"><st c="9008">invoices</st></strong><st c="9016"> data because we want to create a subsequent relationship between customers </st><span class="No-Break"><st c="9092">and invoices.</st></span></p>
			<ol>
				<li value="6"><st c="9105">Now, we add a second relationship, which is between customers and invoices. </st><st c="9182">To do this, we indicate the base DataFrame, which we named </st><strong class="source-inline"><st c="9241">invoices</st></strong><st c="9249"> in </st><em class="italic"><st c="9253">step 5</st></em><st c="9259">, then we give the new DataFrame a name, </st><strong class="source-inline"><st c="9300">customers</st></strong><st c="9309">, and add the unique </st><span class="No-Break"><st c="9330">customer identifier:</st></span><pre class="source-code"><st c="9350">
es.normalize_dataframe(
    base_dataframe_name=»invoices»,
    new_dataframe_name=»customers»,
    index=»customer_id»,
</st><a id="_idTextAnchor1171"/><st c="9460">)</st></pre></li>				<li><st c="9461">We can </st><a id="_idIndexMarker668"/><st c="9468">add a third rel</st><a id="_idTextAnchor1172"/><st c="9483">ationship between the original </st><a id="_idIndexMarker669"/><st c="9515">data and </st><span class="No-Break"><st c="9524">the products:</st></span><pre class="source-code"><st c="9537">
es.normalize_dataframe(
    base_dataframe_name=»data»,
    new_dataframe_name=»items»,
    index=»stock_code»,
)</st></pre></li>				<li><st c="9639">Let’s display the information in the </st><span class="No-Break"><st c="9677">entity set:</st></span><pre class="source-code"><st c="9688">
es</st></pre><p class="list-inset"><st c="9691">In the following output, we see that the entity set contains four DataFrames: the original data, the </st><strong class="source-inline"><st c="9793">invoices</st></strong><st c="9801"> DataFrame, the </st><strong class="source-inline"><st c="9817">customers</st></strong><st c="9826"> DataFrame, and the product or </st><strong class="source-inline"><st c="9857">items</st></strong><st c="9862"> DataFrame. </st><st c="9874">The entity also contains the relationships between invoices or items with the original data, as well as between customers </st><span class="No-Break"><st c="9996">and invoices:</st></span></p><pre class="source-code"><strong class="bold"><st c="10009">Entityset: data</st></strong>
<strong class="bold"><st c="10025">  DataFrames:</st></strong>
<strong class="bold"><st c="10037">    data [Rows: 741301, Columns: 8]</st></strong>
<strong class="bold"><st c="10069">    invoices [Rows: 40505, Columns: 3]</st></strong>
<strong class="bold"><st c="10104">    customers [Rows: 5410, Columns: 2]</st></strong>
<strong class="bold"><st c="10139">    items [Rows: 4631, Columns: 2]</st></strong>
<strong class="bold"><st c="10170">  Relationships:</st></strong>
<strong class="bold"><st c="10185">    data.invoice -&gt; invoices.invoice</st></strong>
<strong class="bold"><st c="10218">    invoices.customer_id -&gt; customers.customer_id</st></strong>
<strong class="bold"><st c="10264">    data.stock_code -&gt; items.stock_code</st></strong></pre></li>				<li><st c="10300">Let’s display the </st><span class="No-Break"><strong class="source-inline"><st c="10319">invoices</st></strong></span><span class="No-Break"><st c="10327"> DataFrame:</st></span><pre class="source-code"><st c="10338">
es["invoices"].hea</st><a id="_idTextAnchor1173"/><st c="10357">d()</st></pre><p class="list-inset"><st c="10361">We see in </st><a id="_idIndexMarker670"/><st c="10372">the following output that </st><strong class="source-inline"><st c="10398">featuretools</st></strong><st c="10410"> au</st><a id="_idTextAnchor1174"/><st c="10413">tomatically created a DataFrame containing the invoice’s unique </st><a id="_idIndexMarker671"/><st c="10478">identifier, followed by the customer’s unique identifier and the first date registered for </st><span class="No-Break"><st c="10569">ea</st><a id="_idTextAnchor1175"/><st c="10571">ch invoice:</st></span></p></li>			</ol>
			<div>
				<div id="_idContainer167" class="IMG---Figure">
					<img src="image/B22396_09_03.jpg" alt="Figure 9.3 – DataFrame with information at the invoice level"/><st c="10583"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="10830">Figure 9.3 – DataFrame with information at the invoice level</st></p>
			<ol>
				<li value="10"><st c="10890">Let’s now display the </st><span class="No-Break"><strong class="source-inline"><st c="10913">customers</st></strong></span><span class="No-Break"><st c="10922"> DataFrame:</st></span><pre class="source-code"><st c="10933">
es["customers"].head()</st></pre><p class="list-inset"><st c="10956">We can see in the following output that </st><strong class="source-inline"><st c="10997">featuretools</st></strong><st c="11009"> automatically created a DataFrame containing the customer’s unique identifier, followed by the date of the first invoice for </st><span class="No-Break"><st c="11135">this</st><a id="_idTextAnchor1176"/><st c="11139"> customer:</st></span></p></li>			</ol>
			<div>
				<div id="_idContainer168" class="IMG---Figure">
					<img src="image/B22396_09_04.jpg" alt="Figure 9.4 – DataFrame with information at the customer level"/><st c="11149"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="11362">Figure 9.4 – DataFrame with information at the customer level</st></p>
			<p class="callout-heading"><st c="11423">Note</st></p>
			<p class="callout"><st c="11428">Go ahead and display the DataFrame containing the products by executing </st><strong class="source-inline"><st c="11501">es["items"].head()</st></strong><st c="11519">. You can also evaluate the size of the different DataFrames using </st><strong class="source-inline"><st c="11586">pandas</st></strong><st c="11592">’ </st><strong class="source-inline"><st c="11595">shape</st></strong><st c="11600"> function. </st><st c="11611">You will notice that the number of rows in each DataFrame coincides with the number of unique invoices, customers, </st><span class="No-Break"><st c="11726">and produc</st><a id="_idTextAnchor1177"/><st c="11736">ts.</st></span></p>
			<ol>
				<li value="11"><st c="11740">We can </st><a id="_idIndexMarker672"/><st c="11748">also display the re</st><a id="_idTextAnchor1178"/><st c="11767">lationships between these data </st><a id="_idIndexMarker673"/><st c="11799">tables </st><span class="No-Break"><st c="11806">as follows:</st></span><pre class="source-code"><st c="11817">
es.plot()</st></pre></li>			</ol>
			<p class="callout-heading"><st c="11827">Note</st></p>
			<p class="callout"><a id="_idTextAnchor1179"/><st c="11832">To visualize the data relationships, you need to have </st><strong class="source-inline"><st c="11887">graphviz</st></strong><st c="11895"> installed. </st><st c="11907">If you don’t, follow the </st><a id="_idIndexMarker674"/><st c="11932">instructions in the </st><strong class="source-inline"><st c="11952">featuretools</st></strong><st c="11964"> documentation to install </st><span class="No-Break"><st c="11990">it: </st></span><a href="https://featuretools.alteryx.com/en/stable/install.html#installing-graphviz"><span class="No-Break"><st c="11994">https://featuretools.alteryx.com/en/stable/install.html#installing-graphviz</st></span></a><span class="No-Break"><st c="12069">.</st></span></p>
			<p class="list-inset"><st c="12070">In the following output, we can see the relational datasets and </st><span class="No-Break"><st c="12135">their re</st><a id="_idTextAnchor1180"/><st c="12143">lationships:</st></span></p>
			<div>
				<div id="_idContainer169" class="IMG---Figure">
					<img src="image/B22396_09_05.jpg" alt="Figure 9.5 – Relationships between the tables containing invoices, customers, and products"/><st c="12156"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="12733">Figure 9.5 – Relationships between the tables containing invoices, customers, and products</st></p>
			<p class="list-inset"><st c="12823">Af</st><a id="_idTextAnchor1181"/><st c="12826">ter entering </st><a id="_idIndexMarker675"/><st c="12840">the data and their relationships,</st><a id="_idTextAnchor1182"/><st c="12873"> we can start </st><a id="_idIndexMarker676"/><st c="12887">automatically creating features for each one of our new DataFrames – that is, customers, invoices, and products – using the default parameters </st><span class="No-Break"><st c="13030">from </st></span><span class="No-Break"><strong class="source-inline"><st c="13035">featuretools</st><a id="_idTextAnchor1183"/></strong></span><span class="No-Break"><st c="13047">.</st></span></p>
			<ol>
				<li value="12"><st c="13048">Let’s create </st><a id="_idIndexMarker677"/><st c="13062">features by aggregating the data at the customer level. </st><st c="13118">To do this, we set up the </st><strong class="bold"><st c="13144">deep feature synthesis</st></strong><st c="13166"> (</st><strong class="bold"><st c="13168">dfs</st></strong><st c="13171">) class from </st><strong class="source-inline"><st c="13185">featuretools</st></strong><st c="13197">, indicating </st><strong class="source-inline"><st c="13210">customers</st></strong><st c="13219"> as the target DataFrame. </st><st c="13245">When creating features, we want to ignore the two columns with </st><span class="No-Break"><st c="13308">unique identifiers:</st></span><pre class="source-code"><st c="13327">
feature_matrix, feature_defs = ft.dfs(
    entityset=es,
    target_dataframe_name=»customers»,
    ignore_columns={
        «invoices»:[«invoice»],
        «invoices»:[«customer_id»],
    }
)</st></pre></li>			</ol>
			<p class="callout-heading"><st c="13488">Note</st></p>
			<p class="callout"><st c="13493">The command from </st><em class="italic"><st c="13511">step 12</st></em><st c="13518"> triggered the creation of 114 features with different aggregations of data at the customer level. </st><st c="13617">The </st><strong class="source-inline"><st c="13621">feature_matrix</st></strong><st c="13635"> variable is a DataFrame with the feature values, and </st><strong class="source-inline"><st c="13689">feature_defs</st></strong><st c="13701"> is a list with the names of the new features. </st><st c="13748">Go ahead and execute </st><strong class="source-inline"><st c="13769">feature_defs</st></strong><st c="13781"> or visit our accompanying GitHub repository (</st><a href="https://github.com/PacktPublishing/Python-Feature-Engineering-Cookbook-Third-Edition/blob/main/ch09-featuretools/Recipe1-Setting-up-an-entitity-set.ipynb"><st c="13827">https://github.com/PacktPublishing/Python-Feature-Engineering-Cookbook-Third-Edition/blob/main/ch09-featuretools/Recipe1-Setting-up-an-entitity-set.ipynb</st></a><st c="13981">) to check the names of the created features. </st><st c="14028">You will find more details about these features in the </st><em class="italic"><st c="14083">How it </st></em><span class="No-Break"><em class="italic"><st c="14090">works…</st></em></span><span class="No-Break"><st c="14096"> section.</st></span></p>
			<ol>
				<li value="13"><st c="14105">For reasons </st><a id="_idIndexMarker678"/><st c="14118">of space, we can’t print out all the features </st><a id="_idIndexMarker679"/><st c="14164">in the </st><a id="_idTextAnchor1184"/><st c="14171">book, so instead, let’s display the nam</st><a id="_idTextAnchor1185"/><st c="14210">es of five of the </st><span class="No-Break"><st c="14229">created features:</st></span><pre class="source-code"><st c="14246">
feature_defs[5:10]</st></pre><p class="list-inset"><st c="14265">In the following output, we see 5 of the 114 features created </st><span class="No-Break"><st c="14328">by </st></span><span class="No-Break"><strong class="source-inline"><st c="14331">featuretools</st></strong></span><span class="No-Break"><st c="14343">:</st></span></p><pre class="source-code"><strong class="bold"><st c="14345">[&lt;Feature: MIN(data.price)&gt;,</st></strong>
<strong class="bold"><st c="14373">&lt;Feature: MIN(data.quantity)&gt;,</st></strong>
<strong class="bold"><st c="14403">&lt;Feature: MODE(data.description)&gt;,</st></strong>
<strong class="bold"><st c="14437">&lt;Feature: MODE(data.stock_code)&gt;,</st></strong>
<strong class="bold"><st c="14470">&lt;Feature: NUM_UNIQUE(data.description)&gt;]</st></strong></pre></li>			</ol>
			<p class="callout-heading"><st c="14511">Note</st></p>
			<p class="callout"><st c="14516">The </st><strong class="source-inline"><st c="14521">featuretools</st></strong><st c="14533"> library names the new features with the function used to create them, followed by the DataFrame that was used to perform the aggregation, followed by the aggregated variable name. </st><st c="14714">Thus, </st><strong class="source-inline"><st c="14720">MIN(data.quantity)</st></strong><st c="14738"> is equivalent to </st><strong class="source-inline"><st c="14756">df.groupby(["customer_id"])["quantity"].min()</st></strong><st c="14801">, if you are familiar with </st><strong class="source-inline"><st c="14828">pandas</st></strong><st c="14834">. We will give more details in the </st><em class="italic"><st c="14869">How it </st></em><span class="No-Break"><em class="italic"><st c="14876">works…</st></em></span><span class="No-Break"><st c="14882"> secti</st><a id="_idTextAnchor1186"/><st c="14888">on.</st></span></p>
			<ol>
				<li value="14"><st c="14892">Let’s display the first five rows of the Dat</st><a id="_idTextAnchor1187"/><st c="14937">aFrame containing five of the </st><span class="No-Break"><st c="14968">created features:</st></span><pre class="source-code"><st c="14985">
feature_matrix[feature_matrix.columns[5:10]].head()</st></pre><p class="list-inset"><st c="15037">In the </st><a id="_idIndexMarker680"/><st c="15045">following output, we can see the first five rows </st><a id="_idIndexMarker681"/><st c="15094">containing the values of the </st><a id="_idTextAnchor1188"/><st c="15123">five </st><span class="No-Break"><st c="15128">new features:</st></span></p></li>			</ol>
			<div>
				<div id="_idContainer170" class="IMG---Figure">
					<img src="image/B22396_09_06.jpg" alt="Figure 9.6 – DataFrame with five features created by aggregating the data at the customer level"/><st c="15141"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="15542">Figure 9.6 – DataFrame with five features created by aggregating the data at the customer level</st></p>
			<ol>
				<li value="15"><st c="15637">Similarly, we can create features automatically by aggregating information at the </st><span class="No-Break"><st c="15720">invoice level:</st></span><pre class="source-code"><st c="15734">
feature_matrix, feature_defs = ft.dfs(
    entityset=es,
    target_dataframe_name=»invoices»,
    ignore_columns = {«data»: [«customer_id»]},
    max_depth =</st><a id="_idTextAnchor1189"/><st c="15877"> 1,
)</st></pre></li>				<li><st c="15882">The previous step returns 24 features – let’s display </st><span class="No-Break"><st c="15937">their names:</st></span><pre class="source-code"><st c="15949">
f</st><a id="_idTextAnchor1190"/><st c="15951">eature_defs</st></pre><p class="list-inset"><st c="15962">We can see the names of the features in the </st><span class="No-Break"><st c="16007">following output:</st></span></p><pre class="source-code"><strong class="bold"><st c="16024">[&lt;Feature: customer_id&gt;,</st></strong>
<strong class="bold"><st c="16049">&lt;Feature: COUNT(data)&gt;,</st></strong>
<strong class="bold"><st c="16072">&lt;Feature: MAX(data.price)&gt;,</st></strong>
<strong class="bold"><st c="16099">&lt;Feature: MAX(data.quantity)&gt;,</st></strong>
<strong class="bold"><st c="16129">&lt;Feature: MEAN(data.price)&gt;,</st></strong>
<strong class="bold"><st c="16157">&lt;Feature: MEAN(data.quantity)&gt;,</st></strong>
<strong class="bold"><st c="16188">&lt;Feature: MIN(data.price)&gt;,</st></strong>
<strong class="bold"><st c="16215">&lt;Feature: MIN(data.quantity)&gt;,</st></strong>
<strong class="bold"><st c="16245">&lt;Feature: MODE(data.description)&gt;,</st></strong>
<strong class="bold"><st c="16279">&lt;Feature: MODE(data.stock_code)&gt;,</st></strong>
<strong class="bold"><st c="16312">&lt;Feature: NUM_UNIQUE(data.description)&gt;,</st></strong>
<strong class="bold"><st c="16352">&lt;Feature: NUM_UNIQUE(data.stock_code)&gt;,</st></strong>
<strong class="bold"><st c="16391">&lt;Feature: SKEW(data.price)&gt;,</st></strong>
<strong class="bold"><st c="16419">&lt;Feature: SKEW(data.quantity)&gt;,</st></strong>
<strong class="bold"><st c="16450">&lt;Feature: STD(data.price)&gt;,</st></strong>
<strong class="bold"><st c="16477">&lt;Feature: STD(data.quantity)&gt;,</st></strong>
<strong class="bold"><st c="16507">&lt;Feature: SUM(data.price)&gt;,</st></strong>
<strong class="bold"><st c="16534">&lt;Feature: SUM(data.quantity)&gt;,</st></strong>
<strong class="bold"><st c="16564">&lt;Feature: DAY(first_data_time)&gt;,</st></strong>
<strong class="bold"><st c="16596">&lt;Feature: MONTH(first_data_time)&gt;,</st></strong>
<strong class="bold"><st c="16630">&lt;Feature: WEEKDAY(first_data_time)&gt;,</st></strong>
<strong class="bold"><st c="16666">&lt;Feature: YEAR(first_data_time)&gt;]</st></strong></pre></li>			</ol>
			<p class="callout-heading"><st c="16700">Note</st></p>
			<p class="callout"><st c="16705">Go ahead and display the DataFrame containing the new features by executing </st><strong class="source-inline"><st c="16782">feature_matrix.head()</st></strong><st c="16803"> or check our accompanying GitHub repository for </st><span class="No-Break"><st c="16852">the result.</st></span></p>
			<p><st c="16863">To</st><a id="_idTextAnchor1191"/><st c="16866"> wrap up, by using the code from </st><em class="italic"><st c="16899">step 1</st><a id="_idTextAnchor1192"/><st c="16905">6</st></em><st c="16907"> and changing the target DataFrame name from </st><strong class="source-inline"><st c="16952">invoices</st></strong><st c="16960"> to </st><strong class="source-inline"><st c="16964">items</st></strong><st c="16969">, go ahead and create features automatically at </st><a id="_idTextAnchor1193"/><a id="_idTextAnchor1194"/><st c="17017">the </st><span class="No-Break"><st c="17021">product level.</st></span></p>
			<h2 id="_idParaDest-255"><a id="_idTextAnchor1195"/><st c="17035">How it works...</st></h2>
			<p><st c="17051">In this recipe, we set up an entity set containing the data and the relationships between some of </st><a id="_idIndexMarker682"/><st c="17150">its variables (unique identifiers). </st><st c="17186">After that, we automatically </st><a id="_idIndexMarker683"/><st c="17215">created features by aggregating the information in the dataset for each of the unique identifiers. </st><st c="17314">We used two main classes from </st><strong class="source-inline"><st c="17344">featuretools</st></strong><st c="17356">, </st><strong class="source-inline"><st c="17358">EntitySet</st></strong><st c="17367"> and </st><strong class="source-inline"><st c="17372">dfs</st></strong><st c="17375">, to create the features. </st><st c="17401">Let’s discuss each of these in </st><span class="No-Break"><st c="17432">more detail.</st></span></p>
			<p><st c="17444">The </st><strong class="source-inline"><st c="17449">EntitySet</st></strong><st c="17458"> class stores </st><a id="_idIndexMarker684"/><st c="17472">the data, the logical types of the variables, and the relationships between the variables. </st><st c="17563">The variable types (whether numeric or categorical) are automatically assigned by </st><strong class="source-inline"><st c="17645">featuretools</st></strong><st c="17657">. We can also set up specific variable types when adding a DataFrame to the entity set. </st><st c="17745">In </st><em class="italic"><st c="17748">step 4</st></em><st c="17754">, we added the data to the entity set and set the logical type of </st><strong class="source-inline"><st c="17820">customer_id</st></strong> <span class="No-Break"><st c="17831">to </st></span><span class="No-Break"><strong class="source-inline"><st c="17835">Categorical</st></strong></span><span class="No-Break"><st c="17846">.</st></span></p>
			<p class="callout-heading"><st c="17847">Note</st></p>
			<p class="callout"><st c="17852">To inspect the datatypes inferred by </st><strong class="source-inline"><st c="17890">featuretools</st></strong><st c="17902">, you can execute </st><strong class="source-inline"><st c="17920">es["data"].ww</st></strong><st c="17933">, where </st><strong class="source-inline"><st c="17941">es</st></strong><st c="17943"> is the entity set and </st><strong class="source-inline"><st c="17966">data</st></strong><st c="17970"> is the name of </st><span class="No-Break"><st c="17986">the DataFrame.</st></span></p>
			<p><st c="18000">The </st><strong class="source-inline"><st c="18005">EntitySet</st></strong><st c="18014"> class has the </st><strong class="source-inline"><st c="18029">add_dataframe</st></strong><st c="18042"> method, which we used in </st><em class="italic"><st c="18068">step 4</st></em><st c="18074"> to add a new DataFrame. </st><st c="18099">When using this method, we need to specify the unique identifier, and if there is none, then we need to create one, as we did in </st><em class="italic"><st c="18228">step 4</st></em><st c="18234">, by setting </st><strong class="source-inline"><st c="18247">make_index</st></strong><st c="18257"> to </st><strong class="source-inline"><st c="18261">True</st></strong><st c="18265">. Note that in the </st><strong class="source-inline"><st c="18284">index</st></strong><st c="18289"> parameter from </st><strong class="source-inline"><st c="18305">add_dataframe</st></strong><st c="18318">, we passed the </st><strong class="source-inline"><st c="18334">"rows"</st></strong><st c="18340"> string. </st><st c="18349">With this configuration, </st><strong class="source-inline"><st c="18374">EntitySet</st></strong><st c="18383"> added a </st><strong class="source-inline"><st c="18392">rows</st></strong><st c="18396"> column containing the unique identifier for each row to the DataFrame, which is a new sequence of integers starting </st><span class="No-Break"><st c="18513">at 0.</st></span></p>
			<p class="callout-heading"><st c="18518">Note</st></p>
			<p class="callout"><st c="18523">Instead of using the </st><strong class="source-inline"><st c="18545">add_dataframe</st></strong><st c="18558"> method to add a DataFrame to an entity set, we can add it by executing </st><strong class="source-inline"><st c="18630">es["df_name"]=df</st></strong><st c="18646">, where </st><strong class="source-inline"><st c="18654">"df_name"</st></strong><st c="18663"> is the name we want to give to the DataFrame and </st><strong class="source-inline"><st c="18713">df</st></strong><st c="18715"> is the DataFrame we want </st><span class="No-Break"><st c="18741">to add.</st></span></p>
			<p><st c="18748">The </st><strong class="source-inline"><st c="18753">EntitySet</st></strong><st c="18762"> class has the </st><strong class="source-inline"><st c="18777">normalize_dataframe</st></strong><st c="18796"> method, which is used to create a new DataFrame and relationship from the unique values of an existing column.</st><a id="_idTextAnchor1196"/><st c="18907"> The method takes the name of the DataFrame to which the new DataFrame will be related and </st><a id="_idIndexMarker685"/><st c="18998">a name for the new DataFrame. </st><st c="19028">We</st><a id="_idTextAnchor1197"/><st c="19030"> also need to indicate the </st><a id="_idIndexMarker686"/><st c="19057">unique identifier for the new DataFrame in the </st><strong class="source-inline"><st c="19104">index</st></strong><st c="19109"> parameter. </st><st c="19121">By default, this method creates a new DataFrame containing the unique identifier, followed by a </st><strong class="source-inline"><st c="19217">datetime</st></strong><st c="19225"> column containing the first date each unique identifier was registered. </st><st c="19298">We can add more columns to this DataFrame by using the </st><strong class="source-inline"><st c="19353">copy_columns</st></strong><st c="19365"> parameters, as we did in </st><em class="italic"><st c="19391">step 5</st></em><st c="19397">. Adding more columns to the new DataFrame is useful if we want to follow up with relationships to this new DataFrame, as we did in </st><span class="No-Break"><em class="italic"><st c="19529">step 6</st></em></span><span class="No-Break"><st c="19535">.</st></span></p>
			<p><st c="19536">The </st><strong class="source-inline"><st c="19541">EntitySet</st></strong><st c="19550"> class also has the </st><strong class="source-inline"><st c="19570">plot()</st></strong><st c="19576"> method, which displays existing relationships in the entity set. </st><st c="19642">In </st><span class="No-Break"><em class="italic"><st c="19645">Figure 9</st></em></span><em class="italic"><st c="19653">.5</st></em><st c="19655">, we saw the relationships between our data tables; the </st><strong class="source-inline"><st c="19711">invoices</st></strong><st c="19719"> and </st><strong class="source-inline"><st c="19724">items</st></strong><st c="19729"> (products) tables were related to the original data, whereas the </st><strong class="source-inline"><st c="19795">customers</st></strong><st c="19804"> table was related to the </st><strong class="source-inline"><st c="19830">invoices</st></strong><st c="19838"> table, which was, in turn, related to the </st><span class="No-Break"><st c="19881">original data.</st></span></p>
			<p class="callout-heading"><st c="19895">Note</st></p>
			<p class="callout"><st c="19900">The relationship between the tables dictates how features will be created. </st><st c="19976">The </st><strong class="source-inline"><st c="19980">invoices</st></strong><st c="19988"> and </st><strong class="source-inline"><st c="19993">items</st></strong><st c="19998"> tables are related to the original data. </st><st c="20040">Thus, we can only create features with depth 1. </st><st c="20088">The </st><strong class="source-inline"><st c="20092">customers</st></strong><st c="20101"> table is, on the other hand, related to invoices, which is related to data. </st><st c="20178">Thus, we can create features with depth 2. </st><st c="20221">That means that new features will consist of aggregations from the entire dataset or aggregations for invoices first, which will then be subsequently aggregated for customers. </st><st c="20397">We can regulate the features to create with the </st><strong class="source-inline"><st c="20445">max_depth</st></strong><st c="20454"> parameter </st><span class="No-Break"><st c="20465">in </st></span><span class="No-Break"><strong class="source-inline"><st c="20468">dfs</st></strong></span><span class="No-Break"><st c="20471">.</st></span></p>
			<p><st c="20472">After setting up the data and the relationships, we used </st><strong class="source-inline"><st c="20530">dfs</st></strong><st c="20533"> from </st><strong class="source-inline"><st c="20539">featuretools</st></strong><st c="20551"> to automatically create features. </st><st c="20586">When creating features with </st><strong class="source-inline"><st c="20614">dfs</st></strong><st c="20617">, we need to set the target DataFrame – that is, the data table for which the features should be created. </st><st c="20723">The </st><strong class="source-inline"><st c="20727">dfs</st></strong><st c="20730"> class creates features by </st><em class="italic"><st c="20757">transforming</st></em><st c="20769"> and </st><em class="italic"><st c="20774">aggregating</st></em><st c="20785"> existing variables, through what are called </st><strong class="bold"><st c="20830">transform</st></strong><st c="20839"> and </st><span class="No-Break"><strong class="bold"><st c="20844">aggregate </st><a id="_idTextAnchor1198"/><st c="20854">primitives</st></strong></span><span class="No-Break"><st c="20864">.</st></span></p>
			<p><st c="20865">A transform </st><a id="_idIndexMarker687"/><st c="20878">primitive transforms variables. </st><st c="20910">For example, from datetime variables, using a transform primitive, </st><strong class="source-inline"><st c="20977">dfs</st></strong><st c="20980"> extracts the </st><strong class="source-inline"><st c="20994">month</st></strong><st c="20999">, </st><strong class="source-inline"><st c="21001">year</st></strong><st c="21005">, </st><strong class="source-inline"><st c="21007">day</st></strong><st c="21010">, and </st><span class="No-Break"><strong class="source-inline"><st c="21016">week</st></strong></span><span class="No-Break"><st c="21020"> values</st><a id="_idTextAnchor1199"/><st c="21027">.</st></span></p>
			<p><st c="21028">An aggregate </st><a id="_idIndexMarker688"/><st c="21042">primitive aggregates information for a unique identifier. </st><st c="21100">It uses mathematical operations such as the mean, standard deviation, maximum and minimum values, the sum, and the skew coefficient for numerical variables. </st><st c="21257">For categorical variables, aggregate primitives u</st><a id="_idTextAnchor1200"/><st c="21306">se the mode and the count of</st><a id="_idTextAnchor1201"/><st c="21335"> unique items. </st><st c="21350">For unique identifiers, they count the number </st><span class="No-Break"><st c="21396">of occurrences.</st></span></p>
			<p><st c="21411">With the functionality of transform and aggregate primitives in mind, let’s try to understand the features that we created in this recipe. </st><st c="21551">We used the default parameters of </st><strong class="source-inline"><st c="21585">dfs</st></strong><st c="21588"> to create the </st><span class="No-Break"><st c="21603">default features.</st></span></p>
			<p class="callout-heading"><st c="21620">Note</st></p>
			<p class="callout"><st c="21625">For more details on the default features returned by </st><strong class="source-inline"><st c="21679">featuretools</st></strong><st c="21691">, </st><span class="No-Break"><st c="21693">visit </st></span><a href="https://featuretools.alteryx.com/en/stable/generated/featuretools.dfs.html#featuretools.dfs"><span class="No-Break"><st c="21699">https://featuretools.alteryx.com/en/stable/generated/featuretools.dfs.html#featuretools.dfs</st></span></a><span class="No-Break"><st c="21790">.</st></span></p>
			<p><st c="21791">We first </st><a id="_idIndexMarker689"/><st c="21801">created features for each customer. </st><strong class="source-inline"><st c="21837">featuretools</st></strong><st c="21849"> returned 114 features for each customer. </st><st c="21891">Because the </st><strong class="source-inline"><st c="21903">customers</st></strong><st c="21912"> data is related to the </st><strong class="source-inline"><st c="21936">invoices</st></strong><st c="21944"> data, which is related to the entire dataset, the </st><a id="_idIndexMarker690"/><st c="21995">features were created by aggregating data at two levels. </st><st c="22052">First, the data was aggregated for each customer using the entire dataset. </st><st c="22127">Next, it was aggregated for each invoice first, and then the pre-aggregated data was aggregated again for </st><span class="No-Break"><st c="22233">each customer.</st></span></p>
			<p><st c="22247">The </st><strong class="source-inline"><st c="22252">featuretools</st></strong><st c="22264"> library names the new features with the function used to aggregate the data – for example, </st><strong class="source-inline"><st c="22356">COUNT</st></strong><st c="22361">, </st><strong class="source-inline"><st c="22363">MEAN</st></strong><st c="22367">, </st><strong class="source-inline"><st c="22369">STD</st></strong><st c="22372">, and </st><strong class="source-inline"><st c="22378">SKEW</st></strong><st c="22382">, among others. </st><st c="22398">Next, it uses the data that was used for the aggregation and follows it with the variable that was aggregated. </st><st c="22509">For example, the </st><strong class="source-inline"><st c="22526">MEAN(data.quantity)</st></strong><st c="22545"> feature contains the mean quantity of items bought by the customer calculated from the entire dataset, which is the equivalent of </st><strong class="source-inline"><st c="22676">df.groupby("customer_id"])["quantity"].mean()</st></strong><st c="22721">, if you are familiar with </st><strong class="source-inline"><st c="22748">pandas</st></strong><st c="22754">. On the other hand, the </st><strong class="source-inline"><st c="22779">MEAN(invoices.MEAN(data.quantity))</st></strong><st c="22813"> feature first takes the mean quantity of items for each invoice – that is, </st><strong class="source-inline"><st c="22889">df.groupby("invoice"])["quantity"].mean()</st></strong><st c="22930"> – and from the resulting series, it takes the mean value, considering the invoices for a </st><span class="No-Break"><st c="23020">particular customer.</st></span></p>
			<p><st c="23040">For categorical </st><a id="_idIndexMarker691"/><st c="23057">features, </st><strong class="source-inline"><st c="23067">featuretools</st></strong><st c="23079"> determines the mode and </st><a id="_idIndexMarker692"/><st c="23104">the unique values. </st><st c="23123">For example, from the </st><strong class="source-inline"><st c="23145">description</st></strong><st c="23156"> variable, we’ve got the </st><strong class="source-inline"><st c="23181">NUM_UNIQUE(data.description)</st></strong><st c="23209"> and </st><strong class="source-inline"><st c="23214">MODE(data.descripti</st><a id="_idTextAnchor1202"/><st c="23233">on)</st></strong><st c="23237"> features. </st><st c="23248">The description is just the name of the item. </st><st c="23294">Thus, these features highlight the number of unique item</st><a id="_idTextAnchor1203"/><st c="23350">s the customer bought and the item the customer bought the </st><span class="No-Break"><st c="23410">most times.</st></span></p>
			<p class="callout-heading"><st c="23421">Note something interesting</st></p>
			<p class="callout"><st c="23448">The </st><strong class="source-inline"><st c="23453">NUM_UNIQUE(data.description)</st></strong><st c="23481"> and </st><strong class="source-inline"><st c="23486">MODE(data.description)</st></strong><st c="23508"> variables are numeric after the aggregation of the categorical features. </st><st c="23582">The </st><strong class="source-inline"><st c="23586">featuretools</st></strong><st c="23598"> library creates more features by using numerical aggregations of these newly created variables. </st><st c="23695">In this way, the </st><strong class="source-inline"><st c="23712">MAX(invoices.NUM_UNIQUE(data.description)</st></strong><st c="23753"> feature first finds the number of unique items per invoice and then returns the maximum from those values for a particular customer, considering all the </st><span class="No-Break"><st c="23907">customer’s invoices.</st></span></p>
			<p><st c="23927">From datetime features, </st><strong class="source-inline"><st c="23952">featuretools</st></strong><st c="23964"> extracts date components by default. </st><st c="24002">Remember that the </st><strong class="source-inline"><st c="24020">customers</st></strong><st c="24029"> DataFrame contains the </st><strong class="source-inline"><st c="24053">customer_id</st></strong><st c="24064"> variable and the date of the first invoice for each customer, as we saw in the output of </st><em class="italic"><st c="24154">step 10</st></em><st c="24161">. From this datetime feature, </st><strong class="source-inline"><st c="24191">featuretools</st></strong><st c="24203"> created </st><strong class="source-inline"><st c="24212">DAY(first_invoices_time)</st></strong><st c="24236">, </st><strong class="source-inline"><st c="24238">MONTH(first_invoices_time)</st></strong><st c="24264">, </st><strong class="source-inline"><st c="24266">WEEKDAY(first_invoices_time)</st></strong><st c="24294">, and </st><strong class="source-inline"><st c="24300">YEAR(first_invoices_time)</st></strong><st c="24325"> features containing the different </st><span class="No-Break"><st c="24360">date parts.</st></span></p>
			<p><st c="24371">Finally, </st><strong class="source-inline"><st c="24381">featuretools</st></strong><st c="24393"> also returned the total number of invoices per customer (</st><strong class="source-inline"><st c="24451">COUNT(invoices)</st></strong><st c="24467">) and the total number of row</st><a id="_idTextAnchor1204"/><a id="_idTextAnchor1205"/><st c="24497">s (</st><strong class="source-inline"><st c="24501">COUNT(data)</st></strong><st c="24513">) </st><span class="No-Break"><st c="24516">per customer.</st></span></p>
			<h2 id="_idParaDest-256"><a id="_idTextAnchor1206"/><st c="24529">See also</st></h2>
			<p><st c="24538">For more details into what inspired </st><strong class="source-inline"><st c="24575">featuretools</st></strong><st c="24587">, check the original article </st><em class="italic"><st c="24616">Deep Feature Synthesis: Towards Automating Data Science Endeavors</st></em><st c="24681"> by Kanter and Veeramachaneni </st><span class="No-Break"><st c="24711">at </st></span><a href="https://www.jmaxkanter.com/papers/DSAA_DSM_2015.pdf"><span class="No-Break"><st c="24714">https://www.jmaxkanter.</st><span id="_idTextAnchor1207"/><span id="_idTextAnchor1208"/><st c="24737">com/papers/DSAA_DSM_2015.pdf</st></span></a><span class="No-Break"><st c="24766">.</st></span></p>
			<h1 id="_idParaDest-257"><a id="_idTextAnchor1209"/><st c="24767">Creating features with general and cumulative operations</st></h1>
			<p><st c="24824">The </st><strong class="source-inline"><st c="24829">f</st><a id="_idTextAnchor1210"/><st c="24830">eaturetools</st></strong><st c="24841"> library uses </st><a id="_idIndexMarker693"/><st c="24855">what are called </st><strong class="bold"><st c="24871">transform primitives</st></strong><st c="24891"> to create features. </st><st c="24912">Transform primitives take one or more columns </st><a id="_idIndexMarker694"/><st c="24958">i</st><a id="_idTextAnchor1211"/><st c="24959">n a dataset as input and </st><a id="_idIndexMarker695"/><st c="24984">return one or more columns as output. </st><st c="25022">They are applied to a </st><span class="No-Break"><em class="italic"><st c="25044">single</st></em></span><span class="No-Break"><st c="25050"> DataFrame.</st></span></p>
			<p><a id="_idTextAnchor1212"/><st c="25061">The </st><strong class="source-inline"><st c="25066">featuretools</st></strong><st c="25078"> library divides its transform primitives into various categories de</st><a id="_idTextAnchor1213"/><st c="25146">pending </st><a id="_idIndexMarker696"/><st c="25155">on the type of operation they perform or the type of variable they modify. </st><st c="25230">For example, </st><strong class="bold"><st c="25243">general transform primitives</st></strong><st c="25271"> apply mathematical operations, such as the square root, the sine, and the cosine. </st><strong class="bold"><st c="25354">Cumul</st><a id="_idTextAnchor1214"/><st c="25359">ative transform primitives</st></strong><st c="25386"> create new features by comparing a row’s value to the </st><a id="_idIndexMarker697"/><st c="25441">previous row’s value. </st><st c="25463">For example, the cumulative sum, cumulative mean, and cumulative minimum and maximum values belong to this category, as well as the difference between row v</st><a id="_idTextAnchor1215"/><st c="25619">alues. </st><st c="25627">There is another cumulative transformation that can be applied to datetime variables, which is the </st><strong class="bold"><st c="25726">time since previous</st></strong><st c="25745"> transformation, which determines the time passed between two </st><span class="No-Break"><st c="25807">consecutive timestamps.</st></span></p>
			<p><st c="25830">In this recipe, we will create features using the general and cumulative trans</st><a id="_idTextAnchor1216"/><a id="_idTextAnchor1217"/><st c="25909">form primitives </st><span class="No-Break"><st c="25926">from </st></span><span class="No-Break"><strong class="source-inline"><st c="25931">featuretools</st></strong></span><span class="No-Break"><st c="25943">.</st></span></p>
			<h2 id="_idParaDest-258"><a id="_idTextAnchor1218"/><st c="25944">Getting ready</st></h2>
			<p><st c="25958">Variable transformations such as the square root or the logarithm are useful when we want to change the distribution of a variable, as we saw in </st><a href="B22396_03.xhtml#_idTextAnchor351"><span class="No-Break"><em class="italic"><st c="26104">Chapter 3</st></em></span></a><st c="26113">, </st><em class="italic"><st c="26115">Transforming Numerical Variables</st></em><st c="26147">. Other mathematical derivations such as the sine and cosine help to capture underlying data patterns, as we described in the </st><em class="italic"><st c="26273">Creating periodic features from cyclical variables</st></em><st c="26323"> recipe in </st><a href="B22396_08.xhtml#_idTextAnchor987"><span class="No-Break"><em class="italic"><st c="26334">Chapter 8</st></em></span></a><st c="26343">, </st><em class="italic"><st c="26345">Creating New Features</st></em><st c="26366">. From the transformations described in those chapters, </st><strong class="source-inline"><st c="26422">featuretools</st></strong><st c="26434"> supports the square root and the logarithm transformation and the sine and cosine (but without the normalization between 0 </st><span class="No-Break"><st c="26558">and 2π).</st></span></p>
			<p><st c="26566">With a cumulative transformation, we can, for example, get the total number of items bought per invoice by adding up the item’s quantity on each row at the invoice level. </st><st c="26738">To understand the features that we will create in this recipe, let’s create them with </st><span class="No-Break"><strong class="source-inline"><st c="26824">pandas</st></strong></span><span class="No-Break"><st c="26830"> first:</st></span></p>
			<ol>
				<li><st c="26837">Let’s import </st><strong class="source-inline"><st c="26851">pandas</st></strong> <span class="No-Break"><st c="26857">and </st></span><span class="No-Break"><strong class="source-inline"><st c="26862">numpy</st></strong></span><span class="No-Break"><st c="26867">:</st></span><pre class="source-code"><st c="26869">
import numpy as np
import pandas as pd</st></pre></li>				<li><st c="26908">Let’s load the retail dataset described in the </st><em class="italic"><st c="26956">Technical </st></em><span class="No-Break"><em class="italic"><st c="26966">requirements</st></em></span><span class="No-Break"><st c="26978"> section:</st></span><pre class="source-code"><st c="26987">
df = pd.read_csv(
    «retail.csv», parse_dates=[«invoice_date»])</st></pre></li>				<li><st c="27049">Let’s </st><a id="_idIndexMarker698"/><st c="27056">capture the two numerical variables, </st><strong class="source-inline"><st c="27093">price</st></strong><st c="27098"> and </st><strong class="source-inline"><st c="27103">quantity</st></strong><st c="27111">, in </st><span class="No-Break"><st c="27116">a list:</st></span><pre class="source-code"><st c="27123">
numeric_vars = ["quantity", "price"]</st></pre></li>				<li><st c="27160">Let’s </st><a id="_idIndexMarker699"/><st c="27167">capture the names of the cumulative functions in </st><span class="No-Break"><st c="27216">a list:</st></span><pre class="source-code"><st c="27223">
func = ["cum</st><a id="_idTextAnchor1219"/><st c="27236">sum", "cummax", "diff"]</st></pre></li>				<li><st c="27260">Let’s create a list with new names for the variables that we </st><span class="No-Break"><st c="27322">will create:</st></span><pre class="source-code"><st c="27334">
new_names = [f"{var}_{function}"
    for function in func f</st><a id="_idTextAnchor1220"/><st c="27390">or var in numeric_vars]</st></pre></li>				<li><st c="27414">Let’s create new variables using the cumulative functions from </st><em class="italic"><st c="27478">step 4</st></em><st c="27484">, applied to the variables from </st><em class="italic"><st c="27516">step 3</st></em><st c="27522">, and add them to </st><span class="No-Break"><st c="27540">the DataFrame:</st></span><pre class="source-code"><st c="27554">
df[new_names] = df.groupby(
    "invoice")[numeric_vars].agg(func)</st></pre><p class="list-inset"><st c="27617">The previous step returns the cumulative sum, cumulative maximum value, and the difference between rows, within each invoice. </st><st c="27744">As soon as it encounters a new invoice number, it </st><span class="No-Break"><st c="27794">starts afresh.</st></span></p></li>				<li><st c="27808">Let’s display the original and new features for one </st><span class="No-Break"><st c="27861">particular invoice:</st></span><pre class="source-code"><st c="27880">
df[df["invoice"] == "489434" ][
    numeric_vars + new_names]</st></pre><p class="list-inset"><st c="27938">In the following output, we can see that </st><strong class="source-inline"><st c="27980">quantity_cumsum</st></strong><st c="27995"> is the cumulative sum for the variable quantity and </st><strong class="source-inline"><st c="28048">price_diff</st></strong><st c="28058"> is the price difference row </st><span class="No-Break"><st c="28087">after row:</st></span></p></li>			</ol>
			<div>
				<div id="_idContainer171" class="IMG---Figure">
					<img src="image/B22396_09_07.jpg" alt="Figure 9.7 – DataFrame showing cumulative functions applied to numerical features in a single entity (invoice)"/><st c="28097"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="28371">Figure 9.7 – DataFrame showing cumulative functions applied to numerical features in a single entity (invoice)</st></p>
			<p class="list-inset"><st c="28481">Let’s now </st><a id="_idIndexMarker700"/><st c="28492">apply the sine </st><a id="_idIndexMarker701"/><st c="28507">and cosine transformation to the </st><span class="No-Break"><st c="28540">entire DataFrame.</st></span></p>
			<ol>
				<li value="8"><st c="28557">Let’s create a list with names for the </st><span class="No-Break"><st c="28597">new variables:</st></span><pre class="source-code"><st c="28611">
new_names = [
    f"{var}_{function}"
    for function in ["sin", "cos"]
    for var in numeric_vars]</st></pre></li>				<li><st c="28701">Let’s transform the price and quantity with the sine </st><span class="No-Break"><st c="28755">and cosine:</st></span><pre class="source-code"><st c="28766">
df[new_names] = df[numeric_vars].agg(
    [np.sin, np.cos])</st></pre><p class="list-inset"><st c="28822">The transformation in </st><em class="italic"><st c="28845">step 9</st></em><st c="28851"> was applied to the entire dataset, irrespective of the invoice number, which is fine because it maps from o</st><a id="_idTextAnchor1221"/><st c="28959">ne row to the same row, as opposed to from one row to the next, as with cumulative functions. </st><st c="29054">You can inspect the result by </st><span class="No-Break"><st c="29084">executing </st></span><span class="No-Break"><strong class="source-inline"><st c="29094">df[new_names].head()</st></strong></span><span class="No-Break"><st c="29114">.</st></span></p></li>			</ol>
			<p><st c="29115">Now that we understand the types of features we want to create, let’s au</st><a id="_idTextAnchor1222"/><a id="_idTextAnchor1223"/><st c="29188">tomate the process </st><span class="No-Break"><st c="29208">with </st><a id="_idTextAnchor1224"/></span><span class="No-Break"><strong class="source-inline"><st c="29213">featuretools</st></strong></span><span class="No-Break"><st c="29225">.</st></span></p>
			<h2 id="_idParaDest-259"><a id="_idTextAnchor1225"/><st c="29226">How to do it...</st></h2>
			<p><st c="29242">We </st><a id="_idTextAnchor1226"/><st c="29246">will </st><a id="_idIndexMarker702"/><st c="29251">apply cumulative transformations </st><a id="_idIndexMarker703"/><st c="29284">for each invoice and general transformations to the </st><span class="No-Break"><st c="29336">entire dataset:</st></span></p>
			<ol>
				<li><st c="29351">First, we’ll import </st><strong class="source-inline"><st c="29372">pandas</st></strong><st c="29378">, </st><strong class="source-inline"><st c="29380">featuretools</st></strong><st c="29392">, and the </st><strong class="source-inline"><st c="29402">Categorical</st></strong> <span class="No-Break"><st c="29413">logical type:</st></span><pre class="source-code"><st c="29427">
import pandas as pd
import featuretools as ft
from woodwork.logical_types import Categorical</st></pre></li>				<li><st c="29520">Let’s load the dataset described in the </st><em class="italic"><st c="29561">Technical </st></em><span class="No-Break"><em class="italic"><st c="29571">requirements</st></em></span><span class="No-Break"><st c="29583"> section:</st></span><pre class="source-code"><st c="29592">
df = pd.read_csv(
    «retail.csv», parse_dates=[«invoice_date»])</st></pre></li>				<li><st c="29654">Let’s set up an </st><span class="No-Break"><st c="29671">entity set:</st></span><pre class="source-code"><st c="29682">
es = ft.EntitySet(id="data")</st></pre></li>				<li><st c="29711">Let’s add the DataFrame to the </st><span class="No-Break"><st c="29743">entity set:</st></span><pre class="source-code"><st c="29754">
es = es.add_dataframe(
    dataframe=df,
    dataframe_name=»data»,
    index="rows",
    make_index=True,
    time_index=»invoice_date»,
    logical_types={
        "customer_id": Categorical,
        "invoice": Categorical,
    }
)</st></pre></li>			</ol>
			<p class="callout-heading"><st c="29944">Note</st></p>
			<p class="callout"><st c="29949">By default, </st><strong class="source-inline"><st c="29962">featuretools</st></strong><st c="29974"> only retains categorical, numeric, and Boolean features in the feature matrix that is generated </st><em class="italic"><st c="30071">after</st></em><st c="30076"> creating new features. </st><st c="30100">The type of the </st><strong class="source-inline"><st c="30116">invoice</st></strong><st c="30123"> variable is not accurately inferred, so we need to enforce it as categorical by setting its logical type as we do in </st><em class="italic"><st c="30241">step 4</st></em><st c="30247">, if we want </st><strong class="source-inline"><st c="30260">featuretools</st></strong><st c="30272"> to retain it in the dataset containing the new features. </st><st c="30330">To learn the datatypes inferred by </st><strong class="source-inline"><st c="30365">featuretools</st></strong><st c="30377">, you </st><a id="_idTextAnchor1227"/><st c="30383">can </st><span class="No-Break"><st c="30387">execute </st></span><span class="No-Break"><strong class="source-inline"><st c="30395">es["data"].</st><a id="_idTextAnchor1228"/><st c="30406">ww</st></strong></span><span class="No-Break"><st c="30409">.</st></span></p>
			<ol>
				<li value="5"><st c="30410">Let’s create </st><a id="_idIndexMarker704"/><st c="30424">a new DataFrame with </st><a id="_idIndexMarker705"/><st c="30445">a relationship to the DataFrame from </st><span class="No-Break"><em class="italic"><st c="30482">step 4</st></em></span><span class="No-Break"><st c="30488">:</st></span><pre class="source-code"><st c="30490">
es.normalize_dataframe(
    base_dataframe_name=»data»,
    new_dataframe_name=»invoices»,
    index="invoice",
    copy_columns=[«customer_id»],
)</st></pre></li>			</ol>
			<p class="callout-heading"><st c="30622">Note</st></p>
			<p class="callout"><st c="30627">For more details about </st><em class="italic"><st c="30651">steps 4</st></em><st c="30658"> and </st><em class="italic"><st c="30663">5</st></em><st c="30664">, visit the </st><em class="italic"><st c="30676">Setting up an entity set and creating features </st></em><span class="No-Break"><em class="italic"><st c="30723">automatically</st></em></span><span class="No-Break"><st c="30736"> recipe.</st></span></p>
			<ol>
				<li value="6"><st c="30744">Let’s make a list with the cumulative transformations that we’ll use to </st><span class="No-Break"><st c="30817">create features:</st></span><pre class="source-code"><st c="30833">
cum_primitives = [
    "cum_sum",
    "cum_max",
    "diff",</st><a id="_idTextAnchor1229"/><st c="30882">
    "time_since_previous"]</st></pre></li>			</ol>
			<p class="callout-heading"><st c="30905">Note</st></p>
			<p class="callout"><st c="30910">You can find </st><strong class="source-inline"><st c="30924">featuretools</st></strong><st c="30936">-supported cumulative transformations at this </st><span class="No-Break"><st c="30983">link: </st></span><a href="https://featuretools.alteryx.com/en/stable/api_reference.html#cumulative-transform-primitives"><span class="No-Break"><st c="30989">https://featuretools.alteryx.com/en/stable/api_reference.html#cumulative-transform-primitives</st></span></a></p>
			<ol>
				<li value="7"><st c="31082">Let’s make </st><a id="_idIndexMarker706"/><st c="31094">a list of the general transformations to </st><span class="No-Break"><st c="31135">carry out:</st></span><pre class="source-code"><st c="31145">
general_prim</st><a id="_idTextAnchor1230"/><st c="31158">itives = ["sine", " cosine "]</st></pre></li>			</ol>
			<p class="callout-heading"><st c="31188">Note</st></p>
			<p class="callout"><st c="31193">You can find </st><strong class="source-inline"><st c="31207">featuretools</st></strong><st c="31219">-supported general transformations at this </st><span class="No-Break"><st c="31263">link: </st></span><a href="https://featuretools.alteryx.com/en/stable/api_reference.html#general-transform-primitives"><span class="No-Break"><st c="31269">https://featuretools.alteryx.com/en/stable/api_reference.html#g</st><span id="_idTextAnchor1231"/><st c="31332">eneral-transform-primiti</st><span id="_idTextAnchor1232"/><st c="31357">ves</st></span></a></p>
			<ol>
				<li value="8"><st c="31361">Finally, let’s </st><a id="_idIndexMarker707"/><st c="31377">create the features. </st><st c="31398">We use the </st><strong class="source-inline"><st c="31409">dfs</st></strong><st c="31412"> class, setting the original DataFrame as the target DataFrame – that is, the one whose variables we’ll use as a template for the new features. </st><st c="31556">Note that we pass an empty list to the </st><strong class="source-inline"><st c="31595">agg_primitives</st></strong><st c="31609"> parameter; this is to avoid returning the default aggregation primitives. </st><st c="31684">We pass the general primitives from </st><em class="italic"><st c="31720">step 7</st></em><st c="31726"> to the </st><strong class="source-inline"><st c="31734">trans_primitives</st></strong><st c="31750"> parameter and the cumulative primitives from </st><em class="italic"><st c="31796">step 6</st></em><st c="31802"> to the </st><span class="No-Break"><strong class="source-inline"><st c="31810">groupby_trans_primitives</st></strong></span><span class="No-Break"><st c="31834"> parameter:</st></span><pre class="source-code"><st c="31845">
feature_matrix, feature_defs = ft.dfs(
    entityset=es,
    target_dataframe_name=»data»,
    agg_primitives=[],
    trans_primitives=general_primitives,
    groupby_trans_primitives = cum_primitives,
    ignore_dataframes = [«invoices»],
)</st></pre></li>			</ol>
			<p class="callout-heading"><st c="32063">Note</st></p>
			<p class="callout"><em class="italic"><st c="32068">Step 8</st></em><st c="32075"> triggers the creation of features, which may take some time depending on how big the data is, how many aggregation levels it has, and the number of features to create. </st><st c="32244">You can check out the output features </st><em class="italic"><st c="32282">before</st></em><st c="32288"> creating them, by setting the </st><strong class="source-inline"><st c="32319">features_only</st></strong><st c="32332"> parameter to </st><strong class="source-inline"><st c="32346">True</st></strong><st c="32350">. This will return just the feature names; you can check them out, make sure they show what you need, and only then trigger the feature synthesis by setting that parameter back </st><span class="No-Break"><st c="32527">to </st></span><span class="No-Break"><strong class="source-inline"><st c="32530">False</st></strong></span><span class="No-Break"><st c="32535">.</st></span></p>
			<ol>
				<li value="9"><st c="32536">Let’s now </st><a id="_idIndexMarker708"/><st c="32547">display the names </st><a id="_idTextAnchor1233"/><a id="_idIndexMarker709"/><st c="32565">of the </st><span class="No-Break"><st c="32572">created features:</st></span><pre class="source-code"><st c="32589">
fea</st><a id="_idTextAnchor1234"/><st c="32593">ture_defs</st></pre><p class="list-inset"><st c="32603">In the following output, we see the names of the features that we created, including the sine and cosine of the price and quantity, and the cumulative transformations of these variables after grouping them by </st><span class="No-Break"><st c="32813">invoice number:</st></span></p><pre class="source-code"><strong class="bold"><st c="32828">[&lt;Feature: customer_id&gt;,</st></strong>
<strong class="bold"><st c="32853">&lt;Feature: invoice&gt;,</st></strong>
<strong class="bold"><st c="32872">&lt;Feature: stock_code&gt;,</st></strong>
<strong class="bold"><st c="32894">&lt;Feature: description&gt;,</st></strong>
<strong class="bold"><st c="32917">&lt;Feature: quantity&gt;,</st></strong>
<strong class="bold"><st c="32937">&lt;Feature: price&gt;,</st></strong>
<strong class="bold"><st c="32954">&lt;Feature: COSINE(price)&gt;,</st></strong>
<strong class="bold"><st c="32979">&lt;Feature: COSINE(quantity)&gt;,</st></strong>
<strong class="bold"><st c="33007">&lt;Feature: SINE(price)&gt;,</st></strong>
<strong class="bold"><st c="33030">&lt;Feature: SINE(quantity)&gt;,</st></strong>
<strong class="bold"><st c="33056">&lt;Feature: CUM_MAX(price) by invoice&gt;,</st></strong>
<strong class="bold"><st c="33093">&lt;Feature: CUM_MAX(quantity) by invoice&gt;,</st></strong>
<strong class="bold"><st c="33133">&lt;Feature: CUM_SUM(price) by invoice&gt;,</st></strong>
<strong class="bold"><st c="33170">&lt;Feature: CUM_SUM(quantity) by invoice&gt;,</st></strong>
<strong class="bold"><st c="33210">&lt;Feature: DIFF(price) by invoice&gt;,</st></strong>
<strong class="bold"><st c="33244">&lt;Feature: DIFF(quantity) by invoice&gt;,</st></strong>
<strong class="bold"><st c="33281">&lt;Feature: TIME_SINCE_PREVIOUS(invoice_date) by invoice&gt;]</st></strong></pre></li>			</ol>
			<p class="callout-heading"><st c="33338">Note</st></p>
			<p class="callout"><st c="33343">The sine </st><a id="_idIndexMarker710"/><st c="33353">and cosine transformation of price and quantity will probably </st><a id="_idIndexMarker711"/><st c="33415">not add much value because these are not cyclical features. </st><st c="33475">I kept these transformations in the recipe to show you how to apply transformation primitives in general, if you ever </st><span class="No-Break"><st c="33593">need them.</st></span></p>
			<p class="list-inset"><st c="33603">As you </st><a id="_idIndexMarker712"/><st c="33611">can see from the </st><a id="_idIndexMarker713"/><st c="33628">previous list, the new features were appended as new colum</st><a id="_idTextAnchor1235"/><st c="33686">ns to the original DataFrame. </st><st c="33717">You can display the fin</st><a id="_idTextAnchor1236"/><st c="33740">al DataFrame by </st><span class="No-Break"><st c="33757">executing </st></span><span class="No-Break"><strong class="source-inline"><st c="33767">feature_matrix.head()</st></strong></span><span class="No-Break"><st c="33788">:</st></span></p>
			<div>
				<div id="_idContainer172" class="IMG---Figure">
					<img src="image/B22396_09_08.jpg" alt="Figure 9.8 – DataFrame resulting from the deep feature synthesis, containing the ﻿original variables and the new features"/><st c="33790"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="34802">Figure 9.8 – DataFrame resulting from the deep feature synthesis, containing the </st><a id="_idTextAnchor1237"/><st c="34883">original variables and the new features</st></p>
			<p><st c="34922">For more details about the cr</st><a id="_idTextAnchor1238"/><a id="_idTextAnchor1239"/><st c="34952">eated features, check the </st><em class="italic"><st c="34979">How it </st></em><span class="No-Break"><em class="italic"><st c="34986">works…</st></em></span><span class="No-Break"><st c="34992"> section.</st></span></p>
			<h2 id="_idParaDest-260"><a id="_idTextAnchor1240"/><st c="35001">How it works...</st></h2>
			<p><st c="35017">To create </st><a id="_idIndexMarker714"/><st c="35028">features using general and </st><a id="_idIndexMarker715"/><st c="35055">cumulative transformations with </st><strong class="source-inline"><st c="35087">featuretools</st></strong><st c="35099">, we first need to set up an entity set with the data and define the relationships between its variables. </st><st c="35205">We described how to set up an entity set in the </st><em class="italic"><st c="35253">Setting up an entity set and creating features </st></em><span class="No-Break"><em class="italic"><st c="35300">automatically</st></em></span><span class="No-Break"><st c="35313"> recipe.</st></span></p>
			<p><st c="35321">To apply cumulative and general transforms, we used the </st><strong class="source-inline"><st c="35378">dfs</st></strong><st c="35381"> class from </st><strong class="source-inline"><st c="35393">featuretools</st></strong><st c="35405">. General transformations are applied to the entire DataFrame without grouping by a specific variable. </st><st c="35508">To perform general transformations, we passed a list of strings with the transformation names to t</st><a id="_idTextAnchor1241"/><st c="35606">he </st><strong class="source-inline"><st c="35610">trans_primitives</st></strong><st c="35626"> parameter </st><span class="No-Break"><st c="35637">fr</st><a id="_idTextAnchor1242"/><st c="35639">om </st></span><span class="No-Break"><strong class="source-inline"><st c="35643">dfs</st></strong></span><span class="No-Break"><st c="35646">.</st></span></p>
			<p><st c="35647">We applied cumulative transformation after grouping by </st><strong class="source-inline"><st c="35703">invoice</st></strong><st c="35710">. To do this, we passed a list of strings with the names of the cumulative transformation to the </st><strong class="source-inline"><st c="35807">groupby_trans_primitives</st></strong><st c="35831"> parameter from </st><strong class="source-inline"><st c="35847">dfs</st></strong><st c="35850">. The </st><strong class="source-inline"><st c="35856">featuretools</st></strong><st c="35868"> library knows it should group by invoice because we established this unique identifier by using the </st><strong class="source-inline"><st c="35969">normalize_dataframe</st></strong><st c="35988"> method from </st><strong class="source-inline"><st c="36001">EntitySet</st></strong><st c="36010"> in </st><span class="No-Break"><em class="italic"><st c="36014">step 5</st></em></span><span class="No-Break"><st c="36020">.</st></span></p>
			<p><st c="36021">Finally, we did not want features created from the variables in the </st><strong class="source-inline"><st c="36090">invoices</st></strong><st c="36098"> DataFrame; thus, we set </st><strong class="source-inline"><st c="36123">dfs</st></strong><st c="36126"> to ignore this DataFrame by setting </st><strong class="source-inline"><st c="36163">ignore_dataframes = ["</st></strong><span class="No-Break"><strong class="source-inline"><st c="36185">invoices"]</st></strong></span><span class="No-Break"><st c="36196">.</st></span></p>
			<p><st c="36197">The </st><strong class="source-inline"><st c="36202">dfs</st></strong><st c="36205"> class returned two variables, the DataFrame with the original and new features, and the name of the features in a list. </st><st c="36326">The new features are named with the operations </st><a id="_idIndexMarker716"/><st c="36373">applied to create them, such as </st><strong class="source-inline"><st c="36405">SINE</st></strong><st c="36409">, </st><strong class="source-inline"><st c="36411">COSINE</st></strong><st c="36417">, </st><strong class="source-inline"><st c="36419">CUM_MAX</st></strong><st c="36426">, or </st><strong class="source-inline"><st c="36431">DIFF</st></strong><st c="36435">, followed by the variable to which the </st><a id="_idIndexMarker717"/><st c="36475">transformation was applied and, when corresponding, the variable that was used </st><span class="No-Break"><st c="36554">for grouping.</st></span></p>
			<p><st c="36567">Note that </st><strong class="source-inline"><st c="36578">featuretools</st></strong><st c="36590"> automatically recognizes and selects the variables over which the transformations should be applied. </st><st c="36692">The sine, cosine, cumulative sum, maximum, and difference were applied to numerical variables, whereas the </st><strong class="source-inline"><st c="36799">time_since_previous</st></strong> <a id="_idTextAnchor1243"/><a id="_idTextAnchor1244"/><st c="36818">transformation was applied to the </st><span class="No-Break"><st c="36853">datetime variable.</st></span></p>
			<h1 id="_idParaDest-261"><a id="_idTextAnchor1245"/><st c="36871">Combining numerical features</st></h1>
			<p><st c="36900">In </st><a href="B22396_08.xhtml#_idTextAnchor987"><span class="No-Break"><em class="italic"><st c="36904">Chapter 8</st></em></span></a><st c="36913">, </st><em class="italic"><st c="36915">Creating New Features</st></em><st c="36936">, we saw th</st><a id="_idTextAnchor1246"/><st c="36947">at we can create new features by combining </st><a id="_idIndexMarker718"/><st c="36991">variables with mathematical operations. </st><st c="37031">The </st><strong class="source-inline"><st c="37035">featuretools</st></strong><st c="37047"> library supports several operations for combining variables, including addition, division, modulo, and multiplication. </st><st c="37167">In this recipe, we will l</st><a id="_idTextAnchor1247"/><a id="_idTextAnchor1248"/><st c="37192">earn how to combine these features </st><span class="No-Break"><st c="37228">with </st></span><span class="No-Break"><strong class="source-inline"><st c="37233">featuretools</st></strong></span><span class="No-Break"><st c="37245">.</st></span></p>
			<h2 id="_idParaDest-262"><a id="_idTextAnchor1249"/><st c="37246">How to do it...</st></h2>
			<p><st c="37262">Let’s begin by importing the libraries and getting the </st><span class="No-Break"><st c="37318">dataset ready:</st></span></p>
			<ol>
				<li><st c="37332">First, we’ll import </st><strong class="source-inline"><st c="37353">pandas</st></strong><st c="37359">, </st><strong class="source-inline"><st c="37361">featuretools</st></strong><st c="37373">, and the </st><strong class="source-inline"><st c="37383">Categorical</st></strong> <span class="No-Break"><st c="37394">logical type:</st></span><pre class="source-code"><st c="37408">
import pandas as pd
import featuretools as ft
from</st><a id="_idTextAnchor1250"/><st c="37459"> woodwork.logical_types import Categorical</st></pre></li>				<li><st c="37501">Let’s load the dataset that described in the </st><em class="italic"><st c="37547">Technical </st></em><span class="No-Break"><em class="italic"><st c="37557">requirements</st></em></span><span class="No-Break"><st c="37569"> section:</st></span><pre class="source-code"><st c="37578">
df = pd.read_csv(
    «retail.csv», parse_dates=[«invoice_date»])</st></pre></li>				<li><st c="37640">Let’s set up an </st><span class="No-Break"><st c="37657">entity set:</st></span><pre class="source-code"><st c="37668">
es = ft.EntitySet(id="data")</st></pre></li>				<li><st c="37697">Let’s add </st><a id="_idIndexMarker719"/><st c="37708">the DataFrame to the </st><span class="No-Break"><st c="37729">entity set:</st></span><pre class="source-code"><st c="37740">
es = es.add_dataframe(
    dataframe=df,
    dataframe_name=»data»,
    index="rows",
    make_index=True,
    time_index=»invoice_date»,
    logical_types={«customer_id»: Categorical},
)</st></pre></li>				<li><st c="37904">Let’s create a new DataFrame with a relationship to the DataFrame from </st><span class="No-Break"><em class="italic"><st c="37976">step 4</st></em></span><span class="No-Break"><st c="37982">:</st></span><pre class="source-code"><st c="37984">
es.normalize_dataframe(
    base_dataframe_name=»data»,
    new_dataframe_name=»invoices»,
    index="invoice",
    copy_columns=[«customer_id»],
)</st></pre></li>			</ol>
			<p class="callout-heading"><st c="38116">Note</st></p>
			<p class="callout"><st c="38121">For more details about </st><em class="italic"><st c="38145">steps 4</st></em><st c="38152"> and </st><em class="italic"><st c="38157">5</st></em><st c="38158">, visit the </st><em class="italic"><st c="38170">Setting up an entity set and creating features </st></em><span class="No-Break"><em class="italic"><st c="38217">automatically</st></em></span><span class="No-Break"><st c="38230"> recipe.</st></span></p>
			<ol>
				<li value="6"><st c="38238">We will multiply the </st><a id="_idTextAnchor1251"/><strong class="source-inline"><st c="38260">quantity</st></strong><st c="38268"> and </st><strong class="source-inline"><st c="38273">price</st></strong><st c="38278"> variables, which reflect the number of items bought and the unit price, respectively, to obtain the total </st><span class="No-Break"><st c="38385">amount paid:</st></span><pre class="source-code"><st c="38397">
feature_matrix, feature_defs = ft.dfs(
    entityset=es,
    target_dataframe_name=»data»,
    agg_primitives=[],
    trans_primitives=[«multiply_numeric»],
    primitive_options={
        («multiply_numeric»): {
            ‹include_columns›: {
                'data': ["quantity", "price"]
            }
        }
    },
    ignore_dataframes=[«invoices»],
)</st></pre></li>			</ol>
			<p class="callout-heading"><st c="38674">Note</st></p>
			<p class="callout"><st c="38679">We set </st><strong class="source-inline"><st c="38687">agg_primitives</st></strong><st c="38701"> to an empty list to avoid the creation of </st><span class="No-Break"><st c="38744">default primitives.</st></span></p>
			<ol>
				<li value="7"><st c="38763">Let’s now </st><a id="_idIndexMarker720"/><st c="38774">display the name of the </st><span class="No-Break"><st c="38798">new features:</st></span><pre class="source-code"><st c="38811">
feature_defs</st></pre><p class="list-inset"><st c="38824">In the following output, we see the feature names, the last one of which corresponds to the combination of the </st><strong class="source-inline"><st c="38936">price</st></strong><st c="38941"> and </st><span class="No-Break"><strong class="source-inline"><st c="38946">quantity</st></strong></span><span class="No-Break"><st c="38954"> variables:</st></span></p><pre class="source-code"><strong class="bold"><st c="38965">[&lt;Feature: customer_id&gt;,</st></strong>
<strong class="bold"><st c="38990">&lt;Feature: stock_code&gt;,</st></strong>
<strong class="bold"><st c="39012">&lt;Feature: description&gt;,</st></strong>
<strong class="bold"><st c="39035">&lt;Feature: quantity&gt;,</st></strong>
<strong class="bold"><st c="39055">&lt;Feature: price&gt;,</st></strong>
<strong class="bold"><st c="39072">&lt;Feature: price * quantity&gt;]</st></strong></pre></li>				<li><st c="39101">To finish off, let’s inspect the new Da</st><a id="_idTextAnchor1252"/><st c="39141">taFrame created in </st><span class="No-Break"><em class="italic"><st c="39161">step 6</st></em></span><span class="No-Break"><st c="39167">:</st></span><pre class="source-code"><st c="39169">
feature_matrix.head()</st></pre><p class="list-inset"><st c="39191">In the </st><a id="_idIndexMarker721"/><st c="39199">following output, we can see that the new featu</st><a id="_idTextAnchor1253"/><st c="39246">re was appended to the right of the </st><span class="No-Break"><st c="39283">original DataFrame:</st></span></p></li>			</ol>
			<div>
				<div id="_idContainer173" class="IMG---Figure">
					<img src="image/B22396_09_09.jpg" alt="Figure 9.9 – DataFrame with the new feature resulting from the product of price with quantity"/><st c="39302"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="39658">Figure 9.9 – DataFrame with the new feature resulting from the product of price with quantity</st></p>
			<p><st c="39751">Combining features with </st><strong class="source-inline"><st c="39776">featuretools</st></strong><st c="39788"> may seem like a lot of work compared to the </st><strong class="source-inline"><st c="39833">df["price"].mul(df["quantity"])</st></strong> <strong class="source-inline"><st c="39864">pandas</st></strong><st c="39871"> functionality. </st><st c="39887">The real power comes in when we create new features in this way and follow it up with aggregations at the invoice or customer level. </st><st c="40020">We will discuss aggregation functions in th</st><a id="_idTextAnchor1254"/><a id="_idTextAnchor1255"/><st c="40063">e </st><em class="italic"><st c="40066">Creating features with aggregation </st></em><span class="No-Break"><em class="italic"><st c="40101">primitives</st></em></span><span class="No-Break"><st c="40111"> recipe.</st></span></p>
			<h2 id="_idParaDest-263"><a id="_idTextAnchor1256"/><st c="40119">How it works...</st></h2>
			<p><st c="40135">To multiply features, we used the </st><strong class="source-inline"><st c="40170">MultiplyNumeric</st></strong><st c="40185"> primitive from </st><strong class="source-inline"><st c="40201">featuretools</st></strong><st c="40213">, which can be accessed from </st><strong class="source-inline"><st c="40242">dfs</st></strong><st c="40245"> using the </st><strong class="source-inline"><st c="40256">multiply_numeric</st></strong><st c="40272"> string. </st><st c="40281">We passed the former string to the </st><strong class="source-inline"><st c="40316">trans_primitive</st></strong> <a id="_idTextAnchor1257"/><st c="40331">parameter and then used the </st><strong class="source-inline"><st c="40360">primitive_options</st></strong><st c="40377"> parameter to specify which variables to multiply. </st><st c="40428">Note that in addition, we passed an empty list to the </st><strong class="source-inline"><st c="40482">agg_primitives</st></strong><st c="40496"> parameter to avoid returning the default aggregation primitives, and we ignored the features coming from the </st><span class="No-Break"><strong class="source-inline"><st c="40606">invoices</st></strong></span><span class="No-Break"><st c="40614"> DataFrame.</st></span></p>
			<p><st c="40625">To check out other functions that allow you to combine variables, visit </st><a href="https://featuretools.alteryx.com/en/stable/api_reference.html#binary-transform-primitives"><st c="40698">https://featuretools.alteryx.com/en/stable/api_reference.html#binary-transform-primitives</st></a><st c="40787">. At the time of writing, I noticed that </st><strong class="source-inline"><st c="40828">MultiplyNumeric</st></strong><st c="40843"> and </st><strong class="source-inline"><st c="40848">DivideNumeric</st></strong><st c="40861"> are not in the documentation. </st><st c="40892">You can always double-check which functions are supported by inspecting the source code: </st><a href="https://github.com/alteryx/featuretools/tree/main/featuretools/primitives/standard/transform/binary"><st c="40981">https://github.com/alteryx/featuretools/tree/main/featuretools/primitives/standard/transform/binary</st></a><st c="41080">. You can </st><a id="_idIndexMarker722"/><st c="41090">also check out which operations you can perform on your data by running the following command after you set up the entity set and its relationships: </st><strong class="source-inline"><st c="41239">ft.get_valid_primitives(es, target_dataframe_name="data", max_dep</st><a id="_idTextAnchor1258"/><a id="_idTextAnchor1259"/><st c="41304">th=2)</st></strong><st c="41310">. Here, </st><strong class="source-inline"><st c="41318">es</st></strong><st c="41320"> is the entity set resulting from </st><span class="No-Break"><em class="italic"><st c="41354">step 5</st></em></span><span class="No-Break"><st c="41360">.</st></span></p>
			<h1 id="_idParaDest-264"><a id="_idTextAnchor1260"/><st c="41361">Extracting features from date and time</st></h1>
			<p><st c="41400">In </st><a href="B22396_06.xhtml#_idTextAnchor748"><span class="No-Break"><em class="italic"><st c="41404">Chapter 6</st></em></span></a><st c="41413">, </st><em class="italic"><st c="41415">Extracting Features from Date and Time</st></em><em class="italic"><st c="41453"> Variables</st></em><st c="41463">, we discussed how we</st><a id="_idTextAnchor1261"/><st c="41484"> can enrich our </st><a id="_idIndexMarker723"/><st c="41500">datasets by extracting features from the date and time parts of datetime variables, such as the year, the month, the day of the week, the hour, and much more. </st><st c="41659">We can extract those features automatically </st><span class="No-Break"><st c="41703">u</st><a id="_idTextAnchor1262"/><st c="41704">tilizing </st></span><span class="No-Break"><strong class="source-inline"><st c="41713">featuretools</st></strong></span><span class="No-Break"><st c="41725">.</st></span></p>
			<p><st c="41726">The </st><strong class="source-inline"><st c="41731">featuretools</st></strong><st c="41743"> library supports the creation of various features from datetime variables </st><a id="_idIndexMarker724"/><st c="41818">using its </st><strong class="bold"><st c="41828">datetime transform primitives</st></strong><st c="41857">. These primitives include common variables such as year, month, and day, and other features such as </st><em class="italic"><st c="41958">is it lunch time</st></em><st c="41974"> or </st><em class="italic"><st c="41978">is it weekday</st></em><st c="41991">. In addition, we can extract features indicating if the date was a federal or bank holiday (as they call it in the UK) or features that determine the distance in time to a certain date. </st><st c="42178">For a retail company, the proximity to dates such as Boxing Day, Black Fridays, or Christmas normally signals an increase in sales, and if they are forecasting demand, these will make </st><span class="No-Break"><st c="42362">useful variables.</st></span></p>
			<p class="callout-heading"><st c="42379">Note</st></p>
			<p class="callout"><st c="42384">For more details on the features that can be created from datetime variables, </st><span class="No-Break"><st c="42463">visit </st></span><a href="https://featuretools.alteryx.com/en/stable/api_reference.html#datetime-transform-primitives"><span class="No-Break"><st c="42469">https://featuretools.alteryx.com/en/stable/api_reference.html#datetime-transform-primitives</st></span></a><span class="No-Break"><st c="42560">.</st></span></p>
			<p><st c="42561">In this recipe, we will automatically create mul</st><a id="_idTextAnchor1263"/><a id="_idTextAnchor1264"/><st c="42610">tiple features from a datetime variable </st><span class="No-Break"><st c="42651">with </st></span><span class="No-Break"><strong class="source-inline"><st c="42656">featuretools</st></strong></span><span class="No-Break"><st c="42668">.</st></span></p>
			<h2 id="_idParaDest-265"><a id="_idTextAnchor1265"/><st c="42669">How to do it...</st></h2>
			<p><st c="42685">Let’s begin </st><a id="_idIndexMarker725"/><st c="42698">by importing the libraries and getting the </st><span class="No-Break"><st c="42741">dataset ready:</st></span></p>
			<ol>
				<li><st c="42755">First, we’ll import </st><strong class="source-inline"><st c="42776">pandas</st></strong><st c="42782">, </st><strong class="source-inline"><st c="42784">featuretools</st></strong><st c="42796">, and some special </st><span class="No-Break"><st c="42815">datetime primitives:</st></span><pre class="source-code"><st c="42835">
import pandas as pd
import featuretools as ft
from featuretools.primitives import (
    IsFederalHoliday, DistanceToHoliday)
from woodwork.logical_types import Categorical</st></pre></li>				<li><st c="43003">Let’s load the dataset described in the </st><em class="italic"><st c="43044">Technical </st></em><span class="No-Break"><em class="italic"><st c="43054">requirements</st></em></span><span class="No-Break"><st c="43066"> section:</st></span><pre class="source-code"><st c="43075">
df = pd.read_csv(
    «retail.csv», parse_dates=[«invoice_date»])</st></pre></li>				<li><st c="43137">Let</st><a id="_idTextAnchor1266"/><st c="43141">’s set up an </st><span class="No-Break"><st c="43155">entity set:</st></span><pre class="source-code"><st c="43166">
es = ft.EntitySet(id="data")</st></pre></li>				<li><st c="43195">Let’s add the DataFrame to the </st><span class="No-Break"><st c="43227">entity set:</st></span><pre class="source-code"><st c="43238">
es = es.add_dataframe(
    dataframe=df,
    dataframe_name=»data»,
    index="rows",
    make_index=True,
    time_index=»invoice_date»,
    logical_types={«customer_id»: Categorical},
)</st></pre></li>				<li><st c="43402">Let’s create a new DataFrame with a relationship to the DataFrame from </st><span class="No-Break"><em class="italic"><st c="43474">step 4</st></em></span><span class="No-Break"><st c="43480">:</st></span><pre class="source-code"><st c="43482">
es.normalize_dataframe(
    base_dataframe_name=»data»,
    new_dataframe_name=»invoices»,
    index="invoice",
    copy_columns=[«customer_id»],
)</st></pre></li>			</ol>
			<p class="callout-heading"><st c="43614">Note</st></p>
			<p class="callout"><st c="43619">For more details about </st><em class="italic"><st c="43643">steps 4</st></em><st c="43650"> and </st><em class="italic"><st c="43655">5</st></em><st c="43656">, visit the </st><em class="italic"><st c="43668">Setting up an entity set and creating features </st></em><span class="No-Break"><em class="italic"><st c="43715">automatically</st></em></span><span class="No-Break"><st c="43728"> recipe.</st></span></p>
			<ol>
				<li value="6"><st c="43736">Let’s create </st><a id="_idIndexMarker726"/><st c="43750">a primitive that returns a Boolean vector indicating if the date coincides with a UK bank holiday (that is, a </st><span class="No-Break"><st c="43860">non-working day):</st></span><pre class="source-code"><st c="43877">
is_bank_hol = IsFederalHoliday(country="UK")</st></pre></li>			</ol>
			<p class="callout-heading"><st c="43922">Note</st></p>
			<p class="callout"><st c="43927">When setting up the primitive to determine bank holidays, it is important to choose the right country. </st><st c="44031">For a list of supported countries, </st><span class="No-Break"><st c="44066">visit </st></span><a href="https://github.com/dr-prodigy/python-holidays#available-countries"><span class="No-Break"><st c="44072">https://github.com/dr-prodigy/python-holidays#available-countries</st></span></a><span class="No-Break"><st c="44137">.</st></span></p>
			<ol>
				<li value="7"><st c="44138">Let’s check out which bank holidays are included in </st><span class="No-Break"><st c="44191">this primitive:</st></span><pre class="source-code"><st c="44206">
hols = is_bank_hol.holidayUtil.federal_holidays.values()
available_hols = list(set(hols))</st></pre><p class="list-inset"><st c="44296">If we </st><a id="_idIndexMarker727"/><st c="44303">execute </st><strong class="source-inline"><st c="44311">available_hols</st></strong><st c="44325">, we’ll see a list of bank holidays supported for </st><span class="No-Break"><st c="44375">the UK:</st></span></p><pre class="source-code"><strong class="bold"><st c="44382">['May Day',</st></strong>
<strong class="bold"><st c="44394"> 'Good Friday',</st></strong>
<strong class="bold"><st c="44409"> 'Wedding of William and Catherine',</st></strong>
<strong class="bold"><st c="44445"> 'Coronation of Charles III',</st></strong>
<strong class="bold"><st c="44474"> 'Christmas Day',</st></strong>
<strong class="bold"><st c="44491"> 'Wedding of Charles and Diana',</st></strong>
<strong class="bold"><st c="44523"> 'Christmas Day (observed)',</st></strong>
<strong class="bold"><st c="44551"> 'State Funeral of Queen Elizabeth II',</st></strong>
<strong class="bold"><st c="44590"> 'Silver Jubilee of Elizabeth II',</st></strong>
<strong class="bold"><st c="44624"> 'Spring Bank Holiday',</st></strong>
<strong class="bold"><st c="44647"> 'Diamond Jubilee of Elizabeth II',</st></strong>
<strong class="bold"><st c="44682"> 'Boxing Day (observed)',</st></strong>
<strong class="bold"><st c="44707"> 'Platinum Jubilee of Elizabeth II',</st></strong>
<strong class="bold"><st c="44743"> "New Year's Day (observed)",</st></strong>
<strong class="bold"><st c="44772"> 'Boxing Day',</st></strong>
<strong class="bold"><st c="44786"> 'Golden Jubilee of Elizabeth II',</st></strong>
<strong class="bold"><st c="44820"> 'Millennium Celebrations',</st></strong>
<strong class="bold"><st c="44847"> "New Year's Day"]</st></strong></pre></li>				<li><st c="44865">Let’s create another primitive that determines the days to a certain date – in this case, the distance to </st><span class="No-Break"><st c="44972">Boxing Day:</st></span><pre class="source-code"><st c="44983">
days_to_boxing = DistanceToHoliday(
    holiday="Boxing Day", country="UK")</st></pre></li>				<li><st c="45055">Now, let’s make a list containing strings that identify common features that we can get from </st><strong class="source-inline"><st c="45149">datetime</st></strong><st c="45157"> and include the primitives from </st><em class="italic"><st c="45190">steps 6</st></em> <span class="No-Break"><st c="45197">and </st></span><span class="No-Break"><em class="italic"><st c="45202">8</st></em></span><span class="No-Break"><st c="45203">:</st></span><pre class="source-code"><st c="45204">
date_primitives = [
    "day", "year", "month", "weekday",
    "days_in_month", "part_of_day",
    "hour</st><a id="_idTextAnchor1267"/><st c="45297">", "minute",
    is_bank_hol,
    days_to_boxing
]</st></pre></li>				<li><st c="45340">Let’s now </st><a id="_idIndexMarker728"/><st c="45351">create date and time features from </st><em class="italic"><st c="45386">step 9</st></em><st c="45392"> based on the </st><strong class="source-inline"><st c="45406">invoice_date</st></strong> <span class="No-Break"><st c="45418">date variable:</st></span><pre class="source-code"><st c="45433">
feature_matrix, feature_defs = ft.dfs(
    entityset=es,
    target_dataframe_name=»invoices»,
    agg_primitives=[],
    trans_primitives=date_primitives,
)</st></pre></li>			</ol>
			<p class="callout-heading"><st c="45575">Note</st></p>
			<p class="callout"><st c="45580">In </st><em class="italic"><st c="45584">step 4</st></em><st c="45590">, we entered the </st><strong class="source-inline"><st c="45607">invoice_date</st></strong><st c="45619"> variable as a time variable. </st><st c="45649">Thus, </st><strong class="source-inline"><st c="45655">featuretools</st></strong><st c="45667"> will use this variable to create date- and </st><span class="No-Break"><st c="45711">time-related features.</st></span></p>
			<ol>
				<li value="11"><st c="45733">Let’s display the names of the </st><span class="No-Break"><st c="45765">created features:</st></span><pre class="source-code"><st c="45782">
feature_defs</st></pre><p class="list-inset"><st c="45795">In the following output, we see the names of the original and </st><span class="No-Break"><st c="45858">time features:</st></span></p><pre class="source-code"><strong class="bold"><st c="45872">[&lt;Feature: customer_id&gt;,</st></strong>
<strong class="bold"><st c="45897">&lt;Feature: DAY(first_data_time)&gt;,</st></strong>
<strong class="bold"><st c="45929">&lt;Feature: DAYS_IN_MONTH(first_data_time)&gt;,</st></strong>
<strong class="bold"><st c="45971">&lt;Feature: DISTANCE_TO_HOLIDAY(</st></strong>
<strong class="bold"><st c="46002">     first_data_time, holiday=Boxing Day, country=UK)&gt;,</st></strong>
<strong class="bold"><st c="46053">&lt;Feature: HOUR(first_data_time)&gt;,</st></strong>
<strong class="bold"><st c="46086">&lt;Feature: IS_FEDERAL_HOLIDAY(</st></strong>
<strong class="bold"><st c="46116">     first_data_time, , country=UK)&gt;,</st></strong>
<strong class="bold"><st c="46149">&lt;Feature: MINUTE(first_data_time)&gt;,</st></strong>
<strong class="bold"><st c="46184">&lt;Feature: MONTH(first_data_time)&gt;,</st></strong>
<strong class="bold"><st c="46218">&lt;Feature: PART_OF_DAY(first_data_time)&gt;,</st></strong>
<strong class="bold"><st c="46258">&lt;Feature: WEEKDAY(first_data_time)&gt;,</st></strong>
<strong class="bold"><st c="46294">&lt;Feature: YEAR(first_data_time)&gt;]</st></strong></pre><p class="list-inset"><st c="46328">Go ahead and execute </st><strong class="source-inline"><st c="46350">feature_matrix.head()</st></strong><st c="46371"> to take a look at the resulting DataFrame with the features created from the invoice date. </st><st c="46463">The DataFrame </st><a id="_idIndexMarker729"/><st c="46477">is quite big, so for reasons</st><a id="_idTextAnchor1268"/><st c="46505"> of space, we’ll only display a few columns in </st><span class="No-Break"><st c="46552">the book.</st></span></p></li>				<li><st c="46561">Let’s display the resulting DataFrame containing three of the </st><span class="No-Break"><st c="46624">new features:</st></span><pre class="source-code"><st c="46637">
columns = [
    "DISTANCE_TO_HOLIDAY(first_data_time,
        holiday=Boxing Day, country=UK)",
    "HOUR(first_data_time)",
    "IS_FEDERAL_HOLIDAY(first_data_time,
        country=UK)",
]
feature_matrix[columns].head()</st></pre><p class="list-inset"><st c="46830">In the</st><a id="_idTextAnchor1269"/><st c="46837"> following output, we see the DataFrame with the </st><span class="No-Break"><st c="46886">new features:</st></span></p></li>			</ol>
			<div>
				<div id="_idContainer174" class="IMG---Figure">
					<img src="image/B22396_09_10.jpg" alt="Figure 9.10 – DataF﻿rame with some of the features derived from datetime"/><st c="46899"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="47148">Figure 9.10 – DataF</st><a id="_idTextAnchor1270"/><st c="47167">rame with some of the features derived from datetime</st></p>
			<p><st c="47220">Note that </st><a id="_idIndexMarker730"/><st c="47231">some of the created features are numeric, such as </st><strong class="source-inline"><st c="47281">HOUR</st></strong><st c="47285"> or </st><strong class="source-inline"><st c="47289">DAY</st></strong><st c="47292">, some are Booleans, such as </st><strong class="source-inline"><st c="47321">IS_FEDERAL_HOLIDAY</st></strong><st c="47339">, and some are categorical, such as </st><strong class="source-inline"><st c="47375">PART_OF_DAY</st></strong><st c="47386">. To take a look at the values of </st><strong class="source-inline"><st c="47420">PART_OF_DAY</st></strong><st c="47431">, </st><span class="No-Break"><st c="47433">e</st><a id="_idTextAnchor1271"/><a id="_idTextAnchor1272"/><st c="47434">xecute </st></span><span class="No-Break"><strong class="source-inline"><st c="47441">feature_matrix["PAR</st><a id="_idTextAnchor1273"/><st c="47460">T_OF_DAY(first_data_time)"].unique()</st></strong></span><span class="No-Break"><st c="47497">.</st></span></p>
			<h2 id="_idParaDest-266"><a id="_idTextAnchor1274"/><st c="47498">How it works...</st></h2>
			<p><st c="47514">To create features from datetime variables, we used datetime transform primitives from </st><strong class="source-inline"><st c="47602">featuretools </st></strong><st c="47615">(</st><a href="https://featuretools.alteryx.com/en/stable/api_reference.html#datetime-transform-primitives"><st c="47616">https://featuretools.alteryx.com/en/stable/api_reference.html#datetime-transform-primitives</st></a><st c="47707">). </st><st c="47711">These primitives can be accessed from </st><strong class="source-inline"><st c="47749">dfs</st></strong><st c="47752"> using the strings and functions we specified in </st><em class="italic"><st c="47801">steps 6</st></em><st c="47808"> to</st><em class="italic"><st c="47811"> 9</st></em><st c="47813"> through the </st><strong class="source-inline"><st c="47826">trans_primitive</st></strong><st c="47841"> parameter. </st><st c="47853">Note that in addition, we passed an empty list to the </st><strong class="source-inline"><st c="47907">agg_primitives</st></strong><st c="47921"> parameter not to return the default aggregation primitives that would have been otherwise applied to our datetime features. </st><st c="48046">We also ignored the features coming from the </st><span class="No-Break"><strong class="source-inline"><st c="48091">invoices</st></strong></span><span class="No-Break"><st c="48099"> DataFrame.</st></span></p>
			<p class="callout-heading"><st c="48110">Note</st></p>
			<p class="callout"><st c="48115">We set </st><strong class="source-inline"><st c="48123">agg_primitives</st></strong><st c="48137"> to an empty list and ignored the </st><strong class="source-inline"><st c="48171">invoices</st></strong><st c="48179"> DataFrame to keep the outputs simple and be able to focus on datetime features. </st><st c="48260">However, note that the real power of </st><strong class="source-inline"><st c="48297">featuretools</st></strong><st c="48309"> consists in creating primitives from </st><strong class="source-inline"><st c="48347">datetim</st><a id="_idTextAnchor1275"/><a id="_idTextAnchor1276"/><a id="_idTextAnchor1277"/><st c="48354">e</st></strong><st c="48356"> and then aggregating them further at different </st><span class="No-Break"><st c="48404">entity levels.</st></span></p>
			<h1 id="_idParaDest-267"><a id="_idTextAnchor1278"/><st c="48418">Extracting features from text</st></h1>
			<p><st c="48448">In </st><a href="B22396_11.xhtml#_idTextAnchor1459"><span class="No-Break"><em class="italic"><st c="48452">Chapter 11</st></em></span></a><st c="48462">, </st><em class="italic"><st c="48464">Extracting Feat</st><a id="_idTextAnchor1279"/><st c="48479">ures from Text Variables</st></em><st c="48504">, we will discuss various features that </st><a id="_idIndexMarker731"/><st c="48544">we can extract from text pieces utilizing </st><strong class="source-inline"><st c="48586">pandas</st></strong><st c="48592"> and </st><strong class="source-inline"><st c="48597">scikit-learn</st></strong><st c="48609">. We can also extract multiple features from text automatically by </st><span class="No-Break"><st c="48676">utilizing </st></span><span class="No-Break"><strong class="source-inline"><st c="48686">featuretools</st></strong></span><span class="No-Break"><st c="48698">.</st></span></p>
			<p><st c="48699">The </st><strong class="source-inline"><st c="48704">featuretools</st></strong><st c="48716"> library supports the creation of several basic features from text as part of its default functionality, such as the number of characters, the number of words, the mean character count per word, and the median word length in a piece of text, </st><span class="No-Break"><st c="48958">among others.</st></span></p>
			<p class="callout-heading"><st c="48971">Note</st></p>
			<p class="callout"><st c="48976">For a full list </st><a id="_idIndexMarker732"/><st c="48993">of the default text primitives, </st><span class="No-Break"><st c="49025">visit </st></span><a href="https://featuretools.alteryx.com/en/stable/api_reference.html#naturallanguage-transform-primitives"><span class="No-Break"><st c="49031">https://featuretools.alteryx.com/en/stable/api_reference.html#naturallanguage-transform-primitives</st></span></a><span class="No-Break"><st c="49129">.</st></span></p>
			<p><st c="49130">In addition, there is an accompanying Python library, </st><strong class="source-inline"><st c="49185">nlp_primitives</st></strong><st c="49199">, which contains additional primitives to create more advanced features based on NLP. </st><st c="49285">Among these functions, we find primitives for determining the diversity score, the polarity score, or the count of </st><span class="No-Break"><st c="49400">stop words.</st></span></p>
			<p class="callout-heading"><st c="49411">Note</st></p>
			<p class="callout"><st c="49416">There is no documentation at the time of writing to learn more about the primitives supported </st><a id="_idIndexMarker733"/><st c="49511">by the </st><strong class="source-inline"><st c="49518">nlp_primitives</st></strong><st c="49532"> library, so to find out more, you need to check the source </st><span class="No-Break"><st c="49592">code: </st></span><a href="https://github.com/alteryx/nlp_primitives/tree/6243ef2379501bfec2c3f19e35a30b5954605e57/nlp_primitives"><span class="No-Break"><st c="49598">https://github.com/alteryx/nlp_primitives/tree/6243ef2379501bfec2c3f19e35a30b5954605e57/nlp_primitives</st></span></a><span class="No-Break"><st c="49700">.</st></span></p>
			<p><st c="49701">In this recipe, we will first create multiple features from a text variable utilizing </st><strong class="source-inline"><st c="49788">featuretools</st></strong><st c="49800">’ default functionality and the</st><a id="_idTextAnchor1280"/><a id="_idTextAnchor1281"/><st c="49832">n highlight how to use p</st><a id="_idTextAnchor1282"/><st c="49857">rimitives from the </st><span class="No-Break"><strong class="source-inline"><st c="49877">nlp_primitives</st></strong></span><span class="No-Break"><st c="49891"> library.</st></span></p>
			<h2 id="_idParaDest-268"><a id="_idTextAnchor1283"/><st c="49900">Getting ready</st></h2>
			<p><st c="49914">To follow along with this recipe, you need to install the </st><strong class="source-inline"><st c="49973">nlp_primitives</st></strong><st c="49987"> library, which you can do </st><span class="No-Break"><st c="50014">with </st></span><span class="No-Break"><strong class="source-inline"><st c="50019">pip</st></strong></span><span class="No-Break"><st c="50022">:</st></span></p>
			<pre class="console"><st c="50024">
pip install nlp_primitives</st></pre>			<p><st c="50051">Otherwise, you can </st><span class="No-Break"><st c="50071">use </st></span><span class="No-Break"><strong class="source-inline"><st c="50075">conda</st></strong></span><span class="No-Break"><st c="50080">:</st></span></p>
			<pre class="console"><st c="50082">
conda install -c conda-forge nlp-primitives</st></pre>			<p class="callout-heading"><st c="50126">Note</st></p>
			<p class="callout"><st c="50131">For more details, visit the </st><strong class="source-inline"><st c="50160">nlp_primi</st><a id="_idTextAnchor1284"/><a id="_idTextAnchor1285"/><st c="50169">tives</st></strong><st c="50175"> GitHub </st><span class="No-Break"><st c="50183">repository: </st></span><a href="https://github.com/alteryx/nlp_primitives"><span class="No-Break"><st c="50195">https://github.com/alteryx/nlp_primitives</st></span></a></p>
			<h2 id="_idParaDest-269"><a id="_idTextAnchor1286"/><st c="50236">How to do it...</st></h2>
			<p><st c="50252">Let’s begin </st><a id="_idIndexMarker734"/><st c="50265">by importing the libraries and getting the </st><span class="No-Break"><st c="50308">dataset ready:</st></span></p>
			<ol>
				<li><st c="50322">First, we’ll import </st><strong class="source-inline"><st c="50343">pandas</st></strong><st c="50349">, </st><strong class="source-inline"><st c="50351">featuretools</st></strong><st c="50363">, and the </st><span class="No-Break"><st c="50373">logical types:</st></span><pre class="source-code"><st c="50387">
import pandas as pd
import featuretools as ft
from woodwork.logical_types import (
   Categorical, NaturalLanguage)</st></pre></li>				<li><st c="50500">Let’s load the dataset described in the </st><em class="italic"><st c="50541">Technical </st></em><span class="No-Break"><em class="italic"><st c="50551">requirements</st></em></span><span class="No-Break"><st c="50563"> section:</st></span><pre class="source-code"><st c="50572">
df = pd.read_csv(
    «retail.csv», parse_dates=[«invoice_date»])</st><a id="_idTextAnchor1287"/></pre></li>				<li><st c="50634">Let’s set up an </st><span class="No-Break"><st c="50651">entity set:</st></span><pre class="source-code"><st c="50662">
es = ft.EntitySet(id="data")</st></pre></li>				<li><st c="50691">Let’s add the DataFrame to the entity set, highlighting that the </st><strong class="source-inline"><st c="50757">description</st></strong><st c="50768"> variable is a </st><span class="No-Break"><st c="50783">text variable:</st></span><pre class="source-code"><st c="50797">
es = es.add_dataframe(
    dataframe=df,
    dataframe_name=»data»,
    index="rows",
    make_index=True,
    time_index=»invoice_date»,
    logical_types={
        «customer_id»: Categorical,
        "invoice": Categorical,
        «description»: NaturalLanguage,
    }
)</st></pre></li>			</ol>
			<p class="callout-heading"><st c="51019">Note</st></p>
			<p class="callout"><st c="51024">For the </st><strong class="source-inline"><st c="51033">featuretools</st></strong><st c="51045"> library‘s text primitives to work, we need to indicate which variables are text by using the </st><strong class="source-inline"><st c="51139">NaturalLanguage</st></strong> <span class="No-Break"><st c="51154">logical type.</st></span></p>
			<ol>
				<li value="5"><st c="51168">Let’s create </st><a id="_idIndexMarker735"/><st c="51182">a new DataFrame with a relationship to the DataFrame from </st><span class="No-Break"><em class="italic"><st c="51240">step 4</st></em></span><span class="No-Break"><st c="51246">:</st></span><pre class="source-code"><st c="51248">
es.normalize_dataframe(
    base_dataframe_name=»data»,
    new_dataframe_name=»invoices»,
    index="invoice",
    copy_columns=[«customer_id»],
)</st></pre></li>			</ol>
			<p class="callout-heading"><st c="51380">Note</st></p>
			<p class="callout"><st c="51385">For more details about </st><em class="italic"><st c="51409">steps 4</st></em><st c="51416"> and </st><em class="italic"><st c="51421">5</st></em><st c="51422">, visit the </st><em class="italic"><st c="51434">Setting up </st><a id="_idTextAnchor1288"/><st c="51445">an entity set and creating features </st></em><span class="No-Break"><em class="italic"><st c="51481">automatically</st></em></span><span class="No-Break"><st c="51494"> recipe.</st></span></p>
			<ol>
				<li value="6"><st c="51502">Let’s make a list with strings corresponding to the text features we want </st><span class="No-Break"><st c="51577">to create:</st></span><pre class="source-code"><st c="51587">
text_primitives = [
    "num_words",
    "num_characters",
    "MeanCharactersPerWord" ,
    "PunctuationCount"]</st></pre></li>				<li><st c="51684">Let’s now </st><a id="_idIndexMarker736"/><st c="51695">extract the text features from the </st><span class="No-Break"><strong class="source-inline"><st c="51730">description</st></strong></span><span class="No-Break"><st c="51741"> variable:</st></span><pre class="source-code"><st c="51751">
feature_matrix, feature_defs = ft.dfs(
    entityset=es,
    target_dataframe_name=»data»,
    agg_primitives=[],
    trans_primitives=text_primitives,
    ignore_dataframes=[«invoices»],
)</st></pre></li>				<li><st c="51921">Let’s display the names of the </st><span class="No-Break"><st c="51953">created features:</st></span><pre class="source-code"><st c="51970">
feature_defs</st></pre><p class="list-inset"><st c="51983">In the following output, we see the names of the original features, followed by those created from the </st><span class="No-Break"><strong class="source-inline"><st c="52087">description</st></strong></span><span class="No-Break"><st c="52098"> variable:</st></span></p><pre class="source-code"><strong class="bold"><st c="52108">[&lt;Feature: customer_id&gt;,</st></strong>
<strong class="bold"><st c="52133">&lt;Feature: invoice&gt;,</st></strong>
<strong class="bold"><st c="52152">&lt;Feature: stock_code&gt;,</st></strong>
<strong class="bold"><st c="52174">&lt;Feature: quantity&gt;,</st></strong>
<strong class="bold"><st c="52194">&lt;Feature: price&gt;,</st></strong>
<strong class="bold"><st c="52211">&lt;Feature: MEAN_CHARACTERS_PER_WORD(description)&gt;,</st></strong>
<strong class="bold"><st c="52260">&lt;Feature: NUM_CHARACTERS(description)&gt;,</st></strong>
<strong class="bold"><st c="52299">&lt;Feature: NUM_WORDS(description)&gt;,</st></strong>
<strong class="bold"><st c="52333">&lt;Feature: PUNCTUATION_COUNT(description)&gt;]</st></strong></pre><p class="list-inset"><st c="52376">Go ahead and inspect the result by </st><span class="No-Break"><st c="52412">executing </st></span><span class="No-Break"><strong class="source-inline"><st c="52422">feature_matrix.head()</st></strong></span><span class="No-Break"><st c="52443">.</st></span></p></li>				<li><st c="52444">Let’s display </st><a id="_idIndexMarker737"/><st c="52459">a slice of the DataFrame containing the </st><span class="No-Break"><st c="52499">text-derived features:</st></span><pre class="source-code">
<strong class="bold"><st c="52521">text_f = [</st></strong>
<strong class="bold"><st c="52532">     "NUM_CHARACTERS(description)",</st></strong>
<strong class="bold"><st c="52563">     "NUM_WORDS(description)",</st></strong>
<strong class="bold"><st c="52589">     "PUNCTUATION_COUNT(description)",</st></strong>
<strong class="bold"><st c="52623">]</st></strong>
<strong class="bold"><st c="52625">feature_matrix[text_f].head()</st></strong></pre><p class="list-inset"><st c="52654">In the followin</st><a id="_idTextAnchor1289"/><st c="52670">g output, we see a DataFrame with the features created from </st><span class="No-Break"><st c="52731">the text:</st></span></p></li>			</ol>
			<div>
				<div id="_idContainer175" class="IMG---Figure">
					<img src="image/B22396_09_11.jpg" alt="Figure 9.11 – DataFrame with the features created from text"/><st c="52740"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="52874">Figure 9.11 – DataFrame with the features created from text</st></p>
			<p class="callout-heading"><st c="52933">Note</st></p>
			<p class="callout"><st c="52938">The </st><strong class="source-inline"><st c="52943">featuretools</st></strong><st c="52955"> library removes the original text variable, </st><strong class="source-inline"><st c="53000">description</st></strong><st c="53011">, and in its place, it returns the </st><span class="No-Break"><st c="53046">new features.</st></span></p>
			<p><st c="53059">To create features using the primitives from the </st><strong class="source-inline"><st c="53109">nlp_primitives</st></strong><st c="53123"> package, you need to import them first – for example, by executing from </st><strong class="source-inline"><st c="53196">nlp_primitives import DiversityScore</st></strong><st c="53232"> – and then add the primitives to the text primitive list that we created in </st><em class="italic"><st c="53309">step 6</st></em><st c="53315">. Note that these are</st><a id="_idTextAnchor1290"/><a id="_idTextAnchor1291"/> <a id="_idTextAnchor1292"/><a id="_idTextAnchor1293"/><st c="53336">complex functions, so they</st><a id="_idTextAnchor1294"/><st c="53363"> may take some time to create </st><span class="No-Break"><st c="53393">the features.</st></span></p>
			<h2 id="_idParaDest-270"><a id="_idTextAnchor1295"/><st c="53406">How it works...</st></h2>
			<p><st c="53422">To create </st><a id="_idIndexMarker738"/><st c="53433">features from text variables, we used the default text primitives from </st><strong class="source-inline"><st c="53504">featuretools</st></strong><st c="53516">. These primitives can be accessed from </st><strong class="source-inline"><st c="53556">dfs</st></strong><st c="53559"> by passing a list with strings corresponding to the primitive names, such as those from </st><em class="italic"><st c="53648">step 6</st></em><st c="53654">, to the </st><span class="No-Break"><strong class="source-inline"><st c="53663">trans_primitives</st></strong></span><span class="No-Break"><st c="53679"> parameter.</st></span></p>
			<p><st c="53690">For more advanced primitives, you need to import the primitive functions from the </st><strong class="source-inline"><st c="53773">nlp_primitives</st></strong><st c="53787"> library and then pass them on to the </st><strong class="source-inline"><st c="53825">trans_primitives</st></strong><st c="53841"> parameter from </st><strong class="source-inline"><st c="53857">dfs</st></strong><st c="53860">. With this, </st><strong class="source-inline"><st c="53873">dfs</st></strong><st c="53876"> can tap into the functionality of these primitives to create new features from the text. </st><st c="53966">T</st><a id="_idTextAnchor1296"/><a id="_idTextAnchor1297"/><st c="53967">he </st><strong class="source-inline"><st c="53970">nlp_primitives</st></strong><st c="53984"> library uses the </st><strong class="source-inline"><st c="54002">nltk</st></strong><st c="54006"> Python library un</st><a id="_idTextAnchor1298"/><st c="54024">der </st><span class="No-Break"><st c="54029">the hood.</st></span></p>
			<h1 id="_idParaDest-271"><a id="_idTextAnchor1299"/><st c="54038">Creating features with aggregation primitives</st></h1>
			<p><st c="54084">Throughout this chapter, we’ve created features automatically by mapping existing variables into </st><a id="_idIndexMarker739"/><st c="54182">new features through various functions. </st><st c="54222">For example, we extracted date and time parts from datetime variables, counted the number of words,</st><a id="_idTextAnchor1300"/><st c="54321"> characters, and punctuation in texts, combined numerical features into new variables, and transformed features with functions such as sine and cosine. </st><st c="54473">To create these features, we worked with </st><span class="No-Break"><st c="54514">transform primitives.</st></span></p>
			<p><st c="54535">The </st><strong class="source-inline"><st c="54540">featuretools</st></strong><st c="54552"> library also </st><a id="_idIndexMarker740"/><st c="54566">supports </st><strong class="bold"><st c="54575">aggregation primitives</st></strong><st c="54597">, and here is where it gets interesting. </st><st c="54638">These primitives take related observations as input and return a single value as output. </st><st c="54727">For example, if we have a numerical variable, </st><strong class="source-inline"><st c="54773">price</st></strong><st c="54778">, related to an invoice, an aggregation primitive would take all the price observations for a single invoice and return a single value, such as the mean price or the sum (that is, the total amount paid), for </st><span class="No-Break"><st c="54986">that invoice.</st></span></p>
			<p class="callout-heading"><st c="54999">Note</st></p>
			<p class="callout"><st c="55004">The </st><strong class="source-inline"><st c="55009">featuretools</st></strong><st c="55021"> aggregation functionality is the equivalent of </st><strong class="source-inline"><st c="55069">groupby</st></strong><st c="55076"> in </st><strong class="source-inline"><st c="55080">pandas</st></strong><st c="55086">, followed by </st><strong class="source-inline"><st c="55100">pandas</st></strong><st c="55106"> fun</st><a id="_idTextAnchor1301"/><st c="55110">ctions such as </st><strong class="source-inline"><st c="55126">mean</st></strong><st c="55130">, </st><strong class="source-inline"><st c="55132">sum</st></strong><st c="55135">, </st><strong class="source-inline"><st c="55137">std</st></strong><st c="55140">, and </st><strong class="source-inline"><st c="55146">count</st></strong><st c="55151">, </st><span class="No-Break"><st c="55153">among others.</st></span></p>
			<p><st c="55166">Some aggregation primitives work with numerical variables, such as the mean, sum, or maximum </st><a id="_idIndexMarker741"/><st c="55260">and minimum values. </st><st c="55280">Other aggregation primitives are specific to categorical variables, such as the number</st><a id="_idTextAnchor1302"/><st c="55366"> of unique values and the most frequent </st><span class="No-Break"><st c="55406">value (mode).</st></span></p>
			<p class="callout-heading"><st c="55419">Note</st></p>
			<p class="callout"><st c="55424">For a </st><a id="_idIndexMarker742"/><st c="55431">complete list of supported aggregation primitives, </st><span class="No-Break"><st c="55482">visit </st></span><a href="https://featuretools.alteryx.com/en/stable/api_reference.html#aggregation-primitives"><span class="No-Break"><st c="55488">https://featuretools.alteryx.com/en/stable/api_reference.html#aggregation-primitives</st></span></a><span class="No-Break"><st c="55572">.</st></span></p>
			<p><st c="55573">In this recipe, we will first create multiple features by aggregating existing variables. </st><st c="55664">After that, we will combine the use of transfo</st><a id="_idTextAnchor1303"/><a id="_idTextAnchor1304"/><st c="55710">rm and aggregation primitives to highlight the true power </st><span class="No-Break"><st c="55769">of </st></span><span class="No-Break"><strong class="source-inline"><st c="55772">featuretools</st></strong></span><span class="No-Break"><st c="55784">.</st></span></p>
			<h2 id="_idParaDest-272"><a id="_idTextAnchor1305"/><st c="55785">Getting ready</st></h2>
			<p><st c="55799">In this recipe, we will use the </st><em class="italic"><st c="55832">Online Retail II</st></em><st c="55848"> dataset from the UCI Machine Learning Repository. </st><st c="55899">This dataset has information about products (items), invoices, and customers. </st><st c="55977">To follow along with this recipe, it is important to understand the nature of and the relationships between these entities and how to correctly set up an entity set with </st><strong class="source-inline"><st c="56147">featuretools</st></strong><st c="56159">, which we described in the </st><em class="italic"><st c="56187">Setting up an entity set and creating features automatically</st></em><st c="56247"> recipe. </st><st c="56256">Make</st><a id="_idTextAnchor1306"/><a id="_idTextAnchor1307"/><st c="56260"> sure you checked that recip</st><a id="_idTextAnchor1308"/><st c="56288">e out before proceeding with the </st><span class="No-Break"><st c="56322">next section.</st></span></p>
			<h2 id="_idParaDest-273"><a id="_idTextAnchor1309"/><st c="56335">How to do it...</st></h2>
			<p><st c="56351">Let’s begin by importing the libraries and getting the </st><span class="No-Break"><st c="56407">dataset ready:</st></span></p>
			<ol>
				<li><st c="56421">First, we’ll import </st><strong class="source-inline"><st c="56442">pandas</st></strong><st c="56448">, </st><strong class="source-inline"><st c="56450">featuretools</st></strong><st c="56462">, and the </st><span class="No-Break"><st c="56472">logical types:</st></span><pre class="source-code"><st c="56486">
import pandas as pd
import featuretools as ft
from woodwork.logical_types import (
    Categorical, NaturalLanguage)</st></pre></li>				<li><st c="56599">Let’s load </st><a id="_idIndexMarker743"/><st c="56611">the dataset described in the </st><em class="italic"><st c="56640">Technical </st></em><span class="No-Break"><em class="italic"><st c="56650">requirements</st></em></span><span class="No-Break"><st c="56662"> section:</st></span><pre class="source-code"><st c="56671">
df = pd.read_csv(
    «retail.csv», parse_dates=[«invoice_date»])</st></pre></li>				<li><st c="56733">Let’s set up an </st><span class="No-Break"><st c="56750">entity set:</st></span><pre class="source-code"><st c="56761">
es = ft.EntitySet(id="data")</st></pre></li>				<li><st c="56790">Let’s add the DataFrame to the entity set, highlighting that the </st><strong class="source-inline"><st c="56856">description</st></strong><st c="56867"> variable is a text variable, </st><strong class="source-inline"><st c="56897">customer_id</st></strong><st c="56908"> is categorical, and </st><strong class="source-inline"><st c="56929">invoice_date</st></strong><st c="56941"> is a </st><span class="No-Break"><st c="56947">datetime feature:</st></span><pre class="source-code"><st c="56964">
es = es.add_dataframe(
    dataframe=df,
    dataframe_name=»data»,
    index="rows",
    make_index=True,
    time_index=»invoice_date»,
    logical_types={
        «customer_id»: Categorical,
        «description»: NaturalLanguage,
    }
)</st></pre></li>				<li><st c="57162">Let’s create a new DataFrame with a relationship to the DataFrame from </st><span class="No-Break"><em class="italic"><st c="57234">step 4</st></em></span><span class="No-Break"><st c="57240">:</st></span><pre class="source-code"><st c="57242">
es.normalize_dataframe(
    base_dataframe_name=»data»,
    new_dataframe_name=»invo</st><a id="_idTextAnchor1310"/><st c="57319">ices»,
    index="invoice",
    copy_columns=[«customer_id»],
)</st></pre></li>				<li><st c="57375">Now, we add </st><a id="_idIndexMarker744"/><st c="57388">the second relationship, which is between customers and invoices. </st><st c="57454">To do this, we indicate the base DataFrame, which we called </st><strong class="source-inline"><st c="57514">invoices</st></strong><st c="57522"> in </st><em class="italic"><st c="57526">step 5</st></em><st c="57532">, we give the new DataFrame a name, </st><strong class="source-inline"><st c="57568">customers</st></strong><st c="57577">, and we add a unique </st><span class="No-Break"><st c="57599">customer identifier:</st></span><pre class="source-code"><st c="57619">
es.normalize_dataframe(
    base_dataframe_name=»invoices»,
    new_dataframe_name=»customers»,
    index=»customer_id»,
)</st></pre></li>			</ol>
			<p class="callout-heading"><st c="57730">Note</st></p>
			<p class="callout"><st c="57735">For more details about </st><em class="italic"><st c="57759">steps 4</st></em><st c="57766"> to </st><em class="italic"><st c="57770">5</st></em><st c="57771">, visit the </st><em class="italic"><st c="57783">Setting up an entity set and creating features </st></em><span class="No-Break"><em class="italic"><st c="57830">automatically</st></em></span><span class="No-Break"><st c="57843"> recipe.</st></span></p>
			<ol>
				<li value="7"><st c="57851">Let’s make a list with string names that identify the aggregation primitives we want </st><span class="No-Break"><st c="57937">to use:</st></span><pre class="source-code"><st c="57944">
agg_primitives = ["mean", "max", "min", "sum"]</st></pre></li>				<li><st c="57991">Let’s create features by aggregating the data at the customer level. </st><st c="58061">To do this, we set up the </st><strong class="source-inline"><st c="58087">dfs</st></strong><st c="58090"> class from </st><strong class="source-inline"><st c="58102">featuretools</st></strong><st c="58114">, indicating </st><strong class="source-inline"><st c="58127">customers</st></strong><st c="58136"> as the target DataFrame and passing the aggregation primitives from </st><em class="italic"><st c="58205">step 7</st></em><st c="58211"> and an empty list to the </st><strong class="source-inline"><st c="58237">trans_primitives</st></strong><st c="58253"> parameter to prevent </st><strong class="source-inline"><st c="58275">dfs</st></strong><st c="58278"> from returning the </st><span class="No-Break"><st c="58298">default transformations:</st></span><pre class="source-code"><st c="58322">
feature_matrix, feature_defs = ft.dfs(
    entityset=es,
    target_dataframe_name=»cus</st><a id="_idTextAnchor1311"/><st c="58402">tomers»,
    agg_primitives=agg_primitives,
    trans_primitives=[],
)</st></pre></li>				<li><st c="58465">Let’s display </st><a id="_idIndexMarker745"/><st c="58480">the names of the </st><span class="No-Break"><st c="58497">created features:</st></span><pre class="source-code"><st c="58514">
feature_defs</st></pre><p class="list-inset"><st c="58527">In the following output, we see the name features that were aggregated at the </st><span class="No-Break"><st c="58606">customer level:</st></span></p><pre class="source-code"><strong class="bold"><st c="58621">[&lt;Feature: MAX(data.price)&gt;,</st></strong>
<strong class="bold"><st c="58650">&lt;Feature: MAX(data.quantity)&gt;,</st></strong>
<strong class="bold"><st c="58680">&lt;Feature: MEAN(data.price)&gt;,</st></strong>
<strong class="bold"><st c="58708">&lt;Feature: MEAN(data.quantity)&gt;,</st></strong>
<strong class="bold"><st c="58739">&lt;Feature: MIN(data.price)&gt;,</st></strong>
<strong class="bold"><st c="58766">&lt;Feature: MIN(data.quantity)&gt;,</st></strong>
<strong class="bold"><st c="58796">&lt;Feature: SUM(data.price)&gt;,</st></strong>
<strong class="bold"><st c="58823">&lt;Feature: SUM(data.quantity)&gt;,</st></strong>
<strong class="bold"><st c="58853">&lt;Feature: MAX(invoices.MEAN(data.price))&gt;,</st></strong>
<strong class="bold"><st c="58895">&lt;Feature: MAX(invoices.MEAN(data.quantity))&gt;,</st></strong>
<strong class="bold"><st c="58940">&lt;Feature: MAX(invoices.MIN(data.price))&gt;,</st></strong>
<strong class="bold"><st c="58981">&lt;Feature: MAX(invoices.MIN(data.quantity))&gt;,</st></strong>
<strong class="bold"><st c="59025">&lt;Feature: MAX(invoices.SUM(data.price))&gt;,</st></strong>
<strong class="bold"><st c="59066">&lt;Feature: MAX(invoices.SUM(data.quantity))&gt;,</st></strong>
<strong class="bold"><st c="59110">&lt;Feature: MEAN(invoices.MAX(data.price))&gt;,</st></strong>
<strong class="bold"><st c="59152">&lt;Feature: MEAN(invoices.MAX(data.quantity))&gt;,</st></strong>
<strong class="bold"><st c="59197">&lt;Feature: MEAN(invoices.MEAN(data.price))&gt;,</st></strong>
<strong class="bold"><st c="59240">&lt;Feature: MEAN(invoices.MEAN(data.quantity))&gt;,</st></strong>
<strong class="bold"><st c="59286">&lt;Feature: MEAN(invoices.MIN(data.price))&gt;,</st></strong>
<strong class="bold"><st c="59328">&lt;Feature: MEAN(invoices.MIN(data.quantity))&gt;,</st></strong>
<strong class="bold"><st c="59373">&lt;Feature: MEAN(invoices.SUM(data.price))&gt;,</st></strong>
<strong class="bold"><st c="59415">&lt;Feature: MEAN(invoices.SUM(data.quantity))&gt;,</st></strong>
<strong class="bold"><st c="59460">&lt;Feature: MIN(invoices.MAX(data.price))&gt;,</st></strong>
<strong class="bold"><st c="59501">&lt;Feature: MIN(invoices.MAX(data.quantity))&gt;,</st></strong>
<strong class="bold"><st c="59545">&lt;Feature: MIN(invoices.MEAN(data.price))&gt;,</st></strong>
<strong class="bold"><st c="59587">&lt;Feature: MIN(invoices.MEAN(data.quantity))&gt;,</st></strong>
<strong class="bold"><st c="59632">&lt;Feature: MIN(invoices.SUM(data.price))&gt;,</st></strong>
<strong class="bold"><st c="59673">&lt;Feature: MIN(invoices.SUM(data.quantity))&gt;,</st></strong>
<strong class="bold"><st c="59717">&lt;Feature: SUM(invoices.MAX(data.price))&gt;,</st></strong>
<strong class="bold"><st c="59758">&lt;Feature: SUM(invoices.MAX(data.quantity))&gt;,</st></strong>
<strong class="bold"><st c="59802">&lt;Feature: SUM(invoices.MEAN(data.price))&gt;,</st></strong>
<strong class="bold"><st c="59844">&lt;Feature: SUM(invoices.MEAN(data.quantity))&gt;,</st></strong>
<strong class="bold"><st c="59889">&lt;Feature: SUM(invoices.MIN(data.price))&gt;,</st></strong>
<strong class="bold"><st c="59930">&lt;Feature: SUM(invoices.MIN(data.quantity))&gt;]</st></strong></pre></li>			</ol>
			<p class="callout-heading"><st c="59975">Note</st></p>
			<p class="callout"><st c="59980">Remember that </st><strong class="source-inline"><st c="59995">featuretools</st></strong><st c="60007"> names features with the function used to create them, followed by the DataFrame that was used in the computation, followed by the variable that was used in the computation. </st><st c="60181">Thus, </st><strong class="source-inline"><st c="60187">MAX(data.price)</st></strong><st c="60202"> is the maximum price seen in the dataset for each customer. </st><st c="60263">On the other hand, </st><strong class="source-inline"><st c="60282">MEAN(invoices.MAX(data.price))</st></strong><st c="60312"> is the mean value of all maximum prices observed in each invoice for a particular customer. </st><st c="60405">That is, if a customer has six invoices, we first find the maximum price for </st><a id="_idTextAnchor1312"/><st c="60482">each of the six invoices and then take the average of </st><span class="No-Break"><st c="60536">those values.</st></span></p>
			<ol>
				<li value="10"><st c="60549">Let’s now </st><a id="_idIndexMarker746"/><st c="60560">display the resulting DataFrame containing the original data and </st><span class="No-Break"><st c="60625">new features:</st></span><pre class="source-code"><st c="60638">
feature_matrix.head()</st></pre><p class="list-inset"><st c="60660">In the fol</st><a id="_idTextAnchor1313"/><st c="60671">lowing output, we see </st><em class="italic"><st c="60694">some</st></em><st c="60698"> of the variables in the DataFrame returned </st><span class="No-Break"><st c="60742">by </st></span><span class="No-Break"><strong class="source-inline"><st c="60745">dfs</st></strong></span><span class="No-Break"><st c="60748">:</st></span></p></li>			</ol>
			<div>
				<div id="_idContainer176" class="IMG---Figure">
					<img src="image/B22396_09_12.jpg" alt="Figure 9.12 – DataFrame with some of the features resulting from aggregations at the customer level"/><st c="60750"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="61524">Figure 9.12 – DataFrame with some of the features resulting from aggregations at the customer level</st></p>
			<p class="list-inset"><st c="61623">Due to space limitations, we can’t display the entire output of </st><em class="italic"><st c="61688">step 10</st></em><st c="61695">, so make sure you execute it on your computer or visit our accompanying GitHub repository for more </st><span class="No-Break"><st c="61795">details: </st></span><a href="https://github.com/PacktPublishing/Python-Feature-Engineering-Cookbook-Third-Edition/blob/main/ch09-featuretools/Recipe6-Creating-features-with-aggregation-primitives.ipynb"><span class="No-Break"><st c="61804">https://github.com/PacktPublishing/Python-Feature-Engineering-Cookbook-Third-Edition/blob/main/ch09-featuretools/Recipe6-Creating-features-with-aggregation-primitives.ipynb</st></span></a><span class="No-Break"><st c="61976">.</st></span></p>
			<p class="list-inset"><st c="61977">To follow up, let’s combine what we learned from the recipes using transform primitives with the aggregation</st><a id="_idTextAnchor1314"/><st c="62086"> functions from this recipe. </st><st c="62115">First, we will create new features from existing datetime and text variables; then, we will aggregate those features along with the numerical variables, at the </st><span class="No-Break"><st c="62275">customer level.</st></span></p>
			<ol>
				<li value="11"><st c="62290">Let’s make lists with date and </st><span class="No-Break"><st c="62322">text primitives:</st></span><pre class="source-code"><st c="62338">
trans_primitives = ["month", "weekday", "num_words"]</st></pre></li>				<li><st c="62391">Let’s make a list with an </st><span class="No-Break"><st c="62418">aggregation primitive:</st></span><pre class="source-code"><st c="62440">
agg_primitives = ["mean"]</st></pre></li>				<li><st c="62466">Let’s now </st><a id="_idIndexMarker747"/><st c="62477">automatically create features by transforming and then </st><span class="No-Break"><st c="62532">aggregating variables:</st></span><pre class="source-code"><st c="62554">
feature_matrix, feature_defs = ft.dfs(
    entityset=es,
    target_dataframe_name=»customers»,
    agg_primitives=agg_primitives,
    trans_primitives=trans_primitives,
    max_depth=3,
)</st></pre><p class="list-inset"><st c="62723">The code from </st><em class="italic"><st c="62738">step 13</st></em><st c="62745"> triggers the creation of the features and their subsequent aggregation at the </st><span class="No-Break"><st c="62824">customer level.</st></span></p></li>				<li><st c="62839">Let’s display the names of the </st><span class="No-Break"><st c="62871">new features:</st></span><pre class="source-code"><st c="62884">
feature_defs</st></pre><p class="list-inset"><st c="62897">In the following output, we see the names of the </st><span class="No-Break"><st c="62947">created variables:</st></span></p><pre class="source-code"><strong class="bold"><st c="62965">[&lt;Feature: MEAN(data.price)&gt;,</st></strong>
<strong class="bold"><st c="62995">&lt;Feature: MEAN(data.quantity)&gt;,</st></strong>
<strong class="bold"><st c="63026">&lt;Feature: MONTH(first_invoices_time)&gt;,</st></strong>
<strong class="bold"><st c="63064">&lt;Feature: WEEKDAY(first_invoices_time)&gt;,</st></strong>
<strong class="bold"><st c="63104">&lt;Feature: MEAN(invoices.MEAN(data.price))&gt;,</st></strong>
<strong class="bold"><st c="63147">&lt;Feature: MEAN(invoices.MEAN(data.quantity))&gt;,</st></strong>
<strong class="bold"><st c="63193">&lt;Feature: MEAN(data.NUM_WORDS(description))&gt;,</st></strong>
<strong class="bold"><st c="63238">&lt;Feature: MEAN(invoi</st><a id="_idTextAnchor1315"/><st c="63259">ces.MEAN(data.NUM_</st></strong>
<strong class="bold"><st c="63278">    WORDS(description)))&gt;] WORDS(description)))&gt;]</st></strong></pre></li>			</ol>
			<p><st c="63324">Note that in our recipes, we keep the creation of features to a minimum due to space limitations, but you can create as many features as you want and enr</st><a id="_idTextAnchor1316"/><a id="_idTextAnchor1317"/><st c="63478">ich your datasets dramatically with the functionality built </st><span class="No-Break"><st c="63539">into </st></span><span class="No-Break"><strong class="source-inline"><st c="63544">featuretools</st></strong></span><span class="No-Break"><st c="63556">.</st></span></p>
			<h2 id="_idParaDest-274"><a id="_idTextAnchor1318"/><st c="63557">How it works...</st></h2>
			<p><st c="63573">In this recipe, we brought together the creation of features using transform primitives, which we </st><a id="_idIndexMarker748"/><st c="63672">discussed throughout the chapter, with the creation of features using </st><span class="No-Break"><st c="63742">aggregation primitives.</st></span></p>
			<p><st c="63765">To create features with </st><strong class="source-inline"><st c="63790">featuretools</st></strong><st c="63802"> automatically, we first need to enter the data into an entity set and establish the relationships between the data. </st><st c="63919">We discussed how to set up an entity set in the </st><em class="italic"><st c="63967">Setting up an entity set and creating features </st></em><span class="No-Break"><em class="italic"><st c="64014">automatically</st></em></span><span class="No-Break"><st c="64027"> recipe.</st></span></p>
			<p><st c="64035">To aggregate existing features, we used the </st><strong class="source-inline"><st c="64080">dfs</st></strong><st c="64083"> class. </st><st c="64091">We created a list with a string corresponding to the aggregation primitives and passed it to the </st><strong class="source-inline"><st c="64188">agg_primitives</st></strong><st c="64202"> parameter from </st><strong class="source-inline"><st c="64218">dfs</st></strong><st c="64221">. To aggregate existing variables without creating new features, we passed an empty list to the </st><strong class="source-inline"><st c="64317">trans_primitives</st></strong><st c="64333"> parameter </st><span class="No-Break"><st c="64344">of </st></span><span class="No-Break"><strong class="source-inline"><st c="64347">dfs</st></strong></span><span class="No-Break"><st c="64350">.</st></span></p>
			<p><st c="64351">The </st><strong class="source-inline"><st c="64356">customers</st></strong><st c="64365"> DataFrame is the child of the </st><strong class="source-inline"><st c="64396">invoice</st></strong><st c="64403"> DataFrame, which is, in turn, the child of the original data. </st><st c="64466">Thus, </st><strong class="source-inline"><st c="64472">dfs</st></strong><st c="64475"> created aggregations from the original data and the pre-aggregated data for each invoice. </st><st c="64566">Thus, the </st><strong class="source-inline"><st c="64576">MEAN(data.price)</st></strong><st c="64592"> feature consists of the mean price for an item bought by a customer calculated from the entire data, whereas </st><strong class="source-inline"><st c="64702">MEAN(invoices.MEAN(data.price))</st></strong><st c="64733"> calculates the mean price per invoice first and then takes the mean of those values for a customer. </st><st c="64834">Thus, if a customer has five invoices, </st><strong class="source-inline"><st c="64873">featuretools</st></strong><st c="64885"> first calculates the mean price paid for each of those invoices and then takes the mean of those values. </st><st c="64991">As such, </st><strong class="source-inline"><st c="65000">MEAN(data.price)</st></strong><st c="65016"> and </st><strong class="source-inline"><st c="65021">MEAN(invoices.MEAN(data.price))</st></strong><st c="65052"> are not the </st><span class="No-Break"><st c="65065">same feature.</st></span></p>
			<p class="callout-heading"><st c="65078">Note</st></p>
			<p class="callout"><st c="65083">An aggregate primitive aggregates information for a unique identifier. </st><st c="65155">Aggregate primitives use mathematical operations such as the mean, standard deviation, maximum and minimum values, the sum, and the skew coefficient for numerical variables. </st><st c="65329">For categorical variables, aggregate primitives use the mode and the count of unique items. </st><st c="65421">For unique ident</st><a id="_idTextAnchor1319"/><st c="65437">ifiers, aggregate primitives count the number </st><span class="No-Break"><st c="65484">of occurrences.</st></span></p>
			<p><st c="65499">Next, we combined </st><a id="_idIndexMarker749"/><st c="65518">the creation of new features from date and text variables with aggregation. </st><st c="65594">To do this, we passed a list of strings corresponding to the transform primitives to the </st><strong class="source-inline"><st c="65683">trans_primitives</st></strong><st c="65699"> parameter, and another list of strings corresponding to the aggregation primitives to the </st><strong class="source-inline"><st c="65790">agg_primitives</st></strong><st c="65804"> parameter </st><span class="No-Break"><st c="65815">of </st></span><span class="No-Break"><strong class="source-inline"><st c="65818">dfs</st></strong></span><span class="No-Break"><st c="65821">.</st></span></p>
			<p><st c="65822">One of the outputs of </st><em class="italic"><st c="65845">step 13</st></em><st c="65852"> is a list of the new features. </st><st c="65884">From these, we can identify features created from the first invoice date for each customer, such as </st><strong class="source-inline"><st c="65984">MONTH(first_invoices_time)</st></strong><st c="66010"> and </st><strong class="source-inline"><st c="66015">WEEKDAY(first_invoices_time)</st></strong><st c="66043">. We can also see features that were aggregated from features created from text, such as </st><strong class="source-inline"><st c="66132">MEAN(data.NUM_WORDS(description))</st></strong><st c="66165"> and </st><strong class="source-inline"><st c="66170">MEAN(invoices.MEAN(data.NUM_WORDS(description)))</st></strong><st c="66218">. Finally, we can see the aggregations of existing n</st><a id="_idTextAnchor1320"/><a id="_idTextAnchor1321"/><a id="_idTextAnchor1322"/><st c="66270">umerical variables, such as </st><strong class="source-inline"><st c="66299">MEAN(data.price)</st></strong> <span class="No-Break"><st c="66315">and </st></span><span class="No-Break"><strong class="source-inline"><st c="66320">MEAN(invoices.MEAN(data.price))</st></strong></span><span class="No-Break"><st c="66351">.</st></span></p>
			<p class="callout-heading"><st c="66352">Note</st></p>
			<p class="callout"><st c="66357">If you want to apply transform and aggregation primitives to specific variables, you can do so by specifying the primitive options as discussed </st><span class="No-Break"><st c="66502">here: </st></span><a href="https://docs.featuretools.com/en/stable/guides/specifying_primitive_options.html"><span class="No-Break"><st c="66508">https://docs.featuretools.com/en/stable/guides/specifying_primitive_options.html</st></span></a><span class="No-Break"><st c="66588">.</st></span></p>
		</div>
	<div id="charCountTotal" value="66589"/></body></html>