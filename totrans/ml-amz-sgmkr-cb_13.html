<html><head></head><body>
		<div id="_idContainer210">
			<h1 id="_idParaDest-132"><em class="italic"><a id="_idTextAnchor139"/>Chapter 10</em>: Recommender Systems </h1>
			<p>In this chapter, we will learn about what recommender systems are, discuss their various types, and work through a <strong class="bold">DataRobot</strong> implementation of a content-based recommender system. Within this chapter, <strong class="bold">recommender system</strong>, <strong class="bold">recommendation system</strong>, <strong class="bold">recommender engines</strong>, and <strong class="bold">recommendation engines</strong> are used interchangeably. </p>
			<p>In their simplest form, recommender systems suggest potentially relevant items to users or buyers. In today's commercial environment, businesses tend to have numerous items, products, or services for sale, making it more challenging for users or buyers to connect with their desired products or services. This chapter explains the ubiquity of recommendation engines in the current business space. </p>
			<p>Although this book is not the place to cover every aspect of recommendation systems, we will discuss how to utilize DataRobot to build and (make predictions from) recommendation engines and present a conceptual overview of these systems, as well as a brief discussion of their types. Thus, by the end of this chapter, you will learn how to utilize DataRobot to build a content-based recommendation engine. The main topics in this chapter include the following:</p>
			<ul>
				<li>A conceptual introduction to recommender systems</li>
				<li>A<a id="_idTextAnchor140"/>pproaches to building recommender systems</li>
				<li><a id="_idTextAnchor141"/>Defining and setting up recommender systems in DataRobot</li>
				<li><a id="_idTextAnchor142"/>Building recommender systems in DataRobot</li>
				<li><a id="_idTextAnchor143"/><a id="_idTextAnchor144"/>Making recommender system predictions with DataRobot</li>
			</ul>
			<h1 id="_idParaDest-133"><a id="_idTextAnchor145"/>Technical requirements</h1>
			<p>Most parts of this chapter require access to the DataRobot software. The code example is based on a relatively small dataset, Book-Crossing, consisting of three tables, whose manipulation was carried out with <strong class="bold">Jupyter Notebook</strong>.</p>
			<p>Check out the following video to see the Code in Action at <a href="https://bit.ly/3HxcNUL">https://bit.ly/3HxcNUL</a>.</p>
			<h2 id="_idParaDest-134"><a id="_idTextAnchor146"/>Book-Crossing dataset</h2>
			<p>The example<a id="_idIndexMarker469"/> used to illustrate the use of DataRobot in building recommendation systems is based on the Book-Crossing dataset by Cai-Nicolas Ziegler and colleagues. This dataset was accessed at <a href="http://www2.informatik.uni-freiburg.de/~cziegler/BX/">http://www2.informatik.uni-freiburg.de/~cziegler/BX/</a>. <a id="_idTextAnchor147"/></p>
			<p class="callout-heading">Note</p>
			<p class="callout">Before using this dataset, the authors of this book have informed the owner of the dataset about its use in this book. </p>
			<p class="callout">Cai-Nicolas Ziegler, Sean M. McNee, Joseph A. Konstan, Georg Lausen (2005). <em class="italic">Improving Recommendation Lists Through Topic Diversification. Proceedings of the 14th International World Wide Web Conference (WWW '05)</em>. May 10 – 14, 2005, Chiba, Japan.</p>
			<p>The data was collected during a four-week collection of the Book-Crossing community between August and September 2004. The subsequent three tables, provided in CSV format, make up this dataset. </p>
			<ul>
				<li><strong class="bold">Users</strong>: This <a id="_idIndexMarker470"/>table presents the profile of the users, with an anonymized <strong class="source-inline">User-ID</strong> presented as integers. Also provided are the users' <strong class="source-inline">Location</strong> and <strong class="source-inline">Age</strong> values.</li>
				<li><strong class="bold">Books</strong>: This <a id="_idIndexMarker471"/>table contains the characteristics of the books. Its features include <strong class="source-inline">ISBM</strong>, <strong class="source-inline">Book-Title</strong>, <strong class="source-inline">Book-Author</strong>, <strong class="source-inline">Year-Of-Publication</strong>, <strong class="source-inline">Publisher</strong>.</li>
				<li><strong class="bold">Ratings</strong>: This<a id="_idIndexMarker472"/> table shows the book ratings. Each row provides a user's rating for a book. The <strong class="source-inline">Book-Rating</strong> value is either implicit as <strong class="source-inline">0</strong> or explicit between <strong class="source-inline">1</strong> and <strong class="source-inline">10</strong> (the higher the number, the better the rating). However, within the context of this project, we will focus solely on ratings that are explicit for the model development. The table also includes the <strong class="source-inline">User-ID</strong> and <strong class="source-inline">ISBN</strong> values.</li>
			</ul>
			<h1 id="_idParaDest-135"><a id="_idTextAnchor148"/>A conceptual introduction to recommender systems</h1>
			<p>Businesses have a long-standing history of recommending their products or services to customers. For instance, walk into a bookshop and you are likely to see a list of popular books bought by other customers. This is a simple kind of recommendation system, as it gives buyers a snapshot of potential products to purchase.</p>
			<p>In a bid to win in the<a id="_idIndexMarker473"/> digital economy, businesses are becoming increasingly customer-centric. <strong class="bold">Customer centricity</strong> implies that companies aim to put the needs of the<a id="_idIndexMarker474"/> customer first. Still, with the needs of customers being as diverse as the customers themselves, businesses need to take a unique approach in putting forward their products. This explains, in part, the failings of <strong class="bold">popularity-based recommendation systems</strong>, as they fail to consider the unique<a id="_idIndexMarker475"/> profiles of buyers. As such, with growing digitalization, increased business offerings, and a growing diversity of customers' needs, this approach is unlikely to win. </p>
			<p>Interestingly, data science tools can offer a number of approaches to make recommender systems more intelligent by considering the needs of the buyers in a variety of ways.</p>
			<p>In presenting the different types of recommender systems, we will continue to use the bookshop example.</p>
			<p>First, the <strong class="bold">item-based collaborative filtering</strong> approach<a id="_idIndexMarker476"/> to recommendation systems makes product suggestions to book buyers based on the buyer's product purchase history and how those <em class="italic">products</em> relate to others. As such, if an individual bought <em class="italic">Book A</em>, and <em class="italic">Book A</em> is linked to <em class="italic">Book B</em>, then <em class="italic">Book B</em> is suggested. The second approach, <strong class="bold">user-based collaborative filtering</strong>, considers<a id="_idIndexMarker477"/> similarities between <em class="italic">buyers</em> when making suggestions. As such, if <em class="italic">Buyer A</em> is similar to <em class="italic">Buyer B</em>, and <em class="italic">Buyer A</em> buys <em class="italic">Book C</em>, then <em class="italic">Book C</em> would <a id="_idIndexMarker478"/>be recommended to <em class="italic">Buyer B</em>. The third approach, <strong class="bold">content-based recommendation</strong>, takes into account both the book and user characteristics in making suggestions. Finally, the <strong class="bold">hybrid system</strong> approach<a id="_idIndexMarker479"/> uses a combination of collaborative-based and content-based methods in making recommendations. It is easy to see that both of these methods come with strengths and weaknesses. We will now take a deeper look at these approaches and how DataRobot can be used to build a content-based recommendati<a id="_idTextAnchor149"/>on system.</p>
			<h1 id="_idParaDest-136"><a id="_idTextAnchor150"/>Approaches to building recommender systems</h1>
			<p>Recommender systems <a id="_idIndexMarker480"/>aim to suggest relevant <a id="_idIndexMarker481"/>products to buyers. Because of their ability to consider the uniqueness of buyers, intelligent recommender engines have generated billions of dollars for businesses and helped buyers find relevant products. They represent a win-win for both consumers and businesses. Various data-driven approaches to creating intelligent recommendation systems have been introduced. There are three major approaches to recommendation systems: collaborative filtering systems, content-based systems, and hybrid systems. Let's discuss each of these approaches in the following sub-sections.</p>
			<h2 id="_idParaDest-137"><a id="_idTextAnchor151"/>Collaborative filtering recommender systems</h2>
			<p>The core idea behind <a id="_idIndexMarker482"/>collaborative filtering<a id="_idIndexMarker483"/> recommender systems is leveraging past actions by others to infer what an individual might be interested in. Collaborative filtering approaches draw on data stores of the historic interaction between products and users. <em class="italic">Table 10.1</em> presents an interaction matrix of users rating books. Each user rated a book with a number between 1 and 5, with 5 representing the highest level of enjoyment. Where there are no ratings, the individual is assumed not to have read the book. There are two broad types of collaborative filtering: <em class="italic">item-based</em> collaborative and <em class="italic">user-based</em> collaborative filtering. </p>
			<div>
				<div id="_idContainer200" class="IMG---Figure">
					<img src="image/Figure_10.01_B17159.jpg" alt="Table 10.1 – User/product interaction matrix&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Table 10.1 – User/product interaction matrix</p>
			<p><em class="italic">Item-based collaborative filtering</em> systems (or <strong class="bold">item-to-item collaborative algorithms</strong>) find similarities<a id="_idIndexMarker484"/> between items and base their recommendations on these similarities. This approach is grounded in suggesting items to individuals based on <a id="_idIndexMarker485"/>how similar items are to the ones these individuals previously enjoyed or bought. Drawing on <em class="italic">Table 10.1</em>, an<a id="_idIndexMarker486"/> item-based filtering approach would easily see that <em class="italic">Book C</em> and <em class="italic">Book E</em> are rated in a similar way by previous readers. Based on this item relationship, if an individual rates <em class="italic">Book C</em> highly, a recommendation of <em class="italic">Book E</em> is made and vice versa. So, since <em class="italic">User 5</em> highly rated <em class="italic">Book E</em> and has not seen <em class="italic">Book C</em>, a recommendation of <em class="italic">Book C</em> is put forward, as there is a high likelihood of them liking <em class="italic">Book C</em>.</p>
			<p>With <em class="italic">user-based collaborative filtering</em> systems, similarities are found between <em class="italic">users</em>, and recommendations are based on these. <strong class="bold">User-to-user collaborative algorithms</strong> aim to find users with similar behavior<a id="_idIndexMarker487"/> or who are in the same behavioral neighborhood, as established by their historic actions. The algorithm then considers what their preferences are and makes recommendations. The core idea of these recommendation systems is the assumption that if individuals <em class="italic">are</em> alike, <em class="italic">what</em> they like will be similar. From <em class="italic">Table 10.1</em>, it could be inferred that <em class="italic">User 2</em> and <em class="italic">User 4</em> have similar book interests. Because <em class="italic">User 4</em> has rated <em class="italic">Book D</em> highly, the likelihood of <em class="italic">User 2</em> liking <em class="italic">Book D</em> is considered high and therefore recommended. As we can see, both collaborative filtering approaches are based on the idea of <em class="italic">similarities</em>. </p>
			<p>Similarity metrics offer a basis for recommendations to be made. There are several similarity metrics, with<a id="_idIndexMarker488"/> the <strong class="bold">Pearson correlation coefficient</strong> and <strong class="bold">Cosine similarity</strong> being among the most popular. Others have approached this <a id="_idIndexMarker489"/>measurement of similarity drawing on <em class="italic">neighborhoods</em>. The <strong class="bold">K-nearest neighbors</strong> algorithm<a id="_idIndexMarker490"/> is utilized to find the nearest items or users to the one being recommended or recommended to, respectively.</p>
			<p>Because the <a id="_idIndexMarker491"/>interaction dataset is easily acquired, building <a id="_idIndexMarker492"/>collaborative filtering is considerably easier than content-based systems, as will be discussed in the next sections. However, the collaborative approach to recommendation systems has a few shortcomings. Within the context of <em class="italic">Table 10.1</em>, a new user, <em class="italic">User 6</em>, is introduced with no history. It is easy to see that the collaborative filtering system will struggle to make recommendations to this user. The problem is similar for an item without historic data. This problem, otherwise known as<a id="_idIndexMarker493"/> the <strong class="bold">cold start</strong> problem, is well documented. <strong class="bold">Data sparsity</strong> is<a id="_idIndexMarker494"/> another problem commonly associated with collaborative filtering. Most platforms and large businesses have buyers and products. Still, the most active users would only buy a fraction of the available products. As such, there is a gap in the data needed to meaningfully compute the similarities when powering these engines.</p>
			<h2 id="_idParaDest-138"><a id="_idTextAnchor152"/>Content-based recommender systems</h2>
			<p><em class="italic">Content-based recommender</em> systems make suggestions based on the item characteristics and user <a id="_idIndexMarker495"/>profiles. This approach has a <a id="_idIndexMarker496"/>different type of data structure underpinning it. Content-based systems are <strong class="bold">machine learning</strong> (<strong class="bold">ML</strong>) models, built by leveraging historic datasets consisting of item descriptions, user profiles, and user preferences. Some writers differentiate content-based recommender systems from <em class="italic">demographic</em> systems, but here, we consider demographic information as part of the profile of the user. In the case of buying, this classification model is used to predict the likelihood of users liking an item. Within the context of a books recommendation system, every book needs to be associated with its description, which could include its genre, cover, number of pages, size, and publisher, while information regarding the user could include their location, profession, age, and marital status. As illustrated in <em class="italic">Table 10.2</em>, the users' ratings come in addition to these. In this case, because the rating is represented by a value between <strong class="source-inline">1</strong> and <strong class="source-inline">5</strong>, the model is regression-based, as it predicts an interval variable. This model becomes a content-based recommendation engine.</p>
			<p>From the preceding discussion, we can see that a content-based system can easily mitigate the cold start problem, as books and users are likely to have some forms of descriptions. In comparison to collaborative filtering systems, content-based systems are more scalable, as in the production environment, predictions can easily be made when needed, rather than having to make predictions for all users and products at the same time. Importantly, even when users only rate or buy a few products, content-based systems will still perform well, as they focus on the descriptions and not necessarily the users or products. That said, most content-based systems struggle when the characteristics of the items are not readily available. Within certain contexts, it could be challenging to generate attributes for a product (for instance, if the product is or has images or sounds). In cases <a id="_idIndexMarker497"/>of this nature, content-based systems will <a id="_idIndexMarker498"/>have no descriptions to analyze. Additionally, demographic information of users might not be readily available due to growing online privacy concerns. The limitations of both the collaborative filtering and content-based approaches to recommendation gave rise to the use of hybrid systems.</p>
			<h2 id="_idParaDest-139"><a id="_idTextAnchor153"/>Hybrid recommender systems</h2>
			<p><em class="italic">Hybrid recommender systems</em> are<a id="_idIndexMarker499"/> an integrated approach to<a id="_idIndexMarker500"/> recommendation systems. Hybrid systems generate recommendations to users by leveraging a combination of two or more recommendation strategies. By doing so, they mitigate the limitations attributed to either of the strategies, thereby benefiting from <em class="italic">the wisdom of the many</em>. </p>
			<p>There are several approaches to<a id="_idIndexMarker501"/> hybrid systems. The most commonly used (and the easiest to implement) is the <strong class="bold">weighted approach</strong>. Here, scores from independent recommendation systems are aggregated to give an overall recommendation score. Aggregation methods vary and can include basic averaging, applying rules, and using linear functions. The <strong class="bold">staged approach</strong> could <a id="_idIndexMarker502"/>also be deployed. This typically involves the recommendation systems' results being integrated as input features in another recommendation system. As such, the output of the <em class="italic">Stage 1</em> system becomes an additional input for the <em class="italic">Stage 2</em> system. The <strong class="bold">switching approach</strong> involves<a id="_idIndexMarker503"/> using a rule to switch between different recommendation systems to capitalize on their advantages in a given context. For instance, if collaborative filtering is seen to give better results, a switch regime could use the collaborative filtering approach, but when there is a cold start, it could change to the content-based approach. An advantage the hybrid system has <a id="_idIndexMarker504"/>over content-based systems is the ability<a id="_idIndexMarker505"/> to develop recommendations when item features are difficult to establish. As will be demonstrated in <a href="B17159_11_Final_NM_ePub.xhtml#_idTextAnchor161"><em class="italic">Chapter 11</em></a>, <em class="italic">Working with Geospatial Data, NLP, and Image Processing</em>, DataRobot has advanced feature extraction capabilities for images and text data.  </p>
			<h1 id="_idParaDest-140"><a id="_idTextAnchor154"/>Defining and setting up recommender systems in DataRobot</h1>
			<p>DataRobot, due to its ability to extract features from images, audio, and text data, effectively manages the<a id="_idIndexMarker506"/> feature availability limitation of the <a id="_idIndexMarker507"/>content-based <a id="_idIndexMarker508"/>recommender systems. This, in addition<a id="_idIndexMarker509"/> to DataRobot's automated ML models' processes, means it is well positioned to leverage the advantages of the content-based approach while compensating for the feature-unavailability limitation of this approach. As described in the <em class="italic">Technical requirements</em> section, the dataset used for our example consists of three tables. This includes the user table (presenting profiles of the users), the book table (outlining characteristics of the books), and the rating table (containing user book ratings). Since we have one table describing the books, and another, the users, integrating these and the ratings sets the scene for the content-based recommender system. To do this, we employed Jupyter Notebook. <em class="italic">Figure 10.1</em> presents the script we ran to ingest the dataset, manipulate it, merge the tables, and write it back as a CSV file:</p>
			<p class="figure-caption"> </p>
			<div>
				<div id="_idContainer201" class="IMG---Figure">
					<img src="image/Figure_10.02_B17159.jpg" alt="Figure 10.1 – Data manipulations in Jupyter Notebook&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.1 – Data manipulations in Jupyter Notebook</p>
			<p>Rows on the<a id="_idIndexMarker510"/> rating table where <strong class="source-inline">rating</strong> had a value<a id="_idIndexMarker511"/> of <strong class="source-inline">0</strong> were excluded, as the ratings were<a id="_idIndexMarker512"/> implicit. These rows will be<a id="_idIndexMarker513"/> used to demonstrate how to make predictions with recommendation engines in the <em class="italic">Making recommender system predictions with DataRobot</em> section. Having manipulated the tables by changing their headings, as well as consolidating the <strong class="source-inline">ratings</strong>, <strong class="source-inline">books</strong>, and <strong class="source-inline">users</strong> values into a table, each row has the description of a user and a book, and also a rating. A snapshot of the data is shown in <em class="italic">Table 10.2</em>. Although we could create the DataRobot project in Jupyter Notebook using the Python API method (as will be illustrated in <a href="B17159_12_Final_NM_ePub.xhtml#_idTextAnchor176"><em class="italic">Chapter 12</em></a>, <em class="italic">DataRobot Python API</em>) for consistency, we downloaded the data as a file: <strong class="source-inline">rating.csv</strong>.</p>
			<div>
				<div id="_idContainer202" class="IMG---Figure">
					<img src="image/Figure_10.03_B17159.jpg" alt="Table 10.2 – Data snapshot&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Table 10.2 – Data snapshot</p>
			<p>Following the<a id="_idIndexMarker514"/> process established in <a href="B17159_06_Final_NM_ePub.xhtml#_idTextAnchor104"><em class="italic">Chapter 6</em></a>, <em class="italic">Model Building with DataRobot</em>, we created a DataRobot project for the recommender system. When<a id="_idIndexMarker515"/> doing this, we drag the <strong class="source-inline">rating.csv</strong> file<a id="_idIndexMarker516"/> into the initial project window. This <a id="_idIndexMarker517"/>opens up the window shown in <em class="italic">Figure 10.2</em>. For each row, since the book rating is used as an indicator of the user's interest, it can be used as the target variable. Due to the nature of the target variable, <strong class="source-inline">ratings</strong>, the ML models for this recommender system will be of the regression models type. </p>
			<div>
				<div id="_idContainer203" class="IMG---Figure">
					<img src="image/Figure_10.04_B17159.jpg" alt="Figure 10.2 – DataRobot project initiation window &#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.2 – DataRobot project initiation window </p>
			<p>As expected, ratings <a id="_idIndexMarker518"/>made are the range of <strong class="source-inline">1</strong> to <strong class="source-inline">10</strong>. Ideally, we <a id="_idIndexMarker519"/>will drop the rows with implicit<a id="_idIndexMarker520"/> ratings (of <strong class="source-inline">0</strong>) and <strong class="source-inline">user_ID</strong> fields <a id="_idIndexMarker521"/>to create a robust dataset for modeling. The next thing to do is build the recommender system's ML models.</p>
			<h1 id="_idParaDest-141"><a id="_idTextAnchor155"/>Building recommender systems in DataRobot</h1>
			<p>One of <a id="_idIndexMarker522"/>the strengths of driverless <strong class="bold">artificial intelligence</strong> (<strong class="bold">AI</strong>) platforms <a id="_idIndexMarker523"/>such as DataRobot lies in their simplification of the data science model-building process. Given the similarity of the content-based recommendation model-building process to the typical ML one, DataRobot's ML capabilities could be leveraged in building these systems. Having set up the data (as detailed in the previous section), click on <strong class="bold">Start</strong> (<em class="italic">Figure 10.2</em>) to commence the modeling process. To avoid over-optimistic model performance which fails to generalize where users provide more than one ratings for items, it might be useful to partition the rating according to the users. To do this, within the <strong class="bold">Advanced options</strong> window, open the <strong class="bold">Group</strong> tab and enter <strong class="source-inline">user_id</strong> in the <strong class="bold">Group ID Feature</strong> field.</p>
			<p>As detailed in <a href="B17159_06_Final_NM_ePub.xhtml#_idTextAnchor104"><em class="italic">Chapter 6</em></a>, <em class="italic">Model Building with DataRobot</em>, DataRobot commences the development of ML models when the <strong class="bold">Start</strong> button is clicked. However, with recommender systems, the DataRobot's present strong prediction accuracy as the platform benefits from cutting-edge technological advances in developing models. Recommendation<a id="_idIndexMarker524"/> datasets pose difficulties for modeling <a id="_idIndexMarker525"/>because of their high data sparsity and dimensions. The DataRobot's models exploit higher-order combinatorial features learned from the input data. Though some of these models will not run automatically when the <strong class="bold">Start</strong> button is clicked, they can be accessed in the <strong class="bold">Repository</strong> tab. Because these models are based on <a id="_idIndexMarker526"/>the <strong class="bold">Keras</strong> neural network, they use a training schedule in their development. So, they can easily be found by entering <strong class="source-inline">Training Schedule</strong> or simply <strong class="source-inline">Training</strong> in the search field in the model <strong class="bold">Repository</strong> tab during model creation. This will bring up a list of relevant models (see <em class="italic">Figure 10.3</em>):</p>
			<div>
				<div id="_idContainer204" class="IMG---Figure">
					<img src="image/Figure_10.05_B17159.jpg" alt="Figure 10.3 – Selecting the advanced modeling approaches most suitable for recommender systems&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.3 – Selecting the advanced modeling approaches most suitable for recommender systems</p>
			<p>In addition to<a id="_idIndexMarker527"/> selecting these modeling methods to be<a id="_idIndexMarker528"/> included in the list of models to be created, the models' <strong class="bold">Sample Size</strong>, <strong class="bold">Cross Validation runs</strong>, and <strong class="bold">Feature List</strong> options are to be set For the current project, we selected 16% of the sample size (which snaps to <strong class="source-inline">Autopilot Stage 1</strong>) based on the <strong class="source-inline">Informative Features</strong>, and then carried out all five <strong class="source-inline">Cross Validation</strong> runs. A final click on <strong class="bold">Run Tasks</strong> includes these in the processing queue. </p>
			<p>After the models have been created, the next step is to evaluate them in terms of their accuracy. Prior to this, it is important to examine the <strong class="bold">Relative Importance</strong> chart to check if our model aligns with common sense. As is apparent in <em class="italic">Figure 10.4</em>, opening the <strong class="bold">Variable Importance</strong> window through the <strong class="bold">Insight</strong> window offers us the opportunity to explore these models:</p>
			<div>
				<div id="_idContainer205" class="IMG---Figure">
					<img src="image/Figure_10.06_B17159.jpg" alt="Figure 10.4 – Variable importance&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.4 – Variable importance</p>
			<p>The values next to <strong class="bold">Scores based on Text feature (location)</strong> and <strong class="bold">Scores based on Text feature (title)</strong> suggest that the model performance is significantly informed by a person field and an item field. Models that capitalize on the learned creation of higher-order variables excel in these situations. This is because they generate higher-order variables that <a id="_idIndexMarker529"/>are interactions between the <a id="_idIndexMarker530"/>person-specific and item-specific features, drawing on learning from the data. As a result, in the preceding case, a feature that combines the presence of an aspect of a location (for example, <strong class="source-inline">London</strong>) and an aspect of the title (for example, <strong class="source-inline">Kingdom</strong>) could be interpreted as influential to the model. So, in this simplified example, a higher-order feature that is an interaction between <strong class="source-inline">London</strong> and <strong class="source-inline">Kingdom</strong> is created. The rating predictions consequently change considerably depending on the presence of this newly created higher-order feature. </p>
			<p>In model selection, using the <a id="_idIndexMarker531"/>definite <strong class="bold">root mean squared error</strong> (<strong class="bold">RMSE</strong>) evaluation metrics, we see that <strong class="source-inline">Keras Slim Residual Neural Network Regressor using Adaptive Training Schedule (1 Layer: 64 Units)</strong> is the best-performing model (see <em class="italic">Figure 10.5</em>). It is important to highlight that measuring the accuracy of models for recommendation systems in some contexts is not as straightforward. Imagine that in this case, we could only have a rating of <strong class="source-inline">1</strong> when an individual buys a book, and otherwise it would be <strong class="source-inline">0</strong>. Naively measuring how accurate the model is becomes limited, as a <strong class="source-inline">0</strong> rating does not necessarily imply that an individual is not interested in an item. This is because it is possible that the individual has never read the book. Because a good recommender system will recommend items whose characteristics align with an individual's profile as a potential book to read that are unread, it is likely to have a significant proportion of false positives. This is because, although their current rating is <strong class="source-inline">0</strong>, the user in question will most likely be interested in reading them. In cases like these, the <strong class="bold">Recall</strong> type becomes a more important metric in evaluating the model performance. Given that we are only certain of cases where individuals buy items, it is reasonable to evaluate those cases in isolation. Therefore, the extent to which <a id="_idIndexMarker532"/>the model accuracy predicts books <a id="_idIndexMarker533"/>that are read correctly, usually referred to as the <strong class="bold">Recall</strong>, becomes a more suitable metric. </p>
			<div>
				<div id="_idContainer206" class="IMG---Figure">
					<img src="image/Figure_10.07_B17159.jpg" alt="Figure 10.5 – Leaderboard tab for recommendation systems&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.5 – Leaderboard tab for recommendation systems</p>
			<p>For a recommendation system, accuracy and prediction speed is very important to consider when deciding which model to use. To ground this discussion, it is important to understand that there are two major approaches to making predictions with recommendation systems. The first approach is a batch scoring of combinations of users by items, where items are yet to be read by the user. This dataset becomes larger exponentially as items and users increase. The second approach is a <em class="italic">real-time prediction</em>. For instance, imagine an individual arrives at an e-commerce platform. That individual's data with those of the products is rapidly scored and suggestions are scored nearly instantly. In both cases, the speed of the prediction is pivotal for commercial success. The DataRobot <strong class="bold">Speed vs Accuracy</strong> chart offers some support in analyzing speed and accuracy for recommendation systems. As seen in <em class="italic">Figure 10.6</em>, the RMSE metric for that <strong class="source-inline">Keras Slim Residual Neural Network Regressor using Adaptive Training Schedule (1 Layer: 64 Units)</strong> is <strong class="source-inline">1.6746</strong>, and its prediction speed is <strong class="source-inline">35.57</strong> ms per every 1,000 predictions. The validation scores<a id="_idIndexMarker534"/> for some blender models appear better, but<a id="_idIndexMarker535"/> these are much weaker in terms of the speed of prediction.</p>
			<div>
				<div id="_idContainer207" class="IMG---Figure">
					<img src="image/Figure_10.08_B17159.jpg" alt="Figure 10.6 – DataRobots' Speed vs Accuracy chart&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.6 – DataRobots' Speed vs Accuracy chart</p>
			<p>This suggests that though it is very accurate, this model is very slow in making predictions. The <strong class="bold">Speed vs Accuracy</strong> chart presents a snapshot visualization of several models' speed and accuracy. A more in-depth pairwise comparison can be carried out<a id="_idIndexMarker536"/> using the <strong class="bold">Model Comparison</strong> tool. To<a id="_idIndexMarker537"/> continue the discussion of prediction, we will now tu<a id="_idTextAnchor156"/><a id="_idTextAnchor157"/><a id="_idTextAnchor158"/>rn to making recommendation system predictions in DataRobot.</p>
			<h1 id="_idParaDest-142"><a id="_idTextAnchor159"/>Making recommender system predictions with DataRobot</h1>
			<p>Creating<a id="_idIndexMarker538"/> suggestions from<a id="_idIndexMarker539"/> recommendation engines on DataRobot is straightforward. We use the drag and drop approach (as discussed in earlier chapters), as our prediction dataset is only small. With larger datasets (over 1 GB), as is more typical for recommender systems, using the DataRobot prediction API is advised. The API approach to creating models and making predictions is covered in depth in <a href="B17159_12_Final_NM_ePub.xhtml#_idTextAnchor176"><em class="italic">Chapter 12</em></a>, <em class="italic">DataRobot Python API</em>. </p>
			<p>Our prediction dataset for our example is 64 MB in size, and so the drag and drop approach is appropriate. For this prediction approach, we specify the columns we want to use from the original dataset. Ideally, we at least need an identifier for the item and user. As illustrated in <em class="italic">Figure 10.7</em>, we have chosen to include the <strong class="source-inline">ISBN</strong>, <strong class="source-inline">user_id</strong>, and <strong class="source-inline">title</strong> fields in our predictions. We drag and drop the prediction dataset into the specified region. As usual, this dataset is quickly evaluated, and we are presented with the <strong class="bold">Run external test</strong> or <strong class="bold">Compute prediction</strong> options.</p>
			<div>
				<div id="_idContainer208" class="IMG---Figure">
					<img src="image/Figure_10.09_B17159.jpg" alt="Figure 10.7 – A recommendation engine prediction setup&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.7 – A recommendation engine prediction setup</p>
			<p>At this point, we<a id="_idIndexMarker540"/> click on <strong class="bold">Compute predictions</strong> to commence the prediction process. Following the completion of the prediction<a id="_idIndexMarker541"/> process, the predictions are downloaded as a <strong class="source-inline">.csv</strong> file (see <em class="italic">Table 10.3</em>). As noted previously, the prediction set is drawn from the original dataset where the ratings were implicit (so the rating score was zero). Thus, the prediction dataset has only a limited sample of the possible person-item interactions. Some users (for instance, the user with <strong class="source-inline">8</strong> as  <strong class="source-inline">user_id</strong>), have about <strong class="source-inline">10</strong> items scored, while some have only <strong class="source-inline">1</strong> item scored. In an ideal situation, all items not seen by an individual would be rated. That said, suggestions served to the user are then made in order of predicted interests. For user <strong class="source-inline">8</strong>, the book titled <strong class="source-inline">A Second Chicken Soup for the Woman's Soul (Chicken Soup for the Soul Series)</strong> is served first. In some cases, the top <em class="italic">n</em> recommendations is used. By top <em class="italic">n</em> in our book case, we mean, for each user the top <em class="italic">n</em> books are selected based on their prediction values.</p>
			<div>
				<div id="_idContainer209" class="IMG---Figure">
					<img src="image/Figure_10.10_B17159.jpg" alt=" Table 10.3 – A recommendation engine sample prediction&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption"> Table 10.3 – A recommendation engine sample prediction</p>
			<p>The selected model can be deployed<a id="_idIndexMarker542"/> as a <strong class="bold">REST</strong> API using DataRobot, as shown in <a href="B17159_08_Final_NM_ePub.xhtml#_idTextAnchor116"><em class="italic">Chapter 8</em></a>, <em class="italic">Model Scoring and Deployment</em>, and then the data can be scored via the DataRobot API call (which we will discuss in <a href="B17159_12_Final_NM_ePub.xhtml#_idTextAnchor176"><em class="italic">Chapter 12</em></a>, <em class="italic">DataRobot Python API</em>). Some DataRobot models can<a id="_idIndexMarker543"/> be downloaded as <strong class="bold">JAR</strong> files, which <a id="_idIndexMarker544"/>can be integrated with other applications<a id="_idIndexMarker545"/> to make real-time predictions. Elsewhere, a batch prediction can be made using different person-item interactions, before<a id="_idIndexMarker546"/> being stored in a big data storage table, such as <strong class="bold">Google Cloud BigQuery</strong>. </p>
			<h1 id="_idParaDest-143"><a id="_idTextAnchor160"/>Summary</h1>
			<p>In this chapter, we introduced and appraised different approaches to recommendation systems. We examined the data structure requirements for content-based and collaborative filtering recommendation systems, and we discussed their underlining assumptions. We then point out the strengths of DataRobot in extracting features from challenging data types (for instance, image data) that normally limit the use of content-based systems. We then illustrated the use of DataRobot in building and making predictions using a content-based recommender system based on a small dataset. </p>
			<p>It is important to highlight that the dataset used for this project was made up of multiple data types. DataRobot is capable of extracting features and integrating different data types to create ML models. In the next chapter, we will explore how to use datasets with a combination of image, text, and location data when creating ML models. </p>
		</div>
	</body></html>