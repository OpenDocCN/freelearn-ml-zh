["```py\nimport numpy as np\n\nimport matplotlib\nimport matplotlib.pyplot as plt\n\n%matplotlib inline\n```", "```py\nsamples=np.array([[1,2],[12,2],[0,1],[10,0],[9,1],[8,2],[0,10],[1,8],[2,9],[9,9],[10,8],[8,9] ], dtype=np.float)\ncenters=np.array([[3,2], [2,6], [9,3], [7,6]], dtype=np.float)\nN=len(samples)\n```", "```py\n        fig, ax = plt.subplots()\n        ax.scatter(samples.transpose()[0], samples.transpose()[1], marker = \n        'o', s = 100 )\n        ax.scatter(centers.transpose()[0], centers.transpose()[1], marker = \n        's', s = 100, color='black')\n        plt.plot()\n```", "```py\n    def distance (sample, centroids):\n        distances=np.zeros(len(centroids))\n        for i in range(0,len(centroids)):\n            dist=np.sqrt(sum(pow(np.subtract(sample,centroids[i]),2)))\n            distances[i]=dist\n        return distances\n```", "```py\n    def showcurrentstatus (samples, centers, clusters, plotnumber):\n        plt.subplot(620+plotnumber)\n        plt.scatter(samples.transpose()[0], samples.transpose()[1], marker = \n        'o', s = 150 , c=clusters)\n        plt.scatter(centers.transpose()[0], centers.transpose()[1], marker = \n        's', s = 100, color='black')\n        plt.plot()\n```", "```py\n    def kmeans(centroids, samples, K, plotresults):\n        plt.figure(figsize=(20,20))\n        distances=np.zeros((N,K))\n        new_centroids=np.zeros((K, 2))\n        final_centroids=np.zeros((K, 2))\n        clusters=np.zeros(len(samples), np.int)\n\n        for i in range(0,len(samples)):\n            distances[i] = distance(samples[i], centroids)\n            clusters[i] = np.argmin(distances[i])\n            new_centroids[clusters[i]] += samples[i]        \n            divisor = np.bincount(clusters).astype(np.float)\n            divisor.resize([K])\n            for j in range(0,K):\n            final_centroids[j] = np.nan_to_num(np.divide(new_centroids[j] , \n            divisor[j]))\n            if (i>3 and plotresults==True):\n                showcurrentstatus(samples[:i], final_centroids, \n                clusters[:i], i-3)\n            return final_centroids\n```", "```py\n    finalcenters=kmeans (centers, samples, 4, True)\n```", "```py\n    import numpy as np\n\n    import matplotlib\n    import matplotlib.pyplot as plt\n\n    from sklearn.datasets.samples_generator import make_blobs\n    %matplotlib inline\n```", "```py\n    data, features = make_blobs(n_samples=100, n_features = 2, centers=4, \n    shuffle=True, cluster_std=0.8)\n    fig, ax = plt.subplots()\n    ax.scatter(data.transpose()[0], data.transpose()[1], c=features,marker = \n    'o', s = 100 )\n    pl\n```", "```py\n    def distance (sample, data):\n        distances=np.zeros(len(data))\n        for i in range(0,len(data)):\n            dist=np.sqrt(sum(pow(np.subtract(sample,data[i]),2)))\n            distances[i]=dist\n        return distances\n```", "```py\n    def add_sample(newsample, data, features):\n        distances=np.zeros((len(data),len(data[0])))\n        #calculate the distance of the new sample and the current data\n        distances = distance(newsample, data)\n        closestneighbors = np.argpartition(distances, 3)[:3]\n        closestgroups=features[closestneighbors]\n        return np.argmax(np.bincount(closestgroups))\n```", "```py\n    def knn (newdata, data, features):\n        for i in newdata:\n            test=add_sample (i, data, features);\n            features=np.append(features, [test],axis=0)\n            data=np.append(data, [i],axis=0)\n        return data,features\n```", "```py\n        newsamples=np.random.rand(20,2)*20-8.\n    >    finaldata, finalfeatures=knn (newsamples, data, features)\n```", "```py\n    fig, ax = plt.subplots()\n    ax.scatter(finaldata.transpose()[0], finaldata.transpose()[1], \n    c=finalfeatures,marker = 'o', s = 100 )\n    ax.scatter(newsamples.transpose()[0], newsamples.transpose()\n    [1],c='none',marker =  \n    's', s = 100 )\n    plt.plot()\n```"]