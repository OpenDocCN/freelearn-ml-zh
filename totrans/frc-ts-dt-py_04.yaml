- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Handling Non-Daily Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When Prophet was first released, it was assumed all data would be collected
    on a daily scale, with one row of data per day. It has since grown to handle many
    different granularities of data, but because of its historical conventions, there
    are a few things to be cautious of when working with non-daily data in Prophet.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will look at monthly data (and in fact, this is applicable
    to any data that is measured in timeframes greater than a day) and see how to
    change the frequency of predictions to avoid unexpected results. You will also
    look at hourly data and observe an additional component in the components plot.
    Finally, you will learn how to handle data that has regular gaps along the time
    axis.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Using monthly data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using sub-daily data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using data with regular gaps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The data files and code for examples in this chapter can be found at [https://github.com/PacktPublishing/Forecasting-Time-Series-Data-with-Prophet-Second-Edition](https://github.com/PacktPublishing/Forecasting-Time-Series-Data-with-Prophet-Second-Edition).
  prefs: []
  type: TYPE_NORMAL
- en: Please refer to the *Preface* of this book for the technical requirements necessary
    to run the code examples.
  prefs: []
  type: TYPE_NORMAL
- en: Using monthly data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 2*](B19630_02.xhtml#_idTextAnchor104), *Getting Started with Prophet*,
    we built our first Prophet model using the `Mauna Loa` dataset. The data was reported
    daily, which is what Prophet expects by default and is therefore why we did not
    need to change any of Prophet’s default parameters. In this next example, though,
    let’s take a look at a new set of data that is not reported every day, the `Air
    Passengers` dataset, to see how Prophet handles this difference in data granularity.
  prefs: []
  type: TYPE_NORMAL
- en: This is a classic time series dataset spanning 1949 through 1960\. It counts
    the number of passengers on commercial airlines each month during that period
    of explosive growth in the industry. The `Air Passengers` dataset, in contrast
    to the Mauna Loa dataset, has one observation per month. What happens if we attempt
    to predict future dates?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a model and plot the forecast to see what happens. We begin as
    we did with the Mauna Loa example, by importing the necessary libraries and loading
    our data into a properly formatted DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Before building our model, let’s just take a look at the first few rows to
    ensure that our DataFrame looks as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You should now see this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – The Air Passengers DataFrame](img/Fig_4.1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – The Air Passengers DataFrame
  prefs: []
  type: TYPE_NORMAL
- en: The data is reported on a monthly basis, with one measurement for each month.
    Passenger numbers are reported per thousand, which means that the first row indicates
    that 112,000 commercial passengers took to the skies during the month beginning
    January 1, 1949.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just as we did with Mauna Loa in the previous chapter, we will next instantiate
    our model and fit it. With this `Air Passengers` dataset, we will set `seasonality_mode`
    to `''multiplicative''`, but don’t concern yourself with this for now—we’ll cover
    it in [*Chapter 5*](B19630_05.xhtml#_idTextAnchor254), *Working with* *Seasonality*.
    Next, we send our data to the `fit` method and then make a `future` DataFrame.
    Let’s forecast `5` years. Finally, we will use `predict` with `future` and then
    plot the forecast to see how we did:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we created our `future` DataFrame with `5` years of daily data,
    having provided Prophet only with monthly data. Prophet is able to apply its seasonality
    calculations appropriately on the first day of each month, for which it has good
    training data. For the remaining days, though, it doesn’t quite know what to do
    and overfits its seasonality curve in wild and unpredictable ways, as can be seen
    in the following graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – Future forecast with daily frequency](img/Fig_4.2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – Future forecast with daily frequency
  prefs: []
  type: TYPE_NORMAL
- en: 'We can fix this by instructing Prophet to only forecast on a monthly scale,
    to match the monthly data it is trained on. We need to specify a frequency in
    the `make_future_dataframe` method, and we do this by passing the `freq` argument.
    We must also update `periods` because although we are still forecasting `5` years
    into the future, we only want `12` entries per year, one for each month:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `freq` argument accepts anything that pandas identifies as a frequency
    string. In this case, we used `''MS''`, meaning *month start*. Here is the output
    of that code block, showing the plotted forecast now that Prophet has been instructed
    to predict only on the first day of each month:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 – Future forecast with monthly frequency](img/Fig_4.3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3 – Future forecast with monthly frequency
  prefs: []
  type: TYPE_NORMAL
- en: That’s much better, exactly what we might expect the forecast to look like.
    By feeding the `freq` argument to the `make_future_dataframe` method, we do not
    make the mistake of asking Prophet to forecast dates for which it has no training
    knowledge. By default, the frequency is set to `'D'`, for *daily*, and our periods
    are the number of days we want to forecast. Whenever changing the frequency to
    some other setting, be sure to set your periods to the same scale.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s see what changes when we use data on a sub-daily scale. To do that,
    I’ll introduce a new dataset: Divvy.'
  prefs: []
  type: TYPE_NORMAL
- en: Using sub-daily data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will be using data from the *Divvy bike share program*
    in Chicago, Illinois. The data contains the number of bicycle rides taken each
    hour from the beginning of 2014 through to the end of 2018 and exhibits a general
    increasing trend along with very strong yearly seasonality. Because it is hourly
    data and there are very few rides overnight (sometimes zero per hour), the data
    does show a density of measurements at the low end:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 4.4 – \uFEFFNumber of Divvy rides per hour](img/Fig_4.4.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 4.4 – Number of Divvy rides per hour
  prefs: []
  type: TYPE_NORMAL
- en: Using `Air Passengers` data previously. You as the analyst need to use the `freq`
    argument and adjust the periods in the `make_future_dataframe` method, and Prophet
    will do the rest. If Prophet sees at least two days of data and the spacing between
    data is less than one day, it will fit daily seasonality.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see this in action by making a simple forecast. We already imported the
    necessary libraries in the previous example, so let’s continue by loading the
    new data and adding it to our DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Next, we continue as we did in the previous example by instantiating our model
    (again, using `seasonality_mode='multiplicative'`, and again, not worrying about
    it for now) before fitting our model. When we create the `future` DataFrame, we
    again need to set a frequency but this time we will use `'h'`, for hourly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that our frequency is hourly, we need to adjust our period to match, so
    we multiply the `365`-day forecast we want by `24` hours per day:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we will predict our `future` DataFrame. With our forecast complete,
    we will plot it with the first `plot` function and then the components in the
    second `plot` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The first of those two plots is the forecast shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5 – Divvy forecast plot](img/Fig_4.5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.5 – Divvy forecast plot
  prefs: []
  type: TYPE_NORMAL
- en: 'The forecast includes a rather large amount of uncertainty. To understand why,
    we need to look at the components plot as shown in *Figure 4**.6*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6 – Divvy components plot](img/Fig_4.6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.6 – Divvy components plot
  prefs: []
  type: TYPE_NORMAL
- en: There are a few things to note about this series of plots. Starting from the
    uppermost plot, the **trend** plot, we can see that it still exhibits annual periodicity.
    Why wasn’t this captured in the **yearly** seasonality plot? Unfortunately, this
    data contains some very complex seasonalities that Prophet is unable to fully
    model.
  prefs: []
  type: TYPE_NORMAL
- en: In particular, the **daily** seasonality itself is seasonal within the year.
    It’s seasonality within seasonality. The daily seasonality rises in the day and
    falls in the night, but the amount of the increase is dependent upon the time
    of year, and Prophet is not built to capture this type of seasonality. This is
    what causes so much forecast uncertainty. In later chapters, we will learn a few
    techniques to control this.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we look at the `Mauna Loa` plot featured several straight-line segments.
    Also, the plot goes from Sunday to Sunday, whereas the `Mauna Loa` plot went from
    Sunday to Saturday. Both of these changes reflect the more continuous nature of
    hourly data.
  prefs: []
  type: TYPE_NORMAL
- en: When we only had daily data, as we did with Mauna Loa, the weekly seasonality
    only needed to show the effect of each day (although, under the hood, it was still
    a continuous model). But now that we have hourly data, it is important to see
    the continuous effect. We are shown 12:00:00 a.m. on Sunday through 11:59:59 p.m.
    on Saturday, which is 1 second shy of 8 days. The `Mauna Loa` plot in essence
    showed the daily effect at a single moment each day, exactly 7 days, hence the
    difference between the two plots.
  prefs: []
  type: TYPE_NORMAL
- en: Now take a look at the **yearly** seasonality. It’s quite *wavy*. Just take
    note of that for now. We’ll talk about it in [*Chapter 5*](B19630_05.xhtml#_idTextAnchor254),
    *Working with Seasonality*, when we learn about the **Fourier order**.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the **daily** seasonality plot. This is new and only appears when Prophet
    models sub-daily data. It’s quite revealing with this dataset, though. It seems
    that riders in the Divvy network ride a lot around 8 a.m., possibly commuting
    to work. There is an even larger spike just after 5 p.m., possibly riders returning
    home. And finally, there’s a small hump just after midnight. These must be the
    night owls, who spent the evening out with friends and are returning home to bed.
  prefs: []
  type: TYPE_NORMAL
- en: 'I also want to mention one more thing about the forecast: the model predicts
    some negative values, although it’s impossible for Divvy to have a negative number
    of rides taken during any given hour. The Prophet developers are actively working
    on this issue and will release a solution in a future update.'
  prefs: []
  type: TYPE_NORMAL
- en: In the last two sections, you learned that super-daily data and sub-daily data
    pose no difficult issues to overcome; we can simply adjust the frequency of future
    predictions. But now suppose that Divvy had only been collecting data from 8 a.m.
    until 6 p.m. each day. The last topic to cover in this chapter is how to handle
    data with regular gaps.
  prefs: []
  type: TYPE_NORMAL
- en: Using data with regular gaps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout your career, you may encounter datasets with regular gaps in reporting,
    particularly when the data was collected by humans who have working hours, personal
    hours, and sleeping hours. It simply may not be possible to collect measurements
    with perfect periodicity.
  prefs: []
  type: TYPE_NORMAL
- en: As you will see when we look at outliers in a later chapter, Prophet is robust
    in handling missing values. However, when that missing data occurs at regular
    intervals, Prophet will have no training data at all during those gaps to make
    estimations with. The seasonality will be constrained during periods where data
    exists but unconstrained during the gaps, and Prophet’s predictions can exhibit
    much larger fluctuations than the actual data displays. Let’s see this in action.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose that Divvy’s data had only been collected between the hours of 8 a.m.
    and 6 p.m. each day. We can simulate this by removing the data from outside these
    hours from our DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now compare the following plot of this new DataFrame with the full dataset,
    which we saw in *Figure 4**.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.7 – Divvy rides per hour between 8 a.m. and 6 p.m.](img/Fig_4.7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.7 – Divvy rides per hour between 8 a.m. and 6 p.m.
  prefs: []
  type: TYPE_NORMAL
- en: 'This plot is much sparser than *Figure 4**.4*, particularly at low *y*-axis
    values. We lost all overnight data, from when ridership is down. Each day only
    has 10 data points now, one for each hour between 8 a.m. and 6 p.m. Now, let’s
    build a forecast model exactly as we did in the previous section, making our `future`
    DataFrame with one year of hourly frequency, but taking no extra precautions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The plotted forecast shows much wider daily fluctuations in the future period
    than the historical training data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.8 – Divvy forecast with regular gaps](img/Fig_4.8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.8 – Divvy forecast with regular gaps
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we are seeing unconstrained estimates in the future period causing wide
    fluctuations in predictions. This is the same effect that we observed with the
    `Air Passengers` data when we predicted daily forecasts with monthly data. We
    can zoom in on just 3 days in August 2018 to see more clearly what’s going on
    by replotting and using Matplotlib to constrain the limits of the `x` and `y`
    axes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Whereas the forecast plot from before showed 5 years of predictions, this plot
    shows just 3 days, so you can fully see what’s going on:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.9 – Divvy forecast over 3 days](img/Fig_4.9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.9 – Divvy forecast over 3 days
  prefs: []
  type: TYPE_NORMAL
- en: In the previous section, when we looked at *Figure 4**.6*, we noted that the
    daily seasonality component showed ridership picking up before 8 a.m. and hitting
    a local peak right at 8 a.m. There was a slump at midday and then a large peak
    right after 6 p.m. We are seeing the same thing in *Figure 4**.9*, except that
    Prophet is making wild predictions before 8 a.m. and after 6 p.m., where it has
    no training data. This area is unconstrained and can follow almost any pattern
    as long as the equations work out for the midday period where data exists.
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution to this problem is to simply modify the `future` DataFrame to
    exclude those times for which our training data had regular gaps. We don’t even
    need to instantiate a new model or refit; we can just reuse our previous work.
    So, continuing on, we create a new `future2` DataFrame, remove those times earlier
    than 8 a.m. and later than 6 p.m., and then predict our forecast and plot the
    results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we see a good forecast:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 4.10 – Divvy with regular gap\uFEFFs fixed](img/Fig_4.10.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 4.10 – Divvy with regular gaps fixed
  prefs: []
  type: TYPE_NORMAL
- en: 'The daily fluctuations in the predicted future are of the same magnitude as
    our historical training data. Contrast that with *Figure 4**.8*, where the future
    period showed a much wider range of predictions. Let’s again plot those same 3
    days in August to compare the output with *Figure 4**.9*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We see the same curve as before for the hours between 8 a.m. and 6 p.m., but
    this time, Prophet simply connects them with a straight line. There is, in fact,
    no data in our `forecast` DataFrame for these time periods; Prophet simply ignores
    them:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.11 – Divvy 3-day forecast with regular gaps fixed](img/Fig_4.11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.11 – Divvy 3-day forecast with regular gaps fixed
  prefs: []
  type: TYPE_NORMAL
- en: 'Prophet is a continuous time model, so although the `forecast` DataFrame ignores
    those excluded times, the equations that underpin the model are defined continuously.
    We can observe this by plotting the daily seasonality with the `plot_seasonality`
    function. This function is contained within Prophet’s `plot` package, so we need
    to import it first. It takes two required arguments, the model and a string identifying
    the seasonality to plot, and we also pass an optional argument to change the figure
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember that we did not create a new model to solve the regular gap problem;
    we only removed those empty periods from our `forecast` DataFrame the second time
    around. As we used only one model in these two examples, of course the components
    are the same. So, the daily seasonality we plotted is the same for both versions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.12 – Divvy daily seasonality](img/Fig_4.12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.12 – Divvy daily seasonality
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the period from 8 a.m. until 6 p.m. matches both *Figure 4**.9*
    and *Figure 4**.11*, even though those two plots showed wildly different results
    overnight. As we have no training or future data for times outside that range,
    those times on the daily seasonality plot can be ignored. They are merely mathematical
    artifacts of the equations that created the midday curve.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you took the lessons learned from the basic `Mauna Loa` model
    you built in [*Chapter 2*](B19630_02.xhtml#_idTextAnchor104), *Getting Started
    with Prophet*, and learned what changes you need to make when the periodicity
    of your data is not daily. Specifically, you used the `Air Passengers` dataset
    to model monthly data and used the `freq` argument when making your `future` DataFrame
    in order to hold back Prophet from making daily predictions.
  prefs: []
  type: TYPE_NORMAL
- en: Then, you used the hourly data from Divvy’s bike share program to set the future
    frequency to hourly so that Prophet would increase the granularity of its prediction
    timescale. Finally, you simulated periodic missing data in the Divvy dataset and
    learned a different way to match the `future` DataFrame’s schedule to that of
    the training data, in order to prevent Prophet from making unconstrained predictions.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how to handle the different datasets you will encounter in
    this book, you’re ready for the next topic! In the next chapter, you will learn
    all about seasonality. Seasonality is at the heart of Prophet’s power and it’s
    a big topic, so prepare yourself!
  prefs: []
  type: TYPE_NORMAL
