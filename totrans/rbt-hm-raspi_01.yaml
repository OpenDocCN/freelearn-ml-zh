- en: '1'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Planning a Robot with Raspberry Pi Pico
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you plan, you create the best chance for a mission’s success. We want to
    build robots in an achievable way. Let’s start with a plan in mind! We’ll use
    this plan to explore why **Raspberry Pi Pico** is a great fit for this and make
    a shopping list!
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you’ll learn about Raspberry Pi Pico’s capabilities. You’ll
    discover **CircuitPython** and understand why it is a great language for Raspberry
    Pi Pico. Additionally, we’ll plan a robot design and understand the trade-offs
    to make choices about the robot early in the project. We’ll check that our robot
    fits together, working out the parts and tools you’ll need with suggestions on
    how to get them.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the chapter, you’ll have both a plan and parts arriving so that
    you are ready to build a robot. Additionally, you’ll have a starting process for
    making other robots and setting yourself up for success with them.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is Raspberry Pi Pico, and why is it suitable for robotics?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is CircuitPython?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Planning a Raspberry Pi Pico robot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test fitting a Raspberry Pi Pico robot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A recommended shopping list for robot basics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ll go into the necessary hardware and shopping list as we progress further
    in this chapter. So, in this section, we’ll just focus on what you will need physically
    and on your computer to get started.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will require the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Some thin cardboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A ruler, pencil, and scissors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A good web browser with internet access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is Raspberry Pi Pico, and why is it suitable for robotics?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the heart of every robot is a **controller**. Usually, this is a computing
    device that is responsible for running the code for the robot to perform its tasks
    and behaviors. Choosing a controller is a key choice in robot design. You can
    either come from the *I have this controller, what can I do with it?* perspective
    or the *which controllers have the capabilities I’ll want for a particular* *robot?*
    perspective.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll take a closer look at what Raspberry Pi Pico offers as
    a controller and the trade-offs it’s made. We’ll explore why it is good for robotics
    and why it could be part of a larger, more interesting system, too.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we’ll delve into the details of its interfaces and how they’ll
    be useful to us.
  prefs: []
  type: TYPE_NORMAL
- en: A microcontroller that runs Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s start by taking a look at Raspberry Pi Pico, and discover what it has.
    The following photograph shows Raspberry Pi Pico:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.1 – Raspberry Pi Pico ](img/Figure_1.01_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.1 – Raspberry Pi Pico
  prefs: []
  type: TYPE_NORMAL
- en: Raspberry Pi Pico, as shown in *Figure 1**.1*, is an *RP2040* microcontroller
    on a Raspberry Pi-designed board. This **microcontroller** is a small computing
    device that has been designed to interface closely with hardware. It has a USB
    connection on the right-hand side for power or programming on a computer. The
    LED is useful for debugging. Also, there are many **input/output** (**IO**) pins
    around the edges to connect things. It is with these IO pins that the magic happens
    when it comes to controlling robots!
  prefs: []
  type: TYPE_NORMAL
- en: Controllers use IO pins to write and read from attached hardware. They can group
    pins into buses (which we’ll cover in more detail later) to exchange data with
    other devices. Additionally, they can create waveforms on outputs for controlling
    motors and LEDs.
  prefs: []
  type: TYPE_NORMAL
- en: 'This sounds a lot like the other **Raspberry Pi** models. However, this is
    a different class of computer. **Raspberry Pi Pico** has more in common with an
    **Arduino** board. Let’s take a closer look at what that difference means with
    the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.2 – Microcontroller boards versus single-board computers ](img/Figure_1.02_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.2 – Microcontroller boards versus single-board computers
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 1**.2* shows that while microcontroller boards such as Raspberry Pi
    Pico and Arduino might look similar to **single-board computers** (**SBCs**) such
    as Raspberry Pi 4 or BeagleBone, they have different key areas. For instance,
    they differ in storage, CPU speed, cost size, the complexity of software, and
    how closely your software runs to the hardware.'
  prefs: []
  type: TYPE_NORMAL
- en: While Raspberry Pi Pico is brilliantly suited to controlling hardware, such
    as robots, it isn’t as suited to high-memory or CPU tasks such as AI or visual
    recognition. There’s a kind of robot system known as **horse-and-rider**, which
    combines an SBC (for example, Raspberry Pi 4) for complex processing with a microcontroller
    (for example, Pico) for controlling hardware.
  prefs: []
  type: TYPE_NORMAL
- en: 'The low complexity means that code on a microcontroller has nearly no boot
    time, which means your code doesn’t have to coexist with other software in an
    operating system. Take a look at the following block diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.3 – Running your code on Raspberry Pi versus Pico ](img/Figure_1.03_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.3 – Running your code on Raspberry Pi versus Pico
  prefs: []
  type: TYPE_NORMAL
- en: This preceding diagram represents the software architecture on Raspberry Pi
    versus Raspberry Pi Pico. It shows how a Linux computer, such as Raspberry Pi,
    has additional layers of software along with competing apps running alongside
    your code.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to this, controllers have **interrupts**. They can notify the code
    that something has changed, such as the state of an IO pin. You’ll find this on
    the other Raspberry Pi models, but they are controlled by that pesky operating
    system again. In Pico and other microcontrollers, you get more control over what
    happens or when something changes on an IO pin, allowing responsive code with
    predictable timing.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, how does Raspberry Pi Pico compare with the Arduino Uno? The following
    table shows details from their specifications and datasheets:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 1.1 – Comparing the Pico with the Arduino Uno ](img/B18001_01_Table_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Table 1.1 – Comparing the Pico with the Arduino Uno
  prefs: []
  type: TYPE_NORMAL
- en: The preceding table shows that Raspberry Pi Pico has a faster multicore processor,
    along with more storage and digital IO pins. Additionally, Raspberry Pi Pico has
    a unique **Programmable IO** (**PIO**) system for extreme flexibility in organizing
    data to and from these pins. Official Pico boards are also cheaper than official
    Arduino boards.
  prefs: []
  type: TYPE_NORMAL
- en: Another place that Raspberry Pi Pico compares favorably with Arduino is in its
    use of Python (CircuitPython or MicroPython). Many microcontrollers, such as Arduino,
    require C/C++ to program, which can be difficult for beginners. Python is easier
    to understand, allows for complex and interesting data structures, and has access
    to many libraries of code, too.
  prefs: []
  type: TYPE_NORMAL
- en: 'In short, the key features of Raspberry Pi Pico are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A microcontroller—this offers low power and is small compared with SBCs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has responsible and flexible IO options.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is low cost compared to many microcontroller boards and most SBCs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is programmable in Python.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A number of the features I attribute to Raspberry Pi Pico are due to the *RP2040*—the
    chip that powers Pico and is available in forms other than Raspberry Pi Pico.
  prefs: []
  type: TYPE_NORMAL
- en: IO flexibility is Raspberry Pi Pico’s most interesting feature, so let’s take
    a look at that next.
  prefs: []
  type: TYPE_NORMAL
- en: Raspberry Pi Pico’s interfaces for sensors and devices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Raspberry Pi Pico has many interfaces for connecting to hardware, along with
    its unique PIO system. In this section, we’ll look at each type of interface.
  prefs: []
  type: TYPE_NORMAL
- en: A **digital IO pin** is the basic IO system for Raspberry Pi Pico. An output
    can be on or off, which is great for turning LEDs on or off, but you are unable
    to control their brightness. Similarly, an input can also detect on or off states.
    Raspberry Pi Pico has 26 of these pins.
  prefs: []
  type: TYPE_NORMAL
- en: '**Pulse-Width Modulation** (**PWM**) is a waveform for controlling outputs
    such as LEDs and motors—including DC motors, stepper motors, and servo motors.
    PWM pins output square wave pulses, with a changing (modulating) on-off ratio
    (pulse widths). Changing pulse width results in changes to the brightness of an
    LED, the speed of a motor, or a servo motor’s position. Raspberry Pi Pico has
    16 PWM channels, making it capable of controlling many such devices at once. These
    PWM pins still require a power control device to drive the motors.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Analog** input pins detect levels of voltage between **ground** (**GND**)
    and 3.3V. This is good for interfacing with simple sensors, such as light sensors,
    joysticks, slider/knob controls, temperature sensors, and measuring currents (using
    a bit of additional circuitry). Raspberry Pi Pico has three of these inputs.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A **universal asynchronous receiver-transmitter** (**UART**) controls a serial
    port. It can send streams of data to and from devices using two pins: a **TX transmit**
    pin and an **RX receive** pin. With this, it is capable of sending/receiving data
    that is more complicated than just a varying level. Raspberry Pi Pico has two
    independent UART interfaces.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pico has two **Serial Peripheral Interface** (**SPI**) bus controllers. SPI
    uses four pins, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.4 – Raspberry Pi Pico SPI bus usage ](img/Figure_1.04_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.4 – Raspberry Pi Pico SPI bus usage
  prefs: []
  type: TYPE_NORMAL
- en: The preceding diagram shows Raspberry Pi Pico using an SPI bus to connect to
    two devices—for example, displays or sensors. The bus has **transmit** (**TX**),
    also known as **Controller Out/ Peripheral In** (**COPI**) or **Microcontroller
    Out/Sensor In** (**MOSI**) for transmitting data from the controller, **receive**
    (**RX**) also known as **Controller In/ Peripheral Out** (**CIPO**) or **Microcontroller
    In/Sensor Out** (**MISO**) for receiving data back to the controller, **SCK**
    (a clock for timing the signal), and **Chip Select** (**CSEL/CS**) a chip selection
    pin for each peripheral. SPI uses chip selections to enable communication with
    multiple devices, as shown by the dashed lines of **Device 1 CS** and **Device
    2 CS**. See [https://makezine.com/article/maker-news/mosi-miso-and-140-years-of-wrong/](https://makezine.com/article/maker-news/mosi-miso-and-140-years-of-wrong/)
    for details on the current SPI acronyms.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Inter-Integrated Circuit** (**I2C**) is a data bus designed for communicating
    between integrated circuits such as sensors, memory devices, and output devices.
    An I2C bus has a data pin (which is often called *SDA – Serial Data*) and a clock
    pin (which is often called *SCL – Serial Clock*) keeping things synchronized.
    Multiple devices share an I2C bus by sending/receiving data with addresses, such
    as those in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.5 – I2C buses on Raspberry Pi Pico ](img/Figure_1.05_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.5 – I2C buses on Raspberry Pi Pico
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 1**.5* shows Pico and then some child peripherals connected via two
    independent I2C buses, assignable to different pin configurations, with some devices
    having the same address but different I2C connections. Additionally, I2C can address
    registers (such as memory locations) within devices. We’ll use I2C later to communicate
    with sensors.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, Raspberry Pi Pico has PIO. PIO is a feature that is unique to Pico.
    PIO consists of two blocks with four *state machines*. Each can run simple code
    independently of the main CPU and control one or more pins to send data to or
    from them. A single-state machine can control all the pins if that was useful
    for the code. Additionally, each state machine comes with buffers to hold data
    until it can be transferred. The following is an example block diagram of the
    PIO system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.6 – The Raspberry Pi Pico PIO system ](img/Figure_1.06_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.6 – The Raspberry Pi Pico PIO system
  prefs: []
  type: TYPE_NORMAL
- en: The preceding diagram shows two PIO devices inside the Pico. Each has code storage
    memory, so you can have two independent functions. In each PIO device, there are
    state machines that can independently run the code from that local memory.
  prefs: []
  type: TYPE_NORMAL
- en: Since PIO state machines run independently, and their instructions are about
    shifting data to/from pins, they can create interfaces for many kinds of hardware.
    For example, is there a weird protocol device? Use PIO. Do you need rapid counting
    independent of the main CPU? Use PIO. People have made **Video Graphics Array**
    (**VGA**) outputs with PIO, so it’s capable of fast and complex data handling.
    Additionally, you can also get interrupts from PIOs to tell you when something
    has happened.
  prefs: []
  type: TYPE_NORMAL
- en: 'That was quite a lot of IO systems. Let’s summarize them in a table, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 1.2 – The Raspberry Pi Pico IO systems ](img/B18001_01_Table_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Table 1.2 – The Raspberry Pi Pico IO systems
  prefs: []
  type: TYPE_NORMAL
- en: These protocols share pins, so using an I2C bus consumes 2 pins from the 26-pin
    pool.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve had a tour of Raspberry Pi Pico’s features and interfaces, let’s
    take a look at how we’ll program it in this book, using **CircuitPython**.
  prefs: []
  type: TYPE_NORMAL
- en: What is CircuitPython?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many microcontrollers require C/C++ or Assembler to program—for example, the
    popular Arduino ecosystem. However, in robotics, Python is rapidly becoming a
    de facto language. It is used for AI and data science and is great for rapidly
    trying out new ideas. Let’s examine why it is handy and, specifically, why I’ve
    chosen **CircuitPython** for this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python does not require a compile step. Getting you quick feedback on your
    code and Python’s **read-eval-print loop** (**REPL**) allow you to start typing
    and experimenting with code instantly. The REPL allows you to see what works before
    using ideas in code that you’ll keep. Here’s a REPL session with CircuitPython:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The preceding session shows a print running in a REPL on Raspberry Pi Pico.
    We’ll explore how to use the REPL for some Pico experiments. It even comes with
    built-in assistance; however, on Pico, not all of the help is left in, for size
    reasons.
  prefs: []
  type: TYPE_NORMAL
- en: Python has other things that help, such as being able to directly return multiple
    values from a function. Python has function calls and classes like C++, but functions
    can be used as data, and references to them can be stored in variables. Additionally,
    Python has functional programming elements that allow programmers to chain tools
    together for processing streams of data.
  prefs: []
  type: TYPE_NORMAL
- en: Python uses exceptions to handle errors, allowing you to choose how to respond
    to them or observe their output, leading you directly to a problem.
  prefs: []
  type: TYPE_NORMAL
- en: MicroPython is the original port of the Python language to run on small memory
    devices such as microcontrollers. It has a community working on it, and CircuitPython
    builds on it.
  prefs: []
  type: TYPE_NORMAL
- en: In CircuitPython, Raspberry Pi Pico mounts as a USB storage device, so you can
    copy your code and the libraries your code uses, directly onto the Pico. This
    makes composing code from multiple libraries or using third parties simple. Copying
    code over with the correct name is enough to run that code when Raspberry Pi Pico
    is powered up again.
  prefs: []
  type: TYPE_NORMAL
- en: CircuitPython has a huge library of device support for Neopixel LEDs, Bluetooth,
    many sensors, displays, and other devices. This library not only works with Pico
    but runs across many CircuitPython controllers, so familiarity with these library
    components will be useful when you are working with other controllers.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve chosen a language and the controller that we will build robots
    with in this book, it’s time to start planning a robot!
  prefs: []
  type: TYPE_NORMAL
- en: Planning a Raspberry Pi Pico robot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve been fact-finding for our robot-building mission. Before we start our
    robot-building journey, we’ll make a rough plan of what we want to do, then refine
    it. We’ll make important decisions, which we can examine further as we start to
    build the robot.
  prefs: []
  type: TYPE_NORMAL
- en: An overview of robot planning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When planning the robot, there are several things we need to consider:'
  prefs: []
  type: TYPE_NORMAL
- en: What do we want this robot to do? What is it for?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What style of robot is suitable?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What kinds of sensors or outputs will we need?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What rough shape and size will it have?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once we’ve answered these questions, we can make further decisions about what
    we build. These don’t require much detail. Robotics is full of interesting diversions,
    making it tempting to jump between ideas. By having a constrained plan and working
    to it, you can keep your pace on getting a robot built, saving distractions and
    cool ideas for the next robot or three!
  prefs: []
  type: TYPE_NORMAL
- en: What do we want this robot to do? What is it for?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Will the robot solve a problem, clean your kitchen, explore a space, deliver
    packages, impress guests at a conference, or compete in a robot competition?
  prefs: []
  type: TYPE_NORMAL
- en: 'The robot we’ll build in this book has several purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring Raspberry Pi Pico and its capabilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trying out sensors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing algorithms guided a little by challenges in robot competitions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Navigating a known space
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a custom chassis, adaptable for future ideas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keeping it simple enough to get started
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With these goals in mind, we can look at the specific details.
  prefs: []
  type: TYPE_NORMAL
- en: What style of robot is suitable?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are many robot styles. We should choose one, probably the simplest possible
    for our goal. Take a look at the following diagram for a selection of different
    robot styles:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.7 – Different robot styles ](img/Figure_1.07_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.7 – Different robot styles
  prefs: []
  type: TYPE_NORMAL
- en: The first robot style is a robot arm used in industry. These are fascinating
    and fun to build. However, they do not satisfy our goals of building a robot chassis
    to try out sensors.
  prefs: []
  type: TYPE_NORMAL
- en: The next panel shows a quadcopter drone—an **unmanned aerial vehicle** (**UAV**).
    These are complicated to build and program, so they do not meet our goal of keeping
    it simple.
  prefs: []
  type: TYPE_NORMAL
- en: The third panel shows a walking robot—a hexapod. These require controlling many
    servo motors. Their power usage and complexity make them an unsuitable but exciting
    option for a follow-up robot!
  prefs: []
  type: TYPE_NORMAL
- en: The fourth panel shows a wheeled robot. Wheeled robots can be simple **two-wheel-drive**
    (**2WD**) robots with a roller, such as this one. 2WD rover platforms such as
    this satisfy our goals of building a chassis and getting to know sensors and algorithms.
    They can later be made more interesting, with tracks, mecanum wheels, rocker bogies,
    or individually steered wheels, allowing them to also meet the adaptable goal.
  prefs: []
  type: TYPE_NORMAL
- en: I recommend that we go ahead with a 2WD rover throughout this book but keep
    the other variations in mind for further robot builds!
  prefs: []
  type: TYPE_NORMAL
- en: What kinds of sensors or outputs will we need?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of our goals is to try out different sensors. A robot made to navigate spaces
    will influence the sensors we’ll use. They all contribute to locating the robot.
  prefs: []
  type: TYPE_NORMAL
- en: 'Good sensors for this include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Distance sensors**: What is in front of the robot? How far are the nearest
    objects? We might want more than one of these devices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Encoders**: How has the robot moved? How far did it go?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Inertial Measurement Unit** (**IMU**): Has the robot turned? What is its
    position relative to north?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Along with these sensors, we can have simple outputs—the motors that we drive
    wheels with. As a later extension, we could also add Bluetooth to give us some
    feedback on our robot’s status. We don’t need to plan all of this yet but leave
    space for it so that we can extend the robot later.
  prefs: []
  type: TYPE_NORMAL
- en: What rough shape and size will it have?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, we have a firm idea of a 2WD robot. We know it probably needs to support
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Raspberry Pi Pico
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pair of motors with wheels and a caster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many sensors and, later, Bluetooth
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Power for the system, including batteries plus voltage conversion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A breadboard for wiring all of this together
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although we don’t want the robot to be too big, we are going to need some real
    estate to play with. Let’s start with a rough estimate of 150 mm x 200 mm.
  prefs: []
  type: TYPE_NORMAL
- en: So, we’ve answered some questions about what we want. We will use the next few
    sections to dive deeper into the planning of this robot, looking at the different
    aspects of the planning and the choices we’ll make. The first of those is to consider
    trade-offs.
  prefs: []
  type: TYPE_NORMAL
- en: A note on trade-offs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All designs make trade-offs. The truth is that no design fits all cases, and
    usually, no design is perfect but will be good enough in the right aspects where
    it works. We will need to make decisions and read datasheets for parts to also
    assist us.
  prefs: []
  type: TYPE_NORMAL
- en: One example is size and weight—we already mentioned that we don’t want a large
    robot. After all, we have a limited workbench size, and larger robots require
    more power, larger motors, and larger batteries. Additionally, we’d need to work
    with tougher and—likely—harder-to-cut materials. For a different context and goal,
    perhaps a large, heavier robot would be more suitable. So, the first trade-off
    is to keep the robot small but not too small—that is, to keep it simple.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve suggested Raspberry Pi Pico, and the trade-offs from Raspberry Pi there,
    for example lighter weight, reduced cost, and power.
  prefs: []
  type: TYPE_NORMAL
- en: But what of sensor trade-offs? Every sensor has multiple types, which we will
    dive into in their respective chapters. They differ in price, features, and complexity.
  prefs: []
  type: TYPE_NORMAL
- en: In many aspects, we can trade having more complexity for reduced weight or cost
    or more features for a higher cost.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing a robot chassis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have many options for our 2WD robot chassis. Again, this depends on what
    we want to learn or achieve. We have stated our goal of building a flexible chassis.
    Some good options for doing this are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Buying a chassis kit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adapting a lunchbox or toy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Doing a scratch build by hand
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 3D printing or laser cutting a chassis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chassis kits are an easy option but have limited flexibility. Many come with
    motors, wheels, batteries, and even a motor driver designed for a specific main
    controller. In this way, they can save time and money, allowing you to focus entirely
    on the code and sensors, but they offer less opportunity to learn design aspects.
    It’s often tricky to find a chassis kit with the right shape and size, and as
    they get larger, they quickly become more expensive.
  prefs: []
  type: TYPE_NORMAL
- en: You could also adapt a lunchbox into a robot chassis—cutting mounting holes
    for motors, sensors, boards, and other parts can be a good place to learn design
    skills. However, you’d need to fit your robot electronics and hardware in a constrained
    space. Note that the curved sides of lunchboxes can complicate things.
  prefs: []
  type: TYPE_NORMAL
- en: Scratch-building a chassis gives you great flexibility. You can learn how to
    design in CAD and how to use hand tools. Additionally, you need to make choices
    about the type and thickness of the material, and in doing so, you’ll be able
    to understand more about making strong robots. You’ll learn how to fit sensors
    and expand your robot if things get a bit tight. This requires more time and patience
    than the kits, but the rewards are great.
  prefs: []
  type: TYPE_NORMAL
- en: 3D printing and laser cutting require precise designs, along with expensive
    and specialist tools or services. As you dive further into robotics, and progress
    beyond a simple 2WD robot, creating more interesting shapes and sensor mounts,
    it is likely to be an important area of exploration. If you are not confident
    with hand tools, finding a laser-cutting service for the same parts will achieve
    good results, but it can be costly.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, so that you can get exposure to the design and hand tools while
    still giving us lots of flexibility, we will take the scratch-building option.
    We will learn CAD skills that are transferable to 3D printing. We’ll learn how
    to cut and drill parts, looking at some premade parts to save time. Additionally,
    we’ll size our design at approximately 150 mm x 200 mm and modify this if needed.
    But what about the motors?
  prefs: []
  type: TYPE_NORMAL
- en: Choosing motors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This 2WD motor requires two main drive motors. We could consider stepper motors,
    which move a little each time they are pulsed, although these bring a little extra
    complexity—perhaps an idea to keep for later. DC motors, which rotate continuously
    when powered, seem like the right choice. They will need to be geared so that
    they have enough power to move the robot, without being too quick and hard to
    control.
  prefs: []
  type: TYPE_NORMAL
- en: We should keep these motors small and at a low voltage. As we are unlikely to
    want to build an additional gearbox, geared motors are sensible. There are some
    options here in terms of the size we are working with. First is the yellow *TT*
    motor with plastic gears— however, these motors are not of great quality and take
    up a fair amount of space. Another option is to use servomotors that are adapted
    for continuous rotation—however, these can be a little expensive.
  prefs: []
  type: TYPE_NORMAL
- en: A small, common, high-quality but inexpensive option is N20 or micro-metal gear
    motors. To save space and effort, there are models of these that have encoders
    pre-fitted. We can use similarly common plastic brackets to attach them to our
    robot. That makes them convenient to use, too.
  prefs: []
  type: TYPE_NORMAL
- en: Robot wheels
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For a 2WD robot, there are a few ways in which to lay the wheels out. One possibility
    is to have two driving wheels with two idler wheels (that is, unpowered). However,
    those wheels can drag, making it harder to turn the robot. A common way is to
    have a third wheel as a caster—either a ball that can roll in any direction or
    a swivel wheel such as a shopping trolley. Because of the size of the robot, a
    ball caster seems like a good idea.
  prefs: []
  type: TYPE_NORMAL
- en: The wheels themselves should have a hub that is compatible with the motors that
    we’ve chosen. A pair of N20 wheels with a diameter of 60-100 mm should be suitable.
  prefs: []
  type: TYPE_NORMAL
- en: So, we have a rough size for our robot, and we know the controllers, motors,
    and some of the sensors. The next item to choose is the power systems.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing the power systems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A robot isn’t much fun without independent power—by which I mean its own source
    of power without needing to be plugged into a wall. Usually, this means batteries.
    It then needs ways to provide power to the control electronics, sensors, external
    boards, and motors. Take a look at the following diagram for an outline of power
    distribution in a 2WD robot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.8 – Power distribution in a 2WD robot ](img/Figure_1.08_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.8 – Power distribution in a 2WD robot
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 1**.8*, the thicker lines show raw battery power connections. A 2WD
    chassis will need to drive at least two motors, which are power-hungry devices
    that require a battery connection.
  prefs: []
  type: TYPE_NORMAL
- en: This robot needs to power Raspberry Pi Pico and other sensors. Since we intend
    to add Bluetooth, we should leave power aside for that. So, the other thick line
    goes to a regulator for these, making more palatable power for these systems—the
    raw battery voltage would likely destroy them. The thinner solid lines show regulated
    power.
  prefs: []
  type: TYPE_NORMAL
- en: The Pico will be sending/receiving electronic control signals, designated by
    the thin dashed lines in the preceding diagram. These also go to the motor controller.
    The motor controller will provide PWM-controlled power from the batteries to the
    motor, modulated by the signals the Pico sends to them. The motor power is shown
    by the thick dashed lines to the motors on the left-hand side.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we have a few considerations to bear in mind. We require an input voltage
    that is suitable for the motors and to drive a regulator. We need a regulator
    that can handle the power capacity requirements for the Pico, sensors, and Bluetooth,
    and we need batteries that can supply enough current to drive them.
  prefs: []
  type: TYPE_NORMAL
- en: Calculating power requirements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s start with what we know—5V is a good output voltage for a regulator, and
    where needed, the Pico can further regulate down to 3.3V. A regulator for 5V likely
    requires 7V or more.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Voltage measures electrical pressure. A current measures how fast electrical
    energy flows. Combining both of them shows system power usage. A current in amps
    or milliamps can be used as a stand-in for power in watts when the voltage is
    known.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look up the specifications for the N20 gear motors. Perform an online
    search for the N20 motor datasheet. You’ll be looking for a PDF document. Usually,
    these have a picture or diagram of the product, followed by the specification
    and feature tables. If you look for *Rated Voltage*, they say 6V; however, further
    down the sheet, there is usually a table relating to the voltage of the motor
    speed. Based on the motors and regulator basics, an input voltage of 7V-12V would
    make sense.
  prefs: []
  type: TYPE_NORMAL
- en: Our electronics don’t operate on voltage alone and require a current to operate.
    So, a regulator will need to handle the minimum current requirements. We’ll need
    to look at some datasheets and specifications for the other parts. We will include
    sensors. For Bluetooth, we will include a low-power **Bluetooth Low Energy** (**BLE**)
    board using the highest current measurements from [https://learn.adafruit.com/introducing-the-adafruit-bluefruit-le-uart-friend/current-measurements](https://learn.adafruit.com/introducing-the-adafruit-bluefruit-le-uart-friend/current-measurements).
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll base it on worst-case values so that we can handle them. Let’s start
    by looking at datasheets and gathering numbers into a table, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 1.3 – Device power requirements ](img/B18001_01_Table_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Table 1.3 – Device power requirements
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 3*](B18001_03.xhtml#_idTextAnchor055) of the datasheet for Raspberry
    Pi Pico (which can be found at [https://datasheets.raspberrypi.com/pico/pico-datasheet.pdf](https://datasheets.raspberrypi.com/pico/pico-datasheet.pdf))
    shows the electrical specification, with peak currents at a little under 92 mA
    (milliamps—a measure of current). We’ll round this up to 100 mA as a margin.'
  prefs: []
  type: TYPE_NORMAL
- en: The Adafruit Bluetooth board uses only 15.2 mA when fully active, but we can
    round it up to 20 mA to be generous. The sensors need maybe 50 mA of extra room
    to accommodate them.
  prefs: []
  type: TYPE_NORMAL
- en: We can add these estimates together to suggest a minimum current specification.
    Based on these datasheets and estimates, any regulator capable of over 400 mA
    will be plenty.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing a regulator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Motor control and power supplies can be totally separate concerns, giving great
    flexibility, but this can take up more space. There are boards designed for Raspberry
    Pi Pico that allow you to control motors while supplying power to Raspberry Pi
    Pico. However, will they supply 400 mA?
  prefs: []
  type: TYPE_NORMAL
- en: Kitronik has some neat Raspberry Pi Pico motor boards—a small motor only, along
    with a larger robotics board with servo motor outputs and a prototyping area.
    However, the supply for the Pico on the robotics board datasheet has 100 mA for
    peripherals, which won’t work.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we understand that we need a regulator that is capable of outputting 5V,
    at a minimum of 400 mA. We want something small and simple. A suitable device
    for this is a **Universal Battery Eliminator Circuit** (**UBEC**). These can handle
    3 A. We’d put this through a VSYS pin on the Pico.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing a motor controller
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The suggested motors are small. Motors have a stall current—that is, the power
    they draw if they are trying to move and block a logical maximum. For the N20s,
    their datasheet suggests 350 mA at 6V. It might be a little over that, perhaps
    550 mA. A motor controller needs to handle a little over this peak per channel—motor
    controllers that are unable to handle motor load tend to go up in smoke! Take
    a look at the following two common simple motor controllers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.9 – An L298N motor controller next to a TB6612fng ](img/Figure_1.09_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.9 – An L298N motor controller next to a TB6612fng
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 1**.9*, on the left-hand side, you can see the very common **L298N**—internet
    searches suggest this handles 2 A per channel. They are small, inexpensive, and
    easy to find. However, this is a 5V logic device. Raspberry Pi Pico outputs 3.3V
    logic, which might not work properly with this controller without logic-level
    conversion.
  prefs: []
  type: TYPE_NORMAL
- en: On the right-hand side is another good choice, the **Toshiba TB6612fng**. These
    handle 1.2 A per channel, which is a bit less than shown previously but still
    good enough. It will handle up to 15V for controlling motors and logic voltages
    from 3V to 5V, so it won’t require level shifters for Raspberry Pi Pico. There
    is a module from *SparkFun* for these, which will work well with the Pico and
    is small enough to fit on a breadboard next to it.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we should plan to have a power switch on the breadboard from the
    batteries to the motor controller and regulator. Talking of batteries, we still
    need to select them.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing batteries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We also need something to go through the power regulator—batteries.
  prefs: []
  type: TYPE_NORMAL
- en: While we can (and should, at a more advanced stage) consider Lithium-ion batteries,
    the type used in **remote control** cars, the simplest possible option is AA batteries.
    For our motor and regulator choice, 8 x AA gives 12V. These are easy to buy and
    replace but take up a lot of space for their power output. Our motors don’t require
    a lot of current, so they will be good enough.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve examined our power requirements and some solutions, we’ll take
    a look at which pins are being used on our Raspberry Pi Pico and ensure that our
    plans for hardware won’t conflict.
  prefs: []
  type: TYPE_NORMAL
- en: Pin usage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our Raspberry Pi Pico has many IO pins, but we need to consider whether all
    the items we intend to connect to it will be able to simultaneously connect to
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s re-examine the specifications for the Pico at [https://www.raspberrypi.com/documentation/microcontrollers/raspberry-pi-pico.html](https://www.raspberrypi.com/documentation/microcontrollers/raspberry-pi-pico.html):'
  prefs: []
  type: TYPE_NORMAL
- en: 26 **General Purpose Input/Output** (**GPIO**) pins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2 x UART, 2 x SPI, and 2 x SPI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The motor controller will consume two pins per motor, and we know these motors
    come with encoders, with a further two pins each. That means, so far, we’ve used
    8 of the 26 IO pins. This should leave us plenty of room for expansion.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve checked our basic concept, we’ll move on to test fitting—an approximation
    of how we’ll build the robot.
  prefs: []
  type: TYPE_NORMAL
- en: Test fitting a Raspberry Pi Pico robot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we’ve checked that we can power our system, we need to make sure it
    is all going to fit on the robot. In this step, you get a rough idea of where
    things will be, whether your chassis will be big enough, and whether the robot
    design is likely to work.
  prefs: []
  type: TYPE_NORMAL
- en: The key thing for a test fit is that it is not detailed. Use the simplest method
    to check whether things will fit, be it sliding around cut-out paper rectangles
    or using simple software.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s make some simple paper or card parts. For this section, you’ll require
    card, a pencil, a ruler, and scissors. Card from a cereal box is great for this,
    but paper will also do.
  prefs: []
  type: TYPE_NORMAL
- en: For a test fit, rectangles are often good enough. The intention is to determine
    what will fit inside a space and position things. Detail isn’t necessary. For
    large robots, you might need to make a scale model. As this robot is small, you
    can make parts at a 1:1 scale. This has an added advantage—if you already have
    parts in your possession, you get to use them.
  prefs: []
  type: TYPE_NORMAL
- en: Creating your first test-fit part
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You’ll need the datasheets for your devices again—this time to start looking
    at the mechanical sizes of things. For a test fit, you just need to create bounding
    boxes for items, ensuring there is enough space for them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with a breadboard and the Pico. Since the Pico is on the breadboard,
    you can just model the breadboard size. I recommend a 400-pin breadboard, which
    is also known as a half-plus. Use a search engine to look for `half plus breadboard
    dimensions` and click on the images panel. What you are looking for is a flat
    diagram showing the outside dimensions of the board, such as the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.10 – Breadboard dimensions ](img/Figure_1.10_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.10 – Breadboard dimensions
  prefs: []
  type: TYPE_NORMAL
- en: The preceding diagram shows what to expect with a drawing/picture in terms of
    dimensions, which, in this case, is a breadboard. It measures 84 mm along the
    top and 56 mm along the right-hand side. It’s important to note here that I’m
    using millimeters throughout the book, and I will convert from other units if
    necessary. Stick to one measurement system in a robot design!
  prefs: []
  type: TYPE_NORMAL
- en: 'We can take the paper or card and draw an 84 mm by 56 mm rectangle in pencil.
    This does not need to be too accurate—the nearest 5 mm is good enough. The following
    photograph shows this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.11 – Making a breadboard test-fit part ](img/Figure_1.11_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.11 – Making a breadboard test-fit part
  prefs: []
  type: TYPE_NORMAL
- en: As the preceding photograph shows, you simply draw it out. Additionally, so
    that we can identify it later, write *breadboard* on the part, along with its
    dimensions of *84 x 56*. Keep these handy so that they can be used for reference
    later.
  prefs: []
  type: TYPE_NORMAL
- en: Then, you can cut this out with scissors. I tend to make a wide rough cut, and
    then a finer close cut as a second pass for this.
  prefs: []
  type: TYPE_NORMAL
- en: This simple rectangle, with the right measurements, is our first test-fit part.
    Next, we will need the motor parts.
  prefs: []
  type: TYPE_NORMAL
- en: Motors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The motors we are using are N20 motors. If we place them on the underside of
    the robot, as is common with these designs, we still need to consider how their
    wires come up through the chassis. It is easier to put them on top so that the
    motor wires can face upward.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can search the web for N20 motor brackets. Look in the images tab for drawings
    so that we can get the correct dimensions and add extra space for wiring behind
    the motor. The following photograph shows me making these test parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.12 – Making cardboard motor test-fit parts ](img/Figure_1.12_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.12 – Making cardboard motor test-fit parts
  prefs: []
  type: TYPE_NORMAL
- en: For this part, as the preceding photograph shows, we want two rectangles of
    30 mm by 35 mm. Label them. On one of the longer edges of each part, add an arrow
    to show that this is where the wheels will go.
  prefs: []
  type: TYPE_NORMAL
- en: We have motors and a breadboard. Next, we need to make stand-in parts for powering
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Power systems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The UBEC doesn’t take up a lot of space, so we can ignore it. The controller
    we’ve chosen will fit on a breadboard with the Pico, so it is already accounted
    for. We do need to account for the batteries.
  prefs: []
  type: TYPE_NORMAL
- en: We have a couple of variants on an 8 x AA battery holder—the flat kind, which
    takes up more space but comes with mounting screws, or the 4 x 2 kind. These use
    vertical space instead. Another way to save space is to put batteries on the underside
    of the chassis.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this stage, we will use the flat holder as it is easier. You can look up
    the size for them and create a labeled rectangle for them. My battery box came
    out as 93 mm x 57 mm:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.13 – A battery box in cardboard ](img/Figure_1.13_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.13 – A battery box in cardboard
  prefs: []
  type: TYPE_NORMAL
- en: The preceding photograph shows a battery box created from cardboard. Now, we
    have a bunch of parts to go on the chassis. Next, we need to represent the chassis
    itself.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a rough chassis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We previously suggested that the chassis should be about 150 mm x 200 mm. Create
    this rectangle in cardboard, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.14 – The cardboard chassis ](img/Figure_1.14_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.14 – The cardboard chassis
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from the preceding photograph, this is not—at all—intended to
    be a perfectly neat cut. It is simply meant to be good enough to see where things
    likely need to go. Give the chassis labels just as we have done so far with the
    other parts. Additionally, we can label one of the shorter edges of the chassis
    part as the front.
  prefs: []
  type: TYPE_NORMAL
- en: This is the last item to test fit. Let’s start to arrange these parts.
  prefs: []
  type: TYPE_NORMAL
- en: Arranging the test-fit parts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, you should have a set of rectangles representing the different parts.
    The following photograph shows the parts and how we can arrange them:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.15 – Our test-fit parts in cardboard ](img/Figure_1.15_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.15 – Our test-fit parts in cardboard
  prefs: []
  type: TYPE_NORMAL
- en: The boxes on the left-hand side of *Figure 1**.15* are correctly proportioned
    parts and have been placed in a rough position. However, they aren’t properly
    laid out yet. The right-hand side shows a possible layout.
  prefs: []
  type: TYPE_NORMAL
- en: It’ll be easier to fit motors around the breadboard if we rotate it so that
    it’s tall instead of wide. We have the batteries at the back of the robot, in
    the middle, then we have the breadboard in front of them, along the middle. Notice
    that there is a gap between the batteries and the breadboard—we don’t want any
    parts to be too close together.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve put the motors on either side of the breadboard, leaving space at the
    front to expand our robot design.
  prefs: []
  type: TYPE_NORMAL
- en: We have accounted for the major parts of the robot, including computing, power,
    and motors. There’s also adequate space for expansion. We’ll tune this later as
    we get deeper into the design, but this shows our combination is viable.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our robot design, it’s time to shop for tools and materials!
  prefs: []
  type: TYPE_NORMAL
- en: A recommended shopping list for robot basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve got a plan—a test fit, a method to make the chassis, decisions about the
    processing on board, and how we will power the thing. Now, we need to buy the
    necessary parts and tools to make this happen.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with the parts.
  prefs: []
  type: TYPE_NORMAL
- en: Robot parts and where to find them
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many places to find robot parts, and some of these parts go by different
    names from different manufacturers. I’ll attempt to provide enough information
    about the parts so that they can be easily found in many countries.
  prefs: []
  type: TYPE_NORMAL
- en: Part shopping list
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We’ll start with a part list for the initial robot chassis. For each part,
    where necessary, we’ll show search terms, synonyms, and manufacturer numbers.
    You can try combinations of these to find parts—I wouldn’t suggest using all the
    terms at once but instead refining them until you get something else. Then, we
    can discuss places to buy them:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Raspberry Pi Pico**: This is the most important part to get you started.
    Other RP2040-based boards might be suitable; however, with different form factors
    and pins, you’ll need to get creative when it comes to wiring them. Beware of
    parts with fewer exposed pins, and ensure that they are *RP2040* boards. *Alternative
    parts*: Headered Pico, Pimoroni Pico LiPo, Adafruit Feather *RP2040*, *SparkFun
    Pro Micro RP2040*, *RP2040* Plus.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A USB micro cable**: You might already have one for your phone, but phones
    have been coming with USB-C cables for some time. To be specific, I mean a USB-A
    to USB-Micro cable. However, some laptops have a USB-C port—for those cases, consider
    a USB-C to USB-Micro cable instead.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Headers**: You’ll need to solder headers onto Raspberry Pi Pico and the motor
    controller. Later sensors will require them, too. Search terms for these include
    *male breakaway strip and single-row PCB through-hole pin headers*. Make sure
    that you choose 2.54 mm or 0.1-inch pitch headers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A solderless breadboard**: I suggest a mini/half plus 400 tie-point breadboard,
    self-adhesive. Standard 0.1-inch (or 2.54 mm) pitch spacing, with a separating
    channel between the columns.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Wiring**: You’ll need wiring between the components on the breadboard. For
    this, I suggest precut breadboard jump wire kits. These should be of the U-shape
    solderless kind—insulated cables with bare ends. They will be in different color-coded
    lengths and can be bent into shape to fit across breadboard connections.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A Drv8833 or TB6612fng motor controller or motor driver**: I recommend the
    SparkFun or Adafruit models; however, other models will work. Stick to this chip,
    and ensure it’s a module/breakout board, not just the bare chip. It should have
    a square device with a capacitor on the board, too. I recommend getting a model
    that has pin functions printed on it. Alternatives are the L9110S, the less efficient
    L298n boards, or the L293 chip, which may need additional space.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A 5V 3A UBEC or a 5V UBEC (DC/DC step-down buck converter)**: Search for
    ones that can handle a minimum of 3 A. Larger ones are also fine. Look for those
    with a 5V output. If they allow 6V too, just make sure that you set the jumper
    to 5V. Look for those with bare input cables and a pin header end. Other buck
    converter modules may be suitable, but check for 3 A current capacity, and ensure
    that the output is 5V.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**8 x AA battery holder or battery compartment**: Look for the flat-style ones
    with an integrated switch. Some come with round barrel jacks instead of bare ends—in
    which case, a 2.1-mm jack to screw the terminal block can be used to finish this.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A 1N5817 Schottky diode**: These are common in many electronic outlets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Motors**: The N20 micro-metal gear motors with encoders. The 298:1 ratio
    motors have the right combination of speed and torque. Adafruit has these as ADA4640\.
    Small DC gear motors with encoders can be substituted, but please be aware that
    the larger motors may require the robot to scale up along with power requirements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ball caster**: A 16-30-mm caster should be fine. Most models will be suitable.
    Just remember to use the drawings for their mount holes later.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**40-90-mm wheels with N20 d-hole or universal hubs**: Make sure they are designed
    for N20 motors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**3 mm or 0.118-inch thick styrene card sheets/plates**: Go for an A4, 200
    x 150 mm, or greater size. They should be solid, flat sheets—not foam or hollow,
    and, ideally, not textured. Possible search terms include Plasticard, styrene
    sheet, Evergreen, and Plastruct. ABS sheets are suitable, but not acrylic as this
    can be brittle.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Kit for mounting parts**: Possible search terms include standoff and mounting
    kit. Preferably, they should be in metal, but nylon will do fine. They should
    be M2, M2.5, or M3 if possible. M2.5 will cover most cases. They should have standoffs,
    bolts (including machine screws and truss screws), and nuts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This list of parts and search terms will help you find all the suggested parts
    to build this robot. Here is a helpful list of places to buy parts from. It isn’t
    exhaustive, and there might be sellers in your country that can help.
  prefs: []
  type: TYPE_NORMAL
- en: 'For electronics parts, wheels, motors, and modules, the following stores ship
    worldwide:'
  prefs: []
  type: TYPE_NORMAL
- en: '[ThePiHut.com](https://ThePiHut.com), [pimoroni.com](https://pimoroni.com),
    [adafruit.com](https://adafruit.com), [Robu.in](https://Robu.in), and [mouser.com](https://mouser.com).
    For some items, [Pololu.com](https://Pololu.com) and [Sparkfun.com](https://Sparkfun.com)
    might carry them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Both Adafruit and Pimoroni have web pages that list their various distributors:
    [https://www.adafruit.com/distributors](https://www.adafruit.com/distributors)
    and [https://shop.pimoroni.com/pages/worldwide-distributors](https://shop.pimoroni.com/pages/worldwide-distributors).
    They are a reliable source of reference.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Online marketplaces such as eBay, AliExpress, and Alibaba can be used—but buyers
    beware. Sellers on them might not have good support or return policies in place.
    Parts might also be cheap substitutes, and they could take a long time to deliver.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the styrene sheet, model supply shops are a good bet. Brands such as Evergreen
    are widely distributed. Hobbycraft, AliExpress, Alibaba, and Amazon carry these.
    While there, I suggest getting styrene angle strips and square tubes for later
    robot enhancements.
  prefs: []
  type: TYPE_NORMAL
- en: The robot workshop and makerspaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is a list of workshop and hand tools associated with this book. You can
    buy them yourself or use a makerspace. Let’s start with the tools that you will
    need access to.
  prefs: []
  type: TYPE_NORMAL
- en: List of tools
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The tools required for this book are common in many workshops. In addition
    to this, school and college DT rooms, makerspaces, and many workshop stores will
    carry them:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Plastic cutter**: The kind with changeable blades. We will be cutting through
    styrene, which can quickly dull a knife. Linoleum flooring cutting blades will
    also be a useful alternative here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A cutting mat to protect your work surfaces.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You’ll need a try square, preferably metal.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A ruler**: This should be at least 200 mm long. Since the book is working
    in metric, I suggest metric markings, too.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sandpaper**: You will need a selection of, at the very least, 400, 600, and
    1,000 grit or similar.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Soldering iron and stand**: You’ll be soldering some parts, so an iron is
    essential. Do not use a soldering iron without a stand! Many come with them. I
    recommend a temperature-controlled iron. In addition to this, a brass wool tip
    cleaner and some solder are required. We’ll use lead-free flux core solder wire.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 10-20-mm hook and loop self-adhesive disks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A drill with 2-mm and 3-mm bits. This should be a small drill, preferably cordless.
    These are small parts, so precision is required more than power.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You’ll need a pencil to make draft lines with. Personally, I like mechanical
    pencils.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I recommend safety goggles when you drill or cut. Get a good comfortable pair—cheap
    uncomfortable ones might end up on your head instead of covering your eyes and
    won’t be protecting you.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For drilling and cutting, a hobby vise or clamp keeps the part still and your
    hands safe. A small bench vise is suitable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You need a flat work area with good lighting.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Screwdrivers**: You will want a screwdriver set. It should have Phillips
    (PH0 and PH1) and flat-bladed (2 mm and 3 mm) screwdrivers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spanner or wrenches in metric. Precision sets will be useful.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can purchase these items and tools from electronics, hobby, DIY, and tool
    stores. AliExpress, Alibaba, eBay, and Amazon will also have them. However, if
    you do not have all of these tools, it feels like a lot of stuff.
  prefs: []
  type: TYPE_NORMAL
- en: An alternative to buying all these tools is to find a makerspace or hackerspace
    near you. They will have most, if not all, of these tools. Makerspaces are community-run
    spaces, have collections of tools, and might even have scrap material of just
    the right kind of styrene. Additionally, they have other makers, who can lend
    you a hand and assist you if you run into difficulty with a robot project.
  prefs: []
  type: TYPE_NORMAL
- en: There are makerspaces in most cities globally. They can be easily found on search
    engines and social media. If there is no makerspace in your area, reaching out
    via social media to other makers might help you to find a similar community project.
    There is a global makerspace directory at [https://makerspaces.make.co/](https://makerspaces.make.co/).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about Raspberry Pi Pico, why it’s a good controller
    to build a robot around, and why we will be using CircuitPython to program it.
    You discovered the planning process of a robot, choosing parts for it, and then
    test-fitting them to ensure our plan is likely to work. You had a view of datasheets
    and discovered a little about the size and electrical characteristics of parts.
    You also had a tour of the parts you’ll need to buy and the tools you’ll need
    to work with them. Finally, you were introduced to makerspaces as places to find
    tools and other makers.
  prefs: []
  type: TYPE_NORMAL
- en: We have a rough robot plan. However, to start building something, we need to
    take some practical steps to prepare Raspberry Pi Pico for use in one. We’ll discover
    how to do this in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get you familiar with the content of this chapter, these additional exercises
    will attempt to test you on what you’ve learned, and prepare you for later sections:'
  prefs: []
  type: TYPE_NORMAL
- en: Find a datasheet for the Bluefruit LE UART Friend. Find the electrical current
    used by the device, along with its width and height for fitting it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are going to add such a Bluetooth board to our robot. Use the dimensions
    from the datasheet to make a part in your test-fit diagram.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Find a space on the robot for this part that does not overlap with other parts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Look on the websites of the previously mentioned stores. See if you can find
    out where you’d be able to buy this part.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Please refer to the following resources for more information:'
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about CircuitPython, the [https://circuitpython.readthedocs.io/](https://circuitpython.readthedocs.io/)
    website is a great resource.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a detailed look at Python on microcontrollers, please refer to *MicroPython
    Cookbook*, by *Marwan Alsabbagh*, *Packt Publishing*. This book has sections on
    CircuitPython and MicroPython in general.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Embedded Systems Architecture*, by *Daniele Lacamera*, *Packt Publishing*,
    offers an extensive dive into the I2C and SPI bus interfaces.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another perspective on makerspaces comes from *Progression of a Maker*, which
    can be found at [https://hub.packtpub.com/progression-maker/](https://hub.packtpub.com/progression-maker/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
