- en: Homogeneous Ensembles Using Keras
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Keras的同质集成
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: An ensemble of homogeneous models for energy prediction
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于能量预测的同质模型集成
- en: An ensemble of homogeneous models for handwritten digit classification
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于手写数字分类的同质模型集成
- en: Introduction
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: 'In the case of ensemble models, each base classifier must have some degree
    of diversity within itself. This diversity can be obtained in one of the following
    manners:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在集成模型的情况下，每个基础分类器必须在自身内部具有一定的多样性。这种多样性可以通过以下方式之一获得：
- en: By using different subsets of training data through various resampling methods
    or randomization of the training data
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用各种重采样方法或训练数据的随机化来使用不同的训练数据子集
- en: By using different learning hyperparameters for different base learners
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过为不同的基础学习器使用不同的学习超参数
- en: By using different learning algorithms
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用不同的学习算法
- en: In the case of ensemble models, where different algorithms are used for the
    base learners, the ensemble is called a **heterogeneous ensemble method**. If
    the same algorithm is used for all the base learners on different distributions
    of the training set, the ensemble is called a **homogeneous ensemble**.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在集成模型的情况下，如果基础学习器使用了不同的算法，则该集成被称为**异质集成方法**。如果所有基础学习器在不同的训练集分布上使用了相同的算法，则该集成被称为**同质集成**。
- en: An ensemble of homogeneous models for energy prediction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用于能量预测的同质模型集成
- en: In the following example, we will use the Keras API. Keras is an open source
    high-level framework for building deep neural networks. It's written on top of
    TensorFlow or Theano and uses them for its calculations behind the scenes. Keras
    can run on both CPU and GPU. The default settings of Keras are designed to deliver
    good results in most cases.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将使用Keras API。Keras是一个开源的高级框架，用于构建深度神经网络。它建立在TensorFlow或Theano之上，并在幕后使用它们进行计算。Keras可以在CPU和GPU上运行。Keras的默认设置旨在在大多数情况下提供良好的结果。
- en: The focus of Keras is the idea of a model. Keras supports two types of models.
    The main type of model is a sequence of layers, called **sequential**. The other
    type of model in Keras is the non-sequential model, called **model**.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Keras的重点是模型的概念。Keras支持两种类型的模型。主要类型的模型是一系列层，称为**顺序**。Keras中的另一种模型是非顺序模型，称为**模型**。
- en: 'To build a sequential model, carry out the following steps:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建一个顺序模型，执行以下步骤：
- en: Instantiate a sequential model using `Sequential()`
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Sequential()`实例化一个顺序模型
- en: Add layers to it one by one using the `Dense` class
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Dense`类逐个添加层
- en: 'Compile the model with the following:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下方式编译模型：
- en: A mandatory loss function
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个强制性的损失函数
- en: A mandatory optimizer
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个强制性的优化器
- en: Optional evaluation parameters
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选评估参数
- en: Use data to fit the model
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用数据拟合模型
- en: Evaluate the model
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 评估模型
- en: 'Here''s a diagrammatic flow of the preceding steps:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是前面步骤的流程图：
- en: '![](img/f89f4516-767a-4737-a6a6-dd1e6b30bd1d.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f89f4516-767a-4737-a6a6-dd1e6b30bd1d.png)'
- en: 'In the following code block, we can see a short code example:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码块中，我们可以看到一个简短的代码示例：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Getting ready
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We'll start by installing Keras. In order to install Keras, you will need to
    have Theano or TensorFlow installed in your system. In this example, we'll go
    with TensorFlow as the backend for Keras.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先安装Keras。为了安装Keras，您需要在您的系统中安装Theano或TensorFlow。在这个例子中，我们将选择TensorFlow作为Keras的后端。
- en: 'There are two variants of TensorFlow: a CPU version and a GPU version.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: TensorFlow有两种变体：CPU版本和GPU版本。
- en: 'To install the current CPU-only version, use the following command:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装当前仅CPU版本，请使用以下命令：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If you have to install the GPU package, use the following command:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您必须安装GPU包，请使用以下命令：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Once you''ve installed TensorFlow, you''ll need to install Keras using the
    following command:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 安装TensorFlow后，您需要使用以下命令安装Keras：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In order to upgrade your already-installed Keras library, use the following
    command:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了升级您已安装的Keras库，请使用以下命令：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Once we''re done with installing the libraries, let''s import the required
    libraries:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完库后，让我们导入所需的库：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We set our working directory according to our requirements:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们根据我们的要求设置我们的工作目录：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We read our `energydata.csv` dataset:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们读取我们的`energydata.csv`数据集：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We check whether there are any null values in our dataset:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们检查我们的数据集中是否有任何空值：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How to do it...
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We''ll now build our `test` subset and train our neural network models:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将构建我们的`test`子集并训练我们的神经网络模型：
- en: 'Separate the `test` subset to apply the models in order to make predictions:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`test`子集分离出来，以便应用模型进行预测：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Check the shape of the `train `and `test` subsets:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查`train`和`test`子集的形状：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Take the `test` subset and split it into target and feature variables:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`test`子集拆分为目标和特征变量：
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Validate the preceding split by checking the shape of `X_test` and `Y_test`:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过检查`X_test`和`Y_test`的形状来验证前面的拆分：
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let''s create multiple neural network models using Keras. We use `For...Loop`
    to build multiple models:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用Keras创建多个神经网络模型。我们使用`For...Loop`来构建多个模型：
- en: '[PRE13]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Take the summation of the predicted values and divide them by the number of iterations
    to get the average predicted values. We use the average predicted values to calculate
    the **mean-squared error** (**MSE**) for our ensemble:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将预测值的总和除以迭代次数，得到平均预测值。我们使用平均预测值来计算集成模型的**均方误差**（**MSE**）：
- en: '[PRE14]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: How it works...
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Here''s a diagrammatic representation of the ensemble homogeneous model workflow:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是集成同质模型工作流程的图示表示：
- en: '![](img/e78d32ca-81b3-482a-9bd6-5ece7e724693.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图示](img/e78d32ca-81b3-482a-9bd6-5ece7e724693.png)'
- en: In the preceding diagram, we assume that we have 100 train samples. We train
    100 models on our 100 train samples and apply them to our test sample. We get
    100 sets of predictions, which we ensemble by averaging whether the target variable
    is a numeric variable or whether we are calculating probabilities for a classification
    problem. In the case of class predictions, we would opt for max voting.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们假设我们有100个训练样本。我们在我们的100个训练样本上训练了100个模型，并将它们应用于我们的测试样本。我们得到了100组预测结果，通过平均是否目标变量是数值变量或是否在计算分类问题的概率来集成。在类别预测的情况下，我们会选择最大投票。
- en: In *Step 1*, we separated our train and test samples. This is the same test
    sample that we used for our predictions with all the models we built in this recipe.
    In *Step 2*, we checked the shape of the `train` and `test` subsets. In *Step
    3*, we split our test subset into target and predictor variables, and then checked
    the shape again in *Step 4* to ensure we got the right split.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤 1*中，我们分离了我们的训练和测试样本。这是我们在这个菜谱中构建的所有模型用于预测的相同测试样本。在*步骤 2*中，我们检查了`train`和`test`子集的形状。在*步骤
    3*中，我们将测试子集拆分为目标和预测变量，然后在*步骤 4*中再次检查形状，以确保我们得到了正确的拆分。
- en: In *Step 5*, we used the Keras library to build our neural network models. We
    initialized two variables, `ensemble` and `frac`. We used the `ensemble` variable
    to run a `for` loop for a certain number of iterations (in our case, we set it
    to `200`). We then used the `frac` variable to assign the proportion of data we
    took for our bootstrap samples from the training subset. In our example, we set
    `frac` to `0.8`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤 5*中，我们使用Keras库构建我们的神经网络模型。我们初始化了两个变量，`ensemble`和`frac`。我们使用`ensemble`变量运行一个循环，进行一定次数的迭代（在我们的例子中，我们将其设置为`200`）。然后我们使用`frac`变量来分配从训练子集中提取的bootstrap样本的数据比例。在我们的例子中，我们将`frac`设置为`0.8`。
- en: In *Step 5*, within the `for...loop` iteration, we built multiple neural network
    models and applied the models to our test subset to get the predictions. We created
    sequential models by passing a list of layers using the `add()` method. In the
    first layer, we specified the input dimensions using the `input_dim` argument.
    Because we have 24 input dimensions, we set `input_dim` to `24`. We also mentioned
    the `Activation` function to use in each layer by setting the `Activation` argument.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤 5*中，在`for...loop`循环迭代中，我们构建了多个神经网络模型，并将这些模型应用于我们的测试子集以获取预测结果。我们通过使用`add()`方法传递一个层列表来创建顺序模型。在第一层中，我们使用`input_dim`参数指定输入维度。因为我们有24个输入维度，所以将`input_dim`设置为`24`。我们还通过设置`Activation`参数提到了在每个层中要使用的`Activation`函数。
- en: 'You can also set the `Activation` function through an `Activation` layer, as
    follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以通过`Activation`层设置`Activation`函数，如下所示：
- en: '[PRE15]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In this step, before we build our model, we configure the learning process using
    the `compile` method. The `compile` method takes the mandatory `loss function`,
    the mandatory `optimizer`, and the optional `metrics` as an argument.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一步中，在我们构建模型之前，我们使用`compile`方法配置学习过程。`compile`方法接受必选的`loss function`、必选的`optimizer`和可选的`metrics`作为参数。
- en: The `optimizer` argument can take values such as **Stochastic Gradient Descent **(**SGD**), `RMSprop`,
    `Adagrad`, `Adadelta`, `Adam`, `Adamax`, or `Nadam`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`optimizer`参数可以取**随机梯度下降**（**SGD**）、`RMSprop`、`Adagrad`、`Adadelta`、`Adam`、`Adamax`或`Nadam`等值。'
- en: '`loss function` can take values such as `mean_squared_error`, `mean_absolute_error`, `mean_absolute_percentage_error`, `mean_squared_logarithmic_error`, `squared_hinge`, `categorical_hinge`,
    or `binary_crossentropy`. More details are available at [https://keras.io/losses/](https://keras.io/losses/).'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`loss function` 可以取值如 `mean_squared_error`、`mean_absolute_error`、`mean_absolute_percentage_error`、`mean_squared_logarithmic_error`、`squared_hinge`、`categorical_hinge`
    或 `binary_crossentropy`。更多详情请参阅 [https://keras.io/losses/](https://keras.io/losses/)。'
- en: We also keep adding the predictions array to an array variable, called `predictions_total`,
    using the `np.add()` method.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用 `np.add()` 方法将预测数组添加到名为 `predictions_total` 的数组变量中。
- en: Once we finished all the iterations in the `for` loop in *Step 5*, we divided
    the summation of predictions by the number of iterations, which is held in the
    `ensemble` variable and set to `200`, to get the average predictions. We used
    the average predictions to calculate the MSE of the ensemble result.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们在 *步骤 5* 中的 `for` 循环中完成了所有迭代，我们将预测的总和除以迭代次数，这个迭代次数存储在 `ensemble` 变量中，并设置为
    `200`，以获得平均预测。我们使用平均预测来计算集成结果的均方误差（MSE）。
- en: There's more...
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: If you have high computational requirements, you can use Google Colaboratory. Colaboratory
    is a free Jupyter notebook environment that requires no setup and runs entirely
    in the cloud. It's a free cloud service that supports free GPU. You can use Google
    Colab to build your deep learning applications using TensorFlow, Keras, PyTorch,
    and OpenCV.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你具有高计算需求，你可以使用 Google Colaboratory。Colaboratory 是一个免费的 Jupyter 笔记本环境，无需设置，完全在云端运行。它是一个免费的云服务，支持免费的
    GPU。你可以使用 Google Colab 来构建你的深度学习应用程序，使用 TensorFlow、Keras、PyTorch 和 OpenCV。
- en: Once you create your account with [https://colab.research.google.com/](https://colab.research.google.com/),
    you can log in using your credentials.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你使用 [https://colab.research.google.com/](https://colab.research.google.com/)
    创建了账户，你可以使用你的凭据登录。
- en: 'Once you''re logged in, you can move straight to the `File` menu to create
    your Python notebook:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你登录，你可以直接点击“文件”菜单来创建你的 Python 笔记本：
- en: '![](img/931b17de-964b-4ef9-a5ca-fbefd119a528.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/931b17de-964b-4ef9-a5ca-fbefd119a528.png)'
- en: Once you click on the File tab, you'll see New Python 3 notebook; a new notebook
    is created that supports Python 3.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你点击了“文件”标签，你会看到“新建 Python 3 笔记本”；一个支持 Python 3 的新笔记本将被创建。
- en: 'You can click on Untitled0.ipynb in the top-left corner to rename the file:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以点击左上角的 Untitled0.ipynb 来重命名文件：
- en: '![](img/b6b14a5c-e286-4f02-93f5-b9c58805fef2.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b6b14a5c-e286-4f02-93f5-b9c58805fef2.png)'
- en: 'Go to Edit and then Notebook settings. A window pops up to indicate the different
    settings that you can have:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 前往“编辑”然后“笔记本设置”。一个窗口会弹出，显示你可以有不同的设置：
- en: '![](img/1c957538-b972-4980-a900-d69544ed9fda.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1c957538-b972-4980-a900-d69544ed9fda.png)'
- en: Choose the **Graphics Processing Unit** (**GPU**) option as the Hardware accelerator,
    as shown in the preceding screenshot, in order to use the free GPU.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 选择**图形处理单元**（**GPU**）作为硬件加速器，如前面的截图所示，以便使用免费的 GPU。
- en: 'One neat thing about Google Colab is it can work on your own Google Drive. You
    can choose to create your own folder in your Google Drive or use the default Colab
    Notebooks folder. In order to use the default Google Colab Notebooks folder, follow
    the steps shown in the following screenshot:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 Google Colab 的一个很酷的事情是它可以在你自己的 Google Drive 上工作。你可以选择在你的 Google Drive 中创建自己的文件夹，或者使用默认的
    Colab 笔记本文件夹。为了使用默认的 Google Colab 笔记本文件夹，请按照以下截图中的步骤操作：
- en: '![](img/b21d3679-750f-4335-9a7f-74af17b93341.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b21d3679-750f-4335-9a7f-74af17b93341.png)'
- en: To start reading your datasets, you can store them in folders in Google Drive.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始读取你的数据集，你可以将它们存储在 Google Drive 的文件夹中。
- en: 'After you have logged in to Google Colab and created a new notebook, you will
    have to mount the drive by executing the following code in your notebook:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在你登录 Google Colab 并创建了一个新的笔记本之后，你必须在笔记本中执行以下代码来挂载驱动器：
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'When the preceding code is run, it will ask for the authorization code to be
    entered, as shown here:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行前面的代码时，它会要求输入授权码，如下所示：
- en: '![](img/4cad1459-aa85-4a26-92a2-e1ba88e9d95e.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4cad1459-aa85-4a26-92a2-e1ba88e9d95e.png)'
- en: 'Click on the preceding URL to get an authorization code:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 点击前面的 URL 获取授权码：
- en: '![](img/e49f2e8c-79d1-4314-abf4-74b6df76ed6e.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e49f2e8c-79d1-4314-abf4-74b6df76ed6e.png)'
- en: Paste the authorization code into the text box. You'll get a different authorization
    code each time. Upon authorization, the drive is mounted.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 将授权码粘贴到文本框中。每次授权时都会得到不同的授权码。授权后，驱动器将被挂载。
- en: Once the drive is mounted, you can read `.csv` file using `pandas`, as we showed
    earlier in the chapter. The rest of the code, as shown in the *How to do it* section,
    runs as it is. If you use the GPU, you'll notice that there is a substantial increase
    in the speed of your computational performance.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦挂载驱动器，您可以使用`pandas`读取`.csv`文件，就像我们在本章前面所展示的那样。其余的代码，如*如何做*部分所示，将按原样运行。如果您使用GPU，您会注意到您的计算性能速度有显著提高。
- en: In order to install additional libraries in Google Colab, you'll need to run
    the `pip install` command with a ! sign before it. For example, you can run `!pip
    install utils` to install utils in the Google Colab instance.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在Google Colab中安装额外的库，您需要运行带有!符号的`pip install`命令。例如，您可以在Google Colab实例中运行`!pip
    install utils`来安装utils。
- en: See also
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'There are various activation functions available for use with the Keras library:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Keras库中有各种激活函数可供使用：
- en: Softmax activation function
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Softmax激活函数
- en: Exponential linear unit
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指数线性单元
- en: Scaled exponential linear unit
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缩放指数线性单元
- en: Softplus activation function
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Softplus激活函数
- en: Rectified linear unit
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 矩形线性单元
- en: Hyperbolic tangent activation function
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 双曲正切激活函数
- en: Sigmoid activation function
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sigmoid激活函数
- en: Linear activation function
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线性激活函数
- en: Exponential activation function
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指数激活函数
- en: For more information about the preceding activation functions, visit [https://keras.io/activations/](https://keras.io/activations/).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 关于前面提到的激活函数的更多信息，请访问[https://keras.io/activations/](https://keras.io/activations/).
- en: An ensemble of homogeneous models for handwritten digit classification
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手写数字分类的同质模型集成
- en: In this example, we will use a dataset called The **Street View House Numbers**
    (**SVHN**) dataset from [http://ufldl.stanford.edu/housenumbers/](http://ufldl.stanford.edu/housenumbers/).
    The dataset is also provided in the GitHub in `.hd5f` format.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们将使用一个名为The **Street View House Numbers** (**SVHN**)的数据集，该数据集来自[http://ufldl.stanford.edu/housenumbers/](http://ufldl.stanford.edu/housenumbers/)。该数据集也以`.hd5f`格式提供在GitHub上。
- en: This dataset is a real-world dataset and is obtained from house numbers in Google
    Street View images.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 此数据集是一个真实世界的数据集，并从Google街景图像中的门牌号码获得。
- en: We use Google Colab to train our models. In the first phase, we build a single
    model using Keras. In the second phase, we ensemble multiple homogeneous models
    and ensemble the results.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用Google Colab来训练我们的模型。在第一阶段，我们使用Keras构建单个模型。在第二阶段，我们集成多个同质模型并将结果集成。
- en: Getting ready
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The dataset has 60,000 house number images. Each image is labeled between 1
    and 10\. Digit 1 is labelled as 1, digit 9 is labelled as 9, and digit 0 is labelled
    as 10\. The images are 32 x 32 images centered around a single character. In some
    cases, we can see the images are visually indistinct.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 该数据集包含60,000个门牌号码图像。每个图像标记为1到10之间。数字1标记为1，数字9标记为9，数字0标记为10。图像是围绕单个字符的32 x 32图像。在某些情况下，我们可以看到图像在视觉上不清晰。
- en: 'We import the required libraries:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入所需的库：
- en: '[PRE17]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We mount the Google Drive:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们挂载Google Drive：
- en: '[PRE18]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, we import a library called `h5py` to read the HDF5 format file and our data
    file, which is called `SVHN_single_grey.h5`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们导入一个名为`h5py`的库来读取HDF5格式文件和我们的数据文件，该文件称为`SVHN_single_grey.h5`：
- en: '[PRE19]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We load the training and test subsets and close the file:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们加载训练和测试子集，并关闭文件：
- en: '[PRE20]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We reshape our train and test subsets. We also change the datatype to float:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们重塑我们的训练和测试子集。我们还更改数据类型为浮点数：
- en: '[PRE21]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We now normalize our data by dividing it by 255.0\. This also converts the
    data type of the values to float:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在通过除以255.0来归一化我们的数据。这也将值的类型转换为浮点数：
- en: '[PRE22]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We check the shape of the train and test subsets:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们检查训练和测试子集的形状：
- en: '[PRE23]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We see that the shape of the `train` and `test` features and our target subsets
    are as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到`train`和`test`特征以及我们的目标子集的形状如下：
- en: '![](img/cfdbb7d5-3001-4dc6-b046-01dde8bf8b48.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cfdbb7d5-3001-4dc6-b046-01dde8bf8b48.png)'
- en: 'We visualize some of the images. We also print labels on top of the images:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可视化了一些图像。我们还在图像上方打印标签：
- en: '[PRE24]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The first 10 images are shown as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所示显示前10张图像：
- en: '![](img/ecbd6145-9449-460e-9e18-1cd953487adc.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ecbd6145-9449-460e-9e18-1cd953487adc.png)'
- en: 'We now perform one-hot encoding on our target variable. We also store our `y_test`
    labels in another variable, called `y_test_actuals`, for later use:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对目标变量进行独热编码。同时，我们将`y_test`标签存储在另一个变量中，称为`y_test_actuals`，以备后用：
- en: '[PRE25]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The shapes before and after one-hot encoding are as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 独热编码前后的形状如下：
- en: '![](img/81fa3c37-968c-4a24-8d35-a2a672133a44.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](img/81fa3c37-968c-4a24-8d35-a2a672133a44.png)'
- en: How to do it...
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We''ll now build a single model with the Keras library:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用Keras库构建一个单一模型：
- en: 'Build a linear stack of layers with the sequential model:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用序列模型构建一个线性的层堆叠：
- en: '[PRE26]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Compile the model:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译模型：
- en: '[PRE27]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Fit the model to the `train` data and validate it with the `test` data:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将模型拟合到`train`数据，并使用`test`数据进行验证：
- en: '[PRE28]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Plot the model''s accuracy at every epoch:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每个epoch绘制模型的准确率：
- en: '[PRE29]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We see the following model accuracy plot:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到以下模型准确率图：
- en: '![](img/a5b170b0-ef5f-41cc-9915-340b5d345445.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a5b170b0-ef5f-41cc-9915-340b5d345445.png)'
- en: 'Plot the loss at every epoch:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每个epoch绘制损失：
- en: '[PRE30]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We see the following model loss plot:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到以下模型损失图：
- en: '![](img/480f23ae-eb8f-43f0-ab1a-8f0f7347fa55.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/480f23ae-eb8f-43f0-ab1a-8f0f7347fa55.png)'
- en: 'Reuse the code from the scikit-learn website to plot the confusion matrix:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重用scikit-learn网站上的代码来绘制混淆矩阵：
- en: '[PRE31]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Plot the confusion matrix both numerically and graphically:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以数值和图形两种方式绘制混淆矩阵：
- en: '[PRE32]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The confusion matrix appears as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 混淆矩阵如下所示：
- en: '![](img/0744e47b-b9c7-464e-8753-4eed29c9d736.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0744e47b-b9c7-464e-8753-4eed29c9d736.png)'
- en: 'We''ll now look at how to ensemble the results of multiple homogeneous models.
    Define a function to fit the model to the training data:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将查看如何集成多个同质模型的成果。定义一个函数来将模型拟合到训练数据：
- en: '[PRE33]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Write a function to ensemble the predictions of all the models:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个函数来集成所有模型的预测：
- en: '[PRE34]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '`numpy.argmax`returns indices of the max element of the array in a particular
    axis.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`numpy.argmax`返回数组在特定轴上的最大元素的索引。'
- en: 'Write a function to evaluate the models and get the accuracy score of each
    model:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个函数来评估模型并获取每个模型的准确率分数：
- en: '[PRE35]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Fit all the models:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拟合所有模型：
- en: '[PRE36]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Plot the accuracy score against each epoch:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将准确率分数与每个epoch对应：
- en: '[PRE37]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: How it works...
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In *Step 1* to *Step 7*, we built a single neural network model to see how to
    use a labelled image dataset to train our model and predict the actual label for
    an unseen image.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第1步*到*第7步*中，我们构建了一个单一的神经网络模型，以了解如何使用标记的图像数据集来训练我们的模型并预测未见过的图像的实际标签。
- en: 'In *Step 1*, we built a linear stack of layers with the sequential model using
    Keras. We defined the three layers: one input layer, one hidden layer, and one
    output layer. We provided `input_shape=1024` to the input layer since we have
    32 x 32 images. We used the relu activation function in the first and second layers.
    Because ours is a multi-class classification problem, we used softmax as the activation
    function for our output layer.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第1步*中，我们使用Keras的序列模型构建了一个线性的层堆叠。我们定义了三个层：一个输入层、一个隐藏层和一个输出层。由于我们有32 x 32的图像，我们将`input_shape=1024`提供给输入层。我们在第一层和第二层使用了relu激活函数。因为这是一个多类分类问题，所以我们为输出层使用了softmax激活函数。
- en: In *Step 2*, we compiled the model with `loss='categorical_crossentropy'` and
    `optimizer='adam'`. In *Step 3*, we fitted our model to our train data and validated
    it on our test data.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第2步*中，我们使用`loss='categorical_crossentropy'`和`optimizer='adam'`编译了模型。在*第3步*中，我们将模型拟合到我们的训练数据，并在测试数据上验证它。
- en: In *Step 4* and* Step 5*, we plotted the model accuracy and the loss metric
    for every epoch.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第4步*和*第5步*中，我们绘制了每个epoch的模型准确率和损失指标。
- en: In *Step 6* and *Step 7*, we reused a `plot_confusion_matrix()` function from
    the scikit-learn website to plot our confusion matrix both numerically and visually.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第6步*和*第7步*中，我们重用了scikit-learn网站上的`plot_confusion_matrix()`函数来绘制我们的混淆矩阵，既以数值形式又以可视形式。
- en: 'From *Step 8* onward, we ensembled multiple models. We wrote three custom functions:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 从*第8步*开始，我们集成了多个模型。我们编写了三个自定义函数：
- en: '`train_models()`: To train and compile our model using sequential layers.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`train_models()`: 使用序列层训练和编译我们的模型。'
- en: '`ensemble_predictions()`: To ensemble the predictions and find the maximum
    value across classes for all observations.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ensemble_predictions()`: 对预测进行集成，并找到所有观察值跨类中的最大值。'
- en: '`evaluate_models()`: To calculate the accuracy score for every model.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`evaluate_models()`: 计算每个模型的准确率分数。'
- en: In *Step 11*, we fitted all the models. We set the `no_of_models` variable to
    `50`. We trained our models in a loop by calling the `train_models()` function.
    We then passed `x_train` and `y_train` to the `train_models()` function for every
    model built at every iteration. We also called `evaluate_models()`, which returned
    the accuracy scores of each model built. We then appended all the accuracy scores.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第11步*中，我们拟合了所有模型。我们将`no_of_models`变量设置为`50`。我们通过调用`train_models()`函数在循环中训练我们的模型。然后，我们将`x_train`和`y_train`传递给每个迭代中构建的每个模型的`train_models()`函数。我们还调用了`evaluate_models()`，它返回了每个构建的模型的准确率分数。然后，我们将所有准确率分数附加在一起。
- en: In *Step 12*, we plotted the accuracy scores for all the models.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第12步*中，我们绘制了所有模型的准确率分数。
