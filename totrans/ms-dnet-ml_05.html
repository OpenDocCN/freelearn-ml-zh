<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;5.&#xA0;Time Out &#x2013; Obtaining Data" id="12AK81-a18db0be6c20485ba81f22e43ca13055"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05" class="calibre1"/>Chapter 5. Time Out – Obtaining Data</h1></div></div></div><p class="calibre6">In this chapter, we are going to break from looking at various machine learning models. Instead, we are going to revisit some of the issues that I glossed over in <a class="calibre1" title="Chapter 2. AdventureWorks Regression" href="part0024_split_000.html#MSDG2-a18db0be6c20485ba81f22e43ca13055">Chapter 2</a>, <span class="strong"><em class="calibre11">AdventureWorks Regression</em></span>, <a class="calibre1" title="Chapter 3. More AdventureWorks Regression" href="part0029_split_000.html#RL0A2-a18db0be6c20485ba81f22e43ca13055">Chapter 3</a>, <span class="strong"><em class="calibre11">More AdventureWorks Regression</em></span>, and <a class="calibre1" title="Chapter 4. Traffic Stops – Barking Up the Wrong Tree?" href="part0032_split_000.html#UGI01-a18db0be6c20485ba81f22e43ca13055">Chapter 4</a>, <span class="strong"><em class="calibre11">Traffic Stops – Barking Up the Wrong Tree?</em></span>. We are going to look at different ways in which we can obtain data using Visual Studio and type providers. We will then look at how type providers help us solve problems of missing data, how we can use parallelism to speed up our data extraction, and how we can use type providers on secured web services.</p></div>

<div class="book" title="Chapter&#xA0;5.&#xA0;Time Out &#x2013; Obtaining Data" id="12AK81-a18db0be6c20485ba81f22e43ca13055">
<div class="book" title="Overview"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch05lvl1sec29" class="calibre1"/>Overview</h1></div></div></div><p class="calibre6">One of the underappreciated <a id="id240" class="calibre1"/>skills that a data scientist must possess is the ability to gather and assimilate heterogeneous data. Heterogeneous data is data from different sources, structures, and formats. Heterogeneous stands in contrast to homogenous data which assumes that all of the data that is imported is the same as all of the other data that may already exist. When the data scientist gets heterogeneous data, one of the first things they will do is transform the data to a point that it can be combined with the other data. The most common shape of that transformation is the<a id="id241" class="calibre1"/> <span class="strong"><strong class="calibre7">data frame</strong></span>—sometimes called the <span class="strong"><em class="calibre11">rectangle</em></span> because the columns are attributes and the rows are the data. For example, here is a data frame that we have seen earlier:</p><div class="mediaobject"><img src="../images/00070.jpeg" alt="Overview" class="calibre8"/></div><p class="calibre9"> </p><p class="calibre6">Ideally, each frame has a unique key that allows it to be combined with other data frames. In this case, <span class="strong"><strong class="calibre7">ProductID</strong></span> is<a id="id242" class="calibre1"/> the primary key. If you are thinking that this is a lot like RDBMS theory—you are right.</p><p class="calibre6">One of the bigger differences between a research analysts and a line of business developer is how they approach using data in their project. For the software engineer, data elements must<a id="id243" class="calibre1"/> be meticulously defined, created, and tracked. For the research analyst, all of that mental effort is noise that is tangential to solving the problem.</p><p class="calibre6">This is where the power of type providers comes in. Instead of spending any effort on extracting data, we spend our time transforming, shaping, and analyzing it.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="SQL Server providers"><div class="book" id="1394Q2-a18db0be6c20485ba81f22e43ca13055"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec30" class="calibre1"/>SQL Server providers</h1></div></div></div><p class="calibre6">Even though there is lots of buzz surrounding <code class="literal">no-sql</code> databases like MongoDb and unstructured data stores like <span class="strong"><em class="calibre11">data lakes</em></span> (or <span class="strong"><em class="calibre11">data swamps</em></span>, depending on your point of view), a significant percentage of data that our industry works with is still stored in relational databases. As we <a id="id244" class="calibre1"/>have seen in prior chapters, the data scientist must be able to effectively communicate with relational databases using SQL. However, we also saw that F# offers the ability to use something called a type provider to access SQL Server.</p></div>

<div class="book" title="SQL Server providers">
<div class="book" title="Non-type provider"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch05lvl2sec43" class="calibre1"/>Non-type provider</h2></div></div></div><p class="calibre6">Let's go back to the SQL that was used in <a class="calibre1" title="Chapter 3. More AdventureWorks Regression" href="part0029_split_000.html#RL0A2-a18db0be6c20485ba81f22e43ca13055">Chapter 3</a>, <span class="strong"><em class="calibre11">More AdventureWorks Regression</em></span>, to bring down the Average Orders, Average Reviews, and List Price for individual customers and see how to do<a id="id245" class="calibre1"/> it differently. Go into Visual Studio and create an F# Windows Library called <code class="literal">TypeProviders</code>.</p><p class="calibre6">Notice that I am using .NET<a id="id246" class="calibre1"/> Framework 4.5.2. The framework's minor version does not matter, as long as it is 4.x. It is important to note that you cannot use type providers with <span class="strong"><strong class="calibre7">Portable Class Libraries</strong></span> (<span class="strong"><strong class="calibre7">PCLs</strong></span>).</p><div class="mediaobject"><img src="../images/00071.jpeg" alt="Non-type provider" class="calibre8"/></div><p class="calibre9"> </p><p class="calibre6">Once Visual Studio <a id="id247" class="calibre1"/>generates the files for you, go ahead and delete <code class="literal">Library1.fs</code> and remove all the contents of <code class="literal">Script1.fsx</code>. Rename <code class="literal">Scipt1.fsx</code> to <code class="literal">SqlServerProviders.fsx</code>. Next, add a reference to <code class="literal">System.Transactions</code>:</p><div class="mediaobject"><img src="../images/00072.jpeg" alt="Non-type provider" class="calibre8"/></div><p class="calibre9"> </p><p class="calibre6">Go into <code class="literal">SqlServerProviders.fsx</code> and <a id="id248" class="calibre1"/>add this code (you can copy it from <a class="calibre1" title="Chapter 3. More AdventureWorks Regression" href="part0029_split_000.html#RL0A2-a18db0be6c20485ba81f22e43ca13055">Chapter 3</a>, <span class="strong"><em class="calibre11">More AdventureWorks Regression</em></span>, it is identical):</p><div class="informalexample"><pre class="programlisting">#r "System.Transactions.dll"

open System
open System.Text
open System.Data.SqlClient

type ProductInfo = {ProductID:int; AvgOrders:float; AvgReviews: float; ListPrice: float}

let productInfos = ResizeArray&lt;ProductInfo&gt;()

[&lt;Literal&gt;]
let connectionString = "data source=nc54a9m5kk.database.windows.net;initial catalog=AdventureWorks2014;user id= PacktReader;password= P@cktM@chine1e@rning;"

[&lt;Literal&gt;]
let query =
    "Select 
    A.ProductID, AvgOrders, AvgReviews, ListPrice
    From
    (Select 
    ProductID,
    (Sum(OrderQty) + 0.0)/(Count(Distinct SOH.CustomerID) + 0.0) as AvgOrders
    from [Sales].[SalesOrderDetail] as SOD
    inner join [Sales].[SalesOrderHeader] as SOH
    on SOD.SalesOrderID = SOH.SalesOrderID
    inner join [Sales].[Customer] as C
    on SOH.CustomerID = C.CustomerID
    Where C.StoreID is not null
    Group By ProductID) as A
    Inner Join 
    (Select
    ProductID,
    (Sum(Rating) + 0.0) / (Count(ProductID) + 0.0) as AvgReviews
    from [Production].[ProductReview] as PR
    Group By ProductID) as B
    on A.ProductID = B.ProductID
    Inner Join
    (Select
    ProductID,
    ListPrice
    from [Production].[Product]
    ) as C
    On A.ProductID = C.ProductID"
            
let connection = new SqlConnection(connectionString)
let command = new SqlCommand(query,connection)
connection.Open()
let reader = command.ExecuteReader()
while reader.Read() do
    productInfos.Add({ProductID=reader.GetInt32(0);
                        AvgOrders=(float)(reader.GetDecimal(1));
                        AvgReviews=(float)(reader.GetDecimal(2));
                        ListPrice=(float)(reader.GetDecimal(3));})

productInfos</pre></div><p class="calibre6">There are 52 lines of total code here, 26 of which are SQL inside the string called <code class="literal">query</code>. This seems like a lot of work for something that  appears to be pretty basic. Also, if we want to change our output<a id="id249" class="calibre1"/> rectangle, we would have to rewrite this SQL and hope we got it right. Also, we now need to know some fairly advanced SQL even though we don't care one whit that the data is stored in a SQL Server database. How can type providers help us here?</p></div></div>

<div class="book" title="SQL Server providers">
<div class="book" title="SqlProvider"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch05lvl2sec44" class="calibre1"/>SqlProvider</h2></div></div></div><p class="calibre6">Go back into Visual Studio, open up the nugget package manager, and enter this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">PM&gt; Install-Package SQLProvider -prerelease</strong></span>
</pre></div><p class="calibre6">Next, go into the script file <a id="id250" class="calibre1"/>and add this:</p><div class="informalexample"><pre class="programlisting">#r "../packages/SQLProvider.0.0.11-alpha/lib/ FSharp.Data.SQLProvider.dll"</pre></div><div class="informalexample" title="Note"><h3 class="title2"><a id="tip05" class="calibre1"/>Tip</h3><p class="calibre6"><span class="strong"><strong class="calibre7">Warning</strong></span></p><p class="calibre6">Type Providers are constantly changing their version number. Therefore, <code class="literal">SQLProvider.0.0.11</code> will fail unless you edit it. To determine the correct version, go into the packages folder in your solution and look at the path.</p></div><p class="calibre6">Once you put in the correct version of the provider, you might get a dialog box that looks like this (this is from the last chapter):</p><div class="mediaobject"><img src="../images/00073.jpeg" alt="SqlProvider" class="calibre8"/></div><p class="calibre9"> </p><p class="calibre6">Click on <span class="strong"><strong class="calibre7">Enable</strong></span>. Heading back to the script, go ahead and enter the following code:</p><div class="informalexample"><pre class="programlisting">open System
open System.Linq
open FSharp.Data.Sql

[&lt;Literal&gt;]
let connectionString = "data source=nc54a9m5kk.database.windows.net;initial catalog=AdventureWorks2014;user id= PacktReader;password= P@cktM@chine1e@rning;"

type AdventureWorks = SqlDataProvider&lt;Common.DatabaseProviderTypes.MSSQLSERVER,connectionString&gt;
let context = AdventureWorks.GetDataContext()

Sending that to the FSI gives us this:
val connectionString : string =
  "data source=nc54a9m5kk.database.windows.net;initial catalog=A"+[72 chars]
type AdventureWorks = SqlDataProvider&lt;...&gt;
val context : SqlDataProvider&lt;...&gt;.dataContext</pre></div><p class="calibre6">Enter the following code in the script file:</p><div class="informalexample"><pre class="programlisting">let customers =  
    query {for c in context.Sales.Customer do
           where (c.StoreId &gt; 0)
           select c.CustomerId}
           |&gt; Seq.toArray </pre></div><p class="calibre6">Sending that to the FSI <a id="id251" class="calibre1"/>gives us the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">val customers : int [] =</strong></span>
<span class="strong"><strong class="calibre7">  [|1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21;</strong></span>
<span class="strong"><strong class="calibre7">    22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36; 37; 38; 39; 40;</strong></span>
<span class="strong"><strong class="calibre7">    41; 42; 43; 44; 45; 46; 47; 48; 49; 50; 51; 52; 53; 54; 55; 56; 57; 58; 59;</strong></span>
<span class="strong"><strong class="calibre7">    60; 61; 62; 63; 64; 65; 66; 67; 68; 69; 70; 71; 72; 73; 74; 75; 76; 77; 78;</strong></span>
<span class="strong"><strong class="calibre7">    79; 80; 81; 82; 83; 84; 85; 86; 87; 88; 89; 90; 91; 92; 93; 94; 95; 96; 97;</strong></span>
<span class="strong"><strong class="calibre7">    98; 99; 100; ...|]</strong></span>
</pre></div><p class="calibre6">There are a couple of things to notice here. First, we are sending a query (sometimes referred to as a <span class="strong"><em class="calibre11">computational expression</em></span>) to the type provider. In this case, we are selecting all customers where the <code class="literal">storeId</code> is greater than <code class="literal">0</code>—the individual customers. The expression is everything between the <code class="literal">{}</code> symbols. Notice that it is LINQ-syntax, because it is LINQ. If you are not familiar, LINQ <a id="id252" class="calibre1"/>stands for <span class="strong"><strong class="calibre7">language Integrated Query</strong></span> and is a language within a language—it allows for querying capabilities to be placed inside your .NET language of choice. The other thing to notice is that the results of the expression are piped to our familiar F# <code class="literal">Seq</code> type. This means we can get any result from the expression and use <code class="literal">Seq</code> to further shape or refine the data. To see this in action, enter this into the script file:</p><div class="informalexample"><pre class="programlisting">let products = 
    query {for soh in context.Sales.SalesOrderHeader do
           join sod in context.Sales.SalesOrderDetail on (soh.SalesOrderId = sod.SalesOrderId)
           join c in context.Sales.Customer on (soh.CustomerId = c.CustomerId)
           join p in context.Production.Product on (sod.ProductId = p.ProductId)
           where (c.CustomerId |=| customers)
           select (p.ProductId)}
           |&gt; Seq.distinct
           |&gt; Seq.toArray </pre></div><p class="calibre6">When you send it to<a id="id253" class="calibre1"/> the FSI, you should see an array of product IDs:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">val products : int [] =</strong></span>
<span class="strong"><strong class="calibre7">  [|776; 777; 778; 771; 772; 773; 774; 714; 716; 709; 712; 711; 762; 758; 745;</strong></span>
<span class="strong"><strong class="calibre7">    743; 747; 715; 742; 775; 741; 708; 764; 770; 730; 754; 725; 765; 768; 753;</strong></span>
<span class="strong"><strong class="calibre7">    756; 763; 732; 729; 722; 749; 760; 726; 733; 738; 766; 755; 707; 710; 761;</strong></span>
<span class="strong"><strong class="calibre7">    748; 739; 744; 736; 767; 717; 769; 727; 718; 759; 751; 752; 750; 757; 723;</strong></span>
<span class="strong"><strong class="calibre7">    786; 787; 788; 782; 783; 779; 780; 781; 815; 816; 808; 809; 810; 823; 824;</strong></span>
</pre></div><p class="calibre6">Going back to the code, we are joining three tables<a id="id254" class="calibre1"/> from the <span class="strong"><strong class="calibre7">AdventureWorks</strong></span> database together via their foreign keys:</p><div class="informalexample"><pre class="programlisting">join sod in context.Sales.SalesOrderDetail on (soh.SalesOrderId = sod.SalesOrderId)
join c in context.Sales.Customer on (soh.CustomerId = c.CustomerId)
join p in context.Production.Product on (sod.ProductId = p.ProductId)</pre></div><p class="calibre6">In the next line, we are selecting only those customers that are in the customers' table that we created previously. Notice that we are using the F# <code class="literal">in</code> operator of <code class="literal">|=|</code>:</p><div class="informalexample"><pre class="programlisting">where (c.CustomerId |=| customers)</pre></div><p class="calibre6">Finally, we are selecting only the product IDs and then pulling down all of the values and then selecting the unique values:</p><div class="informalexample"><pre class="programlisting">select (p.ProductId)}
|&gt; Seq.distinct
|&gt; Seq.toArray</pre></div><p class="calibre6">Let's keep going and see what else we can do. Enter the following into the script:</p><div class="informalexample"><pre class="programlisting">let averageReviews = 
    query {for pr in context.Production.ProductReview do
            where (pr.ProductId |=| products)
            select pr}
            |&gt; Seq.groupBy(fun pr -&gt; pr.ProductId)
            |&gt; Seq.map(fun (id,a) -&gt; id, a |&gt; Seq.sumBy(fun pr -&gt; pr.Rating), a |&gt; Seq.length)
            |&gt; Seq.map( fun (id,r,c) -&gt; id, float(r)/float(c))
            |&gt; Seq.sortBy(fun (id, apr) -&gt; id)
            |&gt; Seq.toArray</pre></div><p class="calibre6">Sending this to the REPL we see:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">val averageReviews : (int * float) [] =</strong></span>
<span class="strong"><strong class="calibre7">  [|(749, 3.9); (750, 3.977272727); (751, 3.93877551); (752, 4.02173913);</strong></span>
<span class="strong"><strong class="calibre7">    (753, 3.939393939); (754, 3.965517241); (755, 3.628571429);</strong></span>
<span class="strong"><strong class="calibre7">    (756, 3.742857143); (757, 3.9375); (758, 3.845070423); (759, 3.483870968);</strong></span>
<span class="strong"><strong class="calibre7">    (760, 4.035874439);</strong></span>
</pre></div><p class="calibre6">In this block of code, we are pulling down all the reviews. We are then grouping the reviews by <code class="literal">productId</code>. From there, we can sum up the ratings and the count of the number of reviews (using <code class="literal">Seq.length</code>). We can then divide the total ratings amount by the number of reviews<a id="id255" class="calibre1"/> and get the average review for each <code class="literal">productId</code>. Finally, we throw in a <code class="literal">Seq.sortBy</code> and pipe it to an array. All of this F# code should be familiar as it is very similar to how we manipulated data in <a class="calibre1" title="Chapter 2. AdventureWorks Regression" href="part0024_split_000.html#MSDG2-a18db0be6c20485ba81f22e43ca13055">Chapter 2</a>, <span class="strong"><em class="calibre11">AdventureWorks Regression</em></span>, <a class="calibre1" title="Chapter 3. More AdventureWorks Regression" href="part0029_split_000.html#RL0A2-a18db0be6c20485ba81f22e43ca13055">Chapter 3</a>, <span class="strong"><em class="calibre11">More AdventureWorks Regression</em></span>, and <a class="calibre1" title="Chapter 4. Traffic Stops – Barking Up the Wrong Tree?" href="part0032_split_000.html#UGI01-a18db0be6c20485ba81f22e43ca13055">Chapter 4</a>, <span class="strong"><em class="calibre11">Traffic Stops – Barking Up the Wrong Tree?</em></span>.</p><p class="calibre6">Next, let's create a data frame (sometimes called a <span class="strong"><em class="calibre11">rectangle</em></span> of data if you are geometrically inclined) of prices for each product:</p><div class="informalexample"><pre class="programlisting">let listPrices = 
    query {for p in context.Production.Product do
            where (p.ProductId |=| products)
            select p}
            |&gt; Seq.map(fun p -&gt; p.ProductId, p.ListPrice)   
            |&gt; Seq.sortBy(fun (id, lp) -&gt; id)
            |&gt; Seq.toArray</pre></div><p class="calibre6">Sending that to the REPL, you should see the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">val listPrices : (int * decimal) [] =</strong></span>
<span class="strong"><strong class="calibre7">  [|(707, 34.9900M); (708, 34.9900M); (709, 9.5000M); (710, 9.5000M);</strong></span>
<span class="strong"><strong class="calibre7">    (711, 34.9900M); (712, 8.9900M); (714, 49.9900M); (715, 49.9900M);</strong></span>
<span class="strong"><strong class="calibre7">    (716, 49.9900M); (717, 1431.5000M); (718, 1431.5000M); (719, 1431.5000M);</strong></span>
<span class="strong"><strong class="calibre7">    (722, 337.2200M); (723, 337.2200M); (725, 337.2200M); (726, 337.2200M);</strong></span>
<span class="strong"><strong class="calibre7">    (727, 337.2200M)</strong></span>
</pre></div><p class="calibre6">This code does not introduce anything new. We pull down all of the products that are in our array, take the <code class="literal">productId</code> and <code class="literal">list price</code>, sort it, and send it to an array. Finally, enter the following into<a id="id256" class="calibre1"/> the script file:</p><div class="informalexample"><pre class="programlisting">let averageOrders = 
    query {for soh in context.Sales.SalesOrderHeader do
            join sod in context.Sales.SalesOrderDetail on (soh.SalesOrderId = sod.SalesOrderId)
            join c in context.Sales.Customer on (soh.CustomerId = c.CustomerId)
            where (c.CustomerId |=| customers)
            select (soh,sod)}
            |&gt; Seq.map (fun (soh,sod) -&gt; sod.ProductId, sod.OrderQty, soh.CustomerId)
            |&gt; Seq.groupBy (fun (pid,q,cid) -&gt; pid )
            |&gt; Seq.map (fun (pid,a) -&gt; pid, a |&gt; Seq.sumBy (fun (pid,q,cid) -&gt; q), a |&gt; Seq.distinctBy (fun (pid,q,cid) -&gt; cid))
            |&gt; Seq.map (fun (pid,q,a) -&gt; pid,q, a |&gt; Seq.length)
            |&gt; Seq.map (fun (pid,q,c) -&gt; pid, float(q)/float(c))
            |&gt; Seq.sortBy (fun (id, ao) -&gt; id)
            |&gt; Seq.toArray</pre></div><p class="calibre6">Sending this to the REPL gives us the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">val averageOrders : (int * float) [] =</strong></span>
<span class="strong"><strong class="calibre7">  [|(707, 17.24786325); (708, 17.71713147); (709, 16.04347826);</strong></span>
<span class="strong"><strong class="calibre7">    (710, 3.214285714); (711, 17.83011583); (712, 22.33941606);</strong></span>
<span class="strong"><strong class="calibre7">    (714, 15.35576923); (715, 22.82527881); (716, 13.43979058);</strong></span>
<span class="strong"><strong class="calibre7">    (717, 4.708737864); (718, 5.115789474); (719, 3.303030303);</strong></span>
</pre></div><p class="calibre6">This is a pretty sizable code block so it can look daunting. What we are doing is first pulling down all of the <code class="literal">SalesOrderHeaders</code> and <code class="literal">SalesOrderDetails</code> as a tuple select (<code class="literal">soh,sod</code>). We then pipe that set into a <code class="literal">Seq.map</code> that returns a sequence of a tuple that has three elements: <code class="literal">ProductId</code>, <code class="literal">OrderQty</code>, and <code class="literal">CustomerId |&gt; Seq.map(fun (soh,sod) -&gt; sod.ProductId, sod.OrderQty, soh.CustomerId)</code>. From there we pipe those tuples into a <code class="literal">groupBy</code> for the <code class="literal">ProductId |&gt; Seq.groupBy(fun (pid,q,cid) -&gt; pid)</code>. From there, we go a bit crazy. Take a look at the next line:</p><div class="informalexample"><pre class="programlisting">|&gt; Seq.map(fun (pid,a) -&gt; pid, a |&gt; Seq.sumBy(fun (pid,q,cid) -&gt; q), a |&gt; Seq.distinctBy(fun (pid,q,cid) -&gt; cid))</pre></div><p class="calibre6">Hopefully, you remember the discussion about <code class="literal">GroupBy</code>, so you realize that the input is a tuple of <code class="literal">ProductId</code> and an array of the three-item tuple of (<code class="literal">ProductId</code>, <code class="literal">OrderQty</code>, and <code class="literal">CustomerId</code>). We create a new three-item tuple that has <code class="literal">ProductId</code>, the sum of the <code class="literal">OrderQty</code>, and yet another tuple that has the <code class="literal">CustomerId</code> and a sequence of the distinct <code class="literal">customerId</code> items.</p><p class="calibre6">When we pipe this to the next line, we take the length of that last tuple (<code class="literal">CustomerId,</code> Array of <code class="literal">CustomerIds</code>) as that is the number of unique customers that ordered the product. The three-item tuple<a id="id257" class="calibre1"/> is <code class="literal">ProductId</code>, <code class="literal">SumOfQuantityOrdered</code>, and <code class="literal">CountOfUniqueCustomersThatOrdered</code>. Since that is a bit verbose, I used the standard tuple notation of <code class="literal">(pid, q, c)</code>, where <code class="literal">q</code> is SumOfQuan<code class="literal">t</code>ityOrdered and <code class="literal">c</code> is <code class="literal">CountOfUniqueCustomersThatOrdered</code>. This tuple is then piped to the following:</p><div class="informalexample"><pre class="programlisting">|&gt; Seq.map(fun (pid,q,c) -&gt; pid, float(q)/float(c))</pre></div><p class="calibre6">We can now get the average number of orders for each product. We then finish off with a sort and send it to an array. We now have three arrays of tuples:</p><div class="informalexample"><pre class="programlisting">averageOrders: ProductId, AverageNumberOfOrders
averageReviews: ProductId, AverageReviews
listPrices: ProductId, PriceOfProduct</pre></div><p class="calibre6">Ideally, we can then combine these into one array that has <code class="literal">ProductId</code>, <code class="literal">AverageNumberOfOrders</code>, <code class="literal">AverageReviews</code>, and <code class="literal">PriceOfProduct</code>. To do that, you might think that we can just zip these three arrays up. Go into the script and enter the following:</p><div class="informalexample"><pre class="programlisting">Seq.zip3 averageOrders  averageReviews  listPrices </pre></div><p class="calibre6">When you send it to the FSI, you will see something disappointing:</p><div class="informalexample"><pre class="programlisting">val it : seq&lt;(int * float) * (int * float) * (int * decimal)&gt; =
  seq
    [((707, 17.24786325), (749, 3.9), (707, 34.9900M));
     ((708, 17.71713147),</pre></div><p class="calibre6">The arrays are not matching up. Apparently, some products do not have any ratings. What we need is a way to join these three arrays into one array and have the join occur on the <code class="literal">ProductId</code>. Although we could go back and play around with our <code class="literal">where</code> clauses in the LINQ expressions, there is an alternative way.</p></div></div>

<div class="book" title="SQL Server providers">
<div class="book" title="Deedle"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch05lvl2sec45" class="calibre1"/>Deedle</h2></div></div></div><p class="calibre6">Go into<a id="id258" class="calibre1"/> the script file and enter <a id="id259" class="calibre1"/>the following code:</p><div class="informalexample"><pre class="programlisting">#load "../packages/FsLab.0.3.17/FsLab.fsx"
open Foogle
open Deedle
open FSharp.Data</pre></div><p class="calibre6">As we did earlier, you will have to make sure the version numbers match. When you send it to the REPL, you will see<a id="id260" class="calibre1"/> the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">[Loading F:\Git\MLDotNet\Book Chapters\Chapter05\TypeProviders.Solution\packages\FsLab.0.3.10\FsLab.fsx]</strong></span>

<span class="strong"><strong class="calibre7">namespace FSI_0009.FsLab</strong></span>
<span class="strong"><strong class="calibre7">  val server : Foogle.SimpleHttp.HttpServer option ref</strong></span>
<span class="strong"><strong class="calibre7">  val tempDir : string</strong></span>
<span class="strong"><strong class="calibre7">  val pid : int</strong></span>
<span class="strong"><strong class="calibre7">  val counter : int ref</strong></span>
<span class="strong"><strong class="calibre7">  val displayHtml : html:string -&gt; unit</strong></span>
<span class="strong"><strong class="calibre7">namespace FSI_0009.FSharp.Charting</strong></span>
<span class="strong"><strong class="calibre7">  type Chart with</strong></span>
<span class="strong"><strong class="calibre7">    static member</strong></span>
<span class="strong"><strong class="calibre7">      </strong></span>
<span class="strong"><strong class="calibre7">Line : data:Deedle.Series&lt;'K,#FSharp.Charting.value&gt; * ?Name:string *</strong></span>
<span class="strong"><strong class="calibre7">             ?Title:string * ?Labels:#seq&lt;string&gt; * ?Color:Drawing.Color *</strong></span>
</pre></div><p class="calibre6">What we have done is loaded <span class="strong"><strong class="calibre7">Deedle</strong></span>. Deedle is a neat library created for time-series analysis. Let's see if Deedle<a id="id261" class="calibre1"/> can help us with our unbalanced array issue. The first thing we want to do is to take our array of tuples and turn them into data frames. Enter this into the script:</p><div class="informalexample"><pre class="programlisting">let averageOrders' = Frame.ofRecords averageOrders
let listPrices' = Frame.ofRecords listPrices
let averageReviews' = Frame.ofRecords averageReviews</pre></div><p class="calibre6">Sending this to the FSI, you will see something like the following:</p><div class="informalexample"><pre class="programlisting">      Item1 Item2            
0  -&gt; 749   3.9              
1  -&gt; 750   3.97727272727273 
2  -&gt; 751   3.93877551020408 
3  -&gt; 752   4.02173913043478 
4  -&gt; 753   3.9393939393939</pre></div><p class="calibre6">Let's rename <code class="literal">Item1</code> and <code class="literal">Item2</code> to something that has a bit more meaning and make the first vector of the fame the primary key of the frame. Enter the following into the script file:</p><div class="informalexample"><pre class="programlisting">let orderNames = ["ProductId"; "AvgOrder"]
let priceNames = ["ProductId"; "Price"]
let reviewNames = ["ProductId"; "AvgReview"]

let adjustFrame frame headers =
    frame |&gt; Frame.indexColsWith headers
          |&gt; Frame.indexRowsInt "ProductId"
          |&gt; Frame.sortRowsByKey

let averageOrders'' = adjustFrame averageOrders' orderNames
let listPrices'' = adjustFrame listPrices' priceNames
let averageReviews'' = adjustFrame averageReviews' reviewNames
Sending that to the REPL, should see something like:
val averageReviews'' : Frame&lt;int,string&gt; =
  
       AvgReview        
749 -&gt; 3.9              
750 -&gt; 3.97727272727273 
751 -&gt; 3.93877551020408</pre></div><p class="calibre6">This code should be fairly self-explanatory. We are creating a function called <code class="literal">adjustFrame</code> that takes in<a id="id262" class="calibre1"/> two arguments: a data frame and an array of strings that will become the header<a id="id263" class="calibre1"/> values. We apply the headers via the first pipe, make the first column (<code class="literal">ProductId</code>) the <code class="literal">primaryKey</code> via the second pipe, and then sort the frame via the third pipe. We then apply this function to our three data frames: orders, prices, and reviews. Notice that we are using the tick notation.</p><p class="calibre6">From there, we can now combine the frames based on their key. Go to the script file and add this:</p><div class="informalexample"><pre class="programlisting">averageOrders'' |&gt; Frame.join JoinKind.Inner listPrices''
                |&gt; Frame.join JoinKind.Inner averageReviews''</pre></div><p class="calibre6">Sending this to the FSI, you should see the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">       AvgReview        Price     AvgOrder         </strong></span>
<span class="strong"><strong class="calibre7">749 -&gt; 3.9              3578.2700 4.47457627118644 </strong></span>
<span class="strong"><strong class="calibre7">750 -&gt; 3.97727272727273 3578.2700 4.72727272727273 </strong></span>
<span class="strong"><strong class="calibre7">751 -&gt; 3.93877551020408 3578.2700 4.875            </strong></span>
<span class="strong"><strong class="calibre7">752 -&gt; 4.02173913043478</strong></span>
</pre></div><p class="calibre6">Cool huh? Deedle is a very powerful library that you can use in a variety of scenarios.</p><p class="calibre6">Going back to our original task, we now have two different ways to pull data out from a database and transform it. When you do a side-by-side comparison of the ADO.NET SQL ways and the type-provider approach, there are some pretty strong arguments to be made to use the type provider method. First, <code class="literal">SqlDataProvider</code> is designed for most of the popular relational databases out there. If you moved your<a id="id264" class="calibre1"/> <span class="strong"><strong class="calibre7">AdventureWorks</strong></span> database from MS SQL Server to MySql, all you would have to change is the connection string and all the code would be the same. Second, consider that there is no SQL in the type provider implementation. Instead, we are using an F# computational expression to pick what tables and what records we want. This means we don't have to know any SQL and we have even more portability. If we move our AdventureWorks database to a NoSQL database like Mongo or DocumentDb, we would have to swap out a type provider and then change our connection string. Finally, consider our approach to the data using the type provider. We do not have to build any classes ahead of time to put our data into, as types are automatically generated for us.</p><p class="calibre6">Also, since we are bringing down small chunks of data to the client that are then transformed, we can run each step of our though process independently. I can't emphasize how important that is; we are extracting and transforming the data <a id="id265" class="calibre1"/>with small viewable steps that align with our thought process. We can spend our mental energy and time focusing<a id="id266" class="calibre1"/> on the problem at hand and not wading through the syntax of a language we may or may not be comfortable with. The downside of the type provider method is that it may be slower than the ADO.NET approach because there is less opportunity to hand-adjust query optimization. In this case, we are doing ad hoc data exploration and analysis on a small dataset so the performance differences are minor. However, even if it was a large dataset, I would still follow the software engineering mantra of, "Make it right. Then make it fast."</p></div></div>

<div class="book" title="SQL Server providers">
<div class="book" title="MicrosoftSqlProvider"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch05lvl2sec46" class="calibre1"/>MicrosoftSqlProvider</h2></div></div></div><p class="calibre6">Before we leave our discussion on type providers, I want to show another type provider that is built upon Entity <a id="id267" class="calibre1"/>Framework 7 that has a lot of promise, especially when you want to start using type providers as a replacement to your current ORM. It is called the <code class="literal">EntityFramework.MicrosoftSqlServer</code> type provider.</p><p class="calibre6">Go back to Visual Studio, open the package manager console and enter the following:</p><div class="informalexample"><pre class="programlisting">PM&gt; Install-Package FSharp.EntityFramework.MicrosoftSqlServer –Pre</pre></div><p class="calibre6">Next, go to your script file and enter the following:</p><div class="informalexample"><pre class="programlisting">#I @"..\packages" 
#r @"EntityFramework.Core.7.0.0-rc1-final\lib\net451\EntityFramework.Core.dll"
#r @"EntityFramework.MicrosoftSqlServer.7.0.0-rc1-final\lib\net451\EntityFramework.MicrosoftSqlServer.dll"
#r @"EntityFramework.Relational.7.0.0-rc1-final\lib\net451\EntityFramework.Relational.dll"
#r @"Inflector.1.0.0.0\lib\net45\Inflector.dll"
#r @"Microsoft.Extensions.Caching.Abstractions.1.0.0-rc1-final\lib\net451\Microsoft.Extensions.Caching.Abstractions.dll"
#r @"Microsoft.Extensions.Caching.Memory.1.0.0-rc1-final\lib\net451\Microsoft.Extensions.Caching.Memory.dll"
#r @"Microsoft.Extensions.Configuration.1.0.0-rc1-final\lib\net451\Microsoft.Extensions.Configuration.dll"
#r @"Microsoft.Extensions.Configuration.Abstractions.1.0.0-rc1-final\lib\net451\Microsoft.Extensions.Configuration.Abstractions.dll"
#r @"Microsoft.Extensions.Configuration.Binder.1.0.0-rc1-final\lib\net451\Microsoft.Extensions.Configuration.Binder.dll"
#r @"Microsoft.Extensions.DependencyInjection.1.0.0-rc1-final\lib\net451\Microsoft.Extensions.DependencyInjection.dll"
#r @"Microsoft.Extensions.Logging.1.0.0-rc1-final\lib\net451\Microsoft.Extensions.Logging.dll"
#r @"Microsoft.Extensions.Logging.Abstractions.1.0.0-rc1-final\lib\net451\Microsoft.Extensions.Logging.Abstractions.dll"
#r @"Microsoft.Extensions.OptionsModel.1.0.0-rc1-final\lib\net451\Microsoft.Extensions.OptionsModel.dll"
#r @"Microsoft.Extensions.Primitives.1.0.0-rc1-final\lib\net451\Microsoft.Extensions.Primitives.dll"
#r @"Remotion.Linq.2.0.1\lib\net45\Remotion.Linq.dll"
#r @"System.Collections.Immutable.1.1.36\lib\portable-net45+win8+wp8+wpa81\System.Collections.Immutable.dll"
#r @"System.Diagnostics.DiagnosticSource.4.0.0-beta-23516\lib\dotnet5.2\System.Diagnostics.DiagnosticSource.dll"
#r @"Ix-Async.1.2.5\lib\net45\System.Interactive.Async.dll"

#r "../packages/Microsoft.Extensions.DependencyInjection.Abstractions.1.0.0-rc1-final/lib/net451/Microsoft.Extensions.DependencyInjection.Abstractions.dll"
#r @"FSharp.EntityFramework.MicrosoftSqlServer.0.0.2.0-alpha\lib\net451\FSharp.EntityFramework.MicrosoftSqlServer.dll"</pre></div><p class="calibre6">Yes, I know that is a lot, but you only have to enter this once and you don't have to bring it over to your <code class="literal">.fs</code> file. If you don't want to copy and paste this code over to your script, you can just install all<a id="id268" class="calibre1"/> of Entity Framework, and these packages will be available. In any event, enter the following into the script file:</p><div class="informalexample"><pre class="programlisting">open System
open System.Data.SqlClient
open Microsoft.Data.Entity
open FSharp.Data.Entity

[&lt;Literal&gt;]
let connectionString = "data source=nc54a9m5kk.database.windows.net;initial catalog=AdventureWorks2014; user id= PacktReader;password= P@cktM@chine1e@rning;"

type AdventureWorks = SqlServer&lt;connectionString, Pluralize = true&gt;
let context = new AdventureWorks()
Sending this to the REPL will give you this:
    nested type Sales.SpecialOffer
    nested type Sales.SpecialOfferProduct
    nested type Sales.Store
    nested type dbo.AWBuildVersion
    nested type dbo.DatabaseLog
    nested type dbo.ErrorLog
  end
val context : AdventureWorks</pre></div><p class="calibre6">Go back to the script file and enter the following:</p><div class="informalexample"><pre class="programlisting">let salesOrderQuery = 
    query { for soh in context.``Sales.SalesOrderHeaders`` do
            join sod in context.``Sales.SalesOrderDetails`` on (soh.SalesOrderID = sod.SalesOrderID)
            where (soh.OrderDate &gt; DateTime(2013,5,1))
            select(soh)} |&gt; Seq.head</pre></div><p class="calibre6">When you send this to<a id="id269" class="calibre1"/> the FSI, you will see the <code class="literal">SalesOrderheader</code> Entity Framework type in all its glory:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">     FK_SalesOrderHeader_Address_BillToAddressID = null;</strong></span>
<span class="strong"><strong class="calibre7">     FK_SalesOrderHeader_CreditCard_CreditCardID = null;</strong></span>
<span class="strong"><strong class="calibre7">     FK_SalesOrderHeader_CurrencyRate_CurrencyRateID = null;</strong></span>
<span class="strong"><strong class="calibre7">     FK_SalesOrderHeader_Customer_CustomerID = null;</strong></span>
<span class="strong"><strong class="calibre7">     FK_SalesOrderHeader_SalesPerson_SalesPersonID = null;</strong></span>
<span class="strong"><strong class="calibre7">     FK_SalesOrderHeader_SalesTerritory_TerritoryID = null;</strong></span>
<span class="strong"><strong class="calibre7">     FK_SalesOrderHeader_ShipMethod_ShipMethodID = null;</strong></span>
<span class="strong"><strong class="calibre7">     Freight = 51.7855M;</strong></span>
<span class="strong"><strong class="calibre7">     ModifiedDate = 5/9/2013 12:00:00 AM;</strong></span>
<span class="strong"><strong class="calibre7">     OnlineOrderFlag = true;</strong></span>
<span class="strong"><strong class="calibre7">     OrderDate = 5/2/2013 12:00:00 AM;</strong></span>
<span class="strong"><strong class="calibre7">     PurchaseOrderNumber = null;</strong></span>
<span class="strong"><strong class="calibre7">     RevisionNumber = 8uy;</strong></span>
<span class="strong"><strong class="calibre7">     SalesOrderDetail = null;</strong></span>
<span class="strong"><strong class="calibre7">     SalesOrderHeaderSalesReason = null;</strong></span>
<span class="strong"><strong class="calibre7">     SalesOrderID = 50788;</strong></span>
<span class="strong"><strong class="calibre7">     SalesOrderNumber = "SO50788";</strong></span>
<span class="strong"><strong class="calibre7">     SalesPersonID = null;</strong></span>
<span class="strong"><strong class="calibre7">     ShipDate = 5/9/2013 12:00:00 AM;</strong></span>
<span class="strong"><strong class="calibre7">     ShipMethodID = 1;</strong></span>
<span class="strong"><strong class="calibre7">     ShipToAddressID = 20927;</strong></span>
<span class="strong"><strong class="calibre7">     Status = 5uy;</strong></span>
<span class="strong"><strong class="calibre7">     SubTotal = 2071.4196M;</strong></span>
<span class="strong"><strong class="calibre7">     TaxAmt = 165.7136M;</strong></span>
<span class="strong"><strong class="calibre7">     TerritoryID = 4;</strong></span>
<span class="strong"><strong class="calibre7">     TotalDue = 2288.9187M;</strong></span>
<span class="strong"><strong class="calibre7">     rowguid = 74fca7f8-654b-432f-95fb-0dd42b0e3cf1;}</strong></span>
<span class="strong"><strong class="calibre7">&gt;</strong></span>
</pre></div><p class="calibre6">The implications are that anything you do with Entity Framework, you can do with the type provider—with no upfront code. No templates, no designers, no nothin'.</p><p class="calibre6">Let's press on and see how the type provider handles null. Go into the script and enter the following:</p><div class="informalexample"><pre class="programlisting">let salesOrderQuery' = 
    query { for soh in context.``Sales.SalesOrderHeaders`` do
            join sod in context.``Sales.SalesOrderDetails`` on (soh.SalesOrderID = sod.SalesOrderID)
            join p in context.``Production.Products`` on (sod.ProductID = p.ProductID)
            where (soh.OrderDate &gt; DateTime(2013,5,1) &amp;&amp; p.ProductSubcategoryID =  new System.Nullable&lt;int&gt;(1))
            select(soh)} |&gt; Seq.head
salesOrderQuery'</pre></div><p class="calibre6">When you send this to<a id="id270" class="calibre1"/> the FSI, you will see something like the following:</p><div class="informalexample"><pre class="programlisting">     SalesPersonID = null;
     ShipDate = 5/9/2013 12:00:00 AM;
     ShipMethodID = 1;
     ShipToAddressID = 20927;
     Status = 5uy;
     SubTotal = 2071.4196M;
     TaxAmt = 165.7136M;
     TerritoryID = 4;
     TotalDue = 2288.9187M;
     rowguid = 74fca7f8-654b-432f-95fb-0dd42b0e3cf1;}
&gt;</pre></div><p class="calibre6">Notice that we have to use <code class="literal">System.Nullable&lt;int&gt;</code> in the <code class="literal">where</code> condition to account for the fact that <code class="literal">ProductSubcategoyID</code> is nullable on the database. This leads to one small <span class="strong"><em class="calibre11">gotcha</em></span> with using the type provider. You can't use the out of the box <code class="literal">|=|</code> operator to search for an array of values. For example, if you sent the following to the REPL:</p><div class="informalexample"><pre class="programlisting">let salesOrderQuery''' =
 query { for soh in context.``Sales.SalesOrderHeaders`` do
            join sod in context.``Sales.SalesOrderDetails`` on (soh.SalesOrderID = sod.SalesOrderID)
            join p in context.``Production.Products`` on (sod.ProductID = p.ProductID)
            where (soh.OrderDate &gt; DateTime(2013,5,1) &amp;&amp; p.ProductSubcategoryID |=| [|1;2;3|])
            select(soh)} |&gt; Seq.head</pre></div><p class="calibre6">You will get the following back:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">SqlServerProviders.fsx(199,105): error FS0001: This expression was expected to have type</strong></span>
<span class="strong"><strong class="calibre7">    Nullable&lt;int&gt;    </strong></span>
<span class="strong"><strong class="calibre7">&gt; but here has type</strong></span>
<span class="strong"><strong class="calibre7">    int  </strong></span>
</pre></div><p class="calibre6">We now need to <a id="id271" class="calibre1"/>create an array of nullable ints. Will that work?</p><div class="informalexample"><pre class="programlisting">let produceSubcategories = [|new System.Nullable&lt;int&gt;(1); new System.Nullable&lt;int&gt;(2); new System.Nullable&lt;int&gt;(3)|]

let salesOrderQuery''' = 
query { for soh in context.``Sales.SalesOrderHeaders`` do
        join sod in context.``Sales.SalesOrderDetails`` on (soh.SalesOrderID = sod.SalesOrderID)
        join p in context.``Production.Products`` on (sod.ProductID = p.ProductID)
        where (soh.OrderDate &gt; DateTime(2013,5,1) &amp;&amp; p.ProductSubcategoryID |=| produceSubcategories)
        select(soh)} |&gt; Seq.head</pre></div><p class="calibre6">Alas, no:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">System.ArgumentException: The input sequence was empty.</strong></span>
<span class="strong"><strong class="calibre7">Parameter name: source</strong></span>
<span class="strong"><strong class="calibre7">   at Microsoft.FSharp.Collections.SeqModule.Head[T](IEnumerable`1 source)</strong></span>
<span class="strong"><strong class="calibre7">   at &lt;StartupCode$FSI_0024&gt;.$FSI_0024.main@() in F:\Git\MLDotNet\Book Chapters\Chapter05\TypeProviders.Solution\TypeProviders\SqlServerProviders.fsx:line 206</strong></span>
<span class="strong"><strong class="calibre7">Stopped due to error</strong></span>
</pre></div><p class="calibre6">So there are a couple of ways out of this problem. Option number 1, is that you can create a function. Enter the following into your script file:</p><div class="informalexample"><pre class="programlisting">let isBikeSubcategory id =
    let produceSubcategories = [|new System.Nullable&lt;int&gt;(1);
    new System.Nullable&lt;int&gt;(2); new System.Nullable&lt;int&gt;(3)|]
    Array.contains id produceSubcategories

isBikeSubcategory(new System.Nullable&lt;int&gt;(1))
isBikeSubcategory(new System.Nullable&lt;int&gt;(6))

let salesOrderQuery''' = 
    query { for soh in context.``Sales.SalesOrderHeaders`` do
            join sod in context.``Sales.SalesOrderDetails`` on (soh.SalesOrderID = sod.SalesOrderID)
            join p in context.``Production.Products`` on (sod.ProductID = p.ProductID)
            where (soh.OrderDate &gt; DateTime(2013,5,1) &amp;&amp; isBikeSubcategory(p.ProductSubcategoryID))
            select(soh)} |&gt; Seq.head
salesOrderQuery'''</pre></div><p class="calibre6">Sending this to the FSI gives you the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">     Status = 5uy;</strong></span>
<span class="strong"><strong class="calibre7">     SubTotal = 2071.4196M;</strong></span>
<span class="strong"><strong class="calibre7">     TaxAmt = 165.7136M;</strong></span>
<span class="strong"><strong class="calibre7">     TerritoryID = 4;</strong></span>
<span class="strong"><strong class="calibre7">     TotalDue = 2288.9187M;</strong></span>
<span class="strong"><strong class="calibre7">     rowguid = 74fca7f8-654b-432f-95fb-0dd42b0e3cf1;}</strong></span>
<span class="strong"><strong class="calibre7">&gt;</strong></span>
</pre></div><p class="calibre6">There is no new <a id="id272" class="calibre1"/>code here. We created a function.</p><p class="calibre6">But wait! There's more! Go back to the script file and enter the following:</p><div class="informalexample"><pre class="programlisting">let produceSubcategories = [|new System.Nullable&lt;int&gt;(1);
new System.Nullable&lt;int&gt;(2); new System.Nullable&lt;int&gt;(3)|]
let (|=|) id a = Array.contains id a

let salesOrderQuery4 = 
    query { for soh in context.``Sales.SalesOrderHeaders`` do
            join sod in context.``Sales.SalesOrderDetails`` on (soh.SalesOrderID = sod.SalesOrderID)
            join p in context.``Production.Products`` on (sod.ProductID = p.ProductID)
            where (soh.OrderDate &gt; DateTime(2013,5,1) &amp;&amp; p.ProductSubcategoryID |=| produceSubcategories )
            select(soh)} |&gt; Seq.head
salesOrderQuery4</pre></div><p class="calibre6">So what is this line of code?</p><div class="informalexample"><pre class="programlisting">let (|=|) id a = Array.contains id a</pre></div><p class="calibre6">It is a function named <code class="literal">|=|</code> that takes in two parameters: the <code class="literal">id</code> to search and the array that gets searched. This function is called an <span class="strong"><em class="calibre11">infix</em></span> operator because we are assigning symbols to stand in for a more descriptive name. Consider how the <code class="literal">+</code> operator stands in for <span class="strong"><em class="calibre11">Add</em></span>. With that infix operator in place, we can go back and make our syntax more intuitive here:</p><div class="informalexample"><pre class="programlisting">where (soh.OrderDate &gt; DateTime(2013,5,1) &amp;&amp; p.ProductSubcategoryID |=| produceSubcategories )</pre></div><p class="calibre6">There is one more option to consider: just ditching the extra function and inlining <code class="literal">Array.contains</code>. Go back to the script and enter this in:</p><div class="informalexample"><pre class="programlisting">let produceSubcategories = [|new System.Nullable&lt;int&gt;(1);
new System.Nullable&lt;int&gt;(2); new System.Nullable&lt;int&gt;(3)|]

let salesOrderQuery5 = 
    query { for soh in context.``Sales.SalesOrderHeaders`` do
            join sod in context.``Sales.SalesOrderDetails`` on (soh.SalesOrderID = sod.SalesOrderID)
            join p in context.``Production.Products`` on (sod.ProductID = p.ProductID)
            where (soh.OrderDate &gt; DateTime(2013,5,1) &amp;&amp;  Array.contains p.ProductSubcategoryID produceSubcategories)
            select(soh)} |&gt; Seq.head
salesOrderQuery5</pre></div><p class="calibre6">Sending this to<a id="id273" class="calibre1"/> the REPL gives us the expected return:</p><div class="informalexample"><pre class="programlisting">     ShipDate = 5/9/2013 12:00:00 AM;
     ShipMethodID = 1;
     ShipToAddressID = 20927;
     Status = 5uy;
     SubTotal = 2071.4196M;
     TaxAmt = 165.7136M;
     TerritoryID = 4;
     TotalDue = 2288.9187M;
     rowguid = 74fca7f8-654b-432f-95fb-0dd42b0e3cf1;}
&gt;</pre></div><p class="calibre6">So we have three different ways to handle the problem. Do we pick the named function, the in-fix operator, or the in-line function? In this case, I would pick the in-fix operator because we are replacing an existing operator that should work and makes the line the most readable. Others might disagree and you have to be prepared as a data scientist to be able to read other people's code, so it is good that you are familiar with all three ways.</p></div></div>

<div class="book" title="SQL Server providers">
<div class="book" title="SQL Server type provider wrap up"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch05lvl2sec47" class="calibre1"/>SQL Server type provider wrap up</h2></div></div></div><p class="calibre6">I have already highlighted two SQL type providers in this chapter. There are actually five different type providers that you <a id="id274" class="calibre1"/>can use when accessing SQL databases that I know of, and there are certainly more. When you first start using F#, you might be confused about which one to use. For your reference, here is my basic run down:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="literal">FSharp.Data.TypeProviders.SqlServerProvider</code>: This is a part of Visual Studio install, is supported by Microsoft, and no new development is going on. Since this is<a id="id275" class="calibre1"/> the end of life, you would not want to use this.</li><li class="listitem"><code class="literal">FSharp.Data.TypeProviders.EntityFrameworkProvider</code>: This is a part of Visual Studio install, is supported by Microsoft, and no new development is going<a id="id276" class="calibre1"/> on. It is good for vanilla databases.</li><li class="listitem"><code class="literal">FSharp.Data.SqlClient</code>: This was created by the community. It is a very stable way to pass SQL commands to the server. It does not support LINQ-style computational <a id="id277" class="calibre1"/>expressions. It is good for CRUD-based<a id="id278" class="calibre1"/> F# operations.</li><li class="listitem"><code class="literal">FSharp.Data.SqlProvider</code>: This was created by the community in pre-release, so there is some<a id="id279" class="calibre1"/> instability. It is very good for doing LINQ-style computation expressions. It supports different RDMS like Oracle, MySQL, and SQL Server.</li><li class="listitem"><code class="literal">FSharp.EntityFramework.MicrosoftSqlServer</code>: This was created by the community. It is in its <a id="id280" class="calibre1"/>very early stages, but holds tons of promise to be a great replacement to traditional ORM coding. It is good for doing LINQ-style computation expressions.</li></ul></div></div></div>

<div class="book" title="SQL Server providers">
<div class="book" title="Non SQL type providers"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_6"><a id="ch05lvl2sec48" class="calibre1"/>Non SQL type providers</h2></div></div></div><p class="calibre6">Type providers are not just for relational database management systems. In fact, there are JSON type providers, XML type providers, CSV type providers, the list goes on. Let's take a look at a couple <a id="id281" class="calibre1"/>and see how we can use them to make some really interesting data frames based on heterogeneous data.</p><p class="calibre6">Go into Visual Studio and add a new script file called <code class="literal">NonSqlTypeProviders.fsx</code>. At the top, bring in all of the references that we'll be using and open up the needed libraries:</p><div class="informalexample"><pre class="programlisting">#load "../packages/FsLab.0.3.17/FsLab.fsx"

#I @"..\packages" 
#r @"EntityFramework.Core.7.0.0-rc1-final\lib\net451\EntityFramework.Core.dll"
#r @"EntityFramework.MicrosoftSqlServer.7.0.0-rc1-final\lib\net451\EntityFramework.MicrosoftSqlServer.dll"
#r @"EntityFramework.Relational.7.0.0-rc1-final\lib\net451\EntityFramework.Relational.dll"
#r @"Inflector.1.0.0.0\lib\net45\Inflector.dll"
#r @"Microsoft.Extensions.Caching.Abstractions.1.0.0-rc1-final\lib\net451\Microsoft.Extensions.Caching.Abstractions.dll"
#r @"Microsoft.Extensions.Caching.Memory.1.0.0-rc1-final\lib\net451\Microsoft.Extensions.Caching.Memory.dll"
#r @"Microsoft.Extensions.Configuration.1.0.0-rc1-final\lib\net451\Microsoft.Extensions.Configuration.dll"
#r @"Microsoft.Extensions.Configuration.Abstractions.1.0.0-rc1-final\lib\net451\Microsoft.Extensions.Configuration.Abstractions.dll"
#r @"Microsoft.Extensions.Configuration.Binder.1.0.0-rc1-final\lib\net451\Microsoft.Extensions.Configuration.Binder.dll"
#r @"Microsoft.Extensions.DependencyInjection.1.0.0-rc1-final\lib\net451\Microsoft.Extensions.DependencyInjection.dll"
#r @"Microsoft.Extensions.Logging.1.0.0-rc1-final\lib\net451\Microsoft.Extensions.Logging.dll"
#r @"Microsoft.Extensions.Logging.Abstractions.1.0.0-rc1-final\lib\net451\Microsoft.Extensions.Logging.Abstractions.dll"
#r @"Microsoft.Extensions.OptionsModel.1.0.0-rc1-final\lib\net451\Microsoft.Extensions.OptionsModel.dll"
#r @"Microsoft.Extensions.Primitives.1.0.0-rc1-final\lib\net451\Microsoft.Extensions.Primitives.dll"
#r @"Remotion.Linq.2.0.1\lib\net45\Remotion.Linq.dll"
#r @"System.Collections.Immutable.1.1.36\lib\portable-net45+win8+wp8+wpa81\System.Collections.Immutable.dll"
#r @"System.Diagnostics.DiagnosticSource.4.0.0-beta-23516\lib\dotnet5.2\System.Diagnostics.DiagnosticSource.dll"
#r @"Ix-Async.1.2.5\lib\net45\System.Interactive.Async.dll"
#r "../packages/Microsoft.Extensions.DependencyInjection.Abstractions.1.0.0-rc1-final/lib/net451/Microsoft.Extensions.DependencyInjection.Abstractions.dll"
#r @"FSharp.EntityFramework.MicrosoftSqlServer.0.0.2.0-alpha\lib\net451\FSharp.EntityFramework.MicrosoftSqlServer.dll"

open System
open Foogle
open Deedle
open FSharp.Data
open System.Data.SqlClient
open Microsoft.Data.Entity</pre></div><p class="calibre6">Send it to the REPL to make sure you have all of the needed libraries. In the script, add the following code to bring in data from our AdventureWorks SQL Server database. You will notice that I am<a id="id282" class="calibre1"/> piping straight to Deedle's dataframe:</p><div class="informalexample"><pre class="programlisting">[&lt;Literal&gt;]
let connectionString = "data source=nc54a9m5kk.database.windows.net;initial catalog=AdventureWorks2014;user id=chickenskills@nc54a9m5kk;password=sk1lzm@tter;"

type AdventureWorks = SqlServer&lt;connectionString, Pluralize = true&gt;
let context = new AdventureWorks()

let salesNames = ["Date"; "Sales"]
let salesByDay = 
    query { for soh in context.``Sales.SalesOrderHeaders`` do
            join sod in context.``Sales.SalesOrderDetails`` on (soh.SalesOrderID = sod.SalesOrderID)
            where (soh.OrderDate &gt; DateTime(2013,5,1))
            select(soh)}
            |&gt; Seq.countBy(fun soh -&gt; soh.OrderDate)
            |&gt; Frame.ofRecords
            |&gt; Frame.indexColsWith salesNames
            |&gt; Frame.indexRowsDate "Date"
            |&gt; Frame.sortRowsByKeySend it to the REPL to get this:
                         Sales 
5/2/2013 12:00:00 AM  -&gt; 9     
5/3/2013 12:00:00 AM  -&gt; 9     
:                        ...   
6/30/2014 12:00:00 AM -&gt; 96    </pre></div><p class="calibre6">Go back to the script and add some data that is stored in a CSV file from Yahoo Finance. In this case, it is the change in daily stock price for the Dow Jones Industrial Average:</p><div class="informalexample"><pre class="programlisting">let stockNames = ["Date"; "PriceChange"]
type Stocks = CsvProvider&lt;"http://ichart.finance.yahoo.com/table.csv?s=^DJI"&gt;
let dow = Stocks.Load("http://ichart.finance.yahoo.com/table.csv?s=^DJI")
let stockChangeByDay = 
    dow.Rows |&gt; Seq.map(fun r -&gt; r.Date, (r.``Adj Close`` - r.Open)/r.Open)
             |&gt; Frame.ofRecords
             |&gt; Frame.indexColsWith stockNames
             |&gt; Frame.indexRowsDate "Date"
             |&gt; Frame.sortRowsByKey</pre></div><p class="calibre6">Send it to the REPL to get the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">type Stocks = CsvProvider&lt;...&gt;</strong></span>
<span class="strong"><strong class="calibre7">val dow : CsvProvider&lt;...&gt;</strong></span>
<span class="strong"><strong class="calibre7">val stockChangeByDay : Frame&lt;int,string&gt; =</strong></span>
<span class="strong"><strong class="calibre7">  </strong></span>
<span class="strong"><strong class="calibre7">                          PriceChange                     </strong></span>
<span class="strong"><strong class="calibre7">1/29/1985 12:00:00 AM  -&gt; 0.0116614159112959501515062411  </strong></span>
<span class="strong"><strong class="calibre7">1/30/1985 12:00:00 AM  -&gt; -0.0073147907201291486627914499 </strong></span>
<span class="strong"><strong class="calibre7">:                         ...                             </strong></span>
<span class="strong"><strong class="calibre7">11/25/2015 12:00:00 AM -&gt; -0.000416362767587419771025076  </strong></span>
<span class="strong"><strong class="calibre7">11/27/2015 12:00:00 AM -&gt; 0.0004128690819110368634773694  </strong></span>
</pre></div><p class="calibre6">Go back to the script and add some data that is served up by an API in JSON format from Quandl. In this case, it is<a id="id283" class="calibre1"/> the number of sunspots recorded by the Royal Observatory in Belgium.</p><div class="informalexample"><pre class="programlisting">let sunspotNames = ["Date"; "Sunspots"]

type Sunspots = JsonProvider&lt;"https://www.quandl.com/api/v3/datasets/SIDC/SUNSPOTS_D.json?start_date=2015-10-01&amp;end_date=2015-10-01"&gt;
let sunspots = Sunspots.Load("https://www.quandl.com/api/v3/datasets/SIDC/SUNSPOTS_D.json?start_date=2013-05-01")
let sunspotsByDay = 
    sunspots.Dataset.Data |&gt; Seq.map(fun r -&gt; r.DateTime, Seq.head r.Numbers ) 
                          |&gt; Frame.ofRecords
                          |&gt; Frame.indexColsWith sunspotNames
                          |&gt; Frame.indexRowsDate "Date"
                          |&gt; Frame.sortRowsByKey</pre></div><p class="calibre6">When you send it to the FSI, you should get something like the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">val sunspotsByDay : Frame&lt;DateTime,string&gt; =</strong></span>
<span class="strong"><strong class="calibre7">  </strong></span>
<span class="strong"><strong class="calibre7">                          Sunspots </strong></span>
<span class="strong"><strong class="calibre7">5/1/2013 12:00:00 AM   -&gt; 142.0    </strong></span>
<span class="strong"><strong class="calibre7">5/2/2013 12:00:00 AM   -&gt; 104.0    </strong></span>
<span class="strong"><strong class="calibre7">:                         ...      </strong></span>
<span class="strong"><strong class="calibre7">10/30/2015 12:00:00 AM -&gt; 88.0     </strong></span>
<span class="strong"><strong class="calibre7">10/31/2015 12:00:00 AM -&gt; 83.0</strong></span>
</pre></div><p class="calibre6">Finally, go back to the script and join all three data frames:</p><div class="informalexample"><pre class="programlisting">let dataFrame = salesByDay |&gt; Frame.join JoinKind.Inner stockChangeByDay
                           |&gt; Frame.join JoinKind.Inner sunspotsByDay</pre></div><p class="calibre6">Sending that to the REPL gives:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">val dataFrame : Frame&lt;DateTime,string&gt; =</strong></span>
<span class="strong"><strong class="calibre7">  </strong></span>
<span class="strong"><strong class="calibre7">                         PriceChange                     Sales Sunspots </strong></span>
<span class="strong"><strong class="calibre7">5/2/2013 12:00:00 AM  -&gt; 0.0088858122275952653140731221  9     104.0    </strong></span>
<span class="strong"><strong class="calibre7">5/3/2013 12:00:00 AM  -&gt; 0.0095997784626598973212920005  9     98.0     </strong></span>
<span class="strong"><strong class="calibre7">:                        ...                             ...   ...      </strong></span>
<span class="strong"><strong class="calibre7">6/27/2014 12:00:00 AM -&gt; 0.0002931965456766616196704027  82    67.0     </strong></span>
<span class="strong"><strong class="calibre7">6/30/2014 12:00:00 AM -&gt; -0.0015363085597738848688182542 96    132.0    </strong></span>
</pre></div><p class="calibre6">We'll leave the process of creating a model to see if there is a relationship among the Down Jones Price Change <a id="id284" class="calibre1"/>and the number of sunspots on the amount of Sales by Day up to the reader. Before you get too carried away, you might want to consider this website about data elements that have no relation but are correlated (<a class="calibre1" href="http://tylervigen.com/spurious-correlations">http://tylervigen.com/spurious-correlations</a>). I think this is my<a id="id285" class="calibre1"/> favorite one:</p><div class="mediaobject"><img src="../images/00074.jpeg" alt="Non SQL type providers" class="calibre8"/></div><p class="calibre9"> </p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Combining data"><div class="book" id="147LC2-a18db0be6c20485ba81f22e43ca13055"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec31" class="calibre1"/>Combining data</h1></div></div></div><p class="calibre6">Sometimes <a id="id286" class="calibre1"/>the data that you obtain from a source system is incomplete. Consider this dataset of crash locations that was <a id="id287" class="calibre1"/>obtained from the State Department of Transportation office:</p><div class="mediaobject"><img src="../images/00075.jpeg" alt="Combining data" class="calibre8"/></div><p class="calibre9"> </p><p class="calibre6">Notice that latitude and longitude are missing and that location does not use a normal address/city/state pattern. Rather, it is <span class="strong"><strong class="calibre7">OnRoad</strong></span>, <span class="strong"><strong class="calibre7">Miles</strong></span>, <span class="strong"><strong class="calibre7">FromRoad</strong></span>, and <span class="strong"><strong class="calibre7">TowardRoad</strong></span>. Unfortunately, this is fairly common when getting data from public entities—systems may have been built before lat/lon became mainstream and the system's addressing might be designed to only work inside the system. This means we need a way to figure out the latitude and longitude from this atypical addressing.</p><p class="calibre6">If you pull the source code down from the site, you will see a couple of script files. The first is called <code class="literal">BingGeocode</code>. This is a script that goes out to the Bing maps API and returns a geolocation for a given address. The key thing is that, although Bing does not recognize <span class="strong"><strong class="calibre7">OnRoad</strong></span>/<span class="strong"><strong class="calibre7">FromRoad</strong></span>/<span class="strong"><strong class="calibre7">TowardRoad</strong></span>, it does recognize cross streets. Therefore, we can take a sample from the crash dataset of incidents that happened at or near intersections—which we can determine from the <span class="strong"><strong class="calibre7">OnRoad</strong></span>/<span class="strong"><strong class="calibre7">FromRoad</strong></span> as long as the <span class="strong"><strong class="calibre7">Miles</strong></span> value is fairly low. In fact, 90 percent of the records are within a quarter mile of an intersection.</p><p class="calibre6">If you inspect the code, you will see that there is nothing particularly new here. We use the JSON type provider to make the call to Bing, and we parse the results, using the <code class="literal">Option</code> type to return none or some Geolocation. If you want to run this on your machine, we will need to sign up for the <a id="id288" class="calibre1"/>Bing Map API developer program here (<a class="calibre1" href="https://www.bingmapsportal.com/">https://www.bingmapsportal.com/</a>) and put your value into the <code class="literal">apiKey</code>:</p><div class="informalexample"><pre class="programlisting">#r "../packages/FSharp.Data.2.2.5/lib/net40/FSharp.Data.dll"

open System.IO
open System.Text
open FSharp.Data

[&lt;Literal&gt;]
let sample = "..\Data\BingHttpGet.json"
type Context = JsonProvider&lt;sample&gt;

let getGeocode address =
    let apiKey = "yourApiKeyHere"
    let baseUri = "http://dev.virtualearth.net/REST/v1/Locations?q=" + address + "&amp;o=json&amp;key=" + apiKey
    let searchResult = Context.Load(baseUri)
    let resourceSets = searchResult.ResourceSets
    match resourceSets.Length with
    | 0 -&gt; None
    | _ -&gt; let resources = resourceSets.[0].Resources
           match resources.Length with
           | 0 -&gt; None
           | _ -&gt; let resource = resources.[0]
                  Some resource.GeocodePoints

let address = "1%20Microsoft%20Way%20Redmond%20WA%2098052"
let address' = "Webser st and Holtz ln Cary,NC"

getGeocode address'</pre></div><p class="calibre6">In the solution, there is another script file that does the actual heavy lifting of pulling the original crash data from the database, updating it with the latitude and longitude, and then putting it back into the database. This script file is called <code class="literal">UpdateCrashLatLon.fsx</code>. If you look at the code, the first part pulls down crashes that happened in the same town as the traffic stops and occurred within a quarter mile of an intersection. It then creates an address string that is passed to the Bing geocode file and creates a frame with the ID and the latitude and longitude. We then filter that Array with only the values that returned as some:</p><div class="informalexample"><pre class="programlisting">#r "../packages/FSharp.Data.2.2.5/lib/net40/FSharp.Data.dll"
#r "System.Data.Entity.dll"
#r "FSharp.Data.TypeProviders.dll"
#r "System.Data.Linq.dll"
#load "BingGeocode.fsx"

open System
open System.Data.Linq
open System.Data.Entity
open Microsoft.FSharp.Data.TypeProviders

[&lt;Literal&gt;]
let connectionString = "data source=nc54a9m5kk.database.windows.net;initial catalog=Traffic;user id=chickenskills@nc54a9m5kk;password=sk1lzm@tter;"

type EntityConnection = SqlEntityConnection&lt;connectionString,Pluralize = true&gt;
let context = EntityConnection.GetDataContext()

type Crash = {Id: int; OnRoad:string; FromRoad:string }

let trafficCrashes = 
    context.dbo_TrafficCrashes 
    |&gt; Seq.filter(fun tc -&gt; tc.MunicipalityId = Nullable&lt;int&gt;(13))
    |&gt; Seq.filter(fun tc -&gt; (float)tc.Miles &lt;= 0.25)
    |&gt; Seq.map(fun tc -&gt; {Id=tc.Id; OnRoad=tc.OnRoad; FromRoad=tc.FromRoad})
    |&gt; Seq.toArray

let trafficCrashes' = 
    trafficCrashes 
    |&gt; Array.map(fun c -&gt; c.Id, c.OnRoad + " and " + c.FromRoad + " Cary,NC")
    |&gt; Array.map(fun (i,l) -&gt; i, BingGeocode.getGeocode(l))

let trafficCrashes'' = 
    trafficCrashes' 
    |&gt; Array.filter(fun (i,p) -&gt; p.IsSome)
    |&gt; Array.map(fun (i,p) -&gt; i, p.Value.[0].Coordinates.[0], p.Value.[0].Coordinates.[1])</pre></div><p class="calibre6">There is one new line of code in this script: <code class="literal">#load "BingGeocode.fsx"</code>. This adds a reference to the script file we already created, so we can go ahead and invoke the <code class="literal">getGeocode()</code> function.</p><p class="calibre6">Before we update the database with our data, I wrote a script to write the data to the local disk:</p><div class="informalexample"><pre class="programlisting">//Write so we can continue to work without going to Bing again
//They throttle so you really only want to go there once
open System.IO
let baseDirectory = System.IO.DirectoryInfo(__SOURCE_DIRECTORY__)
let dataDirectory = baseDirectory.Parent.Parent.FullName + @"\Data"

use outFile = new StreamWriter(dataDirectory + @"\crashGeocode.csv")
trafficCrashes'' |&gt; Array.map (fun (i,lt,lg) -&gt; i.ToString() ,lt.ToString(), lg.ToString())
                 |&gt; Array.iter (fun (i,lt,lg) -&gt; outFile.WriteLine(sprintf "%s,%s,%s" i lt lg))
outFile.Flush
outFile.Close()</pre></div><p class="calibre6">As the comment says, Bing throttles how many requests you can make per hour. The last thing you want is to have to re-query Bing because you are experimenting with the data and get a 401 error back because you are at your limit. Rather, it is much better to bring it local once and work off a local copy.</p><p class="calibre6">With the data local, we can then pull down each record from the database that we want to update, update the lat/long, and write it back to the database:</p><div class="informalexample"><pre class="programlisting">type Crash' = {Id: int; Latitude: float; Longitude: float}

let updateDatabase (crash:Crash') =
    let trafficCrash = 
        context.dbo_TrafficCrashes 
        |&gt; Seq.find(fun tc -&gt; tc.Id = crash.Id)
    trafficCrash.Latitude &lt;- Nullable&lt;float&gt;(crash.Latitude)
    trafficCrash.Longitude &lt;- Nullable&lt;float&gt;(crash.Longitude)
    context.DataContext.SaveChanges() |&gt; ignore

open FSharp.Data
type CrashProvider = CsvProvider&lt;"../Data/crashGeocode.csv"&gt;
let crashes = 
    CrashProvider.Load("../Data/crashGeocode.csv").Rows
    |&gt; Seq.map(fun r -&gt; {Id=r.id; Latitude=float r.latitude; Longitude= float r.longitude})
    |&gt; Seq.toArray
    |&gt; Array.iter(fun c -&gt; updateDatabase(c))</pre></div></div>

<div class="book" title="Combining data">
<div class="book" title="Parallelism"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch05lvl2sec49" class="calibre1"/>Parallelism</h2></div></div></div><p class="calibre6">I want to show you one more trick that will greatly speed up your data extraction—parallelism. My machine has four cores, but only one core is being used in the prior example when making the API calls to Bing. It would be much faster if I could use all of the cores and make the<a id="id289" class="calibre1"/> requests in parallel. F# makes this a snap. As a demonstration, I re-queried Bing for the first 200 crash records and wrote the time out to the FSI:</p><div class="informalexample"><pre class="programlisting">let trafficCrashes = 
    context.dbo_TrafficCrashes
    |&gt; Seq.filter (fun tc -&gt; tc.MunicipalityId = Nullable&lt;int&gt;(13))
    |&gt; Seq.filter (fun tc -&gt; (float)tc.Miles &lt;= 0.25)
    |&gt; Seq.map (fun tc -&gt; {Id=tc.Id; OnRoad=tc.OnRoad; FromRoad=tc.FromRoad})
    |&gt; Seq.take 200
    |&gt; Seq.toArray

open System.Diagnostics
let stopwatch = Stopwatch()
stopwatch.Start()
let trafficCrashes' = 
    trafficCrashes 
    |&gt; Array.map (fun c -&gt; c.Id, c.OnRoad + " and " + c.FromRoad + " Cary,NC")
    |&gt; Array.map (fun (i,l) -&gt; i, BingGeocode.getGeocode(l))

stopwatch.Stop()
printfn "serial - %A" stopwatch.Elapsed.Seconds </pre></div><p class="calibre6">When I ran it, it took<a id="id290" class="calibre1"/> 33 seconds:</p><div class="informalexample"><pre class="programlisting">serial - 33</pre></div><p class="calibre6">Next, I added this code:</p><div class="informalexample"><pre class="programlisting">stopwatch.Reset()

open Microsoft.FSharp.Collections.Array.Parallel

stopwatch.Start()
let pTrafficCrashes' = 
    trafficCrashes 
    |&gt; Array.map (fun c -&gt; c.Id, c.OnRoad + " and " + c.FromRoad + " Cary,NC")
    |&gt; Array.Parallel.map (fun (i,l) -&gt; i, BingGeocode.getGeocode(l))

stopwatch.Stop()
printfn "parallel - %A" stopwatch.Elapsed.Seconds</pre></div><p class="calibre6">Notice that the only change was adding a reference to <code class="literal">Collections.Array.Parallel</code> and then considering the following line:</p><div class="informalexample"><pre class="programlisting">|&gt; Array.map (fun (i,l) -&gt; i, BingGeocode.getGeocode(l))</pre></div><p class="calibre6">Change this line to the following:</p><div class="informalexample"><pre class="programlisting">|&gt; Array.Parallel.map (fun (i,l) -&gt; i, BingGeocode.getGeocode(l))</pre></div><p class="calibre6">When I ran it, I saw this in the FSI:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">parallel - 12</strong></span>
</pre></div><p class="calibre6">So I got a 3x speed improvement by changing one line. Because F# was built from the ground-up with parallelism and async in mind, it is very easy to take advantage of these concepts. The other languages have these features bolted on and can be very cumbersome to use and often can lead to race conditions or worse.</p><p class="calibre6">There is one more<a id="id291" class="calibre1"/> thing to note when you are pulling mass data from a web service. Unless you explicitly code it, you have no real way of monitoring the progress. I<a id="id292" class="calibre1"/> often pop open Fiddler (<a class="calibre1" href="http://www.telerik.com/fiddler">http://www.telerik.com/fiddler</a>) and monitor the HTTP traffic to see how things are progressing.</p><div class="mediaobject"><img src="../images/00076.jpeg" alt="Parallelism" class="calibre8"/></div><p class="calibre9"> </p></div></div>

<div class="book" title="Combining data">
<div class="book" title="JSON type provider – authentication"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch05lvl2sec50" class="calibre1"/>JSON type provider – authentication</h2></div></div></div><p class="calibre6">The JSON type provider is a very handy tool, but there is a limitation to its out of the box implementation—it assumes that the web service does not have any authentication or the authentication token is <a id="id293" class="calibre1"/>part of the query string. Some <a id="id294" class="calibre1"/>datasets are not like that—in fact most web services use headers for authentication. Fortunately, there is a way to code around this.</p><p class="calibre6">Consider this open dataset—the NOAA archives (<a class="calibre1" href="http://www.ncdc.noaa.gov/cdo-web/webservices/v2">http://www.ncdc.noaa.gov/cdo-web/webservices/v2</a>). If you look <a id="id295" class="calibre1"/>at the solution that comes with the chapter, there is a script file called <code class="literal">GetWeatherData.fsx</code>. In this script, I picked a single zip code for the town where the traffic stops and crashes<a id="id296" class="calibre1"/> occurred and pulled down the daily precipitation:</p><div class="informalexample"><pre class="programlisting">#r "System.Net.Http.dll"
#r "../packages/FSharp.Data.2.2.5/lib/net40/FSharp.Data.dll"
 
open System
open System.Net
open FSharp.Data
open System.Net.Http
open System.Net.Http.Headers
open System.Collections.Generic

[&lt;Literal&gt;]
let uri = "http://www.ncdc.noaa.gov/cdo-web/api/v2/data?datasetid=GHCND&amp;locationid=ZIP:27519&amp;startdate=2012-01-01&amp;enddate=2012-12-31&amp;limit=1000"
let apiToken = "yourApiTokenHere"
use client = new WebClient()
client.Headers.Add("token", apiToken)
let resultJson = client.DownloadString(uri)

[&lt;Literal&gt;]
let weatherSample = "..\Data\NOAAHttpGet.json"
type weatherServiceContext = JsonProvider&lt;weatherSample&gt;
let searchResult = weatherServiceContext.Parse(resultJson)
let results = searchResult.Results

let dailyPrecipitation = 
    results 
    |&gt; Seq.where (fun r -&gt; r.Value &gt; 0)
    |&gt; Seq.groupBy (fun r -&gt; r.Date)
    |&gt; Seq.map (fun (d,a) -&gt; d, a |&gt; Seq.sumBy (fun r -&gt; r.Value))
    |&gt; Seq.sortBy (fun (d,c) -&gt; d) </pre></div><p class="calibre6">There is one thing new here. I am using the JSON type provider but the authorization token needs to be in the header of the request. Since the JSON type provider does not allow you to set headers, you need to pull the data down via the <code class="literal">System.Net.WebClient</code> class (where you can set the <code class="literal">auth</code> token in the header) and then use the JSON type provider to parse the results. You can see that I am using <code class="literal">Parse()</code> and not <code class="literal">Load()</code> in the following line to accomplish that:</p><div class="informalexample"><pre class="programlisting">let searchResult = weatherServiceContext.Parse(resultJson)</pre></div><p class="calibre6">Just like the geolocation data, I then pushed the data frame to disk because the number of requests are limited:</p><div class="informalexample"><pre class="programlisting">open System.IO
let baseDirectory = System.IO.DirectoryInfo(__SOURCE_DIRECTORY__)
let dataDirectory = baseDirectory.Parent.Parent.FullName + @"\Data"

use outFile = new StreamWriter(dataDirectory + @"\dailyPrecipitation.csv")
dailyPrecipitation 
    |&gt; Seq.map(fun (d,p) -&gt; d.ToString(), p.ToString())
    |&gt; Seq.iter(fun (d,p) -&gt; outFile.WriteLine(sprintf "%s,%s" d p))

outFile.Flush
outFile.Close()</pre></div><p class="calibre6">Also, like the data geolocation data, you can do this on your machine but you will need an <code class="literal">apiToken</code>. You can go to the NOAA developer website to apply for one. I also added the data as a table on the SQL Server so you don't have to pull the data from the source code to write the remaining<a id="id297" class="calibre1"/> code in the chapter. Go into the active <code class="literal">kmeans.fsx</code> script file and enter this to get the data from the database:</p><div class="informalexample"><pre class="programlisting">type DailyPercipitation = {WeatherDate: DateTime; Amount: int; }
let dailyWeather = 
    context.dbo_DailyPercipitation 
    |&gt; Seq.map(fun dw -&gt; {WeatherDate=dw.RecordDate; Amount=dw.Amount;})
    |&gt; Seq.toArray</pre></div><p class="calibre6">When you send it to the FSI, you will get the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">type DailyPercipitation =</strong></span>
<span class="strong"><strong class="calibre7">  {WeatherDate: DateTime;</strong></span>
<span class="strong"><strong class="calibre7">   Amount: int;}</strong></span>
<span class="strong"><strong class="calibre7">val dailyWeather : DailyPercipitation [] =</strong></span>
<span class="strong"><strong class="calibre7">  [|{WeatherDate = 1/9/2012 12:00:00 AM;</strong></span>
<span class="strong"><strong class="calibre7">      Amount = 41;};</strong></span>
<span class="strong"><strong class="calibre7">    {WeatherDate = 1/10/2012 12:00:00 AM;</strong></span>
<span class="strong"><strong class="calibre7">      Amount = 30;}; {WeatherDate = 1/11/2012 12:00:00 AM;</strong></span>
<span class="strong"><strong class="calibre7">      Amount = 5;};</strong></span>
<span class="strong"><strong class="calibre7">    {WeatherDate = 1/12/2012 12:00:00 AM;</strong></span>
<span class="strong"><strong class="calibre7">     Amount = 124;}; </strong></span>
<span class="strong"><strong class="calibre7">    {WeatherDate = 1/13/2012 12:00:00 AM;</strong></span>
<span class="strong"><strong class="calibre7">     Amount = 5;}; </strong></span>
<span class="strong"><strong class="calibre7">    {WeatherDate = 1/21/2012 12:00:00 AM;</strong></span>
<span class="strong"><strong class="calibre7">...</strong></span>
</pre></div></div></div>
<div class="book" title="Summary" id="1565U1-a18db0be6c20485ba81f22e43ca13055"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec32" class="calibre1"/>Summary</h1></div></div></div><p class="calibre6">If you ask a data scientist what they like least about their day, they will tell you meetings, building slide decks, and munging data in no particular order. Although F# type providers can't help you with meetings and building slide decks, it can decrease the amount of time spent obtaining and cleaning data. Although not completely frictionless, type providers can help you with relational and non-relational data stores and enable you to spend more time with the "fun" parts of data science. Speaking of which, let's jump back into the fun with KNN and Naïve Bayes modeling.</p></div></body></html>