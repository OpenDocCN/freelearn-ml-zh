- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Getting Started with Prophet
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用Prophet
- en: Prophet is an open source piece of software, which means that the entirety of
    the underlying code is freely available to anyone to inspect and modify. This
    gives Prophet a great deal of power, as any user can add features or fix bugs,
    but it also has its downsides. Many closed source software packages, such as Microsoft
    Word or Tableau, come packaged in their own independent installation file with
    a neat graphical user interface to not only walk users through installation but
    also enable them to interact with the software once it has been installed.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Prophet 是一个开源软件，这意味着其底层代码的整个内容对任何人都是免费可检查和修改的。这使得Prophet具有很大的力量，因为任何用户都可以添加功能或修复错误，但它也有其缺点。许多封闭源代码软件包，如Microsoft
    Word或Tableau，都包含在其独立的安装文件中，具有整洁的图形用户界面，不仅可以帮助用户完成安装，而且一旦安装完毕，还可以与软件进行交互。
- en: Prophet, in contrast, is accessed through either the **Python** or **R** programming
    language and depends upon many additional open source libraries. This gives it
    great flexibility, as users can tweak features or even add entirely new ones to
    suit their specific problem, but it comes with the downside of potentially difficult
    usability. That’s what this book aims to simplify.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 与之相反，Prophet通过 **Python** 或 **R** 编程语言访问，并依赖于许多额外的开源库。这使得它具有很大的灵活性，因为用户可以调整功能或甚至添加全新的功能以适应他们特定的需求，但这也带来了潜在的可用性困难。这正是本书旨在简化的目标。
- en: In this chapter, we will walk you through the entire installation procedure
    depending upon which operating system you use, and then we will build our first
    forecast together by modeling the atmospheric carbon dioxide levels over the last
    few decades.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将根据您使用的操作系统，向您展示整个安装过程，然后我们将通过模拟过去几十年大气二氧化碳水平来共同构建我们的第一个预测模型。
- en: 'In full, this chapter will cover the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将全面涵盖以下内容：
- en: Installing Prophet
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装Prophet
- en: Building a simple model in Prophet
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Prophet中构建简单模型
- en: Interpreting the forecast DataFrame
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解读预测DataFrame
- en: Understanding components plots
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解组件图
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The data files and code for examples in this chapter can be found at [https://github.com/PacktPublishing/Forecasting-Time-Series-Data-with-Prophet-Second-Edition](https://github.com/PacktPublishing/Forecasting-Time-Series-Data-with-Prophet-Second-Edition).
    In this chapter, we will walk through the process of installing many of the requirements.
    So, to begin this chapter, it is only necessary that you have a Windows, macOS,
    or Linux machine capable of running Anaconda with Python 3.7+.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章示例的数据文件和代码可以在 [https://github.com/PacktPublishing/Forecasting-Time-Series-Data-with-Prophet-Second-Edition](https://github.com/PacktPublishing/Forecasting-Time-Series-Data-with-Prophet-Second-Edition)
    找到。在本章中，我们将介绍安装许多要求的过程。因此，为了开始本章，您只需要拥有一台能够运行Anaconda和Python 3.7+的Windows、macOS或Linux机器。
- en: Installing Prophet
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Prophet
- en: Installing Prophet on your machine is a straightforward process. However, under
    the hood, Prophet depends upon the **Stan** programming language, and installing
    **PyStan**, the Python interface for it, is unfortunately not so straightforward
    because it requires many non-standard compilers.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的机器上安装Prophet是一个简单的过程。然而，在底层，Prophet依赖于 **Stan** 编程语言，而安装其Python接口 **PyStan**
    并不简单，因为它需要许多非标准编译器。
- en: But don’t worry, because there is a really easy way to get Prophet and all dependencies
    installed, no matter which operating system you use, and that is through Anaconda.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 但别担心，因为有一个非常简单的方法来安装Prophet及其所有依赖项，无论您使用哪种操作系统，那就是通过Anaconda。
- en: '**Anaconda** is a free distribution of Python that comes bundled with hundreds
    of additional Python packages that are useful for data science, along with the
    package management system **conda**. This is in contrast to installing the Python
    language from its source on [https://www.python.org/](https://www.python.org/),
    which will include the default Python package manager, called **pip**.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**Anaconda** 是一个免费的Python发行版，它捆绑了数百个对数据科学有用的Python包，以及包管理系统 **conda**。这与从 [https://www.python.org/](https://www.python.org/)
    的源代码安装Python语言形成对比，后者将包括默认的Python包管理器，称为 **pip**。'
- en: When `pip` installs a new package, it will install any dependencies without
    checking whether these dependent Python packages will conflict with others. This
    can be a particular problem when one package is dependent on one version, while
    another package requires a different version. You may have, for example, a working
    installation of Google’s TensorFlow package, which requires the NumPy package
    to work with large, multidimensional arrays, and use `pip` to install a new package
    that specifies a different NumPy version as a dependency.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `pip` 安装一个新的包时，它将安装所有依赖项，而不会检查这些依赖的 Python 包是否会与其他包冲突。当其中一个包依赖于一个版本，而另一个包需要不同版本时，这可能会成为一个特别的问题。例如，你可能有一个
    Google 的 TensorFlow 包的工作安装，该包需要 NumPy 包来处理大型多维数组，并使用 `pip` 安装一个指定不同 NumPy 版本作为依赖项的新包。
- en: The different version of NumPy would then overwrite the other version and you
    may find that TensorFlow suddenly doesn’t work as expected, or even at all. In
    contrast, `conda` will analyze the current environment and work out on its own
    how to install a compatible set of dependencies for all installed packages and
    provide a warning if this cannot be done.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，不同的 NumPy 版本将覆盖其他版本，你可能会发现 TensorFlow 突然无法按预期工作，甚至完全无法工作。相比之下，`conda` 将分析当前环境，并自行确定如何为所有已安装的包安装兼容的依赖集，如果无法完成，将提供警告。
- en: PyStan, and many other Python tools, for that matter, require compilers written
    in the C language. These types of dependencies are unable to be installed using
    `pip`, but Anaconda already includes them. Therefore, it *is strongly recommended
    to first* *install Anaconda*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: PyStan 以及许多其他 Python 工具，实际上都需要用 C 语言编写的编译器。这类依赖无法使用 `pip` 安装，但 Anaconda 已经包含了它们。因此，**强烈建议首先**
    **安装 Anaconda**。
- en: If you already have a Python environment that you are happy with and do not
    want to install the full Anaconda distribution, there is a much smaller version
    available called `conda`, Python, and a small number of required packages. Although
    it is technically possible to install Prophet and all dependencies without Anaconda,
    it can be extremely difficult and the procedure varies a great deal depending
    on the machine in use, so writing a single guide to cover all scenarios is nearly
    impossible.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经有一个你满意的 Python 环境，并且不想安装完整的 Anaconda 发行版，有一个更小的版本可供选择，称为 `conda`，Python
    以及一小部分必需的包。虽然技术上可以在没有 Anaconda 的情况下安装 Prophet 及其所有依赖项，但这可能非常困难，而且过程会因使用的机器而大不相同，因此编写一个涵盖所有场景的单个指南几乎是不可能的。
- en: This guide assumes that you will begin with an Anaconda or Miniconda installation,
    with Python 3 or greater. If you’re unsure of whether you want Anaconda or Miniconda,
    go with Anaconda. Note that the full Anaconda distribution will require about
    3 GB of space on your computer due to all of the packages included, so if space
    is an issue, you should consider Miniconda instead.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 本指南假设你将从一个 Anaconda 或 Miniconda 安装开始，使用 Python 3 或更高版本。如果你不确定是否想要 Anaconda 或
    Miniconda，选择 Anaconda。请注意，由于包含了所有包，完整的 Anaconda 发行版将需要你的电脑上大约 3 GB 的空间，因此如果空间是个问题，你应该考虑
    Miniconda。
- en: Important note
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: As of Prophet version 0.6, Python 2 is no longer supported. Be sure that you
    have Python 3.7+ installed on your machine before proceeding. Installing Anaconda
    is strongly recommended.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 截至 Prophet 版本 0.6，Python 2 已不再受支持。在继续之前，请确保你的机器上已安装 Python 3.7+。强烈建议安装 Anaconda。
- en: Installation on macOS
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: macOS 上的安装
- en: 'If you do not already have Anaconda or Miniconda installed, that should be
    your first step. Instructions for installing Anaconda can be found in the Anaconda
    documentation at [https://docs.anaconda.com/anaconda/install/mac-os/](https://docs.anaconda.com/anaconda/install/mac-os/).
    If you know that you want Miniconda over Anaconda, start here: [https://docs.conda.io/projects/continuumio-conda/en/latest/user-guide/install/macos.html](https://docs.conda.io/projects/continuumio-conda/en/latest/user-guide/install/macos.html).
    Use all of the defaults for installation in either case.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有安装 Anaconda 或 Miniconda，那么这应该是你的第一步。安装 Anaconda 的说明可以在 Anaconda 文档中找到，网址为
    [https://docs.anaconda.com/anaconda/install/mac-os/](https://docs.anaconda.com/anaconda/install/mac-os/)。如果你知道你想要
    Miniconda 而不是 Anaconda，从这里开始：[https://docs.conda.io/projects/continuumio-conda/en/latest/user-guide/install/macos.html](https://docs.conda.io/projects/continuumio-conda/en/latest/user-guide/install/macos.html)。在两种情况下，都使用安装的默认设置。
- en: 'With Anaconda or Miniconda installed, installing Prophet can be achieved using
    `conda`. Simply run the following two commands in the terminal to first install
    `gcc`, a collection of compilers that PyStan requires, and then install Prophet
    itself, which will automatically also install PyStan:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Anaconda 或 Miniconda 后，可以使用 `conda` 来安装 Prophet。只需在终端中运行以下两个命令，首先安装 PyStan
    所需的编译器集合 `gcc`，然后安装 Prophet 本身，这将自动安装 PyStan：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: After that, you should be able to get started! You can skip ahead to the *Building
    a simple model in Prophet* section, in which we will see how to build your first
    model.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，你应该可以开始使用了！你可以跳过到 *在 Prophet 中构建简单模型* 部分，我们将看到如何构建你的第一个模型。
- en: Installation on Windows
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Windows 上的安装
- en: 'As with macOS, the first step is to ensure that Anaconda or Miniconda is installed.
    Anaconda installation instructions can be found at [https://docs.anaconda.com/anaconda/install/windows/](https://docs.anaconda.com/anaconda/install/windows/),
    and those for Miniconda are available here: [https://docs.conda.io/projects/continuumio-conda/en/latest/user-guide/install/windows.html](https://docs.conda.io/projects/continuumio-conda/en/latest/user-guide/install/windows.html).'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 与 macOS 类似，第一步是确保已安装 Anaconda 或 Miniconda。Anaconda 安装说明可在 [https://docs.anaconda.com/anaconda/install/windows/](https://docs.anaconda.com/anaconda/install/windows/)
    找到，而 Miniconda 的说明则在此：[https://docs.conda.io/projects/continuumio-conda/en/latest/user-guide/install/windows.html](https://docs.conda.io/projects/continuumio-conda/en/latest/user-guide/install/windows.html)。
- en: 'On Windows, you must check the box to register Anaconda as the default Python
    version. This is required to install PyStan correctly. You may see a version of
    Python other than the one shown here, such as Python 3.8:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上，你必须勾选复选框以将 Anaconda 注册为默认的 Python 版本。这是正确安装 PyStan 所必需的。你可能看到的是除这里显示的版本之外的
    Python 版本，例如 Python 3.8：
- en: '![Figure 2.1 – Registering Anaconda as the default Python version](img/Fig_2.1.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.1 – 将 Anaconda 注册为默认 Python 版本](img/Fig_2.1.jpg)'
- en: Figure 2.1 – Registering Anaconda as the default Python version
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1 – 将 Anaconda 注册为默认 Python 版本
- en: 'Once Anaconda or Miniconda has been installed, you’ll have access to the `gcc`,
    which is a collection of compilers that PyStan requires, and then install Prophet
    itself, which will automatically also install PyStan, by running the following
    two commands in your Command Prompt:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了 Anaconda 或 Miniconda，你将能够访问 `gcc`，这是 PyStan 所需的编译器集合，然后通过在命令提示符中运行以下两个命令来安装
    Prophet 本身，这将自动安装 PyStan：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: That second command includes additional syntax to instruct `conda` to look at
    the `conda-forge` channel for the Prophet files. `conda-forge` is a community
    effort that allows developers to provide their software as a `conda` package.
    Prophet is not included in the default Anaconda distribution, but with the `conda-forge`
    channel, the Facebook team provides access directly through `conda`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个命令包含额外的语法，指示 `conda` 在 `conda-forge` 通道中查找 Prophet 文件。`conda-forge` 是一个社区项目，允许开发者将他们的软件作为
    `conda` 包提供。Prophet 不包含在默认的 Anaconda 发行版中，但通过 `conda-forge` 通道，Facebook 团队直接通过
    `conda` 提供了访问权限。
- en: That should leave you with Prophet successfully installed!
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就应该成功安装了 Prophet！
- en: Installation on Linux
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Linux 上的安装
- en: Installing Anaconda on Linux requires just a few additional steps compared with
    macOS or Windows, but they should not pose any problems. Full instructions can
    be found in Anaconda’s documentation at [https://docs.anaconda.com/anaconda/install/linux/](https://docs.anaconda.com/anaconda/install/linux/).
    Instructions for Miniconda are available at [https://docs.conda.io/projects/continuumio-conda/en/latest/user-guide/install/linux.html](https://docs.conda.io/projects/continuumio-conda/en/latest/user-guide/install/linux.html).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 上安装 Anaconda 与 macOS 或 Windows 相比只需额外几步，但它们不应造成任何问题。完整说明可在 Anaconda
    的文档中找到，网址为 [https://docs.anaconda.com/anaconda/install/linux/](https://docs.anaconda.com/anaconda/install/linux/)。Miniconda
    的说明可在 [https://docs.conda.io/projects/continuumio-conda/en/latest/user-guide/install/linux.html](https://docs.conda.io/projects/continuumio-conda/en/latest/user-guide/install/linux.html)
    找到。
- en: Because Linux is offered by various distributions, it is not possible to write
    a fully comprehensive guide for Prophet installation. However, if you are already
    using Linux, it is a fair assumption that you are also well versed in its intricacies.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Linux 由各种发行版提供，因此无法编写一个全面详尽的 Prophet 安装指南。然而，如果你已经在使用 Linux，那么你对它的复杂性应该也很熟悉。
- en: 'Just make sure that you have the `gcc`, `g++`, and `build-essential` compilers
    installed, as well as the `python-dev` and `python3-dev` Python development tools.
    If your Linux distribution is a Red Hat system, install `gcc64` and `gcc64-c++`.
    After that, use `conda` to install Prophet:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 只需确保你已经安装了 `gcc`、`g++` 和 `build-essential` 编译器，以及 `python-dev` 和 `python3-dev`
    Python 开发工具。如果你的 Linux 发行版是 Red Hat 系统，请安装 `gcc64` 和 `gcc64-c++`。之后，使用 `conda`
    安装 Prophet：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If everything went well, you should be ready to go now! Let’s test it out by
    building your first model.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，你现在应该已经准备好了！让我们通过构建你的第一个模型来测试它。
- en: Building a simple model in Prophet
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Prophet 中构建一个简单的模型
- en: The longest record of direct measurements of **Carbon Dioxide** (**CO**2) in
    the atmosphere was started in March 1958 by Charles David Keeling of the Scripps
    Institution of Oceanography. Keeling was based in La Jolla, California, but received
    permission from the **National Oceanic and Atmospheric Administration** (**NOAA**)
    to use its facility located 2 miles above sea level on the northern slope of Mauna
    Loa, a volcano on the island of Hawaii, to collect CO2 samples. At that elevation,
    Keeling’s measurements would be unaffected by local releases of CO2, such as from
    nearby factories.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 直接测量大气中**二氧化碳**（**CO2**）的最长记录始于1958年3月，由斯克里普斯海洋研究所的查尔斯·大卫·凯林（Charles David Keeling）开始。凯林位于加利福尼亚州的拉霍亚，但他获得了**国家海洋和大气管理局**（**NOAA**）的许可，在夏威夷岛上的火山马乌纳洛亚（Mauna
    Loa）北部斜坡上2英里高的设施中收集二氧化碳样本。在这个海拔高度，凯林的测量不会受到附近工厂等局部二氧化碳排放的影响。
- en: 'In 1961, Keeling published the data he had collected thus far, establishing
    that there was strong seasonal variation in CO2 levels and that they were rising
    steadily, a trend that later became known as the **Keeling Curve**. By May 1974,
    the NOAA had begun their own parallel measurements and have continued since then.
    The Keeling Curve graph is as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 1961年，凯林（Keeling）发布了迄今为止收集的数据，确立了二氧化碳水平存在强烈季节性变化，并且它们正在稳步上升的趋势，这一趋势后来被称为**凯林曲线**。到1974年5月，NOAA已经开始进行自己的平行测量，并且一直持续到现在。凯林曲线图如下：
- en: '![Figure 2.2 – The Keeling Curve, showing the concentration of carbon dioxide
    in the atmosphere](img/Fig_2.2.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图2.2 – 凯林曲线，显示大气中二氧化碳的浓度](img/Fig_2.2.jpg)'
- en: Figure 2.2 – The Keeling Curve, showing the concentration of carbon dioxide
    in the atmosphere
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 – 凯林曲线，显示大气中二氧化碳的浓度
- en: With its seasonality and increasing trend, this curve is a good candidate to
    try out with Prophet. This dataset contains over 19,000 daily observations across
    53 years. The unit of measurement for CO2 is **Parts Per Million** (**PPM**),
    a measure of CO2 molecules per million molecules of air.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其季节性和上升趋势，这条曲线是尝试使用 Prophet 的良好候选。这个数据集包含53年间的超过19,000个每日观测值。二氧化碳的测量单位是**百万分之一**（**PPM**），表示每百万个空气分子中的二氧化碳分子数。
- en: 'To begin our model, we need to import the necessary libraries, `pandas` and
    `matplotlib`, and import the Prophet class from the `prophet` package:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始我们的模型，我们需要导入必要的库，`pandas` 和 `matplotlib`，并从 `prophet` 包中导入 Prophet 类：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As input, Prophet always requires a pandas DataFrame with two columns:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 作为输入，Prophet 总是需要一个包含两列的 pandas DataFrame：
- en: '`ds`, for date stamp, should be a `datestamp` or `timestamp` column in a format
    expected by pandas'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ds`，日期戳，应该是 pandas 预期格式的 `datestamp` 或 `timestamp` 列'
- en: '`y`, a numeric column containing the measurement we wish to forecast'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`y`，一个包含我们希望预测的测量的数值列'
- en: 'Here, we use pandas to import the data, in this case, a `.csv` file, and then
    load it into a DataFrame. Note that we also convert the `ds` column into a pandas
    `datetime` format to ensure that pandas correctly identifies it as containing
    dates and doesn’t simply load it as an alphanumeric string:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用 pandas 导入数据，在这种情况下，一个 `.csv` 文件，并将其加载到一个 DataFrame 中。请注意，我们还把 `ds`
    列转换成 pandas 的 `datetime` 格式，以确保 pandas 正确地将其识别为包含日期，而不是简单地将其作为字母数字字符串加载：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If you’re familiar with the scikit-learn (`sklearn`) package, you’ll feel right
    at home in Prophet because it was designed to operate in a similar way. Prophet
    follows the sklearn paradigm of first creating an instance of the model class
    before calling the `fit` and `predict` methods:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉 scikit-learn (`sklearn`) 包，你会在 Prophet 中感到非常自在，因为它被设计成以类似的方式运行。Prophet
    遵循 sklearn 的范式，首先创建模型类的实例，然后再调用 `fit` 和 `predict` 方法：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In that single `fit` command, Prophet analyzed the data and isolated both the
    seasonality and trend without requiring us to specify any additional parameters.
    It has not yet made any future forecast, though. To do that, we need to first
    make a DataFrame of future dates and then call the `predict` method. The `make_future_dataframe`
    method requires us to specify the number of days we intend to forecast out. In
    this case, we will choose 10 years, or `365` days times `10`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在那个单一的 `fit` 命令中，Prophet 分析了数据，并独立地识别了季节性和趋势，而无需我们指定任何额外的参数。尽管如此，它还没有做出任何未来的预测。为了做到这一点，我们首先需要创建一个包含未来日期的
    DataFrame，然后调用 `predict` 方法。`make_future_dataframe` 方法要求我们指定我们打算预测的天数。在这种情况下，我们将选择
    10 年，即 `365` 天乘以 `10`：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: At this point, the `forecast` DataFrame contains Prophet’s prediction for CO2
    concentrations going 10 years into the future. We will explore that DataFrame
    in a moment, but first, let’s plot the data using Prophet’s `plot` functionality.
    The `plot` method is built upon Matplotlib; it requires a DataFrame output from
    the `predict` method (our `forecast` DataFrame in this example).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，`forecast` DataFrame 包含了 Prophet 对未来 10 年 CO2 浓度的预测。我们稍后将探索这个 DataFrame，但首先，让我们使用
    Prophet 的 `plot` 功能来绘制数据。`plot` 方法是基于 Matplotlib 构建的；它需要一个来自 `predict` 方法的 DataFrame
    输出（在这个例子中是我们的 `forecast` DataFrame）。
- en: 'We’re labeling the axes with the optional `xlabel` and `ylabel` arguments,
    but just sticking with the default for the optional `figsize` argument. Note that
    I am also adding a title using raw Matplotlib syntax; because the Prophet plot
    is built upon Matplotlib, anything you can do to a Matplotlib figure can be performed
    here as well. Also, don’t be confused by the odd `ylabel` text with the dollar
    signs; that just tells Matplotlib to use its own TeX-like engine to mark the subscript
    in CO2:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用可选的 `xlabel` 和 `ylabel` 参数来标记坐标轴，但对于可选的 `figsize` 参数则保持默认设置。注意，我还使用原始的 Matplotlib
    语法添加了一个标题；因为 Prophet 图表是基于 Matplotlib 构建的，所以你可以在这里执行任何对 Matplotlib 图表的操作。另外，不要被带有美元符号的奇怪
    `ylabel` 文本弄混淆；这只是为了告诉 Matplotlib 使用其自己的类似 TeX 的引擎来标记 CO2 下的下标：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The graph is as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图形如下所示：
- en: '![Figure 2.3 – Prophet forecast](img/Fig_2.3.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.3 – Prophet 预测](img/Fig_2.3.jpg)'
- en: Figure 2.3 – Prophet forecast
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.3 – Prophet 预测
- en: And that’s it! In those 12 lines of code, we have arrived at our 10-year forecast.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！在这 12 行代码中，我们已经得到了我们的 10 年预测。
- en: Interpreting the forecast DataFrame
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释预测 DataFrame
- en: 'Now, let’s take a look at that `forecast` DataFrame by displaying the first
    three rows (I’ve transposed it here, in order to better see the column names on
    the page) and learn how these values were used in the preceding chart:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过显示前三个行（我已经将其转置，以便更好地在页面上查看列名）来查看那个 `forecast` DataFrame，并了解这些值是如何在前面的图表中使用的：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'After running that command, you should see the following table printed out:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 执行该命令后，你应该会看到以下表格打印出来：
- en: "![Figure 2.4 – The forecas\uFEFFt DataFrame](img/Fig_2.4.jpg)"
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.4 – 预测 DataFrame](img/Fig_2.4.jpg)'
- en: Figure 2.4 – The forecast DataFrame
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.4 – 预测 DataFrame
- en: 'The following is a description of each of the columns in the `forecast` DataFrame:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对 `forecast` DataFrame 中每一列的描述：
- en: '`''ds''`: The date stamp or timestamp that the values in that row pertain to'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''ds''`：该行中值相关的日期戳或时间戳'
- en: '`''trend''`: The value of the trend component alone'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''trend''`：趋势成分的值'
- en: '`''yhat_lower''`: The lower bound of the uncertainty interval around the final
    prediction'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''yhat_lower''`：最终预测的不确定性区间的下限'
- en: '`''yhat_upper''`: The upper bound of the uncertainty interval around the final
    prediction'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''yhat_upper''`：最终预测的不确定性区间的上限'
- en: '`''trend_lower''`: The lower bound of the uncertainty interval around the trend
    component'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''trend_lower''`：趋势成分的不确定性区间的下限'
- en: '`''trend_upper''`: The upper bound of the uncertainty interval around the trend
    component'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''trend_upper''`：趋势成分的不确定性区间的上限'
- en: '`''additive_terms''`: The combined value of all the additive seasonalities'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''additive_terms''`：所有加性季节性的总和值'
- en: '`''additive_terms_lower''`: The lower bound of the uncertainty interval around
    the additive seasonalities'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''additive_terms_lower''`：加性季节性的不确定性区间的下限'
- en: '`''additive_terms_upper''`: The upper bound of the uncertainty interval around
    the additive seasonalities'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''additive_terms_upper''`：加性季节性的不确定性区间的上限'
- en: '`''weekly''`: The value of the weekly seasonality component'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''weekly''`：每周季节性成分的值'
- en: '`''weekly_lower''`: The lower bound of the uncertainty interval around the
    weekly component'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''weekly_lower''`：每周成分的不确定性区间的下限'
- en: '`''weekly_upper''`: The upper bound of the uncertainty interval around the
    weekly component'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''weekly_upper''`：围绕每周组件的不确定性区间的上限'
- en: '`''yearly''`: The value of the yearly seasonality component'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''yearly''`：每年季节性组件的值'
- en: '`''yearly_lower''`: The lower bound of the uncertainty interval around the
    yearly component'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''yearly_lower''`：围绕每年组件的不确定性区间的下限'
- en: '`''yearly_upper''`: The upper bound of the uncertainty interval around the
    yearly component'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''yearly_upper''`：围绕每年组件的不确定性区间的上限'
- en: '`''multiplicative_terms''`: The combined value of all the multiplicative seasonalities'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''multiplicative_terms''`：所有乘法季节性的综合值'
- en: '`''multiplicative_terms_lower''`: The lower bound of the uncertainty interval
    around the multiplicative seasonalities'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''multiplicative_terms_lower''`：围绕乘法季节性的不确定性区间的下限'
- en: '`''multiplicative_terms_upper''`: The upper bound of the uncertainty interval
    around the multiplicative seasonalities'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''multiplicative_terms_upper''`：围绕乘法季节性的不确定性区间的上限'
- en: '`''yhat''`: The final predicted value; a combination of `''trend''`, `''multiplicative_terms''`,
    and `''additive_terms''`'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''yhat''`：最终的预测值；由 `''trend''`、`''multiplicative_terms''` 和 `''additive_terms''`
    组合而成'
- en: If the data contains a daily seasonality, then the columns for `'daily'`, `'daily_upper'`,
    and `'daily_lower'` will also be included, following the pattern established by
    the `'weekly'` and `'yearly'` columns. Later chapters will include discussions
    and examples of both the additive/multiplicative seasonalities and the uncertainty
    intervals.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据包含每日季节性，那么 `'daily'`、`'daily_upper'` 和 `'daily_lower'` 这几列也会被包含在内，遵循 `'weekly'`
    和 `'yearly'` 列所建立的模式。后面的章节将包括关于加法/乘法季节性和不确定性区间的讨论和示例。
- en: Tip
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: '*yhat* is pronounced as *why hat*. It comes from the statistical notation where
    the *ŷ* variable represents a predicted value of the *y* variable. In general,
    placing a hat, or caret, over a true parameter denotes an estimator of it.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*yhat* 发音为 *why hat*。它来自统计符号，其中 *ŷ* 变量代表 *y* 变量的预测值。一般来说，在真实参数上放置一个帽子或撇号表示它的估计值。'
- en: In *Figure 2**.3*, the black dots represent the actual recorded `y` values we
    fit (those in the `df['y']` column), whereas the solid line represents the calculated
    `yhat` values (the `forecast['yhat']` column). Note that the solid line extends
    beyond the range of the black dots where we have forecasted into the future. The
    lighter shading notable around the solid line in the forecasted region represents
    the uncertainty interval, bound by `forecast['yhat_lower']` and `forecast['yhat_upper']`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图2**.3 中，黑色点代表我们拟合的实际记录的 `y` 值（`df['y']` 列中的那些），而实线代表计算的 `yhat` 值（`forecast['yhat']`
    列）。请注意，实线延伸到了黑色点的范围之外，我们预测到了未来。在预测区域中，围绕实线的较浅阴影表示不确定性区间，由 `forecast['yhat_lower']`
    和 `forecast['yhat_upper']` 限制。
- en: Now, let’s break down that forecast into its components.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将这个预测分解成其组件。
- en: Understanding components plots
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解组件图
- en: In [*Chapter 1*](B19630_01.xhtml#_idTextAnchor031), *The History and Development
    of Time Series Forecasting*, Prophet was introduced as an additive regression
    model. *Figures 1.4 and 1.5* showed how individual component curves for the trend
    and the different seasonalities are added together to create a more complex curve.
    The Prophet algorithm essentially does this in reverse; it takes a complex curve
    and decomposes it into its constituent parts. The first step toward greater control
    over a Prophet forecast is to understand these components so that they can be
    manipulated individually. Prophet provides a `plot_components` method to visualize
    these.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第一章*](B19630_01.xhtml#_idTextAnchor031) *时间序列预测的历史与发展* 中，Prophet被介绍为一个加法回归模型。*图1.4和1.5*
    展示了趋势和不同季节性的单个组件曲线是如何相加以形成一个更复杂的曲线。Prophet算法本质上做的是相反的操作；它将一个复杂的曲线分解为其组成部分。掌握Prophet预测的更大控制权的第一步是理解这些组件，以便可以单独操作它们。Prophet提供了一个
    `plot_components` 方法来可视化这些组件。
- en: 'Continuing with our progress on the Mauna Loa model, plotting the components
    is as simple as running these commands:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 继续我们的Mauna Loa模型进展，绘制组件就像运行以下命令一样简单：
- en: '[PRE9]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As you can see in the output plot, Prophet has isolated three components in
    this dataset: **trend**, **weekly seasonality**, and **yearly seasonality**:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在输出图中可以看到的，Prophet已经将这个数据集隔离成三个组件：**趋势**、**每周季节性**和**每年季节性**：
- en: "![Figure 2.5 – Mauna Loa c\uFEFFomponents plot](img/Fig_2.5.jpg)"
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图2.5 – Mauna Loa组件图](img/Fig_2.5.jpg)'
- en: Figure 2.5 – Mauna Loa components plot
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5 – Mauna Loa组件图
- en: The **trend** constantly increases but seems to have a steepening slope as time
    progresses—an acceleration of CO2 concentration in the atmosphere. The trend line
    also shows slim uncertainty intervals in the forecasted year. From this curve,
    we learn that atmospheric CO2 concentrations were about 320 PPM in 1965\. This
    grew to about 400 PPM by 2015 and we expect about 430 PPM by 2030\. However, these
    exact numbers will vary depending upon the day of the week and the time of year
    due to the existence of the seasonality effects.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**趋势**持续增加，但随着时间的推移似乎有一个变陡的斜率——大气中二氧化碳浓度的加速。趋势线还显示了预测年份中很小的不确定性区间。从这条曲线中，我们了解到1965年大气中的二氧化碳浓度约为320
    PPM。到2015年增长到约400 PPM，我们预计到2030年将达到约430 PPM。然而，这些确切数字将因季节性效应的存在而根据一周中的某一天和一年中的某个时间而有所不同。'
- en: The **weekly seasonality** shows that by day of the week, values will vary by
    about 0.01 PPM—an insignificant amount and most likely due purely to noise and
    random chance. Indeed, intuition tells us that CO2 levels (when measured far enough
    away from human activity, as they are on the high slopes of Mauna Loa) do not
    care much what day of the week it is and are unaffected by it.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**每周季节性**表明，根据一周中的某一天，值将变化约0.01 PPM——这是一个微不足道的数量，很可能是纯粹由于噪声和随机机会。确实，直觉告诉我们，二氧化碳水平（当测量距离人类活动足够远时，如莫纳罗亚山的高坡上）并不太关心一周中的哪一天，并且不受其影响。'
- en: We will learn in [*Chapter 5*](B19630_05.xhtml#_idTextAnchor254), *Working with
    Seasonality*, how to instruct Prophet not to fit a weekly seasonality, as is prudent
    in this case. In [*Chapter 11*](B19630_11.xhtml#_idTextAnchor728), *Managing Uncertainty
    Intervals*, we will learn how to plot uncertainty for seasonality and ensure that
    a seasonality such as this can be ignored.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[*第五章*](B19630_05.xhtml#_idTextAnchor254)，“处理季节性”中学习如何指导Prophet不要拟合每周季节性，正如在这个案例中那样谨慎。在[*第十一章*](B19630_11.xhtml#_idTextAnchor728)，“管理不确定性区间”中，我们将学习如何绘制季节性的不确定性，并确保可以忽略像这样的季节性。
- en: Now, looking at the **yearly seasonality** reveals that CO2 rises throughout
    the winter and peaks in May or so, while falling in the summer with a trough in
    October. Measurements of CO2 can be 3 PPM above or 3 PPM below what the trend
    alone would predict, based on the time of year. If you refer back to the original
    data plotted in *Figure 2**.2*, you will be reminded that there was a very obvious
    cyclical nature to the curve, captured with this yearly seasonality.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，观察**年度季节性**可以发现，二氧化碳在整个冬季上升，大约在5月份达到峰值，而在夏季下降，10月份达到低谷。根据一年中的时间，二氧化碳的测量值可能比仅根据趋势预测的值高3
    PPM或低3 PPM。如果你回顾原始数据中*图2.2*所绘制的曲线，你会想起曲线有一个非常明显的周期性，这正是通过这种年度季节性捕捉到的。
- en: As simple as that model was, that is often all you need to make very accurate
    forecasts with Prophet! We used no additional parameters than the defaults and
    yet achieved very good results.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 就像那个模型那么简单，这通常就是你需要用Prophet做出非常准确的预测的所有！我们没有使用比默认参数更多的参数，却取得了非常好的结果。
- en: Summary
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Hopefully, you experienced no issues in installing Prophet on your machine at
    the beginning of this chapter. The potential challenge of installing the Stan
    dependency is greatly eased by using the Anaconda distribution of Python. After
    installation, we looked at the CO2 levels measured in the atmosphere 2 miles above
    the Pacific Ocean at Mauna Loa in Hawaii. We built our first Prophet model and,
    in just 12 lines of code, were able to forecast the next 10 years of CO2 levels.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你在本章开头安装Prophet时没有遇到任何问题。使用Python的Anaconda发行版大大减轻了安装Stan依赖项的潜在挑战。安装后，我们查看了在夏威夷莫纳罗亚山2英里以上的太平洋大气层中测量的二氧化碳水平。我们构建了第一个Prophet模型，并且仅用12行代码就能预测未来10年的二氧化碳水平。
- en: After that, we inspected the `forecast` DataFrame and saw the rich results that
    Prophet outputs. Finally, we plotted the components of the forecast – the trend,
    yearly seasonality, and weekly seasonality – to better understand the data’s behavior.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们检查了`forecast`数据框，并看到了Prophet输出的丰富结果。最后，我们绘制了预测的组成部分——趋势、年度季节性和每周季节性——以更好地理解数据的行为。
- en: There is a lot more to Prophet than just this simple example, though. In the
    next chapter, we’ll take a deep dive into the equations behind Prophet’s model
    to understand how it works.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Prophet远不止这个简单的例子那么简单。在下一章中，我们将深入探讨Prophet模型背后的方程，以了解它是如何工作的。
