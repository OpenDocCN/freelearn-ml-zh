- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Getting Started with Prophet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Prophet is an open source piece of software, which means that the entirety of
    the underlying code is freely available to anyone to inspect and modify. This
    gives Prophet a great deal of power, as any user can add features or fix bugs,
    but it also has its downsides. Many closed source software packages, such as Microsoft
    Word or Tableau, come packaged in their own independent installation file with
    a neat graphical user interface to not only walk users through installation but
    also enable them to interact with the software once it has been installed.
  prefs: []
  type: TYPE_NORMAL
- en: Prophet, in contrast, is accessed through either the **Python** or **R** programming
    language and depends upon many additional open source libraries. This gives it
    great flexibility, as users can tweak features or even add entirely new ones to
    suit their specific problem, but it comes with the downside of potentially difficult
    usability. That’s what this book aims to simplify.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will walk you through the entire installation procedure
    depending upon which operating system you use, and then we will build our first
    forecast together by modeling the atmospheric carbon dioxide levels over the last
    few decades.
  prefs: []
  type: TYPE_NORMAL
- en: 'In full, this chapter will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing Prophet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a simple model in Prophet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interpreting the forecast DataFrame
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding components plots
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The data files and code for examples in this chapter can be found at [https://github.com/PacktPublishing/Forecasting-Time-Series-Data-with-Prophet-Second-Edition](https://github.com/PacktPublishing/Forecasting-Time-Series-Data-with-Prophet-Second-Edition).
    In this chapter, we will walk through the process of installing many of the requirements.
    So, to begin this chapter, it is only necessary that you have a Windows, macOS,
    or Linux machine capable of running Anaconda with Python 3.7+.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Prophet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Installing Prophet on your machine is a straightforward process. However, under
    the hood, Prophet depends upon the **Stan** programming language, and installing
    **PyStan**, the Python interface for it, is unfortunately not so straightforward
    because it requires many non-standard compilers.
  prefs: []
  type: TYPE_NORMAL
- en: But don’t worry, because there is a really easy way to get Prophet and all dependencies
    installed, no matter which operating system you use, and that is through Anaconda.
  prefs: []
  type: TYPE_NORMAL
- en: '**Anaconda** is a free distribution of Python that comes bundled with hundreds
    of additional Python packages that are useful for data science, along with the
    package management system **conda**. This is in contrast to installing the Python
    language from its source on [https://www.python.org/](https://www.python.org/),
    which will include the default Python package manager, called **pip**.'
  prefs: []
  type: TYPE_NORMAL
- en: When `pip` installs a new package, it will install any dependencies without
    checking whether these dependent Python packages will conflict with others. This
    can be a particular problem when one package is dependent on one version, while
    another package requires a different version. You may have, for example, a working
    installation of Google’s TensorFlow package, which requires the NumPy package
    to work with large, multidimensional arrays, and use `pip` to install a new package
    that specifies a different NumPy version as a dependency.
  prefs: []
  type: TYPE_NORMAL
- en: The different version of NumPy would then overwrite the other version and you
    may find that TensorFlow suddenly doesn’t work as expected, or even at all. In
    contrast, `conda` will analyze the current environment and work out on its own
    how to install a compatible set of dependencies for all installed packages and
    provide a warning if this cannot be done.
  prefs: []
  type: TYPE_NORMAL
- en: PyStan, and many other Python tools, for that matter, require compilers written
    in the C language. These types of dependencies are unable to be installed using
    `pip`, but Anaconda already includes them. Therefore, it *is strongly recommended
    to first* *install Anaconda*.
  prefs: []
  type: TYPE_NORMAL
- en: If you already have a Python environment that you are happy with and do not
    want to install the full Anaconda distribution, there is a much smaller version
    available called `conda`, Python, and a small number of required packages. Although
    it is technically possible to install Prophet and all dependencies without Anaconda,
    it can be extremely difficult and the procedure varies a great deal depending
    on the machine in use, so writing a single guide to cover all scenarios is nearly
    impossible.
  prefs: []
  type: TYPE_NORMAL
- en: This guide assumes that you will begin with an Anaconda or Miniconda installation,
    with Python 3 or greater. If you’re unsure of whether you want Anaconda or Miniconda,
    go with Anaconda. Note that the full Anaconda distribution will require about
    3 GB of space on your computer due to all of the packages included, so if space
    is an issue, you should consider Miniconda instead.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: As of Prophet version 0.6, Python 2 is no longer supported. Be sure that you
    have Python 3.7+ installed on your machine before proceeding. Installing Anaconda
    is strongly recommended.
  prefs: []
  type: TYPE_NORMAL
- en: Installation on macOS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you do not already have Anaconda or Miniconda installed, that should be
    your first step. Instructions for installing Anaconda can be found in the Anaconda
    documentation at [https://docs.anaconda.com/anaconda/install/mac-os/](https://docs.anaconda.com/anaconda/install/mac-os/).
    If you know that you want Miniconda over Anaconda, start here: [https://docs.conda.io/projects/continuumio-conda/en/latest/user-guide/install/macos.html](https://docs.conda.io/projects/continuumio-conda/en/latest/user-guide/install/macos.html).
    Use all of the defaults for installation in either case.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With Anaconda or Miniconda installed, installing Prophet can be achieved using
    `conda`. Simply run the following two commands in the terminal to first install
    `gcc`, a collection of compilers that PyStan requires, and then install Prophet
    itself, which will automatically also install PyStan:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: After that, you should be able to get started! You can skip ahead to the *Building
    a simple model in Prophet* section, in which we will see how to build your first
    model.
  prefs: []
  type: TYPE_NORMAL
- en: Installation on Windows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As with macOS, the first step is to ensure that Anaconda or Miniconda is installed.
    Anaconda installation instructions can be found at [https://docs.anaconda.com/anaconda/install/windows/](https://docs.anaconda.com/anaconda/install/windows/),
    and those for Miniconda are available here: [https://docs.conda.io/projects/continuumio-conda/en/latest/user-guide/install/windows.html](https://docs.conda.io/projects/continuumio-conda/en/latest/user-guide/install/windows.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'On Windows, you must check the box to register Anaconda as the default Python
    version. This is required to install PyStan correctly. You may see a version of
    Python other than the one shown here, such as Python 3.8:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – Registering Anaconda as the default Python version](img/Fig_2.1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.1 – Registering Anaconda as the default Python version
  prefs: []
  type: TYPE_NORMAL
- en: 'Once Anaconda or Miniconda has been installed, you’ll have access to the `gcc`,
    which is a collection of compilers that PyStan requires, and then install Prophet
    itself, which will automatically also install PyStan, by running the following
    two commands in your Command Prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: That second command includes additional syntax to instruct `conda` to look at
    the `conda-forge` channel for the Prophet files. `conda-forge` is a community
    effort that allows developers to provide their software as a `conda` package.
    Prophet is not included in the default Anaconda distribution, but with the `conda-forge`
    channel, the Facebook team provides access directly through `conda`.
  prefs: []
  type: TYPE_NORMAL
- en: That should leave you with Prophet successfully installed!
  prefs: []
  type: TYPE_NORMAL
- en: Installation on Linux
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Installing Anaconda on Linux requires just a few additional steps compared with
    macOS or Windows, but they should not pose any problems. Full instructions can
    be found in Anaconda’s documentation at [https://docs.anaconda.com/anaconda/install/linux/](https://docs.anaconda.com/anaconda/install/linux/).
    Instructions for Miniconda are available at [https://docs.conda.io/projects/continuumio-conda/en/latest/user-guide/install/linux.html](https://docs.conda.io/projects/continuumio-conda/en/latest/user-guide/install/linux.html).
  prefs: []
  type: TYPE_NORMAL
- en: Because Linux is offered by various distributions, it is not possible to write
    a fully comprehensive guide for Prophet installation. However, if you are already
    using Linux, it is a fair assumption that you are also well versed in its intricacies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just make sure that you have the `gcc`, `g++`, and `build-essential` compilers
    installed, as well as the `python-dev` and `python3-dev` Python development tools.
    If your Linux distribution is a Red Hat system, install `gcc64` and `gcc64-c++`.
    After that, use `conda` to install Prophet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If everything went well, you should be ready to go now! Let’s test it out by
    building your first model.
  prefs: []
  type: TYPE_NORMAL
- en: Building a simple model in Prophet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The longest record of direct measurements of **Carbon Dioxide** (**CO**2) in
    the atmosphere was started in March 1958 by Charles David Keeling of the Scripps
    Institution of Oceanography. Keeling was based in La Jolla, California, but received
    permission from the **National Oceanic and Atmospheric Administration** (**NOAA**)
    to use its facility located 2 miles above sea level on the northern slope of Mauna
    Loa, a volcano on the island of Hawaii, to collect CO2 samples. At that elevation,
    Keeling’s measurements would be unaffected by local releases of CO2, such as from
    nearby factories.
  prefs: []
  type: TYPE_NORMAL
- en: 'In 1961, Keeling published the data he had collected thus far, establishing
    that there was strong seasonal variation in CO2 levels and that they were rising
    steadily, a trend that later became known as the **Keeling Curve**. By May 1974,
    the NOAA had begun their own parallel measurements and have continued since then.
    The Keeling Curve graph is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2 – The Keeling Curve, showing the concentration of carbon dioxide
    in the atmosphere](img/Fig_2.2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.2 – The Keeling Curve, showing the concentration of carbon dioxide
    in the atmosphere
  prefs: []
  type: TYPE_NORMAL
- en: With its seasonality and increasing trend, this curve is a good candidate to
    try out with Prophet. This dataset contains over 19,000 daily observations across
    53 years. The unit of measurement for CO2 is **Parts Per Million** (**PPM**),
    a measure of CO2 molecules per million molecules of air.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin our model, we need to import the necessary libraries, `pandas` and
    `matplotlib`, and import the Prophet class from the `prophet` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'As input, Prophet always requires a pandas DataFrame with two columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ds`, for date stamp, should be a `datestamp` or `timestamp` column in a format
    expected by pandas'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`y`, a numeric column containing the measurement we wish to forecast'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here, we use pandas to import the data, in this case, a `.csv` file, and then
    load it into a DataFrame. Note that we also convert the `ds` column into a pandas
    `datetime` format to ensure that pandas correctly identifies it as containing
    dates and doesn’t simply load it as an alphanumeric string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If you’re familiar with the scikit-learn (`sklearn`) package, you’ll feel right
    at home in Prophet because it was designed to operate in a similar way. Prophet
    follows the sklearn paradigm of first creating an instance of the model class
    before calling the `fit` and `predict` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In that single `fit` command, Prophet analyzed the data and isolated both the
    seasonality and trend without requiring us to specify any additional parameters.
    It has not yet made any future forecast, though. To do that, we need to first
    make a DataFrame of future dates and then call the `predict` method. The `make_future_dataframe`
    method requires us to specify the number of days we intend to forecast out. In
    this case, we will choose 10 years, or `365` days times `10`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: At this point, the `forecast` DataFrame contains Prophet’s prediction for CO2
    concentrations going 10 years into the future. We will explore that DataFrame
    in a moment, but first, let’s plot the data using Prophet’s `plot` functionality.
    The `plot` method is built upon Matplotlib; it requires a DataFrame output from
    the `predict` method (our `forecast` DataFrame in this example).
  prefs: []
  type: TYPE_NORMAL
- en: 'We’re labeling the axes with the optional `xlabel` and `ylabel` arguments,
    but just sticking with the default for the optional `figsize` argument. Note that
    I am also adding a title using raw Matplotlib syntax; because the Prophet plot
    is built upon Matplotlib, anything you can do to a Matplotlib figure can be performed
    here as well. Also, don’t be confused by the odd `ylabel` text with the dollar
    signs; that just tells Matplotlib to use its own TeX-like engine to mark the subscript
    in CO2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The graph is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3 – Prophet forecast](img/Fig_2.3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.3 – Prophet forecast
  prefs: []
  type: TYPE_NORMAL
- en: And that’s it! In those 12 lines of code, we have arrived at our 10-year forecast.
  prefs: []
  type: TYPE_NORMAL
- en: Interpreting the forecast DataFrame
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let’s take a look at that `forecast` DataFrame by displaying the first
    three rows (I’ve transposed it here, in order to better see the column names on
    the page) and learn how these values were used in the preceding chart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'After running that command, you should see the following table printed out:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 2.4 – The forecas\uFEFFt DataFrame](img/Fig_2.4.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 2.4 – The forecast DataFrame
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a description of each of the columns in the `forecast` DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''ds''`: The date stamp or timestamp that the values in that row pertain to'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''trend''`: The value of the trend component alone'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''yhat_lower''`: The lower bound of the uncertainty interval around the final
    prediction'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''yhat_upper''`: The upper bound of the uncertainty interval around the final
    prediction'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''trend_lower''`: The lower bound of the uncertainty interval around the trend
    component'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''trend_upper''`: The upper bound of the uncertainty interval around the trend
    component'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''additive_terms''`: The combined value of all the additive seasonalities'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''additive_terms_lower''`: The lower bound of the uncertainty interval around
    the additive seasonalities'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''additive_terms_upper''`: The upper bound of the uncertainty interval around
    the additive seasonalities'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''weekly''`: The value of the weekly seasonality component'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''weekly_lower''`: The lower bound of the uncertainty interval around the
    weekly component'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''weekly_upper''`: The upper bound of the uncertainty interval around the
    weekly component'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''yearly''`: The value of the yearly seasonality component'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''yearly_lower''`: The lower bound of the uncertainty interval around the
    yearly component'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''yearly_upper''`: The upper bound of the uncertainty interval around the
    yearly component'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''multiplicative_terms''`: The combined value of all the multiplicative seasonalities'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''multiplicative_terms_lower''`: The lower bound of the uncertainty interval
    around the multiplicative seasonalities'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''multiplicative_terms_upper''`: The upper bound of the uncertainty interval
    around the multiplicative seasonalities'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''yhat''`: The final predicted value; a combination of `''trend''`, `''multiplicative_terms''`,
    and `''additive_terms''`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the data contains a daily seasonality, then the columns for `'daily'`, `'daily_upper'`,
    and `'daily_lower'` will also be included, following the pattern established by
    the `'weekly'` and `'yearly'` columns. Later chapters will include discussions
    and examples of both the additive/multiplicative seasonalities and the uncertainty
    intervals.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: '*yhat* is pronounced as *why hat*. It comes from the statistical notation where
    the *ŷ* variable represents a predicted value of the *y* variable. In general,
    placing a hat, or caret, over a true parameter denotes an estimator of it.'
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 2**.3*, the black dots represent the actual recorded `y` values we
    fit (those in the `df['y']` column), whereas the solid line represents the calculated
    `yhat` values (the `forecast['yhat']` column). Note that the solid line extends
    beyond the range of the black dots where we have forecasted into the future. The
    lighter shading notable around the solid line in the forecasted region represents
    the uncertainty interval, bound by `forecast['yhat_lower']` and `forecast['yhat_upper']`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s break down that forecast into its components.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding components plots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 1*](B19630_01.xhtml#_idTextAnchor031), *The History and Development
    of Time Series Forecasting*, Prophet was introduced as an additive regression
    model. *Figures 1.4 and 1.5* showed how individual component curves for the trend
    and the different seasonalities are added together to create a more complex curve.
    The Prophet algorithm essentially does this in reverse; it takes a complex curve
    and decomposes it into its constituent parts. The first step toward greater control
    over a Prophet forecast is to understand these components so that they can be
    manipulated individually. Prophet provides a `plot_components` method to visualize
    these.
  prefs: []
  type: TYPE_NORMAL
- en: 'Continuing with our progress on the Mauna Loa model, plotting the components
    is as simple as running these commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the output plot, Prophet has isolated three components in
    this dataset: **trend**, **weekly seasonality**, and **yearly seasonality**:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 2.5 – Mauna Loa c\uFEFFomponents plot](img/Fig_2.5.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 2.5 – Mauna Loa components plot
  prefs: []
  type: TYPE_NORMAL
- en: The **trend** constantly increases but seems to have a steepening slope as time
    progresses—an acceleration of CO2 concentration in the atmosphere. The trend line
    also shows slim uncertainty intervals in the forecasted year. From this curve,
    we learn that atmospheric CO2 concentrations were about 320 PPM in 1965\. This
    grew to about 400 PPM by 2015 and we expect about 430 PPM by 2030\. However, these
    exact numbers will vary depending upon the day of the week and the time of year
    due to the existence of the seasonality effects.
  prefs: []
  type: TYPE_NORMAL
- en: The **weekly seasonality** shows that by day of the week, values will vary by
    about 0.01 PPM—an insignificant amount and most likely due purely to noise and
    random chance. Indeed, intuition tells us that CO2 levels (when measured far enough
    away from human activity, as they are on the high slopes of Mauna Loa) do not
    care much what day of the week it is and are unaffected by it.
  prefs: []
  type: TYPE_NORMAL
- en: We will learn in [*Chapter 5*](B19630_05.xhtml#_idTextAnchor254), *Working with
    Seasonality*, how to instruct Prophet not to fit a weekly seasonality, as is prudent
    in this case. In [*Chapter 11*](B19630_11.xhtml#_idTextAnchor728), *Managing Uncertainty
    Intervals*, we will learn how to plot uncertainty for seasonality and ensure that
    a seasonality such as this can be ignored.
  prefs: []
  type: TYPE_NORMAL
- en: Now, looking at the **yearly seasonality** reveals that CO2 rises throughout
    the winter and peaks in May or so, while falling in the summer with a trough in
    October. Measurements of CO2 can be 3 PPM above or 3 PPM below what the trend
    alone would predict, based on the time of year. If you refer back to the original
    data plotted in *Figure 2**.2*, you will be reminded that there was a very obvious
    cyclical nature to the curve, captured with this yearly seasonality.
  prefs: []
  type: TYPE_NORMAL
- en: As simple as that model was, that is often all you need to make very accurate
    forecasts with Prophet! We used no additional parameters than the defaults and
    yet achieved very good results.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Hopefully, you experienced no issues in installing Prophet on your machine at
    the beginning of this chapter. The potential challenge of installing the Stan
    dependency is greatly eased by using the Anaconda distribution of Python. After
    installation, we looked at the CO2 levels measured in the atmosphere 2 miles above
    the Pacific Ocean at Mauna Loa in Hawaii. We built our first Prophet model and,
    in just 12 lines of code, were able to forecast the next 10 years of CO2 levels.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we inspected the `forecast` DataFrame and saw the rich results that
    Prophet outputs. Finally, we plotted the components of the forecast – the trend,
    yearly seasonality, and weekly seasonality – to better understand the data’s behavior.
  prefs: []
  type: TYPE_NORMAL
- en: There is a lot more to Prophet than just this simple example, though. In the
    next chapter, we’ll take a deep dive into the equations behind Prophet’s model
    to understand how it works.
  prefs: []
  type: TYPE_NORMAL
