- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building an MSA with Docker Containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we discussed how to apply the DevOps process of building
    and running MSA systems, and the importance of aligning the organizational structure
    with DevOps.
  prefs: []
  type: TYPE_NORMAL
- en: We also highlighted the importance of embracing automation and adapting agile
    development methodologies throughout the MSA project life cycle, and throughout
    the CI/CD operations.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will cover what a **container** is, how to install containers,
    how to work with them, and how to handle the data flow between containers to build
    a simple project. We will use **Docker** as our platform since it is one of the
    most popular and widely used platforms in the field today.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: What are containers anyway, and why use them?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing Docker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating ABC-MSA containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ABC-MSA microservices inter-communication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are containers anyway, and why use them?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A container is defined as an operating system-level virtualization artifact,
    created by grouping different finite compute resources into a self-contained execution
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in the following figure of a container ship, containers are self-contained
    units, independent from any other container in the ship. The ship is the engine
    that is used to carry and transport containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1: A container ship](img/B18934_09_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.1: A container ship'
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, the idea with containers is to create operating system-level virtualization.
    This means that, from within the kernel, you group different physical machine
    resources, applications, and I/O functions into a self-contained execution environment.
    Each of these self-contained resources forms a single container, hence the name
    container. The **Container Engine** is similar to the ship in the preceding example,
    where the container engine is used to carry, run, and transport the containers.
  prefs: []
  type: TYPE_NORMAL
- en: Containers have existed for a long time and can be traced back to Unix’s **chroot**
    in the late 1970s and early 1980s, and before we even came to learn about what
    we call today a **hypervisor**. A hypervisor is a component that enables us to
    spin up **virtual** **machines** (**VMs**).
  prefs: []
  type: TYPE_NORMAL
- en: Unix’s chroot evolved later in the 1990s to Linux containers or what we call
    **LXC**, and then to **Solaris Zones** in the early 2000s. These concepts started
    to evolve with time from **cgroups** (originally developed by Google) and **namespaces**
    (developed by IBM) in to the container engines we see today, such as Docker, **Rkt**,
    **CRI-O**, **Containers**, Microsoft **Hyper-V** Containers, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Although there are similarities between containers and VMs, both still have
    a few fundamental differences.
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in the following diagram, containers share the same kernel of the
    host operating system but isolate and limit the allocated resources, giving us
    something that feels like a VM but that’s much more lightweight in terms of resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2: VMs versus containers](img/B18934_09_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.2: VMs versus containers'
  prefs: []
  type: TYPE_NORMAL
- en: In hypervisor virtualization, each VM will have to have its own virtual hardware
    and its own guest operating system. In addition to all that, there is a great
    deal of emulation taking place in the hypervisor. Accordingly, each VM needs much
    more resources compared to what a container needs. Resources include CPU cycles,
    memory, storage, and more. Moreover, you are likely to have duplicates of the
    same guest OS deployed on multiple VMs for the VM to deliver the required function,
    thus even more overhead and waste of resources.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 9**.2* shows the hypervisor deployed on top of a host OS. A more common
    hypervisor virtualization model, however, is deploying the bare-metal hypervisor
    on the hardware directly. In either case, the overhead is are still significantly
    higher than deploying containers.'
  prefs: []
  type: TYPE_NORMAL
- en: The lightweight nature of containers enables companies to run many more virtualized
    environments in the data center compared to VMs. Since containers share resources
    much more efficiently than VMs, and with finite physical resources in data centers,
    containers largely increase the capacity of the data center infrastructure, which
    means containers become a better choice in hosting applications, especially in
    our case of MSA.
  prefs: []
  type: TYPE_NORMAL
- en: Container performance is another thing to look at. With containers, I/O virtual
    drivers’ communication, hardware emulation, and resources overhead are minimal,
    completely contrary to the case in the hypervisor virtualization environment.
    Accordingly, containers generally outperform VMs. Containers boot in 1-3 seconds
    compared to minutes in the case of VMs.
  prefs: []
  type: TYPE_NORMAL
- en: Applications running on a container can directly interact with and access the
    hardware. In the case of hypervisor virtualization, there is always a hypervisor
    between the application and the VM (unless a hypervisor bypass is enabled, which
    has its own limitations).
  prefs: []
  type: TYPE_NORMAL
- en: With containers, you can package the application with all of its dependencies
    in a contained environment that’s reusable and completely portable to any other
    platform. That’s one of the most important features of containers. Developers
    can develop an application on their development servers, ship it to the testing
    environment, then staging and production, and run the application without having
    to worry about portability and dependency issues.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: For all the aforementioned reasons, the most popular deployment model of microservices
    is the container-per-service model. This is where each microservice of the MSA
    is deployed on a single container dedicated to running that particular application.
  prefs: []
  type: TYPE_NORMAL
- en: The other important difference between containers and VMs is security. Since
    containers use the same kernel, multiple containers may very well access the same
    kernel subsystem outside the boundaries of the container. This means a container
    could gain access to other containers running on the same physical host. A single
    application with root access, for example, could access any other container data.
  prefs: []
  type: TYPE_NORMAL
- en: There are many ways to harden the security of containers, but none of these
    techniques would help containers match the VM’s total isolation security.
  prefs: []
  type: TYPE_NORMAL
- en: There are cases, of course, where using VMs would be a better option than using
    containers. Or in some scenarios, a mix of both VMs and containers would be the
    most appropriate deployment model. It all depends on the use case, the application,
    or the system you are deploying in your organization.
  prefs: []
  type: TYPE_NORMAL
- en: In a multi-tenant environment, where complete workload isolation is necessary,
    using VMs would be a better choice. Or, if you are trying to build an R&D environment
    for hosting critical intellectual capital, or highly confidential data or applications,
    a complete workload isolation will also be necessary. Therefore, in this case,
    using VMs would be the better option.
  prefs: []
  type: TYPE_NORMAL
- en: For our MSA example, we need a very lightweight, fast-starting, highly portable,
    and high-performing virtualization environment to build our MSA system. Hence,
    containers, with a container-per-microservice deployment model, are the better
    choice in our scenario. Each of the MSA system’s microservices would be deployed
    in its own container and would have its own development team, development cycle,
    QA cycle, updates, run life cycle, and release cycle.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table summarizes the differences between containers and hypervisor
    virtualization:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **Containers** | **Hypervisor VM’s** |'
  prefs: []
  type: TYPE_TB
- en: '| Resource Usage and Overhead | Lightweight, Please overhead, and more efficient
    use of resources | High overhead and resource-intensive |'
  prefs: []
  type: TYPE_TB
- en: '| Container and Application Size | Averages 5-20 MB | Measured in 100s of MB
    or GB |'
  prefs: []
  type: TYPE_TB
- en: '| Performance | High performance | Lower performance |'
  prefs: []
  type: TYPE_TB
- en: '| Scalability | Easy to scale out/high horizontal scaling | Scaling out is
    harder and consumes resources |'
  prefs: []
  type: TYPE_TB
- en: '| Bootup Time | Very short startup time (1-3 seconds) | Startup time is in
    minutes |'
  prefs: []
  type: TYPE_TB
- en: '| Portability | System-agnostic and highly portable | Portability is limited
    |'
  prefs: []
  type: TYPE_TB
- en: '| DevOps and CI/CD Suitability | Enables more agile DevOps and smoother CI/CD
    | Could slow down CI/CD operations |'
  prefs: []
  type: TYPE_TB
- en: '| Host Hardware Access | Applications access HW directly | No direct access
    to HW |'
  prefs: []
  type: TYPE_TB
- en: '| Security | Less secure; shares the same kernel | More secure; each VM has
    its own OS kernel |'
  prefs: []
  type: TYPE_TB
- en: 'Table 9.1: Differences between containers and Hypervisor VMs'
  prefs: []
  type: TYPE_NORMAL
- en: Despite the many options we currently have in choosing a container engine, Docker
    is by far the most popular engine used today, to the extent that Docker today
    is synonymous with containers. That’s the main reason why we have chosen to work
    with Docker as our container’s engine in this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker is also ideal for agile DevOps and CI/CD operations. In a CI/CD environment,
    the time between building a Docker image to the time it is up and running in the
    production environment is usually around 1-5 minutes in total:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3: Docker Engine container virtualization](img/B18934_09_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.3: Docker Engine container virtualization'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 9**.3* shows Docker Engine installed on the host operating system to
    enable the containerization of microservices or applications in general.'
  prefs: []
  type: TYPE_NORMAL
- en: Docker in itself may not be sufficient to manage all the CI/CD operations. Organizations
    usually complement Docker by using a clustering technology such as **Kubernetes**
    or **Marathon** to smoothly deploy, manage, and operate the containers within
    the cluster in which your system is running. However, in this book, we will focus
    on Docker itself and how to use Docker to build our MSA system.
  prefs: []
  type: TYPE_NORMAL
- en: Also, to move, test, and deploy containers, we will need to have a repository
    to save these containers and be able to move them to different environments. Many
    tools can help with that, with **Docker Hub** and **GitHub** being two of the
    most commonly used repositories. For our project, we will use GitHub as our project
    repository.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have covered what containers are, the difference between containers
    and VMs, and why we prefer to use containers in MSA. In the next section, we will
    explain the different components of Docker, how to install Docker, and how to
    work with Docker’s components to create a system’s microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will start this section by talking about Docker installation. Then, we will
    cover the main components of Docker, the purpose of each component, and how these
    components relate to each other. This section will help us prepare the environment
    that we will use later for our ABC-MSA demo project.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: To maximize your hands-on learning experience, you need to follow all of our
    hands-on installation steps. But before doing so, please make sure you have a
    physical or virtual host available for the Docker installation demo before we
    dive deeper into this section. A virtual host can be created using virtualization
    software such as VirtualBox or VMWare.
  prefs: []
  type: TYPE_NORMAL
- en: Although you can install Docker on Windows or Mac, in our demo, we will use
    an Ubuntu Server 22.x Linux environment to install Docker **Community Edition**
    (**CE**). We suggest you use a similar environment to be able to follow our installation
    steps.
  prefs: []
  type: TYPE_NORMAL
- en: Docker Engine installation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we know the main components of Docker, let’s take a step back and learn
    how to install Docker and create different Docker images for the ABC-MSA system.
  prefs: []
  type: TYPE_NORMAL
- en: The best way to install Docker Engine is to follow Docker’s official installation
    guide from Docker Docs at [https://docs.docker.com/engine/install/](https://docs.docker.com/engine/install/).
    Pick your server system platform installation guide from the list.
  prefs: []
  type: TYPE_NORMAL
- en: You may also want to install Docker Desktop on your workstation. Docker Desktop
    is available for download from the same installation guide referred to previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the installation is completed, verify Docker’s functionality by running
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: And,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You may need root privileges to issue the Docker commands successfully.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have installed Docker, let’s go over the main components of Docker
    and how to use each.
  prefs: []
  type: TYPE_NORMAL
- en: Docker components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are four main components of Docker: the Docker file, the Docker image,
    the Docker container, and the Docker volume. The following is a brief description
    of each of these components.'
  prefs: []
  type: TYPE_NORMAL
- en: The Docker file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Docker file is a text file that works as a manifest that describes how
    the Docker image should be built. The Docker file specifies the base image that
    will be used to create the Docker image. So, for example, if you were to use the
    latest Ubuntu version as your base Linux image for the container, you would have
    the following line specified at the top of your Docker file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that `ubuntu` is not tagged with any version number, which will instruct
    Docker to pull the latest version available for that base image. If you prefer
    to use CentOS version 7.0, for example, you must then tag the base image with
    the version number, as shown in the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The specific image tag can be found on Docker Hub. Docker Hub is a public repository
    that stores many free Docker official images for reuse by Docker users. Among
    many others, base images could be Linux, Windows, Node.js, Redis, Postgres, or
    other relational DB images.
  prefs: []
  type: TYPE_NORMAL
- en: After you specify the base operating system image, you can use the `RUN` command
    to run the commands that you would like to execute during the Docker image creation.
    These are regular shell commands that are usually issued to download and install
    packages and libraries that will be used in your Docker image.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Docker file has to be named `Dockerfile` for Docker to be able to use it.
    The following is a simple Dockerfile example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.4: A Docker file (Dockerfile) example](img/B18934_09_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.4: A Docker file (Dockerfile) example'
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding sample Dockerfile does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Uses Ubuntu version 22.10 as the base image to run on the container that will
    be created later.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fetches the latest packages list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Installs Python version 3 and the PIP Python package management system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Installs a package called Ansible (Ansible is an automation tool).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Docker image
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once you have finished composing your Dockerfile, you will need to save it as
    a `Dockerfile` to be able to use it to create the Docker image.
  prefs: []
  type: TYPE_NORMAL
- en: A Docker image is a binary file that works as a template with a set of instructions
    on how a Docker container should be created.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that a Docker image can either be created from the Dockerfile, as
    we are explaining here, or downloaded from a public or private repository such
    as Docker Hub or GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: 'To build a Docker image, use the following command while pointing at the `Dockerfile`
    location. The following example assumes the Dockerfile is located in the user’s
    home directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command will build an image called `packt_demo_image`. This image
    will be used later to create the container with the specs defined in the Dockerfile.
  prefs: []
  type: TYPE_NORMAL
- en: The `-t` option means `tty`, which attaches a terminal to the container.
  prefs: []
  type: TYPE_NORMAL
- en: 'To verify that your image has been created, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You can add the `-a` option to the end of the proceeding command to show all
    images created on the host machine.
  prefs: []
  type: TYPE_NORMAL
- en: In CI/CD operations, the images that are built are usually shared in a public
    or private repository so that they’re available to the project team, or even the
    public in some cases.
  prefs: []
  type: TYPE_NORMAL
- en: The Docker container
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The last step is to run a container based on the Docker image you created (or
    pulled from the image repository). To run a container, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'To verify that the container is running, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command will show only the running containers. To show other containers
    on the host machine, add the `-a` option to the end of the command.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use the older version of the preceding command to verify that
    the container is running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The following diagram shows the relationship between all four Docker components
    and summarizes the entire process of running a container. First, we create a Dockerfile.
    Then, we use that file to create the Docker image. The Docker image can then be
    used to create the Docker container(s) locally, or first uploaded to a private
    or public repository where others can download and create their Docker container(s):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.5: Docker components](img/B18934_09_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.5: Docker components'
  prefs: []
  type: TYPE_NORMAL
- en: Docker containers have a life cycle of their own – they can run for a specific
    task with no regard for what their previous state is, and once that specific task
    is completed, the Docker container automatically terminates.
  prefs: []
  type: TYPE_NORMAL
- en: In other cases, containers need to be aware of their previous status. If so,
    they will need to be persistent to preserve the container data after its termination.
    That’s when Docker volumes become very handy. Next, we will talk about what a
    Docker volume is and how it can be created.
  prefs: []
  type: TYPE_NORMAL
- en: The Docker volume
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Docker volumes are a form of storage that a Docker container can be attached
    to. Containers are attached to volumes to read and write persistent data, which
    are necessary for the function of the container.
  prefs: []
  type: TYPE_NORMAL
- en: To elaborate more, consider the Docker container for the Customer Management
    microservice (`customer_management`). If you need to create a new customer in
    the `customer_management` container, you will need to update the local data store
    installed in that container. If the container is not persistent, once the container
    terminates, all data created or changed inside that container will be lost.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid this problem, we will need to create a Docker volume and attach the
    container to that volume. The container itself can then run and update whatever
    data it needs to update in its volume, and then terminate. When it starts the
    next time, it gets instantiated with all the previous statuses and data it had
    before the last termination.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a Docker volume for the `customer_management` container, for example,
    use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command will list all volumes created on our host machine and
    verify the volume we have just created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Once we create the volume, Docker mounts a local drive space on the host machine
    to preserve the container’s data and its mounted filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: 'To show more details about the volume, including the volume’s name, the local
    host and the container’s target mount locations, and the date and time of the
    volume’s creation, use the `docker volume inspect` or `docker inspect` command,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Assuming we have previously created the `packt_demo_image` image, to create
    the persistent `customer_management` container, we will need to attach the container
    to the volume we have just created using the mount points shown in the `docker
    volume inspect` command’s output. The following command will create the container,
    attach the volume to the container, and then run the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `it` option in the `docker run` command is for interactive `tty` mode, and
    the `d` option is for running the container in the background.
  prefs: []
  type: TYPE_NORMAL
- en: '`/app_data` is an absolute path within the container that’s mounted to the
    local host’s mount point. From the preceding inspect data shown, the `/var/lib/docker/volumes/customer_management_volume/_data`
    mount point is mapped to `/app_data` in the container.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To verify that the container is running, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: If the container terminates for whatever reason, use the `-a` option at the
    end of the preceding command to show the available container on the host. You
    can use the `docker container start` or `docker container stop` command, followed
    by the container’s name, to run or terminate any of the available containers you
    built on that host.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have installed Docker Engine and understand the different components
    of Docker, we will go over how to create the main ABC-MSA containers as microservices
    and provide an example of how these microservices talk to each other.
  prefs: []
  type: TYPE_NORMAL
- en: Creating ABC-MSA containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our ABC-MSA system, we are adopting a container-per-microservice approach.
    Therefore, we need to identify the main containers we will build, the components
    we need for each container in our ABC-MSA system, and then build the necessary
    Dockerfile(s) to use.
  prefs: []
  type: TYPE_NORMAL
- en: We are building our microservice applications using **Flask**. Flask is a **Web
    Server Gateway Interface** (**WSGI**) micro-framework that enables applications
    to respond to API calls in a simple, flexible, and scalable manner. We won’t discuss
    our applications’ code in this book, but the code is available on our GitHub with
    detailed documentation for your reference.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will explain how we build our ABC-MSA Dockerfile(s), images,
    and microservices, how we will start to listen to API calls in each container,
    and how the system’s microservices will be able to communicate with each other.
  prefs: []
  type: TYPE_NORMAL
- en: For demo purposes, we will use port HTTP/8080 in the container to listen to
    HTTP API requests. The production environment should use HTTPS/443 and consider
    the `tomcat` server for handling all web connections.
  prefs: []
  type: TYPE_NORMAL
- en: The following is only part of the full system container setup. All the ABC-MSA
    system’s created files and Docker images can be found in our GitHub repository
    at [https://github.com/PacktPublishing/Machine-Learning-in-Microservices](https://github.com/PacktPublishing/Machine-Learning-in-Microservices).
  prefs: []
  type: TYPE_NORMAL
- en: ABC-MSA containers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following are the services we have previously identified for our ABC-MSA
    system:'
  prefs: []
  type: TYPE_NORMAL
- en: API Gateway
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A frontend web dashboard interface
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Customer Management
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Product Management
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Order Management
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inventory Management
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Courier Management
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Shipping Management
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Payment Authorization
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Notification Management
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Aggregator: “Product Ordered Qty”'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Management and Orchestration
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can code and build each of these services from scratch, but the good news
    is that we don’t have to. Docker Hub offers a rich library with many Docker images
    that we can leverage in building our microservices. Docker Hub can be accessed
    at [https://hub.docker.com/](https://hub.docker.com/).
  prefs: []
  type: TYPE_NORMAL
- en: We will not go over each of these services. Instead, we will focus on the ones
    that provide different development and deployment approaches. Some of the services
    are already available through Docker Hub, and some others are similar, so one
    example of these will suffice. Nevertheless, all the project files will be made
    available in this book’s GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: API Gateway
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many open source and commercial API gateways can be pulled from different internet
    repositories, including Tyk, API Umbrella, WSO2, Apiman, Kong, and Fusio, to name
    a few. We will use Tyk in our ABC-MSA system since it is easy to use, has comprehensive
    features including authentication and service discovery, and is 100% an open source
    product with no feature restrictions.
  prefs: []
  type: TYPE_NORMAL
- en: To install a Tyk Docker container, just follow the instructions at [https://tyk.io/docs/tyk-oss/ce-docker/](https://tyk.io/docs/tyk-oss/ce-docker/).
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the Tyk API gateway listens to TCP port `8080`. To verify your
    installation, issue an API call test to Tyk using the `curl` command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: If Tyk has been successfully installed and is running on your host, you should
    get a dictionary output stating Tyk’s status and the current version, as shown
    in the preceding command output.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also verify that the Tyk Docker image and container were created successfully
    using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We can see the `tyk` image details in the preceding command output, as well
    as the running container and what port it is listening to. We can also see a Redis
    image and container. This is because Redis is a prerequisite for Tyk and is included
    in the Tyk installation package.
  prefs: []
  type: TYPE_NORMAL
- en: The Customer Management microservice as an example
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Customer Management, Product Management, Order Management, Inventory Management,
    Courier Management, Shipping Management, Payment Authorization, and Notification
    Management microservices are all similar in terms of how we can build and deploy
    the container. In this section, we will learn how to create an image that we can
    use to create a system microservice. We have picked the Customer Management microservice
    as an example.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned earlier, for these microservices to communicate with the API gateway
    or any other components in the ABC-MSA system, we need to have Flask installed
    and running, listening to port HTTP/8080 in the running container.
  prefs: []
  type: TYPE_NORMAL
- en: We also need an internal data store for our application to use and manage. And
    since our code will be written in Python, we need to have Python installed as
    well. All these required components, along with some essential dependency packages,
    need to be specified in our Dockerfile.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we need to write the Dockerfile required for creating the microservice
    image that we will use to create the microservice container. Each ABC-MSA container
    should have its own development cycle and be deployed either using the CI/CD cycle
    we discussed in [*Chapter 8*](B18934_08.xhtml#_idTextAnchor086) or uploaded manually
    to the team repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of the Dockerfile that’s required for creating
    the Customer Management image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The aforementioned Dockerfile specifies what the Customer Management Docker
    image should look like. The following are some insights into what each of the
    lines in the file will do:'
  prefs: []
  type: TYPE_NORMAL
- en: Specify Ubuntu as the Linux operating system that will be used in the Customer
    Management container.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Install some required packages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: MySQL (required for our application)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Python (required for our application)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: pip (required to be able to install Flask)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The rest are some other tools needed for troubleshooting (optional)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Install Flask (required for our application).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Expose TCP/HTTP port `8080` for Flask to listen to API calls.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a working directory in the container to act as the mount point for saving
    the container’s data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Download the Customer Management application code from our GitHub repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set an environment variable to let Flask know what application it will use when
    responding to API calls.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use our downloaded `start_services` shell script to start Flask and MySQL in
    the container.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `start_services` shell script contains the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The first line enables Flask to listen to port `8080` on all the host network
    interfaces. This is OK in the development and testing environment. In the production
    environment, however, Flask should only be available on the localhost `127.0.0.1`
    network interface to limit API access to the local environment. Also, for better
    security, port HTTPS/443 should be used in API calls instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming the Dockerfile has been placed in the current user home directory,
    we now need to create our Customer Management microservice/container from the
    Dockerfile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Docker will take a few minutes to finish creating the image. Once all the Dockerfile
    steps have been completed, you should see the following command as the last line
    of the `docker build` command’s output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This signals a successful completion. Now, we can use the `docker image ls`
    command to verify that the `abc_msa_customer_management` image has been created
    successfully.
  prefs: []
  type: TYPE_NORMAL
- en: The last step is creating the container. Since the application will configure
    and update the MySQL database, we need to create a persistent container to retain
    all the changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to what we explained earlier, we will use the `docker run` command
    to create the Customer Management container, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `p` option is used to “publish” and map the ports that the container listens
    to with the ports the host machine listens to. So, the host machine will be listening
    to port `8003` for HTTP/8080 requests on the container.
  prefs: []
  type: TYPE_NORMAL
- en: We have chosen 8003 to standardize the way the host listens to the container’s
    API call requests.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that each container has a TCP stack that is different from the host’s
    TCP stack. So, the TCP HTTP/8080 port is only local within the container itself,
    but outside that particular container’s environment, that TCP HTTP/8080 port is
    different from the TCP HTTP/8080 port available on any other container or on the
    host machine itself.
  prefs: []
  type: TYPE_NORMAL
- en: To access that port from outside the realm of the `customer_management` container,
    you need to map the `customer_management` container’s TCP HTTP/8080 port to a
    specific port on the host machine.
  prefs: []
  type: TYPE_NORMAL
- en: Since we need to map the local TCP HTTP/8080 port of each of the 12 containers
    we identified earlier, we decided to follow a specific pattern. Map the TCP/80nn
    port on the host machine to each local TCP HTTP/8080 of each container. Here,
    nn is the container’s number.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 9**.6* shows how some of the ABC-MSA container’s TCP HTTP/8080 ports
    are mapped on the host machine.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We don’t have to run all the containers on a single host. The system containers
    could be scattered across different hosts, depending on many factors, such as
    how critical the service/application running on the container is, how the system
    is designed, the desired overall redundancy, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ Figure 9.6: The container’s local port mappings to the host machine’s TCP
    stack](img/B18934_09_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.6: The container’s local port mappings to the host machine’s TCP stack'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, verify that the container is running using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command will allow you to connect to the container’s `bash` shell
    using the root privilege (a user ID of `0`, as specified in the command):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: That’s all for the Customer Management microservice. In the same manner, we
    can create the rest of the ABC-MSA containers. We just need to make sure we use
    appropriate corresponding names for the other microservice’s containers and volumes
    and map to the right TCP/80nn port number on the host machine.
  prefs: []
  type: TYPE_NORMAL
- en: The frontend web dashboard interface
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The dashboard is the main component of the **user interface** (**UI**) interaction
    and interacts with all services offered to the user. In our ABC-MSA example, we
    created a simple cart application where the user can place products in the cart
    and place an order.
  prefs: []
  type: TYPE_NORMAL
- en: The Dashboard container is built the same way the `customer_management` container
    is built, as shown in the previous section. The main difference between both is
    the additional web server that we will need to have on the Dashboard microservice,
    and the ports to be exposed on the container. The Dashboard’s Dockerfile should
    be changed accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Like all the containers we are building, the container’s local TCP port that
    listens to API calls is TCP HTTP/8080, and the host-mapped TCP port in the `dashboard`
    container case should be TCP/8002.
  prefs: []
  type: TYPE_NORMAL
- en: The Dashboard container will still need to listen to HTTP/80 for user web UI
    requests. Unless the host machine is running another application or web page on
    HTTP/80 port, we should be OK to use that port.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to map the HTTP/80 port on the host machine, as shown in the following
    `docker` `run` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This command has an additional `p` option to map the HTTP/80 port on the container
    with the HTTP/80 port on the host machine. `abc_msa_dashboard` is the Dashboard
    microservice image.
  prefs: []
  type: TYPE_NORMAL
- en: Managing your system’s containers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you saw in the preceding examples, the `docker run` command can get lengthy
    and messy. **Docker Compose** helps us manage the deployment of containers. With
    Docker Compose, it is much easier to manage the deployment of the containers,
    change deployment parameters, include all system containers in a single YAML file,
    and specify the order of the containers’ deployment and dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a sample YAML file for initializing three of the ABC-MSA containers,
    as we did with the `docker run` commands earlier, but in a more organized and
    structured YAML way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command runs the Docker Compose `.``yaml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `f` option is used to specify the YAML file’s name, and the `&` option is
    used to run the containers in the shell’s background.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we showed you how to create some of the ABC-MSA images and
    containers. The ABC-MSA containers are now ready to communicate with each other
    either directly or, as we will show later in this book, through the API Gateway.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn how we can use the containers we created,
    how we can issue API calls to them, and what response we should expect.
  prefs: []
  type: TYPE_NORMAL
- en: ABC-MSA microservice inter-communication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will learn how to expose APIs from containers and how containers
    communicate with API consumers.
  prefs: []
  type: TYPE_NORMAL
- en: The microservice application code for each container is available in the ABC-MSA
    project on GitHub. We recommend that you download the code to your local test
    environment to be able to get some hands-on experience when following the steps
    we will cover in this section.
  prefs: []
  type: TYPE_NORMAL
- en: There are two main ways for containers to communicate with each other. One is
    by using the container’s name in a **Docker network**, and the other is by using
    the container’s IP and TCP port. The following are some of the details you need
    to know about to be able to configure your containers to communicate with each
    other.
  prefs: []
  type: TYPE_NORMAL
- en: The Docker network
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we have containers running on the same host, containers can communicate
    with each other on the same host using only container names and without the need
    to specify the container’s IP address or listening port.
  prefs: []
  type: TYPE_NORMAL
- en: The concept of using only container names is programmatically very useful, especially
    in cases where these IPs change dynamically. The names are usually deterministic,
    and by only specifying the Docker’s container name, you avoid having to apply
    different layers of system operations to first learn about the container’s TCP/IP
    details before starting to communicate with the target container.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there are some prerequisites to enabling container communication through
    their names only:'
  prefs: []
  type: TYPE_NORMAL
- en: The containers communicating with each other will all need to be on the same
    host
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will need to create a Docker network on the host
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will need to attach the containers to the created Docker network when running
    the container using the `docker run` command or by specifying the container’s
    instantiation details in the `docker-compose` YAML file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following command creates a Docker network on the host machine that can
    be used for our ABC-MSA system’s inter-microservice communication:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command lists the Docker networks configured on the host machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, attach the ABC-MSA containers to the `abc_msa_network` network by using
    the `--network` option in the `docker run` command, as shown in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Using Docker networks is very useful in many cases. However, since we are designing
    our ABC-MSA system so that containers can run independently of their host location,
    we will be using the container’s IP/TCP communication.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll explain how the ABC-MSA microservices communicate
    using TCP/IP and go over some examples of how to test the communication and data
    exchanges.
  prefs: []
  type: TYPE_NORMAL
- en: TCP/IP communication between containers/microservices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have installed Docker, built our Docker images and volumes, and started
    the containers of all our microservices. Now, it is time to understand how these
    containers interact with each other.
  prefs: []
  type: TYPE_NORMAL
- en: Upon running Docker on the container’s host, the host automatically creates
    a virtual IP network and assigns an IP address to each running Docker container
    on that host. That virtual IP network is only internal to the host running the
    containers and cannot be accessed from anywhere outside that host.
  prefs: []
  type: TYPE_NORMAL
- en: The container’s host carries at least two IPs. There’s one inside IP that’s
    internal to the Docker network and that can only be recognized inside that Docker
    network. Then, there’s an outside IP, which is usually assigned by the **Dynamic
    Host Configuration Protocol** (**DHCP**) server in the organization’s network.
    The outside IP is necessary for the container’s host to communicate with the outside
    world.
  prefs: []
  type: TYPE_NORMAL
- en: The internal Docker network of the container’s host is not visible to any other
    host in the network. Therefore, for an outside host to communicate with a specific
    container in the container’s host machine, it will need to use the outside IP
    of the container’s host machine.
  prefs: []
  type: TYPE_NORMAL
- en: Among a lot of other information, to get the assigned IP address, as well as
    the inside and outside listening ports of a specific container in your system,
    use the `docker inspect` command, followed by the container’s name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our demo setup is shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ Figure 9.7: ABC-MSA container communication](img/B18934_09_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.7: ABC-MSA container communication'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the host machine’s inside IP address is 172.17.0.100, and the
    outside IP address is 192.168.1.100\. The container’s host is listening to the
    container’s mapped ports (`8001` to `8012`), as explained earlier.
  prefs: []
  type: TYPE_NORMAL
- en: If other hosts in the network want to send API calls to one of the ABC-MSA containers,
    that outside host will need to send the request to the outside IP address of the
    container’s host, 192.168.1.100, using the mapped port of the container it wants
    to communicate with.
  prefs: []
  type: TYPE_NORMAL
- en: 'To elaborate further, the preceding diagram and the following example show
    an outside host testing the API response of the Product Management container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'ABC-MSA API calls return a JSON variable for easier data handling. One of the
    APIs we built for ABC-MSA microservices is `service_info`. An example of an API
    call for `service_info` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are communicating internally from within the Docker network (172.17.0.0),
    you can communicate directly with the container’s IP and listening ports. Performing
    the same `curl` test on the Product Management container from the API Gateway
    shell would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Knowing how to pass API requests and handle the API response is key to developing
    your MSA system. Please refer to our ABC-MSA code in this book’s GitHub repository
    for examples of how the API calls are issued and handled across the entire system.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered the concept of containers, what they are, and how
    they are different from VMs. Then, we worked with Docker as one of the most popular
    container platforms available today. We showed you how to install Docker and create
    Dockerfiles, Docker images, Docker volumes, and Docker containers.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we applied all these concepts by building some of the ABC-MSA microservices
    with hands-on examples. We built the containers and showed how microservices communicate
    with each other.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will focus on building an AI microservice in the MSA
    system. We will discuss some of the most important AI/ML/DL algorithms that should
    be considered and implemented in an MSA system, and how these algorithms help
    with a system’s overall stability, performance, and supportability.
  prefs: []
  type: TYPE_NORMAL
