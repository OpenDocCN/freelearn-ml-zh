- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Building an MSA with Docker Containers
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Docker 容器构建 MSA
- en: In the previous chapter, we discussed how to apply the DevOps process of building
    and running MSA systems, and the importance of aligning the organizational structure
    with DevOps.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了如何应用构建和运行 MSA 系统的 DevOps 流程，以及将组织结构与 DevOps 对齐的重要性。
- en: We also highlighted the importance of embracing automation and adapting agile
    development methodologies throughout the MSA project life cycle, and throughout
    the CI/CD operations.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还强调了在整个 MSA 项目生命周期以及 CI/CD 运作中拥抱自动化和适应敏捷开发方法的重要性。
- en: This chapter will cover what a **container** is, how to install containers,
    how to work with them, and how to handle the data flow between containers to build
    a simple project. We will use **Docker** as our platform since it is one of the
    most popular and widely used platforms in the field today.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍什么是 **容器**，如何安装容器，如何使用它们，以及如何处理容器之间的数据流以构建一个简单的项目。我们将使用 **Docker** 作为我们的平台，因为它是目前该领域最受欢迎和最广泛使用的平台之一。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: What are containers anyway, and why use them?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器究竟是什么，为什么要使用它们？
- en: Installing Docker
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 Docker
- en: Creating ABC-MSA containers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 ABC-MSA 容器
- en: ABC-MSA microservices inter-communication
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ABC-MSA 微服务间通信
- en: What are containers anyway, and why use them?
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器究竟是什么，为什么要使用它们？
- en: A container is defined as an operating system-level virtualization artifact,
    created by grouping different finite compute resources into a self-contained execution
    environment.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 容器被定义为一种操作系统级别的虚拟化实体，通过将不同的有限计算资源组合成一个自包含的执行环境来创建。
- en: 'As shown in the following figure of a container ship, containers are self-contained
    units, independent from any other container in the ship. The ship is the engine
    that is used to carry and transport containers:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下集装箱船的图所示，容器是自包含的单元，独立于船上的任何其他容器。船是用于携带和运输容器的引擎：
- en: '![Figure 9.1: A container ship](img/B18934_09_1.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.1：一艘集装箱船](img/B18934_09_1.jpg)'
- en: 'Figure 9.1: A container ship'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.1：一艘集装箱船
- en: Similarly, the idea with containers is to create operating system-level virtualization.
    This means that, from within the kernel, you group different physical machine
    resources, applications, and I/O functions into a self-contained execution environment.
    Each of these self-contained resources forms a single container, hence the name
    container. The **Container Engine** is similar to the ship in the preceding example,
    where the container engine is used to carry, run, and transport the containers.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，容器化的想法是在操作系统级别创建虚拟化。这意味着，在内核内部，你可以将不同的物理机器资源、应用程序和 I/O 功能组合成一个自包含的执行环境。这些自包含的资源形成一个单独的容器，因此得名容器。**容器引擎**与前面示例中的船只类似，其中容器引擎用于携带、运行和运输容器。
- en: Containers have existed for a long time and can be traced back to Unix’s **chroot**
    in the late 1970s and early 1980s, and before we even came to learn about what
    we call today a **hypervisor**. A hypervisor is a component that enables us to
    spin up **virtual** **machines** (**VMs**).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 容器已经存在很长时间了，可以追溯到 Unix 的 **chroot** 在 1970 年代后期和 1980 年代初期，以及在我们甚至了解到今天我们称之为
    **虚拟机管理程序** 之前。虚拟机管理程序是一个组件，它使我们能够启动 **虚拟** **机器**（**VMs**）。
- en: Unix’s chroot evolved later in the 1990s to Linux containers or what we call
    **LXC**, and then to **Solaris Zones** in the early 2000s. These concepts started
    to evolve with time from **cgroups** (originally developed by Google) and **namespaces**
    (developed by IBM) in to the container engines we see today, such as Docker, **Rkt**,
    **CRI-O**, **Containers**, Microsoft **Hyper-V** Containers, and more.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Unix 的 chroot 在 1990 年代后期演变为 Linux 容器，或我们称之为 **LXC**，然后在 2000 年代初演变为 **Solaris
    Zones**。这些概念随着时间的推移从 **cgroups**（最初由 Google 开发）和 **namespaces**（由 IBM 开发）发展到我们今天看到的容器引擎，如
    Docker、**Rkt**、**CRI-O**、**Containers**、Microsoft **Hyper-V** 容器等。
- en: Although there are similarities between containers and VMs, both still have
    a few fundamental differences.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管容器和虚拟机之间存在相似之处，但两者仍然有一些基本的不同之处。
- en: 'As shown in the following diagram, containers share the same kernel of the
    host operating system but isolate and limit the allocated resources, giving us
    something that feels like a VM but that’s much more lightweight in terms of resources:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下图所示，容器共享宿主操作系统的同一内核，但隔离并限制分配的资源，给我们带来了一种类似于虚拟机的感觉，但在资源方面要轻得多：
- en: '![Figure 9.2: VMs versus containers](img/B18934_09_2.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.2：虚拟机与容器](img/B18934_09_2.jpg)'
- en: 'Figure 9.2: VMs versus containers'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2：虚拟机与容器
- en: In hypervisor virtualization, each VM will have to have its own virtual hardware
    and its own guest operating system. In addition to all that, there is a great
    deal of emulation taking place in the hypervisor. Accordingly, each VM needs much
    more resources compared to what a container needs. Resources include CPU cycles,
    memory, storage, and more. Moreover, you are likely to have duplicates of the
    same guest OS deployed on multiple VMs for the VM to deliver the required function,
    thus even more overhead and waste of resources.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚拟机管理程序虚拟化中，每个虚拟机都将拥有自己的虚拟硬件和自己的客户操作系统。除此之外，虚拟机管理程序中还有大量的仿真。因此，每个虚拟机需要的资源比容器需要的资源要多得多。资源包括CPU周期、内存、存储等。此外，你可能会在多个虚拟机上部署相同的客户操作系统，以便虚拟机能够提供所需的功能，从而产生更多的开销和资源浪费。
- en: '*Figure 9**.2* shows the hypervisor deployed on top of a host OS. A more common
    hypervisor virtualization model, however, is deploying the bare-metal hypervisor
    on the hardware directly. In either case, the overhead is are still significantly
    higher than deploying containers.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9**.2* 展示了部署在宿主操作系统之上的虚拟机管理程序。然而，更常见的虚拟机管理程序虚拟化模型是在硬件上直接部署裸机虚拟机管理程序。在两种情况下，开销仍然比部署容器要高得多。'
- en: The lightweight nature of containers enables companies to run many more virtualized
    environments in the data center compared to VMs. Since containers share resources
    much more efficiently than VMs, and with finite physical resources in data centers,
    containers largely increase the capacity of the data center infrastructure, which
    means containers become a better choice in hosting applications, especially in
    our case of MSA.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 容器的轻量级特性使得公司能够在数据中心运行比虚拟机更多的虚拟化环境。由于容器比虚拟机更有效地共享资源，并且数据中心有有限的物理资源，容器在很大程度上增加了数据中心基础设施的容量，这意味着容器在托管应用程序方面成为一个更好的选择，尤其是在我们的MSA案例中。
- en: Container performance is another thing to look at. With containers, I/O virtual
    drivers’ communication, hardware emulation, and resources overhead are minimal,
    completely contrary to the case in the hypervisor virtualization environment.
    Accordingly, containers generally outperform VMs. Containers boot in 1-3 seconds
    compared to minutes in the case of VMs.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 容器性能是另一个需要考虑的因素。与虚拟机管理程序虚拟化环境相反，容器中的I/O虚拟驱动程序通信、硬件仿真和资源开销都极小。因此，容器通常比虚拟机表现更好。容器的启动时间只需1-3秒，而虚拟机则需要几分钟。
- en: Applications running on a container can directly interact with and access the
    hardware. In the case of hypervisor virtualization, there is always a hypervisor
    between the application and the VM (unless a hypervisor bypass is enabled, which
    has its own limitations).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器上运行的应用程序可以直接与硬件交互和访问。在虚拟机管理程序虚拟化的情况下，应用程序和虚拟机之间始终有一个虚拟机管理程序（除非启用了虚拟机管理程序绕过，这有其自身的限制）。
- en: With containers, you can package the application with all of its dependencies
    in a contained environment that’s reusable and completely portable to any other
    platform. That’s one of the most important features of containers. Developers
    can develop an application on their development servers, ship it to the testing
    environment, then staging and production, and run the application without having
    to worry about portability and dependency issues.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 使用容器，你可以在一个可重复使用且完全可移植到任何其他平台的环境中打包应用程序及其所有依赖项。这是容器最重要的特性之一。开发者可以在他们的开发服务器上开发应用程序，将其发送到测试环境，然后是预生产和生产，而无需担心可移植性和依赖性问题。
- en: Important note
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: For all the aforementioned reasons, the most popular deployment model of microservices
    is the container-per-service model. This is where each microservice of the MSA
    is deployed on a single container dedicated to running that particular application.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有上述原因，微服务最流行的部署模型是每个服务一个容器的模型。这就是MSA的每个微服务都部署在运行特定应用程序的专用容器上。
- en: The other important difference between containers and VMs is security. Since
    containers use the same kernel, multiple containers may very well access the same
    kernel subsystem outside the boundaries of the container. This means a container
    could gain access to other containers running on the same physical host. A single
    application with root access, for example, could access any other container data.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 容器和虚拟机之间的另一个重要区别是安全性。由于容器使用相同的内核，多个容器可能会在容器边界之外访问相同的内核子系统。这意味着容器可以访问同一物理主机上运行的另一个容器。例如，一个具有root访问权限的单个应用程序可以访问任何其他容器的数据。
- en: There are many ways to harden the security of containers, but none of these
    techniques would help containers match the VM’s total isolation security.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多方法可以加强容器安全性，但没有任何这些技术可以帮助容器达到虚拟机的完全隔离安全性。
- en: There are cases, of course, where using VMs would be a better option than using
    containers. Or in some scenarios, a mix of both VMs and containers would be the
    most appropriate deployment model. It all depends on the use case, the application,
    or the system you are deploying in your organization.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在某些情况下，使用虚拟机可能比使用容器更好。或者在某些场景中，虚拟机和容器的混合部署模式可能是最合适的。这完全取决于您在组织中部署的使用案例、应用程序或系统。
- en: In a multi-tenant environment, where complete workload isolation is necessary,
    using VMs would be a better choice. Or, if you are trying to build an R&D environment
    for hosting critical intellectual capital, or highly confidential data or applications,
    a complete workload isolation will also be necessary. Therefore, in this case,
    using VMs would be the better option.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在需要完全工作负载隔离的多租户环境中，使用虚拟机会是一个更好的选择。或者，如果您正在尝试构建一个用于托管关键知识产权、高度机密数据或应用程序的研发环境，也需要完全的工作负载隔离。因此，在这种情况下，使用虚拟机将是更好的选择。
- en: For our MSA example, we need a very lightweight, fast-starting, highly portable,
    and high-performing virtualization environment to build our MSA system. Hence,
    containers, with a container-per-microservice deployment model, are the better
    choice in our scenario. Each of the MSA system’s microservices would be deployed
    in its own container and would have its own development team, development cycle,
    QA cycle, updates, run life cycle, and release cycle.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的MSA示例，我们需要一个非常轻量级、快速启动、高度可移植且高性能的虚拟化环境来构建我们的MSA系统。因此，在我们的场景中，使用容器，采用每个微服务一个容器的部署模式，是更好的选择。MSA系统中的每个微服务都会部署在其自己的容器中，并拥有自己的开发团队、开发周期、质量保证周期、更新、运行生命周期和发布周期。
- en: 'The following table summarizes the differences between containers and hypervisor
    virtualization:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格总结了容器和虚拟机管理程序之间的区别：
- en: '|  | **Containers** | **Hypervisor VM’s** |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '|  | **容器** | **虚拟机管理程序** |'
- en: '| Resource Usage and Overhead | Lightweight, Please overhead, and more efficient
    use of resources | High overhead and resource-intensive |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| 资源使用和开销 | 轻量级，请减少开销，并更高效地使用资源 | 高开销和资源密集型'
- en: '| Container and Application Size | Averages 5-20 MB | Measured in 100s of MB
    or GB |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| 容器和应用程序大小 | 平均5-20 MB | 以MB或GB为单位衡量'
- en: '| Performance | High performance | Lower performance |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| 性能 | 高性能 | 性能较低'
- en: '| Scalability | Easy to scale out/high horizontal scaling | Scaling out is
    harder and consumes resources |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| 可扩展性 | 容易扩展/高横向扩展 | 扩展难度较大且消耗资源'
- en: '| Bootup Time | Very short startup time (1-3 seconds) | Startup time is in
    minutes |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| 启动时间 | 非常短的启动时间（1-3秒） | 启动时间以分钟计'
- en: '| Portability | System-agnostic and highly portable | Portability is limited
    |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| 可移植性 | 系统无关性和高度可移植性 | 可移植性有限'
- en: '| DevOps and CI/CD Suitability | Enables more agile DevOps and smoother CI/CD
    | Could slow down CI/CD operations |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| DevOps和CI/CD适用性 | 使DevOps更加敏捷，CI/CD流程更加顺畅 | 可能会减慢CI/CD操作'
- en: '| Host Hardware Access | Applications access HW directly | No direct access
    to HW |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 主机硬件访问 | 应用程序直接访问硬件 | 无法直接访问硬件'
- en: '| Security | Less secure; shares the same kernel | More secure; each VM has
    its own OS kernel |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 安全性 | 安全性较低；共享相同的内核 | 安全性更高；每个虚拟机都有自己的操作系统内核'
- en: 'Table 9.1: Differences between containers and Hypervisor VMs'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 表9.1：容器和虚拟机管理程序的区别
- en: Despite the many options we currently have in choosing a container engine, Docker
    is by far the most popular engine used today, to the extent that Docker today
    is synonymous with containers. That’s the main reason why we have chosen to work
    with Docker as our container’s engine in this book.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们在选择容器引擎时有许多选项，但Docker是目前使用最广泛的引擎，以至于Docker今天与容器同义。这就是我们选择在本书中使用Docker作为容器引擎的主要原因。
- en: 'Docker is also ideal for agile DevOps and CI/CD operations. In a CI/CD environment,
    the time between building a Docker image to the time it is up and running in the
    production environment is usually around 1-5 minutes in total:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Docker也非常适合敏捷的DevOps和CI/CD操作。在CI/CD环境中，从构建Docker镜像到其在生产环境中启动并运行的总时间通常在1-5分钟之间：
- en: '![Figure 9.3: Docker Engine container virtualization](img/B18934_09_3.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图9.3：Docker Engine容器虚拟化](img/B18934_09_3.jpg)'
- en: 'Figure 9.3: Docker Engine container virtualization'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3：Docker Engine容器虚拟化
- en: '*Figure 9**.3* shows Docker Engine installed on the host operating system to
    enable the containerization of microservices or applications in general.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9**.3*显示了在宿主操作系统上安装的Docker Engine，以实现微服务或应用程序的一般容器化。'
- en: Docker in itself may not be sufficient to manage all the CI/CD operations. Organizations
    usually complement Docker by using a clustering technology such as **Kubernetes**
    or **Marathon** to smoothly deploy, manage, and operate the containers within
    the cluster in which your system is running. However, in this book, we will focus
    on Docker itself and how to use Docker to build our MSA system.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Docker本身可能不足以管理所有的CI/CD操作。组织通常通过使用**Kubernetes**或**Marathon**等集群技术来补充Docker，以便在您的系统运行的集群中平滑地部署、管理和操作容器。然而，在本书中，我们将专注于Docker本身以及如何使用Docker构建我们的MSA系统。
- en: Also, to move, test, and deploy containers, we will need to have a repository
    to save these containers and be able to move them to different environments. Many
    tools can help with that, with **Docker Hub** and **GitHub** being two of the
    most commonly used repositories. For our project, we will use GitHub as our project
    repository.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，为了移动、测试和部署容器，我们需要有一个仓库来保存这些容器，并能够将它们移动到不同的环境。许多工具可以帮助我们完成这项工作，其中**Docker
    Hub**和**GitHub**是两个最常用的仓库。对于我们的项目，我们将使用GitHub作为我们的项目仓库。
- en: So far, we have covered what containers are, the difference between containers
    and VMs, and why we prefer to use containers in MSA. In the next section, we will
    explain the different components of Docker, how to install Docker, and how to
    work with Docker’s components to create a system’s microservices.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经介绍了容器是什么，容器与VM之间的区别，以及为什么我们更倾向于在MSA中使用容器。在下一节中，我们将解释Docker的不同组件，如何安装Docker，以及如何与Docker的组件一起工作来创建系统的微服务。
- en: Installing Docker
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Docker
- en: We will start this section by talking about Docker installation. Then, we will
    cover the main components of Docker, the purpose of each component, and how these
    components relate to each other. This section will help us prepare the environment
    that we will use later for our ABC-MSA demo project.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从这个节开始，先谈谈Docker的安装。然后，我们将介绍Docker的主要组件，每个组件的目的，以及这些组件是如何相互关联的。本节将帮助我们为后续的ABC-MSA演示项目准备环境。
- en: Important note
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: To maximize your hands-on learning experience, you need to follow all of our
    hands-on installation steps. But before doing so, please make sure you have a
    physical or virtual host available for the Docker installation demo before we
    dive deeper into this section. A virtual host can be created using virtualization
    software such as VirtualBox or VMWare.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为了最大限度地提高您的动手学习体验，您需要遵循我们所有的动手安装步骤。但在我们深入这一节之前，请确保您有一个物理或虚拟主机可用于Docker安装演示。可以使用虚拟化软件（如VirtualBox或VMWare）创建虚拟主机。
- en: Although you can install Docker on Windows or Mac, in our demo, we will use
    an Ubuntu Server 22.x Linux environment to install Docker **Community Edition**
    (**CE**). We suggest you use a similar environment to be able to follow our installation
    steps.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您可以在Windows或Mac上安装Docker，但在我们的演示中，我们将使用Ubuntu Server 22.x Linux环境来安装Docker**社区版**（**CE**）。我们建议您使用类似的环境，以便能够跟随我们的安装步骤。
- en: Docker Engine installation
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker Engine安装
- en: Now that we know the main components of Docker, let’s take a step back and learn
    how to install Docker and create different Docker images for the ABC-MSA system.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了Docker的主要组件，让我们退一步，学习如何安装Docker并为ABC-MSA系统创建不同的Docker镜像。
- en: The best way to install Docker Engine is to follow Docker’s official installation
    guide from Docker Docs at [https://docs.docker.com/engine/install/](https://docs.docker.com/engine/install/).
    Pick your server system platform installation guide from the list.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Docker 引擎的最佳方式是遵循 Docker Docs 中的官方安装指南，网址为 [https://docs.docker.com/engine/install/](https://docs.docker.com/engine/install/)。从列表中选择你的服务器系统平台安装指南。
- en: You may also want to install Docker Desktop on your workstation. Docker Desktop
    is available for download from the same installation guide referred to previously.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还希望在你的工作站上安装 Docker Desktop。Docker Desktop 可以从之前提到的安装指南中下载。
- en: 'After the installation is completed, verify Docker’s functionality by running
    the following command:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，通过运行以下命令来验证 Docker 的功能：
- en: '[PRE0]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: And,
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，
- en: '[PRE1]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You may need root privileges to issue the Docker commands successfully.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能需要 root 权限才能成功执行 Docker 命令。
- en: Now that we have installed Docker, let’s go over the main components of Docker
    and how to use each.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了 Docker，让我们来回顾 Docker 的主要组件以及如何使用它们。
- en: Docker components
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker 组件
- en: 'There are four main components of Docker: the Docker file, the Docker image,
    the Docker container, and the Docker volume. The following is a brief description
    of each of these components.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 有四个主要组件：Docker 文件、Docker 镜像、Docker 容器和 Docker 卷。以下是这些组件的简要描述。
- en: The Docker file
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Docker 文件
- en: 'The Docker file is a text file that works as a manifest that describes how
    the Docker image should be built. The Docker file specifies the base image that
    will be used to create the Docker image. So, for example, if you were to use the
    latest Ubuntu version as your base Linux image for the container, you would have
    the following line specified at the top of your Docker file:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 文件是一个文本文件，它作为一个清单，描述了如何构建 Docker 镜像。Docker 文件指定了用于创建 Docker 镜像的基础镜像。例如，如果你打算使用最新的
    Ubuntu 版本作为你的基础 Linux 镜像，你会在 Docker 文件的顶部指定以下行：
- en: '[PRE2]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Notice that `ubuntu` is not tagged with any version number, which will instruct
    Docker to pull the latest version available for that base image. If you prefer
    to use CentOS version 7.0, for example, you must then tag the base image with
    the version number, as shown in the following line:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `ubuntu` 没有指定任何版本号，这将指示 Docker 拉取该基础镜像的最新版本。例如，如果你希望使用 CentOS 7.0 版本，你必须在该基础镜像上指定版本号，如下所示：
- en: '[PRE3]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The specific image tag can be found on Docker Hub. Docker Hub is a public repository
    that stores many free Docker official images for reuse by Docker users. Among
    many others, base images could be Linux, Windows, Node.js, Redis, Postgres, or
    other relational DB images.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 特定的镜像标签可以在 Docker Hub 上找到。Docker Hub 是一个公共仓库，存储了许多免费 Docker 官方镜像，供 Docker 用户重用。其中许多镜像包括
    Linux、Windows、Node.js、Redis、Postgres 或其他关系型数据库镜像。
- en: After you specify the base operating system image, you can use the `RUN` command
    to run the commands that you would like to execute during the Docker image creation.
    These are regular shell commands that are usually issued to download and install
    packages and libraries that will be used in your Docker image.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在指定了基础操作系统镜像之后，你可以使用 `RUN` 命令来运行你希望在 Docker 镜像创建过程中执行的命令。这些是常规的 shell 命令，通常用于下载和安装将在你的
    Docker 镜像中使用的软件包和库。
- en: 'The Docker file has to be named `Dockerfile` for Docker to be able to use it.
    The following is a simple Dockerfile example:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 文件必须命名为 `Dockerfile`，Docker 才能使用它。以下是一个简单的 Dockerfile 示例：
- en: '![Figure 9.4: A Docker file (Dockerfile) example](img/B18934_09_4.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.4：Docker 文件（Dockerfile）示例](img/B18934_09_4.jpg)'
- en: 'Figure 9.4: A Docker file (Dockerfile) example'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.4：Docker 文件（Dockerfile）示例
- en: 'The preceding sample Dockerfile does the following:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 之前示例中的 Dockerfile 执行以下操作：
- en: Uses Ubuntu version 22.10 as the base image to run on the container that will
    be created later.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Ubuntu 22.10 版本作为基础镜像，在稍后创建的容器上运行。
- en: Fetches the latest packages list.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取最新的软件包列表。
- en: Installs Python version 3 and the PIP Python package management system.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 Python 3 和 PIP Python 包管理器。
- en: Installs a package called Ansible (Ansible is an automation tool).
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装了一个名为 Ansible 的软件包（Ansible 是一个自动化工具）。
- en: The Docker image
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Docker 镜像
- en: Once you have finished composing your Dockerfile, you will need to save it as
    a `Dockerfile` to be able to use it to create the Docker image.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你完成了 Dockerfile 的编写，你需要将其保存为 `Dockerfile`，以便能够使用它来创建 Docker 镜像。
- en: A Docker image is a binary file that works as a template with a set of instructions
    on how a Docker container should be created.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Docker镜像是一个二进制文件，它作为一个模板，包含了一组关于如何创建Docker容器的指令。
- en: Please note that a Docker image can either be created from the Dockerfile, as
    we are explaining here, or downloaded from a public or private repository such
    as Docker Hub or GitHub.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Docker镜像可以是Dockerfile创建的，正如我们在这里解释的，也可以从公共或私有仓库（如Docker Hub或GitHub）下载。
- en: 'To build a Docker image, use the following command while pointing at the `Dockerfile`
    location. The following example assumes the Dockerfile is located in the user’s
    home directory:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建Docker镜像，请使用以下命令，同时指向`Dockerfile`的位置。以下示例假设Dockerfile位于用户的家目录中：
- en: '[PRE4]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding command will build an image called `packt_demo_image`. This image
    will be used later to create the container with the specs defined in the Dockerfile.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将构建一个名为`packt_demo_image`的镜像。这个镜像将用于稍后根据Dockerfile中定义的规范创建容器。
- en: The `-t` option means `tty`, which attaches a terminal to the container.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`-t`选项表示`tty`，它将一个终端附加到容器。'
- en: 'To verify that your image has been created, use the following command:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证您的镜像已创建，请使用以下命令：
- en: '[PRE5]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You can add the `-a` option to the end of the proceeding command to show all
    images created on the host machine.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将`-a`选项添加到上一个命令的末尾，以显示在主机机器上创建的所有镜像。
- en: In CI/CD operations, the images that are built are usually shared in a public
    or private repository so that they’re available to the project team, or even the
    public in some cases.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在CI/CD操作中，构建的镜像通常被共享在公共或私有仓库中，以便项目团队使用，在某些情况下甚至对公众开放。
- en: The Docker container
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Docker容器
- en: 'The last step is to run a container based on the Docker image you created (or
    pulled from the image repository). To run a container, use the following command:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是根据您创建的Docker镜像（或从镜像仓库拉取的镜像）运行容器。要运行容器，请使用以下命令：
- en: '[PRE6]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To verify that the container is running, use the following command:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证容器正在运行，请使用以下命令：
- en: '[PRE7]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The preceding command will show only the running containers. To show other containers
    on the host machine, add the `-a` option to the end of the command.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将只显示正在运行的容器。要显示主机机器上的其他容器，请将`-a`选项添加到命令的末尾。
- en: 'You can also use the older version of the preceding command to verify that
    the container is running:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以使用上述命令的旧版本来验证容器正在运行：
- en: '[PRE8]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following diagram shows the relationship between all four Docker components
    and summarizes the entire process of running a container. First, we create a Dockerfile.
    Then, we use that file to create the Docker image. The Docker image can then be
    used to create the Docker container(s) locally, or first uploaded to a private
    or public repository where others can download and create their Docker container(s):'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了所有四个Docker组件之间的关系，并总结了运行容器的整个过程。首先，我们创建一个Dockerfile。然后，我们使用该文件创建Docker镜像。Docker镜像可以用来在本地创建Docker容器（s），或者首先上传到私有或公共仓库，其他人可以从那里下载并创建他们的Docker容器（s）：
- en: '![Figure 9.5: Docker components](img/B18934_09_5.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图9.5：Docker组件](img/B18934_09_5.jpg)'
- en: 'Figure 9.5: Docker components'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5：Docker组件
- en: Docker containers have a life cycle of their own – they can run for a specific
    task with no regard for what their previous state is, and once that specific task
    is completed, the Docker container automatically terminates.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Docker容器有自己的生命周期——它们可以运行特定的任务，而不考虑它们之前的状态，一旦特定任务完成，Docker容器就会自动终止。
- en: In other cases, containers need to be aware of their previous status. If so,
    they will need to be persistent to preserve the container data after its termination.
    That’s when Docker volumes become very handy. Next, we will talk about what a
    Docker volume is and how it can be created.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他情况下，容器需要知道它们之前的状态。如果是这样，它们需要持久化以在终止后保留容器数据。这时，Docker卷就变得非常有用。接下来，我们将讨论什么是Docker卷以及如何创建它。
- en: The Docker volume
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Docker卷
- en: Docker volumes are a form of storage that a Docker container can be attached
    to. Containers are attached to volumes to read and write persistent data, which
    are necessary for the function of the container.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Docker卷是Docker容器可以附加的一种存储形式。容器通过附加卷来读取和写入持久数据，这对于容器的功能是必要的。
- en: To elaborate more, consider the Docker container for the Customer Management
    microservice (`customer_management`). If you need to create a new customer in
    the `customer_management` container, you will need to update the local data store
    installed in that container. If the container is not persistent, once the container
    terminates, all data created or changed inside that container will be lost.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更详细地说明，考虑 Customer Management 微服务（`customer_management`）的 Docker 容器。如果您需要在
    `customer_management` 容器中创建新客户，您需要更新该容器中安装的本地数据存储。如果容器不是持久的，一旦容器终止，容器内部创建或更改的所有数据都将丢失。
- en: To avoid this problem, we will need to create a Docker volume and attach the
    container to that volume. The container itself can then run and update whatever
    data it needs to update in its volume, and then terminate. When it starts the
    next time, it gets instantiated with all the previous statuses and data it had
    before the last termination.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这个问题，我们需要创建一个 Docker 卷并将容器附加到该卷。然后容器本身可以运行并更新其卷中需要更新的任何数据，然后终止。当它下次启动时，它会以最后一次终止前的所有状态和数据实例化。
- en: 'To create a Docker volume for the `customer_management` container, for example,
    use the following command:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 要为 `customer_management` 容器创建 Docker 卷，例如，请使用以下命令：
- en: '[PRE9]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The following command will list all volumes created on our host machine and
    verify the volume we have just created:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令将列出我们主机机器上创建的所有卷并验证我们刚刚创建的卷：
- en: '[PRE10]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Once we create the volume, Docker mounts a local drive space on the host machine
    to preserve the container’s data and its mounted filesystem.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了卷，Docker 将在主机机器上挂载一个本地驱动器空间以保留容器的数据及其挂载的文件系统。
- en: 'To show more details about the volume, including the volume’s name, the local
    host and the container’s target mount locations, and the date and time of the
    volume’s creation, use the `docker volume inspect` or `docker inspect` command,
    as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示有关卷的更多详细信息，包括卷的名称、本地主机和容器的目标挂载位置，以及卷的创建日期和时间，请使用 `docker volume inspect`
    或 `docker inspect` 命令，如下所示：
- en: '[PRE11]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Assuming we have previously created the `packt_demo_image` image, to create
    the persistent `customer_management` container, we will need to attach the container
    to the volume we have just created using the mount points shown in the `docker
    volume inspect` command’s output. The following command will create the container,
    attach the volume to the container, and then run the container:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们之前创建了 `packt_demo_image` 镜像，要创建持久的 `customer_management` 容器，我们需要使用 `docker
    volume inspect` 命令的输出中显示的挂载点将容器附加到我们刚刚创建的卷。以下命令将创建容器，将卷附加到容器，然后运行容器：
- en: '[PRE12]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `it` option in the `docker run` command is for interactive `tty` mode, and
    the `d` option is for running the container in the background.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker run` 命令中的 `it` 选项用于交互式 `tty` 模式，而 `d` 选项用于在后台运行容器。'
- en: '`/app_data` is an absolute path within the container that’s mounted to the
    local host’s mount point. From the preceding inspect data shown, the `/var/lib/docker/volumes/customer_management_volume/_data`
    mount point is mapped to `/app_data` in the container.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`/app_data` 是容器内的一个绝对路径，挂载到本地主机的挂载点。从前面的检查数据中可以看出，`/var/lib/docker/volumes/customer_management_volume/_data`
    挂载点映射到容器中的 `/app_data`。'
- en: 'To verify that the container is running, use the following command:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证容器正在运行，请使用以下命令：
- en: '[PRE13]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If the container terminates for whatever reason, use the `-a` option at the
    end of the preceding command to show the available container on the host. You
    can use the `docker container start` or `docker container stop` command, followed
    by the container’s name, to run or terminate any of the available containers you
    built on that host.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果容器因任何原因终止，请在上一条命令的末尾使用 `-a` 选项来显示主机上可用的容器。您可以使用 `docker container start` 或
    `docker container stop` 命令，后跟容器名称，来运行或终止在主机上构建的任何可用容器。
- en: Now that we have installed Docker Engine and understand the different components
    of Docker, we will go over how to create the main ABC-MSA containers as microservices
    and provide an example of how these microservices talk to each other.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了 Docker 引擎并了解了 Docker 的不同组件，我们将介绍如何创建主要的 ABC-MSA 容器作为微服务，并提供一个示例说明这些微服务如何相互通信。
- en: Creating ABC-MSA containers
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 ABC-MSA 容器
- en: In our ABC-MSA system, we are adopting a container-per-microservice approach.
    Therefore, we need to identify the main containers we will build, the components
    we need for each container in our ABC-MSA system, and then build the necessary
    Dockerfile(s) to use.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的ABC-MSA系统中，我们采用每个微服务一个容器的策略。因此，我们需要确定我们将构建的主要容器，我们ABC-MSA系统中每个容器所需的组件，然后构建必要的Dockerfile(s)来使用。
- en: We are building our microservice applications using **Flask**. Flask is a **Web
    Server Gateway Interface** (**WSGI**) micro-framework that enables applications
    to respond to API calls in a simple, flexible, and scalable manner. We won’t discuss
    our applications’ code in this book, but the code is available on our GitHub with
    detailed documentation for your reference.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用**Flask**构建我们的微服务应用程序。Flask是一个**Web服务器网关接口**（**WSGI**）微框架，它使应用程序能够以简单、灵活和可扩展的方式响应API调用。我们不会在本书中讨论我们的应用程序代码，但代码可在我们的GitHub上找到，并提供详细的文档供您参考。
- en: In this section, we will explain how we build our ABC-MSA Dockerfile(s), images,
    and microservices, how we will start to listen to API calls in each container,
    and how the system’s microservices will be able to communicate with each other.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将解释我们如何构建ABC-MSA的Dockerfile(s)、镜像和微服务，我们将如何开始在容器中监听API调用，以及系统微服务如何相互通信。
- en: For demo purposes, we will use port HTTP/8080 in the container to listen to
    HTTP API requests. The production environment should use HTTPS/443 and consider
    the `tomcat` server for handling all web connections.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示目的，我们将在容器中使用HTTP/8080端口来监听HTTP API请求。生产环境应使用HTTPS/443，并考虑使用`tomcat`服务器来处理所有Web连接。
- en: The following is only part of the full system container setup. All the ABC-MSA
    system’s created files and Docker images can be found in our GitHub repository
    at [https://github.com/PacktPublishing/Machine-Learning-in-Microservices](https://github.com/PacktPublishing/Machine-Learning-in-Microservices).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 以下只是完整系统容器设置的其中一部分。所有ABC-MSA系统创建的文件和Docker镜像都可以在我们的GitHub仓库[https://github.com/PacktPublishing/Machine-Learning-in-Microservices](https://github.com/PacktPublishing/Machine-Learning-in-Microservices)中找到。
- en: ABC-MSA containers
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ABC-MSA容器
- en: 'The following are the services we have previously identified for our ABC-MSA
    system:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是之前为我们的ABC-MSA系统识别出的服务：
- en: API Gateway
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: API网关
- en: A frontend web dashboard interface
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前端Web仪表板界面
- en: Customer Management
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户管理
- en: Product Management
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 产品管理
- en: Order Management
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 订单管理
- en: Inventory Management
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 库存管理
- en: Courier Management
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 快递管理
- en: Shipping Management
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发货管理
- en: Payment Authorization
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 付款授权
- en: Notification Management
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通知管理
- en: 'Aggregator: “Product Ordered Qty”'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 聚合器： “已订购产品数量”
- en: Management and Orchestration
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 管理和编排
- en: We can code and build each of these services from scratch, but the good news
    is that we don’t have to. Docker Hub offers a rich library with many Docker images
    that we can leverage in building our microservices. Docker Hub can be accessed
    at [https://hub.docker.com/](https://hub.docker.com/).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从头开始编写和构建这些服务中的每一个，但好消息是，我们不必这样做。Docker Hub提供了一个丰富的库，其中包含许多我们可以利用来构建微服务的Docker镜像。Docker
    Hub可以通过[https://hub.docker.com/](https://hub.docker.com/)访问。
- en: We will not go over each of these services. Instead, we will focus on the ones
    that provide different development and deployment approaches. Some of the services
    are already available through Docker Hub, and some others are similar, so one
    example of these will suffice. Nevertheless, all the project files will be made
    available in this book’s GitHub repository.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会逐一介绍这些服务。相反，我们将关注那些提供不同开发和部署方法的服务。其中一些服务已经可以通过Docker Hub获得，还有一些其他的服务类似，所以举一个这些服务的例子就足够了。尽管如此，所有项目文件都将在这个书籍的GitHub仓库中提供。
- en: API Gateway
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: API网关
- en: Many open source and commercial API gateways can be pulled from different internet
    repositories, including Tyk, API Umbrella, WSO2, Apiman, Kong, and Fusio, to name
    a few. We will use Tyk in our ABC-MSA system since it is easy to use, has comprehensive
    features including authentication and service discovery, and is 100% an open source
    product with no feature restrictions.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开源和商业API网关可以从不同的互联网仓库中获取，包括Tyk、API Umbrella、WSO2、Apiman、Kong和Fusio等，仅举几例。我们将在ABC-MSA系统中使用Tyk，因为它易于使用，具有包括身份验证和服务发现在内的全面功能，并且是完全开源的产品，没有任何功能限制。
- en: To install a Tyk Docker container, just follow the instructions at [https://tyk.io/docs/tyk-oss/ce-docker/](https://tyk.io/docs/tyk-oss/ce-docker/).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装Tyk Docker容器，只需遵循[https://tyk.io/docs/tyk-oss/ce-docker/](https://tyk.io/docs/tyk-oss/ce-docker/)中的说明。
- en: 'By default, the Tyk API gateway listens to TCP port `8080`. To verify your
    installation, issue an API call test to Tyk using the `curl` command, as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Tyk API 网关监听 TCP 端口 `8080`。要验证您的安装，请使用 `curl` 命令向 Tyk 发出 API 调试请求，如下所示：
- en: '[PRE14]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If Tyk has been successfully installed and is running on your host, you should
    get a dictionary output stating Tyk’s status and the current version, as shown
    in the preceding command output.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 Tyk 已成功安装并在您的主机上运行，您应该会得到一个字典输出，显示 Tyk 的状态和当前版本，如前一个命令输出所示。
- en: 'You can also verify that the Tyk Docker image and container were created successfully
    using the following commands:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用以下命令验证 Tyk Docker 镜像和容器是否已成功创建：
- en: '[PRE15]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We can see the `tyk` image details in the preceding command output, as well
    as the running container and what port it is listening to. We can also see a Redis
    image and container. This is because Redis is a prerequisite for Tyk and is included
    in the Tyk installation package.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在前一个命令输出中看到 `tyk` 镜像的详细信息，以及正在运行的容器和它监听哪个端口。我们还可以看到一个 Redis 镜像和容器。这是因为 Redis
    是 Tyk 的先决条件，并且包含在 Tyk 安装包中。
- en: The Customer Management microservice as an example
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 以客户管理微服务为例
- en: The Customer Management, Product Management, Order Management, Inventory Management,
    Courier Management, Shipping Management, Payment Authorization, and Notification
    Management microservices are all similar in terms of how we can build and deploy
    the container. In this section, we will learn how to create an image that we can
    use to create a system microservice. We have picked the Customer Management microservice
    as an example.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建和部署容器方面，客户管理、产品管理、订单管理、库存管理、快递管理、发货管理、支付授权和通知管理微服务在本质上都是相似的。在本节中，我们将学习如何创建一个可以用来创建系统微服务的镜像。我们选择了客户管理微服务作为示例。
- en: As mentioned earlier, for these microservices to communicate with the API gateway
    or any other components in the ABC-MSA system, we need to have Flask installed
    and running, listening to port HTTP/8080 in the running container.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，为了使这些微服务能够与 API 网关或 ABC-MSA 系统中的任何其他组件进行通信，我们需要安装并运行 Flask，监听运行容器中的 HTTP/8080
    端口。
- en: We also need an internal data store for our application to use and manage. And
    since our code will be written in Python, we need to have Python installed as
    well. All these required components, along with some essential dependency packages,
    need to be specified in our Dockerfile.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个内部数据存储库，以便我们的应用程序使用和管理。由于我们的代码将用 Python 编写，因此我们还需要安装 Python。所有这些必需的组件以及一些基本依赖包都需要在我们的
    Dockerfile 中指定。
- en: Now, we need to write the Dockerfile required for creating the microservice
    image that we will use to create the microservice container. Each ABC-MSA container
    should have its own development cycle and be deployed either using the CI/CD cycle
    we discussed in [*Chapter 8*](B18934_08.xhtml#_idTextAnchor086) or uploaded manually
    to the team repository.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要编写创建微服务镜像所需的 Dockerfile，我们将使用该镜像创建微服务容器。每个 ABC-MSA 容器都应该有自己的开发周期，并可以使用我们讨论过的
    CI/CD 循环部署，或者手动上传到团队仓库。
- en: 'The following is an example of the Dockerfile that’s required for creating
    the Customer Management image:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是为创建客户管理镜像所需的 Dockerfile 的示例：
- en: '[PRE16]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The aforementioned Dockerfile specifies what the Customer Management Docker
    image should look like. The following are some insights into what each of the
    lines in the file will do:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 上述 Dockerfile 指定了客户管理 Docker 镜像应该是什么样子。以下是对文件中每一行将执行的操作的一些见解：
- en: Specify Ubuntu as the Linux operating system that will be used in the Customer
    Management container.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定 Ubuntu 作为将在客户管理容器中使用的 Linux 操作系统。
- en: 'Install some required packages:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装一些必需的软件包：
- en: MySQL (required for our application)
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: MySQL（我们的应用程序所需的）
- en: Python (required for our application)
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python（我们的应用程序所需的）
- en: pip (required to be able to install Flask)
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: pip（用于安装 Flask）
- en: The rest are some other tools needed for troubleshooting (optional)
  id: totrans-175
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其余的是一些用于故障排除的其他工具（可选）。
- en: Install Flask (required for our application).
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 Flask（我们的应用程序所需的）。
- en: Expose TCP/HTTP port `8080` for Flask to listen to API calls.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 Flask 暴露 TCP/HTTP 端口 `8080` 以监听 API 调用。
- en: Create a working directory in the container to act as the mount point for saving
    the container’s data.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在容器中创建一个工作目录，作为保存容器数据的挂载点。
- en: Download the Customer Management application code from our GitHub repository.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从我们的 GitHub 仓库下载客户管理应用程序代码。
- en: Set an environment variable to let Flask know what application it will use when
    responding to API calls.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置一个环境变量，让Flask知道在响应API调用时将使用哪个应用程序。
- en: Use our downloaded `start_services` shell script to start Flask and MySQL in
    the container.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用我们下载的`start_services`shell脚本在容器中启动Flask和MySQL。
- en: 'The `start_services` shell script contains the following commands:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`start_services`shell脚本包含以下命令：'
- en: '[PRE17]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The first line enables Flask to listen to port `8080` on all the host network
    interfaces. This is OK in the development and testing environment. In the production
    environment, however, Flask should only be available on the localhost `127.0.0.1`
    network interface to limit API access to the local environment. Also, for better
    security, port HTTPS/443 should be used in API calls instead.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行使Flask能够监听所有主机网络接口上的端口`8080`。这在开发和测试环境中是可以的。然而，在生产环境中，Flask应该只可在localhost
    `127.0.0.1`网络接口上可用，以限制API访问到本地环境。此外，为了更好的安全性，API调用应使用HTTPS/443端口。
- en: 'Assuming the Dockerfile has been placed in the current user home directory,
    we now need to create our Customer Management microservice/container from the
    Dockerfile:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 假设Dockerfile已放置在当前用户主目录中，我们现在需要从Dockerfile创建我们的客户管理微服务/容器：
- en: '[PRE18]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Docker will take a few minutes to finish creating the image. Once all the Dockerfile
    steps have been completed, you should see the following command as the last line
    of the `docker build` command’s output:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Docker将花费几分钟时间来完成镜像的创建。一旦所有Dockerfile步骤都已完成，你应该会在`docker build`命令输出的最后一行看到以下命令：
- en: '[PRE19]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This signals a successful completion. Now, we can use the `docker image ls`
    command to verify that the `abc_msa_customer_management` image has been created
    successfully.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这表示操作已成功完成。现在，我们可以使用`docker image ls`命令来验证`abc_msa_customer_management`镜像是否已成功创建。
- en: The last step is creating the container. Since the application will configure
    and update the MySQL database, we need to create a persistent container to retain
    all the changes.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是创建容器。由于应用程序将配置和更新MySQL数据库，我们需要创建一个持久容器以保留所有更改。
- en: 'Similar to what we explained earlier, we will use the `docker run` command
    to create the Customer Management container, as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前解释的类似，我们将使用`docker run`命令来创建客户管理容器，如下所示：
- en: '[PRE20]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `p` option is used to “publish” and map the ports that the container listens
    to with the ports the host machine listens to. So, the host machine will be listening
    to port `8003` for HTTP/8080 requests on the container.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`p`选项用于“发布”并将容器监听的端口与主机机器监听的端口进行映射。因此，主机机器将监听端口`8003`以处理容器的HTTP/8080请求。'
- en: We have chosen 8003 to standardize the way the host listens to the container’s
    API call requests.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择了8003来标准化主机监听容器API调用请求的方式。
- en: Remember that each container has a TCP stack that is different from the host’s
    TCP stack. So, the TCP HTTP/8080 port is only local within the container itself,
    but outside that particular container’s environment, that TCP HTTP/8080 port is
    different from the TCP HTTP/8080 port available on any other container or on the
    host machine itself.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，每个容器都有一个与主机TCP栈不同的TCP栈。因此，TCP HTTP/8080端口仅在容器内部是本地的，但在特定容器的环境之外，该TCP HTTP/8080端口与任何其他容器或主机机器上可用的TCP
    HTTP/8080端口不同。
- en: To access that port from outside the realm of the `customer_management` container,
    you need to map the `customer_management` container’s TCP HTTP/8080 port to a
    specific port on the host machine.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 要从`customer_management`容器外部访问该端口，您需要将`customer_management`容器的TCP HTTP/8080端口映射到主机机器上的一个特定端口。
- en: Since we need to map the local TCP HTTP/8080 port of each of the 12 containers
    we identified earlier, we decided to follow a specific pattern. Map the TCP/80nn
    port on the host machine to each local TCP HTTP/8080 of each container. Here,
    nn is the container’s number.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们需要将之前识别出的12个容器中的每个容器的本地TCP HTTP/8080端口进行映射，我们决定遵循一个特定的模式。将主机机器上的TCP/80nn端口映射到每个容器的本地TCP
    HTTP/8080端口。在这里，nn是容器的编号。
- en: '*Figure 9**.6* shows how some of the ABC-MSA container’s TCP HTTP/8080 ports
    are mapped on the host machine.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9**.6*展示了ABC-MSA容器的一些TCP HTTP/8080端口如何在主机机器上进行映射。'
- en: 'We don’t have to run all the containers on a single host. The system containers
    could be scattered across different hosts, depending on many factors, such as
    how critical the service/application running on the container is, how the system
    is designed, the desired overall redundancy, and so on:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不必在单个主机上运行所有容器。系统容器可以根据许多因素分散在不同的主机上，例如容器上运行的服务/应用程序的重要性、系统的设计、所需的总体冗余度等：
- en: '![ Figure 9.6: The container’s local port mappings to the host machine’s TCP
    stack](img/B18934_09_6.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.6：容器本地端口映射到主机机器的 TCP 栈](img/B18934_09_6.jpg)'
- en: 'Figure 9.6: The container’s local port mappings to the host machine’s TCP stack'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.6：容器本地端口映射到主机机器的 TCP 栈
- en: 'Now, verify that the container is running using the following command:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用以下命令验证容器是否正在运行：
- en: '[PRE21]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The following command will allow you to connect to the container’s `bash` shell
    using the root privilege (a user ID of `0`, as specified in the command):'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令将允许您使用 root 权限（命令中指定的用户 ID 为 `0`）连接到容器的 `bash` shell：
- en: '[PRE22]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: That’s all for the Customer Management microservice. In the same manner, we
    can create the rest of the ABC-MSA containers. We just need to make sure we use
    appropriate corresponding names for the other microservice’s containers and volumes
    and map to the right TCP/80nn port number on the host machine.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 对于客户管理微服务，这就是全部内容。以同样的方式，我们可以创建 ABC-MSA 的其余容器。我们只需确保为其他微服务的容器和卷使用适当的对应名称，并将它们映射到主机机器上的正确
    TCP/80nn 端口号。
- en: The frontend web dashboard interface
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 前端 Web 仪表板界面
- en: The dashboard is the main component of the **user interface** (**UI**) interaction
    and interacts with all services offered to the user. In our ABC-MSA example, we
    created a simple cart application where the user can place products in the cart
    and place an order.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 仪表板是用户界面（**UI**）交互的主要组件，并与提供给用户的所有服务进行交互。在我们的 ABC-MSA 示例中，我们创建了一个简单的购物车应用程序，用户可以在购物车中放置产品并下订单。
- en: The Dashboard container is built the same way the `customer_management` container
    is built, as shown in the previous section. The main difference between both is
    the additional web server that we will need to have on the Dashboard microservice,
    and the ports to be exposed on the container. The Dashboard’s Dockerfile should
    be changed accordingly.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 仪表板容器的构建方式与 `customer_management` 容器相同，如前节所示。两者之间的主要区别是我们需要在仪表板微服务上添加额外的 Web
    服务器，以及容器上需要暴露的端口。仪表板的 Dockerfile 应相应地进行更改。
- en: Like all the containers we are building, the container’s local TCP port that
    listens to API calls is TCP HTTP/8080, and the host-mapped TCP port in the `dashboard`
    container case should be TCP/8002.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们构建的所有容器一样，该容器的本地 TCP 端口用于监听 API 调用是 TCP HTTP/8080，而在 `dashboard` 容器的情况下，主机映射的
    TCP 端口应该是 TCP/8002。
- en: The Dashboard container will still need to listen to HTTP/80 for user web UI
    requests. Unless the host machine is running another application or web page on
    HTTP/80 port, we should be OK to use that port.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 仪表板容器仍然需要监听 HTTP/80 以处理用户 Web UI 请求。除非主机机器在 HTTP/80 端口上运行另一个应用程序或网页，否则我们应该可以使用该端口。
- en: 'Now, we need to map the HTTP/80 port on the host machine, as shown in the following
    `docker` `run` command:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要将主机机器上的 HTTP/80 端口映射，如下面的 `docker` `run` 命令所示：
- en: '[PRE23]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This command has an additional `p` option to map the HTTP/80 port on the container
    with the HTTP/80 port on the host machine. `abc_msa_dashboard` is the Dashboard
    microservice image.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令具有一个额外的 `p` 选项，用于将容器上的 HTTP/80 端口映射到主机机器上的 HTTP/80 端口。`abc_msa_dashboard`
    是仪表板微服务镜像。
- en: Managing your system’s containers
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理您的系统容器
- en: As you saw in the preceding examples, the `docker run` command can get lengthy
    and messy. **Docker Compose** helps us manage the deployment of containers. With
    Docker Compose, it is much easier to manage the deployment of the containers,
    change deployment parameters, include all system containers in a single YAML file,
    and specify the order of the containers’ deployment and dependencies.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在先前的示例中所见，`docker run` 命令可能会变得冗长且混乱。**Docker Compose** 帮助我们管理容器的部署。使用 Docker
    Compose，管理容器的部署、更改部署参数、将所有系统容器包含在一个 YAML 文件中，以及指定容器的部署顺序和依赖关系都变得容易得多。
- en: 'The following is a sample YAML file for initializing three of the ABC-MSA containers,
    as we did with the `docker run` commands earlier, but in a more organized and
    structured YAML way:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例 YAML 文件，用于初始化三个 ABC-MSA 容器，就像我们之前使用 `docker run` 命令所做的那样，但以更组织化和结构化的
    YAML 方式：
- en: '[PRE24]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The following command runs the Docker Compose `.``yaml` file:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令运行 Docker Compose `.yaml` 文件：
- en: '[PRE25]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `f` option is used to specify the YAML file’s name, and the `&` option is
    used to run the containers in the shell’s background.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`f` 选项用于指定 YAML 文件的名称，而 `&` 选项用于在 shell 的后台运行容器。'
- en: In this section, we showed you how to create some of the ABC-MSA images and
    containers. The ABC-MSA containers are now ready to communicate with each other
    either directly or, as we will show later in this book, through the API Gateway.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们向您展示了如何创建一些 ABC-MSA 图像和容器。ABC-MSA 容器现在可以直接相互通信，或者，正如我们将在本书后面展示的，通过 API
    网关进行通信。
- en: In the next section, we will learn how we can use the containers we created,
    how we can issue API calls to them, and what response we should expect.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何使用我们创建的容器，如何向它们发出 API 调用，以及我们应该期待什么响应。
- en: ABC-MSA microservice inter-communication
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ABC-MSA 微服务间通信
- en: In this section, we will learn how to expose APIs from containers and how containers
    communicate with API consumers.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何从容器中暴露 API 以及容器如何与 API 消费者进行通信。
- en: The microservice application code for each container is available in the ABC-MSA
    project on GitHub. We recommend that you download the code to your local test
    environment to be able to get some hands-on experience when following the steps
    we will cover in this section.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 每个容器的微服务应用程序代码都可在 GitHub 上的 ABC-MSA 项目中找到。我们建议您将代码下载到本地测试环境中，以便在遵循本节中将要介绍的步骤时获得一些实践经验。
- en: There are two main ways for containers to communicate with each other. One is
    by using the container’s name in a **Docker network**, and the other is by using
    the container’s IP and TCP port. The following are some of the details you need
    to know about to be able to configure your containers to communicate with each
    other.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 容器之间相互通信主要有两种方式。一种是通过在 **Docker 网络** 中使用容器的名称，另一种是通过使用容器的 IP 地址和 TCP 端口。以下是一些您需要了解的细节，以便能够配置您的容器以相互通信。
- en: The Docker network
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker 网络
- en: When we have containers running on the same host, containers can communicate
    with each other on the same host using only container names and without the need
    to specify the container’s IP address or listening port.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在同一主机上运行容器时，容器可以使用容器名称在同一主机上进行通信，而无需指定容器的 IP 地址或监听端口。
- en: The concept of using only container names is programmatically very useful, especially
    in cases where these IPs change dynamically. The names are usually deterministic,
    and by only specifying the Docker’s container name, you avoid having to apply
    different layers of system operations to first learn about the container’s TCP/IP
    details before starting to communicate with the target container.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 仅使用容器名称的概念在程序上非常有用，尤其是在这些 IP 地址动态变化的情况下。名称通常是确定的，并且仅通过指定 Docker 的容器名称，您就可以避免在开始与目标容器通信之前，必须应用不同层级的系统操作来了解容器的
    TCP/IP 详细信息。
- en: 'However, there are some prerequisites to enabling container communication through
    their names only:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，要仅通过名称启用容器通信，有一些先决条件：
- en: The containers communicating with each other will all need to be on the same
    host
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与其他容器进行通信的容器都需要在同一主机上。
- en: We will need to create a Docker network on the host
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要在主机上创建一个 Docker 网络。
- en: We will need to attach the containers to the created Docker network when running
    the container using the `docker run` command or by specifying the container’s
    instantiation details in the `docker-compose` YAML file
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用 `docker run` 命令运行容器或通过在 `docker-compose` YAML 文件中指定容器的实例化详细信息时，我们需要将容器附加到创建的
    Docker 网络上。
- en: 'The following command creates a Docker network on the host machine that can
    be used for our ABC-MSA system’s inter-microservice communication:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令在主机机器上创建一个 Docker 网络，可用于我们的 ABC-MSA 系统的微服务间通信：
- en: '[PRE26]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The following command lists the Docker networks configured on the host machine:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令列出了主机机器上配置的 Docker 网络：
- en: '[PRE27]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, attach the ABC-MSA containers to the `abc_msa_network` network by using
    the `--network` option in the `docker run` command, as shown in the following
    example:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用 `docker run` 命令中的 `--network` 选项将 ABC-MSA 容器附加到 `abc_msa_network` 网络，如下例所示：
- en: '[PRE28]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Using Docker networks is very useful in many cases. However, since we are designing
    our ABC-MSA system so that containers can run independently of their host location,
    we will be using the container’s IP/TCP communication.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，使用 Docker 网络非常有用。然而，由于我们正在设计 ABC-MSA 系统，使得容器可以独立于其主机位置运行，我们将使用容器的 IP/TCP
    通信。
- en: In the next section, we’ll explain how the ABC-MSA microservices communicate
    using TCP/IP and go over some examples of how to test the communication and data
    exchanges.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将解释 ABC-MSA 微服务如何使用 TCP/IP 进行通信，并介绍一些测试通信和数据交换的示例。
- en: TCP/IP communication between containers/microservices
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器/微服务之间的 TCP/IP 通信
- en: So far, we have installed Docker, built our Docker images and volumes, and started
    the containers of all our microservices. Now, it is time to understand how these
    containers interact with each other.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经安装了 Docker，构建了我们的 Docker 镜像和卷，并启动了所有微服务的容器。现在，是时候了解这些容器如何相互交互了。
- en: Upon running Docker on the container’s host, the host automatically creates
    a virtual IP network and assigns an IP address to each running Docker container
    on that host. That virtual IP network is only internal to the host running the
    containers and cannot be accessed from anywhere outside that host.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器的主机上运行 Docker 后，主机会自动创建一个虚拟 IP 网络并为该主机上运行的每个 Docker 容器分配一个 IP 地址。这个虚拟 IP
    网络仅限于运行容器的宿主机内部，并且无法从宿主机外部访问。
- en: The container’s host carries at least two IPs. There’s one inside IP that’s
    internal to the Docker network and that can only be recognized inside that Docker
    network. Then, there’s an outside IP, which is usually assigned by the **Dynamic
    Host Configuration Protocol** (**DHCP**) server in the organization’s network.
    The outside IP is necessary for the container’s host to communicate with the outside
    world.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 容器的主机至少携带两个 IP 地址。有一个内部 IP 地址是 Docker 网络内部的，并且只能在 Docker 网络内部识别。然后，还有一个外部 IP
    地址，通常由组织网络中的 **动态主机配置协议**（**DHCP**）服务器分配。外部 IP 地址对于容器主机与外部世界的通信是必要的。
- en: The internal Docker network of the container’s host is not visible to any other
    host in the network. Therefore, for an outside host to communicate with a specific
    container in the container’s host machine, it will need to use the outside IP
    of the container’s host machine.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 容器主机的内部 Docker 网络对网络中的任何其他主机都是不可见的。因此，对于外部主机要与容器主机的特定容器通信，它需要使用容器主机的外部 IP 地址。
- en: Among a lot of other information, to get the assigned IP address, as well as
    the inside and outside listening ports of a specific container in your system,
    use the `docker inspect` command, followed by the container’s name.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在众多其他信息中，要获取分配的 IP 地址，以及系统中特定容器的内部和外部监听端口，请使用 `docker inspect` 命令，后跟容器的名称。
- en: 'Our demo setup is shown in the following diagram:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下图展示了我们的演示设置：
- en: '![ Figure 9.7: ABC-MSA container communication](img/B18934_09_7.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.7：ABC-MSA 容器通信](img/B18934_09_7.jpg)'
- en: 'Figure 9.7: ABC-MSA container communication'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.7：ABC-MSA 容器通信
- en: As you can see, the host machine’s inside IP address is 172.17.0.100, and the
    outside IP address is 192.168.1.100\. The container’s host is listening to the
    container’s mapped ports (`8001` to `8012`), as explained earlier.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，主机机的内部 IP 地址是 172.17.0.100，外部 IP 地址是 192.168.1.100。容器的主机正在监听容器映射的端口（`8001`
    到 `8012`），如前所述。
- en: If other hosts in the network want to send API calls to one of the ABC-MSA containers,
    that outside host will need to send the request to the outside IP address of the
    container’s host, 192.168.1.100, using the mapped port of the container it wants
    to communicate with.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 如果网络中的其他主机想要向 ABC-MSA 容器之一发送 API 调用，那么外部主机需要将请求发送到容器主机的外部 IP 地址，即 192.168.1.100，使用它想要通信的容器的映射端口。
- en: 'To elaborate further, the preceding diagram and the following example show
    an outside host testing the API response of the Product Management container:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步说明，前面的图和下面的示例展示了外部主机测试产品管理容器 API 响应的情况：
- en: '[PRE29]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'ABC-MSA API calls return a JSON variable for easier data handling. One of the
    APIs we built for ABC-MSA microservices is `service_info`. An example of an API
    call for `service_info` is as follows:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: ABC-MSA API 调用返回一个 JSON 变量，以便更容易地处理数据。我们为 ABC-MSA 微服务构建的一个 API 是 `service_info`。`service_info`
    API 调用的一个示例如下：
- en: '[PRE30]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If you are communicating internally from within the Docker network (172.17.0.0),
    you can communicate directly with the container’s IP and listening ports. Performing
    the same `curl` test on the Product Management container from the API Gateway
    shell would look like this:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是在Docker网络（172.17.0.0）内部进行内部通信，你可以直接与容器的IP和监听端口进行通信。从API网关shell对产品管理容器执行相同的`curl`测试将看起来像这样：
- en: '[PRE31]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Knowing how to pass API requests and handle the API response is key to developing
    your MSA system. Please refer to our ABC-MSA code in this book’s GitHub repository
    for examples of how the API calls are issued and handled across the entire system.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 了解如何发送API请求和处理API响应对于开发你的MSA系统至关重要。请参考本书GitHub仓库中的ABC-MSA代码，以了解API调用在整个系统中是如何发出和处理的示例。
- en: Summary
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered the concept of containers, what they are, and how
    they are different from VMs. Then, we worked with Docker as one of the most popular
    container platforms available today. We showed you how to install Docker and create
    Dockerfiles, Docker images, Docker volumes, and Docker containers.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了容器这一概念，它们是什么，以及它们与虚拟机有何不同。然后，我们使用Docker作为目前最受欢迎的容器平台之一进行了操作。我们向您展示了如何安装Docker和创建Dockerfile、Docker镜像、Docker卷和Docker容器。
- en: Then, we applied all these concepts by building some of the ABC-MSA microservices
    with hands-on examples. We built the containers and showed how microservices communicate
    with each other.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过构建一些ABC-MSA微服务并使用实际示例应用了所有这些概念。我们构建了容器，并展示了微服务之间是如何相互通信的。
- en: In the next chapter, we will focus on building an AI microservice in the MSA
    system. We will discuss some of the most important AI/ML/DL algorithms that should
    be considered and implemented in an MSA system, and how these algorithms help
    with a system’s overall stability, performance, and supportability.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将专注于在MSA系统中构建AI微服务。我们将讨论一些在MSA系统中应考虑和实施的最重要的人工智能/机器学习/深度学习算法，以及这些算法如何帮助系统的整体稳定性、性能和支持性。
