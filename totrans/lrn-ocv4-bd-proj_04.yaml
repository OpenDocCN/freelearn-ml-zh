- en: Delving into Histogram and Filters
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入直方图和滤波器
- en: 'In the last chapter, we learned the basics of user interfaces in OpenCV, using
    Qt libraries or native ones; we also learned how to use advanced OpenGL user interfaces.
    We learned about basic color conversions, and filters that allow us to create
    our first application. This chapter will introduce you to the following concepts:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了使用Qt库或本地库在OpenCV中实现用户界面的基础知识；我们还学习了如何使用高级OpenGL用户界面。我们学习了基本的颜色转换和允许我们创建第一个应用程序的过滤器。本章将介绍以下概念：
- en: Histogram and histogram equalization
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直方图和直方图均衡
- en: Look-up tables
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找表
- en: Blur and median blur
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模糊和中值模糊
- en: Canny filter
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Canny滤波器
- en: Image-color equalization
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像颜色均衡
- en: Understanding the conversion between image types
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解图像类型之间的转换
- en: 'After we learn the basics of OpenCV and user interfaces, we are going to create
    our first complete application in this chapter, a basic photo tool, and cover
    the following topics:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们学习OpenCV和用户界面的基础知识之后，我们将在本章中创建我们的第一个完整应用程序，一个基本的照片工具，并涵盖以下主题：
- en: Generating a CMake script file
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成CMake脚本文件
- en: Creating the graphical user interface
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建图形用户界面
- en: Calculating and drawing a histogram
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算和绘制直方图
- en: Histogram equalization
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直方图均衡
- en: The lomography camera effect
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 洛马格诺伊相机效果
- en: The cartoonize effect
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 卡通化效果
- en: This application will help us to understand how to create an entire project
    from scratch and understand the histogram concept. We will see how to equalize
    the histogram of the color image and create two effects, using a combination of
    filters and the use of look-up tables.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 此应用程序将帮助我们了解如何从头开始创建整个项目，并理解直方图的概念。我们将看到如何均衡彩色图像的直方图，并创建两种效果，使用滤波器的组合和使用查找表。
- en: Technical requirements
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'This chapter requires familiarity with the basics of the C++ programming language.
    All the code used in this chapter can be downloaded from the following GitHub
    link: [https://github.com/PacktPublishing/Learn-OpenCV-4-By-Building-Projects-Second-Edition/tree/master/Chapter_04](https://github.com/PacktPublishing/Learn-OpenCV-4-By-Building-Projects-Second-Edition/tree/master/Chapter_04).
    The code can be executed on any operating system, though it is only tested on
    Ubuntu.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章要求熟悉C++编程语言的基础知识。本章中使用的所有代码都可以从以下GitHub链接下载：[https://github.com/PacktPublishing/Learn-OpenCV-4-By-Building-Projects-Second-Edition/tree/master/Chapter_04](https://github.com/PacktPublishing/Learn-OpenCV-4-By-Building-Projects-Second-Edition/tree/master/Chapter_04)。代码可以在任何操作系统上执行，尽管它仅在Ubuntu上进行了测试。
- en: 'Check out the following video to see the Code in Action:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的实际应用：
- en: '[http://bit.ly/2Sid17y](http://bit.ly/2Sid17y)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://bit.ly/2Sid17y](http://bit.ly/2Sid17y)'
- en: Generating a CMake script file
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成CMake脚本文件
- en: 'Before we start creating our source file, we are going to generate the `CMakeLists.txt`
    file to allow us to compile our project, structure it, and execute it. The following
    CMake script is simple and basic but enough to compile and generate the executable:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始创建源文件之前，我们将生成`CMakeLists.txt`文件，以便我们可以编译我们的项目，对其进行结构化，并执行它。以下CMake脚本简单且基本，但足以编译和生成可执行文件：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The first line indicates the minimum CMake version required to generate our
    project, the second one sets the project name that we can use as the `${PROJECT_NAME}`
    variable, and the third one sets the required C++ version; in our case, we require
    the **C++11** version, as we can see in the next snippet:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行指示生成我们的项目所需的最低CMake版本，第二行设置的项目名称可以用作`${PROJECT_NAME}`变量，第三行设置所需的C++版本；在我们的案例中，我们需要**C++11**版本，正如我们可以在下一个片段中看到：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Moreover, we require the OpenCV library. First, we need to find the library,
    and then we''ll show a message on the OpenCV library version found with the `MESSAGE`
    function:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还需要OpenCV库。首先，我们需要找到库，然后我们将使用`MESSAGE`函数显示找到的OpenCV库版本信息：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If the library, with a minimum version of 4.0, is found, then we include the
    headers and library files in our project:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找到的库版本至少为4.0，则将头文件和库文件包含到我们的项目中：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, we only need to add the source files to compile and link with the OpenCV
    library. The project name variable is used as the executable name, and we use
    only a single source file, called `main.cpp`:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要将源文件添加到编译中，并与OpenCV库链接。项目名称变量用作可执行文件名称，我们只使用一个名为`main.cpp`的单个源文件：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Creating the graphical user interface
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建图形用户界面
- en: 'Before we start with the image processing algorithms, we create the main user
    interface for our application. We are going to use the Qt-based user interface
    to allow us to create single buttons. The application receives one input parameter
    to load the image to process, and we are going to create four buttons, as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始图像处理算法之前，我们为我们的应用程序创建主用户界面。我们将使用基于Qt的用户界面来允许我们创建单个按钮。应用程序接收一个输入参数来加载要处理的图像，我们将创建四个按钮，如下所示：
- en: Show histogram
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示直方图
- en: Equalize histogram
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直方图均衡化
- en: Lomography effect
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 洛马格诺效应
- en: Cartoonize effect
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 卡通化效果
- en: 'We can see the four results in the following screenshot:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在以下屏幕截图中看到四个结果：
- en: '![](img/a38b1318-6814-42a2-9531-c45262b6fedd.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a38b1318-6814-42a2-9531-c45262b6fedd.png)'
- en: 'Let''s begin developing our project. First of all, we are going to include
    the OpenCV – required headers, define an image matrix to store the input image,
    and create a constant string to use the new command-line parser already available
    from OpenCV 3.0; in this constant, we allow only two input parameters, `help`
    and the required image input:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始开发我们的项目。首先，我们将包含OpenCV – 必需的头文件，定义一个图像矩阵来存储输入图像，并创建一个常量字符串来使用OpenCV 3.0已提供的新的命令行解析器；在这个常量中，我们只允许两个输入参数，`help`和必需的图像输入：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The main function starts with the command-line parser variable; next, we set
    the about instruction and print the help message. This line sets up the help instructions
    of our final executable:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 主函数从命令行解析变量开始；接下来，我们设置关于说明并打印帮助信息。这一行设置了我们的最终可执行文件的帮助说明：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If the user doesn''t require help, then we have to get the file path image
    in the `imgFile` variable string and check that all required parameters are added
    with the `parser.check()` function:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户不需要帮助，那么我们必须在`imgFile`变量字符串中获取文件路径图像，并使用`parser.check()`函数检查是否添加了所有必需的参数：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, we can read the image file with the `imread` function, and then create
    the window in which the input image will be shown later with the `namedWindow`
    function:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用`imread`函数读取图像文件，然后使用`namedWindow`函数创建一个窗口，稍后将在其中显示输入图像：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'With the image loaded and the window created, we only need to create the buttons
    for our interface and link them with the callback functions; each callback function
    is defined in the source code and we are going to explain these functions later
    in this chapter. We are going to create the buttons with the `createButton` function
    with the `QT_PUSH_BUTTON` constant to button style:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在图像加载和窗口创建后，我们只需要创建我们的界面按钮并将它们与回调函数链接；每个回调函数都在源代码中定义，我们将在本章后面解释这些函数。我们将使用`createButton`函数和`QT_PUSH_BUTTON`常量来创建按钮，以按钮样式：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To finish our main function, we show the input image and wait for a key press
    to finish our application:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成我们的主函数，我们显示输入图像并等待按键以结束我们的应用程序：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now, we only have to define each callback function, and in the next sections,
    we are going to do just that.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要定义每个回调函数，在接下来的章节中，我们将这样做。
- en: Drawing a histogram
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制直方图
- en: A histogram is a statistical graphic representation of variable distribution
    that allows us to understand the density estimation and probability distribution
    of data. A histogram is created by dividing the entire range of variable values
    into a small range of values, and then counting how many values fall into each
    interval.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 直方图是变量分布的统计图形表示，它允许我们理解数据的密度估计和概率分布。直方图是通过将变量值的整个范围划分为一个小范围值，然后计算落入每个区间的值数量来创建的。
- en: If we apply this histogram concept to an image, it seems to be difficult to
    understand but, in fact, it is very simple. In a gray image, our variable values'
    ranges are each possible gray value (from `0` to `255`), and the density is the
    number of pixels of the image that have this value. This means that we have to
    count the number of pixels of the image that have a value of `0`, the number of
    pixels with a value of `1`, and so on.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将这个直方图概念应用到图像上，看起来很难理解，但实际上它非常简单。在灰度图像中，我们的变量值范围是每个可能的灰度值（从`0`到`255`），密度是具有此值的图像像素数。这意味着我们必须计算具有值为`0`的图像像素数，具有值为`1`的像素数，依此类推。
- en: The callback function that shows the histogram of the input image is `showHistoCallback`
    ; this function calculates the histogram of each channel image and shows the result
    of each histogram channel in a new image.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 显示输入图像直方图的回调函数是`showHistoCallback`；这个函数计算每个通道图像的直方图，并在新图像中显示每个直方图通道的结果。
- en: 'Now, check the following code:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，检查以下代码：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let''s understand how to extract each channel histogram and how to draw it.
    First, we need to create three matrices to process each input image channel. We
    use a vector-type variable to store each one and use the `split` OpenCV function
    to divide the input image among these three channels:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解如何提取每个通道的直方图以及如何绘制它。首先，我们需要创建三个矩阵来处理每个输入图像通道。我们使用一个向量类型的变量来存储每个矩阵，并使用`split`
    OpenCV函数将这些通道分配给这三个通道：
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, we are going to define the number of bins of our histogram, in our case,
    one per possible pixel value:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将定义直方图的分箱数量，在我们的例子中，每个可能的像素值对应一个分箱：
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s define our range of variables and create three matrices to store each
    histogram:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义变量的范围并创建三个矩阵来存储每个直方图：
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can calculate the histograms using the `calcHist` OpenCV function. This
    function has several parameters with this order:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`calcHist` OpenCV函数来计算直方图。此函数有多个参数，顺序如下：
- en: '**The input image**: In our case, we use one image channel stored in the `bgr`
    vector'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输入图像**：在我们的例子中，我们使用存储在`bgr`向量中的一个图像通道'
- en: '**The number of images in the input to calculate the histogram**: In our case,
    we only use `1` image'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**计算直方图所需的输入图像数量**：在我们的例子中，我们只使用`1`个图像'
- en: '**The number channel dimensions used to compute the histogram**: We use `0`
    in our case'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用于计算直方图的通道维度**：在我们的例子中，我们使用`0`'
- en: The optional mask matrix.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选的掩码矩阵。
- en: The variable to store the calculated histogram.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于存储计算出的直方图的变量。
- en: '**Histogram dimensionality**: This is the dimension of the space where the
    image (here, a gray plane) is taking its values, in our case `1`'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**直方图维度**：这是图像（在这里，是一个灰度平面）取值的空间维度，在我们的例子中是`1`'
- en: '**Number of bins to calculate**: In our case `256` bins, one per pixel value'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**计算分箱的数量**：在我们的例子中是`256`个分箱，每个分箱对应一个像素值'
- en: '**Range of input variables**: In our case, from `0` to `255` possible pixels
    values'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输入变量的范围**：在我们的例子中，从`0`到`255`可能的像素值'
- en: 'Our `calcHist` function for each channel looks as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为每个通道的`calcHist`函数看起来如下：
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now that we have calculated each channel histogram, we have to draw each one
    and show it to the user. To do this, we are going to create a color image that
    is `512` by `300` pixels in size:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经计算了每个通道的直方图，我们必须绘制每个直方图并向用户显示。为此，我们将创建一个大小为`512` x `300`像素的颜色图像：
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Before we draw the histogram values into our image, we are going to normalize
    the histogram matrices between the minimum value, `0`, and a maximum value; the
    maximum value is the same as the height of our output histogram image:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将直方图值绘制到我们的图像之前，我们将直方图矩阵在最小值`0`和最大值之间进行归一化；最大值与我们的输出直方图图像的高度相同：
- en: '[PRE17]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now we have to draw a line from bin `0` to bin `1`, and so on. Between each
    bin, we have to calculate how many pixels there are; then, a `binStep` variable
    is calculated by dividing the width by the number of bins. Each small line is
    drawn from horizontal position `i-1` to `i`; the vertical position is the histogram
    value in the corresponding `i`, and it is drawn with the color channel representation:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须从分箱`0`到分箱`1`画一条线，依此类推。在每个分箱之间，我们必须计算有多少像素；然后，通过除以分箱的数量来计算`binStep`变量。每条小线是从水平位置`i-1`到`i`绘制的；垂直位置是相应`i`的直方图值，并且使用颜色通道表示来绘制：
- en: '[PRE18]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Finally, we show the histogram image with the `imshow` function:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用`imshow`函数显示直方图图像：
- en: '[PRE19]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This is the result for the `lena.png` image:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`lena.png`图像的结果：
- en: '![](img/7cc7556f-246c-4765-b1d1-55c62e9a1869.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7cc7556f-246c-4765-b1d1-55c62e9a1869.png)'
- en: Image color equalization
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图像色彩均衡
- en: In this section, we are going to learn how to equalize a color image. Image
    equalization, or histogram equalization, tries to obtain a histogram with a uniform
    distribution of values. The result of equalization is an increase in the contrast
    of an image. Equalization allows lower local contrast areas to gain high contrast,
    spreading out the most frequent intensities. This method is very useful when the
    image is extremely dark or bright and there is a very small difference between
    the background and foreground. Using histogram equalization, we increase the contrast
    and the details that are over- or under-exposed. This technique is very useful
    in medical images, such as X-rays.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there are two main disadvantages to this method: the increase in background
    noise and a consequent decrease in useful signals. We can see the effect of equalization
    in the following photograph, and the histogram changes and spreads when increasing
    the image contrast:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/56a126f0-b50e-4488-a28d-eb54b5eccd50.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
- en: 'Let''s implement our equalization histogram; we are going to implement it in
    the `Callback` function defined in the user interface''s code:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To equalize a color image, we only have to equalize the luminance channel.
    We can do this with each color channel but the result is not usable. Alternatively,
    we can use any other color image format, such as **HSV** or **YCrCb**, that separates
    the luminance component in an individual channel. Thus, we choose **YCrCb** and
    use the Y channel (luminance) to equalize. Then, we follow these steps:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Convert or input the **BGR** image into **YCrCb** using the `cvtColor`
    function:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '2\. Split the **YCrCb** image into different channels matrix:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '3\. Equalize the histogram only in the Y channel, using the `equalizeHist`
    function which has only two parameters, the input and output matrices:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '4\. Merge the resulting channels and convert them into the **BGR** format to
    show the user the result:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The process applied to a low-contrast `Lena` image will have the following
    result:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fa858d66-53c0-40ab-bdf2-f97db2cdb0ca.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
- en: Lomography effect
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we are going to create another image effect, which is a photograph
    effect that is very common in different mobile applications, such as Google Camera
    or Instagram. We are going to discover how to use a **look-up table** (**LUT**).
    We will go through LUTs later in this same section. We are going to learn how
    to add an over image, in this case a dark halo, to create our desired effect.
    The function that implements this effect is the `lomoCallback` callback and it
    has the following code:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Let''s look at how the lomography effect works and how to implement it. The
    lomography effect is divided into different steps, but in our example, we did
    a very simple lomography effect with two steps:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: A color manipulation effect by using a look-up table to apply a curve to the
    red channel
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A vintage effect by applying a dark halo to the image
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The first step was to manipulate the red color with a curve transform by applying
    the following function:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e428a8cc-1511-412e-84cd-640a09c5df72.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
- en: 'This formula generates a curve that makes the dark values darker and the light
    values lighter, where **x** is the possible pixels value (`0` to `255`) and **s**
    is a constant that we set to `0.1` in our example. A lower constant value that
    generates pixels with values lower than `128` is very dark, and over `128` is
    very bright. Values near to `1` convert the curve into a line and do not generate
    our desired effect:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/70093da0-1f3c-4924-b4f7-aba9a99af497.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
- en: This function is very easy to implement by applying an LUT. An LUT is a vector
    or table that returns a preprocessed value for a given value to perform computation
    in the memory. An LUT is a common technique used to spare CPU cycles by avoiding
    performing costly computations repeatedly. Instead of calling the `exponential`/`divide`
    function for each pixel, we perform it only once for each possible pixel value
    ( `256` times) and store the result in a table. Thus, we have saved CPU time at
    the cost of a bit of memory. While this may not make a great difference on a standard
    PC with small image sizes, this makes a huge one for CPU-limited hardware, such
    as Raspberry Pi.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in our case, if we want to apply a function for every pixel in
    our image, then we have to make *width* x *height* operations; for example, in
    100 x 100 pixels, there will be 10,000 calculations. If we can pre-calculate all
    possible results for all possible inputs, we can create the LUT table. In an image,
    there are only **256** possible values as a pixel value. If we want to change
    the color by applying a function, we can pre-calculate the 256 values and save
    them in an LUT vector. In our sample code, we define the `E` variable and create
    an `lut` matrix of `1` row and `256` columns. Then, we do a loop over all possible
    pixel values by applying our formula and saving it into an `lut` variable:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'As we mentioned earlier in this section, we don''t apply the function to all
    channels; thus, we need to split our input image by channels using the `split`
    function:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We then apply our `lut` table variable to the red channel. OpenCV gives us
    the `LUT` function, which has three parameters:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Input image
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Matrix of look-up table
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Output image
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then, our call to the `LUT` function and red channel looks like this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, we only have to merge our computed channels:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The first step is done and we only have to create the dark halo to finish our
    effect. Then, we create a gray image with a white circle inside, with the same
    input image size:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Check out the following screenshot:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/51793ccb-0ca9-4d51-a930-17105ecdad99.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
- en: 'If we apply this image to our input image, we will get a strong change from
    dark to white; thus, we can apply a big blur using the `blur` filter function
    to our circle halo image to get a smooth effect:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The image will be altered to give us the following result:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/db62a585-6b82-4227-86b3-1aa64980bd09.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/db62a585-6b82-4227-86b3-1aa64980bd09.png)'
- en: 'Now, if we have to apply this halo to our image from step 1, an easy way to
    do this is to multiply both images. However, we will have to convert our input
    image from an 8-bit image to a 32-bit float, because we need to multiply our blurred
    image, which has values in the `0` to `1` range, with our input image, which has
    integer values. The following code will do it for us:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们必须将这个光环应用到步骤1中的图像上，一个简单的方法是将两个图像相乘。然而，我们必须将我们的输入图像从8位图像转换为32位浮点数，因为我们需要将我们的模糊图像（其值在`0`到`1`范围内）与我们的输入图像相乘，而输入图像具有整数值。以下代码将为我们完成这项工作：
- en: '[PRE32]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'After converting our image, we only need to multiply each matrix per element:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在转换我们的图像后，我们只需要逐元素相乘每个矩阵：
- en: '[PRE33]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Finally, we will convert the float image matrix result to an 8-bit image matrix:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将浮点图像矩阵结果转换为8位图像矩阵：
- en: '[PRE34]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This will be the result:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是结果：
- en: '![](img/b5c3ab57-53cc-46d2-8a7f-98fd05d371b4.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b5c3ab57-53cc-46d2-8a7f-98fd05d371b4.png)'
- en: Cartoonize effect
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 卡通化效果
- en: 'The last section of this chapter is dedicated to creating another effect, called
    **cartoonize**; the purpose of this effect is to create an image that looks like
    a cartoon. To do this, we divide the algorithm into two steps: **edge detection**
    and **color filtering**.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的最后部分致力于创建另一种效果，称为**卡通化**；这种效果的目的就是创建一个看起来像卡通的图像。为了做到这一点，我们将算法分为两个步骤：**边缘检测**和**颜色过滤**。
- en: 'The `cartoonCallback` function defines this effect, which has the following
    code:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`cartoonCallback`函数定义了这个效果，其代码如下：'
- en: '[PRE35]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The first step is to detect the most important *edges* of the image. We need
    to remove noise from the input image before detecting the edges. There are several
    ways to do it. We are going to use a median filter to remove all possible small
    noise, but we can use other methods, such as Gaussian blur. The OpenCV function
    is `medianBlur`, which accepts three parameters: input image, output image, and
    the kernel size (a kernel is a small matrix used to apply some mathematical operation,
    such as convolutional means, to an image):'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是检测图像最重要的**边缘**。在检测边缘之前，我们需要从输入图像中去除噪声。有几种方法可以做到这一点。我们将使用中值滤波器去除所有可能的小噪声，但我们可以使用其他方法，例如高斯模糊。OpenCV函数`medianBlur`接受三个参数：输入图像、输出图像和核大小（核是一个用于对图像应用某些数学运算的小矩阵，例如卷积运算）：
- en: '[PRE36]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'After removing any possible noise, we detect the strong edges with the `Canny`
    filter:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在去除任何可能的噪声后，我们使用`Canny`滤波器检测强边缘：
- en: '[PRE37]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `Canny` filter accepts the following parameters:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`Canny`滤波器接受以下参数：'
- en: Input image
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入图像
- en: Output image
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出图像
- en: First threshold
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个阈值
- en: Second threshold
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个阈值
- en: Sobel size aperture
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sobel大小孔径
- en: Boolean value to indicate whether we need to use a more accurate image gradient
    magnitude
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔值，表示是否需要使用更精确的图像梯度幅度
- en: 'The smallest value between the first threshold and the second threshold is
    used for edge linking. The largest value is used to find initial segments of strong
    edges. The sobel size aperture is the kernel size for the sobel filter that will
    be used in the algorithm. After detecting edges, we are going to apply a small
    dilation to join broken edges:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个阈值和第二个阈值之间最小的值用于边缘链接。最大的值用于找到强边缘的初始段。Sobel大小孔径是算法中将使用的Sobel滤波器的核大小。在检测到边缘后，我们将应用一个小膨胀来连接断裂的边缘：
- en: '[PRE38]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Similar to what we did in the lomography effect, if we need to multiply our
    edges'' result image with the color image, then we require the pixel values to
    be in the `0` and `1` range. For this, we will divide the canny result by `256`
    and invert the edges to black:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们在lomography效果中所做的一样，如果我们需要将我们的边缘结果图像与颜色图像相乘，那么我们需要像素值在`0`和`1`范围内。为此，我们将Canny结果除以`256`并反转边缘为黑色：
- en: '[PRE39]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We will also transform the canny 8 unsigned bit pixel format to a float matrix:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将Canny 8位无符号像素格式转换为浮点矩阵：
- en: '[PRE40]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'To give a cool result, we can blur the edges, and to give smooth result lines,
    we can apply a `blur` filter:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 为了得到一个酷炫的结果，我们可以模糊边缘，为了得到平滑的结果线条，我们可以应用一个`blur`滤镜：
- en: '[PRE41]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The first step of the algorithm is finished, and now we are going to work with
    the color. To get a cartoon look, we are going to use the `bilateral` filter:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 算法的第一步已经完成，现在我们将处理颜色。为了得到卡通效果，我们将使用`bilateral`滤波器：
- en: '[PRE42]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `bilateral` filter is a filter that reduces the noise of an image while
    keeping the edges. With appropriate parameters, which we will explore later, we
    can get a cartoonish effect.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`双边`滤波器是一种在保持边缘的同时减少图像噪声的滤波器。通过适当的参数，我们将在后面探讨，我们可以得到卡通效果。'
- en: 'The `bilateral` filter''s parameters are as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`双边`滤波器的参数如下：'
- en: Input image
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入图像
- en: Output image
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出图像
- en: Diameter of pixel neighborhood; if it's set to negative, it is computed from
    a sigma space value
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 像素邻域直径；如果设置为负值，则从sigma空间值计算得出
- en: Sigma color value
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sigma颜色值
- en: Sigma coordinate space
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sigma坐标空间
- en: With a diameter greater than five, the `bilateral` filter starts to become slow.
    With sigma values greater than 150, a cartoonish effect appears.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当直径大于五时，`双边`滤波器开始变得缓慢。当sigma值大于150时，会出现卡通效果。
- en: 'To create a stronger cartoonish effect, we truncate the possible color values
    to 10 by multiplying and dividing the pixels values:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建更强的卡通效果，我们可以通过乘以和除以像素值来截断可能的颜色值到10：
- en: '[PRE43]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Finally, we have to merge the color and edges results. Then, we have to create
    a three-channel image as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须合并颜色和边缘的结果。然后，我们必须创建一个如下所示的三通道图像：
- en: '[PRE44]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We can convert our color result image to a 32-bit float image and then multiply
    both images per element:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将我们的颜色结果图像转换为32位浮点图像，然后逐元素乘以两个图像：
- en: '[PRE45]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Finally, we only need to convert our image to 8 bits and then show the resulting
    image to the user:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们只需将我们的图像转换为8位，然后向用户展示结果图像：
- en: '[PRE46]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In the next screenshot, we can see the input image (left image) and the result
    of applying the cartoonize effect (right image):'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一张截图，我们可以看到输入图像（左侧图像）和应用卡通化效果的结果（右侧图像）：
- en: '![](img/b6a8c27a-6435-4b18-abc8-dad291b07de3.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b6a8c27a-6435-4b18-abc8-dad291b07de3.png)'
- en: Summary
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we saw how to create a complete project that manipulates images
    by applying different effects. We also split a color image into multiple matrices
    to apply effects to only one channel. We saw how to create look-up tables, merge
    multiple matrices into one, use the `Canny` and `bilateral` filters, draw circles,
    and multiply images to get halo effects.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了如何通过应用不同的效果来创建一个完整的处理图像的项目。我们还把彩色图像分割成多个矩阵，以便只对一个通道应用效果。我们看到了如何创建查找表，将多个矩阵合并成一个，使用`Canny`和`双边`滤波器，绘制圆形，以及通过乘法图像来获得光环效果。
- en: In the next chapter, we will learn how to do object inspection, and how to segment
    an image into different parts and detect those parts.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何进行对象检查，以及如何将图像分割成不同的部分并检测这些部分。
