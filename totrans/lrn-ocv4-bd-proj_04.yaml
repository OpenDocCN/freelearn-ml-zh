- en: Delving into Histogram and Filters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the last chapter, we learned the basics of user interfaces in OpenCV, using
    Qt libraries or native ones; we also learned how to use advanced OpenGL user interfaces.
    We learned about basic color conversions, and filters that allow us to create
    our first application. This chapter will introduce you to the following concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: Histogram and histogram equalization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Look-up tables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blur and median blur
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Canny filter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Image-color equalization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the conversion between image types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After we learn the basics of OpenCV and user interfaces, we are going to create
    our first complete application in this chapter, a basic photo tool, and cover
    the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Generating a CMake script file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the graphical user interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculating and drawing a histogram
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Histogram equalization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The lomography camera effect
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The cartoonize effect
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This application will help us to understand how to create an entire project
    from scratch and understand the histogram concept. We will see how to equalize
    the histogram of the color image and create two effects, using a combination of
    filters and the use of look-up tables.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter requires familiarity with the basics of the C++ programming language.
    All the code used in this chapter can be downloaded from the following GitHub
    link: [https://github.com/PacktPublishing/Learn-OpenCV-4-By-Building-Projects-Second-Edition/tree/master/Chapter_04](https://github.com/PacktPublishing/Learn-OpenCV-4-By-Building-Projects-Second-Edition/tree/master/Chapter_04).
    The code can be executed on any operating system, though it is only tested on
    Ubuntu.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the Code in Action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://bit.ly/2Sid17y](http://bit.ly/2Sid17y)'
  prefs: []
  type: TYPE_NORMAL
- en: Generating a CMake script file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we start creating our source file, we are going to generate the `CMakeLists.txt`
    file to allow us to compile our project, structure it, and execute it. The following
    CMake script is simple and basic but enough to compile and generate the executable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The first line indicates the minimum CMake version required to generate our
    project, the second one sets the project name that we can use as the `${PROJECT_NAME}`
    variable, and the third one sets the required C++ version; in our case, we require
    the **C++11** version, as we can see in the next snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Moreover, we require the OpenCV library. First, we need to find the library,
    and then we''ll show a message on the OpenCV library version found with the `MESSAGE`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If the library, with a minimum version of 4.0, is found, then we include the
    headers and library files in our project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we only need to add the source files to compile and link with the OpenCV
    library. The project name variable is used as the executable name, and we use
    only a single source file, called `main.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Creating the graphical user interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we start with the image processing algorithms, we create the main user
    interface for our application. We are going to use the Qt-based user interface
    to allow us to create single buttons. The application receives one input parameter
    to load the image to process, and we are going to create four buttons, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Show histogram
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Equalize histogram
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lomography effect
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cartoonize effect
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can see the four results in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a38b1318-6814-42a2-9531-c45262b6fedd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s begin developing our project. First of all, we are going to include
    the OpenCV – required headers, define an image matrix to store the input image,
    and create a constant string to use the new command-line parser already available
    from OpenCV 3.0; in this constant, we allow only two input parameters, `help`
    and the required image input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The main function starts with the command-line parser variable; next, we set
    the about instruction and print the help message. This line sets up the help instructions
    of our final executable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If the user doesn''t require help, then we have to get the file path image
    in the `imgFile` variable string and check that all required parameters are added
    with the `parser.check()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can read the image file with the `imread` function, and then create
    the window in which the input image will be shown later with the `namedWindow`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'With the image loaded and the window created, we only need to create the buttons
    for our interface and link them with the callback functions; each callback function
    is defined in the source code and we are going to explain these functions later
    in this chapter. We are going to create the buttons with the `createButton` function
    with the `QT_PUSH_BUTTON` constant to button style:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'To finish our main function, we show the input image and wait for a key press
    to finish our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now, we only have to define each callback function, and in the next sections,
    we are going to do just that.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing a histogram
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A histogram is a statistical graphic representation of variable distribution
    that allows us to understand the density estimation and probability distribution
    of data. A histogram is created by dividing the entire range of variable values
    into a small range of values, and then counting how many values fall into each
    interval.
  prefs: []
  type: TYPE_NORMAL
- en: If we apply this histogram concept to an image, it seems to be difficult to
    understand but, in fact, it is very simple. In a gray image, our variable values'
    ranges are each possible gray value (from `0` to `255`), and the density is the
    number of pixels of the image that have this value. This means that we have to
    count the number of pixels of the image that have a value of `0`, the number of
    pixels with a value of `1`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The callback function that shows the histogram of the input image is `showHistoCallback`
    ; this function calculates the histogram of each channel image and shows the result
    of each histogram channel in a new image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, check the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s understand how to extract each channel histogram and how to draw it.
    First, we need to create three matrices to process each input image channel. We
    use a vector-type variable to store each one and use the `split` OpenCV function
    to divide the input image among these three channels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we are going to define the number of bins of our histogram, in our case,
    one per possible pixel value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s define our range of variables and create three matrices to store each
    histogram:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We can calculate the histograms using the `calcHist` OpenCV function. This
    function has several parameters with this order:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The input image**: In our case, we use one image channel stored in the `bgr`
    vector'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The number of images in the input to calculate the histogram**: In our case,
    we only use `1` image'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The number channel dimensions used to compute the histogram**: We use `0`
    in our case'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The optional mask matrix.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The variable to store the calculated histogram.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Histogram dimensionality**: This is the dimension of the space where the
    image (here, a gray plane) is taking its values, in our case `1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Number of bins to calculate**: In our case `256` bins, one per pixel value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Range of input variables**: In our case, from `0` to `255` possible pixels
    values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Our `calcHist` function for each channel looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have calculated each channel histogram, we have to draw each one
    and show it to the user. To do this, we are going to create a color image that
    is `512` by `300` pixels in size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we draw the histogram values into our image, we are going to normalize
    the histogram matrices between the minimum value, `0`, and a maximum value; the
    maximum value is the same as the height of our output histogram image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have to draw a line from bin `0` to bin `1`, and so on. Between each
    bin, we have to calculate how many pixels there are; then, a `binStep` variable
    is calculated by dividing the width by the number of bins. Each small line is
    drawn from horizontal position `i-1` to `i`; the vertical position is the histogram
    value in the corresponding `i`, and it is drawn with the color channel representation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we show the histogram image with the `imshow` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the result for the `lena.png` image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7cc7556f-246c-4765-b1d1-55c62e9a1869.png)'
  prefs: []
  type: TYPE_IMG
- en: Image color equalization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to learn how to equalize a color image. Image
    equalization, or histogram equalization, tries to obtain a histogram with a uniform
    distribution of values. The result of equalization is an increase in the contrast
    of an image. Equalization allows lower local contrast areas to gain high contrast,
    spreading out the most frequent intensities. This method is very useful when the
    image is extremely dark or bright and there is a very small difference between
    the background and foreground. Using histogram equalization, we increase the contrast
    and the details that are over- or under-exposed. This technique is very useful
    in medical images, such as X-rays.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there are two main disadvantages to this method: the increase in background
    noise and a consequent decrease in useful signals. We can see the effect of equalization
    in the following photograph, and the histogram changes and spreads when increasing
    the image contrast:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/56a126f0-b50e-4488-a28d-eb54b5eccd50.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s implement our equalization histogram; we are going to implement it in
    the `Callback` function defined in the user interface''s code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'To equalize a color image, we only have to equalize the luminance channel.
    We can do this with each color channel but the result is not usable. Alternatively,
    we can use any other color image format, such as **HSV** or **YCrCb**, that separates
    the luminance component in an individual channel. Thus, we choose **YCrCb** and
    use the Y channel (luminance) to equalize. Then, we follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Convert or input the **BGR** image into **YCrCb** using the `cvtColor`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '2\. Split the **YCrCb** image into different channels matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '3\. Equalize the histogram only in the Y channel, using the `equalizeHist`
    function which has only two parameters, the input and output matrices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '4\. Merge the resulting channels and convert them into the **BGR** format to
    show the user the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The process applied to a low-contrast `Lena` image will have the following
    result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fa858d66-53c0-40ab-bdf2-f97db2cdb0ca.png)'
  prefs: []
  type: TYPE_IMG
- en: Lomography effect
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we are going to create another image effect, which is a photograph
    effect that is very common in different mobile applications, such as Google Camera
    or Instagram. We are going to discover how to use a **look-up table** (**LUT**).
    We will go through LUTs later in this same section. We are going to learn how
    to add an over image, in this case a dark halo, to create our desired effect.
    The function that implements this effect is the `lomoCallback` callback and it
    has the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at how the lomography effect works and how to implement it. The
    lomography effect is divided into different steps, but in our example, we did
    a very simple lomography effect with two steps:'
  prefs: []
  type: TYPE_NORMAL
- en: A color manipulation effect by using a look-up table to apply a curve to the
    red channel
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A vintage effect by applying a dark halo to the image
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The first step was to manipulate the red color with a curve transform by applying
    the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e428a8cc-1511-412e-84cd-640a09c5df72.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This formula generates a curve that makes the dark values darker and the light
    values lighter, where **x** is the possible pixels value (`0` to `255`) and **s**
    is a constant that we set to `0.1` in our example. A lower constant value that
    generates pixels with values lower than `128` is very dark, and over `128` is
    very bright. Values near to `1` convert the curve into a line and do not generate
    our desired effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/70093da0-1f3c-4924-b4f7-aba9a99af497.png)'
  prefs: []
  type: TYPE_IMG
- en: This function is very easy to implement by applying an LUT. An LUT is a vector
    or table that returns a preprocessed value for a given value to perform computation
    in the memory. An LUT is a common technique used to spare CPU cycles by avoiding
    performing costly computations repeatedly. Instead of calling the `exponential`/`divide`
    function for each pixel, we perform it only once for each possible pixel value
    ( `256` times) and store the result in a table. Thus, we have saved CPU time at
    the cost of a bit of memory. While this may not make a great difference on a standard
    PC with small image sizes, this makes a huge one for CPU-limited hardware, such
    as Raspberry Pi.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in our case, if we want to apply a function for every pixel in
    our image, then we have to make *width* x *height* operations; for example, in
    100 x 100 pixels, there will be 10,000 calculations. If we can pre-calculate all
    possible results for all possible inputs, we can create the LUT table. In an image,
    there are only **256** possible values as a pixel value. If we want to change
    the color by applying a function, we can pre-calculate the 256 values and save
    them in an LUT vector. In our sample code, we define the `E` variable and create
    an `lut` matrix of `1` row and `256` columns. Then, we do a loop over all possible
    pixel values by applying our formula and saving it into an `lut` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'As we mentioned earlier in this section, we don''t apply the function to all
    channels; thus, we need to split our input image by channels using the `split`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We then apply our `lut` table variable to the red channel. OpenCV gives us
    the `LUT` function, which has three parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: Input image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Matrix of look-up table
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Output image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then, our call to the `LUT` function and red channel looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we only have to merge our computed channels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The first step is done and we only have to create the dark halo to finish our
    effect. Then, we create a gray image with a white circle inside, with the same
    input image size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Check out the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/51793ccb-0ca9-4d51-a930-17105ecdad99.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we apply this image to our input image, we will get a strong change from
    dark to white; thus, we can apply a big blur using the `blur` filter function
    to our circle halo image to get a smooth effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The image will be altered to give us the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/db62a585-6b82-4227-86b3-1aa64980bd09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, if we have to apply this halo to our image from step 1, an easy way to
    do this is to multiply both images. However, we will have to convert our input
    image from an 8-bit image to a 32-bit float, because we need to multiply our blurred
    image, which has values in the `0` to `1` range, with our input image, which has
    integer values. The following code will do it for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'After converting our image, we only need to multiply each matrix per element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we will convert the float image matrix result to an 8-bit image matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This will be the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b5c3ab57-53cc-46d2-8a7f-98fd05d371b4.png)'
  prefs: []
  type: TYPE_IMG
- en: Cartoonize effect
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last section of this chapter is dedicated to creating another effect, called
    **cartoonize**; the purpose of this effect is to create an image that looks like
    a cartoon. To do this, we divide the algorithm into two steps: **edge detection**
    and **color filtering**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `cartoonCallback` function defines this effect, which has the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The first step is to detect the most important *edges* of the image. We need
    to remove noise from the input image before detecting the edges. There are several
    ways to do it. We are going to use a median filter to remove all possible small
    noise, but we can use other methods, such as Gaussian blur. The OpenCV function
    is `medianBlur`, which accepts three parameters: input image, output image, and
    the kernel size (a kernel is a small matrix used to apply some mathematical operation,
    such as convolutional means, to an image):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'After removing any possible noise, we detect the strong edges with the `Canny`
    filter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Canny` filter accepts the following parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: Input image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Output image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First threshold
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Second threshold
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sobel size aperture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boolean value to indicate whether we need to use a more accurate image gradient
    magnitude
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The smallest value between the first threshold and the second threshold is
    used for edge linking. The largest value is used to find initial segments of strong
    edges. The sobel size aperture is the kernel size for the sobel filter that will
    be used in the algorithm. After detecting edges, we are going to apply a small
    dilation to join broken edges:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to what we did in the lomography effect, if we need to multiply our
    edges'' result image with the color image, then we require the pixel values to
    be in the `0` and `1` range. For this, we will divide the canny result by `256`
    and invert the edges to black:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also transform the canny 8 unsigned bit pixel format to a float matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'To give a cool result, we can blur the edges, and to give smooth result lines,
    we can apply a `blur` filter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The first step of the algorithm is finished, and now we are going to work with
    the color. To get a cartoon look, we are going to use the `bilateral` filter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The `bilateral` filter is a filter that reduces the noise of an image while
    keeping the edges. With appropriate parameters, which we will explore later, we
    can get a cartoonish effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `bilateral` filter''s parameters are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Input image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Output image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Diameter of pixel neighborhood; if it's set to negative, it is computed from
    a sigma space value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sigma color value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sigma coordinate space
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With a diameter greater than five, the `bilateral` filter starts to become slow.
    With sigma values greater than 150, a cartoonish effect appears.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a stronger cartoonish effect, we truncate the possible color values
    to 10 by multiplying and dividing the pixels values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to merge the color and edges results. Then, we have to create
    a three-channel image as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'We can convert our color result image to a 32-bit float image and then multiply
    both images per element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we only need to convert our image to 8 bits and then show the resulting
    image to the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'In the next screenshot, we can see the input image (left image) and the result
    of applying the cartoonize effect (right image):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b6a8c27a-6435-4b18-abc8-dad291b07de3.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw how to create a complete project that manipulates images
    by applying different effects. We also split a color image into multiple matrices
    to apply effects to only one channel. We saw how to create look-up tables, merge
    multiple matrices into one, use the `Canny` and `bilateral` filters, draw circles,
    and multiply images to get halo effects.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to do object inspection, and how to segment
    an image into different parts and detect those parts.
  prefs: []
  type: TYPE_NORMAL
