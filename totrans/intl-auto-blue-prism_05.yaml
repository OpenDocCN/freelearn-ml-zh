- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: IA Process and Work Queue Designs for HITL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The primary difference between RPA and IA lies in the *certainty of outcomes*
    and *risk*. In some cases, people implement so-called “IA” that doesn’t incur
    any risk. A Chatbot interface that classifies human input, which further triggers
    traditional RPA to run, falls into this category. While there’s ML in the chatbot
    portion, the risk is contained and resolved before RPA even begins. For these
    types of IA Processes, you really only need to know how to interface with the
    ML part (see *Chapters 1*, *2*, and *3*), and this chapter can be omitted.
  prefs: []
  type: TYPE_NORMAL
- en: For IA cases that *do* change the risk profile, by creating non-deterministic
    process outcomes, you’re hopefully convinced that designing an IA process to accommodate
    HITL should be standard practice, even if the team decides to keep HITL turned
    off. There could be an update to the prediction model, regulatory changes, new
    business requirements, and so on that will lead to enabling HITL reviews again.
  prefs: []
  type: TYPE_NORMAL
- en: The number of Processes and the number of Work Queues are two fundamental design
    decisions that an IA Solution Designer must make. Almost all of the other design
    elements, such as whether to use Tags, Statuses, Deferrals, and so on depend on
    these two decisions. This chapter discusses when to choose *one versus multiple
    Processes* and *one versus multiple Work Queues* when implementing IA in BP. It’s
    important to keep in mind that this discussion focuses specifically on IA – meaning
    a design that enables ML prediction and HITL review afterward. Other use-case-specific
    design topics involving Work Queues, such as parent-child Queues, won’t be presented.
  prefs: []
  type: TYPE_NORMAL
- en: 'More specifically, we will be looking at the pros and cons of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Single BP Process, single Work Queue designs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiple BP Process, single Work Queue designs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiple BP Processes, multiple Work Queue designs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Download and import the three `.bprelease` files in the `ch5` folder on GitHub:
    [https://github.com/PacktPublishing/Intelligent-Automation-with-Blue-Prism/tree/main/ch5](https://github.com/PacktPublishing/Intelligent-Automation-with-Blue-Prism/tree/main/ch5)'
  prefs: []
  type: TYPE_NORMAL
- en: The GitHub folder also has an Excel file that will be saved as part of *Example
    1* of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Single-Process, single-Work Queue designs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If there’s such a thing as a *default* solution design, it would be a *single*
    BP Process and a *single* Work Queue created from the *Blue Prism Process Template*.
    As we saw in the examples in [*Chapter 4*](B18416_04.xhtml#_idTextAnchor062),
    this *simple* design can absolutely be used for IA.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll discuss the two main IA solution designs that involve
    a *single* Process and a *single* Work Queue, including their pros, cons, and
    when you might choose them.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous (non-blocking) reviews
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In an **asynchronous review** design, the BP Process *doesn’t wait* for the
    current Item to be reviewed so that it can continue processing. Instead, the Process
    suspends work on the current Item that needs HITL review and moves on to the next
    one. This is probably how most IA Processes should be designed since reviewers
    usually can’t predict when an Item needs review or how long it will take before
    the Item is actually reviewed.
  prefs: []
  type: TYPE_NORMAL
- en: All three of the examples from [*Chapter 4*](B18416_04.xhtml#_idTextAnchor062)
    were designed to operate asynchronously. Statuses determine when an Item is pending
    review, and Deferrals prevent Items from being selected by **Get Next Item** too
    quickly.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s evaluate this *asynchronous review* design from the perspective of **functionality**,
    **maintainability** (in terms of how easy it will be to modify in the future),
    and **operability**. We’ll be using these three criteria to evaluate all of the
    designs in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Functionality
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This design allows for Work Queue Items to be indefinitely Deferred until they
    are reviewed by a human. Items that aren’t Deferred can continue automated processing.
  prefs: []
  type: TYPE_NORMAL
- en: The Process continually switches between two distinct cycles of operation. The
    first cycle is creating review data and checking for completed HITL reviews. The
    next is picking up an Item for traditional RPA processing.
  prefs: []
  type: TYPE_NORMAL
- en: Maintainability
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In terms of maintainability, all of the logic, both business and IA-related,
    is contained in a *single* BP Process. This isn’t clearly good nor bad, as some
    people consider it easier to maintain than a multi-Process solution. My view is
    that having too much in a single Process – in our case, the business logic, the
    ML calling code, and the HITL logic – makes the solution less maintainable. Containing
    everything in a single Process prevents multiple developers from editing it at
    once, which is undesirable if there’s lots of logic there.
  prefs: []
  type: TYPE_NORMAL
- en: Operability
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Controller needs to know how to check Item Statuses in order to find out
    which Items haven’t been reviewed yet. They need to know exactly which Statuses
    exist so that they can edit the Statuses manually in the Control Room. This is
    how they can force an Item to continue automated processing, even if it’s flagged
    for review. There will always be added operational complexity when moving from
    RPA to IA, regardless of the specific Process and Work Queue design that’s chosen.
  prefs: []
  type: TYPE_NORMAL
- en: Controllers also need to find out whether Items that are waiting for review
    are stuck in limbo. There’s a chance that the data shared between the Digital
    Worker and the reviewer, whether it be an Excel file in a shared folder, a database
    record, or a web interface, is incorrectly generated or accidentally deleted.
  prefs: []
  type: TYPE_NORMAL
- en: Pros
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An advantage of the asynchronous review design is that everything is contained
    in one Process, making the Session usage (license consumption) easy to predict.
    The scheduling is also simple to manage. This benefits companies that need to
    carefully control how their licenses are used. Statistics about a case’s Total
    Work Time are also clear from the Control Room since we only have a single Work
    Queue.
  prefs: []
  type: TYPE_NORMAL
- en: Cons
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One downside of this design is that Work Queue Items can’t be picked up for
    work immediately after it’s reviewed (assuming that it’s desirable to do so).
    It always has to wait for the Deferral time to pass before it can be picked up
    by **Get** **Next Item**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another downside of this design is that checking for reviewed predictions so
    that their Statuses can be updated should probably occur outside of the Process
    Template’s Work Block. In the following figure, we see that the Process checks
    for completed human reviews right before a new Item is worked on:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – Checking for a reviewed prediction should only happen in between
    Items](img/B18416_05_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 – Checking for a reviewed prediction should only happen in between
    Items
  prefs: []
  type: TYPE_NORMAL
- en: This is required because the logic that checks for completed reviews is unrelated
    to the case-specific logic of the Item that’s locked by **Get Next Item**. We
    don’t want an Exception that occurs in the review-checking logic to cause an Item
    that’s being worked on to be an Exception as well. The compromise that’s made
    by placing checking logic outside the Work Block is that the Process can Terminate
    if an Exception happens there. A *two*-Process design can decouple the review-checking
    logic from the actual business process logic, mitigating this issue.
  prefs: []
  type: TYPE_NORMAL
- en: Another concern with this design lies in the amount of time spent performing
    the review checking versus actually processing a case. They’re two relatively
    independent activities that need to run within the same Session. Depending on
    actual conditions, you might spend so much time in the review-checking logic that
    it *negatively impacts the throughput of working cases*. Imagine that checking
    for completed reviews requires logging in to a custom website. If this website
    is slow or requires lots of navigation between pages, the gap between picking
    up cases using **Get Next Item** due to checking for completed reviews can become
    very large.
  prefs: []
  type: TYPE_NORMAL
- en: A full example of this one-Process, one-Work Queue, asynchronous design can
    be found in [*Chapter 4*](B18416_04.xhtml#_idTextAnchor062), *Example 3*.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve discussed the merits and demerits of the asynchronous review
    design, let’s look at a different *single*-Process, *single*-Work Queue design
    for *synchronous* reviews.
  prefs: []
  type: TYPE_NORMAL
- en: Synchronous (blocking) reviews
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we have **SLA requirements** that require manual review to complete in a
    short timeframe, we should consider a **synchronous review** design. In this design,
    the Process blocks and waits for the Work Queue Item's review to be completed
    before progressing.
  prefs: []
  type: TYPE_NORMAL
- en: Functionality
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In a synchronous review Process, we must complete the current Item, including
    waiting for HITL review, before moving on to other Items. This is often desired
    when IA is backing a real-time customer interaction. Recall that there’s a real
    IA use case where ML is used to help verify pharmaceutical prescriptions. Depending
    on the setting where this is used – such as a pharmacy, a doctor’s office, or
    a hospital – the customer’s expectation of receiving their medication can be considered
    “real-time,” and as low as a few minutes.
  prefs: []
  type: TYPE_NORMAL
- en: Under a synchronous review design, the BP Process enters a polling loop that
    blocks and continually checks to see whether the prediction has been reviewed.
    If the review is completed within the SLA period, automated processing continues.
    If the ML review doesn’t complete within the SLA period, the case is marked as
    an Exception.
  prefs: []
  type: TYPE_NORMAL
- en: Maintainability
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Similar to the asynchronous design, everything is contained within a *single*
    Process, which to most developers could be considered maintainable. The logic
    to implement a polling loop is simpler than the logic for the asynchronous design
    and easy for even new developers to grasp.
  prefs: []
  type: TYPE_NORMAL
- en: Operability
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Control Room operations are straightforward compared to the asynchronous design
    – Items that aren’t reviewed within the time limit are marked as an Exception.
    Controllers don’t really need to do anything different from non-IA solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Pros
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There aren’t many advantages to this design besides the overall simplicity of
    the solution. It’s easy to understand, modify the polling logic, schedule and
    predict the license usage. The strongest reason to choose this design is to enable
    real-time reviews.
  prefs: []
  type: TYPE_NORMAL
- en: Cons
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The most significant downside of this design is *significantly lowered case
    throughput*, which is a trade-off to meeting individual case SLAs. If there’s
    also a high volume of cases, more BP sessions need to be concurrently running,
    resulting in more licenses being used. Time is inevitably wasted in the polling
    loop, and this waste increases as the SLA period is longer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an example of this single-Process, single-Work Queue-blocking
    design for a hospital setting. At a high level, we will be going through the following
    four steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Examine the contents of the example’s Release file and import additional dependencies.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Understand the logic to create `.html` review files with images.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Examine the polling logic used to achieve synchronous reviews.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the example to see the result in the Control Room.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Example 1 – polling for reviewed predictions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this example, we’ll use the prescription medication scenario that was described
    earlier. Imagine that we’re working on a project for a private hospital where
    roughly 200 patients are processed per day. Each of these patients is expected
    to need medication from the hospital pharmacy. To shorten the time spent waiting
    and improve patient satisfaction at the pharmacy, the hospital is looking to use
    image-based ML to automatically *count the number of pills* for their most commonly
    prescribed medications.
  prefs: []
  type: TYPE_NORMAL
- en: The ML team has already built a model for multiple types of medication and determined
    the thresholds where they want human intervention for manual review. To meet the
    goals of the project (reduce the time spent waiting by patients), we’ve decided
    on a blocking process design where the Digital Worker waits for, at most, *two
    minutes* for a prediction to be reviewed. A small team of trained remote workers
    will be responsible for performing manual review using a simple web interface.
    The web interface is chosen as the reviewers need to look at an image of the medication.
  prefs: []
  type: TYPE_NORMAL
- en: The Digital Worker will save `.html` files to a network share folder. One `.html`
    file contains the image of the prescription medication and a drop-down list for
    the reviewer to choose the amount of medication shown in the image. The `.html`
    filename will contain the Item ID. The concept of batch size isn’t relevant to
    this case as we don’t want to review multiple predictions in a single `.``html`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Our first step is to verify the contents of the `.bprelease` file and import
    some additional files needed for this example.
  prefs: []
  type: TYPE_NORMAL
- en: Verify the Release contents and import dependencies
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Here, we’ll examine the `.bprelease` file contents and import a third-party
    asset from the DX. Then, we’ll download an Excel file containing the thresholds
    for human review and ensure that it’s saved to the correct location:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Verify that *one* Process, *one* Work Queue, and *four* Environment Variables
    have been imported:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.2 – The Release contents of Example 1](img/B18416_05_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 – The Release contents of Example 1
  prefs: []
  type: TYPE_NORMAL
- en: Download and Import the `.html` files. Note that this step has been completed
    if you’ve gone through *Example 3, GCP Cloud Vision batch OCR processing* section
    of[*Chapter 2*](B18416_02.xhtml#_idTextAnchor028). Ignore this step if **Utility
    – File Manipulation** has already been imported.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Download the Excel file from [https://github.com/PacktPublishing/Intelligent-Automation-with-Blue-Prism/blob/main/ch5/Ch5%20Example%201%20Thresholds.xlsx](https://github.com/PacktPublishing/Intelligent-Automation-with-Blue-Prism/blob/main/ch5/Ch5%20Example%201%20Thresholds.xlsx).
    This contains the thresholds for triggering the review of different medication
    types.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the Excel file into the path specified by the Environment Variable named
    `C:/Users/Public/Ch5 Example` `1 Thresholds.xlsx`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the Excel file. This file stores the thresholds for the different types
    of medication (if we have more medication types, we can add more rows to the spreadsheet):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.3 – The threshold configuration Excel file](img/B18416_05_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.3 – The threshold configuration Excel file
  prefs: []
  type: TYPE_NORMAL
- en: Locate the Environment Variable named `.html` files as the interface to review
    predictions. After the reviewer has reviewed a prediction, they’re expected to
    press a button named **Submit Reviewed Prediction**, which either triggers the
    browser’s file download dialog to pop up or automatically downloads a file onto
    your PC. The behavior depends on how your browser is set up.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.4 – The static .html review interface](img/B18416_05_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.4 – The static .html review interface
  prefs: []
  type: TYPE_NORMAL
- en: Under more realistic conditions, we wouldn’t use static `.html` files. We’d
    have a web server serving the review web pages, where pressing the **Submit**
    button would automatically copy the necessary file to a shared location. This
    would remove the need for the user to download a file altogether. However, setting
    up a web server is outside the scope of this book and unnecessary to illustrate
    the concepts of a synchronous review design.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s look at the Process diagram. Most of the Process is structured identically
    to *Example 2 – Thresholding* from [*Chapter 4*](B18416_04.xhtml#_idTextAnchor062).
    Only the important differences will be highlighted here.
  prefs: []
  type: TYPE_NORMAL
- en: Examine the .html file creation logic
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An important part of the solution lies in how we implement the data-sharing
    interface between the Digital Worker and the reviewer. Since images are part of
    the review data, we’ve chosen a web browser and HTML form as the review interface.
    Let’s see how this can be achieved:'
  prefs: []
  type: TYPE_NORMAL
- en: Open **Example 1 – Polling for Reviewed Predictions** in the *Ch5* Group in
    the Process Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Locate and open the `03b Write Image to HTML Template` Page. This Page is executed
    after we know that a prediction needs manual review.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Look at the first three Action Stages after Start. The first Action writes the
    image of the medication into a file. The second Action reads the image content
    back into BP as a Base64 string. The third Action deletes the image file created
    by Action 1\. The purpose is to convert the image into Base64 encoding so that
    it can be embedded directly into the `.``html` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Look at the *Multi Calc* Stage. Here, the Base64 image string is replaced with
    a `Text` Data Item, which contains an HTML template for the select list, a `Text`
    Data Item is saved as a `.html` file, with the Item ID as the filename, into the
    path specified by the **Ch5 Example 1 To Review Folder Path** Environment Variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.5 – Embed the image as Base64 into the HTML file](img/B18416_05_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.5 – Embed the image as Base64 into the HTML file
  prefs: []
  type: TYPE_NORMAL
- en: Open the `.js` file stored on a CDN, meaning that this example *requires an
    Internet connection* *to run*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Examine the following JavaScript, which is part of the **HTML Template** Data
    Item. When the **Submit** button is pressed in the HTML form, JavaScript is triggered,
    showing the file download dialog. This file download dialog defaults to naming
    the filename as the current Item’s ID, and it stores the reviewed prediction value
    as the file content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We should now understand how the Digital Worker exchanges data with the reviewer.
    BP creates a `.html` file named after the current Item ID into the path specified
    by the **Ch5 Example 1 To Review Folder Path** Environment Variable.
  prefs: []
  type: TYPE_NORMAL
- en: The reviewer monitors this folder manually and opens any `.html` files that
    appear in their default web browser. The `.html` file contains the image of the
    medication, a drop-down list for the reviewer to select the correct amount of
    medication, and a button to submit the form. The `.txt` file is written to disk,
    which contains the drop-down list value (the human-reviewed amount of medication)
    as content.
  prefs: []
  type: TYPE_NORMAL
- en: Examine the polling logic
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s now examine the two major parts that make the polling logic work. The
    first part is a wait loop that throws an Exception if the maximum wait time is
    surpassed; the second part is the cleanup of the `.html` and `.``txt` files:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to `Main Page`. See that inside the Work Block, we’ve added a new Page named
    `Wait for Reviewed Predictions`. This Page contains the logic that stalls execution
    by polling for the reviewed prediction if a review is required:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.6 – The Wait for Reviewed Predictions Page contains the polling
    logic](img/B18416_05_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.6 – The Wait for Reviewed Predictions Page contains the polling logic
  prefs: []
  type: TYPE_NORMAL
- en: Open the `Wait for Reviewed` `Predictions` Page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Locate the Block named `.txt` file named with the current Item ID. This is
    the same `.txt` file that’s saved by pressing the `.html` review file. If an exact
    file isn’t found, we continue to poll until the maximum timeout value specified
    in the **Ch5 Example 1 Max Timeout Seconds** Environment Variable is reached.
    An Exception is thrown if the file isn’t detected within the maximum allowed timeout:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.7 – The polling logic](img/B18416_05_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.7 – The polling logic
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the six Stages that immediately follow the `.txt` file named after
    the current Item ID is found, the Work Queue Status is updated. The revised prediction
    is read back into BP, and the `.txt` file is deleted:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.8 – Read the revised prediction and delete the .txt file](img/B18416_05_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.8 – Read the revised prediction and delete the .txt file
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Updating the Status is not crucial to the correct functioning of this single-work
    queue polling design. It’s kept here to skip steps on the `Main Page` in case
    the Item is retried after an Exception or Stop. However, updating the Status is
    crucial to the asynchronous review design. There, the Status is used to repeatedly
    defer the Item until it has been reviewed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Locate the `.html` file is deleted as the final step on this Page. It’s safe
    to delete the `.html` file even if it’s still loaded in the reviewer’s browser
    due to how modern browsers work:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.9 – Delete the .html file](img/B18416_05_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.9 – Delete the .html file
  prefs: []
  type: TYPE_NORMAL
- en: Run the Process
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This Process loads 10 randomly generated Items into the Work Queue named [*Chapter
    5*](B18416_05.xhtml#_idTextAnchor075) *Example 1 Queue*. Due to random creation,
    this Process might need to be run multiple times before an image is selected for
    manual review. On average, there should be four Items that need manual review
    for every Session run. The ML algorithm is not real – it’s a placeholder, based
    on random numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will run the polling Process and let two minutes pass. This should cause
    the first Item to be marked as an Exception since the review didn’t complete within
    the timeout period. Then, we will manually review all subsequent Items within
    their two-minute limit. This should result in all of the other Items being marked
    as Completed:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to the Control Room, locate the *Ch5* Group, and start the Process named
    **Example 1 – Polling for Reviewed Predictions**. *Do not wait for the Session*
    *to complete*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the folder that has been configured for the **Ch5 Example 1 To Review Folder
    Path** Environment Variable in Windows File Explorer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Wait for a `.html` file to appear. Once a file appears, the reviewer has 120
    seconds before this Item is marked as an Exception:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.10 – An .html file appears in the To Review Folder Path](img/B18416_05_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.10 – An .html file appears in the To Review Folder Path
  prefs: []
  type: TYPE_NORMAL
- en: 'Wait 120 seconds for the Item to expire and open the Work Queue named [*Chapter
    5*](B18416_05.xhtml#_idTextAnchor075) *Example 1 Queue*. See that there is one
    Item marked as an Exception. Note that the Item Key displayed in the Control Room
    is not the same as the Item ID (filename of the `.``html` file):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.11 – The Item is marked as an Exception once the maximum wait time
    is surpassed](img/B18416_05_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.11 – The Item is marked as an Exception once the maximum wait time
    is surpassed
  prefs: []
  type: TYPE_NORMAL
- en: 'Return to Windows File Explorer and wait for another `.html` file to appear.
    Open the file as soon as possible in your web browser. Review the prediction by
    choosing the amount of medication and clicking on the **Submit Reviewed** **Prediction**
    button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.12 – Perform human review and submit](img/B18416_05_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.12 – Perform human review and submit
  prefs: []
  type: TYPE_NORMAL
- en: If the **Save as** dialog appears, ensure that the folder matches the value
    of the **Ch5 Example 1 Completed Review Folder Path** Environment Variable. Save
    the file without renaming it. The **Save as** dialog might not appear if you have
    your browser set to automatically download files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat *steps 5* and *6*, reviewing any `.html` files that appear, until the
    Session has finished executing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once the Session run is complete, open the [*Chapter 5*](B18416_05.xhtml#_idTextAnchor075)
    *Example 1 Queue* Work Queue and see that all Items have been marked as **Completed**
    except for one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.13 – All Items except for one are completed](img/B18416_05_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.13 – All Items except for one are completed
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we saw how a *single* Process and *single* Work Queue, together
    with a polling loop, can fulfill the IA use case where real-time HITL review is
    needed. We also devised a method to review images by writing them into `.``html`
    files.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s move the discussion from *single*-Process designs and look at *multi-Process*
    ones.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: While you can design a *single* BP Process with *multiple* Work Queues, there
    aren’t any clear reasons to do so for IA. As a general design rule, avoid having
    multiple Work Queues for a single BP Process. It’s difficult to follow the Process
    flow when there are multiple Work Queues that can be the source of an Item that’s
    worked on, reducing maintainability. An exception to this is if the additional
    Work Queues aren’t a source of Items to be worked on, such as for Parent/Child
    Work Queue designs where only Item Statuses, Tags, or Data are updated.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple-Process, single-Work Queue designs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Under the context of IA, there are three broad reasons why you might want to
    have multiple BP Processes working on only a *single* Work Queue. The first is
    to *keep distinct pieces of logic separate*. We will see an example of this later
    in the section, which has one BP Process primarily for the business logic and
    other Processes to house logic specific to the ML portions of the solution design.
    Keeping these separate makes future modifications to the business logic easier
    to manage.
  prefs: []
  type: TYPE_NORMAL
- en: The next reason is closely related to the first one. We can separate a solution
    into different Processes to *promote reusability*. As you can imagine, the logic
    to implement random sampling, thresholding, notifying reviewers that predictions
    are ready for review, and so on, are potentially interchangeable across multiple
    IA Processes, and could be implemented as their own Process.
  prefs: []
  type: TYPE_NORMAL
- en: The third reason is to enable different sections of the overall process to *scale
    differently*. Imagine that we’re putting a new IA process into production and
    that the random sampling percentage is set to 100%, to force human review of every
    ML prediction during hypercare. If there’s a BP Process dedicated specifically
    to checking for reviewed predictions, we can run it on more Digital Workers to
    prevent bottlenecks during this time. Once we’re happy with the accuracy and performance
    of the ML model, the random sampling percentage and the number of Sessions that
    the review-checking Process needs can be lowered.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will discuss a *multiple*-Process, *single*-Queue IA
    design where the logic for manual reviews is split into its own Process. This
    section also contains an example.
  prefs: []
  type: TYPE_NORMAL
- en: Independent manual review logic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The review-checking logic that we’ve previously seen can be put in a separate
    Process, decoupling it from the business logic. The following figure shows how
    this can be set up at a high level.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.14 – A two-Process, single-Queue design](img/B18416_05_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.14 – A two-Process, single-Queue design
  prefs: []
  type: TYPE_NORMAL
- en: '*Process 1* in the diagram performs all the business logic steps, including
    making the ML prediction. *Process 2* uses the *same* Work Queue as Process 1
    and is only responsible for the logic related to HITL review – transferring data
    to the reviewers and checking for completed reviews. Its main purpose is to update
    the Work Queue Item Status so that Process 1 can continue automated processing
    on an Item after it has been reviewed.'
  prefs: []
  type: TYPE_NORMAL
- en: Functionality
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The main function of this design is to allow Process 1 to spend *all* of its
    time executing business logic as opposed to IA solution logic (writing share data
    and checking for reviewed predictions). It allows for *independent scaling* of
    the two activities. For instance, you could dedicate multiple Sessions to run
    Process 1 while only having one Session run Process 2, or the other way around,
    depending on your actual need.
  prefs: []
  type: TYPE_NORMAL
- en: Maintainability
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By moving from one Process to two, each Process overall becomes simpler to maintain.
    But the overall complexity of the solution increases, as developers need to understand
    how both Processes affect the execution flow of an Item. As the IA team gains
    experience and documentation practices improve, this complexity is significantly
    reduced.
  prefs: []
  type: TYPE_NORMAL
- en: Operability
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *single*-Process, *single*-Queue example checks to see whether a review
    is completed by looping through the contents of a *completed folder*. This completed
    folder could instead be an API call, a database, or some other system. Files or
    records in the “completed location” *must* contain a reference to the *Item ID*
    somewhere. BP must be able to lock the Item based on the Item ID to update its
    Status so that it can continue automated processing as required.
  prefs: []
  type: TYPE_NORMAL
- en: Having the Item ID directly exposed to reviewers is fragile from an *operations*
    standpoint. Someone could accidentally (or deliberately) modify the Item ID. This
    could result in a permanently stuck Work Queue Item that can no longer be reviewed,
    or updating the Status of a different Item than was intended.
  prefs: []
  type: TYPE_NORMAL
- en: The alternative to looping through a data transfer location is to loop through
    the Work Queue for Items that are pending review. Unfortunately, **Get Next Item**
    can’t filter based on Status. We can, however, filter Work Queues based on *Tags*,
    which we’ll implement in an example shortly. We’ll also need to store a reference
    to the file path or third-party system ID as Work Queue Data so that the Item
    ID doesn’t need to be exposed to the reviewer.
  prefs: []
  type: TYPE_NORMAL
- en: Also, since we plan on looping through every Item that’s pending review, we
    can ensure that the review data is persisted correctly and recreate it if it isn’t.
    This isn’t possible in our previous design since we’re only looping through the
    contents of the completed folder, and not the full set of everything that needs
    to be reviewed.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs: []
  type: TYPE_NORMAL
- en: You might be wondering whether we could have added Tags to our *single*-Process,
    *single*-Work Queue example to prevent exposing the Item ID to reviewers. While
    it would work technically, in practice, it takes too much time away from actually
    working the Items according to business logic. Recall that the review-checking
    logic in our previous example was positioned outside of the Main Page’s Work Block.
    If the number of Items pending review is high or if checking to see whether a
    pending Item has been reviewed takes more than a few seconds, we can end up spending
    significant amounts of time just doing this checking.
  prefs: []
  type: TYPE_NORMAL
- en: Pros
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the *single*-Process, *single*-Queue design, review checking is performed
    *outside* the Work Block of the Process Template. Exceptions that occur outside
    the Work Block potentially result in Terminations. With a two-Process design,
    review logic can be placed into its own Work Block. Exceptions that occur no longer
    lead to immediate Termination. This makes this design well-suited for scenarios
    where checking for a completed review has complex logic, such as logging into
    a web interface.
  prefs: []
  type: TYPE_NORMAL
- en: While some might consider this solution as more difficult to maintain, as there
    are two Processes instead of just one, I’d argue that it’s now easier to maintain
    the primary Process that contains the business logic, since much of the IA solution
    logic has been moved out. It’s the business logic that’s more apt to change over
    the lifetime of an IA solution. Moving to a two-Process design also enables reuse
    and targeted scaling.
  prefs: []
  type: TYPE_NORMAL
- en: Cons
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The main downside of this *two*-process, *single*-Work Queue design over the
    single-Process one is that the number of Sessions used to get a working solution
    is, at minimum, two. The scheduling also becomes more complex.
  prefs: []
  type: TYPE_NORMAL
- en: Looping through every Item that’s marked for human review, regardless of whether
    it has been reviewed, unnecessarily adds to the Total Work Time of that Item.
    A negative consequence of this two Process, single-Queue design is that the case
    duration statistics will be higher than the single-Process design.
  prefs: []
  type: TYPE_NORMAL
- en: Another downside is caused by moving the logic that persists prediction data
    so that it can be shared with the reviewer in the new Process. Since we’re offloading
    that task to a different Process, we’re effectively no longer saving review data
    immediately after an ML prediction is made. We may need *frequent Session runs
    of Process 2* to ensure that review data is created in a timely manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s look at an implementation of this single-Work Queue, two-Process
    design in an example. At a high level, we will be going through five steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Verify the contents of the Release.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Confirm that the HITL review logic has been moved out of Process 1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Understand the functionality that has been moved into Process 2.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run Process 1 and see the results in the Control Room.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run Process 2 and see the results in the Control Room.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Example 2 – independent manual review logic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Suppose that we’re deploying the customer churn example from [*Chapter 4*](B18416_04.xhtml#_idTextAnchor062),
    *Example 3* into production for the first time. During our hypercare period, we
    want to review every single ML prediction. Based on the case volume, the hypercare
    period, and the overall seasonality of retail shopping, we want to revise our
    original *single*-Process design and split out the review logic so that it can
    be scaled independently and started on multiple Sessions. We will still keep a
    *single* Work Queue.
  prefs: []
  type: TYPE_NORMAL
- en: The Release has already been developed. Let’s examine how the review logic has
    been split into a separate Process, and execute it to get an idea of how it can
    be scaled and maintained independently.
  prefs: []
  type: TYPE_NORMAL
- en: Verify the Release contents
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This Release’s contents are similar to those of [*Chapter 4*](B18416_04.xhtml#_idTextAnchor062),
    *Example 3*, except that there’s an additional Process:'
  prefs: []
  type: TYPE_NORMAL
- en: Verify that *two Processes*, one Work Queue, and five Environment Variables
    have been imported (descriptions of the Environment Variables can be found in
    [*Chapter 4*](B18416_04.xhtml#_idTextAnchor062), *Example 3*):![](img/B18416_05_15.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 5.15 – The Release contents for Example 2
  prefs: []
  type: TYPE_NORMAL
- en: Verify that the **Ch5 Example 2 Random Sampling Target** Environment Variable
    is set to **100.0**, meaning that all ML predictions will be reviewed as required
    by the hypercare period.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verify that the primary Process no longer has review-related logic
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s ensure that the Process containing the main business logic no longer
    has logic related to creating Excel files and updating Item Statuses:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the Process named **Example 2A – Random Sampling** in the *Ch5* Group in
    the Process Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On the `Main Page`, see that there’s no Page to check for reviewed predictions
    before the **Get Next Item** Stages; this logic has been removed from this Process:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.16 – There are no Pages to check for reviewed predictions](img/B18416_05_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.16 – There are no Pages to check for reviewed predictions
  prefs: []
  type: TYPE_NORMAL
- en: Open any of the `Main Page`. See that a Tag Filter has been added to *not* select
    any Items with the **Manual Review** **Required** Tag.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See that the Work Queue name on the `Main Page` is set to **Chapter 5** **Example**
    **2 Queue**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.17 – Take note of the Queue name](img/B18416_05_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.17 – Take note of the Queue name
  prefs: []
  type: TYPE_NORMAL
- en: Open the Page named `Update Status and Tag for Manual Review`. See that there’s
    no longer any logic to write Excel files to disk. Also, see that we’re setting
    the Tag for Items requiring HITL review to **Manual** **Review Required**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We’ve finished verifying that the primary Process contains no logic related
    to HITL reviews. Next, let’s look at the second Process of this design, which
    contains the IA logic related to writing review data to disk and checking for
    completed reviews.
  prefs: []
  type: TYPE_NORMAL
- en: Examine the Process that checks for reviewed predictions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This second Process is developed using the standard BP Process Template. We’ll
    see that all of the logic regarding HITL reviews has been moved to this new Process:'
  prefs: []
  type: TYPE_NORMAL
- en: Open **Example 2B – Manual Review Logic** Process under the *Ch5* Group in the
    Process Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: See that the Queue Name on the `Main Page` is also set to **Chapter 5** **Example
    2 Queue**, matching the Work Queue in **Example 2A – Random Sampling** Process.
    Both Processes work from the same Queue.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open any of the `Main Page`. See that there’s a Tag Filter that selects Items
    tagged with **Manual** **Review Required**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Look at the Work Block on the `Main Page`. There are two steps. First, review
    data is written to the share folders. Next, we check to see whether the Item has
    been moved to the *completed* folder, indicating that it has been reviewed. Putting
    these in the Work Block allows us to gracefully recover from Exceptions and retry
    Items from the Control Room:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.18 – The two steps related to review logic are in the Work Block](img/B18416_05_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.18 – The two steps related to review logic are in the Work Block
  prefs: []
  type: TYPE_NORMAL
- en: Open the `02 Check for Reviewed` `Predictions` Page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Locate the *Update Item* Block. See that we’re Updating the Status and removing
    the Tag when an Item is reviewed. The remaining logic on this Page is related
    to shared folder file management:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.19 – Update the Item’s Status and Tag](img/B18416_05_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.19 – Update the Item’s Status and Tag
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve seen that Process 1 no longer contains HITL review logic and that
    both Processes share the same Work Queue. Process 2 removes the `Main Page` to
    skip steps in case of Item retries.
  prefs: []
  type: TYPE_NORMAL
- en: Run the primary Process
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s run the main Process and examine the Work Queue. This Process randomly
    generates 13 Items to populate the Work Queue and performs ML predictions. We
    should see that all Items will stop processing, pending human review:'
  prefs: []
  type: TYPE_NORMAL
- en: Locate the *Ch5* folder and run **Example 2A – Random Sampling** in the Control
    Room. Wait for the Session to complete.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'View the contents of the **Chapter 5** **Example 2 Queue**. See that all 13
    Items have the **Manual Review Required** Status and Tag since our random sampling
    rate is set to 100%:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.20 – All Items have the Manual Review Required Status](img/B18416_05_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.20 – All Items have the Manual Review Required Status
  prefs: []
  type: TYPE_NORMAL
- en: Open Windows File Explorer and navigate to the folder defined in the **Ch5 Example
    2 To Review Folder Path** Environment Variable. Check that there are no Excel
    files in this folder. This is because the logic to write review files to disk
    has been moved to Process 2, which hasn’t been run yet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the HITL review-checking logic Process
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The second Process writes review data to the shared folder and checks for completed
    reviews. This should be run *concurrently* with the previous Process. However,
    we’ll be running the Processes sequentially for the benefit of readers using the
    trial edition of BP. Here, we’ll be reviewing eight of the thirteen predictions
    before running the second Process again:'
  prefs: []
  type: TYPE_NORMAL
- en: Locate the *Ch5* Group and run the **Example 2B – Manual Review Logic** Process
    in the Control Room. Wait for the Session to complete.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open Windows File Explorer and navigate to the folder defined in the **Ch5 Example
    2 To Review Folder Path** Environment Variable. Check that there are three Excel
    files in this folder. Two of the Excel files should have five items needing review
    (according to the batch size) and one file should have three, totaling 13\. Notice
    that Item ID is no longer a column in the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Cut and paste one of the files with five predictions and the file that has three
    predictions into the folder defined in the **Ch5 Example 2 Completed Review Folder
    Path** Environment Variable. This simulates what a reviewer does after completing
    the review of two Excel files, totaling eight predictions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run **Example 2B – Manual Review Logic** in the Control Room again. Wait for
    the Session to complete.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Look at **Chapter 5** **Example 2 Queue** Work Queue to see that eight of the
    Item’s Statuses are set to **Manual Review Complete** and have been untagged:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.21 – Eight Items have updated their Status and removed their Tag](img/B18416_05_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.21 – Eight Items have updated their Status and removed their Tag
  prefs: []
  type: TYPE_NORMAL
- en: Open Windows File Explorer and navigate to the folder defined in the **Ch5 Example
    2 Completed Review Folder Path** Environment Variable. Verify that there are no
    longer any Excel files in this folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At this point, eight of the Items have been untagged, meaning that they can
    be picked up by Process 1’s **Get Next** **Item** Action.
  prefs: []
  type: TYPE_NORMAL
- en: Run the primary Process again
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We will rerun the primary Process and pretend that it never stopped. While
    13 new Work Queue Items will be created, we’re more interested in seeing that
    the 8 Items from the previous run are marked as **Completed**:'
  prefs: []
  type: TYPE_NORMAL
- en: Run **Example 2A – Random Sampling** in the Control Room again. Wait for the
    Session to complete.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: View the contents of **Chapter 5** **Example 2 Queue**. See that 8 of the 26
    Items are marked as **Completed**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this example, we saw how the review-checking logic can be separated into
    its own Process, independent from the main business logic. This has a number of
    benefits, namely promoting reusability and allowing for the independent scaling
    of the business logic versus the review-checking logic. The overall robustness
    of the data transfer design is also improved by removing the need to expose the
    Item ID to reviewers, and by locating the review-checking logic inside of an Exception-handling
    Block.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s move on from *multiple*-Process, *single*-Work Queue designs, and
    explore why we might want to use *multiple* Processes and *multiple* Work Queues
    in IA.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple-process, multiple-work queue designs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Adding new Process(es) and Work Queue(s) is a great way to *add ML to an existing
    BP solution*, as much of the original design and Process diagram can stay the
    same. While adding more Work Queues leads to an overall more complex design, they
    can add some nuanced improvements to our solution, especially around auditing,
    making them worthy of consideration.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at the pros and cons of a *two-Process*, *two-Queue* IA solution
    design, where the Work Queue Items that need human review are saved to a separate
    Work Queue.
  prefs: []
  type: TYPE_NORMAL
- en: Fully independent manual reviews
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the downsides of the *two-Process*, *single*-Work Queue design is that
    the case duration statistics end up higher due to the repeated checking of each
    Item. If we instead push all Items that need review into a *new Work Queue*, we
    can separate the time spent processing the business logic from the time that is
    spent on review checking.
  prefs: []
  type: TYPE_NORMAL
- en: 'This *two* Queue design is shown in the following figure. The first Process
    performs the business logic, including making ML predictions. If an Item requires
    manual review, *only data that is relevant to the review* is pushed into Work
    Queue 2\. Process 2 saves review data in the review interface and checks to see
    whether the review is completed. If a review is complete, it updates the Item
    Status in Work Queue 1 so that automated processing can continue:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.22 – A two-Process, two-Work Queue design](img/B18416_05_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.22 – A two-Process, two-Work Queue design
  prefs: []
  type: TYPE_NORMAL
- en: Functionality
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The functionality of this design is identical to the multiple-Process, single-Queue
    design. We can dedicate *all* of Process 1’s time to executing business logic,
    and we can have *independent scaling* of the two Processes. Adding a new Work
    Queue doesn’t affect the functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Maintainability
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This design actually improves maintainability compared to the two-Process, single-Queue
    one. The addition of the Work Queue leads to an even cleaner separation between
    the business logic and the HITL review logic.
  prefs: []
  type: TYPE_NORMAL
- en: Operability
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The addition of a new Work Queue most directly impacts how we operate the IA
    solution. Although being able to isolate the time spent performing business logic
    versus the time spent in manual review logic is useful, the reporting and Control
    Room operations can become more complex. If you want a view of how long an Item
    takes to complete, including the review logic time, the case durations of the
    two Queues need to be added together in your reporting. This should really only
    be a one-off change to the automated reporting that’s put into place, though.
    The Controller also needs to navigate between two Work Queues, while remembering
    the *Item Key*, to get a full picture of what’s happening with an Item, which
    is an operational inconvenience.
  prefs: []
  type: TYPE_NORMAL
- en: Pros
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The main benefit of this design, something that will become increasingly important
    in the future, is that the second Work Queue enables *simpler HITL auditing*.
    Since we only push the minimum amount of data needed to perform the human review,
    the Session Logs or Work Queue data of Process 2 can be readily exported without
    exposing unnecessary data. We should strongly consider implementing this Process
    design if we need to frequently answer the following:'
  prefs: []
  type: TYPE_NORMAL
- en: What were the original inputs to the ML prediction?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Who performed the review?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What was the revised label and why?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While they might not seem relevant now, these are precisely the types of questions
    that regulators and courts of law will ask whether an ML prediction causes harm
    or damage to a user or customer.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: If the Windows filesystem is used as the data-sharing method, you must explicitly
    enable folder or file-based auditing. This will generate security events that
    allow you to find out which user has modified a file (reviewed a prediction).
  prefs: []
  type: TYPE_NORMAL
- en: The isolated Work Queue or Session Log data that contains only what has been
    human-reviewed can be readily *fed back to the data scientists* who developed
    the algorithm. If we didn’t have this clean source of corrected data, we would
    need to generate it by filtering the Session Logs programmatically and removing
    any extraneous data. The main benefits of this design are simplified HITL auditing
    and enabling data feedback to the ML model developers.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, this type of design is well-suited to turning existing RPA Processes
    into IA ones as the existing RPA design can largely remain unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: Cons
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Most of the negatives are the operational inconveniences discussed earlier.
    Items must now be tracked across multiple Work Queues and reporting becomes more
    complex.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve discussed a *two*-Process, *two*-Work Queue design, let’s go
    one step further and separate out the ML prediction logic as well.
  prefs: []
  type: TYPE_NORMAL
- en: Separating ML predictions and manual reviews into their own Processes and Work
    Queues
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we need to expand the simplified auditing to *encompass all ML predictions*,
    we can move the ML algorithm calling steps and data into their own Process and
    Work Queue. This leads to a *three*-Process, *three*-Work Queue design, as shown
    in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.23 – A three-Process, three-Work Queue design](img/B18416_05_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.23 – A three-Process, three-Work Queue design
  prefs: []
  type: TYPE_NORMAL
- en: Our first Process and Work Queue contain standard business logic. All ML predictions
    that need to be made are added to Work Queue 2, which is worked by Process 2\.
    Process 2 executes the ML algorithm, generates the prediction, and decides whether
    human review is necessary. If human review isn’t needed, the Item’s Status is
    updated in Work Queue 1 so that automated processing continues. If human review
    is needed, the Item gets pushed into Work Queue 3\. Process 3 creates the data
    needed for HITL review and updates the Item Status in Queue 1 when the review
    is completed.
  prefs: []
  type: TYPE_NORMAL
- en: Functionality, maintainability, and operability
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These are largely the same as the two-Process, two-Work Queue design.
  prefs: []
  type: TYPE_NORMAL
- en: Pros
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The benefits are largely the same as the *two*-Process, *two*-Work Queue design,
    except that we gain additional *audit options for all ML predictions* that are
    made.
  prefs: []
  type: TYPE_NORMAL
- en: Cons
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This design suffers from the same problems as the *two*-Process, *two*-Work
    Queue design. Depending on business needs, the reporting can be more complicated
    if we need to add the execution times of multiple Work Queues together. The Controller
    will have an even harder time keeping track of what’s happening to a case across
    three different Work Queues.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s look at an implementation of this *three*-Process, *three*-Work
    Queue design through an example.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3 – full separation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this example (based on a real-life IA case), we’re automating a national
    utility’s customer claims process. 5,000 claims are processed per month. The current
    non-automated process requires human judgment and there are 25 possible resolutions
    to a customer’s claim.
  prefs: []
  type: TYPE_NORMAL
- en: This national utility has developed an ML recommendation system that displays
    the top three resolution suggestions and their confidence scores. Manual review
    is triggered when the confidence scores of the top two recommendations are within
    5% of each other. This is a more complex form of *thresholding* where there’s
    a dependency between the predicted labels.
  prefs: []
  type: TYPE_NORMAL
- en: Cases are reviewed through a web interface containing the three recommendations,
    their confidence levels, the relevant case data, and customer data. Since the
    solution is for a national utility, the IA team wants to stay ahead of regulations
    and implement a solution design that facilitates the auditing of all ML predictions
    and human reviews.
  prefs: []
  type: TYPE_NORMAL
- en: 'The goal of this example is to illustrate the logic needed to get this three-Process,
    three-Work Queue design working. At a high level, we will go through the following
    11 steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Verify the Release contents and configure an Environment Variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Examine Process 1’s (business logic) `Main Page`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: See how data is pushed into the ML Queue (Queue 2).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Examine Process 2’s (ML prediction) `Main Page`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Examine Process 3’s (HITL review) `Main Page`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run Process 1 and see the result in the Control Room.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run Process 2 and see the result in the Control Room.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run Process 3 and see the result in the Control Room.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Review one prediction.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run Process 3 again and see the result in the Control Room.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run Process 1 again and see the result in the Control Room.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verify the Release contents and configure an Environment Variable
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s get familiar with `.bprelease` and configure one Environment Variable:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Verify that *three* Processes, *three* Work Queues, and *three* Environment
    Variables have been imported:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.24 – The Release contents for Example 3](img/B18416_05_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.24 – The Release contents for Example 3
  prefs: []
  type: TYPE_NORMAL
- en: Open the Environment Variable named **Ch5 Example 3 Completed Review Folder
    Path**. Change the value so that it matches the default download folder of your
    web browser. Do not put a trailing slash at the end of the folder name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Examine Process 1’s Main Page
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, let’s look at the first Process, which contains the primary business
    logic. This is close to what an RPA Process would look like without any IA components
    added. We’ll highlight the areas that make this solution design function:'
  prefs: []
  type: TYPE_NORMAL
- en: Open **Example 3A – IA Business Logic** in the *Ch5* Group in the Process Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open any of the `Main Page`. See that a **Tag Filter** has been added to not
    select Items with the **Waiting ML Prediction** or **Manual Review** **Required**
    Tags:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.25 – Get Next Item filters on two Tags](img/B18416_05_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.25 – Get Next Item filters on two Tags
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the *Work* Block. There’s a Page named `03 Push to Queue 2` that’s
    responsible for connecting this Process to Process 2, which performs all ML predictions.
    All execution paths lead to this Page, meaning that all Items will eventually
    be pushed to Queue 2 for ML prediction:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.26 – The 03 Push to Queue 2 Page](img/B18416_05_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.26 – The 03 Push to Queue 2 Page
  prefs: []
  type: TYPE_NORMAL
- en: See that there’s an `Unlock Item` Page following `03 Push to` `Queue 2`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Here, we saw that Tag Filters were used in **Get Next Item** so that Items that
    require manual review or ML prediction are not selected.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s look at what happens on the `03 Push to Queue` `2` Page.
  prefs: []
  type: TYPE_NORMAL
- en: Pushing Items into the ML Work Queue
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `03 Push to Queue 2` Page adds a new Item in Work Queue 2, **Tags** the
    current Item, and adds a reference to the newly created Item in Work Queue 2 to
    the current Item’s Data:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `03 Push to Queue` `2` Page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Look at the first three Actions that are connected to Start. The first Action
    copies the existing Item Data into a new Collection, omitting any Data that’s
    irrelevant to the ML prediction. The second Action adds the current Item ID of
    Work Queue 1 into this new Collection. The third Action adds this new Collection
    to Work Queue 2:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.27 – The first three Actions of the 03 Push to Queue 2 Page](img/B18416_05_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.27 – The first three Actions of the 03 Push to Queue 2 Page
  prefs: []
  type: TYPE_NORMAL
- en: Open the next Action named **Work Queues::Tag Item**. See that we add the **Waiting
    ML Prediction** Tag to the current Item, which prevents it from being picked up
    in this Process using **Get Next Item**. This Tag will be removed in Process 2.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Process 1 is relatively straightforward. Only a few changes have been made to
    the standard Process Template, namely adding *Tag Filters* to **Get Next Item**,
    adding a new Page to push Items into Work Queue 2, and unlocking the current Item.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s look at the ML prediction Process itself.
  prefs: []
  type: TYPE_NORMAL
- en: Examine Process 2’s Main Page
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s quickly look at Process 2’s `Main` `Page` to understand the logic that’s
    happening at a high level. This Process is responsible for running the ML prediction
    and checking to see whether HITL review is required through thresholding:'
  prefs: []
  type: TYPE_NORMAL
- en: Open **Example 3B – ML Prediction** in the *Ch5* Group in the Process Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Look at the first two Pages in the *Work* Block on the `Main Page`. `01 ML
    Prediction` triggers the ML prediction and persists the predicted results into
    the current Item Data. `02 Check for Manual Review` contains the logic that checks
    the *threshold* between the two recommended resolutions with the highest Confidence
    Scores. These first two Pages have similar logic to what we’ve seen in previous
    examples:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.28 – The first two Pages in the Work Block of Process 2](img/B18416_05_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.28 – The first two Pages in the Work Block of Process 2
  prefs: []
  type: TYPE_NORMAL
- en: Look at the `03a Update Queue 1 Item` Page. It is run when HITL review is not
    needed. In this Page, we try to lock the equivalent Item in Work Queue 1, update
    its Status, and remove the Tag. This allows Process 1 to continue processing this
    Item.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Look at the `03b Push to Queue 3` Page. It is run when HITL review is needed.
    This Page contains the logic needed to create an Item for Queue 3\. It’s largely
    the same as what was done in Process 1 to push an Item into Work Queue 2.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Examine Process 3’s Main Page
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Finally, let’s take a high-level look at our third Process, which is responsible
    for saving the `.html` files for the reviewers, as well as checking for completed
    reviews:'
  prefs: []
  type: TYPE_NORMAL
- en: Open **Example 3C – Manual Review Logic** in the *Ch5* Group in the Process
    Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See that the *Work* Block on the `Main Page` only has two Pages. There’s no
    Choice Stage and Status checking to skip steps because we want to be able to recreate
    the `.html` files if they’re missing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.29 – Two Pages in the Work Block of Process 3](img/B18416_05_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.29 – Two Pages in the Work Block of Process 3
  prefs: []
  type: TYPE_NORMAL
- en: Look at the `01 Write Shared Review Data` Page. It writes the input data to
    the ML algorithm and the three predictions into a .html file using Find/replace.
    Once the file is saved to the shared location specified by the **Ch5 Example 3
    To Review Folder Path** Environment Variable, this file path is saved into the
    current Item’s Data. This allows us to check to see whether the file is missing
    and recreate it if necessary.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Look at the `02 Check for Reviewed Predictions` Page. It checks to see whether
    a `.txt` file is present in the location specified by the **Ch5 Example 3 Completed
    Review Folder Path** Environment Variable. If yes, we try to lock the equivalent
    Item in Work Queue 1, update its Status, and remove the Tag. This allows Process
    1 to continue processing this Item after it’s retrieved using **Get** **Next Item**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Look at the two Pages that follow the *Item Review Complete?* Decision Stage.
    Depending on whether the Item was manually reviewed, we either defer the Item
    or mark it as Completed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After examining the three Processes of this solution, we should notice that
    nothing here is really new compared to the earlier examples in this chapter. However,
    we’ve structured the solution such that the three different concerns – the business
    logic, the ML prediction logic, and the HITL review logic – stay relatively independent.
  prefs: []
  type: TYPE_NORMAL
- en: Communication between Work Queues happens by persisting the Item ID of other
    Queues into our Item Data. This allows us to lock and update Item Tags and Statuses
    of Process 1, containing the main business flow.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s run the example Process.
  prefs: []
  type: TYPE_NORMAL
- en: Run the primary Process
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We need to run three Processes in the Control Room to complete our example.
    The primary Process that we’ll run next randomly generates 10 items to populate
    the Work Queue. After populating, each item should have the Status and Tags set
    so that we’re waiting for an ML prediction before we can continue:'
  prefs: []
  type: TYPE_NORMAL
- en: Run **Example 3A – IA Business Logic** in the *Ch5* Group in the Control Room.
    Wait for the Session to complete.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'View the contents of [*Chapter 5*](B18416_05.xhtml#_idTextAnchor075) *Example
    3 Queue 1* under **Queue Management**. See that all 10 Items have the **Waiting
    ML** **Prediction** Tag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.30 – All Items in Queue 1 are waiting for ML prediction](img/B18416_05_30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.30 – All Items in Queue 1 are waiting for ML prediction
  prefs: []
  type: TYPE_NORMAL
- en: View the contents of `Chapter 5` `Example 3 Queue 2` under **Queue Management**.
    There should be 10 Items in this Queue, with the same Item Keys that are in Queue
    1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Items are now waiting for Process 2 to run.
  prefs: []
  type: TYPE_NORMAL
- en: Run the ML Process
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The second Process that we need to run generates the ML prediction and determines
    which Items require HITL review. Work Queues 1, 2, and 3 are modified by this
    Process:'
  prefs: []
  type: TYPE_NORMAL
- en: Run **Example 3B – ML Prediction** in the *Ch5* Group in the Control Room. Wait
    for the Session to complete.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'View the contents of [*Chapter 5*](B18416_05.xhtml#_idTextAnchor075) *Example
    3 Queue 2* under **Queue Management**. See that all 10 Items have completed their
    ML prediction:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.31 – All Items in Queue 2 have finished their ML prediction](img/B18416_05_31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.31 – All Items in Queue 2 have finished their ML prediction
  prefs: []
  type: TYPE_NORMAL
- en: 'View the contents of [*Chapter 5*](B18416_05.xhtml#_idTextAnchor075) *Example
    3 Queue 1* under **Queue Management**. See that some of the Items require HITL
    review. Note that this is truly random. If you don’t see any Items that need review,
    please run Process 1 and Process 2 again. Count the number of Items that need
    review. In the following figure, it’s two:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.32 – Some Items in Queue 1 should require manual review](img/B18416_05_32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.32 – Some Items in Queue 1 should require manual review
  prefs: []
  type: TYPE_NORMAL
- en: 'View the contents of [*Chapter 5*](B18416_05.xhtml#_idTextAnchor075) *Example
    3 Queue 3* under **Queue Management**. There should be the same number of Items
    in this queue as was counted in *step 3* (two). You can compare the two Queues
    based on Item Key as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.33 – Items needing manual review in Queue 1 should also be in Queue
    3](img/B18416_05_33.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.33 – Items needing manual review in Queue 1 should also be in Queue
    3
  prefs: []
  type: TYPE_NORMAL
- en: Run the HITL review Process
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now, let’s run the final Process. This Process generates review data and checks
    to see whether a review is complete. If so, it updates the Item in Work Queue
    1 so that it can continue automated processing:'
  prefs: []
  type: TYPE_NORMAL
- en: Run **Example 3C – Manual Review Logic** in the *Ch5* Group in the Control Room.
    Wait for the Session to complete. This Process will have looped through all Items
    needing review, created their review files, and checked to see whether the review
    was complete.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the folder defined by the `.html` files in the folder should be the same
    as the number of Items in [*Chapter 5*](B18416_05.xhtml#_idTextAnchor075) *Example
    3 Queue 1* (two in this case).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Manually review one file
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s review one prediction by opening one of the review files and submitting
    the web form. This web form will attempt to save a `.txt` file to the location
    specified by the **Ch5 Example 3 Completed Review Folder Path** Environment Variable:'
  prefs: []
  type: TYPE_NORMAL
- en: Choose one of the `.html` files and open it in your web browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Scroll to the bottom of the web page, select a random Resolution from the drop-down
    list, and press the **Submit Reviewed** **Prediction** button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.34 – Manually review the Item](img/B18416_05_34.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.34 – Manually review the Item
  prefs: []
  type: TYPE_NORMAL
- en: Save the file if the **Save as** dialog appears. Ensure that the folder that
    you save the file to matches the value of the **Ch5 Example 3 Completed Review
    Folder Path** Environment Variable. Do not rename the file. The **Save as** dialog
    might not appear if your browser is set to automatically download files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the HITL review Process again
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we’ve reviewed a prediction, we can run the third Process again (this
    will find that there’s a matching .txt file for one of the Items, and update that
    Item in Work Queue 1 by removing the Tag so that it can be picked up by Process
    1’s Get Next Item):'
  prefs: []
  type: TYPE_NORMAL
- en: Run **Example 3C – Manual Review Logic** in the *Ch5* Group in the Control Room.
    Wait for the Session to complete.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'View the contents of [*Chapter 5*](B18416_05.xhtml#_idTextAnchor075) *Example
    3 Queue 3* under **Queue Management**. One of the Items should be marked as **Completed**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.35 – One Item has been marked as Completed in Queue 3](img/B18416_05_35.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.35 – One Item has been marked as Completed in Queue 3
  prefs: []
  type: TYPE_NORMAL
- en: 'View the contents of [*Chapter 5*](B18416_05.xhtml#_idTextAnchor075) *Example
    3 Queue 1* under **Queue Management**. The Item with the same Item Key should
    have a **Manual Review Complete** Status and no Tag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.36 – The same Item in Queue 1 should have an updated Status and
    no Tag](img/B18416_05_36.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.36 – The same Item in Queue 1 should have an updated Status and no
    Tag
  prefs: []
  type: TYPE_NORMAL
- en: Run the primary Process again
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The last step in this example is to run the primary Process again (note that
    10 new Items will be added to Queue 1 and Queue 2; we expect all of the Items
    from the previous Session run to complete except for those marked as **Manual**
    **Review Required**):.
  prefs: []
  type: TYPE_NORMAL
- en: Run **Example 3A – IA Business Logic** in the *Ch5* Group in the Control Room.
    Wait for the Session to complete.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: View the contents of [*Chapter 5*](B18416_05.xhtml#_idTextAnchor075) *Example
    3 Queue 1* under **Queue Management**. See that all of the Items that were added
    in the original Session run are marked as **Completed**, except for the ones tagged
    with **Manual** **Review Required**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We’ve completed *Example 3*. In this example, we went through a *three*-Process,
    *three*-Work Queue design that separates ML logic and HITL review logic into their
    own Process and Work Queue. Inter-process communication is handled by Tag Filters,
    Statuses, and keeping references to the equivalent Item IDs in other Queues.
  prefs: []
  type: TYPE_NORMAL
- en: The main benefits of this type of design are simplified auditability and the
    separate scaling of different IA concerns. We won’t go through the motions of
    exporting the Session Logs, but it’s straightforward to see that we can selectively
    export just the ML or HITL review logs in case a customer (or regulatory body)
    complains about the resolution chosen for their claim.
  prefs: []
  type: TYPE_NORMAL
- en: Design comparison
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve covered five different IA designs that varied in terms of their number
    of Processes and Work Queues. Let’s review the designs to understand why we might
    want to choose one design over another. Keep in mind that none of the designs
    are better or worse than others. It’s about how appropriate it is for your use
    case, the skill level of developers, and the overall maturity of the IA initiative.
  prefs: []
  type: TYPE_NORMAL
- en: Design 1 – asynchronous reviews (one Process, one Work Queue)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This self-contained design allows for human review to be delayed forever. The
    Process alternates through cycles of doing work on an Item and checking for reviewed
    predictions. The checking of completed reviews is done by querying the data share
    location as opposed to looping through each Item that’s pending review.
  prefs: []
  type: TYPE_NORMAL
- en: Since everything is in a single Process and Work Queue, it’s well suited for
    scenarios where the number of concurrent Sessions available is limited or the
    work volume is low. Control Room management overhead is also low. Maintaining/updating
    the single Process can be considered simpler for newer development teams.
  prefs: []
  type: TYPE_NORMAL
- en: This design is less suitable if checking for a reviewed prediction takes a long
    time to execute or is prone to throw Exceptions. This is because the checking
    logic is located outside of the main Work Block.
  prefs: []
  type: TYPE_NORMAL
- en: Design 2 – synchronous (polling) reviews (one Process, one Work Queue)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This design should be used when we need to stop and wait for HITL review to
    complete when HITL is required. If a human review isn’t performed within the time
    limit, the Item is marked as an Exception. Since each Item pauses and waits for
    human review, the overall case throughput of this design is the lowest. Otherwise,
    it has similar pros/cons to the asynchronous design.
  prefs: []
  type: TYPE_NORMAL
- en: Design 3 – independent HITL review logic (two Processes, one Work Queue)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This design splits the HITL review logic into a separate Process while keeping
    the same Work Queue. The main benefit of this design is that the business logic
    and review checking can be scaled independently in terms of Session runs. The
    maintainability in my opinion is also improved.
  prefs: []
  type: TYPE_NORMAL
- en: This design loops through all Work Queue Items that need human review instead
    of looping at the data share interface. This allows review records to be recreated
    if they’re missing. This also increases the Total Work Time of an individual case,
    making the statistics look worse.
  prefs: []
  type: TYPE_NORMAL
- en: Since there are two BP Processes, we need a minimum of two Sessions to run this
    solution. If the Session runs for the review logic Process are infrequent, the
    data share records won’t be created in a timely manner, even if the reviewers
    are available to do their work. Items that have finished human review also depend
    on frequent runs of the review-checking Process so that the Item can have its
    Status updated and picked up for continued automated processing.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the scheduling is more complex when compared to single-Process solutions,
    although this shouldn’t be an issue for experienced Controllers.
  prefs: []
  type: TYPE_NORMAL
- en: Design 4 – fully independent HITL reviews (two Processes, two Work Queues)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Building on Design 3, we can further separate the manual review portion by pushing
    Items that need human review into a separate Work Queue. This allows us to isolate
    case statistics, separating the time spent performing review logic (saving the
    data to be shared with reviewers and checking for completed reviews) from the
    time spent performing business logic. The trade-off that’s made when isolating
    these statistics is that we might want an end-to-end view of the time spent on
    a case. This requires adding the case times from two Work Queues together. Operationally,
    adding another Work Queue makes tracking cases in the Control Room more difficult
    for the Controller.
  prefs: []
  type: TYPE_NORMAL
- en: Most notably, adding a new Work Queue increases the auditability of what was
    reviewed and allows for this data to be more easily fed back to data science teams
    so that the ML algorithm can be improved. This design is also a good way to extend
    an existing RPA process, by adding ML. Besides these points, this design has similar
    pros and cons to Design 3.
  prefs: []
  type: TYPE_NORMAL
- en: Design 5 – full separation (three Processes, three Work Queues)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our final design builds on Design 4\. It places all the ML logic (making the
    prediction and checking whether HITL review is necessary) into a new Process and
    data into a separate Work Queue. As a result, we gain a simple way to audit all
    ML predictions. Besides this, we have similar pros and cons to Designs 3 and 4.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored five IA designs that differed in terms of the number
    of BP Processes and Work Queues. Deciding on the number of Processes and Work
    Queues is extremely important for both IA and general RPA design as it affects
    almost every aspect of the remaining solution. This includes the potential scalability,
    case reporting statistics, maintainability, logging, auditability, scheduling,
    and other Control Room operations.
  prefs: []
  type: TYPE_NORMAL
- en: Two IA designs were presented containing a single Process and a single Work
    Queue. One design was for synchronous reviews and the other for asynchronous reviews.
    In our third design, we split off the logic used to handle HITL reviews into its
    own Process, leading to a two-Process, single-Work Queue design. This allows for
    increased reusability and the separate scaling of business logic versus HITL review
    logic. For the fourth design, we added a new Work Queue to store all the Items
    that need manual review. This provides a simpler audit trail into which predictions
    were corrected by a human. It also allows us to more easily feed back these corrected
    predictions to the ML team. Finally, our fifth design further split off all of
    the ML calling logic into its own Work Queue and Process, enhancing scalability
    and simplifying the auditing of all ML predictions.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll discuss some smaller design elements that supplement
    the larger Process/Work Queue structure that was chosen based on the learnings
    of this chapter. These elements, such as Environment Variables, Session Variables,
    and Credentials, can improve the overall IA solution management and operations.
  prefs: []
  type: TYPE_NORMAL
