["```py\n(ns my-namespace\n  (:use [clj-ml classifiers data]))\n```", "```py\n(def fish-template\n  [{:category [:salmon :sea-bass]}\n   :length :width :lightness])\n```", "```py\n(def *classifier* (make-classifier ...))\n```", "```py\n(def fish-cv-data\n  (for [i (range 3000)] (make-sample-fish)))\n```", "```py\n(def fish-cv-dataset\n  (make-dataset \"fish-cv\" fish-template fish-cv-data))\n```", "```py\n(defn cv-classifier [folds]\n  (dataset-set-class fish-cv-dataset 0)\n  (classifier-evaluate *classifier* :cross-validation\n                       fish-cv-dataset folds))\n```", "```py\nuser> (def cv (cv-classifier 10))\n#'user/cv\n```", "```py\nuser> (print (:summary cv))\n\nCorrectly Classified Instances        2986              99.5333 %\nIncorrectly Classified Instances        14               0.4667 %\nKappa statistic                          0.9888\nMean absolute error                      0.0093\nRoot mean squared error                  0.0681\nRelative absolute error                  2.2248 %\nRoot relative squared error             14.9238 %\nTotal Number of Instances             3000     \nnil\n```", "```py\nuser> (print (:confusion-matrix cv))\n=== Confusion Matrix ===\n\n    a    b   <-- classified as\n 2129    0 |    a = salmon\n    9  862 |    b = sea-bass\nnil\n```", "```py\n(ns my-namespace\n  (:use [clojure.java.io :only [file]]\n        [incanter.stats :only [cdf-chisq]])\n```", "```py\n(def min-spam-score 0.7)\n(def max-ham-score 0.4)\n\n(defn classify-score [score]\n  [(cond\n    (<= score max-ham-score) :ham\n    (>= score min-spam-score) :spam\n    :else :unsure)\n   score])\n```", "```py\n(defrecord TokenFeature [token spam ham])\n\n(defn new-token [token]\n  (TokenFeature. token 0 0))\n\n(defn inc-count [token-feature type]\n  (update-in token-feature [type] inc))\n```", "```py\n(def feature-db\n  (agent {} :error-handler #(println \"Error: \" %2)))\n\n(def total-ham (agent 0))\n(def total-spam (agent 0))\n```", "```py\n(defn clear-db []\n  (send feature-db (constantly {}))\n  (send total-ham  (constantly 0))\n  (send total-spam (constantly 0)))\n\n(defn update-feature!\n  \"Looks up a TokenFeature record in the database and\n  creates it if it doesn't exist, or updates it.\"\n  [token f & args]\n  (send feature-db update-in [token]\n        #(apply f (if %1 %1 (new-token token))\n                args)))\n```", "```py\n(def token-regex #\"[a-zA-Z]{3,}\")\n\n(def header-fields\n  [\"To:\"\n   \"From:\"\n   \"Subject:\"\n   \"Return-Path:\"])\n```", "```py\nuser> (re-seq #\"From:(.*)\\n\"\n              \"From: someone@host.org\\n\")\n([\"From: someone@host.org\\n\" \" someone@host.org\"])\n```", "```py\n(defn header-token-regex [f]\n  (re-pattern (str f \"(.*)\\n\")))\n\n(defn extract-tokens-from-headers [text]\n  (for [field header-fields]\n    (map #(str field %1)  ; prepends field to each word from line\n         (mapcat (fn [x] (->> x second (re-seq token-regex)))\n                 (re-seq (header-token-regex field)\n                         text)))))\n\n(defn extract-tokens [text]\n  (apply concat\n         (re-seq token-regex text)\n         (extract-tokens-from-headers text)))\n```", "```py\nuser> (def sample-text\n        \"From: 12a1mailbot1@web.de\n         Return-Path: <12a1mailbot1@web.de>\n         MIME-Version: 1.0\")\n\nuser> (extract-tokens-from-headers sample-text)\n(() (\"From:mailbot\" \"From:web\")\n () (\"Return-Path:mailbot\" \"Return-Path:web\"))\n```", "```py\n(defn update-features!\n  \"Updates or creates a TokenFeature in database\n  for each token in text.\"\n  [text f & args]\n  (doseq [token (extract-tokens text)]\n    (apply update-feature! token f args)))\n```", "```py\n(defn inc-total-count! [type]\n  (send (case type\n          :spam total-spam\n          :ham total-ham)\n        inc))\n\n(defn train! [text type]\n  (update-features! text inc-count type)\n  (inc-total-count! type))\n```", "```py\n(defn extract-features\n  \"Extracts all known tokens from text\"\n  [text]\n  (keep identity (map #(@feature-db %1) (extract-tokens text))))\n```", "```py\n(defn spam-probability [feature]\n  (let [s (/ (:spam feature) (max 1 @total-spam))\n        h (/ (:ham feature) (max 1 @total-ham))]\n      (/ s (+ s h))))\n\n(defn bayesian-spam-probability\n  \"Calculates probability a feature is spam on a prior\n  probability assumed-probability for each feature,\n  and weight is the weight to be given to the prior\n  assumed (i.e. the number of data points).\"\n  [feature & {:keys [assumed-probability weight]\n              :or   {assumed-probability 1/2 weight 1}}]\n  (let [basic-prob (spam-probability feature)\n        total-count (+ (:spam feature) (:ham feature))]\n    (/ (+ (* weight assumed-probability)\n          (* total-count basic-prob))\n       (+ weight total-count))))\n```", "```py\n(defn fisher\n  \"Combines several probabilities with Fisher's method.\"\n  [probs]\n  (- 1 (cdf-chisq\n         (* -2 (reduce + (map #(Math/log %1) probs)))\n         :df (* 2 (count probs)))))\n```", "```py\n(defn score [features]\n  (let [spam-probs (map bayesian-spam-probability features)\n        ham-probs (map #(- 1 %1) spam-probs)\n        h (- 1 (fisher spam-probs))\n        s (- 1 (fisher ham-probs))]\n     (/ (+ (- 1 h) s) 2)))\n```", "```py\n(defn classify\n  \"Returns a vector of the form [classification score]\"\n  [text]\n   (-> text\n       extract-features\n       score\n       classify-score))\n```", "```py\n(defn populate-emails\n  \"Returns a sequence of vectors of the form [filename type]\"\n  []\n  (letfn [(get-email-files [type]\n            (map (fn [f] [(.toString f) (keyword type)])\n                 (rest (file-seq (file (str \"corpus/\" type))))))]\n    (mapcat get-email-files [\"ham\" \"spam\"])))\n```", "```py\n(defn train-from-corpus! [corpus]\n  (doseq [v corpus]\n    (let [[filename type] v]\n      (train! (slurp filename) type))))\n\n(defn cv-from-corpus [corpus]\n  (for [v corpus]\n    (let [[filename type] v\n          [classification score] (classify (slurp filename))]\n      {:filename filename\n       :type type\n       :classification classification\n       :score score})))\n```", "```py\n(defn test-classifier! [corpus cv-fraction]\n  \"Trains and cross-validates the classifier with the sample\n  data in corpus, using cv-fraction for cross-validation.\n  Returns a sequence of maps representing the results\n  of the cross-validation.\"\n    (clear-db)\n    (let [shuffled (shuffle corpus)\n          size (count corpus)\n          training-num (* size (- 1 cv-fraction))\n          training-set (take training-num shuffled)\n          cv-set (nthrest shuffled training-num)]\n      (train-from-corpus! training-set)\n      (await feature-db)\n      (cv-from-corpus cv-set)))\n```", "```py\n(defn result-type [{:keys [filename type classification score]}]\n  (case type\n    :ham  (case classification\n            :ham :correct\n            :spam :false-positive\n            :unsure :missed-ham)\n    :spam (case classification\n            :spam :correct\n            :ham :false-negative\n            :unsure :missed-spam)))\n```", "```py\n(defn analyze-results [results]\n  (reduce (fn [map result]\n            (let [type (result-type result)]\n              (update-in map [type] inc)))\n          {:total (count results) :correct 0 :false-positive 0\n           :false-negative 0 :missed-ham 0 :missed-spam 0}\n          results))\n\n(defn print-result [result]\n  (let [total (:total result)]\n    (doseq [[key num] result]\n      (printf \"%15s : %-6d%6.2f %%%n\"\n              (name key) num (float (* 100 (/ num total)))))))\n```", "```py\n(defn train-and-cv-classifier [cv-frac]\n  (if-let [emails (seq (populate-emails))]\n    (-> emails\n        (test-classifier! cv-frac)\n        analyze-results\n        print-result)\n    (throw (Error. \"No mails found!\"))))\n```", "```py\nuser> (classify \"Make money fast\")\n[:unsure 0.5]\nuser> (classify \"Job interview today! Programmer job position for GNU project\")\n[:unsure 0.5]\n```", "```py\nuser> (train-and-cv-classifier 1/5)\n          total : 600   100.00 %\n        correct : 585    97.50 %\n false-positive : 1       0.17 %\n false-negative : 1       0.17 %\n     missed-ham : 9       1.50 %\n    missed-spam : 4       0.67 %\nnil\n```", "```py\nuser> (classify \"Make money fast\")\n[:spam 0.9720416490829515]\nuser> (classify \"Job interview today! Programmer job position for GNU project\")\n[:ham 0.19095646757667556]\n```", "```py\nuser> (extract-features \"some text to extract\")\n(#clj_ml5.spam.TokenFeature{:token \"some\", :spam 91, :ham 837}\n #clj_ml5.spam.TokenFeature{:token \"text\", :spam 907, :ham 1975}\n #clj_ml5.spam.TokenFeature{:token \"extract\", :spam 3, :ham 5})\n```", "```py\nuser> (classify \"Job\")\n[:unsure 0.6871002132196162]\nuser> (train! \"Job\" :ham)\n#<Agent@1f7817e: 1993>\nuser> (classify \"Job\")\n[:unsure 0.6592140921409213]\n```", "```py\nuser> (train! \"Job\" :spam)\n#<Agent@1f7817e: 1994>\nuser> (classify \"Job\")\n[:spam 0.7445135045480734]\n```", "```py\nuser> (train-and-cv-classifier 1/10)\n          total : 300   100.00 %\n        correct : 294    98.00 %\n false-positive : 0       0.00 %\n false-negative : 1       0.33 %\n     missed-ham : 3       1.00 %\n    missed-spam : 2       0.67 %\nnil\n```"]