- en: Using Computational Photography with OpenCV
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用OpenCV进行计算摄影
- en: 0The goal of this chapter is to build on what we have covered in the previous
    chapters about photography and image processing and investigate some algorithms
    that OpenCV gives you access in a lot more detail. We'll focus on working with
    digital photography and building tools that will allow you to harness the power
    of OpenCV, and even think about using it as your go-to tool for editing your photos.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是建立在前面章节中关于摄影和图像处理所涵盖的内容之上，并深入探讨OpenCV提供的算法。我们将专注于处理数码摄影和构建能够让您利用OpenCV力量的工具，甚至考虑将其作为您编辑照片的首选工具。
- en: 'In this chapter, we will cover the following concepts:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下概念：
- en: Planning the app
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 规划应用
- en: Understanding the 8-bit problem
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解8位问题
- en: Using **gamma correction**
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**伽玛校正**
- en: Understanding **high-dynamic-range imaging** (**HDRI**)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解**高动态范围成像**（**HDRI**）
- en: Understanding panorama stitching
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解全景拼接
- en: Improving panorama stitching
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改进全景拼接
- en: Learning the basics of digital photography and the concepts of high dynamic
    imaging will not only allow you to understand computational photography better,
    but it will make you a better photographer. Since we will explore these topics
    in detail, you will also understand how much work it takes to write a new algorithm.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 学习数码摄影的基础知识和高动态成像的概念不仅可以帮助您更好地理解计算摄影，还可以使您成为一名更好的摄影师。由于我们将详细探讨这些主题，您还将了解编写新算法需要付出多少努力。
- en: Through this chapter, you will learn how to work with unprocessed (RAW) images
    directly from digital cameras, how to use OpenCV's computational photography tools,
    and how to use low-level OpenCV APIs to build a panorama stitching algorithm.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章的学习，您将了解如何直接从数码相机处理（RAW）图像，如何使用OpenCV的计算摄影工具，以及如何使用低级OpenCV API构建全景拼接算法。
- en: We have quite a few topics to cover, so let's roll up our sleeves and get started.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有很多主题要介绍，所以让我们挽起袖子开始吧。
- en: Getting started
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始学习
- en: You can find the code that we present in this chapter at our GitHub repository
    at [https://github.com/PacktPublishing/OpenCV-4-with-Python-Blueprints-Second-Edition/tree/master/chapter5](https://github.com/PacktPublishing/OpenCV-4-with-Python-Blueprints-Second-Edition/tree/master/chapter5).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在我们的GitHub仓库中找到本章中展示的代码，网址为[https://github.com/PacktPublishing/OpenCV-4-with-Python-Blueprints-Second-Edition/tree/master/chapter5](https://github.com/PacktPublishing/OpenCV-4-with-Python-Blueprints-Second-Edition/tree/master/chapter5)。
- en: We will also use the `rawpy` and `exifread` Python packages for reading RAW
    images and reading image metadata. For the full list of requirements, you can
    refer to the `requirements.txt` file in the book's Git repository.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用`rawpy`和`exifread`Python包来读取RAW图像和读取图像元数据。对于完整的需求列表，您可以参考书中Git仓库中的`requirements.txt`文件。
- en: Planning the app
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规划应用
- en: We have multiple concepts to familiarize ourselves with. With a view to building
    your toolbox for image processing, we are going to develop the algorithms that
    we are going to familiarize ourselves with into Python scripts that use OpenCV
    to accomplish real-life problems.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有几个概念需要熟悉。为了构建您的图像处理工具箱，我们将把我们要熟悉的概念开发成使用OpenCV解决实际问题的Python脚本。
- en: 'We will use OpenCV to implement the following scripts so that you will be able
    to use them whenever you need to do photo processing:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用OpenCV实现以下脚本，以便您在需要处理照片时可以使用它们：
- en: '`gamma_correct.py`: This is a script that applies gamma correction to the input
    image and shows the resulting image.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gamma_correct.py`：这是一个脚本，它对输入图像应用伽玛校正，并显示结果图像。'
- en: '`hdr.py`: This is a script that takes images as input and produces a **high
    dynamic range** (**HDR**) image as an output.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hdr.py`：这是一个脚本，它以图像为输入，并生成一个**高动态范围**（**HDR**）图像作为输出。'
- en: '`panorama.py`: This is a script that takes multiple images as input and produces
    a single stitched image that is larger than the individual images.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`panorama.py`：这是一个脚本，它以多个图像为输入，并生成一个比单个图像更大的拼接图像。'
- en: We'll first start with a discussion of how digital photography works and the
    reason we can't take perfect pictures without needing to do post-processing. Let's
    start with the 8-bit problem for images.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先讨论数码摄影的工作原理以及为什么我们不需要进行后期处理就无法拍摄完美的照片。让我们从图像的8位问题开始。
- en: Understanding the 8-bit problem
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解8位问题
- en: Typical **Joint Photographic Experts Group** (**JPEG**) images that we are used
    to seeing, work by encoding each pixel into 24 bits—one 8-bit number per **RGB**
    (**red**, **green**, **blue**) color component, which gives us an integer within
    the 0-255 range. This is just a number, 255, *but is it enough information or
    not?* To understand this, let's try to understand how these numbers are recorded
    and what these numbers mean.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们习惯看到的典型**联合图像专家小组**（**JPEG**）图像，是通过将每个像素编码为24位来工作的——每个**RGB**（红色、绿色、蓝色）颜色组件一个8位数字，这给我们一个在0-255范围内的整数。这只是一个数字，255，*但这足够信息吗？*为了理解这一点，让我们尝试了解这些数字是如何记录的以及这些数字代表什么。
- en: 'Most current digital cameras use a **Bayer filter, **or equivalent, that works
    using the same principles. A Bayer filter is an array of sensors of different
    colors placed on a grid similar to the following diagram:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数当前的数码相机使用**拜耳滤波器**，或等效的，它使用相同的原则。拜耳滤波器是一个不同颜色传感器的阵列，放置在一个类似于以下图所示的网格上：
- en: '![](img/faac3543-7aab-4455-bcd0-a6cde3768ac0.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/faac3543-7aab-4455-bcd0-a6cde3768ac0.png)'
- en: Image source—https://en.wikipedia.org/wiki/Bayer_filter#/media/File:Bayer_pattern_on_sensor.svg
    (CC SA 3.0)
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图片来源—https://en.wikipedia.org/wiki/Bayer_filter#/media/File:Bayer_pattern_on_sensor.svg
    (CC SA 3.0)
- en: In the previous diagram, each of these sensors measures the intensity of the
    light that gets into it, and a group of four sensors represents a single pixel.
    The data from these four sensors are combined to provide us with the three values
    for R, G, and B.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，每个传感器测量进入它的光的强度，四个传感器一组代表一个单独的像素。这四个传感器的数据被组合起来，为我们提供R、G和B的三个值。
- en: Different cameras might have a slightly different layout of red, green, and
    blue pixels, but at the end of the day, they are using small sensors that discretize
    the amount of radiation they get into a single value within the 0-255 range, where
    0 means no radiation at all and 255 means the brightest radiation that the sensor
    can record.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的相机可能会有红色、绿色和蓝色像素的不同布局，但最终，它们都在使用小的传感器，将它们接收到的辐射量离散化到0-255范围内的单个值，其中0表示完全没有辐射，255表示传感器可以记录的最亮辐射。
- en: The range of brightness that is detectable is called the **dynamic range** or
    the **luminance range**. The ratio between the smallest amount of radiation that
    could be registered (that is, 1) and the highest (that is, 255) is called the **c****ontrast
    ratio.**
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 可检测的亮度范围被称为**动态范围**或**亮度范围**。最小可注册的辐射量（即，1）与最高辐射量（即，255）之间的比率称为**对比度比**。
- en: As we said, JPEG files have a contrast ratio of *255:1*. Most current LCD monitors
    have already surpassed that and have a contrast ratio of up to *1,000:1*. I bet
    you are waiting for your eye's ratio. I'm not sure about you, but most humans
    can see up to *15,000:1*.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所说，JPEG文件具有*255:1*的对比度比。大多数当前的LCD显示器已经超过了这个比例，对比度比高达*1,000:1*。我打赌你正在等待你眼睛的对比度比。我不确定你，但大多数人类可以看到高达*15,000:1*。
- en: So, we can see quite a lot more than even our best monitor can show, and a lot
    more than a simple JPEG file stores. Don't despair too much, because the latest
    digital cameras have been catching up and can now capture intensity ratios of
    up to *28,000:1* (the really expensive ones).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以看到比我们最好的显示器显示的还要多，比简单的JPEG文件存储的还要多。不要过于绝望，因为最新的数码相机已经迎头赶上，现在可以捕捉到高达*28,000:1*的强度比（真正昂贵的那些）。
- en: 'The small dynamic range is the reason that, when you are shooting a picture
    and you have the sun in the background, you either see the sun and the surroundings
    are all white without any detail, or everything in the foreground is extremely
    dark. Here is an example screenshot:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 小的动态范围是当你拍照时，如果背景有太阳，你要么看到太阳，周围的一切都是白色，没有任何细节，要么前景中的所有东西都极其黑暗的原因。这里是一个示例截图：
- en: '![](img/d8e38611-5931-491a-9e4d-01998b5650b2.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d8e38611-5931-491a-9e4d-01998b5650b2.png)'
- en: Image source—https://github.com/mamikonyana/winter-hills (CC SA 4.0)
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图片来源—https://github.com/mamikonyana/winter-hills (CC SA 4.0)
- en: So, the problem is that we either display things that are too bright, or we
    display things that are too dark. Before we move forward, let's take a look at
    how to read files that have more than 8 bits and import the data into OpenCV.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，问题是我们要么显示过亮的东西，要么显示过暗的东西。在我们继续前进之前，让我们看看如何读取超过8位的文件并将数据导入OpenCV。
- en: Learning about RAW images
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解RAW图像
- en: Since this chapter is about computational photography, some of you reading it
    are probably photography enthusiasts and love taking pictures using the RAW formats
    that your camera supports—be it **Nikon Electronic Format** (**NEF**) or **Canon
    Raw Version 2** (**CR2**).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Raw files usually capture a lot more information (usually more bits per pixel)
    than JPEG files, and if you are going to do a lot of post-processing, these files
    are a lot more convenient to work with, since they will produce higher-quality
    final images.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: 'So let''s take a look at how to open a CR2 file using Python and load it into
    OpenCV. For that, we will use a Python library called `rawpy`. For convenience,
    we will write a function called `load_image` that can handle both RAW images and
    regular JPEG files so we can abstract this part away and concentrate on more fun
    things in the rest of the chapter:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we take care of the imports (as promised, just one small extra library):'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We define the function, adding an optional `bps` argument, which will let us
    control how much precision we want the images to have, that is, we want to check
    if we want the full 16 bits or are just 8 bits good enough:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, if the file has a `.CR2` extension, we open the file with `rawpy` and
    extract the image without trying to do any post-processing, since we want to do
    that with OpenCV:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As Canon (Canon Inc.—an optical products company) and OpenCV use a different
    ordering of colors, we switch from RGB to **BGR **(**blue**, **green**, and **red**),
    which is the default ordering in OpenCV and we `return` the resulting image:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'For anything that is not `.CR2`, we use OpenCV:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now we know how to get all our images into OpenCV, it's time to get started
    with one of the brightest algorithms we have.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: 'Since my camera has a 14-bit dynamic range, we are going to use images captured
    with my camera:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Once we know how to load our pictures, let's try to see how we can best display
    them on the screen.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Using gamma correction
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Why is everybody still using JPEG files if they can only distinguish between
    255 different levels? **Does it mean it can only capture a dynamic range of 1:255?*
    It turns out there are clever tricks that people use.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned before, the camera sensors capture values that are linear, that
    is, 4 means that it has 4 times more light than 1, and 80 has 8 times more light
    than 10\. But does the JPEG file format have to use a linear scale? It turns out
    that it doesn't. So, if we are willing to sacrifice the difference between two
    values, for example, 100 and 101, we can fit another value there.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand this better, let''s look at the histogram of gray pixel values
    of a RAW image. Here is the code to generate that—just load the image, convert
    it to grayscale, and show the histogram using `pyplot`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here is the result of the histogram:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3e368499-f598-40c1-bd9d-d1731a0930b5.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
- en: 'We have two pictures: the left one is a *normal* picture, where you can see
    some clouds, but it''s almost impossible to see anything in the foreground, and
    the right one has tried to capture some detail in the trees, and because of that
    has burned all the clouds. *Is there a way to combine these?*'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两张图片：左边的是一张*正常*的图片，你可以看到一些云，但几乎看不到前景中的任何东西，而右边的一张则试图捕捉树中的细节，因此烧毁了所有的云。*有没有办法将它们结合起来？*
- en: 'If we take a closer look at the histograms, we see that the burned-out part
    is visible on the right-hand histogram because there are values that are 16,000
    that get encoded as 255, that is, white pixels. But on the left-hand picture,
    there are no white pixels. The way we encode 14-bit values into 8-bit values is
    very rudimentary: we just divide the values by *64 (=2⁶)*, so we lose the distinction
    between 2,500 and 2,501 and 2,502; instead, we only have 39 (out of 255) because
    the values in the 8-bit format have to be integers.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们仔细观察直方图，我们会看到在右侧直方图上可以看见烧毁的部分，因为存在值为16,000的数据被编码为255，即白色像素。但在左侧图片中，没有白色像素。我们将14位值编码为8位值的方式非常基础：我们只是将值除以*64
    (=2⁶)*，因此我们失去了2,500和2,501以及2,502之间的区别；相反，我们只有39（255个中的39个）因为8位格式中的值必须是整数。
- en: This is where gamma corrections come in. Instead of simply showing the recorded
    value as the intensity, we are going to make some corrections, to make the image
    more visually appealing.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是伽玛校正发挥作用的地方。我们不会简单地显示记录的值作为强度，我们将进行一些校正，使图像更具有视觉吸引力。
- en: 'We are going to use a non-linear function to try to emphasize the parts that
    we think are more important:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用非线性函数来尝试强调我们认为更重要的一部分：
- en: '![](img/ec71864e-36ff-4fea-8bcd-bf7fb0880fbb.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ec71864e-36ff-4fea-8bcd-bf7fb0880fbb.png)'
- en: 'Let''s try to visualize this formula for two different values—**γ = 0.3** and **γ
    = 3**:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试可视化这个公式对于两个不同值——**γ = 0.3**和**γ = 3**：
- en: '![](img/f8fd3ea0-b583-418a-91f7-f56ca2b0f7ce.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f8fd3ea0-b583-418a-91f7-f56ca2b0f7ce.png)'
- en: As you can see, small gammas put an emphasis on lower values; the pixel values
    from **0**-**50** are mapped to pixel values from **0**-**150** (more than half
    of the available values). The reverse is true of the higher gammas—the values
    from **200**-**250** are mapped to the values **100**-**250** (more than half
    of the available values). So, if you want to make your photo brighter, you should
    pick a gamma value of **γ < 1**, which is often called **gamma compression**.
    And if you want to make your photos dimmer to show more detail, you should pick
    a gamma value of **γ > 1**, which is called **gamma expansion.**
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，小的伽玛值强调较低的值；**0**-**50**的像素值映射到**0**-**150**的像素值（超过一半的可供值）。对于较高的伽玛值，情况相反——**200**-**250**的值映射到**100**-**250**的值（超过一半的可供值）。因此，如果你想使你的照片更亮，你应该选择**γ
    < 1**的伽玛值，这通常被称为**伽玛压缩**。如果你想使你的照片变暗以显示更多细节，你应该选择**γ > 1**的伽玛值，这被称为**伽玛扩展**。
- en: 'Instead of using integers for *I*, we can start with a float number and get
    to O, then convert that number to an integer to lose even less of information.
    Let''s write some Python code to implement gamma correction:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以不用整数来表示*I*，而是从一个浮点数开始，得到O，然后将该数字转换为整数以丢失更少的信息。让我们编写一些Python代码来实现伽玛校正：
- en: 'First, let''s write a function to apply our formula. Because we are using 14-bit
    numbers, we will have to change it to the following:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们编写一个函数来应用我们的公式。因为我们使用14位数字，所以我们需要将其更改为以下形式：
- en: '![](img/beccc155-e722-44a5-a24e-b34c4b5fa6c0.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/beccc155-e722-44a5-a24e-b34c4b5fa6c0.png)'
- en: 'Thus, the relevant code will be as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，相关的代码如下：
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, we have used the `@functools.lru_cache` decorator to make sure we don't
    compute anything twice.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了`@functools.lru_cache`装饰器来确保我们不会两次计算相同的内容。
- en: 'Then, we just iterate over all the pixels and apply our transformation function:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们只需遍历所有像素并应用我们的转换函数：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now let''s take a look at how to use this to show the new image alongside the
    regularly transformed 8-bit image. We will write a script for this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用这个方法来显示新图像与常规转换的8位图像并排。我们将为此编写一个脚本：
- en: 'First, let''s configure a `parser` to load an image and allow setting the `gamma`
    value:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们配置一个`parser`来加载图像并允许设置`gamma`值：
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Load the `gray` image as a `14bit` image:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`gray`图像加载为`14bit`图像：
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Use linear transformation to get output values as an integer in the range [`0`-`255`]:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用线性变换来获取输出值作为范围`[0`-`255`]内的整数：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Use our `apply_gamma` function we wrote previously to get a gamma-corrected
    image:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用我们之前编写的`apply_gamma`函数来获取伽玛校正的图像：
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then, plot both of the images together with their histogram:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将这两张图像及其直方图一起绘制出来：
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Finally, `show` the image:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，`显示`图像：
- en: '[PRE14]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We have now plotted the histogram and will look at the magic that is elaborated
    in the following two images with their histograms:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经绘制了直方图，接下来我们将看看以下两张图像及其直方图中所阐述的神奇之处：
- en: '![](img/180de854-3e0e-4164-b4b3-963cf8c863b4.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/180de854-3e0e-4164-b4b3-963cf8c863b4.png)'
- en: Look at the picture at the top right—you can see almost everything! And we are
    only getting started.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 看看右上角的图片——你几乎可以看到一切！而我们才刚刚开始。
- en: It turns out gamma compensation works great on black and white images, but it
    can't do everything! It can either correct brightness and we lose most of the
    color information, or it can correct color information and we lose the brightness
    information. So, we have to find a new best friend—that is, HDRI.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，伽玛补偿在黑白图像上效果很好，但它不能做所有的事情！它要么可以校正亮度，我们就会失去大部分的颜色信息，要么它可以校正颜色信息，我们就会失去亮度信息。因此，我们必须找到一个新最好的朋友——那就是，HDRI。
- en: Understanding high-dynamic-range imaging
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解高动态范围成像
- en: '**High-dynamic-range** imaging (**HDR**) is a technique to produce images that
    have a greater dynamic range of luminosity (that is, contrast ratio) than could
    be displayed through the display medium, or captured with the camera using a single
    shot. There are two main ways to create such images—using special image sensors,
    such as an oversampled binary image sensor, or the way we will focus on here,
    by combining multiple **Standard Dynamic Range** (**SDR**) images to produce a
    combined HDR image.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**高动态范围**成像（**HDR**）是一种技术，可以产生比通过显示介质显示或使用单次拍摄用相机捕获的图像具有更大亮度动态范围（即对比度比）的图像。创建此类图像有两种主要方法——使用特殊的图像传感器，例如过采样二进制图像传感器，或者我们在这里将重点关注的，通过组合多个**标准动态范围**（**SDR**）图像来生成一个组合HDR图像。'
- en: HDR imaging works with images that use more than 8 bits per channel (usually
    32-bit float values), allowing a much wider dynamic range. As we know, the *dynamic
    range* of a scene is the contrast ratio between its brightest and darkest parts.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: HDR成像使用的是每个通道超过8位（通常是32位浮点值）的图像，这使得动态范围更广。正如我们所知，场景的**动态范围**是其最亮和最暗部分之间的对比度比。
- en: 'Let''s take a closer look at what the luminance values are of certain things
    that we can see. The following diagram shows values that we can easily see, from
    the dark sky (around *10^(-4) cd/m²*) to the sun during sunset (*10⁵ cd/m²*):'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看我们能看到的某些事物的亮度值。以下图表显示了我们可以轻松看到的值，从黑暗的天空（大约*10^(-4) cd/m²*）到日落时的太阳（*10⁵
    cd/m²*）：
- en: '![](img/f2981dc9-a73e-499b-bab2-4393ddf84700.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f2981dc9-a73e-499b-bab2-4393ddf84700.png)'
- en: We can see more than these values. Because some people can adjust their eyes
    to even darker places, we can definitely see the sun when it's not on the horizon
    but is higher up in the sky, probably up to *10⁸ cd/m²*, but this range is already
    quite a big range, so let's stick to it for now. For comparison, a usual 8-bit
    image has a contrast ratio of *256:1*, the human eye can see at one time around
    million to 1, and the 14-bit RAW format shows *2^(14):1*.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到的不仅仅是这些值。因为有些人可以调整他们的眼睛适应甚至更暗的地方，所以当太阳不在地平线上，而是在更高的天空时，我们肯定可以看到太阳，可能高达*10⁸
    cd/m²*，但这个范围已经相当大了，所以我们现在就坚持这个范围。为了比较，一个普通的8位图像对比度比为*256:1*，人眼一次可以看到大约百万到1的对比度，而14位RAW格式显示*2^(14):1*。
- en: 'Display media also have limitations; for example, a typical IPS monitor has
    a contrast ratio of around *1,000:1*, and a VA monitor could have a contrast ratio
    of up to *6,000:1*. So, let''s place these values on this spectrum and see how
    they compare:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 显示媒体也有局限性；例如，典型的IPS显示器对比度比约为*1,000:1*，而VA显示器对比度可能高达*6,000:1*。因此，让我们将这些值放在这个频谱上，看看它们是如何比较的：
- en: '![](img/42cafd44-1d8a-4f16-a98f-737a8c9a4532.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/42cafd44-1d8a-4f16-a98f-737a8c9a4532.png)'
- en: Now, this doesn't look like we can see much, which is true since it takes time
    for us to adjust to different lighting conditions. The same is true about a camera.
    But in just one glance, our naked eye can see quite a lot more than even the best
    camera can. *So how can we remedy this?*
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这看起来我们看不到多少，这是真的，因为我们需要时间来适应不同的光照条件。同样的情况也适用于相机。但仅仅一眼，我们的裸眼就能看到比最好的相机还能看到的东西更多。*那么我们该如何解决这个问题呢*？
- en: 'As we said, the trick is to take multiple pictures in quick succession, which
    most cameras allow with ease. If we were to take pictures in quick succession
    that complement each other, we could cover quite a big part of the spectrum with
    just five JPEGs:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所说的，技巧是快速连续拍摄多张照片，大多数相机都能轻松实现这一点。如果我们连续拍摄互补的照片，只需五张JPEG图片就能覆盖相当大的光谱范围：
- en: '![](img/3ddd82b2-79ca-437c-afe4-f86aa18ba231.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3ddd82b2-79ca-437c-afe4-f86aa18ba231.png)'
- en: 'This seems a little too easy, but remember, taking five pictures is quite easy.
    But, we are talking about one picture that has all the dynamic range, not five
    separate pictures. There are two big problems with HDR images:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来有点太简单了，但记住，拍摄五张照片相当容易。但是，我们谈论的是一张包含所有动态范围的图片，而不是五张单独的图片。HDR图像有两个主要问题：
- en: '*How can we combine multiple images into a single image?*'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*我们如何将多张图像合并成一张图像？*'
- en: '*How can we display an image that has a higher dynamic range than our display
    media?*'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*我们如何显示一个比我们的显示媒体动态范围更高的图像？*'
- en: However, even before we can combine those images, let's take a closer look at
    how can we vary the exposure of the camera, that is, its sensitivity to light.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们能够合并这些图像之前，让我们更仔细地看看我们如何可以改变相机的曝光，即其对光线的敏感度。
- en: Exploring ways to vary exposure
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索改变曝光的方法
- en: As we discussed earlier in this chapter, modern **Digital Single Lens Reflector**
    cameras (**DSLR**s), and other digital cameras as well, have a fixed sensor grid
    (usually placed as a Bayer filter), which just measures the light intensity of
    the camera.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章前面讨论的，现代**单镜头反光数码相机**（**DSLR**）以及其他数码相机，都有一个固定的传感器阵列（通常放置为拜耳滤镜），它只是测量相机的光强度。
- en: I bet you have seen the same camera used to capture beautiful night pictures
    where the water looks like a silky cloud and stills that sports photographers
    have taken of a player at full stretch. *So how can they use the same camera for
    such different settings and get results that we see on the screen?*
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我敢打赌，你见过同一个相机用来捕捉美丽的夜景，其中水面看起来像丝质云朵，以及体育摄影师拍摄的运动员全伸展的照片。*那么他们如何使用同一个相机在如此不同的设置中并获得我们在屏幕上看到的结果呢？*
- en: When measuring the exposure, it's really hard to measure the luminance that
    is being captured. It's a lot easier to measure relative speed instead of measuring
    luminance in the power of 10, which could be quite difficult to adjust. We measure
    the speed in the power of 2; we call that a **stop**.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在测量曝光时，很难测量被捕获的亮度。相对于以10的幂次测量亮度来说，测量相对速度要容易得多，这可能相当难以调整。我们以2的幂次来测量速度；我们称之为**档位**。
- en: The trick is that, even though the camera is restricted, it has to be able to
    capture a limited luminance range per picture. The range itself could be moved
    along the luminance spectrum. To overcome this, let's study the shutter speed,
    aperture, and ISO speed parameters of the camera.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这个技巧是，尽管相机受到限制，但它必须能够捕捉每张图片的有限亮度范围。这个范围本身可以在亮度光谱上移动。为了克服这一点，让我们研究相机的快门速度、光圈和ISO速度参数。
- en: Shutter speed
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快门速度
- en: Shutter speed is not really the speed of the shutter, but it's the length of
    time for which a camera's shutter is open when taking a photograph. Thus, it's
    the amount of time for which the digital sensor inside the camera is exposed to
    light for collecting information. It's the most intuitive control out of all the
    camera controls because we can feel it happening.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 快门速度并不是快门的速度，而是在拍照时相机快门开启的时间长度。因此，这是相机内部数字传感器暴露于光线以收集信息的时间长度。这是所有相机控制中最直观的一个，因为我们能感觉到它的发生。
- en: Shutter speeds are usually measured in fractions of a second. For example, *1/60*
    is the fastest speed for which, if we shake the camera while clicking photos while
    it is held in our hands, it doesn't introduce a blur in the photograph. So if
    you are going to use your own pictures, make sure to not do this, or get yourself
    a tripod.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 快门速度通常以秒的分数来衡量。例如，*1/60* 是最快的速度，如果我们手持相机拍照时摇晃相机，它不会在照片中引入模糊。所以如果你要使用自己的照片，确保不要这样做，或者准备一个三脚架。
- en: Aperture
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 光圈
- en: 'Aperture is the diameter of the hole in the optical lens through which the
    light passes into the camera. The following picture shows examples of the opening
    set to different aperture values:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 光圈是光学镜头中光线通过的孔的直径。以下图片展示了设置为不同光圈值的开口示例：
- en: '![](img/22395445-cfda-4e3e-b0d4-1392f3995960.jpeg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/22395445-cfda-4e3e-b0d4-1392f3995960.jpeg)'
- en: Image source—https://en.wikipedia.org/wiki/Aperture#/media/File:Lenses_with_different_apertures.jpg
    (CC SA 4.0)
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图片来源—https://en.wikipedia.org/wiki/Aperture#/media/File:Lenses_with_different_apertures.jpg
    (CC SA 4.0)
- en: 'Aperture is usually measured using an *f-number*. The f-number is the ratio
    of the system''s focal length to the diameter of the opening (the entrance pupil).
    We won''t concern ourselves with the focal length of the lens; the only thing
    we need to know is that only zoom lenses have variable focal lengths, thus if
    we don''t change the magnification on the lens, the focal length will stay the
    same. So we can measure the **area** of the entrance pupil by squaring the inverse
    of the **f-number**:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 光圈通常使用*f数*来衡量。f数是系统焦距与开口直径（入射光瞳）的比值。我们不会关心镜头的焦距；我们唯一需要知道的是，只有变焦镜头才有可变焦距，因此如果我们不改变镜头的放大倍数，焦距将保持不变。所以我们可以通过平方f数的倒数来测量入射光瞳的**面积**：
- en: '![](img/1ab9769f-3113-47dc-a35b-521a9a2552d2.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1ab9769f-3113-47dc-a35b-521a9a2552d2.png)'
- en: And, we know that the bigger the area, the more light we will get in our pictures.
    Thus, if we were to increase the f-number, that would correspond to a decrease
    in the size of the entrance pupil and our pictures would become darker, enabling
    us to take pictures during the afternoon.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们知道面积越大，我们图片中的光线就越多。因此，如果我们增加f数，这将对应于入射光瞳大小的减小，我们的图片会变暗，使我们能够在下午拍照。
- en: ISO speed
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ISO感光度
- en: ISO speed is the sensitivity of the sensors used in cameras. It is measured
    using numbers that map the sensitivity of the digital sensor to the chemical films
    that were used when computers were not around yet.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: ISO感光度是相机中使用的传感器的灵敏度。它使用数字来衡量数字传感器的灵敏度，这些数字对应于计算机出现之前使用的化学胶片。
- en: ISO speed is measured in two numbers; for example, *100/21°*, where the first
    number is the speed on the arithmetic scale and the second number is the number
    on the logarithmic scale. Since these numbers have a one-to-one mapping, usually
    the second one is omitted, and we simply write *ISO 100*. ISO 100 is two times
    less sensitive to light than ISO 200 and it is said that the difference is **1
    stop**.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: ISO感光度以两个数字来衡量；例如，*100/21°*，其中第一个数字是算术尺度上的速度，第二个数字是对数尺度上的数字。由于这些数字有一一对应的关系，通常省略第二个数字，我们简单地写成*ISO
    100*。ISO 100比ISO 200对光线的敏感度低两倍，据说这种差异是**1挡**。
- en: It is easier to talk in powers of 2 rather than powers of 10, so photographers
    came up with the notion of **stops**. One stop is two times different, 2 stops
    are 4 times different, and so on. Thus, *n* stops are *2^n* times different. This
    analogy has become so widespread that people have started using fractional and
    real numbers for stops.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 用2的幂次方来表示比用10的幂次方表示更容易，因此摄影师提出了**挡位**的概念。一挡是两倍不同，两挡是四倍不同，以此类推。因此，*n*挡是*2^n*倍不同。这种类比已经变得如此普遍，以至于人们开始使用分数和实数来表示挡位。
- en: Now that we understand how to control the exposure, let's try to look at the
    algorithms that can combine multiple pictures with different exposures into a
    single image.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何控制曝光，让我们来看看可以将多张不同曝光的图片组合成一张图片的算法。
- en: Generating HDR images using multiple exposure images
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用多曝光图片生成HDR图像
- en: Now, once we know how it's possible to get more pictures, we can take multiple
    photos that have very little or no overlapping dynamic range. Let's have a look
    at the most popular algorithm for HDR, first published by Paul E Debevec and Jitendra
    Malik in 2008.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一旦我们知道了如何获取更多的图片，我们就可以拍摄多张几乎没有重叠动态范围的图片。让我们先看看最流行的HDR算法，该算法最早由Paul E Debevec和Jitendra
    Malik于2008年发表。
- en: 'It turns out that if you want to have good results, you have to have pictures
    that are overlapping, to make sure you have good accuracy and since there is noise
    in the photos. It''s usually common to have 1, 2, or at most 3 stops difference
    from picture to picture. If we were to shoot five 8-bit photos with a difference
    of 3 stops, we would cover the human eye''s one million to one sensitivity ratio:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，如果你想得到好的结果，你需要有重叠的图片，以确保你有一个好的精度，因为照片中存在噪声。通常，图片之间的差异为1、2或最多3挡。如果我们拍摄五张8位图片，差异为3挡，我们将覆盖人眼一百万到一的敏感度比：
- en: '![](img/3359ab4c-0eaa-4fb3-b51c-c6985079210e.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3359ab4c-0eaa-4fb3-b51c-c6985079210e.png)'
- en: Now let's take a closer look at how the Debevec HDR algorithm works.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更详细地看看Debevec HDR算法是如何工作的。
- en: 'First, let''s assume that the recorded values the camera sees are some function
    of the scene''s irradiance. We talked about this being linear before, but nothing
    is truly linear in real life. Let the recorded value matrix be ***Z*** and the
    irradiance matrix be **X**; we have the following:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们假设相机看到的记录值是场景辐照度的某个函数。我们之前提到这应该是线性的，但现实生活中没有任何东西是完全线性的。让记录值矩阵为***Z***，辐照度矩阵为**X**；我们有以下内容：
- en: '![](img/cde2add2-a9a6-4caf-b1c1-634856164ae5.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cde2add2-a9a6-4caf-b1c1-634856164ae5.png)'
- en: 'Here, we have also used **Δt** as the measure of exposure time, and the function
    ***f*** is called the **response function** of our camera. Also, we assume that
    if we double the exposure and half the irradiance, we will have the same output
    and vice versa. This should be true across all images, and the value of ***E*** should
    not change from picture to picture; only the recorded values of ***Z*** and the
    exposure time **Δt** can change. If we apply the **inverse response function**(** *f^(-1)***)
    and take the logarithm of both sides, then we get that for all of the pictures(***i***)
    that we have:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '这里，我们也将**Δt**作为曝光时间的度量，函数***f***被称为我们相机的**响应函数**。我们还假设如果我们加倍曝光并减半辐照度，我们将得到相同的输出，反之亦然。这应该适用于所有图像，而***E***的值不应该从一张图片到另一张图片改变；只有***Z***的记录值和曝光时间**Δt**可以改变。如果我们应用**逆响应函数**(**
    *f^(-1)* **)并取两边的对数，那么我们得到对于所有我们有的图片(***i***):'
- en: '![](img/dde52fc9-57b0-487f-8e40-6e06e708d448.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dde52fc9-57b0-487f-8e40-6e06e708d448.png)'
- en: Now the trick is to come up with an algorithm that can calculate the ***f^(-1)***,
    and that's what Debevec et al. have done.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的技巧是提出一个可以计算***f^(-1)***的算法，这正是Debevec等人所做的事情。
- en: Of course, our pixel values are not going to follow this rule exactly, and we
    will have to fit an approximate solution, but, let's take a more detailed look
    at what these values are.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们的像素值不会完全遵循这个规则，我们不得不拟合一个近似解，但让我们更详细地看看这些值是什么。
- en: Before we move forward, let's take a look at how we can recover **Δt[i]** values
    from the picture files in the next section.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续前进之前，让我们看看如何在下一节中从图片文件中恢复**Δt[i]**值。
- en: Extracting exposure strength from images
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从图像中提取曝光强度
- en: 'Assuming the **principle of reciprocity** for all the camera parameters that
    we discussed previously, let''s try to come up with a function—`exposure_strength`—that
    returns a time equivalent to the exposure:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们之前讨论的所有相机参数都遵循**互易原理**，让我们尝试提出一个函数——`exposure_strength`——它返回一个等同于曝光时间的时长：
- en: 'First, let''s set a reference for ISO speed and f-stop:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们为ISO速度和光圈设置一个参考值：
- en: '[PRE15]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, let''s use the `exifread` Python package, which makes it easy to read
    the metadata associated with the images. Most modern cameras record the metadata
    in this standard format:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，让我们使用`exifread`Python包，它使得读取与图像关联的元数据变得容易。大多数现代相机以这种标准格式记录元数据：
- en: '[PRE16]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then, let''s extract the `f_stop` value and see how much bigger the entrance
    pupil area to the reference was:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，让我们提取`f_stop`值，看看参考的入射光瞳面积大多少：
- en: '[PRE17]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then, let''s see how much more sensitive the ISO setting was:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，让我们看看ISO设置更加敏感多少：
- en: '[PRE18]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Finally, let''s combine all the values with the shutter speed and return `exposure_time`:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们将所有值与快门速度结合，并返回`exposure_time`：
- en: '[PRE19]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here is an example of the values of the photographs that I am using for this
    demo, taken from the **Frozen River** photo collection:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是用于本演示的图片值示例，取自**Frozen River**图片集：
- en: '| **Photograph** | **Aperture** | **ISO Speed** | **Shutter Speed** |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| **照片** | **光圈** | **ISO速度** | **快门速度** |'
- en: '| AM5D5669.CR2 | 6 3/8 | 100 | 1/60 |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| AM5D5669.CR2 | 6 3/8 | 100 | 1/60 |'
- en: '| AM5D5670.CR2 | 6 3/8 | 100 | 1/250 |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| AM5D5670.CR2 | 6 3/8 | 100 | 1/250 |'
- en: '| AM5D5671.CR2 | 6 3/8 | 100 | 1/160 |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| AM5D5671.CR2 | 6 3/8 | 100 | 1/160 |'
- en: '| AM5D5672.CR2 | 6 3/8 | 100 | 1/100 |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| AM5D5672.CR2 | 6 3/8 | 100 | 1/100 |'
- en: '| AM5D5673.CR2 | 6 3/8 | 100 | 1/40 |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| AM5D5673.CR2 | 6 3/8 | 100 | 1/40 |'
- en: '| AM5D5674.CR2 | 6 3/8 | 160 | 1/40 |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| AM5D5674.CR2 | 6 3/8 | 160 | 1/40 |'
- en: '| AM5D5676.CR2 | 6 3/8 | 250 | 1/40 |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| AM5D5676.CR2 | 6 3/8 | 250 | 1/40 |'
- en: 'This is the output of the time estimates for these pictures using the `exposure_strength`
    function:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用`exposure_strength`函数对这些图片进行时间估计的输出：
- en: '[PRE20]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now, once we have the exposure times, let's see how this can be used to get
    the camera response function.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一旦我们有了曝光时间，让我们看看如何使用它来获取相机响应函数。
- en: Estimating the camera response function
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 估计相机响应函数
- en: 'Let''s plot ![](img/cbafee7e-4b86-48bc-9cab-fce681e46113.png) on the *y* axis,
    and **Z[i]** on the *x* axis:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在*Y*轴上绘制 ![](img/cbafee7e-4b86-48bc-9cab-fce681e46113.png)，在*x*轴上绘制**Z[i]**：
- en: '![](img/acd17978-8a98-4618-ad89-de957b72155a.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](img/acd17978-8a98-4618-ad89-de957b72155a.png)'
- en: 'What we are trying to do is to find an ***f^(-1)*** and, more importantly,
    the ![](img/d04631b2-e5aa-4874-b7b3-06192cc9d677.png) of all the pictures, such
    that when we add **log(E)** to the log exposure, we will have all the pixels on
    the same function. You can see the results of the Debevec algorithm in the following
    screenshot:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们试图找到一个**f^(-1)**，更重要的是，所有图片的 ![](img/d04631b2-e5aa-4874-b7b3-06192cc9d677.png)。这样，当我们把**log(E)**加到曝光的对数上时，我们将有所有像素在同一个函数上。你可以在下面的屏幕截图中看到Debevec算法的结果：
- en: '![](img/594d6332-a67a-4fc5-b877-afd67b331ccb.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](img/594d6332-a67a-4fc5-b877-afd67b331ccb.png)'
- en: The Debevec algorithm estimates both the ***f^(-1)***, which passes approximately
    through all the pixels, and the ![](img/d04631b2-e5aa-4874-b7b3-06192cc9d677.png).
    The ***E*** matrix is the resulting HDR image matrix that we recover.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Debevec算法估计了**f^(-1)**，它大约通过所有像素，以及 ![](img/d04631b2-e5aa-4874-b7b3-06192cc9d677.png)。**E**矩阵是我们恢复的HDR图像矩阵。
- en: Now let's take a look at how to implement this using OpenCV.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何使用OpenCV来实现这一点。
- en: Writing an HDR script using OpenCV
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用OpenCV编写HDR脚本
- en: 'The first step of the script is going to be setting up the script arguments
    using Python''s built-in `argparse` module:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本的第一个步骤将是使用Python内置的`argparse`模块设置脚本参数：
- en: '[PRE21]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As you can see, we have set up two mutually exclusive arguments—`--image-dir`,
    a directory that contains the images, and `--images`, a list of images that we
    are going to use. And we make sure that we populate `args.images` with the list
    of all the images, so the rest of the script shouldn't worry about which of the
    options the user has chosen.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们设置了两个互斥的参数—`--image-dir`，一个包含图像的目录，以及 `--images`，一个我们将要使用的图像列表。我们确保将所有图像的列表填充到`args.images`中，这样脚本的其他部分就不必担心用户选择了哪个选项。
- en: 'After we have all the command-line arguments, the rest of the procedure is
    as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们有了所有的命令行参数之后，接下来的步骤如下：
- en: 'Read all `images` into the memory:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有`images`读入内存：
- en: '[PRE22]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Read the metadata and estimate exposure times using `exposure_strength`:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`exposure_strength`读取元数据和估计曝光时间：
- en: '[PRE23]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Calculate the **camera response function**—`crf_debevec`:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算**相机响应函数**—`crf_debevec`：
- en: '[PRE24]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Use the camera response function to calculate the HDR image:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用相机响应函数来计算HDR图像：
- en: '[PRE25]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Notice that the HDR image is of type `float32` and not `uint8`, as it contains
    the full dynamic range of all exposure images.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到HDR图像是`float32`类型，而不是`uint8`，因为它包含了所有曝光图像的全动态范围。
- en: Now we have the HDR image and we've come to the next important part. Let's see
    how we can show the HDR image using our 8-bit image representation.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了HDR图像，我们已经来到了下一个重要部分。让我们看看我们如何使用我们的8位图像表示来显示HDR图像。
- en: Displaying HDR images
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示HDR图像
- en: Displaying HDR images is tricky. As we said, HDR has more values than the camera,
    so we need to figure out a way to display that. Luckily, OpenCV is here to help
    us again, and, as you've probably guessed by now, we can use gamma correction
    to map all the different values we have into a smaller spectrum of values in the
    range `0` to `255`. This process is called **Tone Mapping**.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 显示HDR图像很棘手。正如我们所说，HDR比相机有更多的值，所以我们需要找出一种方法来显示它。幸运的是，OpenCV在这里帮助我们，而且，正如你现在可能已经猜到的，我们可以使用伽玛校正将所有不同的值映射到范围`0`到`255`的较小值域中。这个过程被称为**色调映射**。
- en: 'OpenCV has a method for it that takes `gamma` as an argument:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV有一个方法可以做到这一点，它接受`gamma`作为参数：
- en: '[PRE26]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now we have to `clip` all the values to become integers:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们必须将所有值`clip`成整数：
- en: '[PRE27]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'After that, we can show our resulting HDR image using `pyplot`:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们可以使用`pyplot`显示我们的结果HDR图像：
- en: '[PRE28]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This results in the following gorgeous image:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这会产生以下令人惊叹的图像：
- en: '![](img/3bedf9ea-7f0e-4b41-a0cc-81602427037d.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3bedf9ea-7f0e-4b41-a0cc-81602427037d.png)'
- en: Now, let's see how can we extend the camera's field of view—potentially to 360
    degrees!
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何扩展相机的视野—可能到360度！
- en: Understanding panorama stitching
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解全景拼接
- en: Another very interesting topic in computational photography is **panorama stitching**.
    I'm sure most of you have a panorama function on your phone. This section will
    focus on the ideas behind panorama stitching and, instead of just calling a single
    function, we will go through all the steps involved in creating a panorama from
    a bunch of separate photos.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 计算摄影中另一个非常有趣的话题是**全景拼接**。我相信你们大多数人手机上都有全景功能。本节将专注于全景拼接背后的思想，而不仅仅是调用一个单独的函数，我们将通过所有创建全景所需的步骤。
- en: Writing script arguments and filtering images
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写脚本参数和过滤图像
- en: 'We want to write a script that will take a list of images and will produce
    a single panorama picture. So, let''s set up the `ArgumentParser` for our script:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要编写一个脚本，该脚本将接受一系列图像并生成一张单独的全景图。因此，让我们为我们的脚本设置`ArgumentParser`：
- en: '[PRE29]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Here, we created an instance of `ArgumentParser` and added arguments to pass
    either an image directory of a list of images. Then, we make sure we get all the
    images from the image directory if it is passed, instead of passing a list of
    images.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个`ArgumentParser`的实例并添加了参数，以便传递图像目录或图像列表。然后，我们确保如果传递了图像目录，我们获取所有图像，而不是传递图像列表。
- en: 'Now, as you can imagine, the next step is to use a feature extractor and see
    what the common features that images share are. This is very much like the previous
    two chapters, that is, [Chapter 3](905b17f6-8eea-4d33-9291-17ea93371f2d.xhtml), *Finding
    Objects via Feature Matching and Perspective Transforms,* and [Chapter 4](efb28928-4399-4e3d-9ca3-6e773aaaa699.xhtml),
    *3D Scene Reconstruction Using Structure from Motion*. We will also write a function
    to filter those images that have common features, so the script is even more versatile.
    Let''s go through the function step by step:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，正如你可以想象的那样，下一步是使用特征提取器并查看图像共享的共同特征。这非常类似于前两个章节，即[第3章](905b17f6-8eea-4d33-9291-17ea93371f2d.xhtml)，*通过特征匹配和透视变换寻找物体*和[第4章](efb28928-4399-4e3d-9ca3-6e773aaaa699.xhtml)，*使用运动结构进行3D场景重建*。我们还将编写一个函数来过滤具有共同特征的图像，这样脚本就更加灵活。让我们一步一步地通过这个函数：
- en: 'Create the `SURF` feature extractor and compute all of the features of all
    images:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`SURF`特征提取器并计算所有图像的所有特征：
- en: '[PRE30]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Create a `matcher` class that matches an image to its closest neighbors that
    share the most features:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`matcher`类，该类将图像与其最接近的邻居匹配，这些邻居共享最多的特征：
- en: '[PRE31]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Filter the images and make sure that we have at least two images that share
    features so we can proceed with the algorithm:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 过滤图像并确保我们至少有两个共享特征的图像，这样我们就可以继续算法：
- en: '[PRE32]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Run the `matcher` again to check whether we have removed any of the images
    and `return` the variables we will need in the future:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行`matcher`以检查我们是否删除了任何图像，并`返回`我们将来需要的变量：
- en: '[PRE33]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: After we have filtered the images and have all the features, we move on to the
    next step, which is setting up a blank canvas for the panorama stitching.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们过滤了图像并有了所有特征之后，我们继续下一步，即设置空白画布进行全景拼接。
- en: Figuring out relative positions and the final picture size
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确定相对位置和最终图片大小
- en: Once we have separated all the connected pictures and know all the features,
    it's time to figure out how big the merged panorama is going to be and create
    the blank canvas to start adding pictures to it. First, we need to find the parameters
    of the pictures.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们分离了所有连接的图片并知道了所有特征，就到了确定合并全景的大小并创建空白画布以开始添加图片的时候了。首先，我们需要找到图片的参数。
- en: Finding camera parameters
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 寻找相机参数
- en: 'In order to be able to merge images, we need to compute homography matrices
    of all the images and then use those to adjust the images so they can be merged
    together. We will write a function to do that:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够合并图像，我们需要计算所有图像的透视矩阵，然后使用这些矩阵调整图像，以便它们可以合并在一起。我们将编写一个函数来完成这项工作：
- en: 'First, we are going to create the `HomographyBasedEstimator()` function:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将创建`HomographyBasedEstimator()`函数：
- en: '[PRE34]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Once we have the `estimator`, for extracting all the camera parameters, we
    use the matched `features` from different images:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们有了`estimator`，用于提取所有相机参数，我们就使用来自不同图像的匹配`features`：
- en: '[PRE35]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We make sure the `R` matrices have the correct type:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们确保`R`矩阵具有正确的类型：
- en: '[PRE36]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Then, we `return` all the parameters:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们`返回`所有参数：
- en: '[PRE37]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: It is possible to make these parameters better using a refiner, for example,
    `cv2.detail_BundleAdjusterRay`, but we'll keep things simple for now.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用细化器（例如，`cv2.detail_BundleAdjusterRay`）来改进这些参数，但现在我们保持简单。
- en: Creating the canvas for the panorama
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建全景图的画布
- en: 'Now it''s time to create the canvas. For that, we create a `warper` object
    based on our desired rotation schema. For simplicity, let''s assume a planar model:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候创建画布了。为此，我们根据所需的旋转方案创建一个`warper`对象。为了简单起见，让我们假设一个平面模型：
- en: '[PRE38]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Then, we `enumerate` over all the connected images and get all the regions
    of interest in each of the images:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们`遍历`所有连接的图像，并获取每张图像中的所有感兴趣区域：
- en: '[PRE39]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Finally, we estimate the final `canvas_size` based on all regions of interest:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们根据所有感兴趣区域估计最终的`canvas_size`：
- en: '[PRE40]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Now, let's see how to use the canvas size to blend all the images together.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用画布大小来混合所有图像。
- en: Blending the images together
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 合并图像
- en: 'First, we create a `MultiBandBlender` object, which will help us merge images
    together. Instead of just picking values from one or the other image, `blender`
    will do interpolation between the available values:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个`MultiBandBlender`对象，这将帮助我们合并图像。`blender`不会仅仅从一张或另一张图像中选取值，而是会在可用的值之间进行插值：
- en: '[PRE41]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Then, for each of the connected images, we do the following:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，对于每个连接的图像，我们执行以下操作：
- en: 'We `warp` the image and get the `corner` locations:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们`warp`图像并获取`corner`位置：
- en: '[PRE42]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Then, calculate the `mask` of the image on the canvas:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，计算画布上图像的`mask`：
- en: '[PRE43]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'After that, convert the values into `np.int16` and `feed` it into `blender`:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，将值转换为`np.int16`并将其`feed`到`blender`中：
- en: '[PRE44]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'After that, we use the `blend` function on `blender`, to get the final `result`,
    and save it:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们在`blender`上使用`blend`函数来获取最终的`result`，并保存它：
- en: '[PRE45]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We can also scale the image down to 600 pixels wide and display it:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将图像缩小到600像素宽并显示：
- en: '[PRE46]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'When we use the images from [https://github.com/mamikonyana/yosemite-panorama](https://github.com/mamikonyana/yosemite-panorama), we
    have this wonderful panorama picture in the end:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用来自[https://github.com/mamikonyana/yosemite-panorama](https://github.com/mamikonyana/yosemite-panorama)的图像时，我们最终得到了这张精彩的全景图片：
- en: '![](img/a7a027a5-0cc3-4c62-a350-720fe117d104.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a7a027a5-0cc3-4c62-a350-720fe117d104.png)'
- en: You can see that it's not perfect and the white balance requires correcting
    from picture to picture, but this is a great start. In the next section, we will
    work on refining the stitching output.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到它并不完美，白平衡需要从一张图片到另一张图片进行校正，但这是一个很好的开始。在下一节中，我们将致力于改进拼接输出。
- en: Improving panorama stitching
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进全景拼接
- en: You can either play with the script that we already have and add or remove certain
    features (for example, you can add a white balance compensator, to make sure you
    have a smoother transition from one picture to another), or you can tweak other
    parameters to learn.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以玩弄我们已有的脚本，添加或删除某些功能（例如，你可以添加一个白平衡补偿器，以确保从一张图片到另一张图片的过渡更加平滑），或者调整其他参数来学习。
- en: 'But know this—when you need a quick panorama, OpenCV also has a handy `Stitcher`
    class that does most of what we have discussed already:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 但要知道——当你需要快速全景时，OpenCV还有一个方便的`Stitcher`类，它已经完成了我们讨论的大部分工作：
- en: '[PRE47]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This code snippet is probably a lot faster than uploading your photos to a panorama
    service to get a good picture—so enjoy creating panoramas!
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码片段可能比将你的照片上传到全景服务以获得好图片要快得多——所以享受创建全景吧！
- en: Don't forget to add some code to crop the panorama so it doesn't have black
    pixels!
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记添加一些代码来裁剪全景，以免出现黑色像素！
- en: Summary
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to take simple images that we can take from
    our cameras with limited abilities—either with limited dynamic range or limited
    field of view and use OpenCV to merge multiple images into a single one that is better
    than the original one.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用有限能力的相机拍摄简单的图像——无论是有限的动态范围还是有限的视野，然后使用OpenCV将多张图像合并成一张比原始图像更好的单张图像。
- en: We left you with three scripts that you could build upon. Most importantly,
    there are still a lot of features missing from `panorama.py`, and there are a
    lot of other HDR techniques. Best of all, it's possible to do HDR and panorama
    stitching at the same time. *Wouldn't it be splendid to just look around from
    the mountain top at sunset? Imagine that!*
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们留下了三个你可以在此基础上构建的脚本。最重要的是，`panorama.py`中仍然缺少很多功能，还有很多其他的HDR技术。最好的是，可以同时进行HDR和全景拼接。*想象一下，在日落时分从山顶四处张望，那将是多么美妙！*
- en: This was the last chapter about camera photography. The rest of this book will
    focus on video monitoring and applying machine learning techniques to image processing
    tasks.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这是关于相机摄影的最后一章。本书的其余部分将专注于视频监控并将机器学习技术应用于图像处理任务。
- en: In the next chapter, we will focus on tracking visually salient and moving objects
    in a scene. This will give you an understanding of how to deal with non-static
    scenes. We will also explore how we can make an algorithm focus on what's important
    in a scene quickly, which is a technique known to speed up object detection, object
    recognition, object tracking, and content-aware image editing.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将专注于跟踪场景中视觉上显著和移动的物体。这将帮助你了解如何处理非静态场景。我们还将探讨如何让算法快速关注场景中的重点，这是一种已知可以加速目标检测、目标识别、目标跟踪和内容感知图像编辑的技术。
- en: Further reading
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'There are a lot of other topics to explore in computational photography:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算摄影学中还有许多其他主题可以探索：
- en: It's especially worth taking a look at the **Exposure Fusion** technique developed
    by Tom Mertens, et al. The *Exposure fusion* article by Tom Mertens, Jan Kautz,
    and Frank Van Reeth, in Computer Graphics and Applications, 2007, Pacific Graphics
    2007, proceedings at 15th Pacific Conference on, pages 382–390, IEEE, 2007.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特别值得一看的是汤姆·梅滕斯等人开发的**曝光融合**技术。汤姆·梅滕斯、简·考茨和弗兰克·范·里特撰写的《曝光融合》文章，发表于《计算机图形学与应用》，2007年，太平洋图形学2007，第15届太平洋会议论文集，第382-390页，IEEE，2007年。
- en: The *Recovering High Dynamic Range Radiance Maps from Photographs* article by
    Paul E Debevec and Jitendra Malik, in ACM SIGGRAPH 2008 classes, 2008, page 31,
    ACM, 2008.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由保罗·E·德贝维克和吉滕德拉·马利克撰写的《从照片中恢复高动态范围辐射图》文章，收录于ACM SIGGRAPH 2008课程中，2008年，第31页，ACM，2008年。
- en: Attributions
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 归属
- en: The **Frozen River** photo collection can be found at [https://github.com/mamikonyana/frozen-river](https://github.com/mamikonyana/frozen-river) and
    is verified with a CC-BY-SA-4.0 license.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '**Frozen River** 照片集可在[https://github.com/mamikonyana/frozen-river](https://github.com/mamikonyana/frozen-river)找到，并经过CC-BY-SA-4.0许可验证。'
