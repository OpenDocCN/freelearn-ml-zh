- en: Chapter 7. Association Rules based learning
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章：基于关联规则的学习
- en: We have covered Decision tree, instance and kernel-based supervised and unsupervised
    learning methods in the previous chapters. We also explored the most commonly
    used algorithms across these learning algorithms in the previous chapters. In
    this chapter, we will cover association rule based learning and, in specific,
    Apriori and FP-Growth algorithms among others. We will learn the basics of this
    technique and get hands-on implementation guidance using Apache Mahout, R, Julia,
    Apache Spark, and Python. The following figure depicts different learning models
    covered in this book. The techniques highlighted in orange will be dealt with
    in detail in this chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我们已经介绍了决策树、实例和基于核的监督学习和无监督学习方法。在前几章中，我们还探讨了这些学习算法中最常用的算法。在本章中，我们将介绍基于关联规则的学习，特别是Apriori和FP-Growth算法等。我们将学习这项技术的基礎，并使用Apache
    Mahout、R、Julia、Apache Spark和Python等工具获得实际操作指导。以下图表展示了本书中涵盖的不同学习模型。本章将详细讨论橙色突出显示的技术。
- en: '![Association Rules based learning](img/B03980_07_01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![基于关联规则的学习](img/B03980_07_01.jpg)'
- en: 'The following topics are covered in depth in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章深入探讨了以下主题：
- en: Understanding the basics and core principles of association rules based learning
    models
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解基于关联规则学习模型的基礎和核心原理
- en: Core use cases for association rule such as the Market Basket problem
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关联规则的核心应用案例，例如市场篮子问题
- en: Key terms such as itemsets, lift, support, confidence and frequent itemsets,
    and rule generation techniques
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关键术语，如项集、提升度、支持度、置信度和频繁项集，以及规则生成技术
- en: A deep dive into association rule based algorithms such as Apriori and FP-Growth;
    comparing and contrasting Apriori and FP-Growth in the context of large datasets
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深入探讨基于关联规则的算法，如Apriori和FP-Growth；在大型数据集的背景下比较和对比Apriori和FP-Growth
- en: Overview and purpose of some advanced association rules concepts such as correlation
    and sequential rules
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些高级关联规则概念（如相关规则和序列规则）的概述和目的
- en: A sample implementation for Apache Mahout, R, Apache Spark, Julia and Python
    (scikit-learn) libraries and modules.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Apache Mahout、R、Apache Spark、Julia和Python（scikit-learn）库和模块的示例实现。
- en: Association rules based learning
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于关联规则的学习
- en: 'Association rule-based Machine learning deals with finding frequent patterns,
    associations, and transactions that can be used for classification and prediction
    requirements. The association rule based learning process is as follows: given
    a set of transactions, finding rules and using these rules to predict the occurrence
    of an item based on the occurrences of other items in the transaction is Association
    rule based learning. The following diagram represents the scope of Machine learning:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 基于关联规则的机器学习处理的是寻找频繁模式、关联和交易，这些可以用于分类和预测需求。基于关联规则的学习过程如下：给定一组交易，找到规则并使用这些规则根据交易中其他项目的发生来预测项目的发生是关联规则学习。以下图表表示了机器学习的范围：
- en: '![Association rules based learning](img/B03980_07_02.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![基于关联规则的学习](img/B03980_07_02.jpg)'
- en: Association rule – a definition
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关联规则——一个定义
- en: An association rule is a representation of a pattern that describes the probability
    with which an event occurs, given the occurrence of another event. Usually, the
    syntax for association rules follows the *if...then* statements that relate two
    sets of unrelated data from the repository. In short, it helps find the relationship
    between objects that are frequently used together. The goal of association rules
    is to find all the sets of items that have greater support than minimum support
    using the large dataset to predict the rules that have confidence greater than
    the minimum confidence. One of the most common examples where association rule
    is used is the Market Basket example. To elaborate the Market basket example,
    if a customer buys an iPad, he or she is likely to buy an iPad case as well.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 关联规则是对一个模式的表现，描述了在另一个事件发生的情况下，一个事件发生的概率。通常，关联规则的语法遵循*如果...那么*语句，这些语句将来自存储库的两个无关数据集联系起来。简而言之，它有助于找到经常一起使用的对象之间的关系。关联规则的目标是使用大数据集找到所有支持度大于最小支持度的项目集，以预测置信度大于最小置信度的规则。关联规则最常用的例子之一是市场篮子示例。为了详细说明市场篮子示例，如果一个顾客购买了iPad，那么他或她很可能也会购买iPad保护套。
- en: Two important criteria are used in association rules, **Support** and **Confidence**.
    Every association rule should have a minimum Confidence and minimum Support at
    the same time. This is usually user-defined.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 关联规则中使用两个重要标准，**支持度**和**置信度**。每个关联规则都应该同时具有最小置信度和最小支持度。这通常是用户定义的。
- en: Now, let's look at what Support, Confidence, and lift measures are. Let's consider
    the same example as explained previously, *If X then Y*. where *X* is buying an
    iPad and *Y* is buying an iPad case.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看支持度、置信度和提升度度量是什么。让我们考虑之前解释的相同例子，*如果 X 则 Y*，其中 *X* 是购买 iPad，*Y* 是购买 iPad
    case。
- en: Then Support is defined as the frequency with which *X* and *Y* are purchased
    together over the total number of purchases or transactions.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，支持度定义为在所有购买或交易次数中，*X* 和 *Y* 一起购买的总频率。
- en: '![Association rule – a definition](img/B03980_07_13.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![关联规则 – 定义](img/B03980_07_13.jpg)'
- en: Confidence can be defined as the frequency with which *X* and *Y* are purchased
    together over the frequency with which *X* is purchased in isolation.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 置信度可以定义为 *X* 和 *Y* 一起购买的频率与 *X* 单独购买的频率之比。
- en: '![Association rule – a definition](img/B03980_07_14.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![关联规则 – 定义](img/B03980_07_14.jpg)'
- en: Lift is defined as the Support over the Support for *X* times the Support for
    *Y*.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 提升度定义为 *X* 的支持度除以 *X* 的支持度乘以 *Y* 的支持度。
- en: '![Association rule – a definition](img/B03980_07_15.jpg)![Association rule
    – a definition](img/B03980_07_03.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![关联规则 – 定义](img/B03980_07_15.jpg)![关联规则 – 定义](img/B03980_07_03.jpg)'
- en: Before understanding the significance of these measures, let's look at the terms
    used in this context as an example. A collection of items in a warehouse called
    itemset are represented as *I = { i[1], i[2], …. i[n]}*, a set of all transactions
    where each transaction consists of a subset of itemset is represented as *T =
    { t[1], t[2], …. t[n]}*, where *t*[x] is a subset of *I* with a **Unique Transaction
    Identifier** (**UTI**).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在理解这些度量的重要性之前，让我们以一个例子来看看这个上下文中使用的术语。仓库中物品的集合称为项集，表示为 *I = { i[1], i[2], ….
    i[n]}*，所有交易的集合，其中每个交易由项集的子集组成，表示为 *T = { t[1], t[2], …. t[n]}*，其中 *t*[x] 是 *I*
    的一个具有**唯一交易标识符**（**UTI**）的子集。
- en: Let's represent items, transactions, and measures using an example now.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们用一个例子来表示物品、交易和度量。
- en: 'Consider five items and five transactions as depicted here:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑五个项目和五个交易，如图所示：
- en: '*I = {iPad(A), iPad case(B), iPad scratch guard(C), Apple care (D), iPhone
    (E)}*'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*I = {iPad(A), iPad case(B), iPad scratch guard(C), Apple care (D), iPhone
    (E)}*'
- en: '![Association rule – a definition](img/B03980_07_04.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![关联规则 – 定义](img/B03980_07_04.jpg)'
- en: '*T = {{ iPad, iPad case, iPad scratch guard }, { iPad, iPad scratch guard,
    Apple care }, { iPad case, iPad scratch guard, Apple care }, { iPad, Apple care,
    iPhone }, { iPad case, iPad scratch guard, iPhone }}*'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*T = {{ iPad, iPad case, iPad scratch guard }, { iPad, iPad scratch guard,
    Apple care }, { iPad case, iPad scratch guard, Apple care }, { iPad, Apple care,
    iPhone }, { iPad case, iPad scratch guard, iPhone }}*'
- en: The table below shows the support, confidence and lift values for each of the
    identified rules.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 下表显示了每个识别出的规则的支持度、置信度和提升度值。
- en: '| # | Rule | Support | Confidence | Lift |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| # | 规则 | 支持度 | 置信度 | 提升度 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| **1** | If iPad (*A*) is purchased, iPhone (*D*) is also purchased | 2/5
    | 2/3 | 10/9 |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| **1** | 如果购买 iPad (*A*)，则也会购买 iPhone (*D*) | 2/5 | 2/3 | 10/9 |'
- en: '| **2** | If iPad scratch guard(*C*) is purchased, iPad (*A*) is also purchased
    | 2/5 | 2/4 | 5/6 |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| **2** | 如果购买 iPad scratch guard(*C*)，则也会购买 iPad (*A*) | 2/5 | 2/4 | 5/6 |'
- en: '| **3** | If iPad (*A*) is purchased, iPad scratch guard (*C*) is also purchased
    | 2/5 | 2/3 | 5/6 |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| **3** | 如果购买 iPad (*A*)，则也会购买 iPad scratch guard (*C*) | 2/5 | 2/3 | 5/6
    |'
- en: '| **4** | If iPad case(*B*) and iPad scratch guard (*C*) are purchased, then
    apple care (*D*) is also purchased | 1/5 | 1/3 | 5/9 |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| **4** | 如果购买 iPad case(*B*) 和 iPad scratch guard (*C*)，则也会购买 apple care (*D*)
    | 1/5 | 1/3 | 5/9 |'
- en: 'From these itemsets, based on the support and confidence computations, frequent
    itemset(s) can be determined. The goal of association rule mining is to find the
    rules that satisfy the criteria given here:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些项集中，基于支持和置信度的计算，可以确定频繁项集。关联规则挖掘的目的是找到满足以下标准的规则：
- en: support ≥ minsup (minimum support) threshold
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持度 ≥ 最小支持度（minsup）阈值
- en: confidence ≥ minconf (minimum confidence) threshold
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 置信度 ≥ 最小置信度（minconf）阈值
- en: 'The following are the steps involved in frequent itemset generation and mining
    association rules:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 频繁项集生成和关联规则挖掘涉及以下步骤：
- en: List all the possible association rules.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出所有可能的关联规则。
- en: Compute the support and confidence for each rule.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算每个规则的支撑度和置信度。
- en: Prune the rules that fail to satisfy the minsup and minconf threshold values.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除不满足最小支持度(minsup)和最小置信度(minconf)阈值值的规则。
- en: This approach is called the brute force approach and is usually known to be
    computationally prohibitive.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法称为暴力方法，通常被认为是计算上不可行的。
- en: Tip
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Rules originating from the same itemset usually have the same support, but vary
    with confidence. The minimum support (minsup) and the minimum confidence (minconf)
    are the values that are agreed upon during the problem definition statement. For
    example, minimum support and confidence can take percentage values like 75% and
    85% respectively.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 来自同一项集的规则通常具有相同的支撑度，但置信度不同。最小支持度(minsup)和最小置信度(minconf)是在问题定义陈述中达成一致的价值。例如，最小支持度和置信度可以取百分比值，如75%和85%。
- en: 'To avoid all expensive computations, we can simplify this process into two
    steps:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免所有昂贵的计算，我们可以将这个过程简化为两个步骤：
- en: '**Frequent itemset generation**: This requires generating all the itemsets
    with support ≥ minsup'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**频繁项集生成**：这需要生成所有支持度 ≥ minsup 的项集'
- en: '**Rule generation**: From the identified frequent itemsets, generate rules
    with the highest confidence'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**规则生成**：从识别出的频繁项集中生成置信度最高的规则'
- en: 'When there are five items, there are 32 candidate itemsets. The following figure
    depicts the itemset combination for five items: **A**, **B**, **C**, **D**, and
    **E**:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当有五个项目时，有32个候选项集。以下图显示了五个项目的项集组合：**A**、**B**、**C**、**D**和**E**：
- en: '![Association rule – a definition](img/B03980_07_05.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![关联规则 – 定义](img/B03980_07_05.jpg)'
- en: 'The possible number of itemsets and rules, given the number of items is defined
    here:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 给定项目数量，可能的项集和规则数量在此定义：
- en: 'Given *d* unique items:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 给定*d*个唯一项目：
- en: '*Total number of possible itemsets = 2*^d'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*可能的项集总数 = 2^d*'
- en: 'The standard formula for computing total possible association rules is defined
    here:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 计算总可能关联规则的标准公式在此定义：
- en: '![Association rule – a definition](img/B03980_07_16.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![关联规则 – 定义](img/B03980_07_16.jpg)'
- en: For example, if *d* is equivalent to 6, then the *total number of possible itemsets
    = 2*^d *= 64*
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果*d*等于6，那么*可能的项集总数 = 2^d* = 64
- en: Thus, the *total number of possible association rules = 602 rules*
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，*可能的关联规则总数 = 602条规则*
- en: The following graph shows the relationship between the number of items and possible
    association rules.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了项目数量与可能的关联规则之间的关系。
- en: '![Association rule – a definition](img/B03980_07_06.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![关联规则 – 定义](img/B03980_07_06.jpg)'
- en: Efficient ways of generating frequent itemsets and association rules determine
    the efficiency of the association rule algorithms. In the next sections, we will
    cover the Apriori and FP-Growth algorithms in detail.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 生成频繁项集和关联规则的高效方法决定了关联规则算法的效率。在接下来的章节中，我们将详细介绍Apriori和FP-Growth算法。
- en: Apriori algorithm
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Apriori算法
- en: 'In this section, we will cover the Apriori algorithm step-by-step using an
    example. The Apriori algorithm is as stated here:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过一个示例逐步介绍Apriori算法。Apriori算法如下所述：
- en: '![Apriori algorithm](img/B03980_07_07.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![Apriori算法](img/B03980_07_07.jpg)'
- en: Tip
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Apriori principle—for all the frequent itemsets, the subsets must also be frequent.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Apriori原理——对于所有频繁项集，其子集也必须是频繁的。
- en: Consider the five items (from the example in the previous section)
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑前一个示例中的五个项目
- en: '*I = {iPad(A), iPad case(B), iPad scratch guard(C), Apple care (D), iPhone
    (E)}*, and the following nine transactions. Let''s assume that the minimum Support
    count is two:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*I = {iPad(A), iPad case(B), iPad scratch guard(C), Apple care (D), iPhone
    (E)}*，以下九个事务。假设最小支持度计数为两个：'
- en: '| TID | The purpose or meaning in the context of Machine learning |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| TID | 在机器学习中的目的或意义 |'
- en: '| --- | --- |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| **1** | iPad(*A*), iPad case(*B*), and iPhone(*E*) |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| **1** | iPad(*A*)、iPad case(*B*)和iPhone(*E*) |'
- en: '| **2** | iPad case(*B*) and Apple care(*D*) |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| **2** | iPad case(*B*)和Apple care(*D*) |'
- en: '| **3** | iPad case(*B*) and iPad scratch guard(*C*) |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| **3** | iPad case(*B*)和iPad scratch guard(*C*) |'
- en: '| **4** | iPad(*A*), iPad case(*B*), and Apple care(*D*) |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| **4** | iPad(*A*)、iPad case(*B*)和Apple care(*D*) |'
- en: '| **5** | iPad(*A*) and Apple care(*D*) |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| **5** | iPad(*A*)和Apple care(*D*) |'
- en: '| **6** | iPad case(*B*) and iPad scratch guard(*C*) |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| **6** | iPad case(*B*)和iPad scratch guard(*C*) |'
- en: '| **7** | iPad(*A*) and Apple care(*D*) |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| **7** | iPad(*A*)和Apple care(*D*) |'
- en: '| **8** | iPad(*A*), iPad case(*B*), iPad scratch guard(*C*), and iPhone (*E*)
    |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| **8** | iPad(*A*)、iPad case(*B*)、iPad scratch guard(*C*)和iPhone (*E*) |'
- en: '| **9** | iPad(*A*), iPad case(*B*), and iPad scratch guard(*C*) |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
- en: 'Let''s debug the previous algorithm using the previous datasets:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: 'Get the number of occurrences for each item from the previous transactions
    (*C*[1]):'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| Itemset | Support count |'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| *{iPad(A)}* | 6 |'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| *{iPad case(B)}* | 7 |'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| *{iPad scratch guard(C)}* | 6 |'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| *{Apple care(D)}* | 2 |'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| *{iPhone(E)}* | 2 |'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: 'Determine Frequent 1—Itemsets (*L*[1]) from *C*[1]:'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '| Itemset | Support count |'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| *{iPad(A)}* | 6 |'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| *{iPad case(B)}* | 7 |'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| *{iPad scratch guard(C)}* | 6 |'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| *{Apple care(D)}* | 2 |'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| *{iPhone(E)}* | 2 |'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: 'Generate 2—Itemset candidates (*C*[2]) and scan the dataset for Support count:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| Itemset | Support count |'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| *{iPad(A), iPad case(B)}* | 4 |'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| *{iPad(A), iPad scratch guard(C)}* | 4 |'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| *{iPad(A), Apple care(D)}* | 1 |'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| *{iPad(A), iPhone(E)}* | 2 |'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| *{iPad case(B), iPad scratch guard(C)}* | 4 |'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| *{iPad case(B), Apple care(D)}* | 2 |'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| *{iPad case(B), iPhone(E)}* | 2 |'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| *{iPad scratch guard(C), Apple care(D)}* | 0 |'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| *{iPad scratch guard(C), iPhone(E)}* | 1 |'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| *{Apple care(D), iPhone(E)}* | 0 |'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: 'Determine Frequent 2—Itemsets (*L*[2]) from *C*[2]:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| Itemset | Support count |'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| *{iPad(A), iPad case(B)}* | 4 |'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| *{iPad(A), iPad scratch guard(C)}* | 4 |'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| *{iPad(A), Apple care(D)}* | 2 |'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| *{iPad case(B), iPad scratch guard(C)}* | 4 |'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| *{iPad case(B), Apple care(D)}* | 2 |'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| *{iPad case(B), iPhone(E)}* | 2 |'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: Generate 3—Itemset candidates (*C*[3]).
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, scan the dataset for Support count and frequent 3—Itemset identification.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is similar to the previously followed steps, but we will demonstrate how
    pruning can be applied to identify the frequent itemset, based on the Apriori
    principle effectively. First, we identify the possible subset itemsets. We then
    check whether there are any of the subset itemsets that do not belong to the frequent
    itemset list. If not found, we eliminate that 3—Itemset possibility.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '| C3 | Itemset | Possible subset itemsets |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
- en: '| **1**✓ | *{A,B,C}* | *{A,B}*✓ | *{A,C}*✓ | *{B,C}*✓ |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
- en: '| **2**✓ | *{A,B,D}* | *{A,B}*✓ | *{A,D}*✓ | *{B,D}*✓ |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
- en: '| **3**✕ | *{A,C,D}* | *{A,C}*✓ | *{A,D}*✓ | *{C,D}*✕ |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
- en: '| **4**✕ | *{B,C,D}* | *{B,C}*✓ | *{B,D}*✓ | *{C,D}*✕ |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
- en: '| **5**✕ | *{B,C,E}* | *{B,C}*✓ | *{B,E}*✕ | *{C,E}*✕ |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
- en: '| **6**✕ | *{B,D,E}* | *{B,D}*✓ | *{B,E}*✕ | *{D,E}*✕ |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
- en: 'In the previous table, the ✕ itemsets are pruned using the Apriori technique,
    and the data from step 4 (*L*[2]) is used. The itemsets are represented using
    the item codes *A*, *B*, *C*, *D*, and *E* instead of the actual names for ease
    of understanding. The 3—itemset candidates can be identified as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '| C[3] | Itemset | Support Count |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
- en: '| **1** | *{iPad(A), iPad case (B), iPad scratch guard(C)}* | 2 |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
- en: '| **2** | *{iPad(A), iPad case (B), Apple care(C)}* | 2 |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
- en: 'Thus, the Frequent 3—Itemsets are:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '| L[3] | Itemset | Support Count |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
- en: '| **1** | *{iPad(A), iPad case (B), iPad scratch guard(C)}* | 2 |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| **1** | *{iPad(A), iPad case (B), iPad scratch guard(C)}* | 2 |'
- en: '| **2** | *{iPad(A), iPad case (B), Apple care(C)}* | 2 |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| **2** | *{iPad(A), iPad case (B), Apple care(C)}* | 2 |'
- en: Generate 4— Itemset candidates (*C*[4]).
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成4-项集候选（*C*[4]）。
- en: Finally, scan the dataset for the Support count and frequent 3—Itemset identification
    (*L*[4]).
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，扫描数据集以获取支持度计数和频繁3-项集识别（*L*[4]）。
- en: As we can see, the pruning stops here, as there are no further *C*[3] options
    available.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，剪枝在这里停止，因为没有更多的 *C*[3] 选项可用。
- en: 'The Apriori algorithm is not efficient as it requires multiple dataset scans.
    However, there are some techniques to improve the efficiency. Some of them are
    as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Apriori算法效率不高，因为它需要多次数据集扫描。然而，有一些技术可以提高效率。以下是一些方法：
- en: If a transaction does not contain any frequent item-sets, it is not useful and
    need not participate in the subsequent scans
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个事务不包含任何频繁项集，则它没有用，不需要参与后续扫描
- en: Any itemset that is frequent in the dataset should be frequent in at least one
    partition of the dataset
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何在数据集中频繁出现的项集至少应该在数据集的一个分区中频繁出现
- en: Application of sampling, to include a subset of the whole data set with a lower
    support threshold, will yield more efficiency
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用采样，包括整个数据集的一个子集，具有较低的支持度阈值，将提高效率
- en: Rule generation strategy
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 规则生成策略
- en: 'Let''s say we have a frequent itemset *{A, B, C, D}*, and the possible candidate
    rules are:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个频繁项集 *{A, B, C, D}*，可能的候选规则如下：
- en: ABC→D
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: ABC→D
- en: ABD→C
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: ABD→C
- en: ACD→B
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: ACD→B
- en: BCD→A
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: BCD→A
- en: AB→CD
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: AB→CD
- en: AC→BD
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: AC→BD
- en: AD→BC
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: AD→BC
- en: BC→AD
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: BC→AD
- en: BD→AC
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: BD→AC
- en: CD→AB
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: CD→AB
- en: A→BCD
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: A→BCD
- en: B→ACD
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: B→ACD
- en: C→ABD
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: C→ABD
- en: D→ABC
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: D→ABC
- en: 'The standard formula is, for every k items in the frequent itemset, *2k-2*
    possible candidate rules can be defined. Only the rules with high confidence can
    be retained. The following figure depicts marking the low confidence rules and
    knocking them off:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 标准公式是，对于频繁项集中的每个k个项，可以定义 *2k-2* 个可能的候选规则。只有具有高置信度的规则可以保留。以下图示了标记低置信度规则并去除它们：
- en: '![Rule generation strategy](img/B03980_07_08.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![规则生成策略](img/B03980_07_08.jpg)'
- en: Rules for defining appropriate minsup
  id: totrans-164
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 定义适当最小支持度的规则
- en: 'Some important guidelines to be followed for defining the minsup threshold
    for the association rule based mining are as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义基于关联规则挖掘的最小支持度阈值时，需要遵循的一些重要指南如下：
- en: 'Too high minsup: This will lead to missing itemsets with rare items'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小支持度太高：这将导致丢失包含稀有物品的项集
- en: 'Too low minsup: This will result in computational expense as more scans will
    be needed'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小支持度太低：这将导致计算开销，因为需要更多的扫描
- en: Apriori – the downside
  id: totrans-168
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Apriori – 不足之处
- en: It is now clear that in Apriori algorithm, for every *k* itemsets we will need
    to use *(k-1)* frequent itemsets and when the database scans are done, the pattern
    matching approach is used. The primary bottlenecks are two huge candidate sets
    and multiple database scans. Let's see an example—if there are 10⁴ frequent 1-itemsets,
    then this will result in 10⁷ candidate 2-itemsets. And for every *n* itemsets,
    the longest pattern length, *n + 1* scans are required.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在很清楚，在Apriori算法中，对于每个 *k* 项集，我们都需要使用 *(k-1)* 个频繁项集，当数据库扫描完成后，使用模式匹配方法。主要瓶颈是两个巨大的候选集和多次数据库扫描。让我们看看一个例子——如果有10⁴个频繁1项集，那么这将导致10⁷个候选2项集。并且对于每个
    *n* 项集，需要 *n + 1* 次扫描。
- en: The solution for this would be to avoid the candidate itemset generation completely,
    and one way of solving this is to compress a large dataset or database into a
    compact **frequent pattern tree** (**FP-tree**) that will avoid expensive scans.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法是完全避免候选项集的生成，一种解决方法是将大型数据集或数据库压缩成一个紧凑的**频繁模式树**（**FP-tree**），这将避免昂贵的扫描。
- en: 'There are several ways of optimizing the Apriori implementation and here are
    some of the important ones:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以优化Apriori实现，以下是一些重要的方法：
- en: '**Approach 1**—**Has-based itemset counting**: There is a threshold value set
    for every k itemset bucket, and if the count of the itemset for that itemset is
    lower than the threshold, this bucket will not be processed. This in-turn reduces
    the itemset buckets that are to be considered for processing, thus improving the
    efficiency.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方法1**—**基于项集计数的近似方法**：为每个k项集桶设置一个阈值，如果该项集的计数低于阈值，则该桶将不会处理。这反过来减少了需要考虑处理的项集桶，从而提高了效率。'
- en: '**Approach 2**—**Transaction elimination / counting**: In case a transaction
    does not contain the target k itemset, this transaction does not add value or
    make sense for being processed. So, this approach is about identifying these transactions
    and eliminating them from being processed.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方法2**—**事务消除/计数**：如果一个事务不包含目标k项集，则该事务不会增加价值或没有意义进行处理。因此，这种方法是识别这些事务并将它们从处理中排除。'
- en: '**Approach 3**—**Partitioning**: Any itemset that is potentially frequent in
    the dataset will need to be frequent in the partitions of the dataset as well;
    in the absence of which, the itemset could potentially be excluded from being
    processed.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方法3**—**分区**：任何在数据集中可能频繁的项集也必须在数据集的分区中频繁；否则，项集可能会被排除在处理之外。'
- en: '**Approach 4**—**Sampling**: This is a simpler way to consider a sample or
    a subset of the bigger universe of data and run the mining process. This would
    reduce the k, and thus the frequent k-itemsets.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方法4**—**采样**：这是一种考虑样本或大数据集子集的更简单方法，并运行挖掘过程。这将减少k值，从而减少频繁k项集。'
- en: '**Approach 5**—**Dynamic itemset counting**: This is one of the most effective
    methods, and involves including a new itemset only if it is frequent in all its
    subset itemsets.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方法5**—**动态项集计数**：这是最有效的方法之一，它只在新项集在其所有子项集中频繁时才包括新项集。'
- en: Although, there are optimization techniques for Apriori; it poses inefficiency
    as a result of expensive scans that are inherent, which will need to be addressed.
    This brings us to the next algorithm of association rule based learning, the **FP-growth**
    algorithm.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Apriori有优化技术；但它由于固有的昂贵扫描而效率低下，这需要解决。这使我们来到了基于关联规则学习的下一个算法，即**FP-growth**算法。
- en: FP-growth algorithm
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FP-growth算法
- en: 'The FP-growth algorithm is an efficient and scalable alternative to mining
    frequent patterns, and thus association rule mining. It addresses most of the
    performance bottlenecks that an Apriori algorithm would undergo. It allows frequent
    itemset generation without having to actually generate the candidate itemsets.
    This algorithm has two steps primarily:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: FP-growth算法是一种高效且可扩展的挖掘频繁模式、从而关联规则挖掘的替代方法。它解决了Apriori算法可能遇到的大部分性能瓶颈。它允许在不实际生成候选项集的情况下生成频繁项集。此算法主要有两个步骤：
- en: Building a compact data structure from the database called FP-tree
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从数据库中构建紧凑的数据结构称为FP树
- en: Extracting frequent itemsets directly from the FP-tree
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接从FP树中提取频繁项集
- en: 'Let''s consider the same example we used in the Apriori algorithm. There is
    a total of five items (from the example in the previous section):'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑与Apriori算法中使用的相同示例。总共有五个项目（来自上一节中的示例）：
- en: '*I is {iPad(A), iPad case(B), iPad scratch guard(C), Apple care (D), iPhone
    (E)}*, and the following nine transactions. Let''s assume that the minimum support
    count is two:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '*I是{iPad(A), iPad保护壳(B), iPad防刮保护膜(C), Apple Care (D), iPhone (E)}*，以及以下九个事务。假设最小支持计数为二：'
- en: '| TID | Transaction Itemsets |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| TID | 事务项集 |'
- en: '| --- | --- |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| **1** | *iPad(A), iPad case(B), and iPhone(E)* |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| **1** | *iPad(A), iPad保护壳(B), 和iPhone(E)* |'
- en: '| **2** | *iPad case(B), Apple care(D)* |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| **2** | *iPad保护壳(B), Apple Care(D)* |'
- en: '| **3** | *iPad case(B), iPad scratch guard(C)* |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| **3** | *iPad保护壳(B), iPad防刮保护膜(C)* |'
- en: '| **4** | *iPad(A), iPad case(B), and Apple care(D)* |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| **4** | *iPad(A), iPad保护壳(B), 和Apple Care(D)* |'
- en: '| **5** | *iPad(A), Apple care(D)* |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| **5** | *iPad(A), Apple Care(D)* |'
- en: '| **6** | *iPad case(B), iPad scratch guard(C)* |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| **6** | *iPad保护壳(B), iPad防刮保护膜(C)* |'
- en: '| **7** | *iPad(A), Apple care(D)* |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| **7** | *iPad(A), Apple Care(D)* |'
- en: '| **8** | *iPad(A), iPad case(B), iPad scratch guard(C), and iPhone (E)* |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| **8** | *iPad(A), iPad保护壳(B), iPad防刮保护膜(C), 和iPhone (E)* |'
- en: '| **9** | *iPad(A), iPad case(B), and iPad scratch guard(C)* |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| **9** | *iPad(A), iPad保护壳(B), 和iPad防刮保护膜(C)* |'
- en: 'We will now look at building an FP-tree for this database:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将查看为该数据库构建FP树：
- en: 'Identify/calculate the minimum support count. Since it needs to be 30%, the
    minimum support count is calculated as follows:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 识别/计算最小支持计数。由于需要30%，最小支持计数计算如下：
- en: Minimum support count = 30/100 * 9 = 2.7 ~ 3
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最小支持计数 = 30/100 * 9 = 2.7 ~ 3
- en: 'Calculate the frequency of occurrence for 1-itemset. Additionally, based on
    the support count, add priority:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算单项集的出现频率。此外，根据支持计数，添加优先级：
- en: '| Itemset | Support count | Priority |'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 项集 | 支持计数 | 优先级 |'
- en: '| --- | --- | --- |'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| *{iPad(A)}* | 6 | 2 |'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| *{iPad(A)}* | 6 | 2 |'
- en: '| *{iPad case(B)}* | 7 | 1 |'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| *{iPad保护壳(B)}* | 7 | 1 |'
- en: '| *{iPad scratch guard(C)}* | 6 | 3 |'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| *{iPad防刮保护膜(C)}* | 6 | 3 |'
- en: '| *{Apple care(D)}* | 2 | 4 |'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| *{Apple care(D)}* | 2 | 4 |'
- en: '| *{iPhone(E)}* | 2 | 5 |'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| *{iPhone(E)}* | 2 | 5 |'
- en: 'Order the items for each transaction as per the priority:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据优先级对每笔交易的物品进行排序：
- en: '| TID | Transaction Itemsets | Re-ordered Itemsets based on priority |'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| TID | 交易项集 | 根据优先级重新排序的项集 |'
- en: '| --- | --- | --- |'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| **1** | iPad(*A*), iPad case(*B*), and iPhone(*E*) | iPad case(*B*), iPad(*A*),
    and iPhone(*E*) |'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| **1** | iPad(*A*)，iPad保护壳(*B*), 以及iPhone(*E*) | iPad保护壳(*B*), iPad(*A*),
    以及iPhone(*E*) |'
- en: '| **2** | iPad case(*B*), Apple care(*D*) | iPad case(*B*), Apple care(*D*)
    |'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| **2** | iPad保护壳(*B*), Apple care(*D*) | iPad保护壳(*B*), Apple care(*D*) |'
- en: '| **3** | iPad case(*B*), iPad scratch guard(*C*) | iPad case(*B*), iPad scratch
    guard(*C*) |'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| **3** | iPad保护壳(*B*)，iPad防刮保护膜(*C*) | iPad保护壳(*B*)，iPad防刮保护膜(*C*) |'
- en: '| **4** | iPad(*A*), iPad case(*B*), and Apple care(*D*) | iPad case(*B*),
    iPad(*A*), and Apple care(*D*) |'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| **4** | iPad(*A*)，iPad保护壳(*B*)，以及Apple care(*D*) | iPad保护壳(*B*)，iPad(*A*)，以及Apple
    care(*D*) |'
- en: '| **5** | iPad(*A*), Apple care(*D*) | iPad(*A*), Apple care(*D*) |'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| **5** | iPad(*A*)，Apple care(*D*) | iPad(*A*)，Apple care(*D*) |'
- en: '| **6** | iPad case(*B*), iPad scratch guard(*C*) | iPad case(*B*), iPad scratch
    guard(*C*) |'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| **6** | iPad保护壳(*B*), iPad防刮保护膜(*C*) | iPad保护壳(*B*), iPad防刮保护膜(*C*) |'
- en: '| **7** | iPad(*A*), Apple care(*D*) | iPad(*A*), Apple care(*D*) |'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| **7** | iPad(*A*)，Apple care(*D*) | iPad(*A*)，Apple care(*D*) |'
- en: '| **8** | iPad(*A*), iPad case(*B*), iPad scratch guard(*C*), and iPhone (*E*)
    | iPad case(*B*), iPad(*A*), iPad scratch guard(*C*), and iPhone (*E*) |'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| **8** | iPad(*A*)，iPad保护壳(*B*)，iPad防刮保护膜(*C*)，以及iPhone (*E*) | iPad保护壳(*B*),
    iPad(*A*), iPad防刮保护膜(*C*), 以及iPhone (*E*) |'
- en: '| **9** | iPad(*A*), iPad case(*B*), and iPad scratch guard(*C*) | iPad case(*B*),
    iPad(*A*), and iPad scratch guard(*C*) |'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| **9** | iPad(*A*)，iPad保护壳(*B*)，以及iPad防刮保护膜(*C*) | iPad保护壳(*B*), iPad(*A*),
    以及iPad防刮保护膜(*C*) |'
- en: Create FP-tree for transaction for **TID** = **1**, and the ordered itemset
    is iPad case(*B*), iPad(*A*), and iPhone(*E*).![FP-growth algorithm](img/B03980_07_09.jpg)
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为**TID** = **1**的交易创建FP树，并按顺序排列的项集是iPad保护壳(*B*)，iPad(*A*)，以及iPhone(*E*)。![FP-growth算法](img/B03980_07_09.jpg)
- en: Now, scan the database for **TID** = **2**, iPad case (*B*) and Apple care(*D*).
    The updated FP-tree will look like this:![FP-growth algorithm](img/B03980_07_10.jpg)
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，扫描数据库以查找**TID** = **2**，iPad保护壳 (*B*) 和Apple care(*D*)。更新后的FP树将如下所示：![FP-growth算法](img/B03980_07_10.jpg)
- en: Scan all the transactions in the order of L and update the FP-tree accordingly.
    The final FP-tree will be as shown next. Note that every time an item is encountered
    again in the transaction, the count value on the node is incremented.![FP-growth
    algorithm](img/B03980_07_11.jpg)
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照L的顺序扫描所有交易并相应地更新FP树。最终的FP树将如下所示。请注意，每次在交易中遇到重复的项目时，节点上的计数值都会增加。![FP-growth算法](img/B03980_07_11.jpg)
- en: Generate a conditional FP-tree for each of the transactions and define the conditional
    pattern base.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为每笔交易生成一个条件FP树并定义条件模式基。
- en: 'Finally, generate the frequent patterns. The result for the given dataset is
    shown here:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，生成频繁模式。给定数据集的结果如下所示：
- en: '[PRE0]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Apriori versus FP-growth
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Apriori与FP-growth对比
- en: 'The following graph shows the relationship between the algorithms with different
    minsup threshold values:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图显示了不同minsup阈值值算法之间的关系：
- en: '![Apriori versus FP-growth](img/B03980_07_12.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![Apriori与FP-growth对比](img/B03980_07_12.jpg)'
- en: 'Image source: An article by Prof. Pier Luca Lanzi'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 图片来源：Pier Luca Lanzi教授的文章
- en: 'The advantages of the FP-growth algorithm are detailed here:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: FP-growth算法的优点在此详细说明：
- en: The complete information for frequent pattern mining is preserved, without breaking
    the pattern in a long transaction
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完整地保留了频繁模式挖掘的信息，而不会在长交易中打断模式。
- en: Data is compacted by eliminating irrelevant information as infrequent itemsets
    are avoided upfront
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过消除不相关信息（在事先避免不频繁项集）来压缩数据。
- en: The FP-growth algorithm works in a divide-and-conquer mode, where the dataset
    is decomposed as per the frequent itemset patterns uncovered so far. This reduces
    searches to the subset of datasets as against the complete database
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FP-growth算法以分而治之的模式工作，将数据集根据迄今为止发现的频繁项集模式进行分解。这减少了搜索到数据集的子集，而不是完整的数据库。
- en: The candidate itemsets are not generated in this case and hence, will not need
    to be tested
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这种情况下不会生成候选项集，因此不需要进行测试。
- en: Implementing Apriori and FP-growth
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现Apriori和FP-growth
- en: Refer to the source code provided for this chapter for implementing the Apriori
    classifier (source code path `.../chapter7/...` under each of the folders for
    the technology.)
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考本章提供的源代码以实现Apriori分类器（源代码路径在各个技术文件夹下的`.../chapter7/...`中）。
- en: Using Mahout
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Mahout
- en: Refer to the code files folder `.../mahout/chapter7/aprioriexample/`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考代码文件文件夹 `.../mahout/chapter7/aprioriexample/`。
- en: Refer to the code files folder `.../mahout/chapter7/fpgrowthexample/`.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考代码文件文件夹 `.../mahout/chapter7/fpgrowthexample/`。
- en: Using R
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 R
- en: Refer to the code files folder `.../r/chapter7/aprioriexample/`.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考代码文件文件夹 `.../r/chapter7/aprioriexample/`。
- en: Refer to the code files folder `.../r/chapter7/fpgrowthexample/`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考代码文件文件夹 `.../r/chapter7/fpgrowthexample/`。
- en: Using Spark
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Spark
- en: Refer to the code files folder `.../spark/chapter7/aprioriexample/`.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考代码文件文件夹 `.../spark/chapter7/aprioriexample/`。
- en: Refer to the code files folder `.../spark/chapter7/fpgrowthexample/`.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考代码文件文件夹 `.../spark/chapter7/fpgrowthexample/`。
- en: Using Python (Scikit-learn)
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Python (Scikit-learn)
- en: Refer to the code files folder `.../python-scikit-learn/ chapter7/aprioriexample/`.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考代码文件文件夹 `.../python-scikit-learn/ chapter7/aprioriexample/`。
- en: Refer to the code files folder `.../python-scikit-learn/chapter7/fpgrowthexample/`.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考代码文件文件夹 `.../python-scikit-learn/chapter7/fpgrowthexample/`。
- en: Using Julia
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Julia
- en: Refer to the code files folder `.../julia/chapter7/aprioriexample/`.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考代码文件文件夹 `.../julia/chapter7/aprioriexample/`。
- en: Refer to the code files folder `.../julia/chapter7/fpgrowthexample/`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考代码文件文件夹 `.../julia/chapter7/fpgrowthexample/`。
- en: Summary
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you have learned the association rule based learning methods
    and, Apriori and FP-growth algorithms. With a common example, you learned how
    to do frequent pattern mining using Apriori and FP-growth algorithms with a step-by-step
    debugging of the algorithm. We also compared and contrasted the algorithms and
    their performance. We have example implementations for Apriori using Mahout, R,
    Python, Julia, and Spark. In the next chapter, we will cover the Bayesian methods
    and specifically, the Naïve-Bayes algorithm.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了基于关联规则的学习方法以及 Apriori 和 FP-growth 算法。通过一个共同示例，你学习了如何使用 Apriori 和 FP-growth
    算法进行频繁模式挖掘，并通过逐步调试算法来学习。我们还比较和对比了算法及其性能。我们提供了使用 Mahout、R、Python、Julia 和 Spark
    的 Apriori 示例实现。在下一章中，我们将介绍贝叶斯方法，特别是朴素贝叶斯算法。
