<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer022">&#13;
			<h1 id="_idParaDest-51" class="chapter-number"><a id="_idTextAnchor050"/>3</h1>&#13;
			<h1 id="_idParaDest-52"><a id="_idTextAnchor051"/>Intermediate Data Processing</h1>&#13;
			<p>The previous chapter covered a suite of commonly used functions offered by <strong class="source-inline">dplyr</strong> for data processing. For example, when characterizing and extracting the statistics of a dataset, we can follow the split-apply-combine procedure using <strong class="source-inline">group_by()</strong> and <strong class="source-inline">summarize()</strong>. This chapter continues from the previous one and focuses on intermediate data processing techniques, including transforming categorical and numeric variables and reshaping DataFrames. Besides that, we will also introduce string manipulation techniques for working with textual data, whose format is fundamentally different from the neatly shaped tables we have been working with <span class="No-Break">so far.</span></p>&#13;
			<p>By the end of this chapter, you will be able to perform more advanced data manipulation and extend your data massaging skills to string-based texts, which are fundamental to the field of natural <span class="No-Break">language processing.</span></p>&#13;
			<p>In this chapter, we will cover the <span class="No-Break">following topics:</span></p>&#13;
			<ul>&#13;
				<li>Transforming categorical and <span class="No-Break">numeric variables</span></li>&#13;
				<li>Reshaping <span class="No-Break">the DataFrame</span></li>&#13;
				<li>Manipulating <span class="No-Break">string data</span></li>&#13;
				<li>Working <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">stringr</strong></span></li>&#13;
				<li>Introducing <span class="No-Break">regular expressions</span></li>&#13;
				<li>Working with tidy <span class="No-Break">text mining</span></li>&#13;
			</ul>&#13;
			<h1 id="_idParaDest-53"><a id="_idTextAnchor052"/>Technical requirements</h1>&#13;
			<p>To complete the exercises in this chapter, you will need to have <span class="No-Break">the following:</span></p>&#13;
			<ul>&#13;
				<li>The latest version of the <strong class="source-inline">rebus</strong> package, which is 0.1-3 at the time <span class="No-Break">of writing</span></li>&#13;
				<li>The latest version of the <strong class="source-inline">tidytext</strong> package, which is 0.3.2 at the time <span class="No-Break">of writing</span></li>&#13;
				<li>The latest version of the <strong class="source-inline">tm</strong> package, which is 0.7-8 at the time <span class="No-Break">of writing</span></li>&#13;
			</ul>&#13;
			<p>All the code and data for this chapter is available <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/The-Statistics-and-Machine-Learning-with-R-Workshop/tree/main/Chapter_3"><span class="No-Break">https://github.com/PacktPublishing/The-Statistics-and-Machine-Learning-with-R-Workshop/tree/main/Chapter_3</span></a><span class="No-Break">.</span></p>&#13;
			<h1 id="_idParaDest-54"><a id="_idTextAnchor053"/>Transforming categorical and numeric variables</h1>&#13;
			<p>As covered in the<a id="_idIndexMarker247"/> previous chapter, we can use the <strong class="source-inline">mutate()</strong> function from <strong class="source-inline">dplyr</strong> to transform<a id="_idIndexMarker248"/> existing variables and create new ones. The specific transformation depends on the type of the variable and the resulting shape we would like it to be. For example, we may want to change the value of a categorical variable according to a mapping dictionary, create a new variable based on a combination of filtering conditions of existing variables, or group a numeric variable into different ranges in a new variable. Let us look at these scenarios <span class="No-Break">in turn.</span></p>&#13;
			<h2 id="_idParaDest-55"><a id="_idTextAnchor054"/>Recoding categorical variables</h2>&#13;
			<p>There are many cases<a id="_idIndexMarker249"/> when you would want to recode the values of a variable, such as mapping countries’ short names to the corresponding full names. Let’s create a dummy <strong class="source-inline">tibble</strong> dataset to <span class="No-Break">illustrate this.</span></p>&#13;
			<p>In the following code, we have created a <strong class="source-inline">students</strong> variable that stores information on age, country, gender, and height. This is a small dummy dataset but it’s good enough for <span class="No-Break">demonstration purposes:</span></p>&#13;
			<pre class="source-code">&#13;
students = tibble(age = c(26, 30, 28, 31, 25, 29, 30, 29),&#13;
                  country = c('SG', 'CN', 'US', 'UK','CN', 'SG', 'IN', 'SG'),&#13;
                  gender = c('F', 'F', 'M', 'M', 'M', 'F', 'F', 'M'),&#13;
height = c(168, 169, 175, 178, 170, 170, 172, 180))</pre>			<p>Now, let’s go through an example of converting the values of the <strong class="source-inline">country</strong> variable into their <span class="No-Break">full names.</span></p>&#13;
			<h3>Exercise 3.1 – converting the country variable values into their full names</h3>&#13;
			<p>This exercise <a id="_idIndexMarker250"/>will use the <strong class="source-inline">recode()</strong> function from the <strong class="source-inline">dplyr</strong> package to map the existing short country names to the corresponding <span class="No-Break">full </span><span class="No-Break"><a id="_idIndexMarker251"/></span><span class="No-Break">names:</span></p>&#13;
			<ol>&#13;
				<li>Add a new column that converts the short country names into the corresponding full names by providing a mapping table <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">recode()</strong></span><span class="No-Break">:</span><pre class="source-code">&#13;
students_new = students %&gt;%&#13;
  mutate(country_fullname = recode(country,&#13;
                                   "SG"="Singapore",&#13;
                                   "CN"="China",&#13;
                                   "UK"="United Kingdom",&#13;
                                   "IN"="India"))&#13;
&gt;&gt;&gt; students_new&#13;
# A tibble: 8 x 5&#13;
    age country gender height country_fullname&#13;
  &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;dbl&gt; &lt;chr&gt;&#13;
1    26 SG      F         168 Singapore&#13;
2    30 CN      F         169 China&#13;
3    28 UK      M         175 United Kingdom&#13;
4    31 UK      M         178 United Kingdom&#13;
5    25 CN      M         170 China&#13;
6    29 SG      F         170 Singapore&#13;
7    30 IN      F         172 India&#13;
8    29 SG      M         180 Singapore</pre><p class="list-inset">Here, we provided a mapping dictionary as an argument in the <strong class="source-inline">recode()</strong> function, which searches for the keys in the left column and assigns the corresponding values in the right column to <strong class="source-inline">country_fullname</strong>. Note that the newly created column assumes a <span class="No-Break">character type.</span></p></li>				<li>Perform the same<a id="_idIndexMarker252"/> conversion and store the<a id="_idIndexMarker253"/> result as a <span class="No-Break"><strong class="source-inline">factor</strong></span><span class="No-Break"> type:</span><pre class="source-code">&#13;
students_new = students_new %&gt;%&#13;
  mutate(country_fullname2 = recode_factor(country,&#13;
                                   "SG"="Singapore",&#13;
                                   "CN"="China",&#13;
                                   "UK"="United Kingdom",&#13;
                                   "IN"="India"))&#13;
&gt;&gt;&gt; students_new&#13;
# A tibble: 8 x 6&#13;
    age country gender height country_fullname country_fullname2&#13;
  &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;dbl&gt; &lt;chr&gt;            &lt;fct&gt;&#13;
1    26 SG      F         168 Singapore        Singapore&#13;
2    30 CN      F         169 China            China&#13;
3    28 UK      M         175 United Kingdom   United Kingdom&#13;
4    31 UK      M         178 United Kingdom   United Kingdom&#13;
5    25 CN      M         170 China            China&#13;
6    29 SG      F         170 Singapore        Singapore&#13;
7    30 IN      F         172 India            India&#13;
8    29 SG      M         180 Singapore        Singapore</pre><p class="list-inset">We can <a id="_idIndexMarker254"/>see that the resulting variable, <strong class="source-inline">country_fullname2</strong>, is a factor by <a id="_idIndexMarker255"/><span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">recode_factor()</strong></span><span class="No-Break">.</span></p></li>			</ol>&#13;
			<p>When the new column we want to create depends on a complex combination of existing ones, we can resort to the <strong class="source-inline">case_when()</strong> function, as introduced in the <span class="No-Break">following section.</span></p>&#13;
			<h2 id="_idParaDest-56"><a id="_idTextAnchor055"/>Creating variables using case_when()</h2>&#13;
			<p>The <strong class="source-inline">case_when()</strong> function<a id="_idIndexMarker256"/> provides a convenient way to<a id="_idIndexMarker257"/> set multiple <strong class="source-inline">if-else</strong> conditions when creating a new variable. It takes a sequence of two-sided formulas, where the left-hand side contains the filtering conditions and the right-hand side provides the replacement value that matches the preceding conditions. The syntax inside the function follows a <strong class="source-inline">logical condition(s) ~ replacement value</strong> pattern that gets evaluated sequentially, where multiple variables can be used inside the logical conditioning. At the end of the sequence is a <strong class="source-inline">TRUE ~ default value</strong> case that gets assigned to the variable if all preceding conditions evaluate <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">FALSE</strong></span><span class="No-Break">.</span></p>&#13;
			<p>Let’s go through an exercise to create a new variable based on multiple <strong class="source-inline">if-else</strong> conditions involving <span class="No-Break">multipl<a id="_idTextAnchor056"/>e columns.</span></p>&#13;
			<h3>Exercise 3.2 – creating a new variable using multiple conditions and columns</h3>&#13;
			<p>In this exercise, we<a id="_idIndexMarker258"/> will create a new variable that indicates the age and region of <span class="No-Break">the students.</span></p>&#13;
			<p>Create a new variable type to identify whether the students come from Asia and are in their 20s or 30s by assuming <strong class="source-inline">asia_20+</strong> and <strong class="source-inline">asia_30+</strong> as values, respectively. Set the value to <strong class="source-inline">others</strong> if there is <span class="No-Break">no match:</span></p>&#13;
			<pre class="source-code">&#13;
students_new = students %&gt;%&#13;
  mutate(type = case_when(age &gt;= 30 &amp; country %in% c("SG","IN","CN") ~ "asia_30+",&#13;
                             age &lt; 30 &amp; age &gt;= 20 &amp; country %in% c("SG","IN","CN") ~ "asia_20+",&#13;
                             TRUE ~ "others"))&#13;
&gt;&gt;&gt; students_new&#13;
# A tibble: 8 x 5&#13;
    age country gender height type&#13;
  &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;dbl&gt; &lt;chr&gt;&#13;
1    26 SG      F         168 asia_20+&#13;
2    30 CN      F         169 asia_30+&#13;
3    28 UK      M         175 others&#13;
4    31 UK      M         178 others&#13;
5    25 CN      M         170 asia_20+&#13;
6    29 SG      F         170 asia_20+&#13;
7    30 IN      F         172 asia_30+&#13;
8    29 SG      M         180 asia_20+</pre>			<p>Here, we used the <strong class="source-inline">&amp;</strong> sign to combine multiple <strong class="source-inline">AND</strong> conditions that evaluate <strong class="source-inline">age</strong> and <strong class="source-inline">country</strong>. When neither of the preceding conditions in the sequence evaluate to <strong class="source-inline">TRUE</strong>, the function will <a id="_idIndexMarker259"/>fall into the all-encompassing <strong class="source-inline">TRUE</strong> case and assign <strong class="source-inline">others</strong> as the <span class="No-Break">default value.</span></p>&#13;
			<p>Next, we will look at converting a numeric column into <span class="No-Break">different bins/categories.</span></p>&#13;
			<h2 id="_idParaDest-57"><a id="_idTextAnchor057"/>Binning numeric variables using cut()</h2>&#13;
			<p>A numeric <a id="_idIndexMarker260"/>column can be partitioned into<a id="_idIndexMarker261"/> different categories using the <strong class="source-inline">cut()</strong> function. For a numeric column, it assigns the value to the corresponding predefined intervals and codes the value based on the assigned interval. The resulting column of intervals assumes an ordered <span class="No-Break">factor type.</span></p>&#13;
			<p>The <strong class="source-inline">cut()</strong> function has <a id="_idIndexMarker262"/>three key arguments: <strong class="source-inline">x</strong> to accept a <a id="_idIndexMarker263"/>numeric vector to be binned, <strong class="source-inline">breaks</strong> to accept a numeric vector of cut points, which could include negative infinity, <strong class="source-inline">–Inf</strong>, and positive infinity, <strong class="source-inline">Inf</strong>, and <strong class="source-inline">labels</strong> to indicate the labels of the <span class="No-Break">resulting intervals.</span></p>&#13;
			<p>Let’s go through an exercise using <strong class="source-inline">cut()</strong> to convert the <strong class="source-inline">age</strong> column into different <span class="No-Break">age groups.</span></p>&#13;
			<h3>Exercise 3.3 – binning the age column into three groups</h3>&#13;
			<p>In this exercise, we will <a id="_idIndexMarker264"/>use the <strong class="source-inline">cut()</strong> function to assign the value of the <strong class="source-inline">age</strong> column to one of the following ranges: <strong class="source-inline">(-infinity, 25)</strong>, <strong class="source-inline">[26, 30]</strong>, or <strong class="source-inline">[</strong><span class="No-Break"><strong class="source-inline">31, infinity]</strong></span><span class="No-Break">:</span></p>&#13;
			<ol>&#13;
				<li>Segment the <strong class="source-inline">age</strong> column into three intervals with breakpoints at <strong class="source-inline">25</strong> and <strong class="source-inline">30</strong> (inclusive on the right) and store them in a new column <span class="No-Break">named </span><span class="No-Break"><strong class="source-inline">age_group</strong></span><span class="No-Break">:</span><pre class="source-code">&#13;
students_new = students %&gt;%&#13;
  mutate(age_group = cut(x = age,&#13;
                    breaks = c(-Inf, 25, 30, Inf),&#13;
                    labels = c("&lt;=25", "26-30", "&gt;30")))&#13;
&gt;&gt;&gt; students_new&#13;
# A tibble: 8 x 5&#13;
    age country gender height age_group&#13;
  &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;dbl&gt; &lt;fct&gt;&#13;
1    26 SG      F         168 26-30&#13;
2    30 CN      F         169 26-30&#13;
3    28 UK      M         175 26-30&#13;
4    31 UK      M         178 &gt;30&#13;
5    25 CN      M         170 &lt;=25&#13;
6    29 SG      F         170 26-30&#13;
7    30 IN      F         172 26-30&#13;
8    29 SG      M         180 26-30</pre><p class="list-inset">Here, we can see that <strong class="source-inline">age_group</strong> is an ordered factor with <span class="No-Break">three levels.</span></p><p class="list-inset">A <a id="_idIndexMarker265"/>few cutting functions perform automatic binning when we do not have a specific cutoff point in mind. For example, <strong class="source-inline">cut_interval()</strong> cuts the original vector into a specified number of groups with equal intervals, while <strong class="source-inline">cut_number()</strong> converts the input vector into a specific number of groups, where each group has approximately the same number of observations. The <strong class="source-inline">tidyverse</strong> package provides both functions. Let’s try <span class="No-Break">them out.</span></p></li>				<li>Group the <strong class="source-inline">age</strong> column into three bins of equal length <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">cut_interval()</strong></span><span class="No-Break">:</span><pre class="source-code">&#13;
students_new = students %&gt;%&#13;
  mutate(age_group = cut_interval(age, n=3))&#13;
&gt;&gt;&gt; students_new&#13;
# A tibble: 8 x 5&#13;
    age country gender height age_group&#13;
  &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;dbl&gt; &lt;fct&gt;&#13;
1    26 SG      F         168 [25,27]&#13;
2    30 CN      F         169 (29,31]&#13;
3    28 UK      M         175 (27,29]&#13;
4    31 UK      M         178 (29,31]&#13;
5    25 CN      M         170 [25,27]&#13;
6    29 SG      F         170 (27,29]&#13;
7    30 IN      F         172 (29,31)&#13;
8    29 SG      M         180 (27,29)</pre><p class="list-inset">The <strong class="source-inline">age_group</strong> column now consists of three levels that represent equal-length <a id="_idIndexMarker266"/>intervals. Let’s check out the counts of each level using the <span class="No-Break"><strong class="source-inline">summary()</strong></span><span class="No-Break"> function:</span></p><pre class="source-code">&gt;&gt;&gt; summary(students_new$age_group)&#13;
[25,27] (27,29) (29,31)&#13;
      2       3       3</pre></li>				<li>Group the <strong class="source-inline">age</strong> column into three bins of an equal number of observations <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">cut_interval()</strong></span><span class="No-Break">:</span><pre class="source-code">&#13;
students_new = students %&gt;%&#13;
  mutate(age_group = cut_number(age, n=3))&#13;
&gt;&gt;&gt; students_new&#13;
# A tibble: 8 x 5&#13;
    age country gender height age_group&#13;
  &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;dbl&gt; &lt;fct&gt;&#13;
1    26 SG      F         168 [25,28.3]&#13;
2    30 CN      F         169 (29.7,31]&#13;
3    28 UK      M         175 [25,28.3]&#13;
4    31 UK      M         178 (29.7,31]&#13;
5    25 CN      M         170 [25,28.3]&#13;
6    29 SG      F         170 (28.3,29.7]&#13;
7    30 IN      F         172 (29.7,31)&#13;
8    29 SG      M         180 (28.3,29.7)</pre><p class="list-inset">The cutoff <a id="_idIndexMarker267"/>points are now assuming decimal points to make the resulting count of observations approximately equal, as verified in the <span class="No-Break">following code:</span></p><pre class="source-code">&gt;&gt;&gt; summary(students_new$age_group)&#13;
  [25,28.3] (28.3,29.7)   (29.7,31)&#13;
3           2           3</pre></li>			</ol>&#13;
			<p>So far, we have looked at different ways to transform an existing categorical or numeric variable and create a new variable based on specific conditions. Next, we will look at how to transform and reshape the whole DataFrame to facilitate <span class="No-Break">our analysis.</span></p>&#13;
			<h1 id="_idParaDest-58"><a id="_idTextAnchor058"/>Reshaping the DataFrame</h1>&#13;
			<p>A DataFrame <a id="_idIndexMarker268"/>that consists of a combination of categorical and numeric columns can be expressed in both wide and long formats. For example, the <strong class="source-inline">students</strong> DataFrame is considered a long format since all countries are stored in the <strong class="source-inline">country</strong> column. Depending on the specific purpose of processing, we may want to create a separate column for each unique country in the dataset, which adds more columns to the DataFrame and converts it into a <span class="No-Break">wide format.</span></p>&#13;
			<p>Converting between wide and long formats can be achieved via the <strong class="source-inline">spread()</strong> and <strong class="source-inline">gather()</strong> functions, both of which are provided by the <strong class="source-inline">tidyr</strong> package from the <strong class="source-inline">tidyverse</strong> ecosystem. Let’s see how it works <span class="No-Break">in practice.</span></p>&#13;
			<h2 id="_idParaDest-59"><a id="_idTextAnchor059"/>Converting from long format into wide format using spread()</h2>&#13;
			<p>There will be times when we’ll want to turn a long-formatted DataFrame into a wide format. The <strong class="source-inline">spread()</strong> function<a id="_idIndexMarker269"/> can be used to convert a categorical column with multiple categories into multiple columns, as specified by the <strong class="source-inline">key</strong> argument, with each category added to the DataFrame as a separate column. The column names will be the unique values of the categorical column. The <strong class="source-inline">value</strong> argument specifies the contents to be spread and filled in these additional columns upon calling the <strong class="source-inline">spread()</strong> function. Let’s go through an exercise <span class="No-Break">on this.</span></p>&#13;
			<h3>Exercise 3.4 – converting from long format into wide format</h3>&#13;
			<p>In this exercise, we will <a id="_idIndexMarker270"/>convert the <strong class="source-inline">students</strong> DataFrame into a wide format <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">spread()</strong></span><span class="No-Break">:</span></p>&#13;
			<ol>&#13;
				<li>Use <strong class="source-inline">country</strong> as the <strong class="source-inline">key</strong> argument and <strong class="source-inline">height</strong> as the <strong class="source-inline">value</strong> argument to convert students into a wide<a id="_idTextAnchor060"/> format using <strong class="source-inline">spread()</strong>. Store the resulting DataFrame <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">students_wide</strong></span><span class="No-Break">:</span><pre class="source-code">&#13;
students_wide = students %&gt;%&#13;
  spread(key = country, value = height)&#13;
&gt;&gt;&gt; students_wide&#13;
# A tibble: 7 x 6&#13;
    age gender    CN    IN    SG    UK&#13;
  &lt;dbl&gt; &lt;chr&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;&#13;
1    25 M        170    NA    NA    NA&#13;
2    26 F         NA    NA   168    NA&#13;
3    28 M         NA    NA    NA   175&#13;
4    29 F         NA    NA   170    NA&#13;
5    29 M         NA    NA   180    NA&#13;
6    30 F        169   172    NA    NA&#13;
7    31 M         NA    NA    NA   178</pre><p class="list-inset">We can see that the original <strong class="source-inline">height</strong> column disappears, and four additional columns are added. These four columns correspond to the unique countries, and the values of these columns are filled in by the heights. If the corresponding height for a particular country is not available, <strong class="source-inline">NA</strong> is used to fill in the <span class="No-Break">missing combination.</span></p><p class="list-inset">If we want to specify a default value for these <strong class="source-inline">NA</strong> values, we can set the <strong class="source-inline">fill</strong> argument <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">spread()</strong></span><span class="No-Break">.</span></p></li>				<li>Use the <a id="_idIndexMarker271"/>rounded average height to fill the <strong class="source-inline">NA</strong> values in the resulting wide format. Store the resulting DataFrame <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">students_wide2</strong></span><span class="No-Break">:</span><pre class="source-code">&#13;
avg_height = round(mean(students$height))&#13;
students_wide2 = students %&gt;%&#13;
  spread(key = country, value = height, fill = avg_height)&#13;
&gt;&gt;&gt; students_wide2&#13;
# A tibble: 7 x 6&#13;
    age gender    CN    IN    SG    UK&#13;
  &lt;dbl&gt; &lt;chr&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;&#13;
1    25 M        170   173   173   173&#13;
2    26 F        173   173   168   173&#13;
3    28 M        173   173   173   175&#13;
4    29 F        173   173   170   173&#13;
5    29 M        173   173   180   173&#13;
6    30 F        169   172   173   173&#13;
7    31 M        173   173   173   178</pre></li>			</ol>&#13;
			<p>Converting from long into wide could be helpful from an analysis and presentational perspective since we can visually compare the heights across all countries for a specific combination of age and gender. However, this comes with additional storage costs, as shown by the <a id="_idIndexMarker272"/>multiple <strong class="source-inline">NA</strong> <span class="No-Break">values earlier.</span></p>&#13;
			<p>Now, let’s learn how to convert a wide-formatted DataFrame into a <span class="No-Break">long format.</span></p>&#13;
			<h2 id="_idParaDest-60"><a id="_idTextAnchor061"/>Converting from wide format into long format using gather()</h2>&#13;
			<p>When we are in<a id="_idIndexMarker273"/> the opposite situation, where the given data is in a wide format, we can use the <strong class="source-inline">gather()</strong> function to convert it into a long format for more convenient follow-up processing. For example, by compressing the four country columns into the <strong class="source-inline">key</strong> variable and storing all heights under the <strong class="source-inline">value</strong> variable specified in <strong class="source-inline">gather()</strong>, we can continue with the usual split-apply-combine treatments we introduced earlier based on just two columns instead of four <span class="No-Break">or more.</span></p>&#13;
			<p>The <strong class="source-inline">gather()</strong> function also uses the <strong class="source-inline">key</strong> and <strong class="source-inline">value</strong> arguments to specify the name of the resulting <strong class="source-inline">key</strong> and <strong class="source-inline">value</strong> columns in the long-formatted table. Besides, we need to specify the columns whose names are used to fill in the <strong class="source-inline">key</strong> column and the values in the <strong class="source-inline">value</strong> column. When <a id="_idIndexMarker274"/>there are many adjacent columns to specify, we can use the <strong class="source-inline">:</strong> operator by passing the starting and ending column names to select all columns in between. Let’s go through a <span class="No-Break">practice exercise.</span></p>&#13;
			<h3>Exercise 3.5 – converting from wide format into long format</h3>&#13;
			<p>This exercise will convert the wide-formatted <strong class="source-inline">students_wide</strong> DataFrame back into its original <span class="No-Break">long format:</span></p>&#13;
			<ol>&#13;
				<li>Convert <strong class="source-inline">students_wide</strong> into a long format by specifying the <strong class="source-inline">key</strong> column as <strong class="source-inline">country</strong> and the <strong class="source-inline">value</strong> column as <strong class="source-inline">height</strong>, and using the values of the <strong class="source-inline">CN</strong>, <strong class="source-inline">IN</strong>, <strong class="source-inline">SG</strong>, and <strong class="source-inline">UK</strong> columns to fill in the <strong class="source-inline">key</strong> and <strong class="source-inline">value</strong> <span class="No-Break">columns, respectively:</span><pre class="source-code">&#13;
students_long = students_wide %&gt;%&#13;
  gather(key = "country", value = "height", CN:UK)&#13;
&gt;&gt;&gt; students_long&#13;
# A tibble: 28 x 4&#13;
     age gender country height&#13;
   &lt;dbl&gt; &lt;chr&gt;  &lt;chr&gt;    &lt;dbl&gt;&#13;
 1    25 M      CN         170&#13;
 2    26 F      CN          NA&#13;
 3    28 M      CN          NA&#13;
 4    29 F      CN          NA&#13;
 5    29 M      CN          NA&#13;
 6    30 F      CN         169&#13;
 7    31 M      CN          NA&#13;
 8    25 M      IN          NA&#13;
 9    26 F      IN          NA&#13;
10    28 M      IN          NA&#13;
# … with 18 more rows</pre><p class="list-inset">We can see that several rows with missing values in the <strong class="source-inline">height</strong> column have been added to <strong class="source-inline">students_long</strong>. This is because of their original presence in <strong class="source-inline">students_wide</strong>. Let’s remove them using the <strong class="source-inline">drop_na()</strong> function <span class="No-Break">from </span><span class="No-Break"><strong class="source-inline">dplyr</strong></span><span class="No-Break">.</span></p></li>				<li>Remove the <a id="_idIndexMarker275"/>rows with <strong class="source-inline">NA</strong> values in the <span class="No-Break"><strong class="source-inline">height</strong></span><span class="No-Break"> column:</span><pre class="source-code">&#13;
students_long = students_long %&gt;%&#13;
  drop_na(height)&#13;
&gt;&gt;&gt; students_long&#13;
# A tibble: 8 x 4&#13;
    age gender country height&#13;
  &lt;dbl&gt; &lt;chr&gt;  &lt;chr&gt;    &lt;dbl&gt;&#13;
1    25 M      CN         170&#13;
2    30 F      CN         169&#13;
3    30 F      IN         172&#13;
4    26 F      SG         168&#13;
5    29 F      SG         170&#13;
6    29 M      SG         180&#13;
7    28 M      UK         175&#13;
8    31 M      UK         178</pre><p class="list-inset">With that, we have obtained the long-formatted DataFrame. Now, let’s verify whether it is the same as the original <span class="No-Break"><strong class="source-inline">students</strong></span><span class="No-Break"> DataFrame.</span></p></li>				<li>Verify whether <strong class="source-inline">students_long</strong> is the same as <strong class="source-inline">students</strong> <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">all_equal()</strong></span><span class="No-Break">:</span><pre class="source-code">&#13;
&gt;&gt;&gt; all_equal(students, students_long, ignore_row_order = T, ignore_col_order = T)&#13;
TRUE</pre><p class="list-inset">The <strong class="source-inline">all_equal()</strong> function from <strong class="source-inline">dplyr</strong> compares two datasets and checks whether they are identical. It provides a flexible way to carry out an equality comparison and supports ignoring the ordering of rows and/or columns. The result shows that we have <a id="_idIndexMarker276"/>successfully converted back into the <span class="No-Break">original dataset.</span></p></li>			</ol>&#13;
			<p>With that, we have looked at different ways to reshape the DataFrame. Next, we will cover how to deal with <span class="No-Break">string data.</span></p>&#13;
			<h1 id="_idParaDest-61"><a id="_idTextAnchor062"/>Manipulating string data</h1>&#13;
			<p>Character-typed strings are <a id="_idIndexMarker277"/>standard in real-life data, such as name and address. Analyzing string data requires properly cleaning the raw characters and converting the information embedded in a blob of textual data into a quantifiable numeric summary. For example, we may want to find the matching names of all students that follow a <span class="No-Break">specific pattern.</span></p>&#13;
			<p>This section will cover different ways to define patterns via regular expressions to detect, split, and extract string data. Let’s start with the basics <span class="No-Break">of strings.</span></p>&#13;
			<h2 id="_idParaDest-62"><a id="_idTextAnchor063"/>Creating strings</h2>&#13;
			<p>A <strong class="bold">string</strong> is a<a id="_idIndexMarker278"/> character-typed<a id="_idIndexMarker279"/> variable that is represented by a sequence of characters (including punctuation) wrapped by a pair of double quotes (<strong class="source-inline">""</strong>). Sometimes, a single quote (<strong class="source-inline">'</strong>) is also used to denote a string, although it is generally recommended to use double quotes unless the characters themselves include <span class="No-Break">double quotes.</span></p>&#13;
			<p>There are multiple ways to create a string. The following exercise introduces a few different ways to initialize a <span class="No-Break">character-typed string.</span></p>&#13;
			<h3>Exercise 3.6 – expressing strings in R</h3>&#13;
			<p>In this<a id="_idIndexMarker280"/> exercise, we will <a id="_idIndexMarker281"/>look at creating strings <span class="No-Break">in R:</span></p>&#13;
			<ol>&#13;
				<li>Try to type out the following strings in the <span class="No-Break">R console:</span><pre class="source-code">&#13;
&gt;&gt;&gt; "statistics workshop"&#13;
"statistics workshop"</pre><p class="list-inset">The strings are printed without error. Let’s see what happens if we wrap <strong class="source-inline">statistics</strong> with double quotes to highlight <span class="No-Break">this word.</span></p></li>				<li>Add double quotes to <strong class="source-inline">statistics</strong> in <span class="No-Break">the string:</span><pre class="source-code">&#13;
&gt;&gt;&gt; ""statistics" workshop"&#13;
Error: unexpected symbol in """statistics"</pre><p class="list-inset">This time, an error pops up because R takes the second double quote as the ending quote of the string. This error can be avoided by switching to using single quotes for the outside quotes when double quotes are used in <span class="No-Break">a string.</span></p></li>				<li>Wrap the previous string with <span class="No-Break">single quotes:</span><pre class="source-code">&#13;
&gt;&gt;&gt; '"statistics" workshop'&#13;
"\"statistics\" workshop"</pre><p class="list-inset">Now, R interprets the string correctly and considers all content within the pair of single quotes as a whole string. Note that the resulting string is still printed with double quotes in the console. The two double quotes within the string are also preceded by a backward slash (<strong class="source-inline">\</strong>). This is called an escape sequence and is used to indicate the literal interpretation of the double quotes as characters instead of the start of a string. The escape sequence is a useful way to include special characters in <span class="No-Break">a string.</span></p><p class="list-inset">We can also manually add the escape character inside the string to enforce the correct interpretation, which will print out the same result <span class="No-Break">as before.</span></p></li>				<li>Add the escape sequence before the double quotes inside <span class="No-Break">the string:</span><pre class="source-code">&#13;
&gt;&gt;&gt; "\"statistics\" workshop"&#13;
"\"statistics\" workshop"</pre><p class="list-inset">Printing out the string sequence with a backslash is not convenient for reading. To beautify the output, we can pass the exact string to the <span class="No-Break"><strong class="source-inline">writeLines()</strong></span><span class="No-Break"> function.</span></p></li>				<li>Print the<a id="_idIndexMarker282"/> same <a id="_idIndexMarker283"/>string <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">writeLines()</strong></span><span class="No-Break">:</span><pre class="source-code">&#13;
&gt;&gt;&gt; writeLines("\"statistics\" workshop")&#13;
"statistics" workshop</pre></li>			</ol>&#13;
			<p>Next, we will look at how to turn numbers into strings for <span class="No-Break">better interpretation.</span></p>&#13;
			<h2 id="_idParaDest-63"><a id="_idTextAnchor064"/>Converting numbers into strings</h2>&#13;
			<p>As we <a id="_idIndexMarker284"/>learned earlier, numbers can be converted into strings via the <strong class="source-inline">as.character()</strong> function. However, it would be inconvenient to directly read and report a big number such as <strong class="source-inline">123000</strong>. We would usually express it in a more readable manner such as 123,000 or a more concise way such as 1.23e+05, where the latter follows the scientific representation with e+05 equal to 10<span class="superscript">5</span>. Additionally, we may want to display a limited number of digits after the decimal point for a <span class="No-Break">floating number.</span></p>&#13;
			<p>All of these can be achieved via the <strong class="source-inline">format()</strong> function, which is useful when converting and printing numbers as strings while following different formats. Let’s see how this is done <span class="No-Break">in practice.</span></p>&#13;
			<h3>Exercise 3.7 – converting numbers into strings using format()</h3>&#13;
			<p>This <a id="_idIndexMarker285"/>exercise will use <strong class="source-inline">format()</strong> to convert numbers into pretty and easily <span class="No-Break">readable strings:</span></p>&#13;
			<ol>&#13;
				<li>Add a comma as a thousands separator to <strong class="source-inline">123000</strong> by specifying the <strong class="source-inline">big.mark</strong> argument <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">format()</strong></span><span class="No-Break">:</span><pre class="source-code">&#13;
&gt;&gt;&gt; format(123000, big.mark = ",")&#13;
"123,000"</pre><p class="list-inset">Notice that the result is now a character-type string with a <span class="No-Break">comma added.</span></p></li>				<li>Convert <strong class="source-inline">123000</strong> into <span class="No-Break">scientific format:</span><pre class="source-code">&#13;
&gt;&gt;&gt; format(123000, scientific = TRUE)&#13;
"1.23e+05"</pre><p class="list-inset">Using scientific format is a concise way to represent large numbers. We can also shorten a long floating number by specifying the number of digits <span class="No-Break">to display.</span></p></li>				<li>Display only three digits of <strong class="source-inline">1.256</strong> by specifying the <span class="No-Break"><strong class="source-inline">digits</strong></span><span class="No-Break"> argument:</span><pre class="source-code">&#13;
&gt;&gt;&gt; format(1.256, digits = 3)&#13;
"1.26"</pre><p class="list-inset">The result is rounded and converted into a string, displaying only three digits as specified. We can also achieve the same rounding effect <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">round()</strong></span><span class="No-Break">.</span></p></li>				<li>Round <strong class="source-inline">1.256</strong> to two <span class="No-Break">decimal points:</span><pre class="source-code">&#13;
&gt;&gt;&gt; round(1.256, digits = 2)&#13;
1.26</pre><p class="list-inset">This time, the <a id="_idIndexMarker286"/>result is still numeric since <strong class="source-inline">round()</strong> does not involve <span class="No-Break">type conversion.</span></p></li>			</ol>&#13;
			<p>In the next section, we will look at connecting <span class="No-Break">multiple strings.</span></p>&#13;
			<h2 id="_idParaDest-64"><a id="_idTextAnchor065"/>Connecting strings</h2>&#13;
			<p>When there are <a id="_idIndexMarker287"/>multiple strings, we can use <strong class="source-inline">paste()</strong> to connect<a id="_idIndexMarker288"/> and join them into a single string. This becomes important if we want to print long and customized messages in our program instead of relying on manually typing <span class="No-Break">them out.</span></p>&#13;
			<p>The <strong class="source-inline">paste()</strong> function takes an arbitrary number of string inputs as arguments and combines them into one. Let’s see how <span class="No-Break">it works.</span></p>&#13;
			<h3>Exercise 3.8 – combining strings using paste()</h3>&#13;
			<p>In this exercise, we will look at different ways to combine multiple <span class="No-Break">string inputs:</span></p>&#13;
			<ol>&#13;
				<li>Connect the <strong class="source-inline">statistics</strong> and <strong class="source-inline">workshop</strong> strings to generate <span class="No-Break"><strong class="source-inline">statistics workshop</strong></span><span class="No-Break">:</span><pre class="source-code">&#13;
&gt;&gt;&gt; paste("statistics", "workshop")&#13;
"statistics workshop"</pre><p class="list-inset">Here, we can see that a space is automatically added between the two strings. This is controlled by the <strong class="source-inline">sep</strong> argument, which specifies the filling content between strings and assumes a default value of a space. We can choose to override the default behavior by passing a separating character to <span class="No-Break">this argument.</span></p></li>				<li>Remove the space in between and <span class="No-Break">generate </span><span class="No-Break"><strong class="source-inline">statisticsworkshop</strong></span><span class="No-Break">:</span><pre class="source-code">&#13;
&gt;&gt;&gt; paste("statistics", "workshop", sep = "")&#13;
"statisticsworkshop"</pre><p class="list-inset">We can also <a id="_idIndexMarker289"/>achieve the same result using <a id="_idIndexMarker290"/>the <strong class="source-inline">paste0()</strong> function, which directly connects two strings <span class="No-Break">by default:</span></p><pre class="source-code">&gt;&gt;&gt; paste0("statistics", "workshop")&#13;
"statisticsworkshop"</pre><p class="list-inset">Let’s see what happens when we connect a single string to a vector <span class="No-Break">of strings.</span></p></li>				<li>Connect a vector of <strong class="source-inline">statistics</strong> and <strong class="source-inline">workshop</strong> <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">course</strong></span><span class="No-Break">:</span><pre class="source-code">&#13;
&gt;&gt;&gt; paste(c("statistics", "workshop"), "course")&#13;
"statistics course" "workshop course"</pre><p class="list-inset">The result shows that <strong class="source-inline">course</strong> is added to each element in the vector. This is completed via the recycling operation under the hood, where <strong class="source-inline">course</strong> is recycled so that it can be combined with each string in the vector. This is similar to the broadcasting mechanism <span class="No-Break">in Python.</span></p><p class="list-inset">We can also remove the vector structure and combine all elements into a single string by specifying the <span class="No-Break"><strong class="source-inline">collapse</strong></span><span class="No-Break"> argument.</span></p></li>				<li>Compress <a id="_idIndexMarker291"/>the previous output into a<a id="_idIndexMarker292"/> single string separated <span class="No-Break">by </span><span class="No-Break"><strong class="source-inline">+</strong></span><span class="No-Break">:</span><pre class="source-code">&#13;
&gt;&gt;&gt; paste(c("statistics", "workshop"), "course", collapse = " + ")&#13;
"statistics course + workshop course"</pre><p class="list-inset">After plugging in all the components of the combined vector and separating them by the specified argument, the result is a single <span class="No-Break">collapsed string.</span></p></li>			</ol>&#13;
			<p>So far, we have learned the basics when it comes to working with string data. The <strong class="source-inline">stringr</strong> package provided by the <strong class="source-inline">tidyverse</strong> ecosystem provides many handy functions if we want to have more flexible control of our strings. This will be covered in the <span class="No-Break">following section.</span></p>&#13;
			<h1 id="_idParaDest-65"><a id="_idTextAnchor066"/>Working with stringr</h1>&#13;
			<p>The <strong class="source-inline">stringr</strong> package <a id="_idIndexMarker293"/>provides a cohesive set of functions that all start with <strong class="source-inline">str_</strong> and are designed to make working with strings as easy <span class="No-Break">as possible.</span></p>&#13;
			<p>Let’s start with the basic functions of <strong class="source-inline">stringr</strong> by replicating the same results from the <span class="No-Break">previous exercise.</span></p>&#13;
			<h2 id="_idParaDest-66"><a id="_idTextAnchor067"/>Basics of stringr</h2>&#13;
			<p>The <strong class="source-inline">str_c()</strong> function<a id="_idIndexMarker294"/> from<a id="_idIndexMarker295"/> the <strong class="source-inline">stringr</strong> package can concatenate multiple strings with similar functionalities as in <strong class="source-inline">paste()</strong>. Let’s see its use <span class="No-Break">in action.</span></p>&#13;
			<h3>Exercise 3.9 – combining strings using paste()</h3>&#13;
			<p>In this exercise, we will <a id="_idIndexMarker296"/>reproduce the same as what we <a id="_idIndexMarker297"/>did in <em class="italic">Exercise 3.8</em> <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">str_c()</strong></span><span class="No-Break">:</span></p>&#13;
			<ol>&#13;
				<li>Concatenate <strong class="source-inline">statistics</strong> with <strong class="source-inline">workshop</strong> with a separating space <span class="No-Break">in between:</span><pre class="source-code">&#13;
&gt;&gt;&gt; str_c("statistics", "workshop", sep = " ")&#13;
"statistics workshop"</pre><p class="list-inset">We can use the <strong class="source-inline">sep</strong> argument to specify the separator <span class="No-Break">between strings.</span></p></li>				<li>Combine a vector of <strong class="source-inline">statistics</strong> and <strong class="source-inline">workshop</strong> <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">course</strong></span><span class="No-Break">:</span><pre class="source-code">&#13;
&gt;&gt;&gt; str_c(c("statistics", "workshop"), "course", sep = " ")&#13;
"statistics course" "workshop course"</pre><p class="list-inset">The same recycling behavior also <span class="No-Break">appears here.</span></p></li>				<li>Compress the preceding output into a single string separated <span class="No-Break">by </span><span class="No-Break"><strong class="source-inline">+</strong></span><span class="No-Break">:</span><pre class="source-code">&#13;
&gt;&gt;&gt; str_c(c("statistics", "workshop"), "course", sep = " ", collapse = " + ")&#13;
"statistics course + workshop course"</pre></li>			</ol>&#13;
			<p>There are two other <a id="_idIndexMarker298"/>common <strong class="source-inline">stringr</strong> functions: <strong class="source-inline">str_length()</strong>, which returns the length of the <a id="_idIndexMarker299"/>string, and <strong class="source-inline">str_sub()</strong>, which subtracts parts of <span class="No-Break">the string:</span></p>&#13;
			<ul>&#13;
				<li>For example, we can get the length of each string in a vector, as shown in the following <span class="No-Break">code snippet.</span><pre class="source-code">&#13;
&gt;&gt;&gt; str_length(c("statistics", "workshop"))&#13;
10  8</pre></li>				<li>Alternatively, we can use the <strong class="source-inline">nchar()</strong> function from base R to achieve the same result, as <span class="No-Break">shown here:</span><pre class="source-code">&#13;
&gt;&gt;&gt; nchar(c("statistics", "workshop"))&#13;
10  8</pre></li>				<li>We can also use <strong class="source-inline">str_sub()</strong> to extract <a id="_idIndexMarker300"/>parts of the string by providing a starting and<a id="_idIndexMarker301"/> <span class="No-Break">ending index:</span><pre class="source-code">&#13;
&gt;&gt;&gt; str_sub(c("statistics", "workshop"), start = 1, end = 3)&#13;
"sta" "wor"</pre></li>			</ul>&#13;
			<p>Extracting parts of a string is one way to look for patterns in the string. In the next section, we will cover a more advanced approach for pattern matching beyond <span class="No-Break">positional indexing.</span></p>&#13;
			<h2 id="_idParaDest-67"><a id="_idTextAnchor068"/>Pattern matching in a string</h2>&#13;
			<p>Matching patterns in a string is a<a id="_idIndexMarker302"/> common way to extract intelligence from<a id="_idIndexMarker303"/> textual data. When a match is found, we could split or replace the string based on the match, add additional data such as the number of matches, or perform other text-based analyses. Let’s go through a few exercises to get familiar with <span class="No-Break">string matches.</span></p>&#13;
			<h3>Exercise 3.10 – locating matches in a string</h3>&#13;
			<p>In this exercise, we will cover <a id="_idIndexMarker304"/>three functions that are commonly used in locating a match in a string, including detecting a match using <strong class="source-inline">str_detect()</strong>, selecting the strings of a vector that have a match using <strong class="source-inline">str_subset()</strong>, and counting the number of matches in a string <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">str_count()</strong></span><span class="No-Break">:</span></p>&#13;
			<ol>&#13;
				<li>Detect the occurrence of <strong class="source-inline">stat</strong> in a vector of strings containing <strong class="source-inline">statistics</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">workshop</strong></span><span class="No-Break">:</span><pre class="source-code">&#13;
&gt;&gt;&gt; str_detect(c("statistics", "workshop"), "stat")&#13;
TRUE FALSE</pre><p class="list-inset">The <strong class="source-inline">str_detect()</strong> function<a id="_idIndexMarker305"/> looks for a specified pattern in the input strings and returns a logical vector of the same length as the input vector, with <strong class="source-inline">TRUE</strong> indicating a match and <span class="No-Break"><strong class="source-inline">FALSE</strong></span><span class="No-Break"> otherwise.</span></p></li>				<li>Subset<a id="_idIndexMarker306"/> the <a id="_idIndexMarker307"/>string that <span class="No-Break">contains </span><span class="No-Break"><strong class="source-inline">stat</strong></span><span class="No-Break">:</span><pre class="source-code">&#13;
&gt;&gt;&gt; str_subset(c("statistics", "workshop"), "stat")&#13;
"statistics"</pre><p class="list-inset">The <strong class="source-inline">str_subset()</strong> function<a id="_idIndexMarker308"/> completes detection and selection in one shot. It will return only the strings that match the <span class="No-Break">specified pattern.</span></p></li>				<li>Count the occurrence<a id="_idIndexMarker309"/> of <strong class="source-inline">t</strong> in each string of the <span class="No-Break">previous vector:</span><pre class="source-code">&#13;
&gt;&gt;&gt; str_count(c("statistics", "workshop"), "t")&#13;
3 0</pre><p class="list-inset">The <strong class="source-inline">str_count()</strong> function<a id="_idIndexMarker310"/> returns an integer vector of the same length as the input vector <a id="_idIndexMarker311"/>and shows each string’s frequency of a <span class="No-Break">particular</span><span class="No-Break"><a id="_idIndexMarker312"/></span><span class="No-Break"> match.</span></p></li>			</ol>&#13;
			<p>Next, we will look at how to split a string based on a <span class="No-Break">particular match.</span></p>&#13;
			<h2 id="_idParaDest-68"><a id="_idTextAnchor069"/>Splitting a string</h2>&#13;
			<p>Splitting a string based<a id="_idIndexMarker313"/> on a specific pattern can be achieved via the <strong class="source-inline">str_split()</strong> function, which <a id="_idIndexMarker314"/>assumes a similar naming and argument setting as in previous functions. The original string could then be decomposed into smaller pieces to support a more refined analysis. Let’s see how it can <span class="No-Break">be used.</span></p>&#13;
			<h3>Exercise 3.11 – splitting a string using str_split()</h3>&#13;
			<p>This exercise will <a id="_idIndexMarker315"/>use <strong class="source-inline">str_split()</strong> to decompose a string into <a id="_idIndexMarker316"/>smaller pieces based on a specific <span class="No-Break">matching condition:</span></p>&#13;
			<ol>&#13;
				<li>Separate the <strong class="source-inline">statistics &amp; machine learning workshop</strong> string at the <strong class="source-inline">&amp;</strong> <span class="No-Break">sign:</span><pre class="source-code">&#13;
&gt;&gt;&gt; str_split(c("statistics &amp; machine leaning workshop"), "&amp;")&#13;
[[1]]&#13;
[1] "statistics "               " machine leaning workshop"</pre><p class="list-inset">The result is a single-entry list that contains a vector of two elements in the first entry. Note that both the resulting substrings have a space inside, showing that the an exact pattern match is used to split the string. We could then include the space in the matching pattern to remove the spaces in the <span class="No-Break">resulting substrings.</span></p></li>				<li>Include preceding and trailing spaces in the <span class="No-Break">matching pattern:</span><pre class="source-code">&#13;
&gt;&gt;&gt; str_split(c("statistics &amp; machine leaning workshop"), " &amp; ")&#13;
[[1]]&#13;
[1] "statistics"               "machine leaning workshop"</pre><p class="list-inset">With that, the spaces in the substrings have been removed. As shown in the following code snippet, since the result is wrapped in a list, we can follow the list indexing rule to access the <span class="No-Break">corresponding element.</span></p></li>				<li>Access the second element from the <span class="No-Break">previous result:</span><pre class="source-code">&#13;
&gt;&gt;&gt; str_split(c("statistics &amp; machine leaning workshop"), " &amp; ")[[1]][2]&#13;
"machine leaning workshop"</pre><p class="list-inset">The result shows that we have successfully accessed the second element of the first entry in <span class="No-Break">the list.</span></p><p class="list-inset">As we learned in <a href="B18680_01.xhtml#_idTextAnchor014"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, <em class="italic">Getting Started with R</em>, a list is a flexible structure that can hold data of different types and lengths. This is particularly useful since we would not know how many substrings would be found in advance. See the <span class="No-Break">following example:</span></p><pre class="source-code">&gt;&gt;&gt; str_split(c("statistics &amp; machine leaning workshop", "stats &amp; ml &amp; workshop"), " &amp; ")&#13;
[[1]]&#13;
[1] "statistics"               "machine leaning workshop"&#13;
[[2]]&#13;
[1] "stats"    "ml"       "workshop"</pre><p class="list-inset">In this example, the <a id="_idIndexMarker317"/>first original string is split into two <a id="_idIndexMarker318"/>substrings while the second is split into three. Each original string corresponds to an entry in the list and can assume a different number <span class="No-Break">of substrings.</span></p><p class="list-inset">We can convert the return into a more structured and rectangular format, such as a DataFrame, by specifying the <strong class="source-inline">simplify</strong> argument <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">TRUE</strong></span><span class="No-Break">:</span></p><pre class="source-code">&gt;&gt;&gt; str_split(c("statistics &amp; machine leaning workshop", "stats &amp; ml &amp; workshop"), " &amp; ", simplify = TRUE)&#13;
     [,1]         [,2]                       [,3]&#13;
[1,] "statistics" "machine leaning workshop" ""&#13;
[2,] "stats"      "ml"                       "workshop"</pre><p class="list-inset">The <a id="_idIndexMarker319"/>resulting DataFrame will assume<a id="_idIndexMarker320"/> the same number of rows as the input vector and the same number of columns as the longest entry in <span class="No-Break">the list.</span></p></li>			</ol>&#13;
			<p>Next, we will look at replacing a matched pattern in <span class="No-Break">a string.</span></p>&#13;
			<h2 id="_idParaDest-69"><a id="_idTextAnchor070"/>Replacing a string</h2>&#13;
			<p>The <strong class="source-inline">str_replace()</strong> and <strong class="source-inline">str_replace_all()</strong> functions<a id="_idIndexMarker321"/> replace the matches with new text specified by<a id="_idIndexMarker322"/> the <strong class="source-inline">replacement</strong> argument. The difference is that <strong class="source-inline">str_replace()</strong> only replaces the first match, while <strong class="source-inline">str_replace_all()</strong> replaces<a id="_idIndexMarker323"/> all matches as its <span class="No-Break">name suggests.</span></p>&#13;
			<p>Let’s try replacing the <strong class="source-inline">&amp;</strong> sign with <strong class="source-inline">and</strong> using <span class="No-Break">both functions:</span></p>&#13;
			<pre class="source-code">&#13;
&gt;&gt;&gt; str_replace(c("statistics &amp; machine leaning workshop", "stats &amp; ml &amp; workshop"), pattern = "&amp;", replacement = "and")&#13;
"statistics and machine leaning workshop" "stats and ml &amp; workshop"&#13;
&gt;&gt;&gt; str_replace_all(c("statistics &amp; machine leaning workshop", "stats &amp; ml &amp; workshop"), pattern = "&amp;", replacement = "and")&#13;
"statistics and machine leaning workshop" "stats and ml and workshop"</pre>			<p>We can see that all <strong class="source-inline">&amp;</strong> signs are replaced by <strong class="source-inline">and</strong> in the second string. Again, replacing a particular match involves <a id="_idIndexMarker324"/>a two-step process: locating the match, if any, and performing the replacement. The <strong class="source-inline">str_replace()</strong> and <strong class="source-inline">str_replace_all()</strong> functions <a id="_idIndexMarker325"/>complete both steps in <span class="No-Break">one shot.</span></p>&#13;
			<p>In the next section, we will go through a bit of a challenge that requires combining these <span class="No-Break"><strong class="source-inline">stringr</strong></span><span class="No-Break"> functions.</span></p>&#13;
			<h2 id="_idParaDest-70"><a id="_idTextAnchor071"/>Putting it together</h2>&#13;
			<p>Often, a particular string processing task involves using more than one <strong class="source-inline">stringr</strong> function. Together, these functions could deliver useful transformations to the textual data. Let’s go through an exercise that puts together what we have covered <span class="No-Break">so far.</span></p>&#13;
			<h3>Exercise 3.12 – converting strings using multiple functions</h3>&#13;
			<p>In this exercise, we will use different<a id="_idIndexMarker326"/> string-based functions to convert <strong class="source-inline">statistics and machine leaning workshop</strong> into <strong class="source-inline">stats &amp; ml workshop</strong>. First, we will replace <strong class="source-inline">and</strong> with the <strong class="source-inline">&amp;</strong> sign, split the string, and work with the individual pieces. Let’s see how this can <span class="No-Break">be achieved:</span></p>&#13;
			<ol>&#13;
				<li>Create a <strong class="source-inline">title</strong> variable to hold the string and replace <strong class="source-inline">and</strong> <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">&amp;</strong></span><span class="No-Break">:</span><pre class="source-code">&#13;
&gt;&gt;&gt; title = "statistics and machine leaning workshop"&#13;
&gt;&gt;&gt; title = str_replace(title, pattern = "and", replacement = "&amp;")&#13;
&gt;&gt;&gt; title&#13;
"statistics &amp; machine leaning workshop"</pre><p class="list-inset">Here, we used <strong class="source-inline">str_replace()</strong> to replace <strong class="source-inline">and</strong> <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">&amp;</strong></span><span class="No-Break">.</span></p></li>				<li>Split <strong class="source-inline">title</strong> into substrings <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">&amp;</strong></span><span class="No-Break">:</span><pre class="source-code">&#13;
&gt;&gt;&gt; a = str_split(title, " &amp; ")&#13;
&gt;&gt;&gt; a&#13;
[[1]]&#13;
[1] "statistics"               "machine leaning workshop"</pre><p class="list-inset">Here, we used <strong class="source-inline">str_split()</strong> to split the original string into smaller substrings. Note that additional spaces are added to the matching pattern as well. We will work with these individual <span class="No-Break">pieces now.</span></p></li>				<li>Convert <strong class="source-inline">statistics</strong> <span class="No-Break">into </span><span class="No-Break"><strong class="source-inline">stats</strong></span><span class="No-Break">:</span><pre class="source-code">&#13;
&gt;&gt;&gt; b = str_c(str_sub(a[[1]][1], 1, 4), str_sub(a[[1]][1], -1, -1))&#13;
&gt;&gt;&gt; b&#13;
"stats"</pre><p class="list-inset">Here, we <a id="_idIndexMarker327"/>extracted the first four characters, namely <strong class="source-inline">stat</strong>, and the last character, <strong class="source-inline">s</strong>, using <strong class="source-inline">str_sub()</strong>, then concatenated them using <strong class="source-inline">str_c()</strong>. Note that <strong class="source-inline">-1</strong> indicates the last positional indexing of <span class="No-Break">a string.</span></p><p class="list-inset">Now, we can start to work on the <span class="No-Break">second part.</span></p></li>				<li>Split the second element of the <strong class="source-inline">a</strong> variable with <span class="No-Break">a space:</span><pre class="source-code">&#13;
&gt;&gt;&gt; c = unlist(str_split(a[[1]][2], " "))&#13;
&gt;&gt;&gt; c&#13;
"machine"  "leaning"  "workshop"</pre><p class="list-inset">Here, we used <strong class="source-inline">str_split()</strong> to split the <strong class="source-inline">machine leaning workshop</strong> string with a space and converted the result from a list into a vector using <strong class="source-inline">unlist()</strong>. We did this conversion to save some typing in the follow-up referencing since there is only one entry in the <span class="No-Break">returned list.</span></p><p class="list-inset">Now, we can repeat a similar step by extracting the first characters of <strong class="source-inline">machine</strong> and <strong class="source-inline">learning</strong> and combining them to <span class="No-Break">form </span><span class="No-Break"><strong class="source-inline">ml</strong></span><span class="No-Break">.</span></p></li>				<li>Form <strong class="source-inline">ml</strong> based on the <span class="No-Break">previous outputs:</span><pre class="source-code">&#13;
&gt;&gt;&gt; d = str_c(str_sub(c[1], 1, 1), str_sub(c[2], 1, 1))&#13;
&gt;&gt;&gt; d&#13;
"ml"</pre><p class="list-inset">Now, we can combine all the worked components into <span class="No-Break">one string.</span></p></li>				<li>Use the <a id="_idIndexMarker328"/>previous outputs to form the final <span class="No-Break">expected string:</span><pre class="source-code">&#13;
&gt;&gt;&gt; e = str_c(b, "&amp;", d, c[3], sep = " ")&#13;
&gt;&gt;&gt; e&#13;
"stats &amp; ml workshop"</pre></li>			</ol>&#13;
			<p>In the next section, we will learn about more advanced pattern matching techniques that use <span class="No-Break">regular expressions.</span></p>&#13;
			<h1 id="_idParaDest-71"><a id="_idTextAnchor072"/>Introducing regular expressions</h1>&#13;
			<p>A <strong class="bold">regular expression</strong> is a <a id="_idIndexMarker329"/>sequence of characters that bear a special meaning and are used for pattern matching in strings. Since the specific meaning of characters in a regular expression requires some memorization and can easily be forgotten if you do not use them often, we will avoid introducing its underlying syntax and focus on intuitive and more human-friendly programming using<a id="_idIndexMarker330"/> the <strong class="source-inline">rebus</strong> package. It is a good companion to <strong class="source-inline">stringr</strong> and provides utility functions that facilitate string manipulation and make building regular expressions much easier. Remember to install this package via <strong class="source-inline">install.package("rebus")</strong> when you use it for the <span class="No-Break">first time.</span></p>&#13;
			<p>The <strong class="source-inline">rebus</strong> package<a id="_idIndexMarker331"/> has a special operator called <strong class="source-inline">%R%</strong> that’s used to concatenate matching conditions. For example, to detect whether a string starts with a particular character, such as <strong class="source-inline">s</strong>, we could specify the pattern as <strong class="source-inline">START %R% "s"</strong> and pass it to the pattern argument of the <strong class="source-inline">str_detect()</strong> function, where <strong class="source-inline">START</strong> is a special keyword that’s used to indicate the start of a string. Similarly, the <strong class="source-inline">END</strong> keyword indicates the end of a string. Together, they are called anchors in the <strong class="source-inline">rebus</strong> library. Let’s look at the <span class="No-Break">following example:</span></p>&#13;
			<pre class="source-code">&#13;
&gt;&gt;&gt; str_detect(c("statistics", "machine learning"), pattern = START %R% "s")&#13;
TRUE FALSE</pre>			<p>We can also type <strong class="source-inline">START</strong> in the console. The result, which is a carat sign, is exactly the character used in vanilla regression expressions to indicate the start of <span class="No-Break">a string:</span></p>&#13;
			<pre class="source-code">&#13;
&gt;&gt;&gt; START&#13;
&lt;regex&gt; ^</pre>			<p>In addition, <strong class="source-inline">str_view()</strong> is<a id="_idIndexMarker332"/> another useful function that visualizes the matched parts of a string. Running the following command will bring up an HTML viewer panel with the matched <span class="No-Break">parts highlighted:</span></p>&#13;
			<pre class="source-code">&#13;
&gt;&gt;&gt; str_view(c("statistics", "machine learning"), pattern = START %R% "s")</pre>			<p>This is shown in <span class="No-Break"><em class="italic">Figure 3</em></span><span class="No-Break"><em class="italic">.1</em></span><span class="No-Break">:</span></p>&#13;
			<div>&#13;
				<div id="_idContainer021" class="IMG---Figure">&#13;
					<img src="Images/B18680_03_001.jpg" alt="Figure 3.1 – Visualizing the matching result in the viewer pane using str_view()" width="825" height="292"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.1 – Visualizing the matching result in the viewer pane using str_view()</p>&#13;
			<p>Let’s go through an exercise to learn more about the various pattern matching functions <span class="No-Break">in rebus.</span></p>&#13;
			<h3>Exercise 3.13 – applying regular expressions using rebus</h3>&#13;
			<p>In this exercise, we will apply <a id="_idIndexMarker333"/>different regular expressions to match the expected pattern in <span class="No-Break">the strings:</span></p>&#13;
			<ol>&#13;
				<li>Run the following command to create a vector of strings. Note that the strings are designed to be simple but good enough to demonstrate the purpose of the matching functions we will <span class="No-Break">introduce here:</span><pre class="source-code">&#13;
&gt;&gt;&gt; texts = c("stats 101", "machine learning", "R 101 ABC workshop", "101 R workshop")</pre></li>				<li>Search for a string from the vector that ends <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">learning</strong></span><span class="No-Break">:</span><pre class="source-code">&#13;
&gt;&gt;&gt; str_subset(texts, pattern = "learning" %R% END)&#13;
"machine learning"</pre><p class="list-inset">Here, we used the <strong class="source-inline">END</strong> keyword in the <strong class="source-inline">pattern</strong> argument to indicate that the string should end <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">learning</strong></span><span class="No-Break">.</span></p></li>				<li>Search for a string that contains any character followed <span class="No-Break">by </span><span class="No-Break"><strong class="source-inline">101</strong></span><span class="No-Break">:</span><pre class="source-code">&#13;
&gt;&gt;&gt; str_subset(texts, pattern = ANY_CHAR %R% "101")&#13;
"stats 101"          "R 101 ABC workshop"</pre><p class="list-inset">Note that <strong class="source-inline">ANY_CHAR</strong> is a special keyword, a wildcard that indicates any single character and corresponds to a dot in normal regression expressions, as shown in the <span class="No-Break">following code:</span></p><pre class="source-code">&gt;&gt;&gt; ANY_CHAR&#13;
&lt;regex&gt; .</pre><p class="list-inset">Since the<a id="_idIndexMarker334"/> pattern says any character followed by <strong class="source-inline">101</strong>, two strings have been selected due to the presence of <strong class="source-inline">101</strong>. <strong class="source-inline">101 R workshop</strong> has not been selected since there is no character <span class="No-Break">before </span><span class="No-Break"><strong class="source-inline">101</strong></span><span class="No-Break">.</span></p></li>				<li>Search for a string whose third character <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">a</strong></span><span class="No-Break">:</span><pre class="source-code">&#13;
&gt;&gt;&gt; str_subset(texts, pattern = START %R% ANY_CHAR %R% ANY_CHAR %R% "a")&#13;
"stats 101"</pre><p class="list-inset">Here, we specified the third character to be <strong class="source-inline">a</strong> by passing in two wildcard keywords at <span class="No-Break">the beginning.</span></p></li>				<li>Search for a string that starts with <strong class="source-inline">stats</strong> <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">R</strong></span><span class="No-Break">:</span><pre class="source-code">&#13;
&gt;&gt;&gt; str_subset(texts, pattern = START %R% or("stats", "R"))&#13;
"stats 101"          "R 101 ABC workshop"</pre><p class="list-inset">The <strong class="source-inline">or()</strong> function is useful when specifying more than one <span class="No-Break">matching condition.</span></p></li>				<li>Search for a string that contains one or more <strong class="source-inline">a</strong> or <span class="No-Break"><strong class="source-inline">A</strong></span><span class="No-Break"> characters:</span><pre class="source-code">&#13;
&gt;&gt;&gt; str_subset(texts, pattern = one_or_more(char_class("aA")))&#13;
"stats 101"          "machine learning"   "R 101 ABC workshop"</pre><p class="list-inset">Two new <a id="_idIndexMarker335"/>functions were used here. The <strong class="source-inline">char_class()</strong> function enforces matching one and only one of the allowable characters specified in the input argument, while the <strong class="source-inline">one_or_more()</strong> function says that the pattern wrapped within the parentheses could be repeated more <span class="No-Break">than once.</span></p></li>			</ol>&#13;
			<p>Next, we will cover the <strong class="source-inline">tidytext</strong> package, which allows us to conveniently work with unstructured textual data and the <span class="No-Break"><strong class="source-inline">tidyverse</strong></span><span class="No-Break"> ecosystem.</span></p>&#13;
			<h1 id="_idParaDest-72"><a id="_idTextAnchor073"/>Working with tidy text mining</h1>&#13;
			<p>The <strong class="source-inline">tidytext</strong> package handles <a id="_idIndexMarker336"/>unstructured text by following the tidy data<a id="_idIndexMarker337"/> principle, which mandates that data is represented as a structured, rectangular-shaped, and tibble-like object. In the case of text mining, this requires converting a piece of text in a single cell into one token per row in <span class="No-Break">the DataFrame.</span></p>&#13;
			<p>Another commonly used representation for a collection of texts (called<a id="_idIndexMarker338"/> a <strong class="bold">corpus</strong>) is <a id="_idIndexMarker339"/>the <strong class="bold">document-term matrix</strong>, where each row represents one document (this could be a short sentence or a lengthy article) and each column represents one term (a unique word in the whole corpus, for example). Each cell in the matrix usually contains a representative statistic, such as frequency of occurrence, to indicate the number of times the term appears in <span class="No-Break">the document.</span></p>&#13;
			<p>We will dive into both representations and look at how to convert between a document-term matrix and a tidy data format for text mining in the <span class="No-Break">following sections.</span></p>&#13;
			<h2 id="_idParaDest-73"><a id="_idTextAnchor074"/>Converting text into tidy data using unnest_tokens()</h2>&#13;
			<p>Let’s create <a id="_idIndexMarker340"/>a slightly different dummy dataset, <span class="No-Break">as follows:</span></p>&#13;
			<pre class="source-code">&#13;
texts = c("stats 101", "Machine Learning", "R and ML workshop", "R workshop &amp; Statistics with R")&#13;
texts_df = tibble(id = 1:length(texts), text = texts)&#13;
&gt;&gt;&gt; texts_df&#13;
# A tibble: 4 x 2&#13;
     id text&#13;
  &lt;int&gt; &lt;chr&gt;&#13;
1     1 stats 101&#13;
2     2 Machine Learning&#13;
3     3 R and ML workshop&#13;
4     4 R workshop &amp; Statistics with R</pre>			<p>The <strong class="source-inline">texts</strong> column<a id="_idIndexMarker341"/> in this dataset contains text of arbitrary length. Although it is stored as a tibble object, it is not quite suitable for tidy text analysis. For example, each row consists of multiple words in the <strong class="source-inline">texts</strong> column, making it challenging to derive statistical summaries such as the frequency of words. It would be much easier to get these statistics when each row corresponds to a single word for all <span class="No-Break">the text.</span></p>&#13;
			<p>Note that looking at word-level information is common in text mining, although we could extend to other variations such as pairs of words or even sentences. The unit of analysis used for text mining is called <a id="_idIndexMarker342"/>a <strong class="bold">token</strong>, and <strong class="bold">tokenization</strong> is the process of converting raw text into a series of tokens. Also, each row of<a id="_idIndexMarker343"/> text is often referred to as a document. In this case, we would like to have a data representation that has one token per row for each document, which can be achieved using the <strong class="source-inline">unnest_tokens()</strong> function from the <strong class="source-inline">tidytext</strong> package. Remember to install and load this package if you have not <span class="No-Break">done so.</span></p>&#13;
			<p>The <strong class="source-inline">unnest_tokens()</strong> function takes two inputs: the column used to host the resulting tokens from text, and the column whose text will be decomposed into tokens. There are also other aspects that the <strong class="source-inline">unnest_tokens()</strong> function takes care of when converting into a tidy text<a id="_idIndexMarker344"/> DataFrame. Let’s go through an exercise to learn more <span class="No-Break">about this.</span></p>&#13;
			<h3>Exercise 3.14 – building tidy text using unnest_tokens()</h3>&#13;
			<p>In this exercise, we <a id="_idIndexMarker345"/>will use <strong class="source-inline">unnest_tokens()</strong> to build<a id="_idIndexMarker346"/> tidy text and extract <span class="No-Break">word frequency:</span></p>&#13;
			<ol>&#13;
				<li>Convert <strong class="source-inline">texts_df</strong> into tidy text format using <strong class="source-inline">unnest_tokens()</strong> and name the token-holding column <strong class="source-inline">unit_token</strong>. Store the result <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">tidy_df</strong></span><span class="No-Break">:</span><pre class="source-code">&#13;
&gt;&gt;&gt; tidy_df &lt;- texts_df %&gt;%&#13;
  unnest_tokens(unit_token, text)&#13;
&gt;&gt;&gt; tidy_df&#13;
# A tibble: 13 x 2&#13;
      id unit_token&#13;
   &lt;int&gt; &lt;chr&gt;&#13;
1 stats&#13;
 2     1 101&#13;
 3     2 machine&#13;
 4     2 learning&#13;
 5     3 r&#13;
 6     3 and&#13;
 7     3 ml&#13;
 8     3 workshop&#13;
 9     4 r&#13;
10     4 workshop&#13;
11     4 statistics&#13;
12     4 with&#13;
13     4 r</pre><p class="list-inset">Note that <strong class="source-inline">unnest_tokens()</strong> uses word-level tokenization by default; thus, the <strong class="source-inline">unit_token</strong> column contains all the word tokens extracted from respective texts, and each word occupies one row. Note that the <strong class="source-inline">&amp;</strong> sign is removed from the result<a id="_idIndexMarker347"/> since <strong class="source-inline">unnest_tokens()</strong> removes all punctuation by default and converts all words into lowercase. The rest of the columns, such as <strong class="source-inline">id</strong>, are retained and duplicated for <a id="_idIndexMarker348"/>each word in the raw <span class="No-Break">text string.</span></p><p class="list-inset">We can also <a id="_idIndexMarker349"/>use <strong class="bold">n-grams</strong> representation, where <em class="italic">n</em> refers to the number of consecutive words used to form a unique token. When <em class="italic">n=2</em>, the tokenization is called<a id="_idIndexMarker350"/> a <span class="No-Break"><strong class="bold">bigram</strong></span><span class="No-Break"> representation.</span></p><p class="list-inset">Convert <strong class="source-inline">texts_df</strong> into tidy data using a bigram representation by specifying the token and <span class="No-Break"><em class="italic">n</em></span><span class="No-Break"> arguments:</span></p><pre class="source-code">&gt;&gt;&gt; tidy_df2 &lt;- texts_df %&gt;%&#13;
  unnest_tokens(unit_token, text, token = "ngrams", n = 2)&#13;
&gt;&gt;&gt; tidy_df2&#13;
# A tibble: 9 x 2&#13;
     id unit_token&#13;
  &lt;int&gt; &lt;chr&gt;&#13;
1     1 stats 101&#13;
2     2 machine learning&#13;
3     3 r and&#13;
4     3 and ml&#13;
5     3 ml workshop&#13;
6     4 r workshop&#13;
7     4 workshop statistics&#13;
8     4 statistics with&#13;
9     4 with r</pre><p class="list-inset">We can see that the resulting tokens consist of each consecutive pair of words in the original text. Again, punctuation removal and lowercase conversion are performed under <span class="No-Break">the hood.</span></p><p class="list-inset">We can easily derive the<a id="_idIndexMarker351"/> word frequency<a id="_idIndexMarker352"/> distribution with the tidy <span class="No-Break">data available.</span></p></li>				<li>Derive the word counts <span class="No-Break">from </span><span class="No-Break"><strong class="source-inline">tidy_df</strong></span><span class="No-Break">:</span><pre class="source-code">&#13;
&gt;&gt;&gt; tidy_df %&gt;%&#13;
count(unit_token, sort = TRUE)&#13;
# A tibble: 10 x 2&#13;
   unit_token     n&#13;
   &lt;chr&gt;      &lt;int&gt;&#13;
 1 r              3&#13;
 2 workshop       2&#13;
 3 101            1&#13;
 4 and            1&#13;
 5 learning       1&#13;
 6 machine        1&#13;
 7 ml             1&#13;
 8 statistics     1&#13;
 9 stats          1&#13;
10 with           1</pre><p class="list-inset">Here, we used the <strong class="source-inline">count()</strong> function to count the frequency of each unique word. We can also overlay this analysis with other <strong class="source-inline">dplyr</strong> operations, such as removing stop words (for example, <strong class="source-inline">the</strong> and <strong class="source-inline">a</strong>) from the word counts. Stop words are common words that do not convey additional meaning in text mining and are often <a id="_idIndexMarker353"/>removed from the corpus. We <a id="_idIndexMarker354"/>can inspect the list of English stop words using the <strong class="source-inline">get_stopwords()</strong> function, <span class="No-Break">as follows:</span></p><pre class="source-code">&gt;&gt;&gt; get_stopwords()&#13;
# A tibble: 175 x 2&#13;
   word      lexicon&#13;
   &lt;chr&gt;     &lt;chr&gt;&#13;
 1 i         snowball&#13;
 2 me        snowball&#13;
 3 my        snowball&#13;
 4 myself    snowball&#13;
 5 we        snowball&#13;
 6 our       snowball&#13;
 7 ours      snowball&#13;
 8 ourselves snowball&#13;
 9 you       snowball&#13;
10 your      snowball&#13;
# … with 165 more rows</pre></li>				<li>Derive the <a id="_idIndexMarker355"/>word frequency<a id="_idIndexMarker356"/> after removing the stop words. Store the result <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">tidy_df2</strong></span><span class="No-Break">:</span><pre class="source-code">&#13;
&gt;&gt;&gt; tidy_df2 = tidy_df %&gt;%&#13;
  filter(!(unit_token %in% get_stopwords()$word)) %&gt;%&#13;
  count(unit_token, sort = TRUE)&#13;
&gt;&gt;&gt; tidy_df2&#13;
# A tibble: 8 x 2&#13;
  unit_token     n&#13;
  &lt;chr&gt;      &lt;int&gt;&#13;
1 r              3&#13;
2 workshop       2&#13;
3 101            1&#13;
4 learning       1&#13;
5 machine        1&#13;
6 ml             1&#13;
7 statistics     1&#13;
8 stats          1</pre><p class="list-inset">We can<a id="_idIndexMarker357"/> see that <strong class="source-inline">and</strong> and <strong class="source-inline">with</strong> have been <a id="_idIndexMarker358"/>removed from <span class="No-Break">the result.</span></p></li>			</ol>&#13;
			<p>Next, we will work with text in the form of a document-term matrix, which is the most commonly used format when building machine learning models using <span class="No-Break">textual data.</span></p>&#13;
			<h2 id="_idParaDest-74"><a id="_idTextAnchor075"/>Working with a document-term matrix</h2>&#13;
			<p>We can convert the tidy <a id="_idIndexMarker359"/>DataFrame from earlier to and from a document-term matrix. Since we used unigram (single-word) representation in the previous exercise, we will continue working with unigram word frequency and look at how to transform between tidy data and a document-term matrix, as shown in the <span class="No-Break">following exercise.</span></p>&#13;
			<p>A commonly used package for text mining<a id="_idIndexMarker360"/> is <strong class="source-inline">tm</strong>. Remember to install and load this package before you continue with the <span class="No-Break">following exercise.</span></p>&#13;
			<h3>Exercise 3.15 – converting to and from a document-term matrix</h3>&#13;
			<p>In this exercise, we will get the word frequency table in a tidy format, followed by converting the table into a sparse document-term matrix. A sparse matrix<a id="_idIndexMarker361"/> is a special data structure that contains the same amount of information but occupies much less memory space than a typical DataFrame. Lastly, we will look at converting a document-term matrix back into <span class="No-Break">tidy format:</span></p>&#13;
			<ol>&#13;
				<li>Derive the word frequency count for each document and word token using <strong class="source-inline">tidy_df</strong> from the previous exercise. Save the result <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">count_df</strong></span><span class="No-Break">:</span><pre class="source-code">&#13;
&gt;&gt;&gt; count_df = tidy_df %&gt;%&#13;
  group_by(id, unit_token) %&gt;%&#13;
  summarise(count=n())&#13;
&gt;&gt;&gt; count_df&#13;
# A tibble: 12 x 3&#13;
# Groups:   id [4]&#13;
      id unit_token count&#13;
   &lt;int&gt; &lt;chr&gt;      &lt;int&gt;&#13;
 1     1 101            1&#13;
 2     1 stats          1&#13;
 3     2 learning       1&#13;
 4     2 machine        1&#13;
 5     3 and            1&#13;
 6     3 ml             1&#13;
 7     3 r              1&#13;
 8     3 workshop       1&#13;
 9     4 r              2&#13;
10     4 statistics     1&#13;
11     4 with           1&#13;
12     4 workshop       1</pre><p class="list-inset">Here, <strong class="source-inline">r</strong> appears twice in the fourth document, and all other words appear once. We will convert it into a document-term <span class="No-Break">matrix format.</span></p></li>				<li>Convert <strong class="source-inline">count_df</strong> into a <a id="_idIndexMarker362"/>document-term matrix by using the <strong class="source-inline">cast_dtm()</strong> function from the <strong class="source-inline">tm</strong> package and store the result <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">dtm</strong></span><span class="No-Break">:</span><pre class="source-code">&#13;
&gt;&gt;&gt; dtm = count_df %&gt;%&#13;
  cast_dtm(id, unit_token, count)&#13;
&gt;&gt;&gt; dtm&#13;
&lt;&lt;DocumentTermMatrix (documents: 4, terms: 10)&gt;&gt;&#13;
Non-/sparse entries: 12/28&#13;
Sparsity           : 70%&#13;
Maximal term length: 10&#13;
Weighting          : term frequency (tf)</pre><p class="list-inset">The result shows that we have a total of four documents and 10 terms. The sparsity is as high as 70% since most words appear only in their respective document. Also, the statistic used to represent a word in a document is the <span class="No-Break">term frequency.</span></p><p class="list-inset">We can also look at the whole table by specifically converting it into a <span class="No-Break">normal matrix:</span></p><pre class="source-code">&gt;&gt;&gt; as.data.frame(as.matrix(dtm), stringsAsFactors=False)&#13;
  101 stats learning machine and ml r workshop statistics with&#13;
1   1     1        0       0   0  0 0        0          0    0&#13;
2   0     0        1       1   0  0 0        0          0    0&#13;
3   0     0        0       0   1  1 1        1          0    0&#13;
4   0     0        0       0   0  0 2        1          1    1</pre><p class="list-inset">Now, we have <a id="_idIndexMarker363"/>the canonical document-term matrix. Note that we can use other statistics, such as <strong class="source-inline">tf-idf</strong>, to represent each cell in the matrix, or even use a vector of multiple numeric values to represent each word in a document. The latter is referred to as <strong class="bold">word embedding</strong>, which<a id="_idIndexMarker364"/> embeds each unique word into a numeric vector of a pre-specified length to achieve a more flexible and <span class="No-Break">powerful representation.</span></p></li>				<li>Convert <strong class="source-inline">dtm</strong> back into <span class="No-Break">tidy format:</span><pre class="source-code">&#13;
&gt;&gt;&gt; tidy_dtm = tidy(dtm)&#13;
&gt;&gt;&gt; tidy_dtm&#13;
# A tibble: 12 x 3&#13;
   document term       count&#13;
   &lt;chr&gt;    &lt;chr&gt;      &lt;dbl&gt;&#13;
 1 1        101            1&#13;
 2 1        stats          1&#13;
 3 2        learning       1&#13;
 4 2        machine        1&#13;
 5 3        and            1&#13;
 6 3        ml             1&#13;
 7 3        r              1&#13;
 8 4        r              2&#13;
 9 3        workshop       1&#13;
10 4        workshop       1&#13;
11 4        statistics     1&#13;
12 4        with           1</pre><p class="list-inset">Now, we have the same tidy data <span class="No-Break">as before.</span></p></li>			</ol>&#13;
			<h1 id="_idParaDest-75"><a id="_idTextAnchor076"/>Summary</h1>&#13;
			<p>In this chapter, we touched upon several intermediate data processing techniques, ranging from structured tabular data to unstructured textual data. First, we covered how to transform categorical and numeric variables, including recoding categorical variables using <strong class="source-inline">recode()</strong>, creating new variables using <strong class="source-inline">case_when()</strong>, and binning numeric variables using <strong class="source-inline">cut()</strong>. Next, we looked at reshaping a DataFrame, including converting a long-format DataFrame into a wide format using <strong class="source-inline">spread()</strong> and back again using <strong class="source-inline">gather()</strong>. We also delved into working with strings, including how to create, convert, and format <span class="No-Break">string data.</span></p>&#13;
			<p>In addition, we covered some essential knowledge regarding the <strong class="source-inline">stringr</strong> package, which provides many helpful utility functions to ease string processing tasks. Common functions include <strong class="source-inline">str_c()</strong>, <strong class="source-inline">str_sub()</strong>, <strong class="source-inline">str_subset()</strong>, <strong class="source-inline">str_detect()</strong>, <strong class="source-inline">str_split()</strong>, <strong class="source-inline">str_count()</strong>, and <strong class="source-inline">str_replace()</strong>. These functions can be combined to create a powerful and easy-to-understand string <span class="No-Break">processing pipeline.</span></p>&#13;
			<p>Then, we introduced regular expressions using the <strong class="source-inline">rebus</strong> package, which provides convenient pattern matching functionalities that work well with <strong class="source-inline">stringr</strong>. Its functions and keywords are easy to read, and they include <strong class="source-inline">START</strong>, <strong class="source-inline">END</strong>, <strong class="source-inline">ANY_CHAR</strong>, <strong class="source-inline">or()</strong>, <strong class="source-inline">one_or_more()</strong>, <span class="No-Break">and others.</span></p>&#13;
			<p>Lastly, we covered working with tidy text data using the <strong class="source-inline">tidytext</strong> package. Converting a set of textual data into a tidy format makes it easy to leverage the many utility functions from the <strong class="source-inline">tidyverse</strong> ecosystem. The <strong class="source-inline">unnest_tokens()</strong> function is often used to tidy up raw texts, and the tidy output can also be converted to and from a document-term matrix, the standard data structure used to develop machine <span class="No-Break">learning models.</span></p>&#13;
			<p>Text mining is a big topic, and we only covered the very basics in this chapter. Hopefully, the basic flavors presented here will encourage you to further explore the potential functionalities provided by the <span class="No-Break"><strong class="source-inline">tidyverse</strong></span><span class="No-Break"> ecosystem.</span></p>&#13;
			<p>In the next chapter, we will switch gears and cover data visualization, taking what we have processed and converting them into visual and <span class="No-Break">actionable insights.</span></p>&#13;
		</div>&#13;
	</div></body></html>