["```py\nfunc neuron(threshold int, inputs ...int) int {\n  var total int\n  for _, in := range inputs {\n    total += in\n  }\n  if total > threshold {\n    return 1\n  }\n  return 0\n}\n```", "```py\nfunc neuron(threshold, weights, inputs []int) int {\n  if len(weights) != len(inputs) {\n    panic(\"Expected length of weights to be the same as the length of inputs\")\n  }\n  var total int \n  for i, in := range inputs {\n    total += weights[i]*in\n  }\n  if total > threshold {\n    return 1\n  }\n  return 0\n}\n```", "```py\nfunc heaviside(a float64) float64 {\n  if a >= 0 {\n    return 1\n  }\n  return 0\n}\n```", "```py\nfunc neuron(weights, inputs []float64) float64 {\n  return heaviside(vectorDot(weights, inputs))\n}\n```", "```py\nfunc affine(weights [][]float64, inputs []float64) []float64 {\n  return activation(matVecMul(weights, inputs))\n}\n```", "```py\n// Image holds the pixel intensities of an image.\n// 255 is foreground (black), 0 is background (white).\ntype RawImage []byte\n\n// Label is a digit label in 0 to 9\ntype Label uint8\n\nconst numLabels = 10\nconst pixelRange = 255\n\nconst (\n  imageMagic = 0x00000803\n  labelMagic = 0x00000801\n  Width = 28\n  Height = 28\n)\n\nfunc readLabelFile(r io.Reader, e error) (labels []Label, err error) {\n  if e != nil {\n    return nil, e\n  }\n\n  var magic, n int32\n  if err = binary.Read(r, binary.BigEndian, &magic); err != nil {\n    return nil, err\n  }\n  if magic != labelMagic {\n    return nil, os.ErrInvalid\n  }\n  if err = binary.Read(r, binary.BigEndian, &n); err != nil {\n    return nil, err\n  }\n  labels = make([]Label, n)\n  for i := 0; i < int(n); i++ {\n    var l Label\n    if err := binary.Read(r, binary.BigEndian, &l); err != nil {\n      return nil, err\n    }\n    labels[i] = l\n  }\n  return labels, nil\n}\n\nfunc readImageFile(r io.Reader, e error) (imgs []RawImage, err error) {\n  if e != nil {\n    return nil, e\n  }\n\n  var magic, n, nrow, ncol int32\n  if err = binary.Read(r, binary.BigEndian, &magic); err != nil {\n    return nil, err\n  }\n  if magic != imageMagic {\n    return nil, err /*os.ErrInvalid*/\n  }\n  if err = binary.Read(r, binary.BigEndian, &n); err != nil {\n    return nil, err\n  }\n  if err = binary.Read(r, binary.BigEndian, &nrow); err != nil {\n    return nil, err\n  }\n  if err = binary.Read(r, binary.BigEndian, &ncol); err != nil {\n    return nil, err\n  }\n  imgs = make([]RawImage, n)\n  m := int(nrow * ncol)\n  for i := 0; i < int(n); i++ {\n    imgs[i] = make(RawImage, m)\n    m_, err := io.ReadFull(r, imgs[i])\n    if err != nil {\n      return nil, err\n    }\n    if m_ != int(m) {\n      return nil, os.ErrInvalid\n    }\n  }\n  return imgs, nil\n}\n```", "```py\nfunc pixelWeight(px byte) float64 {\n  retVal := float64(px)/pixelRange*0.9 + 0.1\n  if retVal == 1.0 {\n    return 0.999\n  }\n  return retVal\n}\n```", "```py\nfunc prepareX(M []RawImage) (retVal tensor.Tensor) {\n  rows := len(M)\n  cols := len(M[0])\n\n  b := make([]float64, 0, rows*cols)\n  for i := 0; i < rows; i++ {\n    for j := 0; j < len(M[i]); j++ {\n      b = append(b, pixelWeight(M[i][j]))\n    }\n  }\n  return tensor.New(tensor.WithShape(rows, cols), tensor.WithBacking(b))\n}\n```", "```py\nfunc prepareY(N []Label) (retVal tensor.Tensor) {\n  rows := len(N)\n  cols := 10\n\n  b := make([]float64, 0, rows*cols)\n  for i := 0; i < rows; i++ {\n    for j := 0; j < 10; j++ {\n      if j == int(N[i]) {\n        b = append(b, 1)\n      } else {\n        b = append(b, 0)\n      }\n    }\n  }\n  return tensor.New(tensor.WithShape(rows, cols), tensor.WithBacking(b))\n}\n\n```", "```py\nfunc reversePixelWeight(px float64) byte {\n  return byte(((px - 0.001) / 0.999) * pixelRange)\n}\n```", "```py\n// visualize visualizes the first N images given a data tensor that is made up of float64s.\n// It's arranged into (rows, 10) image.\n// Row counts are calculated by dividing N by 10 - we only ever want 10 columns.\n// For simplicity's sake, we will truncate any remainders.\nfunc visualize(data tensor.Tensor, rows, cols int, filename string) (err error) {\n  N := rows * cols\n\n  sliced := data\n  if N > 1 {\n    sliced, err = data.Slice(makeRS(0, N), nil) // data[0:N, :] in python\n    if err != nil {\n      return err\n    }\n  }\n\n  if err = sliced.Reshape(rows, cols, 28, 28); err != nil {\n    return err\n  }\n\n  imCols := 28 * cols\n  imRows := 28 * rows\n  rect := image.Rect(0, 0, imCols, imRows)\n  canvas := image.NewGray(rect)\n\n  for i := 0; i < cols; i++ {\n    for j := 0; j < rows; j++ {\n      var patch tensor.Tensor\n      if patch, err = sliced.Slice(makeRS(i, i+1), makeRS(j, j+1)); err != nil {\n        return err\n      }\n\n      patchData := patch.Data().([]float64)\n      for k, px := range patchData {\n        x := j*28 + k%28\n        y := i*28 + k/28\n        c := color.Gray{reversePixelWeight(px)}\n        canvas.Set(x, y, c)\n      }\n    }\n  }\n\n  var f io.WriteCloser\n  if f, err = os.Create(filename); err != nil {\n    return err\n  }\n\n  if err = png.Encode(f, canvas); err != nil {\n    f.Close()\n    return err\n  }\n\n  if err = f.Close(); err != nil {\n    return err\n  }\n  return nil\n}\n```", "```py\nfunc main() {\n  imgs, err := readImageFile(os.Open(\"train-images-idx3-ubyte\"))\n  if err != nil {\n    log.Fatal(err)\n  }\n  log.Printf(\"len imgs %d\", len(imgs))\n\n  data := prepareX(imgs)\n  visualize(data, 100, \"image.png\")\n}\n```", "```py\nfunc zca(data tensor.Tensor) (retVal tensor.Tensor, err error) {\n  var dataᵀ, data2, sigma tensor.Tensor\n  data2 = data.Clone().(tensor.Tensor)\n\n  if err := minusMean(data2); err != nil {\n    return nil, err\n  }\n  if dataᵀ, err = tensor.T(data2); err != nil {\n    return nil, err\n  }\n\n  if sigma, err = tensor.MatMul(dataᵀ, data2); err != nil {\n    return nil, err\n  }\n\n  cols := sigma.Shape()[1]\n  if _, err = tensor.Div(sigma, float64(cols-1), tensor.UseUnsafe()); err != nil {\n    return nil, err\n  }\n\n  s, u, _, err := sigma.(*tensor.Dense).SVD(true, true)\n  if err != nil {\n    return nil, err\n  }\n\n  var diag, uᵀ, tmp tensor.Tensor\n  if diag, err = s.Apply(invSqrt(0.1), tensor.UseUnsafe()); err != nil {\n    return nil, err\n  }\n  diag = tensor.New(tensor.AsDenseDiag(diag))\n\n  if uᵀ, err = tensor.T(u); err != nil {\n    return nil, err\n  }\n\n  if tmp, err = tensor.MatMul(u, diag); err != nil {\n    return nil, err\n  }\n\n  if tmp, err = tensor.MatMul(tmp, uᵀ); err != nil {\n    return nil, err\n  }\n\n  if err = tmp.T(); err != nil {\n    return nil, err\n  }\n\n  return tensor.MatMul(data, tmp)\n}\n\nfunc invSqrt(epsilon float64) func(float64) float64 {\n  return func(a float64) float64 {\n    return 1 / math.Sqrt(a+epsilon)\n  }\n}\n```", "```py\nfunc minusMean(a tensor.Tensor) error {\n  nat, err := native.MatrixF64(a.(*tensor.Dense))\n  if err != nil {\n    return err\n  }\n  for _, row := range nat {\n    mean := avg(row)\n    vecf64.Trans(row, -mean)\n  }\n\n  rows, cols := a.Shape()[0], a.Shape()[1]\n\n  mean := make([]float64, cols)\n  for j := 0; j < cols; j++ {\n    var colMean float64\n    for i := 0; i < rows; i++ {\n      colMean += nat[i][j]\n    }\n    colMean /= float64(rows)\n    mean[j] = colMean\n  }\n\n  for _, row := range nat {\n    vecf64.Sub(row, mean)\n  }\n\n  return nil\n}\n```", "```py\n  for j := 0; j < cols; j++ {\n    var colMean float64\n    for i := 0; i < rows; i++ {\n      colMean += nat[i][j]\n    }\n    colMean /= float64(rows)\n    mean[j] = colMean\n  }\n```", "```py\n  for _, row := range nat {\n    vecf64.Sub(row, mean)\n  }\n```", "```py\n  for _, row := range nat {\n    for j := range row {\n      row[j] -= mean[j]\n    }\n  }\n```", "```py\n  if dataᵀ, err = tensor.T(data2); err != nil {\n    return nil, err\n  }\n```", "```py\n  var sigma tensor.Tensor\n  if sigma, err = tensor.MatMul(dataᵀ, data2); err != nil {\n    return nil, err\n  }\n```", "```py\n  cols := sigma.Shape()[1]\n  if _, err = tensor.Div(sigma, float64(cols-1), tensor.UseUnsafe()); err != nil {\n    return nil, err\n  }\n```", "```py\n  s, u, _, err := sigma.(*tensor.Dense).SVD(true, true)\n  if err != nil {\n    return nil, err\n  }\n```", "```py\ntype NN struct {\n  hidden, final *tensor.Dense\n  b0, b1 float64\n}\n```", "```py\nfunc New(input, hidden, output int) (retVal *NN) {\n  r := make([]float64, hidden*input)\n  r2 := make([]float64, hidden*output)\n  fillRandom(r, float64(len(r)))\n  fillRandom(r2, float64(len(r2)))\n  hiddenT := tensor.New(tensor.WithShape(hidden, input), tensor.WithBacking(r))\n  finalT := tensor.New(tensor.WithShape(output, hidden), tensor.WithBacking(r2))\n  return &NN{\n    hidden: hiddenT,\n    final: finalT,\n  }\n}\n```", "```py\nfunc fillRandom(a []float64, v float64) {\n  dist := distuv.Uniform{\n    Min: -1 / math.Sqrt(v),\n    Max: 1 / math.Sqrt(v),\n  }\n  for i := range a {\n    a[i] = dist.Rand()\n  }\n}\n```", "```py\nfunc (nn *NN) Predict(a tensor.Tensor) (int, error) {\n  if a.Dims() != 1 {\n    return -1, errors.New(\"Expected a vector\")\n  }\n\n  var m maybe\n  hidden := m.do(func() (tensor.Tensor, error) { return nn.hidden.MatVecMul(a) })\n  act0 := m.do(func() (tensor.Tensor, error) { return hidden.Apply(sigmoid, tensor.UseUnsafe()) })\n\n  final := m.do(func() (tensor.Tensor, error) { return tensor.MatVecMul(nn.final, act0) })\n  pred := m.do(func() (tensor.Tensor, error) { return final.Apply(sigmoid, tensor.UseUnsafe()) })\n\n  if m.err != nil {\n    return -1, m.err\n  }\n  return argmax(pred.Data().([]float64)), nil\n}\n```", "```py\ntype maybe struct {\n  err error\n}\n\nfunc (m *maybe) do(fn func() (tensor.Tensor, error)) tensor.Tensor {\n  if m.err != nil {\n    return nil\n  }\n\n  var retVal tensor.Tensor\n  if retVal, m.err = fn(); m.err == nil {\n    return retVal\n  }\n  m.err = errors.WithStack(m.err)\n  return nil\n}\n```", "```py\nif foo, err := bar(); err != nil {\n  return err\n}\n```", "```py\nfunc (m *maybe) sigmoid(a tensor.Tensor) (retVal tensor.Tensor){\n  if m.err != nil {\n    return nil\n  }\n  if retVal, m.err = a.Apply(sigmoid); m.err == nil {\n    return retVal\n  }\n  m.err = errors.WithStack(m.err)\n  return nil\n}\n```", "```py\nfunc affine(weights [][]float64, inputs []float64) []float64 {\n  return activation(matVecMul(weights, inputs))\n}\n```", "```py\nfunc affine(weights [][]float64, inputs []float64) []float64 {\n  return activation(matVecMul(weights, inputs))\n}\n```", "```py\n  // backpropagation\n  outputErrors := m.do(func() (tensor.Tensor, error) { return tensor.Sub(y, pred) })\n  cost = sum(outputErrors.Data().([]float64))\n\n  hidErrs := m.do(func() (tensor.Tensor, error) {\n    if err := nn.final.T(); err != nil {\n      return nil, err\n    }\n    defer nn.final.UT()\n    return tensor.MatMul(nn.final, outputErrors)\n  })\n\n  if m.err != nil {\n    return 0, m.err\n  }\n\n  dpred := m.do(func() (tensor.Tensor, error) { return pred.Apply(dsigmoid, tensor.UseUnsafe()) })\n  m.do(func() (tensor.Tensor, error) { return tensor.Mul(pred, outputErrors, tensor.UseUnsafe()) })\n  // m.do(func() (tensor.Tensor, error) { err := act0.T(); return act0, err })\n  dpred_dfinal := m.do(func() (tensor.Tensor, error) {\n    if err := act0.T(); err != nil {\n      return nil, err\n    }\n    defer act0.UT()\n    return tensor.MatMul(outputErrors, act0)\n  })\n\n  dact0 := m.do(func() (tensor.Tensor, error) { return act0.Apply(dsigmoid) })\n  m.do(func() (tensor.Tensor, error) { return tensor.Mul(hidErrs, dact0, tensor.UseUnsafe()) })\n  m.do(func() (tensor.Tensor, error) { err := hidErrs.Reshape(hidErrs.Shape()[0], 1); return hidErrs, err })\n  // m.do(func() (tensor.Tensor, error) { err := x.T(); return x, err })\n  dcost_dhidden := m.do(func() (tensor.Tensor, error) {\n    if err := x.T(); err != nil {\n      return nil, err\n    }\n    defer x.UT()\n    return tensor.MatMul(hidErrs, x)\n  })\n```", "```py\n  // gradient update\n  m.do(func() (tensor.Tensor, error) { return tensor.Mul(dcost_dfinal, learnRate, tensor.UseUnsafe()) })\n  m.do(func() (tensor.Tensor, error) { return tensor.Mul(dcost_dhidden, learnRate, tensor.UseUnsafe()) })\n  m.do(func() (tensor.Tensor, error) { return tensor.Add(nn.final, dcost_dfinal, tensor.UseUnsafe()) })\n  m.do(func() (tensor.Tensor, error) { return tensor.Add(nn.hidden, dcost_dhidden, tensor.UseUnsafe()) })\n```", "```py\n// X is the image, Y is a one hot vector\nfunc (nn *NN) Train(x, y tensor.Tensor, learnRate float64) (cost float64, err error) {\n  // predict\n  var m maybe\n  m.do(func() (tensor.Tensor, error) { err := x.Reshape(x.Shape()[0], 1); return x, err })\n  m.do(func() (tensor.Tensor, error) { err := y.Reshape(10, 1); return y, err })\n\n  hidden := m.do(func() (tensor.Tensor, error) { return tensor.MatMul(nn.hidden, x) })\n  act0 := m.do(func() (tensor.Tensor, error) { return hidden.Apply(sigmoid, tensor.UseUnsafe()) })\n\n  final := m.do(func() (tensor.Tensor, error) { return tensor.MatMul(nn.final, act0) })\n  pred := m.do(func() (tensor.Tensor, error) { return final.Apply(sigmoid, tensor.UseUnsafe()) })\n  // log.Printf(\"pred %v, correct %v\", argmax(pred.Data().([]float64)), argmax(y.Data().([]float64)))\n\n  // backpropagation.\n  outputErrors := m.do(func() (tensor.Tensor, error) { return tensor.Sub(y, pred) })\n  cost = sum(outputErrors.Data().([]float64))\n\n  hidErrs := m.do(func() (tensor.Tensor, error) {\n    if err := nn.final.T(); err != nil {\n      return nil, err\n    }\n    defer nn.final.UT()\n    return tensor.MatMul(nn.final, outputErrors)\n  })\n\n  if m.err != nil {\n    return 0, m.err\n  }\n\n  dpred := m.do(func() (tensor.Tensor, error) { return pred.Apply(dsigmoid, tensor.UseUnsafe()) })\n  m.do(func() (tensor.Tensor, error) { return tensor.Mul(pred, outputErrors, tensor.UseUnsafe()) })\n  // m.do(func() (tensor.Tensor, error) { err := act0.T(); return act0, err })\n  dpred_dfinal := m.do(func() (tensor.Tensor, error) {\n    if err := act0.T(); err != nil {\n      return nil, err\n    }\n    defer act0.UT()\n    return tensor.MatMul(outputErrors, act0)\n  })\n\n  dact0 := m.do(func() (tensor.Tensor, error) { return act0.Apply(dsigmoid) })\n  m.do(func() (tensor.Tensor, error) { return tensor.Mul(hidErrs, dact0, tensor.UseUnsafe()) })\n  m.do(func() (tensor.Tensor, error) { err := hidErrs.Reshape(hidErrs.Shape()[0], 1); return hidErrs, err })\n  // m.do(func() (tensor.Tensor, error) { err := x.T(); return x, err })\n  dcost_dhidden := m.do(func() (tensor.Tensor, error) {\n    if err := x.T(); err != nil {\n      return nil, err\n    }\n    defer x.UT()\n    return tensor.MatMul(hidErrs, x)\n  })\n\n  // gradient update\n  m.do(func() (tensor.Tensor, error) { return tensor.Mul(dcost_dfinal, learnRate, tensor.UseUnsafe()) })\n  m.do(func() (tensor.Tensor, error) { return tensor.Mul(dcost_dhidden, learnRate, tensor.UseUnsafe()) })\n  m.do(func() (tensor.Tensor, error) { return tensor.Add(nn.final, dcost_dfinal, tensor.UseUnsafe()) })\n  m.do(func() (tensor.Tensor, error) { return tensor.Add(nn.hidden, dcost_dhidden, tensor.UseUnsafe()) })\n  return cost, m.err\n```", "```py\nfunc main() {\n  imgs, err := readImageFile(os.Open(\"train-images-idx3-ubyte\"))\n  if err != nil {\n    log.Fatal(err)\n  }\n  labels, err := readLabelFile(os.Open(\"train-labels-idx1-ubyte\"))\n  if err != nil {\n    log.Fatal(err)\n  }\n\n  log.Printf(\"len imgs %d\", len(imgs))\n  data := prepareX(imgs)\n  lbl := prepareY(labels)\n  visualize(data, 10, 10, \"image.png\")\n\n  data2, err := zca(data)\n  if err != nil {\n    log.Fatal(err)\n  }\n  visualize(data2, 10, 10, \"image2.png\")\n\n  nat, err := native.MatrixF64(data2.(*tensor.Dense))\n  if err != nil {\n    log.Fatal(err)\n  }\n\n  log.Printf(\"Start Training\")\n  nn := New(784, 100, 10)\n  costs := make([]float64, 0, data2.Shape()[0])\n  for e := 0; e < 5; e++ {\n    data2Shape := data2.Shape()\n    var oneimg, onelabel tensor.Tensor\n    for i := 0; i < data2Shape[0]; i++ {\n      if oneimg, err = data2.Slice(makeRS(i, i+1)); err != nil {\n        log.Fatalf(\"Unable to slice one image %d\", i)\n      }\n      if onelabel, err = lbl.Slice(makeRS(i, i+1)); err != nil {\n        log.Fatalf(\"Unable to slice one label %d\", i)\n      }\n      var cost float64\n      if cost, err = nn.Train(oneimg, onelabel, 0.1); err != nil {\n        log.Fatalf(\"Training error: %+v\", err)\n      }\n      costs = append(costs, cost)\n    }\n    log.Printf(\"%d\\t%v\", e, avg(costs))\n    shuffleX(nat)\n    costs = costs[:0]\n  }\n  log.Printf(\"End training\")\n}\n```", "```py\n  log.Printf(\"Start testing\")\n  testImgs, err := readImageFile(os.Open(\"t10k-images.idx3-ubyte\"))\n  if err != nil {\n    log.Fatal(err)\n  }\n\n  testlabels, err := readLabelFile(os.Open(\"t10k-labels.idx1-ubyte\"))\n  if err != nil {\n    log.Fatal(err)\n  }\n\n  testData := prepareX(testImgs)\n  testLbl := prepareY(testlabels)\n  shape := testData.Shape()\n  testData2, err := zca(testData)\n  if err != nil {\n    log.Fatal(err)\n  }\n\n  visualize(testData, 10, 10, \"testData.png\")\n  visualize(testData2, 10, 10, \"testData2.png\")\n\n  var correct, total float64\n  var oneimg, onelabel tensor.Tensor\n  var predicted, errcount int\n  for i := 0; i < shape[0]; i++ {\n    if oneimg, err = testData.Slice(makeRS(i, i+1)); err != nil {\n      log.Fatalf(\"Unable to slice one image %d\", i)\n    }\n    if onelabel, err = testLbl.Slice(makeRS(i, i+1)); err != nil {\n      log.Fatalf(\"Unable to slice one label %d\", i)\n    }\n    if predicted, err = nn.Predict(oneimg); err != nil {\n      log.Fatalf(\"Failed to predict %d\", i)\n    }\n\n    label := argmax(onelabel.Data().([]float64))\n    if predicted == label {\n      correct++\n    } else if errcount < 5 {\n      visualize(oneimg, 1, 1, fmt.Sprintf(\"%d_%d_%d.png\", i, label, predicted))\n      errcount++\n    }\n    total++\n  }\n  fmt.Printf(\"Correct/Totals: %v/%v = %1.3f\\n\", correct, total, correct/total)\n```", "```py\n$ go build . -o chapter7\n $ ./chapter7\n Corerct/Totals: 9719/10000 = 0.972\n```", "```py\n    if predicted == label {\n      correct++\n    } else if errcount < 5 {\n      visualize(oneimg, 1, 1, fmt.Sprintf(\"%d_%d_%d.png\", i, label, predicted))\n      errcount++\n    }\n```"]