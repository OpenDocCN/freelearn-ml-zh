["```py\nmodule X\n # your code\nend\n```", "```py\n# Calculator.jl\nmodule Calculator\n\nexport interest, rate\n\n\"\"\"\n interest(amount, rate)\n\nCalculate interest from an `amount` and interest rate of `rate`.\n\"\"\"\nfunction interest(amount, rate)\n return amount * (1 + rate)\nend\n\n\"\"\"\n rate(amount, interest)\n\nCalculate interest rate based on an `amount` and `interest`.\n\"\"\"\nfunction rate(amount, interest)\n return interest / amount\nend\n\nend # module\n```", "```py\nexport interest, rate\n```", "```py\nusing Calculator: interest\nusing Rater: rate\n\n# Here, the rate function refers to the one defined in Rater module.\n```", "```py\nimport Calculator\nimport Rater\n\ninterest_rate = Calculator.rate(100.00, 3.5)\nrating = Rater.rate(\"Hands-On Design Patterns with Julia\")\n```", "```py\n# Calculator.jl\nmodule Calculator\n\ninclude(\"Mortgage.jl\")\ninclude(\"Banking.jl\")\n\nend # module\n```", "```py\n# Mortgage.jl\nmodule Mortgage\n\n# mortgage related source code\n\nend # module\n```", "```py\n<major>.<minor>.<patch>\n```", "```py\n<major>.<minor>.<patch>-<pre-release>+<build>\n```", "```py\n[compat]\nSaferIntegers = \"1.1.1\"\n```", "```py\n[compat]\nSaferIntegers = \"1.1.1, 2\"\n```", "```py\nabstract type Asset end\n\nabstract type Property <: Asset end\nabstract type Investment <: Asset end\nabstract type Cash <: Asset end\n\nabstract type House <: Property end\nabstract type Apartment <: Property end\n\nabstract type FixedIncome <: Investment end\nabstract type Equity <: Investment end\n```", "```py\n# Display the entire type hierarchy starting from the specified `roottype`\nfunction subtypetree(roottype, level = 1, indent = 4)\n    level == 1 && println(roottype)\n    for s in subtypes(roottype)\n       println(join(fill(\" \", level * indent)) * string(s))\n       subtypetree(s, level + 1, indent)\n    end\nend\n```", "```py\n# simple functions on abstract types\ndescribe(a::Asset) = \"Something valuable\"\ndescribe(e::Investment) = \"Financial investment\"\ndescribe(e::Property) = \"Physical property\"\n```", "```py\n\"\"\"\n location(p::Property) \n\nReturns the location of the property as a tuple of (latitude, longitude).\n\"\"\"\nlocation(p::Property) = error(\"Location is not defined in the concrete type\")\n```", "```py\n\"\"\"\n location(p::Property) \n\nReturns the location of the property as a tuple of (latitude, longitude).\n\"\"\"\nfunction location(p::Property) end\n```", "```py\nfunction walking_disance(p1::Property, p2::Property)\n    loc1 = location(p1)\n    loc2 = location(p2)\n    return abs(loc1.x - loc2.x) + abs(loc1.y - loc2.y)\nend\n```", "```py\nstruct Stock <: Equity\n    symbol::String\n    name::String\nend\n```", "```py\nfunction describe(s::Stock)\n    return s.symbol * \"(\" * s.name * \")\"\nend\n```", "```py\nstruct BasketOfStocks\n    stocks::Vector{Stock}\n    reason::String\nend\n```", "```py\nmutable struct Stock <: Equity\n    symbol::String\n    name::String\nend\n```", "```py\nUnion{Int64,BigInt}\n```", "```py\nabstract type Art end\n\nstruct Painting <: Art\n    artist::String\n    title::String\nend\n```", "```py\nstruct BasketOfThings\n things::Vector{Union{Painting,Stock}}\n reason::String\nend\n```", "```py\nconst Thing = Union{Painting,Stock}\n\nstruct BasketOfThings\n    thing::Vector{Thing}\n    reason::String\nend\n```", "```py\nstruct Stock <: Equity\n    symbol::String\n    name::String\nend\n```", "```py\nstruct StockHolding\n    stock::Stock\n    quantity::Int\nend\n```", "```py\nstruct StockHolding\n    stock::Stock\n    quantity::Float64\nend\n```", "```py\nstruct StockHolding{T} \n    stock::Stock\n    quantity::T\nend\n```", "```py\nstruct StockHolding{T <: Real} \n    stock::Stock\n    quantity::T\nend\n```", "```py\nstruct StockHolding2{T <: Real, P <: AbstractFloat} \n    stock::Stock\n    quantity::T\n    price::P\n    marketvalue::P\nend\n```", "```py\nabstract type Holding{P} end\n```", "```py\nstruct StockHolding3{T, P} <: Holding{P}\n\n stock::Stock\n quantity::T\n price::P\n marketvalue::P\nend\n\nstruct CashHolding{P} <: Holding{P}\n currency::String\n amount::P\n marketvalue::P\nend\n```", "```py\nconvert(::Type{T}, x::T) where {T<:Number} = x\nconvert(::Type{T}, x::Number) where {T<:Number} = T(x)\n```"]