["```py\nimport numpy as np \nfrom PIL import Image, ImageDraw, ImageFont \nfrom skimage import transform as tf\n\n```", "```py\ndef create_captcha(text, shear=0, size=(100, 30), scale=1):\n    im = Image.new(\"L\", size, \"black\")\n    draw = ImageDraw.Draw(im)\n    font = ImageFont.truetype(r\"bretan/Coval-Black.otf\", 22) \n    draw.text((0, 0), text, fill=1, font=font)\n    image = np.array(im)\n    affine_tf = tf.AffineTransform(shear=shear)\n    image = tf.warp(image, affine_tf)\n    image = image / image.max()\n    # Apply scale\n    shape = image.shape\n    shapex, shapey = (int(shape[0] * scale), int(shape[1] * scale))\n    image = tf.resize(image, (shapex, shapey))\n    return image\n\n```", "```py\n%matplotlib inline\nfrom matplotlib import pyplot as plt\nimage = create_captcha(\"GENE\", shear=0.5, scale=0.6)\nplt.imshow(image, cmap='Greys')\n\n```", "```py\nimage = create_captcha(\"SEND\", shear=0.1, scale=1.0)\nplt.imshow(image, cmap='Greys')\n\n```", "```py\nimage = create_captcha(\"BARK\", shear=0.8, scale=1.0)\nplt.imshow(image, cmap='Greys')\n\n```", "```py\nimage = create_captcha(\"WOOF\", shear=0.25, scale=1.5)\nplt.imshow(image, cmap='Greys')\n\n```", "```py\nfrom skimage.measure import label, regionprops\n\ndef segment_image(image):\n    # label will find subimages of connected non-black pixels\n    labeled_image = label(image>0.2, connectivity=1, background=0)\n    subimages = []\n    # regionprops splits up the subimages\n    for region in regionprops(labeled_image):\n        # Extract the subimage\n        start_x, start_y, end_x, end_y = region.bbox\n        subimages.append(image[start_x:end_x,start_y:end_y])\n        if len(subimages) == 0:\n            # No subimages found, so return the entire image\n            return [image,]\n    return subimages\n\n```", "```py\nsubimages = segment_image(image)\n\n```", "```py\nf, axes = plt.subplots(1, len(subimages), figsize=(10, 3)) \nfor i in range(len(subimages)): \n    axes[i].imshow(subimages[i], cmap=\"gray\")\n\n```", "```py\nimage = create_captcha(\"WOOF\", shear=0.25, scale=1.5)\nsubimages = segment_image(image)\nf, axes = plt.subplots(1, len(subimages), figsize=(10, 3), sharey=True) \nfor i in range(len(subimages)): \n    axes[i].imshow(subimages[i], cmap=\"gray\")\n\n```", "```py\nfrom sklearn.utils import check_random_state\nrandom_state = check_random_state(14) \nletters = list(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\") \nshear_values = np.arange(0, 0.5, 0.05)\nscale_values = np.arange(0.5, 1.5, 0.1)\n\n```", "```py\ndef generate_sample(random_state=None): \n    random_state = check_random_state(random_state) \n    letter = random_state.choice(letters) \n    shear = random_state.choice(shear_values)\n    scale = random_state.choice(scale_values)\n    # We use 30,30 as the image size to ensure we get all the text in the image\n    return create_captcha(letter, shear=shear, size=(30, 30), scale=scale), letters.index(letter)\n\n```", "```py\nimage, target = generate_sample(random_state) \nplt.imshow(image, cmap=\"Greys\") \nprint(\"The target for this image is: {0}\".format(target))\n\n```", "```py\ndataset, targets = zip(*(generate_sample(random_state) for i in range(1000))) \ndataset = np.array([tf.resize(segment_image(sample)[0], (20, 20)) for sample in dataset])\ndataset = np.array(dataset, dtype='float') \ntargets = np.array(targets)\n\n```", "```py\nfrom sklearn.preprocessing import OneHotEncoder \nonehot = OneHotEncoder() \ny = onehot.fit_transform(targets.reshape(targets.shape[0],1))\n\n```", "```py\ny = y.todense()\nX = dataset.reshape((dataset.shape[0], dataset.shape[1] * dataset.shape[2]))\n\n```", "```py\nfrom sklearn.cross_validation import train_test_split \nX_train, X_test, y_train, y_test = train_test_split(X, y, train_size=0.9)\n\n```", "```py\nfrom sklearn.neural_network import MLPClassifier\nclf = MLPClassifier(hidden_layer_sizes=(100,), random_state=14)\n\n```", "```py\n{'activation': 'relu',\n 'alpha': 0.0001,\n 'batch_size': 'auto',\n 'beta_1': 0.9,\n 'beta_2': 0.999,\n 'early_stopping': False,\n 'epsilon': 1e-08,\n 'hidden_layer_sizes': (100,),\n 'learning_rate': 'constant',\n 'learning_rate_init': 0.001,\n 'max_iter': 200,\n 'momentum': 0.9,\n 'nesterovs_momentum': True,\n 'power_t': 0.5,\n 'random_state': 14,\n 'shuffle': True,\n 'solver': 'adam',\n 'tol': 0.0001,\n 'validation_fraction': 0.1,\n 'verbose': False,\n 'warm_start': False}\n\n```", "```py\nclf.fit(X_train, y_train)\n\n```", "```py\ny_pred = clf.predict(X_test)\n\n```", "```py\nfrom sklearn.metrics import f1_score\nf1_score(y_pred=y_pred, y_true=y_test, average='macro')\n\n```", "```py\nfrom sklearn.metrics import classification_report\nprint(classification_report(y_pred=y_pred, y_true=y_test))\n\n```", "```py\n             precision    recall  f1-score   support\n\n          0       1.00      1.00      1.00         5\n          1       1.00      1.00      1.00         3\n          2       1.00      1.00      1.00         3\n          3       1.00      1.00      1.00         8\n          4       1.00      1.00      1.00         2\n          5       1.00      1.00      1.00         4\n          6       1.00      1.00      1.00         2\n          7       1.00      1.00      1.00         2\n          8       1.00      1.00      1.00         7\n          9       1.00      1.00      1.00         1\n         10       1.00      1.00      1.00         3\n         11       1.00      1.00      1.00         4\n         12       1.00      0.75      0.86         4\n         13       1.00      1.00      1.00         5\n         14       1.00      1.00      1.00         4\n         15       1.00      1.00      1.00         3\n         16       1.00      1.00      1.00         3\n         17       1.00      1.00      1.00         7\n         18       1.00      1.00      1.00         5\n         19       1.00      1.00      1.00         5\n         20       1.00      1.00      1.00         3\n         21       1.00      1.00      1.00         5\n         22       1.00      1.00      1.00         2\n         23       1.00      1.00      1.00         4\n         24       1.00      1.00      1.00         2\n         25       1.00      1.00      1.00         4\n\navg / total       1.00      0.99      0.99       100\n\n```", "```py\ndef predict_captcha(captcha_image, neural_network):\n    subimages = segment_image(captcha_image)\n    # Perform the same transformations we did for our training data\n    dataset = np.array([np.resize(subimage, (20, 20)) for subimage in subimages])\n    X_test = dataset.reshape((dataset.shape[0], dataset.shape[1] * dataset.shape[2]))\n    # Use predict_proba and argmax to get the most likely prediction\n    y_pred = neural_network.predict_proba(X_test)\n    predictions = np.argmax(y_pred, axis=1)\n\n    # Convert predictions to letters\n    predicted_word = str.join(\"\", [letters[prediction] for prediction in predictions])\n    return predicted_word\n\n```", "```py\nword = \"GENE\"\ncaptcha = create_captcha(word, shear=0.2) \nprint(predict_captcha(captcha, clf))\nplt.imshow(captcha, cmap=\"Greys\") \n\n```", "```py\ndef test_prediction(word, net, shear=0.2, scale=1):\n    captcha = create_captcha(word, shear=shear, scale=scale, size=(len(word) * 25, 30))\n    prediction = predict_captcha(captcha, net) \n    return word == prediction, word, prediction\n\n```", "```py\nfrom nltk.corpus import words\n\n```", "```py\nvalid_words = set([word.upper() for word in words.words() if len(word) == 4])\n\n```", "```py\nnum_correct = 0 \nnum_incorrect = 0 \nfor word in valid_words:\n    shear = random_state.choice(shear_values)\n    scale = random_state.choice(scale_values) \n    correct, word, prediction = test_prediction(word, clf, shear=shear, scale=scale) \n    if correct: \n        num_correct += 1 \n    else: \n        num_incorrect += 1\nprint(\"Number correct is {0}\".format(num_correct)) \nprint(\"Number incorrect is {0}\".format(num_incorrect))\n\n```", "```py\ndef evaluation_versus_shear(shear_value):\n    num_correct = 0 \n    num_incorrect = 0 \n    for word in valid_words: \n        scale = random_state.choice(scale_values)\n        correct, word, prediction = test_prediction(word, clf, shear=shear_value, scale=scale)\n        if correct: \n            num_correct += 1 \n        else: \n            num_incorrect += 1\n    return num_correct/(num_correct+num_incorrect)\n\n```", "```py\nscores = [evaluation_versus_shear(shear) for shear in shear_values]\n\n```", "```py\nplt.plot(shear_values, scores)\n\n```", "```py\nfrom nltk.metrics import edit_distance \nsteps = edit_distance(\"STEP\", \"STOP\") \nprint(\"The number of steps needed is: {0}\".format(steps))\n\n```", "```py\ndef compute_distance(prediction, word):\n    len_word = min(len(prediction), len(word))\n    return len_word - sum([prediction[i] == word[i] for i in range(len_word)])\n\n```", "```py\nfrom operator import itemgetter \n\ndef improved_prediction(word, net, dictionary, shear=0.2, scale=1.0): \n    captcha = create_captcha(word, shear=shear, scale=scale) \n    prediction = predict_captcha(captcha, net) \n\n    if prediction not in dictionary:\n        distances = sorted([(word, compute_distance(prediction, word)) for word in dictionary],\n                           key=itemgetter(1))\n        best_word = distances[0] \n        prediction = best_word[0]\n    return word == prediction, word, prediction\n\n```", "```py\nnum_correct = 0 \nnum_incorrect = 0 \nfor word in valid_words: \n    shear = random_state.choice(shear_values)\n    scale = random_state.choice(scale_values)\n    correct, word, prediction = improved_prediction(word, clf, valid_words, shear=shear, scale=scale)\n    if correct: \n        num_correct += 1 \n    else: \n        num_incorrect += 1\nprint(\"Number correct is {0}\".format(num_correct)) \nprint(\"Number incorrect is {0}\".format(num_incorrect))\n\n```"]