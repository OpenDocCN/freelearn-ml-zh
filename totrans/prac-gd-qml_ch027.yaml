- en: Appendix D
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Installing the Tools
  prefs: []
  type: TYPE_NORMAL
- en: '*Man is a tool-using animal. Without tools he is nothing, with tools he* *is
    all.*'
  prefs: []
  type: TYPE_NORMAL
- en: — Thomas Carlyle
  prefs: []
  type: TYPE_NORMAL
- en: In this appendix, we will give you all the instructions needed to run the code
    examples provided in the main text. We will start by guiding you through the process
    of installing the software that we will use, then we will learn how to access
    the real quantum computers on which we will run our code, and finally, we will
    also show you how to accelerate some of the executions by using a GPU.
  prefs: []
  type: TYPE_NORMAL
- en: D.1 Getting Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the quantum programming libraries that we use in this book are based on
    Python, so you need to have a working Python distribution. If your operating system
    is Linux or macOS, you probably have one already. If your Python version is at
    least 3.7, then you are ready to go.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, even if you already have Python installed on your system, we recommend
    that you consider following one of these two options:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Installing Anaconda**: Anaconda is a data science software distribution that
    includes, among other things, Python and many of its scientific libraries. In
    addition, it also includes Jupyter, an extremely useful web-based interactive
    computing platform that allows you to run code, write text and formulas, and visualize
    graphics, all organized into notebooks. For convenience, we provide all the code
    of the book in Jupyter notebooks that you can download from [https://github.com/PacktPublishing/A-Practical-Guide-to-Quantum-Machine-Learning-and-Quantum-Optimization](https://github.com/PacktPublishing/A-Practical-Guide-to-Quantum-Machine-Learning-and-Quantum-Optimization).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you install Anaconda, you will have most of the non-quantum software libraries
    that we use in the book already on your system, plus some additional ones that
    you may find convenient for other, related projects.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: There is a version of Anaconda called **Anaconda Distribution** that is free
    to download from [https://www.anaconda.com/products/distribution](https://www.anaconda.com/products/distribution).
    It is available for Windows, Linux, and Mac. Anaconda Distribution provides a
    graphical installer, so it is super easy to set up. In case of doubt, you can
    always check the installation instructions at [https://docs.anaconda.com/anaconda/install/index.html](https://docs.anaconda.com/anaconda/install/index.html).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once you install Anaconda, we recommend that you launch it and run JupyterLab.
    This will open an IDE in your web browser that you can use to manage Jupyter notebooks
    and start running code right away. For a quick introduction to how to use JupyterLab,
    you can check this overview of its interface included in the JupyterLab documentation:
    [https://jupyterlab.readthedocs.io/en/stable/user/interface.html](https://jupyterlab.readthedocs.io/en/stable/user/interface.html).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Using Google Colab**: If you prefer not to install anything on your own computer,
    we also have an option for you. Google Colab is a web-based environment provided
    by Google in which you can run Jupyter notebooks with Python code. In fact, its
    interface its very similar to that of Jupyter and can be used to run all the code
    in this book (we know because we did it ourselves!) in addition to many other
    projects, especially those related to machine learning and data science.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The main difference between using Jupyter and Google Colab is that Colab does
    not run on your computer but is cloud-based: it uses hardware owned by Google.
    They provide you with a (usually modest) CPU, some amount of RAM, and some disk
    space, and you also have the chance to request a GPU to accelerate the training
    of your machine learning models.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The basic version of Google Colab is free to use: you only need a working Google
    account to start using it at [https://colab.research.google.com/](https://colab.research.google.com/).
    And should you ever need more computational power, you can upgrade to a paid version
    (see more details at [https://colab.research.google.com/signup](https://colab.research.google.com/signup)).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: By the way, the tutorials at [https://colab.research.google.com/](https://colab.research.google.com/)
    are really helpful, so you will be running your projects in almost no time.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Each of these options has its pros and cons. With Anaconda, you have perfect
    control over what you install, you get to use your own hardware (which probably
    is more powerful than that available at Google Colab, maybe with the exception
    of those sweet GPUs), and you can work offline. But you need to install everything
    yourself, keep it up to date, and solve any version conflicts that may arise.
  prefs: []
  type: TYPE_NORMAL
- en: With Google Colab, you can start running code right away from any computer connected
    to the internet, without the burden of having to install Python and many other
    libraries, and you can use quite powerful GPUs for free. However, you need to
    be online all the time, there are some restrictions on the number of projects
    that you can run simultaneously (at least, with the free version), and the CPU
    speed is not that great.
  prefs: []
  type: TYPE_NORMAL
- en: The good thing is that any of these possibilities (or any other that gets you
    a running Python distribution) works perfectly well for the purpose of running
    the code in this book. Moreover, they are perfectly compatible with each other,
    so you can start writing a notebook on Google Colab and complete it with Anaconda
    or vice versa. Since both are free, you can try them both and use the one that
    better suits your needs at any given moment.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, we don’t want to be too prescriptive. If you don’t feel like relying
    on Anaconda or on a cloud service, you can use your local machine without any
    add-ons and everything will work just fine as long as you have the right versions
    of the packages that we will use.
  prefs: []
  type: TYPE_NORMAL
- en: D.2 Installing the libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although both Anaconda and Google Colab come with a lot of data science, visualization,
    and machine learning libraries already installed by default, they do not yet include
    any of the quantum computing libraries that we use in this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, getting them set up and running is a breeze with **pip**, a package
    manager that comes bundled with Python — you don’t need to install Anaconda or
    access Google Colab to use it. In order to install a new library with pip, you
    just need to run the following instruction on your terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are using a Jupyter notebook to run your code, you can use exactly that
    same instruction, but you need to write it in a cell of its own, with no additional
    code. If you need to install several different libraries and you do not want to
    create a different cell for each pip instruction, then you can put them all together
    in the same cell but you need to use the escape symbol `!`. So, for instance,
    you can install three libraries in the same cell of your Jupyter notebook like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Sometimes, you need to install a particular version of a library. This is the
    case with some of the examples in this book. Don’t worry, because pip has your
    back in this too. You just need to run the following instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, to install version 0.39.2 of Qiskit, which is the one that we
    use in this book, you need to run the following instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Of course, the same comments that we just made about escape symbols in Jupyter
    notebooks apply to this case.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: If you run a `pip` `install` command on a Jupyter notebook to install a different
    version of a library that was already present on the system, you will probably
    need to restart the kernel (if you are running a Jupyter notebook on your local
    machine) or the runtime (in Google Colab) for the changes to take place.
  prefs: []
  type: TYPE_NORMAL
- en: In *Table* *[*D.1*](#x1-242010r1) we have collected all the libraries needed
    for the code in this book, in the order they appear in the main text, together
    with the version that we have used to create the examples. The second column specifies
    the name of each library in pip, so that is the one that you need to use with
    the `pip` `install` command.*
  prefs: []
  type: TYPE_NORMAL
- en: '*| Library name | Pip name | Version number |'
  prefs: []
  type: TYPE_NORMAL
- en: '| Qiskit | qiskit | 0.39.2 |'
  prefs: []
  type: TYPE_TB
- en: '| Pylatexenc | pylatexenc | 2.10 |'
  prefs: []
  type: TYPE_TB
- en: '| Numpy | numpy | 1.21.6 |'
  prefs: []
  type: TYPE_TB
- en: '| Qiskit Aer GPU | qiskit-aer-gpu | 0.11.1 |'
  prefs: []
  type: TYPE_TB
- en: '| PennyLane | pennylane | 0.26 |'
  prefs: []
  type: TYPE_TB
- en: '| PennyLane Qiskit plugin | pennylane-qiskit | 0.24.0 |'
  prefs: []
  type: TYPE_TB
- en: '| Ocean | dwave-ocean-sdk | 6.0.1 |'
  prefs: []
  type: TYPE_TB
- en: '| Qiskit Optimization | qiskit-optimization | 0.4.0 |'
  prefs: []
  type: TYPE_TB
- en: '| Qiskit Nature | qiskit-nature | 0.4.5 |'
  prefs: []
  type: TYPE_TB
- en: '| Scipy | scipy | 1.7.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Matplotlib | matplotlib | 3.2.2 |'
  prefs: []
  type: TYPE_TB
- en: '| PySCF | pyscf | 2.11 |'
  prefs: []
  type: TYPE_TB
- en: '| scikit-learn | scikit-learn | 1.0.2 |'
  prefs: []
  type: TYPE_TB
- en: '| TensorFlow | tensorflow | 2.9.1 |'
  prefs: []
  type: TYPE_TB
- en: '| Qiskit Machine Learning | qiskit-machine-learning | 0.5.0 |'
  prefs: []
  type: TYPE_TB
- en: '| Optuna | optuna | 3.0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| PyTorch | torch | 1.13 |'
  prefs: []
  type: TYPE_TB
- en: '| Qiskit IBM Runtime | qiskit-ibm-runtime | 0.7.0 |'
  prefs: []
  type: TYPE_TB
- en: '**Table D.1**: Libraries used in the book and their version numbers'
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that there are a couple of libraries in the list that we
    never explicitly imported into our code. However, they are used by other packages
    to be able to plot circuits (Pylatexenc) and to obtain Hamiltonians for molecular
    problems (PySCF), so they need to be present in your system.
  prefs: []
  type: TYPE_NORMAL
- en: Some of the libraries already come with Anaconda and Google Colab. In fact,
    it is very likely that the code in this book works with whatever version is included
    in those distributions, so installing the exact version we mention in the table
    should not be especially important.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only exceptions are PyTorch and TensorFlow: for them, the versions that
    you should use are the ones listed in the table.'
  prefs: []
  type: TYPE_NORMAL
- en: For the libraries that do not come with Anaconda and Google Colab, it is highly
    recommended to stick to the versions listed in the table. This is especially important
    for Qiskit and all its modules, which tend to change their APIs quite frequently.
  prefs: []
  type: TYPE_NORMAL
- en: In any case, for convenience, in the book notebooks that you can download from
    [https://github.com/PacktPublishing/A-Practical-Guide-to-Quantum-Machine-Learning-and-Quantum-Optimization](https://github.com/PacktPublishing/A-Practical-Guide-to-Quantum-Machine-Learning-and-Quantum-Optimization),
    we have explicitly included the installation commands of those libraries with
    the exact version that we have used to create the examples. If you’re running
    the code on a local Python installation, you just need to install these libraries
    once, so you can remove the `pip` `install` commands after the first execution.
    However, if you’re using Google Colab, you will need to run those commands every
    time you create a new runtime, because there is no persistence of data from one
    session to another.
  prefs: []
  type: TYPE_NORMAL
- en: D.3 Accessing IBM’s quantum computers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to be able to run circuits on IBM’s quantum computers from your Python
    programs, you first need to create an IBM account. This can be done through the
    IBM Quantum login page located at [https://quantum-computing.ibm.com/login](https://quantum-computing.ibm.com/login),
    and it is completely free.
  prefs: []
  type: TYPE_NORMAL
- en: Then, you need to obtain your API token. You can do this by going to [https://quantum-computing.ibm.com/account](https://quantum-computing.ibm.com/account),
    logging in if necessary, and finding the field titled **API token** (see *Figure*
    *[*D.1*](#FigureD.1)). Then, you can click the icon with the two rectangles next
    to the string of asterisks to copy the token to your clipboard. Should you need
    it, this is also the page where you can generate a new API token by clicking on
    **Generate new** **token**.*
  prefs: []
  type: TYPE_NORMAL
- en: '*![Figure D.1: Getting your IBM Quantum API token](img/file1660.png)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Figure D.1**: Getting your IBM Quantum API token'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have the token, if you want to access IBM’s devices from your Qiskit
    programs, you need to run the following instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: where, of course, you should replace `TOKEN` with your actual token. Then, you
    can obtain access to the IBM provider by using `IBMQ``.``load_account``()`, as
    we do in the main text.
  prefs: []
  type: TYPE_NORMAL
- en: If you are using your local Python installation, you only need to save your
    account once (and, additionally, whenever you change your API token). However,
    if you are using Google Colab, you need to save your account in each new runtime.
    We have prepared the notebooks that you can download from [https://github.com/PacktPublishing/A-Practical-Guide-to-Quantum-Machine-Learning-and-Quantum-Optimization](https://github.com/PacktPublishing/A-Practical-Guide-to-Quantum-Machine-Learning-and-Quantum-Optimization)
    so that you only need to write your actual token in the `ibm_token` `=` instruction.
  prefs: []
  type: TYPE_NORMAL
- en: If you need to access IBM quantum computers from PennyLane, the process is almost
    the same. The only difference is that you need to, additionally, install the PennyLane-Qiskit
    plugin as seen in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: D.4 Accessing D-Wave quantum annealers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to access D-wave quantum annealers from your code, you first need to
    create a free D-Wave Leap account at [https://cloud.dwavesys.com/leap/signup/](https://cloud.dwavesys.com/leap/signup/).
    This will give you 1 minute of free access to run your problems on actual quantum
    devices, as explained in *Chapter* *[*4*](ch012.xhtml#x1-750004), *Adiabatic Quantum
    Computing and* *Quantum Annealing*. If you want to extend this access to get one
    additional free minute per month recurringly, you can provide your GitHub username
    and repository by going to [https://cloud.dwavesys.com/leap/plans/#Custom](https://cloud.dwavesys.com/leap/plans/#Custom)
    and clicking **Get Developer Access**.*
  prefs: []
  type: TYPE_NORMAL
- en: '*In any case, as with IBM quantum computers, you now need to get your API token.
    You can achieve this by going to [https://cloud.dwavesys.com/leap/](https://cloud.dwavesys.com/leap/),
    signing in if needed, and finding the field titled **API Token**. This is usually
    located on the left part of the page, under your name and account type (see *Figure*
    *[*D.2*](#FigureD.2)). There, you can click on **COPY** to copy the token to your
    clipboard and on **RESET** to generate a new token.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*![Figure D.2: Getting your D-Wave API token](img/file1661.png)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Figure D.2**: Getting your D-Wave API token'
  prefs: []
  type: TYPE_NORMAL
- en: Then, you need to configure your access by running `dwave` `config` `create`.
    You can do this either on a terminal or on a Python notebook or program, but in
    this latter case, you need to use the escape symbol `!` before the command. Then,
    you will be prompted to enter some options for your configuration. You just need
    to go with the default values (by pressing *Enter*) on all the questions with
    the exception of **Authentication token**, for which you need to provide the API
    token that you copied from the D-Wave Leap website.
  prefs: []
  type: TYPE_NORMAL
- en: If you are using a local Python installation, this only has to be done once
    and, afterward, you can access D-Wave’s quantum annealers as we describe in *Chapter*
    *[*4*](ch012.xhtml#x1-750004), *Adiabatic Quantum Computing and Quantum Annealing*.
    If you are using Google Colab, you need to run the configuration step every time
    you use a new runtime.*
  prefs: []
  type: TYPE_NORMAL
- en: '*# D.5 Using GPUs to accelerate simulations in Google Colab'
  prefs: []
  type: TYPE_NORMAL
- en: As we mention in *Chapter* *[*2*](ch009.xhtml#x1-400002), *The Tools of the
    Trade in Quantum Computing*, using a GPU to simulate quantum circuits can offer,
    in some cases, a noticeable speedup in computation time. In general, the process
    of setting up a GPU to work with quantum libraries such as Qiskit depends heavily
    on your hardware configuration and your GPU model (although, in principle, only
    Nvidia GPUs are supported).*
  prefs: []
  type: TYPE_NORMAL
- en: '*However, if you are using Google Colab, you have the chance of requesting
    a GPU to run your circuits. The advantages of this approach are two-fold. Not
    only do you not need to buy the GPU yourself, but you also don’t have to set it
    up.'
  prefs: []
  type: TYPE_NORMAL
- en: To request a GPU for one of your Google Colab notebooks, you need to select
    the **Change runtime type** option in the **Runtime** menu. Then, you need to
    select the **GPU** option (see *Figure* *[*D.3*](#FigureD.3)) and click **Save**.
    If there is availability, you will be assigned a GPU. To check the status of the
    GPU, you can run `!``nvidia``-``smi` `-``L`. You will get an output like the following
    (the model of GPU may vary from one session to another):*
  prefs: []
  type: TYPE_NORMAL
- en: '*[PRE5]'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure D.3: Requesting a GPU](img/file1662.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure D.3**: Requesting a GPU'
  prefs: []
  type: TYPE_NORMAL
- en: 'If this command executes without error, it means that you have access to a
    GPU. Now, to use it in Qiskit, you need to install the Qiskit Aer GPU package
    by running the following instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that this will replace the usual Qiskit Aer module (the one that works
    with CPUs only), so you may need to restart your runtime if you had already run
    some Qiskit code. Now, you can try the GPU simulation by executing, for instance,
    the following instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get an output exactly as if you were running the simulation on your
    CPU. It would be something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]*******'
  prefs: []
  type: TYPE_NORMAL
