["```py\nimport math\nwheel_diameter_mm = 70\nwheel_circumference_mm = math.pi * wheel_diameter_mm\n```", "```py\ngear_ratio = 298\nencoder_poles = 28\nticks_per_revolution = encoder_poles * gear_ratio\nticks_to_m = (wheel_circumference_mm / ticks_per_revolution) / 1000\n```", "```py\nspeed = robot.ticks_to_m * (new_position – last_position) / time\n```", "```py\ncircup install asyncio\n```", "```py\nimport busio\nuart = busio.UART(board.GP12, board.GP13, baudrate=9600)\n```", "```py\ndef send_line(message):\n    uart.write(f\"{message}\\n\".encode())\n```", "```py\nimport asyncio\nimport robot\n```", "```py\nclass Settings:\n  speed = 0.7\n  time_interval = 0.2\n```", "```py\nasync def motor_speed_loop():\n  left_last, right_last = robot.left_encoder.read(), robot.right_encoder.read() \n```", "```py\n  while True:\n    await asyncio.sleep(Settings.time_interval)\n```", "```py\n    left_new, right_new = robot.left_encoder.read(), robot.right_encoder.read()\n    left_speed = robot.ticks_to_m * (left_new - left_last) / Settings.time_interval\n    left_last = left_new\n```", "```py\n    right_speed = robot.ticks_to_m * (right_new - right_last) / Settings.time_interval\n    right_last = right_new\n```", "```py\n    robot.send_line(f\"{left_speed:.2f},{right_speed:.2f},0\")\n```", "```py\nasync def stop_motors_after(seconds):\n  await asyncio.sleep(seconds)\n  robot.stop()\n```", "```py\nasync def command_handler():\n  while True:\n    if robot.uart.in_waiting:\n      command = robot.uart.readline().decode().strip()\n      if command.startswith(\"M\"):\n        Settings.speed = float(command[1:])\n      elif command.startswith(\"T\"):\n        Settings.time_interval = float(command[1:])\n      elif command == \"G\":\n        robot.stop()\n      elif command.startswith(\"G\"):\n        await asyncio.sleep(5)\n        robot.set_left(Settings.speed)\n        robot.set_right(Settings.speed)\n        asyncio.create_task(\n          stop_motors_after(float(command[1:]))\n        )\n```", "```py\nasyncio.create_task(motor_speed_loop())\nasyncio.run(command_handler())\n```", "```py\nimport asyncio\n```", "```py\n    async def poll_loop(self):\n        while True:\n            await asyncio.sleep(0)\n            while self.sm.in_waiting:\n                self.sm.readinto(self._buffer)\n```", "```py\n        self._buffer = array.array(\"i\", [0])\n        asyncio.create_task(self.poll_loop())\n```", "```py\n    def read(self):\n        if self.reversed:\n            return -self._buffer[0]\n        else:\n            return self._buffer[0]\n```", "```py\nclass PIDController:\n    def __init__(self, kp, ki, kd, d_filter_gain=0.1):\n        self.kp = kp\n        self.ki = ki\n        self.kd = kd\n        self.d_filter_gain = d_filter_gain\n        self.reset()\n    def reset(self):\n        self.integral = 0\n        self.error_prev = 0\n        self.derivative = 0\n```", "```py\nimport asyncio\nimport time\nimport robot\nimport pid_controller\n```", "```py\nclass Settings:\n  speed = 0.17\n  time_interval = 0.2\n  motors_enabled = False\n```", "```py\nclass SpeedController:\n  def __init__(self, encoder, motor_fn):\n    self.encoder = encoder\n    self.motor_fn = motor_fn\n    self.pid = pid_controller.PIDController(3, 0, 1)\n    self.reset()\n```", "```py\n  def reset(self):\n    self.last_ticks = self.encoder.read()\n    self.pwm = 0\n    self.actual_speed = 0\n    self.pid.reset()\n```", "```py\n  def update(self, dt):\n    current_ticks = self.encoder.read()\n    speed_in_ticks = (current_ticks - self.last_ticks) / dt\n    self.last_ticks = current_ticks\n    self.actual_speed = robot.ticks_to_m * speed_in_ticks\n```", "```py\n    error = Settings.speed - self.actual_speed\n    control_signal = self.pid.calculate(error, dt)\n    self.pwm += control_signal\n    self.motor_fn(self.pwm * Settings.motors_enabled)\n```", "```py\nleft = SpeedController(robot.left_encoder, robot.set_left)\nright = SpeedController(robot.right_encoder, robot.set_right)\n```", "```py\nasync def motor_speed_loop():\n  last_time = time.monotonic()\n  while True:\n    await asyncio.sleep(Settings.time_interval)\n    current_time = time.monotonic()\n    dt = current_time - last_time\n    last_time = current_time\n```", "```py\n    left.update(dt)\n    right.update(dt)\n    robot.send_line(f\" {left.actual_speed:.2f},{Settings.speed * Settings.motors_enabled:.2f},0\")\n```", "```py\nasync def stop_motors_after(seconds):\n  await asyncio.sleep(seconds)\n  Settings.motors_enabled = False\n```", "```py\nasync def command_handler():\n  while True:\n    if robot.uart.in_waiting:\n      command = robot.uart.readline().decode().strip()\n      if command.startswith(\"M\"):\n        Settings.speed = float(command[1:])\n      elif command.startswith(\"T\"):\n        Settings.time_interval = float(command[1:])\n      elif command == \"G\":\n        Settings.motors_enabled = False\n      elif command.startswith(\"G\"):\n        await asyncio.sleep(5)\nasyncio.create_task(stop_motors_after(float(command[1:])))\n        Settings.motors_enabled = True\n        left.reset()\n        right.reset()\n      elif command.startswith(\"?\"):\n        robot.send_line(f\"M{Settings.speed:.1f}\")\n        robot.send_line(f\"T{Settings.time_interval:.1f}\")\n        await asyncio.sleep(3)\n    await asyncio.sleep(0)\n```", "```py\ntry:\n  motors_task = asyncio.create_task(motor_speed_loop())\n  asyncio.run(command_handler())\nfinally:\n  motors_task.cancel()\n  robot.stop()\n```", "```py\nm_to_ticks = 1 / ticks_to_m\n```", "```py\nimport asyncio\nimport time\nimport robot\nimport pid_controller\n```", "```py\nclass DistanceController:\n  def __init__(self, encoder, motor_fn):\n    self.encoder = encoder\n    self.motor_fn = motor_fn\n    self.pid = pid_controller.PIDController(3.25, 0.5, 0.5, d_filter_gain=1)\n    self.start_ticks = self.encoder.read()\n    self.pwm = 0\n    self.error = 0\n```", "```py\n  def update(self, dt, expected):\n    self.actual = self.encoder.read() - self.start_ticks\n    self.error = (expected - self.actual) / robot.ticks_per_revolution\n    control_signal = self.pid.calculate(self.error, dt)\n    self.motor_fn(control_signal)\n```", "```py\nclass DistanceTracker:\n  def __init__(self):\n    self.speed = 0.17\n    self.time_interval = 0.2\n    self.start_time = time.monotonic()\n    self.current_position = 0\n    self.total_distance_in_ticks = 0\n    self.total_time = 0.1\n```", "```py\n  def set_distance(self, new_distance):\n    self.current_position += self.total_distance_in_ticks\n    self.total_distance_in_ticks = robot.m_to_ticks * new_distance\n    self.total_time = max(0.1, abs(new_distance / self.speed))\n    self.start_time = time.monotonic()\n```", "```py\n  async def loop(self):\n    left = DistanceController(robot.left_encoder, robot.set_left)\n    right = DistanceController(robot.right_encoder, robot.set_right)\n    last_time = time.monotonic()\n```", "```py\n    while True:\n      await asyncio.sleep(self.time_interval)\n      current_time = time.monotonic()\n      dt = current_time - last_time\n      last_time = current_time\n      elapsed_time = current_time - self.start_time\n      time_proportion = min(1, elapsed_time / self.total_time)\n```", "```py\n      expected = time_proportion * self.total_distance_in_ticks + self.current_position\n      left.update(dt, expected)\n      right.update(dt, expected)\n      robot.send_line(f\"{expected:.2f},{left.actual:.2f},0\")\n```", "```py\ndistance_tracker = DistanceTracker()\n```", "```py\nasync def command_handler():\n  while True:\n    if robot.uart.in_waiting:\n      command = robot.uart.readline().decode().strip()\n      if command.startswith(\"M\"):\n        distance_tracker.speed = float(command[1:])\n      elif command.startswith(\"T\"):\n        distance_tracker.time_interval = float(command[1:])\n      elif command == \"G\":\n        distance_tracker.set_distance(0)\n      elif command.startswith(\"G\"):\n        await asyncio.sleep(5)\n        distance_tracker.set_distance(float(command[1:]))\n    await asyncio.sleep(0)\n```", "```py\ntry:\n  motors_task = asyncio.create_task(distance_tracker.loop())\n  asyncio.run(command_handler())\nfinally:\n  motors_task.cancel()\n  robot.stop()\n```"]