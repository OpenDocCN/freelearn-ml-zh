<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Using ML.NET with UWP</h1>
                </header>
            
            <article>
                
<p>Now that we have established how to create a production-grade .NET Core console application, in this chapter, we will deep dive into creating a fully functional Windows 10 application with the <strong>Universal Windows Platform</strong> (<strong>UWP</strong>) framework. This application will utilize an ML.NET binary classification model to make web-page-content classifications, in order to determine if the content is benign or malicious. In addition, we will explore breaking your code into a component-based architecture, using a .NET Standard Library to share between our desktop application and the console application that will train our model. By the end of the chapter, you should have a firm grasp of designing and coding a production-grade UWP desktop application with ML.NET.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>Breaking down the UWP application</li>
<li>Creating the web browser classification application</li>
<li>Exploring additional production-application enhancements</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Breaking down the UWP architecture</h1>
                </header>
            
            <article>
                
<p>At a high level, UWP provides an easy framework to create rich desktop applications for Windows 10. As discussed, with .NET Core, UWP allows the targeting of x86, x64, and <strong>Advanced RISC Machine</strong> (<strong>ARM</strong>). At the time of this writing, ARM is not supported with ML.NET. In addition, UWP applications can also be written with JavaScript and HTML.</p>
<p>A typical UWP desktop application includes the following core code elements:</p>
<ul>
<li>Views</li>
<li>Models</li>
<li>View Models</li>
</ul>
<p>These components form a common app architecture principle of the <strong>Model</strong>-<strong>View</strong>-<strong>ViewModel</strong>, otherwise known as <strong>MVVM</strong>. In addition to the code components, images and audio are also common, depending on the nature of your application or game.</p>
<p>Similarly to mobile apps on the Android and iOS platforms, each app is sandboxed to specific permissions that you, the developer, request upon installation. Therefore, as you develop your own UWP applications, request only the required access that your app absolutely requires.</p>
<p>For the example application we will be creating in this chapter, we only require access to the internet as a client, as found in the <span class="packt_screen">Capabilities</span> tab labeled <span class="packt_screen">Internet (Client)</span>, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-614 image-border" src="assets/44a90379-b974-4863-bdcd-8b030ad9a880.png" style="width:51.92em;height:25.08em;"/></p>
<p>The <span class="packt_screen">Internet (Client)</span> and other permissions are defined in the <kbd>Package.appxmanifest</kbd><strong> </strong>file found in the root of UWP applications, under the <span class="packt_screen">Capabilities</span> tab. This file is shown in the Visual Studio Solution Explorer screenshot in the later <em>Exploring the project architecture</em> section.</p>
<p>To prepare for our deep dive into integrating ML.NET in a UWP application, let's dive into the three core components found in a UWP application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Views</h1>
                </header>
            
            <article>
                
<p>Views, as we defined in the previous chapter's Blazor discussion, contain the <strong>user interface</strong> (<strong>UI</strong>) components of an application. Views in UWP development, such as those found in <strong>Windows Presentation Foundation</strong> (<strong>WPF</strong>) and Xamarin.Forms, use the <strong>Extensible Application Markup Language</strong> (<strong>XAML</strong>) syntax. Those familiar with modern web development with Bootstrap's Grid pattern will be able to quickly see the parallels as we deep dive into this later in this chapter. </p>
<p>The biggest differentiation between web development and UWP development is the powerful two-way binding XAML views when used with the MVVM principle. As you will see in the deep dive, XAML binding eliminates the manual setting and getting of values in code behinds, as you might have performed in Windows Forms or WebForms projects previously.</p>
<p>For applications using the web approach, HTML would define your View as with our Blazor project in <a href="5f67e3b8-56bd-47ab-8a72-4f00b239d517.xhtml">Chapter 9</a>, <em>Using ML.NET with ASP.NET Core</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Models</h1>
                </header>
            
            <article>
                
<p>Models provide the container of data between the View and View Model. Think of the Model as purely the transport for containing the data between the View and View Model. For example, if you had a movie list, a <kbd>List</kbd> collection of <kbd>MovieItems</kbd> would be defined in your <kbd>MovieListingModel</kbd> class. This container class would be instantiated and populated in the View Model, to be in turn bound in your View.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">View Models</h1>
                </header>
            
            <article>
                
<p>View Models provide the business-logic layer for populating your Model, and thereby your View indirectly. As mentioned previously, the MVVM binding provided in UWP development eases the management of trigger points to ensure your UI layer is up to date. This is achieved through the use of implementing the <kbd>INotifyPropertyChanged</kbd> interface in our View Model. For each property that we want to bind to our UI, we simply call <kbd>OnPropertyChanged</kbd>. The power behind this is that you can have complex forms with triggers within the setter of other properties, without having conditionals and endless code to handle the complexities.</p>
<div class="packt_tip">If you want to deep dive further into UWP development, Channel9 from Microsoft has a series called <em>Windows 10 Development for Absolute Beginners</em> that covers all of the main aspects of UWP development: <a href="https://channel9.msdn.com/Series/Windows-10-development-for-absolute-beginners">https://channel9.msdn.com/Series/Windows-10-development-for-absolute-beginners</a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating the web browser classification application</h1>
                </header>
            
            <article>
                
<p>As mentioned earlier, the application we will be creating is a web browser classification application. Using the knowledge garnered in the logistic classification chapter, we will be using the <kbd>SdcaLogisticRegression</kbd> algorithm to take the text content of a web page, featurize the text, and provide a confidence level of maliciousness. In addition, we will be integrating this technique into a Windows 10 UWP application that mimics a web browser—effectively on navigation to a page—running the model, and making a determination as to whether the page was malicious. If found to be malicious, we redirect to a warning page. While in a real-world scenario this might prove too slow to run on every page, the benefits of a highly secured web browser, depending on the environment requirements might far outweigh the slight overhead running our model incurs.</p>
<p>As with previous chapters, the completed project code, sample dataset, and project files can be downloaded from <a href="https://github.com/PacktPublishing/Hands-On-Machine-Learning-With-ML.NET/tree/master/chapter10">https://github.com/PacktPublishing/Hands-On-Machine-Learning-With-ML.NET/tree/master/chapter10</a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Exploring the project architecture</h1>
                </header>
            
            <article>
                
<p>With this chapter, we will dive into a native Windows 10 desktop application. As mentioned in the first section of this chapter, we will be using the UWP framework to create our application.</p>
<p>No additional ML.NET NuGet packages are needed for this sample application. However, we will be using the <kbd>HtmlAgilityPack</kbd> NuGet package to provide a quick method to extract the text from a given web page. At the time of this writing, version 1.11.18 was the latest version and is the version used in this example.</p>
<p>In the following screenshot, you will find the Visual Studio Solution Explorer view of the solution. Given that this example comprises three separate projects (more akin to a production scenario), the amount of both new and significantly modified files is quite large. We will review in detail each of the new files shown in the solution screenshot, later on in this section:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-615 image-border" src="assets/a9b4c475-b490-47d3-a201-c424ef6a8d04.png" style="width:16.08em;height:47.00em;"/></p>
<p class="mce-root">The<span> </span><kbd>sampledata.csv</kbd> file (found in the <kbd>Data</kbd> folder in the code repository) contains eight rows of extracted text from URLs found in the <kbd>trainingURLList.csv</kbd> file (also found in the <kbd>Data</kbd> folder). Feel free to adjust the URL list file to test websites you frequently visit. Here is a snippet of one such row:</p>
<div>
<pre>False|BingImagesVideosMapsNewsShoppingMSNOfficeOutlookWordExcelPowerPointOneNoteSwayOneDriveCalendarPeopleSigninRewardsDownloadtoday’simagePlaytoday'squizTheTajMahalinAgraforIndia'sRepublicDay©MicheleFalzone/plainpictureIt'sRepublicDayinIndiaImageofthedayJan26,2020It'sRepublicDayinIndia©MicheleFalzone/plainpictureForIndia's70thRepublicDay</pre></div>
<p>In addition to the <kbd>sampledata.csv</kbd> file, we also added the <kbd>testdata.csv</kbd> file that contains additional data points to test the newly trained model against and to evaluate. Here is a snippet of a sample row of the data inside of <kbd>testdata.csv</kbd>:</p>
<pre>True|USATODAY:LatestWorldandUSNews-USATODAY.comSUBSCRIBENOWtogethomedeliveryNewsSportsEntertainmentLifeMoneyTechTravelOpinionWeatherIconHumidityPrecip.WindsOpensettingsSettingsEnterCityNameCancelSetClosesettingsFullForecastCrosswordsInvestigationsAppsBest-SellingBooksCartoons</pre>
<p>Due to the size of the example project, we will be diving into the code for each of the different components before running the applications at the end of this section in the following order:</p>
<ul>
<li><span>.NET Standard Library for common code between the two applications</span></li>
<li>Windows 10 UWP browser application</li>
<li>.NET Core console application for feature extraction and training</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Diving into the library</h1>
                </header>
            
            <article>
                
<p>Due to the nature of this application and that of production applications where there are multiple platforms and/or ways to execute shared code, a library is being used in this chapter's example application. The benefit of using a library is that all common code can reside in a portable and dependency-free manner. Expanding the functionality in this sample application to include other platforms such as Linux or Mac applications with Xamarin would be a much easier lift than having the code either duplicated or kept in the actual applications.</p>
<p>Classes and enumerations that were changed or added in the library are as follows:</p>
<ul>
<li><kbd>Constants</kbd></li>
<li><kbd>WebPageResponseItem</kbd></li>
<li><kbd>Converters</kbd></li>
<li><kbd>ExtensionMethods</kbd></li>
<li><kbd>WebPageInputItem</kbd></li>
<li><kbd>WebPagePredictionItem</kbd></li>
<li><kbd>WebContentFeatureExtractor</kbd></li>
<li><kbd>WebContentPredictor</kbd></li>
<li><kbd>WebContentTrainer</kbd></li>
</ul>
<p>The <kbd>Classification</kbd>, <kbd>TrainerActions</kbd>,<strong> </strong>and <kbd>BaseML </kbd>classes remain unmodified from <a href="5f67e3b8-56bd-47ab-8a72-4f00b239d517.xhtml">Chapter 9</a>, <em>Using ML.NET with ASP.NET Core</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Constants class</h1>
                </header>
            
            <article>
                
<p>The <kbd>Constants</kbd> class, as used in all of our examples to this point, is the common class that contains our constant values used in our library, trainer, and UWP applications. For this chapter, the <kbd>MODEL_NAME</kbd> and <kbd>MALICIOUS_THRESHOLD</kbd> properties were added to hold our model's name and an arbitrary threshold for when we should decide to classify our prediction as malicious or not, respectively. If you find your model too sensitive, try adjusting this threshold, like this:</p>
<div>
<pre>public static class Constants<br/>{<br/>    public const string MODEL_NAME = "webcontentclassifier.mdl";<br/><br/>    public const string SAMPLE_DATA = "sampledata.csv";<br/><br/>    public const string TEST_DATA = "testdata.csv";<br/><br/>    public const double MALICIOUS_THRESHOLD = .5;<br/>}</pre></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The WebPageResponseItem class</h1>
                </header>
            
            <article>
                
<p>The <kbd>WebPageResponseItem</kbd> class is our container class between our predictor and application. This class contains the properties we set after running the predictor and then use to display in our desktop application, as shown in the following code block:</p>
<pre>public class WebPageResponseItem<br/>{<br/>    public double Confidence { get; set; }<br/><br/>    public bool IsMalicious { get; set; }<br/><br/>    public string Content { get; set; }<br/><br/>    public string ErrorMessage { get; set; }<br/><br/>    public WebPageResponseItem()<br/>    {<br/>    }<br/><br/>    public WebPageResponseItem(string content)<br/>    {<br/>        Content = content;<br/>    }<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Converters class</h1>
                </header>
            
            <article>
                
<p>The <kbd>Converters</kbd> class has been adjusted to provide an extension method to convert our container class into the type our model expects. In this example, we have the <kbd>Content</kbd> property, which simply maps to the <kbd>HTMLContent</kbd> variable in the <kbd>WebPageInputItem</kbd> class, as follows:</p>
<div>
<pre>public static WebPageInputItem ToWebPageInputItem(this WebPageResponseItem webPage)<br/>{<br/>    return new WebPageInputItem<br/>    {<br/>        HTMLContent = webPage.Content<br/>    };<br/>}</pre></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The ExtensionMethods class</h1>
                </header>
            
            <article>
                
<p>The <kbd>ExtensionMethods</kbd> class, as discussed previously in <a href="5f67e3b8-56bd-47ab-8a72-4f00b239d517.xhtml">Chapter 9</a>, <em>Using ML.NET with ASP.NET Core</em>, has been expanded to include the <kbd>ToWebContentString</kbd> extension method. In this method, we pass in the URL from which we want to retrieve the web content. Using the previously mentioned <kbd>HtmlAgilityPack</kbd>, we create an <kbd>HtmlWeb</kbd> object and call the <kbd>Load</kbd><strong> </strong>method, prior to iterating through the <strong>Document Object Model</strong> (<strong>DOM</strong>). Given most websites have extensive scripts and style sheets, our purpose in this example is just to examine the text in the page, thus the filters of script and style nodes in our code. Once the nodes have been traversed and added to a <kbd>StringBuilder</kbd> object, we return the typecast of that object to a string, as shown in the following code block:</p>
<div>
<pre>public static string ToWebContentString(this string url)<br/>{<br/>    var web = new HtmlWeb();<br/><br/>    var htmlDoc = web.Load(url);<br/>            <br/>    var sb = new StringBuilder();<br/><br/>    htmlDoc.DocumentNode.Descendants().Where(n =&gt; n.Name == "script" || n.Name == "style").ToList().ForEach(n =&gt; n.Remove());<br/><br/>    foreach (var node in htmlDoc.DocumentNode.SelectNodes("//text()[normalize-space(.) != '']"))<br/>    {<br/>        sb.Append(node.InnerText.Trim().Replace(" ", ""));<br/>    }<br/><br/>    return sb.ToString();<br/>}</pre></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The WebPageInputItem class</h1>
                </header>
            
            <article>
                
<p>The <kbd>WebPageInputItem</kbd> class is our input object to our model, containing both the label and extracted content of our web page, as shown in the following code block:</p>
<pre>public class WebPageInputItem<br/>{<br/>    [LoadColumn(0), ColumnName("Label")]<br/>    public bool Label { get; set; }<br/><br/>    [LoadColumn(1)]<br/>    public string HTMLContent { get; set; }<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The WebPagePredictionItem class</h1>
                </header>
            
            <article>
                
<p>The <kbd>WebPagePredictionItem</kbd> class is the output object from our model, containing the prediction of whether a web page is malicious or benign, in addition to a probability score that the prediction is accurate and the <kbd>Score</kbd> value used in the evaluation phase of our model creation, as shown in the following code block:</p>
<pre>public class WebPagePredictionItem<br/>{<br/>    public bool Prediction { get; set; }<br/><br/>    public float Probability { get; set; }<br/><br/>    public float Score { get; set; }<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The WebContentFeatureExtractor class</h1>
                </header>
            
            <article>
                
<p>The <kbd>WebContentFeatureExtractor</kbd> class contains our <kbd>GetContentFile</kbd> and <kbd>Extract</kbd> methods, which operate as follows:</p>
<ol>
<li>First, our <kbd>GetContentFile</kbd> method takes the <kbd>inputFile</kbd> and <kbd>outputFile</kbd> values (the URL list CSV and feature-extracted CSV respectively). It then reads each URL, grabs the content, then outputs to the <kbd>outputFile</kbd> string, as follows:</li>
</ol>
<div>
<pre style="padding-left: 60px">private static void GetContentFile(string inputFile, string outputFile)<br/>{<br/>    var lines = File.ReadAllLines(inputFile);<br/><br/>    var urlContent = new List&lt;string&gt;();<br/><br/>    foreach (var line in lines)<br/>    {<br/>        var url = line.Split(',')[0];<br/>        var label = Convert.ToBoolean(line.Split(',')[1]);<br/><br/>        Console.WriteLine($"Attempting to pull HTML from {line}");<br/><br/>        try<br/>        {<br/>            var content = url.ToWebContentString();<br/><br/>            content = content.Replace('|', '-');<br/><br/>            urlContent.Add($"{label}|{content}");<br/>        }<br/>        catch (Exception)<br/>        {<br/>            Console.WriteLine($"Failed to pull HTTP Content from {url}");<br/>        }<br/>    }<br/><br/>    File.WriteAllText(Path.Combine(AppContext.BaseDirectory, outputFile), string.Join(Environment.NewLine, urlContent));<br/>}     </pre></div>
<ol start="2">
<li>Next, we use the <kbd>Extract</kbd> method to call both the training and test extraction, passing in the output filenames for both, like this:</li>
</ol>
<div>
<pre style="padding-left: 60px">public void Extract(string trainingURLList, string testURLList, string trainingOutputFileName, string testingOutputFileName)<br/>{<br/>    GetContentFile(trainingURLList, trainingOutputFileName);<br/><br/>    GetContentFile(testURLList, testingOutputFileName);<br/>}</pre></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The WebContentPredictor class</h1>
                </header>
            
            <article>
                
<p>The <kbd>WebContentPredictor</kbd> class provides the interface for both our command line and desktop applications, using an overloaded <kbd>Predict</kbd> method, described here:</p>
<ol>
<li>The first <kbd>Predict</kbd> method is for our command-line application that simply takes in the URL and calls into the overload in <em>Step 3</em>, after calling the <kbd>ToWebContentString</kbd> extension method, like this:</li>
</ol>
<pre style="padding-left: 60px">public WebPageResponseItem Predict(string url) =&gt; Predict(new WebPageResponseItem(url.ToWebContentString()));</pre>
<ol start="2">
<li>Then, we create the <kbd>Initialize</kbd> method, in which we load our model from the embedded resource. If successful, the method returns <kbd>true</kbd>; otherwise, it returns <kbd>false</kbd>, as shown in the following code block:</li>
</ol>
<pre style="padding-left: 60px">public bool Initialize()<br/>{<br/>    var assembly = typeof(WebContentPredictor).GetTypeInfo().Assembly;<br/><br/>    var resource = assembly.GetManifestResourceStream($"chapter10.lib.Model.{Constants.MODEL_NAME}");<br/><br/>    if (resource == null)<br/>    {<br/>        return false;<br/>    }<br/><br/>    _model = MlContext.Model.Load(resource, out _);<br/><br/>    return true;<br/>}</pre>
<ol start="3">
<li><span> </span>And finally, we call our <kbd>Predict</kbd> method that creates our prediction engine. Then, we call the predictor's <kbd>Predict</kbd> method, and then update the <kbd>Confidence</kbd> and <kbd>IsMalicious</kbd> properties, prior to returning the updated <kbd>WebPageResponseItem</kbd> object, as follows:</li>
</ol>
<pre style="padding-left: 60px">public WebPageResponseItem Predict(WebPageResponseItem webPage)<br/>{<br/>    var predictionEngine = MlContext.Model.CreatePredictionEngine&lt;WebPageInputItem, WebPagePredictionItem&gt;(_model);<br/><br/>    var prediction = predictionEngine.Predict(webPage.ToWebPageInputItem());<br/><br/>    webPage.Confidence = prediction.Probability;<br/>    webPage.IsMalicious = prediction.Prediction;<br/><br/>    return webPage;<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The WebContentTrainer class</h1>
                </header>
            
            <article>
                
<p>The <kbd>WebContentTrainer</kbd><strong> </strong>class contains all of the code to train and evaluate our model. As with previous examples, this functionality is self-contained within one method called <kbd>Train</kbd>:</p>
<ol>
<li>The first change is the use of the <kbd>WebPageInputItem</kbd> class to read the CSV into the <kbd>dataView</kbd> object separated by <kbd>|</kbd>, as shown in the following code block:</li>
</ol>
<pre style="padding-left: 60px">var dataView = MlContext.Data.LoadFromTextFile&lt;WebPageInputItem&gt;(trainingFileName, hasHeader: false, separatorChar: '|');</pre>
<ol start="2">
<li>Next, we map our file data features to create our pipeline. In this example, we simply featurize the <kbd>HTMLContent</kbd> property and pass it to the <kbd>SdcaLogisticRegression</kbd> trainer, like this:</li>
</ol>
<pre style="padding-left: 60px">var dataProcessPipeline = MlContext.Transforms.Text<br/>    .FeaturizeText(FEATURES, nameof(WebPageInputItem.HTMLContent))<br/>    .Append(MlContext.BinaryClassification.Trainers.SdcaLogisticRegression(labelColumnName: "Label", featureColumnName: FEATURES));</pre>
<ol start="3">
<li>Then, we fit the model, and save the model to disk, like this:</li>
</ol>
<pre style="padding-left: 60px">var trainedModel = dataProcessPipeline.Fit(dataView);<br/><br/>MlContext.Model.Save(trainedModel, dataView.Schema, Path.Combine(AppContext.BaseDirectory, modelFileName));</pre>
<ol start="4">
<li>Finally, we load in the testing file, and call the <kbd>BinaryClassification</kbd> evaluation, like this:</li>
</ol>
<pre style="padding-left: 60px">var testingDataView = MlContext.Data.LoadFromTextFile&lt;WebPageInputItem&gt;(testingFileName, hasHeader: false, separatorChar: '|');<br/><br/>IDataView testDataView = trainedModel.Transform(testingDataView);<br/><br/>var modelMetrics = MlContext.BinaryClassification.Evaluate(<br/>    data: testDataView);<br/><br/>Console.WriteLine($"Entropy: {modelMetrics.Entropy}");<br/>Console.WriteLine($"Log Loss: {modelMetrics.LogLoss}");<br/>Console.WriteLine($"Log Loss Reduction: {modelMetrics.LogLossReduction}");</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Diving into the UWP browser application</h1>
                </header>
            
            <article>
                
<p>With the library code having been reviewed, the next component is the desktop application. As discussed in the opening section, our desktop application is a UWP application. For the scope of this example, we are using standard approaches for handling the application architecture, following the MVVM approach discussed in the opening section of this chapter.</p>
<p>The files we will be diving into in this section are as follows:</p>
<ul>
<li><kbd>MainPageViewModel</kbd></li>
<li><kbd>MainPage.xaml</kbd></li>
<li><kbd>MainPage.xaml.cs</kbd></li>
</ul>
<p>The rest of the files inside the UWP project, such as the tile images and app class files, are untouched from the default Visual Studio UWP application template.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The MainPageViewModel class</h1>
                </header>
            
            <article>
                
<p>The purpose of the <kbd>MainPageViewModel</kbd> class is to contain our business logic and control the View:</p>
<ol>
<li>The first thing we do is instantiate our previously discussed <kbd>WebContentPredictor</kbd> class to be used to run predictions, as follows:</li>
</ol>
<pre style="padding-left: 60px">private readonly WebContentPredictor _prediction = new WebContentPredictor();</pre>
<ol start="2">
<li>The next block of code handles the power of MVVM for our <strong>GO</strong> button, the web service URL field, and the web classification properties. For each of these properties, we call <kbd>OnPropertyChanged</kbd> upon a change in values, which triggers the binding of the View to refresh for any field bound to these properties, as shown in the following code block:</li>
</ol>
<pre style="padding-left: 60px">private bool _enableGoButton;<br/><br/>public bool EnableGoButton<br/>{<br/>    get =&gt; _enableGoButton;<br/><br/>    private set<br/>    {<br/>        _enableGoButton = value;<br/>        OnPropertyChanged();<br/>    }<br/>}<br/><br/>private string _webServiceURL;<br/><br/>public string WebServiceURL<br/>{<br/>    get =&gt; _webServiceURL;<br/><br/>    set<br/>    {<br/>        _webServiceURL = value;<br/><br/>        OnPropertyChanged();<br/><br/>        EnableGoButton = !string.IsNullOrEmpty(value);<br/>    }<br/>}<br/><br/>private string _webPageClassification;<br/><br/>public string WebPageClassification<br/>{<br/>    get =&gt; _webPageClassification;<br/><br/>    set<br/>    {<br/>        _webPageClassification = value;<br/>        OnPropertyChanged();<br/>    }<br/>}</pre>
<ol start="3">
<li>Next, we define the <kbd>Initialize</kbd> method, which calls the predictor's <kbd>Initialize</kbd> method. The method will return false if the model can't be loaded or found, as follows:</li>
</ol>
<pre style="padding-left: 60px">public bool Initialize() =&gt; _prediction.Initialize();</pre>
<ol start="4">
<li>Then, we take the entered URL the user entered via the <kbd>WebServiceURL</kbd> property. From that value, we validate that either <kbd>http</kbd> or <kbd>https</kbd> is prefixed. If not, <kbd>http://</kbd> is prefixed to the URL prior to converting it to a URI, like this:</li>
</ol>
<pre style="padding-left: 60px">public Uri BuildUri()<br/>{<br/>    var webServiceUrl = WebServiceURL;<br/><br/>    if (!webServiceUrl.StartsWith("http://", StringComparison.InvariantCultureIgnoreCase) &amp;&amp;<br/>        !webServiceUrl.StartsWith("https://", StringComparison.InvariantCultureIgnoreCase))<br/>    {<br/>        webServiceUrl = $"http://{webServiceUrl}";<br/>    }<br/><br/>    return new Uri(webServiceUrl);<br/>}</pre>
<ol start="5">
<li>Now, onto our <kbd>Classify</kbd> method that takes the URL entered from the user. This method calls our <kbd>Predict</kbd> method, builds our status bar text, and, if found to be malicious, builds the HTML response to send back to our <kbd>WebView</kbd> object, as follows:</li>
</ol>
<pre style="padding-left: 60px">public (Classification ClassificationResult, string BrowserContent) Classify(string url)<br/>{<br/>    var result = _prediction.Predict(url);<br/><br/>    WebPageClassification = $"Webpage is considered {result.Confidence:P1} malicious";<br/><br/>    return result.Confidence &lt; Constants.MALICIOUS_THRESHOLD ? <br/>        (Classification.BENIGN, string.Empty) : <br/>        (Classification.MALICIOUS, $"&lt;html&gt;&lt;body bgcolor=\"red\"&gt;&lt;h2 style=\"text-align: center\"&gt;Machine Learning has found {WebServiceURL} to be a malicious site and was blocked automatically&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt;");<br/>}</pre>
<ol start="6">
<li>And lastly, we implement the <kbd>OnPropertyChanged</kbd> event handler and method that are the standard implementations of the <kbd>INotifyPropertyChanged</kbd> interface, as discussed in the opening section of this chapter and shown in the following code block:</li>
</ol>
<pre style="padding-left: 60px">public event PropertyChangedEventHandler PropertyChanged;<br/><br/>protected virtual void OnPropertyChanged([CallerMemberName] string propertyName = null)<br/>{<br/>    PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">MainPage.xaml</h1>
                </header>
            
            <article>
                
<p>As discussed in the opening section describing UWP development, XAML markup is used to define your UI. For the scope of this application, our UI is relatively simple:</p>
<ol>
<li>The first thing we define is our <kbd>Grid</kbd>. In XAML, a <kbd>Grid</kbd> is a container similar to a <kbd>div</kbd> element in web development. We then define our Rows. Similar to Bootstrap, (but easier to understand, in my opinion) is to pre-define the height of each row. Setting a row to <kbd>Auto</kbd> will auto-size the height to the content's height, while an asterisk translates to using all remaining height based on the main container's height, as shown in the following code block:</li>
</ol>
<pre style="padding-left: 60px">&lt;Grid&gt;<br/>  &lt;Grid.RowDefinitions&gt;<br/>     &lt;RowDefinition Height="Auto" /&gt;<br/>     &lt;RowDefinition Height="*" /&gt;<br/>     &lt;RowDefinition Height="Auto" /&gt;<br/>  &lt;/Grid.RowDefinitions&gt;</pre>
<ol start="2">
<li>Similar to the row definitions in <em>Step 1</em>, we pre-define columns. <kbd>"Auto"</kbd> and <kbd>"*"</kbd> equate to the same principle as they did for the rows, just in regard to width instead of height, as shown in the following code block:</li>
</ol>
<pre style="padding-left: 60px">&lt;Grid.ColumnDefinitions&gt;<br/>    &lt;ColumnDefinition Width="*" /&gt;<br/>    &lt;ColumnDefinition Width="Auto" /&gt;<br/>&lt;/Grid.ColumnDefinitions&gt;</pre>
<ol start="3">
<li>We then define our <kbd>TextBox</kbd> object for the URL entry. Note the <kbd>Binding</kbd><em> </em>call in the <kbd>Text</kbd> value. This binds the textbox's text field to the <kbd>WebServiceURL</kbd> property in our View Model, as follows:</li>
</ol>
<pre style="padding-left: 60px">&lt;TextBox Grid.Row="0" Grid.Column="0" KeyUp="TxtBxUrl_KeyUp" Text="{Binding WebServiceURL, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}" /&gt;</pre>
<ol start="4">
<li>Then, we add the button to mimic a browser's <strong>GO</strong> button, which triggers the navigation. Also, note the use of <kbd>Binding</kbd> to enable or disable the button itself (which is bound based on text being entered into the URL textbox), as shown in the following code block:</li>
</ol>
<pre style="padding-left: 60px">&lt;Button Grid.Row="0" Grid.Column="1" Content="GO" Click="BtnGo_Click" IsEnabled="{Binding EnableGoButton}" /&gt;</pre>
<ol start="5">
<li>We then add the <kbd>WebView</kbd> control that comes with UWP, as follows:</li>
</ol>
<pre style="padding-left: 60px">&lt;WebView Grid.Row="1" Grid.Column="0" Grid.ColumnSpan="2" x:Name="wvMain" NavigationStarting="WvMain_OnNavigationStarting" /&gt;</pre>
<ol start="6">
<li>Lastly, we add our status bar grid and <kbd>TextBlock</kbd> control to show the classification along the bottom of the window, as follows:</li>
</ol>
<pre style="padding-left: 60px">&lt;Grid Grid.Column="0" Grid.ColumnSpan="2" Grid.Row="2" Background="#1e1e1e" Height="30"&gt;<br/>    &lt;TextBlock Text="{Binding WebPageClassification, Mode=OneWay}" Foreground="White" Margin="10,0,0,0" /&gt;<br/>&lt;/Grid&gt;</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">MainPage.xaml.cs</h1>
                </header>
            
            <article>
                
<p>The <kbd>MainPage.xaml.cs</kbd> file contains the code behind the XAML view discussed previously:</p>
<ol>
<li>The first thing we define is a wrapper property around the <kbd>DataContext</kbd> property built into the base <kbd>Page</kbd> class, as follows:</li>
</ol>
<pre style="padding-left: 60px">private MainPageViewModel ViewModel =&gt; (MainPageViewModel) DataContext;</pre>
<ol start="2">
<li class="mce-root">Next, we define the constructor for <kbd>MainPage</kbd> to initialize the <kbd>DataContext</kbd> to our <kbd>MainPageViewModel</kbd> object, as follows:</li>
</ol>
<pre style="padding-left: 60px">public MainPage()<br/>{<br/>    InitializeComponent();<br/><br/>    DataContext = new MainPageViewModel();<br/>}</pre>
<ol start="3">
<li>We then override the base <kbd>OnNavigatedTo</kbd> method to initialize our View Model, and validate the model was loaded properly, as follows:</li>
</ol>
<pre style="padding-left: 60px">protected override async void OnNavigatedTo(NavigationEventArgs e)<br/>{<br/>    var initialization = ViewModel.Initialize();<br/><br/>    if (initialization)<br/>    {<br/>        return;<br/>    }<br/><br/>    await ShowMessage("Failed to initialize model - verify the model has been created");<br/><br/>    Application.Current.Exit();<br/><br/>    base.OnNavigatedTo(e);<br/>}</pre>
<ol start="4">
<li>Next, we add our <kbd>ShowMessage</kbd> wrapper to provide an easy one-liner to call throughout our application, like this:</li>
</ol>
<pre style="padding-left: 60px">public async Task&lt;IUICommand&gt; ShowMessage(string message)<br/>{<br/>    var dialog = new MessageDialog(message);<br/><br/>    return await dialog.ShowAsync();<br/>}</pre>
<ol start="5">
<li>Then, we handle the <strong>GO</strong> button click by calling the <kbd>Navigate</kbd> method, as follows:</li>
</ol>
<pre style="padding-left: 60px">private void BtnGo_Click(object sender, RoutedEventArgs e) =&gt; Navigate();</pre>
<ol start="6">
<li>We then create our <kbd>Navigate</kbd> wrapper method, which builds the URI and passes it to the <kbd>WebView</kbd> object, as follows:</li>
</ol>
<pre style="padding-left: 60px">private void Navigate()<br/>{<br/>    wvMain.Navigate(ViewModel.BuildUri());<br/>}</pre>
<ol start="7">
<li>We also want to handle the keyboard input to listen for the user hitting the <em>Enter</em> key after entering a URL, to provide the user with the ability to either hit <em>Enter</em> or click the <strong>GO</strong> button, like this:</li>
</ol>
<pre style="padding-left: 60px">private void TxtBxUrl_KeyUp(object sender, KeyRoutedEventArgs e)<br/>{<br/>    if (e.Key == VirtualKey.Enter &amp;&amp; ViewModel.EnableGoButton)<br/>    {<br/>        Navigate();<br/>    }<br/>}</pre>
<ol start="8">
<li>Lastly, we block navigation until a classification can be obtained by hooking into the WebView's <kbd>OnNavigationStarting</kbd> event, as follows:</li>
</ol>
<pre style="padding-left: 60px">private void WvMain_OnNavigationStarting(WebView sender, WebViewNavigationStartingEventArgs args)<br/>{<br/>    if (args.Uri == null)<br/>    {<br/>        return;<br/>    }<br/><br/>    var (classificationResult, browserContent) = ViewModel.Classify(args.Uri.ToString());<br/><br/>    switch (classificationResult)<br/>    {<br/>        case Classification.BENIGN:<br/>            return;<br/>        case Classification.MALICIOUS:<br/>            sender.NavigateToString(browserContent);<br/>            break;<br/>    }<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Diving into the trainer application</h1>
                </header>
            
            <article>
                
<p>Now that we have reviewed the shared library and the desktop application, let us dive into the trainer application. With the major architectural changes being performed in Chapter 8's example, by design the trainer application has only minimal changes to handle the specific class objects used in this chapter's example.</p>
<p>We will review the following files:</p>
<ul>
<li><kbd>ProgramArguments</kbd></li>
<li><kbd>Program</kbd></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The ProgramArguments class</h1>
                </header>
            
            <article>
                
<p>Building off the work in Chapter 9's <kbd>ProgramArguments</kbd> class, we are only making three additions to the class. The first two additions are to include both the <kbd>Training</kbd> and <kbd>Testing</kbd> output filenames to provide better flexibility with our example's infrastructure. In addition, the <kbd>URL</kbd> property holds the URL you can pass, using the command line, into the trainer application to get a prediction, as shown in the following code block:</p>
<div>
<pre>public string TrainingOutputFileName { get; set; }<br/><br/>public string TestingOutputFileName { get; set; }<br/><br/>public string URL { get; set; }</pre></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Program class</h1>
                </header>
            
            <article>
                
<p>Inside the <kbd>Program</kbd> class, we will now modify the <kbd>switch case</kbd> statement to use the classes/methods from <a href="9c105516-7e4f-4f99-b70f-8b0d6165d8c5.xhtml">Chapter 10</a>, <em>Using ML.NET with UWP</em>, as follows:</p>
<div>
<pre>switch (arguments.Action)<br/>{<br/>    case ProgramActions.FEATURE_EXTRACTOR:<br/>        new WebContentFeatureExtractor().Extract(arguments.TrainingFileName, arguments.TestingFileName, <br/>            arguments.TrainingOutputFileName, arguments.TestingOutputFileName);<br/>        break;<br/>    case ProgramActions.PREDICT:<br/>        var predictor = new WebContentPredictor();<br/><br/>        var initialization = predictor.Initialize();<br/><br/>        if (!initialization)<br/>        {<br/>            Console.WriteLine("Failed to initialize the model");<br/><br/>            return;<br/>        }<br/><br/>        var prediction = predictor.Predict(arguments.URL);<br/><br/>        Console.WriteLine($"URL is {(prediction.IsMalicious ? "malicious" : "clean")} with a {prediction.Confidence:P2}% confidence");<br/>        break;<br/>    case ProgramActions.TRAINING:<br/>        new WebContentTrainer().Train(arguments.TrainingFileName, arguments.TestingFileName, arguments.ModelFileName);<br/>        break;<br/>    default:<br/>        Console.WriteLine($"Unhandled action {arguments.Action}");<br/>        break;<br/>}</pre></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Running the trainer application</h1>
                </header>
            
            <article>
                
<p><span>To begin running the trainer application, we will need to first run the <kbd>chapter10.trainer</kbd> application to perform feature extraction prior to the training of our model. To run the trainer application, the process is nearly identical to Chapter 9's sample application, with the addition of passing in the test dataset filename path when training:</span></p>
<ol>
<li>Run the trainer application, passing in the paths to the training and test URL list CSVs to perform feature extraction, as follows:</li>
</ol>
<div>
<pre style="padding-left: 60px"><strong>PS chapter10\trainer\bin\Debug\netcoreapp3.0&gt; .\chapter10.trainer.exe TrainingFileName ..\..\..\..\Data\trainingURLList.csv TestingFileName ..\..\..\..\Data\testingURLList.csv</strong><br/>Attempting to pull HTML from https://www.google.com, false<br/>Attempting to pull HTML from https://www.bing.com, false<br/>Attempting to pull HTML from https://www.microsoft.com, false<br/>Attempting to pull HTML from https://www8.hp.com/us/en/home.html, false<br/>Attempting to pull HTML from https://dasmalwerk.eu, true<br/>Attempting to pull HTML from http://vxvault.net, true<br/>Attempting to pull HTML from https://www.tmz.com, true<br/>Attempting to pull HTML from http://openmalware.org, true<br/>Failed to pull HTTP Content from http://openmalware.org<br/>Attempting to pull HTML from https://www.dell.com, false<br/>Attempting to pull HTML from https://www.lenovo.com, false<br/>Attempting to pull HTML from https://www.twitter.com, false<br/>Attempting to pull HTML from https://www.reddit.com, false<br/>Attempting to pull HTML from https://www.tmz.com, true<br/>Attempting to pull HTML from https://www.cnn.com, true<br/>Attempting to pull HTML from https://www.usatoday.com, true</pre>
<ol start="2">
<li>Run the application to train the model, based on <em>Step 1</em>'s sample and test data exports, as follows:</li>
</ol>
</div>
<div>
<pre style="padding-left: 60px"><strong>PS chapter10\trainer\bin\Debug\netcoreapp3.0&gt; .\chapter10.trainer.exe ModelFileName webcontentclassifier.mdl Action TRAINING TrainingFileName ..\..\..\..\Data\sampledata.csv</strong> <strong>TestingFileName ..\..\..\..\Data\testdata.csv</strong><br/>Entropy: 0.9852281360342516<br/>Log Loss: 0.7992317560011841<br/>Log Loss Reduction: 0.18878508766684401</pre></div>
<p style="padding-left: 60px">Feel free to modify the values and see how the prediction changes, based on the dataset on which the model was trained. A few areas of experimentation from this point might be to:</p>
<ul>
<li style="padding-left: 60px">Tweak the hyperparameters reviewed in the <kbd>Trainer</kbd> class on the <strong>Stochastic Dual Coordinate Ascent</strong> (<strong>SDCA</strong>) algorithm, such as <kbd>MaximumNumberOfIterations</kbd>, to see how accuracy is affected.</li>
<li style="padding-left: 60px">Add new features in addition to simply using the HTML content—perhaps the connection type or the number of scripts.</li>
<li style="padding-left: 60px">Add more variation to the training and sample set to get a better sampling of both benign and malicious content.</li>
</ul>
<p>For convenience, the GitHub repository includes all of the following data files in the <kbd>Data</kbd> folder:</p>
<ul>
<li>The <kbd>testdata.csv</kbd> and <kbd>sampledata.csv</kbd> feature-extracted CSV files</li>
<li>The <kbd>testingURLList.csv</kbd> and <kbd>trainingURLList.csv</kbd> URL list CSV files</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Running the browser application</h1>
                </header>
            
            <article>
                
<p>Now that our model has been trained, we can run our desktop application and test the efficacy of the model. To run the example, make sure the <kbd>chapter10_app</kbd> is the startup app and hit <em>F5</em>. Upon launching our browser application, enter <kbd>www.google.com</kbd>, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-616 image-border" src="assets/9ea1a926-8764-4ea7-a41e-9c20058c0a4d.png" style="width:44.00em;height:33.75em;"/></p>
<p>Note the status bar below the web page content in the preceding screenshot, indicating the malicious percentage after running the model. Next, type <kbd>dasmalwerk.eu</kbd> into your browser (this is a website that the default training URL list pre-classified as malicious), and note the forced redirect, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-617 image-border" src="assets/a1a7ca8d-2f87-4670-93be-a9ade98ee292.png" style="width:43.75em;height:25.17em;"/></p>
<p>Feel free to try various files on your machine to see the confidence score, and if you receive a false positive, perhaps add additional features to the model to correct the classification.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Additional ideas for improvements</h1>
                </header>
            
            <article>
                
<p>Now that we have completed our deep dive, there are a couple of additional elements to possibly further enhance the application. A few ideas are discussed here.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Single-download optimization</h1>
                </header>
            
            <article>
                
<p>Currently, when a new URL is entered or the page is changed in the <kbd>WebView</kbd> UWP control, the navigation is halted until a classification can be made. When this occurs—as we detailed previously—with the use of the <kbd>HtmlAgilityPack</kbd> library, we download and extract the text. If the page is deemed to be clean (as one would more than likely encounter the majority of the time), we would effectively be downloading the content twice. An optimization here would be to store the text in the application's sandbox storage once classification is done, then point the <kbd>WebView</kbd> object to that stored content. In addition, if this approach is used, add a purge background worker to remove older data so that your end users don't end up with several gigabytes of web page content.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Logging</h1>
                </header>
            
            <article>
                
<p>As with our previous chapter's deep dive into logging, adding logging could be crucial to remotely understand when an error occurs on a desktop application. Unlike our web application in the previous chapter, where your errors would be more than likely server-side and could be accessed remotely, your desktop application could be installed on any number of configurations of Windows 10, with an almost unlimited number of permutations. As mentioned previously, logging utilizing<span> </span>NLog<span> </span>(<a href="https://nlog-project.org/">https://nlog-project.org/</a>) or a similar open source project is highly recommended, coupled with a remote logging solution such as Loggly so that you can get error data from your user's machines. Given the <strong>General Data Protection Regulation</strong> (<strong>GDPR</strong>) and the recent <strong>California Consumer Privacy Act</strong> (<strong>CCPA</strong>), ensure that the fact this data is leaving the end user's machines is conveyed, and do not include personal data in these logs.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Utilizing a database</h1>
                </header>
            
            <article>
                
<p>Users typically visit the same websites fairly frequently, therefore storing the classification of a particular website's URL in a local database such as LiteDB (<a href="http://www.litedb.org/">http://www.litedb.org/</a>) would significantly improve the performance for the end user. One implementation method would be to store a SHA256 hash of the URL locally as the key, with the classification as the value. Longer term, you could provide a web URL reputation database, with the SHA256 hash of the URL being sent up to a scalable cloud storage solution such as Microsoft's Cosmos DB. Storing the SHA256 hash of the URL avoids any questions from your end users about personally identifiable information and anonymity.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>Over the course of this chapter, we have deep dived into what goes into a production-ready Windows 10 UWP application architecture, using the work performed in previous chapters as a foundation. We also created a brand new web-page-classification Windows 10 application, utilizing the <kbd>SdcaLogisticRegression</kbd> algorithm from ML.NET. Lastly, we also discussed some ways to further enhance the example application (and production applications in general).</p>
<p>With the conclusion of this chapter, this ends the real-world application section. The next section of the book includes both general machine learning practices in an agile production team and extending ML.NET with TensorFlow and <strong>Open Neural Network Exchange</strong> (<strong>ONNX</strong>) models. In the next chapter, we will focus on the former.</p>


            </article>

            
        </section>
    </body></html>