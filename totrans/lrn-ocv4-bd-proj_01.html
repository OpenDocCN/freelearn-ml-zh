<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Getting Started with OpenCV</h1>
                </header>
            
            <article>
                
<p>Computer vision applications are interesting and useful, but the underlying algorithms are computationally intensive. With the advent of cloud computing, we are getting more processing power to work with.</p>
<p>The OpenCV library enables us to run computer vision algorithms efficiently in real time. It has been around for many years, and has become the standard library in this field. One of the main advantages of OpenCV is that it is highly optimized, and available on almost all platforms.</p>
<p>This book will cover the various algorithms we will be using, why we are using them, and how to implement them in OpenCV.</p>
<p>In this chapter, we are going to learn how to install OpenCV on various operating systems. We will discuss what OpenCV offers out of the box, and the various things that we can do using the inbuilt functions.</p>
<p>By the end of this chapter, you will be able to answer the following questions:</p>
<ul>
<li>How do humans process visual data, and how do they understand image content?</li>
<li>What can we do with OpenCV, and what are the various modules available in OpenCV that can be used to achieve those things?</li>
<li>How do we install OpenCV on Windows, Linux, and Mac OS X?</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding the human visual system</h1>
                </header>
            
            <article>
                
<p>Before we jump into OpenCV functionalities, we need to understand why those functions were built in the first place. It's important to understand how the human visual system works, so that you can develop the right algorithms.</p>
<p>The goal of computer vision algorithms is to understand the content of images and videos. Humans seem to do it effortlessly! So, how do we get machines to do it with the same accuracy?</p>
<p>Let's consider the following diagram:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-782 image-border" src="assets/2b852a3b-bc18-4cb4-b42f-98edb1327ca8.png" style="width:31.33em;height:19.50em;"/></div>
<p>The human eye captures all the information that comes along the way, such as color, shape, brightness, and so on. In the preceding image, the human eye captures all the information about the two main objects and stores it in a certain way. Once we understand how our system works, we can take advantage of it to achieve what we want.</p>
<p>For example, here are a few things we need to know:</p>
<ul>
<li>Our visual system is more sensitive to low-frequency content than high-frequency content. Low-frequency content refers to planar regions where pixel values don't change rapidly, and high-frequency content refers to regions with corners and edges where pixel values fluctuate a lot. We can easily see if there are blotches on a planar surface, but it's difficult to spot something like that on a highly-textured surface.</li>
<li>
<p>The human eye is more sensitive to changes in brightness than to changes in color.</p>
</li>
<li>
<p>Our visual system is sensitive to motion. We can quickly recognize if something is moving in our field of vision, even though we are not directly looking at it.</p>
</li>
</ul>
<ul>
<li>We tend to make a mental note of salient points in our field of vision. Let's say you look at a white table with four black legs, and a red dot at one of the corners of the table surface. When you look at this table, you'll immediately make a mental note that the surface and legs have opposing colors, and that there is a red dot on one of the corners. Our brain is really smart that way! We do this automatically so that we can immediately recognize an object if we encounter it again.</li>
</ul>
<p>To get an idea of our field of view, let's look at the top view of a human, and the angles at which we see various things:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-783 image-border" src="assets/385f2bbd-533c-4438-be64-188d0b1b59a6.png" style="width:33.25em;height:17.08em;"/></div>
<p>Our visual system is actually capable of a lot more, but this should be good enough to get us started. You can explore further by reading up on <strong>Human Visual System</strong> (<strong>HVS</strong>) models on the web.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How do humans understand image content?</h1>
                </header>
            
            <article>
                
<p>If you look around, you will see a lot of objects. You encounter many different objects every day, and you recognize them almost instantaneously without any effort. When you see a chair, you don't wait for a few minutes before realizing that it is in fact a chair. You just know that it's a chair right away.</p>
<p>Computers, on the other hand, find it very difficult to do this task. Researchers have been working for many years to find out why computers are not as good as we are at this.</p>
<p>To get an answer to that question, we need to understand how humans do it. The visual data processing happens in the ventral visual stream. This ventral visual stream refers to the pathway in our visual system that is associated with object recognition. It is basically a hierarchy of areas in our brain that helps us recognize objects.</p>
<p>Humans can recognize different objects effortlessly, and can cluster similar objects together. We can do this because we have developed some sort of invariance toward objects of the same class. When we look at an object, our brain extracts the salient points in such a way that factors such as orientation, size, perspective, and illumination don't matter.</p>
<p>A chair that is double the normal size and rotated by 45 degrees is still a chair. We can recognize it easily because of the way we process it. Machines cannot do that so easily. Humans tend to remember an object based on its shape and important features. Regardless of how the object is placed, we can still recognize it.</p>
<p>In our visual system, we build up these hierarchical invariances with respect to position, scale, and viewpoint that help us to be very robust. If you look deeper into our system, you will see that humans have cells in their visual cortex that can respond to shapes such as curves and lines.</p>
<p>As we move further along our ventral stream, we will see more complex cells that are trained to respond to more complex objects such as trees, gates, and so on. The neurons along our ventral stream tend to show an increase in the size of the receptive field. This is coupled with the fact that the complexity of their preferred stimuli increases as well.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Why is it difficult for machines to understand image content?</h1>
                </header>
            
            <article>
                
<p>We now understand how visual data enters the human visual system, and how our system processes it. The issue is that we still don't fully understand how our brain recognizes and organizes this visual data. In machine learning, we just extract some features from images, and ask the computers to learn them using algorithms. We still have these variations, such as shape, size, perspective, angle, illumination, occlusion, and so on.</p>
<p>For example, the same chair looks very different to a machine when you look at it from the profile view. Humans can easily recognize that it's a chair, regardless of how it's presented to us. So, how do we explain this to our machines?</p>
<p>One way to do this would be to store all the different variations of an object, including sizes, angles, perspectives, and so on. But this process is cumbersome and time-consuming. Also, it's actually not possible to gather data that can encompass every single variation. The machines would consume a huge amount of memory and a lot of time to build a model that can recognize these objects.</p>
<p class="mce-root"/>
<p>Even with all this, if an object is partially occluded, computers still won't recognize it. This is because they think this is a new object. So when we build a computer vision library, we need to build the underlying functional blocks that can be combined in many different ways to formulate complex algorithms.</p>
<p>OpenCV provides a lot of these functions, and they are highly optimized. So once we understand what OpenCV is capable of, we can use it effectively to build interesting applications.</p>
<p>Let's go ahead and explore that in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">What can you do with OpenCV?</h1>
                </header>
            
            <article>
                
<p>Using OpenCV, you can pretty much do every computer vision task you can think of. Real-life problems require you to use many computer vision algorithms and modules together to achieve the desired result. So, you just need to understand which OpenCV modules and functions to use, in order to get what you want.</p>
<p>Let's look at what OpenCV can do out of the box.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Inbuilt data structures and input/output</h1>
                </header>
            
            <article>
                
<p>One of the best things about OpenCV is that it provides a lot of in-built primitives to handle operations related to image processing and computer vision. If you have to write something from scratch, you will have to define <kbd>Image</kbd>, <kbd>Point</kbd>, <kbd>Rectangle</kbd>, and so on. These are fundamental to almost any computer vision algorithm.</p>
<p>OpenCV comes with all these basic structures out of the box, contained in the <span class="CodeInTextPACKT">core</span> module. Another advantage is that these structures have already been optimized for speed and memory, and so you don't have to worry about the implementation details.</p>
<p>The <kbd><span class="CodeInTextPACKT">imgcodecs</span></kbd> module handles reading and writing of image files. When you operate on an input image and create an output image, you can save it as a <kbd>.jpg</kbd> or a <kbd>.png</kbd> file with a simple command.</p>
<p class="mce-root"/>
<p>You will be dealing with a lot of video files when you work with cameras. The <kbd>videoio</kbd> module handles everything related to the input and output of video files. You can easily capture a video from the webcam or read a video file in many different formats. You can even save a bunch of frames as a video file by setting properties such as frames per second, frame size, and so on.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Image processing operations</h1>
                </header>
            
            <article>
                
<p>When you write a computer vision algorithm, there are a lot of basic image processing operations that you will use over and over again. Most of these functions are present in the <kbd><span class="CodeInTextPACKT">imgproc</span></kbd> module. You can do things such as image filtering, morphological operations, geometric transformations, color conversions, drawing on images, histograms, shape analysis, motion analysis, feature detection, and more.</p>
<p>Let's consider the following photo:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-784 image-border" src="assets/7ae19f9b-34bf-44b2-a8fc-2a7220ce9ba6.png" style="width:125.00em;height:43.50em;"/></div>
<p>The right image is a rotated version of the one on the left. We can carry out this transformation with a single line in OpenCV.</p>
<p>There is another module, called <kbd>ximgproc</kbd>, which contains advanced image processing algorithms such as structured forests for edge detection, domain transform filter, adaptive manifold filter, and so on.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">GUI</h1>
                </header>
            
            <article>
                
<p>OpenCV provides a module called <kbd>highgui</kbd> that handles all the high-level user interface operations. Let's say you are working on a problem, and you want to check what the image looks like before you proceed to the next step. This module has functions that can be used to create windows to display images and/or videos.</p>
<p>There is a waiting function that will wait until you hit a key on your keyboard before it goes on to the next step. There is also a function that can detect mouse events. This is very useful in developing interactive applications.</p>
<p>Using this functionality, you can draw rectangles on those input windows, and then proceed based on the selected region. Consider the following screenshot:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-785 image-border" src="assets/1bb9b533-be4b-45ea-b55f-e19cdd52c8b7.png" style="width:36.67em;height:28.58em;"/></div>
<p>As you can see, we drew a green rectangle on top of the window. Once we have the coordinates of that rectangle, we can operate only on that region.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Video analysis</h1>
                </header>
            
            <article>
                
<p>Video analysis includes tasks such as analyzing the motion between successive frames in a video, tracking different objects in a video, creating models for video surveillance, and so on. OpenCV provides a module called <kbd>video</kbd> that can handle all of this.</p>
<p>There is also a module called <kbd>videostab</kbd> that deals with video stabilization. Video stabilization is important, as when you are capturing videos by holding the camera in your hands, there's usually a lot of shake that needs correcting. All modern devices use video stabilization to process the video before it's presented to the end user.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">3D reconstruction</h1>
                </header>
            
            <article>
                
<p>3D reconstruction is an important topic in computer vision. Given a set of 2D images, we can reconstruct the 3D scene using relevant algorithms. OpenCV provides algorithms that can find the relationship between various objects in those 2D images to compute their 3D positions in its <kbd>calib3d</kbd> module.</p>
<p>This module can also handle camera calibration, which is essential for estimating the parameters of the camera. These parameters define how the camera sees the scene in front of it. We need to know these parameters to design algorithms, or else we might get unexpected results.</p>
<p>Let's consider the following diagram:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-786 image-border" src="assets/8a240217-624e-4efb-87f3-d36c73cefd50.png" style="width:18.25em;height:16.83em;"/></div>
<p>As we can see here, the same object is captured from multiple positions. Our job is to reconstruct the original object using these 2D images.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Feature extraction</h1>
                </header>
            
            <article>
                
<p>As we discussed earlier, the human visual system tends to extract the salient features from a given scene to remember it for retrieval later. To mimic this, people started designing various feature extractors that can extract these salient points from a given image. Popular algorithms include <span><strong>Scale Invariant Feature Transform</strong></span> (<strong>SIFT</strong>), <span><strong>Speeded Up Robust Features</strong></span> (<strong>SURF</strong>), and <strong>F</strong><span><strong>eatures From Accelerated Segment Test</strong></span> (<strong>FAST</strong>).</p>
<p>An OpenCV module called <kbd>features2d</kbd> provides functions to detect and extract all these features. Another module called <kbd>xfeatures2d</kbd> provides a few more feature extractors, some of which are still in the experimental phase. You can play around with these if you get the chance.</p>
<p>There is also a module called <kbd>bioinspired</kbd> that provides algorithms for biologically-inspired computer vision models.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Object detection</h1>
                </header>
            
            <article>
                
<p>Object detection refers to detecting the location of an object in a given image. This process is not concerned with the type of object. If you design a chair detector, it will not tell you whether the chair in a given image is red with a high back, or blue with a low back<span>—it will</span> <span>just tell you the location of the chair.</span></p>
<p>Detecting the location of objects is a critical step in many computer vision systems. Consider the following photo:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-787 image-border" src="assets/eaa400c1-1994-457e-a3d1-bb5d7d2a65c6.png" style="width:28.92em;height:19.25em;"/></div>
<p class="mce-root"/>
<p class="mce-root"/>
<p>If you run a chair detector on this image, it will put a green box around all the chairs<span>—but</span> it won't tell you what kind of chair it is.</p>
<p>Object detection used to be a computationally-intensive task because of the number of calculations required to perform the detection at various scales. To solve this, Paul Viola and Michael Jones came up with a great algorithm in their seminal 2001 paper, which you can read at the following link: <a href="https://www.cs.cmu.edu/~efros/courses/LBMV07/Papers/viola-cvpr-01.pdf"><span class="URLPACKT">https://www.cs.cmu.edu/~efros/courses/LBMV07/Papers/viola-cvpr-01.pdf</span></a>. They provided a fast way to design an object detector for any object.</p>
<p>OpenCV has modules called <kbd>objdetect</kbd> and <kbd>xobjdetect</kbd> that provide the framework to design an object detector. You can use it to develop detectors for random items such as sunglasses, boots, and so on.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Machine learning</h1>
                </header>
            
            <article>
                
<p><span>Machine learning algorithms are used extensively to build computer vision systems for object recognition, image classification, face detection, visual search, and so on</span>.</p>
<p>OpenCV provides a module called <kbd>ml</kbd><span class="CodeInTextPACKT">,</span> which has many machine learning algorithms bundled into it, including a <strong>Bayes classifier</strong>, <strong>k-nearest neighbors</strong> (<strong>KNN</strong>), <strong>support vector machines</strong> (<strong>SVM</strong>), <strong>decision trees</strong>, <strong>neural networks</strong>, and more.</p>
<p>It also has a module called <strong>Fast Approximate Nearest Neighbor Search Library</strong> (<strong>FLANN</strong><span class="CodeInTextPACKT">),</span> which contains algorithms for fast nearest neighbor searches in large datasets.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Computational photography</h1>
                </header>
            
            <article>
                
<p>Computational photography refers to using advanced image processing techniques to improve the images captured by cameras. Instead of focusing on optical processes and image capture methods, computational photography uses software to manipulate visual data. Applications include high dynamic range imaging, panoramic images, image relighting, and light field cameras.</p>
<p>Let's look at the following image:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-788 image-border" src="assets/12c9b784-2399-48be-9428-a3a919108bdf.png" style="width:40.42em;height:22.75em;"/></div>
<p>Look at those vivid colors! This is an example of a high dynamic range image, and it wouldn't be possible to get this using conventional image capture techniques. To do this, we have to capture the same scene at multiple exposures, register those images with each other, and then blend them nicely to create this image.</p>
<p>The <kbd><span class="CodeInTextPACKT">photo</span></kbd> and <kbd><span class="CodeInTextPACKT">xphoto</span></kbd> modules contain various algorithms that provide algorithms pertaining to computational photography. There is also a module called <kbd>stitching</kbd> that provides algorithms to create panoramic images.</p>
<div class="packt_infobox">The image shown can be found here: <a href="https://pixabay.com/en/hdr-high-dynamic-range-landscape-806260/">https://pixabay.com/en/hdr-high-dynamic-range-landscape-806260/</a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Shape analysis</h1>
                </header>
            
            <article>
                
<p>The notion of shape is crucial in computer vision. We analyze visual data by recognizing various different shapes in the image. This is actually an important step in many algorithms.</p>
<p>Let's say you are trying to identify a particular logo in an image. You know that it can appear in various shapes, orientations, and sizes. One good way to get started is to quantify the characteristics of the shape of the object.</p>
<p>The <kbd><span class="CodeInTextPACKT">shape</span></kbd> module provides all the algorithms required to extract different shapes, measure similarity between them, transform the shapes of objects, and more.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Optical flow algorithms</h1>
                </header>
            
            <article>
                
<p>Optical flow algorithms are used in videos to track features across successive frames. Let's say you want to track a particular object in a video. Running a feature extractor on each frame would be computationally expensive; hence, the process would be slow. So, you just extract the features from the current frame, and then track those features in successive frames.</p>
<p>Optical flow algorithms are heavily used in video-based applications in computer vision. The <kbd><span class="CodeInTextPACKT">optflow</span></kbd> module contains all the algorithms required to perform optical flow. There is also a module called <kbd><span class="CodeInTextPACKT">tracking</span></kbd> that contains more algorithms that can be used to track features.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Face and object recognition</h1>
                </header>
            
            <article>
                
<p>Face recognition refers to identifying the person in a given image. This is not the same as face detection, where you simply identify the location of a face in the given image.</p>
<p>If you want to build a practical biometric system that can recognize the person in front of the camera, you first need to run a face detector to identify the location of the face, and then run a separate face recognizer to identify who the person is. There is an OpenCV module called <kbd>face</kbd> that deals with face recognition.</p>
<p>As we discussed earlier, computer vision tries to model algorithms based on how humans perceive visual data. So, it would be helpful to find salient regions and objects in the images that can help with different applications such as object recognition, object detection and tracking, and so on. There is a module called <kbd>saliency</kbd> that's designed for this purpose. It provides algorithms that can detect salient regions in static images and videos.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Surface matching</h1>
                </header>
            
            <article>
                
<p>We are increasingly interacting with devices that can capture the 3D structure of the objects around us. These devices essentially capture depth information, along with the regular 2D color images. So, it's important for us to build algorithms that can understand and process 3D objects.</p>
<p><strong>Kinect</strong> is a good example of a device that captures depth information along with the visual data. The task at hand is to recognize the input 3D object, by matching it to one of the models in our database. If we have a system that can recognize and locate objects, then it can be used for many different applications.</p>
<p>There is a module called <kbd>surface_matching</kbd> that contains algorithms for 3D object recognition and a pose estimation algorithm using 3D features.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Text detection and recognition</h1>
                </header>
            
            <article>
                
<p>Identifying text in a given scene and recognizing the content is becoming increasingly important. Applications include number plate recognition, recognizing road signs for self-driving cars, book scanning to digitize content, and more.</p>
<p>There is a module called <kbd>text</kbd> that contains various algorithms to handle text detection and recognition.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Deep learning</h1>
                </header>
            
            <article>
                
<p>Deep learning has a big impact on computer vision and image recognition, and achieves a higher level of accuracy than other machine learning and artificially intelligent algorithms. Deep learning is not a new concept; it was introduced to the community around 1986, but it started a revolution around 2012 when new GPU hardware was optimized for parallel computing and <strong>Convolutional Neural Network</strong> (<strong>CNN</strong>) implementations and other techniques allowed the training of complex neural network architectures in reasonable times.</p>
<p>Deep learning can be applied to multiple use cases such as image recognition, object detection, voice recognition, and natural language processing. Since version 3.4, OpenCV has been implementing deep learning algorithms<span>—</span>in the latest version, multiple importers for important frameworks such as <strong>TensorFlow</strong> and <strong>Caffe</strong> have been added.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Installing OpenCV</h1>
                </header>
            
            <article>
                
<p>Let's see how to get OpenCV up and running on various operating systems.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Windows</h1>
                </header>
            
            <article>
                
<p>To keep things easy, let's install OpenCV using pre-built libraries. Go to <a href="https://opencv.org/" target="_blank"><span class="URLPACKT">opencv.org</span></a> and download the latest version for Windows. The current version is 4.0.0, and you can get the download link from the OpenCV homepage. You should make sure you have admin rights before you proceed.</p>
<p>The downloaded file will be an executable file, so just double-click on it to start the installation. The installer expands the content into a folder. You will be able to choose the installation path, and check the installation by inspecting the files.</p>
<p>Once you are done with the previous step, we need to set the OpenCV environment variables and add them to the system path to complete the installation. We will set up an environment variable that will hold the build directory of the OpenCV library. We will be using this in our projects.</p>
<p>Open up the Terminal and type the following:</p>
<pre>C:&gt; setx -m OPENCV_DIR D:OpenCVBuildx64vc14</pre>
<div class="packt_infobox">We are assuming that you have a 64-bit machine with Visual Studio 2015 installed. If you have Visual Studio 2012, replace <kbd><span class="URLPACKT">vc14</span></kbd> with <kbd><span class="URLPACKT">vc11</span></kbd> in the command. The path specified is where we would have our OpenCV binaries, and you should see two folders inside that path called <kbd><span class="URLPACKT">lib</span></kbd> and <kbd><span class="URLPACKT">bin</span></kbd>. If you are using Visual Studio 2018, you should compile OpenCV from scratch.</div>
<p>Let's go ahead and add a path to the <kbd><span class="URLPACKT">bin</span></kbd> folder to our system path. The reason we need to do this is because we will be using the OpenCV library in the form of <strong>dynamic link libraries</strong> (<strong>DLL</strong>s). Essentially, all the OpenCV algorithms are stored here, and our operating system will only load them during runtime.</p>
<p>In order to do that, our operating system needs to know where they are located. The <span><kbd>PATH</kbd></span> system variable contains a list of all the folders where it can find DLLs. So, naturally, we need to add the path of the OpenCV library to this list.</p>
<p>Why do we need to do all this? Well, the other option is to copy the required DLLs in the same folder as the application's executable file (<kbd>.exe</kbd> file). This is an unnecessary overhead, especially when we are working with many different projects.</p>
<p class="mce-root"/>
<p>We need to edit the <kbd><span class="URLPACKT">PATH</span></kbd> variable to add this folder. You can use software such as Path Editor to do this, which you can download from here: <a href="https://patheditor2.codeplex.com"><span class="URLPACKT">https://patheditor2.codeplex.com</span></a>. Once you install it, start it up and add the following new entry (you can right-click on the path to insert a new item):</p>
<pre>%OPENCV_DIR%bin</pre>
<p>Go ahead and save it to the registry. We are done!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Mac OS X</h1>
                </header>
            
            <article>
                
<p>In this section, we will see how to install OpenCV on Mac OS X. Precompiled binaries are not available for Mac OS X, so we need to compile OpenCV from scratch.</p>
<p>Before we proceed, we need to install CMake. If you don't already have CMake installed, you can download it from here: <a href="https://cmake.org/files/v3.12/cmake-3.12.0-rc1-Darwin-x86_64.dmg">https://cmake.org/files/v3.12/cmake-3.12.0-rc1-Darwin-x86_64.dmg</a>. It's a <kbd>.dmg</kbd> file, so once you download it, just run the installer.</p>
<p>Download the latest version of OpenCV from <a href="https://opencv.org/"><span class="URLPACKT">opencv.org</span></a>. The current version is 4.0.0, and you can download it from here: <a href="https://github.com/opencv/opencv/archive/4.0.0.zip"><span class="URLPACKT">https://github.com/opencv/opencv/archive/4.0.0.zip</span></a>. Unzip the contents into a folder of your choice.</p>
<p>OpenCV 4.0.0 also has a new package called <kbd><span class="URLPACKT">opencv_contrib</span></kbd>, containing user contributions that are not yet considered stable, and some algorithms that are not freely available for commercial use in all the latest computer vision algorithms, which is worth keeping in mind. Installing this package is optional<span>—</span>OpenCV will work just fine if you don't install <kbd>opencv_contrib</kbd>.</p>
<p>Since we are installing OpenCV anyway, it's good to install this package so that you can experiment with it later on (as opposed to going through the whole installation process again). It is a great way to learn and play around with new algorithms. You can download it from the following link: <a href="https://github.com/opencv/opencv_contrib/archive/4.0.0.zip">https://github.com/opencv/opencv_contrib<span class="URLPACKT">/archive/4.0.0.zip</span></a>.</p>
<p>Unzip the contents of the zip file into a folder of your choice. For convenience, unzip it into the same folder as before, so that the <kbd><span class="URLPACKT">opencv-4.0.0</span></kbd> and <kbd><span class="URLPACKT">opencv_contrib-4.0.0</span></kbd> folders are in the same main folder.</p>
<p>We are now ready to build OpenCV. Open up your Terminal and navigate to the folder where you unzipped the contents of OpenCV 4.0.0. Run the following commands after substituting the right paths in the commands:</p>
<pre><strong>$ cd /full/path/to/opencv-4.0.0/ 
$ mkdir build 
$ cd build 
$ cmake -D CMAKE_BUILD_TYPE=RELEASE -D CMAKE_INSTALL_PREFIX=/full/path/to/opencv-4.0.0/build -D INSTALL_C_EXAMPLES=ON -D BUILD_EXAMPLES=ON -D OPENCV_EXTRA_MODULES_PATH=/full/path/to/opencv_contrib-4.0.0/modules ../</strong> </pre>
<p>It's time to install OpenCV 4.0.0. Go to the <kbd><span class="URLPACKT">/full/path/to/opencv-4.0.0/build</span></kbd> <span class="URLPACKT"><span>directory</span></span>, and run the following commands on your Terminal:</p>
<pre><strong>$ make -j4 
$ make install</strong> </pre>
<p>In the preceding command, the <strong><kbd><span class="CodeInTextPACKT">-j4</span></kbd></strong> flag indicates that it should be using four cores to install it. It's faster this way! Now, let's set the library path. Open up your <kbd><span class="CodeInTextPACKT">~/.profile</span></kbd> file in your Terminal using the <kbd><span class="CodeInTextPACKT">vi ~/.profile</span></kbd> command, and add the following line:</p>
<pre><strong><span>export DYLD_LIBRARY_PATH=/full/path/to/opencv-4.0.0/build/lib:$DYLD_LIBRARY_PATH</span></strong></pre>
<p>We need to copy the <kbd>pkgconfig</kbd> file in <kbd><span class="CodeInTextPACKT">opencv.pc</span></kbd> to <kbd><span class="URLPACKT">/usr/local/lib/pkgconfig</span></kbd> and name it <kbd><span class="URLPACKT">opencv4.pc</span></kbd>. This way, if you already have an existing OpenCV 3.x.x installation, there will be no conflict. Let's go ahead and do that:</p>
<pre><strong>$ cp /full/path/to/opencv-4.0.0/build/lib/pkgconfig/opencv.pc /usr/local/lib/pkgconfig/opencv4.pc</strong> </pre>
<p>We need to update our <kbd><span class="URLPACKT">PKG_CONFIG_PATH</span></kbd> variable as well. Open up your <kbd><span class="URLPACKT">~/.profile</span></kbd> file and add the following line:</p>
<pre><strong>export PKG_CONFIG_PATH=/usr/local/lib/pkgconfig/:$PKG_CONFIG_PATH</strong> </pre>
<p>Reload your <kbd><span class="URLPACKT">~/.profile</span></kbd> file using the following command:</p>
<pre><strong>$ source ~/.profile</strong> </pre>
<p>We're finished! Let's see if it's working:</p>
<pre><strong>$ cd /full/path/to/opencv-4.0.0/samples/cpp 
$ g++ -ggdb `pkg-config --cflags --libs opencv4` opencv_version.cpp -o /tmp/opencv_version &amp;&amp; /tmp/opencv_version</strong></pre>
<p class="mce-root"/>
<p>If you see <span class="CodeInTextPACKT"><span class="packt_screen">Welcome to OpenCV 4.0.0</span></span> printed on your Terminal, you are good to go. We will be using CMake to build our OpenCV projects throughout this book. We will cover it in more detail in <a href="37cf2702-b8c6-41ff-a935-fd4030f8ce64.xhtml"/><a href="37cf2702-b8c6-41ff-a935-fd4030f8ce64.xhtml">Chapter 2</a>, <em>An Introduction to the Basics of OpenCV</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Linux</h1>
                </header>
            
            <article>
                
<p>Let's see how to install OpenCV on Ubuntu. We need to install some dependencies before we begin. Let's install them using the package manager by running the following command in your Terminal:</p>
<pre><strong>$ sudo apt-get -y install libopencv-dev build-essential cmake libdc1394-22 libdc1394-22-dev libjpeg-dev libpng12-dev libtiff5-dev libjasper-dev libavcodec-dev libavformat-dev libswscale-dev libxine2-dev libgstreamer0.10-dev libgstreamer-plugins-base0.10-dev libv4l-dev libtbb-dev libqt4-dev libmp3lame-dev libopencore-amrnb-dev libopencore-amrwb-dev libtheora-dev libvorbis-dev libxvidcore-dev x264 v4l-utils</strong> </pre>
<p>Now that you have installed the dependencies, let's download, build, and install OpenCV:</p>
<pre><strong>$ wget "https://github.com/opencv/opencv/archive/4.0.0.tar.gz" -O opencv.tar.gz 
$ wget "https://github.com/opencv/opencv_contrib/archive/4.0.0.tar.gz" -O opencv_contrib.tar.gz 
$ tar -zxvf opencv.tar.gz 
$ tar -zxvf opencv_contrib.tar.gz 
$ cd opencv-4.0.0 
$ mkdir build 
$ cd build 
$ cmake -D CMAKE_BUILD_TYPE=RELEASE -D CMAKE_INSTALL_PREFIX=/full/path/to/opencv-4.0.0/build -D INSTALL_C_EXAMPLES=ON -D BUILD_EXAMPLES=ON -D OPENCV_EXTRA_MODULES_PATH=/full/path/to/opencv_contrib-4.0.0/modules ../ 
$ make -j4 
$ sudo make install</strong> </pre>
<p>Let's copy the <kbd>pkgconfig</kbd> file in <kbd><span class="CodeInTextPACKT">opencv.pc</span></kbd> to <kbd><span class="URLPACKT">/usr/local/lib/pkgconfig</span></kbd>, and name it <kbd><span class="URLPACKT">opencv4.pc</span></kbd>:</p>
<pre><strong>$ cp /full/path/to/opencv-4.0.0/build/lib/pkgconfig/opencv.pc /usr/local/lib/pkgconfig/opencv4.pc</strong> </pre>
<p>We're finished! We will now be able to use it to compile our OpenCV programs from the command line. Also, if you already have an existing OpenCV 3.x.x installation, there will be no conflict.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Let's check the installation is working properly:</p>
<pre><strong>$ cd /full/path/to/opencv-4.0.0/samples/cpp 
$ g++ -ggdb `pkg-config --cflags --libs opencv4` opencv_version.cpp -o /tmp/opencv_version &amp;&amp; /tmp/opencv_version</strong> </pre>
<p>If you see <span class="CodeInTextPACKT"><span class="packt_screen">Welcome to OpenCV 4.0.0</span></span> printed on your Terminal, you should be good to go. In the following chapters, we will learn how to use CMake to build our OpenCV projects.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we discussed the human visual system, and how humans process visual data. We explained why it's difficult for machines to do the same, and what we need to consider when designing a computer vision library.</p>
<p>We learned what could be done using OpenCV, and the various modules that can be used to complete those tasks. Finally, <span>we learned how to install OpenCV in various operating systems.</span></p>
<p>In the next chapter, we will discuss how to operate on images and how we can manipulate them using various functions. We will also learn about building a project structure for our OpenCV applications.</p>


            </article>

            
        </section>
    </body></html>