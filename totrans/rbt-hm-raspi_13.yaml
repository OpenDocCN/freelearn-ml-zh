- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: Determining Position Using Monte Carlo Localization
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用蒙特卡洛定位确定位置
- en: We now have several interesting sensors on our robot. However, we have yet to
    combine them to understand the position of our robot. The **Monte Carlo simulation**
    is a method that uses multiple sensors and a model of a robot’s world to estimate
    its location and heading in that world.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在在我们的机器人上有几个有趣的传感器。然而，我们还没有将它们结合起来理解机器人的位置。**蒙特卡洛模拟**是一种使用多个传感器和机器人世界模型来估计其在该世界中的位置和航向的方法。
- en: You will learn how to make a test arena for a robot, followed by how to model
    this arena in code, and how to send this data over Bluetooth to view on a computer.
    You will practice statistical methods for the robot to start guessing its location.
    You will see how to enrich encoder data and move the guesses, and then integrate
    this with distance sensor data to refine the guesses, using a method that is effective
    in the face of noisy sensor data and can cope with minor inaccuracies. This will
    come together in a Monte Carlo guess and check loop.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你将学习如何制作一个用于机器人的测试场地，然后是如何用代码建模这个场地，以及如何通过蓝牙发送这些数据到电脑上查看。你将练习统计方法，让机器人开始猜测其位置。你将看到如何丰富编码器数据并移动猜测，然后将其与距离传感器数据集成以细化猜测，使用一种在面对噪声传感器数据时有效且能应对轻微不准确的方法。这将在蒙特卡洛猜测和检查循环中实现。
- en: 'In this chapter, we will cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Creating a training area for our robot
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为我们的机器人创建训练区域
- en: Modeling a space
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建模空间
- en: Using sensors to track a relative pose
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用传感器跟踪相对姿态
- en: Monte Carlo localization
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蒙特卡洛定位
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you will require the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，你需要以下内容：
- en: The robot and code from [*Chapter 12*](B18001_12.xhtml#_idTextAnchor252), *Detecting
    Orientation with an IMU on Raspberry* *Pi Pico*
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自 [*第 12 章*](B18001_12.xhtml#_idTextAnchor252)，*在 Raspberry Pi Pico 上使用 IMU
    检测方向* 的机器人和代码
- en: A PC or laptop with Bluetooth LE
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有蓝牙低功耗（LE）的 PC 或笔记本电脑
- en: Python 3.7 with the Python `matplotlib`, `bleak`, and `NumPy` libraries installed
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装了 Python 3.7 以及 Python 的 `matplotlib`、`bleak` 和 `NumPy` 库
- en: 10 x 10-mm A1 sheet foam boards
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 10 x 10-mm A1 片材泡沫板
- en: Duct or gaffer tape
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 胶管或电工胶带
- en: A tape measure
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一把卷尺
- en: A metal ruler, set square, and pencil
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一把金属直尺、三角板和铅笔
- en: A sharp craft knife
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一把锋利的工艺刀
- en: A floor space of 1.5 sq meters
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1.5 平方米的地面空间
- en: You can find the code for this chapter at [https://github.com/PacktPublishing/Robotics-at-Home-with-Raspberry-Pi-Pico/tree/main/ch-13](https://github.com/PacktPublishing/Robotics-at-Home-with-Raspberry-Pi-Pico/tree/main/ch-13).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://github.com/PacktPublishing/Robotics-at-Home-with-Raspberry-Pi-Pico/tree/main/ch-13](https://github.com/PacktPublishing/Robotics-at-Home-with-Raspberry-Pi-Pico/tree/main/ch-13)
    找到本章的代码。
- en: Creating a training area for our robot
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为我们的机器人创建训练区域
- en: We will be estimating a robot’s location in a space. The robot needs a known
    space to work in, so we will build a simple world for it to operate in. This training
    area, or arena, is loosely based on those used in Pi Wars (see [https://piwars.org/2022-competition/general-rules/](https://piwars.org/2022-competition/general-rules/)
    under *Arena construction rules*), a British robotics competition, where this
    algorithm could be used for a robot to compete autonomously.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将估计机器人在空间中的位置。机器人需要一个已知的空间来工作，因此我们将为它构建一个简单的世界。这个训练区域，或称场地，大致基于 Pi Wars 中使用的那些（见
    [https://piwars.org/2022-competition/general-rules/](https://piwars.org/2022-competition/general-rules/)
    下的 *场地建设规则*），这是一个英国机器人竞赛，其中这个算法可以用于机器人进行自主竞赛。
- en: Let’s take a closer look at the arena.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看场地。
- en: What we will make
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们将制作什么
- en: 'The following diagram shows the arena we will make:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了我们将制作的场地：
- en: '![Figure 13.1 – A robot test arena ](img/Figure_13.01_B18001.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.1 – 机器人测试场地](img/Figure_13.01_B18001.jpg)'
- en: Figure 13.1 – A robot test arena
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.1 – 机器人测试场地
- en: '*Figure 13**.1* shows a top-view drawing of an arena, complete with dimensions.
    The arena is mostly square to keep it simple to make and model. To help the Monte
    Carlo simulation work, there must be a cutout on one side to prevent rotational
    symmetry – that is, you can’t rotate the arena and have it appear identical from
    multiple angles.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13*。1 显示了一个带有尺寸的场地俯视图。场地主要是方形的，以保持制作和建模简单。为了帮助蒙特卡洛模拟工作，必须在一边有一个切口以防止旋转对称性——也就是说，你不能旋转场地，使其从多个角度看起来相同。'
- en: The arena should be large enough for the robot to move freely inside of it,
    without being excessively large, making 1,500 mm a good compromise. The arena
    walls should be tall enough that the robot’s distance sensors cannot miss them.
    A reasonable wall height would be 200 mm. We will work with *mm* throughout this
    chapter to keep things consistent.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 竞技场应该足够大，以便机器人可以在其中自由移动，但又不过分大，1,500毫米是一个很好的折衷方案。竞技场的墙壁应该足够高，以便机器人的距离传感器不会错过它们。合理的墙面高度将是200毫米。我们将在本章中使用*mm*来保持一致性。
- en: Arena size versus robot speed
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 竞技场大小与机器人速度的关系
- en: Beware that you may want a larger arena for a faster robot, and that a smaller
    arena will give the robot less time to detect its features.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，您可能需要一个更大的竞技场来让机器人跑得更快，而较小的竞技场会给机器人更少的时间来检测其特征。
- en: The arena floor surface is important; if the robot’s wheels are slipping, then
    the calculations will suffer in accuracy.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 竞技场地板表面很重要；如果机器人的轮子打滑，那么计算将受到精度的影响。
- en: Next, we can see how we’ll build this.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以看看我们将如何构建它。
- en: How we will make the arena
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们将如何制作竞技场
- en: We’ll use foam board to build the arena, as it is lightweight and easy to cut;
    A1 boards are readily available, and panels can be cut from these.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用泡沫板来搭建竞技场，因为它轻便且易于切割；A1板很容易买到，可以从这些板上切割出面板。
- en: 'The following figure shows how we can make the arena:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了我们可以如何制作竞技场：
- en: '![Figure 13.2 – Making an arena ](img/Figure_13.02_B18001.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图13.2 – 制作竞技场](img/Figure_13.02_B18001.jpg)'
- en: Figure 13.2 – Making an arena
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.2 – 制作竞技场
- en: '*Figure 13**.2* shows a 3D view of the arena. The letters indicate different
    parts. The Dumont Cybernetics team inspired this style. We can make the arena
    in sections, slotting together corner joints, as shown between panels *D* and
    *B*, or use tape (such as duct tape) to make hinging sections, such as those between
    panels *A* and *B*. This arena is 1,500 mm, so it can be disassembled and folded
    small when not in use.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13**.2*展示了竞技场的3D视图。字母表示不同的部分。Dumont Cybernetics团队启发了这种风格。我们可以将竞技场分成几部分，像面板*D*和*B*之间的那样拼接角落接缝，或者使用胶带（如胶带）制作铰接部分，如面板*A*和*B*之间的部分。这个竞技场是1,500毫米长，所以当不使用时可以拆卸并折叠成小尺寸。'
- en: 'The following diagram shows the parts we will need to make this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了我们将需要的部件来制作这个：
- en: '![Figure 13.3 – A drawing of the parts to make the arena ](img/Figure_13.03_B18001.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图13.3 – 制作竞技场的部件图](img/Figure_13.03_B18001.jpg)'
- en: Figure 13.3 – A drawing of the parts to make the arena
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.3 – 制作竞技场的部件图
- en: '*Figure 13**.3* shows the parts to cut to make the arena. Each part has a letter,
    the number of pieces you’ll need to make, and the measurements to cut the part.
    The slot profiles are all the same as panel **A**, along with the wall heights.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13**.3*显示了制作竞技场需要切割的部件。每个部件都有一个字母，表示您需要制作的部件数量，以及切割部件的尺寸。槽的轮廓都与面板**A**相同，以及墙面高度。'
- en: Four A panels can be cut from a board with some material left over. Let’s see
    how to cut them.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 可以从一块板上切割出四个A面板，并留下一些材料。让我们看看如何切割它们。
- en: Tips for cutting
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 切割技巧
- en: You can cut the foam board in a similar way to the plastics you cut in [*Chapter
    4*](B18001_04.xhtml#_idTextAnchor080), *Building a Robot around Pico*. Use the
    tape measure, large ruler, and set square to mark where you will cut in pencil.
    Ensure the surface you are using to cut is at a comfortable height so that the
    long, repeated cutting does not make your back sore.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用与[*第4章*](B18001_04.xhtml#_idTextAnchor080)中切割塑料类似的方式切割泡沫板，即*在Pico周围搭建机器人*。使用卷尺、大尺子和三角板在铅笔上标记您将切割的位置。确保您用于切割的表面高度适中，这样长时间的重复切割不会使您的背部感到疼痛。
- en: Then, following a straight metal edge, draw a sharp knife along the cut multiple
    times. For the first cut, aim only to score the top plastic layer, and then keep
    making cuts until you are through. Take care to cut the same area – this is a
    matter of letting later cuts follow the earlier cuts by holding the blade lightly
    over them.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，沿着直金属边缘，多次用锋利的刀沿着切割线划过。对于第一次切割，目标只是划破顶部的塑料层，然后继续切割，直到穿过。注意要切割相同区域——这是一个让后续切割跟随早期切割的问题，即轻轻握住刀片。
- en: I suggest cutting wall height strips first, before marking slots and wall lengths
    on them.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议先切割墙面高度条带，然后再在它们上标记槽位和墙面长度。
- en: These sheets often come sandwiched with throw-away foam padding; this will help
    as a cutting surface so that you do not damage a table or floor underneath.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这些板材通常夹有可丢弃的泡沫垫片；这有助于作为切割面，这样您就不会损坏下面的桌子或地板。
- en: If there is tearing, either you are applying too much pressure or need to change
    your blade for a sharp, fresh one.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有撕裂，要么是你施加了过多的压力，要么需要更换你的刀片为锋利的新刀片。
- en: Take care cutting the slots. The wall heights do not need to be super precise;
    within a few mm is good enough. The real world is often not as precise and clear
    as a simulation, and this algorithm will be able to cope with this.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 注意切割槽位。墙壁的高度不需要非常精确；几毫米以内就足够了。现实世界通常不像模拟那样精确和清晰，而这个算法将能够应对这种情况。
- en: Once you have cut the parts, assemble the corners of the arena, and then make
    tape hinges on the inside joins (not the slots). When you disassemble the first
    time, fold the parts along these hinges, and then put tape on the outside of this
    joint. With gaffer tape or duct tape, this should be sturdy enough.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦切割好部件，组装竞技场的角落，然后在内部接合处（不是槽位）制作胶带铰链。第一次拆卸时，沿着这些铰链折叠部件，然后在接合处的外面贴上胶带。使用电工胶带或胶带，这应该足够坚固。
- en: Now that we have a real space, we’ll need to model this so that the robot can
    use it.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了真实的空间，我们需要对其进行建模，以便机器人可以使用它。
- en: Modeling the space
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 空间建模
- en: The aim of a Monte Carlo system is to model or simulate a space and a robot’s
    location. In this section, we will learn how code for the robot will represent
    this space. We will also look at how a computer can be used to visualize our robot’s
    guesses. Monte Carlo-based behavior code checks sensor readings frequently against
    the model of the space, so we should represent the space on the robot to optimize
    this.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Monte Carlo 系统的目标是模拟或模拟空间和机器人的位置。在本节中，我们将学习机器人代码如何表示这个空间。我们还将探讨如何使用计算机来可视化我们的机器人猜测。基于
    Monte Carlo 的行为代码会频繁地将传感器读数与空间模型进行比较，因此我们应该在机器人上表示空间以优化这一点。
- en: 'The role of the computer and the robot in this are shown in the following diagram:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了计算机和机器人在此中的作用：
- en: '![Figure 13.4 – Visualizing with the computer ](img/Figure_13.04_B18001.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.4 – 使用计算机可视化](img/Figure_13.04_B18001.jpg)'
- en: Figure 13.4 – Visualizing with the computer
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.4 – 使用计算机可视化
- en: '*Figure 13**.4* shows an overview of this system’s display and control architecture.
    The behavior code runs on the robot. The computer displays the state of the robot
    code, along with start and stop controls. The arena and state of the system all
    belong to the robot.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13**.4* 显示了该系统显示和控制架构的概述。行为代码在机器人上运行。计算机显示机器人代码的状态，以及启动和停止控制。竞技场和系统的状态都属于机器人。'
- en: Let’s look at how to represent the arena on the robot.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在机器人上表示竞技场。
- en: Representing the arena and robot position as numbers
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将竞技场和机器人位置表示为数字
- en: For a model like this, the boundaries of the arena are important. We can start
    by taking 2D *X* and *Y* coordinates of the corners.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种模型，竞技场的边界很重要。我们可以从获取角落的2D *X* 和 *Y* 坐标开始。
- en: 'Look at the following representation of the arena:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 看看以下竞技场的表示：
- en: '![Figure 13.5 – The arena and poses as coordinates ](img/Figure_13.05_B18001.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.5 – 竞技场和姿态作为坐标](img/Figure_13.05_B18001.jpg)'
- en: Figure 13.5 – The arena and poses as coordinates
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.5 – 竞技场和姿态作为坐标
- en: '*Figure 13**.5* shows a simplified version of the arena. Coordinates describe
    each corner as numbers. We can directly use those in the code. These corners can
    be joined as line segments. A line segment is a set of coordinates for the start
    and end of the line segment. All the coordinates in the code will be in mm.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13**.5* 显示了竞技场的简化版本。坐标描述了每个角落的数字。我们可以在代码中直接使用这些数字。这些角落可以连接成线段。线段是一组表示线段起点和终点的坐标。代码中的所有坐标都将使用毫米为单位。'
- en: Our robot will have a **pose** somewhere within the arena. A pose describes
    the robot’s location in space – in this case, anywhere in the 2D space of the
    arena and facing any of 360 degrees. Imagine this like a map pin, with an arrow
    point showing the heading.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的机器人在竞技场内的某个位置将有一个**姿态**。姿态描述了机器人在空间中的位置 – 在这种情况下，竞技场 2D 空间的任何位置，并面向 360 度中的任何角度。想象这就像一个地图针，有一个箭头指向航向。
- en: '*Figure 13**.5* also shows two robot poses, *A* and *B*. Each has an *X* and
    *Y* coordinate in mm within the arena, and each has a heading theta (θ) in degrees.
    These three numbers will represent every robot pose in this 2D space. At the start
    of a simulation, the robot could be at any position and facing any heading within
    the arena in degrees.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13**.5* 也显示了两个机器人姿态，*A* 和 *B*。每个姿态在竞技场内都有一个 mm 单位的 *X* 和 *Y* 坐标，并且每个姿态都有一个航向
    theta (θ) 度。这三个数字将代表这个 2D 空间中的每个机器人姿态。在模拟开始时，机器人可以位于竞技场内的任何位置，并面向任何角度。'
- en: Our arena representation has *0, 0* for the bottom left. Heading *0* faces right,
    with positive theta angles going anticlockwise. For example, pose *A* has a heading
    of around 30 degrees anticlockwise from the right, and pose *B* has a heading
    of 300 degrees from the right.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们竞技场的表示以*0, 0*为左下角。朝向*0*面向右侧，正theta角度逆时针。例如，姿态*A*从右侧逆时针大约30度，姿态*B*从右侧300度。
- en: In this system, we will have many pose estimates, which behave like particles.
    The Monte Carlo simulation here is also known as a **particle filter**, due to
    how poses are manipulated and then filtered away based on sensor data.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个系统中，我们将有许多姿态估计，它们的行为类似于粒子。这里的蒙特卡洛模拟也被称为**粒子滤波器**，因为姿态是如何被操纵并根据传感器数据进行过滤的。
- en: Now, let’s develop code for the arena boundary line segments.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开发用于竞技场边界线段的代码。
- en: Converting the representation into code
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将表示转换为代码
- en: We’ll represent the arena as code and render it on the computer. Then, we’ll
    move the arena representation over to the robot, with the computer fetching data
    from it.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以代码的形式表示竞技场并在计算机上渲染它。然后，我们将竞技场的表示移动到机器人上，计算机将从它那里获取数据。
- en: 'After creating the `arena.py` file, we can add the arena points to it:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建`arena.py`文件后，我们可以将其添加到其中：
- en: '[PRE0]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `boundary_lines` variable represents a list of line segments, each of which
    is an array of start and end coordinates, read as `[(start_x, start_y), (end_x,
    end_y)]`. We also store the arena `width` and `height` values here. If your arena
    is a different size, please update these values.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`boundary_lines`变量代表一个线段列表，每个线段都是一个包含起始和结束坐标的数组，读取为`[(start_x, start_y), (end_x,
    end_y)]`。我们也将竞技场的`width`和`height`值存储在这里。如果你的竞技场大小不同，请更新这些值。'
- en: We can display this using `matplotlib`, a mathematical plotting library for
    Python. To do this, first install Python 3.7 (or later) on your computer, and
    in a terminal, use the `python3 -mpip install matplotlib numpy` command to get
    the libraries. For Linux, you may need additional `python3-tk` packages in your
    package manager.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`matplotlib`，一个Python的数学绘图库来显示这些。为此，首先在你的电脑上安装Python 3.7（或更高版本），然后在终端中使用`python3
    -mpip install matplotlib numpy`命令来获取库。对于Linux，你可能需要在包管理器中安装额外的`python3-tk`包。
- en: 'Create the `display_arena.py` file to draw the arena. This file starts by importing
    `matplotlib`. The convention is to import `pyplot`, a data-plotting module, as
    `plt`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`display_arena.py`文件以绘制竞技场。该文件首先导入`matplotlib`。惯例是将数据绘图模块`pyplot`导入为`plt`：
- en: '[PRE1]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We will loop over the lines in the arena. The `plot` method takes *X* coordinates
    for a line, followed by *Y* coordinates for it, and allows us to specify a line
    color. Run this with `python3 display_arena.py`, which will draw the arena for
    us:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将遍历竞技场中的线。`plot`方法接受一条线的*X*坐标，然后是它的*Y*坐标，并允许我们指定线条颜色。运行`python3 display_arena.py`，这将为我们绘制竞技场：
- en: '![Figure 13.6 – A matplotlib drawing of the arena ](img/Figure_13.06_B18001.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图13.6 – 竞技场的matplotlib绘制](img/Figure_13.06_B18001.jpg)'
- en: Figure 13.6 – A matplotlib drawing of the arena
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.6 – 竞技场的matplotlib绘制
- en: The preceding diagram shows the arena drawn by the computer from our code. It
    has grid coordinates along the left and the bottom.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图示显示了计算机根据我们的代码绘制的竞技场。它沿着左侧和底部有网格坐标。
- en: We can now look at moving this model data to the robot where it will be used.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以查看将此模型数据移动到机器人，它将使用该数据。
- en: Serving the arena from the robot
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从机器人提供竞技场服务
- en: The robot should be the source of truth for arena data, so let’s put the arena
    model there. Make a `robot` folder on your computer and move `arena.py` into it.
    We will be copying the contents of this `robot` folder to Raspberry Pi Pico. From
    the previous chapters, copy `robot.py`, `pid_controller.py`, and `pio_encoder.py`
    into the `robot` folder.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 机器人应该是竞技场数据的真相来源，因此让我们将竞技场模型放在那里。在你的电脑上创建一个`robot`文件夹，并将`arena.py`移动到其中。我们将把`robot`文件夹的内容复制到Raspberry
    Pi Pico上。从前面的章节中，将`robot.py`、`pid_controller.py`和`pio_encoder.py`复制到`robot`文件夹中。
- en: 'We can then add a little code to serve up our arena boundary lines from the
    robot. In `robot/code.py`, start with imports and helpers:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以添加一些代码来从机器人提供我们的竞技场边界线。在`robot/code.py`中，从导入和辅助函数开始：
- en: '[PRE2]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: On the robot, we can handle commands as we have been since [*Chapter 10*](B18001_10.xhtml#_idTextAnchor210),
    *Using the PID Algorithm to Follow Walls*; however, we will use **JavaScript Object
    Notation** (**JSON**), a convenient method to represent more complex information.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在机器人上，我们可以像在 [*第 10 章*](B18001_10.xhtml#_idTextAnchor210) 中一样处理命令，即使用 PID 算法跟踪墙壁；然而，我们将使用
    **JavaScript 对象表示法**（**JSON**），这是一种方便表示更复杂信息的方法。
- en: Any data we send is converted into JSON, and then a `"\n"` newline is added
    to show that it’s a complete message. We then encode this. The data we receive
    is unpacked with `json.loads`, which will result in data structures of dictionaries.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发送的任何数据都会被转换为 JSON 格式，然后添加一个 `"\n"` 换行符以显示这是一个完整的消息。然后我们对其进行编码。我们接收到的数据使用
    `json.loads` 进行解包，这将导致字典类型的数据结构。
- en: 'We can then add a handler to this that will send back the arena when requested:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以添加一个处理程序，当请求时发送回竞技场：
- en: '[PRE3]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This will loop and wait for the arena command. It prints out any JSON it receives
    for troubleshooting. It will use the JSON to send back the arena data.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这将循环等待竞技场命令。它打印出接收到的任何 JSON 以供故障排除。它将使用 JSON 发送回竞技场数据。
- en: 'The robot can be interacted with via the Bluefruit app in UART mode by sending
    `{"command": "arena"}`. The robot will send the boundary lines back as lists.
    However, ideally, we want the computer to display this from the robot with `matplotlib`.
    We’ll need to connect the computer to the robot first.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '通过在 UART 模式下通过 Bluefruit 应用发送 `{"command": "arena"}`，可以与机器人交互。机器人将以列表的形式发送边界线。然而，理想情况下，我们希望计算机使用
    `matplotlib` 从机器人显示这些信息。我们首先需要将计算机连接到机器人。'
- en: The Bleak library
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Bleak 库
- en: The `python3 -mpip install bleak` to install this. Bleak is documented at [https://bleak.readthedocs.io/en/latest/](https://bleak.readthedocs.io/en/latest/).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `python3 -mpip install bleak` 安装此库。Bleak 的文档在 [https://bleak.readthedocs.io/en/latest/](https://bleak.readthedocs.io/en/latest/)。
- en: We will also need information about the Adafruit Bluefruit system. Bluetooth
    LE has device IDs, and IDs for services on Bluetooth. See [https://learn.adafruit.com/introducing-adafruit-ble-bluetooth-low-energy-friend/uart-service](https://learn.adafruit.com/introducing-adafruit-ble-bluetooth-low-energy-friend/uart-service)
    for details. We will be using these in the following piece of code.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要关于 Adafruit Bluefruit 系统的信息。蓝牙低功耗（BLE）有设备 ID 和蓝牙上服务的 ID。有关详细信息，请参阅 [https://learn.adafruit.com/introducing-adafruit-ble-bluetooth-low-energy-friend/uart-service](https://learn.adafruit.com/introducing-adafruit-ble-bluetooth-low-energy-friend/uart-service)。我们将在下面的代码中使用这些信息。
- en: 'We’ll start with an example to list the devices, to check whether we can find
    the robot’s Bluetooth UART. Create the `find_devices.py` file and add the following:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从列出设备的一个示例开始，以检查我们是否可以找到机器人的蓝牙 UART。创建 `find_devices.py` 文件并添加以下内容：
- en: '[PRE4]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This code starts by importing the `asyncio` and `bleak` libraries. The run function
    needs to be asynchronous so that it can await the `bleak` scanner.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码首先导入 `asyncio` 和 `bleak` 库。run 函数需要是异步的，以便它可以等待 `bleak` 扫描器。
- en: We define the ID and name of the Adafruit Bluefruit based on the Adafruit documentation,
    and then ask the `bleak` library to discover available devices with the Adafruit
    UART service. After waiting for the result, the next few lines print these out.
    The function then filters for the device with the matching name, checks that it
    found it, and prints it successfully.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们根据 Adafruit 文档定义 Adafruit Bluefruit 的 ID 和名称，然后请求 `bleak` 库使用 Adafruit UART
    服务发现可用的设备。等待结果后，接下来的几行将打印这些信息。函数随后会筛选出具有匹配名称的设备，检查是否找到了它，并成功打印出来。
- en: 'Run this with `python3 find_devices.py`. If the robot is off, you will see
    a `Could not find robot` error. However, running with the robot turned on should
    show the following output:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `python3 find_devices.py` 运行此代码。如果机器人处于关闭状态，您将看到“找不到机器人”的错误。然而，在机器人开启状态下运行应该显示以下输出：
- en: '[PRE5]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: From time to time, `bleak` will have trouble finding the robot and display the
    preceding error. You will need to rerun the example to find the robot. We can
    now put this code into a library that we can use in the remaining experiments
    in this chapter.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，`bleak` 可能会难以找到机器人并显示前面的错误。您需要重新运行示例以找到机器人。现在我们可以将此代码放入一个库中，以便在本书剩余的实验中使用。
- en: Creating a Bluetooth LE wrapper library
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个蓝牙低功耗包装库
- en: 'We’ll call the library `robot_ble_connection.py`. We’ll start with imports:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把这个库命名为 `robot_ble_connection.py`。我们将从导入开始：
- en: '[PRE6]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We’ll put our connection handling into a class:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将连接处理放入一个类中：
- en: '[PRE7]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: See [https://learn.adafruit.com/introducing-adafruit-ble-bluetooth-low-energy-friend/gatt-service-details](https://learn.adafruit.com/introducing-adafruit-ble-bluetooth-low-energy-friend/gatt-service-details)
    for an explanation of these variables.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[https://learn.adafruit.com/introducing-adafruit-ble-bluetooth-low-energy-friend/gatt-service-details](https://learn.adafruit.com/introducing-adafruit-ble-bluetooth-low-energy-friend/gatt-service-details)以了解这些变量的解释。
- en: 'When we create the object to handle the connection, we will have two functions
    that the client code can provide, one for a connection being complete and one
    for data being received:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建处理连接的对象时，我们将有两个客户端代码可以提供的函数，一个用于连接完成，一个用于接收数据：
- en: '[PRE8]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`receive_handler` is a function that can be called with a Python `bytes` object
    holding the received data. We’ll adapt our receive handler into one that the `bleak`
    library can use to receive data:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`receive_handler`是一个可以与包含接收数据的Python `bytes`对象一起调用的函数。我们将调整我们的接收处理程序，使其能够被`bleak`库使用来接收数据：'
- en: '[PRE9]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, we add a connect method. This starts the same as the `find_devices` example:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们添加一个连接方法。这和`find_devices`示例的启动方式相同：
- en: '[PRE10]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'However, we then need to connect to this device and handle the received data:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，然后我们需要连接到这个设备并处理接收到的数据：
- en: '[PRE11]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We create a `BleakClient` object and then wait for a connection to the robot.
    After connection, it will create a background task to notify the handler when
    data arrives. This `start_notify` method uses `rx_gatt` to receive UART data from
    this Adafruit Bluefruit device.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个`BleakClient`对象，然后等待连接到机器人。连接后，它将创建一个后台任务来通知处理程序数据到达。这个`start_notify`方法使用`rx_gatt`从这个Adafruit
    Bluefruit设备接收UART数据。
- en: 'We need to be able to close the connection:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要能够关闭连接：
- en: '[PRE12]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then, the final part of this code can send data to the robot:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，这段代码的最后一部分可以向机器人发送数据：
- en: '[PRE13]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This will wait for data to be sent and use the right UUID for transmitting to
    the UART.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这将等待发送数据，并使用正确的UUID将数据传输到UART。
- en: This `robot_ble_connection` library is now ready to be used in code.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`robot_ble_connection`库现在可以在代码中使用了。
- en: Showing the robot’s data on the computer screen
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在计算机屏幕上显示机器人的数据
- en: We can use `matplotlib` to display the data from the robot, connecting to the
    robot with the preceding code, and asking it for the arena. This demonstration
    will tie `matplotlib` together with a Bluetooth connection.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`matplotlib`显示来自机器人的数据，通过前面的代码连接到机器人，并请求竞技场。这个演示将把`matplotlib`与蓝牙连接结合起来。
- en: 'We’ll put this in a new file named `display_from_robot.py`, starting with the
    imports:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把这个放在一个名为`display_from_robot.py`的新文件中，从导入开始：
- en: '[PRE14]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We’ll put our display system in a class called `RobotDisplay`:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把我们的显示系统放在一个名为`RobotDisplay`的类中：
- en: '[PRE15]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The first part sets up the BLE connection and prepares it with a `handle_data`
    method (this is the BLE data handler, which we’ll implement shortly).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分设置BLE连接，并使用一个`handle_data`方法准备它（这是BLE数据处理程序，我们很快将实现它）。
- en: When data arrives via BLE to the computer, a whole message can be split across
    a few calls to the `handle_data` method. We are working in lines of text, so we
    will use `self.buffer` to store any partial line until we get a line ending, signaling
    a line is complete. We also have a place to store the arena from the robot, and
    a flag to detect when the app is closed. The display system is prepared with `plt.subplots`,
    which gets a figure and axes – we’ll use these in a `draw` method to draw the
    display.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据通过BLE到达计算机时，整个消息可以跨越几个对`handle_data`方法的调用进行分割。我们在文本行中工作，所以我们将使用`self.buffer`来存储任何部分行，直到我们得到一个行结束符，表示一行完成。我们还有一个地方来存储来自机器人的竞技场，以及一个标志来检测应用程序是否关闭。显示系统通过`plt.subplots`准备好，它获取一个图形和坐标轴——我们将在`draw`方法中使用这些来绘制显示。
- en: 'Let’s make a handler for the app being closed:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为应用程序关闭创建一个处理程序：
- en: '[PRE16]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This handler will just set the `closed` flag to `True`, which we can check for
    later. `matplotlib` will automatically create an app window for us to display
    output.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 此处理程序将仅将`closed`标志设置为`True`，我们可以在以后进行检查。`matplotlib`将自动为我们创建一个应用程序窗口来显示输出。
- en: 'Next, we will build the BLE data handler:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将构建BLE数据处理器：
- en: '[PRE17]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This collects decoded incoming data into the `self.buffer` variable. While that
    buffer has line endings, `"\n"`, it splits a single line off and decodes it as
    JSON.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这将解码传入的数据并将其收集到`self.buffer`变量中。当缓冲区有行结束符`"\n"`时，它将分割出单行并将其解码为JSON。
- en: We then check whether this JSON has arena data in it. If so, we store it in
    the `arena` data member.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们检查这个JSON是否包含竞技场数据。如果是，我们将其存储在`arena`数据成员中。
- en: 'Next, we put the arena line drawing into a method:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将竞技场线绘制放入一个方法中：
- en: '[PRE18]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This function clears the previous display using the `self.axes.clear()` function
    and then redraws the arena lines.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数使用 `self.axes.clear()` 函数清除之前的显示，然后重新绘制竞技场线条。
- en: 'The app `main` method starts the connection and asks the robot for the arena:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的 `main` 方法启动连接并请求机器人提供竞技场：
- en: '[PRE19]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This function enables interactive mode in `matplotlib` with `plt.ion()` – this
    means we get to handle when the screen is redrawn, which suits our data model.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数通过 `plt.ion()` 启用 `matplotlib` 的交互模式 – 这意味着我们可以处理屏幕重绘的时间，这适合我们的数据模型。
- en: We then call and wait for the BLE `connect` function. Once a connection has
    been made, we wrap the rest in a `try`/`finally` block that will ensure the BLE
    connection is closed if this code is stopped or breaks. We then send a request
    to the robot, asking for the arena.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后调用并等待 BLE 的 `connect` 函数。一旦建立连接，我们将剩余部分包裹在一个 `try`/`finally` 块中，以确保如果此代码停止或中断，BLE
    连接将被关闭。然后我们向机器人发送请求，要求获取竞技场。
- en: 'The code sets up the `close` handler so we can detect whether the window is
    closed, and immediately gets into a main `while` loop based on the closed flag:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码设置 `close` 处理器，以便我们可以检测窗口是否关闭，并立即基于关闭标志进入主 `while` 循环：
- en: '[PRE20]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The main loop uses `plt.draw()` to update the display and then waits 0.05 seconds,
    giving `matplotlib` time to handle interactive events. It also has a 0.01-second
    asynchronous sleep to give the BLE tasks time to run. These sleeps and pauses
    must be called frequently. At the end, `finally` ensures we close the BLE connection.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 主循环使用 `plt.draw()` 更新显示，然后等待0.05秒，给 `matplotlib` 处理交互事件的时间。它还有一个0.01秒的异步睡眠，给
    BLE 任务运行的时间。这些睡眠和暂停必须频繁调用。最后，`finally` 确保我们关闭 BLE 连接。
- en: 'We then need to create an instance of the class and start the `main` loop:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来需要创建类的实例并启动 `main` 循环：
- en: '[PRE21]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'At this point, the display code is complete. Send the `robot` folder to Raspberry
    Pi Pico, and with battery power turned on, start the display code with the following:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，显示代码已完成。将 `robot` 文件夹发送到 Raspberry Pi Pico，并开启电池电源，使用以下命令启动显示代码：
- en: '[PRE22]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You should see the BLE connecting messages and then the following output on
    the computer:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到 BLE 连接消息，然后在计算机上看到以下输出：
- en: '[PRE23]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: After around 30 seconds, you should see the computer display the arena. This
    will look identical to *Figure 13**.6*, but the data is now coming from the robot.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 大约30秒后，你应该看到计算机显示竞技场。这看起来与 *图13**.6 相同，但现在数据来自机器人。
- en: We have the computer connecting to the robot and retrieving arena information
    from it. The robot has modeled the space in simple terms.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们让计算机连接到机器人，并从它那里检索竞技场信息。机器人以简单的方式对空间进行了建模。
- en: In the next section, we’ll look more at robot poses, displaying them on our
    computer, and updating them from encoder sensors.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将更详细地探讨机器人姿态，在计算机上显示它们，并从编码器传感器更新它们。
- en: Using sensors to track relative pose
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用传感器跟踪相对姿态
- en: In this section, we will explore what a pose is, how to create, send, and display
    poses, and how to move the poses relative to the movement of the robot.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨什么是姿态，如何创建、发送和显示姿态，以及如何根据机器人的移动来移动姿态。
- en: Setting up poses
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置姿态
- en: We’ll make some random poses in `robot/code.py` using `ulab` providing this
    functionality in CircuitPython. This library also gives us handy ways of storing
    and dealing with arrays.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 `robot/code.py` 中使用 `ulab` 创建一些随机姿态，提供 CircuitPython 中的此功能。此库还提供了方便的方式来存储和处理数组。
- en: 'Import the `ulab` library, and `random` to generate random poses:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 导入 `ulab` 库和 `random` 以生成随机姿态：
- en: '[PRE24]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'After the `read_json` function, we’ll add a `Simulation` class to hold the
    poses:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `read_json` 函数之后，我们将添加一个 `Simulation` 类来保存姿态：
- en: '[PRE25]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We will create a small population of 20 random poses. The `poses` variable is
    a `NumPy` array of `population_size` items, with each item an *X*, *Y* heading
    pose. NumPy allows us to specify a datatype; we use the `float` type so that we
    can work in fractional values.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个包含20个随机姿态的小型种群。`poses` 变量是一个 `population_size` 个元素的 `NumPy` 数组，每个元素都是一个
    *X*，*Y* 航向姿态。NumPy 允许我们指定数据类型；我们使用 `float` 类型，这样我们就可以在分数值中工作。
- en: 'Add a function (before `Simulation`) to send *X* and *Y* pose coordinates to
    the computer:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Simulation` 之前添加一个函数，用于将 *X* 和 *Y* 姿态坐标发送到计算机：
- en: '[PRE26]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `[:, :2]` notation lets us extract the first two entries of each pose in
    the `poses` array, the *X* and *Y* coordinates. We convert this to `int16` to
    reduce how much data is being sent – the UART is easily overwhelmed by pose data.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`[:, :2]` 符号使我们能够从 `poses` 数组中的每个姿态提取前两个条目，即 *X* 和 *Y* 坐标。我们将这些转换为 `int16`
    以减少发送的数据量 – UART 容易被姿态数据淹没。'
- en: 'The command handler can now send poses after the arena for now:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 命令处理程序现在可以在场地之后发送姿态：
- en: '[PRE27]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now, `command_handler` has the simulation passed into it and sends the poses
    back after the arena. Before we start the handler, we create `simulation` from
    its class.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`command_handler`接收模拟并通过场地发送姿态。在我们开始处理程序之前，我们根据其类创建`simulation`。
- en: This code is now ready for the computer to display these poses.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码现在已准备好由计算机显示这些姿态。
- en: Displaying poses
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示姿态
- en: 'We can now enhance our `matplotlib` file, `display_from_robot.py`, with the
    poses. First, we will add `numpy` to the imports:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以增强我们的`matplotlib`文件`display_from_robot.py`，添加姿态。首先，我们将添加`numpy`到导入部分：
- en: '[PRE28]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'When we set up the display in the `__init__` method, we add an empty `poses`
    member:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在`__init__`方法中设置显示时，我们添加一个空的`poses`成员：
- en: '[PRE29]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Next, we need to extend `handle_data` to load poses into an `int16` NumPy array:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要扩展`handle_data`以将姿态加载到`int16` NumPy数组中：
- en: '[PRE30]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We then add extend the `draw` method to display poses, checking whether any
    are loaded and, if so, putting them into a scatter plot, slicing into the *X*
    and *Y* components to fit `matplotlib` :'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们扩展`draw`方法以显示姿态，检查是否有加载的，如果有，将它们放入散点图，分割到*X*和*Y*组件以适应`matplotlib`：
- en: '[PRE31]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Send the `robot` folder over to Pico, and then run `display_from_robot.py`
    on the computer, and after the BLE startup, you should see something like the
    following screenshot:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 将`robot`文件夹发送到Pico，然后在计算机上运行`display_from_robot.py`，在BLE启动后，你应该看到以下截图类似的内容：
- en: '![Figure 13.7 – Poses drawn in the arena ](img/Figure_13.07_B18001.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![图13.7 – 场地中绘制的姿态](img/Figure_13.07_B18001.jpg)'
- en: Figure 13.7 – Poses drawn in the arena
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.7 – 场地中绘制的姿态
- en: '*Figure 13**.7* shows the arena with 20 poses drawn as dots. Each dot is a
    potential guess of where the robot might be. Some are in the cutout area and will
    later be eliminated.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13.7*显示了场地中绘制的20个姿态，以点表示。每个点都是机器人可能位置的潜在猜测。其中一些在切割区域，稍后将被消除。'
- en: These poses will need to move when our robot moves, so let’s make our robot
    move.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这些姿态需要在我们机器人移动时移动，所以让我们让我们的机器人移动。
- en: Moving with collision avoidance
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 带碰撞避免的移动
- en: 'The robot will be moving while we perform the simulation, and it would be good
    to avoid collisions while the robot moves. We’ll do this as an asynchronous routine
    so that other parts of the code can run at the same time. The following architecture
    diagram shows how this works:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 机器人在我们进行模拟时会移动，所以在机器人移动时避免碰撞会很好。我们将通过异步程序来完成这项工作，这样代码的其他部分也可以同时运行。以下架构图显示了这是如何工作的：
- en: '![Figure 13.8 – A simulation with a collision avoidance architecture ](img/Figure_13.08_B18001.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![图13.8 – 具有碰撞避免架构的模拟](img/Figure_13.08_B18001.jpg)'
- en: Figure 13.8 – A simulation with a collision avoidance architecture
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.8 – 具有碰撞避免架构的模拟
- en: The `command handler` system accepts Bluetooth command requests. The command
    handler starts the `main` loop in `simulation`. The simulation will start both
    a `simulation` `main` method also sends poses via Bluetooth.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`command handler`系统接受蓝牙命令请求。命令处理程序在`simulation`中启动`main`循环。模拟将启动一个`simulation`
    `main`方法，并通过蓝牙发送姿态。'
- en: 'We will start with `DistanceSensorTracker`, a class to keep tabs on the distance
    sensors and their last readings. Place this in `robot/code.py` under the imports:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从`DistanceSensorTracker`开始，这是一个用于跟踪距离传感器及其最后读数的类。将此放在`robot/code.py`下的导入部分：
- en: '[PRE32]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We are being explicit about sensor mode here, adjusting it to the size of the
    arena. We also put in starting values until a reading is available.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里明确指定了传感器模式，调整它以适应场地的尺寸。我们还输入了起始值，直到有读数可用。
- en: 'The sensor tracker loop fetches readings when ready and resets the sensor interrupts:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 传感器追踪器循环在准备好时获取读数并重置传感器中断：
- en: '[PRE33]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We are multiplying the sensor readings by 10 to convert them to mm, and then
    storing them. The remaining code can just use these stored readings.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将传感器读数乘以10以将其转换为毫米，然后存储它们。剩余的代码可以直接使用这些存储的读数。
- en: 'Next, we’ll build the `CollisionAvoid` class to turn the robot away from a
    wall that it detects with the sensors. Add this class after the `DistanceSensorTracker`
    class:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将构建`CollisionAvoid`类，以使机器人远离传感器检测到的墙壁。在`DistanceSensorTracker`类之后添加此类：
- en: '[PRE34]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This has an initial robot speed, along with a reference to the distance sensor
    tracker. This then has a `main` collision-avoiding loop:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这有一个初始的机器人速度，以及一个关于距离传感器追踪器的引用。然后有一个`main`碰撞避免循环：
- en: '[PRE35]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This loop starts the right motor moving, and if a collision looks likely, it
    will set the left motor going backward and wait before driving forward. The `asyncio.sleep`
    delays mean that other tasks can continue on the robot.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 此循环启动右电机移动，如果看起来可能发生碰撞，它将设置左电机向后移动并等待然后再前进。`asyncio.sleep` 延迟意味着其他任务可以在机器人上继续。
- en: 'Inside the `Simulation` class, add the sensors and `collision_avoider` to the
    `__init__` method:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Simulation` 类内部，将传感器和 `collision_avoider` 添加到 `__init__` 方法中：
- en: '[PRE36]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Then, we add a simulation `main` method below the `__init__` simulation. This
    starts tasks for the other components and then loops over, sending the poses back
    to the computer:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在 `__init__` 模拟下方添加一个模拟 `main` 方法。这启动了其他组件的任务，然后循环发送姿态回计算机：
- en: '[PRE37]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: There’s also error handling to stop the robot if anything goes wrong here –
    we cancel the collision avoider task (which would set the robot’s speed) and stop
    the motors. The sleep here allows the other tasks to run and avoids overwhelming
    the BLE UART.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有错误处理以停止机器人，如果这里发生任何错误 – 我们取消碰撞避免器任务（这将设置机器人的速度）并停止电机。这里的睡眠允许其他任务运行并避免 BLE
    UART 过载。
- en: 'Extend the `command_handler` method to start the simulation’s `main` task.
    We’ll do so based on a **Start** button in the display UI. First, we’ll store
    the task state at the top of the handler:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展 `command_handler` 方法以启动模拟的 `main` 任务。我们将基于显示 UI 中的 **启动** 按钮这样做。首先，我们将在处理程序的顶部存储任务状态：
- en: '[PRE38]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Then, we’ll handle a `start` command in it:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将处理其中的 `start` 命令：
- en: '[PRE39]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The start button will run the simulation `main` task if it’s not yet been run.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果尚未运行，启动按钮将运行模拟 `main` 任务。
- en: Adding the start button on the computer
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在计算机上添加启动按钮
- en: 'We need to add the corresponding button to the computer display code. Open
    `display_from_robot.py`. In the imports, add the following:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将相应的按钮添加到计算机显示代码中。打开 `display_from_robot.py`。在导入部分，添加以下内容：
- en: '[PRE40]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In the `RobotDisplay` class, we can add a helper to send a JSON command, much
    as we did on the robot. Add this to the robot display class above its `main` method:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `RobotDisplay` 类中，我们可以添加一个辅助程序来发送 JSON 命令，就像我们在机器人上所做的那样。将其添加到机器人显示类中，在 `main`
    方法之上：
- en: '[PRE41]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This must be asynchronous to use `await` on the BLE `send_uart_data` function.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用 `await` 在 BLE `send_uart_data` 函数上，这必须是非同步的。
- en: 'Above `main`, add a start button handler to call when the button is pressed:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main` 之上添加一个启动按钮处理程序，以便在按钮被按下时调用：
- en: '[PRE42]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This will start sending the data but not wait for it – so the `matplotlib` event
    loop doesn’t get stuck waiting.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这将开始发送数据但不等待它 – 因此 `matplotlib` 事件循环不会卡在等待中。
- en: 'We can replace the JSON sending in the `main` method with the `send_command`
    method:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用 `send_command` 方法替换 `main` 方法中的 JSON 发送：
- en: '[PRE43]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We then add the button. Add the highlighted code into the `main` method:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们添加按钮。将高亮代码添加到 `main` 方法中：
- en: '[PRE44]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The code uses the `send_command` wrapper to request the arena on startup. We
    then add `start_button`, using `plt.axes` to position it.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 代码使用 `send_command` 包装器在启动时请求竞技场。然后我们添加 `start_button`，使用 `plt.axes` 来定位它。
- en: We connect a button `on_clicked` handler to the `start` method to enable the
    button.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将一个 `on_clicked` 处理程序连接到 `start` 方法以启用按钮。
- en: 'Send the `robot` folder to Raspberry Pi Pico, and on the computer, run `display_from_robot.py`.
    I recommend propping the robot up for troubleshooting while connected, and then
    test it in the arena. The display will look like the following screenshot:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `robot` 文件夹发送到 Raspberry Pi Pico，并在计算机上运行 `display_from_robot.py`。我建议在连接时将机器人支撑起来以进行故障排除，然后在竞技场中测试它。显示将类似于以下截图：
- en: '![Figure 13.9 – The arena display with a button ](img/Figure_13.09_B18001.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.9 – 带按钮的竞技场显示](img/Figure_13.09_B18001.jpg)'
- en: Figure 13.9 – The arena display with a button
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.9 – 带按钮的竞技场显示
- en: '*Figure 13**.9* shows the **Start** button on the display. Press **Start**
    to get the robot running – poses will appear, and the robot should be avoiding
    walls in the arena. If not, the next section will help.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13**.9* 显示了显示上的 **启动** 按钮。按下 **启动** 以使机器人运行 – 姿态将出现，机器人应该会在竞技场中避开墙壁。如果不这样做，下一节将有所帮助。'
- en: Troubleshooting
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 故障排除
- en: 'These suggestions will help if you are having trouble here:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在这一步遇到困难，以下建议可能会有帮助：
- en: If the distance sensors are showing errors, please go back to [*Chapter 8*](B18001_08.xhtml#_idTextAnchor166),
    *Sensing Distances to Detect Objects with Pico*, and check the wiring, using the
    tests there.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果距离传感器显示错误，请返回到 [*第 8 章*](B18001_08.xhtml#_idTextAnchor166)，*使用 Pico 感测距离以检测物体*，并检查布线，使用那里的测试。
- en: If the robot is turning too far and getting trapped in the corners, lower the
    sleep after `robot.set_left(-self.speed)`.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果机器人转向过度并陷入角落，请在`robot.set_left(-self.speed)`之后降低sleep时间。
- en: If the robot is going very quickly, either reduce `self.speed` or replace the
    motors with a greater gear ratio – ideally, 298:1, as recommended in [*Chapter
    11*](B18001_11.xhtml#_idTextAnchor233) in the *Slowing the Robot* *Down* section.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果机器人移动速度非常快，可以减少`self.speed`的值，或者用更大齿轮比的电机替换——理想情况下，为298:1，如*减速机器人*部分中[*第11章*](B18001_11.xhtml#_idTextAnchor233)所推荐。
- en: While the robot is now avoiding walls, the poses are not changing when the robot
    moves. To remedy this, we can add a motion model in the next section.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 当机器人现在正在避开墙壁时，当机器人移动时，姿态并没有改变。为了解决这个问题，我们可以在下一节中添加一个运动模型。
- en: Moving poses with the encoders
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用编码器移动姿态
- en: 'We want the poses to move with our robot’s motion, updating both their position
    and their heading. The wheel encoders provide data about each wheel’s motion,
    and we can convert this into rotations and translations of the pose. First, we
    need to store more data about the shape of the chassis in `robot/robot.py`:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望姿态随着机器人的运动而移动，更新它们的位置和航向。轮子编码器提供了关于每个轮子运动的资料，我们可以将这些数据转换为姿态的旋转和平移。首先，我们需要在`robot/robot.py`中存储更多关于底盘形状的数据：
- en: '[PRE45]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We ensure our tick conversion is in mm. We then add the wheelbase – this is
    a measurement between the central contact point of each wheel. Use a value measured
    from your own robot. We can use the wheelbase to calculate the robot’s movement
    from the encoders, as shown in the following diagram:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们确保我们的tick转换是以毫米为单位的。然后我们添加轴距——这是每个轮子中央接触点之间的测量值。使用从您自己的机器人测量的值。我们可以使用轴距来计算机器人从编码器中的运动，如图所示以下图表：
- en: '![Figure 13.10 – Calculating motion from encoders ](img/Figure_13.10_B18001.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![图13.10 – 从编码器计算运动](img/Figure_13.10_B18001.jpg)'
- en: Figure 13.10 – Calculating motion from encoders
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.10 – 从编码器计算运动
- en: '*Figure 13**.10 (a)* shows the robot moving along an arc. Each wheel encoder
    will sense travel along an arc on an inner radius or an outer radius. Our robot
    uses a differential drive, so we can assume all motion takes place around the
    axis between the two wheels. The center of the robot, our pose, travels along
    the turn radius. We can use these with the wheel distance – the distance between
    the two wheels to calculate the arc.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13.10 (a)*显示机器人沿着弧线移动。每个轮子编码器都会感应到在内部半径或外部半径上的弧线运动。我们的机器人使用差速驱动，因此我们可以假设所有运动都发生在两个轮子之间的轴上。机器人的中心，即我们的姿态，沿着转弯半径移动。我们可以使用这些信息，结合轮距——两个轮子之间的距离来计算弧线。'
- en: '*Figure 13**.10 (b)* relates an arc length to the arc angle and radius. Each
    wheel will have traveled an arc, and the encoder will have measured the arc length.
    This arc length is the radius multiplied by the angle (in radians). We will use
    this to calculate the arc. From the motion of the two wheels, measured by the
    encoders (arc lengths) and the wheel distance, we can get the radius and angle
    change (`d_theta`).'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13.10 (b)*将弧长与弧度和半径相关联。每个轮子都会行驶一段弧线，编码器会测量弧长。这个弧长是半径乘以角度（以弧度为单位）。我们将使用这个值来计算弧线。从两个轮子的运动（通过编码器测量的弧长）和轮距，我们可以得到半径和角度变化（`d_theta`）。'
- en: '*Figure 13**.10 (c)* represents a robot motion. Although the robot has moved
    in an arc, for the simulation, we will simplify this arc motion into three components
    – *rotation 1* aligns the robot for a straight-line *translation*, and then *rotation
    2* turns the robot to face the heading expected at the end of the curve.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13.10 (c)*表示机器人运动。尽管机器人沿着弧线移动，但在模拟中，我们将这种弧线运动简化为三个组件——*旋转1*使机器人对齐以进行直线*平移*，然后*旋转2*使机器人转向曲线末尾预期的航向。'
- en: 'Add the following into the `Simulation` class in `robot/code.py`:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下内容添加到`robot/code.py`中的`Simulation`类中：
- en: '[PRE46]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This function will take the changes (or deltas) in encoders and convert them
    to obtain representations of *rotation 1*, *translation*, and *rotation 2*. The
    encoder changes are turned into measurements in mm. We then check for the straight-line
    case, and if it is there, return a translation component only. This prevents `0`
    causing the next part to crash.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数将编码器的变化（或增量）转换为*旋转1*、*平移*和*旋转2*的表示。编码器变化被转换为毫米单位的测量值。然后我们检查直线情况，如果存在，则仅返回平移组件。这可以防止`0`导致下一部分崩溃。
- en: 'The remaining cases now need us to calculate an arc:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 现在剩余的情况需要我们计算一个弧线：
- en: '[PRE47]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The first line uses the wheelbase and the two encoder movements to calculate
    an arc radius. The difference between the motion of the two wheels is then used
    to calculate `d_theta`, how much the robot’s heading changed throughout this arc.
    The `d` prefix represents a delta.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行使用轴距和两个编码器移动来计算弧半径。然后，使用两个车轮的运动差异来计算 `d_theta`，即在这个弧中机器人航向的变化量。`d` 前缀代表增量。
- en: The arc length is then `d_theta` multiplied by the radius. Because this will
    be called fairly frequently, we are going to assume that the arc length is close
    enough to the translation.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 弧长是 `d_theta` 乘以半径。因为这将相当频繁地被调用，所以我们假设弧长足够接近平移。
- en: 'From here, the rotation components can be calculated:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，可以计算旋转分量：
- en: '[PRE48]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: If we assume the arc to be regular, then each rotation component is half of
    the full arc rotation. We also convert this into degrees.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们假设弧是规则的，那么每个旋转分量是完整弧旋转的一半。我们还将此转换为度数。
- en: 'We can then write a method to move poses this way. Add this to `Simulation`
    by following these steps:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以编写一个方法来以这种方式移动姿态。按照以下步骤将此方法添加到 `Simulation` 中：
- en: 'Define the method and add the first rotation into the array of pose rotations
    (the third element):'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义方法并将第一次旋转添加到姿态旋转数组中（第三个元素）：
- en: '[PRE49]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We then move the translation term in the new pose direction:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将平移项移动到新的姿态方向：
- en: '[PRE51]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The `rot1_radians` variable will hold a `NumPy` array. This comes from the second
    element of the poses array, converted into radians. The ability of `NumPy` (or
    `ulab`) to operate on whole arrays is handy here. We will use it again to calculate
    the *X* and *Y* motions. `trans * np.cos` applies the cosine function to every
    element in `rot1_radians` and multiplies each one by the translation term.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`rot1_radians` 变量将保存一个 `NumPy` 数组。这来自姿态数组的第二个元素，转换为弧度。`NumPy`（或 `ulab`）能够操作整个数组的能力在这里很有用。我们再次使用它来计算
    *X* 和 *Y* 运动。`trans * np.cos` 将余弦函数应用于 `rot1_radians` 中的每个元素，并将其乘以平移项。'
- en: 'We then need to add the `rot2` term:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要添加 `rot2` 项：
- en: '[PRE54]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Finally, we constrain the angles between 0 and 360 degrees.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将角度限制在0到360度之间。
- en: 'Next, we need to tie these together with getting the encoder deltas. First,
    we extend the `Simulation.__init__` method to get the initial encoder readings:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要将这些与获取编码器增量联系起来。首先，扩展 `Simulation.__init__` 方法以获取初始编码器读数：
- en: '[PRE56]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'We will use this encoder data in a motion model, moving all our poses with
    the robot’s motion. In the `Simulation` class, we will then add a `motion_model`
    method:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这个编码器数据在运动模型中，用机器人的运动移动所有姿态。然后在 `Simulation` 类中添加一个 `motion_model` 方法：
- en: 'It first gets the latest encoder readings:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它首先获取最新的编码器读数：
- en: '[PRE59]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We calculate the deltas and feed these into `convert_odometry_to_motion`:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们计算增量并将这些输入到 `convert_odometry_to_motion`：
- en: '[PRE62]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We must update the last encoder readings so that we''ll get deltas next time:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须更新最后的编码器读数，以便下次获取增量：
- en: '[PRE65]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Now, we apply these odometry values to our poses:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将这些里程计值应用到我们的姿态上：
- en: '[PRE67]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'We now need to call this motion model. In `Simulation.main`, add the highlighted
    code:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要调用这个运动模型。在 `Simulation.main` 中添加高亮代码：
- en: '[PRE68]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: This will apply the motion model at every cycle before sending the poses. Since
    the motion model requires time to run, the sleep is reduced to compensate, keeping
    the UART data rate similar. Copy the contents of the `robot` folder to Raspberry
    Pi Pico, and launch the `display_from_robot` app.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在发送姿态之前在每个周期应用运动模型。由于运动模型需要时间来运行，因此将睡眠时间减少以补偿，以保持UART数据率相似。将 `robot` 文件夹的内容复制到
    Raspberry Pi Pico，并启动 `display_from_robot` 应用程序。
- en: When you press **Start**, you should now see the poses moving as the robot moves
    around the arena. All the poses should follow the same path, but each from a different
    starting point and orientation.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 当你按下 **开始** 时，你现在应该看到姿态随着机器人在竞技场周围移动而移动。所有姿态都应该遵循相同的路径，但每个都是从不同的起点和方向开始的。
- en: These poses are moving, but the real world is messy, so let’s add randomness
    to this.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这些姿态正在移动，但现实世界很混乱，所以让我们给这个添加随机性。
- en: Pose movement probabilities
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 姿态移动概率
- en: 'Robot movement is not always certain; although we have encoders, wheels can
    slip, wheel sizes can have minor variations, and our calculations might not be
    100% accurate. Imagine that the preceding poses are in a cluster or the cloud,
    and then our robot drives in a particular direction. The following diagram should
    demonstrate this:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 机器人运动并不总是确定的；尽管我们有编码器，车轮可能会打滑，车轮尺寸可能会有细微差异，我们的计算可能不是100%准确。想象一下，前面的姿态在一个簇或云中，然后我们的机器人向特定方向行驶。以下图表应该可以演示这一点：
- en: '![Figure 13.11 – Movement probability distributions ](img/Figure_13.11_B18001.jpg)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![图13.11 – 移动概率分布](img/Figure_13.11_B18001.jpg)'
- en: Figure 13.11 – Movement probability distributions
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.11 – 移动概率分布
- en: '*Figure 13**.11 (a)* shows a section of the arena, with arena coordinates shown
    on the axes. The cluster around the point (250,300) is the initial robot pose
    guesses. The thick line and angle arc show a robot movement at 300 mm, bearing
    30 degrees. However, due to the uncertainties of the motion, the cluster gets
    spread out. The arc shape is due to uncertainty in the angle of the motion, and
    the width of the arc represents the uncertainty of the forward motion of the robot.
    This banana shape represents where a robot could end up. The image here has been
    exaggerated, as the spread on the robot should be far less than this.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13**.11 (a)* 展示了竞技场的一部分，竞技场坐标显示在坐标轴上。围绕点 (250,300) 的簇是初始机器人姿态猜测。粗线和角度弧表示300毫米、30度的机器人移动。然而，由于运动的不可确定性，簇被分散开来。弧形是由于运动角度的不确定性造成的，弧的宽度代表机器人向前运动的不确定性。这种香蕉形状表示机器人可能到达的位置。这里的图像已经被夸张了，因为机器人的扩散应该远小于这个。'
- en: '*Figure 13**.11 (b)* shows how we can model this uncertainty centered around
    a **mean** (average or most likely value) of 0, with a variation on either side.
    A **probability distribution** maps how likely a value is to come up in a random
    selection. The height of each point signifies how likely a particular value is
    to come up. If we use a uniform distribution, all possibilities between -1.0 and
    +1.0 are equal, giving us a rectangle shown for *n=1*. However, we want this distribution
    centered around the mean. If we sum two samples from the uniform distribution
    from -1.0 to 1.0 and divide by 2, we get the *n=2* graph. This is approximately
    a triangle. Here, *n* represents the number of uniform random sample picks we
    add together. We could refine this to the *n=4* curve, using a sum of four uniform
    samples and dividing by 4; however, the trade-off between ideal curves and the
    time cost for each uniform distribution sample makes the triangle at *n=2* good
    enough for our purposes to center the distribution.'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13**.11 (b)* 展示了如何以0为均值（平均或最可能值）为中心来模拟这种不确定性，并在两侧进行变化。**概率分布**映射了在随机选择中某个值出现的可能性。每个点的海拔高度表示特定值出现的可能性。如果我们使用均匀分布，-1.0和+1.0之间的所有可能性都是相等的，这在我们用
    *n=1* 表示的矩形中可以看到。然而，我们希望这种分布以均值为中心。如果我们从-1.0到1.0的均匀分布中取两个样本并除以2，我们就会得到 *n=2* 图。这大约是一个三角形。在这里，*n*
    代表我们添加到一起的均匀随机样本选择数量。我们可以将这个曲线细化到 *n=4*，使用四个均匀样本的总和并除以4；然而，理想曲线和每个均匀分布样本的时间成本之间的权衡使得
    *n=2* 的三角形对于我们的目的来说已经足够好，可以用来使分布居中。'
- en: 'We will use the *n=2* distribution in our model. In `robot/code.py`, add the
    following piece of code before `class Simulation`:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在模型中使用 *n=2* 分布。在 `robot/code.py` 中，在 `class Simulation` 之前添加以下代码片段：
- en: '[PRE69]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: This code will add the two samples, scaling the uniform distributions to match
    how much the model varies, divide by 2, and then add the mean.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将添加两个样本，将均匀分布缩放到与模型变化相匹配的程度，然后除以2，并加上均值。
- en: 'The other factor we will need to account for is that the larger the movement
    we make, the larger the random error factor will be. A large forward motion will
    influence the rotation, and large rotations will affect the forward motion (translation).
    It is conventional to refer to the factors for these influences as `alpha`. Let’s
    add these values to our `Simulation.__init__` class:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要考虑的另一个因素是，我们做的运动越大，随机误差因子就越大。大的前进运动会影响旋转，而大的旋转会影响前进运动（平移）。通常将这些影响因子称为 `alpha`。让我们将这些值添加到我们的
    `Simulation.__init__` 类中：
- en: '[PRE70]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: We have four terms here. They should be values between 0 and 1 and kept low.
    The value `0.05` will represent a 5% error. Tune them to reflect the error seen
    in your robot.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这里有四个项。它们的值应该在0到1之间，并保持较低。值 `0.05` 将代表5%的误差。调整它们以反映你在机器人中看到的误差。
- en: 'We will use this to apply randomness to our model:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这个来对我们的模型应用随机性：
- en: 'Add the following method in `Simulation`, after `move_poses`:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Simulation` 中 `move_poses` 之后添加以下方法：
- en: '[PRE71]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Calculate the scaling factors from the `alpha` terms:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `alpha` 项计算缩放因子：
- en: '[PRE72]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The rotation scaling factors are based on the absolute value of each element;
    they must not be negative. The rotation scales have both a rotation factor and
    a lower translation factor. The translation scale has a translation factor (usually
    larger) and a factor based on both rotations.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 旋转缩放因子基于每个元素的绝对值；它们不能为负。旋转缩放具有旋转因子和较低的平移因子。平移缩放具有平移因子（通常较大）和基于旋转的因子。
- en: 'We will now use this to generate noise around the motion for every pose:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将使用这个模型为每个姿态的运动生成噪声：
- en: '[PRE75]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: This uses the scaled sample function we created, with our scale factor. It uses
    the calculated rotation or translation as a mean. We run this through loops for
    each pose dimension, so for a population of 200, we will get 200 random samples,
    centered around the calculated measurement, with variation scaled to the calculated
    factor.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用我们创建的缩放样本函数，以及我们的缩放因子。它使用计算出的旋转或平移作为平均值。我们对每个姿态维度运行这个循环，因此对于一个200的种群，我们将得到200个围绕计算测量值的随机样本，其变化按计算因子缩放。
- en: 'Finally, we return these models:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们返回这些模型：
- en: '[PRE78]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'We now have a model that generates noise in our motion, meaning that it will
    compensate for the inaccuracies in the measurement by modeling the uncertainty
    in that measurement. Add the highlighted code for this to the `motion_model` method:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个模型可以在我们的运动中生成噪声，这意味着它将通过模拟该测量的不确定性来补偿测量不准确。将高亮显示的代码添加到`motion_model`方法中：
- en: '[PRE79]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: The changes swap the `rot1` variable out for `rot1_model` and do a similar swap
    for the other pose elements. As `rot1_model` has the same number of elements as
    our poses, passing this into `move_poses` will add each sample element-wise to
    the respective pose element. This method takes advantage of how `NumPy` manipulates
    lists.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 变更将`rot1`变量替换为`rot1_model`，并对其他姿态元素进行类似的替换。由于`rot1_model`具有与我们的姿态相同的元素数量，将其传递到`move_poses`中会将每个样本元素逐个添加到相应的姿态元素。这种方法利用了`NumPy`如何操作列表。
- en: Copy the `robot` folder to the robot and run the `display_from_robot.py` app
    on your computer. The motion will be a little randomized. Now, let’s check that
    your robot code is working and behaving as expected.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 将`robot`文件夹复制到机器人上，并在您的电脑上运行`display_from_robot.py`应用程序。运动将会有点随机化。现在，让我们检查您的机器人代码是否按预期工作并表现良好。
- en: Troubleshooting
  id: totrans-327
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 故障排除
- en: 'If this example does not work, try the following methods:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个示例不起作用，请尝试以下方法：
- en: Run with the robot propped up and connected to the computer so that the Mu editor
    serial can see its state. This will show you whether there are any errors in the
    code.
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行机器人，使其支撑起来并连接到电脑，这样Mu编辑器的串口可以查看其状态。这将显示代码中是否存在任何错误。
- en: If the movements are too far or too little, adjust the measurements in `robot/robot.py`
    to match your robot, as they may vary from example values.
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果运动太远或太短，请调整`robot/robot.py`中的测量值以匹配您的机器人，因为它们可能与示例值不同。
- en: If you see sensor or I2C issues, backtrack to check the wiring and previous
    sensor demonstration examples. Also, ensure that you have fresh batteries.
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您看到传感器或I2C问题，请回溯检查布线和之前的传感器演示示例。同时，请确保您有新电池。
- en: We now have our poses motion model based on the encoders. We can now bring the
    distance sensors and arena data into play with the Monte Carlo simulation.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有了基于编码器的姿态运动模型。我们可以现在利用蒙特卡洛模拟将距离传感器和竞技场数据纳入考虑。
- en: Monte Carlo localization
  id: totrans-333
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 蒙特卡洛定位
- en: Our robot’s poses are going outside of the arena, and the distance sensor readings
    should show which guesses (poses) are more likely than others. The **Monte Carlo**
    simulation can improve these guesses, based on the sensor-reading likelihood.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 我们机器人的姿态正在超出竞技场范围，距离传感器的读数应该显示哪些猜测（姿态）比其他猜测更有可能。**蒙特卡洛**模拟可以根据传感器的读数可能性改进这些猜测。
- en: The simulation moves the poses and then observes the state of the sensors to
    create weights based on their likelihood, a process known as the **observation
    model**.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟移动姿态，然后观察传感器的状态以创建基于其可能性的权重，这个过程被称为**观测模型**。
- en: The simulation **resamples** the guesses by picking them, so those with higher
    weights are more likely. The result is a new generation of guesses. This movement
    of particles followed by filtering is why this is also known as a **particle filter**.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟**重新采样**猜测值，通过选择它们，因此权重更高的更有可能。结果是新一代的猜测值。这种粒子跟随过滤的运动是为什么这也被称为**粒子滤波器**。
- en: Let’s start by giving our poses weights, based on being inside or outside the
    arena, and then we’ll look at how to resample from this.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从给我们的姿态分配权重开始，基于它们是否在竞技场内或外，然后我们将探讨如何从这些权重中进行重采样。
- en: Generating pose weights from a position
  id: totrans-338
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从位置生成姿态权重
- en: The initial weight generation can be based on a simple question – is the robot
    inside the arena or not? If not, then we can reduce the pose probability. Note
    that we don’t eliminate these, as the robot could have been placed outside the
    arena map or been tested on your desk. We will just give them a lower probability
    than those that are inside the arena.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 初始权重生成可以基于一个简单的问题 – 机器人是否在竞技场内？如果不是，那么我们可以降低姿态概率。请注意，我们并没有消除这些，因为机器人可能被放置在竞技场地图之外，或者在你桌子上进行测试。我们只是给它们一个比那些在竞技场内的权重更低的概率。
- en: 'In the `robot/arena.py` file, do the following:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在`robot/arena.py`文件中，执行以下操作：
- en: 'We can add a value to indicate a very low probability – close to but not zero:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以添加一个值来表示一个非常低的概率 – 接近但不是零：
- en: '[PRE80]'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Add a function to check whether the arena contains a point:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个函数来检查竞技场是否包含一个点：
- en: '[PRE81]'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'First, check whether the point’s outside the arena rectangle:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，检查点是否在竞技场矩形之外：
- en: '[PRE82]'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Then, we check whether it’s in the cutout section:'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们检查它是否在裁剪部分：
- en: '[PRE85]'
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Otherwise, this point is in the arena:'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，这个点在竞技场中：
- en: '[PRE87]'
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'We can then add an `observation_model` method to our `robot/code.py` `Simulation`
    class to generate the weights:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在我们的`robot/code.py` `Simulation`类中添加一个`observation_model`方法来生成权重：
- en: 'We set up the weights to `ones`, with a weight per pose:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将权重设置为`ones`，每个姿态一个权重：
- en: '[PRE88]'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'We can then loop over the poses, lowering the weights of those outside the
    arena:'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以遍历姿态，降低那些在竞技场之外的姿态的权重：
- en: '[PRE90]'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'We then return the weights:'
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们返回权重：
- en: '[PRE93]'
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: At this point, the weights aren’t being used. We will need to resample them
    for them to act on the poses.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 到这一点，权重没有被使用。我们需要重新采样它们，以便它们能够作用于姿态。
- en: Resampling the poses
  id: totrans-365
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新采样姿态
- en: 'As we step through the Monte Carlo simulation on the robot, we would like a
    subsequent generation of particles to favor more likely poses. We are going to
    use a technique illustrated in the following diagram:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在机器人上逐步进行蒙特卡洛模拟时，我们希望下一代的粒子更倾向于更可能的状态。我们将使用以下图中展示的技术：
- en: '![Figure 13.12 – Low variance resampling ](img/Figure_13.12_B18001.jpg)'
  id: totrans-367
  prefs: []
  type: TYPE_IMG
  zh: '![图13.12 – 低方差重采样](img/Figure_13.12_B18001.jpg)'
- en: Figure 13.12 – Low variance resampling
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.12 – 低方差重采样
- en: '*Figure 13**.12* starts with **Weighted Sample Space**, a number line between
    0 and the sum of all weights. Below this is a bar representing 10 samples (named
    *a* to *j*) in a sample space. The weights of these samples are represented by
    their widths. The shading highlights the different samples.'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13**.12* 从**加权样本空间**开始，这是一个介于0和所有权重之和之间的数轴。在这个数轴下方是一个表示样本空间中10个样本（命名为*a*到*j*）的条形图。这些样本的权重通过它们的宽度来表示。阴影部分突出了不同的样本。'
- en: In the diagram, we generate a new space with five samples *(n=5*). This number
    could be the same as the original space (for generating a new generation), may
    have a smaller number for sending via BLE, and may have a larger number for interpolating.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 在图中，我们生成一个包含五个样本的新空间（n=5）。这个数字可能与原始空间相同（用于生成新一代），可能更小，用于通过BLE发送，也可能更大，用于插值。
- en: Resampling the original set starts by dividing the total sum by the number of
    new samples, which will give a sample interval size of *sum/n*, shown as **Sample
    intervals**. We then generate a single uniform random number between 0 and *sum/n*,
    which will shift the intervals.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 重新采样原始集开始于将总权重除以新样本的数量，这将给出样本间隔大小为*sum/n*，显示为**样本间隔**。然后我们生成一个介于0和*sum/n*之间的单个均匀随机数，这将移动间隔。
- en: We can then look at the weighted sample space and pick out the sample that matches
    the start of each interval – this is the **weight index**. This will produce **New
    sample space**. Note that sample *c*, which has the highest weight, gets sampled
    more times. With larger sample populations, the resampled space will more accurately
    resemble the original.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以查看加权样本空间并挑选出与每个间隔开始匹配的样本 – 这就是**权重索引**。这将产生**新的样本空间**。请注意，具有最高权重的样本*c*被采样更多次。随着样本群体的增大，重采样的空间将更准确地接近原始空间。
- en: The new samples do not have weights and are all considered equally weighted,
    but some samples appear multiple times to represent their previous weight.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 新样本没有权重，并且都被视为同等权重，但某些样本出现多次以表示它们的先前权重。
- en: 'This technique of using random shifted intervals is known as the **low variance
    resampling** method. We will now see how to perform this through code:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 这种使用随机偏移间隔的技术被称为**低方差重采样**方法。我们现在将看到如何通过代码执行此操作：
- en: 'In `robot/code.py`, inside the `Simulation` class, add the following:'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `robot/code.py` 中，在 `Simulation` 类内部，添加以下内容：
- en: '[PRE94]'
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: The `weights` variable refers to the list of weights, and `sample_count` refers
    to the number of samples to get. This method will sample new poses from the poses
    array. We will set up a `samples` variable to hold the new samples.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '`weights` 变量指的是权重列表，`sample_count` 指的是要获取的样本数量。此方法将从姿态数组中采样新的姿态。我们将设置一个 `samples`
    变量来保存新的样本。'
- en: 'Next, we set up the interval size based on `sample_count`:'
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们根据 `sample_count` 设置间隔大小：
- en: '[PRE96]'
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: We can use that to set the interval `shift` value – the start position.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个来设置间隔 `shift` 值——起始位置。
- en: 'We are going to store the cumulative weights while we loop through the original
    samples (poses). We will also store an index in the source sample set:'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们遍历原始样本（姿态）时，我们将存储累积权重，我们还将存储源样本集中的索引：
- en: '[PRE98]'
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'The code will loop until we have the expected number of samples. For each sample,
    there is a `weight_index` parameter:'
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码将循环，直到我们获得预期的样本数量。对于每个样本，都有一个 `weight_index` 参数：
- en: '[PRE100]'
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'We now start adding up weights from the source samples in `cumulative_weights`,
    until they meet the weight index:'
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们从源样本中的 `cumulative_weights` 开始累加权重，直到它们达到权重索引：
- en: '[PRE102]'
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: We keep track of the source sample index that met this weight requirement.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 我们跟踪满足这个权重要求的源样本索引。
- en: 'We can use this `source_index` to add a sample to our set:'
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用这个 `source_index` 向我们的集合添加一个样本：
- en: '[PRE106]'
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: This will drop out of the `while` loop and be the end of the `for` loop.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 这将退出 `while` 循环，并成为 `for` 循环的结束。
- en: 'Finally, we return the new set of samples:'
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们返回新的样本集：
- en: '[PRE107]'
  id: totrans-399
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'We can also increase our population, while sending only a subset. In `Simulation.__init__`,
    change the population size:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以增加我们的种群数量，同时只发送一个子集。在 `Simulation.__init__` 中更改种群大小：
- en: '[PRE108]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: We are limiting the population size here due to Pico memory constraints.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里限制种群大小是因为Pico内存限制。
- en: 'We can then apply our observation model in the `main` loop (in `Simulation.main`):'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以在 `main` 循环（在 `Simulation.main` 中）中应用我们的观察模型：
- en: '[PRE109]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: In our loop, we use the observation model to get weights for the poses. We use
    the `resample` method to get 20 poses to send. We then use `resample` again to
    get a new population of poses. The cycle of updating our poses, observing their
    state, weighting the poses, and then resampling them is known as a **recursive**
    **Bayes filter**.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的循环中，我们使用观察模型来获取姿态的权重。我们使用 `resample` 方法来获取要发送的20个姿态。然后我们再次使用 `resample`
    来获取新的姿态种群。更新我们的姿态、观察它们的状态、对姿态进行加权，然后重新采样的循环被称为**递归贝叶斯滤波器**。
- en: If you send the `robot` folder to Raspberry Pi Pico and launch the app, you
    should start seeing the number of samples outside the arena being reduced. They
    will jump around, since we are sampling 20 from a larger set of 200.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将 `robot` 文件夹发送到 Raspberry Pi Pico 并启动应用程序，你应该开始看到竞技场外样本数量的减少。由于我们从200个更大的集合中采样了20个，它们将会跳跃。
- en: The system reduces the sample space to those that are more likely. However,
    we can include distance sensors to improve this process.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 系统将样本空间减少到那些更有可能的情况。然而，我们可以包括距离传感器来改进这个过程。
- en: Incorporating distance sensors
  id: totrans-408
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集成距离传感器
- en: Our robot has two distance sensors. Our code will check distances the robot
    senses against model data. If each pose is an imaginary map pin, then the distance
    to the nearest obstacle would be a string stretched out from this pin, or a sensor
    beam with a sensed endpoint – the **beam endpoint model**. With 200 poses, this
    could be slow. Let’s see a faster method to model them.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的机器人有两个距离传感器。我们的代码将检查机器人感知的距离与模型数据。如果每个姿态是一个想象中的地图针，那么到最近障碍物的距离将是从这个针拉伸出的字符串，或者是一个带有感知端点的传感器光束——**光束端点模型**。有200个姿态，这可能会很慢。让我们看看一个更快的方法来模拟它们。
- en: Modeling distance sensors in our space
  id: totrans-410
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在我们的空间中模拟距离传感器
- en: One way we could do this is to take an estimate of the robot’s position, and
    then perform the math needed to get the distance to the nearest obstacle. However,
    we can make a lookup table to simplify this.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以采取的一种方法是对机器人的位置进行估计，然后执行获取到最近障碍物距离所需的数学运算。然而，我们可以创建一个查找表来简化这个过程。
- en: 'Let’s look at the following diagram:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下图表：
- en: '![Figure 13.13 – Distance representation ](img/Figure_13.13_B18001.jpg)'
  id: totrans-413
  prefs: []
  type: TYPE_IMG
  zh: '![图13.13 – 距离表示](img/Figure_13.13_B18001.jpg)'
- en: Figure 13.13 – Distance representation
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.13 – 距离表示
- en: '*Figure 13**.13 (a)* shows a **likelihood field** based on distance. The white
    dot is the endpoint at the distance reading from the distance sensor. The bright
    middle line of this grid represents an arena wall. Each grid square has a value
    between 0 and 1 (shown as brightness), representing how likely a sensed distance
    projected here is to have detected the wall. Instead of asking the question, *Is
    this distance measurement a match?*, we can ask, *How likely is this distance
    sensor a match?* We can calculate this grid once only when the system starts up,
    so other code can make fast lookups into the grid to check for sensor readings.'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13**.13 (a)* 展示了一个基于距离的**似然场**。白色圆点是从距离传感器读取的距离读数的终点。这个网格的明亮中间线代表一个竞技场墙壁。每个网格方格都有一个介于0和1之间的值（以亮度表示），表示在此处检测到的距离被检测到墙壁的可能性有多大。我们不是问“这个距离测量是否匹配？”，而是可以问“这个距离传感器匹配的可能性有多大？”我们可以在系统启动时只计算这个网格一次，这样其他代码就可以快速查找网格以检查传感器读数。'
- en: '*Figure 13**.13 (b)* shows how the likelihood changes, with a distance from
    0 to 1,500 in a decaying function. The *Y* axis shows the likelihood of it being
    a hit. The dashed vertical line is a value, currently 250, at the inflection point,
    at which the curve changes direction. A smaller inflection point makes a tighter
    curve; a larger value makes a wider curve.'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13**.13 (b)* 展示了似然如何随距离变化，距离从0到1,500，以衰减函数的形式。*Y*轴显示了它是击中的可能性。虚线垂直线是一个值，目前为250，在曲线改变方向的拐点。较小的拐点会使曲线更紧；较大的值会使曲线更宽。'
- en: 'Let’s import `numpy` at the top of `robot/arena.py`:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`robot/arena.py`的顶部导入`numpy`：
- en: '[PRE110]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'We will convert these values to a grid of 50 mm2 cells. As some poses will
    have distance endpoints outside the boundary, we’ll give the grid an overscan.
    Extend the `robot/arena.py` library with the following:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这些值转换为50 mm²单元格的网格。由于某些姿态的距离端点可能超出边界，我们将给网格一个超扫描。扩展`robot/arena.py`库，如下所示：
- en: '[PRE111]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'We’ll start with how we get the distance to a grid square. In `robot/arena.py`,
    after defining `boundary_lines`, add the following:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先来看如何获取网格方格的距离。在`robot/arena.py`中，在定义`boundary_lines`之后，添加以下内容：
- en: '[PRE112]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: The code unpacks the line segment into `x1` and `y1`, and `x2` and `y2`. It
    then checks whether the line is horizontal (the same *Y*), and whether the point
    being checked is above or below it; this allows a shortcut by subtracting the
    *Y* values. The code can repeat this for vertical lines.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 代码将线段解包为`x1`和`y1`，以及`x2`和`y2`。然后检查该线是否水平（相同的*Y*），以及被检查的点是在其上方还是下方；这可以通过减去*Y*值来实现捷径。代码可以重复这个过程来检查垂直线。
- en: The code then uses Pythagoras’ theorem, where the resulting distance will be
    the hypotenuse.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 代码随后使用毕达哥拉斯定理，其中结果距离将是斜边。
- en: 'We will convert distances into likelihoods with a decaying function, which
    will return a lower value as we get further from zero. The following function
    will, for a specific point, find the nearest segment distance and then apply a
    decaying function to it:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用衰减函数将距离转换为似然，随着我们远离零，它将返回更低的值。以下函数将找到一个特定点的最近段距离，然后对其应用衰减函数：
- en: '[PRE113]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'We can make a function to generate this grid. It starts by making a 2D array
    of float fields filled with zeros to hold the grid values:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个函数来生成这个网格。它首先创建一个填充零的2D浮点数组来存储网格值：
- en: '[PRE114]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: The width of the grid in cells is the width of the arena divided by the cell
    sizes. We then add in the overscan for either side of the arena. The height uses
    a similar calculation.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 网格的宽度（以单元格计）是竞技场宽度除以单元格大小。然后我们在竞技场的两侧添加超扫描。高度使用类似的计算。
- en: 'We then loop over the grid rows and columns to fill in the cell data:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后遍历网格的行和列来填充单元格数据：
- en: '[PRE115]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'This loop gets the arena *X* and *Y* coordinates for each cell and uses the
    coordinates to fetch the likelihood at that position, storing it in the grid.
    We call this function and store the result in the `distance_grid` variable so
    that this calculation will run when the `arena.py` file is imported. The calculated
    distance grid looks like the following diagram:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 这个循环获取每个单元格的竞技场*X*和*Y*坐标，并使用这些坐标来获取该位置的似然，将其存储在网格中。我们调用这个函数并将结果存储在`distance_grid`变量中，这样当导入`arena.py`文件时，这个计算就会运行。计算出的距离网格看起来像以下图表：
- en: '![Figure 13.14 – The distance-based likelihood field ](img/Figure_13.14_B18001.jpg)'
  id: totrans-433
  prefs: []
  type: TYPE_IMG
  zh: '![图13.14 – 基于距离的似然场](img/Figure_13.14_B18001.jpg)'
- en: Figure 13.14 – The distance-based likelihood field
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.14 – 基于距离的似然场
- en: '*Figure 13**.14* shows the distance-based likelihood field.'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13**.14* 展示了基于距离的似然场。'
- en: The overscan extends to -500 mm and 2,000 mm, and the boundary lines are drawn
    in black. Each cell’s value is based on its bottom-left coordinate.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 扫描溢出范围从 -500 毫米到 2,000 毫米，边界线用黑色绘制。每个单元格的值基于其左下角坐标。
- en: We can now use this likelihood field in the observation model.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以在观测模型中使用这个似然场。
- en: Generating weights from the distance sensors
  id: totrans-438
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从距离传感器生成权重
- en: 'For each pose, we will need to project the sensed distances from the sensor
    positions. See the following diagram:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个位姿，我们需要从传感器位置投射感测到的距离。请参见以下图表：
- en: '![Figure 13.15 – Distance sensor geometry ](img/Figure_13.15_B18001.jpg)'
  id: totrans-440
  prefs: []
  type: TYPE_IMG
  zh: '![图13.15 – 距离传感器几何](img/Figure_13.15_B18001.jpg)'
- en: Figure 13.15 – Distance sensor geometry
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.15 – 距离传感器几何
- en: '*Figure 13**.15 (1)* shows poses *A*, *B*, and *C* as dots, with an arrow showing
    their heading. There are dark bars representing the location of the two distance
    sensors relative to the pose – they stick out to the side and forward. From this
    location, we will have sensor readings, represented by the arrows pointing from
    the front of the bars.'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13**.15 (1)* 将位姿 *A*、*B* 和 *C* 以点表示，并用箭头表示它们的航向。有暗条表示两个距离传感器相对于位姿的位置 – 它们向侧面和前方突出。从这个位置，我们将有传感器读数，由指向条前端的箭头表示。'
- en: By projecting the sensor distances against the likelihood field, we can see
    that pose B is a more likely match than pose C, with A as the least likely pose
    here.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将传感器距离与似然场投影，我们可以看到位姿 B 比位姿 C 更有可能匹配，而 A 是这里最不可能的位姿。
- en: '*Figure 13**.15 (2)* shows how we can project the sensors. *Ds* is how far
    the distance sensor goes out to the side (`dist_side_mm` in the code). *Df* is
    how far forward the sensors are from the robot wheels (`dist_forward_mm`). *Dr*
    is the distance sensed, from *Df*. We will have to add this to every pose. Pre-calculating
    a triangle from the sensed distance makes this a little easier. *θ* is the robot’s
    heading. Using the *SOHCAHTOA* mnemonic, we can get *θr*, the angle from the robots
    heading to the right sensor, and using Pythagoras’ theorem, we can get *Hr*, the
    hypotenuse. The adjacent side will be *Df* and *Dr*, and the opposite *Ds*. We
    can then add *Hr* at the *θr* angle to each pose to get the right sensor beam
    endpoint for every pose. The same can be applied to the left sensor reading. While
    complicated, this is faster than calculating the endpoint projecting out to the
    side and forward for each pose.'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13**.15 (2)* 展示了如何投影传感器。*Ds* 表示距离传感器向外延伸的距离（代码中的 `dist_side_mm`）。*Df* 表示传感器从机器人轮子向前延伸的距离。*Dr*
    是从 *Df* 感测到的距离。我们必须将此距离添加到每个位姿中。从感测到的距离预先计算三角形使这个过程变得稍微容易一些。*θ* 是机器人的航向。使用 *SOHCAHTOA*
    口诀，我们可以得到 *θr*，即从机器人航向到右侧传感器的角度，并使用勾股定理，我们可以得到 *Hr*，即斜边。相邻边将是 *Df* 和 *Dr*，对边是
    *Ds*。然后我们可以将 *Hr* 在 *θr* 角度添加到每个位姿中，以获得每个位姿的正确传感器光束端点。同样的方法也可以应用于左侧传感器读取。虽然这个过程比较复杂，但比为每个位姿计算向侧面和前方投射的端点要快。'
- en: Measure the position of the distance sensors on your robot relative to the middle
    of the wheels (or use the CAD drawings). The active part of each sensor to measure
    to is the shiny part at the top middle of each sensor.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 测量你机器人上距离传感器的位置相对于轮子的中间（或使用 CAD 绘图）。每个传感器要测量的活动部分是每个传感器顶部中间的亮面部分。
- en: 'We’ll add these distance sensor positions to our `robot/robot.py` measurement
    after the `wheelbase_mm` definition:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 `robot/robot.py` 文件中的 `wheelbase_mm` 定义之后添加这些距离传感器位置到我们的测量：
- en: '[PRE116]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'We need to add a function to `robot/arena.py` to look up a position in the
    distance grid:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要向 `robot/arena.py` 添加一个函数来查找距离网格中的位置：
- en: 'The function converts an `(x,y)` pose argument to grid coordinates:'
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该函数将 `(x,y)` 位姿参数转换为网格坐标：
- en: '[PRE117]'
  id: totrans-450
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-451
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-452
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-453
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Out-of-bounds requests should return an incredibly low probability:'
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 超出范围的请求应返回一个极低的概率：
- en: '[PRE121]'
  id: totrans-455
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-456
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'We can then return the result stored at the grid location:'
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以返回存储在网格位置的查询结果：
- en: '[PRE123]'
  id: totrans-458
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'In the `robot/code.py` file, we can add a method to the `Simulation` class
    to perform the preceding triangle calculations, to get the sensor endpoints for
    each pose:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `robot/code.py` 文件中，我们可以向 `Simulation` 类添加一个方法来执行前面的三角形计算，以获取每个位姿的传感器端点：
- en: 'This method will take the sensor reading, and inform us whether it’s on the
    right side:'
  id: totrans-460
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此方法将读取传感器数据，并通知我们它是否位于右侧：
- en: '[PRE124]'
  id: totrans-461
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'We then calculate the adjacent and angle of our triangle:'
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们计算三角形的相邻边和角度：
- en: '[PRE125]'
  id: totrans-463
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-464
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-465
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-466
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE128]'
- en: Note here that we calculate the negative of the angle if it is on the right
    side.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果角度在右侧，我们计算角度的负值。
- en: 'We then get the hypotenuse – this will be the distance from between the wheels
    to the sensor beam endpoints:'
  id: totrans-468
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们得到斜边——这将是车轮到传感器光束端点之间的距离：
- en: '[PRE129]'
  id: totrans-469
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'Now, we use `numpy` to help us calculate the angle relative to each pose, converting
    the pose angle to radians as we go:'
  id: totrans-470
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们使用 `numpy` 来帮助我们计算相对于每个姿态的角度，在转换姿态角度为弧度时：
- en: '[PRE130]'
  id: totrans-471
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'We can then build a list of endpoints by projecting from the coordinate of
    each pose, with the hypotenuse at the calculated angle:'
  id: totrans-472
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以构建一个端点列表，通过从每个姿态的坐标投影，使用计算出的角度作为斜边：
- en: '[PRE131]'
  id: totrans-473
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-474
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-475
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-476
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE134]'
- en: We finally return these calculated lists.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终返回这些计算出的列表。
- en: 'We now create an `observe_the_distance_sensors` method inside the `Simulation`
    class and apply those to the existing set of weights:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在在 `Simulation` 类中创建一个 `observe_the_distance_sensors` 方法，并将其应用于现有的权重集：
- en: 'Start by accepting an existing list of weights as an argument:'
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，接受一个现有的权重列表作为参数：
- en: '[PRE135]'
  id: totrans-480
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'We then call `get_sensor_endpoints` for each side:'
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们为每一侧调用 `get_sensor_endpoints`：
- en: '[PRE136]'
  id: totrans-482
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-483
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'We now have a list of distance sensor projections for every pose. We can look
    up the distance likelihood grid at each of those points and add them:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个距离传感器投影的列表，针对每个姿态。我们可以在这些点中查找距离似然网格并将它们添加：
- en: '[PRE138]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'We can then multiply this by the existing weight (inside or outside the arena):'
  id: totrans-486
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以将此乘以现有的权重（场内或场外）：
- en: '[PRE139]'
  id: totrans-487
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'Now, we leave this loop and return the modified weights:'
  id: totrans-488
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们离开这个循环并返回修改后的权重：
- en: '[PRE140]'
  id: totrans-489
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'We then need to incorporate this code into `observation_model`. Make the highlighted
    change:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要将此代码集成到 `observation_model` 中。进行以下突出显示的更改：
- en: '[PRE141]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'If you send this code to the robot, it will weigh and resample from two distance
    sensors. The robot poses will start to form in blobs, located around likely positions
    for the sensors. The blobs will form, scatter, and reform as the robot filters
    and moves them. The following diagram shows what you will see on the display:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将此代码发送到机器人，它将从两个距离传感器进行称重和重采样。机器人的姿态将开始形成在传感器可能位置周围的块状物。随着机器人过滤和移动它们，这些块状物将形成、散开并重新组合。以下图表显示了你在显示屏上将会看到的内容：
- en: '![Figure 13.16 – The localization blob ](img/Figure_13.16_B18001.jpg)'
  id: totrans-493
  prefs: []
  type: TYPE_IMG
  zh: '![图13.16 – 定位块状物](img/Figure_13.16_B18001.jpg)'
- en: Figure 13.16 – The localization blob
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.16 – 定位块状物
- en: In *Figure 13**.16*, the poses have grouped together in a blob, roughly representing
    the robot’s position, which will move with the robot as it drives around the arena.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图13**.16 中，姿态已经聚集在一起形成一个块状物，大致代表机器人的位置，这个位置将在机器人绕场行驶时移动。
- en: You may see one blob, or a few, and they may drive exactly with the robot or
    seem a little off. This is where you will need to tune the model to better suit
    the situation.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会看到一个或几个块状物，它们可能与机器人精确地一起移动，或者看起来有点不对。这就是你需要调整模型以更好地适应情况的地方。
- en: Tuning and improving the Monte Carlo model
  id: totrans-497
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调整和改进蒙特卡洛模型
- en: 'Tuning the following factors can improve this model:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 调整以下因素可以提高此模型：
- en: The `ch-13/4.3-monte-carlo_perf` folder in the GitHub repository contains an
    instrumented version of the code in this chapter for troubleshooting. You will
    need to tune `robot.py` and `arena.py` for your own setup, but this code reports
    issues and tracebacks back to the computer for diagnosis, weight output from the
    observation model rendered on the display, and, if you are connected via USB,
    also sends performance data.
  id: totrans-499
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitHub 仓库中的 `ch-13/4.3-monte-carlo_perf` 文件夹包含本章代码的仪器化版本，用于故障排除。你需要调整 `robot.py`
    和 `arena.py` 以适应你的设置，但此代码会报告问题并将跟踪回计算机进行诊断，显示在显示屏上的观察模型渲染的重量输出，如果你通过 USB 连接，还会发送性能数据。
- en: Measurements in `robot/robot.py` – the accuracy of measurements such as wheel
    diameters, wheelbase, gear ratio, and encoders will guide the odometry model.
    If the movement of the blob doesn’t match the speed and turning, these are the
    likely suspects. The model assumes wheels to be identical in size, which may be
    false if it’s consistently pulling to one side.
  id: totrans-500
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `robot/robot.py` 中的测量值——轮径、轴距、齿轮比和编码器的测量精度将指导里程计模型。如果块状物的移动与速度和转向不匹配，这些很可能是嫌疑人。模型假设车轮大小相同，如果它始终向一侧拉，这可能是错误的。
- en: Similarly, if the distance sensor position measurements in `robot/robot.py`
    are incorrect or the sensors need calibration, the position will be consistently
    off. The sensors can be disrupted by strong sunlight and flickering room lighting.
  id: totrans-501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同样，如果 `robot/robot.py` 中的距离传感器位置测量值不正确或传感器需要校准，位置将始终偏移。传感器可能会被强烈的阳光和闪烁的室内照明干扰。
- en: In the arena, the `get_distance_likelihood` factor, 100, adjusts the decay for
    the likelihood field around each boundary. Lowering this will tighten the fields.
  id: totrans-502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在竞技场中，`get_distance_likelihood`因素，100，调整了围绕每个边界的可能性场的衰减。降低这个值将使场变得更紧密。
- en: In `code.py`, the number of poses is a major factor. Increasing this will make
    for a better model, but beware of memory constraints on Raspberry Pi Pico.
  id: totrans-503
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`code.py`中，姿态的数量是一个主要因素。增加这个值将使模型更好，但请注意Raspberry Pi Pico的内存限制。
- en: The `code.py` alpha factors encode your certainty in the motion model; make
    these lower if you trust the motion model more.
  id: totrans-504
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`code.py`中的alpha因素编码了您对运动模型的确定性；如果您更信任运动模型，请将这些值调低。'
- en: The model also assumes the arena construction to be fairly accurate. Errors
    in these assumptions can stack up to make it harder for the localization algorithm.
  id: totrans-505
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该模型还假设竞技场构建相当准确。这些假设中的错误可能会累积，使定位算法更难。
- en: You will need to spend time with these factors to make a model that is more
    likely to find its location, or is quicker in doing so.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要花时间与这些因素打交道，以创建一个更有可能找到其位置的模型，或者更快地做到这一点。
- en: Let’s summarize what we have learned in this chapter.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结一下本章我们学到了什么。
- en: Summary
  id: totrans-508
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we started by building a test arena for our robot using foam
    board construction, then modeled this in code, and displayed it along with a distance
    sensor likelihood field. We put this on the robot, sent it over BLE, and then
    added poses.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先使用泡沫板结构为我们的机器人构建了一个测试竞技场，然后在代码中对其进行建模，并显示它以及距离传感器可能性场。我们将它放在机器人上，通过BLE发送，然后添加了姿态。
- en: We modeled how poses move using sensors, adding uncertainty to the model. We
    then added a model of distance sensor observations, generating weights that we
    used in a resampling algorithm to generate new poses.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用传感器建模了姿态的移动，向模型添加了不确定性。然后我们添加了距离传感器观察模型，生成了我们在重采样算法中使用的权重，以生成新的姿态。
- en: We finished with a look at tuning factors to improve the performance of this
    system.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过查看调整因素来提高该系统的性能结束了本次讨论。
- en: In the next chapter, we will summarize your Raspberry Pi Pico robotics learning
    journey so far and discuss how you can continue your journey by improving this
    robot or building more robots.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将总结您迄今为止的Raspberry Pi Pico机器人学习之旅，并讨论您如何通过改进这个机器人或构建更多机器人来继续您的旅程。
- en: Exercises
  id: totrans-513
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'The following exercises will deepen your understanding of the topics discussed
    in this chapter and make the robot code better:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 以下练习将加深您对本章讨论主题的理解，并使机器人代码更完善：
- en: The IMU could be added by storing a previous state and calculating the delta.
    You could mix this into the `rot1`/`rot2` values by taking the average of encoder
    calculations versus the IMU angles, or consider whether one sensor is more trusted
    than the others. You will need to calibrate the IMU before it can be used.
  id: totrans-515
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过存储先前状态并计算增量来添加IMU。您可以通过取编码器计算与IMU角度的平均值来将这些值混合到`rot1`/`rot2`中，或者考虑是否有一个传感器比其他传感器更可靠。在使用之前，您需要校准IMU。
- en: The robot’s pose guesses get stuck in **local maxima** – good but wrong guesses
    that are likely based on sensor positions. Consider throwing in 10 fresh guesses
    at every population to nudge the code to try other options.
  id: totrans-516
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机器人的姿态猜测会陷入**局部最大值**——基于传感器位置的良好但错误的猜测。考虑在每次种群中添加10个新的猜测，以推动代码尝试其他选项。
- en: We are using only two observations per pose – having more distance sensors could
    improve this but will make the model slower.
  id: totrans-517
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用每个姿态的两个观察值——拥有更多的距离传感器可能会改善这一点，但会使模型变慢。
- en: Could you add a target zone to the arena? Consider how PIDs could be used to
    steer the robot toward this. Perhaps feed the PID with the mean pose.
  id: totrans-518
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您能否在竞技场中添加一个目标区域？考虑如何使用PID来引导机器人向这个区域移动。也许可以用平均姿态来提供PID。
- en: You can improve the visualization by sending more pose data, including orientation.
    You may need to consider the `msgpack` library or switching to Wi-Fi or BLE over
    SPI, as the amount of data can easily overwhelm the BLE UART connection.
  id: totrans-519
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以通过发送更多的姿态数据，包括方向，来改进可视化。您可能需要考虑使用`msgpack`库或切换到通过SPI的Wi-Fi或BLE，因为数据量很容易超过BLE
    UART连接。
- en: Further reading
  id: totrans-520
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'These aids for further study will let you read on and dive deeper into the
    Monte Carlo algorithm and its quirks:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 这些进一步学习的辅助工具将让您继续阅读并深入了解蒙特卡洛算法及其特性：
- en: '*Probabilistic Robotics* by Sebastian Thrun, Wolfram Burgard, and Dieter Fox,
    published by MIT Press, covers the Monte Carlo particle filter, along with the
    Kalman filter and other probability-based models in far more depth.'
  id: totrans-522
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由Sebastian Thrun、Wolfram Burgard和Dieter Fox合著，并由麻省理工学院出版社出版的《*概率机器人学*》详细介绍了蒙特卡洛粒子滤波器，以及卡尔曼滤波和其他基于概率的模型。
- en: I strongly recommend the *Khan Academy* material on modeling data distributions
    for learning and practicing data distributions.
  id: totrans-523
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我强烈推荐Khan Academy上关于建模数据分布以学习和练习数据分布的材料。
- en: A playlist of 21 videos from Bonn University and Cyrill Stachniss at [https://www.youtube.com/playlist?list=PLgnQpQtFTOGQEn33QDVGJpiZLi-SlL7vA](https://www.youtube.com/playlist?list=PLgnQpQtFTOGQEn33QDVGJpiZLi-SlL7vA)
    covers the topics used here in detail. I recommend them if you want to dive far
    deeper into this topic.
  id: totrans-524
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自波恩大学和Cyrill Stachniss的21个视频播放列表，可在[https://www.youtube.com/playlist?list=PLgnQpQtFTOGQEn33QDVGJpiZLi-SlL7vA](https://www.youtube.com/playlist?list=PLgnQpQtFTOGQEn33QDVGJpiZLi-SlL7vA)上找到，详细介绍了这里使用的主题。如果你想要更深入地研究这个主题，我强烈推荐它们。
