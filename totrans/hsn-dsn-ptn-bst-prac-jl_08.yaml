- en: Reusability Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn about several patterns related to software reusability.
    As you may recall from [Chapter 1](b33529b9-aabc-46cf-88eb-5d2ac885b732.xhtml), *Design
    Patterns and Related Principles*, reusability is one of the four software quality
    objectives that is required for building large-scale applications. Nobody wants
    to reinvent the wheel. The ability to reuse an existing software component saves
    both time and energy—an overall humanity gain! The patterns in this chapter are
    proven techniques that can help us improve application design, reuse existing
    code, and reduce overall code size.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The delegation pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The holy traits pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The parametric type pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The sample source code for this chapter is located at [https://github.com/PacktPublishing/Hands-on-Design-Patterns-and-Best-Practices-with-Julia/tree/master/Chapter05](https://github.com/PacktPublishing/Hands-on-Design-Patterns-and-Best-Practices-with-Julia/tree/master/Chapter05).
  prefs: []
  type: TYPE_NORMAL
- en: The code in this chapter has been tested in a Julia 1.3.0 environment.
  prefs: []
  type: TYPE_NORMAL
- en: The delegation pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Delegation is a pattern that is commonly applied in software engineering. The
    primary objective is to leverage the capabilities of an existing component by
    wrapping it via a *has-a* relationship.
  prefs: []
  type: TYPE_NORMAL
- en: The delegation pattern is widely adopted, even in the object-oriented programming
    community. In the early days of object-oriented programming, people thought that
    code reuse could be achieved beautifully using inheritance. However, people came
    to realize that this promise couldn't be completely fulfilled due to a variety
    of issues related to inheritance. Since then, many software engineers prefer composition
    over inheritance. The concept of composition is to wrap one object within another.
    In order to reuse existing functions, we must delegate functions calls to the
    wrapped object. This section will explain how delegation can be implemented in
    Julia.
  prefs: []
  type: TYPE_NORMAL
- en: The concept of composition is to wrap one object within another. In order to
    reuse existing functions, we must delegate functions calls to the wrapped object.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way is to enhance an existing component with new features. This may sound
    good, but it could be challenging in practice. Consider the following situations:'
  prefs: []
  type: TYPE_NORMAL
- en: The existing component comes from a vendor product and the source code is not
    available. Even if the code is available, the vendor's license may not allow us
    to make custom changes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The existing component is developed and used by another team for a mission-critical
    system and changes are neither welcome nor applicable for that system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The existing component contains a lot of legacy code and new changes may compromise
    the component's stability and require a lot of testing effort.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If modifying an existing component's source code is not an option, then we should
    at least be able to use the component via its published programming interface.
    That is the virtue of the delegation pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Applying the delegation pattern to a banking use case
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The delegation pattern is the idea of creating a new object by wrapping an existing
    one called the *parent* object. In order to reuse the object's features, the functions
    that have been defined for the new object can be delegated (also known as forwarded)
    to the parent.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose that we have access to a banking library that provides some basic account
    management functionality. To understand how it works, let's take a look at the
    source code.
  prefs: []
  type: TYPE_NORMAL
- en: 'A bank account has been designed with the following mutable data structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'As part of the programming interface, the library also provides the field accessors
    (see [Chapter 8](6b565339-641f-444c-ad42-f8ff7998001b.xhtml), *Robustness Patterns*)
    and functions for making deposits, withdrawals, and transfers, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Of course, in practice, such a banking library has to be a lot more complex
    than what is seen here. I suspect that when money goes in and out of a bank account,
    there are many downstream effects such as logging an audit trail, making the new
    balance available on a website, sending emails to the customer, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Let's move on and learn how we can utilize the delegation pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Composing a new type that contains an existing type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As part of a new initiative, the bank wants us to support a new savings account
    product, which provides daily interest for customers. Since the existing account
    management's functionality is critical to the bank's business and is maintained
    by a different team, we have decided to reuse its functionality without touching
    any of the existing source code.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s create our own `SavingsAccount` data type, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The first field, `acct`, is used to hold an `Account` object, while the second
    field, `interest_rate`, contains the interest rate per annum for the account.
    A constructor is also defined to instantiate the object.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to use the underlying `Account` object, we can use a technique called
    *Delegation*, or *Method Forwarding*. This is where we implement the same API
    in `SavingsAccount` and forward the call to the underlying `Account` object whenever
    we want to reuse the existing functions from the underlying object. In this case,
    we can just forward all the field accessor functions and mutating functions from
    the `Account` object, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, we have successfully reused the `Account` data type, but let''s not
    forget that we actually want to build new features in the first place. A savings
    account should accrue interest overnight on a daily basis. So, for the `SavingsAccount`
    object, we can implement a new accessor for the `interest_rate` field and a new
    mutating function called `accrue_daily_interest!`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: At this time, we have created a new `SavingsAccount` object that works just
    like the original `Account` object, except it has the additional capability of
    accruing interest!
  prefs: []
  type: TYPE_NORMAL
- en: However, the sheer volume of these forwarding methods makes us feel a little
    unsatisfied. It would be nice if we didn't have to write all this code manually.
    Perhaps there's a better way...
  prefs: []
  type: TYPE_NORMAL
- en: Reducing boilerplate code for forwarding methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may wonder how it would ever be worth the effort to write so much code just
    to forward the method calls to the parent object. Indeed, the forwarding methods
    serve no purpose other than passing the exact same arguments to the parent. If
    programmers were paid by lines of code, then this would be quite an expensive
    proposition, wouldn't it?
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, this kind of boilerplate code can be reduced greatly using macros.
    There are several open source solutions that can help with this situation. For
    demonstration purposes, we can utilize the `@forward` macro from the `Lazy.jl`
    package. Let''s replace all the forwarding methods, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The usage of `@forward` is fairly straightforward. It takes two expressions
    as arguments. The first argument is the `SavingsAccount.acct` object that you
    want to forward to, while the second argument is just a tuple of function names
    that you wish to forward to, for example, `account_number`, `balance`, and `date_opened`.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we are able to forward mutating functions such as `deposit!` and `withdraw!`,
    but we cannot do the same for `transfer!`. This is because `transfer!` requires
    that we forward its first and second arguments. In this case, we just keep the
    manual forwarding method. Nevertheless, we were able to forward five out of the
    six functions using just two lines of code. It's still a pretty good deal!
  prefs: []
  type: TYPE_NORMAL
- en: It would be possible to make more forwarding macros that take two or three arguments.
    In fact, there are other open source packages that support such scenarios, such
    as the `TypedDelegation.jl` package.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, how does the `@forward` macro work? We can examine how the code gets expanded
    using the `@macroexpand` macro. The following is the result of the line number
    nodes being removed. Basically, for each method that is being forwarded (`balance`
    and `deposit!`), it creates the corresponding function definition with all the
    arguments splatted with the `args...` notation. It also throws in an `@inline` node
    to give the compiler a hint for better performance:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/88ad9266-859f-4b4d-933f-c516b8314b11.png)'
  prefs: []
  type: TYPE_IMG
- en: Inlining is a compiler optimization where a function call is *inlined* as if
    the code had been interpolated into the current code. It may improve performance
    by reducing the overhead of allocating a call stack when functions are called
    repeatedly.
  prefs: []
  type: TYPE_NORMAL
- en: The `@forward` macro was implemented with only a few lines of code. You are
    encouraged to take a look at the source code if you are interested in metaprogramming.
  prefs: []
  type: TYPE_NORMAL
- en: You might be wondering why there are several funny variable names such as `#41#x`
    or `#42#args`. We can treat those as if they are normal variables. They are automatically
    generated by the compiler, and their special naming convention is chosen to avoid
    conflicts with other variables in the current scope.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, it is important to understand that we may not always want to forward
    all the function calls to the object. What if we don't want to use 100% of the
    underlying features? Believe it or not, there are cases like that. For example,
    let's imagine that we have to support another kind of account, such as a certificate
    of deposits, also known as CDs. A CD is a short-term investment product that pays
    a higher interest than a savings account, but the funds cannot be withdrawn during
    the term of investment. Generally, the term of a CD could be 3 months, 6 months,
    or longer. Going back to our code, if we create a new `CertificateOfDepositAccount` object
    and reuse the `Account` object again, we wouldn't want to forward the `withdraw!` and
    `transfer!` methods because they are not features of CDs.
  prefs: []
  type: TYPE_NORMAL
- en: You might wonder how delegation differs from class inheritance in object-oriented
    programming languages. For example, in the Java language, all the public and protected
    methods from the parent class are inherited automatically. This is analogous to
    auto-forwarding all the methods from the parent class.
  prefs: []
  type: TYPE_NORMAL
- en: The inability to choose what to inherit is actually one of the reasons why delegation
    is preferred over inheritance. For a more in-depth discussion, see [Chapter 12](97049a94-ad30-452a-bbb0-296d9438c886.xhtml), *Inheritance
    and Variance*.
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing some real-life examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The delegation pattern is used extensively in open source packages. For example,
    many packages in the JuliaArrays GitHub organization implement the `AbstractArray`
    interface. The special array types usually contain a regular `AbstractArray` object.
  prefs: []
  type: TYPE_NORMAL
- en: Example 1 – the OffsetArrays.jl package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `OffsetArrays.jl` package allows us to define arrays with arbitrary indices
    rather than the standard linear or cartesian style indices. A fun example is to
    use a zero-based array, just like the ones you may find in other programming languages:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5a5a0185-28a8-431b-9b7c-ebc902f501f5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To understand how this works, we need to dig into the source code. Let''s keep
    things concise and review just a portion of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `OffsetArray` data type is composed of the `parent` and `offsets` fields.
    In order to satisfy the `AbstractArray` interface, it implements some of the basic
    functions, such as `Base.size`, `Base.eachindex`, and so on. Since these functions
    are simple enough, the code just forwards the call to the parent object manually.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2 – the ScikitLearn.jl package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's also take a look at the `ScikitLearn.jl` package, which defines a consistent
    API for fitting machine learning models and doing prediction.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is how the `FitBit` type is defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we can see that the `FitBit` object contains a `model` object and that
    it adds a new functionality that keeps track of whether a model has been fitted
    or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: It uses the `@forward` macro to delegate all the major functions, that is, `transform`,
    `predict`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Considerations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You should keep in mind that the delegation pattern introduces a new level of
    indirection, which can increase code complexity and make the code more difficult
    to understand. We should consider some factors when deciding to use the delegation
    pattern.
  prefs: []
  type: TYPE_NORMAL
- en: First, how much code can you reuse from the existing component? Is it 20%, 50%,
    or 80%? This ought to be the very first question you ask before you consider reusing
    an existing component. Let's call the amount of reuse the utilization rate. Obviously,
    the higher the utilization rate, the better it is from a reuse perspective.
  prefs: []
  type: TYPE_NORMAL
- en: Second, how much development effort can be saved by reusing an existing component? If
    the cost of developing the same functionality is low, then it may not be worth
    the effort to reuse the component and increase the complexity of extra indirection.
  prefs: []
  type: TYPE_NORMAL
- en: From the opposite angle, we should also review if there is any critical business
    logic in the existing component. If we decide to not reuse the component, then
    we could end up implementing the same logic again, violating the **Don't Repeat
    Yourself** (**DRY**) principle. This means it can be a maintenance nightmare to
    not reuse the component.
  prefs: []
  type: TYPE_NORMAL
- en: Given these considerations, we should just to make a good judgment about using
    the delegation pattern or not.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will learn how to implement traits in Julia.
  prefs: []
  type: TYPE_NORMAL
- en: The holy traits pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The holy traits pattern has an interesting name. Some people also call it the **Tim
    Holy Traits Trick** (**THTT**). As you might have guessed the pattern is named
    after Tim Holy, who is a long-time contributor to the Julia language and ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: What are traits? In a nutshell, a trait corresponds to the behavior of an object.
    For example, birds and butterflies can fly, so they both have the *CanFly* trait.
    Dolphins and turtles can swim, so they both have the *CanSwim* trait. A duck can
    fly and swim, so it has both the *CanFly* and *CanSwim* traits. Traits are typically
    binary – you either exhibit the trait or not – although that is not a mandatory
    requirement.
  prefs: []
  type: TYPE_NORMAL
- en: Why do we want traits? Traits can be used as a formal contract about how a data
    type can be used. For example, if an object has the *CanFly* trait, then we would
    be quite confident that the object has some kind of *fly* method defined. Likewise,
    if an object has the *CanSwim* trait, then we can probably call some kind of *swim*
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get back to programming. The Julia language doesn't have any built-in
    support for traits. However, the language is versatile enough for developers to
    use traits with the help of the multiple dispatch system. In this section, we
    will look into how this can be done with the special technique known as holy traits.
  prefs: []
  type: TYPE_NORMAL
- en: Revisiting the personal asset management use case
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When designing reusable software, we often create abstractions as data types
    and associate behaviors with them. One way to model behaviors is to leverage a
    type hierarchy. Following the Liskov Substitution Principle, we should be able
    to substitute a type with a subtype when a function is called.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s revisit the abstract type hierarchy of managing personal assets from [Chapter
    2](48061f6f-db77-4db6-9c92-d7550f4317fe.xhtml), *Modules, Packages, and Type Concepts*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/70edf4cf-52b8-4465-befc-a192a4e5473e.png)'
  prefs: []
  type: TYPE_IMG
- en: We can define a function called `value` for determining the value of any asset.
    Such a function can be applied to all the types in the `Asset` hierarchy if we
    assume that all the asset types have some kind of monetary value attached to them.
    Following that line of thought, we can say that almost every asset exhibits the
    *HasValue* trait.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, behaviors can only be applied to certain types in the hierarchy.
    For example, what if we want to define a `trade` function that only works with
    liquid investments? In that case, we would define `trade` functions for `Investment`
    and `Cash` but not for `House` and `Apartments`.
  prefs: []
  type: TYPE_NORMAL
- en: A liquid investment refers to a security instrument that can be traded easily
    in the open market. The investor can quickly convert a liquid instrument into
    cash and vice versa. In general, most investors would like a portion of their
    investment to be liquid in the case of an emergency.
  prefs: []
  type: TYPE_NORMAL
- en: Investments that are not liquid are called illiquid.
  prefs: []
  type: TYPE_NORMAL
- en: 'Programmatically, how do we know which asset types are liquid? One way is to
    check the type of the object against a list of types that represent liquid investments. Suppose
    that we have an array of assets and need to find out which one can be traded quickly
    for cash. In this situation, the code may look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `if` condition in the preceding code is a bit ugly, even in this toy example.
    If we have more types in the condition, then it gets worse. Of course, we can
    create a union type to make it a little better:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a few issues with this approach:'
  prefs: []
  type: TYPE_NORMAL
- en: The union type has to be updated whenever we add a new liquid asset type. This
    kind of maintenance is bad from a design perspective because the programmer must
    remember to update this union type whenever a new type is added to the system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This union type is not available for extension. If other developers want to
    reuse our trading library, then they may want to add new asset types. However,
    they cannot change our definition of the union type because they do not own the
    source code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The if-then-else logic may be repeated in many places in our source, whenever
    we need to do things differently for liquid and illiquid assets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These problems can be solved using the holy traits pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the holy traits pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To illustrate the concept of this pattern, we will implement some functions
    for the personal asset data types that we developed in [Chapter 2](48061f6f-db77-4db6-9c92-d7550f4317fe.xhtml), *Modules,
    Packages, and Data Type Concepts*. As you may recall, the abstract types for the
    asset type hierarchy are defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `Asset` type is at the top of the hierarchy and has the `Property`, `Investment`,
    and `Cash` subtypes. At the next level, `House` and `Apartment` are subtypes of
    `Property`, while `FixedIncome` and `Equity` are subtypes of `Investment`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s define some concrete types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'What do we have here? Let''s take a look at these concepts in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: A `Residence` is a house that someone lives in and has a location.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `Stock` is an equity investment, and it is identified by a trading symbol
    and the name of the company.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `TreasuryBill` is a short-term government-issued form of security in the United
    States, and it is defined with a standard identifier called CUSIP.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Money` is just cash, but we want to store the currency and respective amount
    here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that we have not annotated the types for the fields because they aren't
    important for illustrating the trait concept here.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the trait type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When it comes to investments, we can distinguish between ones that can be sold
    for cash easily in the open market and ones that take considerably more effort
    and time to convert into cash. Things that can easily be converted into cash within
    several days are known as being *liquid*, while the hard-to-sell ones are known
    as being *illiquid*. For example, stocks are liquid while a residence is not.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we want to do is define the traits themselves:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Traits are nothing but data types in Julia! The overall concept of the `LiquidityStyle` trait
    is that it's an abstract type. The specific traits here, `IsLiquid` and `IsIlliquid`,
    have been set up as concrete types without any fields.
  prefs: []
  type: TYPE_NORMAL
- en: There is no standard naming convention for traits, but my research seems to
    indicate that package authors tend to use either `Style` or `Trait` as the suffix
    for trait types.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying traits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next step is to assign data types to these traits. Conveniently, Julia
    allows us to bulk-assign traits to an entire subtype tree using the `<:` operator
    in the function signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a look at how we can interpret these three lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: We have chosen to make all the types illiquid by default. Note that we could
    have done this the other way around and made everything liquid by default. This
    decision is arbitrary and depends on the specific use case.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have chosen to make all the subtypes of `Cash` liquid, which includes the
    concrete `Money` type. The notation of `::Type{<:Cash}` indicates all the subtypes
    of `Cash`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have chosen to make all the subtypes of `Investment` liquid. This includes
    all the subtypes of `FixedIncome` and `Equity`, which covers `Stock` in this example.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You might be wondering why we don''t take `::Type{<: Asset}` as an argument
    for the default trait function. Doing so makes it more restrictive as the default
    value would only be available for types that are defined under the `Asset` type
    hierarchy. This may or may not be desirable, depending on how the trait is used.
    Either way should be fine.'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing trait behavior
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we can tell which types are liquid and which are not, we can define
    methods that take objects with those traits. First, let''s do something really
    simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In Julia, types are first-class citizens. The `tradable(x::T) where {T}` signature
    captures the type of argument as `T`. Since we have already defined the `LiquidityStyle`
    function, we can derive whether the passed argument exhibits the `IsLiquid` or
    `IsIlliquid` trait. So, the first `tradable` method simply takes the return value
    of `LiquidityStyle(T)` and passes it as the first argument for the other two `tradable`
    methods. This simple example demonstrates the dispatch effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at a more interesting function that exploits the same trait.
    Since liquid assets are easily tradable in the market, we should be able to discover
    their market price quickly as well. For stocks, we may call a pricing service
    from the stock exchange. For cash, the market price is just the currency amount.
    Let''s see how this is coded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The code''s structure is the same as the `tradable` function. One method is
    used to determine the trait, while the other two methods implement different behaviors
    for the liquid and illiquid instruments. Here, both `marketprice` functions just
    raise an exception by calling the error function. Of course, that''s not what
    we really want. What we should really have is a specific pricing function for
    the `Stock` and `Money` types. Okay; let''s do just that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `marketprice` method for the `Money` type just returns the amount.
    This is quite a simplification since, in practice, we may calculate the amount
    in the local currency (for example, US Dollars) from the currency and amount.
    As for `Stock`, we just return a random number for the purpose of testing. In
    reality, we would have attached this function to a stock pricing service.
  prefs: []
  type: TYPE_NORMAL
- en: 'For illustration purposes, we have developed the following test functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the result from the Julia REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6a259e07-c52c-4a71-a10a-c2ad9bf7c6ff.png)'
  prefs: []
  type: TYPE_IMG
- en: '*Perfect!* The `tradable` function has correctly identified that cash, stock,
    and bond are liquid and that residence is illiquid. For cash and stocks, the `marketprice`
    function was able to return a value, as expected. Because residence is not liquid,
    an error was raised. Finally, while treasury bills are liquid, an error was raised
    because the `marketprice` function has not been defined for the instrument.'
  prefs: []
  type: TYPE_NORMAL
- en: Using traits with a different type of hierarchy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The best part of the holy trait pattern is that we can use it with any object,
    even when its type belongs to a different abstract type hierarchy. Let''s explore
    the case of literature, where we may define its own type hierarchy as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can make it obey the `LiquidityStyle` trait, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can trade books, just like other tradable assets.
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing some common usages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The holy traits pattern is commonly used in open source packages. Let's take
    a look at some examples.
  prefs: []
  type: TYPE_NORMAL
- en: Example 1 – Base.IteratorSize
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Julia Base library uses traits quite extensively. An example of such a
    trait is `Base.IteratorSize`. Its definition can be found using `generator.jl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This trait is slightly different from what we have learned about so far because
    it is not binary. The `IteratorSize` trait can be `SizeUnknown`, `HasLength`,
    `HasShape{N}`, or `IsInfinite`. The `IteratorSize` function is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s focus on the `IsInfinite` trait since it looks quite interesting. A
    few functions have been defined in `Base.Iterators` that generate infinite sequences.
    For example, the `Iterators.repeated` function can be used to generate the same
    value forever, and we can use the `Iterators.take` function to pick up the values
    from the sequence. Let''s see how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6815ffba-683e-498d-ac76-7a51a6bcf17d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you look at the source code, you''ll see that `Repeated` is the type of
    the iterator and that it is assigned the `IteratorSize` trait with `IsInfinite`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We can quickly test it out like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dc4235c2-b523-405d-92f7-dc03defe94b1.png)'
  prefs: []
  type: TYPE_IMG
- en: '*Voila!* It is infinite, just as we expected! But how is this trait utilized?
    To find out how, we can look into the `BitArray` from the Base library, which
    is a space-efficient Boolean array implementation. Its constructor function can
    take any iterable object, such as an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/767f0b76-afa1-486f-a216-879594fe2b43.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Perhaps it isn''t hard to understand that the constructor can''t really work
    with something that is infinite in nature! Therefore, the implementation of the `BitArray` constructor
    has to take that into account. Because we can dispatch based upon the `IteratorSize` trait,
    the constructor of `BitArray` happily throws an exception when such an iterator
    is passed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'To see it in action, we can call the `BitArray` constructor with the `Repeated`
    iterator, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ed1237a4-d2f8-4272-ae10-090cc54eee43.png)'
  prefs: []
  type: TYPE_IMG
- en: Example 2 – AbstractPlotting.jl ConversionTrait
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`AbstractPlotting.jl` is an abstract plotting library that is part of the Makie
    plotting system. The source code for this library can be found at [https://github.com/JuliaPlots/AbstractPlotting.jl](https://github.com/JuliaPlots/AbstractPlotting.jl).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at a trait that''s related to data conversion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'It defines a `ConversionTrait` that can be used for the `convert_arguments`
    function. As it stands, the conversion logic can be applied to three different
    scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: No conversion. This is handled by the default trait type of `NoConversion`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`PointBased` conversion.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`SurfaceLike` conversion.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'By default, the `convert_arguments` function just returns the arguments untouched
    when conversion is not required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, various `convert_arguments` functions are defined. Here is the function
    for 2D plotting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Using the SimpleTraits.jl package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `SimpleTraits.jl` package ([https://github.com/mauro3/SimpleTraits.jl](https://github.com/mauro3/SimpleTraits.jl))
    may be used to make programming traits a little easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try to redo the `LiquidityStyle` example using SimpleTraits. First,
    define a trait called `IsLiquid`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The syntax may look a little awkward since the `T` seems to be doing nothing,
    but it is actually required because the trait is applicable for a specific type
    `T`. The next thing is to assign types to this trait:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, a special syntax with four colons can be used to define functions that
    take objects exhibiting the trait:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The positive case has the argument annotated with `x::::IsLiquid`, while the
    negative case has the argument annotated with `x::::(!IsLiquid)`. Note that the
    parentheses is required so that the code can be parsed correctly. Now, we can
    test the functions as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f2801aeb-d3fe-4f84-907b-2b8a47ea9993.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As expected, both default implementations throw an error. Now, we can implement
    the pricing function for `Stock` and quickly test again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/99c18709-dced-40da-9ebc-66a3cb818fe8.png)'
  prefs: []
  type: TYPE_IMG
- en: '*Looks great!* As we can see, the `SimpleTrait.jl` package simplifies the process
    of creating traits.'
  prefs: []
  type: TYPE_NORMAL
- en: Using traits can make your code more extendable. We must keep in mind, however,
    that it takes some effort to design proper traits. Documentation is also important
    so that anyone who wants to extend the code can understand how to utilize the
    predefined traits.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will go over parametric types, which are commonly used to extends data
    types easily.
  prefs: []
  type: TYPE_NORMAL
- en: The parametric type pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Parametric type is a core language feature that's used to materialize data types
    with parameters. It is a very powerful technique because the same object structure
    can be reused for different data types in its fields. In this section, we will
    demonstrate how parametric types can be applied effectively.
  prefs: []
  type: TYPE_NORMAL
- en: When designing applications, we often create composite types to conveniently
    hold multiple field elements. In its simplest form, composite types only serve
    as the containers of fields. As we create more and more composite types, it may
    become clear that some of these types look almost the same. Furthermore, the functions
    that operate on these types may be very similar as well. We could end up with
    a lot of boilerplate code. Wouldn't it be cool to have a template that allows
    us to customize a general composite type for a specific use?
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider a trading application that supports buying and selling stocks. In
    the very first version, we may have the following design:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d2beab74-e6a2-48d3-bde2-3ed1e8814cbd.png)'
  prefs: []
  type: TYPE_IMG
- en: Please beware that the notation in the preceding diagram may look a lot like **Unified
    Modeling Language** (**UML**). However, because Julia is not an object-oriented
    language, we may make certain exceptions when illustrating design concepts with
    these diagrams.
  prefs: []
  type: TYPE_NORMAL
- en: 'The corresponding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The data types we defined in the preceding code are fairly straightforward.
    The `LongShort` enum type is used to indicate the direction of trade—buying stock
    would be long, while selling stock would be short. The `@enum` macro is conveniently
    used to define the `Long` and `Short` constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, suppose that we were asked to support stock options in our next version
    of the software. Naively, we could define more data types, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/640576eb-5f4e-4893-b048-adb57d01372a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The code is updated with additional data types, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'You might have noticed that the `StockTrade` and `StockOptionTrade` types are
    very similar. Such repetition is somewhat unsatisfying. It looks even worse when
    we define functions for these data types, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Both the `sign` and `payment` methods are strikingly similar for both the `StockTrade`
    and `StockOptionTrade` types. Perhaps it isn't hard to imagine that this cannot
    scale very well when we add more tradable types to the application. There has
    to be a better way to do this. This is where the parametric type comes to the
    rescue!
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing remove text parametric type for the stock trading app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the trading application we described previously, we could utilize parametric
    types to simplify the code and make it more reusable when adding future trading
    instruments.
  prefs: []
  type: TYPE_NORMAL
- en: It is quite clear that `SingleStockTrade` and `SingleStockOptionTrade` are almost
    the same. In fact, even the function definitions of `sign` and `payment` are identical.
    In this very simple example, we only have two functions for each type. In practice,
    we could have many more functions, and it would become quite messy.
  prefs: []
  type: TYPE_NORMAL
- en: Designing parametric types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To simplify this design, we can parameterize the type of the thing being traded.
    What is the thing? We can leverage the abstract type here. The supertype of `Stock`
    is `Equity`, while the supertype of `Equity` is `Investment`. Since we want to
    keep the code generic and buying/selling investment products is similar, we can
    choose to accept any type that is a subtype of `Investment`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have defined a new type called `SingleTrade`, where the underlying
    instrument has a type, `T`, where `T` can be any subtype of `Investment`. At this
    point, we can create trades with different kinds of instruments:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a30de09b-b1ce-4663-9c3b-89c9da1cf202.png)'
  prefs: []
  type: TYPE_IMG
- en: 'These objects actually have different types—`SingleTrade{Stock}` and `SingleTrade{StockOption}`.
    How do they relate to each other? They are also subtypes of `SingleTrade`, as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1814a36b-4c1d-4615-81c7-90376daa6655.png)'
  prefs: []
  type: TYPE_IMG
- en: Since both types are subtypes of `SingleTrade`, this allows us to define functions
    that apply to both types, as we will see in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Designing parametric methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to fully utilize the compiler''s specialization feature, we should
    define parametric methods that also make use of the parametric type, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s test this out:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b512eb66-22b2-4aee-8e1b-94ced5c18faa.png)'
  prefs: []
  type: TYPE_IMG
- en: 'But hey, we just found a little bug. The option of $3.50 seems too good to
    be true! When looking at buying/selling options, each option contract actually
    represents 100 shares of the underlying stock. Therefore, the payment amount for
    stock option trades needs to be multiplied by 100\. To fix this, we can just implement
    a more specific payment method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can test again. Due to this, the new method is only dispatched for
    option trades:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dc69da3d-b3d0-4159-975e-5494046a2ebf.png)'
  prefs: []
  type: TYPE_IMG
- en: '*Voila! *Isn''t it beautiful? We will look at a more elaborate example in the
    next section.'
  prefs: []
  type: TYPE_NORMAL
- en: Using multiple parametric type arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we're quite happy with our refactoring. However, our boss just called
    and said we have to support *pair trading* in the next release. This new request
    is adding yet another twist to our design!
  prefs: []
  type: TYPE_NORMAL
- en: Pair trading can be used to implement a specific trading strategy, such as market-neutral
    trades or option strategies such as covered calls.
  prefs: []
  type: TYPE_NORMAL
- en: '**Market neutral** trading involves buying one stock and short-selling another
    one at the same time. The idea is to neutralize the market''s effects so that
    the investor can focus on picking the stocks that over-perform or under-perform
    relative to their peers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Covered call strategy** involves buying a stock but selling a call option
    that strikes at a higher price. This allows the investor to earn an additional
    premium in exchange for the limited upside potential of the underlying stock.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be handled easily with parametric types. Let''s create a new type
    called `PairTrade`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the two legs from the trade can have different types, `T` and `S`,
    and that they can be any subtype of `Investment`. Because we expect every `Trade`
    type to support the `payment` function, we can implement this easily, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We can reuse the `stock` and `option` objects from the previous session and
    create a pair trade transaction where we buy 100 shares of the stock and sell
    1 option contract. The expected payment amount is $18,800 - $350 = $18,450:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a4545117-e2e8-4181-bf90-ef8c216cbd6d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To appreciate how much parametric types simplified our design, imagine how
    many functions you would have to write if you had to create separate concrete
    types. In this example, since we have two possible trades in a pair trade transaction
    and each trade can be a stock trade or option trade, we have to support 2 x 2
    = 4 different scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: '`payment(PairTradeWithStockAndStock)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`payment(PairTradeWithStockAndStockOption)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`payment(PairTradeWithStockOptionAndStock)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`payment(PairTradeWithStockOptionAndStockOption)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using parametric types, we only need a single payment function that covers all
    scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Real-life examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find the use of parametric types in almost any open source packages.
    Let's go over some examples.
  prefs: []
  type: TYPE_NORMAL
- en: Example 1 – the ColorTypes.jl package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`ColorTypes.jl` is a package that defines various data types that represent
    colors. In practice, there are many ways in which a color can be defined: **Red-Green-Blue**
    (**RGB**), **Hue-Saturation-Value** (**HSV**), and so on. Most of the time, a
    color can be defined using three real numbers. In the case of grayscale, only
    a single number is required to represent the level of darkness. To support transparent
    colors, an additional value can be used to store an opacity value. First, let''s
    take a look at the type definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The `Colorant{T,N}` type can represent all kinds of colors, with or without
    transparency. The `T` parameter represents the type of each individual value in
    the color definition; for example, Int, Float64, and so on. The `N` parameter
    represents the number of values in the color definition, which is usually three.
  prefs: []
  type: TYPE_NORMAL
- en: '`Color{T,N}` is a subtype of `Colorant{T,N}` and represents non-transparent
    colors. Finally, `AbstractRGB{T}` is a subtype of `Color{T,N}`. Note that the
    `N` parameter is no longer needed as a parameter in `AbstractRGB{T}` because it
    is already defined with N=3\. Now, the concrete parametric type, `RGB{T}`, is
    defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The definition of `RGB{T <: Fractional}` is fairly straightforward. It contains
    three values of type `T`, which can be a subtype of `Fractional`. Since the `Fractional`
    type is defined as a union of `AbstractFloat` and `FixedPoint`, the `r`, `g`,
    and `b` fields may be used as any subtype of `AbstractFloat`, such as `Float64`
    and `Float32`, or any of the `FixedPoint` number types.'
  prefs: []
  type: TYPE_NORMAL
- en: '`FixedPoint` is a type that''s defined in the `FixedPointNumbers.jl` package.
    Fixed-point numbers is a different way to represent real numbers than the floating-point
    format. More information can be found at [https://github.com/JuliaMath/FixedPointNumbers.jl](https://github.com/JuliaMath/FixedPointNumbers.jl).'
  prefs: []
  type: TYPE_NORMAL
- en: If you examine the source code further, you will find that many types are defined
    in a similar fashion.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2 – the NamedDims.jl package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `NamedDims.jl` package adds names to each dimension of a multi-dimensional
    array. The source code can be found at [https://github.com/invenia/NamedDims.jl](https://github.com/invenia/NamedDims.jl).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the definition of `NamedDimsArray`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Don't be intimidated by the signature. It is actually quite straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: '`NamedDimsArray` is a subtype of the abstract array type `AbstractArray{T,
    N}`. It only contains a single field, `data`, which keeps track of the underlying
    data. Because `T` and `N` are already parameters in `A`, they also need to be
    specified in the signature of `NamedDimsArray`. The `L` parameter is used to keep
    track of the names of the dimensions. Note that `L` is not used in any of the
    fields but that it is conveniently stored in the type signature itself.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The primary constructor is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The function only needs to take an `AbstractArray{T,N}` that is an N-dimensional
    array with an element type of `T`. First, it checks if `L` contains a tuple of
    `N` symbols. Because type parameters are first-class, they can be examined in
    the body of the function. Assuming that `L` contains the right number of symbols,
    it just instantiates a `NamedDimsArray` using the known parameters `L`, `T`, `N`,
    as well as the type of the array argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'It may be easier to see how it''s used, so let''s take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/73f8eff3-cf02-4877-a6b3-839f8bb81887.png)'
  prefs: []
  type: TYPE_IMG
- en: In the output, we can see that the type signature is `NamedDimsArray{(:x, :y),Int64,2,Array{Int64,2}}`.
    Matching this with the signature of the `NamedDimsArray` type, we can see that
    `L` is just the two-symbol tuple `(:x, :y)`, `T` is `Int64`, `N` is 2, and the
    underlying data is of the `Array{Int64, 2}` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the `dimnames` function, which is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'This function returns the dimensions tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2c6ddde2-b646-4361-9ea0-1edd673a4b03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, things are getting a little more interesting. What is `NamedDimsArray{L}`?
    Didn''t we need four parameters in this type? It is worth noting that a type such
    as `NamedDimsArray{L, T, N, A}` is actually a subtype of `NamedDimsArray{L}`.
    We can prove this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9706e903-e25c-4c50-95f5-9f7458cf079a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we really want to see what `NamedDimsArray{L}` is, we can try the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9da06100-4702-4f92-a19c-01e6fe22b765.png)'
  prefs: []
  type: TYPE_IMG
- en: What seems to be happening is that `NamedDimsArray{(:x, :y)}` is just shorthand
    for `NamedDimsArray{(:x, :y),T,N,A} where A<:AbstractArray{T,N} where N where
    T`. Because this is a more general type with three unknown parameters, we can
    see why `NamedDimsArray{(:x, :y),Int64,2,Array{Int64,2}}` is a subtype of `NamedDimsArray{(:x,
    :y)}`.
  prefs: []
  type: TYPE_NORMAL
- en: Using parametric types is very good if we wish to reuse functionalities. We
    can almost view each type parameter as a "dimension". When a parametric type has
    two type parameters, we would have many possible subtypes based upon various combinations
    of each type parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have explored several patterns related to reusability. These
    patterns are highly valuable and can be utilized in many places within an application.
    In addition, people coming from an object-oriented background will probably find
    this chapter indispensable when it comes to designing Julia applications.
  prefs: []
  type: TYPE_NORMAL
- en: First, we went into great detail about the delegation pattern, which can be
    used to create new capabilities and lets us reuse functions from an existing object.
    The general technique involves defining a new data type that contains a parent
    object. Then, forwarding functions are defined so that we can reuse the functionalities
    of the parent object. We learned implementing delegation can be largely simplified
    by using `@forward`, which is provided by the `Lazy.jl` package.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we examined the holy trait pattern, which is a formal way to define the
    behavior of objects. The idea is to define traits as native types and utilize
    Julia's built-in dispatch mechanism to call the right method implementation. We
    realize that traits are useful in making the code more extensible. We also learned
    that macros from the `SimpleTraits.jl` package can make trait coding easier.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we looked into the parametric types pattern and how it can be utilized
    to simplify the design of code. We learned that parametric types can reduce the
    size of our code. We also saw that parameters can be used in the bodies of parametric
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss an important subject that attracts a lot
    of people to the Julia programming language – performance patterns!
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How does the delegation pattern work?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the purpose of traits?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Are traits always binary?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can traits be used for objects from a different type hierarchy?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the benefits of parametric types?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do we store the information of a parametric type?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
