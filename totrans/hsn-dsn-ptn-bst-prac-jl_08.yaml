- en: Reusability Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可复用性模式
- en: In this chapter, we will learn about several patterns related to software reusability.
    As you may recall from [Chapter 1](b33529b9-aabc-46cf-88eb-5d2ac885b732.xhtml), *Design
    Patterns and Related Principles*, reusability is one of the four software quality
    objectives that is required for building large-scale applications. Nobody wants
    to reinvent the wheel. The ability to reuse an existing software component saves
    both time and energy—an overall humanity gain! The patterns in this chapter are
    proven techniques that can help us improve application design, reuse existing
    code, and reduce overall code size.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习与软件可复用性相关的几种模式。如您从[第1章](b33529b9-aabc-46cf-88eb-5d2ac885b732.xhtml)，“设计模式及相关原则”中回忆起，可复用性是构建大型应用程序所需的四个软件质量目标之一。没有人愿意重新发明轮子。能够复用现有的软件组件可以节省时间和精力——这是一项整体的人类进步！本章中的模式是经过验证的技术，可以帮助我们改进应用程序设计，复用现有代码，并减少整体代码量。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: The delegation pattern
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 委派模式
- en: The holy traits pattern
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 神圣特质模式
- en: The parametric type pattern
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数化类型模式
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The sample source code for this chapter is located at [https://github.com/PacktPublishing/Hands-on-Design-Patterns-and-Best-Practices-with-Julia/tree/master/Chapter05](https://github.com/PacktPublishing/Hands-on-Design-Patterns-and-Best-Practices-with-Julia/tree/master/Chapter05).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例源代码位于[https://github.com/PacktPublishing/Hands-on-Design-Patterns-and-Best-Practices-with-Julia/tree/master/Chapter05](https://github.com/PacktPublishing/Hands-on-Design-Patterns-and-Best-Practices-with-Julia/tree/master/Chapter05)。
- en: The code in this chapter has been tested in a Julia 1.3.0 environment.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码已在 Julia 1.3.0 环境中进行了测试。
- en: The delegation pattern
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 委派模式
- en: Delegation is a pattern that is commonly applied in software engineering. The
    primary objective is to leverage the capabilities of an existing component by
    wrapping it via a *has-a* relationship.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 委派是一种在软件工程中常用的模式。其主要目标是利用现有组件的能力，通过“包含”关系对其进行包装。
- en: The delegation pattern is widely adopted, even in the object-oriented programming
    community. In the early days of object-oriented programming, people thought that
    code reuse could be achieved beautifully using inheritance. However, people came
    to realize that this promise couldn't be completely fulfilled due to a variety
    of issues related to inheritance. Since then, many software engineers prefer composition
    over inheritance. The concept of composition is to wrap one object within another.
    In order to reuse existing functions, we must delegate functions calls to the
    wrapped object. This section will explain how delegation can be implemented in
    Julia.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 委派模式在面向对象编程社区中得到广泛应用。在面向对象编程的早期，人们认为可以通过继承来实现代码复用。然而，人们逐渐意识到，由于继承存在各种问题，这一承诺无法完全实现。从那时起，许多软件工程师更倾向于使用组合而不是继承。组合的概念是将一个对象包装在另一个对象中。为了复用现有函数，我们必须将函数调用委托给包装对象。本节将解释如何在
    Julia 中实现委派。
- en: The concept of composition is to wrap one object within another. In order to
    reuse existing functions, we must delegate functions calls to the wrapped object.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 组合的概念是将一个对象包装在另一个对象中。为了复用现有函数，我们必须将函数调用委托给包装对象。
- en: 'One way is to enhance an existing component with new features. This may sound
    good, but it could be challenging in practice. Consider the following situations:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方法是通过添加新功能来增强现有组件。这听起来不错，但在实践中可能会具有挑战性。 考虑以下情况：
- en: The existing component comes from a vendor product and the source code is not
    available. Even if the code is available, the vendor's license may not allow us
    to make custom changes.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现有的组件来自供应商产品，源代码不可用。即使代码可用，供应商的许可证可能不允许我们进行自定义更改。
- en: The existing component is developed and used by another team for a mission-critical
    system and changes are neither welcome nor applicable for that system.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现有的组件是由另一个团队为关键任务系统开发和使用的，对该系统来说，更改既不受欢迎也不适用。
- en: The existing component contains a lot of legacy code and new changes may compromise
    the component's stability and require a lot of testing effort.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现有的组件包含大量遗留代码，新的更改可能会影响组件的稳定性，并需要大量的测试工作。
- en: If modifying an existing component's source code is not an option, then we should
    at least be able to use the component via its published programming interface.
    That is the virtue of the delegation pattern.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果修改现有组件的源代码不是一个选择，那么我们至少应该能够通过其发布的编程接口使用该组件。这就是委托模式的价值所在。
- en: Applying the delegation pattern to a banking use case
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将委托模式应用于银行用例
- en: The delegation pattern is the idea of creating a new object by wrapping an existing
    one called the *parent* object. In order to reuse the object's features, the functions
    that have been defined for the new object can be delegated (also known as forwarded)
    to the parent.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 委托模式的想法是通过包装一个称为 *父对象* 的现有对象来创建一个新的对象。为了重用对象的功能，为新对象定义的函数可以被委托（也称为转发）到父对象。
- en: Suppose that we have access to a banking library that provides some basic account
    management functionality. To understand how it works, let's take a look at the
    source code.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个提供一些基本账户管理功能的银行库。为了理解它是如何工作的，让我们看看源代码。
- en: 'A bank account has been designed with the following mutable data structure:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 银行账户已经设计了一个以下可变数据结构：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As part of the programming interface, the library also provides the field accessors
    (see [Chapter 8](6b565339-641f-444c-ad42-f8ff7998001b.xhtml), *Robustness Patterns*)
    and functions for making deposits, withdrawals, and transfers, as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 作为编程接口的一部分，库还提供了字段访问器（见第 8 章，*鲁棒性模式*）以及进行存款、取款和转账的函数，如下所示：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Of course, in practice, such a banking library has to be a lot more complex
    than what is seen here. I suspect that when money goes in and out of a bank account,
    there are many downstream effects such as logging an audit trail, making the new
    balance available on a website, sending emails to the customer, and so on.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在实际应用中，这样的银行库要比这里看到的复杂得多。我怀疑当钱进出银行账户时，会有许多下游影响，例如记录审计跟踪、在网站上提供新的余额、向客户发送电子邮件等等。
- en: Let's move on and learn how we can utilize the delegation pattern.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续学习如何利用委托模式。
- en: Composing a new type that contains an existing type
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合一个包含现有类型的新类型
- en: As part of a new initiative, the bank wants us to support a new savings account
    product, which provides daily interest for customers. Since the existing account
    management's functionality is critical to the bank's business and is maintained
    by a different team, we have decided to reuse its functionality without touching
    any of the existing source code.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一项新举措的一部分，银行希望我们支持一种新的储蓄账户产品，该产品为顾客提供每日利息。由于现有的账户管理功能对银行业务至关重要，并且由不同的团队维护，我们决定在不修改任何现有源代码的情况下重用其功能。
- en: 'First, let''s create our own `SavingsAccount` data type, as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建自己的 `SavingsAccount` 数据类型，如下所示：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The first field, `acct`, is used to hold an `Account` object, while the second
    field, `interest_rate`, contains the interest rate per annum for the account.
    A constructor is also defined to instantiate the object.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个字段 `acct` 用于存储一个 `Account` 对象，而第二个字段 `interest_rate` 包含账户的年利率。还定义了一个构造函数来实例化对象。
- en: 'In order to use the underlying `Account` object, we can use a technique called
    *Delegation*, or *Method Forwarding*. This is where we implement the same API
    in `SavingsAccount` and forward the call to the underlying `Account` object whenever
    we want to reuse the existing functions from the underlying object. In this case,
    we can just forward all the field accessor functions and mutating functions from
    the `Account` object, as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用底层的 `Account` 对象，我们可以使用一种称为 *委托* 或 *方法转发* 的技术。这就是我们在 `SavingsAccount` 中实现相同的
    API，并在想要重用底层对象中现有函数时，将调用转发到底层 `Account` 对象。在这种情况下，我们可以简单地转发 `Account` 对象的所有字段访问器函数和修改函数，如下所示：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'So far, we have successfully reused the `Account` data type, but let''s not
    forget that we actually want to build new features in the first place. A savings
    account should accrue interest overnight on a daily basis. So, for the `SavingsAccount`
    object, we can implement a new accessor for the `interest_rate` field and a new
    mutating function called `accrue_daily_interest!`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经成功地重用了 `Account` 数据类型，但不要忘记我们最初实际上是想构建新的功能。储蓄账户应该每天基于每日利息进行过夜计息。因此，对于
    `SavingsAccount` 对象，我们可以实现一个新的 `interest_rate` 字段访问器和一个名为 `accrue_daily_interest!`
    的新修改函数：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: At this time, we have created a new `SavingsAccount` object that works just
    like the original `Account` object, except it has the additional capability of
    accruing interest!
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个时候，我们已经创建了一个新的`SavingsAccount`对象，它的工作方式与原始的`Account`对象完全一样，除了它还具有累积利息的额外功能！
- en: However, the sheer volume of these forwarding methods makes us feel a little
    unsatisfied. It would be nice if we didn't have to write all this code manually.
    Perhaps there's a better way...
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这些转发方法的数量之多让我们感到有些不满意。如果我们可以不用手动编写所有这些代码，那就太好了。也许有更好的方法...
- en: Reducing boilerplate code for forwarding methods
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 减少转发方法中的样板代码
- en: You may wonder how it would ever be worth the effort to write so much code just
    to forward the method calls to the parent object. Indeed, the forwarding methods
    serve no purpose other than passing the exact same arguments to the parent. If
    programmers were paid by lines of code, then this would be quite an expensive
    proposition, wouldn't it?
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道为什么写这么多代码仅仅是为了将方法调用转发到父对象。确实，转发方法除了将完全相同的参数传递给父对象外，没有其他作用。如果程序员按代码行数付费，那么这将会是一个非常昂贵的提议，不是吗？
- en: 'Fortunately, this kind of boilerplate code can be reduced greatly using macros.
    There are several open source solutions that can help with this situation. For
    demonstration purposes, we can utilize the `@forward` macro from the `Lazy.jl`
    package. Let''s replace all the forwarding methods, as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，这种样板代码可以通过宏大大减少。有几个开源解决方案可以帮助这种情况。为了演示目的，我们可以利用来自`Lazy.jl`包的`@forward`宏。让我们按照以下方式替换所有的转发方法：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The usage of `@forward` is fairly straightforward. It takes two expressions
    as arguments. The first argument is the `SavingsAccount.acct` object that you
    want to forward to, while the second argument is just a tuple of function names
    that you wish to forward to, for example, `account_number`, `balance`, and `date_opened`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`@forward`的使用相当直接。它接受两个表达式作为参数。第一个参数是你想要转发的`SavingsAccount.acct`对象，而第二个参数是你希望转发的函数名称的元组，例如`account_number`、`balance`和`date_opened`。'
- en: Note that we are able to forward mutating functions such as `deposit!` and `withdraw!`,
    but we cannot do the same for `transfer!`. This is because `transfer!` requires
    that we forward its first and second arguments. In this case, we just keep the
    manual forwarding method. Nevertheless, we were able to forward five out of the
    six functions using just two lines of code. It's still a pretty good deal!
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们能够转发像`deposit!`和`withdraw!`这样的可变函数，但对于`transfer!`则不能这样做。这是因为`transfer!`需要我们转发它的第一个和第二个参数。在这种情况下，我们只是保留了手动转发的方法。然而，我们仅用两行代码就成功转发了六个函数中的五个。这仍然是一个相当不错的交易！
- en: It would be possible to make more forwarding macros that take two or three arguments.
    In fact, there are other open source packages that support such scenarios, such
    as the `TypedDelegation.jl` package.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们可以创建更多接受两个或三个参数的转发宏。事实上，还有其他开源包支持这种场景，例如`TypedDelegation.jl`包。
- en: 'So, how does the `@forward` macro work? We can examine how the code gets expanded
    using the `@macroexpand` macro. The following is the result of the line number
    nodes being removed. Basically, for each method that is being forwarded (`balance`
    and `deposit!`), it creates the corresponding function definition with all the
    arguments splatted with the `args...` notation. It also throws in an `@inline` node
    to give the compiler a hint for better performance:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，`@forward`宏是如何工作的呢？我们可以使用`@macroexpand`宏来检查代码是如何被展开的。以下是从行号节点中移除的结果。基本上，对于每个被转发的函数（`balance`和`deposit!`），它都会创建一个带有所有参数使用`args...`表示法展开的相应函数定义。它还加入了一个`@inline`节点，为编译器提供性能优化的提示：
- en: '![](img/88ad9266-859f-4b4d-933f-c516b8314b11.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/88ad9266-859f-4b4d-933f-c516b8314b11.png)'
- en: Inlining is a compiler optimization where a function call is *inlined* as if
    the code had been interpolated into the current code. It may improve performance
    by reducing the overhead of allocating a call stack when functions are called
    repeatedly.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 内联是编译器优化，其中函数调用被*内联*，就像代码被插入到当前代码中一样。它可能通过减少函数重复调用时分配调用栈的开销来提高性能。
- en: The `@forward` macro was implemented with only a few lines of code. You are
    encouraged to take a look at the source code if you are interested in metaprogramming.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`@forward`宏仅用几行代码就实现了。如果你对元编程感兴趣，鼓励你查看源代码。'
- en: You might be wondering why there are several funny variable names such as `#41#x`
    or `#42#args`. We can treat those as if they are normal variables. They are automatically
    generated by the compiler, and their special naming convention is chosen to avoid
    conflicts with other variables in the current scope.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道为什么有几个有趣的变量名，如`#41#x`或`#42#args`。我们可以将它们视为普通变量。它们是由编译器自动生成的，并且选择了特殊的命名约定，以避免与当前作用域中的其他变量冲突。
- en: Finally, it is important to understand that we may not always want to forward
    all the function calls to the object. What if we don't want to use 100% of the
    underlying features? Believe it or not, there are cases like that. For example,
    let's imagine that we have to support another kind of account, such as a certificate
    of deposits, also known as CDs. A CD is a short-term investment product that pays
    a higher interest than a savings account, but the funds cannot be withdrawn during
    the term of investment. Generally, the term of a CD could be 3 months, 6 months,
    or longer. Going back to our code, if we create a new `CertificateOfDepositAccount` object
    and reuse the `Account` object again, we wouldn't want to forward the `withdraw!` and
    `transfer!` methods because they are not features of CDs.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，重要的是要理解我们可能并不总是希望将所有的函数调用转发到对象。如果我们不想使用底层功能的100%呢？信不信由你，确实存在这样的情况。例如，让我们想象我们必须支持另一种类型的账户，比如定期存款单，也称为CD。CD是一种短期投资产品，其利率高于储蓄账户，但在投资期间资金不能提取。一般来说，CD的期限可以是3个月、6个月或更长。回到我们的代码，如果我们创建一个新的`CertificateOfDepositAccount`对象并再次重用`Account`对象，我们就不想转发`withdraw!`和`transfer!`方法，因为它们不是CD的功能。
- en: You might wonder how delegation differs from class inheritance in object-oriented
    programming languages. For example, in the Java language, all the public and protected
    methods from the parent class are inherited automatically. This is analogous to
    auto-forwarding all the methods from the parent class.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道委托在面向对象编程语言中与类继承有何不同。例如，在Java语言中，父类中的所有公共和受保护方法都会自动继承。这相当于自动转发父类中的所有方法。
- en: The inability to choose what to inherit is actually one of the reasons why delegation
    is preferred over inheritance. For a more in-depth discussion, see [Chapter 12](97049a94-ad30-452a-bbb0-296d9438c886.xhtml), *Inheritance
    and Variance*.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 无法选择要继承的内容实际上是为什么委托比继承更受欢迎的原因之一。对于更深入的讨论，请参阅第12章，*继承和变异性*。
- en: Reviewing some real-life examples
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查一些真实世界的例子
- en: The delegation pattern is used extensively in open source packages. For example,
    many packages in the JuliaArrays GitHub organization implement the `AbstractArray`
    interface. The special array types usually contain a regular `AbstractArray` object.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 委托模式在开源包中得到了广泛的应用。例如，JuliaArrays GitHub组织中的许多包实现了`AbstractArray`接口。特殊的数组类型通常包含一个常规的`AbstractArray`对象。
- en: Example 1 – the OffsetArrays.jl package
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例1 – OffsetArrays.jl包
- en: 'The `OffsetArrays.jl` package allows us to define arrays with arbitrary indices
    rather than the standard linear or cartesian style indices. A fun example is to
    use a zero-based array, just like the ones you may find in other programming languages:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`OffsetArrays.jl`包允许我们定义具有任意索引的数组，而不是标准的线性或笛卡尔风格索引。一个有趣的例子是使用基于零的数组，就像你可能在其他编程语言中找到的那样：'
- en: '![](img/5a5a0185-28a8-431b-9b7c-ebc902f501f5.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5a5a0185-28a8-431b-9b7c-ebc902f501f5.png)'
- en: 'To understand how this works, we need to dig into the source code. Let''s keep
    things concise and review just a portion of the code:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解这是如何工作的，我们需要深入研究源代码。让我们保持简洁，只审查代码的一部分：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `OffsetArray` data type is composed of the `parent` and `offsets` fields.
    In order to satisfy the `AbstractArray` interface, it implements some of the basic
    functions, such as `Base.size`, `Base.eachindex`, and so on. Since these functions
    are simple enough, the code just forwards the call to the parent object manually.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`OffsetArray`数据类型由`parent`和`offsets`字段组成。为了满足`AbstractArray`接口，它实现了某些基本功能，例如`Base.size`、`Base.eachindex`等。由于这些函数足够简单，代码只是手动将调用转发到父对象。'
- en: Example 2 – the ScikitLearn.jl package
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例2 – ScikitLearn.jl包
- en: Let's also take a look at the `ScikitLearn.jl` package, which defines a consistent
    API for fitting machine learning models and doing prediction.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也看看`ScikitLearn.jl`包，它定义了一个一致的API来拟合机器学习模型和进行预测。
- en: 'The following is how the `FitBit` type is defined:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何定义`FitBit`类型的：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here, we can see that the `FitBit` object contains a `model` object and that
    it adds a new functionality that keeps track of whether a model has been fitted
    or not:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到`FitBit`对象包含一个`model`对象，并且它添加了一个新功能，用于跟踪模型是否已被拟合：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: It uses the `@forward` macro to delegate all the major functions, that is, `transform`,
    `predict`, and so on.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用`@forward`宏来代理所有主要功能，即`transform`、`predict`等。
- en: Considerations
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 考虑事项
- en: You should keep in mind that the delegation pattern introduces a new level of
    indirection, which can increase code complexity and make the code more difficult
    to understand. We should consider some factors when deciding to use the delegation
    pattern.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该记住，代理模式引入了新的间接层次，这可能会增加代码复杂性，并使代码更难以理解。在决定是否使用代理模式时，我们应该考虑一些因素。
- en: First, how much code can you reuse from the existing component? Is it 20%, 50%,
    or 80%? This ought to be the very first question you ask before you consider reusing
    an existing component. Let's call the amount of reuse the utilization rate. Obviously,
    the higher the utilization rate, the better it is from a reuse perspective.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你能从现有组件中重用多少代码？是20%，50%，还是80%？在你考虑重用现有组件之前，这应该是你最需要问的第一个问题。我们可以把重用量的比例称为利用率。显然，利用率越高，从重用角度来看就越好。
- en: Second, how much development effort can be saved by reusing an existing component? If
    the cost of developing the same functionality is low, then it may not be worth
    the effort to reuse the component and increase the complexity of extra indirection.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，通过重用现有组件可以节省多少开发工作量？如果开发相同功能性的成本很低，那么重用组件并增加额外间接的复杂性可能不值得。
- en: From the opposite angle, we should also review if there is any critical business
    logic in the existing component. If we decide to not reuse the component, then
    we could end up implementing the same logic again, violating the **Don't Repeat
    Yourself** (**DRY**) principle. This means it can be a maintenance nightmare to
    not reuse the component.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 从相反的角度来看，我们也应该审查现有组件中是否存在任何关键的业务逻辑。如果我们决定不重用组件，那么我们可能会再次实现相同的逻辑，违反了**不要重复自己**（**DRY**）原则。这意味着不重用组件可能会成为一个维护噩梦。
- en: Given these considerations, we should just to make a good judgment about using
    the delegation pattern or not.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这些因素，我们应该对是否使用代理模式做出良好的判断。
- en: Next, we will learn how to implement traits in Julia.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将学习如何在Julia中实现特性。
- en: The holy traits pattern
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 神圣的特性模式
- en: The holy traits pattern has an interesting name. Some people also call it the **Tim
    Holy Traits Trick** (**THTT**). As you might have guessed the pattern is named
    after Tim Holy, who is a long-time contributor to the Julia language and ecosystem.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 神圣的特性模式有一个有趣的名字。有些人也称它为**Tim Holy特性技巧**（**THTT**）。正如你可能猜到的，这个模式是以Tim Holy的名字命名的，他是一位长期为Julia语言和生态系统做出贡献的贡献者。
- en: What are traits? In a nutshell, a trait corresponds to the behavior of an object.
    For example, birds and butterflies can fly, so they both have the *CanFly* trait.
    Dolphins and turtles can swim, so they both have the *CanSwim* trait. A duck can
    fly and swim, so it has both the *CanFly* and *CanSwim* traits. Traits are typically
    binary – you either exhibit the trait or not – although that is not a mandatory
    requirement.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 特性是什么？简而言之，特性对应于对象的行为。例如，鸟儿和蝴蝶可以飞翔，因此它们都具有**CanFly**特性。海豚和乌龟可以游泳，因此它们都具有**CanSwim**特性。鸭子可以飞翔和游泳，因此它具有**CanFly**和**CanSwim**特性。特性通常是二元的——要么具有该特性，要么不具有——尽管这不是强制性的要求。
- en: Why do we want traits? Traits can be used as a formal contract about how a data
    type can be used. For example, if an object has the *CanFly* trait, then we would
    be quite confident that the object has some kind of *fly* method defined. Likewise,
    if an object has the *CanSwim* trait, then we can probably call some kind of *swim*
    function.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为什么想要特性？特性可以用作关于数据类型如何使用的正式合同。例如，如果一个对象具有**CanFly**特性，那么我们可以相当自信地认为该对象定义了某种**fly**方法。同样，如果一个对象具有**CanSwim**特性，那么我们可能可以调用某种**swim**函数。
- en: Let's get back to programming. The Julia language doesn't have any built-in
    support for traits. However, the language is versatile enough for developers to
    use traits with the help of the multiple dispatch system. In this section, we
    will look into how this can be done with the special technique known as holy traits.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到编程。Julia语言没有内置对特性的支持。然而，该语言足够灵活，允许开发者通过多分派系统使用特性。在本节中，我们将探讨如何使用被称为神圣特性的特殊技术来实现这一点。
- en: Revisiting the personal asset management use case
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新审视个人资产管理用例
- en: When designing reusable software, we often create abstractions as data types
    and associate behaviors with them. One way to model behaviors is to leverage a
    type hierarchy. Following the Liskov Substitution Principle, we should be able
    to substitute a type with a subtype when a function is called.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当设计可重用软件时，我们经常创建抽象的数据类型并将行为与之关联。建模行为的一种方式是利用类型层次结构。遵循Liskov替换原则，当调用函数时，我们应该能够用子类型替换类型。
- en: 'Let''s revisit the abstract type hierarchy of managing personal assets from [Chapter
    2](48061f6f-db77-4db6-9c92-d7550f4317fe.xhtml), *Modules, Packages, and Type Concepts*:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下从[第2章](48061f6f-db77-4db6-9c92-d7550f4317fe.xhtml)，*模块、包和类型概念*中管理个人资产的高级类型层次结构：
- en: '![](img/70edf4cf-52b8-4465-befc-a192a4e5473e.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/70edf4cf-52b8-4465-befc-a192a4e5473e.png)'
- en: We can define a function called `value` for determining the value of any asset.
    Such a function can be applied to all the types in the `Asset` hierarchy if we
    assume that all the asset types have some kind of monetary value attached to them.
    Following that line of thought, we can say that almost every asset exhibits the
    *HasValue* trait.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以定义一个名为`value`的函数，用于确定任何资产的价值。如果我们假设所有资产类型都附带有某种货币价值，那么这个函数可以应用于`Asset`层次结构中的所有类型。沿着这条思路，我们可以说几乎每种资产都表现出*HasValue*特质。
- en: Sometimes, behaviors can only be applied to certain types in the hierarchy.
    For example, what if we want to define a `trade` function that only works with
    liquid investments? In that case, we would define `trade` functions for `Investment`
    and `Cash` but not for `House` and `Apartments`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，行为只能应用于层次结构中的某些类型。例如，如果我们想定义一个只与流动投资一起工作的`trade`函数怎么办？在这种情况下，我们会为`Investment`和`Cash`定义`trade`函数，但不会为`House`和`Apartments`定义。
- en: A liquid investment refers to a security instrument that can be traded easily
    in the open market. The investor can quickly convert a liquid instrument into
    cash and vice versa. In general, most investors would like a portion of their
    investment to be liquid in the case of an emergency.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 流动投资是指可以在公开市场上轻松交易的证券工具。投资者可以快速将流动工具转换为现金，反之亦然。一般来说，大多数投资者在紧急情况下都希望他们的投资中有一部分是流动的。
- en: Investments that are not liquid are called illiquid.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 非流动的投资被称为非流动资产。
- en: 'Programmatically, how do we know which asset types are liquid? One way is to
    check the type of the object against a list of types that represent liquid investments. Suppose
    that we have an array of assets and need to find out which one can be traded quickly
    for cash. In this situation, the code may look something like this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 编程上，我们如何知道哪些资产类型是流动的？一种方法是将对象类型与表示流动投资的类型列表进行比较。假设我们有一个资产数组，需要找出哪一个可以快速兑换成现金。在这种情况下，代码可能看起来像这样：
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `if` condition in the preceding code is a bit ugly, even in this toy example.
    If we have more types in the condition, then it gets worse. Of course, we can
    create a union type to make it a little better:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码中的`if`条件有点丑陋，即使是这个玩具示例也是如此。如果我们有更多类型的条件，那么它会更糟。当然，我们可以创建一个联合类型来让它变得稍微好一些：
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'There are a few issues with this approach:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法有几个问题：
- en: The union type has to be updated whenever we add a new liquid asset type. This
    kind of maintenance is bad from a design perspective because the programmer must
    remember to update this union type whenever a new type is added to the system.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每当我们添加一个新的流动资产类型时，联合类型必须更新。从设计角度来看，这种维护是糟糕的，因为程序员必须记住在向系统中添加新类型时更新这个联合类型。
- en: This union type is not available for extension. If other developers want to
    reuse our trading library, then they may want to add new asset types. However,
    they cannot change our definition of the union type because they do not own the
    source code.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个联合类型不可扩展。如果其他开发者想重用我们的交易库，他们可能想添加新的资产类型。然而，他们不能更改我们的联合类型定义，因为他们没有源代码。
- en: The if-then-else logic may be repeated in many places in our source, whenever
    we need to do things differently for liquid and illiquid assets.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果-否则逻辑可能在我们的源代码的许多地方重复出现，每当我们需要对流动资产和非流动资产执行不同的操作时。
- en: These problems can be solved using the holy traits pattern.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题可以使用神圣特质模式来解决。
- en: Implementing the holy traits pattern
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现神圣特质模式
- en: 'To illustrate the concept of this pattern, we will implement some functions
    for the personal asset data types that we developed in [Chapter 2](48061f6f-db77-4db6-9c92-d7550f4317fe.xhtml), *Modules,
    Packages, and Data Type Concepts*. As you may recall, the abstract types for the
    asset type hierarchy are defined as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这种模式的概念，我们将实现一些函数，用于我们在[第2章](48061f6f-db77-4db6-9c92-d7550f4317fe.xhtml)，*模块、包和数据类型概念*中开发的个人资产数据类型。如您所回忆的，资产类型层次结构的抽象类型定义如下：
- en: '[PRE11]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `Asset` type is at the top of the hierarchy and has the `Property`, `Investment`,
    and `Cash` subtypes. At the next level, `House` and `Apartment` are subtypes of
    `Property`, while `FixedIncome` and `Equity` are subtypes of `Investment`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`Asset`类型位于层次结构的顶部，具有`Property`、`Investment`和`Cash`子类型。在下一级，`House`和`Apartment`是`Property`的子类型，而`FixedIncome`和`Equity`是`Investment`的子类型。'
- en: 'Now, let''s define some concrete types:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们定义一些具体的类型：
- en: '[PRE12]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'What do we have here? Let''s take a look at these concepts in more detail:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这里有什么？让我们更详细地看看这些概念：
- en: A `Residence` is a house that someone lives in and has a location.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`Residence`是某人居住的房屋，并且有一个位置。
- en: A `Stock` is an equity investment, and it is identified by a trading symbol
    and the name of the company.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`Stock`是股权投资，它通过交易符号和公司名称来识别。
- en: A `TreasuryBill` is a short-term government-issued form of security in the United
    States, and it is defined with a standard identifier called CUSIP.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TreasuryBill`是美国政府发行的一种短期证券，它通过一个称为CUSIP的标准标识符来定义。'
- en: '`Money` is just cash, but we want to store the currency and respective amount
    here.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Money`只是现金，但我们想在这里存储货币和相应的金额。'
- en: Note that we have not annotated the types for the fields because they aren't
    important for illustrating the trait concept here.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们没有注释字段的类型，因为它们在这里说明特性概念并不重要。
- en: Defining the trait type
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义特性类型
- en: When it comes to investments, we can distinguish between ones that can be sold
    for cash easily in the open market and ones that take considerably more effort
    and time to convert into cash. Things that can easily be converted into cash within
    several days are known as being *liquid*, while the hard-to-sell ones are known
    as being *illiquid*. For example, stocks are liquid while a residence is not.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到投资时，我们可以区分那些在公开市场上可以轻易换成现金的投资和那些需要相当多的努力和时间才能换成现金的投资。那些可以在几天内轻易换成现金的东西被称为是*流动的*，而难以出售的被称为是*非流动的*。例如，股票是流动的，而住宅则不是。
- en: 'The first thing we want to do is define the traits themselves:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先想定义特性本身：
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Traits are nothing but data types in Julia! The overall concept of the `LiquidityStyle` trait
    is that it's an abstract type. The specific traits here, `IsLiquid` and `IsIlliquid`,
    have been set up as concrete types without any fields.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 特性在Julia中不过是数据类型！`LiquidityStyle`特性的整体概念是它是一个抽象类型。这里的具体特性，`IsLiquid`和`IsIlliquid`，已经被设置为没有字段的实体类型。
- en: There is no standard naming convention for traits, but my research seems to
    indicate that package authors tend to use either `Style` or `Trait` as the suffix
    for trait types.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 特性的命名没有标准约定，但我的研究似乎表明，包作者倾向于使用`Style`或`Trait`作为特性类型的后缀。
- en: Identifying traits
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 识别特性
- en: 'The next step is to assign data types to these traits. Conveniently, Julia
    allows us to bulk-assign traits to an entire subtype tree using the `<:` operator
    in the function signature:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是为这些特性分配数据类型。方便的是，Julia允许我们使用函数签名中的`<:`运算符批量分配特性到整个子类型树。
- en: '[PRE14]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let''s take a look at how we can interpret these three lines of code:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何解释这三行代码：
- en: We have chosen to make all the types illiquid by default. Note that we could
    have done this the other way around and made everything liquid by default. This
    decision is arbitrary and depends on the specific use case.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们选择默认将所有类型设置为非流动的。请注意，我们也可以反过来，默认将所有东西设置为流动的。这个决定是任意的，取决于特定的用例。
- en: We have chosen to make all the subtypes of `Cash` liquid, which includes the
    concrete `Money` type. The notation of `::Type{<:Cash}` indicates all the subtypes
    of `Cash`.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们选择将所有`Cash`的子类型都做成流动的，这包括具体的`Money`类型。`::Type{<:Cash}`的表示法表明了`Cash`的所有子类型。
- en: We have chosen to make all the subtypes of `Investment` liquid. This includes
    all the subtypes of `FixedIncome` and `Equity`, which covers `Stock` in this example.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们选择将所有`Investment`的子类型都做成流动的。这包括所有`FixedIncome`和`Equity`的子类型，在这个例子中涵盖了`Stock`。
- en: 'You might be wondering why we don''t take `::Type{<: Asset}` as an argument
    for the default trait function. Doing so makes it more restrictive as the default
    value would only be available for types that are defined under the `Asset` type
    hierarchy. This may or may not be desirable, depending on how the trait is used.
    Either way should be fine.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '你可能想知道为什么我们不将`::Type{<: Asset}`作为默认特性函数的参数。这样做使得它更加限制性，因为默认值只适用于在`Asset`类型层次结构下定义的类型。这可能是或可能不是所希望的，这取决于特性是如何使用的。无论如何都应该是可以的。'
- en: Implementing trait behavior
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现特性行为
- en: 'Now that we can tell which types are liquid and which are not, we can define
    methods that take objects with those traits. First, let''s do something really
    simple:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够判断哪些类型是流动的，哪些不是，我们可以定义接受具有这些特性的对象的方法。首先，让我们做一些非常简单的事情：
- en: '[PRE15]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In Julia, types are first-class citizens. The `tradable(x::T) where {T}` signature
    captures the type of argument as `T`. Since we have already defined the `LiquidityStyle`
    function, we can derive whether the passed argument exhibits the `IsLiquid` or
    `IsIlliquid` trait. So, the first `tradable` method simply takes the return value
    of `LiquidityStyle(T)` and passes it as the first argument for the other two `tradable`
    methods. This simple example demonstrates the dispatch effect.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在Julia中，类型是一等公民。`tradable(x::T) where {T}`签名捕获了参数的类型作为`T`。由于我们已定义了`LiquidityStyle`函数，我们可以推导出传递的参数是否表现出`IsLiquid`或`IsIlliquid`特性。因此，第一个`tradable`方法只是接受`LiquidityStyle(T)`的返回值，并将其作为其他两个`tradable`方法的第一个参数传递。这个简单的例子展示了派发效应。
- en: 'Now, let''s look at a more interesting function that exploits the same trait.
    Since liquid assets are easily tradable in the market, we should be able to discover
    their market price quickly as well. For stocks, we may call a pricing service
    from the stock exchange. For cash, the market price is just the currency amount.
    Let''s see how this is coded:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看一个更有趣的函数，它利用了相同的特性。由于流动性资产在市场上很容易交易，我们应该能够快速发现它们的市场价格。对于股票，我们可以从证券交易所调用定价服务。对于现金，市场价格只是货币金额。让我们看看这是如何编码的：
- en: '[PRE16]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The code''s structure is the same as the `tradable` function. One method is
    used to determine the trait, while the other two methods implement different behaviors
    for the liquid and illiquid instruments. Here, both `marketprice` functions just
    raise an exception by calling the error function. Of course, that''s not what
    we really want. What we should really have is a specific pricing function for
    the `Stock` and `Money` types. Okay; let''s do just that:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的结构与`tradable`函数相同。一个方法用于确定特性，而另外两个方法为流动性和非流动性工具实现不同的行为。在这里，两个`marketprice`函数只是通过调用错误函数来抛出异常。当然，这并不是我们真正想要的。我们真正想要的应该是一个针对`Stock`和`Money`类型的特定定价函数。好的；让我们就这样做：
- en: '[PRE17]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, the `marketprice` method for the `Money` type just returns the amount.
    This is quite a simplification since, in practice, we may calculate the amount
    in the local currency (for example, US Dollars) from the currency and amount.
    As for `Stock`, we just return a random number for the purpose of testing. In
    reality, we would have attached this function to a stock pricing service.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`Money`类型的`marketprice`方法只是返回金额。这在实践中是一种相当简化的做法，因为我们可能需要从货币和金额中计算出当地货币（例如，美元）的金额。至于`Stock`，我们只是为了测试目的返回一个随机数。在现实中，我们会将这个函数附加到一个股票定价服务上。
- en: 'For illustration purposes, we have developed the following test functions:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明目的，我们开发了以下测试函数：
- en: '[PRE18]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here''s the result from the Julia REPL:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Julia REPL的结果：
- en: '![](img/6a259e07-c52c-4a71-a10a-c2ad9bf7c6ff.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6a259e07-c52c-4a71-a10a-c2ad9bf7c6ff.png)'
- en: '*Perfect!* The `tradable` function has correctly identified that cash, stock,
    and bond are liquid and that residence is illiquid. For cash and stocks, the `marketprice`
    function was able to return a value, as expected. Because residence is not liquid,
    an error was raised. Finally, while treasury bills are liquid, an error was raised
    because the `marketprice` function has not been defined for the instrument.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '*完美！* `tradable`函数正确地识别出现金、股票和债券是流动的，而住宅是非流动的。对于现金和股票，`marketprice`函数能够返回预期的值。因为住宅不是流动的，所以抛出了一个错误。最后，虽然国库券是流动的，但由于`marketprice`函数尚未定义该工具，所以抛出了一个错误。'
- en: Using traits with a different type of hierarchy
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用具有不同类型层次结构的特性
- en: 'The best part of the holy trait pattern is that we can use it with any object,
    even when its type belongs to a different abstract type hierarchy. Let''s explore
    the case of literature, where we may define its own type hierarchy as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 神圣特性模式的最佳部分在于我们可以用它来处理任何对象，即使它的类型属于不同的抽象类型层次结构。让我们看看文学案例，我们可能定义它自己的类型层次结构如下：
- en: '[PRE19]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, we can make it obey the `LiquidityStyle` trait, as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以让它遵守 `LiquidityStyle` 特性，如下所示：
- en: '[PRE20]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now, we can trade books, just like other tradable assets.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以像其他可交易资产一样交易书籍。
- en: Reviewing some common usages
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 审查一些常见用法
- en: The holy traits pattern is commonly used in open source packages. Let's take
    a look at some examples.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 神圣特性模式在开源包中很常见。让我们看看一些例子。
- en: Example 1 – Base.IteratorSize
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例 1 – Base.IteratorSize
- en: 'The Julia Base library uses traits quite extensively. An example of such a
    trait is `Base.IteratorSize`. Its definition can be found using `generator.jl`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Julia Base 库广泛使用特性。这样的特性之一是 `Base.IteratorSize`。它的定义可以通过 `generator.jl` 查找：
- en: '[PRE21]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This trait is slightly different from what we have learned about so far because
    it is not binary. The `IteratorSize` trait can be `SizeUnknown`, `HasLength`,
    `HasShape{N}`, or `IsInfinite`. The `IteratorSize` function is defined as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特性与我们之前学到的略有不同，因为它不是二元的。`IteratorSize` 特性可以是 `SizeUnknown`、`HasLength`、`HasShape{N}`
    或 `IsInfinite`。`IteratorSize` 函数定义如下：
- en: '[PRE22]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let''s focus on the `IsInfinite` trait since it looks quite interesting. A
    few functions have been defined in `Base.Iterators` that generate infinite sequences.
    For example, the `Iterators.repeated` function can be used to generate the same
    value forever, and we can use the `Iterators.take` function to pick up the values
    from the sequence. Let''s see how this works:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们专注于看起来相当有趣的 `IsInfinite` 特性。`Base.Iterators` 中定义了一些函数来生成无限序列。例如，`Iterators.repeated`
    函数可以用来无限生成相同的值，我们可以使用 `Iterators.take` 函数从序列中选取值。让我们看看这是如何工作的：
- en: '![](img/6815ffba-683e-498d-ac76-7a51a6bcf17d.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6815ffba-683e-498d-ac76-7a51a6bcf17d.png)'
- en: 'If you look at the source code, you''ll see that `Repeated` is the type of
    the iterator and that it is assigned the `IteratorSize` trait with `IsInfinite`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看源代码，你会看到 `Repeated` 是迭代器的类型，并且它被分配了 `IteratorSize` 特性 `IsInfinite`：
- en: '[PRE23]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We can quickly test it out like so:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以快速测试它，如下所示：
- en: '![](img/dc4235c2-b523-405d-92f7-dc03defe94b1.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/dc4235c2-b523-405d-92f7-dc03defe94b1.png)'
- en: '*Voila!* It is infinite, just as we expected! But how is this trait utilized?
    To find out how, we can look into the `BitArray` from the Base library, which
    is a space-efficient Boolean array implementation. Its constructor function can
    take any iterable object, such as an array:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '*Voila!* 它是无限的，正如我们所预期的！但是这个特性是如何被利用的呢？为了找出答案，我们可以查看 Base 库中的 `BitArray`，这是一个空间高效的布尔数组实现。它的构造函数可以接受任何可迭代对象，例如一个数组：'
- en: '![](img/767f0b76-afa1-486f-a216-879594fe2b43.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/767f0b76-afa1-486f-a216-879594fe2b43.png)'
- en: 'Perhaps it isn''t hard to understand that the constructor can''t really work
    with something that is infinite in nature! Therefore, the implementation of the `BitArray` constructor
    has to take that into account. Because we can dispatch based upon the `IteratorSize` trait,
    the constructor of `BitArray` happily throws an exception when such an iterator
    is passed:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 也许不难理解构造函数实际上无法处理本质上无限的事物！因此，`BitArray` 构造函数的实现必须考虑到这一点。因为我们可以根据 `IteratorSize`
    特性进行分派，所以当传递这样的迭代器时，`BitArray` 的构造函数会愉快地抛出一个异常：
- en: '[PRE24]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To see it in action, we can call the `BitArray` constructor with the `Repeated`
    iterator, like so:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 要看到它的实际应用，我们可以用 `Repeated` 迭代器调用 `BitArray` 构造函数，如下所示：
- en: '![](img/ed1237a4-d2f8-4272-ae10-090cc54eee43.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ed1237a4-d2f8-4272-ae10-090cc54eee43.png)'
- en: Example 2 – AbstractPlotting.jl ConversionTrait
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例 2 – AbstractPlotting.jl ConversionTrait
- en: '`AbstractPlotting.jl` is an abstract plotting library that is part of the Makie
    plotting system. The source code for this library can be found at [https://github.com/JuliaPlots/AbstractPlotting.jl](https://github.com/JuliaPlots/AbstractPlotting.jl).'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`AbstractPlotting.jl` 是一个抽象绘图库，它是 Makie 绘图系统的一部分。这个库的源代码可以在 [https://github.com/JuliaPlots/AbstractPlotting.jl](https://github.com/JuliaPlots/AbstractPlotting.jl)
    找到。'
- en: 'Let''s take a look at a trait that''s related to data conversion:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个与数据转换相关的特性：
- en: '[PRE25]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'It defines a `ConversionTrait` that can be used for the `convert_arguments`
    function. As it stands, the conversion logic can be applied to three different
    scenarios:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 它定义了一个 `ConversionTrait`，可以用于 `convert_arguments` 函数。目前，转换逻辑可以应用于三种不同的场景：
- en: No conversion. This is handled by the default trait type of `NoConversion`.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无转换。这由默认特质类型`NoConversion`处理。
- en: '`PointBased` conversion.'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`PointBased`转换。'
- en: '`SurfaceLike` conversion.'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SurfaceLike`转换。'
- en: 'By default, the `convert_arguments` function just returns the arguments untouched
    when conversion is not required:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`convert_arguments`函数在不需要转换时仅返回未更改的参数：
- en: '[PRE26]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then, various `convert_arguments` functions are defined. Here is the function
    for 2D plotting:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，定义了各种`convert_arguments`函数。以下是用于2D绘图的函数：
- en: '[PRE27]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Using the SimpleTraits.jl package
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SimpleTraits.jl包
- en: The `SimpleTraits.jl` package ([https://github.com/mauro3/SimpleTraits.jl](https://github.com/mauro3/SimpleTraits.jl))
    may be used to make programming traits a little easier.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`SimpleTraits.jl`包([https://github.com/mauro3/SimpleTraits.jl](https://github.com/mauro3/SimpleTraits.jl))可能被用来使编程特质变得更容易。'
- en: 'Let''s try to redo the `LiquidityStyle` example using SimpleTraits. First,
    define a trait called `IsLiquid`, as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用SimpleTraits重新做`LiquidityStyle`的例子。首先，定义一个名为`IsLiquid`的特质，如下所示：
- en: '[PRE28]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The syntax may look a little awkward since the `T` seems to be doing nothing,
    but it is actually required because the trait is applicable for a specific type
    `T`. The next thing is to assign types to this trait:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 语法可能看起来有点不自然，因为`T`似乎没有做什么，但实际上它是必需的，因为特质适用于特定的类型`T`。接下来，我们需要为此特质分配类型：
- en: '[PRE29]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then, a special syntax with four colons can be used to define functions that
    take objects exhibiting the trait:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，可以使用带有四个冒号的特殊语法来定义具有特质的对象的功能：
- en: '[PRE30]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The positive case has the argument annotated with `x::::IsLiquid`, while the
    negative case has the argument annotated with `x::::(!IsLiquid)`. Note that the
    parentheses is required so that the code can be parsed correctly. Now, we can
    test the functions as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 正例中，参数被注解为`x::::IsLiquid`，而负例中，参数被注解为`x::::(!IsLiquid)`。请注意，括号是必需的，这样代码才能被正确解析。现在，我们可以按照以下方式测试函数：
- en: '![](img/f2801aeb-d3fe-4f84-907b-2b8a47ea9993.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f2801aeb-d3fe-4f84-907b-2b8a47ea9993.png)'
- en: 'As expected, both default implementations throw an error. Now, we can implement
    the pricing function for `Stock` and quickly test again:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，两种默认实现都会抛出错误。现在，我们可以实现`Stock`的定价函数，并快速再次测试：
- en: '![](img/99c18709-dced-40da-9ebc-66a3cb818fe8.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](img/99c18709-dced-40da-9ebc-66a3cb818fe8.png)'
- en: '*Looks great!* As we can see, the `SimpleTrait.jl` package simplifies the process
    of creating traits.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '*看起来很棒!* 如我们所见，`SimpleTrait.jl`包简化了创建特质的流程。'
- en: Using traits can make your code more extendable. We must keep in mind, however,
    that it takes some effort to design proper traits. Documentation is also important
    so that anyone who wants to extend the code can understand how to utilize the
    predefined traits.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 使用特质可以使你的代码更具可扩展性。然而，我们必须记住，设计适当的特质需要一些努力。文档也同样重要，以便任何想要扩展代码的人都能理解如何利用预定义的特质。
- en: Next, we will go over parametric types, which are commonly used to extends data
    types easily.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论参数化类型，这是一种常用于轻松扩展数据类型的常用技术。
- en: The parametric type pattern
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参数化类型模式
- en: Parametric type is a core language feature that's used to materialize data types
    with parameters. It is a very powerful technique because the same object structure
    can be reused for different data types in its fields. In this section, we will
    demonstrate how parametric types can be applied effectively.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 参数化类型是核心语言特性，用于使用参数实现数据类型。这是一个非常强大的技术，因为相同的对象结构可以用于其字段中的不同数据类型。在本节中，我们将展示如何有效地应用参数化类型。
- en: When designing applications, we often create composite types to conveniently
    hold multiple field elements. In its simplest form, composite types only serve
    as the containers of fields. As we create more and more composite types, it may
    become clear that some of these types look almost the same. Furthermore, the functions
    that operate on these types may be very similar as well. We could end up with
    a lot of boilerplate code. Wouldn't it be cool to have a template that allows
    us to customize a general composite type for a specific use?
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计应用时，我们经常创建复合类型以方便地持有多个字段元素。在其最简单形式中，复合类型仅作为字段的容器。随着我们创建越来越多的复合类型，可能会变得明显，其中一些类型看起来几乎相同。此外，操作这些类型的函数可能也非常相似。我们可能会产生大量的样板代码。如果有一个模板允许我们为特定用途自定义通用复合类型会怎么样？
- en: 'Consider a trading application that supports buying and selling stocks. In
    the very first version, we may have the following design:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个支持买卖股票的交易应用。在最初的版本中，我们可能有以下设计：
- en: '![](img/d2beab74-e6a2-48d3-bde2-3ed1e8814cbd.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d2beab74-e6a2-48d3-bde2-3ed1e8814cbd.png)'
- en: Please beware that the notation in the preceding diagram may look a lot like **Unified
    Modeling Language** (**UML**). However, because Julia is not an object-oriented
    language, we may make certain exceptions when illustrating design concepts with
    these diagrams.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，前面图表中的符号可能看起来非常像**统一建模语言**（**UML**）。然而，由于Julia不是面向对象的语言，我们在用这些图表说明设计概念时可能会做出某些例外。
- en: 'The corresponding code is as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 相应的代码如下：
- en: '[PRE31]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The data types we defined in the preceding code are fairly straightforward.
    The `LongShort` enum type is used to indicate the direction of trade—buying stock
    would be long, while selling stock would be short. The `@enum` macro is conveniently
    used to define the `Long` and `Short` constants.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面代码中定义的数据类型相当直接。`LongShort`枚举类型用于指示交易方向——购买股票将是多头，而卖空股票将是空头。`@enum`宏方便地用于定义`Long`和`Short`常量。
- en: 'Now, suppose that we were asked to support stock options in our next version
    of the software. Naively, we could define more data types, as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们被要求在软件的下一个版本中支持股票期权。天真地，我们可以定义更多的数据类型，如下所示：
- en: '![](img/640576eb-5f4e-4893-b048-adb57d01372a.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/640576eb-5f4e-4893-b048-adb57d01372a.png)'
- en: 'The code is updated with additional data types, like so:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 代码已更新，添加了额外的数据类型，如下所示：
- en: '[PRE32]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'You might have noticed that the `StockTrade` and `StockOptionTrade` types are
    very similar. Such repetition is somewhat unsatisfying. It looks even worse when
    we define functions for these data types, as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到`StockTrade`和`StockOptionTrade`类型非常相似。这种重复多少有些令人不满意。当我们为这些数据类型定义函数时，看起来更糟糕，如下所示：
- en: '[PRE33]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Both the `sign` and `payment` methods are strikingly similar for both the `StockTrade`
    and `StockOptionTrade` types. Perhaps it isn't hard to imagine that this cannot
    scale very well when we add more tradable types to the application. There has
    to be a better way to do this. This is where the parametric type comes to the
    rescue!
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`StockTrade`和`StockOptionTrade`类型，`sign`和`payment`方法非常相似。也许不难想象，当我们向应用中添加更多可交易类型时，这并不能很好地扩展。我们必须有更好的方法来做这件事。这正是参数类型发挥作用的地方！
- en: Utilizing remove text parametric type for the stock trading app
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用去除文本参数类型为股票交易应用
- en: In the trading application we described previously, we could utilize parametric
    types to simplify the code and make it more reusable when adding future trading
    instruments.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前描述的交易应用中，我们可以利用参数类型简化代码，并在添加未来的交易工具时使其更具可重用性。
- en: It is quite clear that `SingleStockTrade` and `SingleStockOptionTrade` are almost
    the same. In fact, even the function definitions of `sign` and `payment` are identical.
    In this very simple example, we only have two functions for each type. In practice,
    we could have many more functions, and it would become quite messy.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，`SingleStockTrade`和`SingleStockOptionTrade`几乎相同。实际上，甚至`sign`和`payment`函数的定义也是相同的。在这个非常简单的例子中，我们只为每种类型有两个函数。在实践中，我们可能有更多的函数，这会变得相当混乱。
- en: Designing parametric types
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计参数类型
- en: 'To simplify this design, we can parameterize the type of the thing being traded.
    What is the thing? We can leverage the abstract type here. The supertype of `Stock`
    is `Equity`, while the supertype of `Equity` is `Investment`. Since we want to
    keep the code generic and buying/selling investment products is similar, we can
    choose to accept any type that is a subtype of `Investment`:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化这个设计，我们可以参数化所交易事物的类型。那是什么东西？我们可以在这里利用抽象类型。`Stock`的超类型是`Equity`，而`Equity`的超类型是`Investment`。由于我们希望保持代码通用，并且买卖投资产品是相似的，我们可以选择接受任何是`Investment`子类型的类型：
- en: '[PRE34]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, we have defined a new type called `SingleTrade`, where the underlying
    instrument has a type, `T`, where `T` can be any subtype of `Investment`. At this
    point, we can create trades with different kinds of instruments:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们定义了一个新的类型，称为`SingleTrade`，其中基础工具的类型为`T`，`T`可以是`Investment`的任何子类型。在这个时候，我们可以创建不同种类的交易：
- en: '![](img/a30de09b-b1ce-4663-9c3b-89c9da1cf202.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a30de09b-b1ce-4663-9c3b-89c9da1cf202.png)'
- en: 'These objects actually have different types—`SingleTrade{Stock}` and `SingleTrade{StockOption}`.
    How do they relate to each other? They are also subtypes of `SingleTrade`, as
    shown in the following screenshot:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这些对象实际上有不同的类型——`SingleTrade{Stock}`和`SingleTrade{StockOption}`。它们之间是如何关联的呢？它们也是`SingleTrade`的子类型，如下面的截图所示：
- en: '![](img/1814a36b-4c1d-4615-81c7-90376daa6655.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1814a36b-4c1d-4615-81c7-90376daa6655.png)'
- en: Since both types are subtypes of `SingleTrade`, this allows us to define functions
    that apply to both types, as we will see in the next section.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这两种类型都是`SingleTrade`的子类型，这允许我们定义适用于这两种类型的函数，正如我们将在下一节中看到的。
- en: Designing parametric methods
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计参数化方法
- en: 'In order to fully utilize the compiler''s specialization feature, we should
    define parametric methods that also make use of the parametric type, like so:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 为了充分利用编译器的特化功能，我们应该定义同时使用参数化类型的参数化方法，如下所示：
- en: '[PRE35]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Let''s test this out:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来测试一下：
- en: '![](img/b512eb66-22b2-4aee-8e1b-94ced5c18faa.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b512eb66-22b2-4aee-8e1b-94ced5c18faa.png)'
- en: 'But hey, we just found a little bug. The option of $3.50 seems too good to
    be true! When looking at buying/selling options, each option contract actually
    represents 100 shares of the underlying stock. Therefore, the payment amount for
    stock option trades needs to be multiplied by 100\. To fix this, we can just implement
    a more specific payment method:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，嘿，我们刚刚发现了一个小错误。3.50美元的期权看起来太好了，不像是真的！在查看买卖期权时，每个期权合约实际上代表100股基础股票。因此，股票期权交易的支付金额需要乘以100。为了修复这个问题，我们可以简单地实现一个更具体的支付方法：
- en: '[PRE36]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, we can test again. Due to this, the new method is only dispatched for
    option trades:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以再次测试。因此，新方法仅针对期权交易进行分发：
- en: '![](img/dc69da3d-b3d0-4159-975e-5494046a2ebf.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dc69da3d-b3d0-4159-975e-5494046a2ebf.png)'
- en: '*Voila! *Isn''t it beautiful? We will look at a more elaborate example in the
    next section.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '*哇！*这不是很美吗？我们将在下一节中看到一个更复杂的例子。'
- en: Using multiple parametric type arguments
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用多个参数化类型参数
- en: So far, we're quite happy with our refactoring. However, our boss just called
    and said we have to support *pair trading* in the next release. This new request
    is adding yet another twist to our design!
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们对重构相当满意。然而，我们的老板刚刚打电话来说，我们必须在下一个版本中支持*对冲交易*。这个新的请求又给我们的设计增添了另一个转折！
- en: Pair trading can be used to implement a specific trading strategy, such as market-neutral
    trades or option strategies such as covered calls.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 对冲交易可以用来实施特定的交易策略，例如市场中性交易或如保护性看涨期权等期权策略。
- en: '**Market neutral** trading involves buying one stock and short-selling another
    one at the same time. The idea is to neutralize the market''s effects so that
    the investor can focus on picking the stocks that over-perform or under-perform
    relative to their peers.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '**市场中性**交易涉及同时买入一只股票和卖空另一只股票。其理念是抵消市场的影响，以便投资者可以专注于挑选相对于同行表现优异或表现不佳的股票。'
- en: '**Covered call strategy** involves buying a stock but selling a call option
    that strikes at a higher price. This allows the investor to earn an additional
    premium in exchange for the limited upside potential of the underlying stock.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '**保护性看涨期权策略**涉及买入股票，但卖出执行价格更高的看涨期权。这允许投资者通过牺牲基础股票有限的上涨潜力来赚取额外的溢价。'
- en: 'This can be handled easily with parametric types. Let''s create a new type
    called `PairTrade`:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过参数化类型轻松处理。让我们创建一个新的类型，称为`PairTrade`：
- en: '[PRE37]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Note that the two legs from the trade can have different types, `T` and `S`,
    and that they can be any subtype of `Investment`. Because we expect every `Trade`
    type to support the `payment` function, we can implement this easily, as follows:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，交易的两侧可以具有不同的类型，`T`和`S`，并且它们可以是`Investment`的任何子类型。因为我们期望每个`Trade`类型都支持`payment`函数，所以我们可以轻松实现，如下所示：
- en: '[PRE38]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We can reuse the `stock` and `option` objects from the previous session and
    create a pair trade transaction where we buy 100 shares of the stock and sell
    1 option contract. The expected payment amount is $18,800 - $350 = $18,450:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以重用前一个会话中的`stock`和`option`对象，创建一个对冲交易交易，其中我们买入100股股票并卖出1份期权合约。预期的支付金额是$18,800
    - $350 = $18,450：
- en: '![](img/a4545117-e2e8-4181-bf90-ef8c216cbd6d.png)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a4545117-e2e8-4181-bf90-ef8c216cbd6d.png)'
- en: 'To appreciate how much parametric types simplified our design, imagine how
    many functions you would have to write if you had to create separate concrete
    types. In this example, since we have two possible trades in a pair trade transaction
    and each trade can be a stock trade or option trade, we have to support 2 x 2
    = 4 different scenarios:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 为了欣赏参数化类型如何简化我们的设计，想象一下，如果您必须创建单独的具体类型，您需要编写多少个函数。在这个例子中，由于对冲交易交易中存在两种可能的交易，并且每种交易可以是股票交易或期权交易，我们必须支持2
    x 2 = 4种不同的场景：
- en: '`payment(PairTradeWithStockAndStock)`'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`payment(PairTradeWithStockAndStock)`'
- en: '`payment(PairTradeWithStockAndStockOption)`'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`payment(PairTradeWithStockAndStockOption)`'
- en: '`payment(PairTradeWithStockOptionAndStock)`'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`payment(PairTradeWithStockOptionAndStock)`'
- en: '`payment(PairTradeWithStockOptionAndStockOption)`'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`payment(PairTradeWithStockOptionAndStockOption)`'
- en: Using parametric types, we only need a single payment function that covers all
    scenarios.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 使用参数化类型，我们只需要一个支付函数就可以涵盖所有场景。
- en: Real-life examples
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现实生活中的例子
- en: You can find the use of parametric types in almost any open source packages.
    Let's go over some examples.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 你几乎可以在任何开源包中找到参数化类型的使用。让我们来看一些例子。
- en: Example 1 – the ColorTypes.jl package
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例 1 – ColorTypes.jl 包
- en: '`ColorTypes.jl` is a package that defines various data types that represent
    colors. In practice, there are many ways in which a color can be defined: **Red-Green-Blue**
    (**RGB**), **Hue-Saturation-Value** (**HSV**), and so on. Most of the time, a
    color can be defined using three real numbers. In the case of grayscale, only
    a single number is required to represent the level of darkness. To support transparent
    colors, an additional value can be used to store an opacity value. First, let''s
    take a look at the type definitions:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`ColorTypes.jl` 是一个定义了表示颜色的各种数据类型的包。在实践中，定义颜色的方式有很多：**红-绿-蓝**（**RGB**）、**色调-饱和度-亮度**（**HSV**）等等。大多数情况下，可以使用三个实数来定义颜色。在灰度的情况下，只需要一个数字来表示暗度。为了支持透明颜色，可以使用额外的值来存储不透明度值。首先，让我们看看类型定义：'
- en: '[PRE39]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `Colorant{T,N}` type can represent all kinds of colors, with or without
    transparency. The `T` parameter represents the type of each individual value in
    the color definition; for example, Int, Float64, and so on. The `N` parameter
    represents the number of values in the color definition, which is usually three.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`Color{T,N}` 类型可以表示所有种类的颜色，包括透明和不透明的。`T` 参数代表颜色定义中每个单独值的类型；例如，Int, Float64
    等。`N` 参数代表颜色定义中的值数量，通常为三个。'
- en: '`Color{T,N}` is a subtype of `Colorant{T,N}` and represents non-transparent
    colors. Finally, `AbstractRGB{T}` is a subtype of `Color{T,N}`. Note that the
    `N` parameter is no longer needed as a parameter in `AbstractRGB{T}` because it
    is already defined with N=3\. Now, the concrete parametric type, `RGB{T}`, is
    defined as follows:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`Color{T,N}` 是 `Colorant{T,N}` 的子类型，代表非透明颜色。最后，`AbstractRGB{T}` 是 `Color{T,N}`
    的子类型。请注意，在 `AbstractRGB{T}` 中不再需要 `N` 参数，因为它已经定义为 N=3。现在，具体的参数化类型 `RGB{T}` 定义如下：'
- en: '[PRE40]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The definition of `RGB{T <: Fractional}` is fairly straightforward. It contains
    three values of type `T`, which can be a subtype of `Fractional`. Since the `Fractional`
    type is defined as a union of `AbstractFloat` and `FixedPoint`, the `r`, `g`,
    and `b` fields may be used as any subtype of `AbstractFloat`, such as `Float64`
    and `Float32`, or any of the `FixedPoint` number types.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`RGB{T <: Fractional}` 的定义相当直接。它包含三个类型为 `T` 的值，`T` 可以是 `Fractional` 的子类型。由于
    `Fractional` 类型定义为 `AbstractFloat` 和 `FixedPoint` 的并集，因此 `r`、`g` 和 `b` 字段可以用任何
    `AbstractFloat` 的子类型，如 `Float64` 和 `Float32`，或者任何 `FixedPoint` 数值类型。'
- en: '`FixedPoint` is a type that''s defined in the `FixedPointNumbers.jl` package.
    Fixed-point numbers is a different way to represent real numbers than the floating-point
    format. More information can be found at [https://github.com/JuliaMath/FixedPointNumbers.jl](https://github.com/JuliaMath/FixedPointNumbers.jl).'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`FixedPoint` 是在 `FixedPointNumbers.jl` 包中定义的类型。定点数是不同于浮点格式的表示实数的方式。更多信息可以在
    [https://github.com/JuliaMath/FixedPointNumbers.jl](https://github.com/JuliaMath/FixedPointNumbers.jl)
    找到。'
- en: If you examine the source code further, you will find that many types are defined
    in a similar fashion.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你进一步检查源代码，你会发现许多类型是以类似的方式定义的。
- en: Example 2 – the NamedDims.jl package
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例 2 – NamedDims.jl 包
- en: The `NamedDims.jl` package adds names to each dimension of a multi-dimensional
    array. The source code can be found at [https://github.com/invenia/NamedDims.jl](https://github.com/invenia/NamedDims.jl).
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`NamedDims.jl` 包为多维数组的每个维度添加了名称。源代码可以在 [https://github.com/invenia/NamedDims.jl](https://github.com/invenia/NamedDims.jl)
    找到。'
- en: 'Let''s take a look at the definition of `NamedDimsArray`:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `NamedDimsArray` 的定义：
- en: '[PRE41]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Don't be intimidated by the signature. It is actually quite straightforward.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 不要被签名吓倒。实际上它相当直接。
- en: '`NamedDimsArray` is a subtype of the abstract array type `AbstractArray{T,
    N}`. It only contains a single field, `data`, which keeps track of the underlying
    data. Because `T` and `N` are already parameters in `A`, they also need to be
    specified in the signature of `NamedDimsArray`. The `L` parameter is used to keep
    track of the names of the dimensions. Note that `L` is not used in any of the
    fields but that it is conveniently stored in the type signature itself.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`NamedDimsArray`是抽象数组类型`AbstractArray{T, N}`的子类型。它只包含一个字段，`data`，用于跟踪底层数据。因为`T`和`N`已经在`A`中作为参数，所以它们也需要在`NamedDimsArray`的签名中指定。`L`参数用于跟踪维度的名称。请注意，`L`在任何一个字段中都没有使用，但它方便地存储在类型签名本身中。'
- en: 'The primary constructor is defined as follows:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 主要构造函数定义如下：
- en: '[PRE42]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The function only needs to take an `AbstractArray{T,N}` that is an N-dimensional
    array with an element type of `T`. First, it checks if `L` contains a tuple of
    `N` symbols. Because type parameters are first-class, they can be examined in
    the body of the function. Assuming that `L` contains the right number of symbols,
    it just instantiates a `NamedDimsArray` using the known parameters `L`, `T`, `N`,
    as well as the type of the array argument.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数只需要一个`AbstractArray{T,N}`，它是一个具有元素类型`T`的N维数组。首先，它检查`L`是否包含一个包含`N`个符号的元组。因为类型参数是一等公民，所以可以在函数体中检查它们。假设`L`包含正确的符号数量，它只需使用已知的参数`L`、`T`、`N`以及数组参数的类型来实例化一个`NamedDimsArray`。
- en: 'It may be easier to see how it''s used, so let''s take a look:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 可能更容易看到它是如何使用的，让我们看一下：
- en: '![](img/73f8eff3-cf02-4877-a6b3-839f8bb81887.png)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/73f8eff3-cf02-4877-a6b3-839f8bb81887.png)'
- en: In the output, we can see that the type signature is `NamedDimsArray{(:x, :y),Int64,2,Array{Int64,2}}`.
    Matching this with the signature of the `NamedDimsArray` type, we can see that
    `L` is just the two-symbol tuple `(:x, :y)`, `T` is `Int64`, `N` is 2, and the
    underlying data is of the `Array{Int64, 2}` type.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出中，我们可以看到类型签名是`NamedDimsArray{(:x, :y),Int64,2,Array{Int64,2}}`。将其与`NamedDimsArray`类型的签名匹配，我们可以看到`L`是两个符号的元组`(:x,
    :y)`，`T`是`Int64`，`N`是2，底层数据是`Array{Int64, 2}`类型。
- en: 'Let''s take a look at the `dimnames` function, which is defined as follows:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`dimnames`函数，其定义如下：
- en: '[PRE43]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This function returns the dimensions tuple:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数返回维度元组：
- en: '![](img/2c6ddde2-b646-4361-9ea0-1edd673a4b03.png)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2c6ddde2-b646-4361-9ea0-1edd673a4b03.png)'
- en: 'Now, things are getting a little more interesting. What is `NamedDimsArray{L}`?
    Didn''t we need four parameters in this type? It is worth noting that a type such
    as `NamedDimsArray{L, T, N, A}` is actually a subtype of `NamedDimsArray{L}`.
    We can prove this as follows:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，事情变得有点更有趣了。`NamedDimsArray{L}`是什么？我们在这个类型中不是需要四个参数吗？值得注意的是，像`NamedDimsArray{L,
    T, N, A}`这样的类型实际上是`NamedDimsArray{L}`的子类型。我们可以如下证明这一点：
- en: '![](img/9706e903-e25c-4c50-95f5-9f7458cf079a.png)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9706e903-e25c-4c50-95f5-9f7458cf079a.png)'
- en: 'If we really want to see what `NamedDimsArray{L}` is, we can try the following:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们真的想了解`NamedDimsArray{L}`是什么，我们可以尝试以下方法：
- en: '![](img/9da06100-4702-4f92-a19c-01e6fe22b765.png)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9da06100-4702-4f92-a19c-01e6fe22b765.png)'
- en: What seems to be happening is that `NamedDimsArray{(:x, :y)}` is just shorthand
    for `NamedDimsArray{(:x, :y),T,N,A} where A<:AbstractArray{T,N} where N where
    T`. Because this is a more general type with three unknown parameters, we can
    see why `NamedDimsArray{(:x, :y),Int64,2,Array{Int64,2}}` is a subtype of `NamedDimsArray{(:x,
    :y)}`.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来正在发生的事情是`NamedDimsArray{(:x, :y)}`只是`NamedDimsArray{(:x, :y),T,N,A}`的简写，其中`A<:AbstractArray{T,N}`，`N`和`T`是未知的参数。因为这是一个具有三个未知参数的更一般类型，所以我们可以看到为什么`NamedDimsArray{(:x,
    :y),Int64,2,Array{Int64,2}}`是`NamedDimsArray{(:x, :y)}`的子类型。
- en: Using parametric types is very good if we wish to reuse functionalities. We
    can almost view each type parameter as a "dimension". When a parametric type has
    two type parameters, we would have many possible subtypes based upon various combinations
    of each type parameter.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望重用功能，使用参数化类型是非常好的。我们可以几乎将每个类型参数视为一个"维度"。当一个参数化类型有两个类型参数时，我们会根据每个类型参数的各种组合有许多可能的子类型。
- en: Summary
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have explored several patterns related to reusability. These
    patterns are highly valuable and can be utilized in many places within an application.
    In addition, people coming from an object-oriented background will probably find
    this chapter indispensable when it comes to designing Julia applications.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了与重用性相关的几个模式。这些模式非常有价值，可以在应用程序的许多地方使用。此外，来自面向对象背景的人可能会发现，在设计Julia应用程序时，这一章是不可或缺的。
- en: First, we went into great detail about the delegation pattern, which can be
    used to create new capabilities and lets us reuse functions from an existing object.
    The general technique involves defining a new data type that contains a parent
    object. Then, forwarding functions are defined so that we can reuse the functionalities
    of the parent object. We learned implementing delegation can be largely simplified
    by using `@forward`, which is provided by the `Lazy.jl` package.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们详细介绍了委派模式，它可以用来创建新的功能，并允许我们重用现有对象的功能。一般技术涉及定义一个新的数据类型，该类型包含一个父对象。然后，定义转发函数，以便我们可以重用父对象的功能。我们了解到通过使用由
    `Lazy.jl` 包提供的 `@forward`，可以大大简化实现委派。
- en: Then, we examined the holy trait pattern, which is a formal way to define the
    behavior of objects. The idea is to define traits as native types and utilize
    Julia's built-in dispatch mechanism to call the right method implementation. We
    realize that traits are useful in making the code more extensible. We also learned
    that macros from the `SimpleTraits.jl` package can make trait coding easier.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们研究了神圣的特质模式，这是一种正式定义对象行为的方式。其思路是将特质定义为原生类型，并利用 Julia 的内置调度机制来调用正确的方法实现。我们意识到特质在使代码更可扩展方面很有用。我们还了解到来自
    `SimpleTraits.jl` 包的宏可以使特质编码更容易。
- en: Finally, we looked into the parametric types pattern and how it can be utilized
    to simplify the design of code. We learned that parametric types can reduce the
    size of our code. We also saw that parameters can be used in the bodies of parametric
    functions.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们探讨了参数化类型模式及其如何被用来简化代码的设计。我们了解到参数化类型可以减小我们代码的大小。我们还看到参数可以在参数化函数的主体中使用。
- en: In the next chapter, we will discuss an important subject that attracts a lot
    of people to the Julia programming language – performance patterns!
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论一个吸引许多人学习 Julia 编程语言的重要主题——性能模式！
- en: Questions
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: How does the delegation pattern work?
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 委派模式是如何工作的？
- en: What is the purpose of traits?
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 特质的目的是什么？
- en: Are traits always binary?
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 特质总是二元的吗？
- en: Can traits be used for objects from a different type hierarchy?
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 特质能否用于不同类型层次的对象？
- en: What are the benefits of parametric types?
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 参数化类型的优点是什么？
- en: How do we store the information of a parametric type?
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何存储参数化类型的信息？
