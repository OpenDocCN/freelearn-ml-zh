- en: Reusability Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可复用性模式
- en: In this chapter, we will learn about several patterns related to software reusability.
    As you may recall from [Chapter 1](b33529b9-aabc-46cf-88eb-5d2ac885b732.xhtml), *Design
    Patterns and Related Principles*, reusability is one of the four software quality
    objectives that is required for building large-scale applications. Nobody wants
    to reinvent the wheel. The ability to reuse an existing software component saves
    both time and energy—an overall humanity gain! The patterns in this chapter are
    proven techniques that can help us improve application design, reuse existing
    code, and reduce overall code size.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习与软件可复用性相关的几种模式。如您从[第1章](b33529b9-aabc-46cf-88eb-5d2ac885b732.xhtml)，“设计模式及相关原则”中回忆起，可复用性是构建大型应用程序所需的四个软件质量目标之一。没有人愿意重新发明轮子。能够复用现有的软件组件可以节省时间和精力——这是一项整体的人类进步！本章中的模式是经过验证的技术，可以帮助我们改进应用程序设计，复用现有代码，并减少整体代码量。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: The delegation pattern
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 委派模式
- en: The holy traits pattern
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 神圣特质模式
- en: The parametric type pattern
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数化类型模式
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The sample source code for this chapter is located at [https://github.com/PacktPublishing/Hands-on-Design-Patterns-and-Best-Practices-with-Julia/tree/master/Chapter05](https://github.com/PacktPublishing/Hands-on-Design-Patterns-and-Best-Practices-with-Julia/tree/master/Chapter05).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例源代码位于[https://github.com/PacktPublishing/Hands-on-Design-Patterns-and-Best-Practices-with-Julia/tree/master/Chapter05](https://github.com/PacktPublishing/Hands-on-Design-Patterns-and-Best-Practices-with-Julia/tree/master/Chapter05)。
- en: The code in this chapter has been tested in a Julia 1.3.0 environment.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码已在 Julia 1.3.0 环境中进行了测试。
- en: The delegation pattern
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 委派模式
- en: Delegation is a pattern that is commonly applied in software engineering. The
    primary objective is to leverage the capabilities of an existing component by
    wrapping it via a *has-a* relationship.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 委派是一种在软件工程中常用的模式。其主要目标是利用现有组件的能力，通过“包含”关系对其进行包装。
- en: The delegation pattern is widely adopted, even in the object-oriented programming
    community. In the early days of object-oriented programming, people thought that
    code reuse could be achieved beautifully using inheritance. However, people came
    to realize that this promise couldn't be completely fulfilled due to a variety
    of issues related to inheritance. Since then, many software engineers prefer composition
    over inheritance. The concept of composition is to wrap one object within another.
    In order to reuse existing functions, we must delegate functions calls to the
    wrapped object. This section will explain how delegation can be implemented in
    Julia.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 委派模式在面向对象编程社区中得到广泛应用。在面向对象编程的早期，人们认为可以通过继承来实现代码复用。然而，人们逐渐意识到，由于继承存在各种问题，这一承诺无法完全实现。从那时起，许多软件工程师更倾向于使用组合而不是继承。组合的概念是将一个对象包装在另一个对象中。为了复用现有函数，我们必须将函数调用委托给包装对象。本节将解释如何在
    Julia 中实现委派。
- en: The concept of composition is to wrap one object within another. In order to
    reuse existing functions, we must delegate functions calls to the wrapped object.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 组合的概念是将一个对象包装在另一个对象中。为了复用现有函数，我们必须将函数调用委托给包装对象。
- en: 'One way is to enhance an existing component with new features. This may sound
    good, but it could be challenging in practice. Consider the following situations:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方法是通过添加新功能来增强现有组件。这听起来不错，但在实践中可能会具有挑战性。 考虑以下情况：
- en: The existing component comes from a vendor product and the source code is not
    available. Even if the code is available, the vendor's license may not allow us
    to make custom changes.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现有的组件来自供应商产品，源代码不可用。即使代码可用，供应商的许可证可能不允许我们进行自定义更改。
- en: The existing component is developed and used by another team for a mission-critical
    system and changes are neither welcome nor applicable for that system.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现有的组件是由另一个团队为关键任务系统开发和使用的，对该系统来说，更改既不受欢迎也不适用。
- en: The existing component contains a lot of legacy code and new changes may compromise
    the component's stability and require a lot of testing effort.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现有的组件包含大量遗留代码，新的更改可能会影响组件的稳定性，并需要大量的测试工作。
- en: If modifying an existing component's source code is not an option, then we should
    at least be able to use the component via its published programming interface.
    That is the virtue of the delegation pattern.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Applying the delegation pattern to a banking use case
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The delegation pattern is the idea of creating a new object by wrapping an existing
    one called the *parent* object. In order to reuse the object's features, the functions
    that have been defined for the new object can be delegated (also known as forwarded)
    to the parent.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Suppose that we have access to a banking library that provides some basic account
    management functionality. To understand how it works, let's take a look at the
    source code.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: 'A bank account has been designed with the following mutable data structure:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As part of the programming interface, the library also provides the field accessors
    (see [Chapter 8](6b565339-641f-444c-ad42-f8ff7998001b.xhtml), *Robustness Patterns*)
    and functions for making deposits, withdrawals, and transfers, as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Of course, in practice, such a banking library has to be a lot more complex
    than what is seen here. I suspect that when money goes in and out of a bank account,
    there are many downstream effects such as logging an audit trail, making the new
    balance available on a website, sending emails to the customer, and so on.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Let's move on and learn how we can utilize the delegation pattern.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Composing a new type that contains an existing type
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As part of a new initiative, the bank wants us to support a new savings account
    product, which provides daily interest for customers. Since the existing account
    management's functionality is critical to the bank's business and is maintained
    by a different team, we have decided to reuse its functionality without touching
    any of the existing source code.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s create our own `SavingsAccount` data type, as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The first field, `acct`, is used to hold an `Account` object, while the second
    field, `interest_rate`, contains the interest rate per annum for the account.
    A constructor is also defined to instantiate the object.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to use the underlying `Account` object, we can use a technique called
    *Delegation*, or *Method Forwarding*. This is where we implement the same API
    in `SavingsAccount` and forward the call to the underlying `Account` object whenever
    we want to reuse the existing functions from the underlying object. In this case,
    we can just forward all the field accessor functions and mutating functions from
    the `Account` object, as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'So far, we have successfully reused the `Account` data type, but let''s not
    forget that we actually want to build new features in the first place. A savings
    account should accrue interest overnight on a daily basis. So, for the `SavingsAccount`
    object, we can implement a new accessor for the `interest_rate` field and a new
    mutating function called `accrue_daily_interest!`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: At this time, we have created a new `SavingsAccount` object that works just
    like the original `Account` object, except it has the additional capability of
    accruing interest!
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: However, the sheer volume of these forwarding methods makes us feel a little
    unsatisfied. It would be nice if we didn't have to write all this code manually.
    Perhaps there's a better way...
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Reducing boilerplate code for forwarding methods
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may wonder how it would ever be worth the effort to write so much code just
    to forward the method calls to the parent object. Indeed, the forwarding methods
    serve no purpose other than passing the exact same arguments to the parent. If
    programmers were paid by lines of code, then this would be quite an expensive
    proposition, wouldn't it?
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, this kind of boilerplate code can be reduced greatly using macros.
    There are several open source solutions that can help with this situation. For
    demonstration purposes, we can utilize the `@forward` macro from the `Lazy.jl`
    package. Let''s replace all the forwarding methods, as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The usage of `@forward` is fairly straightforward. It takes two expressions
    as arguments. The first argument is the `SavingsAccount.acct` object that you
    want to forward to, while the second argument is just a tuple of function names
    that you wish to forward to, for example, `account_number`, `balance`, and `date_opened`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Note that we are able to forward mutating functions such as `deposit!` and `withdraw!`,
    but we cannot do the same for `transfer!`. This is because `transfer!` requires
    that we forward its first and second arguments. In this case, we just keep the
    manual forwarding method. Nevertheless, we were able to forward five out of the
    six functions using just two lines of code. It's still a pretty good deal!
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: It would be possible to make more forwarding macros that take two or three arguments.
    In fact, there are other open source packages that support such scenarios, such
    as the `TypedDelegation.jl` package.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: 'So, how does the `@forward` macro work? We can examine how the code gets expanded
    using the `@macroexpand` macro. The following is the result of the line number
    nodes being removed. Basically, for each method that is being forwarded (`balance`
    and `deposit!`), it creates the corresponding function definition with all the
    arguments splatted with the `args...` notation. It also throws in an `@inline` node
    to give the compiler a hint for better performance:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/88ad9266-859f-4b4d-933f-c516b8314b11.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
- en: Inlining is a compiler optimization where a function call is *inlined* as if
    the code had been interpolated into the current code. It may improve performance
    by reducing the overhead of allocating a call stack when functions are called
    repeatedly.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: The `@forward` macro was implemented with only a few lines of code. You are
    encouraged to take a look at the source code if you are interested in metaprogramming.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: You might be wondering why there are several funny variable names such as `#41#x`
    or `#42#args`. We can treat those as if they are normal variables. They are automatically
    generated by the compiler, and their special naming convention is chosen to avoid
    conflicts with other variables in the current scope.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Finally, it is important to understand that we may not always want to forward
    all the function calls to the object. What if we don't want to use 100% of the
    underlying features? Believe it or not, there are cases like that. For example,
    let's imagine that we have to support another kind of account, such as a certificate
    of deposits, also known as CDs. A CD is a short-term investment product that pays
    a higher interest than a savings account, but the funds cannot be withdrawn during
    the term of investment. Generally, the term of a CD could be 3 months, 6 months,
    or longer. Going back to our code, if we create a new `CertificateOfDepositAccount` object
    and reuse the `Account` object again, we wouldn't want to forward the `withdraw!` and
    `transfer!` methods because they are not features of CDs.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: You might wonder how delegation differs from class inheritance in object-oriented
    programming languages. For example, in the Java language, all the public and protected
    methods from the parent class are inherited automatically. This is analogous to
    auto-forwarding all the methods from the parent class.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: The inability to choose what to inherit is actually one of the reasons why delegation
    is preferred over inheritance. For a more in-depth discussion, see [Chapter 12](97049a94-ad30-452a-bbb0-296d9438c886.xhtml), *Inheritance
    and Variance*.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing some real-life examples
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The delegation pattern is used extensively in open source packages. For example,
    many packages in the JuliaArrays GitHub organization implement the `AbstractArray`
    interface. The special array types usually contain a regular `AbstractArray` object.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: Example 1 – the OffsetArrays.jl package
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `OffsetArrays.jl` package allows us to define arrays with arbitrary indices
    rather than the standard linear or cartesian style indices. A fun example is to
    use a zero-based array, just like the ones you may find in other programming languages:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5a5a0185-28a8-431b-9b7c-ebc902f501f5.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
- en: 'To understand how this works, we need to dig into the source code. Let''s keep
    things concise and review just a portion of the code:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `OffsetArray` data type is composed of the `parent` and `offsets` fields.
    In order to satisfy the `AbstractArray` interface, it implements some of the basic
    functions, such as `Base.size`, `Base.eachindex`, and so on. Since these functions
    are simple enough, the code just forwards the call to the parent object manually.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: Example 2 – the ScikitLearn.jl package
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's also take a look at the `ScikitLearn.jl` package, which defines a consistent
    API for fitting machine learning models and doing prediction.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is how the `FitBit` type is defined:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here, we can see that the `FitBit` object contains a `model` object and that
    it adds a new functionality that keeps track of whether a model has been fitted
    or not:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: It uses the `@forward` macro to delegate all the major functions, that is, `transform`,
    `predict`, and so on.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Considerations
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You should keep in mind that the delegation pattern introduces a new level of
    indirection, which can increase code complexity and make the code more difficult
    to understand. We should consider some factors when deciding to use the delegation
    pattern.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: First, how much code can you reuse from the existing component? Is it 20%, 50%,
    or 80%? This ought to be the very first question you ask before you consider reusing
    an existing component. Let's call the amount of reuse the utilization rate. Obviously,
    the higher the utilization rate, the better it is from a reuse perspective.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Second, how much development effort can be saved by reusing an existing component? If
    the cost of developing the same functionality is low, then it may not be worth
    the effort to reuse the component and increase the complexity of extra indirection.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: From the opposite angle, we should also review if there is any critical business
    logic in the existing component. If we decide to not reuse the component, then
    we could end up implementing the same logic again, violating the **Don't Repeat
    Yourself** (**DRY**) principle. This means it can be a maintenance nightmare to
    not reuse the component.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: Given these considerations, we should just to make a good judgment about using
    the delegation pattern or not.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will learn how to implement traits in Julia.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: The holy traits pattern
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The holy traits pattern has an interesting name. Some people also call it the **Tim
    Holy Traits Trick** (**THTT**). As you might have guessed the pattern is named
    after Tim Holy, who is a long-time contributor to the Julia language and ecosystem.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: What are traits? In a nutshell, a trait corresponds to the behavior of an object.
    For example, birds and butterflies can fly, so they both have the *CanFly* trait.
    Dolphins and turtles can swim, so they both have the *CanSwim* trait. A duck can
    fly and swim, so it has both the *CanFly* and *CanSwim* traits. Traits are typically
    binary – you either exhibit the trait or not – although that is not a mandatory
    requirement.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Why do we want traits? Traits can be used as a formal contract about how a data
    type can be used. For example, if an object has the *CanFly* trait, then we would
    be quite confident that the object has some kind of *fly* method defined. Likewise,
    if an object has the *CanSwim* trait, then we can probably call some kind of *swim*
    function.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: Let's get back to programming. The Julia language doesn't have any built-in
    support for traits. However, the language is versatile enough for developers to
    use traits with the help of the multiple dispatch system. In this section, we
    will look into how this can be done with the special technique known as holy traits.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Revisiting the personal asset management use case
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新审视个人资产管理用例
- en: When designing reusable software, we often create abstractions as data types
    and associate behaviors with them. One way to model behaviors is to leverage a
    type hierarchy. Following the Liskov Substitution Principle, we should be able
    to substitute a type with a subtype when a function is called.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当设计可重用软件时，我们经常创建抽象的数据类型并将行为与之关联。建模行为的一种方式是利用类型层次结构。遵循Liskov替换原则，当调用函数时，我们应该能够用子类型替换类型。
- en: 'Let''s revisit the abstract type hierarchy of managing personal assets from [Chapter
    2](48061f6f-db77-4db6-9c92-d7550f4317fe.xhtml), *Modules, Packages, and Type Concepts*:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下从[第2章](48061f6f-db77-4db6-9c92-d7550f4317fe.xhtml)，*模块、包和类型概念*中管理个人资产的高级类型层次结构：
- en: '![](img/70edf4cf-52b8-4465-befc-a192a4e5473e.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/70edf4cf-52b8-4465-befc-a192a4e5473e.png)'
- en: We can define a function called `value` for determining the value of any asset.
    Such a function can be applied to all the types in the `Asset` hierarchy if we
    assume that all the asset types have some kind of monetary value attached to them.
    Following that line of thought, we can say that almost every asset exhibits the
    *HasValue* trait.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以定义一个名为`value`的函数，用于确定任何资产的价值。如果我们假设所有资产类型都附带有某种货币价值，那么这个函数可以应用于`Asset`层次结构中的所有类型。沿着这条思路，我们可以说几乎每种资产都表现出*HasValue*特质。
- en: Sometimes, behaviors can only be applied to certain types in the hierarchy.
    For example, what if we want to define a `trade` function that only works with
    liquid investments? In that case, we would define `trade` functions for `Investment`
    and `Cash` but not for `House` and `Apartments`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，行为只能应用于层次结构中的某些类型。例如，如果我们想定义一个只与流动投资一起工作的`trade`函数怎么办？在这种情况下，我们会为`Investment`和`Cash`定义`trade`函数，但不会为`House`和`Apartments`定义。
- en: A liquid investment refers to a security instrument that can be traded easily
    in the open market. The investor can quickly convert a liquid instrument into
    cash and vice versa. In general, most investors would like a portion of their
    investment to be liquid in the case of an emergency.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 流动投资是指可以在公开市场上轻松交易的证券工具。投资者可以快速将流动工具转换为现金，反之亦然。一般来说，大多数投资者在紧急情况下都希望他们的投资中有一部分是流动的。
- en: Investments that are not liquid are called illiquid.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 非流动的投资被称为非流动资产。
- en: 'Programmatically, how do we know which asset types are liquid? One way is to
    check the type of the object against a list of types that represent liquid investments. Suppose
    that we have an array of assets and need to find out which one can be traded quickly
    for cash. In this situation, the code may look something like this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 编程上，我们如何知道哪些资产类型是流动的？一种方法是将对象类型与表示流动投资的类型列表进行比较。假设我们有一个资产数组，需要找出哪一个可以快速兑换成现金。在这种情况下，代码可能看起来像这样：
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `if` condition in the preceding code is a bit ugly, even in this toy example.
    If we have more types in the condition, then it gets worse. Of course, we can
    create a union type to make it a little better:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码中的`if`条件有点丑陋，即使是这个玩具示例也是如此。如果我们有更多类型的条件，那么它会更糟。当然，我们可以创建一个联合类型来让它变得稍微好一些：
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'There are a few issues with this approach:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法有几个问题：
- en: The union type has to be updated whenever we add a new liquid asset type. This
    kind of maintenance is bad from a design perspective because the programmer must
    remember to update this union type whenever a new type is added to the system.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每当我们添加一个新的流动资产类型时，联合类型必须更新。从设计角度来看，这种维护是糟糕的，因为程序员必须记住在向系统中添加新类型时更新这个联合类型。
- en: This union type is not available for extension. If other developers want to
    reuse our trading library, then they may want to add new asset types. However,
    they cannot change our definition of the union type because they do not own the
    source code.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个联合类型不可扩展。如果其他开发者想重用我们的交易库，他们可能想添加新的资产类型。然而，他们不能更改我们的联合类型定义，因为他们没有源代码。
- en: The if-then-else logic may be repeated in many places in our source, whenever
    we need to do things differently for liquid and illiquid assets.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果-否则逻辑可能在我们的源代码的许多地方重复出现，每当我们需要对流动资产和非流动资产执行不同的操作时。
- en: These problems can be solved using the holy traits pattern.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题可以使用神圣特质模式来解决。
- en: Implementing the holy traits pattern
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现神圣特质模式
- en: 'To illustrate the concept of this pattern, we will implement some functions
    for the personal asset data types that we developed in [Chapter 2](48061f6f-db77-4db6-9c92-d7550f4317fe.xhtml), *Modules,
    Packages, and Data Type Concepts*. As you may recall, the abstract types for the
    asset type hierarchy are defined as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `Asset` type is at the top of the hierarchy and has the `Property`, `Investment`,
    and `Cash` subtypes. At the next level, `House` and `Apartment` are subtypes of
    `Property`, while `FixedIncome` and `Equity` are subtypes of `Investment`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s define some concrete types:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'What do we have here? Let''s take a look at these concepts in more detail:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: A `Residence` is a house that someone lives in and has a location.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `Stock` is an equity investment, and it is identified by a trading symbol
    and the name of the company.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `TreasuryBill` is a short-term government-issued form of security in the United
    States, and it is defined with a standard identifier called CUSIP.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Money` is just cash, but we want to store the currency and respective amount
    here.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that we have not annotated the types for the fields because they aren't
    important for illustrating the trait concept here.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: Defining the trait type
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When it comes to investments, we can distinguish between ones that can be sold
    for cash easily in the open market and ones that take considerably more effort
    and time to convert into cash. Things that can easily be converted into cash within
    several days are known as being *liquid*, while the hard-to-sell ones are known
    as being *illiquid*. For example, stocks are liquid while a residence is not.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we want to do is define the traits themselves:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Traits are nothing but data types in Julia! The overall concept of the `LiquidityStyle` trait
    is that it's an abstract type. The specific traits here, `IsLiquid` and `IsIlliquid`,
    have been set up as concrete types without any fields.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: There is no standard naming convention for traits, but my research seems to
    indicate that package authors tend to use either `Style` or `Trait` as the suffix
    for trait types.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Identifying traits
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next step is to assign data types to these traits. Conveniently, Julia
    allows us to bulk-assign traits to an entire subtype tree using the `<:` operator
    in the function signature:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let''s take a look at how we can interpret these three lines of code:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: We have chosen to make all the types illiquid by default. Note that we could
    have done this the other way around and made everything liquid by default. This
    decision is arbitrary and depends on the specific use case.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have chosen to make all the subtypes of `Cash` liquid, which includes the
    concrete `Money` type. The notation of `::Type{<:Cash}` indicates all the subtypes
    of `Cash`.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have chosen to make all the subtypes of `Investment` liquid. This includes
    all the subtypes of `FixedIncome` and `Equity`, which covers `Stock` in this example.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You might be wondering why we don''t take `::Type{<: Asset}` as an argument
    for the default trait function. Doing so makes it more restrictive as the default
    value would only be available for types that are defined under the `Asset` type
    hierarchy. This may or may not be desirable, depending on how the trait is used.
    Either way should be fine.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '你可能想知道为什么我们不将`::Type{<: Asset}`作为默认特性函数的参数。这样做使得它更加限制性，因为默认值只适用于在`Asset`类型层次结构下定义的类型。这可能是或可能不是所希望的，这取决于特性是如何使用的。无论如何都应该是可以的。'
- en: Implementing trait behavior
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现特性行为
- en: 'Now that we can tell which types are liquid and which are not, we can define
    methods that take objects with those traits. First, let''s do something really
    simple:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够判断哪些类型是流动的，哪些不是，我们可以定义接受具有这些特性的对象的方法。首先，让我们做一些非常简单的事情：
- en: '[PRE15]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In Julia, types are first-class citizens. The `tradable(x::T) where {T}` signature
    captures the type of argument as `T`. Since we have already defined the `LiquidityStyle`
    function, we can derive whether the passed argument exhibits the `IsLiquid` or
    `IsIlliquid` trait. So, the first `tradable` method simply takes the return value
    of `LiquidityStyle(T)` and passes it as the first argument for the other two `tradable`
    methods. This simple example demonstrates the dispatch effect.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在Julia中，类型是一等公民。`tradable(x::T) where {T}`签名捕获了参数的类型作为`T`。由于我们已定义了`LiquidityStyle`函数，我们可以推导出传递的参数是否表现出`IsLiquid`或`IsIlliquid`特性。因此，第一个`tradable`方法只是接受`LiquidityStyle(T)`的返回值，并将其作为其他两个`tradable`方法的第一个参数传递。这个简单的例子展示了派发效应。
- en: 'Now, let''s look at a more interesting function that exploits the same trait.
    Since liquid assets are easily tradable in the market, we should be able to discover
    their market price quickly as well. For stocks, we may call a pricing service
    from the stock exchange. For cash, the market price is just the currency amount.
    Let''s see how this is coded:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看一个更有趣的函数，它利用了相同的特性。由于流动性资产在市场上很容易交易，我们应该能够快速发现它们的市场价格。对于股票，我们可以从证券交易所调用定价服务。对于现金，市场价格只是货币金额。让我们看看这是如何编码的：
- en: '[PRE16]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The code''s structure is the same as the `tradable` function. One method is
    used to determine the trait, while the other two methods implement different behaviors
    for the liquid and illiquid instruments. Here, both `marketprice` functions just
    raise an exception by calling the error function. Of course, that''s not what
    we really want. What we should really have is a specific pricing function for
    the `Stock` and `Money` types. Okay; let''s do just that:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的结构与`tradable`函数相同。一个方法用于确定特性，而另外两个方法为流动性和非流动性工具实现不同的行为。在这里，两个`marketprice`函数只是通过调用错误函数来抛出异常。当然，这并不是我们真正想要的。我们真正想要的应该是一个针对`Stock`和`Money`类型的特定定价函数。好的；让我们就这样做：
- en: '[PRE17]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, the `marketprice` method for the `Money` type just returns the amount.
    This is quite a simplification since, in practice, we may calculate the amount
    in the local currency (for example, US Dollars) from the currency and amount.
    As for `Stock`, we just return a random number for the purpose of testing. In
    reality, we would have attached this function to a stock pricing service.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`Money`类型的`marketprice`方法只是返回金额。这在实践中是一种相当简化的做法，因为我们可能需要从货币和金额中计算出当地货币（例如，美元）的金额。至于`Stock`，我们只是为了测试目的返回一个随机数。在现实中，我们会将这个函数附加到一个股票定价服务上。
- en: 'For illustration purposes, we have developed the following test functions:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明目的，我们开发了以下测试函数：
- en: '[PRE18]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here''s the result from the Julia REPL:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Julia REPL的结果：
- en: '![](img/6a259e07-c52c-4a71-a10a-c2ad9bf7c6ff.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6a259e07-c52c-4a71-a10a-c2ad9bf7c6ff.png)'
- en: '*Perfect!* The `tradable` function has correctly identified that cash, stock,
    and bond are liquid and that residence is illiquid. For cash and stocks, the `marketprice`
    function was able to return a value, as expected. Because residence is not liquid,
    an error was raised. Finally, while treasury bills are liquid, an error was raised
    because the `marketprice` function has not been defined for the instrument.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '*完美！* `tradable`函数正确地识别出现金、股票和债券是流动的，而住宅是非流动的。对于现金和股票，`marketprice`函数能够返回预期的值。因为住宅不是流动的，所以抛出了一个错误。最后，虽然国库券是流动的，但由于`marketprice`函数尚未定义该工具，所以抛出了一个错误。'
- en: Using traits with a different type of hierarchy
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用具有不同类型层次结构的特性
- en: 'The best part of the holy trait pattern is that we can use it with any object,
    even when its type belongs to a different abstract type hierarchy. Let''s explore
    the case of literature, where we may define its own type hierarchy as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, we can make it obey the `LiquidityStyle` trait, as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now, we can trade books, just like other tradable assets.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing some common usages
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The holy traits pattern is commonly used in open source packages. Let's take
    a look at some examples.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Example 1 – Base.IteratorSize
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Julia Base library uses traits quite extensively. An example of such a
    trait is `Base.IteratorSize`. Its definition can be found using `generator.jl`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This trait is slightly different from what we have learned about so far because
    it is not binary. The `IteratorSize` trait can be `SizeUnknown`, `HasLength`,
    `HasShape{N}`, or `IsInfinite`. The `IteratorSize` function is defined as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let''s focus on the `IsInfinite` trait since it looks quite interesting. A
    few functions have been defined in `Base.Iterators` that generate infinite sequences.
    For example, the `Iterators.repeated` function can be used to generate the same
    value forever, and we can use the `Iterators.take` function to pick up the values
    from the sequence. Let''s see how this works:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6815ffba-683e-498d-ac76-7a51a6bcf17d.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
- en: 'If you look at the source code, you''ll see that `Repeated` is the type of
    the iterator and that it is assigned the `IteratorSize` trait with `IsInfinite`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We can quickly test it out like so:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dc4235c2-b523-405d-92f7-dc03defe94b1.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
- en: '*Voila!* It is infinite, just as we expected! But how is this trait utilized?
    To find out how, we can look into the `BitArray` from the Base library, which
    is a space-efficient Boolean array implementation. Its constructor function can
    take any iterable object, such as an array:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/767f0b76-afa1-486f-a216-879594fe2b43.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
- en: 'Perhaps it isn''t hard to understand that the constructor can''t really work
    with something that is infinite in nature! Therefore, the implementation of the `BitArray` constructor
    has to take that into account. Because we can dispatch based upon the `IteratorSize` trait,
    the constructor of `BitArray` happily throws an exception when such an iterator
    is passed:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To see it in action, we can call the `BitArray` constructor with the `Repeated`
    iterator, like so:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ed1237a4-d2f8-4272-ae10-090cc54eee43.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
- en: Example 2 – AbstractPlotting.jl ConversionTrait
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`AbstractPlotting.jl` is an abstract plotting library that is part of the Makie
    plotting system. The source code for this library can be found at [https://github.com/JuliaPlots/AbstractPlotting.jl](https://github.com/JuliaPlots/AbstractPlotting.jl).'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at a trait that''s related to data conversion:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'It defines a `ConversionTrait` that can be used for the `convert_arguments`
    function. As it stands, the conversion logic can be applied to three different
    scenarios:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: No conversion. This is handled by the default trait type of `NoConversion`.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`PointBased` conversion.'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`SurfaceLike` conversion.'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'By default, the `convert_arguments` function just returns the arguments untouched
    when conversion is not required:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then, various `convert_arguments` functions are defined. Here is the function
    for 2D plotting:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Using the SimpleTraits.jl package
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `SimpleTraits.jl` package ([https://github.com/mauro3/SimpleTraits.jl](https://github.com/mauro3/SimpleTraits.jl))
    may be used to make programming traits a little easier.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try to redo the `LiquidityStyle` example using SimpleTraits. First,
    define a trait called `IsLiquid`, as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The syntax may look a little awkward since the `T` seems to be doing nothing,
    but it is actually required because the trait is applicable for a specific type
    `T`. The next thing is to assign types to this trait:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then, a special syntax with four colons can be used to define functions that
    take objects exhibiting the trait:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The positive case has the argument annotated with `x::::IsLiquid`, while the
    negative case has the argument annotated with `x::::(!IsLiquid)`. Note that the
    parentheses is required so that the code can be parsed correctly. Now, we can
    test the functions as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f2801aeb-d3fe-4f84-907b-2b8a47ea9993.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
- en: 'As expected, both default implementations throw an error. Now, we can implement
    the pricing function for `Stock` and quickly test again:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/99c18709-dced-40da-9ebc-66a3cb818fe8.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
- en: '*Looks great!* As we can see, the `SimpleTrait.jl` package simplifies the process
    of creating traits.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Using traits can make your code more extendable. We must keep in mind, however,
    that it takes some effort to design proper traits. Documentation is also important
    so that anyone who wants to extend the code can understand how to utilize the
    predefined traits.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will go over parametric types, which are commonly used to extends data
    types easily.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: The parametric type pattern
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Parametric type is a core language feature that's used to materialize data types
    with parameters. It is a very powerful technique because the same object structure
    can be reused for different data types in its fields. In this section, we will
    demonstrate how parametric types can be applied effectively.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: When designing applications, we often create composite types to conveniently
    hold multiple field elements. In its simplest form, composite types only serve
    as the containers of fields. As we create more and more composite types, it may
    become clear that some of these types look almost the same. Furthermore, the functions
    that operate on these types may be very similar as well. We could end up with
    a lot of boilerplate code. Wouldn't it be cool to have a template that allows
    us to customize a general composite type for a specific use?
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider a trading application that supports buying and selling stocks. In
    the very first version, we may have the following design:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d2beab74-e6a2-48d3-bde2-3ed1e8814cbd.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
- en: Please beware that the notation in the preceding diagram may look a lot like **Unified
    Modeling Language** (**UML**). However, because Julia is not an object-oriented
    language, we may make certain exceptions when illustrating design concepts with
    these diagrams.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: 'The corresponding code is as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The data types we defined in the preceding code are fairly straightforward.
    The `LongShort` enum type is used to indicate the direction of trade—buying stock
    would be long, while selling stock would be short. The `@enum` macro is conveniently
    used to define the `Long` and `Short` constants.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, suppose that we were asked to support stock options in our next version
    of the software. Naively, we could define more data types, as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/640576eb-5f4e-4893-b048-adb57d01372a.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
- en: 'The code is updated with additional data types, like so:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'You might have noticed that the `StockTrade` and `StockOptionTrade` types are
    very similar. Such repetition is somewhat unsatisfying. It looks even worse when
    we define functions for these data types, as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Both the `sign` and `payment` methods are strikingly similar for both the `StockTrade`
    and `StockOptionTrade` types. Perhaps it isn't hard to imagine that this cannot
    scale very well when we add more tradable types to the application. There has
    to be a better way to do this. This is where the parametric type comes to the
    rescue!
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing remove text parametric type for the stock trading app
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the trading application we described previously, we could utilize parametric
    types to simplify the code and make it more reusable when adding future trading
    instruments.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: It is quite clear that `SingleStockTrade` and `SingleStockOptionTrade` are almost
    the same. In fact, even the function definitions of `sign` and `payment` are identical.
    In this very simple example, we only have two functions for each type. In practice,
    we could have many more functions, and it would become quite messy.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Designing parametric types
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To simplify this design, we can parameterize the type of the thing being traded.
    What is the thing? We can leverage the abstract type here. The supertype of `Stock`
    is `Equity`, while the supertype of `Equity` is `Investment`. Since we want to
    keep the code generic and buying/selling investment products is similar, we can
    choose to accept any type that is a subtype of `Investment`:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, we have defined a new type called `SingleTrade`, where the underlying
    instrument has a type, `T`, where `T` can be any subtype of `Investment`. At this
    point, we can create trades with different kinds of instruments:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a30de09b-b1ce-4663-9c3b-89c9da1cf202.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
- en: 'These objects actually have different types—`SingleTrade{Stock}` and `SingleTrade{StockOption}`.
    How do they relate to each other? They are also subtypes of `SingleTrade`, as
    shown in the following screenshot:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1814a36b-4c1d-4615-81c7-90376daa6655.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
- en: Since both types are subtypes of `SingleTrade`, this allows us to define functions
    that apply to both types, as we will see in the next section.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Designing parametric methods
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to fully utilize the compiler''s specialization feature, we should
    define parametric methods that also make use of the parametric type, like so:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Let''s test this out:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b512eb66-22b2-4aee-8e1b-94ced5c18faa.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
- en: 'But hey, we just found a little bug. The option of $3.50 seems too good to
    be true! When looking at buying/selling options, each option contract actually
    represents 100 shares of the underlying stock. Therefore, the payment amount for
    stock option trades needs to be multiplied by 100\. To fix this, we can just implement
    a more specific payment method:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, we can test again. Due to this, the new method is only dispatched for
    option trades:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dc69da3d-b3d0-4159-975e-5494046a2ebf.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
- en: '*Voila! *Isn''t it beautiful? We will look at a more elaborate example in the
    next section.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: Using multiple parametric type arguments
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we're quite happy with our refactoring. However, our boss just called
    and said we have to support *pair trading* in the next release. This new request
    is adding yet another twist to our design!
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: Pair trading can be used to implement a specific trading strategy, such as market-neutral
    trades or option strategies such as covered calls.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '**Market neutral** trading involves buying one stock and short-selling another
    one at the same time. The idea is to neutralize the market''s effects so that
    the investor can focus on picking the stocks that over-perform or under-perform
    relative to their peers.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '**Covered call strategy** involves buying a stock but selling a call option
    that strikes at a higher price. This allows the investor to earn an additional
    premium in exchange for the limited upside potential of the underlying stock.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be handled easily with parametric types. Let''s create a new type
    called `PairTrade`:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Note that the two legs from the trade can have different types, `T` and `S`,
    and that they can be any subtype of `Investment`. Because we expect every `Trade`
    type to support the `payment` function, we can implement this easily, as follows:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We can reuse the `stock` and `option` objects from the previous session and
    create a pair trade transaction where we buy 100 shares of the stock and sell
    1 option contract. The expected payment amount is $18,800 - $350 = $18,450:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a4545117-e2e8-4181-bf90-ef8c216cbd6d.png)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
- en: 'To appreciate how much parametric types simplified our design, imagine how
    many functions you would have to write if you had to create separate concrete
    types. In this example, since we have two possible trades in a pair trade transaction
    and each trade can be a stock trade or option trade, we have to support 2 x 2
    = 4 different scenarios:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '`payment(PairTradeWithStockAndStock)`'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`payment(PairTradeWithStockAndStockOption)`'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`payment(PairTradeWithStockOptionAndStock)`'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`payment(PairTradeWithStockOptionAndStockOption)`'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using parametric types, we only need a single payment function that covers all
    scenarios.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: Real-life examples
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find the use of parametric types in almost any open source packages.
    Let's go over some examples.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: Example 1 – the ColorTypes.jl package
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`ColorTypes.jl` is a package that defines various data types that represent
    colors. In practice, there are many ways in which a color can be defined: **Red-Green-Blue**
    (**RGB**), **Hue-Saturation-Value** (**HSV**), and so on. Most of the time, a
    color can be defined using three real numbers. In the case of grayscale, only
    a single number is required to represent the level of darkness. To support transparent
    colors, an additional value can be used to store an opacity value. First, let''s
    take a look at the type definitions:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `Colorant{T,N}` type can represent all kinds of colors, with or without
    transparency. The `T` parameter represents the type of each individual value in
    the color definition; for example, Int, Float64, and so on. The `N` parameter
    represents the number of values in the color definition, which is usually three.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '`Color{T,N}` is a subtype of `Colorant{T,N}` and represents non-transparent
    colors. Finally, `AbstractRGB{T}` is a subtype of `Color{T,N}`. Note that the
    `N` parameter is no longer needed as a parameter in `AbstractRGB{T}` because it
    is already defined with N=3\. Now, the concrete parametric type, `RGB{T}`, is
    defined as follows:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The definition of `RGB{T <: Fractional}` is fairly straightforward. It contains
    three values of type `T`, which can be a subtype of `Fractional`. Since the `Fractional`
    type is defined as a union of `AbstractFloat` and `FixedPoint`, the `r`, `g`,
    and `b` fields may be used as any subtype of `AbstractFloat`, such as `Float64`
    and `Float32`, or any of the `FixedPoint` number types.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '`FixedPoint` is a type that''s defined in the `FixedPointNumbers.jl` package.
    Fixed-point numbers is a different way to represent real numbers than the floating-point
    format. More information can be found at [https://github.com/JuliaMath/FixedPointNumbers.jl](https://github.com/JuliaMath/FixedPointNumbers.jl).'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: If you examine the source code further, you will find that many types are defined
    in a similar fashion.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: Example 2 – the NamedDims.jl package
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `NamedDims.jl` package adds names to each dimension of a multi-dimensional
    array. The source code can be found at [https://github.com/invenia/NamedDims.jl](https://github.com/invenia/NamedDims.jl).
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the definition of `NamedDimsArray`:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Don't be intimidated by the signature. It is actually quite straightforward.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '`NamedDimsArray` is a subtype of the abstract array type `AbstractArray{T,
    N}`. It only contains a single field, `data`, which keeps track of the underlying
    data. Because `T` and `N` are already parameters in `A`, they also need to be
    specified in the signature of `NamedDimsArray`. The `L` parameter is used to keep
    track of the names of the dimensions. Note that `L` is not used in any of the
    fields but that it is conveniently stored in the type signature itself.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: 'The primary constructor is defined as follows:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The function only needs to take an `AbstractArray{T,N}` that is an N-dimensional
    array with an element type of `T`. First, it checks if `L` contains a tuple of
    `N` symbols. Because type parameters are first-class, they can be examined in
    the body of the function. Assuming that `L` contains the right number of symbols,
    it just instantiates a `NamedDimsArray` using the known parameters `L`, `T`, `N`,
    as well as the type of the array argument.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: 'It may be easier to see how it''s used, so let''s take a look:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/73f8eff3-cf02-4877-a6b3-839f8bb81887.png)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
- en: In the output, we can see that the type signature is `NamedDimsArray{(:x, :y),Int64,2,Array{Int64,2}}`.
    Matching this with the signature of the `NamedDimsArray` type, we can see that
    `L` is just the two-symbol tuple `(:x, :y)`, `T` is `Int64`, `N` is 2, and the
    underlying data is of the `Array{Int64, 2}` type.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the `dimnames` function, which is defined as follows:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This function returns the dimensions tuple:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2c6ddde2-b646-4361-9ea0-1edd673a4b03.png)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
- en: 'Now, things are getting a little more interesting. What is `NamedDimsArray{L}`?
    Didn''t we need four parameters in this type? It is worth noting that a type such
    as `NamedDimsArray{L, T, N, A}` is actually a subtype of `NamedDimsArray{L}`.
    We can prove this as follows:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9706e903-e25c-4c50-95f5-9f7458cf079a.png)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
- en: 'If we really want to see what `NamedDimsArray{L}` is, we can try the following:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9da06100-4702-4f92-a19c-01e6fe22b765.png)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
- en: What seems to be happening is that `NamedDimsArray{(:x, :y)}` is just shorthand
    for `NamedDimsArray{(:x, :y),T,N,A} where A<:AbstractArray{T,N} where N where
    T`. Because this is a more general type with three unknown parameters, we can
    see why `NamedDimsArray{(:x, :y),Int64,2,Array{Int64,2}}` is a subtype of `NamedDimsArray{(:x,
    :y)}`.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: Using parametric types is very good if we wish to reuse functionalities. We
    can almost view each type parameter as a "dimension". When a parametric type has
    two type parameters, we would have many possible subtypes based upon various combinations
    of each type parameter.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have explored several patterns related to reusability. These
    patterns are highly valuable and can be utilized in many places within an application.
    In addition, people coming from an object-oriented background will probably find
    this chapter indispensable when it comes to designing Julia applications.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: First, we went into great detail about the delegation pattern, which can be
    used to create new capabilities and lets us reuse functions from an existing object.
    The general technique involves defining a new data type that contains a parent
    object. Then, forwarding functions are defined so that we can reuse the functionalities
    of the parent object. We learned implementing delegation can be largely simplified
    by using `@forward`, which is provided by the `Lazy.jl` package.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: Then, we examined the holy trait pattern, which is a formal way to define the
    behavior of objects. The idea is to define traits as native types and utilize
    Julia's built-in dispatch mechanism to call the right method implementation. We
    realize that traits are useful in making the code more extensible. We also learned
    that macros from the `SimpleTraits.jl` package can make trait coding easier.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we looked into the parametric types pattern and how it can be utilized
    to simplify the design of code. We learned that parametric types can reduce the
    size of our code. We also saw that parameters can be used in the bodies of parametric
    functions.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss an important subject that attracts a lot
    of people to the Julia programming language – performance patterns!
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How does the delegation pattern work?
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the purpose of traits?
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Are traits always binary?
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can traits be used for objects from a different type hierarchy?
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the benefits of parametric types?
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do we store the information of a parametric type?
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
