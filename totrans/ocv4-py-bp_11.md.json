["```py\n$ pyinstrument -o profile.html -r html  main.py\n```", "```py\nimport numpy as np\nimport numba\n```", "```py\ndef iou(a: np.ndarray, b: np.ndarray) -> float:\n    a_tl, a_br = a[:4].reshape((2, 2))\n    b_tl, b_br = b[:4].reshape((2, 2))\n    int_tl = np.maximum(a_tl, b_tl)\n    int_br = np.minimum(a_br, b_br)\n    int_area = np.product(np.maximum(0., int_br - int_tl))\n    a_area = np.product(a_br - a_tl)\n    b_area = np.product(b_br - b_tl)\n    return int_area / (a_area + b_area - int_area)\n```", "```py\ndef calc_iou_matrix(detections,trackers):\n    iou_matrix = np.zeros((len(detections), len(trackers)), dtype=np.float32)\n\n    for d, det in enumerate(detections):\n        for t, trk in enumerate(trackers):\n            iou_matrix[d, t] = iou(det, trk)\n    return iou_matrix\n```", "```py\nA = np.random.rand(100,4)\nB = np.random.rand(100,4)\n```", "```py\n%timeit calc_iou_matrix(A,B)\n```", "```py\n307 ms ± 3.15 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)\n```", "```py\n@numba.jit(nopython=True)\ndef product(a):\n    result = 1\n    for i in range(len(a)):\n        result*=a[i]\n    return result\n```", "```py\n@numba.jit(nopython=True)\ndef iou(a: np.ndarray, b: np.ndarray) -> float:\n    a_tl, a_br = a[0:2],a[2:4]\n    b_tl, b_br = b[0:2],b[2:4]\n    int_tl = np.maximum(a_tl, b_tl)\n    int_br = np.minimum(a_br, b_br)\n    int_area = product(np.maximum(0., int_br - int_tl))\n    a_area = product(a_br - a_tl)\n    b_area = product(b_br - b_tl)\n    return int_area / (a_area + b_area - int_area)\n```", "```py\n%timeit calc_iou_matrix(A,B)\n```", "```py\n14.5 ms ± 24.5 µs per loop (mean ± std. dev. of 7 runs, 1 loop each)\n```", "```py\n@numba.jit(nopython=True)\ndef calc_iou_matrix(detections,trackers):\n    iou_matrix = np.zeros((len(detections), len(trackers)), dtype=np.float32)\n    for d in range(len(detections)):\n        det = detections[d]\n        for t in range(len(trackers)):\n            trk = trackers[t]\n            iou_matrix[d, t] = iou(det, trk)\n```", "```py\n7.08 ms ± 31 µs per loop (mean ± std. dev. of 7 runs, 1 loop each)\n```", "```py\n@numba.vectorize\ndef custom_operation(a,b):\n    if b == 0:\n        return 0\n    return a*b if a>b else a/b\n```", "```py\ncustom_operation(A,B)\n```", "```py\ncustom_operation(A,np.ones((1,4)))\n```", "```py\n@numba.guvectorize(['(f8[:, :], f8[:, :], f8[:, :])'], '(m,k),(n,k1)->(m, n)')\ndef calc_iou_matrix(x, y, z):\n    for i in range(x.shape[0]):\n        for j in range(y.shape[1]):\n            z[i, j] = iou(x[i],y[i])\n```", "```py\n196 µs ± 2.46 µs per loop (mean ± std. dev. of 7 runs, 10000 loops each)\n```", "```py\n@numba.guvectorize(['(f8[:, :], f8[:, :], f8)'], '(m,k),(n,k1)->()',target=\"cuda\")\ndef mat_mul(x, y, z):\n    for i in range(x.shape[0]):\n        for j in range(y.shape[1]):\n            z=iou(x[i],y[j])\n```", "```py\n@numba.cuda.jit(device=True)\ndef iou(a: np.ndarray, b: np.ndarray) -> float:\n    xx1 = max(a[0], b[0])\n    yy1 = max(a[1], b[1])\n    xx2 = min(a[2], b[2])\n    yy2 = min(a[3], b[3])\n    w = max(0., xx2 - xx1)\n    h = max(0., yy2 - yy1)\n    wh = w * h\n    result = wh / ((a[2]-a[0])*(a[3]-a[1])\n        + (b[2]-b[0])*(b[3]-b[1]) - wh)\n    return result\n```"]