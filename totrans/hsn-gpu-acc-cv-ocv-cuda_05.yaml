- en: Getting Started with OpenCV with CUDA Support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have seen all the concepts related to parallel programming using
    CUDA and how it can leverage the GPU for acceleration. From this chapter on, we
    will try to use the concept of parallel programming in CUDA for computer vision
    applications. Though we have worked on matrices, we have not worked on actual
    images. Basically, working on images is similar to manipulation of two-dimensional
    matrices. We will not develop the entire code from scratch for computer vision
    applications in CUDA, but we will use the popular computer vision library that
    is called OpenCV. Though this book assumes that the reader has some familiarity
    with working with OpenCV, this chapter revises the concepts of using OpenCV in
    C++. This chapter describes the installation of the OpenCV library with CUDA support
    on Windows and Ubuntu. Then it describes how to test this installation and run
    a simple program. This chapter describes the use of OpenCV in working with images
    and videos by developing simple codes for it. This chapter also compares the performance
    of a program with CUDA support to one without it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to image processing and computer vision
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to OpenCV with CUDA support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installation of OpenCV with CUDA support on Windows and Ubuntu
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with images using OpenCV
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with videos using OpenCV
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arithmetic and logical operations on images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Color-space conversions and image thresholding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance comparison between CPU and GPU OpenCV programs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter requires a basic understanding of image processing and computer
    vision. It needs familiarity with the basic C or C++ programming language and
    all the code samples explained in previous chapters. All of the code used in this
    chapter can be downloaded from the following GitHub link: [https://github.com/PacktPublishing/Hands-On-GPU-Accelerated-Computer-Vision-with-OpenCV-and-CUDA](https://github.com/PacktPublishing/Hands-On-GPU-Accelerated-Computer-Vision-with-OpenCV-and-CUDA).
    The code can be executed on any operating system, though it has only been tested
    on Ubuntu 16.04\.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the Code in Action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://bit.ly/2xF5cQV](http://bit.ly/2xF5cQV)'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to image processing and computer vision
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The volume of image and video data available in the world is increasing day
    by day. The increasing use of mobile devices to capture images and use of the
    internet to post them has allowed production of enormous amounts of video and
    image data every day. Image processing and computer vision are used in many applications
    across various domains. Doctors use MRI and X-ray images for medical diagnoses.
    Space scientists and chemical engineers use images for space exploration and analysis
    of various genes at the molecular level. Images can be used to develop autonomous
    vehicles and video surveillance applications. They can also be used in agricultural
    applications and to identify faulty products during manufacturing. All these applications
    need to process images on a computer at a high speed. We are not going to look
    at how images are captured by a camera sensor and converted into digital images
    for computer storage. In this book, we will only cover the processing of an image
    on a computer, where we assume it is already stored.
  prefs: []
  type: TYPE_NORMAL
- en: Many people use the terms **image processing** and **computer vision** interchangeably.
    However, there is a difference between these two fields. Image processing is concerned
    with improving the visual quality of images by modifying pixel values, whereas
    computer vision is concerned with extracting important information from the images.
    So in image processing, both input and output are images, while in computer vision,
    input is an image but output is the information extracted from that image. Both
    have a wide variety of applications, but image processing is mainly used at the
    pre-processing stage of computer vision applications.
  prefs: []
  type: TYPE_NORMAL
- en: An image is stored as a multidimensional matrix. So processing an image on a
    computer is nothing more than manipulating this matrix. We saw how to work with
    matrices in CUDA in previous chapters. The code for reading, manipulating, and
    displaying images in CUDA might get very long, tedious, and hard to debug. So
    we will use a library that contains APIs for all of these functions and which
    can leverage the advantage of CUDA-GPU acceleration for processing images. This
    library is called OpenCV, which is an acronym for Open Computer Vision. In the
    next section, this library is explained in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to OpenCV
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OpenCV is a computer vision library developed with computational efficiency
    in mind and keeping the focus on real-time performance. It is written in C/C++
    and it contains more than a hundred functions that help in computer vision applications.
    The main advantage of OpenCV is that it is open source and released under a Berkley
    software distribution (BSD) license which allows free use of OpenCV in research
    and commercial applications. This library has an interface in C, C++, Java, and
    Python languages and it can be used in all operating systems, such as Windows,
    Linux, macOS, and Android, without modifying a single line of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'This library can also take advantage of multi-core processing and OpenGL and
    CUDA for parallel processing. As OpenCV is lightweight, it can be used on embedded
    platforms such as Raspberry Pi as well. This makes it ideal for deploying computer
    vision applications on embedded systems in real-life scenarios. We are going to
    explore this in the next few chapters. These features have made OpenCV a default
    choice for computer vision developers. It has a wide developer base and user community
    that helps constantly in improving the library. The downloads for OpenCV are in
    the millions and increasing day by day. The other popular computer vision and
    image processing tool is MATLAB, so you might wonder what are the advantages of
    using OpenCV over MATLAB. The following table shows a comparison between these
    two tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Parameter** | **OpenCV** | **MATLAB** |'
  prefs: []
  type: TYPE_TB
- en: '| Program speed | Higher because it is developed using C/C++ | Lower than OpenCV
    |'
  prefs: []
  type: TYPE_TB
- en: '| Resources needed | OpenCV is a lightweight library so it consumes very little
    memory both in terms of hard disk and RAM. A normal OpenCV program will require
    less than 100MB RAM. | MATLAB is very bulky. The latest MATLAB version installation
    can consume more than 15 GB space on the hard disk and a large chunk of RAM (more
    than 1 GB) when it is in use. |'
  prefs: []
  type: TYPE_TB
- en: '| Portability | OpenCV can run on all operating systems that can run C language.
    | MATLAB can only run on Windows, Linux, and MAC. |'
  prefs: []
  type: TYPE_TB
- en: '| Cost | The use of OpenCV in commercial or academic applications is completely
    free. | MATLAB is a licensed software so you have to pay a large amount to use
    it in your academic or commercial applications. |'
  prefs: []
  type: TYPE_TB
- en: '| Ease of use | OpenCV is comparatively difficult to use as it has less documentation
    and difficult to remember syntax. It also does not have its own development environment.
    | MATLAB has its own integrated development environment with built-in help resources,
    which makes it easy for a new programmer to use. |'
  prefs: []
  type: TYPE_TB
- en: MATLAB and OpenCV both have their pros and cons. But when we want to use computer
    vision in embedded applications and take advantage of parallel processing, OpenCV
    is the ideal choice. So, in this book, OpenCV is described for accelerating computer
    vision applications using GPU and CUDA. OpenCV has APIs in C, C++, Python, and
    Java. It is written in C/C++ so API in those languages will be the fastest. Moreover,
    CUDA acceleration is more supported in C/C++ API, so, in this book, we will use
    OpenCV with C/C++ API. In the next section, we will see how to install OpenCV
    on various operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: Installation of OpenCV with CUDA support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Installation of OpenCV with CUDA is not as trivial as you might think. It involves
    many steps. In this section, all the steps for installing OpenCV in Windows and
    Ubuntu are explained with screenshots, so you can set your environment up easily.
  prefs: []
  type: TYPE_NORMAL
- en: Installation of OpenCV on Windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section explains the steps needed to install OpenCV with CUDA on a Windows
    operating system. The steps are performed on the Windows 10 operating system,
    but it will work on any Windows operating system.
  prefs: []
  type: TYPE_NORMAL
- en: Using pre-built binaries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are pre-built binaries available for OpenCV that can be downloaded and
    used directly in your program. It doesn''t take full advantage of CUDA so it is
    not recommended for this book. The following steps describe the procedure for
    installing OpenCV without CUDA support on Windows:'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure that Microsoft Visual Studio is installed for a compilation of C Programs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Download the latest version of OpenCV from [https://sourceforge.net/projects/opencvlibrary/files/opencv-win/.](https://sourceforge.net/projects/opencvlibrary/files/opencv-win/)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Double click on the downloaded `.exe` file and extract it to your folder of
    choice. Here we are extracting it to the `C://opencv` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set up the environment variable `OPENCV_DIR` by right-clicking on My Computer
    | Advance Setting | Environment Variables | New. Set its value as `C:\opencv\build\x64\vc14`,
    as shown in the following screenshot. Here `vc14` will depend on the version of
    Microsoft Visual Studio:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/606ed750-2439-463b-b0b6-3815c01e63fc.png)'
  prefs: []
  type: TYPE_IMG
- en: Now you can use this installation for OpenCV applications using C/C++.
  prefs: []
  type: TYPE_NORMAL
- en: Building libraries from source
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you want to compile OpenCV with CUDA support, follow these steps for installation:'
  prefs: []
  type: TYPE_NORMAL
- en: OpenCV with CUDA will require a C compiler and GPU compiler. It will require
    Microsoft Visual Studio and the latest CUDA installation. The procedure to install
    them is covered in [Chapter 1](26a373fe-8ec0-40bf-afb7-7db6a1d414c9.xhtml), *Introducing
    CUDA and Getting Started with CUDA*. So before moving ahead, please check that
    they are installed properly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Download the source for the latest version of OpenCV by visiting the link:
    [https://github.com/opencv/opencv/.](https://github.com/opencv/opencv/)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There are some extra modules that are not included in OpenCV, but they are available
    in the extra module call `opencv_contrib`, which can be installed along with OpenCV.
    The functions available in this module are not stable; once they get stable they
    are moved to an actual OpenCV source. If you want to install this module, download
    it from [https://github.com/opencv/opencv_contrib](https://github.com/opencv/opencv_contrib).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Install `cmake` from the following link: [https://cmake.org/download/](https://cmake.org/download/).
    It is needed for compilation of OpenCV library.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extract ZIP files of `opencv` and `opencv_contrib` in any folder. Here they
    are extracted to the `C://opencv` and `C://opencv_contrib` folders.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open CMake to compile OpenCV. In that, you need to select the path for the
    OpenCV source and select the folder in which this source will be built. It is
    shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9f635157-9dfd-44cb-817d-d335ace45c08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then click on Configure. It will start configuring the source. CMake will try
    to locate as many packages as possible based on the path settings in system variables.
    The configuration process is shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/41581058-10c5-48e3-a6bb-de9426d5ab7c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If some of the packages are not located then you can locate them manually.
    To configure OpenCV for installation with CUDA support, you have to check the
    `WITH_CUDA` variable, as shown in the following screenshot, and then click on
    Configure again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c7737d63-7130-496a-813c-c2f520cf7032.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After configuration is finished, click on Generate. This will create the Visual
    Studio project file based on the version of Visual Studio you select. When generating
    is finished, the window should be something like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/84795d15-01df-4596-87d8-c2246c7ad24c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Go to the build directory of the `opencv` folder and find the Visual Studio
    project with the name `OpenCV.sln`, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/df0e50fe-ae0a-4e56-8257-7a2e68527283.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This will open the project in Microsoft Visual Studio. In Solution Explorer,
    find the project with the name `ALL_BUILD`. Right-click on it and build it. Build
    this project for both debug and release options in Visual Studio. This is shown
    in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2ad145cd-82b8-41fd-82a2-968014946b3e.png)'
  prefs: []
  type: TYPE_IMG
- en: It will take a long time to build this entire project, though it will vary depending
    on your processor and Visual Studio version. After successful completion of the
    build operation, you are ready to use the OpenCV library in your C/C++ projects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set up the environment variable `OPENCV_DIR` by right-clicking on My Computer
    | Advance System Settings | Environment Variables | New. Set its value as `C:\opencv\build\x64\vc14`.
    Here, `vc14` will depend on your version of Microsoft Visual Studio:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7d03c092-2e34-4298-ae54-ad8745b9d353.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: You can check the installation by going to the `C://opencv/build/bin/Debug`
    directory and running any .exe application.
  prefs: []
  type: TYPE_NORMAL
- en: Installation of OpenCV with CUDA support on Linux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This section covers the installation steps for OpenCV with CUDA support on
    a Linux operating system. The steps are tested on Ubuntu 16.04, but they should
    work on any Unix distribution:'
  prefs: []
  type: TYPE_NORMAL
- en: 'OpenCV with CUDA will require the latest CUDA installation. The procedure to
    install it is covered in [Chapter 1](26a373fe-8ec0-40bf-afb7-7db6a1d414c9.xhtml),
    *Introducing CUDA and Getting Started with CUDA*. So before moving ahead, please
    check that it is installed properly. You can check the installation of the CUDA
    toolkit and supporting Nvidia device driver by executing the `nvidia-smi` command.
    You should see output similar to the following if your installation is working
    correctly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c762a017-2657-418f-94ef-14748c67ccb6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Download the source for the latest version of OpenCV by visiting the link:
    [https://github.com/opencv/opencv/](https://github.com/opencv/opencv/) . Extract
    it to the `opencv` folder.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There are some extra modules that are not included in OpenCV, but they are
    available in the extra module called `opencv_contrib`, which can be installed
    along with OpenCV. The functions available in this module are not stable; once
    they get stable, they are moved to an actual OpenCV source. If you want to install
    this module, download it from: [https://github.com/opencv/opencv_contrib](https://github.com/opencv/opencv_contrib).
    Extract it to the `opencv_contrib` folder in the same directory as the `opencv`
    folder.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the `opencv` folder and create a build directory. Then go inside this
    newly created `build` directory. These steps can be done by executing the following
    commands from the Command Prompt:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `cmake` command is used to compile `opencv` with CUDA support. Make sure
    the `WITH_CUDA` flag is set to ON in this command, along with a proper path for
    extra modules downloaded and saved in the `opencv_contrib` directory. The entire
    `cmake` command is shown as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'It will start the configuration and creation of `makefile`. It will locate
    all the extra modules based on the values in the system path. The output of the
    `cmake` command with selected CUDA installation is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/06be479f-05cd-42fc-a510-53ccc596d596.png)'
  prefs: []
  type: TYPE_IMG
- en: 'CMake will create a makefile in the build directory after successful configuration.
    To compile OpenCV using this makefile, execute the command `make -j8` from the
    command window, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/55fffc1b-2d4a-4160-85a5-4ee9d82fca62.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After successful compilation, to install OpenCV, you have to execute the command
    `sudo make install` from the command line. The following will be the output of
    that command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/90375fda-7aac-4c29-bd19-2deb9aa8974b.png)'
  prefs: []
  type: TYPE_IMG
- en: Run the `sudo ldconfig` command to finish the installation. It creates the necessary
    links and cache to the `opencv` libraries.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can check the installation by running any example from the `opencv/samples/gpu`
    folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For using OpenCV in the program, you have to include the `opencv2/opencv.hpp`
    header file. This header file will include all other header files necessary for
    the program. So all the OpenCV programs have to include this header file on the
    top.
  prefs: []
  type: TYPE_NORMAL
- en: Working with images in OpenCV
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that OpenCV is installed on the system, we can start using it to work with
    images. In this section, we will learn how images are represented inside OpenCV,
    develop programs to read an image, display an image, and save an image to disk.
    We will also see the method for creating synthetic images in OpenCV. We will also
    use OpenCV to draw different shapes on an image. Along with this, important syntax
    and features of OpenCV will be explained.
  prefs: []
  type: TYPE_NORMAL
- en: Image representation inside OpenCV
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As described earlier, images are nothing but two-dimensional arrays, so they
    should be stored as an array inside a computer for processing. OpenCV provides
    a `Mat` class, which is nothing but an image container used to store an image.
    The `Mat` object can be created and assigned to an image in two separate lines
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The data type of an image and size of the two-dimensional array can also be
    defined while creating an object. The data type of an image is very important
    as it signifies the number of channels and number of bits used to specify a single
    pixel value. Grayscale images have a single channel, while color images are a
    combination of three separate channels: Red, Green, and Blue.'
  prefs: []
  type: TYPE_NORMAL
- en: The number of bits used for a single pixel specifies the number of discrete
    gray level values. An 8-bit image can have gray levels between 0 and 255, while
    16-bit images can have gray levels between 0 to 65,535\. OpenCV supports many
    data types with `CV_8U` as default, which indicates an 8-bit unsigned image with
    a single channel. It is equivalent to `CV_8UC1`. The color images can be specified
    as `CV_8UC3`, which indicates an 8-bit unsigned image with three channels. OpenCV
    supports up to 512 channels. Five or more channels have to be defined in round
    brackets, for example, `CV_8UC(5)` which indicates an 8-bit image with five channels.
    OpenCV also supports signed numbers so the data type can also be `CV_16SC3`, which
    specifies a 16-bit signed image with three channels.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `Mat` object can be used to define the size of an image. This is also called
    the resolution of an image. It indicates the number of pixels in horizontal and
    vertical directions. Normally, the resolution of an image is defined in terms
    of width `x` height. While the size of an array in a `Mat` object should be defined
    in terms of the number of rows `x` number of columns. Some examples of using Mat
    to define image containers are shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The resolution and size of the image will determine the space needed to save
    an image on disk. Suppose the size of a color image with three channels is 1024
    x 1024, then it will take 3 x 1024 x 1024 bytes = 3 MB to store the image on disk.
    In the next section, we will see how to use this Mat object and OpenCV to read
    and display an image.
  prefs: []
  type: TYPE_NORMAL
- en: Reading and displaying an image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will try to develop the code for reading and displaying
    an image using C++ and OpenCV. The entire code for this is as follows it is then
    explained line by line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The program starts with including header files for standard input-output and
    image processing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The functions from the `std` namespace, such as `cout` and `endl`, are used
    in the program, so the `std` namespace is added. All of the OpenCV classes and
    functions are defined using the `cv` namespace. So, to use functions defined in
    the `cv` namespace, we are specifying the `using namespace cv` line. If that line
    is omitted, then every function in the `cv` namespace has to be used in the following
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `main` function contains the code for reading and displaying an image. The
    `imread` command is used to read an image in OpenCV. It returns a `Mat` object.
    The `imread` command has two arguments. The first argument is the name of an image
    along with its path. The path can be specified in two ways. You can specify a
    fully qualified path of an image in your PC or you can specify a relative path
    of an image from your code file. In the preceding example, the relative path is
    used, where an image is located in the images folder that is in the same directory
    as the code file.
  prefs: []
  type: TYPE_NORMAL
- en: The second argument is optional and specifies whether the image is to be read
    as a grayscale or color image. If the image is to be read as a color image, then
    specify `IMREAD_COLOR` or `1`. If the image is to be read as a grayscale image,
    then specify `IMREAD_GRAYSCALE` or `0`. If the image is to be read in its saved
    form, then specify `IMREAD_UNCHANGED` or `-1` as a second argument. If an image
    is read as a color image, the `imread` command will return three channels starting
    with **blue, green,** and **red** (**BGR** format). If the second argument is
    not provided, then the default value is `IMREAD_COLOR` which reads an image as
    a color image.
  prefs: []
  type: TYPE_NORMAL
- en: If, somehow, the image can't be read or it is not available on the disk, then
    the `imread` command will return a `Null Mat` object. If this happens, there is
    no need to continue with further image processing code and we can exit at this
    point by notifying the user about the error. This is handled by the code inside
    the `if` loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'A window in which an image will be displayed should be created. OpenCV provides
    a function called `namedWindow` for that. It requires two arguments. The first
    argument is the name of the window. It has to be a string. The second argument
    specifies the size of the window that is to be created. It can take two values:
    `WINDOW_AUTOSIZE` or `WINDOW_NORMAL`. If `WINDOW_AUTOSIZE` is specified, then
    the user will not be able to resize the window and the image will be displayed
    in its original size. If `WINDOW_NORMAL` is specified, the user will be able to
    resize the window. This argument is optional and its default value is `WINDOW_AUTOSIZE`
    if it is not specified.'
  prefs: []
  type: TYPE_NORMAL
- en: To display an image in the created window, the `imshow` command is used. This
    command requires two arguments. The first argument is the name of the window created
    using the `namedWindow` command and the second argument is the image variable
    that has to be displayed. This variable has to be a `Mat` object. For displaying
    multiple images, separate windows with unique names have to be created. The name
    of the window will appear as a title on the image window.
  prefs: []
  type: TYPE_NORMAL
- en: The `imshow` function should be provided for enough time to display an image
    in the created window. This is done by using the `waitKey` function. So the `imshow`
    function should be followed by the `waitkey` function in all OpenCV programs,
    otherwise the image will not be displayed. `waitKey` is a keyboard binding function
    and it accepts one argument, which is a time in milliseconds. It will wait, for
    a specified time, for a keystroke, then it will move to the next line of code.
    If no argument is specified or 0 is specified, it will wait for an indefinite
    time period for a keystroke. It will move to the next line only when any key is
    pressed on the keyboard. We can also detect whether a specific key is pressed
    and, depending on the key pressed, we can make certain decisions. We will use
    this feature later on in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: All the windows created for displaying the windows need to be closed before
    the termination of the program. This can be done using the `distroyAllWindows`
    function. It will close all the windows created using the `namedWindow` function
    during the program for displaying an image. There is a function called `distroyWindow`,
    which closes specific windows. The name of the window should be provided as an
    argument to the `distroyWindow` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the execution of a program, just copy the code and paste it in Visual Studio
    if using it on Windows, or make a `cpp` file of it in Ubuntu. The build method
    is similar to a normal `cpp` application in Visual Studio, so it is not repeated
    here. For execution on Ubuntu, execute the following commands on the command prompt
    from the folder of a saved `cpp` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding program after execution is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/58a6a2e2-b9d8-4d65-825d-67030a139f50.png)'
  prefs: []
  type: TYPE_IMG
- en: Reading and displaying a color image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the preceding program, the second argument for `imread` is specified as
    `0`, which means that it will read an image as a grayscale image. Suppose you
    want to read any color image. To do this, you can change the `imread` command
    in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The second argument is specified as `1`, which means that it will read an image
    in BGR form. It is important to note that OpenCV''s `imread` and `imshow` use
    BGR format for color images, which is different from the RGB format used by MATLAB
    and other image processing tools. The output after changing `imread` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/24136c64-3fed-4032-9994-7838909c8bd7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The same image can be read as a grayscale image even though it is a color image
    by providing `0` as a second argument. This will convert an image into grayscale
    implicitly and then read. The image will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b67b560c-af73-49b1-8b00-e581f251d2f4.png)'
  prefs: []
  type: TYPE_IMG
- en: It is very important to remember how you are reading the image using the `imread`
    function because it will affect your program's other image processing code.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, in this section, we saw how to read an image and display it using
    OpenCV. In the process, we also learned about some important functions available
    in OpenCV. In the next section, we will see how to create a synthetic image using
    OpenCV.
  prefs: []
  type: TYPE_NORMAL
- en: Creating images using OpenCV
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, we may encounter the need to create our own image or draw some shapes
    on top of existing images. Or we may want to draw bounding boxes around a detected
    object or display labels on an image. So in this section, we will see how to create
    blank grayscale and color images. We will also see the functions for drawing lines,
    rectangles, ellipses, circles, and text on images.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create an empty black image of the size 256 x 256, the following code can
    be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The code is more or less similar to the code developed for reading an image,
    but instead of using the `imread` command here, the image is created using the
    constructor of the `Mat` class only. As discussed earlier, we can provide the
    size and data type while creating a `Mat` object. So while creating an `img` object,
    we have provided four arguments. The first two arguments specify the size of an
    image, which first defines the number of rows (height) and second defines the
    number of columns (width). The third argument defines the data type of an image.
    We have used `CV_8UC1`, which means an 8-bit unsigned integer image with a single
    channel. The last argument specifies the initialization value for all pixels in
    an array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here we have used 0, which is the value for black. When this program is executed,
    it will create a black image of size 256 x 256, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b9972d80-a784-4e1b-9351-ea9b5f797e87.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Similar code can be used for creating blank images of any color, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'While creating a `Mat` object, instead of using the `CV_8UC1` data type, `CV_8UC3`
    is used, which specifies an 8-bit image with three channels. So there are 24 bits
    for a single pixel. The fourth argument specifies the starting pixel values. It
    is specified using the scalar keyword and a tuple of three values specifying starting
    values in all three channels. Here, the blue channel is initialized with 255,
    the green channel is initialized with 0, and red channel is initialized with 0\.
    This will create an image of size 256 x 256 in blue. Different combinations of
    values in tuple will create different colors. The output of the preceding program
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1e87d4d9-3416-4414-a587-247befa168cd.png)'
  prefs: []
  type: TYPE_IMG
- en: Drawing shapes on the blank image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To start drawing different shapes on an image, we will start by creating a
    blank black image of arbitrary size with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This command will create a black image of the size 512 x 512\. Now, we will
    start by drawing different shapes on this image.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing a line
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A line can be specified by two points: the start point and end point. To draw
    a line on the image, these two points have to be specified. The function to draw
    a line on an image is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The line function has five arguments. The first argument specifies the image
    on which a line needs to be drawn, the second and third arguments define the start
    point and end points, respectively. The points are defined using the `Point` class
    constructor, which takes *x* and *y* coordinates of an image as argument. The
    fourth argument specifies the color of the line. It is specified as a tuple of
    B, G, and R values. Here, the value taken is `(0,255,0)`, which specifies green.
    The fifth argument is the thickness of the line. Its value is taken as 7 pixels
    wide. This function also has an optional `linetype` argument. The preceding function
    will draw a diagonal green line of 7 pixels wide from `(0,0)` to `(511,511)`.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing a rectangle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A rectangle can be specified using two extreme diagonal points. OpenCV provides
    a function for drawing a rectangle on an image that has syntax as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The rectangle function has five arguments. The first argument is the image on
    which the rectangle is to be drawn. The second argument is the top-left point
    of the rectangle. The third argument is the bottom-right point of the rectangle.
    The fourth argument specifies the color of the border. It is specified as `(255,255,0)`,
    which is a mix of blue and green, giving cyan. The fifth argument is the thickness
    of the border. If the fifth argument is specified as `-1`, the shape will be filled
    with color. So the preceding function will draw a rectangle with two extreme points,
    `(384,0)` and `(510,128)`, in cyan with a border thickness of 5 pixels.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing a circle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A circle can be specified by a center and its radius. OpenCV provides a function
    for drawing a circle on an image that has syntax as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The circle function has five arguments. The first argument is the image on which
    a circle needs to be drawn. The second argument specifies the center point for
    that circle and the third argument specifies the radius. The fourth argument specifies
    the color of the circle. The value taken is `(0,0,255)`, which is red. The fifth
    argument is the thickness of the border. Here, it is `-1`, which means the circle
    will be filled with red color.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing an ellipse
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'OpenCV provides a function for drawing an ellipse on an image that has syntax
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The ellipse function has many arguments. The first argument specifies the image
    on which an ellipse needs to be drawn. The second argument specifies the center
    of the ellipse. The third argument specifies the box size under which the ellipse
    will be drawn. The fourth argument specifies the angle by which the ellipse needs
    to be rotated. It is taken as `0` degrees. The fifth and sixth argument specifies
    the range of angles for which the ellipse needs to be drawn. It is taken as `0`
    to `180` degrees. So only half the ellipse will be drawn. The next argument specifies
    the color of the ellipse, which is specified only as `255.` It is the same as
    `(255,0,0)`, which is blue. The final argument specifies the thickness of the
    border. It is taken as `-1`, so the ellipse will be filled with blue.
  prefs: []
  type: TYPE_NORMAL
- en: Writing text on an image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'OpenCV provides a function for writing text on an image, which is `putText`.
    The syntax for the function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `putText` function has many arguments. The first argument is the image on
    which text is to be written. The second argument is the text as a String data
    type, which we want to write on an image. The third argument specifies the bottom-left
    corner of the text. The fourth argument specifies the font type. There are many
    font types available in OpenCV, for which you can check OpenCV documentation.
    The fifth argument specifies the scale of the font. The sixth argument is the
    color of the text. It is taken as `(255,255,255)`, which makes white. The seventh
    argument is the thickness of the text, which is taken as `5`, and the last argument
    specifies linetype, which is taken as `8`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have seen separate functions for drawing shapes on an empty black image.
    The following code shows the combination of all the functions previously discussed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The output image for the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/64132bc6-ebc6-4a44-af34-897ba587faa8.png)'
  prefs: []
  type: TYPE_IMG
- en: Saving an image to a file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Images can also be saved to a disk from the OpenCV program. This is helpful
    when we want to store our processed image to a disk on a computer. OpenCV provides
    the `imwrite` function to do this operation. The syntax of this function is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `imwrite` function takes two arguments. The first argument is the name of
    the file you want to save along with its path. The second argument is the `img`
    variable that you want to save. This function returns a Boolean value that indicates
    whether the file is saved successfully or not on a disk.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have worked with images using OpenCV. In the next section,
    we will work with videos, which are nothing but a sequence of images, using OpenCV.
  prefs: []
  type: TYPE_NORMAL
- en: Working with videos in OpenCV
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section will show the process for reading videos from a file and webcam
    using OpenCV. It will also describe the process for saving videos to a file. This
    can also work with USB cameras attached to computers. Videos are nothing more
    than a sequence of images. Though OpenCV is not optimized for video processing
    applications, it does a decent job with it. OpenCV is not able to capture audio,
    so we have to use some other utilities with OpenCV to capture both audio and video.
  prefs: []
  type: TYPE_NORMAL
- en: Working with video stored on a computer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section describes the process of reading a video file stored on a computer.
    All the frames from a video will be read one by one, operated upon, and displayed
    on the screen in all video processing applications using OpenCV.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is for reading and displaying video—a line-by-line explanation
    is then given:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: After including libraries, the first thing that needs to be done inside the
    main function for processing video is to create an object of `VideoCapture`. The
    `VideoCapture` class has many constructors available for working with videos.
    When we want to work with video files stored on a computer, we need to provide
    the name of the video along with its path as an argument to the constructor while
    creating an object of `VideoCapture`.
  prefs: []
  type: TYPE_NORMAL
- en: This object provides many methods and properties that give information related
    to a video. We will see those as and when they are required. It provides the `isopened`
    property, which indicates whether the object creation was successful and whether
    or not video is available. It returns a Boolean value. If `cap.isopened` is `false`,
    the video is not available so there is no need to go any further in the program.
    So that is handled by an `if` loop, which exits the program after notifying the
    user when a video is not available.
  prefs: []
  type: TYPE_NORMAL
- en: The `VideoCapture` class provides a read method that captures the frames one
    by one. To process the entire video, we have to start a continuous loop that runs
    until the end of the video. The infinite `while` loop can do this job. Inside
    the `while` loop, the first frame is read using the read method. This method has
    one argument. It is a Mat object in which we want to store the frame. It returns
    a Boolean value that indicates whether the frame has been read successfully or
    not. When the loop has reached the end of video, this Boolean will return `false`,
    indicating there is no frame available. This flag is checked continuously in the
    loop for the end of the video; and if it is detected, we come out of the `while`
    loop using the `break` statement.
  prefs: []
  type: TYPE_NORMAL
- en: The frame is a single image, so displaying the process for that is the same
    as we saw earlier. In the preceding code, the `waitKey` function is used inside
    an `if` statement. It is waiting for 100 ms after every frame for a keystroke.
    The `if` statement is checking whether the keystroke is `q` or not. If it is `q`,
    it means that the user wants to quit the video so the break statement is included
    inside `if`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This code will terminate display of the video either when the whole video is
    finished or the user presses `q` on the keyboard. Throughout this book, we will
    use this coding practice while processing videos. The output of the preceding
    program is as follows. The screenshot is a frame from a video:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0fb84cb8-4eb4-4e8b-8652-97e2aac8a371.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We have used 100 ms delay between every frame. What do you think will happen
    when you decrease this value to, maybe, 10 ms? The answer is, each frame will
    be displayed faster. It does not mean the frame rate of the video changes. It
    just means that the delay between frames is reduced. If you want to see the actual
    frame rate of the video, you can use the `CAP_PROP_FPS` property of the `cap`
    object. It can be displayed with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `cap` object also has other properties, such as `CAP_PROP_FRAME_WIDTH` and
    `CAP_PROP_FRAME_HEIGHT`, which indicate the width and height of the frames. It
    can also be fetched with the `get` method. These properties can be set by using
    a `set` method of cap object. The `set` method has two arguments. The first argument
    is the `name` of the property and the second argument is the `value` we want to
    set.
  prefs: []
  type: TYPE_NORMAL
- en: This section described the method to read a video from a file. The next section
    will show the process for working with videos from either a webcam or USB camera.
  prefs: []
  type: TYPE_NORMAL
- en: Working with videos from a webcam
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This section describes the process for capturing a video from a webcam or USB
    camera attached to a computer. The good part of OpenCV is that this same code
    will work for laptop and any embedded system that can run C/C++. This helps in
    deploying computer vision applications on any hardware platforms. The code for
    capturing video and displaying it is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: While capturing video from a webcam or USB camera, the device ID for that camera
    needs to be provided as an argument to the constructor of the `VideoCapture` object.
    The primary camera connected will have a device ID zero. The webcam of a laptop
    or USB camera (when there is no webcam) will have device ID zero. If there are
    multiple cameras connected to a device, their device ID will be `(0,1)`, and so
    on. In the preceding code, zero indicates that the primary camera will be used
    by the code to capture the video.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other code is more or less similar to the code for reading video from a
    file. Here, the frame rate of the video is also fetched and displayed. The frames
    will be read one by one at a 1 ms interval and displayed on the window created.
    You have to press `q` to terminate the operation. The output of video captured
    using the webcam is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bbd291d5-2c10-41d3-a2ed-85d868e0a1e4.png)'
  prefs: []
  type: TYPE_IMG
- en: Saving video to a disk
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To save video from the OpenCV program, we need to create an object of the `VideoWriter`
    class. The code to save a video to a file is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: While creating an object of the `VideoWriter` class, the constructor takes five
    arguments. The first argument is the name of the video file you want to save along
    with the absolute or relative path. The second argument is the four character
    code used for video codec. It is created using the `VideoWriter::fourcc` function.
    Here we are using motion JPEG codec, so the four character code for it is `'M'`,
    `'J'`, `'P'`, and `'G'`. There are other codecs that can be used depending on
    your requirements and operating system. The third argument is frames per second.
    It can be specified as an integer variable previously defined or an integer value
    directly in the function. In the preceding code, `30` frames per second is used.
    The fourth argument is the size of the frame. It is defined using the `size` keyword
    with two arguments, `frame_width` and `frame_height`. It is taken as 640 x 640
    in the preceding code. The fifth argument specifies whether the frame to be stored
    is color or grayscale. If its true, the frame is saved as a color frame.
  prefs: []
  type: TYPE_NORMAL
- en: To start writing frames using the `VideoWriter` object, OpenCV provides a `write`
    method. This method is used to write frames into video one by one, so it is included
    inside an infinite `while` loop. This method takes only one argument, which is
    the name of the frame variable. The size of the frame should be the same as the
    size specified while creating the `VideoWriter` object. It is important to flush
    and close the video file created after writing is finished. This can be done by
    releasing the created `VideoWriter` object using the `release` method.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, in this section we looked at the process of reading video from
    a file or camera attached to a device. We have also seen the code for writing
    a video to a file. From the next section onward, we will see how we can operate
    on images or videos using OpenCV with CUDA acceleration.
  prefs: []
  type: TYPE_NORMAL
- en: Basic computer vision applications using the OpenCV CUDA module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In earlier chapters, we saw that CUDA provides an excellent interface to utilize
    the parallel computing capability of GPU to accelerate complex computing applications.
    In this section, we will see how we can utilize the capability of CUDA alongside
    OpenCV for computer vision applications.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to the OpenCV CUDA module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OpenCV has a CUDA module that has hundreds of functions that can utilize GPU
    capabilities. It is only supported on Nvidia GPUs because it uses Nvidia CUDA
    runtime in the background. OpenCV has to be compiled with the `WITH_CUDA` flag
    set to ON for using the CUDA module.
  prefs: []
  type: TYPE_NORMAL
- en: One great feature of using the CUDA module of OpenCV is that it provides a similar
    API to regular OpenCV API. It also does not require detailed knowledge of programming
    in CUDA, although knowledge of CUDA and GPU architecture will not do any harm.
    The researchers have shown that using functions with CUDA acceleration can provide
    5x-100x speedup over similar CPU functions.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will see how to use the CUDA module along with OpenCV
    in various computer vision and image processing applications that operate on individual
    pixels of an image.
  prefs: []
  type: TYPE_NORMAL
- en: Arithmetic and logical operations on images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will see how to perform various arithmetic and logical operations
    on images. We will use functions defined in the CUDA module of OpenCV to perform
    these operations.
  prefs: []
  type: TYPE_NORMAL
- en: Addition of two images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The addition of two images can be performed when two images are of the same
    size. OpenCV provides an `add` function inside the `cv::cuda` namespace for addition
    operation. It performs pixel-wise addition of two images. Suppose in two images,
    the pixel at `(0,0)` has intensity values 100 and 150 respectively. The intensity
    value in the resultant image will be 250, which is the addition of two intensity
    values. OpenCV addition is a saturated operation, which means that if an answer
    of addition goes above 255, it will be saturated at 255\. The code to perform
    addition is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: When any computer vision operation needs to be performed on GPU, the images
    have to be stored on device memory. The memory for it can be allocated with the
    `gpumat` keyword, which is similar to the Mat type used for host memory. The images
    are read in the same way as earlier. Two images are read for addition and stored
    in host memory. These images are copied to device memory using the `upload` method
    of device `memory` variable. The host image variable is passed as a parameter
    to this method.
  prefs: []
  type: TYPE_NORMAL
- en: The function in the GPU CUDA module is defined in the `cv::cuda` namespace.
    It requires images on device memory as its arguments. The add function from the
    CUDA module is used for image addition. It requires three arguments. The first
    two arguments are two images that are to be added and the last argument is the
    destination in which the result will be stored. All three variables should be
    defined using `gpumat`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The resultant image is copied back to the host using the download method of
    the device variable. The host `img` variable, in which the result will be copied,
    is provided as an argument to the download method. Then this image is displayed
    and stored on the disk using the same functions explained in the last section.
    The output of the program is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/11f0673e-6243-40ea-a63c-3ed65d56effe.png)'
  prefs: []
  type: TYPE_IMG
- en: Subtracting two images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Other arithmetic operations can be performed on images using OpenCV and CUDA.
    The `subtract` function is provided by OpenCV to subtract two images. It is also
    a saturated operation, which means that when the answer of subtraction goes below
    zero, it will be saturated to zero. The syntax of the subtract command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, two images to be subtracted are provided as the first two arguments
    and the resultant image is provided as the third argument. The result of the subtraction
    between two images is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c0ea336f-3adf-482f-b9f8-e36d6f7dfc19.png)'
  prefs: []
  type: TYPE_IMG
- en: Image blending
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes there is a need to blend two images with different proportions, instead
    of directly adding two images. Image blending can be represented mathematically
    by the following equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This can be easily accomplished with the `addWeighted` function inside OpenCV.
    The syntax of the function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The function has six arguments. The first argument is the first source image,
    the second argument is a weight of the first image for blending, the third argument
    is the second source image, the fourth argument is a weight of the second image
    for blending, and the fifth argument is the constant gamma to be added while blending.
    The final argument specifies the destination in which the result needs to be stored.
    The function given takes 70 percent of `img1` and 30 percent of `img2` for blending.
    The output for this function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a4c7e83e-3a4d-48aa-ac63-21bfee47ade3.png)'
  prefs: []
  type: TYPE_IMG
- en: Image inversion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Apart from arithmetic operations, OpenCV also provides Boolean operations that
    work on individual bits. It includes AND, OR, NOT, and so on. AND and OR are very
    useful for masking operations, as we will see later on. The NOT operation is used
    for inverting an image where black is converted to white and white is converted
    to black. It can be represented by the following equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In the equation, `255` indicates maximum intensity value for an 8-bit image.
    The program for doing image inversion is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The program is similar to the program for arithmetic operations. The `bitwise_not`
    function is used for image inversion. The image should be a grayscale image. It
    takes two arguments. The first argument indicates the source image to be inverted
    and the second argument indicates the destination in which the inverted image
    is to be stored. The output of the `bitwise_not` operation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3c8c110f-a1f8-4b8d-a6d0-cd6e5b734a5d.png)'
  prefs: []
  type: TYPE_IMG
- en: As can be seen, by doing an inversion, white is converted to black and black
    is converted to white.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, in this section, we have seen various arithmetic and logical operations
    using OpenCV and CUDA. In the next section, we will see some more computer vision
    operations that are widely used in computer vision applications.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the color space of an image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As described earlier, OpenCV can read an image as a grayscale image or as a
    color image, with three channels green, blue, and red, which is called BGR format.
    Other image processing software and algorithms work on RGB images, where the red
    channel is followed by green and blue. There are many other color formats that
    can be used for certain applications. These include the HSV color space, where
    the three channels are Hue, Saturation, and Value. Hue represents color value,
    saturation indicates the gray level in the color, and value represents the brightness
    of the color. The other color space is YCrCb, which is also very useful. This
    system represents colors in an image in terms of one luminance component: luma
    (Y), and two chrominance components: chroma(Cb and Cr).'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many other color spaces available that are supported by OpenCV, such
    as XYZ, HLS, Lab and so on. OpenCV supports more than 150 color conversion methods.
    The conversion from one color space to another can be accomplished by using the
    `cvtColor` function available in OpenCV. An example of using this function for
    changing between various color space is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The `imshow` function expects color images in BGR color format, so the output
    of other color formats using `imshow` might not be visually attractive. The output
    of the preceding program with the same image in different color formats is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/404cfcdd-2a72-4031-999f-029adccc4214.png)'
  prefs: []
  type: TYPE_IMG
- en: Image thresholding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Image thresholding is a very simple image segmentation technique used to extract
    important regions from a grayscale image based on certain intensity values. In
    this technique, if the pixel value is greater than a certain threshold value,
    it is assigned one value, otherwise it is assigned another value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The function used for image thresholding in OpenCV and CUDA is `cv::cuda::threshold.`
    This function has many arguments. The first argument is the source image, which
    should be a grayscale image. The second argument is the destination in which the
    result is to be stored. The third argument is the threshold value, which is used
    to segment the pixel values. The fourth argument is the `maxVal` constant, which
    represents the value to be given if the pixel value is more than the threshold
    value. OpenCV provides different types of thresholding techniques and it is decided
    by the last argument of the function. These thresholding types are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cv:.THRESH_BINARY`: If the intensity of the pixel is greater than the threshold,
    set that pixel intensity equal to the `maxVal` constant. Otherwise set that pixel
    intensity to zero.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cv::THRESH_BINARY_INV`: If the intensity of the pixel is greater than the
    threshold, set that pixel intensity equal to zero. Otherwise set that pixel intensity
    to `maxVal` constant.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cv::THRESH_TRUNC`: This is basically a truncation operation. If the intensity
    of the pixel is greater than the threshold, set that pixel intensity equal to
    the threshold. Otherwise, keep the intensity value as it is.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cv::THRESH_TOZERO`: If the intensity of the pixel is greater than the threshold,
    keep the pixel intensity as it is. Otherwise set that pixel intensity to zero.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cv::THRESH_TOZERO_INV`: If the intensity of the pixel is greater than the
    threshold, set that pixel intensity equal to zero. Otherwise keep the pixel intensity
    as it is.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The program to implement all these thresholding techniques using OpenCV and
    CUDA is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In the `cv::cuda::threshold` function for all thresholding techniques, 128 is
    taken as a threshold for pixel intensity, which is a midpoint between black (0)
    and white (255). The `maxVal` constant is taken as 255, which will be used to
    update pixel intensity when it exceeds the threshold. The other program is similar
    to other OpenCV programs seen earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of the program is as follows, which displays the input image along
    with the output of all five thresholding techniques:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/692261da-2d53-4030-8607-b9325fd0ac3f.png)'
  prefs: []
  type: TYPE_IMG
- en: Performance comparison of OpenCV applications with and without CUDA support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The performance of image processing algorithms can be measured in terms of the
    time it takes to process a single image. When algorithms work on video, performance
    is measured in terms of frames per second, which indicates the number of frames
    it can process in a second. When the algorithm can process more than 30 frames
    per second, it can be considered to work in real time. We can also measure the
    performance of our algorithms implemented in OpenCV, which will be discussed in
    this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we discussed earlier, when OpenCV is built with CUDA compatibility, it can
    increase the performance of algorithms drastically. OpenCV functions in the CUDA
    module are optimized to utilize GPU parallel processing capability. OpenCV also
    provides similar functions that only run on CPU. In this section, we will compare
    the performance of thresholding operations built in the last section with and
    without using GPU. We will compare the performance of the thresholding operation
    in terms of the time taken to process one image and frames per second. The code
    to implement thresholding on CPU and measure performance is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, the threshold function from the `cv` namespace is used,
    which only uses CPU for execution, rather than the `cv::cuda` module. The performance
    of the algorithm is measured using the `gettickcount` and `gettickfrequency` functions.
    The `gettickcount` function returns the time, in milliseconds, that has passed
    after starting the system. We measured the time ticks before and after the execution
    of the code that operates on the image. The difference between the time ticks
    indicates the ticks passed during an execution of the algorithm to process an
    image. This time is measured in the `delta` variable. The `gettickfrequncy` function
    returns the frequency of the timer. Total time taken to process an image can be
    measured by dividing the time ticks by the frequency of the timer. The inverse
    of this time indicates **frames per second** (**FPS**). Both these performance
    measures are printed on the console for thresholding application on the CPU. The
    output on the console is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/31947360-0451-4b22-a563-b6a753f4af42.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As can be seen from the output, the CPU takes `0.169766` seconds to process
    one image, which is equal to `5.89046` FPS. Now we will implement the same algorithm
    on GPU and try to measure the performance of the code. As per the discussion earlier,
    this should increase the performance of the algorithm drastically. The code for
    GPU implementation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'In the code, the functions are used from the `cv::cuda` module, which is optimized
    for GPU parallel processing capabilities. The images are copied to device memory,
    operated upon on GPU, and copied back to host. The performance measures are calculated
    in a similar way as preceding and printed on the console. The output of the program
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5bae944-450a-4c02-ac8b-4bbc4d1d08ba.png)'
  prefs: []
  type: TYPE_IMG
- en: As can be seen, ,GPU implementation only takes `0.55` ms to process a single
    image, which is equal to `1816` FPS. This is a drastic improvement over a CPU
    implementation, though it must be kept in mind that this is a very simple application
    and not ideal for performance comparison between CPU and GPU. This application
    was shown simply to make you familiar with how one can measure the performance
    of any code in OpenCV.
  prefs: []
  type: TYPE_NORMAL
- en: 'A more realistic comparison of CPU and GPU performance can be made by running
    the example codes provided in the OpenCV installation in the `samples/gpu` directory.
    One of the codes, `hog.cpp`, calculates the **histogram of oriented** (**HoG**)
    features from an image and classifies it using **Support Vector Machine** (**SVM**).
    Though details of algorithms are out of the scope of this book, it gives you an
    idea about performance improvement while using GPU implementations. The performance
    comparison on webcam video is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/41657f1b-89cb-4c02-b19e-cf5b51ce8aad.png)'
  prefs: []
  type: TYPE_IMG
- en: As can be seen, while we use only CPU, the performance of the code is around
    13 FPS, and if we use GPU, it increases to 24 FPS, which is almost double the
    CPU performance. This will give you an idea about the importance of using CUDA
    with OpenCV.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, in this section we looked at a comparison between the performance
    of OpenCV using CUDA (GPU) and without using CUDA (CPU). It reemphasizes the notion
    that use of CUDA will improve the performance of computer vision applications
    drastically.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we started with the introduction of computer vision and image
    processing. We described OpenCV library, which is specifically made for computer
    vision applications, and how it is different from other computer vision software.
    OpenCV can leverage the parallel processing capability of GPU by using CUDA. We
    looked at the installation procedure for OpenCV with CUDA in all operating systems.
    We described the process to read an image from disk, display it on screen, and
    save it back to disk. Videos are nothing more than a sequence of images. We learned
    to work with videos from disk as well as videos captured from camera. We developed
    several image processing applications that do different operations on images,
    such as arithmetic operations, logical operations, color space conversions, and
    thresholding. In the last section, we compared the performance of the same algorithm
    on CPU and GPU in terms of time taken to process an image and FPS. So at the end
    of this chapter, you have an idea of the usefulness of OpenCV with CUDA in computer
    vision applications and how to write simple code using it. In the next chapter,
    we will build upon this knowledge and try to develop some more useful computer
    vision applications, such as filtering, edge detection, and morphological operations
    using OpenCV.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: State the difference between terms computer vision and image processing
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is OpenCV ideal for deploying computer vision applications on embedded systems
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write an OpenCV command to initialize 1960 x 1960 color image with red color
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a program to capture frames from a webcam and save it to disk
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which color format is used by OpenCV to read and display a color image
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a program to capture video from webcam, convert it to grayscale and display
    on the screen
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a program to measure the performance of add and subtract operation on
    GPU
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a program for bitwise AND and OR operation on images and explain how it
    can be used for masking
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
