- en: Getting Started with OpenCV with CUDA Support
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用CUDA支持的OpenCV入门
- en: So far, we have seen all the concepts related to parallel programming using
    CUDA and how it can leverage the GPU for acceleration. From this chapter on, we
    will try to use the concept of parallel programming in CUDA for computer vision
    applications. Though we have worked on matrices, we have not worked on actual
    images. Basically, working on images is similar to manipulation of two-dimensional
    matrices. We will not develop the entire code from scratch for computer vision
    applications in CUDA, but we will use the popular computer vision library that
    is called OpenCV. Though this book assumes that the reader has some familiarity
    with working with OpenCV, this chapter revises the concepts of using OpenCV in
    C++. This chapter describes the installation of the OpenCV library with CUDA support
    on Windows and Ubuntu. Then it describes how to test this installation and run
    a simple program. This chapter describes the use of OpenCV in working with images
    and videos by developing simple codes for it. This chapter also compares the performance
    of a program with CUDA support to one without it.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了所有与使用CUDA进行并行编程相关的概念，以及它是如何利用GPU进行加速的。从本章开始，我们将尝试使用CUDA中的并行编程概念来应用于计算机视觉应用。虽然我们已经处理过矩阵，但我们还没有处理过实际图像。基本上，处理图像类似于二维矩阵的操作。我们不会从头开始为CUDA中的计算机视觉应用开发整个代码，但我们将使用名为OpenCV的流行计算机视觉库。尽管这本书假设读者对使用OpenCV有一些熟悉，但本章回顾了在C++中使用OpenCV的概念。本章描述了在Windows和Ubuntu上安装支持CUDA的OpenCV库。然后它描述了如何测试此安装并运行一个简单的程序。本章通过为它开发简单的代码来描述使用OpenCV处理图像和视频。本章还将比较具有CUDA支持的程序与没有CUDA支持的程序的性能。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Introduction to image processing and computer vision
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像处理和计算机视觉简介
- en: Introduction to OpenCV with CUDA support
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持CUDA的OpenCV简介
- en: Installation of OpenCV with CUDA support on Windows and Ubuntu
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Windows 和 Ubuntu 上安装支持 CUDA 的 OpenCV
- en: Working with images using OpenCV
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 OpenCV 处理图像
- en: Working with videos using OpenCV
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用OpenCV处理视频
- en: Arithmetic and logical operations on images
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像上的算术和逻辑运算
- en: Color-space conversions and image thresholding
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 颜色空间转换和图像阈值
- en: Performance comparison between CPU and GPU OpenCV programs
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CPU 和 GPU OpenCV 程序的性能比较
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'This chapter requires a basic understanding of image processing and computer
    vision. It needs familiarity with the basic C or C++ programming language and
    all the code samples explained in previous chapters. All of the code used in this
    chapter can be downloaded from the following GitHub link: [https://github.com/PacktPublishing/Hands-On-GPU-Accelerated-Computer-Vision-with-OpenCV-and-CUDA](https://github.com/PacktPublishing/Hands-On-GPU-Accelerated-Computer-Vision-with-OpenCV-and-CUDA).
    The code can be executed on any operating system, though it has only been tested
    on Ubuntu 16.04\.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章需要具备图像处理和计算机视觉的基本理解。它需要熟悉基本的C或C++编程语言以及前几章中解释的所有代码示例。本章中使用的所有代码都可以从以下GitHub链接下载：[https://github.com/PacktPublishing/Hands-On-GPU-Accelerated-Computer-Vision-with-OpenCV-and-CUDA](https://github.com/PacktPublishing/Hands-On-GPU-Accelerated-Computer-Vision-with-OpenCV-and-CUDA)。代码可以在任何操作系统上执行，尽管它只在Ubuntu
    16.04上进行了测试。
- en: 'Check out the following video to see the Code in Action:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的实际运行情况：
- en: '[http://bit.ly/2xF5cQV](http://bit.ly/2xF5cQV)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://bit.ly/2xF5cQV](http://bit.ly/2xF5cQV)'
- en: Introduction to image processing and computer vision
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图像处理和计算机视觉简介
- en: The volume of image and video data available in the world is increasing day
    by day. The increasing use of mobile devices to capture images and use of the
    internet to post them has allowed production of enormous amounts of video and
    image data every day. Image processing and computer vision are used in many applications
    across various domains. Doctors use MRI and X-ray images for medical diagnoses.
    Space scientists and chemical engineers use images for space exploration and analysis
    of various genes at the molecular level. Images can be used to develop autonomous
    vehicles and video surveillance applications. They can also be used in agricultural
    applications and to identify faulty products during manufacturing. All these applications
    need to process images on a computer at a high speed. We are not going to look
    at how images are captured by a camera sensor and converted into digital images
    for computer storage. In this book, we will only cover the processing of an image
    on a computer, where we assume it is already stored.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 世界上的图像和视频数据量每天都在不断增加。随着移动设备用于捕捉图像和互联网用于发布图像的日益普及，每天都会产生大量的视频和图像数据。图像处理和计算机视觉在各个领域的许多应用中都得到了应用。医生使用MRI和X射线图像进行医学诊断。空间科学家和化学工程师使用图像进行太空探索和分子水平上各种基因的分析。图像可以用于开发自动驾驶车辆和视频监控应用。它们还可以用于农业应用和制造过程中的故障产品识别。所有这些应用都需要在计算机上以高速处理图像。我们不会探讨图像是如何通过相机传感器捕捉并转换为计算机存储的数字图像的。在这本书中，我们只涵盖计算机上的图像处理，假设它已经存储好了。
- en: Many people use the terms **image processing** and **computer vision** interchangeably.
    However, there is a difference between these two fields. Image processing is concerned
    with improving the visual quality of images by modifying pixel values, whereas
    computer vision is concerned with extracting important information from the images.
    So in image processing, both input and output are images, while in computer vision,
    input is an image but output is the information extracted from that image. Both
    have a wide variety of applications, but image processing is mainly used at the
    pre-processing stage of computer vision applications.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 许多人将**图像处理**和**计算机视觉**这两个术语互换使用。然而，这两个领域之间是有区别的。图像处理关注通过修改像素值来提高图像的视觉质量，而计算机视觉关注从图像中提取重要信息。因此，在图像处理中，输入和输出都是图像，而在计算机视觉中，输入是图像，但输出是从该图像中提取的信息。两者都有广泛的应用，但图像处理主要在计算机视觉应用的预处理阶段使用。
- en: An image is stored as a multidimensional matrix. So processing an image on a
    computer is nothing more than manipulating this matrix. We saw how to work with
    matrices in CUDA in previous chapters. The code for reading, manipulating, and
    displaying images in CUDA might get very long, tedious, and hard to debug. So
    we will use a library that contains APIs for all of these functions and which
    can leverage the advantage of CUDA-GPU acceleration for processing images. This
    library is called OpenCV, which is an acronym for Open Computer Vision. In the
    next section, this library is explained in detail.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图像以多维矩阵的形式存储。因此，在计算机上处理图像不过是操作这个矩阵。我们在前面的章节中看到了如何在CUDA中处理矩阵。在CUDA中读取、操作和显示图像的代码可能会变得非常长、繁琐且难以调试。因此，我们将使用一个包含所有这些功能API的库，并且可以利用CUDA-GPU加速处理图像的优势。这个库被称为OpenCV，它是“开放计算机视觉”的缩写。在下一节中，我们将详细介绍这个库。
- en: Introduction to OpenCV
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenCV简介
- en: OpenCV is a computer vision library developed with computational efficiency
    in mind and keeping the focus on real-time performance. It is written in C/C++
    and it contains more than a hundred functions that help in computer vision applications.
    The main advantage of OpenCV is that it is open source and released under a Berkley
    software distribution (BSD) license which allows free use of OpenCV in research
    and commercial applications. This library has an interface in C, C++, Java, and
    Python languages and it can be used in all operating systems, such as Windows,
    Linux, macOS, and Android, without modifying a single line of code.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV是一个以计算效率为前提，并专注于实时性能的计算机视觉库。它用C/C++编写，包含超过一百个有助于计算机视觉应用的功能。OpenCV的主要优势是它是开源的，并且根据伯克利软件发行许可（BSD许可）发布，这允许在研究和商业应用中免费使用OpenCV。这个库提供了C、C++、Java和Python语言的接口，并且可以在所有操作系统上使用，如Windows、Linux、macOS和Android，而无需修改任何一行代码。
- en: 'This library can also take advantage of multi-core processing and OpenGL and
    CUDA for parallel processing. As OpenCV is lightweight, it can be used on embedded
    platforms such as Raspberry Pi as well. This makes it ideal for deploying computer
    vision applications on embedded systems in real-life scenarios. We are going to
    explore this in the next few chapters. These features have made OpenCV a default
    choice for computer vision developers. It has a wide developer base and user community
    that helps constantly in improving the library. The downloads for OpenCV are in
    the millions and increasing day by day. The other popular computer vision and
    image processing tool is MATLAB, so you might wonder what are the advantages of
    using OpenCV over MATLAB. The following table shows a comparison between these
    two tools:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这个库还可以利用多核处理、OpenGL和CUDA进行并行处理。由于OpenCV轻量级，它也可以在树莓派等嵌入式平台上使用。这使得它在现实场景中部署计算机视觉应用到嵌入式系统中变得理想。我们将在接下来的几章中探讨这一点。这些特性使OpenCV成为计算机视觉开发者的默认选择。它拥有广泛的开发者和用户社区，不断帮助改进这个库。OpenCV的下载量以百万计，并且每天都在增加。另一个流行的计算机视觉和图像处理工具是MATLAB，因此你可能会想知道使用OpenCV而不是MATLAB的优势。以下表格显示了这两个工具的比较：
- en: '| **Parameter** | **OpenCV** | **MATLAB** |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| **参数** | **OpenCV** | **MATLAB** |'
- en: '| Program speed | Higher because it is developed using C/C++ | Lower than OpenCV
    |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| 程序速度 | 由于它是用C/C++开发的，所以速度更快 | 低于OpenCV |'
- en: '| Resources needed | OpenCV is a lightweight library so it consumes very little
    memory both in terms of hard disk and RAM. A normal OpenCV program will require
    less than 100MB RAM. | MATLAB is very bulky. The latest MATLAB version installation
    can consume more than 15 GB space on the hard disk and a large chunk of RAM (more
    than 1 GB) when it is in use. |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| 资源需求 | OpenCV是一个轻量级库，因此在硬盘和RAM方面都消耗很少的内存。一个普通的OpenCV程序将需要少于100MB的RAM。 | MATLAB非常庞大。最新版本的MATLAB安装可能需要在硬盘上占用超过15GB的空间，并且在使用时需要大量的RAM（超过1GB）。
    |'
- en: '| Portability | OpenCV can run on all operating systems that can run C language.
    | MATLAB can only run on Windows, Linux, and MAC. |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| 可移植性 | OpenCV可以在所有可以运行C语言的操作系统上运行。 | MATLAB只能在Windows、Linux和MAC上运行。 |'
- en: '| Cost | The use of OpenCV in commercial or academic applications is completely
    free. | MATLAB is a licensed software so you have to pay a large amount to use
    it in your academic or commercial applications. |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| 成本 | 在商业或学术应用中使用OpenCV是完全免费的。 | MATLAB是许可软件，因此你必须支付一大笔钱才能在学术或商业应用中使用它。 |'
- en: '| Ease of use | OpenCV is comparatively difficult to use as it has less documentation
    and difficult to remember syntax. It also does not have its own development environment.
    | MATLAB has its own integrated development environment with built-in help resources,
    which makes it easy for a new programmer to use. |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| 易用性 | 与其较少的文档和难以记忆的语法相比，OpenCV相对较难使用。它也没有自己的开发环境。 | MATLAB有自己的集成开发环境，内置帮助资源，这使得新程序员容易使用。
    |'
- en: MATLAB and OpenCV both have their pros and cons. But when we want to use computer
    vision in embedded applications and take advantage of parallel processing, OpenCV
    is the ideal choice. So, in this book, OpenCV is described for accelerating computer
    vision applications using GPU and CUDA. OpenCV has APIs in C, C++, Python, and
    Java. It is written in C/C++ so API in those languages will be the fastest. Moreover,
    CUDA acceleration is more supported in C/C++ API, so, in this book, we will use
    OpenCV with C/C++ API. In the next section, we will see how to install OpenCV
    on various operating systems.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: MATLAB和OpenCV都有自己的优缺点。但当我们想在嵌入式应用中使用计算机视觉并利用并行处理时，OpenCV是理想的选择。因此，在这本书中，我们将描述如何使用GPU和CUDA加速计算机视觉应用。OpenCV提供了C、C++、Python和Java的API。它是用C/C++编写的，因此这些语言的API将是最快的。此外，CUDA加速在C/C++
    API中支持得更好，所以在这本书中，我们将使用OpenCV的C/C++ API。在下一节中，我们将看到如何在各种操作系统上安装OpenCV。
- en: Installation of OpenCV with CUDA support
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 支持CUDA的OpenCV安装
- en: Installation of OpenCV with CUDA is not as trivial as you might think. It involves
    many steps. In this section, all the steps for installing OpenCV in Windows and
    Ubuntu are explained with screenshots, so you can set your environment up easily.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 使用CUDA安装OpenCV并不像你想象中那么简单。它涉及许多步骤。在本节中，我们将通过截图详细解释在Windows和Ubuntu上安装OpenCV的所有步骤，以便你可以轻松地设置你的环境。
- en: Installation of OpenCV on Windows
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Windows上安装OpenCV
- en: This section explains the steps needed to install OpenCV with CUDA on a Windows
    operating system. The steps are performed on the Windows 10 operating system,
    but it will work on any Windows operating system.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 本节解释了在Windows操作系统上安装带有CUDA的OpenCV所需的步骤。这些步骤在Windows 10操作系统上执行，但它们可以在任何Windows操作系统上工作。
- en: Using pre-built binaries
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用预构建的二进制文件
- en: 'There are pre-built binaries available for OpenCV that can be downloaded and
    used directly in your program. It doesn''t take full advantage of CUDA so it is
    not recommended for this book. The following steps describe the procedure for
    installing OpenCV without CUDA support on Windows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 对于OpenCV，有一些预构建的二进制文件可供下载并直接用于您的程序中。它没有充分利用CUDA，因此不建议在本书中使用。以下步骤描述了在Windows上不使用CUDA支持安装OpenCV的过程：
- en: Make sure that Microsoft Visual Studio is installed for a compilation of C Programs.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保已安装Microsoft Visual Studio以编译C程序。
- en: Download the latest version of OpenCV from [https://sourceforge.net/projects/opencvlibrary/files/opencv-win/.](https://sourceforge.net/projects/opencvlibrary/files/opencv-win/)
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[https://sourceforge.net/projects/opencvlibrary/files/opencv-win/](https://sourceforge.net/projects/opencvlibrary/files/opencv-win/)下载OpenCV的最新版本。
- en: Double click on the downloaded `.exe` file and extract it to your folder of
    choice. Here we are extracting it to the `C://opencv` folder.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击下载的`.exe`文件，并将其提取到您选择的文件夹中。在这里，我们将其提取到`C://opencv`文件夹。
- en: 'Set up the environment variable `OPENCV_DIR` by right-clicking on My Computer
    | Advance Setting | Environment Variables | New. Set its value as `C:\opencv\build\x64\vc14`,
    as shown in the following screenshot. Here `vc14` will depend on the version of
    Microsoft Visual Studio:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过右键单击我的电脑 | 高级设置 | 环境变量 | 新建来设置环境变量`OPENCV_DIR`。将其值设置为`C:\opencv\build\x64\vc14`，如下截图所示。这里`vc14`将取决于Microsoft
    Visual Studio的版本：
- en: '![](img/606ed750-2439-463b-b0b6-3815c01e63fc.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/606ed750-2439-463b-b0b6-3815c01e63fc.png)'
- en: Now you can use this installation for OpenCV applications using C/C++.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以使用此安装为OpenCV应用程序使用C/C++。
- en: Building libraries from source
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从源代码构建库
- en: 'If you want to compile OpenCV with CUDA support, follow these steps for installation:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想编译带有CUDA支持的OpenCV，请按照以下步骤进行安装：
- en: OpenCV with CUDA will require a C compiler and GPU compiler. It will require
    Microsoft Visual Studio and the latest CUDA installation. The procedure to install
    them is covered in [Chapter 1](26a373fe-8ec0-40bf-afb7-7db6a1d414c9.xhtml), *Introducing
    CUDA and Getting Started with CUDA*. So before moving ahead, please check that
    they are installed properly.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: OpenCV带有CUDA将需要一个C编译器和GPU编译器。它需要Microsoft Visual Studio和最新的CUDA安装。安装它们的步骤在[第1章](26a373fe-8ec0-40bf-afb7-7db6a1d414c9.xhtml)，*介绍CUDA和CUDA入门*中有所介绍。因此，在继续之前，请检查它们是否已正确安装。
- en: 'Download the source for the latest version of OpenCV by visiting the link:
    [https://github.com/opencv/opencv/.](https://github.com/opencv/opencv/)'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过访问链接下载OpenCV最新版本的源代码：[https://github.com/opencv/opencv/.](https://github.com/opencv/opencv/)
- en: There are some extra modules that are not included in OpenCV, but they are available
    in the extra module call `opencv_contrib`, which can be installed along with OpenCV.
    The functions available in this module are not stable; once they get stable they
    are moved to an actual OpenCV source. If you want to install this module, download
    it from [https://github.com/opencv/opencv_contrib](https://github.com/opencv/opencv_contrib).
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有些额外的模块不包括在OpenCV中，但它们可以在名为`opencv_contrib`的额外模块中找到，这个模块可以与OpenCV一起安装。此模块中可用的功能不稳定；一旦它们变得稳定，它们就会被移动到实际的OpenCV源中。如果您想安装此模块，请从[https://github.com/opencv/opencv_contrib](https://github.com/opencv/opencv_contrib)下载。
- en: 'Install `cmake` from the following link: [https://cmake.org/download/](https://cmake.org/download/).
    It is needed for compilation of OpenCV library.'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从以下链接安装`cmake`：[https://cmake.org/download/](https://cmake.org/download/)。它是编译OpenCV库所需的。
- en: Extract ZIP files of `opencv` and `opencv_contrib` in any folder. Here they
    are extracted to the `C://opencv` and `C://opencv_contrib` folders.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`opencv`和`opencv_contrib`的ZIP文件提取到任何文件夹中。在这里，它们被提取到`C://opencv`和`C://opencv_contrib`文件夹中。
- en: 'Open CMake to compile OpenCV. In that, you need to select the path for the
    OpenCV source and select the folder in which this source will be built. It is
    shown in the following screenshot:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开CMake以编译OpenCV。在CMake中，您需要选择OpenCV源代码的路径，并选择此源代码将被构建的文件夹。如下截图所示：
- en: '![](img/9f635157-9dfd-44cb-817d-d335ace45c08.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9f635157-9dfd-44cb-817d-d335ace45c08.png)'
- en: 'Then click on Configure. It will start configuring the source. CMake will try
    to locate as many packages as possible based on the path settings in system variables.
    The configuration process is shown in the following screenshot:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后点击配置。它将开始配置源。CMake将尝试根据系统变量的路径设置定位尽可能多的包。配置过程如下面的截图所示：
- en: '![](img/41581058-10c5-48e3-a6bb-de9426d5ab7c.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/41581058-10c5-48e3-a6bb-de9426d5ab7c.png)'
- en: 'If some of the packages are not located then you can locate them manually.
    To configure OpenCV for installation with CUDA support, you have to check the
    `WITH_CUDA` variable, as shown in the following screenshot, and then click on
    Configure again:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果某些包没有找到，您可以手动定位它们。为了配置具有CUDA支持的OpenCV安装，您必须检查如下截图所示的`WITH_CUDA`变量，然后再次点击配置：
- en: '![](img/c7737d63-7130-496a-813c-c2f520cf7032.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c7737d63-7130-496a-813c-c2f520cf7032.png)'
- en: 'After configuration is finished, click on Generate. This will create the Visual
    Studio project file based on the version of Visual Studio you select. When generating
    is finished, the window should be something like the following:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置完成后，点击生成。这将根据您选择的Visual Studio版本创建Visual Studio项目文件。当生成完成后，窗口应该类似于以下截图：
- en: '![](img/84795d15-01df-4596-87d8-c2246c7ad24c.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/84795d15-01df-4596-87d8-c2246c7ad24c.png)'
- en: 'Go to the build directory of the `opencv` folder and find the Visual Studio
    project with the name `OpenCV.sln`, as shown in the following screenshot:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往`opencv`文件夹的构建目录，并找到名为`OpenCV.sln`的Visual Studio项目，如下面的截图所示：
- en: '![](img/df0e50fe-ae0a-4e56-8257-7a2e68527283.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/df0e50fe-ae0a-4e56-8257-7a2e68527283.png)'
- en: 'This will open the project in Microsoft Visual Studio. In Solution Explorer,
    find the project with the name `ALL_BUILD`. Right-click on it and build it. Build
    this project for both debug and release options in Visual Studio. This is shown
    in the following screenshot:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将在Microsoft Visual Studio中打开项目。在解决方案资源管理器中，找到名为`ALL_BUILD`的项目。右键单击它并构建。在Visual
    Studio中为调试和发布选项构建此项目。如下面的截图所示：
- en: '![](img/2ad145cd-82b8-41fd-82a2-968014946b3e.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2ad145cd-82b8-41fd-82a2-968014946b3e.png)'
- en: It will take a long time to build this entire project, though it will vary depending
    on your processor and Visual Studio version. After successful completion of the
    build operation, you are ready to use the OpenCV library in your C/C++ projects.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建整个项目可能需要很长时间，尽管这会根据您的处理器和Visual Studio版本而有所不同。在构建操作成功完成后，您就可以在C/C++项目中使用OpenCV库了。
- en: 'Set up the environment variable `OPENCV_DIR` by right-clicking on My Computer
    | Advance System Settings | Environment Variables | New. Set its value as `C:\opencv\build\x64\vc14`.
    Here, `vc14` will depend on your version of Microsoft Visual Studio:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过右键单击我的电脑 | 高级系统设置 | 环境变量 | 新建来设置环境变量`OPENCV_DIR`。将其值设置为`C:\opencv\build\x64\vc14`。在这里，`vc14`将取决于您使用的Microsoft
    Visual Studio版本：
- en: '![](img/7d03c092-2e34-4298-ae54-ad8745b9d353.png)'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/7d03c092-2e34-4298-ae54-ad8745b9d353.png)'
- en: You can check the installation by going to the `C://opencv/build/bin/Debug`
    directory and running any .exe application.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过访问`C://opencv/build/bin/Debug`目录并运行任何.exe应用程序来检查安装情况。
- en: Installation of OpenCV with CUDA support on Linux
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Linux上安装具有CUDA支持的OpenCV
- en: 'This section covers the installation steps for OpenCV with CUDA support on
    a Linux operating system. The steps are tested on Ubuntu 16.04, but they should
    work on any Unix distribution:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 本节涵盖了在Linux操作系统上安装具有CUDA支持的OpenCV的步骤。这些步骤已在Ubuntu 16.04上测试，但它们应该适用于任何Unix发行版：
- en: 'OpenCV with CUDA will require the latest CUDA installation. The procedure to
    install it is covered in [Chapter 1](26a373fe-8ec0-40bf-afb7-7db6a1d414c9.xhtml),
    *Introducing CUDA and Getting Started with CUDA*. So before moving ahead, please
    check that it is installed properly. You can check the installation of the CUDA
    toolkit and supporting Nvidia device driver by executing the `nvidia-smi` command.
    You should see output similar to the following if your installation is working
    correctly:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 具有CUDA的OpenCV将需要最新的CUDA安装。安装它的过程在[第1章](26a373fe-8ec0-40bf-afb7-7db6a1d414c9.xhtml)，*介绍CUDA和CUDA入门*中有所覆盖。所以在继续之前，请检查它是否已正确安装。您可以通过执行`nvidia-smi`命令来检查CUDA工具包和Nvidia设备驱动程序的安装情况。如果您的安装正常工作，您应该看到如下类似的输出：
- en: '![](img/c762a017-2657-418f-94ef-14748c67ccb6.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c762a017-2657-418f-94ef-14748c67ccb6.png)'
- en: 'Download the source for the latest version of OpenCV by visiting the link:
    [https://github.com/opencv/opencv/](https://github.com/opencv/opencv/) . Extract
    it to the `opencv` folder.'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过访问链接下载OpenCV最新版本的源代码：[https://github.com/opencv/opencv/](https://github.com/opencv/opencv/)。将其解压到`opencv`文件夹中。
- en: 'There are some extra modules that are not included in OpenCV, but they are
    available in the extra module called `opencv_contrib`, which can be installed
    along with OpenCV. The functions available in this module are not stable; once
    they get stable, they are moved to an actual OpenCV source. If you want to install
    this module, download it from: [https://github.com/opencv/opencv_contrib](https://github.com/opencv/opencv_contrib).
    Extract it to the `opencv_contrib` folder in the same directory as the `opencv`
    folder.'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the `opencv` folder and create a build directory. Then go inside this
    newly created `build` directory. These steps can be done by executing the following
    commands from the Command Prompt:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `cmake` command is used to compile `opencv` with CUDA support. Make sure
    the `WITH_CUDA` flag is set to ON in this command, along with a proper path for
    extra modules downloaded and saved in the `opencv_contrib` directory. The entire
    `cmake` command is shown as follows:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'It will start the configuration and creation of `makefile`. It will locate
    all the extra modules based on the values in the system path. The output of the
    `cmake` command with selected CUDA installation is shown in the following screenshot:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/06be479f-05cd-42fc-a510-53ccc596d596.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
- en: 'CMake will create a makefile in the build directory after successful configuration.
    To compile OpenCV using this makefile, execute the command `make -j8` from the
    command window, as shown:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/55fffc1b-2d4a-4160-85a5-4ee9d82fca62.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
- en: 'After successful compilation, to install OpenCV, you have to execute the command
    `sudo make install` from the command line. The following will be the output of
    that command:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/90375fda-7aac-4c29-bd19-2deb9aa8974b.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
- en: Run the `sudo ldconfig` command to finish the installation. It creates the necessary
    links and cache to the `opencv` libraries.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can check the installation by running any example from the `opencv/samples/gpu`
    folder.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For using OpenCV in the program, you have to include the `opencv2/opencv.hpp`
    header file. This header file will include all other header files necessary for
    the program. So all the OpenCV programs have to include this header file on the
    top.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Working with images in OpenCV
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that OpenCV is installed on the system, we can start using it to work with
    images. In this section, we will learn how images are represented inside OpenCV,
    develop programs to read an image, display an image, and save an image to disk.
    We will also see the method for creating synthetic images in OpenCV. We will also
    use OpenCV to draw different shapes on an image. Along with this, important syntax
    and features of OpenCV will be explained.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Image representation inside OpenCV
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As described earlier, images are nothing but two-dimensional arrays, so they
    should be stored as an array inside a computer for processing. OpenCV provides
    a `Mat` class, which is nothing but an image container used to store an image.
    The `Mat` object can be created and assigned to an image in two separate lines
    as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，图像不过是二维数组，因此它们应该在计算机内部以数组的形式存储以供处理。OpenCV 提供了一个 `Mat` 类，它实际上是一个用于存储图像的图像容器。`Mat`
    对象可以通过以下两行分别创建并分配给图像：
- en: '[PRE2]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The data type of an image and size of the two-dimensional array can also be
    defined while creating an object. The data type of an image is very important
    as it signifies the number of channels and number of bits used to specify a single
    pixel value. Grayscale images have a single channel, while color images are a
    combination of three separate channels: Red, Green, and Blue.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建对象时，也可以定义图像的数据类型和二维数组的大小。图像的数据类型非常重要，因为它表示了指定单个像素值所使用的通道数和位数。灰度图像只有一个通道，而彩色图像是三个独立通道的组合：红色、绿色和蓝色。
- en: The number of bits used for a single pixel specifies the number of discrete
    gray level values. An 8-bit image can have gray levels between 0 and 255, while
    16-bit images can have gray levels between 0 to 65,535\. OpenCV supports many
    data types with `CV_8U` as default, which indicates an 8-bit unsigned image with
    a single channel. It is equivalent to `CV_8UC1`. The color images can be specified
    as `CV_8UC3`, which indicates an 8-bit unsigned image with three channels. OpenCV
    supports up to 512 channels. Five or more channels have to be defined in round
    brackets, for example, `CV_8UC(5)` which indicates an 8-bit image with five channels.
    OpenCV also supports signed numbers so the data type can also be `CV_16SC3`, which
    specifies a 16-bit signed image with three channels.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 单个像素使用的位数指定了离散灰度级别值的数量。一个 8 位图像可以具有介于 0 到 255 之间的灰度级别，而 16 位图像可以具有介于 0 到 65,535
    之间的灰度级别。OpenCV 支持许多数据类型，默认为 `CV_8U`，表示单通道的 8 位无符号图像。它等同于 `CV_8UC1`。彩色图像可以指定为 `CV_8UC3`，表示具有三个通道的
    8 位无符号图像。OpenCV 支持多达 512 个通道。五个或更多通道必须用圆括号定义，例如，`CV_8UC(5)` 表示具有五个通道的 8 位图像。OpenCV
    还支持有符号数，因此数据类型也可以是 `CV_16SC3`，表示具有三个通道的 16 位有符号图像。
- en: 'A `Mat` object can be used to define the size of an image. This is also called
    the resolution of an image. It indicates the number of pixels in horizontal and
    vertical directions. Normally, the resolution of an image is defined in terms
    of width `x` height. While the size of an array in a `Mat` object should be defined
    in terms of the number of rows `x` number of columns. Some examples of using Mat
    to define image containers are shown as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`Mat` 对象可以用来定义图像的大小。这也被称为图像的分辨率。它表示水平和垂直方向上的像素数量。通常，图像的分辨率是以宽度 `x` 高度来定义的。而在
    `Mat` 对象中的数组大小应该以行 `x` 列数来定义。以下是一些使用 `Mat` 定义图像容器的示例：'
- en: '[PRE3]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The resolution and size of the image will determine the space needed to save
    an image on disk. Suppose the size of a color image with three channels is 1024
    x 1024, then it will take 3 x 1024 x 1024 bytes = 3 MB to store the image on disk.
    In the next section, we will see how to use this Mat object and OpenCV to read
    and display an image.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图像的分辨率和大小将决定在磁盘上保存图像所需的空间。假设一个具有三个通道的彩色图像的大小为 1024 x 1024，那么它将占用 3 x 1024 x
    1024 字节 = 3 MB 的磁盘空间。在下一节中，我们将看到如何使用这个 `Mat` 对象和 OpenCV 读取和显示图像。
- en: Reading and displaying an image
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取和显示图像
- en: 'In this section, we will try to develop the code for reading and displaying
    an image using C++ and OpenCV. The entire code for this is as follows it is then
    explained line by line:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将尝试使用 C++ 和 OpenCV 开发读取和显示图像的代码。整个代码如下，然后逐行进行解释：
- en: '[PRE4]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The program starts with including header files for standard input-output and
    image processing.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 程序从包含标准输入输出和图像处理的头文件开始。
- en: 'The functions from the `std` namespace, such as `cout` and `endl`, are used
    in the program, so the `std` namespace is added. All of the OpenCV classes and
    functions are defined using the `cv` namespace. So, to use functions defined in
    the `cv` namespace, we are specifying the `using namespace cv` line. If that line
    is omitted, then every function in the `cv` namespace has to be used in the following
    way:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 程序中使用来自 `std` 命名空间的功能，如 `cout` 和 `endl`，因此添加了 `std` 命名空间。所有 OpenCV 类和函数都是使用
    `cv` 命名空间定义的。因此，为了使用 `cv` 命名空间中定义的函数，我们指定了 `using namespace cv` 这一行。如果省略该行，那么在
    `cv` 命名空间中的每个函数都必须以下述方式使用：
- en: '[PRE5]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `main` function contains the code for reading and displaying an image. The
    `imread` command is used to read an image in OpenCV. It returns a `Mat` object.
    The `imread` command has two arguments. The first argument is the name of an image
    along with its path. The path can be specified in two ways. You can specify a
    fully qualified path of an image in your PC or you can specify a relative path
    of an image from your code file. In the preceding example, the relative path is
    used, where an image is located in the images folder that is in the same directory
    as the code file.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`函数包含读取和显示图像的代码。在OpenCV中使用`imread`命令读取图像。它返回一个`Mat`对象。`imread`命令有两个参数。第一个参数是图像的名称及其路径。路径可以有两种指定方式。您可以在PC上指定图像的完整路径，或者从您的代码文件中指定图像的相对路径。在上面的示例中，使用了相对路径，其中图像位于与代码文件相同的目录下的images文件夹中。'
- en: The second argument is optional and specifies whether the image is to be read
    as a grayscale or color image. If the image is to be read as a color image, then
    specify `IMREAD_COLOR` or `1`. If the image is to be read as a grayscale image,
    then specify `IMREAD_GRAYSCALE` or `0`. If the image is to be read in its saved
    form, then specify `IMREAD_UNCHANGED` or `-1` as a second argument. If an image
    is read as a color image, the `imread` command will return three channels starting
    with **blue, green,** and **red** (**BGR** format). If the second argument is
    not provided, then the default value is `IMREAD_COLOR` which reads an image as
    a color image.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数是可选的，用于指定图像是要以灰度图像还是彩色图像读取。如果图像要以彩色图像读取，则指定`IMREAD_COLOR`或`1`。如果图像要以灰度图像读取，则指定`IMREAD_GRAYSCALE`或`0`。如果要以保存的格式读取图像，则将`IMREAD_UNCHANGED`或`-1`作为第二个参数。如果图像作为彩色图像读取，`imread`命令将返回三个通道，从**蓝色、绿色**和**红色**（**BGR**格式）开始。如果第二个参数未提供，则默认值为`IMREAD_COLOR`，它将图像作为彩色图像读取。
- en: If, somehow, the image can't be read or it is not available on the disk, then
    the `imread` command will return a `Null Mat` object. If this happens, there is
    no need to continue with further image processing code and we can exit at this
    point by notifying the user about the error. This is handled by the code inside
    the `if` loop.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果图像无法读取或磁盘上不可用，则`imread`命令将返回一个`Null Mat`对象。如果发生这种情况，无需继续执行进一步图像处理代码，我们可以在此时通过通知用户关于错误来退出。这由`if`循环内的代码处理。
- en: 'A window in which an image will be displayed should be created. OpenCV provides
    a function called `namedWindow` for that. It requires two arguments. The first
    argument is the name of the window. It has to be a string. The second argument
    specifies the size of the window that is to be created. It can take two values:
    `WINDOW_AUTOSIZE` or `WINDOW_NORMAL`. If `WINDOW_AUTOSIZE` is specified, then
    the user will not be able to resize the window and the image will be displayed
    in its original size. If `WINDOW_NORMAL` is specified, the user will be able to
    resize the window. This argument is optional and its default value is `WINDOW_AUTOSIZE`
    if it is not specified.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 应创建一个用于显示图像的窗口。OpenCV提供了一个名为`namedWindow`的函数来实现这一功能。它需要两个参数。第一个参数是窗口的名称，它必须是一个字符串。第二个参数指定要创建的窗口的大小。它可以取两个值：`WINDOW_AUTOSIZE`或`WINDOW_NORMAL`。如果指定了`WINDOW_AUTOSIZE`，则用户将无法调整窗口大小，图像将以原始大小显示。如果指定了`WINDOW_NORMAL`，则用户可以调整窗口大小。此参数是可选的，如果未指定，其默认值为`WINDOW_AUTOSIZE`。
- en: To display an image in the created window, the `imshow` command is used. This
    command requires two arguments. The first argument is the name of the window created
    using the `namedWindow` command and the second argument is the image variable
    that has to be displayed. This variable has to be a `Mat` object. For displaying
    multiple images, separate windows with unique names have to be created. The name
    of the window will appear as a title on the image window.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要在创建的窗口中显示图像，使用`imshow`命令。此命令需要两个参数。第一个参数是使用`namedWindow`命令创建的窗口名称，第二个参数是要显示的图像变量。此变量必须是一个`Mat`对象。要显示多个图像，必须创建具有唯一名称的单独窗口。窗口的名称将作为图像窗口的标题出现。
- en: The `imshow` function should be provided for enough time to display an image
    in the created window. This is done by using the `waitKey` function. So the `imshow`
    function should be followed by the `waitkey` function in all OpenCV programs,
    otherwise the image will not be displayed. `waitKey` is a keyboard binding function
    and it accepts one argument, which is a time in milliseconds. It will wait, for
    a specified time, for a keystroke, then it will move to the next line of code.
    If no argument is specified or 0 is specified, it will wait for an indefinite
    time period for a keystroke. It will move to the next line only when any key is
    pressed on the keyboard. We can also detect whether a specific key is pressed
    and, depending on the key pressed, we can make certain decisions. We will use
    this feature later on in this chapter.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`imshow` 函数应该有足够的时间在创建的窗口中显示一张图片。这是通过使用 `waitKey` 函数来实现的。因此，在所有 OpenCV 程序中，`imshow`
    函数后面都应该跟 `waitkey` 函数，否则图片将不会显示。`waitKey` 是一个键盘绑定函数，它接受一个参数，即以毫秒为单位的时间。它将在指定的时间内等待按键，然后移动到下一行代码。如果没有指定参数或指定为
    0，它将无限期地等待按键。只有在键盘上按下任何键时，它才会移动到下一行。我们还可以检测是否按下了特定的键，并根据按下的键做出某些决定。我们将在本章后面使用这个功能。'
- en: All the windows created for displaying the windows need to be closed before
    the termination of the program. This can be done using the `distroyAllWindows`
    function. It will close all the windows created using the `namedWindow` function
    during the program for displaying an image. There is a function called `distroyWindow`,
    which closes specific windows. The name of the window should be provided as an
    argument to the `distroyWindow` function.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序终止之前，需要关闭为显示窗口创建的所有窗口。这可以通过使用 `destroyAllWindows` 函数来完成。它将关闭程序中通过 `namedWindow`
    函数创建的所有窗口。有一个名为 `destroyWindow` 的函数，可以关闭特定的窗口。应将窗口名称作为参数提供给 `destroyWindow` 函数。
- en: 'For the execution of a program, just copy the code and paste it in Visual Studio
    if using it on Windows, or make a `cpp` file of it in Ubuntu. The build method
    is similar to a normal `cpp` application in Visual Studio, so it is not repeated
    here. For execution on Ubuntu, execute the following commands on the command prompt
    from the folder of a saved `cpp` file:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 对于程序的执行，只需将代码复制并粘贴到 Windows 上的 Visual Studio 中，或者如果你在 Ubuntu 上使用，可以创建一个 `cpp`
    文件。构建方法与 Visual Studio 中的正常 `cpp` 应用程序类似，所以这里不再重复。要在 Ubuntu 上执行，请在保存 `cpp` 文件的文件夹中从命令提示符执行以下命令：
- en: '[PRE6]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The output of the preceding program after execution is as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 前面程序的输出如下：
- en: '![](img/58a6a2e2-b9d8-4d65-825d-67030a139f50.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/58a6a2e2-b9d8-4d65-825d-67030a139f50.png)'
- en: Reading and displaying a color image
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取和显示彩色图像
- en: 'In the preceding program, the second argument for `imread` is specified as
    `0`, which means that it will read an image as a grayscale image. Suppose you
    want to read any color image. To do this, you can change the `imread` command
    in the following way:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的程序中，`imread` 的第二个参数被指定为 `0`，这意味着它将以灰度图像的形式读取图像。假设你想读取任何彩色图像。为此，你可以按以下方式更改
    `imread` 命令：
- en: '[PRE7]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The second argument is specified as `1`, which means that it will read an image
    in BGR form. It is important to note that OpenCV''s `imread` and `imshow` use
    BGR format for color images, which is different from the RGB format used by MATLAB
    and other image processing tools. The output after changing `imread` is as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数被指定为 `1`，这意味着它将以 BGR 格式读取图像。重要的是要注意，OpenCV 的 `imread` 和 `imshow` 使用 BGR
    格式来处理彩色图像，这与 MATLAB 和其他图像处理工具使用的 RGB 格式不同。更改 `imread` 后的输出如下：
- en: '![](img/24136c64-3fed-4032-9994-7838909c8bd7.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](img/24136c64-3fed-4032-9994-7838909c8bd7.png)'
- en: 'The same image can be read as a grayscale image even though it is a color image
    by providing `0` as a second argument. This will convert an image into grayscale
    implicitly and then read. The image will look as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是彩色图像，也可以通过将第二个参数指定为 `0` 来将其读取为灰度图像。这将隐式地将图像转换为灰度并读取。图像将看起来如下：
- en: '![](img/b67b560c-af73-49b1-8b00-e581f251d2f4.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b67b560c-af73-49b1-8b00-e581f251d2f4.png)'
- en: It is very important to remember how you are reading the image using the `imread`
    function because it will affect your program's other image processing code.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 记住如何使用 `imread` 函数读取图像非常重要，因为它将影响你程序中的其他图像处理代码。
- en: To summarize, in this section, we saw how to read an image and display it using
    OpenCV. In the process, we also learned about some important functions available
    in OpenCV. In the next section, we will see how to create a synthetic image using
    OpenCV.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，在本节中，我们看到了如何使用 OpenCV 读取图像并显示它。在这个过程中，我们还了解了一些 OpenCV 中可用的重要函数。在下一节中，我们将看到如何使用
    OpenCV 创建合成图像。
- en: Creating images using OpenCV
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 OpenCV 创建图像
- en: Sometimes, we may encounter the need to create our own image or draw some shapes
    on top of existing images. Or we may want to draw bounding boxes around a detected
    object or display labels on an image. So in this section, we will see how to create
    blank grayscale and color images. We will also see the functions for drawing lines,
    rectangles, ellipses, circles, and text on images.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们可能需要创建自己的图像或在现有图像上绘制一些形状。或者，我们可能想在检测到的对象周围绘制边界框或在图像上显示标签。因此，在本节中，我们将看到如何创建空白灰度和彩色图像。我们还将看到在图像上绘制线条、矩形、椭圆、圆和文本的函数。
- en: 'To create an empty black image of the size 256 x 256, the following code can
    be used:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个大小为 256 x 256 的空黑色图像，可以使用以下代码：
- en: '[PRE8]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The code is more or less similar to the code developed for reading an image,
    but instead of using the `imread` command here, the image is created using the
    constructor of the `Mat` class only. As discussed earlier, we can provide the
    size and data type while creating a `Mat` object. So while creating an `img` object,
    we have provided four arguments. The first two arguments specify the size of an
    image, which first defines the number of rows (height) and second defines the
    number of columns (width). The third argument defines the data type of an image.
    We have used `CV_8UC1`, which means an 8-bit unsigned integer image with a single
    channel. The last argument specifies the initialization value for all pixels in
    an array.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 代码与用于读取图像的代码大致相似，但在这里不是使用 `imread` 命令，而是仅使用 `Mat` 类的构造函数来创建图像。如前所述，我们可以在创建 `Mat`
    对象时提供大小和数据类型。因此，在创建 `img` 对象时，我们提供了四个参数。前两个参数指定了图像的大小，第一个参数定义了行数（高度），第二个参数定义了列数（宽度）。第三个参数定义了图像的数据类型。我们使用了
    `CV_8UC1`，这意味着一个单通道的 8 位无符号整数图像。最后一个参数指定了数组中所有像素的初始化值。
- en: 'Here we have used 0, which is the value for black. When this program is executed,
    it will create a black image of size 256 x 256, as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们使用了 0，这是黑色的值。当程序执行时，它将创建一个大小为 256 x 256 的黑色图像，如下所示：
- en: '![](img/b9972d80-a784-4e1b-9351-ea9b5f797e87.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b9972d80-a784-4e1b-9351-ea9b5f797e87.png)'
- en: 'Similar code can be used for creating blank images of any color, as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用类似的代码创建任何颜色的空白图像，如下所示：
- en: '[PRE9]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'While creating a `Mat` object, instead of using the `CV_8UC1` data type, `CV_8UC3`
    is used, which specifies an 8-bit image with three channels. So there are 24 bits
    for a single pixel. The fourth argument specifies the starting pixel values. It
    is specified using the scalar keyword and a tuple of three values specifying starting
    values in all three channels. Here, the blue channel is initialized with 255,
    the green channel is initialized with 0, and red channel is initialized with 0\.
    This will create an image of size 256 x 256 in blue. Different combinations of
    values in tuple will create different colors. The output of the preceding program
    is as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建 `Mat` 对象时，不是使用 `CV_8UC1` 数据类型，而是使用 `CV_8UC3`，它指定了一个具有三个通道的 8 位图像。因此，单个像素有
    24 位。第四个参数指定了起始像素值。它使用标量关键字和一个包含所有三个通道起始值的元组来指定。在这里，蓝色通道初始化为 255，绿色通道初始化为 0，红色通道初始化为
    0。这将创建一个大小为 256 x 256 的蓝色图像。元组中值的组合将创建不同的颜色。前述程序的输出如下：
- en: '![](img/1e87d4d9-3416-4414-a587-247befa168cd.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1e87d4d9-3416-4414-a587-247befa168cd.png)'
- en: Drawing shapes on the blank image
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在空白图像上绘制形状
- en: 'To start drawing different shapes on an image, we will start by creating a
    blank black image of arbitrary size with the following command:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始在图像上绘制不同的形状，我们将首先使用以下命令创建一个任意大小的空白黑色图像：
- en: '[PRE10]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This command will create a black image of the size 512 x 512\. Now, we will
    start by drawing different shapes on this image.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将创建一个大小为 512 x 512 的黑色图像。现在，我们将开始在这个图像上绘制不同的形状。
- en: Drawing a line
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制线条
- en: 'A line can be specified by two points: the start point and end point. To draw
    a line on the image, these two points have to be specified. The function to draw
    a line on an image is as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 一条线可以通过两个点来指定：起点和终点。要在图像上绘制线条，必须指定这两个点。在图像上绘制线条的函数如下：
- en: '[PRE11]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The line function has five arguments. The first argument specifies the image
    on which a line needs to be drawn, the second and third arguments define the start
    point and end points, respectively. The points are defined using the `Point` class
    constructor, which takes *x* and *y* coordinates of an image as argument. The
    fourth argument specifies the color of the line. It is specified as a tuple of
    B, G, and R values. Here, the value taken is `(0,255,0)`, which specifies green.
    The fifth argument is the thickness of the line. Its value is taken as 7 pixels
    wide. This function also has an optional `linetype` argument. The preceding function
    will draw a diagonal green line of 7 pixels wide from `(0,0)` to `(511,511)`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 线函数有五个参数。第一个参数指定需要绘制线的图像，第二个和第三个参数分别定义起点和终点。这些点使用 `Point` 类构造函数定义，该构造函数以图像的
    *x* 和 *y* 坐标为参数。第四个参数指定线的颜色。它指定为 B、G 和 R 值的元组。这里，取值为 `(0,255,0)`，指定绿色。第五个参数是线的厚度。其值被设置为
    7 像素宽。此函数还有一个可选的 `linetype` 参数。前面的函数将绘制一个从 `(0,0)` 到 `(511,511)` 的对角线绿色线，宽度为 7
    像素。
- en: Drawing a rectangle
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制矩形
- en: 'A rectangle can be specified using two extreme diagonal points. OpenCV provides
    a function for drawing a rectangle on an image that has syntax as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 矩形可以使用两个极端对角点来指定。OpenCV 提供了一个在图像上绘制矩形的函数，其语法如下：
- en: '[PRE12]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The rectangle function has five arguments. The first argument is the image on
    which the rectangle is to be drawn. The second argument is the top-left point
    of the rectangle. The third argument is the bottom-right point of the rectangle.
    The fourth argument specifies the color of the border. It is specified as `(255,255,0)`,
    which is a mix of blue and green, giving cyan. The fifth argument is the thickness
    of the border. If the fifth argument is specified as `-1`, the shape will be filled
    with color. So the preceding function will draw a rectangle with two extreme points,
    `(384,0)` and `(510,128)`, in cyan with a border thickness of 5 pixels.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 矩形函数有五个参数。第一个参数是需要绘制矩形的图像。第二个参数是矩形的左上角点。第三个参数是矩形的右下角点。第四个参数指定边框的颜色。它指定为 `(255,255,0)`，是蓝色和绿色的混合，产生青色。第五个参数是边框的厚度。如果第五个参数被指定为
    `-1`，则形状将被填充。因此，前面的函数将使用两个极端点 `(384,0)` 和 `(510,128)`，以青色绘制一个边框厚度为 5 像素的矩形。
- en: Drawing a circle
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制圆
- en: 'A circle can be specified by a center and its radius. OpenCV provides a function
    for drawing a circle on an image that has syntax as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 圆可以通过中心和半径来指定。OpenCV 提供了一个在图像上绘制圆的函数，其语法如下：
- en: '[PRE13]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The circle function has five arguments. The first argument is the image on which
    a circle needs to be drawn. The second argument specifies the center point for
    that circle and the third argument specifies the radius. The fourth argument specifies
    the color of the circle. The value taken is `(0,0,255)`, which is red. The fifth
    argument is the thickness of the border. Here, it is `-1`, which means the circle
    will be filled with red color.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 圆函数有五个参数。第一个参数是需要绘制圆的图像。第二个参数指定该圆的中心点，第三个参数指定半径。第四个参数指定圆的颜色。取值为 `(0,0,255)`，表示红色。第五个参数是边框的厚度。这里，它被设置为
    `-1`，意味着圆将被红色填充。
- en: Drawing an ellipse
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制椭圆
- en: 'OpenCV provides a function for drawing an ellipse on an image that has syntax
    as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV 提供了一个在图像上绘制椭圆的函数，其语法如下：
- en: '[PRE14]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The ellipse function has many arguments. The first argument specifies the image
    on which an ellipse needs to be drawn. The second argument specifies the center
    of the ellipse. The third argument specifies the box size under which the ellipse
    will be drawn. The fourth argument specifies the angle by which the ellipse needs
    to be rotated. It is taken as `0` degrees. The fifth and sixth argument specifies
    the range of angles for which the ellipse needs to be drawn. It is taken as `0`
    to `180` degrees. So only half the ellipse will be drawn. The next argument specifies
    the color of the ellipse, which is specified only as `255.` It is the same as
    `(255,0,0)`, which is blue. The final argument specifies the thickness of the
    border. It is taken as `-1`, so the ellipse will be filled with blue.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 椭圆函数有许多参数。第一个参数指定需要绘制椭圆的图像。第二个参数指定椭圆的中心。第三个参数指定椭圆将要绘制的框的大小。第四个参数指定椭圆需要旋转的角度。它被设置为
    `0` 度。第五个和第六个参数指定椭圆需要绘制的角度范围。它被设置为 `0` 到 `180` 度。因此，只会绘制椭圆的一半。下一个参数指定椭圆的颜色，它被指定为
    `255.` 它与 `(255,0,0)` 相同，表示蓝色。最后一个参数指定边框的粗细。它被设置为 `-1`，因此椭圆将被蓝色填充。
- en: Writing text on an image
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在图像上写文本
- en: 'OpenCV provides a function for writing text on an image, which is `putText`.
    The syntax for the function is as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV 提供了一个在图像上写文本的函数，即 `putText`。该函数的语法如下：
- en: '[PRE15]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `putText` function has many arguments. The first argument is the image on
    which text is to be written. The second argument is the text as a String data
    type, which we want to write on an image. The third argument specifies the bottom-left
    corner of the text. The fourth argument specifies the font type. There are many
    font types available in OpenCV, for which you can check OpenCV documentation.
    The fifth argument specifies the scale of the font. The sixth argument is the
    color of the text. It is taken as `(255,255,255)`, which makes white. The seventh
    argument is the thickness of the text, which is taken as `5`, and the last argument
    specifies linetype, which is taken as `8`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`putText` 函数有许多参数。第一个参数是要在图像上写文本的图像。第二个参数是作为字符串数据类型的文本，我们想要在图像上写的内容。第三个参数指定文本的左下角。第四个参数指定字体类型。OpenCV
    中有许多可用的字体类型，你可以查看 OpenCV 文档。第五个参数指定字体的缩放比例。第六个参数是文本的颜色。它被设置为 `(255,255,255)`，表示白色。第七个参数是文本的粗细，它被设置为
    `5`，最后一个参数指定线型，它被设置为 `8`。'
- en: 'We have seen separate functions for drawing shapes on an empty black image.
    The following code shows the combination of all the functions previously discussed:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了在空黑图像上绘制形状的单独函数。以下代码显示了之前讨论的所有函数的组合：
- en: '[PRE16]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The output image for the preceding code is as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码的输出图像如下：
- en: '![](img/64132bc6-ebc6-4a44-af34-897ba587faa8.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](img/64132bc6-ebc6-4a44-af34-897ba587faa8.png)'
- en: Saving an image to a file
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将图像保存到文件
- en: 'Images can also be saved to a disk from the OpenCV program. This is helpful
    when we want to store our processed image to a disk on a computer. OpenCV provides
    the `imwrite` function to do this operation. The syntax of this function is as
    follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图像也可以从 OpenCV 程序保存到磁盘。当我们想要将处理后的图像存储到计算机上的磁盘时，这很有用。OpenCV 提供了 `imwrite` 函数来完成此操作。此函数的语法如下：
- en: '[PRE17]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `imwrite` function takes two arguments. The first argument is the name of
    the file you want to save along with its path. The second argument is the `img`
    variable that you want to save. This function returns a Boolean value that indicates
    whether the file is saved successfully or not on a disk.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`imwrite` 函数接受两个参数。第一个参数是你想要保存的文件名及其路径。第二个参数是你想要保存的 `img` 变量。此函数返回一个布尔值，表示文件是否成功保存到磁盘上。'
- en: In this section, we have worked with images using OpenCV. In the next section,
    we will work with videos, which are nothing but a sequence of images, using OpenCV.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们使用 OpenCV 处理了图像。在下一节中，我们将使用 OpenCV 处理视频，视频不过是图像的序列。
- en: Working with videos in OpenCV
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 OpenCV 中处理视频
- en: This section will show the process for reading videos from a file and webcam
    using OpenCV. It will also describe the process for saving videos to a file. This
    can also work with USB cameras attached to computers. Videos are nothing more
    than a sequence of images. Though OpenCV is not optimized for video processing
    applications, it does a decent job with it. OpenCV is not able to capture audio,
    so we have to use some other utilities with OpenCV to capture both audio and video.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将展示使用OpenCV从文件和摄像头读取视频的过程。它还将描述将视频保存到文件的过程。这也可以与连接到计算机的USB摄像头一起工作。视频不过是图像的序列。尽管OpenCV不是针对视频处理应用程序优化的，但它在这方面做得相当不错。OpenCV无法捕获音频，因此我们必须使用其他一些与OpenCV一起使用的工具来捕获音频和视频。
- en: Working with video stored on a computer
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在计算机上处理视频
- en: This section describes the process of reading a video file stored on a computer.
    All the frames from a video will be read one by one, operated upon, and displayed
    on the screen in all video processing applications using OpenCV.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 本节描述了读取存储在计算机上的视频文件的过程。在所有使用OpenCV的视频处理应用程序中，视频的所有帧将逐个读取、处理并在屏幕上显示。
- en: 'The following code is for reading and displaying video—a line-by-line explanation
    is then given:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码用于读取和显示视频——随后将逐行解释：
- en: '[PRE18]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: After including libraries, the first thing that needs to be done inside the
    main function for processing video is to create an object of `VideoCapture`. The
    `VideoCapture` class has many constructors available for working with videos.
    When we want to work with video files stored on a computer, we need to provide
    the name of the video along with its path as an argument to the constructor while
    creating an object of `VideoCapture`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在包含库之后，在主函数中处理视频的第一件事是创建一个`VideoCapture`对象。`VideoCapture`类提供了许多构造函数，可用于处理视频。当我们想要处理存储在计算机上的视频文件时，我们需要在创建`VideoCapture`对象时将视频的名称及其路径作为参数传递给构造函数。
- en: This object provides many methods and properties that give information related
    to a video. We will see those as and when they are required. It provides the `isopened`
    property, which indicates whether the object creation was successful and whether
    or not video is available. It returns a Boolean value. If `cap.isopened` is `false`,
    the video is not available so there is no need to go any further in the program.
    So that is handled by an `if` loop, which exits the program after notifying the
    user when a video is not available.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 此对象提供了许多方法和属性，可以提供与视频相关的信息。我们将根据需要查看它们。它提供了`isopened`属性，该属性指示对象创建是否成功以及视频是否可用。它返回一个布尔值。如果`cap.isopened`为`false`，则视频不可用，因此无需在程序中进一步操作。这通过一个`if`循环处理，当视频不可用时，会通知用户并退出程序。
- en: The `VideoCapture` class provides a read method that captures the frames one
    by one. To process the entire video, we have to start a continuous loop that runs
    until the end of the video. The infinite `while` loop can do this job. Inside
    the `while` loop, the first frame is read using the read method. This method has
    one argument. It is a Mat object in which we want to store the frame. It returns
    a Boolean value that indicates whether the frame has been read successfully or
    not. When the loop has reached the end of video, this Boolean will return `false`,
    indicating there is no frame available. This flag is checked continuously in the
    loop for the end of the video; and if it is detected, we come out of the `while`
    loop using the `break` statement.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`VideoCapture`类提供了一个读取方法，可以逐个捕获帧。为了处理整个视频，我们必须启动一个连续的循环，该循环一直运行到视频的末尾。无限`while`循环可以完成这项工作。在`while`循环内部，使用读取方法读取第一帧。此方法有一个参数。它是一个Mat对象，我们希望在其中存储帧。它返回一个布尔值，指示帧是否已成功读取。当循环到达视频的末尾时，此布尔值将返回`false`，表示没有可用的帧。这个标志在循环中持续检查视频的结束；如果检测到，我们将使用`break`语句退出`while`循环。'
- en: The frame is a single image, so displaying the process for that is the same
    as we saw earlier. In the preceding code, the `waitKey` function is used inside
    an `if` statement. It is waiting for 100 ms after every frame for a keystroke.
    The `if` statement is checking whether the keystroke is `q` or not. If it is `q`,
    it means that the user wants to quit the video so the break statement is included
    inside `if`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 帧是单个图像，因此显示该帧的过程与之前看到的是相同的。在上面的代码中，`waitKey`函数在`if`语句中使用。它会在每个帧之后等待100毫秒以获取按键。`if`语句正在检查按键是否为`q`。如果是`q`，则表示用户想要退出视频，因此在`if`中包含了break语句。
- en: 'This code will terminate display of the video either when the whole video is
    finished or the user presses `q` on the keyboard. Throughout this book, we will
    use this coding practice while processing videos. The output of the preceding
    program is as follows. The screenshot is a frame from a video:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码将在整个视频播放完毕或用户在键盘上按下`q`键时终止视频显示。在整个本书中，我们将使用这种编码实践来处理视频。前一个程序的输出如下。截图是视频的一帧：
- en: '![](img/0fb84cb8-4eb4-4e8b-8652-97e2aac8a371.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0fb84cb8-4eb4-4e8b-8652-97e2aac8a371.png)'
- en: 'We have used 100 ms delay between every frame. What do you think will happen
    when you decrease this value to, maybe, 10 ms? The answer is, each frame will
    be displayed faster. It does not mean the frame rate of the video changes. It
    just means that the delay between frames is reduced. If you want to see the actual
    frame rate of the video, you can use the `CAP_PROP_FPS` property of the `cap`
    object. It can be displayed with the following code:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在每帧之间使用了100毫秒的延迟。当你将这个值减少到，比如，10毫秒时，你认为会发生什么？答案是，每帧将显示得更快。这并不意味着视频的帧率改变了。这只是意味着帧之间的延迟减少了。如果你想看到视频的实际帧率，可以使用`cap`对象的`CAP_PROP_FPS`属性。它可以使用以下代码显示：
- en: '[PRE19]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `cap` object also has other properties, such as `CAP_PROP_FRAME_WIDTH` and
    `CAP_PROP_FRAME_HEIGHT`, which indicate the width and height of the frames. It
    can also be fetched with the `get` method. These properties can be set by using
    a `set` method of cap object. The `set` method has two arguments. The first argument
    is the `name` of the property and the second argument is the `value` we want to
    set.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`cap`对象还具有其他属性，例如`CAP_PROP_FRAME_WIDTH`和`CAP_PROP_FRAME_HEIGHT`，它们表示帧的宽度和高度。这些属性也可以通过`get`方法获取。这些属性可以通过使用cap对象的`set`方法来设置。`set`方法有两个参数。第一个参数是属性的`name`，第二个参数是我们想要设置的`value`。'
- en: This section described the method to read a video from a file. The next section
    will show the process for working with videos from either a webcam or USB camera.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 本节描述了从文件中读取视频的方法。下一节将展示从网络摄像头或USB摄像头处理视频的过程。
- en: Working with videos from a webcam
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理网络摄像头视频
- en: 'This section describes the process for capturing a video from a webcam or USB
    camera attached to a computer. The good part of OpenCV is that this same code
    will work for laptop and any embedded system that can run C/C++. This helps in
    deploying computer vision applications on any hardware platforms. The code for
    capturing video and displaying it is as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 本节描述了从连接到计算机的网络摄像头或USB摄像头捕获视频的过程。OpenCV的好处是，相同的代码将适用于笔记本电脑和任何可以运行C/C++的嵌入式系统。这有助于在任意硬件平台上部署计算机视觉应用。捕获视频并显示的代码如下：
- en: '[PRE20]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: While capturing video from a webcam or USB camera, the device ID for that camera
    needs to be provided as an argument to the constructor of the `VideoCapture` object.
    The primary camera connected will have a device ID zero. The webcam of a laptop
    or USB camera (when there is no webcam) will have device ID zero. If there are
    multiple cameras connected to a device, their device ID will be `(0,1)`, and so
    on. In the preceding code, zero indicates that the primary camera will be used
    by the code to capture the video.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在从网络摄像头或USB摄像头捕获视频时，需要将那个摄像头的设备ID作为`VideoCapture`对象构造函数的参数提供。连接的主摄像头将具有设备ID零。笔记本电脑的网络摄像头或USB摄像头（当没有网络摄像头时）将具有设备ID零。如果有多个摄像头连接到设备，它们的设备ID将是`(0,1)`，依此类推。在前面的代码中，零表示代码将使用主摄像头来捕获视频。
- en: 'The other code is more or less similar to the code for reading video from a
    file. Here, the frame rate of the video is also fetched and displayed. The frames
    will be read one by one at a 1 ms interval and displayed on the window created.
    You have to press `q` to terminate the operation. The output of video captured
    using the webcam is as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 另一段代码与从文件读取视频的代码大致相似。在这里，视频的帧率也被获取并显示。帧将以每1毫秒的间隔逐个读取，并在创建的窗口中显示。您必须按`q`键来终止操作。使用网络摄像头捕获的视频输出如下：
- en: '![](img/bbd291d5-2c10-41d3-a2ed-85d868e0a1e4.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bbd291d5-2c10-41d3-a2ed-85d868e0a1e4.png)'
- en: Saving video to a disk
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将视频保存到磁盘
- en: 'To save video from the OpenCV program, we need to create an object of the `VideoWriter`
    class. The code to save a video to a file is as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 要从OpenCV程序保存视频，我们需要创建`VideoWriter`类的对象。将视频保存到文件的代码如下：
- en: '[PRE21]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: While creating an object of the `VideoWriter` class, the constructor takes five
    arguments. The first argument is the name of the video file you want to save along
    with the absolute or relative path. The second argument is the four character
    code used for video codec. It is created using the `VideoWriter::fourcc` function.
    Here we are using motion JPEG codec, so the four character code for it is `'M'`,
    `'J'`, `'P'`, and `'G'`. There are other codecs that can be used depending on
    your requirements and operating system. The third argument is frames per second.
    It can be specified as an integer variable previously defined or an integer value
    directly in the function. In the preceding code, `30` frames per second is used.
    The fourth argument is the size of the frame. It is defined using the `size` keyword
    with two arguments, `frame_width` and `frame_height`. It is taken as 640 x 640
    in the preceding code. The fifth argument specifies whether the frame to be stored
    is color or grayscale. If its true, the frame is saved as a color frame.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建`VideoWriter`类的对象时，构造函数接受五个参数。第一个参数是你想要保存的视频文件名及其绝对或相对路径。第二个参数是用于视频编解码器的四个字符代码。它是通过`VideoWriter::fourcc`函数创建的。在这里，我们使用运动JPEG编解码器，因此它的四个字符代码是`'M'`、`'J'`、`'P'`和`'G'`。根据你的需求和操作系统，可以使用其他编解码器。第三个参数是每秒帧数。它可以指定为一个之前定义的整数变量或直接在函数中的整数值。在前面的代码中，使用了每秒`30`帧。第四个参数是帧的大小。它使用`size`关键字和两个参数`frame_width`和`frame_height`定义。在前面的代码中，它被定义为640
    x 640。第五个参数指定要存储的帧是彩色还是灰度。如果是真的，帧将以彩色帧保存。
- en: To start writing frames using the `VideoWriter` object, OpenCV provides a `write`
    method. This method is used to write frames into video one by one, so it is included
    inside an infinite `while` loop. This method takes only one argument, which is
    the name of the frame variable. The size of the frame should be the same as the
    size specified while creating the `VideoWriter` object. It is important to flush
    and close the video file created after writing is finished. This can be done by
    releasing the created `VideoWriter` object using the `release` method.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用`VideoWriter`对象写入帧，OpenCV提供了一个`write`方法。此方法用于逐个将帧写入视频，因此它包含在一个无限`while`循环中。此方法仅接受一个参数，即帧变量的名称。帧的大小应与创建`VideoWriter`对象时指定的相同。在写入完成后，重要的是刷新并关闭创建的视频文件。这可以通过使用`release`方法释放创建的`VideoWriter`对象来完成。
- en: To summarize, in this section we looked at the process of reading video from
    a file or camera attached to a device. We have also seen the code for writing
    a video to a file. From the next section onward, we will see how we can operate
    on images or videos using OpenCV with CUDA acceleration.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，在本节中，我们探讨了从设备上的文件或摄像头读取视频的过程。我们还看到了将视频写入文件的代码。从下一节开始，我们将看到如何使用CUDA加速的OpenCV在图像或视频上操作。
- en: Basic computer vision applications using the OpenCV CUDA module
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用OpenCV CUDA模块的基本计算机视觉应用
- en: In earlier chapters, we saw that CUDA provides an excellent interface to utilize
    the parallel computing capability of GPU to accelerate complex computing applications.
    In this section, we will see how we can utilize the capability of CUDA alongside
    OpenCV for computer vision applications.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们了解到CUDA提供了一个优秀的接口，可以充分利用GPU的并行计算能力来加速复杂的计算应用。在本节中，我们将看到如何利用CUDA的能力与OpenCV一起用于计算机视觉应用。
- en: Introduction to the OpenCV CUDA module
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenCV CUDA模块简介
- en: OpenCV has a CUDA module that has hundreds of functions that can utilize GPU
    capabilities. It is only supported on Nvidia GPUs because it uses Nvidia CUDA
    runtime in the background. OpenCV has to be compiled with the `WITH_CUDA` flag
    set to ON for using the CUDA module.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV有一个CUDA模块，它包含数百个可以利用GPU能力的函数。它仅支持Nvidia GPU，因为它在后台使用Nvidia CUDA运行时。为了使用CUDA模块，OpenCV必须编译时设置`WITH_CUDA`标志为ON。
- en: One great feature of using the CUDA module of OpenCV is that it provides a similar
    API to regular OpenCV API. It also does not require detailed knowledge of programming
    in CUDA, although knowledge of CUDA and GPU architecture will not do any harm.
    The researchers have shown that using functions with CUDA acceleration can provide
    5x-100x speedup over similar CPU functions.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 使用OpenCV CUDA模块的亮点之一是它提供了一个与常规OpenCV API相似的API。它也不需要详细了解CUDA编程，尽管了解CUDA和GPU架构不会有害。研究人员已经表明，使用具有CUDA加速的函数可以比类似的CPU函数提供5x-100x的速度提升。
- en: In the next section, we will see how to use the CUDA module along with OpenCV
    in various computer vision and image processing applications that operate on individual
    pixels of an image.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到如何使用CUDA模块与OpenCV结合，在各种计算机视觉和图像处理应用中使用，这些应用在图像的各个像素上操作。
- en: Arithmetic and logical operations on images
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图像上的算术和逻辑运算
- en: In this section, we will see how to perform various arithmetic and logical operations
    on images. We will use functions defined in the CUDA module of OpenCV to perform
    these operations.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看到如何在图像上执行各种算术和逻辑运算。我们将使用OpenCV CUDA模块中定义的函数来执行这些操作。
- en: Addition of two images
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 两个图像的相加
- en: 'The addition of two images can be performed when two images are of the same
    size. OpenCV provides an `add` function inside the `cv::cuda` namespace for addition
    operation. It performs pixel-wise addition of two images. Suppose in two images,
    the pixel at `(0,0)` has intensity values 100 and 150 respectively. The intensity
    value in the resultant image will be 250, which is the addition of two intensity
    values. OpenCV addition is a saturated operation, which means that if an answer
    of addition goes above 255, it will be saturated at 255\. The code to perform
    addition is as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个图像大小相同时，可以执行两个图像的相加。OpenCV在`cv::cuda`命名空间内提供了一个`add`函数用于加法操作。它执行两个图像的逐像素相加。假设在两个图像中，`(0,0)`处的像素强度值分别为100和150。结果图像中的强度值将是250，这是两个强度值的相加。OpenCV的加法是一个饱和操作，这意味着如果加法的结果超过255，它将被饱和到255。执行加法的代码如下：
- en: '[PRE22]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: When any computer vision operation needs to be performed on GPU, the images
    have to be stored on device memory. The memory for it can be allocated with the
    `gpumat` keyword, which is similar to the Mat type used for host memory. The images
    are read in the same way as earlier. Two images are read for addition and stored
    in host memory. These images are copied to device memory using the `upload` method
    of device `memory` variable. The host image variable is passed as a parameter
    to this method.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 当任何计算机视觉操作需要在GPU上执行时，图像必须存储在设备内存中。为此内存的分配可以使用`gpumat`关键字，它与用于主机内存的Mat类型相似。图像的读取方式与之前相同。读取两个图像用于相加，并存储在主机内存中。这些图像使用设备`memory`变量的`upload`方法复制到设备内存。主机图像变量作为参数传递给此方法。
- en: The function in the GPU CUDA module is defined in the `cv::cuda` namespace.
    It requires images on device memory as its arguments. The add function from the
    CUDA module is used for image addition. It requires three arguments. The first
    two arguments are two images that are to be added and the last argument is the
    destination in which the result will be stored. All three variables should be
    defined using `gpumat`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: GPU CUDA模块中的函数定义在`cv::cuda`命名空间中。它需要设备内存中的图像作为其参数。CUDA模块中的add函数用于图像相加。它需要三个参数。前两个参数是要相加的两个图像，最后一个参数是结果将存储的目标。所有三个变量都应该使用`gpumat`定义。
- en: 'The resultant image is copied back to the host using the download method of
    the device variable. The host `img` variable, in which the result will be copied,
    is provided as an argument to the download method. Then this image is displayed
    and stored on the disk using the same functions explained in the last section.
    The output of the program is as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 使用设备变量的`download`方法将结果图像复制回主机。将结果复制的`img`主机变量作为参数传递给`download`方法。然后使用上一节中解释的相同函数显示和存储此图像。程序的输出如下：
- en: '![](img/11f0673e-6243-40ea-a63c-3ed65d56effe.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/11f0673e-6243-40ea-a63c-3ed65d56effe.png)'
- en: Subtracting two images
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从两个图像中减去
- en: 'Other arithmetic operations can be performed on images using OpenCV and CUDA.
    The `subtract` function is provided by OpenCV to subtract two images. It is also
    a saturated operation, which means that when the answer of subtraction goes below
    zero, it will be saturated to zero. The syntax of the subtract command is as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 使用OpenCV和CUDA可以在图像上执行其他算术运算。OpenCV提供了`subtract`函数来减去两个图像。它也是一个饱和操作，这意味着当减法的结果低于零时，它将被饱和到零。`subtract`命令的语法如下：
- en: '[PRE23]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Again, two images to be subtracted are provided as the first two arguments
    and the resultant image is provided as the third argument. The result of the subtraction
    between two images is as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，两个要减去的图像作为前两个参数提供，结果图像作为第三个参数提供。两个图像之间的减法结果如下：
- en: '![](img/c0ea336f-3adf-482f-b9f8-e36d6f7dfc19.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c0ea336f-3adf-482f-b9f8-e36d6f7dfc19.png)'
- en: Image blending
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图像混合
- en: 'Sometimes there is a need to blend two images with different proportions, instead
    of directly adding two images. Image blending can be represented mathematically
    by the following equation:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 有时需要以不同的比例混合两个图像，而不是直接将两个图像相加。图像混合可以用以下方程式表示：
- en: '[PRE24]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This can be easily accomplished with the `addWeighted` function inside OpenCV.
    The syntax of the function is as follows:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过OpenCV中的`addWeighted`函数轻松实现。该函数的语法如下：
- en: '[PRE25]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The function has six arguments. The first argument is the first source image,
    the second argument is a weight of the first image for blending, the third argument
    is the second source image, the fourth argument is a weight of the second image
    for blending, and the fifth argument is the constant gamma to be added while blending.
    The final argument specifies the destination in which the result needs to be stored.
    The function given takes 70 percent of `img1` and 30 percent of `img2` for blending.
    The output for this function is as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数有六个参数。第一个参数是第一个源图像，第二个参数是第一个图像的混合权重，第三个参数是第二个源图像，第四个参数是第二个图像的混合权重，第五个参数是在混合时需要添加的常数伽玛，最后一个参数指定结果需要存储的目标位置。该函数将`img1`的70%和`img2`的30%用于混合。该函数的输出如下：
- en: '![](img/a4c7e83e-3a4d-48aa-ac63-21bfee47ade3.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a4c7e83e-3a4d-48aa-ac63-21bfee47ade3.png)'
- en: Image inversion
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图像反转
- en: 'Apart from arithmetic operations, OpenCV also provides Boolean operations that
    work on individual bits. It includes AND, OR, NOT, and so on. AND and OR are very
    useful for masking operations, as we will see later on. The NOT operation is used
    for inverting an image where black is converted to white and white is converted
    to black. It can be represented by the following equation:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 除了算术运算外，OpenCV还提供了对单个位进行操作的布尔运算。它包括AND、OR、NOT等。AND和OR在掩码操作中非常有用，我们将在后面看到。NOT操作用于反转图像，其中黑色转换为白色，白色转换为黑色。它可以表示为以下方程式：
- en: '[PRE26]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In the equation, `255` indicates maximum intensity value for an 8-bit image.
    The program for doing image inversion is as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在方程式中，`255`表示8位图像的最大强度值。进行图像反转的程序如下：
- en: '[PRE27]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The program is similar to the program for arithmetic operations. The `bitwise_not`
    function is used for image inversion. The image should be a grayscale image. It
    takes two arguments. The first argument indicates the source image to be inverted
    and the second argument indicates the destination in which the inverted image
    is to be stored. The output of the `bitwise_not` operation is as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序与算术运算程序类似。使用`bitwise_not`函数进行图像反转。图像应该是灰度图像。它接受两个参数。第一个参数指示要反转的源图像，第二个参数指示反转图像要存储的目标位置。`bitwise_not`操作的输出如下：
- en: '![](img/3c8c110f-a1f8-4b8d-a6d0-cd6e5b734a5d.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3c8c110f-a1f8-4b8d-a6d0-cd6e5b734a5d.png)'
- en: As can be seen, by doing an inversion, white is converted to black and black
    is converted to white.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如所示，通过反转，白色转换为黑色，黑色转换为白色。
- en: To summarize, in this section, we have seen various arithmetic and logical operations
    using OpenCV and CUDA. In the next section, we will see some more computer vision
    operations that are widely used in computer vision applications.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，在本节中，我们看到了使用OpenCV和CUDA的各种算术和逻辑操作。在下一节中，我们将看到一些在计算机视觉应用中广泛使用的计算机视觉操作。
- en: Changing the color space of an image
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改变图像的色彩空间
- en: 'As described earlier, OpenCV can read an image as a grayscale image or as a
    color image, with three channels green, blue, and red, which is called BGR format.
    Other image processing software and algorithms work on RGB images, where the red
    channel is followed by green and blue. There are many other color formats that
    can be used for certain applications. These include the HSV color space, where
    the three channels are Hue, Saturation, and Value. Hue represents color value,
    saturation indicates the gray level in the color, and value represents the brightness
    of the color. The other color space is YCrCb, which is also very useful. This
    system represents colors in an image in terms of one luminance component: luma
    (Y), and two chrominance components: chroma(Cb and Cr).'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，OpenCV可以以灰度图像或彩色图像的形式读取图像，彩色图像具有三个通道：绿色、蓝色和红色，这种格式称为BGR格式。其他图像处理软件和算法在RGB图像上工作，其中红色通道后面是绿色和蓝色。还有许多其他颜色格式可以用于特定应用。这些包括HSV颜色空间，其中三个通道是色调、饱和度和亮度。色调代表颜色值，饱和度表示颜色的灰度级别，亮度代表颜色的亮度。另一个颜色空间是YCrCb，它也非常有用。这个系统用图像中的一个亮度分量：亮度(Y)，和两个色度分量：色度(Cb和Cr)来表示颜色。
- en: 'There are many other color spaces available that are supported by OpenCV, such
    as XYZ, HLS, Lab and so on. OpenCV supports more than 150 color conversion methods.
    The conversion from one color space to another can be accomplished by using the
    `cvtColor` function available in OpenCV. An example of using this function for
    changing between various color space is as follows:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV支持许多其他颜色空间，例如XYZ、HLS、Lab等。OpenCV支持超过150种颜色转换方法。使用OpenCV中的`cvtColor`函数可以将一种颜色空间转换为另一种颜色空间。以下是一个使用此函数在不同颜色空间之间转换的示例：
- en: '[PRE28]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `imshow` function expects color images in BGR color format, so the output
    of other color formats using `imshow` might not be visually attractive. The output
    of the preceding program with the same image in different color formats is as
    follows:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`imshow`函数期望以BGR颜色格式传递彩色图像，因此使用`imshow`显示其他颜色格式的输出可能不会很吸引人。以下是在不同颜色格式下使用相同图像的前一个程序的输出：'
- en: '![](img/404cfcdd-2a72-4031-999f-029adccc4214.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/404cfcdd-2a72-4031-999f-029adccc4214.png)'
- en: Image thresholding
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图像阈值化
- en: Image thresholding is a very simple image segmentation technique used to extract
    important regions from a grayscale image based on certain intensity values. In
    this technique, if the pixel value is greater than a certain threshold value,
    it is assigned one value, otherwise it is assigned another value.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 图像阈值化是一种非常简单的图像分割技术，用于根据某些强度值从灰度图像中提取重要区域。在这种技术中，如果像素值大于某个阈值值，则分配一个值，否则分配另一个值。
- en: 'The function used for image thresholding in OpenCV and CUDA is `cv::cuda::threshold.`
    This function has many arguments. The first argument is the source image, which
    should be a grayscale image. The second argument is the destination in which the
    result is to be stored. The third argument is the threshold value, which is used
    to segment the pixel values. The fourth argument is the `maxVal` constant, which
    represents the value to be given if the pixel value is more than the threshold
    value. OpenCV provides different types of thresholding techniques and it is decided
    by the last argument of the function. These thresholding types are as follows:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV和CUDA中用于图像阈值化的函数是`cv::cuda::threshold`。此函数有许多参数。第一个参数是源图像，它应该是一个灰度图像。第二个参数是结果要存储的目标。第三个参数是阈值值，它用于分割像素值。第四个参数是`maxVal`常量，它表示如果像素值超过阈值值时赋予的值。OpenCV提供不同类型的阈值化技术，由函数的最后一个参数决定。以下是一些阈值化类型：
- en: '`cv:.THRESH_BINARY`: If the intensity of the pixel is greater than the threshold,
    set that pixel intensity equal to the `maxVal` constant. Otherwise set that pixel
    intensity to zero.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cv:.THRESH_BINARY`：如果像素的强度大于阈值，则将该像素强度设置为`maxVal`常量。否则将该像素强度设置为零。'
- en: '`cv::THRESH_BINARY_INV`: If the intensity of the pixel is greater than the
    threshold, set that pixel intensity equal to zero. Otherwise set that pixel intensity
    to `maxVal` constant.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cv::THRESH_BINARY_INV`：如果像素的强度大于阈值，则将该像素强度设置为零。否则将该像素强度设置为`maxVal`常量。'
- en: '`cv::THRESH_TRUNC`: This is basically a truncation operation. If the intensity
    of the pixel is greater than the threshold, set that pixel intensity equal to
    the threshold. Otherwise, keep the intensity value as it is.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cv::THRESH_TRUNC`：这基本上是一个截断操作。如果像素的强度大于阈值，则将该像素强度设置为阈值。否则，保持强度值不变。'
- en: '`cv::THRESH_TOZERO`: If the intensity of the pixel is greater than the threshold,
    keep the pixel intensity as it is. Otherwise set that pixel intensity to zero.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cv::THRESH_TOZERO`：如果像素的强度大于阈值，则保持像素强度不变。否则将该像素强度设置为零。'
- en: '`cv::THRESH_TOZERO_INV`: If the intensity of the pixel is greater than the
    threshold, set that pixel intensity equal to zero. Otherwise keep the pixel intensity
    as it is.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cv::THRESH_TOZERO_INV`：如果像素的强度大于阈值，则将该像素强度设置为零。否则保持像素强度不变。'
- en: 'The program to implement all these thresholding techniques using OpenCV and
    CUDA is as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 实现所有这些阈值技术使用OpenCV和CUDA的程序如下：
- en: '[PRE29]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In the `cv::cuda::threshold` function for all thresholding techniques, 128 is
    taken as a threshold for pixel intensity, which is a midpoint between black (0)
    and white (255). The `maxVal` constant is taken as 255, which will be used to
    update pixel intensity when it exceeds the threshold. The other program is similar
    to other OpenCV programs seen earlier.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有阈值技术的`cv::cuda::threshold`函数中，128被用作像素强度的阈值，这是黑色（0）和白色（255）之间的中点。`maxVal`常量被设置为255，当像素强度超过阈值时将用于更新像素强度。其他程序与之前看到的其他OpenCV程序类似。
- en: 'The output of the program is as follows, which displays the input image along
    with the output of all five thresholding techniques:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的输出如下，显示了输入图像以及所有五种阈值技术的输出：
- en: '![](img/692261da-2d53-4030-8607-b9325fd0ac3f.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/692261da-2d53-4030-8607-b9325fd0ac3f.png)'
- en: Performance comparison of OpenCV applications with and without CUDA support
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带有和没有CUDA支持的OpenCV应用程序的性能比较
- en: The performance of image processing algorithms can be measured in terms of the
    time it takes to process a single image. When algorithms work on video, performance
    is measured in terms of frames per second, which indicates the number of frames
    it can process in a second. When the algorithm can process more than 30 frames
    per second, it can be considered to work in real time. We can also measure the
    performance of our algorithms implemented in OpenCV, which will be discussed in
    this section.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过处理单个图像所需的时间来衡量图像处理算法的性能。当算法在视频上工作时，性能是通过每秒帧数来衡量的，这表示它在一秒内可以处理的帧数。当算法每秒可以处理超过30帧时，它可以被认为是实时工作的。我们还可以衡量在OpenCV中实现的算法的性能，这将在本节中讨论。
- en: 'As we discussed earlier, when OpenCV is built with CUDA compatibility, it can
    increase the performance of algorithms drastically. OpenCV functions in the CUDA
    module are optimized to utilize GPU parallel processing capability. OpenCV also
    provides similar functions that only run on CPU. In this section, we will compare
    the performance of thresholding operations built in the last section with and
    without using GPU. We will compare the performance of the thresholding operation
    in terms of the time taken to process one image and frames per second. The code
    to implement thresholding on CPU and measure performance is as follows:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前讨论的，当OpenCV与CUDA兼容性构建时，它可以显著提高算法的性能。OpenCV在CUDA模块中的函数被优化以利用GPU并行处理能力。OpenCV还提供了仅在CPU上运行的类似函数。在本节中，我们将比较上一节中构建的带有和不使用GPU的阈值操作的性能。我们将从处理一张图像所需的时间和每秒帧数来比较阈值操作的性能。以下是在CPU上实现阈值并测量性能的代码：
- en: '[PRE30]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In the preceding code, the threshold function from the `cv` namespace is used,
    which only uses CPU for execution, rather than the `cv::cuda` module. The performance
    of the algorithm is measured using the `gettickcount` and `gettickfrequency` functions.
    The `gettickcount` function returns the time, in milliseconds, that has passed
    after starting the system. We measured the time ticks before and after the execution
    of the code that operates on the image. The difference between the time ticks
    indicates the ticks passed during an execution of the algorithm to process an
    image. This time is measured in the `delta` variable. The `gettickfrequncy` function
    returns the frequency of the timer. Total time taken to process an image can be
    measured by dividing the time ticks by the frequency of the timer. The inverse
    of this time indicates **frames per second** (**FPS**). Both these performance
    measures are printed on the console for thresholding application on the CPU. The
    output on the console is as follows:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，使用了来自 `cv` 命名空间的阈值函数，该函数仅使用 CPU 进行执行，而不是 `cv::cuda` 模块。算法的性能使用 `gettickcount`
    和 `gettickfrequency` 函数进行测量。`gettickcount` 函数返回自系统启动后经过的毫秒数。我们测量了在图像操作代码执行前后的时间滴答。时间滴答之间的差异表示算法执行过程中处理图像所经过的滴答数。这个时间被测量在
    `delta` 变量中。`gettickfrequncy` 函数返回计时器的频率。处理图像所需的总时间可以通过将时间滴答除以计时器频率来测量。这个时间的倒数表示
    **每秒帧数** （**FPS**）。这两个性能指标都打印在控制台上，用于 CPU 上的阈值应用。控制台输出如下：
- en: '![](img/31947360-0451-4b22-a563-b6a753f4af42.png)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![](img/31947360-0451-4b22-a563-b6a753f4af42.png)'
- en: 'As can be seen from the output, the CPU takes `0.169766` seconds to process
    one image, which is equal to `5.89046` FPS. Now we will implement the same algorithm
    on GPU and try to measure the performance of the code. As per the discussion earlier,
    this should increase the performance of the algorithm drastically. The code for
    GPU implementation is as follows:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如输出所示，CPU 处理一个图像需要 `0.169766` 秒，相当于 `5.89046` FPS。现在我们将同样的算法实现到 GPU 上，并尝试测量代码的性能。根据之前的讨论，这应该会极大地提高算法的性能。GPU
    实现的代码如下：
- en: '[PRE31]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In the code, the functions are used from the `cv::cuda` module, which is optimized
    for GPU parallel processing capabilities. The images are copied to device memory,
    operated upon on GPU, and copied back to host. The performance measures are calculated
    in a similar way as preceding and printed on the console. The output of the program
    is as follows:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，使用了来自 `cv::cuda` 模块的函数，该模块针对 GPU 并行处理能力进行了优化。图像被复制到设备内存，在 GPU 上进行操作，然后复制回主机。性能指标以类似的方式计算，并在控制台上打印。程序输出如下：
- en: '![](img/c5bae944-450a-4c02-ac8b-4bbc4d1d08ba.png)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c5bae944-450a-4c02-ac8b-4bbc4d1d08ba.png)'
- en: As can be seen, ,GPU implementation only takes `0.55` ms to process a single
    image, which is equal to `1816` FPS. This is a drastic improvement over a CPU
    implementation, though it must be kept in mind that this is a very simple application
    and not ideal for performance comparison between CPU and GPU. This application
    was shown simply to make you familiar with how one can measure the performance
    of any code in OpenCV.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 如所示，GPU 实现仅需要 `0.55` 毫秒来处理单个图像，相当于 `1816` FPS。这比 CPU 实现有显著改进，尽管必须记住这是一个非常简单的应用，并不适合于
    CPU 和 GPU 之间的性能比较。这个应用仅展示如何测量 OpenCV 中任何代码的性能。
- en: 'A more realistic comparison of CPU and GPU performance can be made by running
    the example codes provided in the OpenCV installation in the `samples/gpu` directory.
    One of the codes, `hog.cpp`, calculates the **histogram of oriented** (**HoG**)
    features from an image and classifies it using **Support Vector Machine** (**SVM**).
    Though details of algorithms are out of the scope of this book, it gives you an
    idea about performance improvement while using GPU implementations. The performance
    comparison on webcam video is as follows:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行 OpenCV 安装在 `samples/gpu` 目录中的示例代码，可以更真实地比较 CPU 和 GPU 的性能。其中一个代码，`hog.cpp`，从图像中计算
    **方向直方图** （**HoG**）特征，并使用 **支持向量机** （**SVM**）进行分类。尽管算法的细节超出了本书的范围，但它给你一个关于使用 GPU
    实现时性能改进的想法。在摄像头视频上的性能比较如下：
- en: '![](img/41657f1b-89cb-4c02-b19e-cf5b51ce8aad.png)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![](img/41657f1b-89cb-4c02-b19e-cf5b51ce8aad.png)'
- en: As can be seen, while we use only CPU, the performance of the code is around
    13 FPS, and if we use GPU, it increases to 24 FPS, which is almost double the
    CPU performance. This will give you an idea about the importance of using CUDA
    with OpenCV.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如所见，当我们仅使用CPU时，代码的性能大约为13 FPS，如果我们使用GPU，则性能提升至24 FPS，这几乎是CPU性能的两倍。这会让你对使用CUDA与OpenCV结合的重要性有所了解。
- en: To summarize, in this section we looked at a comparison between the performance
    of OpenCV using CUDA (GPU) and without using CUDA (CPU). It reemphasizes the notion
    that use of CUDA will improve the performance of computer vision applications
    drastically.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，在本节中，我们比较了使用CUDA（GPU）和不使用CUDA（CPU）时OpenCV的性能。这再次强调了使用CUDA将极大地提高计算机视觉应用性能的观点。
- en: Summary
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we started with the introduction of computer vision and image
    processing. We described OpenCV library, which is specifically made for computer
    vision applications, and how it is different from other computer vision software.
    OpenCV can leverage the parallel processing capability of GPU by using CUDA. We
    looked at the installation procedure for OpenCV with CUDA in all operating systems.
    We described the process to read an image from disk, display it on screen, and
    save it back to disk. Videos are nothing more than a sequence of images. We learned
    to work with videos from disk as well as videos captured from camera. We developed
    several image processing applications that do different operations on images,
    such as arithmetic operations, logical operations, color space conversions, and
    thresholding. In the last section, we compared the performance of the same algorithm
    on CPU and GPU in terms of time taken to process an image and FPS. So at the end
    of this chapter, you have an idea of the usefulness of OpenCV with CUDA in computer
    vision applications and how to write simple code using it. In the next chapter,
    we will build upon this knowledge and try to develop some more useful computer
    vision applications, such as filtering, edge detection, and morphological operations
    using OpenCV.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '在本章中，我们首先介绍了计算机视觉和图像处理。我们描述了OpenCV库，它专门为计算机视觉应用而设计，以及它与其他计算机视觉软件的不同之处。OpenCV可以通过使用CUDA利用GPU的并行处理能力。我们查看在所有操作系统上安装具有CUDA的OpenCV的安装过程。我们描述了从磁盘读取图像、在屏幕上显示它以及将其保存回磁盘的过程。视频不过是图像的序列。我们学习了如何处理来自磁盘的视频以及从摄像头捕获的视频。我们开发了几个图像处理应用程序，对图像执行不同的操作，例如算术运算、逻辑运算、颜色空间转换和阈值处理。在最后一节中，我们比较了相同算法在CPU和GPU上的性能，包括处理图像所需的时间和FPS。因此，在本章结束时，你对OpenCV与CUDA在计算机视觉应用中的有用性以及如何使用它编写简单代码有了了解。在下一章中，我们将在此基础上尝试开发更多有用的计算机视觉应用，例如使用OpenCV进行滤波、边缘检测和形态学操作。 '
- en: Questions
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: State the difference between terms computer vision and image processing
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 说明计算机视觉和图像处理这两个术语之间的区别
- en: Why is OpenCV ideal for deploying computer vision applications on embedded systems
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么OpenCV非常适合在嵌入式系统上部署计算机视觉应用
- en: Write an OpenCV command to initialize 1960 x 1960 color image with red color
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个OpenCV命令，以红色初始化1960 x 1960彩色图像
- en: Write a program to capture frames from a webcam and save it to disk
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，从网络摄像头捕获帧并将其保存到磁盘
- en: Which color format is used by OpenCV to read and display a color image
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: OpenCV用于读取和显示彩色图像的颜色格式是什么
- en: Write a program to capture video from webcam, convert it to grayscale and display
    on the screen
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，从网络摄像头捕获视频，将其转换为灰度并显示在屏幕上
- en: Write a program to measure the performance of add and subtract operation on
    GPU
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序来测量GPU上加法和减法操作的性能
- en: Write a program for bitwise AND and OR operation on images and explain how it
    can be used for masking
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序进行图像的位与和或操作，并解释它如何用于遮罩
