- en: 'Chapter 5: Problems with Machine Learning on Graphs'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章：图上机器学习的问题
- en: Graph **machine learning** (**ML**) approaches can be useful for a wide range
    of tasks, with applications ranging from drug design to recommender systems in
    social networks. Furthermore, given the fact that such methods are *general by
    design* (meaning that they are not tailored to a specific problem), the same algorithm
    can be used to solve different problems.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 图**机器学习**（**ML**）方法可以用于广泛的任务，其应用范围从药物设计到社交网络中的推荐系统。此外，鉴于这些方法的设计是*通用的*（这意味着它们不是针对特定问题定制的），相同的算法可以用来解决不同的问题。
- en: There are common problems that can be solved using graph-based learning techniques.
    In this chapter, we will mention some of the most well studied of these by providing
    details about how a specific algorithm, among the ones we have already learned
    about in [*Chapter 3*](B16069_03_Final_JM_ePub.xhtml#_idTextAnchor046), *Unsupervised
    Graph Learning,* and[*Chapter 4*](B16069_04_Final_JM_ePub.xhtml#_idTextAnchor064),
    *Supervised Graph Learning*, can be used to solve a task. After reading this chapter,
    you will be aware of the formal definition of many common problems you may encounter
    when dealing with graphs. In addition, you will learn useful ML pipelines that
    you can reuse on future real-world problems you will deal with.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些常见问题可以使用基于图的学习技术来解决。在本章中，我们将通过提供关于如何使用我们已经在[*第3章*](B16069_03_Final_JM_ePub.xhtml#_idTextAnchor046)“无监督图学习”和[*第4章*](B16069_04_Final_JM_ePub.xhtml#_idTextAnchor064)“监督图学习”中已经学习到的特定算法来解决一个任务的细节，来介绍这些问题中最被广泛研究的一些。阅读本章后，你将了解在处理图时可能遇到的一些常见问题的形式化定义。此外，你还将学习到有用的机器学习管道，你可以在未来处理的真实世界问题中重复使用。
- en: 'More precisely, the following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 更精确地说，本章将涵盖以下主题：
- en: Predicting missing links in a graph
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预测图中的缺失链接
- en: Detecting meaningful structures such as communities
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测有意义的结构，如社区
- en: Detecting graph similarities and graph matching
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测图相似性和图匹配
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'We will be using *Jupyter* Notebooks with Python 3.8 for all of our exercises.
    In the following code block, you can see a list of the Python libraries that will
    be installed for this chapter using `pip` (for example, run `pip install networkx==2.5`
    on the command line):'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Python 3.8的*Jupyter*笔记本来完成所有练习。在下面的代码块中，你可以看到使用`pip`为本章安装的Python库列表（例如，在命令行中运行`pip
    install networkx==2.5`）：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: All code files relevant to this chapter are available at [https://github.com/PacktPublishing/Graph-Machine-Learning/tree/main/Chapter05](https://github.com/PacktPublishing/Graph-Machine-Learning/tree/main/Chapter05).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章相关的所有代码文件均可在[https://github.com/PacktPublishing/Graph-Machine-Learning/tree/main/Chapter05](https://github.com/PacktPublishing/Graph-Machine-Learning/tree/main/Chapter05)找到。
- en: Predicting missing links in a graph
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预测图中的缺失链接
- en: '**Link prediction**, also known as **graph completion**, is a common problem
    when dealing with graphs. More precisely, from a partially observed graph—a graph
    where for a certain pair of nodes it is not possible to exactly know if there
    is (or there is not) an edge between them—we want to predict whether or not edges
    exist for the unknown status node pairs, as seen in *Figure 5.1*. Formally, let
    ![](img/B16069_05_001.png) be a graph where ![](img/B16069_05_002.png) is its
    set of nodes and ![](img/B16069_05_003.png) is its set of edges. The set of edges
    ![](img/B16069_05_004.png) are known as *observed links*, while the set of edges
    ![](img/B16069_05_005.png) are known as *unknown links*. The goal of the link
    prediction problem is to exploit the information of ![](img/B16069_05_006.png)
    and ![](img/B16069_05_007.png) to estimate ![](img/B16069_05_008.png). This problem
    is also common when dealing with temporal graph data. In this setting, let ![](img/B16069_05_009.png)
    be a graph observed at a given timepoint ![](img/B16069_05_010.png), where we
    want to predict the edges of this graph at a given timepoint ![](img/B16069_05_011.png).
    The partially observed graph can be seen here:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**链接预测**，也称为**图补全**，是处理图时遇到的一个常见问题。更确切地说，从一个部分观察到的图——在这种图中，对于某些节点对，无法确切知道它们之间是否存在（或不存在）边——我们想要预测未知状态节点对之间是否存在边，如图*图5.1*所示。形式上，设![](img/B16069_05_001.png)为一个图，其中![](img/B16069_05_002.png)是其节点集，![](img/B16069_05_003.png)是其边集。边集![](img/B16069_05_004.png)被称为*观测链接*，而边集![](img/B16069_05_005.png)被称为*未知链接*。链接预测问题的目标是利用![](img/B16069_05_006.png)和![](img/B16069_05_007.png)的信息来估计![](img/B16069_05_008.png)。当处理时间图数据时，这个问题也很常见。在这种情况下，设![](img/B16069_05_009.png)为在给定时间点![](img/B16069_05_010.png)观察到的图，我们想要预测该图在给定时间点![](img/B16069_05_011.png)的边。部分观察到的图如下所示：'
- en: '![Figure 5.1 – Partially observed graph with observed link  (solid lines) and
    unknown link  (dashed lines)](img/B16069_05_01.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![图5.1 – 具有观测链接（实线）和未知链接（虚线）的部分观察图](img/B16069_05_01.jpg)'
- en: Figure 5.1 – Partially observed graph with observed link ![](img/B16069_05_012.png)
    (solid lines) and unknown link ![](img/B16069_05_013.png) (dashed lines)
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1 – 具有观测链接![](img/B16069_05_012.png)（实线）和未知链接![](img/B16069_05_013.png)（虚线）的部分观察图
- en: The link prediction problem is widely used in different domains, such as a recommender
    system in order to propose friendships in social networks or items to purchase
    on e-commerce websites. It is also used in criminal network investigations in
    order to find hidden connections between criminal clusters, as well as in bioinformatics
    for the analysis of protein-protein interactions. In the next sections, we will
    discuss two families of approaches to solve the link prediction problem—namely,
    **similarity-based** and **embedding-based** methods.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 链接预测问题在多个领域得到广泛应用，例如在推荐系统中提出社交网络中的友谊或电子商务网站上的购买项目。它还用于犯罪网络调查，以找到犯罪集群之间的隐藏联系，以及在生物信息学中用于蛋白质-蛋白质相互作用的分析。在接下来的几节中，我们将讨论解决链接预测问题的两种方法族——即**基于相似度**和**基于嵌入**的方法。
- en: Similarity-based methods
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于相似度的方法
- en: 'In this subsection, we show several simple algorithms to solve the label prediction
    problem. The main shared idea behind all these algorithms is to estimate a similarity
    function between each couple of nodes in a graph. If, according to the function,
    the nodes *look similar*, they will have a high probability of being connected
    by an edge. We will divide these algorithms into two sub-families: `networkx`
    library in the `networkx.algorithms.link_prediction` package.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本子节中，我们展示了几个解决标签预测问题的简单算法。所有这些算法背后的主要共同思想是在图中的每对节点之间估计一个相似度函数。如果根据该函数，节点*看起来相似*，它们将有很高的概率通过边连接。我们将将这些算法分为两个子类：`networkx`库中的`networkx.algorithms.link_prediction`包。
- en: Index-based methods
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于索引的方法
- en: In this section, we will show some algorithms available in `networkx` to compute
    the probability of an edge between two disconnected nodes. These algorithms are
    based on the calculation of a simple index through information obtained by analyzing
    the neighbors of the two disconnected nodes.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将展示`networkx`中可用于计算两个不连接节点之间边概率的一些算法。这些算法基于通过分析两个不连接节点的邻居获得的信息来计算一个简单的指标。
- en: Resource allocation index
  id: totrans-20
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 资源分配指标
- en: 'The resource allocation index method estimates the probability that two nodes
    ![](img/B16069_05_014.png) and ![](img/B16069_05_015.png) are connected by estimating
    the *resource allocation index* for all node pairs according to the following
    formula:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 资源分配索引方法通过估计所有节点对根据以下公式计算的资源分配索引来估计两个节点![](img/B16069_05_014.png)和![](img/B16069_05_015.png)之间连接的概率：
- en: '![](img/B16069_05_016.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16069_05_016.jpg)'
- en: 'In the given formula, the ![](img/B16069_05_017.png) function computes the
    neighbors of the ![](img/B16069_05_018.png) nodes and, as visible in the formula,
    ![](img/B16069_05_019.png) is a node who is a neighbor of both ![](img/B16069_05_020.png)
    and ![](img/B16069_05_021.png). This index can be computed in `networkx` using
    the following code:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在给定的公式中，![](img/B16069_05_017.png)函数计算![](img/B16069_05_018.png)节点的邻居，正如公式中所示，![](img/B16069_05_019.png)是同时是![](img/B16069_05_020.png)和![](img/B16069_05_021.png)邻居的节点。这个索引可以使用以下代码在`networkx`中计算：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The first parameter for the `resource_allocation_index` function is an input
    graph, while the second parameter is a list of possible edges. We want to compute
    the probability of a connection. As a result, we get the following output:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`resource_allocation_index`函数的第一个参数是输入图，第二个参数是可能边的列表。我们想要计算连接的概率。因此，我们得到以下输出：'
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The output is a list containing couples of nodes such as `(1,2)`, `(2,5)`, and
    `(3,4)`, which form the resource allocation index. According to this output, the
    probability of having an edge between those couples of nodes is `0.5`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是一个包含节点对如`(1,2)`、`(2,5)`和`(3,4)`的列表，这些节点对构成了资源分配索引。根据这个输出，这些节点对之间存在边的概率是`0.5`。
- en: Jaccard coefficient
  id: totrans-28
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Jaccard系数
- en: 'The algorithm computes the probability of a connection between two nodes ![](img/B16069_05_0201.png)
    and ![](img/B16069_05_021.png), according to the *Jaccard coefficient*, computed
    as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法根据*Jaccard系数*计算两个节点![](img/B16069_05_0201.png)和![](img/B16069_05_021.png)之间的连接概率，计算方法如下：
- en: '![](img/B16069_05_022.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16069_05_022.jpg)'
- en: 'Here, ![](img/B16069_05_023.png) is used to compute the neighbors of the ![](img/B16069_05_024.png)
    node. The function can be used in `networkx` using the following code:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，![](img/B16069_05_023.png)用于计算![](img/B16069_05_024.png)节点的邻居。该函数可以使用以下代码在`networkx`中使用：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `resource_allocation_index` function has the same parameters as the previous
    function. The result of the code is shown here:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`resource_allocation_index`函数与之前的函数具有相同的参数。代码的结果如下：'
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: According to this output, the probability of having an edge between nodes `(1,2)`
    is `0.5`, while between nodes `(2,5)` this is `0.25`, and between nodes `(3,4)`
    this is `0.333`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这个输出，节点`(1,2)`之间存在边的概率是`0.5`，而节点`(2,5)`之间是`0.25`，节点`(3,4)`之间是`0.333`。
- en: In `networkx`, other methods to compute the probability of a connection between
    two nodes based on their similarity score are `nx.adamic_adar_index` and `nx.preferential_attachment`,
    based on *Adamic/Adar index* and *preferential attachment index* calculations
    respectively. Those functions have the same parameters as the others, and accept
    a graph and a list of a couple of nodes where we want to compute the score. In
    the next section, we will show another family of algorithms based on community
    detection.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在`networkx`中，其他基于相似度分数计算两个节点之间连接概率的方法是`nx.adamic_adar_index`和`nx.preferential_attachment`，分别基于*Adamic/Adar指数*和*优先连接指数*的计算。这些函数具有与其他函数相同的参数，并接受一个图和一个节点对的列表，其中我们想要计算分数。在下一节中，我们将展示另一系列基于社区检测的算法。
- en: Community-based methods
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于社区的方法
- en: As with index-based methods, the algorithms belonging to this family also compute
    an index representing the probability of the disconnected nodes being connected.
    The main difference between index-based and community-based methods is related
    to the logic behind them. Indeed, community-based methods, before generating the
    index, need to compute information about the community belonging to those nodes.
    In this subsection, we will show—also providing several examples—some common community-based
    methods.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 与基于索引的方法一样，属于这个家族的算法也计算一个表示断开节点连接概率的索引。基于索引和基于社区的方法之间的主要区别在于它们的逻辑。实际上，基于社区的方法在生成索引之前，需要计算那些节点所属社区的信息。在本小节中，我们将展示一些常见的基于社区的方法，并提供几个示例。
- en: Community common neighbor
  id: totrans-39
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 社区常见邻居
- en: 'In order to estimate the probability of two nodes being connected, this algorithm
    computes the number of common neighbors and adds to this value the number of common
    neighbors belonging to the same community. Formally, for two nodes ![](img/B16069_05_025.png)
    and ![](img/B16069_05_026.png), the community common neighbor value is computed
    as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了估计两个节点连接的概率，此算法计算共同邻居的数量，并将属于同一社区的共同邻居数量添加到这个值中。形式上，对于两个节点 ![img/B16069_05_025.png](img/B16069_05_025.png)
    和 ![img/B16069_05_026.png](img/B16069_05_026.png)，社区共同邻居值的计算如下：
- en: '![](img/B16069_05_027.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![img/B16069_05_027.jpg](img/B16069_05_027.jpg)'
- en: 'In this formula, ![](img/B16069_05_028.png) is used to compute the neighbors
    of node ![](img/B16069_05_029.png), while ![](img/B16069_05_030.png) if ![](img/B16069_05_031.png)
    belongs to the same community of ![](img/B16069_05_032.png) and ![](img/B16069_05_033.png);
    otherwise, this is 0\. The function can be computed in `networkx` using the following
    code:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个公式中，![img/B16069_05_028.png](img/B16069_05_028.png) 用于计算节点 ![img/B16069_05_029.png](img/B16069_05_029.png)
    的邻居，而 ![img/B16069_05_030.png](img/B16069_05_030.png) 如果 ![img/B16069_05_031.png](img/B16069_05_031.png)
    属于 ![img/B16069_05_032.png](img/B16069_05_032.png) 和 ![img/B16069_05_033.png](img/B16069_05_033.png)
    的同一社区，否则，这个值为 0。该函数可以使用以下代码在 `networkx` 中计算：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'From the preceding code snippet, it is possible to see how we need to assign
    the `community` property to each node of the graph. This property is used to identify
    nodes belonging to the same community when computing the function ![](img/B16069_05_034.png)
    defined in the previous equation. The community value, as we will see in the next
    section, can also be automatically computed using specific algorithms. As we already
    saw, the `cn_soundarajan_hopcroft` function takes the input graph and a couple
    of nodes for which we want to compute the score. As a result, we get the following
    output:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码片段中，我们可以看到我们需要如何将 `community` 属性分配给图中的每个节点。这个属性用于在计算之前方程中定义的函数 ![img/B16069_05_034.png](img/B16069_05_034.png)
    时识别属于同一社区的两个节点。正如我们将在下一节中看到的，社区值也可以使用特定的算法自动计算。正如我们已经看到的，`cn_soundarajan_hopcroft`
    函数接受输入图和一对我们想要计算分数的节点。因此，我们得到以下输出：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The main difference from the previous function is in the index value. Indeed,
    we can easily see that the output is not in the range `(0,1)`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前函数的主要区别在于索引值。实际上，我们可以很容易地看到输出不在 `(0,1)` 范围内。
- en: Community resource allocation
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 社区资源分配
- en: 'As with the previous method, the community resource allocation algorithm merges
    information obtained from the neighbors of the nodes with the community, as shown
    in the following formula:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的方法一样，社区资源分配算法将来自节点邻居和社区的信息合并，如下公式所示：
- en: '![](img/B16069_05_035.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![img/B16069_05_035.jpg](img/B16069_05_035.jpg)'
- en: 'Here, ![](img/B16069_05_036.png) is used to compute the neighbors of node ![](img/B16069_05_037.png),
    while ![](img/B16069_05_038.png) if ![](img/B16069_05_039.png) belongs to the
    same community of ![](img/B16069_05_040.png) and ![](img/B16069_05_041.png); otherwise,
    this is 0\. The function can be computed in `networkx` using the following code:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，![img/B16069_05_036.png](img/B16069_05_036.png) 用于计算节点 ![img/B16069_05_037.png](img/B16069_05_037.png)
    的邻居，而 ![img/B16069_05_038.png](img/B16069_05_038.png) 如果 ![img/B16069_05_039.png](img/B16069_05_039.png)
    属于 ![img/B16069_05_040.png](img/B16069_05_040.png) 和 ![img/B16069_05_041.png](img/B16069_05_041.png)
    的同一社区，否则，这个值为 0。该函数可以使用以下代码在 `networkx` 中计算：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'From the preceding code snippet, it is possible to see how we need to assign
    the `community` property to each node of the graph. This property is used to identify
    nodes belonging to the same community when computing the function ![](img/B16069_05_042.png)
    defined in the previous equation. The community value, as we will see in the next
    section, can also be automatically computed using specific algorithms. As we already
    saw, the `ra_index_soundarajan_hopcroft` function takes the input graph and a
    couple of nodes for which we want to compute the score. As a result, we get the
    following output:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码片段中，我们可以看到我们需要如何将 `community` 属性分配给图中的每个节点。这个属性用于在计算之前方程中定义的函数 ![img/B16069_05_042.png](img/B16069_05_042.png)
    时识别属于同一社区的两个节点。正如我们将在下一节中看到的，社区值也可以使用特定的算法自动计算。正如我们已经看到的，`ra_index_soundarajan_hopcroft`
    函数接受输入图和一对我们想要计算分数的节点。因此，我们得到以下输出：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: From the preceding output, it is possible to see the influence of the community
    in the computation of the index. Since nodes `1` and `2` belong to the same community,
    they have a higher value in the index. On the contrary, edges `(2,5)` and `(3,4)`
    have a value of 0 since they belong to a different community from each other.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出中，我们可以看到社区在索引计算中的影响。由于节点 `1` 和 `2` 属于同一社区，它们在索引中的值更高。相反，边 `(2,5)` 和 `(3,4)`
    由于它们属于不同的社区，其值为 0。
- en: In `networkx`, two other methods to compute the probability of a connection
    between two nodes based on their similarity score merged with community information
    are `nx.a` `within_inter_cluster` and `nx.common_neighbor_centrality`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在`networkx`中，有两种基于节点相似度分数合并社区信息来计算两个节点之间连接概率的方法，分别是`nx.a.within_inter_cluster`和`nx.common_neighbor_centrality`。
- en: In the next section, we will describe a more complex technique based on ML plus
    edge embedding to perform prediction of unknown edges.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将描述一种基于机器学习和边缘嵌入的更复杂的技术，用于预测未知边。
- en: Embedding-based methods
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于嵌入的方法
- en: 'In this section, we describe a more advanced way to perform link prediction.
    The idea behind this approach is to solve the link prediction problem as a supervised
    classification task. More precisely, for a given graph, each couple of nodes is
    represented with a feature vector (![](img/B16069_05_043.png)), and a class label
    (![](img/B16069_05_044.png)) is assigned to each of those node couples. Formally,
    let ![](img/B16069_05_045.png) be a graph, and for each couple of nodes ![](img/B16069_05_046.png),
    we build the following formula:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们描述了一种更高级的进行链接预测的方法。这种方法背后的思想是将链接预测问题作为一个监督分类任务来解决。更确切地说，对于给定的图，每对节点用一个特征向量（![](img/B16069_05_043.png)）表示，并为每对节点分配一个类别标签（![](img/B16069_05_044.png)）。形式上，设![](img/B16069_05_045.png)为一个图，对于每对节点![](img/B16069_05_046.png)，我们构建以下公式：
- en: '![](img/B16069_05_047.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16069_05_047.jpg)'
- en: 'Here, ![](img/B16069_05_048.png) is the *feature vector* representing the couple
    of nodes ![](img/B16069_05_049.png), and ![](img/B16069_05_050.png) is their *label*.
    The value for ![](img/B16069_05_051.png) is defined as follows: ![](img/B16069_05_052.png)
    if, in the graph `G`, the edge connecting node ![](img/B16069_05_053.png) exists;
    otherwise, ![](img/B16069_05_054.png). Using the feature vector and the labels,
    we can then train an ML algorithm in order to predict if a given couple of nodes
    constitute a plausible edge for the given graph.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，![](img/B16069_05_048.png)是表示节点对![](img/B16069_05_049.png)的*特征向量*，而![](img/B16069_05_050.png)是它们的*标签*。![](img/B16069_05_051.png)的值定义为：如果图`G`中存在连接节点![](img/B16069_05_053.png)的边，则为![](img/B16069_05_052.png)；否则为![](img/B16069_05_054.png)。使用特征向量和标签，我们可以训练一个机器学习算法，以预测给定的节点对是否构成给定图的合理边。
- en: 'If it is easy to build the label vector for each couple of nodes, it is not
    so straightforward to build the feature space. In order to generate the feature
    vector for each couple of nodes, we will use some embedding techniques, such as
    `node2vec` and `edge2vec`, already discussed in [*Chapter 3*](B16069_03_Final_JM_ePub.xhtml#_idTextAnchor046),
    *Unsupervised Graph Learning*. Using those embedding algorithms, the generation
    of the feature space will be greatly simplified. Indeed, the whole process can
    be summarized in two main steps, outlined as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果为每对节点构建标签向量很容易，那么构建特征空间就不那么直接了。为了为每对节点生成特征向量，我们将使用一些嵌入技术，例如已在[*第3章*](B16069_03_Final_JM_ePub.xhtml#_idTextAnchor046)“无监督图学习”中讨论过的`node2vec`和`edge2vec`。使用这些嵌入算法，特征空间的生成将大大简化。实际上，整个过程可以总结为以下两个主要步骤，概述如下：
- en: For each node of the graph `G`, its embedding vector is computed using a `node2vec`
    algorithm.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于图`G`中的每个节点，其嵌入向量是通过使用`node2vec`算法计算得到的。
- en: For all the possible couple of nodes in the graph, the embedding is computed
    using an `edge2vec` algorithm.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于图中所有可能的节点对，嵌入是通过使用`edge2vec`算法计算得到的。
- en: We can apply now a generic ML algorithm to the generated feature vector in order
    to solve the classification problem.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以将通用的机器学习算法应用于生成的特征向量，以解决分类问题。
- en: 'In order to give you a practical explanation of this procedure, we will provide
    an example in the following code snippet. More precisely, we will describe the
    whole pipeline (from graph to link prediction) using the `networkx`, `stellargraph`,
    and `node2vec` libraries. We will split the whole process into different steps
    in order to simplify our understanding of the different parts. The link prediction
    problem was applied to the citation network dataset described in [*Chapter 1*](B16069_01_Final_JM_ePub.xhtml#_idTextAnchor014),
    *Getting Started with Graphs in Python*, available at the following link: [https://linqs-data.soe.ucsc.edu/public/lbc/cora.tgz](https://linqs-data.soe.ucsc.edu/public/lbc/cora.tgz).'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给您提供一个关于此过程的实际解释，我们将在下面的代码片段中提供一个示例。更确切地说，我们将使用`networkx`、`stellargraph`和`node2vec`库来描述整个流程（从图到链接预测）。我们将整个过程分成不同的步骤，以便简化我们对不同部分的理解。链接预测问题被应用于在[*第一章*](B16069_01_Final_JM_ePub.xhtml#_idTextAnchor014)“Python中的图入门”中描述的引用网络数据集，可通过以下链接获取：[https://linqs-data.soe.ucsc.edu/public/lbc/cora.tgz](https://linqs-data.soe.ucsc.edu/public/lbc/cora.tgz)。
- en: 'As a first step, we will build a `networkx` graph using the citation dataset,
    as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一步，我们将使用引用数据集构建一个`networkx`图，如下所示：
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Since the dataset is represented as an edge list (see [*Chapter 1*](B16069_01_Final_JM_ePub.xhtml#_idTextAnchor014),
    *Getting Started with Graphs in Python*), we used the `from_pandas_edgelist` function
    to build the graph.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数据集以边列表的形式表示（参见[*第一章*](B16069_01_Final_JM_ePub.xhtml#_idTextAnchor014)“Python中的图入门”），我们使用了`from_pandas_edgelist`函数来构建图。
- en: 'As a second step, we need to create, from the graph `G`, training and test
    sets. More precisely, our training and test sets should contain not only a subset
    of real edges of the graph `G` but also couples of nodes that do not represent
    a real edge in `G`. The couples representing real edges will be *positive instances*
    (class label 1), while the couples that do not represent real edges will be *negative
    instances* (class label 0). This process can be easily performed as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第二步，我们需要从图`G`创建训练集和测试集。更确切地说，我们的训练集和测试集应包含图`G`的真实边的子集，以及不表示`G`中真实边的节点对。代表真实边的节点对将是*正实例*（类别标签1），而那些不表示真实边的节点对将是*负实例*（类别标签0）。这个过程可以很容易地执行，如下所示：
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We used the `EdgeSplitter` class available in `stellargraph`. The main constructor
    parameter of the `EdgeSplitter` class is the graph (`G`) we want to use to perform
    our split. The real splitting is performed using the `train_test_split` function
    that will generate the following outputs:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了`stellargraph`中可用的`EdgeSplitter`类。`EdgeSplitter`类的主要构造参数是我们想要用于执行分割的图（`G`）。实际的分割是通过`train_test_split`函数执行的，该函数将生成以下输出：
- en: '`graph_test` is a subset of the original graph ![](img/B16069_05_055.png) containing
    all the nodes but just a selected subset of edges.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`graph_test`是原始图的一个子集 ![img/B16069_05_055.png](img/B16069_05_055.png)，包含所有节点，但只包含选定的边子集。'
- en: '`samples_test` is a vector containing in each position a couple of nodes. This
    vector will contain couples of nodes representing real edges (positive instance)
    but also couples of nodes that do not represent real edges (negative instance).'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`samples_test`是一个向量，在每个位置包含一对节点。这个向量将包含代表真实边（正实例）的节点对，但也会包含不表示真实边的节点对（负实例）。'
- en: '`labels_test` is a vector having the same length as `samples_test`. It contains
    only 0 or 1\. The value of 0 is present in the position representing a negative
    instance in the `samples_test` vector, while the value of 1 is present in the
    position representing a positive instance in `samples_test`.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`labels_test`是一个与`samples_test`长度相同的向量，它只包含0或1。0的值出现在代表`samples_test`向量中负实例的位置，而1的值出现在代表`samples_test`中正实例的位置。'
- en: 'By following the same procedure used to generate the test set, it is possible
    to generate the training set, as illustrated in the following code snippet:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循用于生成测试集的相同程序，可以生成训练集，如下面的代码片段所示：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The main difference in this part of code is related to the initialization of
    `EdgeSplitter`. In this case, we also provide `graph_test` in order to not repeat
    positive and negative instances generated for the test set.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分代码的主要区别与`EdgeSplitter`的初始化有关。在这种情况下，我们还提供了`graph_test`，以避免为测试集重复生成正负实例。
- en: 'At this point, we have our training and testing datasets with negative and
    positive instances. For each of those instances, we now need to generate their
    feature vector. In this example, we used the `node2vec` library to generate the
    node embedding. In general, every node embedding algorithm can be used to perform
    this task. For the training set, we can thus generate the feature vector with
    the following code:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们有了包含正负实例的训练和测试数据集。对于这些实例中的每一个，我们现在需要生成它们的特征向量。在这个例子中，我们使用了`node2vec`库来生成节点嵌入。一般来说，任何节点嵌入算法都可以用来执行这项任务。因此，对于训练集，我们可以使用以下代码生成特征向量：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'From the previous code snippet, it is possible to see the following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码片段中，我们可以看到以下内容：
- en: We generate the embedding for each node in the training graph using the `node2vec`
    library.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`node2vec`库为训练图中的每个节点生成嵌入。
- en: We use the `HadamardEmbedder` class to generate the embedding of each couple
    of nodes contained in the training set. Those values will be used as feature vectors
    to perform the training of our model.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`HadamardEmbedder`类来生成训练集中包含的每对节点的嵌入。这些值将被用作特征向量以执行我们模型的训练。
- en: In this example, we used the `HadamardEmbedder` algorithm, but in general, other
    embedding algorithms can be used, such as the ones described in [*Chapter 3*](B16069_03_Final_JM_ePub.xhtml#_idTextAnchor046),
    *Unsupervised Graph Learning*.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了`HadamardEmbedder`算法，但一般来说，可以使用其他嵌入算法，例如在[*第3章*](B16069_03_Final_JM_ePub.xhtml#_idTextAnchor046)中描述的，*无监督图学习*。
- en: 'The previous step needs to also be performed for the test set, with the following
    code:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 上一步也需要对测试集执行，以下代码所示：
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The only difference here is given by the `samples_test` array used to compute
    the edge embeddings. Indeed, in this case, we use the data generated for the test
    set. Moreover, it should be noted that the `node2vec` algorithm was not recomputed
    for the test set. Indeed, given the stochastic nature of `node2vec`, it is not
    possible to ensure that the two learned embeddings are "comparable" and therefore
    `node2vec` embeddings will change between runs.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的唯一区别是由用于计算边嵌入的`samples_test`数组给出的。实际上，在这种情况下，我们使用了为测试集生成的数据。此外，应注意`node2vec`算法并未为测试集重新计算。确实，鉴于`node2vec`的随机性，无法保证两次学习到的嵌入是“可比较”的，因此`node2vec`嵌入会在运行之间发生变化。
- en: 'Everything is set now. We can finally train—using the `train_embeddings` feature
    space and the `train_labels` label assignment—an ML algorithm to solve the label
    prediction problem, as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一切已设置完毕。我们最终可以使用`train_embeddings`特征空间和`train_labels`标签分配来训练一个机器学习算法以解决标签预测问题，如下所示：
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In this example, we used a simple `RandomForestClassifier` class, but every
    ML algorithm can be used to solve this task. We can then apply the trained model
    on the `test_embeddings` feature space in order to quantify the quality of the
    classification, as shown in the following code block:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了一个简单的`RandomForestClassifier`类，但任何机器学习算法都可以用来解决这个任务。然后我们可以将训练好的模型应用于`test_embeddings`特征空间，以量化分类的质量，如下所示：
- en: '[PRE15]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As a result, we get the following output:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们得到以下输出：
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As we already mentioned, the methods we just described are just a general schema;
    each piece of the pipeline—such as the train/test split, the node/edge embedding,
    and the ML algorithm—can be changed according to the specific problem we are facing.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，我们刚才描述的方法只是一个通用方案；管道中的每一部分——如训练/测试分割、节点/边嵌入和机器学习算法——都可以根据我们面临的具体问题进行更改。
- en: This method is particularly useful when dealing with link prediction in temporal
    graphs. In this case, information relating to an edge obtained at timepoint ![](img/B16069_05_056.png)
    used to train a model can be applied in order to predict edges at timepoint ![](img/B16069_05_057.png).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法在处理时间图中的链接预测时特别有用。在这种情况下，用于训练模型的时间点![img/B16069_05_056.png](img/B16069_05_056.png)获得的信息可以用来预测时间点![img/B16069_05_057.png](img/B16069_05_057.png)的边。
- en: In this section, we introduced the label prediction problem. We enriched our
    explanation by providing a description, with several examples, of different techniques
    used to find a solution to the link prediction problem. We showed that different
    ways to tackle the problem are available, from simple index-based techniques to
    more complex embedding-based techniques. However, the scientific literature is
    full of algorithms to solve the link prediction task, and there are different
    algorithms to solve this problem. In the paper *Review on Learning and Extracting
    Graph Features for Link Prediction* ([https://arxiv.org/pdf/1901.03425.pdf](https://arxiv.org/pdf/1901.03425.pdf)),
    a good overview of different techniques used to solve the link prediction problem
    is available. In the next section, we will investigate the community detection
    problem.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了标签预测问题。我们通过提供描述和几个示例，丰富了我们的解释，展示了用于找到链接预测问题解决方案的不同技术。我们展示了处理问题的不同方法，从简单的基于索引的技术到更复杂的基于嵌入的技术。然而，科学文献中充满了用于解决链接预测任务的算法，并且存在不同的算法来解决此问题。在论文《关于学习与提取链接预测图特征的综述》（[https://arxiv.org/pdf/1901.03425.pdf](https://arxiv.org/pdf/1901.03425.pdf)）中，可以找到解决链接预测问题所使用不同技术的良好概述。在下一节中，我们将研究社区检测问题。
- en: Detecting meaningful structures such as communities
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测有意义的结构，如社区
- en: 'One common problem data scientists face when dealing with networks is how to
    identify clusters and communities within a graph. This often arises when graphs
    are derived from social networks and communities are known to exist. However,
    the underlying algorithms and methods can also be used in other contexts, representing
    another option to perform clustering and segmentation. For example, these methods
    can effectively be used in text mining to identify emerging topics and to cluster
    documents that refer to single events/topics. A community detection task consists
    of partitioning a graph such that nodes belonging to the same community are tightly
    connected with each other and are weakly connected with nodes from other communities.
    There exist several strategies to identify communities. In general, we can define
    them as belonging to one of two categories, outlined as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 数据科学家在处理网络时面临的一个常见问题是如何在图中识别集群和社区。这种情况通常出现在从社交网络和已知存在社区中导出的图中。然而，这些底层算法和方法也可以在其他环境中使用，代表了一种执行聚类和分割的另一种选择。例如，这些方法可以有效地用于文本挖掘，以识别新兴主题和将引用单个事件/主题的文档进行聚类。社区检测任务包括将图划分为几个部分，使得属于同一社区的节点之间紧密相连，而与其他社区的节点之间则弱连接。存在几种识别社区的策略。一般来说，我们可以将它们定义为属于以下两个类别之一，如下所述：
- en: '**Non-overlapping** community detection algorithms that provide a one-to-one
    association between nodes and communities, thus with no overlapping nodes between
    communities'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**非重叠**社区检测算法，提供节点与社区之间的一对一关联，因此社区之间没有重叠节点'
- en: '**Overlapping** community detection algorithms that allow a node to be included
    in more than one community—for instance, reflecting the natural tendencies of
    social networks to develop overlapping communities (for example, friends from
    school, neighbors, playmates, people being in the same football team, and so on),
    or in biology, where a single protein can be involved in more than one process
    and bioreaction'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重叠**社区检测算法，允许一个节点被包含在多个社区中——例如，反映社交网络自然发展重叠社区的趋势（例如，来自同一所学校的朋友、邻居、玩伴、在同一足球队的人等等），或者在生物学中，一个单一的蛋白质可以参与多个过程和生物反应'
- en: In the following section, we will review some of the most used techniques in
    the context of community detection.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下部分，我们将回顾社区检测中最常用的技术。
- en: Embedding-based community detection
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于嵌入的社区检测
- en: 'One first class of methods that allow us to partition nodes into communities
    can be simply obtained by applying standard shallow clustering techniques on the
    node embeddings, computed using the methods described in [*Chapter 3*](B16069_03_Final_JM_ePub.xhtml#_idTextAnchor046),
    *Unsupervised Graph Learning*. The embedding methods in fact allow us to project
    nodes into a vector space where a distance measure that represents a similarity
    between nodes can be defined. As we have shown in [*Chapter 3*](B16069_03_Final_JM_ePub.xhtml#_idTextAnchor046),
    *Unsupervised Graph Learning*, embedding algorithms are very effective in separating
    nodes with similar neighborhood and/or connectivity properties. Then, standard
    clustering techniques can be used, such as distance-based clustering (K-means),
    connectivity clustering (hierarchical clustering), distribution clustering (Gaussian
    mixture), and density-based clustering (`networkx` utility function, as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 一类允许我们将节点划分为社区的方法可以通过在节点嵌入上应用标准浅层聚类技术简单获得，这些嵌入是通过[*第3章*](B16069_03_Final_JM_ePub.xhtml#_idTextAnchor046)，*无监督图学习*中描述的方法计算的。实际上，嵌入方法允许我们将节点投影到向量空间中，在该空间中可以定义表示节点之间相似性的距离度量。正如我们在[*第3章*](B16069_03_Final_JM_ePub.xhtml#_idTextAnchor046)，*无监督图学习*中所示，嵌入算法在分离具有相似邻域和/或连接属性节点方面非常有效。然后，可以使用标准聚类技术，例如基于距离的聚类（K-means）、基于连接的聚类（层次聚类）、基于分布的聚类（高斯混合）和基于密度的聚类（`networkx`实用函数，如下所示：
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We can then first get the reduced dense node representation using one of the
    embedding algorithms we have seen previously (for instance, `HOPE`), shown as
    follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以首先使用我们之前看到的嵌入算法之一（例如，`HOPE`）获取减少的密集节点表示，如下所示：
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can finally run a clustering algorithm on the resulting vector representation
    provided by the node embeddings, like this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终可以在节点嵌入提供的向量表示上运行聚类算法，如下所示：
- en: '[PRE19]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We can plot the network with the computed communities highlighted in different
    colors, like this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用不同的颜色突出显示计算出的社区，并绘制出网络图，如下所示：
- en: '[PRE20]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'By doing so, you should obtain the output shown in the following screenshot:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，你应该会获得以下屏幕截图所示的输出：
- en: '![Figure 5.2 – Barbell graph where the community detection algorithm has been
    applied using embedding-based methods ](img/B16069_05_02.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图5.2 – 使用基于嵌入的方法应用社区检测算法的哑铃图](img/B16069_05_02.jpg)'
- en: Figure 5.2 – Barbell graph where the community detection algorithm has been
    applied using embedding-based methods
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2 – 使用基于嵌入的方法应用社区检测算法的哑铃图
- en: The two clusters, as well as the connecting nodes, have been correctly grouped
    into three different communities, reflecting the internal structure of the graph.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个簇以及连接的节点已经被正确地分成了三个不同的社区，反映了图的内部结构。
- en: Spectral methods and matrix factorization
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 谱方法和矩阵分解
- en: 'Another way to achieve a graph partition is to process the adjacency matrix
    or the Laplacian matrix that represents the connectivity properties of the graph.
    For instance, spectral clustering can be obtained by applying standard clustering
    algorithms on the eigenvectors of the Laplacian matrix. In some sense, spectral
    clustering can also be seen as a special case of an embedding-based community
    detection algorithm where the embedding technique is so-called spectral embedding,
    obtained by considering the first k-eigenvectors of the Laplacian matrix. By considering
    different definitions of the Laplacian as well as different similarity matrices,
    variations to this method can be obtained. A convenient implementation of this
    method can be found within the `communities` Python library and can be used on
    the adjacency matrix representation easily obtained from a `networkx` graph, as
    illustrated in the following code snippet:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种实现图划分的方法是处理表示图连接属性邻接矩阵或拉普拉斯矩阵。例如，可以通过在拉普拉斯矩阵的特征向量上应用标准聚类算法来获得谱聚类。在某种意义上，谱聚类也可以被视为一种基于嵌入的社区检测算法的特殊情况，其中嵌入技术被称为谱嵌入，通过考虑拉普拉斯矩阵的前k个特征向量获得。通过考虑拉普拉斯的不同定义以及不同的相似性矩阵，可以得到该方法的不同变体。此方法的方便实现可以在`communities`
    Python库中找到，并且可以轻松地应用于从`networkx`图中获得的邻接矩阵表示，如下面的代码片段所示：
- en: '[PRE21]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Moreover, the adjacency matrix (or the Laplacian) can also be decomposed using
    matrix factorization techniques other than the **singular value decomposition**
    (**SVD**) technique—such as **non-negative matrix factorization** (**NMF**)—that
    allow similar descriptions, as illustrated in the following code snippet:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，邻接矩阵（或拉普拉斯矩阵）也可以使用除了**奇异值分解**（**SVD**）技术之外的矩阵分解技术进行分解——例如**非负矩阵分解**（**NMF**）——允许类似的描述，如下面的代码片段所示：
- en: '[PRE22]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The threshold for belonging to the community was set in this example to 0, although
    other values can also be used to retain only the community cores. Note that these
    methods are overlapping community detection algorithms, and nodes might belong
    to more than one community.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，社区归属的阈值被设置为0，尽管也可以使用其他值来仅保留社区核心。请注意，这些方法是重叠的社区检测算法，节点可能属于多个社区。
- en: Probability models
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概率模型
- en: 'Community detection methods can also be derived from fitting the parameters
    of generative probabilistic graph models. Examples of generative models were already
    described in [*Chapter 1*](B16069_01_Final_JM_ePub.xhtml#_idTextAnchor014), *Getting
    Started with Graphs in Python*. However, they did not assume the presence of any
    underlying community, unlike the so-called **stochastic block model** (**SBM**).
    In fact, this model is based on the assumption that nodes can be partitioned into
    *K* disjoint communities and each community has a defined probability of being
    connected to another. For a network of *n* nodes and *K* communities, the generative
    model is thus parametrized by the following:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 社区检测方法也可以通过拟合生成概率图模型的参数来推导。例如，在[*第一章*](B16069_01_Final_JM_ePub.xhtml#_idTextAnchor014)“Python中图形入门”中已经描述了生成模型。然而，它们并没有假设存在任何潜在的社区，与所谓的**随机块模型**（**SBM**）不同。事实上，这个模型基于这样的假设：节点可以被划分为*K*个不相交的社区，并且每个社区都有一个定义的概率，可以连接到另一个社区。对于一个包含*n*个节点和*K*个社区的图，生成模型因此由以下参数来定义：
- en: '**Membership matrix**: *M*, which is a *n x K* matrix and represents the probability
    a given node belongs to a certain class *k*'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隶属矩阵**：*M*，这是一个*n x K*矩阵，表示给定节点属于某个特定类别*k*的概率'
- en: '**Probability matrix**: *B*, which is *K x K* matrix and represents the edge
    probability between a node belonging to community *i* and one node belonging to
    community *j*'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**概率矩阵**：*B*，这是一个*K x K*矩阵，表示属于社区*i*的节点与属于社区*j*的节点之间的边概率'
- en: 'The adjacency matrix is then generated by the following formula:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 邻接矩阵随后通过以下公式生成：
- en: '![](img/B16069_05_058.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16069_05_058.jpg)'
- en: Here, ![](img/B16069_05_059.png) and ![](img/B16069_05_060.png) represent the
    community, and they can be obtained by sampling from a multinomial distribution
    of probabilities ![](img/B16069_05_061.png) and ![](img/B16069_05_062.png).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，![](img/B16069_05_059.png)和![](img/B16069_05_060.png)代表社区，它们可以通过从概率![](img/B16069_05_061.png)和![](img/B16069_05_062.png)的多项分布中进行抽样来获得。
- en: In the SBM, we can basically invert the formulation and reduce the community
    detection problem to posterior estimation of the membership matrix *M* from the
    matrix *A*, via maximum likelihood estimation. A version of this approach has
    recently been used together with randomized spectral clustering in order to perform
    community detection in very large graphs. Note that the SBM model in the limit
    of the constant probability matrix (that is, ![](img/B16069_05_063.png)) corresponds
    to the Erdős-Rényi model. These models have the advantage of also describing a
    relation between communities, identifying community-community relationships.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在SBM中，我们可以基本上逆转公式，将社区检测问题简化为从矩阵*A*中通过最大似然估计对隶属矩阵*M*的后验估计。最近，这种方法与随机谱聚类一起使用，以在非常大的图中进行社区检测。请注意，在恒定概率矩阵的极限下（即，![](img/B16069_05_063.png)），SBM模型对应于Erdős-Rényi模型。这些模型的优势在于它们还描述了社区之间的关系，确定了社区间的联系。
- en: Cost function minimization
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 成本函数最小化
- en: Another possible way to detect communities within a graph is to optimize a given
    cost function that represents a graph structure and penalizes edges across communities
    versus edges within communities. This basically consists of building a measure
    for the quality of a community (as we will see shortly, its modularity) and then
    optimizing the node association to communities in order to maximize the overall
    quality of the partitioning.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在图中检测社区的另一种可能方法是优化一个表示图结构的给定成本函数，并惩罚社区间的边相对于社区内的边。这基本上包括构建一个衡量社区质量（如我们很快将看到的，其模块度）的度量，然后优化节点到社区的关联，以最大化整体划分的质量。
- en: 'In the context of a binary associative community structure, the community association
    can be described by a dichotomic variable ![](img/B16069_05_064.png) with values
    -1 or 1, depending on whether the node belongs to one of the two communities.
    In this setting, we can define the following quantity that can indeed be used
    to effectively represent the cost associated with having a link between two nodes
    of different communities:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在二元关联社区结构的背景下，社区关联可以通过一个二分变量 ![](img/B16069_05_064.png) 来描述，其值为 -1 或 1，具体取决于节点是否属于两个社区中的任何一个。在这种情况下，我们可以定义以下数量，它确实可以用来有效地表示两个不同社区节点之间链接的成本：
- en: '![](img/B16069_05_065.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16069_05_065.jpg)'
- en: Indeed, when two connected nodes, ![](img/B16069_05_066.png) belong to a different
    community ![](img/B16069_05_067.png), the contribution provided by the edge is
    positive. On the other hand, the contribution is 0, both when two nodes are not
    connected (![](img/B16069_05_068.png)) and when two connected nodes belong to
    the same community (![](img/B16069_05_069.png)). Therefore, the problem is to
    find the best community assignment (![](img/B16069_05_070.png) and ![](img/B16069_05_071.png))
    in order to minimize the preceding function. This method, however, applies only
    to binary community detection and is therefore rather limited in its application.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，当两个相连的节点 ![](img/B16069_05_066.png) 属于不同的社区 ![](img/B16069_05_067.png) 时，边的贡献是正的。另一方面，当两个节点没有连接
    (![](img/B16069_05_068.png)) 或者两个相连的节点属于同一社区 (![](img/B16069_05_069.png)) 时，贡献为
    0。因此，问题是要找到最佳的社区分配 (![](img/B16069_05_070.png) 和 ![](img/B16069_05_071.png)) 以最小化前面的函数。然而，这种方法仅适用于二元社区检测，因此在应用上相当有限。
- en: 'Another very popular algorithm belonging to this class is the Louvain method,
    which takes its name from the university where it was invented. This algorithm
    aims to maximize the modularity, defined as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 属于这一类别的另一个非常流行的算法是Louvain方法，该算法的名字来源于它被发明的那所大学。这个算法的目标是最大化模块度，其定义如下：
- en: '![](img/B16069_05_072.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16069_05_072.jpg)'
- en: Here, ![](img/B16069_05_073.png) represents the number of edges, ![](img/B16069_05_074.png)
    and ![](img/B16069_05_075.png) represent the degree of the i-th and j-th node
    respectively, and ![](img/B16069_05_076.png) is the Kronecker delta function,
    which is 1 when ![](img/B16069_05_077.png) and ![](img/B16069_05_078.png) have
    the same value and 0 otherwise. The modularity basically represents a measure
    of how much better the community identification performs as compared to randomly
    rewiring the nodes and thus creating a random network that has the same number
    of edges and degree distribution.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，![](img/B16069_05_073.png) 表示边的数量，![](img/B16069_05_074.png) 和 ![](img/B16069_05_075.png)
    分别表示第 i 个和第 j 个节点的度，而 ![](img/B16069_05_076.png) 是克罗内克δ函数，当 ![](img/B16069_05_077.png)
    和 ![](img/B16069_05_078.png) 有相同的值时为 1，否则为 0。模块度基本上代表了一个与随机重新布线节点相比，社区识别性能提升的度量。因此，它创建了一个具有相同数量边和度分布的随机网络。
- en: 'To maximize this modularity efficiently, the Louvain methods iteratively compute
    the following steps:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有效地最大化这个模块度，Louvain方法迭代地计算以下步骤：
- en: '**Modularity optimization**: Nodes are swept iteratively, and for each node
    we compute the change of modularity *Q* there would be if the node were to be
    assigned to each community of its neighbors. Once all the ![](img/B16069_05_079.png)
    values are computed, the node is assigned to the community that provides the largest
    increase. If there is no increase obtained by placing the node in any other community
    than the one it is in, the node remains in its original community. This optimization
    process continues until no changes are induced.'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**模块度优化**：节点被迭代地移动，并且对于每个节点，我们计算如果该节点被分配给其邻居的每个社区，模块度*Q*会有多大的变化。一旦计算了所有![](img/B16069_05_079.png)值，节点就会被分配到提供最大增加的社区。如果将节点放置在任何其他社区中都不会获得增加，则节点将保留在其原始社区中。此优化过程会一直持续到不再引起变化。'
- en: '**Node aggregation**: In the second step, we build a new network by grouping
    all the nodes in the same community and connecting the communities using edges
    that result from the sum of all edges across the two communities. Edges within
    communities are accounted for as well by means of self-loops that have weights
    resulting from the sum of all edge weights belonging to the community.'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**节点聚合**：在第二步中，我们通过将同一社区中的所有节点分组并使用连接两个社区的所有边的总和形成的边来构建一个新的网络。社区内的边也通过自环来计算，这些自环的权重是社区中所有边权重总和的结果。'
- en: 'A Louvain implementation can already be found in the `communities` library,
    as can be seen in the following code snippet:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在`communities`库中可以找到Louvain实现的示例，如下代码片段所示：
- en: '[PRE23]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Another method to maximize the modularity is the Girvan-Newman algorithm, which
    is based on iteratively removing edges that have the highest betweenness centrality
    (and thus connect two separate clusters of nodes) to create connected component
    communities. Here is the code related to this:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种最大化模块度的方法是Girvan-Newman算法，该算法基于迭代移除具有最高中介中心性的边（因此连接两个分离的节点簇）以创建连通组件社区。以下是相关的代码：
- en: '[PRE24]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The latter algorithm needs to compute the betweenness centrality of all edges
    to remove the edges. Such computations may be very expensive in large graphs.
    The Girvan-Newman algorithm in fact scales as ![](img/B16069_05_080.png), where
    ![](img/B16069_05_081.png) is the number of edges and ![](img/B16069_05_082.png)
    is the number of nodes, and should not be used when dealing with large datasets.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 后者算法需要计算所有边的介数中心性以移除边。在大型图中，此类计算可能非常昂贵。实际上，Girvan-Newman算法的扩展性为![](img/B16069_05_080.png)，其中![](img/B16069_05_081.png)是边的数量，![](img/B16069_05_082.png)是节点的数量，并且当处理大型数据集时不应使用。
- en: Detecting graph similarities and graph matching
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测图相似性和图匹配
- en: Learning a quantitative measure of the *similarity* among graphs is considered
    a key problem. Indeed, it is a critical step for network analysis and can also
    facilitate many ML problems, such as classification, clustering, and ranking.
    Many clustering algorithms, for example, use the concept of similarity for determining
    if an object should or should not be a member of a group.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 学习图中相似性的量化度量被认为是关键问题。事实上，这是网络分析的关键步骤，也可以促进许多机器学习问题，例如分类、聚类和排序。例如，许多聚类算法使用相似性概念来确定一个对象是否应该是某个组的成员。
- en: 'In the graph domain, finding an effective similarity measure constitutes a
    crucial problem for many applications. Consider, for instance, the *role* of a
    node inside a graph. This node might be very important for spreading information
    across a network or guaranteeing network robustness: for example, it could be
    the center of a star graph or it could be a member of a clique. In this scenario,
    it would be very useful to have a powerful method for comparing nodes according
    to their roles. For example, you might be interested in searching for individuals
    showing similar roles or presenting similar unusual and anomalous behaviors. You
    might also use it for searching similar subgraphs or to determine network compatibility
    for *knowledge transfer*. For example, if you find a method for increasing the
    robustness of a network and you know that such a network is very similar to another
    one, you may apply the same solution that worked well for the first network directly
    to the second one:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在图域中，找到一个有效的相似度度量对于许多应用来说是一个关键问题。例如，考虑图内一个节点的*角色*。这个节点可能对于在网络中传播信息或保证网络鲁棒性非常重要：例如，它可能是星形图的中心，或者它可能是团的一部分。在这种情况下，有一个强大的方法来根据节点的角色比较节点将非常有用。例如，你可能对寻找表现出相似角色或呈现类似异常行为的个人感兴趣。你也可以用它来搜索相似的子图或确定网络的兼容性以进行*知识迁移*。例如，如果你找到一个提高网络鲁棒性的方法，并且你知道这样的网络与另一个网络非常相似，你可以直接将适用于第一个网络的同一种解决方案应用于第二个网络：
- en: '![Figure 5.3 – Example of differences between two graphs'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.3 – 两个图之间差异的示例'
- en: '](img/B16069_05_03.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16069_05_03.jpg)'
- en: Figure 5.3 – Example of differences between two graphs
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3 – 两个图之间差异的示例
- en: 'Several metrics can be used for measuring the similarity (distance) between
    two objects. Some examples include the *Euclidean distance*, *Manhattan distance*,
    *cosine similarity*, and so on. However, these metrics might fail to capture the
    specific characteristics of the data being studied, especially on non-Euclidean
    structures such as graphs. Take a look at *Figure 5.3*: how "distant" are **G1**
    and **G2**? They look pretty similar. But what if the missing connection in the
    red community of **G2** causes a severe loss of information? Do they still look
    similar?'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用几种度量来衡量两个对象之间的相似度（距离）。一些例子包括*欧几里得距离*、*曼哈顿距离*、*余弦相似度*等等。然而，这些度量可能无法捕捉到正在研究的数据的特定特征，尤其是在非欧几里得结构如图上。看看*图5.3*：**G1**和**G2**看起来有多“远”？它们看起来相当相似。但是，如果**G2**中红色社区缺失的连接导致严重的信息损失，情况会怎样？它们仍然看起来相似吗？
- en: Several algorithmic approaches and heuristics have been proposed, based on mathematical
    concepts such as *graph isomorphisms*, *edit distance*, and *common subgraphs*
    (we suggest reading [https://link.springer.com/article/10.1007/s10044-012-0284-8](https://link.springer.com/article/10.1007/s10044-012-0284-8)
    for a detailed review). Many of these approaches are currently used in practical
    applications, even if they often require exponentially high computational time
    to provide a solution to **NP-complete** problems in general (where **NP** stands
    for **nondeterministic polynomial time**). Therefore, it is essential to find
    or learn a metric for measuring the similarity of data points involved in the
    specific task. Here is where ML comes to our aid.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 已经提出了几种基于数学概念如*图同构*、*编辑距离*和*公共子图*的算法方法和启发式方法（我们建议阅读[https://link.springer.com/article/10.1007/s10044-012-0284-8](https://link.springer.com/article/10.1007/s10044-012-0284-8)以获取详细综述）。许多这些方法目前在实际应用中被使用，即使它们通常需要指数级高的计算时间来解决一般**NP完全**问题（其中**NP**代表**非确定性多项式时间**）。因此，找到或学习一个用于测量特定任务中涉及的数据点相似度的度量标准是至关重要的。正是在这里，机器学习（ML）为我们提供了帮助。
- en: 'Many algorithms among the ones we have already seen in [*Chapter 3*](B16069_03_Final_JM_ePub.xhtml#_idTextAnchor046),
    *Unsupervised Graph Learning,* and [*Chapter 4*](B16069_04_Final_JM_ePub.xhtml#_idTextAnchor064),
    *Supervised Graph Learning* might be useful for learning an effective similarity
    metric. According to the way they are used, a precise taxonomy can be defined.
    Here, we provide a simple overview of graph similarity techniques. A more comprehensive
    list can be found in the paper *Deep Graph Similarity Learning: A Survey* ([https://arxiv.org/pdf/1912.11615.pdf](https://arxiv.org/pdf/1912.11615.pdf)).
    They can be essentially divided into three main categories, even if sophisticated
    combinations can also be developed. **Graph embedding-based methods** use embedding
    techniques to obtain an embedded representation of the graphs and exploit such
    a representation to learn the similarity function; **graph kernel-based methods**
    define the similarity between graphs by measuring the similarity of their constituting
    substructures; **graph neural network-based methods** use **graph neural networks**
    (**GNNs**) to jointly learn an embedded representation and a similarity function.
    Let''s see all of them in more detail.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前已经看到的[*第3章*](B16069_03_Final_JM_ePub.xhtml#_idTextAnchor046)，“无监督图学习”，和[*第4章*](B16069_04_Final_JM_ePub.xhtml#_idTextAnchor064)，“监督图学习”中的许多算法可能对学习有效的相似度度量很有用。根据它们的使用方式，可以定义一个精确的分类法。在这里，我们提供了一个关于图相似性技术的简单概述。更全面的列表可以在论文《深度图相似性学习：综述》([https://arxiv.org/pdf/1912.11615.pdf](https://arxiv.org/pdf/1912.11615.pdf))中找到。它们基本上可以分为三个主要类别，尽管也可以开发出复杂的组合。**基于图嵌入的方法**使用嵌入技术来获取图的嵌入表示，并利用这种表示来学习相似度函数；**基于图核的方法**通过测量构成子结构的相似度来定义图之间的相似度；**基于图神经网络的方法**使用**图神经网络**（**GNNs**）来联合学习嵌入表示和相似度函数。让我们更详细地看看它们。
- en: Graph embedding-based methods
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于图嵌入的方法
- en: Such techniques seek to apply graph embedding techniques to obtain node-level
    or graph-level representations and further use the representations for similarity
    learning. For example, *DeepWalk* and *Node2Vec* can be used to extract meaningful
    embedding that can then be used to define a similarity function or to predict
    similarity scores. For example, in Tixier et al. (2015), `node2vec` was used for
    encoding node embeddings. Then, **two-dimensional** (**2D**) histograms obtained
    from those node embeddings were passed to a classical 2D **convolutional neural
    network** (**CNN**) architecture designed for images. Such a simple yet powerful
    approach enabled good results to be derived from many benchmark datasets.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这些技术试图将图嵌入技术应用于获取节点级或图级表示，并进一步使用这些表示进行相似度学习。例如，*DeepWalk*和*Node2Vec*可以用来提取有意义的嵌入，然后可以用来定义相似度函数或预测相似度分数。例如，在Tixier等人（2015）的研究中，`node2vec`被用来编码节点嵌入。然后，从这些节点嵌入中获得的**二维**（**2D**）直方图被传递到一个为图像设计的经典二维**卷积神经网络**（**CNN**）架构。这种简单而强大的方法使得从许多基准数据集中得出良好的结果成为可能。
- en: Graph kernel-based methods
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于图核的方法
- en: '**Graph kernel-based methods** have generated a lot of interest in terms of
    capturing the similarity between graphs. These approaches compute the similarity
    between two graphs as a function of the similarities between some of their substructures.
    Different graph kernels exist based on the substructures they use, which include
    random walks, shortest paths, and subgraphs. As an example, a method called **Deep
    Graph Kernels** (**DGK**) (Yanardag et al., 2015) decomposes graphs into substructures
    that are viewed as "words". Then, **natural language processing** (**NLP**) approaches
    such as **continuous bag of words** (**CBOW**) and **skip-gram** are used to learn
    latent representations of the substructures. This way, the kernel between two
    graphs is defined based on the similarity of the substructure space.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '**基于图核的方法**在捕捉图之间的相似度方面引起了很大兴趣。这些方法将两个图之间的相似度计算为它们某些子结构相似度的函数。根据它们使用的子结构，存在不同的图核，包括随机游走、最短路径和子图。例如，一种称为**深度图核**（**DGK**）的方法（Yanardag等人，2015）将图分解为被视为“单词”的子结构。然后，使用**自然语言处理**（**NLP**）方法，如**连续词袋**（**CBOW**）和**跳字模型**（**skip-gram**）来学习子结构的潜在表示。这样，两个图之间的核基于子结构空间的相似度来定义。'
- en: GNN-based methods
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GNN-based methods
- en: With the emergence of **deep learning** (**DL**) techniques, GNNs have become
    a powerful new tool for learning representations on graphs. Such powerful models
    can be easily adapted to various tasks, including graph similarity learning. Furthermore,
    they present a key advantage with respect to other traditional graph embedding
    approaches. Indeed, while the latter generally learn the representation in an
    isolated stage, in this kind of approach, the representation learning and the
    target learning task are conducted jointly. Therefore, the GNN deep models can
    better leverage the graph features for the specific learning task. We have already
    seen an example of similarity learning using GNNs in [*Chapter 3*](B16069_03_Final_JM_ePub.xhtml#_idTextAnchor046),
    *Unsupervised Graph Learning*, where a two-branch network was trained to estimate
    the proximity distance between two graphs.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 随着深度学习（**DL**）技术的出现，图神经网络（GNNs）已成为学习图上表示的强大新工具。这些强大的模型可以轻松地适应各种任务，包括图相似性学习。此外，它们相对于其他传统图嵌入方法具有关键优势。确实，后者通常在独立阶段学习表示，而在这种类型的方法中，表示学习和目标学习任务是一起进行的。因此，GNN深度模型可以更好地利用图特征来执行特定的学习任务。我们已经在[*第3章*](B16069_03_Final_JM_ePub.xhtml#_idTextAnchor046)的“无监督图学习”中看到了使用GNNs进行相似性学习的例子，其中训练了一个双分支网络来估计两个图之间的邻近距离。
- en: Applications
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用
- en: 'Similarity learning on graphs has already achieved promising results in many
    domains. Important applications may be found in chemistry and bioinformatics—for
    example, for finding the chemical compounds that are most similar to a query compound,
    as illustrated on the left-hand side of the following diagram. In neuroscience,
    similarity learning methods have started to be applied to measure the similarity
    of brain networks among multiple subjects, allowing the novel clinical investigation
    of brain diseases:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多领域，图上的相似性学习已经取得了有希望的结果。在化学和生物信息学中可能找到重要的应用，例如，用于寻找与查询化合物最相似的化学物质，如图中左侧所示。在神经科学中，相似性学习方法已经开始应用于测量多个受试者之间脑网络的相似性，从而允许进行新颖的临床研究，以研究脑部疾病。
- en: '![Figure 5.4 – Example of how graphs can be useful for representing various
    objects: (a) differences between two chemical compounds; (b) differences between
    two human poses](img/B16069_05_04.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![图5.4 – 图如何有助于表示各种对象的示例：（a）两种化学物质的差异；（b）两种人类姿态的差异](img/B16069_05_04.jpg)'
- en: 'Figure 5.4 – Example of how graphs can be useful for representing various objects:
    (a) differences between two chemical compounds; (b) differences between two human
    poses'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4 – 图如何有助于表示各种对象的示例：（a）两种化学物质的差异；（b）两种人类姿态的差异
- en: Graph similarity learning has also been explored in computer security, where
    novel approaches have been proposed for the detection of vulnerabilities in software
    systems as well as hardware security problems. Recently, a trend for applying
    such solutions to solve computer vision problems has been observed. Once the challenging
    problem of converting images into graph data has been solved, interesting solutions
    can indeed be proposed for human action recognition in video sequences and object
    matching in scenes, among other areas (as shown on the right-hand side of *Figure
    5.4*).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图相似性学习在计算机安全领域也得到了探索，其中已经提出了新颖的方法来检测软件系统中的漏洞以及硬件安全问题。最近，观察到一种趋势，即应用此类解决方案来解决计算机视觉问题。一旦将图像转换为图数据的挑战性问题得到解决，确实可以提出一些有趣的方法来解决视频序列中的人类动作识别和场景中的物体匹配等问题（如图5.4的右侧所示）。
- en: Summary
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learned how graph-based ML techniques can be used to
    solve many different problems.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用基于图的机器学习技术来解决许多不同的问题。
- en: In particular, we have seen that the same algorithm (or a slightly modified
    version of it) can be adapted to solve apparently very different tasks such as
    link prediction, community detection, and graph similarity learning. We have also
    seen that each problem has its own peculiarities, which have been exploited by
    researchers in order to design more sophisticated solutions.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是我们可以看到，相同的算法（或其略微修改的版本）可以适应解决看似非常不同的任务，例如链接预测、社区检测和图相似性学习。我们也看到，每个问题都有其独特的特点，研究人员已经利用这些特点来设计更复杂的解决方案。
- en: In the next chapter, we will explore real-life problems that have been solved
    using ML.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨使用机器学习解决的问题的实际问题。
