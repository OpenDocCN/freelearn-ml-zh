- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Solving Common MSA Enterprise System Challenges
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned how to decompose the monolith and refactor
    it into an MSA enterprise system. We built a simplified system as an example and
    then refactored the system to demonstrate this process. By doing so, we resolved
    some of the challenges of running a monolithic system. However, moving toward
    MSA introduces a completely different set of issues that need to be addressed.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will discuss the main challenges introduced in MSA, how
    to address them, and what specific methodologies we need to apply to maintain
    the MSA system’s reliability, durability, and smooth operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: MSA system isolation using an Anti-Corruption Layer (ACL)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API gateways
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service catalogs and orchestrators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microservices aggregators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microservices circuit breaker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gateways versus orchestrators versus aggregators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ABC-MSA enhancements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MSA isolation using an ACL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When adopting MSA in a brownfield, your migration from the monolithic system
    to MSA can either be done as a **big bang migration** or **trickle migration**.
  prefs: []
  type: TYPE_NORMAL
- en: In big bang migration, you keep the old monolith system running as-is while
    building the entire MSA system. Once the MSA system has been completed, tested,
    and deployed, you can then completely switch to the new MSA system during your
    organization’s maintenance window, then decommission the old monolith. This type
    of migration, although usable for some scenarios, is usually not recommended in
    the case of large enterprise systems.
  prefs: []
  type: TYPE_NORMAL
- en: Switching users from the old to the new system should be done during the corporate’s
    off-peak hours or the corporate’s standard migration window. And the sudden switch
    of users can be a complex and cumbersome process due to the high potential for
    downtime, potential rollbacks, and risks of unexpected results when applying real
    traffic to the new system, all of which can impose large time constraints during
    the migration window.
  prefs: []
  type: TYPE_NORMAL
- en: A common and safer migration approach in our case is trickle migration, where
    you perform a gradual shift from the old monolithic system to the new MSA system.
    A common way of doing that is by gradually extracting functions, services, and/or
    modules out of your monolith and moving them into standalone microservices as
    part of your new MSA. Gradually, we phase out the existing monolith’s functions
    and build an MSA system piece by piece.
  prefs: []
  type: TYPE_NORMAL
- en: 'To successfully perform a tickle migration, you need what’s called an **Anti-Corruption
    Layer** (**ACL**), which will act as an intermediate layer, a buffer, and a gateway
    between the old, messy monolith and your new clean MSA. The ACL layer will help
    temporarily integrate and glue the new extracted services back into the old system,
    to be able to communicate with old services, databases, and modules without fouling
    your new MSA system. You can see the ACL architecture in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1: Anti-Corruption Layer (ACL)](img/B18934_03_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.1: Anti-Corruption Layer (ACL)'
  prefs: []
  type: TYPE_NORMAL
- en: The ACL lifespan is as long as the monolith system’s lifespan. Once the migration
    has been completed and the monolith has been decommissioned, the ACL will no longer
    be needed. Therefore, it is recommended that you have the ACL written either as
    a standalone service or as part of the monolith.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ACL has three main components:'
  prefs: []
  type: TYPE_NORMAL
- en: The API component, which allows the ACL to communicate with the MSA system using
    the same language as the MSA system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The ACL Facade**, which is the interface that enables the ACL to talk to
    the monolith using the monolith’s language(s).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are two options where the Facade can be placed; one is shown in *Figure
    3**.1*, where the Facade has been placed as part of the new standalone ACL microservice.
    The other option is placing the Facade as a component within the monolith, as
    shown in *Figure 3**.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2: The Facade’s two implementation options](img/B18934_03_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.2: The Facade’s two implementation options'
  prefs: []
  type: TYPE_NORMAL
- en: The choice would depend on the architects’ and developers’ preference regarding
    whether they would like to add more glue code inside the monolith itself, or completely
    isolate any development effort away from the monolith.
  prefs: []
  type: TYPE_NORMAL
- en: '**The ACL Adapter**, which is a part of the ACL, works between the ACL’s northbound
    API and the Facade. The main function of the Adapter is to translate between the
    monolith and the MSA using the **ACL Translator** interface, as shown in *Figure
    3**.1*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ACL is only needed when a trickle migration is adopted. There is no need for
    implementing an ACL in the big bang migration case. And since, between both migration
    styles, there are resources to be consumed, as well as advantages, risks, and
    tradeoffs, MSA project stakeholders will need to decide on which style is more
    suitable for the project and the organization.
  prefs: []
  type: TYPE_NORMAL
- en: Whether an ACL is implemented or not, MSA systems would still need a component
    to act as an interface between the MSA system and external clients. Using an API
    gateway between the MSA and external API calls is considered a good MSA design
    practice. The next section discusses the roles of the API gateway in MSA systems,
    and the tradeoffs of having to adopt an API gateway in MSA design.
  prefs: []
  type: TYPE_NORMAL
- en: Using an API gateway
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we explained in [*Chapter 1*](B18934_01.xhtml#_idTextAnchor014), microservices
    can communicate directly with each other without the need for a centralized manager.
    As the MSA system becomes more mature, the number of microservices gradually increases,
    and direct communication between microservices can become a large overhead – especially
    with calls that need multiple round trips between the API consumer and the API
    provider.
  prefs: []
  type: TYPE_NORMAL
- en: With the microservices’ autonomy principle, each microservice can use its technology
    stack and may communicate with a different API contract than the other microservices
    in the same MSA system. One microservice, for example, may only understand a RESTful
    API with a JSON data structure, while others may only communicate with Thrift
    or Avro.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, the location (IP and listening port) of the active instantiated microservices
    change dynamically within the MSA system. Therefore, the system will need to have
    a mechanism to identify the location at which the API consumer can point its calls
    towards.
  prefs: []
  type: TYPE_NORMAL
- en: There are also situations where you need to tie in your MSA system to legacy
    systems such as the mainframe, AS400, and more.
  prefs: []
  type: TYPE_NORMAL
- en: All of the previous situations require code to be embedded in each microservice
    in the MSA system. This code will help the microservices understand the legacy
    and non-REST communication patterns, discover the network location of other microservices
    in the system, and understand each microservice’s needs in general. Now, how independent
    and portable would such a set of microservices be?
  prefs: []
  type: TYPE_NORMAL
- en: 'A better approach to addressing the preceding challenges is to use an API gateway
    where all system services talk to each other through that gateway. The API gateway
    receives API calls from the system’s API consumers, then maps the data received
    into a data structure and a protocol that API providers can understand and process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3: Moving from services direct communication to API gateway communication](img/B18934_03_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.3: Moving from services direct communication to API gateway communication'
  prefs: []
  type: TYPE_NORMAL
- en: With the API gateway, we significantly reduce direct 1-to-1 communication between
    services. Moreover, we offload the system’s microservices from having multiple
    translations, mapping code, and **Authentication-Authorization-Accounting** (**AAA**)
    tasks. Rather, we move the responsibility of discovering the location of microservices
    from the client to the API gateway, which, in turn, further reduces the code overhead
    and renders microservices as light and independent as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The MSA system’s availability is as good as the API gateway’s availability.
    Therefore, it is necessary for the API gateway to be developed, deployed, and
    managed as a high-performance and highly available mission-critical service.
  prefs: []
  type: TYPE_NORMAL
- en: 'The API gateway can be deployed as a standalone service that’s part of the
    MSA system. The main functions of the gateway are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Minimize the API calls between microservices, which makes MSA inter-service
    communication much more efficient.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minimize API dependencies and breaking changes. In an MSA system with no API
    gateway, if, for whatever reason, one of the API providers changes its API, a
    breaking change will likely happen. This means we will need to create a change
    in every microservice communicating with the API provider. By using an API gateway,
    a change in the API provider will be limited to the API gateway only, to match
    the API contract between the provider and the consumers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Translate and map between API contracts, which offloads the microservices from
    embedding translation code in their core function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run a service discovery mechanism and offload clients from running that function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Act as the entry point to the MSA system’s external client calls.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Load-balance API calls across the different instances of high-availability microservices,
    and offload microservices in high-traffic situations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Offer better security by throttling sudden increases in API calls during **Distributed
    Denial of Service** (**DDoS**) and similar attacks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authenticate and authorize users to access different components in the MSA system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide comprehensive analytics to provide deep insights into system metrics
    and logs, which can help further enhance system design and performance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Despite all these advantages and functions of the API gateway, there are still
    some drawbacks to having an API gateway in your MSA system:'
  prefs: []
  type: TYPE_NORMAL
- en: The most obvious is complexity. The more protocols and API contract data structures
    we have in the system, the more complex the gateway becomes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The MSA’s operation is highly dependent on the API gateway’s performance and
    availability, which may create an unwanted system performance bottleneck.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing an additional intermediary component such as an API gateway in the
    path of intra-microservice communication increases service response time. And
    with chatty services, the increased response time can become considerable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even with all the functions the API gateway provides, we still need a way to
    map each user request to specific tasks that the MSA system would need to run
    to fulfill that request. In the next section, we’ll discuss how the MSA system
    tasks are mapped to specific user services, and how these tasks are orchestrated
    in MSA.
  prefs: []
  type: TYPE_NORMAL
- en: Service catalogs and orchestrators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Orchestration is one of the most commonly used communication patterns in MSA
    systems. We briefly discussed this concept in [*Chapter 1*](B18934_01.xhtml#_idTextAnchor014).
    In this section, we will dive into more details about orchestration.
  prefs: []
  type: TYPE_NORMAL
- en: Determining the most appropriate communication pattern between the different
    microservices depends on many factors. Among the factors that will help determine
    whether choreography or orchestration is the most suited communication pattern
    for the system, you must consider the number of microservices you have in the
    system, the level of interactions between the different microservices, the business
    logic itself, how dynamic business requirements change, and how dynamic system
    updates are.
  prefs: []
  type: TYPE_NORMAL
- en: 'Orchestrators act as the central managers controlling all communication between
    the system’s microservices. They usually interact with the users through a dashboard
    interface that contains all service catalogs. The **Service Catalog** is a set
    of services the MSA system offers to users. Each service in the catalog is linked
    to a set of workflows. **Workflows** are the actions the orchestrator will trigger
    and coordinate between the system’s microservices to deliver the service the user
    selected from the catalog:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4: Orchestrators in MSA](img/B18934_03_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.4: Orchestrators in MSA'
  prefs: []
  type: TYPE_NORMAL
- en: The orchestrator’s functions can be extended beyond managing workflows. Orchestrators
    can also manage the entire life cycle of microservices; this involves provisioning
    and deploying microservices, configuring the microservice, and performing upgrades,
    updates, monitoring, performance audits, and shutdowns when needed.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The orchestrator is the main brain of the MSA system, and it is imperative to
    have the orchestrator deployed and managed as a high-performing and mission-critical
    component of the MSA system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the benefits of running an orchestrator in MSA include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: You have a centralized management platform as a single source of truth for all
    of your workflows. Thus, you can build complex workflows in a complex MSA without
    having to worry about how many microservices you have and how they can scale.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As in the API gateway, you can tie in your legacy systems or part of your old
    monolith and completely isolate your microservices from having to couple with
    any other system component. This saves a lot of effort having to build code into
    the independent microservices and tremendously helps in scaling your MSA.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microservices are visible to the orchestrator and hence can be completely managed,
    audited, and monitored by the orchestrator. This can produce very helpful and
    insightful analytics that can further enhance the MSA system’s supportability
    and operations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The orchestrator’s visibility can help in troubleshooting any operational issues
    and identifying problems quickly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Orchestrators can automatically detect and self-resolute some of the operational
    problems. Orchestrators can, for example, detect resource starvation and reroute
    requests to a backup microservice. Orchestrators can automatically vertically
    or horizontally scale a particular microservice when a problem is detected. Orchestrators
    can also try to automatically restart the service if the service is not responding.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The orchestrator solves many of the MSA operational problems, including some
    of the data synchronization challenges. When scaling the system, however, data
    synchronization and data consistency become a big challenge for the orchestrator
    to address by itself. Microservices aggregators help address data synchronization
    issues when the MSA system scales. In the next section, we will discuss what the
    aggregator pattern is, what it is used for, and how it works.
  prefs: []
  type: TYPE_NORMAL
- en: Microservices aggregators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 2*](B18934_02.xhtml#_idTextAnchor028), we had to copy some schemas
    across multiple microservices and use saga patterns through the orchestrator to
    keep data consistent and preserve the microservice’s autonomy. This solution may
    be viable in a situation if you have a limited number of microservices within
    the MSA system. In a large number of microservices systems, copying schemas across
    different microservices to maintain the synchronization of the individual microservices
    database doesn’t scale well and can severely impact the system’s overall performance.
  prefs: []
  type: TYPE_NORMAL
- en: Consider an MSA system with 100 microservices and copy schemas across about
    20 of those microservices to maintain the microservice’s autonomy. Each time any
    part of any of the schema’s data is updated, the orchestrator will have to sync
    those 20 schemas.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, even if we have all 100 microservices perfectly autonomous, what if
    one of the user’s operations needs to gather information from those 20 microservices?
    The orchestrator will have to issue at least 20 different API calls to 20 different
    microservices to get the information the user is looking for. Not to mention that
    some of these 20 microservices may need to exchange multiple API calls to send
    the result back to the user.
  prefs: []
  type: TYPE_NORMAL
- en: To put things into perspective, let’s revisit the ABC-MSA system we built in
    [*Chapter 2*](B18934_02.xhtml#_idTextAnchor028). We have the `order`, `product`,
    and `inventory` microservices. The `product` microservice is for managing product
    information, the `inventory` microservice is for managing the product inventory,
    and the `order` microservice is for placing and managing orders.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s assume we’re in a situation where a sales analyst is generating a report
    to check a product’s average quantity purchased per order and the product’s inventory
    level at the time at which the order was placed, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5: A sample product order report](img/B18934_03_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.5: A sample product order report'
  prefs: []
  type: TYPE_NORMAL
- en: 'The orchestrator will have to send at least three API calls, one to each of
    the `order`, `product`, and `inventory` microservices, as shown in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.6: A user operation spanning multiple microservices](img/B18934_03_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.6: A user operation spanning multiple microservices'
  prefs: []
  type: TYPE_NORMAL
- en: To minimize dependencies and response time, a better approach for this particular
    situation is to use an `order`, `product`, and `inventory` microservices and update
    its database with the combined information.
  prefs: []
  type: TYPE_NORMAL
- en: 'The API gateway or consumer will only need to send one API call to the aggregator
    to get all the information it needs. The number of API calls is minimized and
    the overall response time is greatly reduced, especially in cases where the information
    required is distributed across a large number of microservices:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.7: An aggregator communication pattern](img/B18934_03_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.7: An aggregator communication pattern'
  prefs: []
  type: TYPE_NORMAL
- en: The aggregator communication pattern reduces the number of API calls users could
    trigger in various operational requests and further enhances the data synchronization’s
    design and performance, as well as the overall system performance, especially
    in high-latency networks.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we know the roles of the API gateway, the orchestrator, and the aggregator.
    In the next section, we will discuss how all these three components interact with
    each other in the MSA.
  prefs: []
  type: TYPE_NORMAL
- en: Gateways versus orchestrators versus aggregators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'From what we have described so far, there are some overlapping functions between
    the API gateway, the orchestrator, and the aggregator. In this section, we will
    answer some of the fundamental questions regarding how all three components interact
    in a single MSA system:'
  prefs: []
  type: TYPE_NORMAL
- en: How do these three MSA components work together?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can an API gateway perform the aggregator and orchestrator functions?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the best practices for deploying all these communication patterns in
    our MSA?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First of all, theoretically speaking, you can have clients interact with the
    MSA microservices directly without an API gateway. However, this would not be
    a good practice. By having no gateway in your MSA system, you would need to have
    most of the gateway functions implemented within each microservice you have in
    the system.
  prefs: []
  type: TYPE_NORMAL
- en: To keep microservices as light and autonomous as possible, it is highly recommended
    to have an API gateway in your MSA system. The API gateway will handle all ingress
    and egress API traffic from the different types of clients. Clients can be a web
    dashboard, a mobile application, a tablet, a third-party integration system, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: Whether you add an aggregator or not will highly depend on your business logic
    and system design. You will only need aggregators if you have client use cases
    where requests need to span across multiple microservices at the backend.
  prefs: []
  type: TYPE_NORMAL
- en: Aggregators can be implemented as part of the gateway itself; however, the best
    practice is to add an aggregator only whenever it is needed and make it an independent
    standalone microservice.
  prefs: []
  type: TYPE_NORMAL
- en: An MSA system can have multiple aggregators, each with specific business logic,
    and fulfilling a specific collection of data from a different set of microservices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, orchestration patterns can also be implemented in the API gateway;
    however, you need the API gateway to focus on doing the main functions it was
    created for and leave orchestration tasks to the orchestrator. The orchestrator
    is also best deployed as a standalone microservice:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.8: MSA high-level architecture](img/B18934_03_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.8: MSA high-level architecture'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding diagram shows the high-level architecture of having all these
    components working together within the MSA system. Clients always interact with
    the API gateway, and the API gateway will route the request to the appropriate
    service within the MSA system.
  prefs: []
  type: TYPE_NORMAL
- en: Client API calls are routed to the appropriate microservice based on the API’s
    configuration. If the client request is something that is fulfilled by communicating
    with a single microservice, then the gateway will send that request directly to
    the microservice. API calls that span multiple microservices and are assigned
    to a specific aggregator in the system will be forwarded to that particular aggregator.
    Finally, for API requests that invoke specific workflows, the API gateway will
    forward those to the orchestrator.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how the API gateway, the orchestrator, and the aggregator
    coexist in the same MSA system. In the next section, we will try to apply the
    concepts of all these three communication patterns to our previously developed
    ABC-MSA system.
  prefs: []
  type: TYPE_NORMAL
- en: Microservices circuit breaker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another challenge in MSA systems is the stability and assurance of workflow
    execution. Saga patterns, which we discussed in [*Chapter 1*](B18934_01.xhtml#_idTextAnchor014),
    are used to ensure that all transactions within a specific workflow are either
    all successfully executed, or all fail. But is that enough to ensure the reliable
    execution of microservices?
  prefs: []
  type: TYPE_NORMAL
- en: Let’s consider a scenario where the called microservice is too slow in responding
    to API calls. Requests get successfully executed, but the microservice’s response
    times out. The microservice consumer, in turn, may assume an execution failure,
    and accordingly repeat the operation, which can be very problematic.
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in the following diagram, when a response timeout takes place in the
    Payment microservice, the Payment microservice will process the payment, but the
    microservice consumer will assume that the payment has not been processed and
    may automatically (or upon user request) retry the process. This behavior will
    cause the payment to be processed multiple times, resulting in multiple charges
    for the same order, or for the order to be placed multiple times:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.9: Payment microservice with too slow of a response time](img/B18934_03_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.9: Payment microservice with too slow of a response time'
  prefs: []
  type: TYPE_NORMAL
- en: In MSA, when microservices get instantiated, they start with limited resources
    and threads to avoid one particular microservice from hogging all the system’s
    resources.
  prefs: []
  type: TYPE_NORMAL
- en: With system resources in mind, consider another scenario, as shown in *Figure
    3**.10*, where the Inventory microservice is part of a service workflow and the
    Payment microservice is neither processing nor responding to API calls for whatever
    reason. In this case, both the Order and Payment microservices will keep waiting
    for confirmation from the inventory before they start releasing their resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the Inventory microservice timing out requests, and under a system heavy
    load or high order volume, requests start to pile up for the Order and Payment
    microservices. Eventually, both the Order and Payment microservices start to run
    out of resources and become unable to respond to requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.10: Inventory microservice is down](img/B18934_03_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.10: Inventory microservice is down'
  prefs: []
  type: TYPE_NORMAL
- en: Similar scenarios in MSA can result in a domino effect, causing a cascading
    failure to multiple microservices, which, in turn, causes an entire system failure.
  prefs: []
  type: TYPE_NORMAL
- en: A microservice **circuit breaker** is used to prevent a system cascading failure
    from happening. A circuit breaker monitors microservice performance using real
    traffic metrics. It analyses parameters such as response time and successful response
    rate and then determines the health of the microservice in real time. Should the
    microservice become unhealthy, the circuit breaker immediately starts responding
    to the microservice consumers with an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'A circuit breaker does not prevent the microservice being monitored from failing;
    rather, it averts a cascading failure from taking place:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.11: The Inventory microservice with an inline circuit breaker](img/B18934_03_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.11: The Inventory microservice with an inline circuit breaker'
  prefs: []
  type: TYPE_NORMAL
- en: When the circuit breaker assumes a microservice is unhealthy, it still needs
    to monitor and evaluate the microservice’s operational performance. The circuit
    breaker switches to a **half-open state**, where it only allows a small portion
    of requests to pass through to the microservice being monitored. Once the circuit
    breaker detects a healthy microservice response, the circuit breaker switches
    its state back to a **closed state**, where API traffic flows back normally to
    the microservice.
  prefs: []
  type: TYPE_NORMAL
- en: Circuit breakers are not needed for every single microservice in the MSA system.
    We only need to deploy a circuit breaker on microservices that can cause a cascading
    failure. Architects will need to study and determine which microservices need
    circuit breaker protection.
  prefs: []
  type: TYPE_NORMAL
- en: A circuit breaker can be deployed as a standalone microservice or be part of
    the API gateway. Whether circuit breakers are implemented as standalone microservices
    or part of the API gateway highly depends on the system’s business and operational
    requirements, as well as the patterns adopted in the architecture itself.
  prefs: []
  type: TYPE_NORMAL
- en: The circuit breaker pattern, as well as the orchestrator, aggregator, ACL, and
    API gateway, are all enhancements architects that can be applied to the MSA system
    for better reliability, resilience, and overall performance. In the next section,
    we will learn how to apply each of the patterns discussed here to our ABC-MSA
    system.
  prefs: []
  type: TYPE_NORMAL
- en: ABC-MSA enhancements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 2*](B18934_02.xhtml#_idTextAnchor028), we refactored our ABC-Monolith
    into a simple ABC-MSA. The ABC-MSA we designed in [*Chapter 2*](B18934_02.xhtml#_idTextAnchor028)
    lacked many of the enhancements we are considering in this chapter. It is time
    to take what we have learned in this chapter and apply that to the ABC-MSA system
    to enhance its design and operations.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, in the ABC-MSA from [*Chapter 2*](B18934_02.xhtml#_idTextAnchor028),
    the orchestrator was doing both the API gateway functions and the orchestration
    function. So far, we have learned that combining both the gateway and orchestration
    functions in one service is not the best option. Therefore, we will add to our
    ABC-MSA system an API gateway dedicated to ingress and egress API calls, and other
    API gateway functions we discussed earlier in this chapter, such as authentication,
    authorization, audit, monitoring, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The API gateway will run as a separate standalone microservice serving direct
    client requests, including the system dashboard and user frontend. The orchestrator
    will also run as a standalone microservice serving the MSA’s workflows.
  prefs: []
  type: TYPE_NORMAL
- en: The aggregator(s) will depend on the use cases where multiple ABC-MSA microservices
    are used to fulfill the user requests.
  prefs: []
  type: TYPE_NORMAL
- en: A simple use case for using an aggregator would be a user checking for an order’s
    shipping status. The status should include the order information, the products
    included in the order, and the shipping status of that order.
  prefs: []
  type: TYPE_NORMAL
- en: 'To show all this information to the user, we will need to pull information
    from three different microservices: Order Management, Product Management, and
    Shipping Management. We will deploy an aggregator as a standalone microservice
    to pull the data from all these microservices and make them available for user
    API consumption:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.12: The enhanced ABC-MSA architecture](img/B18934_03_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.12: The enhanced ABC-MSA architecture'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding diagram, we added the Management and Orchestration layer as
    part of the ABC-MSA system. This layer will manage the orchestration workflows
    and the microservice’s life cycle, including, installation, configuration, instantiation,
    updates, upgrades, and shutdowns.
  prefs: []
  type: TYPE_NORMAL
- en: We will also need an ACL to be active during the transition from the ABC-Monolith
    to the ABC-MSA. The ACL will act as a buffer between both systems to maintain
    the neatness of the architecture and its operations. Once all the ABC-Monolith
    functions have been redeployed into the ABC-MSA, both the old ABC-Monolith and
    the ACL can be decommissioned.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed the different components of the MSA that can be
    introduced to maintain the system’s stability and enhance its performance.
  prefs: []
  type: TYPE_NORMAL
- en: We discussed how to use the ACL to protect our new MSA during its transition
    from the old monolithic system. Then, we covered the roles and functions of the
    API gateway, the aggregator, and the orchestrator. We also covered some of the
    drawbacks you may experience when adopting the various communication patterns
    in MSA.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we redesigned our ABC-MSA to showcase how these different components
    can all function together in a typical MSA.
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 1*](B18934_01.xhtml#_idTextAnchor014) to [*Chapter 3*](#_idTextAnchor039)
    covered the basics of the MSA. In the next chapter, we will start discussing,
    with hands-on examples, key machine learning and deep learning algorithms used
    in MSA enterprise systems, and go over some programming and tool examples of building
    machine learning and deep learning algorithms.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 2: Overview of Machine Learning Algorithms and Applications'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this part, we will shift our focus to machine learning. We will learn about
    the different concepts of machine learning algorithms and how to design and build
    a machine learning system, maintain the model, and apply machine learning to an
    intelligent enterprise MSA.
  prefs: []
  type: TYPE_NORMAL
- en: We will first learn the fundamentals when it comes to identifying the difference
    between different machine learning models and their use cases. Once we’ve covered
    the basics, we will start to learn how to design a machine learning system pipeline.
    Once we have established a machine learning system pipeline, we will learn what
    data shifts are, how they can impact our system, and how we can identify and address
    them. Finally, having gone through all the basics, we will start to explore the
    different use cases for building our very own intelligent enterprise MSA.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of *Part 2*, we will have a basic understanding of machine learning
    and the different algorithms, how to build and maintain a machine learning system,
    and, finally, the different use cases in which we can use machine learning for
    our intelligent enterprise MSA.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part comprises the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 4*](B18934_04.xhtml#_idTextAnchor051), *Key Machine Learning Algorithms
    and Concepts*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 5*](B18934_05.xhtml#_idTextAnchor061), *Machine Learning System Design*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 6*](B18934_06.xhtml#_idTextAnchor072), *Stabilizing the Machine Learning
    System*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B18934_07.xhtml#_idTextAnchor079), *How Machine Learning and
    Deep Learning Help in MSA Enterprise Systems*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
