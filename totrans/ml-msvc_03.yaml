- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Solving Common MSA Enterprise System Challenges
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决常见MSA企业系统挑战
- en: In the previous chapter, we learned how to decompose the monolith and refactor
    it into an MSA enterprise system. We built a simplified system as an example and
    then refactored the system to demonstrate this process. By doing so, we resolved
    some of the challenges of running a monolithic system. However, moving toward
    MSA introduces a completely different set of issues that need to be addressed.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何分解单体并将其重构为MSA企业系统。我们以一个简化的系统为例，然后重构系统以展示此过程。通过这样做，我们解决了运行单体系统的一些挑战。然而，向MSA的迁移引入了完全不同的一组需要解决的问题。
- en: In this chapter, we will discuss the main challenges introduced in MSA, how
    to address them, and what specific methodologies we need to apply to maintain
    the MSA system’s reliability, durability, and smooth operation.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论MSA引入的主要挑战，如何解决它们，以及我们需要应用的具体方法来维护MSA系统的可靠性、耐用性和平稳运行。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: MSA system isolation using an Anti-Corruption Layer (ACL)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用反腐败层（ACL）进行MSA系统隔离
- en: API gateways
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API网关
- en: Service catalogs and orchestrators
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务目录和编排器
- en: Microservices aggregators
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务聚合器
- en: Microservices circuit breaker
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务断路器
- en: Gateways versus orchestrators versus aggregators
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网关与编排器与聚合器
- en: ABC-MSA enhancements
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ABC-MSA增强
- en: MSA isolation using an ACL
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ACL进行MSA隔离
- en: When adopting MSA in a brownfield, your migration from the monolithic system
    to MSA can either be done as a **big bang migration** or **trickle migration**.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在棕色地带采用MSA时，您从单体系统迁移到MSA可以是**大爆炸迁移**或**滴答迁移**。
- en: In big bang migration, you keep the old monolith system running as-is while
    building the entire MSA system. Once the MSA system has been completed, tested,
    and deployed, you can then completely switch to the new MSA system during your
    organization’s maintenance window, then decommission the old monolith. This type
    of migration, although usable for some scenarios, is usually not recommended in
    the case of large enterprise systems.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在大爆炸迁移中，您保持旧的单体系统按原样运行，同时构建整个MSA系统。一旦MSA系统完成、测试和部署，您就可以在组织维护窗口期间完全切换到新的MSA系统，然后退役旧的单体系统。虽然这种迁移在某些场景中可用，但在大型企业系统中通常不推荐使用。
- en: Switching users from the old to the new system should be done during the corporate’s
    off-peak hours or the corporate’s standard migration window. And the sudden switch
    of users can be a complex and cumbersome process due to the high potential for
    downtime, potential rollbacks, and risks of unexpected results when applying real
    traffic to the new system, all of which can impose large time constraints during
    the migration window.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在公司非高峰时段或公司标准迁移窗口期间切换用户从旧系统到新系统。由于高停机时间、潜在的回滚和将真实流量应用于新系统时可能出现意外结果的风险，用户突然切换可能是一个复杂且繁琐的过程，所有这些都可能在迁移窗口期间施加大量时间限制。
- en: A common and safer migration approach in our case is trickle migration, where
    you perform a gradual shift from the old monolithic system to the new MSA system.
    A common way of doing that is by gradually extracting functions, services, and/or
    modules out of your monolith and moving them into standalone microservices as
    part of your new MSA. Gradually, we phase out the existing monolith’s functions
    and build an MSA system piece by piece.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，一种常见且更安全的迁移方法是滴答迁移，其中您逐步从旧的单体系统转移到新的MSA系统。一种常见的方法是逐步从单体中提取功能、服务和/或模块，并将它们作为您新MSA的一部分移动到独立的微服务中。逐渐地，我们逐步淘汰现有单体系统的功能，并逐步构建MSA系统。
- en: 'To successfully perform a tickle migration, you need what’s called an **Anti-Corruption
    Layer** (**ACL**), which will act as an intermediate layer, a buffer, and a gateway
    between the old, messy monolith and your new clean MSA. The ACL layer will help
    temporarily integrate and glue the new extracted services back into the old system,
    to be able to communicate with old services, databases, and modules without fouling
    your new MSA system. You can see the ACL architecture in the following diagram:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要成功执行滴答迁移，您需要所谓的**反腐败层**（**ACL**），它将充当一个中间层、缓冲区和旧混乱单体与您新清洁的MSA之间的网关。ACL层将帮助暂时集成和粘合新提取的服务，以便能够与旧服务、数据库和模块通信，而不会破坏您的新MSA系统。您可以在以下图中看到ACL架构：
- en: '![Figure 3.1: Anti-Corruption Layer (ACL)](img/B18934_03_1.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图3.1：反腐败层（ACL）](img/B18934_03_1.jpg)'
- en: 'Figure 3.1: Anti-Corruption Layer (ACL)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1：反腐败层（ACL）
- en: The ACL lifespan is as long as the monolith system’s lifespan. Once the migration
    has been completed and the monolith has been decommissioned, the ACL will no longer
    be needed. Therefore, it is recommended that you have the ACL written either as
    a standalone service or as part of the monolith.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: ACL的生命周期与单体系统的生命周期一样长。一旦迁移完成，单体系统退役，ACL就不再需要。因此，建议您将ACL编写为独立服务或作为单体的一部分。
- en: 'The ACL has three main components:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: ACL有三个主要组件：
- en: The API component, which allows the ACL to communicate with the MSA system using
    the same language as the MSA system.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API组件，允许ACL使用与MSA系统相同的语言与MSA系统通信。
- en: '**The ACL Facade**, which is the interface that enables the ACL to talk to
    the monolith using the monolith’s language(s).'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ACL外观层**，这是允许ACL使用单体的语言（们）与单体通信的接口。'
- en: 'There are two options where the Facade can be placed; one is shown in *Figure
    3**.1*, where the Facade has been placed as part of the new standalone ACL microservice.
    The other option is placing the Facade as a component within the monolith, as
    shown in *Figure 3**.2*:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 外观层可以放置的位置有两种选择；一种如*图3.1*所示，外观层被放置为新独立的ACL微服务的一部分。另一种选择是将外观层作为单体内部的一个组件，如*图3.2*所示：
- en: '![Figure 3.2: The Facade’s two implementation options](img/B18934_03_2.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图3.2：外观层的两种实现选项](img/B18934_03_2.jpg)'
- en: 'Figure 3.2: The Facade’s two implementation options'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2：外观层的两种实现选项
- en: The choice would depend on the architects’ and developers’ preference regarding
    whether they would like to add more glue code inside the monolith itself, or completely
    isolate any development effort away from the monolith.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 选择将取决于架构师和开发者是否希望在内聚体内部添加更多粘合代码，或者完全将开发工作与内聚体隔离。
- en: '**The ACL Adapter**, which is a part of the ACL, works between the ACL’s northbound
    API and the Facade. The main function of the Adapter is to translate between the
    monolith and the MSA using the **ACL Translator** interface, as shown in *Figure
    3**.1*.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ACL适配器**，作为ACL的一部分，位于ACL的北向API和外观层之间。适配器的主要功能是使用**ACL翻译器**接口在单体和MSA之间进行转换，如*图3.1*所示。'
- en: ACL is only needed when a trickle migration is adopted. There is no need for
    implementing an ACL in the big bang migration case. And since, between both migration
    styles, there are resources to be consumed, as well as advantages, risks, and
    tradeoffs, MSA project stakeholders will need to decide on which style is more
    suitable for the project and the organization.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在采用渐进式迁移时才需要ACL。在大爆炸式迁移的情况下，不需要实现ACL。由于在两种迁移方式之间都有资源消耗，以及优势、风险和权衡，MSA项目的利益相关者需要决定哪种方式更适合项目和组织。
- en: Whether an ACL is implemented or not, MSA systems would still need a component
    to act as an interface between the MSA system and external clients. Using an API
    gateway between the MSA and external API calls is considered a good MSA design
    practice. The next section discusses the roles of the API gateway in MSA systems,
    and the tradeoffs of having to adopt an API gateway in MSA design.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是否实施ACL，MSA系统仍然需要一个组件作为MSA系统和外部客户端之间的接口。在MSA和外部API调用之间使用API网关被认为是良好的MSA设计实践。下一节将讨论API网关在MSA系统中的作用，以及采用API网关在MSA设计中的权衡。
- en: Using an API gateway
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用API网关
- en: As we explained in [*Chapter 1*](B18934_01.xhtml#_idTextAnchor014), microservices
    can communicate directly with each other without the need for a centralized manager.
    As the MSA system becomes more mature, the number of microservices gradually increases,
    and direct communication between microservices can become a large overhead – especially
    with calls that need multiple round trips between the API consumer and the API
    provider.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[*第一章*](B18934_01.xhtml#_idTextAnchor014)中解释的，微服务可以直接相互通信，无需集中式管理。随着MSA系统变得更加成熟，微服务的数量逐渐增加，微服务之间的直接通信可能会成为很大的开销——特别是需要API消费者和API提供者之间多次往返调用的通信。
- en: With the microservices’ autonomy principle, each microservice can use its technology
    stack and may communicate with a different API contract than the other microservices
    in the same MSA system. One microservice, for example, may only understand a RESTful
    API with a JSON data structure, while others may only communicate with Thrift
    or Avro.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, the location (IP and listening port) of the active instantiated microservices
    change dynamically within the MSA system. Therefore, the system will need to have
    a mechanism to identify the location at which the API consumer can point its calls
    towards.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: There are also situations where you need to tie in your MSA system to legacy
    systems such as the mainframe, AS400, and more.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: All of the previous situations require code to be embedded in each microservice
    in the MSA system. This code will help the microservices understand the legacy
    and non-REST communication patterns, discover the network location of other microservices
    in the system, and understand each microservice’s needs in general. Now, how independent
    and portable would such a set of microservices be?
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: 'A better approach to addressing the preceding challenges is to use an API gateway
    where all system services talk to each other through that gateway. The API gateway
    receives API calls from the system’s API consumers, then maps the data received
    into a data structure and a protocol that API providers can understand and process:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3: Moving from services direct communication to API gateway communication](img/B18934_03_3.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.3: Moving from services direct communication to API gateway communication'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: With the API gateway, we significantly reduce direct 1-to-1 communication between
    services. Moreover, we offload the system’s microservices from having multiple
    translations, mapping code, and **Authentication-Authorization-Accounting** (**AAA**)
    tasks. Rather, we move the responsibility of discovering the location of microservices
    from the client to the API gateway, which, in turn, further reduces the code overhead
    and renders microservices as light and independent as possible.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: The MSA system’s availability is as good as the API gateway’s availability.
    Therefore, it is necessary for the API gateway to be developed, deployed, and
    managed as a high-performance and highly available mission-critical service.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: 'The API gateway can be deployed as a standalone service that’s part of the
    MSA system. The main functions of the gateway are as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Minimize the API calls between microservices, which makes MSA inter-service
    communication much more efficient.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minimize API dependencies and breaking changes. In an MSA system with no API
    gateway, if, for whatever reason, one of the API providers changes its API, a
    breaking change will likely happen. This means we will need to create a change
    in every microservice communicating with the API provider. By using an API gateway,
    a change in the API provider will be limited to the API gateway only, to match
    the API contract between the provider and the consumers.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小化API依赖和破坏性变更。在没有API网关的MSA系统中，如果由于任何原因，其中一个API提供者更改了其API，很可能会发生破坏性变更。这意味着我们需要在每个与API提供者通信的微服务中创建一个变更。通过使用API网关，API提供者的变更将仅限于API网关，以匹配提供者和消费者之间的API合约。
- en: Translate and map between API contracts, which offloads the microservices from
    embedding translation code in their core function.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在API合约之间进行翻译和映射，从而减轻了微服务在核心功能中嵌入翻译代码的负担。
- en: Run a service discovery mechanism and offload clients from running that function.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行服务发现机制，并减轻客户端运行该功能的负担。
- en: Act as the entry point to the MSA system’s external client calls.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为MSA系统外部客户端调用的入口点。
- en: Load-balance API calls across the different instances of high-availability microservices,
    and offload microservices in high-traffic situations.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在高可用性微服务的不同实例之间负载均衡API调用，并在高流量情况下减轻微服务的负担。
- en: Offer better security by throttling sudden increases in API calls during **Distributed
    Denial of Service** (**DDoS**) and similar attacks.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过限制在**分布式拒绝服务**（**DDoS**）和类似攻击期间API调用的突然增加，提供更好的安全性。
- en: Authenticate and authorize users to access different components in the MSA system.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证和授权用户访问MSA系统中的不同组件。
- en: Provide comprehensive analytics to provide deep insights into system metrics
    and logs, which can help further enhance system design and performance.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供全面的分析，以深入了解系统指标和日志，这有助于进一步改进系统设计和性能。
- en: 'Despite all these advantages and functions of the API gateway, there are still
    some drawbacks to having an API gateway in your MSA system:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管API网关具有所有这些优点和功能，但在你的MSA系统中使用API网关仍然存在一些缺点：
- en: The most obvious is complexity. The more protocols and API contract data structures
    we have in the system, the more complex the gateway becomes.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最明显的是复杂性。系统中协议和API合约数据结构越多，网关就越复杂。
- en: The MSA’s operation is highly dependent on the API gateway’s performance and
    availability, which may create an unwanted system performance bottleneck.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MSA的操作高度依赖于API网关的性能和可用性，这可能会创建一个不受欢迎的系统性能瓶颈。
- en: Introducing an additional intermediary component such as an API gateway in the
    path of intra-microservice communication increases service response time. And
    with chatty services, the increased response time can become considerable.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在微服务内部通信路径中引入额外的中介组件，如API网关，会增加服务响应时间。对于健谈的服务，增加的响应时间可能会变得相当可观。
- en: Even with all the functions the API gateway provides, we still need a way to
    map each user request to specific tasks that the MSA system would need to run
    to fulfill that request. In the next section, we’ll discuss how the MSA system
    tasks are mapped to specific user services, and how these tasks are orchestrated
    in MSA.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 即使API网关提供了所有这些功能，我们仍然需要一种方法来将每个用户请求映射到MSA系统需要运行以完成该请求的特定任务。在下一节中，我们将讨论MSA系统任务如何映射到特定的用户服务，以及这些任务如何在MSA中编排。
- en: Service catalogs and orchestrators
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务目录和编排器
- en: Orchestration is one of the most commonly used communication patterns in MSA
    systems. We briefly discussed this concept in [*Chapter 1*](B18934_01.xhtml#_idTextAnchor014).
    In this section, we will dive into more details about orchestration.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 编排是MSA系统中最常用的通信模式之一。我们在[*第一章*](B18934_01.xhtml#_idTextAnchor014)中简要讨论了这一概念。在本节中，我们将深入了解编排的更多细节。
- en: Determining the most appropriate communication pattern between the different
    microservices depends on many factors. Among the factors that will help determine
    whether choreography or orchestration is the most suited communication pattern
    for the system, you must consider the number of microservices you have in the
    system, the level of interactions between the different microservices, the business
    logic itself, how dynamic business requirements change, and how dynamic system
    updates are.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 确定不同微服务之间最合适的通信模式取决于许多因素。在确定编排或编排是否是最适合系统的通信模式时，您必须考虑系统中微服务的数量、不同微服务之间的交互水平、业务逻辑本身、动态业务需求如何变化以及系统更新如何动态变化。
- en: 'Orchestrators act as the central managers controlling all communication between
    the system’s microservices. They usually interact with the users through a dashboard
    interface that contains all service catalogs. The **Service Catalog** is a set
    of services the MSA system offers to users. Each service in the catalog is linked
    to a set of workflows. **Workflows** are the actions the orchestrator will trigger
    and coordinate between the system’s microservices to deliver the service the user
    selected from the catalog:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 编排器作为中央管理者，控制系统微服务之间的所有通信。它们通常通过包含所有服务目录的仪表板界面与用户交互。**服务目录**是MSA系统向用户提供的一组服务。目录中的每个服务都链接到一组工作流程。**工作流程**是编排器将在系统微服务之间触发和协调的动作，以提供用户从目录中选择的服务：
- en: '![Figure 3.4: Orchestrators in MSA](img/B18934_03_4.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图3.4：MSA中的编排器](img/B18934_03_4.jpg)'
- en: 'Figure 3.4: Orchestrators in MSA'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4：MSA中的编排器
- en: The orchestrator’s functions can be extended beyond managing workflows. Orchestrators
    can also manage the entire life cycle of microservices; this involves provisioning
    and deploying microservices, configuring the microservice, and performing upgrades,
    updates, monitoring, performance audits, and shutdowns when needed.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 编排器的功能可以扩展到管理工作流程之外。编排器还可以管理微服务的整个生命周期；这包括提供和部署微服务、配置微服务以及根据需要执行升级、更新、监控、性能审计和关闭。
- en: Important note
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The orchestrator is the main brain of the MSA system, and it is imperative to
    have the orchestrator deployed and managed as a high-performing and mission-critical
    component of the MSA system.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 编排器是MSA系统的主要大脑，确保编排器作为高绩效和关键任务组件部署和管理是至关重要的。
- en: 'Some of the benefits of running an orchestrator in MSA include the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在MSA中运行编排器的一些好处包括以下内容：
- en: You have a centralized management platform as a single source of truth for all
    of your workflows. Thus, you can build complex workflows in a complex MSA without
    having to worry about how many microservices you have and how they can scale.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您拥有一个集中式管理平台，作为您所有工作流程的唯一真相来源。因此，您可以在复杂的MSA中构建复杂的工作流程，而无需担心您有多少微服务以及它们如何扩展。
- en: As in the API gateway, you can tie in your legacy systems or part of your old
    monolith and completely isolate your microservices from having to couple with
    any other system component. This saves a lot of effort having to build code into
    the independent microservices and tremendously helps in scaling your MSA.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 就像在API网关中一样，您可以连接您的遗留系统或旧单体系统的一部分，并完全隔离微服务，使其无需与其他系统组件耦合。这可以节省大量将代码构建到独立微服务中的努力，并在扩展MSA方面提供巨大帮助。
- en: Microservices are visible to the orchestrator and hence can be completely managed,
    audited, and monitored by the orchestrator. This can produce very helpful and
    insightful analytics that can further enhance the MSA system’s supportability
    and operations.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务对编排器可见，因此可以完全由编排器管理、审计和监控。这可以产生非常有帮助和有洞察力的分析，可以进一步增强MSA系统的可支持和操作能力。
- en: The orchestrator’s visibility can help in troubleshooting any operational issues
    and identifying problems quickly.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编排器的可见性有助于解决任何操作问题并快速识别问题。
- en: Orchestrators can automatically detect and self-resolute some of the operational
    problems. Orchestrators can, for example, detect resource starvation and reroute
    requests to a backup microservice. Orchestrators can automatically vertically
    or horizontally scale a particular microservice when a problem is detected. Orchestrators
    can also try to automatically restart the service if the service is not responding.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协调器可以自动检测并自行解决一些操作问题。例如，协调器可以检测资源饥饿并重新路由请求到备份微服务。当检测到问题时，协调器可以自动垂直或水平扩展特定的微服务。协调器还可以尝试自动重启服务，如果服务没有响应。
- en: The orchestrator solves many of the MSA operational problems, including some
    of the data synchronization challenges. When scaling the system, however, data
    synchronization and data consistency become a big challenge for the orchestrator
    to address by itself. Microservices aggregators help address data synchronization
    issues when the MSA system scales. In the next section, we will discuss what the
    aggregator pattern is, what it is used for, and how it works.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 协调器解决了许多MSA操作问题，包括一些数据同步挑战。然而，在扩展系统时，数据同步和数据一致性成为协调器必须自行解决的大挑战。微服务聚合器帮助解决MSA系统扩展时的数据同步问题。在下一节中，我们将讨论聚合器模式是什么，它用于什么，以及它是如何工作的。
- en: Microservices aggregators
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务聚合器
- en: In [*Chapter 2*](B18934_02.xhtml#_idTextAnchor028), we had to copy some schemas
    across multiple microservices and use saga patterns through the orchestrator to
    keep data consistent and preserve the microservice’s autonomy. This solution may
    be viable in a situation if you have a limited number of microservices within
    the MSA system. In a large number of microservices systems, copying schemas across
    different microservices to maintain the synchronization of the individual microservices
    database doesn’t scale well and can severely impact the system’s overall performance.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第二章*](B18934_02.xhtml#_idTextAnchor028)中，我们不得不在多个微服务之间复制一些模式，并通过协调器使用saga模式来保持数据一致性和保持微服务的自治性。这种解决方案在MSA系统中微服务数量有限的情况下可能是可行的。在大量微服务的系统中，将模式复制到不同的微服务以保持单个微服务数据库的同步并不适用，并且可能会严重影响系统的整体性能。
- en: Consider an MSA system with 100 microservices and copy schemas across about
    20 of those microservices to maintain the microservice’s autonomy. Each time any
    part of any of the schema’s data is updated, the orchestrator will have to sync
    those 20 schemas.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个拥有100个微服务的MSA系统，并将模式复制到大约20个微服务中，以保持微服务的自治性。每当任何模式数据的任何部分被更新时，协调器都必须同步这20个模式。
- en: Moreover, even if we have all 100 microservices perfectly autonomous, what if
    one of the user’s operations needs to gather information from those 20 microservices?
    The orchestrator will have to issue at least 20 different API calls to 20 different
    microservices to get the information the user is looking for. Not to mention that
    some of these 20 microservices may need to exchange multiple API calls to send
    the result back to the user.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，即使我们拥有所有100个完全自治的微服务，如果用户的某个操作需要从那20个微服务中获取信息，会怎样呢？协调器将不得不向20个不同的微服务发出至少20个不同的API调用，以获取用户所需的信息。更不用说其中的一些20个微服务可能需要交换多个API调用，以便将结果发送回用户。
- en: To put things into perspective, let’s revisit the ABC-MSA system we built in
    [*Chapter 2*](B18934_02.xhtml#_idTextAnchor028). We have the `order`, `product`,
    and `inventory` microservices. The `product` microservice is for managing product
    information, the `inventory` microservice is for managing the product inventory,
    and the `order` microservice is for placing and managing orders.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更清晰地理解，让我们回顾一下我们在[*第二章*](B18934_02.xhtml#_idTextAnchor028)中构建的ABC-MSA系统。我们拥有`订单`、`产品`和`库存`微服务。`产品`微服务用于管理产品信息，`库存`微服务用于管理产品库存，而`订单`微服务用于下单和管理订单。
- en: 'Let’s assume we’re in a situation where a sales analyst is generating a report
    to check a product’s average quantity purchased per order and the product’s inventory
    level at the time at which the order was placed, as shown in the following diagram:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们处于这样一个情况：销售分析师正在生成一个报告，以检查一个产品按订单平均购买数量以及订单下单时的产品库存水平，如下面的图所示：
- en: '![Figure 3.5: A sample product order report](img/B18934_03_5.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图3.5：一个示例产品订单报告](img/B18934_03_5.jpg)'
- en: 'Figure 3.5: A sample product order report'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5：一个示例产品订单报告
- en: 'The orchestrator will have to send at least three API calls, one to each of
    the `order`, `product`, and `inventory` microservices, as shown in the following
    diagram:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 调度器必须至少发送三个API调用，每个调用分别针对`order`、`product`和`inventory`微服务，如下所示：
- en: '![Figure 3.6: A user operation spanning multiple microservices](img/B18934_03_6.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图3.6：跨越多个微服务的用户操作](img/B18934_03_6.jpg)'
- en: 'Figure 3.6: A user operation spanning multiple microservices'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6：跨越多个微服务的用户操作
- en: To minimize dependencies and response time, a better approach for this particular
    situation is to use an `order`, `product`, and `inventory` microservices and update
    its database with the combined information.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 为了最小化依赖和响应时间，在这种情况下更好的方法是使用`order`、`product`和`inventory`微服务，并使用合并的信息更新其数据库。
- en: 'The API gateway or consumer will only need to send one API call to the aggregator
    to get all the information it needs. The number of API calls is minimized and
    the overall response time is greatly reduced, especially in cases where the information
    required is distributed across a large number of microservices:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: API网关或消费者只需向聚合器发送一个API调用，即可获取所需的所有信息。API调用的次数最小化，整体响应时间大大减少，尤其是在所需信息分布在大量微服务中的情况下：
- en: '![Figure 3.7: An aggregator communication pattern](img/B18934_03_7.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图3.7：聚合器通信模式](img/B18934_03_7.jpg)'
- en: 'Figure 3.7: An aggregator communication pattern'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.7：聚合器通信模式
- en: The aggregator communication pattern reduces the number of API calls users could
    trigger in various operational requests and further enhances the data synchronization’s
    design and performance, as well as the overall system performance, especially
    in high-latency networks.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合器通信模式减少了用户在各种操作请求中可能触发的API调用次数，进一步增强了数据同步的设计和性能，以及整体系统性能，尤其是在高延迟网络中。
- en: Now, we know the roles of the API gateway, the orchestrator, and the aggregator.
    In the next section, we will discuss how all these three components interact with
    each other in the MSA.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经了解了API网关、调度器和聚合器的角色。在下一节中，我们将讨论这三个组件如何在MSA中相互交互。
- en: Gateways versus orchestrators versus aggregators
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网关与调度器与聚合器
- en: 'From what we have described so far, there are some overlapping functions between
    the API gateway, the orchestrator, and the aggregator. In this section, we will
    answer some of the fundamental questions regarding how all three components interact
    in a single MSA system:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们迄今为止所描述的内容来看，API网关、调度器和聚合器之间存在一些重叠的功能。在本节中，我们将回答一些关于这三个组件如何在单个MSA系统中交互的基本问题：
- en: How do these three MSA components work together?
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这三个MSA组件是如何协同工作的？
- en: Can an API gateway perform the aggregator and orchestrator functions?
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API网关能否执行聚合器和调度器的功能？
- en: What are the best practices for deploying all these communication patterns in
    our MSA?
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的MSA中部署所有这些通信模式的最佳实践是什么？
- en: First of all, theoretically speaking, you can have clients interact with the
    MSA microservices directly without an API gateway. However, this would not be
    a good practice. By having no gateway in your MSA system, you would need to have
    most of the gateway functions implemented within each microservice you have in
    the system.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，从理论上讲，您可以让客户端直接与MSA微服务交互，而不需要API网关。然而，这并不是一个好的做法。在没有网关的MSA系统中，您需要在系统中每个微服务中实现大部分网关功能。
- en: To keep microservices as light and autonomous as possible, it is highly recommended
    to have an API gateway in your MSA system. The API gateway will handle all ingress
    and egress API traffic from the different types of clients. Clients can be a web
    dashboard, a mobile application, a tablet, a third-party integration system, and
    so on.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使微服务尽可能轻量化和自主，强烈建议在MSA系统中拥有一个API网关。API网关将处理来自不同类型客户端的所有入站和出站API流量。客户端可以是网络仪表板、移动应用、平板电脑、第三方集成系统等。
- en: Whether you add an aggregator or not will highly depend on your business logic
    and system design. You will only need aggregators if you have client use cases
    where requests need to span across multiple microservices at the backend.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 是否添加聚合器将高度取决于您的业务逻辑和系统设计。只有当您有客户端用例，请求需要在后端跨越多个微服务时，您才需要聚合器。
- en: Aggregators can be implemented as part of the gateway itself; however, the best
    practice is to add an aggregator only whenever it is needed and make it an independent
    standalone microservice.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合器可以作为网关本身的一部分实现；然而，最佳实践是在需要时才添加聚合器，并使其成为一个独立的独立微服务。
- en: An MSA system can have multiple aggregators, each with specific business logic,
    and fulfilling a specific collection of data from a different set of microservices.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: MSA系统可以拥有多个聚合器，每个聚合器都有特定的业务逻辑，并从不同的微服务集合中收集特定的数据集。
- en: 'Similarly, orchestration patterns can also be implemented in the API gateway;
    however, you need the API gateway to focus on doing the main functions it was
    created for and leave orchestration tasks to the orchestrator. The orchestrator
    is also best deployed as a standalone microservice:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，编排模式也可以在API网关中实现；然而，你需要让API网关专注于执行其创建时的主要功能，并将编排任务留给编排器。编排器也最好作为独立的独立微服务部署：
- en: '![Figure 3.8: MSA high-level architecture](img/B18934_03_8.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图3.8：MSA高级架构](img/B18934_03_8.jpg)'
- en: 'Figure 3.8: MSA high-level architecture'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.8：MSA高级架构
- en: The preceding diagram shows the high-level architecture of having all these
    components working together within the MSA system. Clients always interact with
    the API gateway, and the API gateway will route the request to the appropriate
    service within the MSA system.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图显示了所有这些组件在MSA系统中协同工作的高级架构。客户端始终与API网关交互，API网关将请求路由到MSA系统中的适当服务。
- en: Client API calls are routed to the appropriate microservice based on the API’s
    configuration. If the client request is something that is fulfilled by communicating
    with a single microservice, then the gateway will send that request directly to
    the microservice. API calls that span multiple microservices and are assigned
    to a specific aggregator in the system will be forwarded to that particular aggregator.
    Finally, for API requests that invoke specific workflows, the API gateway will
    forward those to the orchestrator.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端API调用根据API的配置路由到适当的微服务。如果客户端请求是通过与单个微服务通信来满足的，那么网关将直接将该请求发送到微服务。跨越多个微服务并分配给系统中的特定聚合器的API调用将被转发到该特定聚合器。最后，对于调用特定工作流程的API请求，API网关将将其转发到编排器。
- en: In this section, we learned how the API gateway, the orchestrator, and the aggregator
    coexist in the same MSA system. In the next section, we will try to apply the
    concepts of all these three communication patterns to our previously developed
    ABC-MSA system.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了API网关、编排器和聚合器如何在同一MSA系统中共存。在下一节中，我们将尝试将所有这些三种通信模式的概念应用到我们之前开发的ABC-MSA系统中。
- en: Microservices circuit breaker
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务断路器
- en: Another challenge in MSA systems is the stability and assurance of workflow
    execution. Saga patterns, which we discussed in [*Chapter 1*](B18934_01.xhtml#_idTextAnchor014),
    are used to ensure that all transactions within a specific workflow are either
    all successfully executed, or all fail. But is that enough to ensure the reliable
    execution of microservices?
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在MSA系统中，另一个挑战是工作流程执行的稳定性和保证。我们在[*第一章*](B18934_01.xhtml#_idTextAnchor014)中讨论的Sagas模式用于确保特定工作流程内的所有事务要么全部成功执行，要么全部失败。但这是否足以确保微服务的可靠执行？
- en: Let’s consider a scenario where the called microservice is too slow in responding
    to API calls. Requests get successfully executed, but the microservice’s response
    times out. The microservice consumer, in turn, may assume an execution failure,
    and accordingly repeat the operation, which can be very problematic.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个场景，即被调用的微服务对API调用的响应太慢。请求成功执行，但微服务的响应超时。微服务消费者随后可能会假设执行失败，并相应地重复操作，这可能会非常麻烦。
- en: 'As shown in the following diagram, when a response timeout takes place in the
    Payment microservice, the Payment microservice will process the payment, but the
    microservice consumer will assume that the payment has not been processed and
    may automatically (or upon user request) retry the process. This behavior will
    cause the payment to be processed multiple times, resulting in multiple charges
    for the same order, or for the order to be placed multiple times:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如下图中所示，当支付微服务发生响应超时时，支付微服务将处理支付，但微服务消费者会假设支付尚未处理，并可能自动（或根据用户请求）重试该过程。这种行为会导致支付被多次处理，从而对同一订单产生多次收费，或者导致订单被多次提交：
- en: '![Figure 3.9: Payment microservice with too slow of a response time](img/B18934_03_9.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.9: Payment microservice with too slow of a response time'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: In MSA, when microservices get instantiated, they start with limited resources
    and threads to avoid one particular microservice from hogging all the system’s
    resources.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: With system resources in mind, consider another scenario, as shown in *Figure
    3**.10*, where the Inventory microservice is part of a service workflow and the
    Payment microservice is neither processing nor responding to API calls for whatever
    reason. In this case, both the Order and Payment microservices will keep waiting
    for confirmation from the inventory before they start releasing their resources.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: 'With the Inventory microservice timing out requests, and under a system heavy
    load or high order volume, requests start to pile up for the Order and Payment
    microservices. Eventually, both the Order and Payment microservices start to run
    out of resources and become unable to respond to requests:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.10: Inventory microservice is down](img/B18934_03_10.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.10: Inventory microservice is down'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Similar scenarios in MSA can result in a domino effect, causing a cascading
    failure to multiple microservices, which, in turn, causes an entire system failure.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: A microservice **circuit breaker** is used to prevent a system cascading failure
    from happening. A circuit breaker monitors microservice performance using real
    traffic metrics. It analyses parameters such as response time and successful response
    rate and then determines the health of the microservice in real time. Should the
    microservice become unhealthy, the circuit breaker immediately starts responding
    to the microservice consumers with an error.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'A circuit breaker does not prevent the microservice being monitored from failing;
    rather, it averts a cascading failure from taking place:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.11: The Inventory microservice with an inline circuit breaker](img/B18934_03_11.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.11: The Inventory microservice with an inline circuit breaker'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: When the circuit breaker assumes a microservice is unhealthy, it still needs
    to monitor and evaluate the microservice’s operational performance. The circuit
    breaker switches to a **half-open state**, where it only allows a small portion
    of requests to pass through to the microservice being monitored. Once the circuit
    breaker detects a healthy microservice response, the circuit breaker switches
    its state back to a **closed state**, where API traffic flows back normally to
    the microservice.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Circuit breakers are not needed for every single microservice in the MSA system.
    We only need to deploy a circuit breaker on microservices that can cause a cascading
    failure. Architects will need to study and determine which microservices need
    circuit breaker protection.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: A circuit breaker can be deployed as a standalone microservice or be part of
    the API gateway. Whether circuit breakers are implemented as standalone microservices
    or part of the API gateway highly depends on the system’s business and operational
    requirements, as well as the patterns adopted in the architecture itself.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: The circuit breaker pattern, as well as the orchestrator, aggregator, ACL, and
    API gateway, are all enhancements architects that can be applied to the MSA system
    for better reliability, resilience, and overall performance. In the next section,
    we will learn how to apply each of the patterns discussed here to our ABC-MSA
    system.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: ABC-MSA enhancements
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 2*](B18934_02.xhtml#_idTextAnchor028), we refactored our ABC-Monolith
    into a simple ABC-MSA. The ABC-MSA we designed in [*Chapter 2*](B18934_02.xhtml#_idTextAnchor028)
    lacked many of the enhancements we are considering in this chapter. It is time
    to take what we have learned in this chapter and apply that to the ABC-MSA system
    to enhance its design and operations.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: First of all, in the ABC-MSA from [*Chapter 2*](B18934_02.xhtml#_idTextAnchor028),
    the orchestrator was doing both the API gateway functions and the orchestration
    function. So far, we have learned that combining both the gateway and orchestration
    functions in one service is not the best option. Therefore, we will add to our
    ABC-MSA system an API gateway dedicated to ingress and egress API calls, and other
    API gateway functions we discussed earlier in this chapter, such as authentication,
    authorization, audit, monitoring, and so on.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: The API gateway will run as a separate standalone microservice serving direct
    client requests, including the system dashboard and user frontend. The orchestrator
    will also run as a standalone microservice serving the MSA’s workflows.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: The aggregator(s) will depend on the use cases where multiple ABC-MSA microservices
    are used to fulfill the user requests.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: A simple use case for using an aggregator would be a user checking for an order’s
    shipping status. The status should include the order information, the products
    included in the order, and the shipping status of that order.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: 'To show all this information to the user, we will need to pull information
    from three different microservices: Order Management, Product Management, and
    Shipping Management. We will deploy an aggregator as a standalone microservice
    to pull the data from all these microservices and make them available for user
    API consumption:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.12: The enhanced ABC-MSA architecture](img/B18934_03_12.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.12: The enhanced ABC-MSA architecture'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding diagram, we added the Management and Orchestration layer as
    part of the ABC-MSA system. This layer will manage the orchestration workflows
    and the microservice’s life cycle, including, installation, configuration, instantiation,
    updates, upgrades, and shutdowns.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: We will also need an ACL to be active during the transition from the ABC-Monolith
    to the ABC-MSA. The ACL will act as a buffer between both systems to maintain
    the neatness of the architecture and its operations. Once all the ABC-Monolith
    functions have been redeployed into the ABC-MSA, both the old ABC-Monolith and
    the ACL can be decommissioned.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed the different components of the MSA that can be
    introduced to maintain the system’s stability and enhance its performance.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: We discussed how to use the ACL to protect our new MSA during its transition
    from the old monolithic system. Then, we covered the roles and functions of the
    API gateway, the aggregator, and the orchestrator. We also covered some of the
    drawbacks you may experience when adopting the various communication patterns
    in MSA.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we redesigned our ABC-MSA to showcase how these different components
    can all function together in a typical MSA.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 1*](B18934_01.xhtml#_idTextAnchor014) to [*Chapter 3*](#_idTextAnchor039)
    covered the basics of the MSA. In the next chapter, we will start discussing,
    with hands-on examples, key machine learning and deep learning algorithms used
    in MSA enterprise systems, and go over some programming and tool examples of building
    machine learning and deep learning algorithms.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 2: Overview of Machine Learning Algorithms and Applications'
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this part, we will shift our focus to machine learning. We will learn about
    the different concepts of machine learning algorithms and how to design and build
    a machine learning system, maintain the model, and apply machine learning to an
    intelligent enterprise MSA.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: We will first learn the fundamentals when it comes to identifying the difference
    between different machine learning models and their use cases. Once we’ve covered
    the basics, we will start to learn how to design a machine learning system pipeline.
    Once we have established a machine learning system pipeline, we will learn what
    data shifts are, how they can impact our system, and how we can identify and address
    them. Finally, having gone through all the basics, we will start to explore the
    different use cases for building our very own intelligent enterprise MSA.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: By the end of *Part 2*, we will have a basic understanding of machine learning
    and the different algorithms, how to build and maintain a machine learning system,
    and, finally, the different use cases in which we can use machine learning for
    our intelligent enterprise MSA.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: 'This part comprises the following chapters:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 4*](B18934_04.xhtml#_idTextAnchor051), *Key Machine Learning Algorithms
    and Concepts*'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 5*](B18934_05.xhtml#_idTextAnchor061), *Machine Learning System Design*'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 6*](B18934_06.xhtml#_idTextAnchor072), *Stabilizing the Machine Learning
    System*'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B18934_07.xhtml#_idTextAnchor079), *How Machine Learning and
    Deep Learning Help in MSA Enterprise Systems*'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
