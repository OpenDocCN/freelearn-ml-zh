<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Get Closer to Your Data</h1>
                </header>
            
            <article>
                
<p class="calibre2">In this chapter, we will cover the following recipes:</p>
<ul class="calibre10">
<li class="calibre11">Data manipulation with Python</li>
<li class="calibre11">Analyzing, visualizing, and treating missing values</li>
<li class="calibre11">Exploratory data analysis</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p class="calibre2">In this book, we will cover various ensemble techniques and will learn how to ensemble multiple machine learning algorithms to enhance a model's performance. We will use pandas, NumPy, scikit-learn, and Matplotlib, all of which were built for working with Python, as we will do <span class="calibre5">throughout the book</span><span class="calibre5">. </span>By now, you should be well aware of data manipulation and exploration.</p>
<p class="calibre2">In this chapter, we will recap how to read and manipulate data in Python, how to analyze and treat missing values, and how to explore data to gain deeper insights. We will use various Python packages, such as <kbd class="calibre12">numpy</kbd> and <kbd class="calibre12">pandas</kbd>, for data manipulation and exploration, and <kbd class="calibre12">seaborn</kbd> packages for data visualization. We will continue to use some or all of these libraries in the later chapters of this book as well. We will also use the Anaconda distribution for our Python coding. If you have not installed Anaconda, you need to download it from <a href="https://www.anaconda.com/download/#macos" class="calibre9">https://www.anaconda.com/download</a>. At the time of writing this book, the latest version of Anaconda is 5.2, and comes with both Python 3.6 and Python 2.7. We suggest you download Anaconda for Python 3.6. We will also use the <kbd class="calibre12">HousePrices</kbd> dataset, which is available on GitHub.</p>
<p class="calibre2"/>
<p class="calibre2"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Data manipulation with Python</h1>
                </header>
            
            <article>
                
<p class="calibre2">In real life, it is often hard to get a complete and clean dataset formatted exactly as we need it. The data we receive often <span class="calibre5">can</span>not be directly used in statistical or machine learning algorithms. We need to manipulate the raw data so that the processed data can be used for further analysis and modelling purposes. To begin with, we need to import the required packages, such as <kbd class="calibre12">pandas</kbd>, and read our dataset into Python. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p class="calibre2"><span class="calibre5">We will use the <kbd class="calibre12">os</kbd> package in the operating system's dependent functionality, and the</span><span class="calibre5"> </span><kbd class="calibre12">pandas</kbd> <span class="calibre5">package for data manipulation. </span></p>
<p class="calibre2"><span class="calibre5">Let's now take a look at the data definitions to understand our variables. In the following code, we list the data definition for a few variables.</span><span class="calibre5"> The dataset and the complete data definitions are available on GitHub. Here is an abridged version of the data description file:</span></p>
<pre class="calibre18">MS SubClass (Nominal): Identifies the type of dwelling involved in the sale<br class="title-page-name"/>Lot Frontage (Continuous): Linear feet of street connected to property<br class="title-page-name"/>Alley (Nominal): Type of alley access to property<span><br class="title-page-name"/>Overall Qual (Ordinal): Rates the overall material and finish of the house<br class="title-page-name"/>Overall Cond (Ordinal): Rates the overall condition of the house<br class="title-page-name"/>Year Built (Discrete): Original construction date<br class="title-page-name"/></span>Mas Vnr Type (Nominal): Masonry veneer type<br class="title-page-name"/>Mas Vnr Area (Continuous): Masonry veneer area in square feet<br class="title-page-name"/>Garage Type (Nominal): Garage location<br class="title-page-name"/>Garage Yr Blt (Discrete): Year garage was built<br class="title-page-name"/>Garage Finish (Ordinal): Interior finish of the garage<br class="title-page-name"/>Garage Cars (Discrete): Size of garage in car capacity<br class="title-page-name"/>Garage Area (Continuous): Size of garage in square feet<br class="title-page-name"/>Garage Qual (Ordinal): Garage quality<br class="title-page-name"/>Garage Cond (Ordinal): Garage condition<br class="title-page-name"/>...<br class="title-page-name"/>...<br class="title-page-name"/>SalePrice (Continuous): Sale price $$</pre>
<p class="calibre2">We will then import the <kbd class="calibre12">os</kbd> and <kbd class="calibre12">pandas</kbd> packages and set our working directory according to our requirements, as seen in the following code block:</p>
<pre class="calibre18">import os<br class="title-page-name"/>import pandas as pd<br class="title-page-name"/><br class="title-page-name"/># Set working directory as per your need<br class="title-page-name"/>os.chdir(".../.../Chapter 1")<br class="title-page-name"/>os.getcwd()</pre>
<p class="calibre2">The next step is to download the dataset from GitHub and copy it to your working directory. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p class="calibre2"><span class="calibre5">Now, let's perform some data manipulation steps: </span></p>
<ol class="calibre14">
<li class="calibre11">First, we will read the data in <kbd class="calibre12">HousePrices.csv</kbd> from our current working directory and create our first DataFrame for manipulation. We name the <span>DataFrame</span> <kbd class="calibre12">housepricesdata</kbd>, as follows:</li>
</ol>
<pre class="calibre18">housepricesdata = pd.read_csv("HousePrices.csv")</pre>
<ol start="2" class="calibre14">
<li class="calibre11">Let's now take a look at our DataFrame and see how it looks:</li>
</ol>
<pre class="calibre18"># See first five observations from top<br class="title-page-name"/>housepricesdata.head(5)</pre>
<div class="packttip1">
<p class="calibre2">You<span class="calibre5"> </span>might not be able to see all the rows; Jupyter will truncate some of the variables. In order to view all of the rows and columns for any output in Jupyter, execute the following commands:</p>
<p class="calibre2"><kbd class="calibre19"># Setting options to display all rows and columns</kbd><br class="calibre6"/>
<kbd class="calibre19">pd.options.display.max_rows = None</kbd><br class="calibre6"/>
<kbd class="calibre19">pd.options.display.max_columns = None</kbd></p>
</div>
<ol start="3" class="calibre14">
<li class="calibre11">We can see the dimensions of the <span>DataFrame </span>with <kbd class="calibre12">shape</kbd>. <kbd class="calibre12">shape</kbd> is an attribute of the <kbd class="calibre12">pandas</kbd> DataFrame:</li>
</ol>
<pre class="calibre18">housepricesdata.shape</pre>
<p class="calibre2"/>
<p class="calibre2"/>
<p class="calibre2"/>
<p class="calibre2"/>
<p class="calibre20">With the preceding command, we can see the number of rows and columns, as follows:</p>
<pre class="calibre18">(1460, 81)</pre>
<p class="calibre20"><span class="calibre5">Here, we can see that the DataFrame has <kbd class="calibre12">1460</kbd> observations and <kbd class="calibre12">81</kbd> columns.</span></p>
<ol start="4" class="calibre14">
<li class="calibre11">Let's take a look at the datatypes of the variables in the <span>DataFrame</span>:</li>
</ol>
<pre class="calibre18">housepricesdata.dtypes</pre>
<p class="calibre20">In the following code block, we can see the datatypes of each variable in the <span class="calibre5">DataFrame</span>: </p>
<pre class="calibre18">Id                 int64
MSSubClass         int64
MSZoning          object
LotFrontage      float64
LotArea            int64
LotConfig         object
LandSlope         object
                  ...   
BedroomAbvGr       int64
KitchenAbvGr       int64
KitchenQual       object
TotRmsAbvGrd       int64
SaleCondition     object
SalePrice          int64
Length: 81, dtype: object</pre>
<p class="calibre20">We're now all ready to start with our data manipulation, which we can do in many different ways. In this section, we'll look at a few ways in which we can manipulate and prepare our data for the purpose of analysis.</p>
<p class="calibre20">Let's start by summarizing our data.</p>
<ol start="5" class="calibre14">
<li class="calibre11">The <kbd class="calibre12">describe()</kbd> function will show the statistics for the numerical variables only:</li>
</ol>
<pre class="calibre18">housepricesdata.describe()</pre>
<p class="calibre2"/>
<p class="calibre2"/>
<p class="calibre20">We can see the output in the following screenshot:</p>
<p class="CDPAlignCenter"><img class="aligncenter" src="assets/ae71b07f-4ae3-49f4-824c-63a95f2fabd8.png"/></p>
<ol start="6" class="calibre14">
<li class="calibre11">We will remove the <kbd class="calibre12">id</kbd> column, as this will not be necessary for our analysis:</li>
</ol>
<pre class="calibre18"># inplace=True will overwrite the <span>DataFrame</span> after dropping Id column<br class="title-page-name"/>housepricesdata.drop(['Id'], axis=1, inplace=True)</pre>
<ol start="7" class="calibre14">
<li class="calibre11">Let's now look at the distribution of some of the object type variables, that is, the categorical variables. In the following example, we are going to look at <kbd class="calibre12">LotShape</kbd> and <kbd class="calibre12">LandContour</kbd>. We can study the <span>other </span>categorical variables of the dataset in the same way as shown in the following code block:</li>
</ol>
<pre class="calibre18"># Name the count column as "count"<br class="title-page-name"/>lotshape_frequencies = pd.crosstab(index=housepricesdata["LotShape"], columns="count") <br class="title-page-name"/><br class="title-page-name"/>landcountour_frequencies = pd.crosstab(index=housepricesdata["LandContour"], columns="count") # Name the count column as "count"<br class="title-page-name"/><br class="title-page-name"/>print(lotshape_frequencies)<br class="title-page-name"/>print("\n") # to keep a blank line for display<br class="title-page-name"/>print(landcountour_frequencies)</pre>
<ol start="8" class="calibre14">
<li class="calibre11"><span>We will now see how to perform a conversion between datatypes. </span>What we notice is that the data definition of variables such as <kbd class="calibre12">MSSubClass</kbd>, <kbd class="calibre12">OverallQual</kbd>, and <kbd class="calibre12">OverallCond</kbd> are all categorical variables. After importing the dataset, however, they appear as integers. </li>
</ol>
<div class="packttip">Prior to typecasting any variable, ensure that there are no missing values.</div>
<p class="calibre20"><span class="calibre5">Here, we'll convert the variables to a categorical datatype:</span></p>
<pre class="calibre18"># Using astype() to cast a pandas object to a specified datatype<br class="title-page-name"/>housepricesdata['MSSubClass'] = housepricesdata['MSSubClass'].astype('object')<br class="title-page-name"/>housepricesdata['OverallQual'] = housepricesdata['OverallQual'].astype('object')<br class="title-page-name"/>housepricesdata['OverallCond'] = housepricesdata['OverallCond'].astype('object')<br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/># Check the datatype of MSSubClass after type conversion<br class="title-page-name"/>print(housepricesdata['MSSubClass'].dtype)<br class="title-page-name"/>print('\n') # to keep a blank line for display<br class="title-page-name"/><br class="title-page-name"/># Check the distribution of the levels in MSSubClass after conversion<br class="title-page-name"/># Make a crosstab with pd.crosstab()<br class="title-page-name"/># Name the count column as "count"<br class="title-page-name"/>print(pd.crosstab(index=housepricesdata["MSSubClass"], columns="count")) </pre>
<p class="calibre20">We can see the count of observations for each category of houses, as shown in the following code block:</p>
<pre class="calibre18">category

col_0       count
MSSubClass       
20            536
30             69
40              4
45             12
50            144
60            299
70             60
75             16
80             58
85             20
90             52
120            87
160            63
180            10
190            30</pre>
<p class="calibre20"><span class="calibre5">There are many variables that might not be very useful by themselves, but transforming them gives us a lot of interesting insights. Let's create some new, meaningful variables.</span></p>
<p class="calibre2"/>
<p class="calibre2"/>
<ol start="9" class="calibre14">
<li class="calibre11"><kbd class="calibre12">YearBuilt</kbd> and <kbd class="calibre12">YearRemodAdd</kbd> represent the original construction date and the remodel date respectively. However, if they can be converted into age, these variables will tell us how old the buildings are and how many years it has been since they were remodeled. To do this, we create two new variables, <kbd class="calibre12">BuildingAge</kbd> and <kbd class="calibre12">RemodelAge</kbd>:</li>
</ol>
<pre class="calibre18"># Importing datetime package for date time operations<br class="title-page-name"/>import datetime as dt<br class="title-page-name"/><br class="title-page-name"/># using date time package to find the current year<br class="title-page-name"/>current_year = int(dt.datetime.now().year)<br class="title-page-name"/><br class="title-page-name"/># Subtracting the YearBuilt from current_year to find out the age of the building<br class="title-page-name"/>building_age = current_year - housepricesdata['YearBuilt']<br class="title-page-name"/><br class="title-page-name"/># Subtracting the YearRemonAdd from current_year to find out the age since the<br class="title-page-name"/># building was remodelled<br class="title-page-name"/>remodelled_age = current_year - housepricesdata['YearRemodAdd']</pre>
<ol start="10" class="calibre14">
<li class="calibre11">Now, let's add the two variables to our dataset:</li>
</ol>
<pre class="calibre18"># Adding the two variables to the <span>DataFrame</span><br class="title-page-name"/>housepricesdata['building_age'] = building_age<br class="title-page-name"/>housepricesdata['remodelled_age'] = remodelled_age<br class="title-page-name"/><br class="title-page-name"/># Checking our <span>DataFrame </span>to see if the two variables got added<br class="title-page-name"/>housepricesdata.head(5)</pre>
<p class="calibre20">We notice that <kbd class="calibre12">building_age</kbd> and <kbd class="calibre12">remodelled_age</kbd> are now added to the DataFrame, as shown in the following screenshot:</p>
<p class="CDPAlignCenter"><img class="aligncenter1" src="assets/9a775483-e117-482a-9a06-ca71ada35476.png"/></p>
<p class="calibre20"><span class="calibre5">Variables that contain label data need to be converted into a numerical form for machine learning algorithms to use. To get around this, we will perform encoding that will transform the labels into numerical forms so that the algorithms can use them. </span></p>
<p class="calibre2"/>
<ol start="11" class="calibre14">
<li class="calibre11">We need to identify the variables that need encoding, which include <kbd class="calibre12">Street</kbd>, <kbd class="calibre12">LotShape</kbd>, and <kbd class="calibre12">LandContour</kbd>. We will perform one-hot encoding, which is a representation of categorical variables as binary vectors. We will use the <kbd class="calibre12">pandas</kbd> package in Python to do this:</li>
</ol>
<pre class="calibre18"># We use get_dummies() function to one-hot encode LotShape<br class="title-page-name"/>one_hot_encoded_variables = pd.get_dummies(housepricesdata['LotShape'],prefix='LotShape')<br class="title-page-name"/><br class="title-page-name"/># Print the one-hot encoded variables to see how they look like<br class="title-page-name"/>print(one_hot_encoded_variables)</pre>
<p class="calibre20">We can see the one-hot encoded variables that have been created in the following screenshot:</p>
<p class="CDPAlignCenter"><img class="aligncenter2" src="assets/394c838b-dc90-47d9-9e03-9676cca5c3c2.png"/></p>
<ol start="12" class="calibre14">
<li class="calibre11">Add the one-hot encoded variables to our <span>DataFrame</span>, as follows:</li>
</ol>
<pre class="calibre18"># Adding the new created one-hot encoded variables to our <span>DataFrame</span><br class="title-page-name"/>housepricesdata = pd.concat([housepricesdata,one_hot_encoded_variables],axis=1)<br class="title-page-name"/><br class="title-page-name"/># Let's take a look at the added one-hot encoded variables<br class="title-page-name"/># Scroll right to view the added variables<br class="title-page-name"/>housepricesdata.head(5)</pre>
<p class="calibre2"/>
<p class="calibre20">We can see the output that we get after adding the one-hot encoded variables to the <span class="calibre5">DataFrame</span> in the following screenshot:</p>
<p class="CDPAlignCenter"><img class="aligncenter3" src="assets/62732d2d-f5c0-4382-8ab2-7a6820ab2193.png"/></p>
<ol start="13" class="calibre14">
<li class="calibre11">Now, let's remove the original variables since we have already created our one-hot encoded variables:</li>
</ol>
<pre class="calibre18"># Dropping the original variable after one-hot encoding the original variable<br class="title-page-name"/># inplace = True option will overwrite the <span>DataFrame</span><br class="title-page-name"/><br class="title-page-name"/>housepricesdata.drop(['LotShape'],axis=1, inplace=True)</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p class="calibre2">The <kbd class="calibre12">pandas</kbd> module is a part of the Python standard library – it is one of the key modules for data manipulation. We have also used other packages, such as <kbd class="calibre12">os</kbd> and <kbd class="calibre12">datetime</kbd>. After we set our working directory and read the CSV file into Python as a <kbd class="calibre12">pandas</kbd> DataFrame, we moved on to looking at a few data manipulation methods.</p>
<p class="calibre2"><em class="calibre13">Step 1</em> to <em class="calibre13">Step 5</em> in the preceding section showed us how to read the data from a CSV file in Python using <kbd class="calibre12">pandas</kbd>, and also how to use functions such as <kbd class="calibre12">dtypes</kbd>.</p>
<div class="packtinfobox">The<span> </span><kbd class="calibre19">pandas</kbd> package also provides methods for reading data from various file types. For example, <kbd class="calibre19">pandas.read_excel()</kbd><span> </span>r<span>eads an Excel table into a <kbd class="calibre19">pandas</kbd> DataFrame; <kbd class="calibre19">pandas.read_json()</kbd> converts a JSON string into a<kbd class="calibre19">pandas</kbd> object; and <kbd class="calibre19">pandas.read_parquet()</kbd> loads a parquet object from a file path and returns the <kbd class="calibre19">pandas</kbd> DataFrame. More information on this can be found at <a href="https://bit.ly/2yBqtvd" class="calibre21">https://bit.ly/2yBqtvd</a>.</span></div>
<p class="calibre2"/>
<p class="calibre2"/>
<p class="calibre2">You can also read HDF5 format files in Python using the <kbd class="calibre12">h5py</kbd> package. The <kbd class="calibre12">h5py</kbd> package is a Python interface to the HDF5 binary data format. HDF® supports n-dimensional datasets, and each element in the dataset may itself be a complex object. There is no limit on the number or size of data objects in the collection. More info can be found at <a href="https://www.hdfgroup.org/" class="calibre9">https://www.hdfgroup.org/</a>. A sample code block looks like this:</p>
<pre class="calibre22">import h5py<br class="title-page-name"/><br class="title-page-name"/># With 'r' passed as a parameter to the h5py.File() <br class="title-page-name"/># the file will be read in read-only mode<br class="title-page-name"/>data = h5py.File('File Name.h5', 'r')</pre>
<p class="calibre2">We look at the datatypes of the variables, and use <kbd class="calibre12">describe()</kbd> to see the summary statistics for the numerical variables. We need to note that <kbd class="calibre12">describe()</kbd> works only for numerical variables and is intelligent enough to ignore non-numerical variables. In <em class="calibre13">Step 6</em>, we saw how to look at the count of each level for categorical variables such as <kbd class="calibre12">LotShape</kbd> and <kbd class="calibre12">LandContour</kbd>. We can use the same code to take a look at the distribution of other categorical variables.</p>
<p class="calibre2">In <em class="calibre13">Step 7</em>, <span class="calibre5">we took a look at the distribution of the </span><kbd class="calibre12">LotShape</kbd><span class="calibre5"> and </span><kbd class="calibre12">LandContour</kbd><span class="calibre5"> variables using <kbd class="calibre12">pd.crosstab()</kbd>. </span></p>
<div class="packttip"><span>One common requirement in a crosstab is to include subtotals for the rows and the columns. We can display subtotals using the</span><span> <kbd class="calibre19">margins</kbd> keyword. We pass <kbd class="calibre19">margins=True</kbd> to the <kbd class="calibre19">pd.crosstab()</kbd> function. We can also give a name to subtotal columns using the <kbd class="calibre19">margins_name</kbd> keyword. The default value for <kbd class="calibre19">margins_name</kbd> is</span> <kbd class="calibre19">All</kbd>.</div>
<p class="calibre2">We then moved on to learning how to convert datatypes. We had a few variables that were actually categorical, but appeared to be numerical in the dataset. This is often the case in a real-life scenario, hence we need to learn how to typecast our variables. <em class="calibre13">Step 8</em> showed us how to convert a <span class="calibre5">numerical </span>variable, such as <kbd class="calibre12">MSSubClass</kbd>, into a categorical type. In <em class="calibre13">Step 8</em>, we converted a few variables into a categorical datatype. We then created a crosstab to visualize the frequencies of each level of categorical variables.</p>
<p class="calibre2">In <em class="calibre13">Step 9</em>, we created new meaningful variables from existing variables. We created the new variables, <kbd class="calibre12">BuildingAge</kbd> and <kbd class="calibre12">RemodelAge</kbd>, from <kbd class="calibre12">YearBuilt</kbd> and <kbd class="calibre12">YearRemodAdd</kbd> respectively, to represent the age of the building and the number of years that have passed since the buildings were remodeled. This method of creating new variables can provide better insights into our analysis and modeling. This process of creating new features is called <strong class="calibre4">feature engineering</strong>. In <em class="calibre13">Step 10</em>, we added the new variables to our <span class="calibre5">DataFrame</span>.</p>
<p class="calibre2">From there, we moved on to encoding our categorical variables. We needed to encode our categorical variables because they have named descriptions. Many machine learning algorithms cannot operate on labelled data because they <span class="calibre5">require all input and output variables to be numeric. In <em class="calibre13">Step 12</em>, we encoded them with one-hot encoding. In <em class="calibre13">Step 11</em>, we learned</span> how to use the <kbd class="calibre12">get_dummies()</kbd> function, which is a part of the <kbd class="calibre12">pandas</kbd> package, to create the one-hot encoded variables. In <em class="calibre13">Step 12</em>, we added the <kbd class="calibre12">one-hot_encoded_variables</kbd> to our DataFrame. And finally, in <em class="calibre13">Step 13</em><span class="calibre5">, we </span>removed the original variables that are now one-hot encoded.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p class="calibre2">The types of data manipulation required depend on your business requirements. In this first recipe, we saw a few ways to carry out data manipulation, but t<span class="calibre5">here is no limit to what you can do and how you can manipulate data for analysis. </span></p>
<p class="calibre2">We have also seen how to convert a numerical variable into a categorical variable. We can do this kind of typecasting in many ways. For example, we can convert a categorical variable into a numerical variable, if required, with the following code:</p>
<pre class="calibre15"># Converting a categorical variable to numerical<br class="title-page-name"/># Using astype() to cast a pandas object to a specified datatype<br class="title-page-name"/><br class="title-page-name"/># Here we typecast GarageYrBlt from float64 type to int64 type<br class="title-page-name"/>housepricesdata['GarageYrBlt'] = housepricesdata['GarageYrBlt'].astype('int64')</pre>
<p class="calibre2">You can only convert the <kbd class="calibre12">GarageYrBlt</kbd> <span class="calibre5">variable </span>if it does not contain any missing values. The preceding code will throw an error, since <kbd class="calibre12">GarageYrBlt</kbd> contains missing values. </p>
<p class="calibre2"/>
<p class="calibre2"/>
<p class="calibre2">We have looked at how we can use one-hot encoding to convert categorical variables to numerical variables, and why we do this. In addition to one-hot encoding, we can perform other kinds of encoding, such as label encoding, frequency encoding, and so on. An example code for label encoding is given in the following code block:</p>
<pre class="calibre15"># We use sklearn.preprocessing and import LabelEncoder class<br class="title-page-name"/>from sklearn.preprocessing import LabelEncoder<br class="title-page-name"/><br class="title-page-name"/># Create instance of LabelEncoder class<br class="title-page-name"/>lb_make = LabelEncoder()<br class="title-page-name"/><br class="title-page-name"/># We create a new variable LotConfig_code to hold the new <span>numerical </span>labels<br class="title-page-name"/># We label encode LotConfig variable<br class="title-page-name"/>housepricesdata["LotConfig_Code"] = lb_make.fit_transform(housepricesdata["LotConfig"])<br class="title-page-name"/><br class="title-page-name"/># Display the LotConfig variable and its corresponding label encoded <span>numerical </span>values<br class="title-page-name"/>housepricesdata[["LotConfig", "LotConfig_Code"]]</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul class="calibre10">
<li class="calibre11">The pandas guide to type conversion functions (<a href="https://bit.ly/2MzFwiG" class="calibre9">https://bit.ly/2MzFwiG</a>)</li>
<li class="calibre11">The pandas guide to one-hot encoding using <kbd class="calibre12">get_dummies()</kbd> (<a href="https://bit.ly/2N1xjTZ" class="calibre9">https://bit.ly/2N1xjTZ</a>)</li>
<li class="calibre11">The scikit-learn guide to one-hot encoding (<a href="https://bit.ly/2wrNNLz" class="calibre9">https://bit.ly/2wrNNLz</a>)</li>
<li class="calibre11">The scikit-learn guide to label encoding (<a href="https://bit.ly/2pDddVb" class="calibre9">https://bit.ly/2pDddVb</a>)</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Analyzing, visualizing, and treating missing values</h1>
                </header>
            
            <article>
                
<p class="calibre2">Missing values are caused by incomplete data. It is important to handle missing values effectively, as they can lead to inaccurate inferences and conclusions. In this section, we will look at how to analyze, visualize, and treat missing values.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p class="calibre2">Let's start by analyzing variables with missing values. Set the options in pandas to view all rows and columns, as shown in the previous section:</p>
<ol class="calibre14">
<li class="calibre11">With the following syntax, we can see which variables have missing values:</li>
</ol>
<pre class="calibre18"># Check which variables have missing values<br class="title-page-name"/><br class="title-page-name"/>columns_with_missing_values = housepricesdata.columns[housepricesdata.isnull().any()]<br class="title-page-name"/>housepricesdata[columns_with_missing_values].isnull().sum()</pre>
<p class="calibre2"/>
<p class="calibre20">This <span class="calibre5">will produce </span>the following output:</p>
<p class="CDPAlignCenter"><img class="aligncenter4" src="assets/9acdec10-9936-422f-9b64-e31b4d337ac2.png"/></p>
<ol start="2" class="calibre14">
<li class="calibre11">You might also like to see the missing values in terms of percentages. To see the count and percentage of missing values, execute the following command:</li>
</ol>
<pre class="calibre18">import numpy as np<br class="title-page-name"/>import matplotlib.pyplot as plt<br class="title-page-name"/>%matplotlib inline<br class="title-page-name"/> <br class="title-page-name"/># To hold variable names<br class="title-page-name"/>labels = [] <br class="title-page-name"/><br class="title-page-name"/># To hold the count of missing values for each variable <br class="title-page-name"/>valuecount = [] <br class="title-page-name"/><br class="title-page-name"/># To hold the percentage of missing values for each variable<br class="title-page-name"/>percentcount = [] <br class="title-page-name"/><br class="title-page-name"/>for col in columns_with_missing_values:<br class="title-page-name"/>    labels.append(col)<br class="title-page-name"/>    valuecount.append(housepricesdata[col].isnull().sum())<br class="title-page-name"/>    # housepricesdata.shape[0] will give the total row count<br class="title-page-name"/>   percentcount.append(housepricesdata[col].isnull().sum()/housepricesdata.shape[0])<br class="title-page-name"/>    <br class="title-page-name"/>ind = np.arange(len(labels))<br class="title-page-name"/><br class="title-page-name"/>fig, (ax1, ax2) = plt.subplots(1,2,figsize=(20,18))<br class="title-page-name"/><br class="title-page-name"/>rects = ax1.barh(ind, np.array(valuecount), color='blue')<br class="title-page-name"/>ax1.set_yticks(ind)<br class="title-page-name"/>ax1.set_yticklabels(labels, rotation='horizontal')<br class="title-page-name"/>ax1.set_xlabel("Count of missing values")<br class="title-page-name"/>ax1.set_title("Variables with missing values")<br class="title-page-name"/><br class="title-page-name"/>rects = ax2.barh(ind, np.array(percentcount), color='pink')<br class="title-page-name"/>ax2.set_yticks(ind)<br class="title-page-name"/>ax2.set_yticklabels(labels, rotation='horizontal')<br class="title-page-name"/>ax2.set_xlabel("Percentage of missing values")<br class="title-page-name"/>ax2.set_title("Variables with missing values")</pre>
<p class="calibre20">It will show you the missing values in both absolute and percentage terms, as shown in the following screenshot:</p>
<p class="CDPAlignCenter"><img class="aligncenter5" src="assets/56aadd15-3792-4bd6-af6b-8494ad2e1288.png"/></p>
<p class="calibre20">We notice that variables such as <strong class="calibre4">Alley</strong>, <strong class="calibre4">PoolQC</strong>, <strong class="calibre4">Fence</strong>, and <strong class="calibre4">MiscFeature</strong> have <strong class="calibre4">80%</strong> to <strong class="calibre4">90%</strong> of their values missing. <strong class="calibre4">FireplaceQu</strong> has <strong class="calibre4">47.26%</strong> of its values missing. A few other variables, such as <strong class="calibre4">LotFrontage</strong>, <strong class="calibre4">MasVnrType</strong>, <strong class="calibre4">MasVnrArea</strong>, <strong class="calibre4">BsmtQual</strong>, <strong class="calibre4">BsmtCond</strong>, and a few more Garage-related variables have missing values as well.</p>
<p class="calibre2"/>
<p class="calibre20">But there is a catch. Let's look at the <kbd class="calibre12">Alley</kbd> <span class="calibre5">variable </span>again. It shows us that it has <strong class="calibre4">93.76%</strong> missing values. Now take another look at the data description that we looked at in the preceding section. The variable description for <kbd class="calibre12">Alley</kbd> shows that it has three levels: <em class="calibre13">gravel</em>, <em class="calibre13">paved</em>, and <em class="calibre13">no access</em>. In the original dataset, <kbd class="calibre12">'No Access'</kbd> is codified as <kbd class="calibre12">NA</kbd>. When <kbd class="calibre12">NA</kbd> is read in Python, it is treated as <strong class="calibre4">NaN</strong>, which means that a value is missing, so we need to be careful. </p>
<ol start="3" class="calibre14">
<li class="calibre11">Now, we will replace the missing values for <kbd class="calibre12">Alley</kbd> with a valid value, such as <kbd class="calibre12">'No Access'</kbd>:</li>
</ol>
<pre class="calibre18"># Replacing missing values with 'No Access' in Alley variable<br class="title-page-name"/>housepricesdata['Alley'].fillna('No Access', inplace=True)</pre>
<ol start="4" class="calibre14">
<li class="calibre11">Now, let's visualize the missing values and try to see how can we treat them. The following code generates a chart that showcases the spread of missing values. Here we use the <kbd class="calibre12">seaborn</kbd> library to plot the charts:</li>
</ol>
<pre class="calibre18"># Lets import seaborn. We will use seaborn to generate our charts<br class="title-page-name"/>import seaborn as sns<br class="title-page-name"/><br class="title-page-name"/># We will import matplotlib to resize our plot figure<br class="title-page-name"/>import matplotlib.pyplot as plt<br class="title-page-name"/>%matplotlib inline<br class="title-page-name"/>plt.figure(figsize=(20, 10))<br class="title-page-name"/><br class="title-page-name"/># cubehelix palette is a part of seaborn that produces a colormap<br class="title-page-name"/>cmap = sns.cubehelix_palette(light=1, as_cmap=True, reverse=True)<br class="title-page-name"/>sns.heatmap(housepricesdata.isnull(), cmap=cmap)</pre>
<p class="calibre20">The color of the map is generated with linearly increasing brightness by the <kbd class="calibre12">cubehelix_palette()</kbd> function:</p>
<p class="CDPAlignCenter"><img class="aligncenter6" src="assets/fce12232-d35b-4808-a677-f6aa0a48a877.png"/></p>
<p class="calibre20">From the preceding plot<span class="calibre5">, it is easier to read the spread of the missing values. The white marks on the chart indicate missing values. Notice that</span> <kbd class="calibre12">Alley</kbd> <span class="calibre5">no longer reports any missing values.</span></p>
<ol start="5" class="calibre14">
<li class="calibre11"><kbd class="calibre12">LotFrontage</kbd> is a continuous variable and has <strong class="calibre1">17.74%</strong> of its values missing. Replace the missing values in this variable with its median as follows:</li>
</ol>
<pre class="calibre18"># Filling in the missing values in LotFrontage with its median value<br class="title-page-name"/>housepricesdata['LotFrontage'].fillna(housepricesdata['LotFrontage'].median(), inplace=True)</pre>
<p class="calibre2"/>
<ol start="6" class="calibre14">
<li class="calibre11">Let's view the missing value plot once again to see if the missing values from <kbd class="calibre12">LotFrontage</kbd> have been imputed. Copy and execute the preceding code. The missing value plot will look as follows:</li>
</ol>
<p class="CDPAlignCenter"><img class="aligncenter7" src="assets/3fee1f9b-cda4-48f0-acaf-6dddba9faf97.png"/></p>
<p class="calibre20">Here, we can see in the preceding plot that<span class="calibre5"> </span><span class="calibre5">there are no more missing values for</span> <kbd class="calibre12">Alley</kbd> <span class="calibre5">or </span><kbd class="calibre12">LotFrontage</kbd><span class="calibre5">.</span></p>
<ol start="7" class="calibre14">
<li class="calibre11">We have figured out from the data description that several variables have values that are codified as <kbd class="calibre12">NA</kbd>. Because this is read in Python as missing values, we replace all of these with their actual values, which we get to see in the data description shown in the following code block:</li>
</ol>
<pre class="calibre18"># Replacing all NA values with their original meaning<br class="title-page-name"/>housepricesdata['BsmtQual'].fillna('No Basement', inplace=True)<br class="title-page-name"/>housepricesdata['BsmtCond'].fillna('No Basement', inplace=True)<br class="title-page-name"/>housepricesdata['BsmtExposure'].fillna('No Basement', inplace=True)<br class="title-page-name"/>housepricesdata['BsmtFinType1'].fillna('No Basement', inplace=True)<br class="title-page-name"/>housepricesdata['BsmtFinType2'].fillna('No Basement', inplace=True)<br class="title-page-name"/><br class="title-page-name"/>housepricesdata['GarageYrBlt'].fillna(0, inplace=True)<br class="title-page-name"/><br class="title-page-name"/># For observations where GarageType is null, we replace null values in GarageYrBlt=0<br class="title-page-name"/>housepricesdata['GarageType'].fillna('No Garage', inplace=True)<br class="title-page-name"/>housepricesdata['GarageFinish'].fillna('No Garage', inplace=True)<br class="title-page-name"/>housepricesdata['GarageQual'].fillna('No Garage', inplace=True)<br class="title-page-name"/>housepricesdata['GarageCond'].fillna('No Garage', inplace=True)<br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/>housepricesdata['PoolQC'].fillna('No Pool', inplace=True)<br class="title-page-name"/>housepricesdata['Fence'].fillna('No Fence', inplace=True)<br class="title-page-name"/>housepricesdata['MiscFeature'].fillna('None', inplace=True)<br class="title-page-name"/><br class="title-page-name"/>housepricesdata['FireplaceQu'].fillna('No Fireplace', inplace=True)</pre>
<ol start="8" class="calibre14">
<li class="calibre11">Let's take a look at the missing value plot after having treated the preceding variables:</li>
</ol>
<p class="CDPAlignCenter"><img class="aligncenter8" src="assets/e0321ab2-6f0f-4f91-9157-699fdae69fed.png"/></p>
<p class="calibre20">We notice from the preceding plot <span class="calibre5">that there are no more missing values for the variables that we have just treated. However, we are left with a few missing values</span> in <kbd class="calibre12">MasVnrType</kbd>, <kbd class="calibre12">MasVnrArea</kbd>, <span class="calibre5">and</span> <kbd class="calibre12">Electrical</kbd><span class="calibre5">.</span></p>
<ol start="9" class="calibre14">
<li class="calibre11">Let's try to look at the distribution of <kbd class="calibre12">MasVnrType</kbd> by <kbd class="calibre12">MasVnrArea</kbd> with a crosstab:</li>
</ol>
<pre class="calibre18"># Using crosstab to generate the count of MasVnrType by type of MasVnrArea<br class="title-page-name"/>print(pd.crosstab(index=housepricesdata["MasVnrType"],\<br class="title-page-name"/>                  columns=housepricesdata["MasVnrArea"], dropna=False, margins=True)) </pre>
<p class="calibre20">The following output shows that when <kbd class="calibre12">MasVnrArea</kbd> is zero, we have <kbd class="calibre12">MasVnrType</kbd> as <kbd class="calibre12">None</kbd> in the majority of cases:</p>
<p class="CDPAlignCenter"><img class="aligncenter9" src="assets/a65a465b-030d-4368-8a76-e1c0e6b36702.png"/></p>
<ol start="10" class="calibre14">
<li class="calibre11"><span>We will then</span> impute<span> the missing values in <kbd class="calibre12">MasVnrType</kbd> with <kbd class="calibre12">None</kbd> and <kbd class="calibre12">MasVnrArea</kbd> with zero. This is done with the commands shown in the following code block:</span></li>
</ol>
<pre class="calibre18"># Filling in the missing values for MasVnrType and MasVnrArea with None and 0 respectively<br class="title-page-name"/>housepricesdata['MasVnrType'].fillna('None', inplace=True)<br class="title-page-name"/>housepricesdata['MasVnrArea'].fillna(0, inplace=True)</pre>
<p class="calibre20">We are still left with one missing value in the <kbd class="calibre12">Electrical</kbd> variable.</p>
<ol start="11" class="calibre14">
<li class="calibre11">Let's take a look at the observation where <kbd class="calibre12">Electrical</kbd> has a missing value:</li>
</ol>
<pre class="calibre18">housepricesdata['MSSubClass'][housepricesdata['Electrical'].isnull()]</pre>
<p class="CDPAlignCenter"><img class="aligncenter10" src="assets/9dbf6447-f753-49e3-8e0a-7a674d0c92d4.png"/></p>
<ol start="12" class="calibre14">
<li class="calibre11">We see that <kbd class="calibre12">MSSubClass</kbd> is <kbd class="calibre12">80</kbd> when <kbd class="calibre12">Electrical</kbd> is null. Let's see the distribution of the <kbd class="calibre12">Electrical</kbd> type by <kbd class="calibre12">MSSubClass</kbd>:</li>
</ol>
<pre class="calibre18"># Using crosstab to generate the count of Electrical Type by MSSubClass<br class="title-page-name"/>print(pd.crosstab(index=housepricesdata["Electrical"],\<br class="title-page-name"/>columns=housepricesdata['MSSubClass'], dropna=False, margins=True))</pre>
<p class="CDPAlignLeft1"><span class="calibre5">From the following output, we can see that when <kbd class="calibre12">MSSubClass</kbd> is <kbd class="calibre12">80</kbd>, </span>the majority<span class="calibre5"> of cases of the <kbd class="calibre12">Electrical</kbd> type are <kbd class="calibre12">SBrkr</kbd>:</span></p>
<p class="CDPAlignCenter"><img class="aligncenter11" src="assets/ba143935-687a-420c-955c-06f40a4920d6.png"/></p>
<ol start="13" class="calibre14">
<li class="calibre11">Go ahead and impute the <span>missing value in the </span><kbd class="calibre12"><span>Electrical</span></kbd><span> variable with</span> <span><kbd class="calibre12">SBrKr</kbd> by executing the following code:</span></li>
</ol>
<pre class="calibre18">housepricesdata['Electrical'].fillna('SBrkr', inplace=True)</pre>
<ol start="14" class="calibre14">
<li class="calibre11">After this, let's take a look at our missing value plot for a final time:</li>
</ol>
<pre class="calibre18">import seaborn as sns<br class="title-page-name"/>import matplotlib.pyplot as plt<br class="title-page-name"/>%matplotlib inline<br class="title-page-name"/>plt.figure(figsize=(20, 10))<br class="title-page-name"/><br class="title-page-name"/>cmap = sns.cubehelix_palette(light=1, as_cmap=True, reverse=True)<br class="title-page-name"/>sns.heatmap(housepricesdata.isnull(), cmap=cmap)</pre>
<p class="calibre20">The output we get can be seen in the following chart:</p>
<p class="CDPAlignCenter"><img class="aligncenter12" src="assets/ce0bfa9e-4173-4621-9497-9242509f5889.png"/></p>
<p class="calibre2">Notice that the plot has changed and now shows no missing values in our <span class="calibre5">DataFrame</span>. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p class="calibre2">In <em class="calibre13">Step 1 </em>and <em class="calibre13">Step </em><em class="calibre13">2</em>, we looked at the variables with missing values in absolute and percentage terms. We noticed that the <kbd class="calibre12">Alley</kbd> <span class="calibre5">variable </span>had more than <strong class="calibre4">93%</strong> of its values missing. However, from the data description, we figured out that the <kbd class="calibre12">Alley</kbd> variable had a <strong class="calibre4">No Access to Alley </strong><span class="calibre5">value,</span> which is codified as <kbd class="calibre12">NA</kbd> in the dataset. When this value was read in Python, all instances of <kbd class="calibre12">NA</kbd> were treated as missing values. In <em class="calibre13">Step 3</em>, we replaced the <kbd class="calibre12">NA</kbd> in <kbd class="calibre12">Alley</kbd> with <kbd class="calibre12">No Access</kbd>.</p>
<div class="packttip"><span>Note that we used <kbd class="calibre19">%matplotlib inline</kbd> in <em class="calibre23">Step 2</em>. This is a magic function that renders the plot in the notebook itself. </span></div>
<p class="calibre2">In <em class="calibre13">Step 4</em>, we used the <kbd class="calibre12">seaborn</kbd> library to plot the missing value chart. In this chart, we identified the variables that had missing values. The missing values were denoted in white, while the presence of data was denoted in color. We noticed from the chart that <kbd class="calibre12">Alley</kbd> had no more missing values.</p>
<div class="packtinfobox">In <em class="calibre23">Step 4</em>, we used <kbd class="calibre19">cubehelix_palette()</kbd> from the <kbd class="calibre19">seaborn</kbd> library,  which <span>produces a color map with linearly decreasing (or increasing) brightness. The <kbd class="calibre19">seaborn</kbd> library also provides us with options including <kbd class="calibre19">light_palette()</kbd> and <kbd class="calibre19">dark_palette()</kbd>. <kbd class="calibre19">light_palette()</kbd> gives a sequential palette that blends from light to color, while <kbd class="calibre19">dark_palette()</kbd> produces a sequential palette that blends from dark to color.</span></div>
<p class="calibre2">In <em class="calibre13">Step 5</em>, we noticed that one of the numerical variables, <kbd class="calibre12">LotFrontage</kbd>, had more than <strong class="calibre4">17%</strong> of its values missing. We decided to impute the missing values with the median of this variable. We revisited the missing value chart in <em class="calibre13">Step 6</em> to see whether the variables were left with any missing values. We noticed that <kbd class="calibre12">Alley</kbd> and <kbd class="calibre12">LotFrontage</kbd> showed no white marks, indicating that neither of the two variables had any further missing values.</p>
<p class="calibre2">In <em class="calibre13">Step 7</em>, we identified a handful of variables that had data codified with <kbd class="calibre12">NA</kbd>. This caused the same problem we encountered previously, as Python treated them as missing values. We replaced all such codified values with actual information.</p>
<p class="calibre2">We then revisited the missing value chart in <em class="calibre13">Step 8</em>. We saw that almost all the variables then had no missing values, except for <kbd class="calibre12">MasVnrType</kbd>, <kbd class="calibre12">MasVnrArea</kbd>, and <kbd class="calibre12">Electrical</kbd>.</p>
<p class="calibre2">In <em class="calibre13">Step 9</em> and <em class="calibre13">10</em>, we filled in the missing values for the <kbd class="calibre12">MasVnrType</kbd> and <kbd class="calibre12">MasVnrArea</kbd> <span class="calibre5">variables.</span> We noticed that <kbd class="calibre12">MasVnrType</kbd> is <kbd class="calibre12">None</kbd> whenever <kbd class="calibre12">MasVnrArea</kbd> is <kbd class="calibre12">0.0</kbd>, except for some rare occasions. So, we imputed the <kbd class="calibre12">MasVnrType</kbd> variable with <kbd class="calibre12">None</kbd>, and <kbd class="calibre12">MasVnrArea</kbd> with <kbd class="calibre12">0.0</kbd> wherever those two variables had missing values. We were then only left with one variable with missing values, <kbd class="calibre12">Electrical</kbd>.</p>
<p class="calibre2">In <em class="calibre13">Step 11</em>, we looked at what type of house was missing the <kbd class="calibre12">Electrical</kbd> value. We noticed that <kbd class="calibre12">MSSubClass</kbd> denoted the dwelling type and, for the missing <kbd class="calibre12">Electrical </kbd>value, the <kbd class="calibre12">MSSubClass</kbd> was <kbd class="calibre12">80</kbd>, which meant it was split or multi-level. In <em class="calibre13">Step 12</em>, we checked the distribution of <kbd class="calibre12">Electrical</kbd> by the dwelling type, which was <kbd class="calibre12">MSSubClass</kbd>. We noticed that when <kbd class="calibre12">MSSubClass</kbd> equals <kbd class="calibre12">80</kbd>, the majority of the values of <kbd class="calibre12">Electrical</kbd> are <kbd class="calibre12">SBrkr</kbd>, which stands for standard circuit breakers and Romex. For this reason, we decided to impute the missing value in <kbd class="calibre12">Electrical</kbd> with <kbd class="calibre12">SBrkr</kbd>.</p>
<p class="calibre2">Finally, in <em class="calibre13">Step 14</em>, we again revisited the missing value chart and saw that there were no more missing values in the dataset.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p class="calibre2">Using the preceding plots and missing value charts, it was easy to figure out the count, percentage, and spread of missing values in the datasets. We noticed that many variables had missing values for the same observations. However, after consulting the data description, we saw that most of the missing values were actually not missing, but since they were codified as <kbd class="calibre12">NA</kbd>, pandas treated them as missing values.</p>
<p class="calibre2">It is very important for data analysts to understand data descriptions and treat the missing values appropriately. </p>
<p class="calibre2">Usually, missing data is categorized into three categories:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="calibre1">Missing completely at random</strong> (<strong class="calibre1">MCAR</strong>): MCAR denotes that the missing values have nothing to do with the object being studied. In other words, data is MCAR <span>when the probability of missing data on a variable is not </span><span>related to other measured variables or to the values themselves. An example of this could be, for instance, the age of certain respondents to a survey not being recorded, purely by chance.</span></li>
<li class="calibre11"><strong class="calibre1">Missing at random</strong> (<strong class="calibre1">MAR</strong>): The name MAR is a little misleading here because the absence of values is not random in this case. <span><span>Data is MAR if its absence is related to other observed variables, but not to the underlying values of the data itself. For example, when we collect data from customers, rich customers are less likely to disclose their income than their other counterparts, resulting in MAR data.</span></span></li>
<li class="calibre11"><strong class="calibre1">Missing not at random</strong> (<strong class="calibre1">MNAR</strong>): Data is MNAR, also known as <span><strong class="calibre1">non-ignorable</strong> </span>if it can't be classified as MCAR nor MAR.<span> </span><span>For example, perhaps some consumers don't want to share their age when it is above 40 because they would like to hide it.</span></li>
</ul>
<p class="calibre2">There are various strategies that can be applied to impute the missing values, as listed here:</p>
<ul class="calibre10">
<li class="calibre11">Source the missing data</li>
<li class="calibre11">Leave out incomplete observations</li>
<li class="calibre11">Replace missing data with an estimate, such as a mean or a median</li>
<li class="calibre11">Estimate the missing data from other variables in the dataset</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul class="calibre10">
<li class="calibre11">The scikit-learn module for imputation (<a href="https://bit.ly/2MzFwiG" class="calibre9">https://bit.ly/2MzFwiG</a>)</li>
<li class="calibre11">Multiple imputation by chained equations using the <kbd class="calibre12">StatsModels</kbd> library in Python (<a href="https://bit.ly/2PYLuYy" class="calibre9">https://bit.ly/2PYLuYy</a>)</li>
<li class="calibre11">Feature imputation algorithms using fancyimpute (<a href="https://bit.ly/2MJKfOY" class="calibre9">https://bit.ly/2MJKfOY</a>)</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Exploratory data analysis</h1>
                </header>
            
            <article>
                
<p class="calibre2"><span class="calibre5">We will continue from where we left off in the previous section, on analyzing and treating missing values. Data scientists spend the majority of their time doing data preparation and exploration, not model building and optimization. Now that our dataset has no missing values, we can proceed with our exploratory data analysis.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol class="calibre14">
<li class="calibre11">In the first section on data manipulation, we saw the summary statistics for our datasets. However, we have not looked at this since imputing the missing values.</li>
</ol>
<p class="calibre20">Let's now look at the data and its basic statistics using the following code:</p>
<pre class="calibre18"># To take a look at the top 5 rows in the dataset<br class="title-page-name"/>housepricesdata.head(5)<br class="title-page-name"/><br class="title-page-name"/># To display the summary statistics for all variables<br class="title-page-name"/>housepricesdata.describe()</pre>
<ol start="2" class="calibre14">
<li class="calibre11">With the preceding code, we can see the summary statistics of the variables in the earlier section.</li>
</ol>
<p class="calibre20">Now let's see how many columns there are by datatype:</p>
<pre class="calibre18"># How many columns with different datatypes are there?<br class="title-page-name"/>housepricesdata.get_dtype_counts()</pre>
<p class="calibre20">The following code shows us how many variables there <span class="calibre5">are</span><span class="calibre5"> </span><span class="calibre5">for each datatype. We can see that we have 3 float-type variables, 33 integer-type variables, 45 object-type variables, and 4 unsigned integers that hold the one-hot encoded values for the </span><kbd class="calibre12">LotShape</kbd> <span class="calibre5">variable:</span></p>
<p class="CDPAlignCenter"><img class="aligncenter13" src="assets/90ebfe78-e84f-406b-9455-c774e6817f53.png"/></p>
<ol start="3" class="calibre14">
<li class="calibre11">Let's create two variables to hold the names of the numerical and categorical variables:</li>
</ol>
<pre class="calibre18"># Pulling out names of numerical variables by conditioning dtypes NOT equal to object type<br class="title-page-name"/>numerical_features = housepricesdata.dtypes[housepricesdata.dtypes != "object"].index<br class="title-page-name"/>print("Number of Numerical features: ", len(numerical_features))<br class="title-page-name"/><br class="title-page-name"/># Pulling out names of categorical variables by conditioning dtypes equal to object type<br class="title-page-name"/>categorical_features = housepricesdata.dtypes[housepricesdata.dtypes == "object"].index<br class="title-page-name"/>print("Number of Categorical features: ", len(categorical_features))</pre>
<p class="calibre20">This shows us the amount of numerical and categorical variables there are:</p>
<p class="CDPAlignCenter"><img class="aligncenter14" src="assets/a2029e24-dcf1-403a-b0f3-11f5a2444dfe.png"/></p>
<ol start="4" class="calibre14">
<li class="calibre11">We will now use the <kbd class="calibre12">numerical_features</kbd> variable that we previously created to see the distributions of numerical variables. We will use the <kbd class="calibre12">seaborn</kbd> library to plot our charts:</li>
</ol>
<div class="packttip">We use the <kbd class="calibre19">melt()</kbd> method from pandas to reshape our DataFrame. You may want to view the reshaped data after using the <kbd class="calibre19">melt()</kbd> method to understand how the <span>DataFrame</span> is arranged.</div>
<pre class="calibre18">melt_num_features = pd.melt(housepricesdata, value_vars=numerical_features)<br class="title-page-name"/><br class="title-page-name"/>grid = sns.FacetGrid(melt_num_features, col="variable", col_wrap=5, sharex=False, sharey=False)<br class="title-page-name"/>grid = grid.map(sns.distplot, "value", color="blue") </pre>
<p class="calibre20">The preceding code shows us the univariate distribution of the observations of numerical variables using distribution plots:</p>
<p class="CDPAlignCenter"><img class="aligncenter15" src="assets/e7c5098f-9d3f-4ddd-b430-a60b5a8883c6.png"/></p>
<p class="calibre2"/>
<p class="calibre2"/>
<ol start="5" class="calibre14">
<li class="calibre11">Now, we use the <kbd class="calibre12">categorical_features</kbd> variable to plot the distribution of house prices by each categorical variable:</li>
</ol>
<pre class="calibre18">melt_cat_features = pd.melt(housepricesdata, id_vars=['SalePrice'], value_vars=categorical_features)<br class="title-page-name"/><br class="title-page-name"/>grid = sns.FacetGrid(melt_cat_features, col="variable", col_wrap=2, sharex=False, sharey=False, size=6)<br class="title-page-name"/>grid.map(sns.boxplot, "value", "SalePrice", palette="Set3")<br class="title-page-name"/>grid.fig.subplots_adjust(wspace=1, hspace=0.25)<br class="title-page-name"/><br class="title-page-name"/>for ax in grid.axes.flat: <br class="title-page-name"/>    plt.setp(ax.get_xticklabels(), rotation=90)</pre>
<div class="CDPAlignLeft2">In our dataset, we see that various attributes are present that can drive house prices. We can try to see the relationship between the attributes and the <kbd class="calibre19">SalesPrice</kbd> variable, which indicates the prices of the houses.</div>
<p class="CDPAlignLeft1">Let's see the distribution of the house sale prices by each categorical variable in the following plots:</p>
<p class="CDPAlignCenter"><img class="aligncenter16" src="assets/f69cc0a0-e586-4c9f-8e8a-74fd2816c47e.png"/></p>
<ol start="6" class="calibre14">
<li class="calibre11">We will now take a look at the correlation matrix for all numerical variables using the following code:</li>
</ol>
<pre class="calibre18"># Generate a correlation matrix for all the numerical variables<br class="title-page-name"/>corr=housepricesdata[numerical_features].corr()<br class="title-page-name"/>print(corr)</pre>
<p class="calibre20">This will give you the following output:</p>
<p class="CDPAlignCenter"><img class="aligncenter17" src="assets/1e63dc46-aceb-4074-b6c0-5c5ec3261313.png"/></p>
<p class="calibre20">It might be tough to view the correlations displayed in the preceding format. You might want to take a look at the correlations graphically.</p>
<ol start="7" class="calibre14">
<li class="calibre11">We can also view the correlation matrix plot for the numerical variables. In order to do this, we use the <kbd class="calibre12">numerical_features</kbd> variable that we created in <em class="calibre23">Step 3</em> to hold the names of all the numerical variables:</li>
</ol>
<pre class="calibre18"># Get correlation of <span>numerical </span>variables<br class="title-page-name"/>df_numerical_features= housepricesdata.select_dtypes(include=[np.number])<br class="title-page-name"/><br class="title-page-name"/>correlation= df_numerical_features.corr()<br class="title-page-name"/>correlation["SalePrice"].sort_values(ascending=False)*100<br class="title-page-name"/># Correlation Heat Map (Seaborn library)<br class="title-page-name"/>f, ax= plt.subplots(figsize=(14,14))<br class="title-page-name"/>plt.title("Correlation of Numerical Features with Sale Price", y=1, size=20)<br class="title-page-name"/><br class="title-page-name"/># cmap - matplotlib colormap name or object - can be used to set the color options<br class="title-page-name"/># vmin and vmax is used to anchor the colormap<br class="title-page-name"/>sns.heatmap(correlation, square= True, vmin=-0.2, vmax=0.8, cmap="YlGnBu")</pre>
<div class="packtinfobox">In the preceding code, we used <kbd class="calibre19">select_dtypes(include=[np.number])</kbd> to create the <kbd class="calibre19">df_numeric_features</kbd> variable. However, in <em class="calibre23">Step 3</em>, we used <kbd class="calibre19">dtypes[housepricesdata.dtypes != "object"].index</kbd>. Note that <kbd class="calibre19">select_dtypes()</kbd> returns a <kbd class="calibre19">pandas.DataFrame</kbd>, whereas <kbd class="calibre19">dtypes[].index</kbd> returns a <kbd class="calibre19">pandas.Index</kbd> object.</div>
<p class="calibre2"/>
<p class="calibre2"/>
<p class="calibre20">We can now visualize the correlation plot as follows:</p>
<p class="CDPAlignCenter"><img class="aligncenter18" src="assets/43b35176-1948-4674-89e9-07bfac1934cd.png"/></p>
<p class="calibre2"/>
<p class="calibre2"/>
<div class="packtinfobox"><kbd class="calibre19">cmap</kbd> is a Matplotlib color map object.There are various categories of color map, including sequential, diverging, and qualitative. Among the sequential colors, you may choose to set your <kbd class="calibre19">cmap</kbd> parameter to <kbd class="calibre19">BuPu</kbd> or <kbd class="calibre19">YlGn</kbd>. For qualitative colors, you can set it to values such as <kbd class="calibre19">Set3</kbd>, <kbd class="calibre19">Pastel2</kbd>, and so on. More information on color options can be found at <a href="https://matplotlib.org/tutorials/colors/colormaps.html" class="calibre21">https://matplotlib.org/tutorials/colors/colormaps.html</a>.</div>
<ol start="8" class="calibre14">
<li class="calibre11">You may also want to evaluate the correlation of your numerical variables with <kbd class="calibre12">SalePrice</kbd> to see how these numerical variables are related to the prices of the houses:</li>
</ol>
<pre class="calibre18">row_count = 11<br class="title-page-name"/>col_count = 3<br class="title-page-name"/><br class="title-page-name"/>fig, axs = plt.subplots(row_count, col_count, figsize=(12,36))<br class="title-page-name"/>exclude_columns = ['Id', 'SalePrice']<br class="title-page-name"/>plot_numeric_features = [col for col in numerical_features if col not in exclude_columns]<br class="title-page-name"/><br class="title-page-name"/>for eachrow in range(0, row_count):<br class="title-page-name"/>    for eachcol in range(0, col_count): <br class="title-page-name"/>        i = eachrow*col_count + eachcol<br class="title-page-name"/>        if i &lt; len(plot_numeric_features):<br class="title-page-name"/>            sns.regplot(housepricesdata[plot_numeric_features[i]], housepricesdata['SalePrice'], \<br class="title-page-name"/>                ax = axs[eachrow][eachcol], color='purple', fit_reg=False)<br class="title-page-name"/><br class="title-page-name"/># tight_layout automatically adjusts subplot params so that the subplot(s) fits in to the figure area <br class="title-page-name"/>plt.tight_layout() <br class="title-page-name"/>plt.show()</pre>
<p class="CDPAlignLeft1">The following screenshot shows us the correlation plots. Here, we plot the correlation between each of the <span class="calibre5">numerical </span>variables and <kbd class="calibre12">SalePrice</kbd>:</p>
<p class="CDPAlignCenter1"><br class="calibre6"/>
<img class="aligncenter19" src="assets/6a52456a-94c6-48ac-a721-8808c27fbaff.png"/></p>
<ol start="9" class="calibre14">
<li class="calibre11">If you want to <span>evaluate the correlation of your numerical variables with the sale prices of the houses numerically, you can use the following commands:</span></li>
</ol>
<pre class="calibre18"># See correlation between <span>numerical </span>variables with house prices<br class="title-page-name"/>corr=housepricesdata.corr()["SalePrice"]<br class="title-page-name"/><br class="title-page-name"/># Sort the correlation values. <br class="title-page-name"/># Use [::-1] to sort it in descending manner<br class="title-page-name"/># Use [::+1] to sort it in ascending manner<br class="title-page-name"/>corr[np.argsort(corr)[::-1]]</pre>
<p class="calibre20">You can view the correlation output sorted in a descending manner in the following table:</p>
<p class="CDPAlignCenter"><img class="aligncenter20" src="assets/ed9ccd39-d221-4fd8-b335-5dd28ab8cee9.png"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p class="calibre2">In <em class="calibre13">Step 1</em>, we started by reading and describing our data. This step provided us with summary statistics for our dataset. We looked at the number of variables for each datatype in <em class="calibre13">Step 2</em>.</p>
<p class="calibre2">In <em class="calibre13">Step 3</em>, we created two variables, namely, <kbd class="calibre12">numerical_features</kbd> and <kbd class="calibre12">categorical_features</kbd>, to hold the names of <span class="calibre5">numerical </span>and categorical variables respectively. We used these two variables in the steps when we worked with <span class="calibre5">numerical </span>and categorical features separately. </p>
<p class="calibre2"/>
<p class="calibre2"/>
<p class="calibre2">In <em class="calibre13">Step </em>4 and <em class="calibre13">Step </em>5, we used the <kbd class="calibre12">seaborn</kbd> library to plot our charts. We also introduced the <kbd class="calibre12">melt()</kbd> function from pandas, which can be used to reshape our DataFrame and feed it to the <kbd class="calibre12">FacetGrid()</kbd> function of the <kbd class="calibre12">seaborn</kbd> library. Here, we showed how you can paint the distribution plots for all the <span class="calibre5">numerical </span>variables in one single go. We also showed you how to use the same <kbd class="calibre12">FacetGrid()</kbd> function to plot <span class="calibre5">the distribution of </span><kbd class="calibre12">SalesPrice</kbd> <span class="calibre5">by each categorical variable.</span></p>
<p class="calibre2">We generated the correlation matrix in <em class="calibre13">Step 6</em> using the <kbd class="calibre12">corr()</kbd> function of the <span class="calibre5">DataFrame</span> object. However, we noticed that with too many variables, the display does not make it easy for you to identify the correlations. In <em class="calibre13">Step 7</em>, we plotted the correlation matrix heatmap by using the <kbd class="calibre12">heatmap()</kbd> function from the <kbd class="calibre12">seaborn</kbd> library.</p>
<div class="packtinfobox">The <kbd class="calibre19">corr()</kbd> function c<span>omputes the pairwise correlation of variables, excluding the missing values. The <kbd class="calibre19">pearson</kbd> method is used as the default for computing the correlation. You can also use the <kbd class="calibre19">kendall</kbd> or <kbd class="calibre19">spearman</kbd> methods, depending on your requirements. More information can be found at <a href="https://bit.ly/2CdXr8n" class="calibre21">https://bit.ly/2CdXr8n</a>.</span></div>
<p class="calibre2">In <em class="calibre13">Step 8</em>, we saw how the <span class="calibre5">numerical </span>variables correlated with the sale prices of houses using a scatter plot matrix. We generated the scatter plot matrix using the <kbd class="calibre12">regplot()</kbd> function from the <kbd class="calibre12">seaborn</kbd> library. Note that we used a parameter, <kbd class="calibre12">fit_reg=False</kbd>, to remove the regression line from the scatter plots.</p>
<p class="calibre2">In <em class="calibre13">Step 9</em>, we repeated <em class="calibre13">Step 8</em> to see the relationship of the <span class="calibre5">numerical </span>variables with the sale prices of the houses in a <span class="calibre5">numerical </span>format, instead of scatter plots. We also sorted the output in descending order by passing a <kbd class="calibre12">[::-1]</kbd> argument to the <kbd class="calibre12">corr()</kbd> function.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p class="calibre2">We have seen a few ways to explore data, both statistically and visually. There are quite a few libraries in Python that you can use to visualize your data. One of the most widely used of these is <kbd class="calibre12">ggplot</kbd>. Before we look at a few commands, let's learn how <kbd class="calibre12">ggplot</kbd> works.</p>
<p class="calibre2">There are seven layers of grammatical elements in <kbd class="calibre12">ggplot</kbd>, out of which, first three layers are mandatory:</p>
<ul class="calibre10">
<li class="calibre11">Data</li>
<li class="calibre11">Aesthetics</li>
<li class="calibre11">Geometrics</li>
<li class="calibre11">Facets</li>
<li class="calibre11">Statistics</li>
<li class="calibre11">Coordinates</li>
<li class="calibre11">Theme</li>
</ul>
<p class="calibre2">You will often start by providing a dataset to <kbd class="calibre12">ggplot()</kbd>. Then, you provide an aesthetic mapping with the <kbd class="calibre12">aes()</kbd> function to map the variables to the <em class="calibre13">x </em>and <em class="calibre13">y</em> axes. With <kbd class="calibre12">aes()</kbd>, you can also set the color, size, shape, and position of the charts. You then add the type of geometric shape you want with functions such as <kbd class="calibre12">geom_point()</kbd> or <kbd class="calibre12">geom_histogram()</kbd>. You can also add various options, such as plotting statistical summaries, faceting, visual themes, and coordinate systems.</p>
<p class="calibre2">The following code is an extension to what we have used already in this chapter, so we will directly delve into the <kbd class="calibre12">ggplot</kbd> code here:</p>
<pre class="calibre15">f = pd.melt(housepricesdata, id_vars=['SalePrice'],value_vars= numerical_features[0:9])<br class="title-page-name"/>ggplot(f,aes('value', 'SalePrice')) + geom_point(color='orange') + facet_wrap('variable',scales='free')</pre>
<p class="calibre2"><span class="calibre5">The preceding code generates the following chart:</span></p>
<p class="CDPAlignCenter"><img class="aligncenter21" src="assets/33685075-4116-479c-9e26-f86291e74187.png"/></p>
<p class="calibre2">Similarly, in order to view the density plot for the <span class="calibre5">numerical </span>variables, we can execute the following code<span class="calibre5">:</span></p>
<pre class="calibre15">f_1 = pd.melt(housepricesdata, value_vars=numerical_features[0:9])<br class="title-page-name"/>ggplot(f_1, aes('value')) + geom_density(color="red") + facet_wrap('variable',scales='free') </pre>
<p class="calibre2">The plot shows us the univariate density plot for each of our numerical variables. The <kbd class="calibre12">geom_density()</kbd> <span class="calibre5">computes and draws a kernel density estimate, which is a smoothed version of the histogram:</span></p>
<p class="CDPAlignCenter"><img class="aligncenter22" src="assets/77c12994-1627-466f-a8f9-e17432430292.png"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<div class="calibre24">
<p class="calibre2">The guide to the <kbd class="calibre12">seaborn</kbd> library (<a href="https://bit.ly/2iU2aRU" class="calibre9">https://bit.ly/2iU2aRU</a>) </p>
</div>


            </article>

            
        </section>
    </body></html>