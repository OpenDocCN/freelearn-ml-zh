- en: '*Chapter 5*: Building an AutoML Classification Solution'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 5 章*：构建 AutoML 分类解决方案'
- en: After building your AutoML regression solution with Python in [*Chapter 4*](B16595_04_ePub.xhtml#_idTextAnchor056)*,
    Building an AutoML Regression Solution*, you should be feeling confident in your
    coding abilities. In this chapter, you will build a classification solution. Unlike
    regression, **classification** is used to predict the category of the object of
    interest. For example, if you're trying to predict who is likely to become a homeowner
    in the next five years, classification is the right machine learning approach.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 Python 在 [*第 4 章*](B16595_04_ePub.xhtml#_idTextAnchor056)*，构建 AutoML 回归解决方案*
    中构建您的 AutoML 回归解决方案之后，您应该对自己的编码能力感到自信。在本章中，您将构建一个分类解决方案。与回归不同，**分类**用于预测感兴趣对象的类别。例如，如果您试图预测在接下来的五年内谁有可能成为房主，那么分类是正确的机器学习方法。
- en: '**Binary classification** is when you are trying to predict two classes, such
    as homeowner or not, while **multiclass classification** involves trying to predict
    three or more classes, such as homeowner, renter, or lives with family. You can
    utilize both of these techniques with Azure AutoML, and this chapter will teach
    you how to train both kinds of models using different datasets.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**二元分类**是指您试图预测两个类别，例如房主或非房主，而**多类分类**涉及尝试预测三个或更多类别，例如房主、租房者或与家人同住。您可以使用 Azure
    AutoML 利用这两种技术，本章将教会您如何使用不同的数据集训练这两种类型的模型。'
- en: In this chapter, you will begin by navigating directly to the Jupyter environment
    as you did in [*Chapter 4*](B16595_04_ePub.xhtml#_idTextAnchor056)*, Building
    an AutoML Regression Solution*. Then, you will load in the same Titanic data that
    you used to build a model in [*Chapter 3*](B16595_03_ePub.xhtml#_idTextAnchor044)*,
    Training Your First AutoML Model*. Retraining an identical model would be boring,
    so you will enrich the dataset by adding a few derived columns.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将首先直接导航到 Jupyter 环境，就像您在 [*第 4 章*](B16595_04_ePub.xhtml#_idTextAnchor056)*，构建
    AutoML 回归解决方案* 中做的那样。然后，您将加载与您在 [*第 3 章*](B16595_03_ePub.xhtml#_idTextAnchor044)*，训练您的第一个
    AutoML 模型* 中构建模型相同的泰坦尼克号数据。重新训练相同的模型会令人感到无聊，因此您将通过添加一些派生列来丰富数据集。
- en: Once you accomplish that, you will train, examine, and register your binary
    classification model. Then, you will train a multiclass classification model using
    the popular, publicly available Iris dataset that will predict what type of flower
    an individual plant is based on its dimensions. You will end this chapter by learning
    a few tips and tricks on how to fine-tune classification models. Pay close attention,
    as even seasoned data scientists fail to modify their classification models to
    align with the business problem at hand.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您做到了这一点，您将训练、检查并注册您的二元分类模型。然后，您将使用流行的、公开可用的 Iris 数据集训练一个多类分类模型，该模型将根据其尺寸预测单个植物的花的类型。您将在本章结束时学习一些关于如何微调分类模型的小技巧和窍门。请注意，即使是经验丰富的数据科学家也常常未能修改他们的分类模型以符合手头的业务问题。
- en: By the end of this chapter, you will be able to build all types of classification
    models on your own with ease, regardless of your previous machine learning experience.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将能够轻松地独立构建所有类型的分类模型，无论您之前的机器学习经验如何。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Prepping data for AutoML classification
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备 AutoML 分类数据
- en: Training an AutoML classification model
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 训练 AutoML 分类模型
- en: Registering your trained classification model
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注册您的训练好的分类模型
- en: Training an AutoML multiclass model
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 训练 AutoML 多类模型
- en: Fine-tuning your AutoML classification model
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微调您的 AutoML 分类模型
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you will be building models with Python code in Jupyter notebooks
    through **Azure Machine Learning** (**AML**) **studio**. Furthermore, you will
    be using datasets and Azure resources that you should have created in previous
    chapters. As such, the full list of requirements is as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，您将通过 Jupyter 笔记本中的 Python 代码在 **Azure 机器学习** (**AML**) **工作室** 中构建模型。此外，您将使用您在之前章节中应该已经创建的数据集和
    Azure 资源。因此，完整的要求列表如下：
- en: Access to the internet
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上网访问
- en: A web browser, preferably Google Chrome or Microsoft Edge Chromium
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个网络浏览器，最好是 Google Chrome 或 Microsoft Edge Chromium
- en: A Microsoft Azure account
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 Microsoft Azure 账户
- en: An **Azure Machine Learning** workspace
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 **Azure 机器学习** 工作区
- en: The `titanic-compute-instance` compute instance created in [*Chapter 2*](B16595_02_ePub.xhtml#_idTextAnchor023)*,
    Getting Started with Azure Machine Learning*
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[*第二章*](B16595_02_ePub.xhtml#_idTextAnchor023)*，Azure机器学习入门*中创建的`titanic-compute-instance`计算实例
- en: The `compute-cluster` compute cluster created in [*Chapter 2*](B16595_02_ePub.xhtml#_idTextAnchor023)*,
    Getting Started with Azure Machine Learning*
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[*第二章*](B16595_02_ePub.xhtml#_idTextAnchor023)*，Azure机器学习入门*中创建的`compute-cluster`计算集群
- en: The `Titanic Training Data` dataset from [*Chapter 3*](B16595_03_ePub.xhtml#_idTextAnchor044)*,
    Training your First AutoML Model*
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自[*第三章*](B16595_03_ePub.xhtml#_idTextAnchor044)*，训练你的第一个AutoML模型*的`Titanic
    Training Data`数据集
- en: An understanding of how to navigate to the Jupyter environment from an Azure
    compute instance as demonstrated in [*Chapter 4*](B16595_04_ePub.xhtml#_idTextAnchor056)*,
    Building an AutoML Regression Solution*
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解如何从Azure计算实例导航到Jupyter环境，如[*第四章*](B16595_04_ePub.xhtml#_idTextAnchor056)*，构建AutoML回归解决方案*中所示
- en: Prepping data for AutoML classification
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备AutoML分类数据
- en: Classification, or predicting the category of something based on its attributes,
    is one of the key techniques of machine learning. Just like regression, you first
    need to prep your data before training it with AutoML. In this section, you will
    first navigate to your Jupyter notebook, load in your data, and transform it for
    use with AutoML.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 分类，或根据其属性预测某物的类别，是机器学习的关键技术之一。就像回归一样，在用AutoML训练之前，你首先需要准备你的数据。在本节中，你将首先导航到你的Jupyter笔记本，加载你的数据，并将其转换为AutoML使用。
- en: Just as you loaded in your `Diabetes Sample` dataset via Jupyter notebooks for
    regression, you will do the same with the `Titanic Training Data` dataset. However,
    this time around you will do much more extensive data transformation before training
    your AutoML model. This is to build upon your learning; classification datasets
    do not necessarily require more transformation than their regression counterparts.
    Identical to the previous chapter, you will begin by opening up a Jupyter notebook
    from your compute instance.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你通过Jupyter笔记本加载`Diabetes Sample`数据集进行回归一样，你将同样地加载`Titanic Training Data`数据集。然而，这一次，在训练你的AutoML模型之前，你将进行更广泛的数据转换。这是为了巩固你的学习；分类数据集不一定需要比它们的回归对应物更多的转换。与上一章相同，你将首先从你的计算实例打开一个Jupyter笔记本。
- en: Navigating to your Jupyter environment
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导航到你的Jupyter环境
- en: 'Similar to [*Chapter 4*](B16595_04_ePub.xhtml#_idTextAnchor056)*, Building
    an AutoML Regression Solution*, you will begin by creating a new Jupyter notebook
    for creating your classification model as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 与[*第四章*](B16595_04_ePub.xhtml#_idTextAnchor056)*，构建AutoML回归解决方案*类似，你将首先创建一个新的Jupyter笔记本来创建你的分类模型，如下所示：
- en: First, open AML studio by navigating to [http://ml.azure.com](http://ml.azure.com).
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，通过导航到[http://ml.azure.com](http://ml.azure.com)打开AML工作室。
- en: Once you are in the studio, click **Compute** on the right-hand side of the
    studio under **Manage**.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你进入工作室，在**管理**下点击右侧的**计算**。
- en: If your compute instance is currently paused, check the circular checkbox next
    to `titanic-compute-instance` and click the **Start** button.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你的计算实例当前处于暂停状态，请检查`titanic-compute-instance`旁边的圆形复选框，并点击**启动**按钮。
- en: Then, click `Diabetes_Regression_AutoML` notebook that you previously created.
    Each time you create a Jupyter notebook, it will persist on your AMLS workspace
    even if you or other users access Jupyter from a different compute instance. Feel
    free to create as many notebooks as you want in this space, naming them carefully
    so you can easily track different projects.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，点击之前创建的`Diabetes_Regression_AutoML`笔记本。每次你创建一个Jupyter笔记本，它都会在你的AMLS工作区中持久保存，即使你或其他用户从不同的计算实例访问Jupyter也是如此。在这个空间里，你可以随意创建尽可能多的笔记本，并仔细命名它们，这样你就可以轻松跟踪不同的项目。
- en: Click **New** in the upper right-hand corner of your screen to access the drop-down
    menu.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在屏幕右上角点击**新建**以访问下拉菜单。
- en: Select **Python 3.6 – AzureML** from the drop-down menu.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从下拉菜单中选择**Python 3.6 – AzureML**。
- en: Click the new Jupyter notebook that appeared in the top-left corner of your
    screen, `Untitled.ipynb`.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击屏幕左上角出现的新的Jupyter笔记本，`Untitled.ipynb`。
- en: 'Rename `Untitled.ipynb` to `Titanic Classification_AutoML` by clicking `Titanic_Classification_AutoML`
    in the resulting textbox, and clicking **Rename** as shown in the following screenshot:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击结果文本框中的`Titanic_Classification_AutoML`并将`Untitled.ipynb`重命名为`Titanic Classification_AutoML`，然后点击**重命名**，如以下截图所示：
- en: '![Figure 5.2 – Renaming your Jupyter notebook ](img/B16595_5_02.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图5.2 – 重命名你的Jupyter笔记本](img/B16595_5_02.jpg)'
- en: Figure 5.2 – Renaming your Jupyter notebook
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2 – 重命名你的Jupyter笔记本
- en: With your notebook created, you are now ready to load in your Titanic data.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你的笔记本创建完成后，你现在可以加载你的Titanic数据。
- en: Loading and transforming your data
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载数据并进行转换
- en: All AutoML solutions use roughly the same boilerplate code. If you completed
    [*Chapter 4*](B16595_04_ePub.xhtml#_idTextAnchor056)*, Building an AutoML Regression
    Solution*, begin copying over your code cell by cell. After doing so, simply follow
    the instructions step by step and alter your code when necessary. If you skipped
    directly to this chapter, you will have to code everything from scratch.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 所有AutoML解决方案都使用大致相同的模板代码。如果你完成了[*第4章*](B16595_04_ePub.xhtml#_idTextAnchor056)*，构建AutoML回归解决方案*，请逐行复制你的代码单元格。完成之后，只需按步骤操作，并在必要时修改你的代码。如果你直接跳到这一章，你将不得不从头开始编写代码。
- en: 'Just as before, you will load in your Python libraries and set your workspace,
    datastore, compute cluster, and dataset. You will then transform and register
    your enriched data as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 就像之前一样，你将加载Python库并设置你的工作区、数据存储、计算集群和数据集。然后按照以下方式转换和注册你的增强数据：
- en: 'Load in all of the libraries you will need to run all of your code. Refer to
    [*Chapter 4*](B16595_04_ePub.xhtml#_idTextAnchor056)*, Building an AutoML Regression
    Solution*, for a detailed explanation of all of these packages:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载运行所有代码所需的全部库。请参阅[*第4章*](B16595_04_ePub.xhtml#_idTextAnchor056)*，构建AutoML回归解决方案*，以了解所有这些包的详细解释：
- en: '[PRE0]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Load in `pandas` and `numpy`. These are popular Python packages that help you
    transform data. `pandas`, in particular, is necessary to view the data in your
    dataset:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`pandas`和`numpy`加载数据。这些是流行的Python包，可以帮助你转换数据。特别是`pandas`对于查看数据集中的数据是必要的：
- en: '[PRE1]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Connect your Jupyter notebook to your AMLS workspace:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的Jupyter笔记本连接到你的AutoML工作区：
- en: '[PRE2]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Set your compute cluster:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置你的计算集群：
- en: '[PRE3]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Set your `datastore`. For this exercise, we will use the default datastore
    that comes with your AMLS workspace. If you want to use a different datastore,
    you can replace the name:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置你的`datastore`。对于这个练习，我们将使用随AutoML工作区提供的默认数据存储。如果你想使用不同的数据存储，你可以替换名称：
- en: '[PRE4]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Set your `dataset`:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置你的`dataset`：
- en: '[PRE5]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: '*Step 6* is the first place where you should have altered your code. Each time
    you create a new classification or regression AutoML solution in Azure, use this
    template.'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*第6步*是第一次你应该修改代码的地方。每次你在Azure中创建一个新的分类或回归AutoML解决方案时，都应使用此模板。'
- en: 'The following is the code to view the first 10 rows of data. Make sure that
    it looks correct:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码用于查看数据的前10行。请确保它看起来是正确的：
- en: '[PRE6]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The first 10 rows should appear as follows:'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前十行应该如下所示：
- en: '![Figure 5.3 – Viewing your Titanic dataset ](img/B16595_5_03.jpg)'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图5.3 – 查看你的Titanic数据集](img/B16595_5_03.jpg)'
- en: Figure 5.3 – Viewing your Titanic dataset
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图5.3 – 查看你的Titanic数据集
- en: Convert your dataset into a `Age` column. It's very likely that the age of the
    passengers will vary by other columns such as `Sex`. Instead of replacing these
    nulls with the mean value of the entire `Age` column, let's instead replace them
    with mean age by gender.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的数据集转换为`Age`列。乘客的年龄很可能与其他列（如`Sex`）有关。我们不是用整个`Age`列的平均值替换这些空值，而是用按性别划分的平均年龄来替换。
- en: 'Calculate the mean age of women and men in your `Titanic` dataset:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算你的`Titanic`数据集中男性和女性的平均年龄：
- en: '[PRE7]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This code will show you that the mean age of women is 28 years old and the mean
    age of men is 31 years old. You will use these numbers in the next cell.
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这段代码将显示女性的平均年龄为28岁，男性的平均年龄为31岁。你将在下一个单元格中使用这些数字。
- en: 'Replace null values in the `Age` column with the appropriate number for each
    gender using this conditional Python code:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下条件Python代码用每个性别适当的数字替换`Age`列中的空值：
- en: '[PRE8]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Another common transformation is to bin numerical data. **Binning** numerical
    data means creating multiple categorical columns from a single numeric column,
    for example, splitting an age column into age ranges instead. You should bin numerical
    data when you suspect that the range of numbers matters more than the absolute
    number.
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 另一个常见的转换是将数值数据分箱。**分箱**数值数据意味着从一个数值列创建多个分类列，例如，将年龄列分割成年龄范围。当你怀疑数字的范围比绝对数值更重要时，你应该对数值数据进行分箱。
- en: For example, if you suspect whether a person is young or old matters to whether
    they survived the Titanic, but not their exact age, you should bin data into groups.
    AutoML will not automatically bin data for you, but some algorithms, such as decision
    trees, do not require binning to achieve a similar effect.
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，如果你怀疑一个人的年龄（年轻或年老）是否对他们在泰坦尼克号上是否幸存有影响，但不是他们的确切年龄，你应该将数据分箱到不同的组中。AutoML不会自动为你分箱数据，但某些算法，如决策树，不需要分箱就能达到类似的效果。
- en: 'Bin the `Age` column into four different age groups: Under 15, 15-35, 35-60,
    and over 60:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Age`列分箱到四个不同的年龄组：15岁以下，15-35岁，35-60岁，以及60岁以上：
- en: '[PRE9]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You can try different combinations of ages if you like.
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你喜欢，可以尝试不同的年龄组合。
- en: 'Now that you have binned the `Age` column, drop it. This will be your final
    DataFrame:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你已经将`Age`列分箱了，可以将其删除。这将是你最终的DataFrame：
- en: '[PRE10]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Reregister your altered data and give the dataset a new name, `Titanic Transformed`.
    This will save your transformed pandas DataFrame to your datastore, creating a
    new file on disk:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新注册你的修改后的数据，并给数据集一个新的名字，`Titanic Transformed`。这将把你的转换后的pandas DataFrame保存到你的数据存储中，在磁盘上创建一个新文件：
- en: '[PRE11]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You may get a warning that `register_pandas_dataframe` is an experimental method
    as it is a new feature of the AML SDK. You are safe to ignore this warning.
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可能会收到一个警告，即`register_pandas_dataframe`是一个实验性方法，因为它是AML SDK的新特性。你可以安全地忽略这个警告。
- en: If you're new to Python, some of this code will perplex you, and that's okay.
    You will find great value in learning the `pandas` and `numpy` libraries, as they
    are two of the most popular packages for transforming data. Each time you learn
    a new `pandas` or `numpy` function, save an example to your personal code base
    for later use. Even if you never become a Python expert, however, you will still
    be able to use Azure AutoML to deliver a great model. Yet, Python experts will
    still be able to deliver the best models through careful, nuanced, and savvy data
    transformations.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你刚开始接触Python，一些代码可能会让你感到困惑，这是正常的。你会发现学习`pandas`和`numpy`库非常有价值，因为它们是两个最受欢迎的数据转换包。每次你学习一个新的`pandas`或`numpy`函数时，将示例保存到你的个人代码库中以便以后使用。即使你永远不会成为Python专家，你仍然可以使用Azure
    AutoML交付一个优秀的模型。然而，Python专家仍然可以通过仔细、细致和精明的数据转换来交付最佳模型。
- en: You are now ready to train another model with your Titanic dataset. Between
    intelligently filling in null values and binning the `Age` column, you may expect
    to produce a superior model to that which you built in [*Chapter 3*](B16595_03_ePub.xhtml#_idTextAnchor044)*,
    Training Your First AutoML Model*. Let's see if that's the case.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以使用Titanic数据集训练另一个模型了。在智能填充空值和分箱`Age`列之间，你可能期望产生一个比你在[*第3章*](B16595_03_ePub.xhtml#_idTextAnchor044)*，训练你的第一个AutoML模型*中构建的模型更优越。让我们看看这是否成立。
- en: Training an AutoML classification model
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 训练一个AutoML分类模型
- en: Training an AutoML classification model is very similar to training an AutoML
    regression model, but there are a few key differences. In [*Chapter 4*](B16595_04_ePub.xhtml#_idTextAnchor056)*,
    Building an AutoML Regression Solution*, you began by setting a name for your
    experiment. After that, you set your target column and subsequently set your AutoML
    configurations. Finally, you used AutoML to train a model, performed a data guardrails
    check, and produced results.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 训练一个AutoML分类模型与训练一个AutoML回归模型非常相似，但有一些关键的区别。在[*第4章*](B16595_04_ePub.xhtml#_idTextAnchor056)*，构建AutoML回归解决方案*中，你首先为你的实验设置了一个名字。之后，你设置了目标列，随后设置了AutoML配置。最后，你使用AutoML训练了一个模型，执行了数据守卫检查，并产生了结果。
- en: 'All of the steps in this section are nearly the same. However, pay close attention
    to the data guardrails check and results, as they are substantially different
    when training classification models:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的所有步骤几乎都是相同的。然而，请特别注意数据守卫检查和结果，因为在训练分类模型时它们有显著的不同：
- en: 'Set your `experiment` and give it a name:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置你的`experiment`并给它起一个名字：
- en: '[PRE12]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Set your `dataset` to your transformed `Titanic` data:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的`dataset`设置为你的转换后的`Titanic`数据：
- en: '[PRE13]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Set your target column, `Survived`. Capitalization matters:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置你的目标列，`Survived`。大小写很重要：
- en: '[PRE14]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Create a variable for your `task`: now, `task` is the type of AutoML model
    you are trying to train. For predicting categories, enter `classification`:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为你的`task`创建一个变量：现在，`task`是你试图训练的AutoML模型类型。对于预测类别，输入`classification`：
- en: '[PRE15]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Important note
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 重要提示
- en: You can always turn a regression problem into a classification, and this is
    often an easier machine learning problem to solve. For example, for the diabetes
    problem, you can create a new column based on the `Y` column. Set a numeric threshold
    and assign a `1` to any patient who exceeds the threshold and a `0` to any patient
    below it. Then, try training a classification model with AutoML.
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你总是可以将回归问题转换为分类问题，这通常是一个更容易解决的机器学习问题。例如，对于糖尿病问题，你可以基于`Y`列创建一个新列。设置一个数值阈值，并将超过阈值的任何患者分配为`1`，低于阈值的任何患者分配为`0`。然后，尝试使用AutoML训练一个分类模型。
- en: 'Create a variable for your primary metric: **Primary metric** is how your model
    will be scored. Use **accuracy**. This metric divides the number of cases that
    your model accurately predicted the class (survived or not) of by the total number
    of cases. The higher the score, the better your model. Other options for classification
    include **AUC weighted**, **average precision score weighted**, **norm macro recall**,
    and **precision score weighted**:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为你的主要指标创建一个变量：**主要指标**是评估你的模型的方式。使用**准确率**。此指标将你的模型准确预测类（生还或未生还）的案例数量除以总案例数量。分数越高，你的模型越好。分类的其他选项包括**加权AUC**、**加权平均精确率分数**、**归一化宏召回率**和**加权精确率分数**：
- en: '[PRE16]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Create a variable for `featurization` and set it to `auto`:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`特征化`创建一个变量并将其设置为`auto`：
- en: '[PRE17]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You can set `featurization` to `auto` or `off`. If you set `featurization` to
    `off`, you will have to drop high-cardinality features, impute null values, one-hot
    encode your data, and generate additional features yourself.
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以将`特征化`设置为`auto`或`off`。如果你将`特征化`设置为`off`，你将不得不删除高基数特征，填充空值，对数据进行独热编码，并自己生成额外的特征。
- en: 'With classification, you will also have to balance your classes, meaning that
    you should resample your data to have a close-to-equal number of passengers who
    survived and died on the Titanic. Always set it to `auto` unless you are an expert
    data scientist and are comfortable doing everything yourself:'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用分类时，你还需要平衡你的类别，这意味着你应该重新采样你的数据，以便在泰坦尼克号上生还和死亡乘客的数量接近相等。除非你是经验丰富的数据科学家并且能够自己舒适地完成所有工作，否则始终将其设置为`auto`：
- en: 'Set the number of classes:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置类别数量：
- en: '[PRE18]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is the primary difference when training a classification model. By doing
    this programmatically with the following code, you will never make a mistake as
    you might when manually inputting the number.
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是在训练分类模型时的主要区别。通过以下代码以编程方式执行此操作，你将永远不会像手动输入数字时那样犯错误。
- en: Important note
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 重要提示
- en: AutoML can handle a large number of classes, but you may run into trouble if
    you have overly imbalanced classes. When you have 20 times the number of your
    largest case as your smallest case, you may want to resample your data or bin
    your target column to reduce the discrepancy.
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: AutoML可以处理大量类别，但如果你有过度不平衡的类别，可能会遇到麻烦。当你最大的案例数量是最小案例数量的20倍时，你可能想要重新采样你的数据或对目标列进行分箱以减少差异。
- en: 'Configure your AutoML run: here, you will pass in your task, primary metric,
    featurization settings, compute target, dataset, target column, and the number
    of classes. All of these you have previously created. You will also pass in how
    long the experiment will run, whether it will stop early if the model performance
    does not improve, the number of cross-validations, and whether your experiment
    will record model explanations.'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置你的AutoML运行：在这里，你将传递你的任务、主要指标、特征化设置、计算目标、数据集、目标列和类别数量。所有这些你之前都创建过。你还将传递实验将运行多长时间，如果模型性能没有提高，它是否会提前停止，交叉验证的数量，以及你的实验是否会记录模型解释。
- en: 'Additionally, you will pass in whether or not you want to use `5` and `20`
    splits:'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此外，你将传递是否想要使用`5`和`20`分割：
- en: '[PRE19]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Train your model and watch the results in real time:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 训练你的模型并实时查看结果：
- en: '[PRE20]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Most of this code should feel familiar. Kick off your AutoML run, make yourself
    some coffee, come back, and watch your model run. You will then see a data guardrails
    check as seen in *Figure 5.4*. Notice how it has changed for classification.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数代码应该感觉熟悉。启动你的AutoML运行，为自己泡杯咖啡，回来，观看你的模型运行。然后你会看到如图5.4所示的数据守卫检查。注意它如何为分类而改变。
- en: 'First, it will check your target column to make sure that classes are balanced.
    Then, it will impute missing values. Here, there are two missing values in the
    `Embarked` column. Since it''s a categorical column, it will be filled with the
    most common value. Lastly, like regression, it looks for categorical columns that
    have **high cardinality** or too many unique values given the dataset:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它将检查你的目标列以确保类别平衡。然后，它将填充缺失值。在这里，`Embarked`列中有两个缺失值。由于它是一个分类列，它将被填充为最常见的值。最后，就像回归一样，它寻找具有**高基数**或给定数据集中有太多唯一值的分类列：
- en: '![Figure 5.4 – Data guardrails check for classification](img/B16595_5_04.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.4 – 用于分类的数据边界检查](img/B16595_5_04.jpg)'
- en: Figure 5.4 – Data guardrails check for classification
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4 – 数据边界检查用于分类
- en: 'Just as before, after completing the data guardrails check, AutoML will start
    training models with different combinations of feature transformations, algorithms,
    and hyperparameters. Some of the algorithms used will be unique to classification
    such as naïve Bayes, linear SVC, and **logistic regression**, while others such
    as **random forest**, **light GBM**, and **XGBoost** are shared with regression.
    Your output should resemble something similar to *Figure 5.5*:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 就像之前一样，完成数据边界检查后，AutoML 将开始使用不同组合的特征转换、算法和超参数来训练模型。其中一些算法是用于分类的独特算法，例如朴素贝叶斯、线性
    SVC 和**逻辑回归**，而其他如**随机森林**、**LightGBM**和**XGBoost**则与回归共享。你的输出应该类似于*图 5.5*：
- en: '![Figure 5.5 – AutoML results for classification](img/B16595_5_05.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.5 – 用于分类的 AutoML 结果](img/B16595_5_05.jpg)'
- en: Figure 5.5 – AutoML results for classification
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.5 – 用于分类的 AutoML 结果
- en: 'There are two striking things about these results: the first model trained
    is the best model and the algorithm you trained in [*Chapter 3*](B16595_03_ePub.xhtml#_idTextAnchor044)*,
    Training Your First AutoML Model*, is slightly better. When models are relatively
    simple for machine learning to find patterns, your first model may be your best
    model. Our attempts to outsmart AutoML by filling in nulls ourselves and binning
    the `Age` column failed.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这些结果有两个引人注目之处：第一个训练的模型是最好的模型，而你训练的算法在[*第 3 章*](B16595_03_ePub.xhtml#_idTextAnchor044)*，训练你的第一个
    AutoML 模型*中略有改进。当模型对于机器学习找到模式相对简单时，你的第一个模型可能是最好的模型。我们尝试通过自己填充空值并对`Age`列进行分箱来超越
    AutoML 的尝试失败了。
- en: 'Despite our failure to produce a model, it''s a good exercise to show the inherent
    power of AutoML. Often, leaving the data as is will produce an excellent model.
    Other times, creating new features from your existing features will produce superior
    models. Try experimenting to see if you can get higher-performing results with
    the `Titanic` dataset. See *Figure 5.6* for the visualized results, and notice
    that you can select other metrics from the dropdown in the top-left corner:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们没有成功生成模型，但展示 AutoML 的内在力量是一个很好的练习。通常，保持数据不变会产生一个优秀的模型。有时，从现有特征中创建新特征会产生更优秀的模型。尝试实验，看看你是否可以用`Titanic`数据集获得更高的性能结果。参见*图
    5.6*以查看可视化结果，并注意你可以在左上角的下拉菜单中选择其他指标：
- en: '![Figure 5.6 – AutoML results visualized for classification ](img/B16595_5_06.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.6 – 用于分类的 AutoML 结果可视化](img/B16595_5_06.jpg)'
- en: Figure 5.6 – AutoML results visualized for classification
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6 – 用于分类的 AutoML 结果可视化
- en: Once you have thoroughly experimented with the `Titanic` data and have achieved
    the highest accuracy, you can move on to the next section to register your model.
    Registered models are necessary for later use in scoring new data through machine
    learning pipelines or real-time endpoints.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你彻底实验了`Titanic`数据并达到了最高的准确率，你就可以进入下一节以注册你的模型。注册的模型对于以后通过机器学习管道或实时端点评分新数据是必要的。
- en: Registering your trained classification model
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注册你的训练分类模型
- en: 'The code to register classification models is identical to the code you used
    in [*Chapter 4*](B16595_04_ePub.xhtml#_idTextAnchor056)*, Building an AutoML Regression
    Solution*, to register your regression model. Always register new models, as you
    will use them to score new data using either real-time scoring endpoints or batch
    execution inference pipelines depending on your use case. This will be explained
    in [*Chapter 9*](B16595_09_ePub.xhtml#_idTextAnchor129)*, Implementing a Batch
    Scoring Solution*, and [*Chapter 11*](B16595_11_ePub.xhtml#_idTextAnchor172)*,
    Implementing a Real-Time Scoring Solution*. Likewise, when registering your models,
    always add tags and descriptions for easier tracking:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 注册分类模型的代码与您在[*第4章*](B16595_04_ePub.xhtml#_idTextAnchor056)*，构建一个AutoML回归解决方案*中用于注册回归模型的代码相同。始终注册新模型，因为您将使用它们来对新数据进行评分，具体取决于您的用例，使用实时评分端点或批量执行推理管道。这将在[*第9章*](B16595_09_ePub.xhtml#_idTextAnchor129)*，实现批量评分解决方案*和[*第11章*](B16595_11_ePub.xhtml#_idTextAnchor172)*，实现实时评分解决方案*中解释。同样，在注册模型时，始终添加标签和描述以便于跟踪：
- en: 'First, give your model a name, a description, and some tags:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，为您的模型命名、添加描述和标签：
- en: '[PRE21]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Tags let you easily search for models, so think carefully as you implement them.
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 标签让您能够轻松搜索模型，因此在实现它们时请仔细思考。
- en: 'Next, register your model to your AMLS workspace, passing in your model name,
    tags, and description. Use the `AutoML_run` instance you trained in the previous
    section:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将您的模型注册到您的AMLS工作区，传入您的模型名称、标签和描述。使用上一节中训练的`AutoML_run`实例：
- en: '[PRE22]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Try registering a different model based on `AutoML_run` using this:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试使用以下方法基于`AutoML_run`注册不同的模型：
- en: '`ID.experiment_name = ''Titanic-Transformed-Classification-AutoML''`'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`ID.experiment_name = ''Titanic-Transformed-Classification-AutoML''`'
- en: '`exp = Experiment(workspace=ws, name=experiment_name)`'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`exp = Experiment(workspace=ws, name=experiment_name)`'
- en: '`AutoML_run = AutoMLRun(experiment = exp, run_id = ''your_run_id'')`'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`AutoML_run = AutoMLRun(experiment = exp, run_id = ''your_run_id'')`'
- en: You have registered your model and it is ready for use. You have created a classification
    model that can be used to predict who survived and who did not on the ill-fated
    Titanic voyage. It fell a little short of the classification model you built in
    [*Chapter 3*](B16595_03_ePub.xhtml#_idTextAnchor044)*, Training Your First AutoML
    Model*, but in doing so, you learned a lot. With your lessons in mind, we can
    move on to tips and tricks that will improve your classification models as you
    train more in the future.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 您已注册了您的模型，并且它已准备好使用。您创建了一个分类模型，可以用来预测在不幸的泰坦尼克号航程中谁幸存谁未幸存。它略逊于您在[*第3章*](B16595_03_ePub.xhtml#_idTextAnchor044)*，训练您的第一个AutoML模型*中构建的分类模型，但在此过程中，您学到了很多。带着您的教训，我们可以继续学习在将来训练更多模型时可以改进分类模型的小技巧和窍门。
- en: Training an AutoML multiclass model
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 训练一个AutoML多类模型
- en: Multiclass classification involves predicting three or more classes instead
    of the standard binary classification. Using custom machine learning, training
    multiclass models is often a messy, complicated affair where you have to carefully
    consider the number of classes you are trying to predict, how unbalanced those
    classes are relative to each other, whether you should combine classes together,
    and how you should present your results. Luckily, AutoML takes care of all these
    considerations for you and makes training a multiclass model as simple as training
    a binary classification model.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 多类分类涉及预测三个或更多类别，而不是标准的二分类。使用定制机器学习，训练多类模型通常是一个混乱、复杂的过程，您必须仔细考虑您试图预测的类别数量，这些类别相对于彼此的不平衡程度，是否应该将类别组合在一起，以及您应该如何展示您的结果。幸运的是，AutoML为您处理了所有这些考虑，使得训练一个多类模型与训练一个二分类模型一样简单。
- en: In this section, you load in data using the publicly available Iris dataset.
    You will then set your AutoML classifications for multiclass classification, train
    and register a model, and examine your results. You will notice that much of the
    code is identical to the last section. By understanding the differences between
    binary and multiclass classification in AutoML, you will gain the confidence to
    tackle any type of classification problem irrespective of complexity.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将使用公开可用的Iris数据集加载数据。然后，您将为多类分类设置AutoML分类，训练并注册一个模型，并检查您的结果。您会注意到大部分代码与上一节相同。通过理解AutoML中二类和多类分类之间的差异，您将获得信心去应对任何类型的分类问题，无论其复杂程度如何。
- en: Download the `Iris.csv` file from the GitHub repository, [https://github.com/PacktPublishing/Automated-Machine-Learning-with-Microsoft-Azure](https://github.com/PacktPublishing/Automated-Machine-Learning-with-Microsoft-Azure).
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从GitHub仓库下载`Iris.csv`文件，[https://github.com/PacktPublishing/Automated-Machine-Learning-with-Microsoft-Azure](https://github.com/PacktPublishing/Automated-Machine-Learning-with-Microsoft-Azure)。
- en: Load `Iris.csv` into Azure and create a dataset called `Iris Training` following
    the same steps you took in [*Chapter 3*](B16595_03_ePub.xhtml#_idTextAnchor044)*,
    Training Your First AutoML Model*.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照与[*第3章*](B16595_03_ePub.xhtml#_idTextAnchor044)*，训练你的第一个AutoML模型*相同的步骤，将`Iris.csv`加载到Azure中，并创建一个名为`Iris
    Training`的数据集。
- en: 'Load in all of the libraries you will need to run all of your code. Notice
    these libraries are identical to the ones you used for binary classification:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入你将需要运行所有代码的所有库。注意，这些库与你在二分类中使用的库相同：
- en: '[PRE23]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Load in `pandas` and `numpy`. No matter the data you''re working with, you
    will always find these packages useful:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`pandas`和`numpy`。无论你处理什么数据，你都会发现这些包非常有用：
- en: '[PRE24]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Connect your Jupyter notebook to your AMLS workspace:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的Jupyter笔记本连接到你的AMLS工作区：
- en: '[PRE25]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Set your compute cluster:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置你的计算集群：
- en: '[PRE26]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Set your `datastore`:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置你的`datastore`：
- en: '[PRE27]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Set your `dataset`. Notice that this is the first piece of code that differs
    from binary classification, as you''re using an entirely different dataset:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置你的`dataset`。注意，这是与二分类不同的第一段代码，因为你正在使用一个完全不同的数据集：
- en: '[PRE28]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'View the first 10 rows of your data using the following code. Make sure that
    it looks correct. With Iris data, you are trying to predict the `species` column:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码查看你的数据的前10行。确保它看起来正确。在使用Iris数据时，你试图预测`species`列：
- en: '[PRE29]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The first 10 rows should look similar to *Figure 5.7*:'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前十行应该类似于*图5.7*：
- en: '![Figure 5.7 – Iris data](img/B16595_5_07.jpg)'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图5.7 – Iris数据](img/B16595_5_07.jpg)'
- en: Figure 5.7 – Iris data
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图5.7 – Iris数据
- en: 'Use the pandas `unique` function on the `species` column to see how many classes
    you need to predict. You should see three classes, *Iris-setosa*, *Iris-versicolor*,
    and *Iris-virginica*:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用pandas的`unique`函数在`species`列上查看你需要预测多少个类别。你应该看到三个类别，*Iris-setosa*，*Iris-versicolor*，和*Iris-virginica*：
- en: '[PRE30]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Set your experiment and give it a name:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置你的实验并给它命名：
- en: '[PRE31]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Try to be descriptive when naming your experiments to easily track them, for
    example, by indicating explicitly that this training run is for multiclass classification.
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 尝试在命名你的实验时尽量描述性，以便于轻松追踪，例如，明确指出这次训练运行是为了多类分类。
- en: 'Set your target column to `species`. Capitalization matters:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的目标列设置为`species`。大小写很重要：
- en: '[PRE32]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Unlike most custom machine learning code, you do not have to convert the three
    different classes to integers. AutoML handles all of this on the backend.
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与大多数自定义机器学习代码不同，你不需要将三个不同的类别转换为整数。AutoML在后台处理所有这些。
- en: 'Create a variable for your task: the task is the type of AutoML model you are
    trying to train. For predicting categories, enter `classification`:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为你的任务创建一个变量：任务是你要尝试训练的AutoML模型类型。对于预测类别，输入`classification`：
- en: '[PRE33]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '`task` should be set to `classification` for both binary and multiclass classification
    problems.'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于二分类和多类分类问题，`task`都应该设置为`classification`。
- en: 'Create a variable for your primary metric. Use `accuracy`:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为你的主要指标创建一个变量。使用`accuracy`：
- en: '[PRE34]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: All metrics are the same for binary and multiclass classification problems,
    except some are calculated slightly differently by averaging the metric for each
    class instead of simply comparing true positives to true negatives. Accuracy,
    however, is calculated the same regardless of whether the problem is binary or
    multiclass.
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于二分类和多类分类问题，所有指标都是相同的，除了某些指标是通过平均每个类别的指标而不是简单地比较真阳性与真阴性来计算的不同。然而，准确率无论问题是否为二分类或多类分类，计算方式都是相同的。
- en: 'Create a variable for `featurization` and set it to `auto`:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`featurization`创建一个变量并将其设置为`auto`：
- en: '[PRE35]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: You can set `featurization` to `auto` or `off`. For multiclass problems, it
    is especially important to set it to `auto` so classes are properly balanced.
    Not doing so will impact model performance.
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以将`featurization`设置为`auto`或`off`。对于多类问题，将`featurization`设置为`auto`特别重要，以确保类别得到适当的平衡。如果不这样做，将影响模型性能。
- en: 'Set the number of classes to `3`:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将类别数设置为`3`：
- en: '[PRE36]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: While you can do this programmatically, you can also set it to a number in cases
    where you already know and have confirmed the number of classes.
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 虽然你可以通过编程方式完成此操作，但在你已知并已确认类别数量时，你也可以将其设置为数字。
- en: Important note
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 重要提示
- en: When training multiclass classification problems, sometimes you should hardcode
    in the number of classes. This ensures that your training run will fail if corrupted
    data enters your system and gives you an extra, unexpected class.
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当训练多类分类问题时，有时你应该硬编码类别的数量。这确保了如果损坏的数据进入你的系统并给你一个额外的、意外的类别，你的训练运行将失败。
- en: 'Configure your AutoML run. Nothing is different between multiclass and binary
    classification problems when it comes to configuring the run itself. One caveat
    is that multiclass classification problems often benefit from slightly higher
    cross validation settings. This helps ensures that the classes in each training
    split are more uniform. Set it to `10`:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置你的 AutoML 运行。在配置运行本身方面，多类和二类分类问题之间没有区别。一个注意事项是，多类分类问题通常从稍微更高的交叉验证设置中受益。这有助于确保每个训练分割中的类别更加均匀。将其设置为
    `10`：
- en: '[PRE37]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Train your model and watch the results in real time:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 训练你的模型并实时查看结果：
- en: '[PRE38]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Once your model is done training, register your model:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你的模型完成训练，注册你的模型：
- en: '[PRE39]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As your AutoML model is running, it will perform the usual data guardrails check
    followed by. It is the same for binary and multiclass classification, checking
    for class balancing, missing features, and high cardinality. Your Iris data should
    pass all of these checks easily.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的 AutoML 模型运行时，它将执行通常的数据护栏检查，然后是。对于二类和多元分类，这是相同的，检查类别平衡、缺失特征和高基数。你的 Iris 数据应该轻松通过所有这些检查。
- en: 'Once the data guardrails check is complete, AutoML will start training models
    as usual. Compare the models trained on multiclass Iris data versus binary class
    Titanic data. You should notice that most models are the same. Your output should
    resemble *Figure 5.8*:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦数据护栏检查完成，AutoML 将像往常一样开始训练模型。比较在多类 Iris 数据上训练的模型与二类 Titanic 数据上训练的模型。你应该注意到大多数模型是相同的。你的输出应该类似于
    *图 5.8*：
- en: '![Figure 5.8 – AutoML results for multiclass classification ](img/B16595_5_08.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.8 – 多类分类的 AutoML 结果](img/B16595_5_08.jpg)'
- en: Figure 5.8 – AutoML results for multiclass classification
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.8 – 多类分类的 AutoML 结果
- en: 'There are excellent results. AutoML performs exceptionally well on the Iris
    dataset. There''s also an easy way to graph your performance directly from your
    Jupyter notebook. Scroll down slightly past your model output until you see blue
    links to each of your models as seen in *Figure 5.9*. Click on your highest-performing
    model. For the example, it was the voting ensemble model, but it may be something
    different in your case:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 结果非常出色。AutoML 在 Iris 数据集上表现异常出色。还有一种简单的方法可以直接从你的 Jupyter 笔记本中绘制你的性能。将鼠标稍微向下滚动到你的模型输出之后，直到你看到指向每个模型的蓝色链接，如图
    *图 5.9* 所示。点击你表现最好的模型。对于示例，它是投票集成模型，但你的情况可能不同：
- en: '![Figure 5.9 – Model links ](img/B16595_5_09.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.9 – 模型链接](img/B16595_5_09.jpg)'
- en: Figure 5.9 – Model links
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.9 – 模型链接
- en: 'Clicking on this link will expose a large number of visualizations for your
    AutoML classification experiment. In particular, there''s a **precision-recall
    curve**, an **ROC curve**, a **lift curve**, a **gain curve**, a **calibration
    curve**, and a **confusion matrix**. Business users most easily understand the
    confusion matrix, which shows you the number of classes that were accurately classified
    along with the number that were misclassified. As shown in *Figure 5.10*, AutoML
    only misclassified two data points out of 150 total. In both cases, the model
    incorrectly classified an Iris-versicolor as an Iris-virginica:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 点击此链接将展示大量针对你的 AutoML 分类实验的可视化。特别是，有一个 **精确率-召回率曲线**、一个 **ROC 曲线**、一个 **提升曲线**、一个
    **增益曲线**、一个 **校准曲线** 和一个 **混淆矩阵**。商业用户最容易理解混淆矩阵，它显示了准确分类的类别数量以及错误分类的数量。如图 *图 5.10*
    所示，AutoML 只错误地将 150 个数据点中的两个分类错误。在两种情况下，模型错误地将 Iris-versicolor 分类为 Iris-virginica：
- en: '![Figure 5.10 – Confusion matrix for the Iris classification model ](img/B16595_5_10.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.10 – Iris 分类模型的混淆矩阵](img/B16595_5_10.jpg)'
- en: Figure 5.10 – Confusion matrix for the Iris classification model
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.10 – Iris 分类模型的混淆矩阵
- en: Now that you have trained both a binary and multiclass classification model
    with AutoML, you can apply these techniques to your own data and business problems.
    If you were training custom machine learning models, you would have to memorize
    many little differences between binary and multiclass classification, but Azure
    AutoML handles all of those complexities for you. You don't even have to change
    your categorical column to integers.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经使用AutoML训练了二进制和多类分类模型，您可以将这些技术应用到您自己的数据和业务问题上。如果您正在训练定制的机器学习模型，您将不得不记住二进制和多类分类之间许多小的差异，但Azure
    AutoML为您处理了所有这些复杂性。您甚至不需要将分类列转换为整数。
- en: As such, you should feel comfortable using AutoML for any classification problem
    you have. The final section gives you tips and tricks for achieving better model
    performance.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您应该对使用AutoML解决任何分类问题感到舒适。最后一节为您提供了提高模型性能的技巧和窍门。
- en: Fine-tuning your AutoML classification model
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微调您的AutoML分类模型
- en: In this section, you will first review tips and tricks for improving your AutoML
    classification models and then review the algorithms used by AutoML for both binary
    and multiclass classification.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将首先回顾提高您的AutoML分类模型的技巧和窍门，然后回顾AutoML用于二进制和多类分类的算法。
- en: Improving AutoML classification models
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提高AutoML分类模型
- en: 'Keeping in mind the tips and tricks from [*Chapter 4*](B16595_04_ePub.xhtml#_idTextAnchor056)*,
    Building an AutoML Regression Solution*, here are new ones that are specific to
    classification:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 记住[第4章](B16595_04_ePub.xhtml#_idTextAnchor056)中的技巧和窍门*构建AutoML回归解决方案*，以下是一些特定于分类的新技巧：
- en: Unlike regression problems, nearly all classification problems in the real world
    require you to weigh your target column. The reason is that, for most business
    problems, one class is nearly always more important than the others.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与回归问题不同，在现实世界中，几乎所有分类问题都需要你权衡你的目标列。原因是，对于大多数商业问题，一个类别几乎总是比其他类别更重要。
- en: For example, imagine you are running a business and you are trying to predict
    which customers will stop doing business with you and leave you for a competitor.
    This is a common problem called customer churn or customer turnover. If you misidentify
    a customer as being likely to churn, all you waste is an unnecessary phone call
    or email. However, if your algorithm misses a customer who will churn, you lose
    that customer and their money.
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，假设您正在经营一家企业，您试图预测哪些客户会停止与您做生意，转而与竞争对手合作。这是一个常见的称为客户流失或客户周转的问题。如果您错误地将客户识别为可能流失，您浪费的只是一个不必要的电话或电子邮件。然而，如果您的算法错过了一个即将流失的客户，您就会失去那个客户及其资金。
- en: If you use the normal accuracy metric in AutoML, that is a poor metric for this
    problem. This is because it's much better to misidentify someone as *likely to
    switch* than it is to misidentify someone as *likely to stay*. The solution to
    this is to use the `weight_column_name` feature in AutoML. This allows you to
    create a column that weights hits and misses differently.
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您在AutoML中使用正常准确率指标，那么对于这个问题来说，这是一个很差的指标。这是因为将某人误认为是*可能转换*的人，比误认为是*可能留下*的人要好得多。解决这个问题的方法是使用AutoML中的`weight_column_name`功能。这允许您创建一个对命中和失误进行不同权重的列。
- en: For example, if your algorithm misses a customer who is likely to churn, you
    can penalize that miss 100 times more than if the algorithm says a customer will
    churn when they will not by assigning a weight of 100 to churned customers and
    a weight of 1 to customers who did not churn. This will train a model that excels
    at not missing customers who will turnover, although it will have many false positives
    as well.
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，如果您的算法错过了一个可能流失的客户，您可以比算法错误地表示客户将流失而实际上不会流失时，对该失误进行100倍的惩罚。将流失客户的权重设置为100，未流失客户的权重设置为1。这将训练出一个在不会错过即将流失的客户方面表现优异的模型，尽管它也会有大量的误报。
- en: 'Become familiar with all of the different AutoML configuration options for
    classification. You can find them at this link: [https://docs.microsoft.com/en-us/python/api/azureml-train-automl-client/azureml.train.automl.automlconfig.automlconfig?view=azure-ml-py](https://docs.microsoft.com/en-us/python/api/azureml-train-automl-client/azureml.train.automl.automlconfig.automlconfig?view=azure-ml-py).'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 熟悉所有AutoML分类配置选项。您可以在以下链接中找到它们：[https://docs.microsoft.com/en-us/python/api/azureml-train-automl-client/azureml.train.automl.automlconfig.automlconfig?view=azure-ml-py](https://docs.microsoft.com/en-us/python/api/azureml-train-automl-client/azureml.train.automl.automlconfig.automlconfig?view=azure-ml-py)。
- en: If your target column has a ratio of more than 20 to 1, it is a good idea to
    either collect more data from the smaller class or resample your data to achieve
    the 20 to 1 ratio.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你的目标列的比率超过20比1，收集更多来自较小类别的数据或重新采样你的数据以达到20比1的比率是一个好主意。
- en: Research the five different primary metrics to understand which metrics fit
    your problem best. Classification requires a much more nuanced understanding of
    the business problem to make a wise metric selection.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 研究五种不同的主要指标，以了解哪些指标最适合你的问题。分类需要更深入地理解业务问题，以便做出明智的指标选择。
- en: Use [https://docs.microsoft.com/en-us/azure/machine-learning/how-to-understand-automated-ml](https://docs.microsoft.com/en-us/azure/machine-learning/how-to-understand-automated-ml)
    to understand what a good classification model looks like. Confusion matrices
    are particularly valuable in determining whether your model is better at predicting
    one class over another. Depending on your business use case, this may or may not
    be a problem.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用[https://docs.microsoft.com/en-us/azure/machine-learning/how-to-understand-automated-ml](https://docs.microsoft.com/en-us/azure/machine-learning/how-to-understand-automated-ml)来了解一个好的分类模型是什么样的。混淆矩阵在确定你的模型是否更擅长预测一个类别而不是另一个类别时特别有价值。根据你的业务用例，这可能是也可能不是一个问题。
- en: Go to **Experiments** under **Assets** in AML studio, click your experiment
    name, select **Run ID**, click the **Models** tab, select the highest-performing
    algorithm, and click the **Metrics** tab. This will provide you with all of the
    different metrics and charts necessary to evaluate your algorithm.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在AML studio中，转到**资产**下的**实验**，点击你的实验名称，选择**运行ID**，点击**模型**标签，选择性能最高的算法，然后点击**指标**标签。这将为你提供评估算法所需的所有不同指标和图表。
- en: Explore using the `weight_column_name` configuration option to weigh your data.
    It is important you understand how this works. If some observations are more important
    to get right than others, you should always assign a higher weight to those observations.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索使用`weight_column_name`配置选项来权衡你的数据。理解这一点非常重要。如果某些观察结果比其他观察结果更重要，你应该始终为这些观察结果分配更高的权重。
- en: This is particularly important with classification models because, as mentioned
    before, some observations are almost always more important than others. Try assigning
    `0.1` to survivors and `1` to victims using the `Titanic` data and build a model.
    Then, try the opposite.
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这对于分类模型尤其重要，因为如前所述，某些观察结果几乎总是比其他观察结果更重要。尝试使用泰坦尼克号数据将`0.1`分配给幸存者，将`1`分配给受害者来构建模型。然后，尝试相反的操作。
- en: '**Overfitting**, where you produce a very good model that doesn''t generalize
    to new datapoints, is as much a problem in classification as it is in regression.
    If this happens to you, try adding more historical data or removing columns from
    your dataset. If your target column has more than 2 classes, try binning it to
    create a simple model less prone to overfitting.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过拟合**，即你产生了一个非常好的模型，但不能推广到新的数据点，在分类和回归中都是一个同样的问题。如果你遇到这种情况，尝试添加更多历史数据或从你的数据集中删除列。如果你的目标列有超过2个类别，尝试将其分箱以创建一个更不易过拟合的简单模型。'
- en: Be on the lookout for model bias with classification problems. **Bias** can
    occur when your model sacrifices performance in one class for another class. The
    worst bias occurs when the model only predicts a single class, for example, always
    predicting that a Titanic passenger perished. These models can occasionally be
    highly accurate due to class imbalance. With the Titanic data, such a model would
    be 61.6% accurate.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在处理分类问题时，要注意模型偏差。**偏差**可能发生在你的模型为了另一个类别牺牲了一个类别的性能时。最糟糕的偏差发生在模型只预测一个类别的情况下，例如，总是预测泰坦尼克号乘客死亡。这些模型有时由于类别不平衡而可能非常准确。在泰坦尼克号数据中，这样的模型准确率可达61.6%。
- en: When dealing with large datasets, the size of your compute instance doesn't
    matter, but the size of your compute cluster matters a lot. This is because your
    compute instance is only for writing and submitting code, while the AutoML training
    job runs remotely on the compute cluster. It's important that you train your AutoML
    with appropriately sized **virtual machines** (**VMs**).
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当处理大型数据集时，你的计算实例的大小并不重要，但你的计算集群的大小非常重要。这是因为你的计算实例仅用于编写和提交代码，而AutoML训练作业是在计算集群上远程运行的。确保你使用适当大小的**虚拟机（VM**）来训练AutoML非常重要。
- en: The size of the VMs on your compute cluster should be determined by the size
    of your dataset used for training. Roughly speaking, the RAM of your VM should
    be 20 times as large as the size of the data you are training in uncompressed
    CSV format, or twice as large as the size of the data you are training while in
    a pandas DataFrame. This is because CSV files grow up to 10 times in size when
    converted into a DataFrame. This guarantees a smooth run.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你计算集群上虚拟机的大小应该由用于训练的数据集大小决定。大致来说，你的虚拟机RAM应该是你以未压缩CSV格式训练的数据大小的20倍，或者是在pandas
    DataFrame中训练的数据大小的两倍。这是因为CSV文件在转换为DataFrame时大小会增长到原来的10倍。这保证了运行过程的顺畅。
- en: For example, if your base CSV file is 5 GB in size, then the RAM of each VM
    on your compute cluster should be at least 100 GB. In contrast, if your data is
    5 GB in size after being converted into a pandas DataFrame, then you only require
    VMs with 10 GB of RAM.
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，如果你的基础CSV文件大小为5 GB，那么你计算集群中每个虚拟机的RAM至少应该是100 GB。相比之下，如果你的数据在转换为pandas DataFrame后大小为5
    GB，那么你只需要具有10 GB RAM的虚拟机。
- en: '`AutoMLConfig` has many options that you should familiarize yourself with.
    One such option is `max_cores_per_iteration`. Set this to `-1` so that each model
    training run fully utilizes all the cores on each VM, giving you a little more
    processing power.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AutoMLConfig`有许多选项，你应该熟悉它们。其中一个选项是`max_cores_per_iteration`。将其设置为`-1`，以便每个模型训练运行充分利用每个虚拟机上的所有核心，给你提供更多的处理能力。'
- en: You can train AutoML models in parallel through another `AutoMLConfig` option
    called `max_concurrent_iterations`. This determines how many models AutoML trains
    in parallel. Set this to the maximum number of nodes on your compute cluster.
    If you have 8 nodes on your compute cluster and set `max_concurrent_iterations`
    to `8`, then AutoML will train 8 models at a time.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通过另一个名为`max_concurrent_iterations`的`AutoMLConfig`选项并行训练AutoML模型。这决定了AutoML并行训练多少个模型。将此设置为计算集群上的最大节点数。如果你计算集群上有8个节点，并将`max_concurrent_iterations`设置为`8`，那么AutoML将一次训练8个模型。
- en: These are just a few of the many ways you can fine-tune a classification model
    with AutoML. You can learn more techniques by reading scientific articles on machine
    learning, blog posts, and how-to guides. Of course, nothing beats experience.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是你可以使用AutoML微调分类模型的好几种方法中的一部分。你可以通过阅读机器学习的科学文章、博客文章和教程来学习更多技术。当然，没有什么能比经验更宝贵了。
- en: Try downloading as many open source classification datasets as you can find,
    load them into Azure, and use them to train and fine-tune AutoML models. With
    experience comes wisdom, and with wisdom comes the ability to solve even the toughest
    business problems with automated machine learning techniques. Learning the details
    about AutoML's classification algorithms is also important for you to develop
    your data science knowledge.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试下载尽可能多的开源分类数据集，将它们加载到Azure中，并使用它们来训练和微调AutoML模型。经验带来智慧，智慧带来使用自动化机器学习技术解决甚至最棘手商业问题的能力。了解AutoML分类算法的细节对于你发展数据科学知识也是非常重要的。
- en: Understanding AutoML classification algorithms
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解AutoML分类算法
- en: Many of the algorithms used by AutoML for classification are identical to the
    ones used by AutoML for regression. Like regression, certain algorithms perform
    better in certain situations. Unlike regression, AutoML uses a greater variety
    of algorithms for classification including neural networks.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: AutoML用于分类的许多算法与用于回归的算法相同。与回归一样，某些算法在特定情况下表现更好。与回归不同，AutoML在分类中使用了更多种类的算法，包括神经网络。
- en: The **tree**, **gradient boosting**, and **nearest neighbor** algorithms used
    by AutoML for classification are identical to the ones used for regression, and
    you can review them in [*Chapter 4*](B16595_04_ePub.xhtml#_idTextAnchor056)*,
    Building an AutoML Regression Solution*. The only difference is that the classification
    versions predict probabilities instead of values. **Stochastic gradient descent**
    (**SGD**) is also used by AutoML for classification. Unique to classification
    are logistic regression, naïve Bayes, averaged perceptron classifier, and three
    different algorithms that use **support vector machines** (**SVM**).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: AutoML用于分类的**树**、**梯度提升**和**最近邻**算法与用于回归的算法相同，你可以在[*第4章*](B16595_04_ePub.xhtml#_idTextAnchor056)“构建AutoML回归解决方案”中查看它们。唯一的区别是，分类版本预测的是概率而不是值。**随机梯度下降**（**SGD**）也被AutoML用于分类。独特的分类算法包括逻辑回归、朴素贝叶斯、平均感知器分类器和三种使用**支持向量机**（**SVM**）的算法。
- en: '**Logistic regression** uses a logistic function, an s-shaped sigmoid curve,
    to model the probability that your data belongs to a certain class. Despite its
    name, it is unrelated to regression. Like elastic net for regression, logistic
    regression uses **L1** (**lasso**) and **L2** (**ridge**) regularization to create
    simpler models by adjusting the coefficients of your input variables. Logistic
    regression is simple and easy to use, but it doesn''t do well with small datasets
    or when your data has nonlinear relationships.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '**逻辑回归**使用逻辑函数，一个s形的sigmoid曲线，来模拟你的数据属于某一类别的概率。尽管其名称如此，它与回归无关。与用于回归的弹性网络类似，逻辑回归通过调整输入变量的系数来使用**L1**（**lasso**）和**L2**（**ridge**）正则化创建更简单的模型。逻辑回归简单易用，但它在处理小数据集或数据具有非线性关系时表现不佳。'
- en: '**Naïve Bayes** is another simple classification algorithm. It uses Bayes''
    theorem to calculate the probability of a class given each input feature in a
    row of your data. It then weighs each input feature equally when deciding the
    class. It''s naïve in that it assumes that input features are independent of each
    other. Naïve Bayes performs well even with small data, but its chief assumption
    of independence is almost always violated in real life.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '**朴素贝叶斯**是另一种简单的分类算法。它使用贝叶斯定理来计算给定数据行中每个输入特征的类别概率。然后，在决定类别时，它对每个输入特征给予相同的权重。它之所以被称为“朴素”，是因为它假设输入特征之间相互独立。朴素贝叶斯即使在数据量小的情况下也能表现良好，但它在现实生活中的主要假设——独立性——几乎总是被违反。'
- en: '**Averaged perceptron classifier** is a simple type of **neural network** that
    uses a system of weights and linear functions to make its predictions. Like logistic
    regression, it''s best suited to datasets with linear relationships between your
    input variable and target column. It''s only used for binary classification.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '**平均感知器分类器**是一种简单的**神经网络**类型，它使用一组权重和线性函数来做出预测。与逻辑回归类似，它最适合具有输入变量和目标列之间线性关系的数据库。它仅用于二元分类。'
- en: '**Support vector algorithms** classify data by drawing dividing among hyperplanes
    of data. Imagine visualizing your data in an n-dimensional space where n is the
    number of your input columns. SVM works by finding the lines that divide your
    data best. They work for both linear and non-linear data, even for high-dimensional
    data. AutoML uses three of these algorithms: **support vector classification**
    (**SVC**), linear SVC, and linear SVM classifier.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '**支持向量算法**通过在数据超平面上绘制分割来对数据进行分类。想象一下，在你的输入列数n的n维空间中可视化你的数据。SVM通过找到最佳划分数据的线来工作。它们适用于线性和非线性数据，甚至适用于高维数据。AutoML使用这三种算法中的三种：**支持向量分类**（**SVC**）、线性SVC和线性SVM分类器。'
- en: SVC is a standard implementation of support vector machines that works for both
    multiclass and binary classification problems. Linear SVC is an implementation
    that divides data linearly as opposed to SVC, which can divide data using nonlinear
    kernel functions. Linear SVM classifier, on the other hand, is similar to linear
    SVC but can only be used for binary classification.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: SVC是支持向量机的一个标准实现，适用于多类和二元分类问题。线性SVC是一种将数据线性划分的实现，与可以使用非线性核函数划分数据的SVC不同。另一方面，线性SVM分类器与线性SVC相似，但只能用于二元分类。
- en: 'A summary of the 14 algorithms is provided in the following table:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格提供了14种算法的总结：
- en: '![Figure 5.11 – AutoML classification algorithms ](img/B16595_5_11.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![图5.11 – AutoML分类算法](img/B16595_5_11.jpg)'
- en: Figure 5.11 – AutoML classification algorithms
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.11 – AutoML分类算法
- en: Like regression, AutoML performs **model ensembling** at the end of each AutoML
    training run. **Voting ensembles** take the weighted average of predicted class
    probabilities and use that to predict the class of an individual row of input
    data. **Stack ensembles**, in contrast, train a logistic regression model using
    the output of other models. Usually, one of these two ensemble models will be
    your best model.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 与回归类似，AutoML在每个AutoML训练运行的末尾执行**模型集成**。**投票集成**通过取预测类别概率的加权平均来预测单个输入数据行的类别。相比之下，**堆叠集成**使用其他模型的输出训练逻辑回归模型。通常，这两种集成模型中的任何一个都将是你的最佳模型。
- en: For more information on these models, please consult the AutoML documentation
    found at [https://docs.microsoft.com/en-us/azure/machine-learning/how-to-configure-auto-train#configure-your-experiment-settings](https://docs.microsoft.com/en-us/azure/machine-learning/how-to-configure-auto-train#configure-your-experiment-settings).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这些模型的更多信息，请参阅位于[https://docs.microsoft.com/en-us/azure/machine-learning/how-to-configure-auto-train#configure-your-experiment-settings](https://docs.microsoft.com/en-us/azure/machine-learning/how-to-configure-auto-train#configure-your-experiment-settings)的AutoML文档。
- en: Summary
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: You have added to your repertoire by successfully training a classification
    model using the AML Python SDK. You have loaded in data, heavily transformed it
    using pandas and Numpy, and built a toy AutoML model. You then registered that
    model to your AMLS workspace.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经通过使用AML Python SDK成功训练了一个分类模型，丰富了你的技能库。你已加载数据，使用pandas和Numpy进行了大量转换，并构建了一个玩具AutoML模型。然后，你将该模型注册到你的AMLS工作区。
- en: You can now start building classification models with your own data. You can
    easily solve both binary and multiclass classification problems, and you can present
    results to the business in a way they understand with confusion matrices. Many
    of the most common business problems, such as customer churn, are classification
    problems, and with the knowledge you learned in this chapter, you can solve those
    problems and earn trust and respect in your organization.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以使用自己的数据开始构建分类模型。你可以轻松解决二元和多类分类问题，并且你可以通过混淆矩阵以他们理解的方式展示结果。许多最常见的商业问题，如客户流失，都是分类问题，而通过本章所学到的知识，你可以解决这些问题，并在你的组织中赢得信任和尊重。
- en: The next chapter, [*Chapter 6*](B16595_06_ePub.xhtml#_idTextAnchor081)*, Building
    an AutoML Forecasting Solution*, will be vastly different from the previous two
    chapters. Forecasting problems have many more settings to use and understand compared
    to classification and regression problems, and they always require you to have
    a deeper understanding of your dataset. Novice data scientists also make many
    mistakes when training such models, and AutoML will enable you to avoid all of
    them.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章，[*第6章*](B16595_06_ePub.xhtml#_idTextAnchor081)*，构建AutoML预测解决方案*，将与前两章有很大不同。与分类和回归问题相比，预测问题有更多的设置需要使用和理解，并且它们总是要求你对你的数据集有更深入的了解。新手数据科学家在训练此类模型时也会犯许多错误，而AutoML将使你避免所有这些错误。
