<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer234">
			<h1 id="_idParaDest-101"><em class="italic"><a id="_idTextAnchor102"/>Chapter 9</em>: Using the Deployed TPOT Model in Production</h1>
			<p>You've made it to the final chapter – congratulations! So far, you've learned the basics of TPOT by solving classification and regression tasks, how TPOT works with Dask and neural networks, and how to deploy machine learning models both locally and to the cloud.</p>
			<p>This chapter will serve as icing on the cake, as you'll learn how to communicate with your deployed models to build something even a 5-year-old could use. To be more precise, you'll learn how to communicate with your API through a notebook environment and a simple GUI web application.</p>
			<p>This chapter will cover the following topics:</p>
			<ul>
				<li>Making predictions in a notebook environment</li>
				<li>Developing a simple GUI web application</li>
				<li>Making predictions in a GUI environment</li>
			</ul>
			<h1 id="_idParaDest-102"><a id="_idTextAnchor103"/>Technical requirements</h1>
			<p>This is the last chapter in the book, so some prior knowledge is assumed. You need to know how to build basic machine learning models with TPOT to deploy them. It's assumed that your model is deployed to the AWS virtual machine created in <a href="B16954_08_Final_SK_ePub.xhtml#_idTextAnchor093"><em class="italic">Chapter 8</em></a><em class="italic">, TPOT Model Deployment</em>. If that's not the case, please revisit that chapter.</p>
			<p>This chapter will be quite code-heavy, so you can refer to the official GitHub repository if you get stuck: <a href="https://github.com/PacktPublishing/Machine-Learning-Automation-with-TPOT/tree/main/Chapter09">https://github.com/PacktPublishing/Machine-Learning-Automation-with-TPOT/tree/main/Chapter09</a>.</p>
			<h1 id="_idParaDest-103"><a id="_idTextAnchor104"/>Making predictions in a notebook environment</h1>
			<p>If you took a day's (or a few days') break after the previous chapter, it's likely that your connection to the remote <a id="_idIndexMarker538"/>virtual machine ended. Because of that, you'll need to reconnect and start the API once again. There are ways to make your API always running, but that's out of the scope of this book. Furthermore, if you've moved the <strong class="source-inline">TPOT_Book_KeyPair.pem</strong> file to some other folder, you'll have to reset the permissions:</p>
			<ol>
				<li>With that in mind, execute the first command line from the following snippet, only if you have to reset the permissions:<p class="source-code"><strong class="bold">&gt; chmod 400 TPOT_Book_KeyPair.pem</strong></p><p class="source-code"><strong class="bold">&gt; ssh -i "TPOT_Book_KeyPair.pem" ubuntu@ec2-18-220-113-224.us-east-2.compute.amazonaws.com</strong></p><p class="source-code"><strong class="bold">&gt; cd api</strong></p><p class="source-code"><strong class="bold">&gt; python3 app.py</strong></p></li>
				<li>Your API is running now. The next step is to open a JupyterLab or Jupyter Notebook environment and make a request. You'll need the <strong class="source-inline">requests</strong> library to do so, so here's how to import it:<p class="source-code">import requests</p><p>Let's declare a couple of variables next. These will hold the values for the host name, port, and endpoint:</p><p class="source-code">HOST ='http://ec2-18-220-113-224.us-east-2.compute.amazonaws.com'</p><p class="source-code">PORT = '8000'</p><p class="source-code">ENDPOINT = '/predict'</p><p>From there, we can easily concatenate these three variables into a single one to form a URL:</p><p class="source-code">URL = f'{HOST}:{PORT}{ENDPOINT}'</p><p class="source-code">URL</p><p>Here's how it should look:</p><div id="_idContainer216" class="IMG---Figure"><img src="Images/B16954_09_1.jpg" alt="Figure 9.1 – URL connection string&#13;&#10;" width="1128" height="40"/></div><p class="figure-caption">Figure 9.1 – URL connection string</p><p>Yours will be a bit different due to the difference in the hostname.</p></li>
				<li>Next, we'll <a id="_idIndexMarker539"/>declare a dictionary that will serve as input data. It will be identical to the data sent in the previous chapter through Postman. Here's the code snippet:<p class="source-code">in_data = {</p><p class="source-code">    'SepalLength': 0.4,</p><p class="source-code">    'SepalWidth': 3.1,</p><p class="source-code">    'PetalLength': 0.1,</p><p class="source-code">    'PetalWidth': 14</p><p class="source-code">}</p><p>That's all we need to make a request. Let's do that next.</p></li>
				<li>You can use the <strong class="source-inline">post()</strong> function from the <strong class="source-inline">requests</strong> package to make a POST request. Two parameters are required – the URL and the data in JSON format:<p class="source-code">req = requests.post(url=URL, json=in_data)</p><p class="source-code">req</p><p>The results are displayed in the following figure:</p><p class="figure-caption"><img src="Images/B16954_09_2.png" alt="Figure 9.2 – API response status code&#13;&#10;" width="190" height="28"/></p><p class="figure-caption">Figure 9.2 – API response status code</p><p>This isn't quite what we were looking for, but a status code of 200 is a good sign that we're on the right track as it indicates a success message. You can access the <strong class="source-inline">content</strong> property of the request to get the actual API response:</p><p class="source-code">response = req.content</p><p class="source-code">response</p><p>Here's how the response looks:</p><div id="_idContainer218" class="IMG---Figure"><img src="Images/B16954_09_3.jpg" alt="Figure 9.3 – API response as a string&#13;&#10;" width="1379" height="66"/></div><p class="figure-caption">Figure 9.3 – API response as a string</p><p>As you can see, the prediction is returned successfully but not in the desired format by default.</p></li>
				<li>To change that, you'll <a id="_idIndexMarker540"/>need to transform the response string to a JSON object. You can use the <strong class="source-inline">loads()</strong> function from the <strong class="source-inline">json</strong> package to do so:<p class="source-code">import json</p><p class="source-code">response_json = json.loads(response)</p><p class="source-code">response_json</p><p>Here are the results:</p><div id="_idContainer219" class="IMG---Figure"><img src="Images/B16954_09_4.jpg" alt="Figure 9.4 – API response as a JSON object&#13;&#10;" width="558" height="184"/></div><p class="figure-caption">Figure 9.4 – API response as a JSON object</p></li>
				<li>You can access the <a id="_idIndexMarker541"/>predicted class (or any other property) just as you would for a normal dictionary object. Here's an example:<p class="source-code">response_json['Prediction']</p><p>And here's what's returned:</p></li>
			</ol>
			<div>
				<div id="_idContainer220" class="IMG---Figure">
					<img src="Images/B16954_09_5.jpg" alt="Figure 9.5 – API predicted class&#13;&#10;" width="175" height="37"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.5 – API predicted class</p>
			<p>And that's essentially how you can obtain predictions from a deployed REST API with Python! In the next section, you'll build a basic interactive web application around this API to make it utterly simple for anyone to use.</p>
			<h1 id="_idParaDest-104"><a id="_idTextAnchor105"/>Developing a simple GUI web application</h1>
			<p>This section aims to <a id="_idIndexMarker542"/>demonstrate how the <strong class="source-inline">Flask</strong> framework can be used to develop a simple web application. The focus is shifted toward building an application that captures form data, which is then passed to our deployed machine learning API:</p>
			<ol>
				<li value="1">To start, create the following directory structure:<div id="_idContainer221" class="IMG---Figure"><img src="Images/B16954_09_6.jpg" alt="Figure 9.6 – Web application directory structure&#13;&#10;" width="385" height="163"/></div><p class="figure-caption">Figure 9.6 – Web application directory structure</p><p>Most of the logic is handled in <strong class="source-inline">app.py</strong>, and the <strong class="source-inline">templates</strong> folder is used to store HTML files for the app – more on that in a bit.</p></li>
				<li>This time we'll organize the code a bit better, so you'll need to create an additional file for storing the environment variables. Inside the root directory (<strong class="source-inline">webapp</strong>), create a file called <strong class="source-inline">.env</strong> – and populate it with the following:<p class="source-code">SECRET_KEY=SecretKey</p><p class="source-code">HOST=0.0.0.0</p><p class="source-code">PORT=9000</p><p class="source-code">API_ENDPOINT=http://ec2-18-220-113-224.us-east-2.compute.amazonaws.com:8000/predict</p><p>Creating a separate file like this is considered to be a best practice when developing any sort of web application.</p><p>To use these <a id="_idIndexMarker543"/>environment variables, you'll have to install an additional package to your virtual environment:</p><p class="source-code"><strong class="bold">&gt; pip install python-dotenv</strong></p></li>
				<li>Let's build the basic structure of the application now. Open the <strong class="source-inline">app.py</strong> file and write the following code:<p class="source-code">import os</p><p class="source-code">from flask import Flask, render_template</p><p class="source-code">from dotenv import load_dotenv</p><p class="source-code">load_dotenv('.env')</p><p class="source-code">app = Flask(__name__)</p><p class="source-code">@app.route('/')</p><p class="source-code">def index():</p><p class="source-code">    return render_template('index.html')</p><p class="source-code">if __name__ == '__main__':</p><p class="source-code">    app.run(host=os.getenv('HOST'), port=os.getenv('PORT'))</p><p>If you were to run the application now, you wouldn't get an error, but nothing would be displayed on the screen. The reason is simple – we haven't handled the <strong class="source-inline">index.html</strong> file yet. Before we do so, let's discuss the only potentially unfamiliar part of code: the <strong class="source-inline">render_template()</strong> function. Put simply, this function will display an HTML file instead of showing merely a string or value returned from the function. There's a way to pass parameters, but more on that later.</p></li>
				<li>Onto the <strong class="source-inline">index.html</strong> now – here's <a id="_idIndexMarker544"/>the code you can paste inside the file:<p class="source-code">&lt;!DOCTYPE html&gt;</p><p class="source-code">&lt;html lang="en"&gt;</p><p class="source-code">&lt;head&gt;</p><p class="source-code">    &lt;meta charset="UTF-8"&gt;</p><p class="source-code">    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;</p><p class="source-code">    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;</p><p class="source-code">    &lt;title&gt;Iris Predictioner&lt;/title&gt;</p><p class="source-code">&lt;/head&gt;</p><p class="source-code">&lt;body&gt;</p><p class="source-code">    &lt;h1&gt;Welcome to Iris Predictioner&lt;/h1&gt;</p><p class="source-code">&lt;/body&gt;</p><p class="source-code">&lt;/html&gt;</p><p>Don't worry if you haven't written a line of HTML before – it's a simple markup language. Think of everything you see here as boilerplate. It's what's inside the <strong class="source-inline">&lt;body&gt;&lt;/body&gt;</strong> tag that we're interested in.</p><p>If you were to run your application now, here's how it would look:</p><div id="_idContainer222" class="IMG---Figure"><img src="Images/B16954_09_7.jpg" alt="Figure 9.7 – Iris prediction application (v1)&#13;&#10;" width="812" height="266"/></div><p class="figure-caption">Figure 9.7 – Iris prediction application (v1)</p><p>It's a simple and utterly boring web application, but at least it works.</p></li>
				<li>As mentioned before, our <a id="_idIndexMarker545"/>web application has to handle form data somehow, so let's start working on that. There's a dedicated package for handling form data with <strong class="source-inline">Flask</strong> called <strong class="source-inline">Flask-WTF</strong>. Here's how you can install it:<p class="source-code"><strong class="bold">&gt; pip install flask-wtf</strong></p><p>Once installed, create a <strong class="source-inline">forms.py</strong> file in the root directory – /<strong class="source-inline">webapp/forms.py</strong>. Let's take a look at the code this file contains and explain it:</p><p class="source-code">from flask_wtf import FlaskForm</p><p class="source-code">from wtforms import FloatField, SubmitField</p><p class="source-code">from wtforms.validators import DataRequired</p><p class="source-code">class IrisForm(FlaskForm):</p><p class="source-code">    sepal_length = FloatField(</p><p class="source-code">        label='Sepal Length', validators=[DataRequired()]</p><p class="source-code">    )</p><p class="source-code">    sepal_width = FloatField(</p><p class="source-code">        label='Sepal Width', validators=[DataRequired()]</p><p class="source-code">    )</p><p class="source-code">    petal_length = FloatField(</p><p class="source-code">        label='Petal Length', validators=[DataRequired()]</p><p class="source-code">    )</p><p class="source-code">    petal_width = FloatField(</p><p class="source-code">        label='Petal Width', validators=[DataRequired()]</p><p class="source-code">    )</p><p class="source-code">    submit = SubmitField(label='Predict')</p><p>Okay, so <a id="_idIndexMarker546"/>what's going on in this file? Put simply, <strong class="source-inline">Flask-WTF</strong> allows us to declare forms for <strong class="source-inline">Flask</strong> applications easily, in a class format. We can use any of the built-in field types and validators. For this simple example, we'll only need float and submit fields (for flower measurements and the submit button). Validation-wise, we only want that no fields are left blank.</p><p>That's all you need to do, and <strong class="source-inline">Flask</strong> will take care of the rest.</p></li>
				<li>Onto the <strong class="source-inline">app.py</strong> now. A couple of changes are required:<ul><li><strong class="source-inline">Flask-WTF</strong> forms need a secret key configured to work. You can add it by accessing the <strong class="source-inline">.env</strong> file. What you declare as a value is entirely arbitrary.</li><li>Our index route now needs to allow for both POST and GET methods since it will handle forms. Inside the <strong class="source-inline">index()</strong> function, you'll have to instantiate the previously written <strong class="source-inline">IrisForm</strong> class and return relevant results if there are no validation errors once the submit button is clicked.<p>You can use the <strong class="source-inline">validate_on_submit()</strong> function to check. If the check is passed, the input data is returned in a heading format (we'll see how to show predictions later). If not, the <strong class="source-inline">index.html</strong> template is returned.</p></li><li>A call to <strong class="source-inline">render_template()</strong> now passes a <a id="_idIndexMarker547"/>parameter to our HTML file – <strong class="source-inline">iris_form</strong>. This gives access to form data to our HTML file. You'll see how to deal with it in a minute.<p>Here's how your file should look once the changes are made:</p><p class="source-code">import os</p><p class="source-code">from flask import Flask, render_template</p><p class="source-code">from forms import IrisForm</p><p class="source-code">from dotenv import load_dotenv</p><p class="source-code">load_dotenv('.env')</p><p class="source-code">app = Flask(__name__)</p><p class="source-code">app.config['SECRET_KEY'] = os.getenv('SECRET_KEY')</p><p class="source-code">@app.route('/', methods=['GET', 'POST'])</p><p class="source-code">def index():</p><p class="source-code">    iris_form = IrisForm()</p><p class="source-code">    if iris_form.validate_on_submit():</p><p class="source-code">        return f'''</p><p class="source-code">                &lt;h3&gt;</p><p class="source-code">                    Sepal Length: {iris_form.sepal_length.data}&lt;br&gt;</p><p class="source-code">                    Sepal Width: {iris_form.sepal_width.data}&lt;br&gt;</p><p class="source-code">                    Petal Length: {iris_form.petal_length.data}&lt;br&gt;</p><p class="source-code">                    Petal Width: {iris_form.petal_width.data}</p><p class="source-code">                &lt;/h3&gt;</p><p class="source-code">            '''</p><p class="source-code">    return render_template('index.html', iris_form=iris_form)</p><p class="source-code">if __name__ == '__main__':</p><p class="source-code">    app.run(host=os.getenv('HOST'), port=os.getenv('PORT'))</p><p>We're almost there. Let's tweak the <strong class="source-inline">index.html</strong> file next.</p></li></ul></li>
				<li><strong class="source-inline">index.html</strong> is the <a id="_idIndexMarker548"/>last file you'll need to tweak to have a working application. The only thing we need inside it is a form that displays the fields declared earlier. It's also <a id="_idIndexMarker549"/>mandatory to protect your app from <strong class="bold">Cross-Site Request Forgery</strong> (<strong class="bold">CSRF</strong>) attacks. To do so, you'll have to place a token before the form fields.<p>Here's how the HTML file should look:</p><p class="source-code">&lt;!DOCTYPE html&gt;</p><p class="source-code">&lt;html lang="en"&gt;</p><p class="source-code">&lt;head&gt;</p><p class="source-code">    &lt;meta charset="UTF-8"&gt;</p><p class="source-code">    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;</p><p class="source-code">    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;</p><p class="source-code">    &lt;title&gt;Iris Predictioner&lt;/title&gt;</p><p class="source-code">&lt;/head&gt;</p><p class="source-code">&lt;body&gt;</p><p class="source-code">    &lt;h1&gt;Welcome to Iris Predictioner&lt;/h1&gt;</p><p class="source-code">    &lt;form method="POST" action="{{ url_for('index') }}"&gt;</p><p class="source-code">        {{ iris_form.csrf_token }}</p><p class="source-code">        {{ iris_form.sepal_length.label }} {{ iris_form.sepal_length(size=18) }}</p><p class="source-code">        &lt;br&gt;</p><p class="source-code">        {{ iris_form.sepal_width.label }} {{ iris_form.sepal_width(size=18) }}</p><p class="source-code">        &lt;br&gt;</p><p class="source-code">        {{ iris_form.petal_length.label }} {{ iris_form.petal_length(size=18) }}</p><p class="source-code">        &lt;br&gt;</p><p class="source-code">        {{ iris_form.petal_width.label }} {{ iris_form.petal_width(size=18) }}</p><p class="source-code">        &lt;br&gt;</p><p class="source-code">        &lt;input type="submit" value="Predict"&gt;</p><p class="source-code">    &lt;/form&gt;</p><p class="source-code">&lt;/body&gt;</p><p class="source-code">&lt;/html&gt;</p><p>As you can see, to access parameters sent from the Python file, you have to surround the code with double curly brackets.</p></li>
				<li>If you were to <a id="_idIndexMarker550"/>launch the application now, here's what you'd see on the screen:</li>
			</ol>
			<div>
				<div id="_idContainer223" class="IMG---Figure">
					<img src="Images/B16954_09_8.jpg" alt="Figure 9.8 – Iris prediction application&#13;&#10;" width="824" height="527"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.8 – Iris prediction application</p>
			<p>And that's a frontend for your machine learning application! It's a bit ugly, but we'll style it later. Let's test the functionality first.</p>
			<p>We don't want the form submitted if any of the input values are empty. Here's what happens if the button is pressed immediately:</p>
			<div>
				<div id="_idContainer224" class="IMG---Figure">
					<img src="Images/B16954_09_9.jpg" alt="Figure 9.9 – Iris prediction application form validation (1)&#13;&#10;" width="802" height="526"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.9 – Iris prediction application form validation (1)</p>
			<p>Validation test 1 – check. Let's see what happens if only one input field remains empty:</p>
			<div>
				<div id="_idContainer225" class="IMG---Figure">
					<img src="Images/B16954_09_10.jpg" alt="Figure 9.10 – Iris prediction application form validation (2)&#13;&#10;" width="731" height="531"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.10 – Iris prediction application form validation (2)</p>
			<p>The same <a id="_idIndexMarker551"/>message occurs, just as you would expect. To conclude, the form can't be submitted if any of the input fields are empty.</p>
			<p>To continue, fill out all of the fields, as shown in the following figure:</p>
			<div>
				<div id="_idContainer226" class="IMG---Figure">
					<img src="Images/B16954_09_11.jpg" alt="Figure 9.11 – Iris prediction application form values&#13;&#10;" width="770" height="501"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.11 – Iris prediction application form values</p>
			<p>If you were to click on the button now, here's the result you'd see:</p>
			<div>
				<div id="_idContainer227" class="IMG---Figure">
					<img src="Images/B16954_09_12.jpg" alt="Figure 9.12 – Iris prediction application results&#13;&#10;" width="764" height="343"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.12 – Iris prediction application results</p>
			<p>So far, everything works, but there's still one step we should do before connecting the application to our Iris prediction API – styling. This step is optional, as the application will still work if you decide to jump to the API connection part immediately.</p>
			<p>Setting adequate styles to your <a id="_idIndexMarker552"/>Flask application will require a bit of work and refactoring. You'll find the entire list of steps here. Keep in mind that this book assumes no HTML and CSS knowledge. You're free to copy and paste the content of these files but are encouraged to explore further on your own:</p>
			<ol>
				<li value="1">Let's start with <strong class="source-inline">app.py</strong>. Instead of returning an <strong class="source-inline">H2</strong> tag with input values printed as a single long string, we'll return an HTML template that will show a table. For now, we'll fill out the input data only and set dummy values for prediction and prediction probability.<p>Here's how the file should look after the changes:</p><p class="source-code">import os</p><p class="source-code">from flask import Flask, render_template</p><p class="source-code">from forms import IrisForm</p><p class="source-code">from dotenv import load_dotenv</p><p class="source-code">load_dotenv('.env')</p><p class="source-code">app = Flask(__name__)</p><p class="source-code">app.config['SECRET_KEY'] = os.getenv('SECRET_KEY')</p><p class="source-code">@app.route('/', methods=['GET', 'POST'])</p><p class="source-code">def index():</p><p class="source-code">    iris_form = IrisForm()</p><p class="source-code">    if iris_form.validate_on_submit():</p><p class="source-code">        <strong class="bold">return render_template(</strong></p><p class="source-code"><strong class="bold">            'predicted.html',</strong></p><p class="source-code"><strong class="bold">            sepal_length=iris_form.sepal_length.data,</strong></p><p class="source-code"><strong class="bold">            sepal_width=iris_form.sepal_width.data,</strong></p><p class="source-code"><strong class="bold">            petal_length=iris_form.petal_length.data,</strong></p><p class="source-code"><strong class="bold">            petal_width=iris_form.petal_width.data,</strong></p><p class="source-code"><strong class="bold">            prediction='Prediction',</strong></p><p class="source-code"><strong class="bold">            probability=100000</strong></p><p class="source-code"><strong class="bold">        )</strong></p><p class="source-code">    return render_template('index.html', iris_form=iris_form)</p><p class="source-code">if __name__ == '__main__':</p><p class="source-code">    app.run(host=os.getenv('HOST'), port=os.getenv('PORT'))</p></li>
				<li>Let's create a <a id="_idIndexMarker553"/>template file while we're at it. Under <strong class="source-inline">/templates</strong>, create a <strong class="source-inline">predicted.html</strong> file. As mentioned earlier, this file will contain a table showing the API response (once we implement it).<p>Here's how the file should look:</p><p class="source-code">&lt;!DOCTYPE html&gt;</p><p class="source-code">&lt;html lang="en"&gt;</p><p class="source-code">&lt;head&gt;</p><p class="source-code">    &lt;meta charset="UTF-8"&gt;</p><p class="source-code">    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;</p><p class="source-code">    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;</p><p class="source-code">    &lt;link rel="stylesheet" href="{{ url_for('static', filename='css/main.css') }}"&gt;</p><p class="source-code">    &lt;title&gt;Iris Predictioner&lt;/title&gt;</p><p class="source-code">&lt;/head&gt;</p><p class="source-code">&lt;body&gt;</p><p class="source-code">    &lt;div class="container"&gt;</p><p class="source-code">        &lt;h1&gt;Predictions:&lt;/h1&gt;</p><p class="source-code">        &lt;table&gt;</p><p class="source-code">            &lt;thead&gt;</p><p class="source-code">              &lt;tr&gt;&lt;th&gt;Attribute&lt;/th&gt;&lt;th&gt;Value&lt;/th&gt;&lt;/tr&gt;</p><p class="source-code">            &lt;/thead&gt;</p><p class="source-code">            &lt;tbody&gt;</p><p class="source-code">              &lt;tr&gt;&lt;td&gt;Sepal Length&lt;/td&gt;&lt;td&gt;{{ sepal_length }}&lt;/td&gt;&lt;/tr&gt;</p><p class="source-code">              &lt;tr&gt;&lt;td&gt;Sepal Width&lt;/td&gt;&lt;td&gt;{{ sepal_width }}&lt;/td&gt;&lt;/tr&gt;</p><p class="source-code">              &lt;tr&gt;&lt;td&gt;Petal Length&lt;/td&gt;td&gt;{{ petal_length }}&lt;/td&gt;&lt;/tr&gt;</p><p class="source-code">              &lt;tr&gt;&lt;td&gt;Petal Width&lt;/td&gt;&lt;td&gt;{{ petal_width }}&lt;/td&gt;&lt;/tr&gt;</p><p class="source-code">              &lt;tr&gt;&lt;td&gt;Prediction&lt;/td&gt;&lt;td&gt;{{ prediction }}&lt;/td&gt;&lt;/tr&gt;</p><p class="source-code">              &lt;tr&gt;&lt;td&gt;Probability&lt;/td&gt;&lt;td&gt;{{ probability }}&lt;/td&gt;&lt;/tr&gt;</p><p class="source-code">            &lt;/tbody&gt;</p><p class="source-code">        &lt;/table&gt;</p><p class="source-code">    &lt;/div&gt;</p><p class="source-code">&lt;/body&gt;</p><p class="source-code">&lt;/html&gt;</p><p>As you can see, we've utilized the power of parameter passing to show the data going in and out of the predictive model. If you're wondering what the deal is with CSS file linking in the document head – don't worry about it for now. We still need to work on one thing before dealing with CSS.</p></li>
				<li>Finally, let's <a id="_idIndexMarker554"/>reformat <strong class="source-inline">index.html</strong>. This file will need only minor changes – a couple of CSS classes and a couple of <strong class="source-inline">div</strong> elements. Here is the entire code snippet for the reformatted version:<p class="source-code">&lt;!DOCTYPE html&gt;</p><p class="source-code">&lt;html lang="en"&gt;</p><p class="source-code">&lt;head&gt;</p><p class="source-code">    &lt;meta charset="UTF-8"&gt;</p><p class="source-code">    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;</p><p class="source-code">    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;</p><p class="source-code"><strong class="bold">    &lt;link rel="stylesheet" href="{{ url_for('static', filename='css/main.css') }}"&gt;</strong></p><p class="source-code">    &lt;title&gt;Iris Predictioner&lt;/title&gt;</p><p class="source-code">&lt;/head&gt;</p><p class="source-code">&lt;body&gt;</p><p class="source-code">    <strong class="bold">&lt;div class="container"&gt;</strong></p><p class="source-code">        &lt;h1&gt;Welcome to Iris Predictioner&lt;/h1&gt;</p><p class="source-code">        &lt;form method="POST" action="{{ url_for('index') }}"&gt;</p><p class="source-code">            {{ iris_form.csrf_token }}</p><p class="source-code">            <strong class="bold">&lt;div class="single-input"&gt;</strong></p><p class="source-code">                {{ iris_form.sepal_length.label }} {{ iris_form.sepal_length(size=18) }}</p><p class="source-code">            <strong class="bold">&lt;/div&gt;</strong></p><p class="source-code"><strong class="bold">            &lt;div class="single-input"&gt;</strong></p><p class="source-code">                {{ iris_form.sepal_width.label }} {{ iris_form.sepal_width(size=18) }}</p><p class="source-code">            <strong class="bold">&lt;/div&gt;</strong></p><p class="source-code"><strong class="bold">            &lt;div class="single-input"&gt;</strong></p><p class="source-code">                {{ iris_form.petal_length.label }} {{ iris_form.petal_length(size=18) }}</p><p class="source-code">            <strong class="bold">&lt;/div&gt;</strong></p><p class="source-code"><strong class="bold">            &lt;div class="single-input"&gt;</strong></p><p class="source-code">                {{ iris_form.petal_width.label }} {{ iris_form.petal_width(size=18) }}</p><p class="source-code">            <strong class="bold">&lt;/div&gt;</strong></p><p class="source-code"><strong class="bold">            &lt;input class="btn-submit" type="submit" value="Predict"&gt;</strong></p><p class="source-code">        &lt;/form&gt;</p><p class="source-code">    <strong class="bold">&lt;/div&gt;</strong></p><p class="source-code">&lt;/body&gt;</p><p class="source-code">&lt;/html&gt;</p></li>
				<li>We're almost <a id="_idIndexMarker555"/>there. So far, you've refactored every file that needed refactoring, and now you'll create an additional folder and file. Inside the root directory, create a folder named <strong class="source-inline">static</strong>. Once created, make an additional folder inside it called <strong class="source-inline">css</strong>. This folder will contain all stylings for our application. Inside the <strong class="source-inline">css</strong> folder, create a file called <strong class="source-inline">main.css</strong>.<p>To summarize, here's how your directory structure should look once you have created these folders and file:</p><div id="_idContainer228" class="IMG---Figure"><img src="Images/B16954_09_13.jpg" alt="Figure 9.13 – New directory structure&#13;&#10;" width="460" height="368"/></div><p class="figure-caption">Figure 9.13 – New directory structure</p><p>The <strong class="source-inline">main.css</strong> file is already linked to your HTML files, if you remember. If not, please take a look inside the <strong class="source-inline">&lt;head&gt;&lt;/head&gt;</strong> tag of the HTML files – you'll find the link there.</p><p>Here's the code for the entire <strong class="source-inline">main.css</strong> file:</p><p class="source-code">@import url('https://fonts.googleapis.com/css2?family=Open+Sans:wght@400;600&amp;display=swap');</p><p class="source-code">* { margin: 0; padding: 0; box-sizing: border-box;</p><p class="source-code">    font-family: 'Open Sans', sans-serif; }</p><p class="source-code">body { background-color: #f2f2f2; }</p><p class="source-code">.container { width: 800px; height: 100vh; margin: 0 auto;</p><p class="source-code">    background-color: #ffffff; padding: 0 35px; }</p><p class="source-code">.container &gt; h1 { padding: 35px 0; font-size: 36px;</p><p class="source-code">    font-weight: 600; }</p><p class="source-code">.single-input { display: flex; flex-direction: column;</p><p class="source-code">    margin-bottom: 20px; }</p><p class="source-code">.single-input label { font-weight: 600; }</p><p class="source-code">.single-input label::after { content: ":" }</p><p class="source-code">.single-input input { height: 35px; line-height: 35px;</p><p class="source-code">    padding-left: 10px; }</p><p class="source-code">.btn-submit { width: 100%; height: 35px;</p><p class="source-code">    background-color: #f2f2f2; font-weight: 600;</p><p class="source-code">    cursor: pointer; border: 2px solid #dddddd;</p><p class="source-code">    border-radius: 8px; }</p><p class="source-code">table { font-size: 18px; width: 100%; text-align: left; }</p><p>And we're done. Let's run the application to see how it looks now.</p></li>
				<li>If you were to re-run the <a id="_idIndexMarker556"/>application now, you'd see the stylings taking effect. The following figure shows how the input form looks:</li>
			</ol>
			<div>
				<div id="_idContainer229" class="IMG---Figure">
					<img src="Images/B16954_09_14.jpg" alt="Figure 9.14 – Styled Iris prediction application&#13;&#10;" width="1173" height="782"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.14 – Styled Iris prediction application</p>
			<p>The application by no means looks perfect now, but it's at least in a presentable form. Let fill it out as shown in the following figure:</p>
			<div>
				<div id="_idContainer230" class="IMG---Figure">
					<img src="Images/B16954_09_15.jpg" alt="Figure 9.15 – Styled Iris prediction application (2)&#13;&#10;" width="1185" height="778"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.15 – Styled Iris prediction application (2)</p>
			<p>And finally, let's <a id="_idIndexMarker557"/>click on the <strong class="bold">Predict</strong> button to see how the other page looks:</p>
			<div>
				<div id="_idContainer231" class="IMG---Figure">
					<img src="Images/B16954_09_16.jpg" alt="Figure 9.16 – Iris prediction application predictions&#13;&#10;" width="1178" height="542"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.16 – Iris prediction application predictions</p>
			<p>Let's call it a <a id="_idIndexMarker558"/>day stylings-wise. The application is at a pretty decent point now, but you're free to tweak it further.</p>
			<p>And there you have it – how to build and style a <strong class="source-inline">Flask</strong> application built around a machine learning model. The next section will connect the app to our API, making the app fully functional. See you there.</p>
			<h1 id="_idParaDest-105"><a id="_idTextAnchor106"/>Making predictions in a GUI environment</h1>
			<p>Welcome to the last section of the book. This section will tie our simple web application to an already-deployed machine learning API. This closely resembles a production environment, where <a id="_idIndexMarker559"/>you have one or more machine learning models deployed, and the application development team wants to use them in their application. The only difference is that you're both the data science and application development team.</p>
			<p>Once again, we'll have to make a couple of changes to the application structure:</p>
			<ol>
				<li value="1">Let's start with the simpler part. Inside the root directory, create a Python file called <strong class="source-inline">predictor.py</strong>. This file will hold a single function that implements the logic discussed at the beginning of this chapter when we made predictions in the notebook environment.<p>Put simply, this function has to make a POST request to the API and return a response in JSON format.</p><p>Here's the entire code snippet for the file:</p><p class="source-code">import os</p><p class="source-code">import json</p><p class="source-code">import requests</p><p class="source-code">from dotenv import load_dotenv</p><p class="source-code">load_dotenv('.env')</p><p class="source-code">def predict(sepal_length, sepal_width, petal_length, petal_width):</p><p class="source-code">    URL = os.getenv('API_ENDPOINT')</p><p class="source-code">    req = requests.post(</p><p class="source-code">        url=URL,</p><p class="source-code">        json={</p><p class="source-code">            'SepalLength': sepal_length,</p><p class="source-code">            'SepalWidth': sepal_width,</p><p class="source-code">            'PetalLength': petal_length,</p><p class="source-code">            'PetalWidth': petal_width</p><p class="source-code">        }</p><p class="source-code">    )</p><p class="source-code">    response = json.loads(req.content)</p><p class="source-code">    return response</p><p>Keep in mind that the URL parameter's value will be different on your machine, so please change it accordingly.</p><p>There's no point in <a id="_idIndexMarker560"/>further explaining this code snippet, as it is nearly identical to the code you've seen and written before.</p></li>
				<li>Let's make a couple of changes in <strong class="source-inline">app.py</strong> now. We'll import this file and call the <strong class="source-inline">predict()</strong> function right after the input fields are validated. Once the response is returned, its values are passed as parameters to the corresponding field of the <strong class="source-inline">return</strong> statement.<p>Here is the entire code snippet for the <strong class="source-inline">app.py</strong> file:</p><p class="source-code"><strong class="bold">import os</strong></p><p class="source-code"><strong class="bold">import numpy as np</strong></p><p class="source-code">from flask import Flask, render_template</p><p class="source-code">from forms import IrisForm</p><p class="source-code"><strong class="bold">from predictor import predict</strong></p><p class="source-code">from dotenv import load_dotenv</p><p class="source-code">load_dotenv('.env')</p><p class="source-code">app = Flask(__name__)</p><p class="source-code">app.config['SECRET_KEY'] = os.getenv('SECRET_KEY')</p><p class="source-code">@app.route('/', methods=['GET', 'POST'])</p><p class="source-code">def index():</p><p class="source-code">    iris_form = IrisForm()</p><p class="source-code">    if iris_form.validate_on_submit():</p><p class="source-code"><strong class="bold">        pred_response = predict(</strong></p><p class="source-code"><strong class="bold">            sepal_length=iris_form.sepal_length.data,</strong></p><p class="source-code"><strong class="bold">            sepal_width=iris_form.sepal_width.data,</strong></p><p class="source-code"><strong class="bold">            petal_length=iris_form.petal_length.data,</strong></p><p class="source-code"><strong class="bold">            petal_width=iris_form.petal_width.data</strong></p><p class="source-code"><strong class="bold">        )</strong></p><p class="source-code">        return render_template(</p><p class="source-code">            'predicted.html',</p><p class="source-code">            sepal_length=pred_response['In_PetalLength'],</p><p class="source-code">            sepal_width=pred_response['In_PetalWidth'],</p><p class="source-code">            petal_length=pred_response['In_SepalLength'],</p><p class="source-code">            petal_width=pred_response['In_SepalWidth'],</p><p class="source-code">            <strong class="bold">prediction=pred_response['Prediction'],</strong></p><p class="source-code"><strong class="bold">            probability=f"{np.round((pred_response['Probability'] * 100), 2)}%"</strong></p><p class="source-code"><strong class="bold">        )</strong></p><p class="source-code">    return render_template('index.html', iris_form=iris_form)</p><p class="source-code">if __name__ == '__main__':</p><p class="source-code">    app.run(host=os.getenv('HOST'), port=os.getenv('PORT'))</p><p>As you can see, the <a id="_idIndexMarker561"/>prediction probability is converted to a percentage and rounded to two decimal points. The only reason for doing so is to have nicer-formatted output in the application.</p></li>
				<li>And now the fun part – testing. Open the application and enter some data into the form. Here's an example:</li>
			</ol>
			<div>
				<div id="_idContainer232" class="IMG---Figure">
					<img src="Images/B16954_09_17.jpg" alt="Figure 9.17 – Iris prediction application final test&#13;&#10;" width="1172" height="768"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.17 – Iris prediction application final test</p>
			<p>Once you <a id="_idIndexMarker562"/>click on the <strong class="bold">Predict</strong> button, you'll see the following results on the screen:</p>
			<div>
				<div id="_idContainer233" class="IMG---Figure">
					<img src="Images/B16954_09_18.jpg" alt="Figure 9.18 – Iris prediction application final results&#13;&#10;" width="1169" height="537"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.18 – Iris prediction application final results</p>
			<p>And there you have it – a complete and fully working GUI web application based on a deployed machine learning model.</p>
			<p>Not including the summary that follows, this was the last section of the chapter, but also the entire book. You now know how to deploy machine learning models and build simple web applications around a deployed model. Congratulations!</p>
			<h1 id="_idParaDest-106"><a id="_idTextAnchor107"/>Summary</h1>
			<p>This chapter fell into the category of extensive hands-on chapters, but I hope you've managed to follow along. If you have, you've learned a lot – from how to make predictions in a notebook environment to making predictions in a simple and custom-built web application.</p>
			<p>Not only that, but you've also completed the entire book. Congratulations! You've learned a lot throughout these nine chapters. We started with the basics of machine learning through basic regression and classification examples, and from there slowly built our knowledge of TPOT. You've also learned how TPOT works with parallel training and with neural networks. But probably the most important new skill you've acquired is model deployment. Without it, your models are useless, as no one can use them to create value.</p>
			<p>As always, feel free to explore TPOT and every amazing functionality it has to offer on your own. This book should serve you as a great starting point, as it took you from zero to building web applications around your deployed automated machine learning models in only a couple of hundred pages. Now that's something you can be proud of!</p>
			<h1 id="_idParaDest-107"><a id="_idTextAnchor108"/>Q&amp;A</h1>
			<ol>
				<li value="1">Which Python library can you use to make requests to deployed REST APIs?</li>
				<li>In which format is data provided when making a POST request?</li>
				<li>Name the Flask extension used to build and work with forms.</li>
				<li>Why is it important to validate web application forms if we're talking about data going into a machine learning model?</li>
				<li>Can you pass parameters to HTML template files through Flask? If so, how can you display their values in HTML?</li>
				<li>Explain the process of linking CSS files to Flask applications.</li>
				<li>Explain why there's no point in leaving machine learning models sitting idle on your PC.</li>
			</ol>
		</div>
	</div></body></html>