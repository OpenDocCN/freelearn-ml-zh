["```py\n\nimport numpy as np \n\nseed = 1234 \n\nnp.random.seed(seed)\n\n```", "```py\n\nfrom sklearn.datasets import load_wine \n\nx,y = load_wine(return_X_y = True)\n\n```", "```py\n\nx = x[:59+71] \n\ny = y[:59+71]\n\n```", "```py\n\nfrom sklearn.model_selection import train_test_split \n\nx_tr, x_test, y_tr, y_test = train_test_split(x, y, train_size = 0.9)\n\n```", "```py\n\nfrom sklearn.preprocessing import MaxAbsScaler \n\nscaler = MaxAbsScaler() \n\nx_tr = scaler.fit_transform(x_tr)\n\n```", "```py\n\nx_test = scaler.transform(x_test) \n\nx_test = np.clip(x_test,0,1)\n\n```", "```py\n\nimport pennylane as qml \n\nnqubits = 4 \n\ndev = qml.device(\"lightning.qubit\", wires = nqubits) \n\n@qml.qnode(dev) \n\ndef kernel_circ(a, b): \n\n    qml.AmplitudeEmbedding( \n\n        a, wires=range(nqubits), pad_with=0, normalize=True) \n\n    qml.adjoint(qml.AmplitudeEmbedding( \n\n        b, wires=range(nqubits), pad_with=0, normalize=True)) \n\n    return qml.probs(wires = range(nqubits))\n\n```", "```py\n\nfrom sklearn.svm import SVC \n\ndef qkernel(A, B): \n\n    return np.array([[kernel_circ(a, b)[0] for b in B] for a in A]) \n\nsvm = SVC(kernel = qkernel).fit(x_tr, y_tr)\n\n```", "```py\n\nfrom sklearn.metrics import accuracy_score \n\nprint(accuracy_score(svm.predict(x_test), y_test))\n\n```", "```py\n\nfrom sklearn.decomposition import PCA \n\npca = PCA(n_components = 8) \n\nxs_tr = pca.fit_transform(x_tr) \n\nxs_test = pca.transform(x_test)\n\n```", "```py\n\nnqubits = 8 \n\ndev = qml.device(\"lightning.qubit\", wires=nqubits) \n\n@qml.qnode(dev) \n\ndef kernel_circ(a, b): \n\n    qml.AngleEmbedding(a, wires=range(nqubits)) \n\n    qml.adjoint(qml.AngleEmbedding(b, wires=range(nqubits))) \n\n    return qml.probs(wires = range(nqubits))\n\n```", "```py\n\nsvm = SVC(kernel = qkernel).fit(xs_tr, y_tr) \n\nprint(accuracy_score(svm.predict(xs_test), y_test))\n\n```", "```py\n\nfrom itertools import combinations \n\ndef ZZFeatureMap(nqubits, data): \n\n    # Number of variables that we will load: \n\n    # could be smaller than the number of qubits. \n\n    nload = min(len(data), nqubits) \n\n    for i in range(nload): \n\n        qml.Hadamard(i) \n\n        qml.RZ(2.0 * data[i], wires = i) \n\n    for pair in list(combinations(range(nload), 2)): \n\n        q0 = pair[0] \n\n        q1 = pair[1] \n\n        qml.CZ(wires = [q0, q1]) \n\n        qml.RZ(2.0 * (np.pi - data[q0]) * \n\n            (np.pi - data[q1]), wires = q1) \n\n        qml.CZ(wires = [q0, q1])\n\n```", "```py\n\nnqubits = 4 \n\ndev = qml.device(\"lightning.qubit\", wires = nqubits) \n\n@qml.qnode(dev) \n\ndef kernel_circ(a, b): \n\n    ZZFeatureMap(nqubits, a) \n\n    qml.adjoint(ZZFeatureMap)(nqubits, b) \n\n    return qml.probs(wires = range(nqubits)) \n\nsvm = SVC(kernel=qkernel).fit(xs_tr, y_tr) \n\nprint(accuracy_score(svm.predict(xs_test), y_test))\n\n```", "```py\n\nfrom sklearn.metrics import accuracy_score\n\n```", "```py\n\nfrom qiskit import *\n\n```", "```py\n\nfrom qiskit.circuit import Parameter \n\nparameter = Parameter(\"x\") \n\nqc = QuantumCircuit(1) \n\nqc.rx(parameter, 0)\n\n```", "```py\n\nfrom qiskit.circuit import ParameterVector \n\nparameter = ParameterVector(\"x\", length = 2) \n\nqc = QuantumCircuit(2) \n\nqc.rx(parameter[0], 0) \n\nqc.rx(parameter[1], 1)\n\n```", "```py\n\nfrom qiskit.circuit.library import ZZFeatureMap \n\nzzfm = ZZFeatureMap(8)\n\n```", "```py\n\nfrom qiskit_machine_learning.kernels import QuantumKernel \n\nfrom qiskit.providers.aer import AerSimulator \n\nqkernel = QuantumKernel(feature_map = zzfm, \n\n            quantum_instance = AerSimulator())\n\n```", "```py\n\nfrom qiskit_machine_learning.algorithms import QSVC \n\nqsvm = QSVC(quantum_kernel = qkernel) \n\nqsvm.fit(xs_tr, y_tr)\n\n```", "```py\n\nprint(accuracy_score(qsvm.predict(xs_test), y_test))\n\n```", "```py\n\nprovider = IBMQ.load_account()\n\n```", "```py\n\nfrom qiskit.providers.ibmq import * \n\ndev_list = provider.backends( \n\n    filters = lambda x: x.configuration().n_qubits >= 7, \n\n    simulator = False) \n\ndev = least_busy(dev_list)\n\n```", "```py\n\nfrom sklearn.decomposition import PCA \n\npca = PCA(n_components = 7) \n\nxss_tr = pca.fit_transform(x_tr) \n\nxss_test = pca.transform(x_test)\n\n```", "```py\n\nzzfm = ZZFeatureMap(7) \n\nqkernel = QuantumKernel(feature_map = zzfm, quantum_instance = dev) \n\nqsvm = QSVC(quantum_kernel = qkernel) \n\nqsvm.fit(xss_tr, y_tr)\n\n```"]