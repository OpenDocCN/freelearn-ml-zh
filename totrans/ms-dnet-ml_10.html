<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;10.&#xA0;Big Data and IoT"><div class="book" id="1LCVG2-a18db0be6c20485ba81f22e43ca13055"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch10" class="calibre1"/>Chapter 10. Big Data and IoT</h1></div></div></div><p class="calibre6">Up to this point, this book has followed a pattern of extracting data, cleaning and shaping the data, and then building machine learning models. A common element in all of the examples is that when we've extracted data, we have brought it from the server (or other external sources) locally to our machine. This means our analysis is confined to whatever data fits in the memory on our local machines. While this is good for small- and medium-sized datasets, there are plenty of datasets and questions that do not fit in RAM. The last couple of years have seen the rise of big data, where we can ask questions of datasets that are too large, unstructured, or fast-moving to be analyzed using our conventional machine learning techniques. One domain that fits well with big data is the proliferation of small, inexpensive devices that can send a vast quantity of data to a server for analysis. These <span class="strong"><strong class="calibre7">Internet of Things</strong></span> (<span class="strong"><strong class="calibre7">IoT</strong></span>) devices have the potential to reshape the world around us in ways that typical computers and smartphones cannot. In this chapter, let's run though a potential big data and the Internet of Things scenario at AdventureWorks.</p></div>

<div class="book" title="Chapter&#xA0;10.&#xA0;Big Data and IoT">
<div class="book" title="AdventureWorks and the Internet of Bikes"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch10lvl1sec49" class="calibre1"/>AdventureWorks and the Internet of Bikes</h1></div></div></div><p class="calibre6">One day you are sitting in<a id="id478" class="calibre1"/> your office, your boss comes in and says, "Since you did such a great job on helping reduce our scrap rate, we would <a id="id479" class="calibre1"/>like you to work on a proof of concept with our research and development department. Last month, the management team went to a conference about the Internet of Things and we think we have an interesting use case: the <span class="strong"><strong class="calibre7">Internet of Bikes</strong></span> (<span class="strong"><strong class="calibre7">IoB</strong></span>). We are going to put sensors on a bike model that can read certain diagnostic information about the bike and its riding patterns. We think that a certain segment of our customers would love to have a "smart bike".</p><p class="calibre6">You head over to the research and <a id="id480" class="calibre1"/>development area, where they have tricked out a bike like this:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Tire pressure sensors</li><li class="listitem">Speedometer sensor</li><li class="listitem">Gear sensor</li><li class="listitem">A Raspberry Pi 2 mounted under the seat</li><li class="listitem">A wireless Ethernet shield attached to the PI</li><li class="listitem">A GPS shield attached to the PI<div class="mediaobject"><img src="../images/00155.jpeg" alt="AdventureWorks and the Internet of Bikes" class="calibre8"/></div><p class="calibre15"> </p></li></ul></div><p class="calibre6">The head of the R&amp;D department tells you, "We are trying to find cost-effective wireless sensors. Until then, we are stringing wires through the frame's tube to the PI. We initially thought of using the bike rider's phone as the CPU, but we went with the PI because it is less bulky and weighs much less than a phone—bike riders are very concerned about weight. The PI gets its power from a rechargeable battery and when the bike gets docked at home to recharge, all <a id="id481" class="calibre1"/>of its on-board data is uploaded to our servers at that time. We want to transmit data from the PI to our servers only at the bike's home for security reasons and so the riders are not hit with data plan limitations by using cell networks."</p><p class="calibre6">The head of R&amp;D continues, "We envision a dashboard for people to keep track of their cycling route, their biking habits, and whatnot. Where you come in is on the machine learning piece. We need a way of analyzing these huge amounts of data we are going to collect to provide an enhanced customer experience when they are riding this bike."</p></div></div>

<div class="book" title="Chapter&#xA0;10.&#xA0;Big Data and IoT">
<div class="book" title="AdventureWorks and the Internet of Bikes">
<div class="book" title="Data considerations"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch10lvl2sec83" class="calibre1"/>Data considerations</h2></div></div></div><p class="calibre6">You look at the data (called telemetry) coming from the bike as two different problems. Problem one is getting the data to the server from individual bikes and problem two is having the data in a format that allows for machine learning on a large scale. You decide to solve both those<a id="id482" class="calibre1"/> problems by using the Microsoft Azure IoT suite to stream the data from the bikes into the current Northwind SQL Azure database. You add a table called <code class="literal">telemetry</code> and add a foreign key to <code class="literal">PurchaseOrderHeader</code>.</p><p class="calibre6">You then populate the table with some data from riders in the AdventureWorks Early Adopter program. Although there is not much data in the table to start, it is expected to grow rapidly. The level of atomacy of the table is a single reading that occurs about every second. That means for a 30-minute bike ride, we capture 1,800 rows of data. Since we have about 200 bike riders in our early adopter program, we will generate about 360,000 rows of data every time they take a ride. This one ride generates about as much data as the current AdventureWorks database maintains for the entire company. After one month of data where these bikers go out about every other day, we will have 5.4 million rows of data.</p><p class="calibre6">One of the data elements that we are capturing is latitude and longitude. Fortunately, all of our bike riders<a id="id483" class="calibre1"/> live in Enderlin, North Dakota, and all travel on the straightest road in the United States, Highway 46 (<a class="calibre1" href="https://en.wikipedia.org/wiki/North_Dakota_Highway_46_(54st_SE)">https://en.wikipedia.org/wiki/North_Dakota_Highway_46_(54st_SE)</a>). This means our longitude does not change. Also, we are capturing feet per second as a speed gauge so we can easily compare how riders perform against each other.</p><p class="calibre6">With the data in place, let's take a look at how to analyze data at scale.</p></div></div></div>

<div class="book" title="Chapter&#xA0;10.&#xA0;Big Data and IoT">
<div class="book" title="AdventureWorks and the Internet of Bikes">
<div class="book" title="MapReduce"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch10lvl2sec84" class="calibre1"/>MapReduce</h2></div></div></div><p class="calibre6">Open Visual Studio and <a id="id484" class="calibre1"/>create a new Visual F# Windows Library called <code class="literal">AdventureWorks.IOB</code>:</p><div class="mediaobject"><img src="../images/00156.jpeg" alt="MapReduce" class="calibre8"/></div><p class="calibre9"> </p><p class="calibre6">Go into the NuGet Package <a id="id485" class="calibre1"/>Manager Console and enter this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">PM&gt; install-package Accord.MachineLearning</strong></span>
</pre></div><p class="calibre6">Next, rename <code class="literal">script1.fsx</code> to <code class="literal">MapReduce.fsx</code>. Now, enter in the same code from <a class="calibre1" title="Chapter 5. Time Out – Obtaining Data" href="part0036_split_000.html#12AK81-a18db0be6c20485ba81f22e43ca13055">Chapter 5</a>, <span class="strong"><em class="calibre11">Time Out – Obtaining Data</em></span>, that created a k-NN:</p><div class="informalexample"><pre class="programlisting">#r"../packages/Accord.3.0.2/lib/net40/Accord.dll"
#r"../packages/Accord.Math.3.0.2/lib/net40/Accord.Math.dll"
#r"../packages/Accord.Statistics.3.0.2/lib/net40/Accord.Statistics.dll"
#r"../packages/Accord.MachineLearning.3.0.2/lib/net40/Accord.MachineLearning.dll"

open Accord
open System
open Accord.Math
open Accord.MachineLearning

let inputs = [|[|5.0;1.0|];[|4.5;1.5|];[|5.1;0.75|];[|1.0;3.5|];[|0.5;4.0|];[|1.25;4.0|]|]
let outputs = [|1;1;1;0;0;0|]

let classes = 2
let k = 3
let knn = new KNearestNeighbors(k, classes, inputs, outputs)

let input = [|5.0;0.5|]
let output = knn.Compute(input)</pre></div><p class="calibre6">Sending this to the FSI gives us the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">val inputs : float [] [] =</strong></span>
<span class="strong"><strong class="calibre7">  [|[|5.0; 1.0|]; [|4.5; 1.5|]; [|5.1; 0.75|]; [|1.0; 3.5|]; [|0.5; 4.0|];</strong></span>
<span class="strong"><strong class="calibre7">    [|1.25; 4.0|]|]</strong></span>
<span class="strong"><strong class="calibre7">val outputs : int [] = [|1; 1; 1; 0; 0; 0|]</strong></span>
<span class="strong"><strong class="calibre7">val classes : int = 2</strong></span>
<span class="strong"><strong class="calibre7">val k : int = 3</strong></span>
<span class="strong"><strong class="calibre7">val knn : Accord.MachineLearning.KNearestNeighbors</strong></span>
<span class="strong"><strong class="calibre7">val input : float [] = [|5.0; 0.5|]</strong></span>
<span class="strong"><strong class="calibre7">val output : int = 1</strong></span>
</pre></div><p class="calibre6">Notice this line:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">let output = knn.Compute(input)</strong></span>
</pre></div><p class="calibre6">We called <code class="literal">knn.Compute</code> to do a calculation on a single input after the k-NN model was created.</p><p class="calibre6">This works well enough or a single calculation, but what if we want to do thousands of calculations? For example, let's call <code class="literal">knn.Compute()</code> on 250,000 random samples. After we finish all 250,000 calculations, let's add up the results and then divide that total by the number of observations and see if the dataset is biased towards a particular category.</p><p class="calibre6">First, let's create a<a id="id486" class="calibre1"/> function that will create a random input:</p><div class="informalexample"><pre class="programlisting">let createInput i =
    let random = Random(i)
    [|float(random.Next(0,6)) + Math.Round(random.NextDouble(),2);
      float(random.Next(0,6)) + Math.Round(random.NextDouble(),2);|]</pre></div><p class="calibre6">Sending this to the FSI gives us the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">val createInput : i:int -&gt; float []</strong></span>
</pre></div><p class="calibre6">Next, let's create an array of 250,000 items and populate it with the random values:</p><div class="informalexample"><pre class="programlisting">let observations = Array.zeroCreate&lt;int&gt; 250000
let inputs' = 
    observations 
    |&gt;Array.mapi (fun idx _ -&gt; createInput idx)</pre></div><p class="calibre6">Sending this to the REPL gives us the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">val observations : int [] =</strong></span>
<span class="strong"><strong class="calibre7">  [|0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0;</strong></span>
<span class="strong"><strong class="calibre7">    0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0;</strong></span>
<span class="strong"><strong class="calibre7">    0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0;</strong></span>
<span class="strong"><strong class="calibre7">    0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0;</strong></span>
<span class="strong"><strong class="calibre7">    ...|]</strong></span>
<span class="strong"><strong class="calibre7">val inputs' : float [] [] =</strong></span>
<span class="strong"><strong class="calibre7">  [|[|4.82; 4.56|]; [|1.11; 2.77|];</strong></span>
</pre></div><p class="calibre6">With our data ready, let's <a id="id487" class="calibre1"/>do our calculation. I added a timer to give us an idea of the performance hit for running 250,000 records:</p><div class="informalexample"><pre class="programlisting">let stopwatch = System.Diagnostics.Stopwatch()
stopwatch.Start()
let predictionTotal = 
    inputs' 
    |&gt;Seq.map(fun i -&gt; knn.Compute i)
    |&gt;Seq.reduce(fun acc i -&gt; acc + i)

let predictionBias = float predictionTotal/float 250000
stopwatch.Stop()
stopwatch.Elapsed.TotalSeconds</pre></div><p class="calibre6">Sending this to the FSI will give us the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">val stopwatch : Diagnostics.Stopwatch</strong></span>
<span class="strong"><strong class="calibre7">val predictionTotal : int = 109826</strong></span>
<span class="strong"><strong class="calibre7">val predictionBias : float = 0.439304</strong></span>
<span class="strong"><strong class="calibre7">val it : float = 0.1787221</strong></span>
</pre></div><p class="calibre6">The interesting piece of code is this:</p><div class="informalexample"><pre class="programlisting">let predictionTotal = 
    inputs' 
    |&gt;Seq.map(fun i -&gt; knn.Compute i)
    |&gt;Seq.reduce(fun acc i -&gt; acc + i)</pre></div><p class="calibre6">Notice that we are mapping and reducing. Mapping is old hat to you by now, but you might not be familiar with reducing. Reduce is a high-ordered function that takes in two parameters: an accumulator and a value. Both parameters are of the same type (in this case, <code class="literal">int</code>). What reduce is doing is going through each of the items of the array and applying a function. It then takes the results of that calculation and adds it to the accumulator. In this case, the accumulator <code class="literal">acc</code> is added to the value from the <code class="literal">array (i)</code>.</p><p class="calibre6">Visually, this looks like the following:</p><div class="mediaobject"><img src="../images/00157.jpeg" alt="MapReduce" class="calibre8"/></div><p class="calibre9"> </p><p class="calibre6">You might have heard the expression map/reduce used in the context of big data. That's because some of the pioneers in big data analytics such as Google and Yahoo created Hadoop based on the concept of map/reduce. Hadoop is a platform for big data, including a filesystem (HDFS), query languages (Hive and PIG), and machine learning (Mahdut). Typically, when you hear people talking about Hadoop and map/reduce, they are talking about a specialized implementation using key/value pairs. Also, usually the <span class="strong"><em class="calibre11">map</em></span> part of map/reduce is distributed across thousands of commodity machines. The <span class="strong"><em class="calibre11">reduce</em></span> can be distributed depending on<a id="id488" class="calibre1"/> the nature of the function that is passed to reduce. If the function does a <code class="literal">groupBy</code> or some other calculation on a section of the entire dataset, it can be distributed. In this chapter, we are going to distribute map and are not going to distribute reduce.</p><p class="calibre6">To illustrate why map/reduce is popular for big data, let's distribute the mapping across all of the cores on my machine. This can simulate the way Hadoop distributes processing across thousands of networked computers. Go into Visual Studio and open the NuGet Package Manager and enter this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">PM&gt; Install-Package FSharp.Collections.ParallelSeq</strong></span>
</pre></div><p class="calibre6">Next, go into <code class="literal">MapReduce.fsx</code> and enter this at the bottom:</p><div class="informalexample"><pre class="programlisting">#r"../packages/FSharp.Collections.ParallelSeq.1.0.2/lib/net40/FSharp.Collections.ParallelSeq.dll"
open FSharp.Collections.ParallelSeq

let stopwatch' = new System.Diagnostics.Stopwatch()
stopwatch'.Start()
let predictionTotal' = 
    inputs' 
    |&gt;PSeq.map(fun i -&gt; knn.Compute i)
    |&gt;Seq.reduce(fun acc i -&gt; acc + i)
let predictionBias' = float predictionTotal'/float 250000
stopwatch'.Stop()
stopwatch'.Elapsed.TotalSeconds</pre></div><p class="calibre6">Sending this to the FSI gives us the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">val stopwatch' : Diagnostics.Stopwatch</strong></span>
<span class="strong"><strong class="calibre7">val predictionTotal' : int = 109826</strong></span>
<span class="strong"><strong class="calibre7">val predictionBias' : float = 0.439304</strong></span>
<span class="strong"><strong class="calibre7">val it : float = 0.0700362</strong></span>
</pre></div><p class="calibre6">Notice that the code is identical to the preceding code except that we are now implementing <code class="literal">PSeq</code> for the mapping function, so we are distributing it across all of my cores. You can see that the time dropped significantly by implementing parallelism to the mapping function.</p><p class="calibre6">If you are thinking we have an answer for our big data scenario, you are incorrect. Look what happens when we try and do 5.4 million records:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">System.OutOfMemoryException: Exception of type 'System.OutOfMemoryException' was thrown.</strong></span>
<span class="strong"><strong class="calibre7">&gt;    at Microsoft.FSharp.Collections.ArrayModule.ZeroCreate[T](Int32 count)</strong></span>
</pre></div><p class="calibre6">We can't analyze the data <a id="id489" class="calibre1"/>only with my machine. To do map/reduce and distribute the mapping across many machines, we could implement Hadoop or its faster cousin, Spark, but then we would have to leave Visual Studio and .NET, and journey into the JVM. Also, we would have to learn Java/Python/Scala and be unable to easily integrate with our existing .NET applications. As an alternative, we could use the Azure implementation called HDInsight, but then we are locked-in to a specific cloud vendor. Instead, let's use <code class="literal">MBrace</code> to handle our distributed computations.</p></div></div></div>

<div class="book" title="Chapter&#xA0;10.&#xA0;Big Data and IoT">
<div class="book" title="AdventureWorks and the Internet of Bikes">
<div class="book" title="MBrace"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch10lvl2sec85" class="calibre1"/>MBrace</h2></div></div></div><p class="calibre6">MBrace is an open source project for scalable data scripting using F# or C#. You can find the <a id="id490" class="calibre1"/>website at <a class="calibre1" href="http://mbrace.io/">http://mbrace.io/</a>. MBrace supports a local simulation of distributed computing and actual implementation on Azure and, coming soon, AWS. For this chapter, we are going to <a id="id491" class="calibre1"/>stick with the local <a id="id492" class="calibre1"/>simulation so you don't have to get an Azure or AWS subscription to work through the samples.</p><p class="calibre6">Go back to Visual Studio, open the NuGet Package Manager, and enter this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">PM&gt; Install-Package MBrace.Thespian -pre</strong></span>
</pre></div><p class="calibre6">Once all of the packages install, go into <code class="literal">MapReduce.fsx</code> and add this at the bottom (note that the version number might be different for you):</p><div class="informalexample"><pre class="programlisting">#load"../packages/MBrace.Thespian.1.0.19/MBrace.Thespian.fsx"


open MBrace.Core.Builders
open MBrace.Thespian
open MBrace.Core
open MBrace.Library.Cloud

//Spin up your clusters
let cluster = ThespianCluster.InitOnCurrentMachine(4)

//Basic Example
let number = cloud { return 5 + 10 } |&gt; cluster.Run</pre></div><p class="calibre6">Sending this to the<a id="id493" class="calibre1"/> REPL gives us the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">namespace FSI_0007.MBrace</strong></span>

<span class="strong"><strong class="calibre7">&gt;</strong></span>

<span class="strong"><strong class="calibre7">val cluster : ThespianCluster</strong></span>

<span class="strong"><strong class="calibre7">&gt;</strong></span>

<span class="strong"><strong class="calibre7">val number : int = 15</strong></span>
</pre></div><p class="calibre6">But also notice what is <a id="id494" class="calibre1"/>happening outside of Visual Studio on your machine. You probably got this dialog:</p><div class="mediaobject"><img src="../images/00158.jpeg" alt="MBrace" class="calibre8"/></div><p class="calibre9"> </p><p class="calibre6">If so, click on <span class="strong"><strong class="calibre7">Allow access</strong></span>.</p><p class="calibre6">Next, four dialog boxes popped up, representing the four machines that you initialized on this line:</p><div class="informalexample"><pre class="programlisting">let cluster = ThespianCluster.InitOnCurrentMachine(4)</pre></div><div class="mediaobject"><img src="../images/00159.jpeg" alt="MBrace" class="calibre8"/></div><p class="calibre9"> </p><p class="calibre6">If you cycle through the <a id="id495" class="calibre1"/>dialog boxes, you will notice that one of them<a id="id496" class="calibre1"/> looks like this:</p><div class="mediaobject"><img src="../images/00160.jpeg" alt="MBrace" class="calibre8"/></div><p class="calibre9"> </p><p class="calibre6">Consider executing the following line:</p><div class="informalexample"><pre class="programlisting">let number = cloud { return 5 + 10 } |&gt; cluster.Run</pre></div><p class="calibre6">MBrace sends the job to one of the four consoles. When working with MBrace, everything inside of the curly braces <code class="literal">{}</code> is executed. In this case, it is 5 + 10, but soon enough it will contain much more complicated calculations.</p><p class="calibre6">Go back into <code class="literal">MapReduce.fsx</code> and add this script at the bottom:</p><div class="informalexample"><pre class="programlisting">let mBraceTotal =
    inputs'
    |&gt;Seq.map(fun i -&gt;cloud { return knn.Compute i })
    |&gt; Cloud.Parallel
    |&gt; cluster.Run
    |&gt;Seq.reduce(fun acc i -&gt; acc + i)

let mBracePrediction = float mBraceTotal/float 250000</pre></div><p class="calibre6">When you send this<a id="id497" class="calibre1"/> to the REPL, nothing much will happen for quite a while. If you look at the four console windows, you will see that they are working hard calculating <code class="literal">knn.map</code> on each of those 250,000 <a id="id498" class="calibre1"/>values:</p><div class="mediaobject"><img src="../images/00161.jpeg" alt="MBrace" class="calibre8"/></div><p class="calibre9"> </p><p class="calibre6">Since this is on our local machine and there is overhead passing data to the different processes, it is much slower than running the in-memory map/reduce that we have seen earlier in the chapter. However, out in the real world when we have more data than any one machine can handle and we can spin up several machines on Azure or AWS, MBrace really shines. You will also notice that we did nothing to install Accord.NET on those four other machines. Vagabond, part of the MBrace NuGet package, handles installing missing assemblies for us. This is a brand of awesome that should never be on sale. Instead of worrying about standing up and configuring machines, we can let MBrace handle all of that for us.</p><p class="calibre6">There is one last bit of syntax we want to use. Go back into <code class="literal">MapReduce.fsx</code> and add this at the bottom:</p><div class="informalexample"><pre class="programlisting">let mBraceTotal' =
    inputs' |&gt;Balanced.map(fun i -&gt; knn.Compute i) |&gt; cluster.Run
            |&gt;Seq.reduce(fun acc i -&gt; acc + i)

let mBracePrediction' = float mBraceTotal/float 250000</pre></div><p class="calibre6">Sending it to the REPL has the same effect as the first MBrace example. Consider the following line:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">|&gt;Balanced.map(fun i -&gt; knn.Compute i) |&gt; cluster.Run</strong></span>
</pre></div><p class="calibre6">This line replaces these lines from the first MBrace example:</p><div class="informalexample"><pre class="programlisting">    |&gt;Seq.map(fun i -&gt;cloud { return knn.Compute i })
    |&gt; Cloud.Parallel
    |&gt; cluster.Run</pre></div><p class="calibre6">This is the syntax we will be<a id="id499" class="calibre1"/> using for the AdventureWorks<a id="id500" class="calibre1"/> implementation. If you want to dig into MBrace further, download the starter pack<a id="id501" class="calibre1"/> found on GitHub at <a class="calibre1" href="https://github.com/mbraceproject/MBrace.StarterKit">https://github.com/mbraceproject/MBrace.StarterKit/blo</a>. With our intro to MapReduce and MBrace out of the way, let's see what we can do with AdventureWorks data.</p></div></div></div>

<div class="book" title="Chapter&#xA0;10.&#xA0;Big Data and IoT">
<div class="book" title="AdventureWorks and the Internet of Bikes">
<div class="book" title="Distributed logistic regression"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch10lvl2sec86" class="calibre1"/>Distributed logistic regression</h2></div></div></div><p class="calibre6">In the Visual Studio <span class="strong"><strong class="calibre7">Solution Explorer</strong></span>, add a new F# script file called <code class="literal">AdventureWorksLR</code>. Go back into Visual Studio, open up the NuGet Package Manager, and enter this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">PM&gt; Install-Package SQLProvider -prerelease</strong></span>
</pre></div><p class="calibre6">In that script, add the<a id="id502" class="calibre1"/> following code (your version number might be different):</p><div class="informalexample"><pre class="programlisting">#r "../packages/SQLProvider.0.0.11-alpha/lib/net40/FSharp.Data.SQLProvider.dll"

open System
open System.Linq
open FSharp.Data.Sql

[&lt;Literal&gt;]
let connectionString = "data source=nc54a9m5kk.database.windows.net;initial catalog=AdventureWorks2014;user id=PacktReader;password= P@cktM@chine1e@rning;"

type AdventureWorks = SqlDataProvider&lt;ConnectionString=connectionString&gt;
let context = AdventureWorks.GetDataContext()

type Telemetry = {ID:int; BusinessEntityID: int; TimeStamp: System.DateTime; 
                 Longitude: float; Latitude: float; 
                 FrontTirePressure: float; BackTirePressure: float;
                 GearId: int; TireSpeed: float; RiderLevel: int}

let telemetry = query {for t in context.''[Person].[Telemetry]'' do
  join rl in context.''[Person].[RiderLevel]'' on (t.BusinessEntityID = rl.BusinessEntityID)
  select {ID=t.ID; BusinessEntityID=t.BusinessEntityID;
          TimeStamp=t.TimeStamp;
          Longitude=t.Longitude; Latitude=t.Latitude; 
          FrontTirePressure=t.FrontTirePressure;
          BackTirePressure=t.BackTirePressure;
          GearId=t.GearID;TireSpeed=t.TireSpeed;
          RiderLevel=rl.RiderLevel}}
  |&gt;Seq.toArray</pre></div><p class="calibre6">Sending this to the FSI <a id="id503" class="calibre1"/>gives us the following:</p><div class="informalexample"><pre class="programlisting">val connectionString : string =
  "data source=nc54a9m5kk.database.windows.net;initial catalog=A"+[72 chars]
type AdventureWorks = FSharp.Data.Sql.SqlDataProvider&lt;...&gt;
val context : FSharp.Data.Sql.SqlDataProvider&lt;...&gt;.dataContext
type Telemetry =
  {ID: int;
   BusinessEntityID: int;
   TimeStamp: System.DateTime;
   Longitude: float;
   Latitude: float;
   FrontTirePressure: float;
   BackTirePressure: float;
   GearId: int;
   TireSpeed: float;
   RiderLevel: int;}
val telemetry : Telemetry [] =
  [|{ID = 1;
     BusinessEntityID = 295;
     TimeStamp = 12/30/2015 3:19:02 PM;
     Longitude = 46.6297;
     Latitude = -97.6087;
     FrontTirePressure = 100.0;
     BackTirePressure = 100.0;
     GearId = 2;
     TireSpeed = 20.04;
     RiderLevel = 0;}; {ID = 2;
                        BusinessEntityID = 775;</pre></div><p class="calibre6">There is no new code here. We are creating a <code class="literal">telemetry</code> type that contains all of the useful data that we are capturing from the IoT bikes. We then create an array of telemetries from all of the data in the database. If you were wondering, there are 360,000 records in the <code class="literal">telemetry</code> table.</p><p class="calibre6">Go back to the script <a id="id504" class="calibre1"/>and enter this:</p><div class="informalexample"><pre class="programlisting">#r"../packages/Accord.3.0.2/lib/net40/Accord.dll"
#r"../packages/Accord.Math.3.0.2/lib/net40/Accord.Math.dll"
#r"../packages/Accord.Statistics.3.0.2/lib/net40/Accord.Statistics.dll"
#r"../packages/Accord.MachineLearning.3.0.2/lib/net40/Accord.MachineLearning.dll"

open System
open Accord
open Accord.Math
open Accord.Statistics
open Accord.MachineLearning
open Accord.Statistics.Models.Regression.Linear

Tools.Shuffle(telemetry)
let attachmentPoint = float telemetry.Length * 0.7 |&gt; int
let train = telemetry.[..attachmentPoint]
let test = telemetry.[attachmentPoint+1..]

let trainInputs = train |&gt; Array.map(fun t -&gt; [|float t.GearId; float t.RiderLevel|])
let trainOutputs = train |&gt; Array.map(fun t -&gt; t.TireSpeed)
let target = new MultipleLinearRegression(2, false)
target.Regress(trainInputs, trainOutputs)</pre></div><p class="calibre6">Sending this to the FSI gives us the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">                        RiderLevel = 1;}; ...|]</strong></span>
<span class="strong"><strong class="calibre7">val trainInputs : float [] [] =</strong></span>
<span class="strong"><strong class="calibre7">  [|[|1.0; 1.0|]; [|2.0; 2.0|]; [|2.0; 1.0|]; [|3.0; 1.0|]; [|1.0; 0.0|];</strong></span>
<span class="strong"><strong class="calibre7">    [|3.0; 1.0|]; [|4.0; 2.0|]; [|2.0; 0.0|]; [|3.0; 1.0|]; [|1.0; 0.0|];</strong></span>
<span class="strong"><strong class="calibre7">...|]</strong></span>
<span class="strong"><strong class="calibre7">val trainOutputs : float [] =</strong></span>
<span class="strong"><strong class="calibre7">  [|23.3934008; 30.5693388; 18.2111048; 19.3842; 14.007411; 21.861742;</strong></span>
<span class="strong"><strong class="calibre7">    36.6713256; 14.5381236; 16.2; 25.451495; 25.4571174; 14.5671708;</strong></span>
<span class="strong"><strong class="calibre7">    20.1900384; 19.3655286; 27.8646144; 21.6268866; 19.3454316; ...|]</strong></span>
<span class="strong"><strong class="calibre7">val target : MultipleLinearRegression =</strong></span>
<span class="strong"><strong class="calibre7">  y(x0, x1) = 5.72463678857853*x0 + 6.83607853679457*x1</strong></span>
<span class="strong"><strong class="calibre7">val it : float = 18472679.55</strong></span>
</pre></div><p class="calibre6">This chunk of code creates a multiple linear regression to predict bike speeds based on the level of the rider and the gear they are using. Instead of looking at the r2, let's do a sniff test. Go back to the script and add this:</p><div class="informalexample"><pre class="programlisting">let possible = 
    [|0..4|] 
    |&gt;  Array.collect(fun i -&gt; [|0..2|] 
                               |&gt; Array.map(fun j -&gt; [|float i; float j|]))
let predict = 
    possible
    |&gt; Array.map(fun i -&gt; i, target.Compute(i))</pre></div><p class="calibre6">Sending this to the REPL, gives <a id="id505" class="calibre1"/>us the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">val possible : float [] [] =</strong></span>
<span class="strong"><strong class="calibre7">  [|[|0.0; 0.0|]; [|0.0; 1.0|]; [|0.0; 2.0|]; [|1.0; 0.0|]; [|1.0; 1.0|];</strong></span>
<span class="strong"><strong class="calibre7">    [|1.0; 2.0|]; [|2.0; 0.0|]; [|2.0; 1.0|]; [|2.0; 2.0|]; [|3.0; 0.0|];</strong></span>
<span class="strong"><strong class="calibre7">    [|3.0; 1.0|]; [|3.0; 2.0|]; [|4.0; 0.0|]; [|4.0; 1.0|]; [|4.0; 2.0|]|]</strong></span>
<span class="strong"><strong class="calibre7">val predict : (float [] * float) [] =</strong></span>
<span class="strong"><strong class="calibre7">  [|([|0.0; 0.0|], 0.0); ([|0.0; 1.0|], 6.836078537);</strong></span>
<span class="strong"><strong class="calibre7">    ([|0.0; 2.0|], 13.67215707); ([|1.0; 0.0|], 5.724636789);</strong></span>
<span class="strong"><strong class="calibre7">    ([|1.0; 1.0|], 12.56071533); ([|1.0; 2.0|], 19.39679386);</strong></span>
<span class="strong"><strong class="calibre7">    ([|2.0; 0.0|], 11.44927358); ([|2.0; 1.0|], 18.28535211);</strong></span>
<span class="strong"><strong class="calibre7">    ([|2.0; 2.0|], 25.12143065); ([|3.0; 0.0|], 17.17391037);</strong></span>
<span class="strong"><strong class="calibre7">    ([|3.0; 1.0|], 24.0099889); ([|3.0; 2.0|], 30.84606744);</strong></span>
<span class="strong"><strong class="calibre7">    ([|4.0; 0.0|], 22.89854715); ([|4.0; 1.0|], 29.73462569);</strong></span>
<span class="strong"><strong class="calibre7">    ([|4.0; 2.0|], 36.57070423)|]</strong></span>
</pre></div><p class="calibre6">In this script, <code class="literal">possible</code> is a jagged array of all the possible combination of gears (values 0 to 4) and biker level (values 0 to 2). We then populate this matrix with the results of the <code class="literal">Compute()</code> method. When you take this data and put it in a more user-friendly way, you can see that there is a relationship—the elite cyclists go faster in all gears than the beginners and it looks like the beginners don't use the lowest gear at all:</p><div class="mediaobject"><img src="../images/00162.jpeg" alt="Distributed logistic regression" class="calibre8"/></div><p class="calibre9"> </p><p class="calibre6">With this model created, we<a id="id506" class="calibre1"/> can then run classifiers on the data and get expected speeds for a given gear and biker level. Go into the script file and enter this:</p><div class="informalexample"><pre class="programlisting">#load"../packages/MBrace.Thespian.1.0.19/MBrace.Thespian.fsx"

open MBrace.Core.Builders
open MBrace.Thespian
open MBrace.Core
open MBrace.Library.Cloud

let cluster = ThespianCluster.InitOnCurrentMachine(4)

let testInputs = test |&gt; Array.map(fun t -&gt; [|float t.GearId; float t.RiderLevel|])

let mBraceTotal =
    testInputs 
    |&gt; Balanced.map(fun i -&gt;
                    target.Compute(i)) |&gt; cluster.Run</pre></div><p class="calibre6">When you send this to the REPL, you will see that the console windows pop up and start doing work. After a couple of minutes, you will get this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">val mBraceTotal : float [] =</strong></span>
<span class="strong"><strong class="calibre7">  [|36.57070423; 25.12143065; 36.57070423; 18.28535211; 5.724636789;</strong></span>
<span class="strong"><strong class="calibre7">    24.0099889; 5.724636789; 25.12143065; 24.0099889; 18.28535211; 24.0099889;</strong></span>
<span class="strong"><strong class="calibre7">    5.724636789; 36.57070423; 12.56071533; 24.0099889; 11.44927358; 0.0;</strong></span>
<span class="strong"><strong class="calibre7">    11.44927358; 25.12143065; 12.56071533; 30.84606744; 12.56071533;</strong></span>
<span class="strong"><strong class="calibre7">    11.44927358; 18.28535211;</strong></span>
</pre></div><p class="calibre6">You might be wondering if there is a way to distribute the creation of the model (the <code class="literal">target.Regress(trainInputs, trainOutputs)</code> line). The short answer is no, you cannot be using the frameworks that we are using to do that. However, some models might lend themselves to <a id="id507" class="calibre1"/>distribution and then re-aggregation, but you would have to extend what is offered in numl and Accord.</p></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="The IoT"><div class="book" id="1MBG22-a18db0be6c20485ba81f22e43ca13055"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec50" class="calibre1"/>The IoT</h1></div></div></div><p class="calibre6">But before we leave machine<a id="id508" class="calibre1"/> learning and IoT, let's get crazy. The PI is not just an input device—heck, it is more powerful than the laptop you bought five years ago. Let's make our Raspberry PI-enabled bike the ultimate power in the tri-state area.</p></div>

<div class="book" title="The IoT">
<div class="book" title="PCL linear regression"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch10lvl2sec87" class="calibre1"/>PCL linear regression</h2></div></div></div><p class="calibre6">Go into Visual Studio <a id="id509" class="calibre1"/>and add a new Visual F# Windows Portable Library (.NET 4.5) called <code class="literal">AdventureWorks.IOB.PCL</code>:</p><div class="mediaobject"><img src="../images/00163.jpeg" alt="PCL linear regression" class="calibre8"/></div><p class="calibre9"> </p><p class="calibre6">Once the project is created, go into the NuGet Package Manager Console and enter this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">PM&gt; Install-Package portable.accord.statistics</strong></span>
<span class="strong"><strong class="calibre7">PM&gt; Install-Package portable.accord.MachineLearning</strong></span>
</pre></div><p class="calibre6">Make sure that the default project is pointed to <code class="literal">AdventureWorks.IOB.PCL</code>:</p><div class="mediaobject"><img src="../images/00164.jpeg" alt="PCL linear regression" class="calibre8"/></div><p class="calibre9"> </p><p class="calibre6">One of the issues when dealing with PCLs is that since they are a slimmed-down version of the .NET Framework, they have no data access support. This means we can't use our friendly neighborhood type provider to get the telemetry data to train our models. Instead, we will need to get our data from a different project and push that data into the PCL for it to train the model. Another "gotcha" is that the script file created in the PCL project is evaluated<a id="id510" class="calibre1"/> inside the FSI, which is a full-on .NET Framework. This means you can't assume that all of the code you write inside the <code class="literal">.fsx</code> file can be copied and pasted into the <code class="literal">.fs</code> file. Since we are building on code we already wrote, we won't be using the script file for this section. I know…take a deep breath…functional programming without an REPL.</p><p class="calibre6">Go into the PCL project and delete the <code class="literal">Script.fsx</code> file and rename <code class="literal">PortableLibrary1.fs</code> to <code class="literal">SpeedModel.fs</code>.</p><p class="calibre6">Inside the <code class="literal">SpeedModel.fs</code> file, replace all of the existing code with this:</p><div class="informalexample"><pre class="programlisting">namespace AdventureWorks.IOB.PCL

open System
open Accord
open Accord.Math
open Accord.Statistics
open Accord.MachineLearning
open Accord.Statistics.Models.Regression.Linear

typeTelemetry = {ID:int; BusinessEntityID: int; 
                 TimeStamp: System.DateTime; 
                 Longitude: float; Latitude: float; 
                 FrontTirePressure: float; 
                 BackTirePressure: float;
                 GearId: int; TireSpeed: float; RiderLevel: int}
typeSpeedModel() = 
letmutable model = newMultipleLinearRegression(2, false)

member this.CurrentModel 
with get() = model
and set (value) = model &lt;- value

member this.Train(telemetries:Telemetry array) = 
        Tools.Shuffle(telemetries)
let inputs = telemetries |&gt;Array.map(fun t -&gt; [|float t.GearId; float t.RiderLevel|])
let outputs = telemetries |&gt;Array.map(fun t -&gt; t.TireSpeed)
        model.Regress(inputs, outputs)

member this.Classify telemetry =
let input = [|float telemetry.GearId; float telemetry.RiderLevel|]
        model.Compute(input)        </pre></div><p class="calibre6">This code creates two .NET classes. The <code class="literal">Telemetry</code> class is equivalent to a read-only DTO/POCO that you <a id="id511" class="calibre1"/>would see in C# or VB.NET. The <code class="literal">SpeedModel</code> class is a bit more involved. The class has one property and two methods:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="literal">CurrentModel</code> is a property that allows the linear regression model to be set. Note that the model is an internal <a id="id512" class="calibre1"/>variable that is mutable.</li><li class="listitem"><code class="literal">Train</code> is a method where an <a id="id513" class="calibre1"/>array of telemetries is passed and the linear regression model will be updated. The implementation of <code class="literal">Train()</code> can be copied and pasted from the script file that you worked on previously.</li><li class="listitem"><code class="literal">Classify</code> is a method<a id="id514" class="calibre1"/> where a single telemetry is passed and the linear regression computes the score. The implementation of <code class="literal">Classify()</code> can be copied and pasted from the script file that you worked on previously.</li></ul></div><p class="calibre6">You can check to see if everything is OK by compiling the project.</p></div></div>

<div class="book" title="The IoT">
<div class="book" title="Service layer"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch10lvl2sec88" class="calibre1"/>Service layer</h2></div></div></div><p class="calibre6">With our PCL ready, let's build <a id="id515" class="calibre1"/>a service layer to deploy the model to devices in the field:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Go into Visual Studio and add a new Visual C# Web <span class="strong"><strong class="calibre7">ASP.NET Web Application</strong></span>:<div class="mediaobject"><img src="../images/00165.jpeg" alt="Service layer" class="calibre8"/></div><p class="calibre15"> </p><div class="mediaobject"><img src="../images/00166.jpeg" alt="Service layer" class="calibre8"/></div><p class="calibre15"> </p></li><li class="listitem" value="2">Add a<a id="id516" class="calibre1"/> reference:<div class="mediaobject"><img src="../images/00167.jpeg" alt="Service layer" class="calibre8"/></div><p class="calibre15"> </p></li><li class="listitem" value="3">Next, go into the<a id="id517" class="calibre1"/> NuGet Package Manager Console and add a reference to <code class="literal">Accord.Statistics</code>. Make sure the <span class="strong"><strong class="calibre7">Default project</strong></span> is pointing to <code class="literal">AdventureWorks.IOB.Services</code>:<div class="mediaobject"><img src="../images/00168.jpeg" alt="Service layer" class="calibre8"/></div><p class="calibre15"> </p></li><li class="listitem" value="4">Next, go into the <code class="literal">Web.Config</code> file and add a connection string entry:<div class="informalexample"><pre class="programlisting">&lt;configuration&gt;
&lt;connectionStrings&gt;
&lt;addname="Northwind"connectionString="data source=nc54a9m5kk.database.windows.net;initial catalog=AdventureWorks2014;user id=PacktReader;password= P@cktM@chine1e@rning;" /&gt;
&lt;/connectionStrings&gt;
&lt;appSettings&gt;
&lt;addkey="webpages:Version"value="3.0.0.0" /&gt;</pre></div></li><li class="listitem" value="5">Head over to the <code class="literal">Global.asax.cs</code> file and replace the entire contents with the following:<div class="informalexample"><pre class="programlisting">using System;
using System.Collections.Generic;
using System.Web.Http;
using System.Web.Mvc;
using System.Web.Optimization;
using System.Web.Routing;
using AdventureWorks.IOB.PCL;
using System.Threading;
using System.Configuration;
using System.Data.SqlClient;

namespace AdventureWorks.IOB.Services
{
publicclassWebApiApplication : System.Web.HttpApplication
    {
staticObject _lock = newObject();
Timer _timer = null;
staticSpeedModel _speedModel = null;

protectedvoid Application_Start()
        {
AreaRegistration.RegisterAllAreas();
GlobalConfiguration.Configure(WebApiConfig.Register);
FilterConfig.RegisterGlobalFilters(GlobalFilters.Filters);
RouteConfig.RegisterRoutes(RouteTable.Routes);
BundleConfig.RegisterBundles(BundleTable.Bundles);

            _speedModel = newSpeedModel();
            _timer = newTimer(TrainModel, null, 0, TimeSpan.FromMinutes(5).Milliseconds);

        }

protectedTelemetry[] CreateTelemetries(String connectionString)
        {
var telemetries = newList&lt;Telemetry&gt;();

using (var connection = newSqlConnection(connectionString))
            {
var commandText = "Select T.*,RL.RiderLevel from [Person].[Telemetry] as T " +
"inner join[Person].[RiderLevel] as RL " +
"on T.BusinessEntityID = rl.BusinessEntityID";
using (var command = newSqlCommand(commandText, connection))
                {
                    connection.Open();
var reader = command.ExecuteReader();
while(reader.Read())
                    {
                        telemetries.Add(newTelemetry((int)reader[0], (int)reader[1],
                        (DateTime)reader[2], 
                        (double)reader[3], 
                        (double)reader[4],
                        (double)reader[5], 
                        (double)reader[6],(int)reader[7],
                        (double)reader[8], 
                        (int)reader[9]));
                    }
                }
            }

return telemetries.ToArray();
        }

        private void TrainModel(object state)
        {
            var connectionString = ConfigurationManager.ConnectionStrings["Northwind"].ConnectionString;
            var telemetries = CreateTelemetries(connectionString);
            lock (_lock)
            {
                SpeedModel.Train(telemetries);
            }
        }

publicstaticSpeedModel SpeedModel
        {
get
            {
lock (_lock)
                {
return _speedModel;
                }
            }
set
            {
lock (_lock)
                {
                    _speedModel = value;
                }
            }
        }
    }
}</pre></div></li></ol><div class="calibre13"/></div><p class="calibre6">You can compile the project now. This code is much like <a class="calibre1" title="Chapter 3. More AdventureWorks Regression" href="part0029_split_000.html#RL0A2-a18db0be6c20485ba81f22e43ca13055">Chapter 3</a>, <span class="strong"><em class="calibre11">More AdventureWorks Regression</em></span>, in that we create a timer that fires every 5 minutes. Also, we use a lock to prevent the model being read in an illegal state. When the timer fires, the model is recreated, based on the data from the database. Notice that this is where the C# application is responsible<a id="id518" class="calibre1"/> for getting the data that is passed into the <code class="literal">SpeedModel</code> class.</p><p class="calibre6">Head over to the <code class="literal">Controllers</code> and rename <code class="literal">ValuesController</code> to <code class="literal">SpeedModelController</code>. Go into the file and replace all of the code with this:</p><div class="informalexample"><pre class="programlisting">using System.Web.Http;
using System.Net.Http;
using System.IO;
using System.Xml.Serialization;
using System.Net;

namespace AdventureWorks.IOB.Services.Controllers
{
  publicclassSpeedModelController : ApiController
    {
    // GET api/SpeedModel
      publicHttpResponseMessage Get()
        {
          HttpResponseMessage result = null;

          if (WebApiApplication.SpeedModel != null)
            {
              using (MemoryStream stream = newMemoryStream())
                {
                  var formatter = newXmlSerializer(typeof(double[]));
                  formatter.Serialize(stream, WebApiApplication.SpeedModel.CurrentModel.Coefficients);
                  var content = stream.ToArray();

                  result = Request.CreateResponse(HttpStatusCode.OK);
                  result.Content = newByteArrayContent(content);
                  return result;
                }
            }
              else
            {
              return Request.CreateResponse(HttpStatusCode.Gone);
            }
        }


    }
}</pre></div><p class="calibre6">If you compile the project and run the website, when you navigate to the controller, you will get this:</p><div class="mediaobject"><img src="../images/00169.jpeg" alt="Service layer" class="calibre8"/></div><p class="calibre9"> </p><p class="calibre6">We now have a way <a id="id519" class="calibre1"/>of creating a model based on all the data in the database that we can share to individual clients.</p></div></div>

<div class="book" title="The IoT">
<div class="book" title="Universal Windows app and Raspberry Pi 2"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch10lvl2sec89" class="calibre1"/>Universal Windows app and Raspberry Pi 2</h2></div></div></div><p class="calibre6">This universal app has a <a id="id520" class="calibre1"/>couple of moving parts:</p><div class="book"><ul class="itemizedlist"><li class="listitem">When the app is connected to its home network, it will:<div class="book"><ul class="itemizedlist1"><li class="listitem">Upload all <a id="id521" class="calibre1"/>of the telemetry that is collected to Azure's IoT Suite</li><li class="listitem">Download the most recent global model that was created based on all the riders in the AdventureWorks database from our service layer</li></ul></div></li><li class="listitem">When the app is running, it will collect telemetry data from the sensors hooked up to the bike. After a certain point, it will start generating its own local model and compare it to the global AdventureWorks model. If the local model begins diverging from the expected speed of the global model, it will instruct the biker to shift. The app will keep the telemetry data on local storage until it is connected to the network, then it will upload the data.</li></ul></div><p class="calibre6">Let's code this up:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Go into the <span class="strong"><strong class="calibre7">Solution Explorer</strong></span> and add a new Visual C# Windows Universal Blank App named <a id="id522" class="calibre1"/><code class="literal">AdventureWorks.IOB.RP2</code>:<div class="mediaobject"><img src="../images/00170.jpeg" alt="Universal Windows app and Raspberry Pi 2" class="calibre8"/></div><p class="calibre15"> </p></li><li class="listitem" value="2">Once the project is<a id="id523" class="calibre1"/> created, go to its <span class="strong"><strong class="calibre7">References</strong></span> section and select <span class="strong"><strong class="calibre7">Add Reference</strong></span>:<div class="mediaobject"><img src="../images/00171.jpeg" alt="Universal Windows app and Raspberry Pi 2" class="calibre8"/><div class="caption"><p class="calibre18">The Add Reference... option</p></div></div><p class="calibre15"> </p></li><li class="listitem" value="3">Then navigate <a id="id524" class="calibre1"/>to <span class="strong"><strong class="calibre7">Projects</strong></span> | <span class="strong"><strong class="calibre7">Solution</strong></span> and select the location of your<a id="id525" class="calibre1"/> PCL project:<div class="mediaobject"><img src="../images/00172.jpeg" alt="Universal Windows app and Raspberry Pi 2" class="calibre8"/></div><p class="calibre15"> </p></li><li class="listitem" value="4">Now navigate to <span class="strong"><strong class="calibre7">Universal Windows</strong></span> | <span class="strong"><strong class="calibre7">Extensions</strong></span> | <span class="strong"><strong class="calibre7">Windows IoT Extensions for the UWP</strong></span>:<div class="mediaobject"><img src="../images/00173.jpeg" alt="Universal Windows app and Raspberry Pi 2" class="calibre8"/></div><p class="calibre15"> </p></li><li class="listitem" value="5">Next, go into the NuGet <a id="id526" class="calibre1"/>Package Manager Console and enter this:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre7">PM&gt; Install-Package portable.accord.statistics</strong></span>
</pre></div></li><li class="listitem" value="6">Make sure that the <a id="id527" class="calibre1"/><span class="strong"><strong class="calibre7">Default project</strong></span> is pointing to <code class="literal">AdventureWorks.IOB.RP2</code>:<div class="mediaobject"><img src="../images/00174.jpeg" alt="Universal Windows app and Raspberry Pi 2" class="calibre8"/></div><p class="calibre15"> </p><p class="calibre16">Build the project to make sure all is well.</p></li><li class="listitem" value="7">Next, go to the <span class="strong"><strong class="calibre7">Solution Explorer</strong></span> and add a new folder called <code class="literal">Sensors</code>:<div class="mediaobject"><img src="../images/00175.jpeg" alt="Universal Windows app and Raspberry Pi 2" class="calibre8"/><div class="caption"><p class="calibre18">Adding new folder</p></div></div><p class="calibre15"> </p></li><li class="listitem" value="8">Navigate to<a id="id528" class="calibre1"/> the <code class="literal">Sensors</code> folder:<div class="mediaobject"><img src="../images/00176.jpeg" alt="Universal Windows app and Raspberry Pi 2" class="calibre8"/></div><p class="calibre15"> </p></li><li class="listitem" value="9">Add a new class<a id="id529" class="calibre1"/> called <code class="literal">TelemetryEventArgs.cs</code>:<div class="mediaobject"><img src="../images/00177.jpeg" alt="Universal Windows app and Raspberry Pi 2" class="calibre8"/><div class="caption"><p class="calibre18">Adding a new class</p></div></div><p class="calibre15"> </p></li><li class="listitem" value="10">In <code class="literal">TelemetryEventArgs.cs</code>, replace<a id="id530" class="calibre1"/> the existing code with the<a id="id531" class="calibre1"/> following:<div class="informalexample"><pre class="programlisting">using AdventureWorks.IOB.PCL;
using System;

namespace AdventureWorks.IOB.RP2.Sensors
{
  Public class TelemetryEventArgs : EventArgs
    {
      Public Telemetry Telemetry { get; set; }
    }
}</pre></div></li><li class="listitem" value="11">In the sensors folder, add a new interface called <code class="literal">IBikeController</code>. After it is created, replace all of the code with the following:<div class="informalexample"><pre class="programlisting">using System;

namespace AdventureWorks.IOB.RP2.Sensors
{
Public interface IBikeController
    {
      Event EventHandler&lt;TelemetryEventArgs&gt; TelemetryCreated;
      void SwitchGear(int targetGear);
    }
}</pre></div><p class="calibre16">This interface will be used by the main app to, well, interface with the Raspberry Pi. The Pi communicates back to the main app via an event called <code class="literal">TelemetryCreated</code>. The reason that we used an interface (versus talking directly to the PI) is that we want to borrow a bit from the SOLID principles and have several implementations for our app: an in-memory bike controller that we can use to make sure everything is hooked up correctly and a Raspberry Pi bike controller that actually talks to the hardware that we currently have available. Also, there are so many sensors available on the market, we need a <a id="id532" class="calibre1"/>way of adding in new sensors without changing the existing code.</p></li><li class="listitem" value="12">Go into the <code class="literal">Sensors</code> folder and <a id="id533" class="calibre1"/>add a new class called <code class="literal">InMemoryBikeController</code>. Replace the existing code with this:<div class="informalexample"><pre class="programlisting">using AdventureWorks.IOB.PCL;
using System;
using System.Threading;

namespace AdventureWorks.IOB.RP2.Sensors
{

    public class InMemoryBikeController : IBikeController
    {
        Timer _timer = null;

        public InMemoryBikeController()
        {
            _timer = new Timer(GenerateTelemetry, null, 0, TimeSpan.FromSeconds(1).Milliseconds);
        }

        public event EventHandler&lt;TelemetryEventArgs&gt; TelemetryCreated;

        private void GenerateTelemetry(object state)
        {
            var telemetry = new Telemetry(0, 0, DateTime.UtcNow, 46.6297, -97.6087, 100.0, 100.0, 2, 10.0, 1);
            var args = new TelemetryEventArgs() { Telemetry = telemetry };

            if (TelemetryCreated != null)
            {
                TelemetryCreated(this, args);
            }
        }

        public void SwitchGear(int targetGear)
        {

        }
    }
}</pre></div><p class="calibre16">This code simulates an actual Raspberry Pi. Every second, it fires an event with some <a id="id534" class="calibre1"/>hardcoded telemetry data. It also has a method stub for the <code class="literal">SwitchGears</code> that does nothing.</p></li><li class="listitem" value="13">Make sure everything <a id="id535" class="calibre1"/>compiles and jumps over to the <code class="literal">MainPage.xaml</code> file and replace all of the contents with this:<div class="informalexample"><pre class="programlisting">&lt;Page
  x:Class="AdventureWorks.IOB.RP2.MainPage"
  
  
  
  
  
  mc:Ignorable="d"&gt;

  &lt;Grid Background="{ThemeResource ApplicationPageBackgroundThemeBrush}"&gt;
  &lt;StackPanel HorizontalAlignment="Center" VerticalAlignment="Center"&gt;
  &lt;TextBox x:Name="StatusMessage" Text="IOB Ready!" Margin="10" IsReadOnly="True"/&gt;
  &lt;/StackPanel&gt;
  &lt;/Grid&gt;
&lt;/Page&gt;</pre></div><p class="calibre16">This creates a status box that you can use for debugging. When you deploy this app to the Raspberry Pi, this is unnecessary because there is no graphical user interface.</p></li><li class="listitem" value="14">Next, go into the <code class="literal">MainPage.xaml.cs</code> file and replace everything with this:<div class="informalexample"><pre class="programlisting">using System;
using System.IO;
using System.Linq;
using Windows.UI.Xaml;
using Windows.Web.Http;
using AdventureWorks.IOB.PCL;
using Windows.UI.Xaml.Controls;
using System.Xml.Serialization;
using System.Collections.Generic;
using AdventureWorks.IOB.RP2.Sensors;
using Windows.Networking.Connectivity;
using Accord.Statistics.Models.Regression.Linear;

namespace AdventureWorks.IOB.RP2
{
  publicsealedpartialclassMainPage : Page
    {
      String _networkName = String.Empty;
      SpeedModel _globalSpeedModel = null;
      SpeedModel _localSpeedModel = null;
      List&lt;Telemetry&gt; _telemetries = null;
      IBikeController _bikeController = null;
      DispatcherTimer _timer = null;

      public MainPage()
        {
           this.InitializeComponent();
           _networkName = "MySafeNetwork";
           _globalSpeedModel = newSpeedModel();
           _localSpeedModel = newSpeedModel();
           _telemetries = newList&lt;Telemetry&gt;();
           _bikeController = newInMemoryBikeController();
           _timer = newDispatcherTimer();

           _timer.Interval = newTimeSpan(0, 0, 1);

           NetworkInformation.NetworkStatusChanged += NetworkInformation_NetworkStatusChanged;
           _bikeController.TelemetryCreated += _bikeController_TelemetryCreated;
           _timer.Tick += _timer_Tick;

        }

        privatevoid _timer_Tick(object sender, object e)
        {
          if(_telemetries.Count &gt; 300)
            {
              _localSpeedModel.Train(_telemetries.ToArray());

              var targetGlobalGear = _globalSpeedModel.Classify(_telemetries.Last());
              var targetLocalGear = _localSpeedModel.Classify(_telemetries.Last());
              if (targetGlobalGear &lt; targetLocalGear)
                {
                   _bikeController.SwitchGear((int)targetGlobalGear);
                }
            }
        }

        privatevoid _bikeController_TelemetryCreated(object sender, TelemetryEventArgs e)
        {
           _telemetries.Add(e.Telemetry);
        }

        privatevoid NetworkInformation_NetworkStatusChanged(object sender)
        {
          var connectionProfile = NetworkInformation.GetInternetConnectionProfile();
          if (connectionProfile.ProfileName == _networkName)
            {
               GetGlobalModel();
               UploadLocalTelemetryData();
            }
        }

        privateasyncvoid GetGlobalModel()
        {
          var client = newHttpClient();
          var uri = newUri("http://localhost:3899/api/SpeedModel");
          try
            {
              var response = await client.GetAsync(uri);
              if (response.IsSuccessStatusCode)
                {
                  var content = await response.Content.ReadAsInputStreamAsync();
                  using (var stream = content.AsStreamForRead())
                    {
                      var formatter = newXmlSerializer(typeof(double[]));
                      var coefficients = (double[])formatter.Deserialize(stream);
                      var regression = newMultipleLinearRegression(2);
                      Array.Copy(coefficients, regression.Coefficients,coefficients.Length);
                      _globalSpeedModel.CurrentModel = regression;
                    }
                }
            }
            catch (Exception e)
            {
               this.StatusMessage.Text = e.ToString();
            }

        }

          privateasyncvoid UploadLocalTelemetryData()
        {
//TODO: Send _telemetries to Azure IoT Suite
        }

    }
}</pre></div><p class="calibre16">This is where the heavy lifting occurs. When the app starts, it begins a timer that fires every second (<code class="literal">_timer_Tick</code>). If there are over 5 minutes' worth of<a id="id536" class="calibre1"/> data in the local collection, it generates a <code class="literal">SpeedModel</code>. It then compares this speed model to the global one <a id="id537" class="calibre1"/>and if the global output is less than the local one, it signals the biker via the <code class="literal">.SwitchGear()</code>. The actual implementation is up to the controller. As you will see in a minute, the Raspberry Pi controller turns on an LED that the biker can see. In other examples, we could hook the Pi up to the bike's shifting assembly and shift the gears for the biker—an automatic transmission for the bike, as it were.</p></li><li class="listitem" value="15">Next, go into the <span class="strong"><strong class="calibre7">Solution Explorer</strong></span> and right-click on <span class="strong"><strong class="calibre7">Properties</strong></span> and change the startup<a id="id538" class="calibre1"/> project to <span class="strong"><strong class="calibre7">Multiple startup projects</strong></span> with the <code class="literal">Services</code> and<a id="id539" class="calibre1"/> <code class="literal">RP2</code> projects changed to <span class="strong"><strong class="calibre7">Start</strong></span>. The <code class="literal">Services</code> project has to be listed before the <code class="literal">RP2</code> one:<div class="mediaobject"><img src="../images/00178.jpeg" alt="Universal Windows app and Raspberry Pi 2" class="calibre8"/></div><p class="calibre15"> </p></li><li class="listitem" value="16">One last thing you need to do before we run this is to deploy the Universal Windows application. If you ask me why you need to deploy it first, I will tell you, "Because Microsoft said so." Go into the <span class="strong"><strong class="calibre7">Solution Explorer</strong></span> and right-click on the <code class="literal">Rp2</code> project and select <span class="strong"><strong class="calibre7">Deploy</strong></span>:<div class="mediaobject"><img src="../images/00179.jpeg" alt="Universal Windows app and Raspberry Pi 2" class="calibre8"/><div class="caption"><p class="calibre18">The Deploy option</p></div></div><p class="calibre15"> </p></li><li class="listitem" value="17">Now you can<a id="id540" class="calibre1"/> run the app and both, the browser will pop up for the service<a id="id541" class="calibre1"/> layer and the universal Windows app will start:<div class="mediaobject"><img src="../images/00180.jpeg" alt="Universal Windows app and Raspberry Pi 2" class="calibre8"/></div><p class="calibre15"> </p></li></ol><div class="calibre13"/></div><p class="calibre6">Notice nothing much is happening—at least on the screen. That is pretty typical of IoT projects; the action is on the device and connected peripherals. If the device fired the <code class="literal">NetworkStatus_Changed</code> event, the device would get the most recent global model and upload the global model. You can simulate this by placing <code class="literal">GetGlobalModelinMainPage()</code> and then write it to the status box if you are the type of person who wants to see something on the screen.</p><p class="calibre6">Let's build out the Raspberry Pi implementation of the <code class="literal">BikeController</code>. Since this is a book on machine<a id="id542" class="calibre1"/> learning and not on IoT, I will not be covering the details of setting up a<a id="id543" class="calibre1"/> Raspberry Pi and doing all of the wiring and coding. As a frame of reference, I used the example found at <a class="calibre1" href="http://ms-iot.github.io/content/en-US/win10/samples/Potentiometer.htm">http://ms-iot.github.io/content/en-US/win10/samples/Potentiometer.htm</a>. Basically, each of the sensors would be considered an analog input device (such as a potentiometer) that converts its signal to a digital<a id="id544" class="calibre1"/> signal. For each of the inputs, a <code class="literal">SpiConnection</code> was created like this:</p><div class="informalexample"><pre class="programlisting">privateasyncTask&lt;SpiDevice&gt; InitSPI(int pin)
        {
            var settings = newSpiConnectionSettings(pin);
            settings.ClockFrequency = 500000;   
            settings.Mode = SpiMode.Mode0;    

            string spiAqs = SpiDevice.GetDeviceSelector("SPI0");
            var deviceInfo = awaitDeviceInformation.FindAllAsync(spiAqs);
            returnawaitSpiDevice.FromIdAsync(deviceInfo[0].Id, settings);
        }</pre></div><p class="calibre6">And every second, each device's buffer was read:</p><div class="informalexample"><pre class="programlisting">privatevoid SensorTimer_Tick(ThreadPoolTimer timer)
        {
byte[] readBuffer = newbyte[3]; 
byte[] writeBuffer = newbyte[3] { 0x00, 0x00, 0x00 };
            writeBuffer[0] = 0x06;

//Gear
            _gear.TransferFullDuplex(writeBuffer, readBuffer);
var gear = convertToInt(readBuffer);</pre></div><p class="calibre6">The readings were aggregated into telemetry data and the event was raised:</p><div class="informalexample"><pre class="programlisting">var telemetry = newTelemetry(0, _businessEntityID, DateTime.UtcNow,
                latitude, longitude, frontTire, backTire, gear, tireSpeed, _riderLevel);
var args = newTelemetryEventArgs() { Telemetry = telemetry };

if (TelemetryCreated != null)
            {
                TelemetryCreated(this, args);
            }</pre></div><p class="calibre6">Meanwhile, a different timer was running and shutting off the LED every two seconds. The LED was set when the <code class="literal">SwitchGear</code> method was called:</p><div class="informalexample"><pre class="programlisting">public void SwitchGear(int targetGear)
        {
            _led.Write(GpioPinValue.Low);
        }</pre></div><p class="calibre6">So the controller app can<a id="id545" class="calibre1"/> turn the LED on, and then the Pi turns it off after two seconds. You<a id="id546" class="calibre1"/> can see the final result in the code sample that accompanies the book.</p></div></div>

<div class="book" title="The IoT">
<div class="book" title="Next steps"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch10lvl2sec90" class="calibre1"/>Next steps</h2></div></div></div><p class="calibre6">I glossed over some important IoT issues that would need to be addressed to make this bike app fully functional:</p><div class="book"><ul class="itemizedlist"><li class="listitem">There are hundreds <a id="id547" class="calibre1"/>of input devices that I could have used. You will have to write a specific implementation for the devices that you are interested in. Thank goodness we have an interface!</li><li class="listitem">How to<a id="id548" class="calibre1"/> deploy this app to a Raspberry Pi is beyond the scope of this book. You can learn more about this at <a class="calibre1" href="https://dev.windows.com/en-US/iot">https://dev.windows.com/en-US/iot</a>.</li><li class="listitem">Telemetry to local storage is beyond the scope of this book. This is a universal Windows app issue that can be researched at <a class="calibre1" href="https://msdn.microsoft.com/en-us/library/windows/apps/dn894631.aspx">https://msdn.microsoft.com/en-us/library/windows/apps/dn894631.aspx</a>.</li><li class="listitem">Uploading the <a id="id549" class="calibre1"/>data to the Azure IoT suite is beyond the scope of this book. You can find more information on that at <a class="calibre1" href="https://www.microsoft.com/en-us/server-cloud/internet-of-things/azure-iot-suite.aspx">https://www.microsoft.com/en-us/server-cloud/internet-of-things/azure-iot-suite.aspx</a>.</li></ul></div></div></div>
<div class="book" title="Summary" id="1NA0K1-a18db0be6c20485ba81f22e43ca13055"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec51" class="calibre1"/>Summary</h1></div></div></div><p class="calibre6">This was a fairly ambitious chapter. We looked at some of the challenges of big data and how to use MBrace to help us with distributed machine learning. We then created a sample IoT project to show an example of how big data is generated and how we can deploy ML models to devices. The IoT app used two ML models to give optimal results. We then looked (briefly) at how we can use the power of .NET to build multiple input devices so that we can extend across the variety of hardware that is, and will be, available for IoT.</p></div></body></html>