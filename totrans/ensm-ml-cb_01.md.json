["```py\nMS SubClass (Nominal): Identifies the type of dwelling involved in the sale\nLot Frontage (Continuous): Linear feet of street connected to property\nAlley (Nominal): Type of alley access to property\nOverall Qual (Ordinal): Rates the overall material and finish of the house\nOverall Cond (Ordinal): Rates the overall condition of the house\nYear Built (Discrete): Original construction date\nMas Vnr Type (Nominal): Masonry veneer type\nMas Vnr Area (Continuous): Masonry veneer area in square feet\nGarage Type (Nominal): Garage location\nGarage Yr Blt (Discrete): Year garage was built\nGarage Finish (Ordinal): Interior finish of the garage\nGarage Cars (Discrete): Size of garage in car capacity\nGarage Area (Continuous): Size of garage in square feet\nGarage Qual (Ordinal): Garage quality\nGarage Cond (Ordinal): Garage condition\n...\n...\nSalePrice (Continuous): Sale price $$\n```", "```py\nimport os\nimport pandas as pd\n\n# Set working directory as per your need\nos.chdir(\".../.../Chapter 1\")\nos.getcwd()\n```", "```py\nhousepricesdata = pd.read_csv(\"HousePrices.csv\")\n```", "```py\n# See first five observations from top\nhousepricesdata.head(5)\n```", "```py\nhousepricesdata.shape\n```", "```py\n(1460, 81)\n```", "```py\nhousepricesdata.dtypes\n```", "```py\nId                 int64\nMSSubClass         int64\nMSZoning          object\nLotFrontage      float64\nLotArea            int64\nLotConfig         object\nLandSlope         object\n                  ...   \nBedroomAbvGr       int64\nKitchenAbvGr       int64\nKitchenQual       object\nTotRmsAbvGrd       int64\nSaleCondition     object\nSalePrice          int64\nLength: 81, dtype: object\n```", "```py\nhousepricesdata.describe()\n```", "```py\n# inplace=True will overwrite the DataFrame after dropping Id column\nhousepricesdata.drop(['Id'], axis=1, inplace=True)\n```", "```py\n# Name the count column as \"count\"\nlotshape_frequencies = pd.crosstab(index=housepricesdata[\"LotShape\"], columns=\"count\") \n\nlandcountour_frequencies = pd.crosstab(index=housepricesdata[\"LandContour\"], columns=\"count\") # Name the count column as \"count\"\n\nprint(lotshape_frequencies)\nprint(\"\\n\") # to keep a blank line for display\nprint(landcountour_frequencies)\n```", "```py\n# Using astype() to cast a pandas object to a specified datatype\nhousepricesdata['MSSubClass'] = housepricesdata['MSSubClass'].astype('object')\nhousepricesdata['OverallQual'] = housepricesdata['OverallQual'].astype('object')\nhousepricesdata['OverallCond'] = housepricesdata['OverallCond'].astype('object')\n\n# Check the datatype of MSSubClass after type conversion\nprint(housepricesdata['MSSubClass'].dtype)\nprint('\\n') # to keep a blank line for display\n\n# Check the distribution of the levels in MSSubClass after conversion\n# Make a crosstab with pd.crosstab()\n# Name the count column as \"count\"\nprint(pd.crosstab(index=housepricesdata[\"MSSubClass\"], columns=\"count\")) \n```", "```py\ncategory\n\ncol_0       count\nMSSubClass       \n20            536\n30             69\n40              4\n45             12\n50            144\n60            299\n70             60\n75             16\n80             58\n85             20\n90             52\n120            87\n160            63\n180            10\n190            30\n```", "```py\n# Importing datetime package for date time operations\nimport datetime as dt\n\n# using date time package to find the current year\ncurrent_year = int(dt.datetime.now().year)\n\n# Subtracting the YearBuilt from current_year to find out the age of the building\nbuilding_age = current_year - housepricesdata['YearBuilt']\n\n# Subtracting the YearRemonAdd from current_year to find out the age since the\n# building was remodelled\nremodelled_age = current_year - housepricesdata['YearRemodAdd']\n```", "```py\n# Adding the two variables to the DataFrame\nhousepricesdata['building_age'] = building_age\nhousepricesdata['remodelled_age'] = remodelled_age\n\n# Checking our DataFrame to see if the two variables got added\nhousepricesdata.head(5)\n```", "```py\n# We use get_dummies() function to one-hot encode LotShape\none_hot_encoded_variables = pd.get_dummies(housepricesdata['LotShape'],prefix='LotShape')\n\n# Print the one-hot encoded variables to see how they look like\nprint(one_hot_encoded_variables)\n```", "```py\n# Adding the new created one-hot encoded variables to our DataFrame\nhousepricesdata = pd.concat([housepricesdata,one_hot_encoded_variables],axis=1)\n\n# Let's take a look at the added one-hot encoded variables\n# Scroll right to view the added variables\nhousepricesdata.head(5)\n```", "```py\n# Dropping the original variable after one-hot encoding the original variable\n# inplace = True option will overwrite the DataFrame\n\nhousepricesdata.drop(['LotShape'],axis=1, inplace=True)\n```", "```py\nimport h5py\n\n# With 'r' passed as a parameter to the h5py.File() \n# the file will be read in read-only mode\ndata = h5py.File('File Name.h5', 'r')\n```", "```py\n# Converting a categorical variable to numerical\n# Using astype() to cast a pandas object to a specified datatype\n\n# Here we typecast GarageYrBlt from float64 type to int64 type\nhousepricesdata['GarageYrBlt'] = housepricesdata['GarageYrBlt'].astype('int64')\n```", "```py\n# We use sklearn.preprocessing and import LabelEncoder class\nfrom sklearn.preprocessing import LabelEncoder\n\n# Create instance of LabelEncoder class\nlb_make = LabelEncoder()\n\n# We create a new variable LotConfig_code to hold the new numerical labels\n# We label encode LotConfig variable\nhousepricesdata[\"LotConfig_Code\"] = lb_make.fit_transform(housepricesdata[\"LotConfig\"])\n\n# Display the LotConfig variable and its corresponding label encoded numerical values\nhousepricesdata[[\"LotConfig\", \"LotConfig_Code\"]]\n```", "```py\n# Check which variables have missing values\n\ncolumns_with_missing_values = housepricesdata.columns[housepricesdata.isnull().any()]\nhousepricesdata[columns_with_missing_values].isnull().sum()\n```", "```py\nimport numpy as np\nimport matplotlib.pyplot as plt\n%matplotlib inline\n\n# To hold variable names\nlabels = [] \n\n# To hold the count of missing values for each variable \nvaluecount = [] \n\n# To hold the percentage of missing values for each variable\npercentcount = [] \n\nfor col in columns_with_missing_values:\n    labels.append(col)\n    valuecount.append(housepricesdata[col].isnull().sum())\n    # housepricesdata.shape[0] will give the total row count\n   percentcount.append(housepricesdata[col].isnull().sum()/housepricesdata.shape[0])\n\nind = np.arange(len(labels))\n\nfig, (ax1, ax2) = plt.subplots(1,2,figsize=(20,18))\n\nrects = ax1.barh(ind, np.array(valuecount), color='blue')\nax1.set_yticks(ind)\nax1.set_yticklabels(labels, rotation='horizontal')\nax1.set_xlabel(\"Count of missing values\")\nax1.set_title(\"Variables with missing values\")\n\nrects = ax2.barh(ind, np.array(percentcount), color='pink')\nax2.set_yticks(ind)\nax2.set_yticklabels(labels, rotation='horizontal')\nax2.set_xlabel(\"Percentage of missing values\")\nax2.set_title(\"Variables with missing values\")\n```", "```py\n# Replacing missing values with 'No Access' in Alley variable\nhousepricesdata['Alley'].fillna('No Access', inplace=True)\n```", "```py\n# Lets import seaborn. We will use seaborn to generate our charts\nimport seaborn as sns\n\n# We will import matplotlib to resize our plot figure\nimport matplotlib.pyplot as plt\n%matplotlib inline\nplt.figure(figsize=(20, 10))\n\n# cubehelix palette is a part of seaborn that produces a colormap\ncmap = sns.cubehelix_palette(light=1, as_cmap=True, reverse=True)\nsns.heatmap(housepricesdata.isnull(), cmap=cmap)\n```", "```py\n# Filling in the missing values in LotFrontage with its median value\nhousepricesdata['LotFrontage'].fillna(housepricesdata['LotFrontage'].median(), inplace=True)\n```", "```py\n# Replacing all NA values with their original meaning\nhousepricesdata['BsmtQual'].fillna('No Basement', inplace=True)\nhousepricesdata['BsmtCond'].fillna('No Basement', inplace=True)\nhousepricesdata['BsmtExposure'].fillna('No Basement', inplace=True)\nhousepricesdata['BsmtFinType1'].fillna('No Basement', inplace=True)\nhousepricesdata['BsmtFinType2'].fillna('No Basement', inplace=True)\n\nhousepricesdata['GarageYrBlt'].fillna(0, inplace=True)\n\n# For observations where GarageType is null, we replace null values in GarageYrBlt=0\nhousepricesdata['GarageType'].fillna('No Garage', inplace=True)\nhousepricesdata['GarageFinish'].fillna('No Garage', inplace=True)\nhousepricesdata['GarageQual'].fillna('No Garage', inplace=True)\nhousepricesdata['GarageCond'].fillna('No Garage', inplace=True)\n\nhousepricesdata['PoolQC'].fillna('No Pool', inplace=True)\nhousepricesdata['Fence'].fillna('No Fence', inplace=True)\nhousepricesdata['MiscFeature'].fillna('None', inplace=True)\n\nhousepricesdata['FireplaceQu'].fillna('No Fireplace', inplace=True)\n```", "```py\n# Using crosstab to generate the count of MasVnrType by type of MasVnrArea\nprint(pd.crosstab(index=housepricesdata[\"MasVnrType\"],\\\n                  columns=housepricesdata[\"MasVnrArea\"], dropna=False, margins=True)) \n```", "```py\n# Filling in the missing values for MasVnrType and MasVnrArea with None and 0 respectively\nhousepricesdata['MasVnrType'].fillna('None', inplace=True)\nhousepricesdata['MasVnrArea'].fillna(0, inplace=True)\n```", "```py\nhousepricesdata['MSSubClass'][housepricesdata['Electrical'].isnull()]\n```", "```py\n# Using crosstab to generate the count of Electrical Type by MSSubClass\nprint(pd.crosstab(index=housepricesdata[\"Electrical\"],\\\ncolumns=housepricesdata['MSSubClass'], dropna=False, margins=True))\n```", "```py\nhousepricesdata['Electrical'].fillna('SBrkr', inplace=True)\n```", "```py\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n%matplotlib inline\nplt.figure(figsize=(20, 10))\n\ncmap = sns.cubehelix_palette(light=1, as_cmap=True, reverse=True)\nsns.heatmap(housepricesdata.isnull(), cmap=cmap)\n```", "```py\n# To take a look at the top 5 rows in the dataset\nhousepricesdata.head(5)\n\n# To display the summary statistics for all variables\nhousepricesdata.describe()\n```", "```py\n# How many columns with different datatypes are there?\nhousepricesdata.get_dtype_counts()\n```", "```py\n# Pulling out names of numerical variables by conditioning dtypes NOT equal to object type\nnumerical_features = housepricesdata.dtypes[housepricesdata.dtypes != \"object\"].index\nprint(\"Number of Numerical features: \", len(numerical_features))\n\n# Pulling out names of categorical variables by conditioning dtypes equal to object type\ncategorical_features = housepricesdata.dtypes[housepricesdata.dtypes == \"object\"].index\nprint(\"Number of Categorical features: \", len(categorical_features))\n```", "```py\nmelt_num_features = pd.melt(housepricesdata, value_vars=numerical_features)\n\ngrid = sns.FacetGrid(melt_num_features, col=\"variable\", col_wrap=5, sharex=False, sharey=False)\ngrid = grid.map(sns.distplot, \"value\", color=\"blue\") \n```", "```py\nmelt_cat_features = pd.melt(housepricesdata, id_vars=['SalePrice'], value_vars=categorical_features)\n\ngrid = sns.FacetGrid(melt_cat_features, col=\"variable\", col_wrap=2, sharex=False, sharey=False, size=6)\ngrid.map(sns.boxplot, \"value\", \"SalePrice\", palette=\"Set3\")\ngrid.fig.subplots_adjust(wspace=1, hspace=0.25)\n\nfor ax in grid.axes.flat: \n    plt.setp(ax.get_xticklabels(), rotation=90)\n```", "```py\n# Generate a correlation matrix for all the numerical variables\ncorr=housepricesdata[numerical_features].corr()\nprint(corr)\n```", "```py\n# Get correlation of numerical variables\ndf_numerical_features= housepricesdata.select_dtypes(include=[np.number])\n\ncorrelation= df_numerical_features.corr()\ncorrelation[\"SalePrice\"].sort_values(ascending=False)*100\n# Correlation Heat Map (Seaborn library)\nf, ax= plt.subplots(figsize=(14,14))\nplt.title(\"Correlation of Numerical Features with Sale Price\", y=1, size=20)\n\n# cmap - matplotlib colormap name or object - can be used to set the color options\n# vmin and vmax is used to anchor the colormap\nsns.heatmap(correlation, square= True, vmin=-0.2, vmax=0.8, cmap=\"YlGnBu\")\n```", "```py\nrow_count = 11\ncol_count = 3\n\nfig, axs = plt.subplots(row_count, col_count, figsize=(12,36))\nexclude_columns = ['Id', 'SalePrice']\nplot_numeric_features = [col for col in numerical_features if col not in exclude_columns]\n\nfor eachrow in range(0, row_count):\n    for eachcol in range(0, col_count): \n        i = eachrow*col_count + eachcol\n        if i < len(plot_numeric_features):\n            sns.regplot(housepricesdata[plot_numeric_features[i]], housepricesdata['SalePrice'], \\\n                ax = axs[eachrow][eachcol], color='purple', fit_reg=False)\n\n# tight_layout automatically adjusts subplot params so that the subplot(s) fits in to the figure area \nplt.tight_layout() \nplt.show()\n```", "```py\n# See correlation between numerical variables with house prices\ncorr=housepricesdata.corr()[\"SalePrice\"]\n\n# Sort the correlation values. \n# Use [::-1] to sort it in descending manner\n# Use [::+1] to sort it in ascending manner\ncorr[np.argsort(corr)[::-1]]\n```", "```py\nf = pd.melt(housepricesdata, id_vars=['SalePrice'],value_vars= numerical_features[0:9])\nggplot(f,aes('value', 'SalePrice')) + geom_point(color='orange') + facet_wrap('variable',scales='free')\n```", "```py\nf_1 = pd.melt(housepricesdata, value_vars=numerical_features[0:9])\nggplot(f_1, aes('value')) + geom_density(color=\"red\") + facet_wrap('variable',scales='free') \n```"]