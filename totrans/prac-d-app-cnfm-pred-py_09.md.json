["```py\nn_cal = 1000\n```", "```py\nalpha = 0.1\n```", "```py\nidx = np.array([1] * n_cal + [0] * (smx.shape[0]-n_cal)) > 0\n```", "```py\nnp.random.seed(42)\n```", "```py\nnp.random.shuffle(idx)\n```", "```py\ncal_smx, test_smx = smx[idx,:], smx[~idx,:]\n```", "```py\ncal_labels, test_labels = labels[idx], labels[~idx]\n```", "```py\ncal_scores = 1-cal_smx[np.arange(n_cal),cal_labels]\n```", "```py\nq_level = np.ceil((n_cal+1)*(1-alpha))/n_cal\n```", "```py\nqhat = np.quantile(cal_scores, q_level, method='higher')\n```", "```py\nprediction_sets = test_smx >= (1-qhat)\n```", "```py\nempirical_coverage = prediction_sets[np.arange(prediction_sets.shape[0]),test_labels].mean()\n```", "```py\nprint(f\"The empirical coverage is: {empirical_coverage}\")\n```", "```py\n# Get scores. calib_X.shape[0] == calib_Y.shape[0] == n\n```", "```py\ncal_pi = cal_smx.argsort(1)[:, ::-1]\n```", "```py\ncal_srt = np.take_along_axis(cal_smx, cal_pi, axis=1).cumsum(axis=1)\n```", "```py\ncal_scores = np.take_along_axis(cal_srt, cal_pi.argsort(axis=1), axis=1)[\n```", "```py\n    range(n_cal), cal_labels\n```", "```py\n]\n```", "```py\n# Get the score quantile\n```", "```py\nqhat = np.quantile(\n```", "```py\n    cal_scores, np.ceil((n_cal + 1) * (1 - alpha)) / n_cal, method=\"higher\"\n```", "```py\n)\n```", "```py\ntest_pi = test_smx.argsort(1)[:, ::-1]\n```", "```py\ntest_srt = np.take_along_axis(test_smx, test_pi, axis=1).cumsum(axis=1)\n```", "```py\nprediction_sets = np.take_along_axis(test_srt <= qhat, test_pi.argsort(axis=1), axis=1)\n```", "```py\nlam_reg = 0.01\n```", "```py\nk_reg = 5\n```", "```py\ndisallow_zero_sets = False\n```", "```py\nrand = True\n```", "```py\nreg_vec = np.array(k_reg*[0,] + (smx.shape[1]-k_reg)*[lam_reg,])[None,:]\n```", "```py\ncal_pi = cal_smx.argsort(1)[:,::-1];\n```", "```py\ncal_srt = np.take_along_axis(cal_smx,cal_pi,axis=1)\n```", "```py\ncal_srt_reg = cal_srt + reg_vec\n```", "```py\ncal_L = np.where(cal_pi == cal_labels[:,None])[1]\n```", "```py\ncal_scores = cal_srt_reg.cumsum(axis=1)[np.arange(n_cal),cal_L] - np.random.rand(n_cal)*cal_srt_reg[np.arange(n_cal),cal_L]\n```", "```py\nqhat = np.quantile(cal_scores, np.ceil((n_cal+1)*(1-alpha))/n_cal, method='higher')\n```", "```py\nn_test = test_smx.shape[0]\n```", "```py\ntest_pi = test_smx.argsort(1)[:,::-1]\n```", "```py\ntest_srt = np.take_along_axis(test_smx,test_pi,axis=1)\n```", "```py\ntest_srt_reg = test_srt + reg_vec\n```", "```py\ntest_srt_reg_cumsum = test_srt_reg.cumsum(axis=1)\n```", "```py\nindicators = (test_srt_reg.cumsum(axis=1) - np.random.rand(n_test,1)*test_srt_reg) <= qhat if rand else test_srt_reg.cumsum(axis=1) -test_srt_reg <= qhat\n```", "```py\nif disallow_zero_sets: indicators[:,0] = True\n```", "```py\nprediction_sets = np.take_along_axis(indicators,test_pi.argsort(axis=1),axis=1)\n```"]