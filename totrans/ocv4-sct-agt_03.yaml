- en: Searching for Luxury Accommodations Worldwide
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Today the bridal suite, tomorrow a prison. A secret agent's sleeping arrangements
    are horribly unpredictable.
  prefs: []
  type: TYPE_NORMAL
- en: Each day, someone in MI6 gets the job of booking a stellar hotel room and, conversely,
    some evil henchman has to pick a warehouse or dilapidated apartment, plus a lamp,
    a chair, and implements of bondage. For mini missions or brief beatings, it is
    tolerable to leave the choice of venue to a fallible human being. However, for
    long-term rentals or acquisitions, would it not be wiser to develop a specialized
    search engine that takes the legwork and the guesswork out of the equation?
  prefs: []
  type: TYPE_NORMAL
- en: 'With this motivation, we are going to develop a desktop app called `Luxocator:
    The Luxury Locator`. It is a search engine that finds images on the web by keyword
    search and classifies each image as a luxury, interior scene; luxury, exterior
    scene; Stalinist, interior scene; or Stalinist, exterior scene, according to certain
    visual cues in the image.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Particularly, our classifier relies on comparing statistical distributions
    of color in different images or sets of images. This topic is called **color histogram
    analysis**. We will learn how to efficiently store and process our statistical
    model and how to redistribute it, along with our code, in an application bundle.
    Specifically, this chapter covers the following programming topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Using OpenCV's Python bindings, along with the NumPy and SciPy libraries, to
    classify images based on color histogram analysis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Bing Image Search API to acquire images from a web search
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a GUI application with `wxPython`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using PyInstaller to bundle a Python application as an executable that can run
    on other systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter''s project has the following software dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '**A Python environment with the following modules**: OpenCV, NumPy, SciPy,
    Requests, wxPython, and optionally PyInstaller'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setup instructions are covered in [Chapter 1](e3ac8266-975b-43ca-8221-482a15eb0e05.xhtml),
    *Preparing for the Mission*. Refer to the setup instructions for any version requirements.
    Basic instructions for running Python code are covered in [Appendix C](c44b1aaa-fe12-4054-85fb-37d584f15d3b.xhtml),
    *Running with Snakes (or, First Steps with Python)*.
  prefs: []
  type: TYPE_NORMAL
- en: The completed project for this chapter can be found in this book's GitHub repository, [https://github.com/PacktPublishing/OpenCV-4-for-Secret-Agents-Second-Edition](https://github.com/PacktPublishing/OpenCV-4-for-Secret-Agents-Second-Edition),
    in the `Chapter002` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Planning the Luxocator app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter uses Python. Being a high-level, interpreted language with great
    third-party libraries for numeric and scientific computing, Python lets us focus
    on the functionality of the system rather than implementing subsystem details.
    For our first project, such a high-level perspective is precisely what we need.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an overview of Luxocator''s functionality and our choice of
    Python libraries that support this functionality. Like many computer vision applications,
    Luxocator has six basic steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Acquire a static set of reference images**: For Luxocator, we (the developers)
    choose certain images that we deem to be luxury indoor scenes, other images that
    we consider Stalinist indoor scenes, and so on. We load these images into memory.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Train a model based on the reference images**: For Luxocator, our model describes
    each image in terms of its normalized color histogram—that is, the distribution
    of colors across the image''s pixels. We use OpenCV and NumPy to perform the calculations.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Store the results of the training**: For Luxocator, we use SciPy to compress
    the reference histograms and write/read them to/from disk.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Acquire a dynamic set of query images**: For Luxocator, we acquire query
    images using the Bing Search API through a Python wrapper. We also use the Requests
    library to download the full-resolution images.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Compare the query images to the reference images**: For Luxocator, we compare
    each query image and each reference image based on the intersection of their histograms.
    We then make a classification based on the average results of these comparisons.
    We use NumPy to perform the calculations.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Present the results of the comparison**: For Luxocator, we provide a GUI
    for initiating a search and navigating the results. This cross-platform GUI is
    developed in `wxPython`. A classification label, such as Stalinist, exterior,
    is shown below each image. See the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1b03f4f2-86f3-4b97-845a-1d148dba3fe2.png)'
  prefs: []
  type: TYPE_IMG
- en: Optionally, we use PyInstaller to build Luxocator so that it can be deployed
    to users who do not have Python or the aforementioned libraries. However, remember
    that you might need to do extra troubleshooting of your own to make PyInstaller
    work in some environments, including Raspberry Pi or other ARM devices.
  prefs: []
  type: TYPE_NORMAL
- en: Creating, comparing, and storing histograms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"A grey-green color that often finds itself on the walls of public institutions-e.g.,
    hospitals, schools, government buildings—and, where appropriated, on sundry supplies
    and equipment."'
  prefs: []
  type: TYPE_NORMAL
- en: – "institutional green", Segen's Medical Dictionary (2012)
  prefs: []
  type: TYPE_NORMAL
- en: I hesitate to make sweeping statements about the ideal color of paint on a wall.
    It depends. I have found solace in many walls of many colors. My mother is a painter
    and I like paint in general.
  prefs: []
  type: TYPE_NORMAL
- en: But not all color is paint. Some color is dirt. Some color is concrete or marble,
    plywood or mahogany. Some color is the sky through big windows, the ocean, the
    golf course, the swimming pool, or Jacuzzi. Some color is discarded plastics and
    beer bottles, baked food on the stove, or perished vermin. Some color is unknown.
    Maybe the paint camouflages the dirt.
  prefs: []
  type: TYPE_NORMAL
- en: A typical camera can capture at least 16.7 million (*256 * 256 * 256*) distinct
    colors. For any given image, we can count the number of pixels of each color.
    This set of counts is called the **color histogram** of the image. Typically,
    most entries in the histogram will be zero because most scenes are not polychromatic
    (many-colored).
  prefs: []
  type: TYPE_NORMAL
- en: We can normalize the histogram by dividing the color counts by the total number
    of pixels. Since the number of pixels is factored out, normalized histograms are
    comparable even if the original images have different resolutions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given a pair of normalized histograms, we can measure the histograms'' similarity
    on a scale of zero to one. One measure of similarity is called the **intersection**
    of the histograms. It is computed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b373e041-8828-452c-9593-b94fe12d709a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is the equivalent Python code (which we will optimize later):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, suppose that in one image, `50%` of the pixels are black and `50%`
    are white. In another image, `100%` of the pixels are black. The similarity is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here, a similarity of one does not mean that the images are identical; it means
    that their normalized histograms are identical. Relative to the first image, the
    second image could be a different size, could be flipped, or could even contain
    the same pixel values in a randomly different order.
  prefs: []
  type: TYPE_NORMAL
- en: Conversely, a similarity of zero does not mean that the images look completely
    different to a layperson; it just means that they have no color values in common.
    For example, an image that is all black and another image that is all charcoal-gray
    have histograms with a similarity of zero by our definition.
  prefs: []
  type: TYPE_NORMAL
- en: For the purpose of classifying images, we want to find the average similarity
    between a query histogram and a set of multiple reference histograms. A single
    reference histogram (and a single reference image) would be far too specific for
    a broad classification such as **Lu****xury, indoor**.
  prefs: []
  type: TYPE_NORMAL
- en: Although we focus on one approach to comparing histograms, there are many alternatives.
    For a discussion of several algorithms and their implementations in Python, see
    this blog post by Adrian Rosebrock at [http://www.pyimagesearch.com/2014/07/14/3-ways-compare-histograms-using-opencv-python/](http://www.pyimagesearch.com/2014/07/14/3-ways-compare-histograms-using-opencv-python/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write a class called `HistogramClassifier`, which creates and stores
    sets of references histograms and finds the average similarity between a query
    histogram and each set of reference histograms. To support this functionality,
    we will use OpenCV, NumPy, and SciPy. Create a file called `HistogramClassifier.py`
    and add the following shebang line (path to the Python interpreter) and `import`
    statements at the top:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Some versions of PyInstaller work better if we explicitly import the `numpy`
    module before the `cv2` module. Remember that OpenCV's Python bindings depend
    on NumPy. Also, note that the OpenCV Python module is called `cv2`, even though
    we are using OpenCV 4\. The name `cv2` comes from a historical distinction between
    the parts of OpenCV that had an underlying C++ implementation (called `cv2`) and
    the parts that an older, underlying C implementation (called `cv`). As of OpenCV
    4, everything is `cv2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'An instance of `HistogramClassifier` stores several variables. A public Boolean
    called `verbose` controls the level of logging. A public float called `minimumSimilarityForPositiveLabel`
    defines a similarity threshold—if all the average similarities fall below this
    value, then the query image is given an `''Unknown''` classification. Several
    variables store values related to the color model. We assume that our images have
    three color channels with 8 bits (256 possible values) per channel. Finally, and
    most importantly, a dictionary called `_references` maps string keys such as `''Luxury,
    interior''` to lists of reference histograms. Let''s declare the variables in
    the `HistogramClassifier` class''s `__init__` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: By convention, in a Python class, a variable or method name is prefixed with
    an underscore if the variable or method is meant to be protected (accessed only
    within the class and its subclasseses). However, this level of protection is not
    actually enforced. Most of our member variables and methods in this book are marked
    as protected, but a few are public. Python supports private variables and methods
    (denoted by a double-underscore prefix) that are meant to be inaccessible, even
    to subclasses. However, we avoid private variables and methods in this book because
    Python classes should typically be highly extensible.
  prefs: []
  type: TYPE_NORMAL
- en: '`HistogramClassifier` has a method, `_createNormalizedHist`, which takes two
    arguments—an image and a Boolean indicating whether to store the resulting histogram
    in a **sparse** (compressed) format. The histogram is computed using an OpenCV
    function, `cv2.calcHist`. As arguments, it takes the image, the number of channels,
    the histogram size (that is, the dimensions of the color model), and the range
    of each color channel. We flatten the resulting histogram into a one-dimensional
    format that uses memory more efficiently. Then, optionally, we convert the histogram
    into a sparse format using a SciPy function called `scipy.sparse.csc_matrix`.'
  prefs: []
  type: TYPE_NORMAL
- en: A sparse matrix uses a form of compression that relies on a default value, normally
    `0`. That is to say, we do not bother storing all the zeroes individually; instead,
    we note the ranges that are full of zeroes. For histograms, this is an important
    optimization because in a typical image, most of the possible colors are absent.
    So, most of the histogram values are `0`.
  prefs: []
  type: TYPE_NORMAL
- en: Compared to an uncompressed format, a sparse format offers better memory efficiency
    but worse computational efficiency. The same trade-off applies to compressed formats
    in general.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the implementation of `_createNormalizedHist`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'A public method, `addReference`, accepts two arguments—an image and a label
    (the label is a string describing the classification). We pass the image to `_createNormalizedHist`
    in order to create a normalized histogram in a sparse format. For a reference
    histogram, the sparse format is more appropriate because we want to keep many
    reference histograms in memory for the entire duration of a classification session.
    After creating the histogram, we add it to a list in `_references`, using the
    label as the key. Here is the implementation of `addReference`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'For the purposes of Luxocator, reference images come from files on disk. Let''s
    give `HistogramClassifier` a public method, `addReferenceFromFile`, which accepts
    a file path instead of directly accepting an image. It also accepts a label. We
    load the image from file using an OpenCV method called `cv2.imread`, which accepts
    a path and a color format. Based on our earlier assumption about having three
    color channels, we always want to load images in color, not grayscale. This option
    is represented by the `cv2.IMREAD_COLOR` value. Having loaded the image, we pass
    it and the label to `addReference`. The implementation of `addReferenceFromFile`
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we arrive at the crux of the matter—the `classify` public method, which
    accepts a query image, as well as an optional string to identify the image in
    log output. For each set of reference histograms, we compute the average similarity
    to the query histogram. If all similarity values fall below `minimumSimilarityForPositiveLabel`,
    we return the `''Unknown''` label. Otherwise, we return the label of the most
    similar set of reference histograms. If `verbose` is `True`, we also log all the
    labels and their respective average similarities. Here is the method''s implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note the use of the `todense` method to decompress a sparse matrix.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also provide a public method, `classifyFromFile`, which accepts a file path
    instead of directly accepting an image. Here is the implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Computing all our reference histograms will take a bit of time. We do not want
    to recompute them every time we run Luxocator. So, we need to serialize and deserialize
    (save and load) the histograms to/from disk. For this purpose, SciPy provides
    two functions, `scipy.io.savemat` and `scipy.io.loadmat`. They accept a file and
    various optional arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can implement a `serialize` method with optional compression, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'When deserializing, we get a dictionary from `scipy.io.loadmat`. However, this
    dictionary contains more than our original `_references` dictionary. It also contains
    some serialization metadata and some serialization metadata, and some additional
    arrays that wrap the lists that were originally in `_references`. We strip out
    these unwanted, added contents and store the result back in `_references`. The
    implementation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: That is our classifier. Next, we will test our classifier by feeding it some
    reference images and a query image.
  prefs: []
  type: TYPE_NORMAL
- en: Training the classifier with reference images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"Can you identify this coastline? Given time, yes."'
  prefs: []
  type: TYPE_NORMAL
- en: – Photo caption, Dante Stella ([http://www.dantestella.com/technical/hex352.html](http://www.dantestella.com/technical/hex352.html))
  prefs: []
  type: TYPE_NORMAL
- en: A small selection of reference images is included in this book's GitHub repository in
    a folder called `Chapter002/images`. Feel free to experiment with the classifier
    by adding more reference images, since a larger set may yield more reliable results.
    Bear in mind that our classifier relies on average similarity, so the more times
    you include a given color scheme in the reference images, the more heavily you
    are weighting the classifier in favor of that color scheme.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of `HistogramClassifier.py`, let''s add a `main` method to train
    and serialize a classifier using our reference images. We will also run the classifier
    on a couple of the images as a test. Here is a partial implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Depending on the number of reference images, this method may take several minutes
    (or even longer) to run. Fortunately, since we are serializing the trained classifier,
    we will not have to run such a method every time we open our main application.
    Instead, we will simply deserialize the trained classifier from file, as we will
    see later in this chapter in the *Integrating everything into the GUI* section.
  prefs: []
  type: TYPE_NORMAL
- en: For a large number of training images, you might wish to modify the `main` function
    of `HistogramClassifier.py` to use all images in a specified folder. (For examples
    of iteration over all images in a folder, refer to the `describe.py` file in the
    code for [Chapter 3](49c9a5fb-89a3-4c0d-bbee-021d2618168c.xhtml)*, Training a
    Smart Alarm to Recognize the Villain and His Cat*.) However, for a small number
    of training images, I find it more convenient to specify a list of images in code
    so that we can comment and uncomment individual images to see the effect on training.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's consider how our main application will acquire query images.
  prefs: []
  type: TYPE_NORMAL
- en: Acquiring images from the web
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our query images will come from a web search. Before we start implementing
    the search functionality, let''s write some helper functions that let us fetch
    images through the `Requests` library and convert them into an OpenCV-compatible
    format. Because this functionality is highly reusable, we will put it in a module
    of static utility functions. Let''s create a file called `RequestsUtils.py` and
    import OpenCV, NumPy, and Requests, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'As a global variable, let''s store `HEADERS`, a dictionary of headers that
    we will use when making web requests. Some servers reject requests that appear
    to come from a bot. To improve the chance of our requests being accepted, let''s
    set the `''User-Agent''` header to a value that mimics a web browser, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Whenever we receive a response to a web request, we want to check whether the
    status code is `200` OK. This is only a cursory test of whether the response is
    valid, but it is a good enough test for our purposes. We implement this test in
    the following method, `validateResponse`, which returns `True` if the response
    is deemed valid; otherwise, it logs an error message and returns `False`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'With the help of `HEADERS` and `validateResponse`, we can try to get an image
    from a URL and return that image in an OpenCV-compatible format (failing that,
    we return `None`). As an intermediate step, we read raw data from a web response
    into a NumPy array using a function called `numpy.fromstring`. We then interpret
    this data as an image using a function called `cv2.imdecode`. Here is our implementation,
    a function called `cvImageFromUrl` that accepts a URL as an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'To test these two functions, let''s give `RequestsUtils.py` a `main` function
    that downloads an image from the web, converts it into an OpenCV-compatible format,
    and writes it to disk using an OpenCV function called `imwrite`. Here is our implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: To confirm that everything worked, open `image.png` (which should be in the
    same directory as `RequestsUtils.py`) and compare it to the online image, which
    you can view in a web browser at [http://nummist.com/images/ceiling.gaze.jpg](http://nummist.com/images/ceiling.gaze.jpg).
  prefs: []
  type: TYPE_NORMAL
- en: Although we are putting a simple test of our `RequestUtils` module in a `main`
    function, a more sophisticated and maintainable approach to writing tests in Python
    is to use the classes in the `unittest` module of the standard library. For more
    information, refer to the official tutorial at [https://docs.python.org/3/library/unittest.html](https://docs.python.org/3/library/unittest.html).
  prefs: []
  type: TYPE_NORMAL
- en: Acquiring images from Bing Image Search
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Microsoft''s search engine, Bing, has an API that enables us to send queries
    and receive results in our own application. For a limited number of queries per
    month, the Bing Search API is free to use (currently, the limit is three thousand
    queries per month and three queries per second). However, we must register for
    it by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to [https://azure.microsoft.com/](https://azure.microsoft.com/) and log in.
    You will need to create a Microsoft account if you do not already have one.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to [https://azure.microsoft.com/en-us/services/cognitive-services/bing-image-search-api/](https://azure.microsoft.com/en-us/services/cognitive-services/bing-image-search-api/). Click
    the Try Bing Image Search button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next to the Guest option, click the Get started button to start a free seven-day
    trial. After you have started your trial, go to [https://azure.microsoft.com/en-us/try/cognitive-services/](https://azure.microsoft.com/en-us/try/cognitive-services/).
    Select the Search APIs tab. Under the Bing Image Search APIs v7 section, find
    the 32-character API key (you might find two keys labeled Key 1 and Key 2 . Either
    of these is fine). Copy the key and save it in a safe place. We will need to use
    it later to associate our Bing session with our Microsoft Account.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As an alternative to step three, or after your seven-day trial expires, you
    can create a free account. Next to the Free Azure account option, click the Sign
    up button to register for a free account with limited uses per month (of course,
    if you decide to use Luxocator obsessively, to the exclusion of normal activities,
    you can always upgrade to a paid account later). Even though the account is free,
    the registration process requires you to provide a phone number and a credit card
    in order to verify your identity. Once you have completed the registration process,
    click the Portal tab to go the Microsoft Azure control panel. Click Cognitive
    Services, then Add, then Bing Search v7, and then Create. Fill out the **Create**
    dialog by following the example in the following screenshot. Click the dialog''s
    Create button. Click the Go to resource button. Click Keys. Find the 32-character
    API key (you might see two keys labeled Key 1 and Key 2\. Either of these is fine).
    Copy the key and save it in a safe place:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/19793bb0-a3ea-4938-bd28-9b2e98337f52.png)'
  prefs: []
  type: TYPE_IMG
- en: Create an environment variable named `BING_SEARCH_KEY`. Set its value equal
    to the API key that we created in step three or four (later, in our code, we will
    access the value of this environment variable in order to associate our Bing search
    session with our API key). Depending on your operating system, there are many
    different ways to create an environment variable. On Windows, you may want to
    use the Control Panel to add a user environment variable. On Unix-like systems,
    you may want to add a definition of the environment variable by editing the user's
    login script, which is called `~/.profile` on Mac, Ubuntu, and many other systems.
    After you have created the environment variable, reboot (or log out and log back
    in).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The Bing Search API and several other Microsoft APIs have a third-party Python
    wrapper called `py-ms-cognitive`. We can install it using Python''s package manager,
    `pip`. Open a Terminal (on Unix-like systems) or Command Prompt (on Windows) and
    run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Building atop `py-ms-cognitive`, we want a high-level interface for submitting
    a query string and navigating through a resulting list of images, which should
    be in an OpenCV-compatible format. We will make a class, `ImageSearchSession`,
    which offers such an interface. First, let''s create a file, `ImageSearchSession.py`,
    and add the following `import` statements at the top:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Note that we are modifying one of the `py_ms_cognitive` Python wrapper's static
    variables, `PyMsCognitiveImageSearch.SEARCH_IMAGE_BASE`. We do this because, by
    default, `py_ms_cognitive` uses an outdated base URL for the Bing Search API endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: For `py_ms_cognitive`, we are using OpenCV, pretty-print (for logging JSON results
    from the search), system libraries, and our networking utility functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like `HistogramClassifier`, `ImageSearchSession` has a public Boolean called `verbose` to
    control the level of logging. Moreover, `ImageSearchSession` has member variables
    to store the current query, metadata about the current image results, and metadata
    to help us navigate to the previous and next results. We can initialize these
    variables like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We provide getters for many of the member variables, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Given these variables, we can navigate through a large set of results by fetching
    only a few at a time; that is, by looking through a window into the results. We
    can move our window to earlier or later results, as needed, by simply adjusting
    the offset by the number of requested results and clamping the offset to the valid
    range. Here are some implementations of the `searchPrev` and `searchNext` methods,
    which rely on a more general search method that we will implement afterwards:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The more general-purpose `search` method accepts a query string, a maximum
    number of results, and an offset relative to the first available result. We store
    these arguments in member variables for reuse in the `searchPrev` and `searchNext`
    methods. The search method also uses the `BING_SEARCH_KEY` environment variable
    that we defined earlier. Here is this first part of the method''s implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we set up our search parameters, specifying that the results should be
    in `JSON` format and should include color photos only:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We set up a search and request the results in `JSON` format. We handle any
    exceptions by printing an error message, setting the number of search results
    to `0`, and returning prematurely:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'If the request succeeded, we proceed to parse the `JSON`. We store metadata
    about the actual number of results received and number of results available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'If the `verbose` public variable is `True`, we print the JSON results. Here
    is the end of the method''s implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Although the `search` method fetches a textual description of results, including
    image URLs, it does not actually fetch any full-sized images. This is good, because
    the full-sized images may be large and we do not need them all at once. Instead,
    we provide another method, `getCvImageAndUrl`, to retrieve the image and image
    URL that have a specified index in the current results. The index is given as
    an argument. As an optional second argument, this method accepts a Boolean indicating
    whether a thumbnail should be used instead of the full-sized image. We use `cvImageFromUrl`
    to fetch and convert the thumbnail or full-sized image. Here is our implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The caller of `getCvImageAndUrl` is responsible for dealing gracefully with
    image downloads that are slow or that fail. Recall that our `cvImageFromUrl` function
    just logs an error and returns `None` if the download fails.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test `ImageSearchSession`, let''s write a main function that instantiates
    the class, sets `verbose` to `True`, searches for `''luxury condo sales''`, and
    writes the first resulting image to disk. Here is the implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have a classifier and a search session, we are almost ready to proceed
    to the frontend of Luxocator. We just need a few more utility functions to help
    us prepare data and images for bundling and display.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing images and resources for the app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Alongside `RequestsUtils.py` and `ImageSearchSession.py`, let''s create another
    file called `ResizeUtils.py` with the following `import` statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'For display in a GUI, images usually have to be resized. One popular mode of
    resizing is called **aspect fill**. Here, we want to preserve the image''s aspect
    ratio while changing its larger dimension (width for a landscape image or height
    for a portrait image) to a certain value. OpenCV does not directly provide this
    resizing mode, but it does provide a function, `cv2.resize`, which accepts an
    image, target dimensions, and optional arguments, including an interpolation method.
    We can write our own function, `cvResizeAspectFill`, which accepts an image, maximum
    size, and preferred interpolation methods for upsizing and downsizing. It determines
    the appropriate arguments for `cv2.resize` and passes them along. Here is the
    implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: For a description of the interpolation methods that OpenCV supports, see the
    official documentation at [https://docs.opencv.org/master/da/d54/group__imgproc__transform.html#ga47a974309e9102f5f08231edc7e7529d](https://docs.opencv.org/master/da/d54/group__imgproc__transform.html#ga47a974309e9102f5f08231edc7e7529d).
    For upsizing, we default to `cv2.INTER_LANCZOS4`, which produces sharp results.
    For downsizing, we default to `cv2.INTER_AREA`, which produces moiré-free results
    (moiré is an artifact that makes parallel lines or concentric curves look like
    crosshatching when they are sharpened at certain magnifications).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s create another file called `WxUtils.py` with the following `import`
    statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Due to API changes between `wxPython 3` and `wxPython 4`, it is important for
    us to check which version has been imported. We use the following code to get
    a version string, such as `''4.0.3''`, and to parse the major version number,
    such as `4`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'OpenCV and wxPython use different image formats, so we will implement a conversion
    function, `wxBitmapFromCvImage`. While OpenCV stores color channels in BGR order,
    wxPython expects RGB order. We can use an OpenCV function, `cv2.cvtColor`, to
    reformat the image data accordingly. Then, we can use a wxPython function, `wx.BitmapFromBuffer`,
    to read the reformatted data into a wxPython bitmap, which we return. Here is
    the implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: On some versions of Raspberry Pi and Raspbian, `wx.BitmapFromBuffer` suffers
    from a platform-specific bug that causes it to fail. For a workaround, see [Appendix
    A](ddc68808-2fe3-4064-b333-632e68bb4ddf.xhtml),* Making WxUtils.py Compatible
    with Raspberry Pi*, at the end of this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have one more utility module to make. Let''s create a file, `PyInstallerUtils.py`,
    with `import` statements for the `os` and `sys` modules from Python''s standard
    library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'When we bundle our application using PyInstaller, the paths to resources will
    change. So, we need a function that correctly resolves paths, regardless of whether
    our application has been bundled or not. Let''s add a function, `pyInstallerResourcePath`,
    which resolves a given path relative to the app directory (the `''_MEIPASS''`
    attribute) or, failing that, the current working directory (`''.''`). It is implemented
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Our utilities modules are done now and we can move on to implementing the frontend
    of Luxocator.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating everything into the GUI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For Luxocator''s front end, let''s create a file called `Luxocator.py`. This
    module depends on OpenCV, wxPython, and some of Python''s standard OS and threading
    functionality. It also depends on all the other modules that we have written in
    this chapter. Add the following shebang line and `import` statements at the top
    of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s implement the `Luxocator` class as a subclass of `wx.Frame`, which
    represents a GUI frame such as the contents of a window. Most of our GUI code
    is in the `Luxocator` class''s `__init__` method, which is, therefore, a big method
    but not very complicated. Our GUI elements include a search control, previous
    and next buttons, a bitmap, and a label to show the classification result. All
    of these GUI elements are stored in member variables. The bitmap is confined to
    a certain maximum size (by default, 768 pixels in the larger dimension), and the
    other elements are laid out below it. Several methods are registered as callbacks
    to handle events such as the window closing, the *Esc* key being pressed, a search
    string being entered, or the next or previous button being clicked. Besides the
    GUI elements, other member variables include instances of our `HistogramClassifier`
    and `ImageSearchSession` classes. Here is the implementation of the initializer,
    interspersed with some remarks on the GUI elements that we are using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: For more information about using bitmaps, controls, and layouts in wxPython,
    refer to the official wiki at [http://wiki.wxpython.org/](http://wiki.wxpython.org/).
  prefs: []
  type: TYPE_NORMAL
- en: 'The search control (coming up next) deserves special attention because it contains
    multiple controls within it, and its behavior differs slightly across operating
    systems. It may have up to three sub-controls—a text field, a search button, and
    a cancel button. There may be a callback for the *Enter* key being pressed while
    the text field is active. If the search and cancel buttons are present, they have
    callbacks for being clicked. We can set up the search control and its callbacks
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'By contrast, the label, previous and next buttons, and bitmap do not have any
    sub-controls that concern us. We can set them up as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Our controls are lined up horizontally, with the search control on the left
    edge of the window, the previous and next buttons on the right edge, and the label
    halfway in-between the search control and previous button. We use an instance
    of `wx.BoxSizer` to define this horizontal layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The best thing about layouts (and Russian dolls) is that they can be nested,
    one inside another. Our horizontal layout of controls needs to appear below the
    bitmap. This relationship is a vertical layout, which we define using another
    `wx.BoxSizer` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: That is the end of the `__init__` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see in the following code, we provide getters and setters for the
    `verbose` property of our `ImageSearchSession` instance and our `HistogramClassifier`
    instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `_onCloseWindow` callback just cleans up the application by calling the
    `Destroy` method of the superclass. Here is its implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, we have connected the *Esc* key to the `_onQuitCommand` callback,
    which closes the window. This, in turn, will result in `_onCloseWindow` being
    called. Here is the implementation of `_onQuitCommand`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `_onSearchEntered` callback submits the query string through the search
    method of `ImageSearchSession`. Then, it calls a helper method, `_updateImageAndControls`,
    which asynchronously fetches images and updates the GUI, as we will see later.
    Here is the implementation of `_onSearchEntered`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `_onSearchCanceled` callback simply clears the search control''s text field,
    as seen in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Our remaining GUI event callbacks, `_onNextButtonClicked` and `_onPrevButtonClicked`,
    check whether more results are available and, if so, uses the `searchNext` or
    `searchPrev` method of `ImageSearchSession`. Then, using the `_updateImageAndControls`
    helper method, images are fetched asynchronously and the GUI is updated. Here
    are the implementations of the callbacks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The `_disableControls` method disables the search control and the previous
    and next buttons, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Conversely, the `_enableControls` method enables the search control, the previous
    button (if we are not already at the first available search result), and the next
    button (if we are not already at the last available search result). Here is the
    implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The `_updateImageAndControls` method first disables the controls because we
    do not want to handle any new queries until the current query is handled. Then,
    a busy cursor is shown and another helper method, `_updateImageAndControlsAsync`,
    is started on a background thread. Here is the implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The background method, `_updateImageAndControlsAsync`, starts by fetching an
    image and converting it into OpenCV format. If the image cannot be fetched and
    converted, an error message is used as the label. Otherwise, the image is classified
    and resized to an appropriate size for display. Then, the resized image and the
    classification label are passed to a third and final helper method, `_updateImageAndControlsResync`,
    which updates the GUI on the main thread. Here is the implementation of `_updateImageAndControlsAsync`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The synchronous callback, `_updateImageAndControlsResync`, hides the busy cursor,
    creates a wxPython bitmap from the fetched image (or just a black bitmap if no
    image was successfully fetched and converted), shows the image and its classification
    label, resizes GUI elements, re-enables controls, and refreshes the window. Here
    is its implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'When the image cannot be successfully fetched and converted, the user sees
    something like the following screenshot, containing a black placeholder image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7f60d4b5-d0cf-4e4a-9e10-f393b476c78d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Conversely, when an image is successfully fetched and converted, the users
    sees the classification result, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/38150fba-5da2-485f-bfb9-32b5adcd3007.png)'
  prefs: []
  type: TYPE_IMG
- en: 'That completes the implementation of the `Luxocator` class. Now, let''s write
    a `main` method to set resource paths and launch an instance of `Luxocator`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Note that one of the resources is a certificate bundle called `cacert.pem`.
    It is required by Requests in order to make an SSL connection, which is, in turn,
    required by Bing. You can find a copy of it inside this chapter's code bundle,
    which is downloadable from my website at [http://nummist.com/opencv/7376_02.zip](http://nummist.com/opencv/7376_02.zip).
    Place `cacert.pem` in the same folder as `Luxocator.py`. Note that our code sets
    an environment variable, `REQUESTS_CA_BUNDLE`, which is used by Requests to locate
    the certificate bundle.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on how it is installed or how it is bundled with an app, Requests
    may or may not have an internal version of the certificate bundle. For predictability,
    it is better to provide this external version.
  prefs: []
  type: TYPE_NORMAL
- en: Running Luxocator and troubleshooting SSL problems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At this point, you can run `Luxocator.py`, enter search keywords, and navigate
    through the results. Watch for any errors that Luxocator might print to the Terminal.
    On some systems, notably Ubuntu 14.04 and its derivatives, such as Linux Mint
    17, you might run into a bug in the Requests library when Luxocator attempts to
    access an HTTPS URL. The symptom of this bug is an error message similar to the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'If you encounter this problem, you can try to resolve it by installing additional
    SSL-related packages and downgrading Requests to an earlier version. Some users
    of Ubuntu 14.04 and its derivatives report that they resolved the problem by running
    the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Alternatively, some users of Ubuntu 14.04 and its derivatives report that they
    resolved the problem by upgrading to a newer version of the operating system.
    Note that the problem is not specific to Luxocator, but rather it affects any
    software that uses Requests, so it is potentially an issue of system-wide importance.
  prefs: []
  type: TYPE_NORMAL
- en: When you are satisfied with your results from testing Luxocator, let's proceed
    to build a Luxocator package that we can more easily distribute to other users'
    systems.
  prefs: []
  type: TYPE_NORMAL
- en: Building Luxocator for distribution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To tell PyInstaller how to build Luxocator, we must create a specification
    file, which we will call `Luxocator.spec`. Actually, the specification file is
    a Python script that uses a PyInstaller class called `Analysis` and the PyInstaller
    functions called `PYZ`, `EXE`, and `BUNDLE`. The `Analysis` class is responsible
    for analyzing one or more Python scripts (in our case, just `Luxocator.py`) and
    tracing all the dependencies that must be bundled with these scripts in order
    to make a redistributable application. Sometimes, `Analysis` makes mistakes or
    omissions, so we modify the list of dependencies after it is initialized. Then,
    we zip the scripts, make an executable, and (for Mac) make an app bundle using
    `PYZ`, `EXE`, and `BUNDLE`, respectively. Here is the implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that this script specifies three resource files that must be bundled with
    the app: `cacert.pem`, `classifier.mat`, and `winicon-windowed.ico`. We have already
    discussed `cacert.pem` in the previous section, and `classifier.mat` is the output
    of our main function in `HistogramClassifier.py`. The Windows icon file, `winicon-windowed.ico`,
    is included in this book''s GitHub repository in the `Chapter002/win` folder.
    Alternatively, you may provide your own icon file if you prefer.'
  prefs: []
  type: TYPE_NORMAL
- en: For more information about PyInstaller's `Analysis` class, specification files,
    and other functionality, see the official documentation at [https://pyinstaller.readthedocs.io/](https://pyinstaller.readthedocs.io/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s write a platform-specific shell script to clean any old builds,
    train our classifier, and then bundle the app using PyInstaller. On Windows, create
    a script called `build.bat`, containing the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: If `pyinstaller.exe` is not in your system's `Path`, you will need to change
    the `build.bat` script's definition of the `PYINSTALLER` variable in order to
    provide a full path to `pyinstaller.exe`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, on Mac or Linux, create a script called `build.sh`. Make it executable
    (for example, by running `$ chmod +x build.sh` in the Terminal). The file should
    contain the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: If the `pyinstaller` executable (or a similar executable, such as `pyinstaller-3.6` for
    Python 3.6)  is not in your system's `PATH`, you will need to change the `build.sh` script's
    definition of the `PYINSTALLER` variable in order to provide a full path to `pyinstaller`.
  prefs: []
  type: TYPE_NORMAL
- en: Note that on Mac (the Darwin platform), we are manually modifying the app bundle's
    contents as a post-build step. We do this in order to overwrite the default app
    icon and default properties file that PyInstaller puts in all Mac apps (notably,
    in some versions of PyInstaller, the default properties do not include support
    for Retina mode, so they make the app look pixelated on recent Mac hardware. Our
    customizations fix this issue). This book's GitHub repository includes the custom
    Mac app contents in a folder called `Chapter002/mac/Contents`. You may modify
    its files to provide any icon and properties you want.
  prefs: []
  type: TYPE_NORMAL
- en: After running the platform-specific build script, we should have a redistributable
    build of Luxocator at `dist/Luxocator.exe` (Windows), `dist/Luxocator.app` (Mac),
    or `dist/Luxocator` (Linux). If we are using 64-bit Python libraries on our development
    machine, this build will only work on 64-bit systems. Otherwise, it should work
    on both 32-bit and 64-bit systems. The best way to test the build is to run it
    on another machine that doesn't have any of the relevant libraries (such as OpenCV)
    installed.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So much can happen in a single mission! We trained an OpenCV/NumPy/SciPy histogram
    classifier, performed Bing Image Searches, built a `wxPython` app, and used PyInstaller
    to bundle it all for redistribution to Russia with love (or, indeed, to any destination
    with any sentiment). At this point, you are well-primed to create other Python
    applications that combine computer vision, web requests, and a GUI.
  prefs: []
  type: TYPE_NORMAL
- en: For our next mission, we will dig our claws deeper into OpenCV and computer
    vision by building a fully functional cat recognizer!
  prefs: []
  type: TYPE_NORMAL
