<html><head></head><body>
<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch02" class="calibre1"/>Chapter 2. Something We Look At – Graphical User Interfaces</h1></div></div></div><p class="calibre7">In this chapter, we will cover the main user interface capabilities included with the OpenCV library. We will start with the user interface functions included in the <code class="email">highgui</code> module. Then, we will deal with the insertion of objects (such as text and geometrical shapes) on<a id="id123" class="calibre1"/> the displayed windows to point out some specific <a id="id124" class="calibre1"/>characteristics on images. Finally, the chapter addresses the new Qt functions included in OpenCV to enrich the user experience.</p></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_1"><a id="ch02lvl1sec14" class="calibre1"/>Using OpenCV's highgui module</h1></div></div></div><p class="calibre7">The <code class="email">highgui</code> module<a id="id125" class="calibre1"/> has been designed to provide an easy way to visualize the results and try the functionality of developed applications with OpenCV. As we saw in the previous chapter, this module supplies functions to perform the following operations:</p><div><ul class="itemizedlist"><li class="listitem">Reading<a id="id126" class="calibre1"/> images and videos from files and live cameras (<code class="email">imread</code>) through a <code class="email">VideoCapture</code> object.</li><li class="listitem">Writing <a id="id127" class="calibre1"/>images and videos from memory to disk (<code class="email">imwrite</code>) through a <code class="email">VideoWriter</code> object.</li><li class="listitem">Creating a window that can display images and video frames (<code class="email">namedWindow</code> and <code class="email">imshow</code>).</li><li class="listitem">Fetching and handling events when a key is pressed (<code class="email">waitKey</code>).</li></ul></div><p class="calibre7">Of course, the module contains more functions to enhance the user interaction with the software applications. Some of them will be explained in this chapter. In the following <code class="email">tbContrast</code> code example, we can read an image file and two windows are created: the first one shows the original image and the other is the resulting image after increasing or decreasing the contrast to the original image applying a quite simple scaling operation. The following example shows how to create a trackbar in the window to easily change the contrast <a id="id128" class="calibre1"/>factor (scale) in the image. Let's see the code:</p><div><pre class="programlisting">#include "opencv2/core/core.hpp"
#include "opencv2/highgui/highgui.hpp"
#include &lt;iostream&gt;

using namespace std;
using namespace cv;

int main(int argc, char* argv[]) {
    const char in_win[]="Orig. image";
    const char out_win[]="Image converted...(no saved)";
    int TBvalContrast=50; // Initial value of the TrackBar
    Mat out_img;

    if (argc != 2) {
        cout &lt;&lt; "Usage: &lt;cmd&gt;&lt;input image_file&gt;" &lt;&lt; endl;
        return -1;
    }
    Mat in_img = imread(argv[1]); // Open and read the image
    if (in_img.empty()) {
        cout &lt;&lt; "Error!!! Image cannot be loaded..." &lt;&lt; endl;
        return -1;
    }
    namedWindow(in_win); // Creates window for orig. image
<strong class="calibre8">    moveWindow(in_win, 0, 0);</strong> // Move window to pos. (0, 0)
    imshow(in_win, in_img); // Shows original image
    namedWindow(out_win);
<strong class="calibre8">    createTrackbar("Contrast", out_win, &amp;TBvalContrast, 100);</strong>
    cout &lt;&lt; "Press Esc key to exit..." &lt;&lt; endl;
    while (true) {
<strong class="calibre8">    in_img.convertTo(out_img, -1, TBvalContrast/50.0);</strong>
        imshow(out_win, out_img);
        if (waitKey(50) == 27) // If Esc key pressed breaks
            break;
    }
    return 0;
}</pre></div><p class="calibre7">The following screenshot shows the original image (<code class="email">fruits.jpg</code>) and the same image with increased contrast obtained with the <code class="email">tbContrast</code> application.</p><div><img src="img/00008.jpeg" alt="Using OpenCV's highgui module" class="calibre9"/><div><p class="calibre13">Original image and the image with increased contrast</p></div></div><p class="calibre10"> </p><div><h3 class="title2"><a id="note05" class="calibre1"/>Note</h3><p class="calibre7">To avoid repetition in the examples, only the remarkable new portions of code are explained.</p></div><p class="calibre7">The code <a id="id129" class="calibre1"/>explanation is given as follows:</p><div><ul class="itemizedlist"><li class="listitem"><code class="email">void moveWindow(const string&amp; winname, int x, int y)</code>: This function <a id="id130" class="calibre1"/>moves the window to the specified screen (x, y) position being the origin point (0, 0) at the upper-left corner. When a window is created and displayed, its default position is at the center of the screen. That behavior is quite convenient if only one window is displayed. However, if several windows have to be shown, they are overlapped and should be moved in order to see their content. In the example, this function is used as follows:<div><pre class="programlisting">moveWindow(in_win,0,0);</pre></div><p class="calibre15">Now, the window that shows the original image is moved, after its creation, to the upper-left corner (origin) of the screen while the converted imaged is located at its default position (center of the screen).</p></li><li class="listitem"><code class="email">intcreateTrackbar(const string&amp;trackbarname, const string&amp;winname, int*value, intrange, TrackbarCallbackonChange=0, void*userdata=0)</code>: This function creates a <a id="id131" class="calibre1"/><strong class="calibre8">trackbar</strong> (a slider) attached to the window with the specified name and range. The position of the slider is synchronized with the <code class="email">value</code> variable. Moreover, it is possible to implement a <strong class="calibre8">callback</strong> function for being called after the <a id="id132" class="calibre1"/>slider moves. In this call, a pointer to the user<a id="id133" class="calibre1"/> data is passed as argument. In our code, this<a id="id134" class="calibre1"/> function is used as follows:<div><pre class="programlisting">createTrackbar("Contrast", out_win, &amp;TBvalContrast, 100);</pre></div><div><h3 class="title2"><a id="note06" class="calibre1"/>Note</h3><p class="calibre7">A callback is a function passed as an argument to another function. The callback function is passed as a pointer to the code, which is executed when an expected event occurs.</p></div><p class="calibre15">In this code, the trackbar is called <code class="email">"Contrast"</code> without a callback function linked to it. Initially, the slider is located at the middle (50) of the full range (100). This range allows a maximum scale factor of 2.0 (100/50).</p></li><li class="listitem"><code class="email">void Mat::convertTo(OutputArray m, int rtype, double alpha=1, double beta=0 ) const</code>: This function converts an array to another <a id="id135" class="calibre1"/>data type with an optional scaling. If <code class="email">rtype</code> is negative, the output matrix will have the same type as the input. The applied scaling applied formula is as follows:<div><pre class="programlisting">
<strong class="calibre8">m(x, y) = alfa(*this)(x, y) + beta,</strong>
</pre></div><p class="calibre15">In this code, a final implicit cast (<code class="email">saturate_cast&lt;&gt;</code>) is applied to avoid possible overflows. In the <code class="email">tbContrast</code> example, this function is used inside an infinite loop:</p><div><pre class="programlisting">while (true) {
    in_img.convertTo(out_img, -1, TBvalContrast/50.0);
    imshow(out_win, out_img);
    if (waitKey(50) == 27) // If Esc key pressed breaks
        break;
}</pre></div></li></ul></div><p class="calibre7">In the previous chapter, we saw code examples that can create an implicit infinite loop waiting for a pressed key with the function call <code class="email">waitKey</code> (without arguments). The events on the application main window (for example, trackbars, mouse, and so on) are caught and handled inside of that loop. On the contrary, in this example, we create an infinite loop <a id="id136" class="calibre1"/>with a <code class="email">while</code> statement applying the contrast change with the <code class="email">convertTo</code> function with a scale factor from <code class="email">0.0</code> (slider at <code class="email">0</code>) to <code class="email">2.0</code> (slider at <code class="email">100</code>). The infinite loop breaks when the <em class="calibre12">Esc</em> key (ASCII code 27) is pressed. The implemented contrast method is quite simple because the new values for the pixels are calculated by multiplying the original value by a factor greater than <code class="email">1.0</code> to increase contrast and a factor smaller than <code class="email">1.0</code> to decrease contrast. In this method, when a pixel value exceeds <code class="email">255</code> (in any channel), a rounding (saturate cast) has to be done.</p><div><h3 class="title2"><a id="note07" class="calibre1"/>Note</h3><p class="calibre7">In the next chapter, we will explain a more sophisticated algorithm to improve the image contrast using the image histogram equalization.</p></div><p class="calibre7">Then, in the <code class="email">tbContrastCallB</code> example, we show the same functionality, but using a <code class="email">trackbarcallback</code> function that is called every time the slider is moved. Note that the events are handled when the <code class="email">waitKey</code> function is called. The application ends if you press any key. The code is as follows:</p><div><pre class="programlisting">//… (omitted for brevity)
<strong class="calibre8">#define IN_WIN "Orig. image"</strong>
<strong class="calibre8">#define OUT_WIN "Image converted...(no saved)"</strong>
<strong class="calibre8">Mat in_img, out_img;</strong>

// CallBack function for contrast TrackBar
<strong class="calibre8">void updateContrast(int TBvalContrast, void *userData=0) {</strong>

<strong class="calibre8">    in_img.convertTo(out_img, -1, TBvalContrast/50.0);</strong>
<strong class="calibre8">    imshow(OUT_WIN, out_img);</strong>
<strong class="calibre8">    return;</strong>
<strong class="calibre8">}</strong>

int main(int argc, char* argv[]) {

    int TBvalContrast=50; // Value of the TrackBar

    // (omitted for simplicity)
    in_img = imread(argv[1]); // Open and read the image
    // (omitted for simplicity)
    in_img.copyTo(out_img); // Copy orig. image to final img
    namedWindow(IN_WIN); // Creates window for orig. image
    moveWindow(IN_WIN, 0, 0); // Move window to pos. (0, 0)
    imshow(IN_WIN, in_img); // Shows original image
    namedWindow(OUT_WIN); // Creates window for converted image
<strong class="calibre8">    createTrackbar("Contrast", OUT_WIN, &amp;TBvalContrast, 100,</strong>
                   updateContrast);
    imshow(OUT_WIN, out_img); // Shows converted image
    cout &lt;&lt; "Press any key to exit..." &lt;&lt; endl;
    waitKey();
    return 0;
}</pre></div><p class="calibre7">In this <a id="id137" class="calibre1"/>example, a <code class="email">void</code> pointer to the <code class="email">updatedContrast</code> function is passed as argument to the <code class="email">createTrackbar</code> function:</p><div><pre class="programlisting">createTrackbar("Contrast", OUT_WIN, &amp;TBvalContrast, 100,
updateContrast);</pre></div><p class="calibre7">The callback function gets as its first argument the value of the slider in the trackbar and a <code class="email">void</code> pointer to other user data. The new pixels values for the image will be calculated in this function.</p><div><h3 class="title2"><a id="note08" class="calibre1"/>Note</h3><p class="calibre7">In this example (and subsequent ones), some portions of code are not shown for brevity because the omitted code is the same as that in previous examples.</p></div><p class="calibre7">Using a callback function cause a few changes in this new code because the accessible data inside this function has to be defined with global scope. Then, more complexity is avoided on the datatypes passed to the callback function as follows:</p><div><ul class="itemizedlist"><li class="listitem">Windows names are defined symbols (for example, <code class="email">#define IN_WIN</code>). In the previous example (<code class="email">tbContrast</code>), the window names are stored in local variables (strings).</li><li class="listitem">In this case, the <code class="email">Mat</code> variables for the original (<code class="email">in_img</code>) and converted (<code class="email">out_img</code>) images are declared as global variables.</li></ul></div><div><h3 class="title2"><a id="tip03" class="calibre1"/>Tip</h3><p class="calibre7">Sometimes in this book, the sample code uses global variables for simplicity. Be extremely cautious with global variables since they can be changed anywhere in the code.</p></div><p class="calibre7">The two different implementations shown in the previous example produce the same results. However, it should be noted that after using a callback function, the resulting application (<code class="email">tbContrastCallB</code>) is more efficient because the math operations for the image <a id="id138" class="calibre1"/>conversion only take place at the change of the trackbar slide (when the callback is executed). In the first version (<code class="email">tbContrast</code>), the <code class="email">convertTo</code> function is called inside the <code class="email">while</code> loop even if the <code class="email">TBvalContrast</code> variable doesn't change.</p></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec15" class="calibre1"/>Text and drawing</h1></div></div></div><p class="calibre7">In the previous section, we used a simple user interface to get input values by a trackbar. However, in many applications, the user has to point locations and regions on the image and mark them <a id="id139" class="calibre1"/>with text labels. For this purpose, the <code class="email">highgui</code> module provides a <a id="id140" class="calibre1"/>set of drawing functions along with mouse event handling.</p><p class="calibre7">The <code class="email">drawThings</code> code example shows an easy application to mark positions on an input image. The positions are marked with a red circle and a black text label next to it. The following screenshot displays the window with the input image and the marked positions on it. To mark each position on the image, the user uses has to click the left mouse button over it. In other application, the marked position could be the obtained points or regions from an algorithm applied to the input image.</p><p class="calibre7">Next, we show the example code where some pieces of code have been omitted for simplicity, since they are duplicated in other previous examples:</p><div><pre class="programlisting">    // (omitted for simplicity)
#define IN_WIN "Drawing..."

Mat img;

// CallBack Function for mouse events
<strong class="calibre8">void cbMouse(int event, int x, int y, int flags, void* userdata)</strong> {

<strong class="calibre8">static</strong> int imark=0;
    char textm[] = "mark999";

    if (event == <strong class="calibre8">EVENT_LBUTTONDOWN</strong>) { // Left mouse button pressed
<strong class="calibre8">circle(img, Point(x, y), 4, Scalar(0,0,255), 2);</strong>
<strong class="calibre8">imark++;</strong>// Increment the number of marks
<strong class="calibre8">sprintf(textm, "mark %d", imark);// Set the mark text</strong>
<strong class="calibre8">putText(img, textm, Point(x+6, y), FONT_HERSHEY_PLAIN,</strong>
<strong class="calibre8">                1, Scalar(0,0,0),2);</strong>
<strong class="calibre8">imshow(IN_WIN, img);</strong> // Show final image
    }
    return;
}

int main(int argc, char* argv[]) {

    // (omitted for brevity)	
    img = imread(argv[1]); //open and read the image
    // (omitted for brevity)
    namedWindow(IN_WIN);
<strong class="calibre8">    setMouseCallback(IN_WIN, cbMouse, NULL);</strong>
    imshow(IN_WIN, img);
    cout &lt;&lt; "Pres any key to exit..." &lt;&lt; endl;
    waitKey();
    return 0;
}</pre></div><p class="calibre7">The code<a id="id141" class="calibre1"/> explanation<a id="id142" class="calibre1"/> is given as follows:</p><div><ul class="itemizedlist"><li class="listitem"><code class="email">void setMouseCallback(const string&amp; winname, MouseCallback onMouse, void* userdata=0)</code>: This function sets an event mouse handler for the <a id="id143" class="calibre1"/>specified window. In this function, the second argument is the callback function executed whenever a mouse event occurs. The final argument is a <code class="email">void</code> pointer to the data passed as argument to that function. In our code, this function is used as follows:<div><pre class="programlisting">setMouseCallback(IN_WIN, cbMouse, NULL);</pre></div><p class="calibre15">In this case, rather than use a global variable for the name of the window, a defined symbol with global scope has been preferred (<code class="email">IN_WIN</code>).</p><div><img src="img/00009.jpeg" alt="Text and drawing" class="calibre9"/><div><p class="calibre13">Image with circles and text on it</p></div></div><p class="calibre14"> </p><p class="calibre15">The mouse handler itself is declared as follows:</p><div><pre class="programlisting">void cbMouse(int event, int x, int y, int flags, void* userdata)</pre></div><p class="calibre15">Here, <code class="email">event</code> indicates the mouse event type, <code class="email">x</code> and <code class="email">y</code> are the coordinates <a id="id144" class="calibre1"/>for the location of the event at the<a id="id145" class="calibre1"/> window, and <code class="email">flags</code> is the specific condition whenever an event occurs. In this example, the unique captured mouse event is the left mouse click (<code class="email">EVENT_LBUTTONDOWN</code>).</p><p class="calibre15">The following enumerations define the events and flags handled in the mouse callback functions:</p><div><pre class="programlisting">enum{
  EVENT_MOUSEMOVE      =0,
    EVENT_LBUTTONDOWN    =1,
    EVENT_RBUTTONDOWN    =2,
    EVENT_MBUTTONDOWN    =3,
    EVENT_LBUTTONUP      =4,
    EVENT_RBUTTONUP      =5,
    EVENT_MBUTTONUP      =6,
    EVENT_LBUTTONDBLCLK  =7,
    EVENT_RBUTTONDBLCLK  =8,
    EVENT_MBUTTONDBLCLK  =9};

enum {
    EVENT_FLAG_LBUTTON   =1,
    EVENT_FLAG_RBUTTON   =2,
    EVENT_FLAG_MBUTTON   =4,
    EVENT_FLAG_CTRLKEY   =8,
    EVENT_FLAG_SHIFTKEY  =16,
    EVENT_FLAG_ALTKEY    =32};</pre></div></li><li class="listitem"><code class="email">void circle(Mat&amp; img, Point center, int radius, const Scalar&amp; color, int thickness=1, int lineType=8, int shift=0)</code>: This<a id="id146" class="calibre1"/> function draws a circle over the image with the specified <code class="email">radius</code> (in pixels) and <code class="email">color</code> at the position marked by its <code class="email">center</code>. Moreover, a <code class="email">thickness</code> value for the line and other additional parameters can be set. The <a id="id147" class="calibre1"/>usage of this function in the example is as<a id="id148" class="calibre1"/> follows:<div><pre class="programlisting">circle(img, Point(x, y), 4, Scalar(0,0,255), 2);</pre></div><p class="calibre15">The center of the circle is the point where the mouse is clicked. The radius has <code class="email">4</code> pixels and the color is pure red (<code class="email">Scalar(0, 0, 255)</code>) with a line thickness of <code class="email">2</code> pixels.</p><div><h3 class="title2"><a id="note09" class="calibre1"/>Note</h3><p class="calibre7">Remember that OpenCV uses a BGR color scheme and the <code class="email">Scalar</code> class is used to represent the three (or four if opacity channel is considered) channels of each pixel with greater values for a brighter one (or more opaque).</p></div><p class="calibre15">Other drawing functions included in the <code class="email">highgui</code> module allow us to draw ellipses, lines, rectangles, and polygons.</p></li><li class="listitem"><code class="email">void putText(Mat&amp; image, const string&amp; text, Point org, int fontFace, double fontScale, Scalar color, int thickness=1, int lineType=8, bool bottomLeftOrigin=false)</code>: This function draws <a id="id149" class="calibre1"/>a <code class="email">text</code> string in the <code class="email">image</code> at the specified position (<code class="email">org</code>) with the properties set by the arguments <code class="email">fontFace</code>, <code class="email">fontScale</code>, <code class="email">color</code>, <code class="email">thickness</code>, and <code class="email">lineType</code>. It is possible to set the coordinates origin at the bottom-left corner with the last argument (<code class="email">bottomLeftOrigin</code>). In the example, this function is used as follows:<div><pre class="programlisting">imark++; // Increment the number of marks
sprintf(textm, "mark %d", imark); // Set the mark text
putText(img, textm, Point(x+6, y), FONT_HERSHEY_PLAIN,
1.0, Scalar(0,0,0),2);</pre></div><p class="calibre15">In the <code class="email">drawThings</code> example, we draw a text <code class="email">"mark"</code> followed by an increasing number that points out the mark order. To store the mark order, we used a <code class="email">static</code> variable (<code class="email">imark</code>) that maintains its value between the calls. The <code class="email">putText</code> function draws the text at the location where the mouse click occurs with a 6-pixels shift on <em class="calibre12">x</em> axis. The font face is specified by the flag <code class="email">FONT_HERSHEY_PLAIN</code> and is drawn without scale (<code class="email">1.0</code>), black color (<code class="email">Scalar(0, 0, 0)</code>), and <code class="email">2</code> pixels thickness.</p><p class="calibre15">The <a id="id150" class="calibre1"/>available<a id="id151" class="calibre1"/> flags for the font face are defined by the enumeration:</p><div><pre class="programlisting">enum{
    FONT_HERSHEY_SIMPLEX = 0,
    FONT_HERSHEY_PLAIN = 1,
    FONT_HERSHEY_DUPLEX = 2,
    FONT_HERSHEY_COMPLEX = 3,
    FONT_HERSHEY_TRIPLEX = 4,
    FONT_HERSHEY_COMPLEX_SMALL = 5,
    FONT_HERSHEY_SCRIPT_SIMPLEX = 6,
    FONT_HERSHEY_SCRIPT_COMPLEX = 7,
    FONT_ITALIC = 16};</pre></div></li></ul></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec16" class="calibre1"/>Selecting regions</h1></div></div></div><p class="calibre7">Many computer vision applications require to focus interest inside local regions of the images. In that case, it is a very <a id="id152" class="calibre1"/>useful user tool to select the <a id="id153" class="calibre1"/>desired <strong class="calibre8">regions of interest</strong> (<strong class="calibre8">ROI</strong>). In the <code class="email">drawRs</code> example, we show how to select, with the mouse, rectangular regions in the image to locally increase the contrast inside these regions (as shown in the following screenshot). For better control over region selection, we implement a click-and-drag behavior to reshape the rectangular boundary of each region.</p><div><img src="img/00010.jpeg" alt="Selecting regions" class="calibre9"/><div><p class="calibre13">Output image with increased contrast in some rectangular regions</p></div></div><p class="calibre10"> </p><p class="calibre7">For the<a id="id154" class="calibre1"/> sake of simplicity, only the code corresponding to the function callback for mouse events is shown, since the rest is quite similar in the previous examples. The code is as follows:</p><div><pre class="programlisting">void cbMouse(int event, int x, int y, int flags, void* userdata) {

  static Point p1, p2; // Static vars hold values between calls
  static bool p2set = false;

  if (event == EVENT_LBUTTONDOWN) { // Left mouse button pressed
      p1 = Point(x, y); // Set orig. point
      p2set = false;
  } else if (event == EVENT_MOUSEMOVE &amp;&amp;
flags == EVENT_FLAG_LBUTTON) {
      if (x &gt;<strong class="calibre8">orig_img.size().width</strong>) // Check out of bounds
          x = orig_img.size().width;
      else if (x &lt; 0)
          x = 0;
      if (y &gt;<strong class="calibre8">orig_img.size().height</strong>) // Check out of bounds
          y = orig_img.size().height;
      else if (y &lt; 0)
          y = 0;
      p2 = Point(x, y); // Set final point
      p2set = true;
<strong class="calibre8">orig_img.copyTo(tmp_img); // Copy orig. to temp. image</strong>
<strong class="calibre8">rectangle(tmp_img, p1, p2, Scalar(0, 0, 255));</strong>
      imshow(IN_WIN, tmp_img); // Draw temporal image with rect.
  } else if (event == EVENT_LBUTTONUP &amp;&amp; p2set) {
<strong class="calibre8">Mat submat = orig_img(Rect(p1, p2)); // Set region</strong>
      submat.convertTo(submat, -1, 2.0); // Compute contrast
   rectangle(orig_img, p1, p2, Scalar(0, 0, 255));
      imshow(IN_WIN, orig_img); // Show image
  }
  return;
}</pre></div><p class="calibre7">The callback <a id="id155" class="calibre1"/>function declares <code class="email">static</code> its local variables, so they maintain their values between calls. The variables, <code class="email">p1</code> and <code class="email">p2</code>, store the points for defining the rectangular region of interest, and <code class="email">p2set</code> holds the Boolean (<code class="email">bool</code>) value that indicates if point <code class="email">p2</code> is set. When <code class="email">p2set</code> is <code class="email">true</code>, a new selected region can be drawn and its new values computed.</p><p class="calibre7">The mouse callback function handles the following events:</p><div><ul class="itemizedlist"><li class="listitem"><code class="email">EVENT_LBUTTONDOWN</code>: This button is also called left button down. The initial position (<code class="email">p1</code>) is <a id="id156" class="calibre1"/>set to <code class="email">Point(x, y)</code> where the event occurs. Also, the <code class="email">p2set</code> variable is set to <code class="email">false</code>.</li><li class="listitem"><code class="email">EVENT_MOUSEMOVE &amp;&amp; EVENT_FLAG_LBUTTON</code>: Move the mouse with the left<a id="id157" class="calibre1"/> button down. First, the boundaries should be checked so that we can correct coordinates and avoid errors just in case the final point is out of the window. Then, the temporal <code class="email">p2</code> point is set to the final position of the mouse and <code class="email">p2set</code> is set to <code class="email">true</code>. Finally, a temporal image is shown in the window with the rectangle drawn on it.</li><li class="listitem"><code class="email">EVENT_LBUTTONUP</code>: This <a id="id158" class="calibre1"/>button is also called left button up and is valid only if <code class="email">p2set</code> is <code class="email">true</code>.The final region is selected. Then a subarray can be pointed in the original image for further computation. After that, a rectangle around the final region is drawn in the original image and the result is shown into the application window.</li></ul></div><p class="calibre7">Next, we take a closer look at the code:</p><div><ul class="itemizedlist"><li class="listitem"><code class="email">Size Mat::size() const:</code> Returns the matrix size <code class="email">(Size(cols, rows))</code>: This <a id="id159" class="calibre1"/>function is used to get the bounds of the image (<code class="email">orig_img</code>) as follows:<div><pre class="programlisting">if (x &gt; orig_img.size().width) // Check out bounds
            x = orig_img.size().width;
        else if (x &lt; 0)
            x = 0;
        if (y &gt; orig_img.size().height) // Check out bounds
            y = orig_img.size().height;</pre></div><p class="calibre15">Since <code class="email">Mat::size()</code> returns a <code class="email">Size</code> object, we can access its members <code class="email">width</code> and <code class="email">height</code> to obtain the greatest values for <code class="email">x</code> and <code class="email">y</code> in the image (<code class="email">orig_img</code>) and compare those with the coordinates where the mouse event take place.</p></li><li class="listitem"><code class="email">void Mat::copyTo(OutputArray m) const</code>: This method copies the matrix to <a id="id160" class="calibre1"/>another one, reallocating new size and type if it is needed. Before copying, the following method<a id="id161" class="calibre1"/> invokes:<div><pre class="programlisting">
<strong class="calibre8">m.create(this-&gt;size(), this-&gt;type());</strong>
</pre></div><p class="calibre15">In the example, the following method is employed to make a temporal copy of the original image:</p><div><pre class="programlisting">orig_img.copyTo(tmp_img); // Copy orig. to temp. image</pre></div><p class="calibre15">The rectangle that defines the selected region is drawn over this temporal image.</p></li><li class="listitem"><code class="email">void rectangle(Mat&amp; img, Point pt1, Point pt2, const Scalar&amp; color, int thickness=1, int lineType=8, int shift=0)</code>: This<a id="id162" class="calibre1"/> function draws a rectangle defined by points <code class="email">pt1</code> and <code class="email">pt2</code> over the image (<code class="email">img</code>) with the specified <code class="email">color</code>, <code class="email">thickness</code>, and <code class="email">lineType</code>. In the code example, this function is used twice. First, to draw a red (<code class="email">Scalar(0, 0, 255)</code>) rectangle on the temporal image (<code class="email">tmp_img</code>) around the selected area, and then to draw the boundaries of the final selected region in the original image (<code class="email">orig_img</code>):<div><pre class="programlisting">rectangle(tmp_img, p1, p2, Scalar(0, 0 ,255));
//…
rectangle(orig_img, p1, p2, Scalar(0, 0, 255));</pre></div></li><li class="listitem"><code class="email">Mat::Mat(const Mat&amp; m, const Rect&amp; roi)</code>: The constructor takes a submatrix of <code class="email">m</code> limited by the rectangle (<code class="email">roi</code>) that represents a region of interest in the image stored in <code class="email">m</code>. This constructor is applied, in the code example, to <a id="id163" class="calibre1"/>get the rectangular region <a id="id164" class="calibre1"/>whose contrast has to be converted:<div><pre class="programlisting">Mat submat = orig_img(Rect(p1, p2));// Set subarray on orig. image</pre></div></li></ul></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec17" class="calibre1"/>Using Qt-based functions</h1></div></div></div><p class="calibre7">While <code class="email">highgui</code> will be sufficient for most purposes, the Qt UI framework (available at <a class="calibre1" href="http://qt-project.org/">http://qt-project.org/</a>) can be leveraged in OpenCV to develop richer user interfaces. A <a id="id165" class="calibre1"/>number of OpenCV's user interface functions use<a id="id166" class="calibre1"/> the Qt library behind the scenes. In order to use these functions, OpenCV must have been compiled with the <code class="email">WITH_QT</code> option.</p><p class="calibre7">Note that Qt is a class and <strong class="calibre8">widget</strong> library that allows the creation of full-fledged applications with rich, event-driven user interfaces. In this section, however, we will mainly focus on specific Qt-based functions within OpenCV. Programming with Qt is out of the scope of this book.</p><p class="calibre7">With Qt support on, windows created with the <code class="email">namedWindow</code> function will automatically look like what is shown in the following screenshot. There is a toolbar with useful functions such as pan, zoom, and save image. Windows also display a status bar at the bottom with the current mouse location and RGB value under that pixel. Right-clicking on the image will display a pop-up menu with the same toolbar options.</p><div><img src="img/00011.jpeg" alt="Using Qt-based functions" class="calibre9"/><div><p class="calibre13">Window displayed with Qt support enabled</p></div></div><p class="calibre10"> </p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch02lvl2sec11" class="calibre1"/>Text overlays and status bar</h2></div></div></div><p class="calibre7">Text can be <a id="id167" class="calibre1"/>displayed on a line across the top of the image. This<a id="id168" class="calibre1"/> is very useful to show frames per second, number <a id="id169" class="calibre1"/>of detections, filenames, and so on. The main function is <code class="email">displayOverlay(const string&amp; winname, const string&amp; text, int delayms=0)</code>. The function expects a window identifier and the text to display. Multiple<a id="id170" class="calibre1"/> lines are allowed by using the <code class="email">\n</code> character in the text string. The text will be displayed in the center and has a fixed size. The <code class="email">delayms</code> parameter allows to display the text only for a specified amount of milliseconds (<code class="email">0=forever</code>).</p><p class="calibre7">We can also display user text in the status bar. This text will replace the default <em class="calibre12">x</em> and <em class="calibre12">y</em> coordinates and RGB value under the current pixel. The <code class="email">displayStatusBar(const string&amp; winname, const string&amp; text, int delayms=0)</code> function has the same parameters as the previous <code class="email">displayOverlay</code> function. When the delay has passed, the default status bar text will be displayed.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch02lvl2sec12" class="calibre1"/>The properties dialog</h2></div></div></div><p class="calibre7">One of the most useful features of OpenCV's Qt-based functions is the properties dialog window. This <a id="id171" class="calibre1"/>window can be used to place trackbars and<a id="id172" class="calibre1"/> buttons. Again, this comes in handy while tuning parameters for our application. The properties dialog window can be accessed by pressing the last button in the toolbar (as shown in the preceding screenshot) or by pressing <em class="calibre12">Ctrl</em> + <em class="calibre12">P</em>. The window will only be accessible if trackbars or button have been assigned to it. To create a trackbar for the properties dialog, simply use the <code class="email">createTrackbar</code> function<a id="id173" class="calibre1"/> passing an empty string (not <code class="email">NULL</code>) as the window name.</p><p class="calibre7">Buttons can also be added to the properties dialog. Since both the original window and the dialog windows can be visible at the same time, this can be useful to activate/deactivate features in our application and see the results immediately. To add buttons to the dialog, use the <code class="email">createButton(const string&amp; button_name, ButtonCallback on_change, void* userdata=NULL,inttype=CV_PUSH_BUTTON, bool initial_button_state=0)</code> function. The first parameter is the button label (that is, the text to be displayed in the button). Every time the button changes its state, the <code class="email">on_change</code> callback function will be called. This should be in the form <code class="email">void on_change(intstate, void *userdata)</code>. The userdata pointer passed to <code class="email">createButton</code> will be passed to this callback function every time it is called. The state parameter signals the button change and it will have a different value for each type of button, given by parameter types:</p><div><ul class="itemizedlist"><li class="listitem"><code class="email">CV_PUSH_BUTTON</code>: Push button</li><li class="listitem"><code class="email">CV_CHECKBOX</code>: Checkbox button; the state will be either 1 or 0</li><li class="listitem"><code class="email">CV_RADIOBOX</code>: Radiobox button; the state will be either 1 or 0</li></ul></div><p class="calibre7">For the<a id="id174" class="calibre1"/> first two types, the callback is called once on each <a id="id175" class="calibre1"/>press. For the radiobox button, it is called both for the button just clicked and for the button that goes unclicked.</p><p class="calibre7">Buttons are organized into button bars. Button bars occupy one row in the dialog window. Each new button is added to the right of the last one. Trackbars take up an entire row, so button bars are terminated when a trackbar is added. The following <code class="email">propertyDlgButtons</code> example shows how buttons and trackbars are laid out in the properties dialog:</p><div><pre class="programlisting">#include "opencv2/core/core.hpp"
#include "opencv2/highgui/highgui.hpp"
#include &lt;iostream&gt;

using namespace std;
using namespace cv;

Mat image;
const char win[]="Flip image";

void on_flipV(int state, void *p)
{
    flip(image, image, 0);  // flip vertical
    imshow(win, image);
}

void on_flipH(int state, void *p)
{
    flip(image, image, 1);  // flip horizontal
    imshow(win, image);
}

void on_negative(int state, void *p)
{
    bitwise_not(image, image);  // invert all channels
    imshow(win, image);
}

int main(int argc, char *argv[])
{
    if (argc != 2) {//Check args.
        cout &lt;&lt; "Usage: &lt;cmd&gt;&lt;file_in&gt;\n";
        return -1;
    }
    image = imread(argv[1]);
    if (image.empty()) {
        cout &lt;&lt; "Error! Input image cannot be read...\n";
        return -1;
    }

    namedWindow(win);
    imshow(win, image);
    displayOverlay(win, argv[1], 0);
    createButton("Flip Vertical", on_flipV, NULL, CV_PUSH_BUTTON);
    createButton("Flip Horizontal", on_flipH, NULL, CV_PUSH_BUTTON);
    int v=0;
    createTrackbar("trackbar1", "", &amp;v, 255);
    createButton("Negative", on_negative, NULL, CV_CHECKBOX);

    cout &lt;&lt; "Press any key to exit...\n";
    waitKey();
    return 0;
}</pre></div><p class="calibre7">This code is <a id="id176" class="calibre1"/>similar to the <code class="email">flipImage</code> example in<a id="id177" class="calibre1"/> the previous chapter. In this example, an image filename is passed as an argument. A properties window is created with two buttons for vertical and horizontal flipping, a dummy trackbar, and a checkbox button to invert color intensities. The callback functions <code class="email">on_flipV</code> and <code class="email">on_flipH</code> simply flip the current image and show the result (we use a global image variable for this), while the callback function <code class="email">on_negative</code> logically inverts color intensities and shows the result. Note that the <a id="id178" class="calibre1"/>trackbar is not really being used; it is used to show the <strong class="calibre8">line feed</strong> effect. The following screenshot shows the result:</p><div><img src="img/00012.jpeg" alt="The properties dialog" class="calibre9"/><div><p class="calibre13">The propertyDlgButtons example</p></div></div><p class="calibre10"> </p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch02lvl2sec13" class="calibre1"/>Windows properties</h2></div></div></div><p class="calibre7">As mentioned <a id="id179" class="calibre1"/>previously, by default, all new windows <a id="id180" class="calibre1"/>will look like what's shown in the screenshot in the <em class="calibre12">Using Qt-based functions</em> section. Still, we can display windows in the non-Qt format by passing the <code class="email">CV_GUI_NORMAL</code> option to <code class="email">namedWindow</code>. On the other hand, window size parameters can be retrieved and set using the <code class="email">double getWindowProperty(const string&amp; winname, int prop_id)</code> and <code class="email">setWindowProperty (const string&amp; winname, int prop_id,double prop_value)</code> functions. The following table shows the properties that can be changed:</p><div><table border="1" class="calibre17"><colgroup class="calibre18"><col class="calibre19"/><col class="calibre19"/><col class="calibre19"/></colgroup><thead class="calibre20"><tr class="calibre21"><th valign="bottom" class="calibre22">
<p class="calibre23">Property (<code class="literal">prop_id</code>)</p>
</th><th valign="bottom" class="calibre22">
<p class="calibre23">Description</p>
</th><th valign="bottom" class="calibre22">
<p class="calibre23">Possible values</p>
</th></tr></thead><tbody class="calibre24"><tr class="calibre21"><td valign="top" class="calibre25">
<p class="calibre23">
<code class="literal">CV_WND_PROP_FULLSCREEN</code>
</p>
</td><td valign="top" class="calibre25">
<p class="calibre23">Displays<a id="id181" class="indexterm"/> a fullscreen <a id="id182" class="indexterm"/>or regular window</p>
</td><td valign="top" class="calibre25">
<p class="calibre23">
<code class="literal">CV_WINDOW_NORMAL</code> or <code class="literal">CV_WINDOW_FULLSCREEN</code>
</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre25">
<p class="calibre23">
<code class="literal">CV_WND_PROP_AUTOSIZE</code>
</p>
</td><td valign="top" class="calibre25">
<p class="calibre23">Window automatically resizes<a id="id183" class="indexterm"/> to <a id="id184" class="indexterm"/>fit the displayed image</p>
</td><td valign="top" class="calibre25">
<p class="calibre23">
<code class="literal">CV_WINDOW_NORMAL</code> or <code class="literal">CV_WINDOW_AUTOSIZE</code>
</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre25">
<p class="calibre23">
<code class="literal">CV_WND_PROP_ASPECTRATIO</code>
</p>
</td><td valign="top" class="calibre25">
<p class="calibre23">Allows resized windows<a id="id185" class="indexterm"/> to have<a id="id186" class="indexterm"/> any ratio or fixed original ratio</p>
</td><td valign="top" class="calibre25">
<p class="calibre23">
<code class="literal">CV_WINDOW_FREERATIO</code> or <code class="literal">CV_WINDOW_KEEPRATIO</code>
</p>
</td></tr></tbody></table></div><p class="calibre7">More<a id="id187" class="calibre1"/> importantly, window properties can be saved. This <a id="id188" class="calibre1"/>includes not only size and location, but also flags, trackbar values, zoom, and panning location. To save and load window properties, use the <code class="email">saveWindowParameters(const string&amp; windowName)</code> and <code class="email">loadWindowParameters(const string&amp; windowName)</code> functions.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_4"><a id="ch02lvl2sec14" class="calibre1"/>Qt images</h2></div></div></div><p class="calibre7">If we want to use the<a id="id189" class="calibre1"/> Qt libraries extensively in our project (that is, beyond OpenCV's Qt-based functions), we have to find a way to convert OpenCV's images to<a id="id190" class="calibre1"/> the format used by Qt (<code class="email">QImage</code>). This can be done by using the following function:</p><div><pre class="programlisting">QImage* Mat2Qt(const Mat &amp;image)
{
Mat temp=image.clone();
cvtColor(image, temp, CV_BGR2RGB);
QImage *imgQt= new QImage((const unsigned char*)(temp.data),temp.cols,temp.rows,QImage::Format_RGB888);
return imgQt;
}</pre></div><p class="calibre7">This function creates a Qt image using OpenCV's image data. Note that a conversion is first necessary, since Qt uses RGB images while OpenCV uses BGR order.</p><p class="calibre7">Finally, to display the image with Qt, we have at least two options:</p><div><ul class="itemizedlist"><li class="listitem">Create a class that extends the <code class="email">QWidget</code> class and implements paint events.</li><li class="listitem">Create a label and set it to draw an image (using the <code class="email">setPixMap</code> method).</li></ul></div></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec18" class="calibre1"/>Summary</h1></div></div></div><p class="calibre7">In this chapter, we provided a deeper view of the <code class="email">highgui</code> module functionality to enrich the user experience. The main elements supplied by OpenCV to build graphical user interfaces are shown in some code samples. Moreover, we reviewed the new Qt functionality inside OpenCV.</p><p class="calibre7">The chapter's examples cover topics such as <code class="email">tbarContrast</code>, <code class="email">tbarContrastCallB</code>, <code class="email">drawThings</code>, <code class="email">drawRs</code>, and <code class="email">propertyDlgButtons</code>.</p><p class="calibre7">The next chapter will cover the implementation of the most usual methods used for image processing, such as brightness control, contrast and color conversion, retina filtering, and geometrical transformations.</p></div></body></html>