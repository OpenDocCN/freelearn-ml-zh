["```py\nif(!\"recommenderlab\" %in% rownames(installed.packages())){install.packages(\"recommenderlab\")}\n```", "```py\nlibrary(\"recommenderlab\")\nhelp(package = \"recommenderlab\")\n```", "```py\nset.seed(1)\n```", "```py\ndata_package <- data(package = \"recommenderlab\")\ndata_package$results[, \"Item\"]\n```", "```py\ndata(MovieLense)\nMovieLense\n## 943 x 1664 rating matrix of class 'realRatingMatrix' with 99392 ratings.\n```", "```py\nclass(MovieLense)\n## [1] \"realRatingMatrix\"\n## attr(,\"package\")\n## [1] \"recommenderlab\"\n```", "```py\nmethods(class = class(MovieLense))\n```", "```py\nobject.size(MovieLense)\n## 1388448 bytes\nobject.size(as(MovieLense, \"matrix\"))\n## 12740464 bytes\n```", "```py\nobject.size(as(MovieLense, \"matrix\")) / object.size(MovieLense)\n## 9.17604692433566 bytes\n```", "```py\nsimilarity_users <- similarity(MovieLense[1:4, ], method = \"cosine\", which = \"users\")\n```", "```py\nclass(similarity_users)\n## [1] \"dist\"\n```", "```py\nas.matrix(similarity_users)\n```", "```py\nimage(as.matrix(similarity_users), main = \"User similarity\")\n```", "```py\nsimilarity_items <- similarity(MovieLense[, 1:4], method = \"cosine\", which = \"items\")\nas.matrix(similarity_items)\n```", "```py\nimage(as.matrix(similarity_items), main = \"Item similarity\")\n```", "```py\nrecommender_models <- recommenderRegistry$get_entries(dataType = \"realRatingMatrix\")\n```", "```py\nnames(recommender_models)\n```", "```py\nlapply(recommender_models, \"[[\", \"description\")\n## $IBCF_realRatingMatrix\n## [1] \"Recommender based on item-based collaborative filtering (real data).\"\n##\n## $PCA_realRatingMatrix\n## [1] \"Recommender based on PCA approximation (real data).\"\n##\n## $POPULAR_realRatingMatrix## [1] \"Recommender based on item popularity (real data).\"\n##\n## $RANDOM_realRatingMatrix\n## [1] \"Produce random recommendations (real ratings).\"\n##\n## $SVD_realRatingMatrix\n## [1] \"Recommender based on SVD approximation (real data).\"\n##\n## $UBCF_realRatingMatrix\n## [1] \"Recommender based on user-based collaborative filtering (real data).\"\n```", "```py\nrecommender_models$IBCF_realRatingMatrix$parameters\n```", "```py\nlibrary(\"recommenderlab\")\nlibrary(\"ggplot2\")\ndata(MovieLense)\nclass(MovieLense)\n## [1] \"realRatingMatrix\"\n## attr(,\"package\")\n## [1] \"recommenderlab\"\n```", "```py\ndim(MovieLense)\n## [1]  943 1664\n```", "```py\nslotNames(MovieLense)\n## [1] \"data\"      \"normalize\"\nMovieLense contains a data slot. Let's take a look at it.\nclass(MovieLense@data)\n## [1] \"dgCMatrix\"\n## attr(,\"package\")\n## [1] \"Matrix\"\ndim(MovieLense@data)\n## [1]  943 1664\n```", "```py\nvector_ratings <- as.vector(MovieLense@data)\nunique(vector_ratings)\n## [1] 5 4 0 3 1 2\nThe ratings are integers in the range 0-5\\. Let's count the occurrences of each of them.\ntable_ratings <- table(vector_ratings)\ntable_ratings\n```", "```py\nvector_ratings <- vector_ratings[vector_ratings != 0]\n```", "```py\nvector_ratings <- factor(vector_ratings)\n```", "```py\nqplot(vector_ratings) + ggtitle(\"Distribution of the ratings\")\n```", "```py\nviews_per_movie <- colCounts(MovieLense)\n```", "```py\ntable_views <- data.frame(\n  movie = names(views_per_movie),\n  views = views_per_movie\n  )\ntable_views <- table_views[order(table_views$views, decreasing = TRUE), ]\n```", "```py\nggplot(table_views[1:6, ], aes(x = movie, y = views)) + geom_bar(stat=\"identity\") + theme(axis.text.x = element_text(angle = 45, hjust = 1)) + ggtitle(\"Number of views of the top movies\")\n```", "```py\naverage_ratings <- colMeans(MovieLense)\n```", "```py\nqplot(average_ratings) + stat_bin(binwidth = 0.1) + ggtitle(\"Distribution of the average movie rating\")\n```", "```py\naverage_ratings_relevant <- average_ratings[views_per_movie > 100]\n```", "```py\nqplot(average_ratings_relevant) + stat_bin(binwidth = 0.1) + ggtitle(paste(\"Distribution of the relevant average ratings\"))\n```", "```py\nimage(MovieLense, main = \"Heatmap of the rating matrix\")\n```", "```py\nimage(MovieLense[1:10, 1:15], main = \"Heatmap of the first rows and columns\")\n```", "```py\nmin_n_movies <- quantile(rowCounts(MovieLense), 0.99)\nmin_n_users <- quantile(colCounts(MovieLense), 0.99)\nmin_n_movies\n##    99%\n## 440.96\nmin_n_users\n##    99%\n## 371.07\n```", "```py\nimage(MovieLense[rowCounts(MovieLense) > min_n_movies, colCounts(MovieLense) > min_n_users], main = \"Heatmap of the top users and movies\")\n```", "```py\nratings_movies <- MovieLense[rowCounts(MovieLense) > 50, colCounts(MovieLense) > 100] ratings_movies\n## 560 x 332 rating matrix of class 'realRatingMatrix' with 55298 ratings.\n```", "```py\n# visualize the top matrix\nmin_movies <- quantile(rowCounts(ratings_movies), 0.98)\nmin_users <- quantile(colCounts(ratings_movies), 0.98)\n```", "```py\nimage(ratings_movies[rowCounts(ratings_movies) > min_movies, colCounts(ratings_movies) > min_users], main = \"Heatmap of the top users and movies\")\n```", "```py\naverage_ratings_per_user <- rowMeans(ratings_movies)\n```", "```py\nqplot(average_ratings_per_user) + stat_bin(binwidth = 0.1) + ggtitle(\"Distribution of the average rating per user\")\n```", "```py\nratings_movies_norm <- normalize(ratings_movies)\n```", "```py\nsum(rowMeans(ratings_movies_norm) > 0.00001)\n## [1] 0\n```", "```py\n# visualize the normalized matrix\nimage(ratings_movies_norm[rowCounts(ratings_movies_norm) > min_movies, colCounts(ratings_movies_norm) > min_users], main = \"Heatmap of the top users and movies\")\n```", "```py\nratings_movies_watched <- binarize(ratings_movies, minRating = 1)\n```", "```py\nmin_movies_binary <- quantile(rowCounts(ratings_movies), 0.95)\nmin_users_binary <- quantile(colCounts(ratings_movies), 0.95)\n```", "```py\nimage(ratings_movies_watched[rowCounts(ratings_movies) > min_movies_binary,colCounts(ratings_movies) > min_users_binary], main = \"Heatmap of the top users and movies\")\n```", "```py\nratings_movies_good <- binarize(ratings_movies, minRating = 3)\n```", "```py\nimage(ratings_movies_good[rowCounts(ratings_movies) > min_movies_binary, colCounts(ratings_movies) > min_users_binary], main = \"Heatmap of the top users and movies\")\n```", "```py\nwhich_train <- sample(x = c(TRUE, FALSE), size = nrow(ratings_movies), replace = TRUE, prob = c(0.8, 0.2))\nhead(which_train)\n## [1]  TRUE  TRUE  TRUE FALSE  TRUE FALSE\n```", "```py\nrecc_data_train <- ratings_movies[which_train, ]\nrecc_data_test <- ratings_movies[!which_train, ]\n```", "```py\nwhich_set <- sample(x = 1:5, size = nrow(ratings_movies), replace = TRUE)\nfor(i_model in 1:5) {\n  which_train <- which_set == i_model\n  recc_data_train <- ratings_movies[which_train, ]\n  recc_data_test <- ratings_movies[!which_train, ]\n  # build the recommender\n}\n```", "```py\nrecommender_models <- recommenderRegistry$get_entries(dataType = \"realRatingMatrix\")\nrecommender_models$IBCF_realRatingMatrix$parameters\n```", "```py\nrecc_model <- Recommender(data = recc_data_train, method = \"IBCF\", parameter = list(k = 30))recc_model\n## Recommender of type 'IBCF' for 'realRatingMatrix' ## learned using 111 users.\nclass(recc_model)\n## [1] \"Recommender\"\n## attr(,\"package\")\n## [1] \"recommenderlab\"\n```", "```py\nmodel_details <- getModel(recc_model)\nmodel_details$description\n## [1] \"IBCF: Reduced similarity matrix\"\nmodel_details$k\n## [1] 30\n```", "```py\nclass(model_details$sim)\n## [1] \"dgCMatrix\"\n## attr(,\"package\")\n## [1] \"Matrix\"\ndim(model_details$sim)\n## [1] 332 332\n```", "```py\nn_items_top <- 20\n```", "```py\nimage(model_details$sim[1:n_items_top, 1:n_items_top], main = \"Heatmap of the first rows and columns\")\n```", "```py\nmodel_details$k\n## [1] 30\nrow_sums <- rowSums(model_details$sim > 0)\ntable(row_sums)\n## row_sums\n##  30\n## 332\n```", "```py\ncol_sums <- colSums(model_details$sim > 0)\n```", "```py\nqplot(col_sums) + stat_bin(binwidth = 1) + ggtitle(\"Distribution of the column count\")\n```", "```py\nwhich_max <- order(col_sums, decreasing = TRUE)[1:6]\nrownames(model_details$sim)[which_max]\n```", "```py\nn_recommended <- 6\n```", "```py\nrecc_predicted <- predict(object = recc_model, newdata = recc_data_test, n = n_recommended)\nrecc_predicted\n## Recommendations as 'topNList' with n = 6 for 449 users.\n```", "```py\nclass(recc_predicted)\n## [1] \"topNList\"## attr(,\"package\")## [1] \"recommenderlab\"\nslotNames(recc_predicted)\n## [1] \"items\"      \"itemLabels\" \"n\"\n```", "```py\nrecc_predicted@items[[1]]\n## [1] 201 182 254 274 193 297\n```", "```py\nrecc_user_1 <- recc_predicted@items[[1]]movies_user_1 <- recc_predicted@itemLabels[recc_user_1]\nmovies_user_1\n```", "```py\nrecc_matrix <- sapply(recc_predicted@items, function(x){\n  colnames(ratings_movies)[x]\n})\ndim(recc_matrix)\n## [1]   6 449\n```", "```py\nrecc_matrix[, 1:4]\n```", "```py\nnumber_of_items <- factor(table(recc_matrix))chart_title <- \"Distribution of the number of items for IBCF\"\n```", "```py\nqplot(number_of_items) + ggtitle(chart_title)\n```", "```py\nnumber_of_items_sorted <- sort(number_of_items, decreasing = TRUE)\nnumber_of_items_top <- head(number_of_items_sorted, n = 4)\ntable_top <- data.frame(names(number_of_items_top), number_of_items_top)\ntable_top\n```", "```py\nrecommender_models <- recommenderRegistry$get_entries(dataType = \"realRatingMatrix\")\nrecommender_models$UBCF_realRatingMatrix$parameters\n```", "```py\nrecc_model <- Recommender(data = recc_data_train, method = \"UBCF\")recc_model\n## Recommender of type 'UBCF' for 'realRatingMatrix' ## learned using 451 users.\n```", "```py\nmodel_details <- getModel(recc_model)\n```", "```py\nnames(model_details)\n```", "```py\nmodel_details$data\n## 451 x 332 rating matrix of class 'realRatingMatrix' with 43846 ratings.\n## Normalized using center on rows.\n```", "```py\nn_recommended <- 6\nrecc_predicted <- predict(object = recc_model, newdata = recc_data_test, n = n_recommended) recc_predicted\n## Recommendations as 'topNList' with n = 6 for 109 users.\n```", "```py\nrecc_matrix <- sapply(recc_predicted@items, function(x){colnames(ratings_movies)[x]\n})\ndim(recc_matrix)\n## [1]   6 109\n```", "```py\nrecc_matrix[, 1:4]\n```", "```py\nnumber_of_items <- factor(table(recc_matrix))\nchart_title <- \"Distribution of the number of items for UBCF\"\n```", "```py\nqplot(number_of_items) + ggtitle(chart_title)\n```", "```py\nnumber_of_items_sorted <- sort(number_of_items, decreasing = TRUE)\nnumber_of_items_top <- head(number_of_items_sorted, n = 4)\ntable_top <- data.frame(names(number_of_items_top), number_of_items_top)\ntable_top\n```", "```py\nratings_movies_watched <- binarize(ratings_movies, minRating = 1)\n```", "```py\nqplot(rowSums(ratings_movies_watched)) + stat_bin(binwidth = 10) + geom_vline(xintercept = mean(rowSums(ratings_movies_watched)), col = \"red\", linetype = \"dashed\") + ggtitle(\"Distribution of movies by user\")\n```", "```py\nwhich_train <- sample(x = c(TRUE, FALSE), size = nrow(ratings_movies), replace = TRUE, prob = c(0.8, 0.2))\nrecc_data_train <- ratings_movies[which_train, ]\nrecc_data_test <- ratings_movies[!which_train, ]\n```", "```py\nrecc_model <- Recommender(data = recc_data_train, method = \"IBCF\", parameter = list(method = \"Jaccard\"))\nmodel_details <- getModel(recc_model)\n```", "```py\nn_recommended <- 6\nrecc_predicted <- predict(object = recc_model, newdata = recc_data_test, n = n_recommended)\nrecc_matrix <- sapply(recc_predicted@items, function(x){colnames(ratings_movies)[x]\n})\n```", "```py\nrecc_matrix[, 1:4]\n```", "```py\nrecc_model <- Recommender(data = recc_data_train, method = \"UBCF\", parameter = list(method = \"Jaccard\"))\n```", "```py\nn_recommended <- 6\nrecc_predicted <- predict(object = recc_model, newdata = recc_data_test,n = n_recommended)\nrecc_matrix <- sapply(recc_predicted@items, function(x){colnames(ratings_movies)[x]\n})\ndim(recc_matrix)\n## [1]   6 109\nrecc_matrix[, 1:4]\n```"]