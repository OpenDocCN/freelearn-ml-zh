["```py\nCascadia@v0.4.0\nGumbo@v0.5.1\nHTTP@v0.7.1\nIJulia@v1.14.1\n```", "```py\npkg> add PackageName@vX.Y.Z \n```", "```py\npkg> add IJulia@v1.14.1\n```", "```py\njulia> download(\"https://raw.githubusercontent.com/PacktPublishing/Julia-Programming-Projects/master/Chapter05/Project.toml\", \"Project.toml\")\npkg> activate . \npkg> instantiate\n```", "```py\nusing HTTP, Sockets\nconst HOST = ip\"0.0.0.0\"\nconst PORT = 9999\nrouter = HTTP.Router()\nserver = HTTP.Server(router)\nHTTP.register!(router, \"/\", HTTP.HandlerFunction(req -> HTTP.Messages.Response(200, \"Hello World\")))\nHTTP.register!(router, \"/bye\", HTTP.HandlerFunction(req -> HTTP.Messages.Response(200, \"Bye\")))\nHTTP.register!(router, \"*\", HTTP.HandlerFunction(req -> HTTP.Messages.Response(404, \"Not found\")))\nHTTP.serve(server, HOST, PORT) \n```", "```py\nmodule WebApp \n\nusing HTTP, Sockets \n\nconst HOST = ip\"0.0.0.0\" \nconst PORT = 8888 \nconst ROUTER = HTTP.Router() \nconst SERVER = HTTP.Server(ROUTER) \n\nHTTP.serve(SERVER, HOST, PORT) \n\nend \n```", "```py\nHTTP.register!(ROUTER, \"/\", landingpage) # root page \nHTTP.register!(ROUTER, \"/new/*\", newgamepage) # /new/$difficulty_level -- new game \nHTTP.register!(ROUTER, \"/*/wiki/*\", articlepage) # /$session_id/wiki/$wikipedia_article_url -- article page \nHTTP.register!(ROUTER, \"/*/back/*\", backpage) # /$session_id/back/$number_of_steps -- go back the navigation history \nHTTP.register!(ROUTER, \"/*/solution\", solutionpage) # /$session_id/solution -- display the solution \nHTTP.register!(ROUTER, \"*\", notfoundpage) # everything else -- not found\n```", "```py\nconst landingpage = HTTP.HandlerFunction() do req \nend \nconst newgamepage = HTTP.HandlerFunction() do req \nend \nconst articlepage = HTTP.HandlerFunction() do req \nend \nconst backpage = HTTP.HandlerFunction() do req  \nend \nconst solutionpage = HTTP.HandlerFunction() do req \nend \nconst notfoundpage = HTTP.HandlerFunction() do req \nend \n```", "```py\nmodule WebApp \n\nusing HTTP, Sockets \nusing ..Gameplay \n\n# Configuration \nconst HOST = ip\"0.0.0.0\" \nconst PORT = 8888 \nconst ROUTER = HTTP.Router() \nconst SERVER = HTTP.Server(ROUTER) \n\n# Routes handlers \nconst landingpage = HTTP.HandlerFunction() do req \n  html = \"\"\" \n  <!DOCTYPE html> \n  <html> \n  <head> \n    <meta charset=\"utf-8\" /> \n    <link rel=\"stylesheet\" href=\"https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css\" integrity=\"sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO\" crossorigin=\"anonymous\"> \n    <title>6 Degrees of Wikipedia</title> \n  </head> \n\n  <body> \n    <div class=\"jumbotron\"> \n      <h1>Six degrees of Wikipedia</h1> \n      <p> \n        The goal of the game is to find the shortest path between two random Wikipedia articles.<br/> \n        Depending on the difficulty level you choose, the Wiki pages will be further apart and less related.<br/> \n        If you can't find the solution, you can always go back up the articles chain, but you need to find the solution within the maximum number of steps, otherwise you lose.<br/> \n        If you get stuck, you can always check the solution, but you'll lose.<br/> \n        Good luck and enjoy! \n      </p> \n\n      <hr class=\"my-4\"> \n\n      <div> \n        <h4>New game</h4> \n          <a href=\"/new/$(Gameplay.DIFFICULTY_EASY)\" class=\"btn btn-primary btn-lg\">Easy ($(Gameplay.DIFFICULTY_EASY) links away)</a> | \n          <a href=\"/new/$(Gameplay.DIFFICULTY_MEDIUM)\" class=\"btn btn-primary btn-lg\">Medium ($(Gameplay.DIFFICULTY_MEDIUM) links away)</a> | \n          <a href=\"/new/$(Gameplay.DIFFICULTY_HARD)\" class=\"btn btn-primary btn-lg\">Hard ($(Gameplay.DIFFICULTY_HARD) links away)</a> \n        </div> \n    </div> \n  </body> \n  </html> \n  \"\"\" \n\n  HTTP.Messages.Response(200, html) \nend \n\nconst newgamepage = HTTP.HandlerFunction() do req \nend \n\nconst articlepage = HTTP.HandlerFunction() do req \nend \n\nconst backpage = HTTP.HandlerFunction() do req \nend \n\nconst solutionpage = HTTP.HandlerFunction() do req \nend \n\nconst notfoundpage = HTTP.HandlerFunction() do req \nend \n\n# Routes definitions \nHTTP.register!(ROUTER, \"/\", landingpage) # root page \nHTTP.register!(ROUTER, \"/new/*\", newgamepage) # /new/$difficulty_level -- new game \nHTTP.register!(ROUTER, \"/*/wiki/*\", articlepage) # /$session_id/wiki/$wikipedia_article_url -- article page \nHTTP.register!(ROUTER, \"/*/back/*\", backpage) # /$session_id/back/$number_of_steps -- go back the navigation history \nHTTP.register!(ROUTER, \"/*/solution\", solutionpage) # /$session_id/solution -- display the solution \nHTTP.register!(ROUTER, \"*\", notfoundpage) # everything else -- not found \n\n# Start server \nHTTP.serve(SERVER, HOST, PORT) \n\nend \n```", "```py\nusing Pkg \npkg\"activate .\" \n\ninclude(\"Database.jl\") \ninclude(\"Wikipedia.jl\") \ninclude(\"Gameplay.jl\") \ninclude(\"WebApp.jl\") \n\nusing .Wikipedia, .Gameplay, .WebApp \n```", "```py\ngame = parse(UInt8, (replace(req.target, \"/new/\"=>\"\"))) |> newgamesession \n```", "```py\nmodule GameSession \n\nusing ..Gameplay, ..Wikipedia, ..Wikipedia.Articles \nusing Random \n\nmutable struct Game \n  id::String \n  articles::Vector{Article} \n  history::Vector{Article} \n  steps_taken::UInt8 \n  difficulty::UInt8 \n\n  Game(game_difficulty) = \n    new(randstring(), newgame(game_difficulty), Article[], 0, game_difficulty) \nend \n\nconst GAMES = Dict{String,Game}() \n\nend\n```", "```py\nexport newgamesession, gamesession, destroygamesession \n\nfunction newgamesession(difficulty) \n  game = Game(difficulty) \n  GAMES[game.id] = game \n  game \nend \n\nfunction gamesession(id) \n  GAMES[id] \nend \n\nfunction destroygamesession(id) \n  delete!(GAMES, id) \nend\nnewgamesession function, which creates a new Game of the indicated difficulty and stores it into the GAMES dict data structure. There's also a getter function, gamesession, which retrieves a Game by id. Finally, we add a destructor function, which removes the corresponding Game from the GAMES dict, effectively making it unavailable on the frontend and leaving it up for garbage collection. All of these functions are exported.\n```", "```py\nusing ..GameSession, ..Wikipedia, ..Wikipedia.Articles \n\nconst newgamepage = HTTP.HandlerFunction() do req \n  game = parse(UInt8, (replace(req.target, \"/new/\"=>\"\"))) |> newgamesession \n  article = game.articles[1] \n  push!(game.history, article) \n\n  HTTP.Messages.Response(200, wikiarticle(article)) \nend\n```", "```py\nfunction wikiarticle(article) \n  html = \"\"\" \n  <!DOCTYPE html> \n  <html> \n  <head> \n    <meta charset=\"utf-8\" /> \n    <link rel=\"stylesheet\" href=\"https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css\" integrity=\"sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO\" crossorigin=\"anonymous\"> \n    <title>6 Degrees of Wikipedia</title> \n  </head> \n\n  <body> \n    <h1>$(article.title)</h1> \n    <div id=\"wiki-article\"> \n      $(article.content) \n    </div> \n  </body> \n  </html> \n  \"\"\" \nend\n\n```", "```py\nusing Pkg pkg\"activate .\" include(\"Database.jl\") include(\"Wikipedia.jl\") include(\"Gameplay.jl\") include(\"GameSession.jl\") include(\"WebApp.jl\") using .Wikipedia, .Gameplay, .GameSession, .WebApp \n```", "```py\nfunction articleinfo(content) \n  dom = articledom(content) \n  (extractcontent(dom.root), extractlinks(dom.root), extracttitle(dom.root), extractimage(dom.root)) \nend \n```", "```py\nfunction extractcontent(elem) \n  matchFirst(Selector(\"#bodyContent\"), elem) |> string \nend \n```", "```py\n<div id=\"wiki-article\"> \n     $(article.content) \n</div> \n```", "```py\n<div id=\"wiki-article\"> \n    $(replace(article.content, \"/wiki/\"=>\"/$(game.id)/wiki/\")) \n</div> \n```", "```py\nfunction wikiarticle(game, article) \n```", "```py\nHTTP.Messages.Response(200, wikiarticle(game, article))  \n```", "```py\nfunction objective(game) \n  \"\"\" \n  <h3> \n    Go from <i>$(game.articles[1].title)</i>  \n    to <i>$(game.articles[end].title)</i> \n  </h3> \n  <h5> \n    Progress: $(size(game.history, 1) - 1)  \n    out of maximum $(size(game.articles, 1) - 1) links  \n    in $(game.steps_taken) steps \n  </h5> \n  <h6> \n    <a href=\"/$(game.id)/solution\">Solution?</a> |  \n    <a href=\"/\">New game</a> \n  </h6>\"\"\" \nend \n```", "```py\nfunction history(game) \n  html = \"<ol>\" \n  iter = 0 \n  for a in game.history \n    html *= \"\"\" \n    <li><a href=\"/$(game.id)/back/$(iter + 1)\">$(a.title)</a></li> \n    \"\"\" \n    iter += 1 \n  end \n\n  html * \"</ol>\" \nend\n```", "```py\nfunction puzzlesolved(game, article) \n  article.url == game.articles[end].url \nend\n```", "```py\nfunction losinggame(game) \n  game.steps_taken >= Gameplay.MAX_NUMBER_OF_STEPS \nend\n```", "```py\nmodule WebApp \n\nusing HTTP, Sockets \nusing ..Gameplay, ..GameSession, ..Wikipedia, ..Wikipedia.Articles \n\n# Configuration \nconst HOST = ip\"0.0.0.0\" \nconst PORT = 8888 \nconst ROUTER = HTTP.Router() \nconst SERVER = HTTP.Server(ROUTER) \n\n# Functions \nfunction wikiarticle(game, article) \n  html = \"\"\" \n  <!DOCTYPE html> \n  <html> \n  $(head()) \n\n  <body> \n    $(objective(game)) \n    $(history(game)) \n    <hr/> \n    $( \n      if losinggame(game) \n        \"<h1>You Lost :( </h1>\" \n      else \n        puzzlesolved(game, article) ? \"<h1>You Won!</h1>\" : \"\" \n      end \n    ) \n\n    <h1>$(article.title)</h1> \n    <div id=\"wiki-article\"> \n      $(replace(article.content, \"/wiki/\"=>\"/$(game.id)/wiki/\")) \n    </div> \n  </body> \n  </html> \n  \"\"\" \nend \n\nfunction history(game) \n  html = \"<ol>\" \n  iter = 0 \n  for a in game.history \n    html *= \"\"\" \n    <li><a href=\"/$(game.id)/back/$(iter + 1)\">$(a.title)</a></li> \n    \"\"\" \n    iter += 1 \n  end \n\n  html * \"</ol>\" \nend \n\nfunction objective(game) \n  \"\"\" \n  <h3> \n    Go from <i>$(game.articles[1].title)</i>  \n    to <i>$(game.articles[end].title)</i> \n  </h3> \n  <h5> \n    Progress: $(size(game.history, 1) - 1)  \n    out of maximum $(size(game.articles, 1) - 1) links  \n    in $(game.steps_taken) steps \n  </h5> \n  <h6> \n    <a href=\"/$(game.id)/solution\">Solution?</a> |  \n    <a href=\"/\">New game</a> \n  </h6>\"\"\" \nend \n\nfunction head() \n  \"\"\" \n  <head> \n    <meta charset=\"utf-8\" /> \n    <link rel=\"stylesheet\" href=\"https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css\" integrity=\"sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO\" crossorigin=\"anonymous\"> \n    <title>6 Degrees of Wikipedia</title> \n  </head> \n  \"\"\" \nend \n\nfunction puzzlesolved(game, article) \n  article.url == game.articles[end].url \nend \n\nfunction losinggame(game) \n  game.steps_taken >= Gameplay.MAX_NUMBER_OF_STEPS \nend \n\n# Routes handlers \nconst landingpage = HTTP.HandlerFunction() do req \n  html = \"\"\" \n  <!DOCTYPE html> \n  <html> \n  $(head()) \n\n  <body> \n    <div class=\"jumbotron\"> \n      <h1>Six degrees of Wikipedia</h1> \n      <p> \n        The goal of the game is to find the shortest path between two random Wikipedia articles.<br/> \n        Depending on the difficulty level you choose, the Wiki pages will be further apart and less related.<br/> \n        If you can't find the solution, you can always go back up the articles chain, but you need to find the solution within the maximum number of steps, otherwise you lose.<br/> \n        If you get stuck, you can always check the solution, but you'll lose.<br/> \n        Good luck and enjoy! \n      </p> \n\n      <hr class=\"my-4\"> \n\n      <div> \n        <h4>New game</h4> \n          <a href=\"/new/$(Gameplay.DIFFICULTY_EASY)\" class=\"btn btn-primary btn-lg\">Easy ($(Gameplay.DIFFICULTY_EASY) links away)</a> | \n          <a href=\"/new/$(Gameplay.DIFFICULTY_MEDIUM)\" class=\"btn btn-primary btn-lg\">Medium ($(Gameplay.DIFFICULTY_MEDIUM) links away)</a> | \n          <a href=\"/new/$(Gameplay.DIFFICULTY_HARD)\" class=\"btn btn-primary btn-lg\">Hard ($(Gameplay.DIFFICULTY_HARD) links away)</a> \n        </div> \n    </div> \n  </body> \n  </html> \n  \"\"\" \n\n  HTTP.Messages.Response(200, html) \nend \n\nconst newgamepage = HTTP.HandlerFunction() do req \n  game = parse(UInt8, (replace(req.target, \"/new/\"=>\"\"))) |> newgamesession \n  article = game.articles[1] \n  push!(game.history, article) \n\n  HTTP.Messages.Response(200, wikiarticle(game, article)) \nend \n\nconst articlepage = HTTP.HandlerFunction() do req \nend \n\nconst backpage = HTTP.HandlerFunction() do req \nend \n\nconst solutionpage = HTTP.HandlerFunction() do req \nend \n\nconst notfoundpage = HTTP.HandlerFunction() do req \nend \n\n# Routes definitions \nHTTP.register!(ROUTER, \"/\", landingpage) # root page \nHTTP.register!(ROUTER, \"/new/*\", newgamepage) # /new/$difficulty_level -- new game \nHTTP.register!(ROUTER, \"/*/wiki/*\", articlepage) # /$session_id/wiki/$wikipedia_article_url -- article page \nHTTP.register!(ROUTER, \"/*/back/*\", backpage) # /$session_id/back/$number_of_steps -- go back the navigation history \nHTTP.register!(ROUTER, \"/*/solution\", solutionpage) # /$session_id/solution -- display the solution HTTP.register!(ROUTER, \"*\", notfoundpage) # everything else -- not found # Start server HTTP.serve(SERVER, HOST, PORT) \n\nend\n```", "```py\nconst MAX_NUMBER_OF_STEPS = 10 \n```", "```py\nconst articlepage = HTTP.HandlerFunction() do req \n  uri_parts = parseuri(req.target) \n  game = gamesession(uri_parts[1]) \n  article_uri = \"/wiki/$(uri_parts[end])\" \n  existing_articles = Articles.find(article_uri) \n  article = isempty(existing_articles) ?  \n    persistedarticle(fetchpage(article_uri)...) :  \n    existing_articles[1] \n  push!(game.history, article) \n  game.steps_taken += 1 \n  puzzlesolved(game, article) && destroygamesession(game.id) \n  HTTP.Messages.Response(200, wikiarticle(game, article)) \nend\n```", "```py\nfunction parseuri(uri) \n  map(x -> String(x), split(uri, \"/\", keepempty = false)) \nend\n```", "```py\nconst backpage = HTTP.HandlerFunction() do req \n  uri_parts = parseuri(req.target) \n  game = gamesession(uri_parts[1]) \n  history_index = parse(UInt8, uri_parts[end]) \n\n  article = game.history[history_index] \n  game.history = game.history[1:history_index] \n\n  HTTP.Messages.Response(200, wikiarticle(game, article)) \nend \n```", "```py\nconst solutionpage = HTTP.HandlerFunction() do req \n  uri_parts = parseuri(req.target) \n  game = gamesession(uri_parts[1]) \n  game.history = game.articles \n  game.steps_taken = Gameplay.MAX_NUMBER_OF_STEPS \n  article = game.articles[end]\n  HTTP.Messages.Response(200, wikiarticle(game, article)) \nend\n```", "```py\nconst notfoundpage = HTTP.HandlerFunction() do req \n  HTTP.Messages.Response(404, \"Sorry, this can't be found\") \nend \n```", "```py\nmodule WebApp \n\n# code truncated #\n\nfunction history(game) \n  html = \"\"\"<ol class=\"list-group\">\"\"\" \n  iter = 0 \n  for a in game.history \n    html *= \"\"\" \n      <li class=\"list-group-item\"> \n        <a href=\"/$(game.id)/back/$(iter + 1)\">$(a.title)</a> \n      </li> \n    \"\"\" \n    iter += 1 \n  end \n\n  html * \"</ol>\" \nend \n\nfunction objective(game) \n  \"\"\" \n  <div class=\"jumbotron\"> \n    <h3>Go from \n      <span class=\"badge badge-info\">$(game.articles[1].title)</span> \n      to \n      <span class=\"badge badge-info\">$(game.articles[end].title)</span> \n    </h3> \n    <hr/> \n    <h5> \n      Progress: \n      <span class=\"badge badge-dark\">$(size(game.history, 1) - 1)</span> \n      out of maximum \n      <span class=\"badge badge-dark\">$(size(game.articles, 1) - 1)</span> \n      links in \n      <span class=\"badge badge-dark\">$(game.steps_taken)</span> \n      steps \n    </h5> \n    $(history(game)) \n    <hr/> \n    <h6> \n      <a href=\"/$(game.id)/solution\" class=\"btn btn-primary btn-lg\">Solution?</a> | \n      <a href=\"/\" class=\"btn btn-primary btn-lg\">New game</a> \n    </h6> \n  </div> \n  \"\"\" \nend \n\n# code truncated #\n\nend \n```"]