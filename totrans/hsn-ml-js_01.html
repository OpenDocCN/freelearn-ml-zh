<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Exploring the Potential of JavaScript</h1>
                </header>
            
            <article>
                
<p>We will cover the following topics in this chapter:</p>
<ul>
<li>Why JavaScript?</li>
<li>Why machine learning, why now?</li>
<li>Advantages and challenges of JavaScript</li>
<li>The CommonJS initiative</li>
<li>Node.js</li>
<li>TypeScript language</li>
<li>Improvements in ES6</li>
<li>Preparing the development environment</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Why JavaScript?</h1>
                </header>
            
            <article>
                
<p>I started writing about <strong>machine learning</strong> (<strong>ML</strong>) in JavaScript in 2010. At the time, Node.js was brand new and JavaScript was just beginning to come into its own as a language. For much of the history of the internet, JavaScript had been seen as a toy language, used to create simple dynamic interactions on web pages.</p>
<p>The perception of JavaScript began to change in 2005 with the release of the <strong>Prototype JavaScript Framework</strong>, which aimed to simplify AJAX requests and help developers deal with cross-browser <kbd>XMLHttpRequest</kbd>. The Prototype Framework also introduced the familiar dollar function as an alias for <kbd>`document.getElementById`: `$(“myId”)`</kbd>, for instance.</p>
<p>One year later, John Resig released the wildly popular jQuery library. At the time of writing, <a href="https://w3techs.com/" target="_blank">w3techs.com</a> reports that jQuery is used on 96% of websites whose JavaScript libraries are known to them (which accounts for 73% of all websites). jQuery worked to make common JavaScript operations cross-browser compatible and easy to achieve, bringing important tools such as AJAX requests, <strong>Document Object Model</strong> (<strong>DOM</strong>) traversal and manipulation, and animations to web developers everywhere.</p>
<p>Then, in 2008, the Chrome web browser and the Chrome V8 JavaScript engine were released. Chrome and V8 introduced a marked performance improvement over older browsers: JavaScript was now fast, owing in large part to the V8 engine's innovative just-in-time compiler that builds machine code directly from JavaScript.</p>
<p>JavaScript became more popular as jQuery and Chrome took over the web. Developers historically have never loved JavaScript as a programming language, but with jQuery in the picture, running on a fast and modern browser, it became clear that JavaScript was an underutilized tool and capable of much more than it had been used for previously.</p>
<p>In 2009, the JavaScript developer community decided to break JavaScript free from the web browser environment. The CommonJS initiative was launched early that year, and Node.js followed after a few months. CommonJS modules' goal was to develop a standard library and improve the ecosystem for JavaScript so that it could be used outside of the browser environment. As part of this effort, CommonJS standardized a module-loading interface that allowed developers to build libraries that they could share with others.</p>
<p>The release of Node.js in mid-2009 rocked the JavaScript world by giving JavaScript developers a new paradigm to consider: JavaScript as a server-side language. Packing the Chrome V8 engine under the hood made Node.js surprisingly fast, though the V8 engine doesn't deserve all of the credit for the software's performance. The Node.js instance uses an event loop to process requests, so it can handle a large number of concurrent connections despite being single-threaded.</p>
<p>The novelty of JavaScript on the server, its surprising performance, and the early introduction of the npm registry which let developers publish and discover modules, attracted thousands of developers. The standard library published with Node.js was primarily low-level I/O APIs, and developers raced to see who could publish the first good HTTP request wrapper, the first easy-to-use HTTP server, the first high-level image processing library, and so on. The rapid early growth of the JavaScript ecosystem generated confidence in developers who were reluctant to adopt the new technology. JavaScript, for the first time, was being seen as a real programming language, rather than just something we tolerated because of web browsers.</p>
<p>While JavaScript as a programming platform was maturing, the Python community was busy working on ML, in part inspired by Google's success in the market. The foundational and very popular number processing library, NumPy, was released in 2006, though it had existed in one form or another for a decade prior. A ML library called <strong>scikit-learn</strong> was released in 2010, and that was the moment I decided to start teaching ML to JavaScript developers.</p>
<p>The popularity of ML in Python and the ease of building and training models with tools, such as scikit-learn, astounded me and many others. In my eyes, the surge in popularity caused an ML bubble; because models were so easy to build and run, I found that many developers didn't actually understand the mechanics of the algorithms and techniques they were using. Many developers lamented their underperforming models, not understanding that they themselves were the weak link in the chain.</p>
<p>Machine learning at the time had been seen as mystical, magical, academic, accessible only to a select few geniuses, and only accessible to Python developers. I felt differently. Machine learning is just a category of algorithms with no magic involved. Most of the algorithms are actually easy to understand and reason about!</p>
<p>Rather than showing developers how to import Bayes in Python, I wanted to show developers how to build the algorithms from scratch, an important step in building intuition. I also wanted my students to largely ignore the popular Python libraries that existed at the time, because I wanted to reinforce the notion that ML algorithms can be written in any language and Python is not required.</p>
<p>I chose JavaScript as my teaching platform. To be perfectly honest, I chose JavaScript in part because it was considered a <em>bad</em> language by many at that time. My message was <em>machine learning is easy, you can even do it in JavaScript!</em> Fortunately for me, Node.js and JavaScript were both becoming incredibly popular, and my early articles on ML in JavaScript were read by over a million curious developers in the following years.</p>
<p>I also chose JavaScript in part because I didn't want ML to be seen as a tool only accessible to academics, or computer scientists, or even college graduates. I believed, and still believe, that these algorithms can be thoroughly understood by any competent developer, given enough practice and repetition. I chose JavaScript because it allowed me to reach a new audience of frontend and full-stack web developers, many of whom were self-taught or had never studied computer science formally. If the goal was to demystify and democratize the field of ML, I felt it was much better to reach the web developer community rather than the backend Python programmer community, which as a whole was already more comfortable with ML at the time.</p>
<p>Python has always been and remains the language of choice for ML, in part due to the maturity of the language, in part due to the maturity of the ecosystem, and in part due to the positive feedback loop of early ML efforts in Python. Recent developments in the JavaScript world, however, are making JavaScript more attractive to ML projects. I think we will see a major ML renaissance in JavaScript within a few years, especially as laptops and mobile devices become ever more powerful and JavaScript itself surges in popularity.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Why machine learning, why now?</h1>
                </header>
            
            <article>
                
<p>Several ML techniques have been around since before computers themselves, but many of the modern ML algorithms we use today were discovered all the way back in the 1970s and 1980s. They were interesting but not practical then, and were confined largely to academia.</p>
<p>What changed to give ML its massive rise in popularity? First, computers finally got fast enough to run non-trivial neural networks and large ML models. And then two things happened: Google and <strong>Amazon Web Services</strong> (<strong>AWS</strong>). Google proved the value of ML to the market in a very visible manner, and then AWS made scalable computing and storage resources readily available (AWS democratized it and created new competition).</p>
<p>Google PageRank, the ML algorithm powering Google Search, taught us all about business applications of ML. Sergei and Larry, the founders of Google, told the world that the massive success of their search engine and resultant advertising business was the PageRank algorithm: a relatively straightforward linear algebra equation, with a massive matrix.</p>
<div class="packt_infobox">Note that neural networks are also relatively straightforward linear algebra equations with a massive matrix.</div>
<p>That was ML in all its glory; big data giving big insight which translates into a major market success. This got the world economically interested in ML.</p>
<p>AWS, with the launch of EC2 and hourly billing, democratized compute resources. Researchers and early-stage start ups were now able to launch large computing clusters quickly, train their models, and scale the cluster back down, avoiding the need for large capital expenditures on beefy servers. This created new competition and an inaugural generation of ML-focused start ups, products, and initiatives.</p>
<p>ML has recently had another surge in popularity, both in the developer and business communities. The first generation of ML-focused start ups and products have now come to maturity and are proving the value of ML in the market, and in many cases these companies are closing in on or have overtaken their competitors. The desire of companies to remain competitive in their market drove up the demand for ML solutions.</p>
<p>The late 2015 introduction of Google's neural network library, <strong>TensorFlow</strong>, energized developers by democratizing neural networks much in the same way that EC2 democratized computing power. Additionally, those first-generation start ups that focused on developers have also come to maturity, and now we can make a simple API request to AWS or <strong>Google Cloud Platform</strong> (<strong>GCP</strong>) that runs an entire pretrained <strong>Convolutional Neural Network</strong> (<strong>CNN</strong>) on an image, and tells me if I'm looking at a cat, a woman, a handbag, a car, or all four at once.</p>
<p>As ML is democratized it will slowly lose its competitive value, that is, companies will no longer be able to use ML to jump leaps and bounds ahead of the competition, because their competition will also be using ML. Everyone in the field is now using the same algorithms, and competition becomes a data war. If we want to keep competing on technology, if we want to find the next 10x improvement, then we'll either need to wait for, or preferably cause, the next big technological breakthrough.</p>
<p>If ML had not been such a success in the market, that would have been the end of the story. All the important algorithms would be known to all, and the fight would move to who can gather the best data, put walls around their garden, or exploit their ecosystem the best.</p>
<p>But introducing a tool such as TensorFlow into the market changed all of that. Now, neural networks have been democratized. It's surprisingly easy to build a model, train and run it on a GPU, and generate real results. The academic fog surrounding neural networks has been lifted, and now tens of thousands of developers are playing around with techniques, experimenting, and refining. This will launch a second major wave of ML popularity, particularly focused on neural networks. The next generation of ML and neural network-focused start ups and products is being born right now, and when they come to maturity in a few years, we should see a number of significant breakthroughs, as well as breakaway companies.</p>
<p>Each new market success we see will create demand for ML developers. The increase of the talent pool and democratization of technology causes technology breakthroughs. Each new technology breakthrough hits the market and creates new market successes, and the cycle will continue while the field itself advances at an accelerating pace. I think, for purely economic reasons, that we really are headed for an <strong>artificial intelligence</strong> (<strong>AI</strong>) boom.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Advantages and challenges of JavaScript</h1>
                </header>
            
            <article>
                
<p>Despite my optimism towards the future of ML in JavaScript, most developers today would still choose Python for their new projects, and nearly all large-scale production systems are developed in Python or other languages more typical to ML.</p>
<p>JavaScript, like any other tool, has its advantages and disadvantages. Much of the historic criticism of JavaScript has focused on a few common themes: strange behavior in type coercion, the prototypical object-oriented model, difficulty organizing large codebases, and managing deeply nested asynchronous function calls with what many developers call <em>callback hell</em>. Fortunately, most of these historic gripes have been resolved by the introduction of <strong>ES6</strong>, that is, <strong>ECMAScript 2015</strong>, a recent update to the JavaScript syntax.</p>
<p>Despite the recent language improvements, most developers would still advise against using JavaScript for ML for one reason: the ecosystem. The Python ecosystem for ML is so mature and rich that it's difficult to justify choosing any other ecosystem. But this logic is self-fulfilling and self-defeating; we need brave individuals to take the leap and work on real ML problems if we want JavaScript's ecosystem to mature. Fortunately, JavaScript has been the most popular programming language on GitHub for a few years running, and is growing in popularity by almost every metric.</p>
<p>There are some advantages to using JavaScript for ML. Its popularity is one; while ML in JavaScript is not very popular at the moment, the language itself is. As demand for ML applications rises, and as hardware becomes faster and cheaper, it's only natural for ML to become more prevalent in the JavaScript world. There are tons of resources available for learning JavaScript in general, maintaining Node.js servers, and deploying JavaScript applications. The <strong>Node Package Manager</strong> (<strong>npm</strong>) ecosystem is also large and still growing, and while there aren't many very mature ML packages available, there are a number of well built, useful tools out there that will come to maturity soon.</p>
<p>Another advantage to using JavaScript is the universality of the language. The modern web browser is essentially a portable application platform which allows you to run your code, basically without modification, on nearly any device. Tools like <strong>electron</strong> (while considered by many to be bloated) allow developers to quickly develop and deploy downloadable desktop applications to any operating system. Node.js lets you run your code in a server environment. React Native brings your JavaScript code to the native mobile application environment, and may eventually allow you to develop desktop applications as well. JavaScript is no longer confined to just dynamic web interactions, it's now a general-purpose, cross-platform programming language.</p>
<p>Finally, using JavaScript makes ML accessible to web and frontend developers, a group that historically has been left out of the ML discussion. Server-side applications are typically preferred for ML tools, since the servers are where the computing power is. That fact has historically made it difficult for web developers to get into the ML game, but as hardware improves, even complex ML models can be run on the client, whether it's the desktop or the mobile browser.</p>
<p>If web developers, frontend developers, and JavaScript developers all start learning about ML today, that same community will be in a position to improve the ML tools available to us all tomorrow. If we take these technologies and democratize them, expose as many people as possible to the concepts behind ML, we will ultimately elevate the community and seed the next generation of ML researchers.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The CommonJS initiative</h1>
                </header>
            
            <article>
                
<p>In 2009, a Mozilla engineer named Kevin Dangoor realized that server-side JavaScript needed a lot of help in order to be useful. The concept of server-side JavaScript had already existed, but wasn't very popular due to a number of limitations, particularly in terms of the JavaScript ecosystem.</p>
<p>In a blog post written in January of 2009, Dangoor cited a few examples of where JavaScript needed some help. He wrote that the JavaScript ecosystem would need a standard library and standard interfaces for things such as file and database access. Additionally, the JavaScript environment needed a way to package, publish, and install libraries and dependencies for others to use, and also needed a package repository to host all of the aforementioned.</p>
<p>Out of all of this came the <strong>CommonJS</strong> initiative, whose most notable contribution to the JavaScript ecosystem is the CommonJS module format. If you've done any work with Node.js, you're probably already familiar with CommonJS: your <kbd>package.json</kbd> file is written in the CommonJS modules package specification format, and writing code like <kbd>var app = require(‘./app.js’)</kbd> in one file with <kbd>module.exports = App</kbd> in <kbd>app.js</kbd> is using the CommonJS module specification.</p>
<p>The standardization of modules and packages paved the way for a significant boost in JavaScript popularity. Developers were now able to use modules to write complex applications spanning many files, without polluting the global namespace. Package and library developers were able to build and publish new libraries of higher levels of abstraction than JavaScript's standard library. Node.js and npm would shortly grab onto these concepts and build a major ecosystem around package sharing.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Node.js</h1>
                </header>
            
            <article>
                
<p>The release of Node.js in 2009 is possibly the single most important moment in JavaScript's history, though it would not have been possible without the release of the Chrome browser and Chrome's V8 JavaScript engine in the previous year.</p>
<p>Those readers who remember the launch of Chrome also recognize why Chrome dominated the browser wars: Chrome was fast, it was minimalist, it was modern, it was easy to develop for, and JavaScript itself ran much faster on Chrome than on other browsers.</p>
<p>Behind Chrome is the open source Chromium project, which in turn developed the <strong>V8</strong> JavaScript engine. The innovation that V8 brought to the JavaScript world was its new execution model: instead of interpreting JavaScript in real time, V8 contains a JIT compiler that turns JavaScript directly into native machine code. This gambit paid off, and the combined effect of its stellar performance and its open source status led others to co-opt V8 for their own purposes.</p>
<p>Node.js took the V8 JavaScript engine, added an event-driven architecture around it, and added a low-level I/O API for disk and file access. The event-driven architecture turned out to be a critical decision. Other server-side languages and technologies, such as PHP, typically used a thread pool to manage concurrent requests, with each thread itself blocking while processing the request. Node.js is a single-threaded process, but using an event loop avoids blocking operations and instead favors asynchronous, callback-driven logic. While the single-threaded nature of Node.js is considered by many to be a drawback, Node.js was still able to handle many concurrent requests with good performance, and that was enough to bring developers to the platform.</p>
<p>A few months later, the npm project was released. Building on top of the foundational work that CommonJS achieved, npm allowed package developers to publish their modules to a centralized registry (called the <strong>npm registry</strong>), and allowed package consumers to install and maintain dependencies with the npm command-line tool.</p>
<p>Node.js likely would not have broken into the mainstream if not for npm. The Node.js server itself provided the JavaScript engine, the event loop, and a few low-level APIs, but as developers work on bigger projects they tend to want higher-level abstractions. When making HTTP requests or reading files from disk, developers don't always want to have to worry about binary data, writing headers, and other low-level issues. The npm and the npm registry let the developer community write and share their own high-level abstractions in the form of modules other developers could simply install and <kbd>require()</kbd>.</p>
<p>Unlike other programming languages which typically have high-level abstractions built in, Node.js was allowed to focus on providing the low-level building blocks and the community took care of the rest. The community stepped up by building excellent abstractions such as the <kbd>Express.js</kbd> web application framework, the <kbd>Sequelize ORM</kbd>, and hundreds of thousands of other libraries ready to be used after just a simple <kbd>npm install</kbd> command.</p>
<p>With the advent of Node.js, JavaScript developers with no prior server-side language knowledge were now able to build entire full-stack applications. The frontend code and backend code could now be written in the same language, by the same developers.</p>
<p>Ambitious developers were now building entire applications in JavaScript, though they ran into a few issues and solutions along the way. Single-page applications fully written in JavaScript became popular, but also became difficult to template and organize. The community responded by building frameworks such as <strong>Backbone.js</strong> (the spiritual predecessor to frameworks such as Angular and React), <strong>RequireJS</strong> (a CommonJS and AMD module loader), and templating languages such as <strong>Mustache</strong> (a spiritual predecessor to JSX).</p>
<p>When developers ran into issues with SEO on their single-page applications, they invented the concept of <strong>isomorphic applications</strong>, or codes that could be rendered both server side (so that web spiders could index the content) and client side (to keep the application fast and JavaScript-powered). This led to the invention of more JavaScript frameworks such as <strong>MeteorJS</strong>.</p>
<p>Eventually, JavaScript developers building single-page applications realized that often, their server-side and database requirements were lightweight, requiring just authentication, and data storage, and retrieval. This led to the development of <em>serverless</em> technologies or <strong>database-as-a-service</strong> (<strong>DBaaS</strong>) platforms such as <strong>Firebase</strong>, which in turn laid out a path for mobile JavaScript applications to become popular. The Cordova/PhoneGap project appeared around the same time, allowing developers to wrap their JavaScript code in a native iOS or Android WebView component and deploy their JavaScript applications to the mobile app stores.</p>
<p>For our purposes throughout this book, we'll be relying on Node.js and npm very heavily. Most of the examples in this book will use ML packages available on npm.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">TypeScript language</h1>
                </header>
            
            <article>
                
<p>The development and sharing of new packages on npm was not the only result of JavaScript's popularity. JavaScript's increasing usage as a primary programming language caused many developers to lament the lack of IDE and language tooling support. Historically, IDEs were more popular with developers of compiled and statically-typed languages such as C and Java, as it’s easier to parse and statically analyze those types of languages. It wasn't until recently that great IDEs started appearing for languages such as JavaScript and PHP, while Java has had IDEs geared towards it for many years.</p>
<p>Microsoft wanted better tooling and support for their large-scale JavaScript projects, but there were a few issues with the JavaScript language itself that got in the way. In particular, JavaScript's dynamic typing (the fact that <kbd>var number</kbd> could start its life as the integer <strong>5</strong>, but then be assigned to an object later) precludes using static analysis tools to ensure type safety, and also makes it difficult for an IDE to find the correct variable or object to autocomplete with. Additionally, Microsoft wanted a class-based object-oriented paradigm with interfaces and contracts, but JavaScript's object-oriented programming paradigm was based on <strong>prototypes</strong>, not classes.</p>
<p>Microsoft therefore invented the TypeScript language in order to support large-scale JavaScript development efforts. TypeScript introduced classes, interfaces, and static typing to the language. Unlike Google's Dart, Microsoft made sure TypeScript would always be a strict superset of JavaScript, meaning that all valid JavaScript is also valid TypeScript. The TypeScript compiler does static type checking at compile time, helping developers catch errors early. Support for static typing also helps IDEs interpret code more accurately, making for a nicer developer experience.</p>
<p>Several of TypeScript's early improvements to the JavaScript language have been made irrelevant by ECMAScript 2015, or what we call ES6. For instance, TypeScript's module loader, class syntax, and arrow function syntax have been subsumed by ES6, and TypeScript now simply uses the ES6 versions of those constructs; however, TypeScript still brings static typing to JavaScript, which ES6 wasn't able to accomplish.</p>
<p>I bring up TypeScript here because, while we won't be using TypeScript in the examples in this book, some of the examples of ML libraries we examine here are written in TypeScript.</p>
<p>For instance, one example found on the <kbd>deeplearn.js</kbd> tutorials page shows code that looks like the following:</p>
<pre>const graph = new Graph();<br/> // Make a new input in the graph, called 'x', with shape [] (a Scalar).<br/> const x: Tensor = graph.placeholder('x', []);<br/> // Make new variables in the graph, 'a', 'b', 'c' with shape [] and   <br/>    random<br/> // initial values.<br/> const a: Tensor = graph.variable('a', Scalar.new(Math.random()));<br/> const b: Tensor = graph.variable('b', Scalar.new(Math.random()));<br/> const c: Tensor = graph.variable('c', Scalar.new(Math.random()));</pre>
<p>The syntax looks like ES6 JavaScript except for the new colon notation seen in <kbd>const x: Tensor = … :</kbd> this code is telling the TypeScript compiler that the <kbd>const x</kbd> must be an instance of the <kbd>Tensor</kbd> class. When TypeScript compiles this code, it first checks that everywhere <kbd>x</kbd> is used expects a <kbd>Tensor</kbd> (it will throw an error if not), and then it simply discards the type information when compiling to JavaScript. Converting the preceding TypeScript code to JavaScript is as simple as removing the colon and the <kbd>Tensor</kbd> keyword from the variable definition.</p>
<p>You are welcome to use TypeScript in your own examples as you follow along with this book, however, you will have to update the build process that we set up later to support TypeScript.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Improvements in ES6</h1>
                </header>
            
            <article>
                
<p>The ECMAScript committee, which defines the specification for the JavaScript language itself, released a new specification called ECMAScript 6/ECMAScript 2015 in June 2015. The new standard, called <strong>ES6</strong> for short, was a major revision of the JavaScript programming language and added a number of new paradigms intended to make development of JavaScript programs easier.</p>
<p>While ECMAScript defines the specification for the JavaScript language, the actual implementation of the language is dependent on the browser vendors and the maintainers of the various JavaScript engines. ES6 by itself is only a guideline, and because the browser vendors each have their own timeline for implementing new language features, the JavaScript language and the JavaScript implementations diverged slightly. Features defined by ES6, such as classes, were not available in the major browsers, but developers wanted to use them anyway.</p>
<p>Enter <strong>Babel</strong>, the JavaScript transpiler. Babel can read and parse different JavaScript flavors (such as ES6, ES7, ES8, and React JSX) and convert it or compile it into browser-standard ES5. Even today, the entirety of ES6 has not yet been implemented by the browser vendors, so Babel remains an essential tool for developers wishing to write ES6 code.</p>
<p>The examples in this book will use ES6. If you're not yet familiar with the newer syntax, here are a few of the major features you'll see used throughout this book.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Let and const</h1>
                </header>
            
            <article>
                
<p>In ES5 JavaScript, we use the <kbd>var</kbd> keyword to define variables. In most cases, <kbd>var</kbd> can simply be replaced with <kbd>let</kbd>, with the major difference between the two constructs being the scoping of the variable with respect to blocks. The following example from <span><strong>MDN web docs</strong>, or previously <strong>Mozilla Developer Network</strong> (<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let" target="_blank">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let</a>),</span> demonstrates the subtle difference between the two:</p>
<pre>function varTest() {<br/>  var x = 1;<br/>  if (true) {<br/>    var x = 2;  // same variable!<br/>    console.log(x);  // 2<br/>  }<br/>  console.log(x);  // 2<br/> }<br/> <br/> function letTest() {<br/>  let x = 1;<br/>  if (true) {<br/>    let x = 2;  // different variable<br/>    console.log(x);  // 2<br/>  }<br/>  console.log(x);  // 1<br/> }</pre>
<p>So, while you must use additional caution in cases like the preceding one, in most cases you can simply replace <kbd>var</kbd> with <kbd>let</kbd>.</p>
<p>The <kbd>const</kbd> keyword, unlike <kbd>let</kbd>, defines a variable as a constant; that is, you cannot reassign a variable initialized with <kbd>const</kbd> at a later date. For example, the following code causes an error with a message similar to <kbd>invalid assignment to const a</kbd>:</p>
<pre>const a = 1;<br/>a = 2;</pre>
<p>On the other hand the same code, using <kbd>var</kbd> or <kbd>let</kbd> to define <kbd>a</kbd>, would run successfully.</p>
<div class="packt_tip">Note that if <kbd>a</kbd> is an object, you are allowed to modify object properties of <kbd>a</kbd>.</div>
<p>The following code will run successfully:</p>
<pre>const obj = {};<br/>obj.name = ‘My Object’;</pre>
<p>However, attempting to redefine objects such as in <kbd>obj = {name: “other object”}</kbd> would cause an error.</p>
<p>I find that in most programming contexts, <kbd>const</kbd> is typically more appropriate than <kbd>let</kbd>, as most variables you use never need to be redefined. My recommendation is to use <kbd>const</kbd> as much as you can, and use <kbd>let</kbd> only when you have a reason to redefine the variable later.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Classes</h1>
                </header>
            
            <article>
                
<p>One very welcome change in ES6 is the addition of classes and class inheritance. Previously, object-oriented programming in JavaScript required prototypical inheritance, which many developers found unintuitive, like the following ES5 example:</p>
<pre>var Automobile = function(weight, speed) {<br/>   this.weight = weight;<br/>   this.speed = speed;<br/>}<br/>Automobile.prototype.accelerate = function(extraSpeed) {<br/>   this.speed += extraSpeed;<br/>}<br/>var RaceCar = function (weight, speed, boost) {<br/>   Automobile.call(this, weight, speed);<br/>   this.boost = boost;<br/>}<br/>RaceCar.prototype = Object.create(Automobile.prototype);<br/>RaceCar.prototype.constructor = RaceCar;<br/>RaceCar.prototype.accelerate = function(extraSpeed) {<br/>  this.speed += extraSpeed + this.boost;<br/>}</pre>
<p>In the preceding code, extending an object requires calling the parent class in the child's <kbd>constructor</kbd> function, creating a clone of the parent's prototype object, and overriding the parent's prototype constructor with the child's prototype constructor. These steps were seen as unintuitive and burdensome by most developers.</p>
<p>Using ES6 classes, however, the code will look like this:</p>
<pre>class Automobile {<br/> constructor(weight, speed) {<br/>   this.weight = weight;<br/>   this.speeed = speed;<br/> }<br/> accelerate(extraSpeed) {<br/>   this.speed += extraSpeed;<br/> }<br/>}<br/>class RaceCar extends Automobile {<br/> constructor(weight, speed, boost) {<br/>   super(weight, speed);<br/>   this.boost = boost;<br/> }<br/> accelerate(extraSpeed) {<br/>   this.speed += extraSpeed + this.boost;<br/> }<br/>}</pre>
<p>The preceding syntax is more in line with what we'd expect from object-oriented programming, and also makes inheritance much simpler.</p>
<p>It's important to note that under the hood, ES6 classes still use JavaScript's prototypical inheritance paradigm. Classes are just syntactic sugar on top of the existing system, so there is no significant difference between these two approaches other than clean code.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Module imports</h1>
                </header>
            
            <article>
                
<p>ES6 also defines a module import and export interface. With the older CommonJS approach, modules are exported using the <kbd>modules.export</kbd> construct, and modules are imported with the <kbd>require(filename)</kbd> function. The ES6 approach looks a little different. In one file, define and export a class, as shown in the following code:</p>
<pre>Class Automobile {<br/>…<br/>}<br/>export default Automobile</pre>
<p>And in another file, import the class, as shown in the following code:</p>
<pre>import Automobile from ‘./classes/automobile.js’;<br/>const myCar = new Automobile();</pre>
<p>At present, Babel compiles ES6 modules to the same format as CommonJS modules, so you can use either the ES6 modules syntax or the CommonJS modules syntax if you’re using Babel.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Arrow functions</h1>
                </header>
            
            <article>
                
<p>One quirky, useful, but somewhat annoying aspect of ES5 JavaScript is its heavy use of callbacks that run asynchronously. You are probably intimately familiar with jQuery code that looks something like this:</p>
<pre>$(“#link”).click(function() {<br/>  var $self = $(this);<br/>  doSomethingAsync(1000, function(resp) {<br/>    $self.addClass(“wasFaded”);<br/>    var processedItems = resp.map(function(item) {<br/>      return processItem(item);<br/>    });<br/>    return shipItems(processedItems);<br/>  });<br/>});</pre>
<p>We're forced to create a variable called <kbd>$self</kbd> because the original <kbd>this</kbd> context is lost in our inner anonymous function. We also have a lot of boilerplate and difficult-to-read code due to needing to create three separate anonymous functions.</p>
<p>Arrow function syntax is both syntactic sugar that helps us write anonymous functions with a shorter syntax, and also a functional update that preserves the context of <kbd>this</kbd> inside an arrow function.</p>
<p>For instance, the preceding code may be written in ES6 as follows:</p>
<pre>$(“#link”).click(function() {<br/>  dozsSomethingAsync(1000, resp =&gt; {<br/>    $(this).addClass(“wasFaded”);<br/>    const processedItems = resp.map(item =&gt; processItem(Item));<br/>    return shipItems(processedItems);<br/>  });<br/>});</pre>
<p>You can see in the preceding code that we no longer need a <kbd>$self</kbd> variable to preserve <kbd>this</kbd>, and our call to <kbd>.map</kbd> is much simpler, no longer requiring the <kbd>function</kbd> keyword, parentheses, curly braces, or a <kbd>return</kbd> statement.</p>
<p>Now let's look at some equivalent functions. Let's look at the following code:</p>
<pre>const double = function(number) {<br/>  return number * 2;<br/>}</pre>
<p>The preceding code would be similar to:</p>
<pre>const double = number =&gt; number * 2;<br/>// Is equal to:<br/>const double = (number) =&gt; { return number * 2; }</pre>
<p>In the aforementioned examples, we can omit the parentheses around the <kbd>number</kbd> parameter because the function only requires one parameter. If the function required two parameters, we would be required to add parentheses as in the next example. Additionally, if the body of our function only requires one line, we can omit the function body curly braces and omit the <kbd>return</kbd> statement.</p>
<p>Let's look at another equivalence, with multiple parameters, as shown in the following code:</p>
<pre>const sorted = names.sort(function (a, b) {<br/>  return a.localeCompare(b);<br/>});</pre>
<p>The preceding code would be similar to:</p>
<pre>const sorted = names.sort((a, b) =&gt; a.localeCompare(b));</pre>
<p>I find that arrow functions make themselves most useful in situations like the preceding one, when you're doing data transformations, especially where using <kbd>Array.map</kbd>, <kbd>Array.filter</kbd>, <kbd>Array.reduce</kbd>, and <kbd>Array.sort</kbd> calls with straightforward function bodies. Arrow functions are less useful in jQuery because of jQuery's tendency to give you data using the <kbd>this</kbd> context, which you don't receive with anonymous arrow functions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Object literals</h1>
                </header>
            
            <article>
                
<p>ES6 makes some improvements to object literals. There are several improvements, but the one you'll see most is the implicit naming of object properties. In ES5 it would be as follows:</p>
<pre>var name = ‘Burak’;<br/>var title = ‘Author’;<br/>var object = {name: name, title: title};</pre>
<p>In ES6, if the property name and the variable name are the same as the preceding one, you can simplify it to the following:</p>
<pre>const name = ‘Burak’;<br/>const title = ‘Author’;<br/>const object = {name, title};</pre>
<p>Additionally, ES6 introduces the object spread operator, which simplifies shallow object merges. For instance, take a look at the following code in ES5:</p>
<pre>function combinePreferences(userPreferences) {<br/> var defaultPreferences = {size: ‘large’, mode: ‘view’};<br/> return Object.assign({}, defaultPreferences, userPreferences);<br/>}</pre>
<p>The preceding code will create a new object from <kbd>defaultPreferences</kbd>, and merge in properties from <kbd>userPreferences</kbd>. Passing an empty object to the <kbd>Object.assign</kbd> instance first parameter ensures that we create a new object rather than overwriting <kbd>defaultPreferences</kbd> (which isn't an issue in the preceding example, but is an issue in real-life use cases).</p>
<p>And now, let's take a look at the same in ES6:</p>
<pre>function combinePreferences(userPreferences) {<br/> var defaultPreferences = {size: ‘large’, mode: ‘view’};<br/> return {...defaultPreferences, ...userPreferences};<br/>}</pre>
<p>This approach does the same as the ES5 example, but is quicker and easier to read in my opinion than the <kbd>Object.assign</kbd> method. Developers familiar with React and Redux, for instance, often use the object spread operator when managing reducer state operations.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The for...of function</h1>
                </header>
            
            <article>
                
<p>The <kbd>for</kbd> loops over arrays in ES5 are often achieved using the <kbd>for (index in array)</kbd> syntax, which looks something like this:</p>
<pre>var items = [1, 2, 3 ];<br/>for (var index in items) {<br/>var item = items[index];<br/>…<br/> }</pre>
<p>And ES6 adds the <kbd>for...of</kbd> syntax, which saves you a step, as you can see from the following code:</p>
<pre>const items = [1, 2, 3 ];<br/>for (const item of items) {<br/> …<br/> }</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Promises</h1>
                </header>
            
            <article>
                
<p>Promises, in one form or another, have been available in JavaScript for a while. All jQuery users are familiar with the idea. A <strong>promise</strong> is a reference to a variable that is generated asynchronously and may become available in the future.</p>
<p>The ES5 way of doing things, if you weren't already using some sort of third-party promise library or jQuery's deferred's, was to accept a callback function to an asynchronous method and run the callback upon successful completion, as shown in the following code:</p>
<pre>function updateUser(user, settings, onComplete, onError) {<br/>  makeAsyncApiRequest(user, settings, function(response) {<br/>    if (response.isValid()) {<br/>      onComplete(response.getBody());<br/>    } else {<br/>      onError(response.getError())<br/>    }<br/>  });<br/>}<br/>updateUser(user, settings, function(body) { ... }, function(error) { ... });</pre>
<p>In ES6, you may return a <kbd>Promise</kbd> which encapsulates the asynchronous request and either gets resolved or rejected, as shown in the following code:</p>
<pre>function updateUser(user, settings) {<br/>  return new Promise((resolve, reject) =&gt; {<br/>    makeAsyncApiRequest(user, settings, function(response) {<br/>      if (response.isValid()) {<br/>        resolve(response.getBody());<br/>      } else {<br/>        reject(response.getError())<br/>      }<br/>    });<br/>  });<br/>}<br/>updateUser(user, settings)<br/>  .then(<br/>    body =&gt; { ... },<br/>    error =&gt; { ... }<br/>  );</pre>
<p>The real power of promises is that they can be passed around as objects, and promise handlers can be chained.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The async/await functions</h1>
                </header>
            
            <article>
                
<p>The <kbd>async</kbd> and <kbd>await</kbd> keywords are not an ES6 feature but rather an ES8 feature. While promises bring huge improvements to the way we deal with asynchronous calls, promises also are susceptible to lots of method chaining, and in some cases force us to use asynchronous paradigms when we really just want to write a function that acts asynchronously but reads as if it were a synchronous function.</p>
<p>Now let's take a look at the following example from MDN's asynchronous function reference page (<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function" target="_blank">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function</a>):</p>
<pre>function resolveAfter2Seconds() {<br/>  return new Promise(resolve =&gt; {<br/>    setTimeout(() =&gt; {<br/>      resolve('resolved');<br/>    }, 2000);<br/>  });<br/>}<br/>async function asyncCall() {<br/>  console.log('calling');<br/>  var result = await resolveAfter2Seconds();<br/>  console.log(result);<br/>  // expected output: "resolved"<br/>}<br/>asyncCall();</pre>
<p>The <kbd>resolveAfter2Seconds</kbd> function is a normal JavaScript function that returns an ES6 promise. The magic is in the <kbd>asyncCall</kbd> function, which is marked by the <kbd>async</kbd> keyword. Inside <kbd>asyncCall</kbd>, we invoke <kbd>resolveAfter2Seconds</kbd> with the <kbd>await</kbd> keyword, rather than using the more familiar promise <kbd>.then(result =&gt; console.log(result))</kbd> construct we'd normally use in ES6. The <kbd>await</kbd> keyword makes our <kbd>async</kbd> function wait for the promise to resolve before continuing, and returns the result of the <kbd>Promise</kbd> directly. In this manner, <kbd>async</kbd>/<kbd>await</kbd> can convert asynchronous functions that use promises to read like synchronous functions, which should help keep deeply nested promise calls and asynchronous function stats neat and easy to read.</p>
<p>The <kbd>async</kbd> and <kbd>await</kbd> features are part of ES8, not ES6, so when we set up Babel in a few minutes we'll need to be sure to include all new versions of EMCAScript in our configuration, not just ES6.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Preparing the development environment</h1>
                </header>
            
            <article>
                
<p>The examples in this book will use both the web browser environment and the Node.js environment. While Node.js Version 8 and higher has support for ES6+, not all browser vendors have complete support yet for ES6+ features, and we will therefore be using Babel to transpile all of our code regardless.</p>
<p>This book will try its best to use the same project structure for all examples, whether they're executed on the command line in Node.js or run in the browser. Because we're attempting to standardize this project structure, not every project will use all of the features we set up in this section.</p>
<p>The tools you will need are:</p>
<ul>
<li>Your favorite code editor, such as Vim, Emacs, Sublime Text, or WebStorm</li>
<li>An up-to-date web browser such as Chrome or Firefox</li>
<li>Node.js Version 8 LTS or higher; this book will use version 9.4.0 for all examples</li>
<li>The Yarn package manager (optional; you may use npm instead)</li>
<li>Various build tools such as Babel and Browserify</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Installing Node.js</h1>
                </header>
            
            <article>
                
<p>If you're a macOS user, the easiest way to install Node.js is through a package manager such as <strong>Homebrew</strong> or <strong>MacPorts</strong>. For best compatibility with the examples in this book, install Node.js version 9.4.0 or greater.</p>
<p>Windows users can also use the <strong>Chocolatey</strong> package manager to install Node.js, otherwise you may follow the instructions on the Node.js current download page: <a href="https://nodejs.org/en/" target="_blank">https://nodejs.org/en/</a>.</p>
<p>Linux users should be careful if installing Node.js through their distribution's package manager, as the shipped version of Node.js may be a much older version. If your package manager uses a version older than V8, you may either add a repository to your package manager, build from source, or install from binary, as appropriate for your system.</p>
<p>Once you've installed Node.js, ensure that it runs and is the correct version by running <kbd>node --version</kbd> from the command line. The output will look like the following:</p>
<pre><strong>$ node --version</strong><br/><strong> V9.4.0</strong></pre>
<p>This is also a good time to test that <kbd>npm</kbd> also works:</p>
<pre><strong>$ npm --version</strong><br/><strong> 5.6.0</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Optionally installing Yarn</h1>
                </header>
            
            <article>
                
<p>Yarn is a package management tool similar to and compatible with npm, though I find it is faster and easier to work with. If using Homebrew on macOS, you may simply install it using <kbd>brew install yarn</kbd>; otherwise follow the instructions found on Yarn's installation guide page (<a href="https://yarnpkg.com/en/docs/install#windows-stable" target="_blank">https://yarnpkg.com/en/docs/install#windows-stable</a>).</p>
<p>If you want to use npm instead of Yarn, you may; both respect the same format for <kbd>package.json</kbd>, though they have slightly different syntaxes for commands such as <kbd>add</kbd>, <kbd>require</kbd>, and <kbd>install</kbd>. If you're using npm instead of Yarn, simply replace the commands with the correct function; the package names used will all be the same.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating and initializing an example project</h1>
                </header>
            
            <article>
                
<p>Use the command line, your favorite IDE, or your file browser to create a directory somewhere on your machine called <kbd>MLinJSBook</kbd>, with a subdirectory called <kbd>Ch1-Ex1</kbd>.</p>
<p>Navigate your command line to the <kbd>Ch1-Ex1</kbd> folder, and run the command <kbd>yarn init</kbd>, which like <kbd>npm init</kbd> will create a <kbd>package.json</kbd> file and prompt you for basic information. Respond to the prompts, answering appropriately. You will not be publishing this package so the answers aren't too important, however, when prompted for the application's entry point, type in <kbd>dist/index.js</kbd>.</p>
<p>Next, we need to install a few build tools that we'll use for the majority of our example projects:</p>
<ul>
<li><kbd>babel-core</kbd>: The Babel transpiler core</li>
<li><kbd>babel-preset-env</kbd>: The Babel parser preset that parses ES6, ES7, and ES8 code</li>
<li><kbd>browserify</kbd>: A JavaScript bundler which can compile multiple files into a single file</li>
<li><kbd>babelify</kbd>: The Babel plugin for Browserify</li>
</ul>
<p>Install these as development environment requirements by issuing the following command:</p>
<pre><strong>yarn add -D babel-cli browserify babelify babel-preset-env</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a Hello World project</h1>
                </header>
            
            <article>
                
<p>To test that everything is building and running, we'll create a very simple two-file Hello World project and add our build script.</p>
<p>First, create two subdirectories under your <kbd>Ch1-Ex1</kbd> folder: <kbd>src</kbd> and <kbd>dist</kbd>. We'll use this convention for all projects: <kbd>src</kbd> will contain JavaScript source code, <kbd>dist</kbd> will contain built source code and any additional assets (images, CSS, HTML files, and so on) required by the project.</p>
<p>In the <kbd>src</kbd> folder, create a file called <kbd>greeting.js</kbd> with the following code:</p>
<pre>const greeting = name =&gt; 'Hello, ' + name + '!';<br/>export default greeting;</pre>
<p>Then create another file called <kbd>index.js</kbd> with the following:</p>
<pre>import greeting from './greeting';<br/>console.log(greeting(process.argv[2] || 'world'));</pre>
<p>This small application tests whether we can use basic ES6 syntax and module loading, as well as access command-line arguments given to Node.js.</p>
<p>Next, open up the <kbd>package.json</kbd> file in <kbd>Ch1-Ex1</kbd>, and add the following section to the file:</p>
<pre>"scripts": {<br/> "build-web": "browserify src/index.js -o dist/index.js -t [ babelify -  <br/>  -presets [ env ] ]",<br/> "build-cli": "browserify src/index.js --node -o dist/index.js -t [  <br/>  babelify --presets [ env ] ]",<br/> "start": "yarn build-cli &amp;&amp; node dist/index.js"<br/>},</pre>
<p>This defines three simple command-line scripts:</p>
<ul>
<li><kbd>Build-web</kbd> uses Browserify and Babel to compile everything that <kbd>src/index.js</kbd> touches into a single file called <kbd>dist/index.js</kbd></li>
<li><kbd>Build-cli</kbd> is similar to <kbd>build-web</kbd>, except it also uses Browserify's node option flag; without this option we would not be able to access command-line arguments given to Node.js</li>
<li><kbd>Start</kbd> is intended only for CLI/Node.js examples, and both builds and runs the source code</li>
</ul>
<p>Your <kbd>package.json</kbd> file should now look something like the following:</p>
<pre>{<br/>"name": "Ch1-Ex1",<br/>"version": "0.0.1",<br/>"description": "Chapter one example",<br/>"main": "src/index.js",<br/>"author": "Burak Kanber",<br/>"license": "MIT",<br/>"scripts": {<br/>  "build-web": "browserify src/index.js -o dist/index.js -t [ babelify --presets [ env ] ]",<br/>  "build-cli": "browserify src/index.js --node -o dist/index.js -t [ babelify --presets [ env ] ]",<br/>  "start": "yarn build-cli &amp;&amp; node dist/index.js"<br/>},<br/>"dependencies": {<br/>  "babel-core": "^6.26.0",<br/>  "babel-preset-env": "^1.6.1",<br/>  "babelify": "^8.0.0",<br/>  "browserify": "^15.1.0"<br/>}}</pre>
<p>Let's put this simple application through a few tests. First, make sure that <kbd>yarn build-cli</kbd> works. You should see something like the following:</p>
<pre><strong>$ yarn build-cli</strong><br/><strong>yarn run v1.3.2</strong><br/><strong>$ browserify src/index.js --node -o dist/index.js -t [ babelify --presets [ env ] ]</strong><br/><strong>Done in 0.59s.</strong></pre>
<p>At this point, confirm that the <kbd>dist/index.js</kbd> file has been built, and try running it directly, using the following code:</p>
<pre><strong>$ node dist/index.js</strong><br/><strong>Hello, world!</strong></pre>
<p>Also try passing in your name as an argument to the command, using the following code:</p>
<pre><strong>$ node dist/index.js Burak</strong><br/><strong>Hello, Burak!</strong></pre>
<p>Now, let's try the <kbd>build-web</kbd> command, as shown in the following code. Because this command omits the <kbd>node</kbd> option, we expect that our argument will not work:</p>
<pre><strong>$ yarn build-web</strong><br/><strong>yarn run v1.3.2</strong><br/><strong>$ browserify src/index.js -o dist/index.js -t [ babelify --presets [ env ] ]</strong><br/><strong>Done in 0.61s.</strong><br/><strong>$ node dist/index.js Burak</strong><br/><strong>Hello, world!</strong></pre>
<p>Without the <kbd>node</kbd> option, our arguments are not forwarded to the script, and it defaults to saying <kbd>Hello, world!</kbd>, which is the expected result here.</p>
<p>Finally, let's test our <kbd>yarn start</kbd> command, using the following code, to make sure it builds the CLI version of the application and also forwards our command-line arguments, using the following code:</p>
<pre><strong>$ yarn start "good readers"</strong><br/><strong>yarn run v1.3.2</strong><br/><strong>$ yarn build-cli &amp;&amp; node dist/index.js 'good readers'</strong><br/><strong>$ browserify src/index.js --node -o dist/index.js -t [ babelify --presets [ env ] ]</strong><br/><strong>Hello, good readers!</strong><br/><strong>Done in 1.05s.</strong></pre>
<p>The <kbd>yarn start</kbd> command successfully built the CLI version of the application and forwarded our command-line arguments to the program.</p>
<p>We will try our best to use the same structure for each of the examples in this book, however, pay attention to the beginning of each chapter as each example may require some additional setup work.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we've discussed the important moments of JavaScript's history as applied to ML, starting from the launch of Google (<a href="https://www.google.com/" target="_blank">https://www.google.com/</a>) and finishing up at the end of 2017 with the release of Google's <kbd>deeplearn.js</kbd> library.</p>
<p>We’ve discussed some advantages to using JavaScript for machine learning, and also some of the challenges we’re facing, particularly in terms of the machine learning ecosystem.</p>
<p>We then took a tour of the most important recent developments in the JavaScript language, and had a brief introduction to ES6, the newest stable JavaScript language specification.</p>
<p>Finally, we set up an example development environment using Node.js, the Yarn package manager, Babel, and Browserify—tools that we will use throughout the rest of the book in our examples.</p>
<p>In the next chapter, we'll begin exploring and processing the data itself.</p>


            </article>

            
        </section>
    </body></html>