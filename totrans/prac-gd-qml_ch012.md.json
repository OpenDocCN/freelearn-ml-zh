["```py\n\nimport dimod \n\nJ = {(0,1):1, (0,2):1} \n\nh = {} \n\nproblem = dimod.BinaryQuadraticModel(h, J, 0.0, dimod.SPIN) \n\nprint(\"The problem we are going to solve is:\") \n\nprint(problem)\n\n```", "```py\n\nThe problem we are going to solve is: \n\nBinaryQuadraticModel({0: 0.0, 1: 0.0, 2: 0.0}, \n\n    {(1, 0): 1.0, (2, 0): 1.0}, 0.0, ’SPIN’)\n\n```", "```py\n\nfrom dwave.system import DWaveSampler \n\nfrom dwave.system import EmbeddingComposite \n\nsampler = EmbeddingComposite(DWaveSampler()) \n\nresult = sampler.sample(problem, num_reads=10) \n\nprint(\"The solutions that we have obtained are\") \n\nprint(result)\n\n```", "```py\n\nThe solutions that we have obtained are \n\n   0  1  2 energy num_oc. chain_. \n\n0 +1 -1 -1   -2.0       6     0.0 \n\n1 -1 +1 +1   -2.0       4     0.0 \n\n[’SPIN’, 2 rows, 10 samples, 3 variables]\n\n```", "```py\n\nx0 = dimod.Binary(\"x0\") \n\nx1 = dimod.Binary(\"x1\") \n\nx2 = dimod.Binary(\"x2\")\n\n```", "```py\n\nblp = dimod.ConstrainedQuadraticModel() \n\nblp.set_objective(-5*x0+3*x1-2*x2) \n\nblp.add_constraint(x0 + x2 <= 1, \"First constraint\") \n\nblp.add_constraint(3*x0 -x1 + 3*x2 <= 4, \"Second constraint\")\n\n```", "```py\n\nprint(\"Our variables are:\") \n\nprint(blp.variables) \n\nprint(\"Our objective is:\") \n\nprint(blp.objective) \n\nprint(\"Our constraints are:\") \n\nprint(blp.constraints)\n\n```", "```py\n\nOur variables are: \n\nVariables([’x0’, ’x1’, ’x2’]) \n\nOur objective is: \n\nObjectiveView({’x0’: -5.0, ’x1’: 3.0, ’x2’: -2.0}, {}, 0.0, \n\n    {’x0’: ’BINARY’, ’x1’: ’BINARY’, ’x2’: ’BINARY’}) \n\nOur constraints are: \n\n{’First constraint’: Le(ConstraintView({’x0’: 1.0, ’x2’: 1.0}, {}, 0.0, \n\n    {’x0’: ’BINARY’, ’x2’: ’BINARY’}), 1.0), ’Second constraint’: \n\n    Le(ConstraintView({’x0’: 3.0, ’x1’: -1.0, ’x2’: 3.0}, {}, 0.0, \n\n    {’x0’: ’BINARY’, ’x1’: ’BINARY’, ’x2’: ’BINARY’}), 4.0)}\n\n```", "```py\n\nsample1 = {\"x0\":1, \"x1\":1, \"x2\":1} \n\nprint(\"The assignment is\", sample1) \n\nprint(\"Its cost is\", blp.objective.energy(sample1)) \n\nprint(\"Is it feasible?\",blp.check_feasible(sample1)) \n\nprint(\"The violations of the constraints are\") \n\nprint(blp.violations(sample1))\n\n```", "```py\n\nThe assignment is {’x0’: 1, ’x1’: 1, ’x2’: 1} \n\nIts cost is -4.0 \n\nIs it feasible? False \n\nThe violations of the constraints are \n\n{’First constraint’: 1.0, ’Second constraint’: 1.0}\n\n```", "```py\n\nsample2 = {\"x0\":0, \"x1\":0, \"x2\":1} \n\nprint(\"The assignment is\", sample2) \n\nprint(\"Its cost is\", blp.objective.energy(sample2)) \n\nprint(\"Is it feasible?\",blp.check_feasible(sample2)) \n\nprint(\"The violations of the constraints are\") \n\nprint(blp.violations(sample2))\n\n```", "```py\n\nThe assignment is {’x0’: 0, ’x1’: 0, ’x2’: 1} \n\nIts cost is -2.0 \n\nIs it feasible? True \n\nThe violations of the constraints are \n\n{’First constraint’: 0.0, ’Second constraint’: -1.0}\n\n```", "```py\n\nsolver = dimod.ExactCQMSolver() \n\nsolution = solver.sample_cqm(blp) \n\nprint(\"The list of assignments is\") \n\nprint(solution)\n\n```", "```py\n\nThe list of assignments is \n\n  x0 x1 x2 energy num_oc. is_sat. is_fea. \n\n6  1  0  1   -7.0       1 arra...   False \n\n2  1  0  0   -5.0       1 arra...    True \n\n7  1  1  1   -4.0       1 arra...   False \n\n3  1  1  0   -2.0       1 arra...    True \n\n4  0  0  1   -2.0       1 arra...    True \n\n0  0  0  0    0.0       1 arra...    True \n\n5  0  1  1    1.0       1 arra...    True \n\n1  0  1  0    3.0       1 arra...    True \n\n[’INTEGER’, 8 rows, 8 samples, 3 variables]\n\n```", "```py\n\nSample(sample={’x0’: 1, ’x1’: 0, ’x2’: 1}, energy=-7.0, \n\n    num_occurrences=1, is_satisfied=array([False, False]), \n\n    is_feasible=False)\n\n```", "```py\n\nfeasible_sols = solution.filter(lambda s: s.is_feasible)\n\n```", "```py\n\nSample(sample={’x0’: 1, ’x1’: 0, ’x2’: 0}, energy=-5.0, num_occurrences=1, \n\n    is_satisfied=array([ True,  True]), is_feasible=True)\n\n```", "```py\n\ny0, y1 = dimod.Binaries([\"y0\", \"y1\"]) \n\ncqm = dimod.ConstrainedQuadraticModel() \n\ncqm.set_objective(-2*y0-3*y1) \n\ncqm.add_constraint(y0 + 2*y1 <= 2)\n\n```", "```py\n\nqubo, invert = dimod.cqm_to_bqm(cqm, lagrange_multiplier = 5) \n\nprint(qubo)\n\n```", "```py\n\nBinaryQuadraticModel({’y0’: -17.0, ’y1’: -23.0, \n\n    ’slack_03b79fa9-3faa-410c-800b-65cfaf281cdf_0’: -15.0, \n\n    ’slack_03b79fa9-3faa-410c-800b-65cfaf281cdf_1’: -15.0}, \n\n    {(’y1’, ’y0’): 20.0, \n\n    (’slack_03b79fa9-3faa-410c-800b-65cfaf281cdf_0’, ’y0’): 10.0, \n\n    (’slack_03b79fa9-3faa-410c-800b-65cfaf281cdf_0’, ’y1’): 20.0, \n\n    (’slack_03b79fa9-3faa-410c-800b-65cfaf281cdf_1’, ’y0’): 10.0, \n\n    (’slack_03b79fa9-3faa-410c-800b-65cfaf281cdf_1’, ’y1’): 20.0, \n\n    (’slack_03b79fa9-3faa-410c-800b-65cfaf281cdf_1’, \n\n    ’slack_03b79fa9-3faa-410c-800b-65cfaf281cdf_0’): 10.0}, \n\n    20.0, ’BINARY’)\n\n```", "```py\n\nsampler = EmbeddingComposite(DWaveSampler()) \n\nresult = sampler.sample(qubo, num_reads=10) \n\nprint(\"The solutions that we have obtained are\") \n\nprint(result)\n\n```", "```py\n\n  slack_03b79fa9-3faa-410c-800b-65cfaf281cdf_0 ... y1 energy num_oc. ... \n\n0                                            0 ...  1   -3.0       5 ... \n\n1                                            1 ...  0   -2.0       3 ... \n\n2                                            0 ...  0   -2.0       1 ... \n\n3                                            0 ...  1    0.0       1 ... \n\n[’BINARY’, 4 rows, 10 samples, 4 variables]\n\n```", "```py\n\nsamples = [] \n\noccurrences = [] \n\nfor s in result.data(): \n\n    samples.append(invert(s.sample)) \n\n    occurrences.append(s.num_occurrences) \n\nsampleset = dimod.SampleSet.from_samples_cqm(samples,cqm, \n\n    num_occurrences=occurrences) \n\nprint(\"The solutions to the original problem are\") \n\nprint(sampleset)\n\n```", "```py\n\nThe solutions to the original problem are \n\n  y0 y1 energy num_oc. is_sat. is_fea. \n\n3  1  1   -5.0       1 arra...   False \n\n0  0  1   -3.0       5 arra...    True \n\n1  1  0   -2.0       3 arra...    True \n\n2  1  0   -2.0       1 arra...    True \n\n[’INTEGER’, 4 rows, 10 samples, 2 variables]\n\n```", "```py\n\nfinal_sols = sampleset.filter(lambda s: s.is_feasible) \n\nfinal_sols = final_sols.aggregate() \n\nprint(\"The final solutions are\") \n\nprint(final_sols)\n\n```", "```py\n\n  y0 y1 energy num_oc. is_sat. is_fea. \n\n0  0  1   -3.0       5 arra...    True \n\n1  1  0   -2.0       4 arra...    True \n\n[’INTEGER’, 2 rows, 9 samples, 2 variables]\n\n```", "```py\n\nfrom dwave.cloud import Client \n\nfor solver in Client.from_config().get_solvers(): \n\n    print(solver)\n\n```", "```py\n\nBQMSolver(id=’hybrid_binary_quadratic_model_version2’) \n\nDQMSolver(id=’hybrid_discrete_quadratic_model_version1’) \n\nCQMSolver(id=’hybrid_constrained_quadratic_model_version1’) \n\nStructuredSolver(id=’Advantage_system6.1’) \n\nStructuredSolver(id=’Advantage2_prototype1.1’) \n\nStructuredSolver(id=’DW_2000Q_6’) \n\nStructuredSolver(id=’Advantage_system4.1’)\n\n```", "```py\n\nfrom dwave.system import DWaveSampler \n\nsampler=DWaveSampler(solver=’DW_2000Q_6’) \n\nprint(\"Name:\",sampler.properties[\"chip_id\"]) \n\nprint(\"Number of qubits:\",sampler.properties[\"num_qubits\"]) \n\nprint(\"Category:\",sampler.properties[\"category\"]) \n\nprint(\"Supported problems:\",sampler.properties[\"supported_problem_types\"]) \n\nprint(\"Topology:\",sampler.properties[\"topology\"]) \n\nprint(\"Range of reads:\",sampler.properties[\"num_reads_range\"])\n\n```", "```py\n\nName: DW_2000Q_6 \n\nNumber of qubits: 2048 \n\nCategory: qpu \n\nSupported problems: [’ising’, ’qubo’] \n\nTopology: {’type’: ’chimera’, ’shape’: [16, 16, 4]} \n\nRange of reads: [1, 10000]\n\n```", "```py\n\nName: Advantage_system4.1 \n\nNumber of qubits: 5760 \n\nCategory: qpu \n\nSupported problems: [’ising’, ’qubo’] \n\nTopology: {’type’: ’pegasus’, ’shape’: [16]} \n\nRange of reads: [1, 10000]\n\n```", "```py\n\nName: Advantage2_prototype1.1 \n\nNumber of qubits: 576 \n\nCategory: qpu \n\nSupported problems: [’ising’, ’qubo’] \n\nTopology: {’type’: ’zephyr’, ’shape’: [4, 4]} \n\nRange of reads: [1, 10000]\n\n```", "```py\n\nsampler=DWaveSampler(solver=’DW_2000Q_6’) \n\nprint(\"Couplings:\",sampler.properties[\"couplers\"])\n\n```", "```py\n\n[[0, 4], [1, 4], [2, 4], [3, 4], [0, 5], [1, 5], [2, 5], [3, 5], \n\n[0, 6], [1, 6], [2, 6], [3, 6], [0, 7], [1, 7], [2, 7], [3, 7], \n\n[4, 12], [8, 12], [9, 12], [10, 12], [11, 12], [5, 13], [8, 13], \n\n[9, 13], [10, 13], [11, 13], [6, 14], [8, 14], [9, 14], [10, 14], \n\n[11, 14], [7, 15], [8, 15], [9, 15], [10, 15], [11, 15], [12, 20], \n\n[16, 20], [17, 20], [18, 20], [19, 20], [13, 21], [16, 21], \n\n[17, 21], [18, 21], [19, 21], [16, 22], [17, 22]...\n\n```", "```py\n\n{0: {4, 5, 6, 7, 128}, 1: {4, 5, 6, 7, 129}, \n\n 2: {4, 5, 6, 7, 130}, 3: {4, 5, 6, 7, 131}, \n\n 4: {0, 1, 2, 3, 12}, 5: {0, 1, 2, 3, 13}, \n\n 6: {0, 1, 2, 3, 14}, 7: {0, 1, 2, 3, 15}, \n\n 8: {12, 13, 14, 15, 136}, ...\n\n```", "```py\n\n# Define the problem \n\nJ = {(0,1):1, (0,2):1, (1,2):1} \n\nh = {} \n\ntriangle = dimod.BinaryQuadraticModel(h, J, 0.0, dimod.SPIN) \n\n# Embed it and solve it on the DW_2000Q_6 annealer \n\nsampler = EmbeddingComposite(DWaveSampler(solver = \"DW_2000Q_6\")) \n\nresult = sampler.sample(triangle, num_reads=10, \n\n    return_embedding = True) \n\nprint(\"The samples obtained are\") \n\nprint(result) \n\nprint(\"The embedding used was\") \n\nprint(result.info[\"embedding_context\"])\n\n```", "```py\n\nThe samples obtained are \n\n   0  1  2 energy num_oc. chain_. \n\n0 +1 -1 -1   -1.0       3     0.0 \n\n1 +1 +1 -1   -1.0       2     0.0 \n\n2 +1 -1 +1   -1.0       2     0.0 \n\n3 -1 +1 +1   -1.0       3     0.0 \n\n[’SPIN’, 4 rows, 10 samples, 3 variables] \n\nThe embedding used was \n\n{’embedding’: {1: (1015, 1008), 0: (1011,), 2: (1012,)}, \n\n’chain_break_method’: ’majority_vote’, ’embedding_parameters’: {}, \n\n’chain_strength’: 1.9996979771955565}\n\n```", "```py\n\nsampler = DWaveSampler(solver = \"Advantage_system4.1\") \n\nprint(\"The default annealing time is\", \n\n    sampler.properties[\"default_annealing_time\"],\"microseconds\") \n\nprint(\"The possible values for the annealing time (in microseconds)\"\\ \n\n    \" lie in the range\",sampler.properties[\"annealing_time_range\"])\n\n```", "```py\n\nThe default annealing time is 20.0 microseconds \n\nThe possible values for the annealing time (in microseconds) \n\n    lie in the range [0.5, 2000.0]\n\n```", "```py\n\nJ = {(0,1):1, (0,2):1, (1,2):1} \n\nh = {} \n\ntriangle = dimod.BinaryQuadraticModel(h, J, 0.0, dimod.SPIN) \n\nsampler = EmbeddingComposite(DWaveSampler(solver = \"DW_2000Q_6\")) \n\nresult = sampler.sample(triangle, num_reads=10, annealing_time = 100) \n\nprint(\"The samples obtained are\") \n\nprint(result)\n\n```", "```py\n\nforward_schedule=[[0.0, 0.0], [5.0, 0.25], [25, 0.75], [30, 1.0]]\n\n```", "```py\n\nforward_schedule=[[0.0, 0.0], [5.0, 0.25], [25, 0.75], [30, 1.0]] \n\nsampler = EmbeddingComposite(DWaveSampler()) \n\nresult = sampler.sample(triangle, num_reads=10, \n\n    anneal_schedule = forward_schedule)\n\n```", "```py\n\nreverse_schedule=[[0.0, 1.0], [10.0, 0.5], [20, 1.0]]\n\n```", "```py\n\nreverse_schedule=[[0.0, 1.0], [10.0, 0.5], [20, 1.0]] \n\ninitial_state = {0:1, 1:1, 2:1} \n\nsampler = EmbeddingComposite(DWaveSampler()) \n\nresult = sampler.sample(triangle, num_reads=10, \n\n    anneal_schedule = reverse_schedule, \n\n    reinitialize_state=False, initial_state = initial_state) \n\nprint(\"The samples obtained are\") \n\nprint(result)\n\n```", "```py\n\nThe samples obtained are \n\n   0  1  2 energy num_oc. chain_. \n\n0 -1 +1 -1   -1.0       1     0.0 \n\n1 +1 +1 -1   -1.0       1     0.0 \n\n2 +1 +1 -1   -1.0       1     0.0 \n\n3 -1 +1 -1   -1.0       1     0.0 \n\n4 -1 -1 +1   -1.0       1     0.0 \n\n5 +1 -1 +1   -1.0       1     0.0 \n\n6 +1 +1 -1   -1.0       1     0.0 \n\n7 +1 +1 -1   -1.0       1     0.0 \n\n8 +1 -1 -1   -1.0       1     0.0 \n\n9 -1 +1 -1   -1.0       1     0.0 \n\n[’SPIN’, 10 rows, 10 samples, 3 variables]\n\n```", "```py\n\nsampler = DWaveSampler(\"Advantage_system4.1\") \n\nprint(\"The coupling strength range is\", sampler.properties[\"h_range\"])\n\n```", "```py\n\nThe coupling strength range is [-4.0, 4.0]\n\n```", "```py\n\nsampler = EmbeddingComposite(DWaveSampler(\"Advantage_system4.1\")) \n\n# Define the problem \n\nx0 = dimod.Binary(\"x0\") \n\nx1 = dimod.Binary(\"x1\") \n\nx2 = dimod.Binary(\"x2\") \n\nblp = dimod.ConstrainedQuadraticModel() \n\nblp.set_objective(-5*x0+3*x1-2*x2) \n\nblp.add_constraint(x0 + x2 <= 1, \"First constraint\") \n\nblp.add_constraint(3*x0 -x1 + 3*x2 <= 4, \"Second constraint\") \n\n# Convert the problem and run it \n\nqubo, invert = dimod.cqm_to_bqm(blp, lagrange_multiplier = 10) \n\nresult = sampler.sample(qubo, num_reads=100) \n\n# Aggregate and show the results \n\nsamples = [] \n\noccurrences = [] \n\nfor s in result.data(): \n\n    samples.append(invert(s.sample)) \n\n    occurrences.append(s.num_occurrences) \n\nsampleset = dimod.SampleSet.from_samples_cqm(samples,blp, \n\n    num_occurrences=occurrences) \n\nprint(\"The solutions to the original problem are\") \n\nprint(sampleset.filter(lambda s: s.is_feasible).aggregate())\n\n```", "```py\n\nThe solutions to the original problem are \n\n  x0 x1 x2 energy num_oc. is_sat. is_fea. \n\n0  1  0  0   -5.0      21 arra...    True \n\n1  1  1  0   -2.0      32 arra...    True \n\n2  0  0  1   -2.0      11 arra...    True \n\n3  0  0  0    0.0      17 arra...    True \n\n4  0  1  1    1.0      10 arra...    True \n\n5  0  1  0    3.0       9 arra...    True \n\n[’INTEGER’, 6 rows, 100 samples, 3 variables]\n\n```", "```py\n\nThe solutions to the original problem are \n\n  x0 x1 x2 energy num_oc. is_sat. is_fea. \n\n0  1  0  0   -5.0      30 arra...    True \n\n1  1  1  0   -2.0      31 arra...    True \n\n2  0  0  1   -2.0      16 arra...    True \n\n3  0  0  0    0.0       8 arra...    True \n\n4  0  1  1    1.0      10 arra...    True \n\n5  0  1  0    3.0       3 arra...    True \n\n[’INTEGER’, 6 rows, 98 samples, 3 variables]\n\n```", "```py\n\nThe solutions to the original problem are \n\n  x0 x1 x2 energy num_oc. is_sat. is_fea. \n\n0  1  0  0   -5.0      76 arra...    True \n\n1  0  0  1   -2.0       5 arra...    True \n\n2  1  1  0   -2.0      11 arra...    True \n\n3  0  0  0    0.0       1 arra...    True \n\n4  0  1  1    1.0       1 arra...    True \n\n[’INTEGER’, 5 rows, 94 samples, 3 variables]\n\n```", "```py\n\nimport greedy \n\nimport dimod \n\nJ = {(0,1):1, (1,2):1, (2,3):1, (3,0):1} \n\nh = {} \n\nproblem = dimod.BinaryQuadraticModel(h, J, 0.0, dimod.SPIN) \n\n# Sample with SteepestDescentSolver \n\nsolver = greedy.SteepestDescentSolver() \n\nsolution = solver.sample(problem, num_reads = 10) \n\nprint(solution.aggregate())\n\n```", "```py\n\n0  1  2  3 energy num_oc. num_st. \n0 +1 -1 +1 -1   -4.0       5       1 \n2 -1 +1 -1 +1   -4.0       3       1 \n1 +1 -1 -1 +1    0.0       1       0 \n3 +1 +1 -1 -1    0.0       1       0 \n[’SPIN’, 4 rows, 10 samples, 4 variables]\n\n```", "```py\n\nimport tabu \n\nsolver = tabu.TabuSampler() \n\nsolution = solver.sample(problem, num_reads = 10) \n\nprint(solution.aggregate())\n\n```", "```py\n\nimport neal \n\nsolver = neal.SimulatedAnnealingSampler() \n\nsolution = solver.sample(problem, num_reads = 10) \n\nprint(solution.aggregate())\n\n```", "```py\n\nimport dwave.system \n\nsampler = dwave.system.LeapHybridSampler() \n\nsolution = solver.sample(problem, num_reads = 10) \n\nprint(solution.aggregate())\n\n```", "```py\n\nsampler.properties[\"quota_conversion_rate\"]\n\n```"]