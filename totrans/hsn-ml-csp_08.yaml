- en: Encyclopedias and Neurons – Traveling Salesman Problem
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 百科全书和神经元 – 旅行商问题
- en: In this chapter we are going to solve one of the most famous of all problems
    for machine learners. We will also dive into the world of graph theory (just a
    bit) as well as neural network neurons. Let's start off by explaining the traveling
    salesman problem, shall we?
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将解决机器学习者面临的最著名的问题之一。我们还将进入图论的世界（只是稍微了解一下）以及神经网络神经元。让我们先从解释旅行商问题开始，怎么样？
- en: 'In this chapter we will cover:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Traveling salesman problem
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 旅行商问题
- en: Learning rate parameter
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习率参数
- en: Traveling salesman problem
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 旅行商问题
- en: We have a salesman who must travel between *n* cities. He doesn't care about
    which order this happens in, nor which city he visits first or last. His only
    concern is that he visits each city only once and finishes at home, where he started.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个必须旅行于*n*个城市之间的旅行商。他不在乎这个顺序是怎样的，也不在乎他首先或最后访问哪个城市。他唯一关心的是他只访问每个城市一次，并最终回到起点。
- en: Each city is a node, and each node is connected to other close nodes by an edge
    (think of it like a road, plane, train, car, and so on).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 每个城市是一个节点，每个节点通过边与其他相邻节点相连（想象它就像一条路、飞机、火车、汽车等等）。
- en: Now, each of those connections has one or more weights associated with it, which
    we will call the **cost**.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每个这些连接都关联着一个或多个权重，我们将称之为**成本**。
- en: The cost describes the difficulty of travel along that connection, such as the
    cost of the plane ticket, the amount of gas the car needs, and so on.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 成本描述了沿着该连接旅行的难度，例如飞机票的成本、汽车所需的汽油量等等。
- en: Our salesman has a boss as we met in [Chapter 1](7a1f2cca-1be5-426a-8e8a-6a4a3828cd76.xhtml),
    *Machine Learning Basics*, so his marching orders are to keep the cost and distance
    he travels as low as possible.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的旅行商有一个老板，就像我们在[第一章](7a1f2cca-1be5-426a-8e8a-6a4a3828cd76.xhtml)“机器学习基础”中遇到的那样，所以他的命令是尽可能降低成本和旅行距离。
- en: '*How does this apply to me in real life?* you may ask. This problem actually
    has several applications in real life such as'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问：“这对我现实生活中有什么用？”这个问题实际上在现实生活中有几种应用，例如
- en: The design and creation of circuit boards for your computer. With millions of
    transistors, the circuit board needs to be drilled and created precisely.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为您的计算机设计电路板。由于有数百万个晶体管，电路板需要精确地钻孔和制造。
- en: It also appears as a subproblem in DNA sequencing, which has become a big part
    of machine learning for many people.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它也出现在DNA测序的子问题中，这已经成为许多人机器学习的一部分。
- en: For those that have taken up or are familiar with graph theory, you hopefully
    remember the undirected weighted graph. That is exactly what we are dealing with
    here. The cities are vertices, the paths are edges, and the path distance is the
    edge weight. Never thought you'd use that knowledge again, did you? In essence,
    we have a minimization problem of starting and finishing at a specific vertex
    after having visited every other vertex just once. We may, in fact, end up with
    a complete graph when we are done, where each pair of vertices is connected by
    an edge.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些已经学习过或熟悉图论的人来说，你希望记得无向加权图。这正是我们在这里处理的内容。城市是顶点，路径是边，路径距离是边权重。你没想到会再次使用这些知识，对吧？本质上，我们有一个最小化问题，即在访问过每个其他顶点一次后，从特定的顶点开始并结束。实际上，我们可能最终得到一个完全图，其中每对顶点都通过边相连。
- en: 'Next, we must talk about asymmetry and symmetry, because this problem may end
    up being either. What do we mean exactly? Well, we have either an asymmetric traveling
    salesman problem or a symmetric traveling salesman problem. It all depends upon
    the distance between two cities. If the distances are the same in each direction,
    we have a symmetric traveling salesman problem, and the symmetry helps us have
    the possible solutions. If the paths do not exist in both directions, or if the
    distances are different, we have a directed graph. Here is a diagram showing the
    preceding description:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须谈谈不对称性和对称性，因为这个问题可能最终会变成其中之一。我们究竟是什么意思呢？嗯，我们可能有一个不对称的旅行商问题或一个对称的旅行商问题。这完全取决于两个城市之间的距离。如果每个方向上的距离都相同，我们就有一个对称的旅行商问题，对称性有助于我们找到可能的解决方案。如果路径在两个方向上都不存在，或者距离不同，我们就有一个有向图。下面是一个展示上述描述的图表：
- en: '![](img/7ea1158d-5dd6-46d9-927a-3243696efbf9.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7ea1158d-5dd6-46d9-927a-3243696efbf9.png)'
- en: The traveling salesman problem can be symmetric or asymmetric. In this chapter,
    we are going to take you through the wonderful land of genetic algorithms. Let's
    start with an incredibly oversimplistic description of what's going to happen.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 旅行商问题可以是对称的也可以是不对称的。在本章中，我们将带您进入遗传算法的奇妙领域。让我们从一个极其简化的描述开始，看看将要发生什么。
- en: In the biology world, when we want to create a new genotype, we take a little
    bit from parent **A** and the rest from parent **B**. This is called crossover
    mutation, if you are updating your buzzword-compliant checklist! After this happens,
    these genotypes are perturbed, or altered, ever so slightly. This is called **mutation**
    (update that buzzword compliant list again), and this is how genetic material
    is created.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在生物学领域，当我们想要创建一个新的基因型时，我们会从父母**A**那里拿一点，从父母**B**那里拿剩下的。如果你正在更新你的时髦词汇清单，这被称为交叉变异！在这个发生之后，这些基因型会受到干扰，或者轻微地改变。这被称为**变异**（再次更新你的时髦词汇清单），这就是如何创造遗传物质的。
- en: Next, we delete the original generation, replaced by the new one, and each genotype
    is tested. The newer genotypes, being the better part of their previous components,
    will now be skewed towards higher fitness; on an average, this generation should
    score higher than its predecessor.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们删除原始一代，用新一代替换，并对每个基因型进行测试。新的基因型，作为它们先前成分的较好部分，现在将偏向于更高的适应度；平均而言，这一代应该比前一代得分更高。
- en: This process continues for many generations, and over time, the average fitness
    of the population will evolve and increase. This doesn't always work, as in real
    life, but generally speaking, it does.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程会持续很多代，随着时间的推移，种群的平均适应度将演变并增加。这并不总是有效，就像现实生活中一样，但一般来说，它是有效的。
- en: With a seminar of genetic algorithmic programming behind us, let's dive into
    our application.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在遗传算法编程研讨会之后，让我们深入我们的应用。
- en: 'Here''s what our sample application looks like. It is based on the Accord.NET
    framework. After we''ve defined the number of houses we need to visit, we simply
    click on the Generate button:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们的示例应用的样子。它基于Accord.NET框架。在我们定义了需要访问的房屋数量之后，我们只需点击生成按钮：
- en: '![](img/5852916c-ce94-4bba-adb9-ff2010210271.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5852916c-ce94-4bba-adb9-ff2010210271.png)'
- en: In our test application, we can change the number of houses that we want to
    visit very easily, as shown in the highlighted area.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的测试应用中，我们可以非常容易地更改我们想要访问的房屋数量，如高亮区域所示。
- en: 'We could have a very simple problem space or a more complicated one. Here is
    an example of a very simple problem space:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能有一个非常简单的问题空间，或者一个更复杂的问题空间。这里是一个非常简单的问题空间的例子：
- en: '![](img/11f8c269-cfe9-4e8c-8c1a-30b2f450db74.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](img/11f8c269-cfe9-4e8c-8c1a-30b2f450db74.png)'
- en: 'And here is an example of a more complicated problem space:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个更复杂的问题空间的例子：
- en: '![](img/f22d22ab-aa44-4951-82b8-13f4631562b3.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f22d22ab-aa44-4951-82b8-13f4631562b3.png)'
- en: 'We also have three different types of selection methods for our algorithm to
    work with, namely Elite, Rank, and Roulette:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有三种不同的选择方法供我们的算法使用，即精英、排名和轮盘赌：
- en: '![](img/ab140719-461c-4cf3-b830-d2be1935a592.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ab140719-461c-4cf3-b830-d2be1935a592.png)'
- en: 'Elite: Specifies the number of best chromosomes to work within the next generation.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 精英：指定下一代中要工作的最佳染色体的数量。
- en: 'Roulette: Selects chromosomes based on their rank (fitness value).'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 轮盘赌：根据染色体的排名（适应度值）选择染色体。
- en: 'Rank: Selects chromosomes based on their rank (fitness value). This differs
    from the Roulette selection method in that the wheel and sector sizes are different
    within the calculation.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排名：根据染色体的排名（适应度值）选择染色体。这与轮盘赌选择方法不同，因为在计算中轮盘和扇区的大小不同。
- en: 'Finally, we choose the total number of iterations we want our algorithm to
    use. We select the Calculate Route button, and, assuming all goes well, we''ll
    end up with our map looking similar to this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们选择算法要使用的总迭代次数。我们选择计算路线按钮，如果一切顺利，我们最终会得到一个与这个类似的地图：
- en: '![](img/b913e5cd-325a-4d20-a531-77f68c56c7de.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b913e5cd-325a-4d20-a531-77f68c56c7de.png)'
- en: 'Let''s take a look at what happens when we select the number of cities we want
    and then click on the Generate button:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看当我们选择我们想要的城市的数量然后点击生成按钮时会发生什么：
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first thing that we do is initialize our random number generator and seed
    it. Next, we get the total number of cities that the user specified, and then
    create a new array from that. Finally, we plot each point and update our map.
    The map is a chart control from Accord.NET that will take care of a lot of visual
    plotting for us.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先做的事情是初始化我们的随机数生成器并对其进行播种。接下来，我们获取用户指定的城市总数，然后根据这个创建一个新的数组。最后，我们绘制每个点并更新我们的地图。这个地图是来自Accord.NET的图表控件，将为我们处理大量的视觉绘图。
- en: With that done, we are ready to calculate our route and (hopefully) solve our
    problem.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，我们就准备好计算我们的路线，并（希望）解决这个问题。
- en: 'Next, let''s see what our main search solution looks like:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看我们的主要搜索解决方案是什么样子：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let''s try and break all that down into more usable chunks for you. The first
    thing we do is determine the selection method that we''ll use to rank our chromosomes:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试将所有这些分解成更可用的块供你使用。我们首先确定我们将使用什么选择方法来排名我们的染色体：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'I want to take this opportunity to point out the `TSPChromosome` you see here.
    This object is based on a short-array chromosome (one that is an array of unsigned
    short values ranging from 2 to 65,536\. There are two specific features:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我想借此机会指出你在这里看到的`TSPChromosome`。这个对象基于一个短数组染色体（一个范围从2到65,536的无符号短整数值的数组）。有两个特定的特性：
- en: All genes are unique within the chromosome, meaning there are no two genes with
    the same value
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有基因在染色体中都是唯一的，这意味着没有两个基因具有相同的值
- en: The maximum value of each gene is equal to the chromosome length minus 1
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个基因的最大值等于染色体长度减1
- en: 'Next, we must create the path variable for us to fill in with our data points:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须为我们创建一个路径变量来填充我们的数据点：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'After this is complete, we can enter our `while` loop and begin our processing.
    To do that, we will process a single generation by running a single epoch. You
    can think of an epoch as an iteration:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此步骤后，我们可以进入我们的`while`循环并开始处理。为此，我们将通过运行一个epoch来处理单个生成。你可以把epoch看作是一个迭代：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We then get the best values from that effort:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后从那个努力中获得最佳值：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We update and create our path between each city:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在每座城市之间更新和创建我们的路径：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'And we supply that value to our chart control:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将该值提供给我们的图表控件：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Let's see some examples of what our route might look like based on the selection
    method that we choose.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看根据我们选择的排名方法，我们的路线可能是什么样子的一些例子。
- en: 'The Elite selection:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 精英选择：
- en: '![](img/97c489e9-78a5-4c48-b6c3-a16089603056.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/97c489e9-78a5-4c48-b6c3-a16089603056.png)'
- en: 'The Rank selection:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 排名选择：
- en: '![](img/3f3947c7-7cce-46f5-b247-12539e267f3c.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3f3947c7-7cce-46f5-b247-12539e267f3c.png)'
- en: The difference between this and the Roulette selection method is in the wheel
    and its sector size calculation methods. The size of the wheel equals *size *
    (size +1) / 2*, where *size* is the size of the current population. The worst
    chromosome has its sector size equal to 1, the next has a size of 2, and so on.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这与轮盘赌选择方法的区别在于轮盘和其扇区大小计算方法。轮盘的大小等于*size * (size +1) / 2*，其中*size*是当前种群的大小。最差的染色体其扇区大小等于1，下一个大小为2，以此类推。
- en: 'The Roulette selection:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 轮盘赌选择：
- en: '![](img/9f9e0630-f82a-4842-a908-bf94bb5fbcb1.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9f9e0630-f82a-4842-a908-bf94bb5fbcb1.png)'
- en: This algorithm selects chromosomes of the new generation according to their
    fitness values. The higher the value, the greater the chances of it becoming a
    member of the new generation.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法根据它们的适应度值选择新一代的染色体。值越高，成为新一代成员的机会就越大。
- en: What you will notice as you generate your routes is that the Elite method finds
    its solution right away. The Rank method continues refining its route throughout
    the iterations, and the Roulette method refines its routes even more.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当你生成你的路线时，你会注意到精英方法立即找到了它的解决方案。排名方法在整个迭代过程中持续优化其路线，而轮盘赌方法则进一步优化其路线。
- en: To illustrate what I mean, define a huge load for your salesman today. Let's
    say he has 200 houses to visit, as we need to sell a lot of encyclopedias today.
    This is where the beauty of our algorithm shines. It's easy to create the optimal
    map and route if we are dealing with five houses. But if we are dealing with 200
    houses, not so much!
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明我的意思，定义一个巨大的销售员今天的负载。比如说他今天要访问200座房子，因为我们需要今天卖很多百科全书。这就是我们算法之美的所在。如果我们处理的是五座房子，很容易创建最优的地图和路线。但如果我们处理的是200座房子，那就大不相同了！
- en: '![](img/67bf4408-40f4-424e-824c-84f4a98aca18.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/67bf4408-40f4-424e-824c-84f4a98aca18.png)'
- en: Now that we've solved our problem, let's see if we can apply what we learned
    from our earlier chapter about **self-organizing maps** (**SOM**) here to approach
    this problem from a different angle. If you recall, back in [Chapter 6](01438011-1511-48a3-af59-1d6451a3128e.xhtml),
    *Color Blending – Self-Organizing Maps and Elastic Neural Networks*, we discussed
    SOM in general. So we'll preclude the academia from happening here! We're going
    to use a technique called Elastic Network Training, which is a great unsupervised
    approach to such a problem as we have here.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经解决了这个问题，让我们看看我们能否将我们从之前章节中学到的关于**自组织映射**（**SOM**）的知识应用到这个问题上，从不同的角度来解决这个问题。如果你还记得，在[第6章](01438011-1511-48a3-af59-1d6451a3128e.xhtml)，“颜色混合
    - 自组织映射和弹性神经网络”中，我们讨论了SOM的一般情况。所以我们将避免在这里发生学术讨论！我们将使用一种称为弹性网络训练的技术，这是一种针对我们这里的问题的非常好的无监督方法。
- en: '![](img/d7c46099-1bea-474c-ba05-f411d6e93957.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d7c46099-1bea-474c-ba05-f411d6e93957.png)'
- en: Let's first talk briefly about what an **Elastic Map** is. Elastic Maps provide
    a tool for creating nonlinear dimensionality reduction. They are a system of elastic
    springs in our data space that approximate a low-dimensional manifold. With this
    capability, we can go from completely unstructured clustering (no elasticity)
    to a closer linear principal components analysis manifold for high bending/low
    stretching of the springs. You'll see when using our sample application that the
    lines are not necessarily as rigid as they were in our previous solution. And
    in many cases, they may not even get into the center of the city we are visiting
    (the line generates off the center) but approach only the outskirts of the city
    limits, as in the preceding example!
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先简要地谈谈什么是**弹性地图**。弹性地图提供了一种创建非线性降维的工具。它们是我们数据空间中弹性弹簧的系统，近似于低维流形。有了这种能力，我们可以从完全无结构的聚类（无弹性）到更接近线性主成分分析流形，弹簧有高弯曲/低拉伸。当你使用我们的示例应用程序时，你会发现线条并不一定像我们之前的解决方案那样僵硬。在许多情况下，它们甚至可能不会进入我们访问的城市中心（线条从中心生成）但仅接近城市边缘，就像前面的例子一样！
- en: Once again, we'll be dealing with neurons, one of my favorite objects of all.
    This time we'll have a bit more control though, by being able to specify our learning
    rate and radius. As with our previous example, we'll be able to specify the total
    number of cities our salesman must visit today. Let's go easier on him this time
    though!
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，我们将处理神经元，这是我所有最爱之一。这次我们将有更多的控制权，因为我们能够指定我们的学习率和半径。就像我们之前的例子一样，我们将能够指定我们的旅行商今天必须访问的总城市数。不过这次我们对他宽容一些吧！
- en: 'To start, we''ll visit 50 cities and use a learning rate of `0.3` and radius
    of `0.75`. Finally, we will run for 50,000 iterations (don''t worry; this will
    go fast). Our output will look like this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将访问50个城市，并使用学习率`0.3`和半径`0.75`。最后，我们将运行50,000次迭代（别担心；这会很快完成）。我们的输出将看起来像这样：
- en: '![](img/41121417-820a-4800-87e1-686bd0f6d353.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/41121417-820a-4800-87e1-686bd0f6d353.png)'
- en: 'Now, what happens if we change our radius to a different value, say, 0.25?
    Note how our angles between some cities become more pronounced:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们把半径改为不同的值，比如0.25，会发生什么呢？注意一些城市之间的角度变得更为明显：
- en: '![](img/0b891719-fb9b-43b8-8b1d-fbe52275dafe.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0b891719-fb9b-43b8-8b1d-fbe52275dafe.png)'
- en: 'Next, let''s change our learning rate from 0.3 to 0.75:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们将学习率从0.3改为0.75：
- en: '![](img/35e19e73-4025-40fc-8e21-82c8d0c333af.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/35e19e73-4025-40fc-8e21-82c8d0c333af.png)'
- en: 'Even though our route looks very similar in the end, there is one important
    difference. In the previous example, the route path for our salesman was not drawn
    until all the iterations were complete. By raising the learning rate, the route
    gets drawn several times before the perfect route is complete. Here are some images
    showing the progression:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们的路线最终看起来非常相似，但有一个重要的区别。在上一个例子中，我们的旅行商的路线图是在所有迭代完成后才绘制的。通过提高学习率，路线图会在完美的路线完成之前绘制几次。以下是一些显示进度的图片：
- en: '![](img/785cc6e2-d233-47ce-9176-2a1edf306085.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/785cc6e2-d233-47ce-9176-2a1edf306085.png)'
- en: 'Here we are at iteration 5777 of our solution:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在处于我们的解决方案的第5777次迭代：
- en: '![](img/08874e3a-19a4-4bdc-b944-43b3bfc5abc9.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](img/08874e3a-19a4-4bdc-b944-43b3bfc5abc9.png)'
- en: 'This shows how our solution looks at iteration 44636:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了我们的解决方案在第44636次迭代时的样子。
- en: '![](img/09a4e84c-51e5-479f-b3dc-7289dd36ce4f.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/09a4e84c-51e5-479f-b3dc-7289dd36ce4f.png)'
- en: 'This one shows how our solution looks at iteration 34299:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这一张显示了我们的解决方案在第34299次迭代时的样子：
- en: '![](img/7dc9b79e-c1b5-48a1-b58f-3b9da4438abb.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7dc9b79e-c1b5-48a1-b58f-3b9da4438abb.png)'
- en: 'Now, let''s look into a small bit of code to see how our search solution differs
    this time:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看一小段代码，看看我们的搜索解决方案这次有何不同：
- en: '[PRE8]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The first thing you see that we've done is creating a `DistanceNetwork` object.
    This object contains only a single `DistanceLayer`, which is a single layer of
    distance neurons. A distance neuron computes its output as the distance between
    its weights and inputs—the sum of absolute differences between the weight values
    and input values. All of this together makes up our SOM and, more importantly,
    our Elastic Network.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 您首先看到我们做的事情是创建一个`DistanceNetwork`对象。这个对象只包含一个`DistanceLayer`，即一个距离神经元层。距离神经元通过计算其权重和输入之间的距离来输出其输出——权重值和输入值之间绝对差异的总和。所有这些共同构成了我们的SOM（自组织映射）和，更重要的是，我们的弹性网络。
- en: Next, we have to initialize our network with some random weights. We will do
    this by creating a **uniform continuous distribution** for each neuron. A uniform
    continuous distribution, or rectangular distribution, is a symmetric probability
    distribution such that, for each member of the family, all intervals of the same
    length on the distribution's support have the same probability. You will usually
    see this written out as U(*a*, *b*), with parameters *a* and *b* being the minimum
    and maximum values respectively.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须用一些随机权重初始化我们的网络。我们将通过为每个神经元创建**均匀连续分布**来完成此操作。均匀连续分布，或矩形分布，是一种对称的概率分布，对于该家族的每个成员，分布支持上相同长度的所有区间都有相同的概率。您通常会看到它写成U(*a*,
    *b*)，其中参数*a*和*b*分别是最小值和最大值。
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, we create our elastic learner object, which allows us to train our distance
    network:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建我们的弹性学习器对象，它允许我们训练我们的距离网络：
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here''s what the `ElasticNetworkLearning` constructor looks like internally:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`ElasticNetworkLearning`构造函数的内部样子：
- en: '![](img/945ba172-7ba3-4692-8100-e0f4148b24b7.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/945ba172-7ba3-4692-8100-e0f4148b24b7.png)'
- en: 'Now we calculate our learning rate and radius:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们计算我们的学习率和半径：
- en: '[PRE12]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Finally, we are in our central processing loop, where we will remain until
    told to stop:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们进入了我们的中央处理循环，我们将一直保持在这里，直到被告知停止：
- en: '[PRE13]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the preceding loop, the trainer is running one epoch (iteration) per loop
    increment. Here''s what the `trainer.Run` function looks like, so you can see
    what''s happening. Basically, the method finds the winning neuron (the one that
    has the weights with values closest to the specified input vector). It then updates
    its weights as well as the weights of the neighboring neurons:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的循环中，训练器在每个循环增量中运行一个epoch（迭代）。以下是`trainer.Run`函数的样子，这样您可以看到发生了什么。基本上，该方法找到获胜神经元（其权重值最接近指定输入向量的神经元）。然后它更新其权重以及邻近神经元的权重：
- en: '[PRE14]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The two main functions of this method that we will look deeper into are computing
    the network and obtaining the winner (highlighted items).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要深入了解的这种方法的主要两个功能是计算网络和获取获胜者（高亮显示的项目）。
- en: 'How do we compute the network? Basically, we work ourselves down through the
    distance layer and into each neuron in order to update the weights correctly,
    similar to what you see here:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何计算网络？基本上，我们通过距离层逐层向下工作，进入每个神经元，以正确更新权重，类似于您在这里看到的情况：
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, we need to compute the winner, the neuron with the minimum weight
    and therefore the minimum distance:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要计算获胜者，即权重最小、距离最小的神经元：
- en: '[PRE16]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Let's talk briefly about the parameters you can enter on the screen.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要谈谈您可以在屏幕上输入的参数。
- en: Learning rate parameter
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习率参数
- en: The learning rate is a parameter that determines the speed of learning. More
    formally, it determines how much we are adjusting the weights of our network with
    respect to the loss gradient. If it is too low, we travel slower down our slope.
    Even though we desire to have a low learning rate, it could mean that we'll be
    taking a long time to reach convergence. The learning rate also affects how quickly
    our model can converge tolocal minima (best accuracy).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 学习率是一个决定学习速度的参数。更正式地说，它决定了我们根据损失梯度调整网络权重的程度。如果它太低，我们在斜坡上移动的速度会变慢。尽管我们希望学习率低，但这可能意味着我们将花费很长时间才能达到收敛。学习率还会影响我们的模型多快能收敛到局部最小值（最佳精度）。
- en: When dealing with neurons, it determines the acquisition time (the amount of
    time it takes for a response to a new experience to be learned) for neurons with
    weights being used for training.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理神经元时，它决定了用于训练的权重神经元的获取时间（学习新经验所需的时间）。
- en: '![](img/0dd70be0-c08f-44a6-8af2-60d03935a5d8.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0dd70be0-c08f-44a6-8af2-60d03935a5d8.png)'
- en: 'Effect of various learning rates on convergence (image credit: [cs231n](http://cs231n.github.io/neural-networks-3/))'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 各种学习率对收敛的影响（图片来源：[cs231n](http://cs231n.github.io/neural-networks-3/))
- en: Learning radius
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习半径
- en: The learning radius determines the number of neurons to be updated around the
    winning neuron. Any neuron that is in the circle of the radius will be updated
    during the learning process. The closer the neuron, the more updates that are
    happening. The farther away, the fewer.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 学习半径决定了围绕获胜神经元需要更新的神经元数量。在学习过程中，任何位于半径圆内的神经元都将被更新。神经元越靠近，更新的次数越多；距离越远，更新的次数越少。
- en: Summary
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we learned about neurons, which is an incredibly fascinating
    branch of research, focused on heavily for several years. We also learned about
    the famous traveling salesman problem, what it is, and how we can solve it with
    a computer. This little example has wide-reaching applications in the real world.
    In our next chapter, we are going to put all this neural knowledge we have gained
    and apply it to **Restricted Boltzmann Machines** (**RBM**) with a **Deep Belief
    Network** (**DBN**). This chapter will be sure to add a lot of terminology to
    your buzzword-compliant checklist! In the next chapter, we will answer the question
    that we all, as developers, face: *Should I take the job?*'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了神经元，这是一个非常迷人的研究领域，多年来一直备受关注。我们还学习了著名的旅行商问题，它是什么，以及我们如何用计算机来解决它。这个小小的例子在现实世界中有着广泛的应用。在我们下一章中，我们将把我们所获得的所有神经知识应用到**受限玻尔兹曼机**（**RBM**）和**深度信念网络**（**DBN**）上。这一章肯定会为你的术语清单增添许多术语！在下一章中，我们将回答我们作为开发者都面临的问题：*我应该接受这份工作吗？*
