<html><head></head><body>
<div id="_idContainer095" class="calibre2">
<h1 class="chapter-number" id="_idParaDest-112"><a id="_idTextAnchor120" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.1.1">6</span></h1>
<h1 id="_idParaDest-113" class="calibre5"><a id="_idTextAnchor121" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.2.1">Federated Learning and Implementing FL Using Open Source Frameworks</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.3.1">In this chapter, you will learn about </span><strong class="bold"><span class="kobospan" id="kobo.4.1">Federated Learning</span></strong><span class="kobospan" id="kobo.5.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.6.1">FL</span></strong><span class="kobospan" id="kobo.7.1">) and how to implement it using open source frameworks. </span><span class="kobospan" id="kobo.7.2">We will cover why it is needed and how to preserve data privacy. </span><span class="kobospan" id="kobo.7.3">We will also look at the definition of FL, as well as its characteristics and the steps involved </span><span><span class="kobospan" id="kobo.8.1">in it.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.9.1">We will cover the following </span><span><span class="kobospan" id="kobo.10.1">main topics:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span><span class="kobospan" id="kobo.11.1">FL</span></span></li>
<li class="calibre11"><span><span class="kobospan" id="kobo.12.1">FL algorithms</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.13.1">The steps involved in </span><span><span class="kobospan" id="kobo.14.1">implementing FL</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.15.1">Open source frameworks for </span><span><span class="kobospan" id="kobo.16.1">implementing FL</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.17.1">An end-to-end use case of implementing fraud detection </span><span><span class="kobospan" id="kobo.18.1">using FL</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.19.1">FL with </span><span><span class="kobospan" id="kobo.20.1">differential privacy</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.21.1">By exploring these topics, you will gain a comprehensive understanding of the need for FL and the open source frameworks for </span><span><span class="kobospan" id="kobo.22.1">implementing FL.</span></span></p>
<h1 id="_idParaDest-114" class="calibre5"><a id="_idTextAnchor122" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.23.1">Federated learning</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.24.1">FL has emerged as a solution to address the challenges of traditional centralized </span><strong class="bold"><span class="kobospan" id="kobo.25.1">Machine Learning</span></strong><span class="kobospan" id="kobo.26.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.27.1">ML</span></strong><span class="kobospan" id="kobo.28.1">) approaches in scenarios where data privacy and data locality are of </span><span><span class="kobospan" id="kobo.29.1">paramount importance.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.30.1">The key reasons that we need FL are </span><span><span class="kobospan" id="kobo.31.1">as follows:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.32.1">Preserving data privacy</span></strong><span class="kobospan" id="kobo.33.1">: In many situations, data is sensitive and cannot be shared due to legal, ethical, or privacy concerns. </span><span class="kobospan" id="kobo.33.2">FL enables you to train models directly on distributed data sources without sharing the raw data, ensuring privacy protection. </span><span class="kobospan" id="kobo.33.3">By keeping data local and performing model updates locally, FL minimizes the risk of exposing </span><span><span class="kobospan" id="kobo.34.1">sensitive information.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.35.1">Data localization and regulatory compliance</span></strong><span class="kobospan" id="kobo.36.1">: FL allows organizations to comply with data localization requirements and regulations. </span><span class="kobospan" id="kobo.36.2">Instead of transferring data to a central server, data remains within the jurisdiction where it is generated or collected, addressing concerns related to cross-border </span><span><span class="kobospan" id="kobo.37.1">data transfers.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.38.1">Scalability and efficiency</span></strong><span class="kobospan" id="kobo.39.1">: Centralized machine learning approaches often face challenges when dealing with large volumes of data, as aggregating and processing data from various sources can be time-consuming and resource-intensive. </span><span class="kobospan" id="kobo.39.2">FL distributes the training process, allowing data to remain decentralized while benefiting from the collective intelligence of all participating devices or data sources. </span><span class="kobospan" id="kobo.39.3">This decentralized approach improves scalability and </span><span><span class="kobospan" id="kobo.40.1">computational efficiency.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.41.1">Access to diverse data</span></strong><span class="kobospan" id="kobo.42.1">: FL facilitates the pooling of data from multiple sources, enabling models to learn from diverse datasets without the need for direct data sharing. </span><span class="kobospan" id="kobo.42.2">This is particularly beneficial in scenarios where data sources have distinct characteristics, such as different demographics, geographical regions, or user preferences. </span><span class="kobospan" id="kobo.42.3">Access to a diverse range of data enhances the generalization and robustness of </span><span><span class="kobospan" id="kobo.43.1">ML models.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.44.1">Enhanced security and resilience</span></strong><span class="kobospan" id="kobo.45.1">: With FL, the data remains distributed across devices or edge nodes, reducing the risk of a single point of failure or vulnerability. </span><span class="kobospan" id="kobo.45.2">This distributed nature enhances the security and resilience of the overall system, making it less susceptible to attacks </span><span><span class="kobospan" id="kobo.46.1">or breaches.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.47.1">User empowerment and inclusion</span></strong><span class="kobospan" id="kobo.48.1">: FL offers opportunities for user participation and control over their data. </span><span class="kobospan" id="kobo.48.2">Instead of relinquishing data ownership and control to a centralized authority, users can actively contribute to the learning process while retaining control over their personal information. </span><span class="kobospan" id="kobo.48.3">This empowers individuals and promotes a sense of inclusion </span><span><span class="kobospan" id="kobo.49.1">and transparency.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.50.1">The need for FL arises from the critical requirements of preserving data privacy, complying with regulatory frameworks, achieving scalability and efficiency, accessing diverse data sources, ensuring security, and </span><span><span class="kobospan" id="kobo.51.1">empowering users.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.52.1">By leveraging FL, organizations can overcome the limitations of centralized approaches and unlock the potential of distributed data for training robust and privacy-preserving </span><span><span class="kobospan" id="kobo.53.1">ML models.</span></span></p>
<h2 id="_idParaDest-115" class="calibre7"><a id="_idTextAnchor123" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.54.1">Preserving privacy</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.55.1">Let’s consider the case of ARDHA Bank (a fictional bank for illustration purposes only). </span><span class="kobospan" id="kobo.55.2">ARDHA Bank is a financial institution that has been operating in the United States for several years, adhering to country-specific regulations. </span><span class="kobospan" id="kobo.55.3">The bank offers a range of services to its customers, including fraud prevention, loyalty programs, and digital payments. </span><span class="kobospan" id="kobo.55.4">Initially, ARDHA Bank employed static rule-based systems to detect and prevent fraudulent activities. </span><span class="kobospan" id="kobo.55.5">However, recognizing the need for more advanced approaches, they transitioned to utilizing ML algorithms for enhanced fraud detection </span><span><span class="kobospan" id="kobo.56.1">and prevention.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.57.1">With access to a comprehensive dataset comprising historical and current transaction data, ARDHA Bank developed ML and </span><strong class="bold"><span class="kobospan" id="kobo.58.1">Deep Learning</span></strong><span class="kobospan" id="kobo.59.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.60.1">DL</span></strong><span class="kobospan" id="kobo.61.1">) algorithms specifically tailored to their operations. </span><span class="kobospan" id="kobo.61.2">These algorithms were trained on this extensive dataset, allowing the bank to effectively identify and prevent financial fraud with exceptional accuracy. </span><span class="kobospan" id="kobo.61.3">By leveraging the power of ML and DL techniques, ARDHA Bank significantly improved its ability to detect and mitigate fraudulent digital transactions, thereby safeguarding its customers’ </span><span><span class="kobospan" id="kobo.62.1">financial interests.</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer077">
<span class="kobospan" id="kobo.63.1"><img alt="Figure 6.1 – A simple ML model in a financial bank" src="image/B16573_06_01.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.64.1">Figure 6.1 – A simple ML model in a financial bank</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.65.1">ARDHA Bank, having experienced success in the </span><strong class="bold"><span class="kobospan" id="kobo.66.1">United States</span></strong><span class="kobospan" id="kobo.67.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.68.1">US</span></strong><span class="kobospan" id="kobo.69.1">), made the strategic decision to expand its business and establish branches in two additional countries – France (for Europe) and India. </span><span class="kobospan" id="kobo.69.2">With the expansion, ARDHA Bank aimed to offer the same suite of services to its customers in both regions. </span><span class="kobospan" id="kobo.69.3">To provide digital payment services in France and India, one option considered by ARDHA Bank was to transmit periodic transaction data from both countries to their US servers. </span><span class="kobospan" id="kobo.69.4">The US servers would then serve as the central location to run the ML models. </span><span class="kobospan" id="kobo.69.5">After training the ML models on the combined data from all regions, the trained models would be deployed to the regional servers in France and India. </span><span class="kobospan" id="kobo.69.6">By adopting this approach, ARDHA Bank sought to leverage the infrastructure of its US servers to process and analyze the transaction data efficiently. </span><span class="kobospan" id="kobo.69.7">The centralized training of ML models allowed for a unified approach to fraud detection and prevention, ensuring consistency and accuracy across different regions. </span><span class="kobospan" id="kobo.69.8">This strategy enabled ARDHA Bank to provide reliable and effective digital payment services in Europe and India while maintaining data security and privacy. </span><span class="kobospan" id="kobo.69.9">By utilizing regional servers and deploying the trained ML models locally, the bank ensured swift and localized decision-making, catering to the specific needs and regulatory requirements of </span><span><span class="kobospan" id="kobo.70.1">each region.</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer078">
<span class="kobospan" id="kobo.71.1"><img alt="Figure 6.2 – A simple ML model in a financial bank in three locations" src="image/B16573_06_02.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.72.1">Figure 6.2 – A simple ML model in a financial bank in three locations</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.73.1">The proposed solution, which involves transferring data to a central server and running ML models on that data, faces challenges due to privacy regulations and data localization laws in Europe and India. </span><span class="kobospan" id="kobo.73.2">These regulations, such as the </span><strong class="bold"><span class="kobospan" id="kobo.74.1">General Data Protection Regulation</span></strong><span class="kobospan" id="kobo.75.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.76.1">GDPR</span></strong><span class="kobospan" id="kobo.77.1">) in Europe and India’s data localization requirements, stipulate that data generated within these countries must be stored within local data centers. </span><span class="kobospan" id="kobo.77.2">Data must remain within the borders of the country where it </span><span><span class="kobospan" id="kobo.78.1">was created.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.79.1">Given these privacy and localization constraints, an alternative approach is necessary. </span><span class="kobospan" id="kobo.79.2">One possible alternative is to run ML models locally at each branch or location of the bank. </span><span class="kobospan" id="kobo.79.3">This approach entails deploying client models that utilize the local data available at each location. </span><span class="kobospan" id="kobo.79.4">The local models would process the data within the boundaries of the respective country, ensuring compliance with privacy regulations. </span><span class="kobospan" id="kobo.79.5">To implement this alternative, only the model weights and parameters, not the transaction data used by customers, would be shared with a central server. </span><span class="kobospan" id="kobo.79.6">The central server, hosted in any country, would be responsible for running a global model using the aggregated model weights and parameters from each location. </span><span class="kobospan" id="kobo.79.7">The resulting global model could then be regularly distributed back to the local clients in each country. </span><span class="kobospan" id="kobo.79.8">This approach enables the bank to leverage the benefits of ML models while adhering to privacy regulations and data localization laws. </span><span class="kobospan" id="kobo.79.9">By conducting ML computations locally and sharing only model-related information, the bank ensures compliance, data security, and privacy. </span><span class="kobospan" id="kobo.79.10">Additionally, this distributed approach allows for local adaptation and customization while still benefiting from the insights gained through the </span><span><span class="kobospan" id="kobo.80.1">global model.</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer079">
<span class="kobospan" id="kobo.81.1"><img alt="Figure 6.3 – Local model interactions with the global model" src="image/B16573_06_03.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.82.1">Figure 6.3 – Local model interactions with the global model</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.83.1">This approach is known as </span><strong class="bold"><span class="kobospan" id="kobo.84.1">Federated Machine Learning</span></strong><span class="kobospan" id="kobo.85.1">, or FL. </span><span class="kobospan" id="kobo.85.2">In FL, the traditional paradigm of moving data to a central location is reversed. </span><span class="kobospan" id="kobo.85.3">Instead, the model and computation are brought to </span><span><span class="kobospan" id="kobo.86.1">the data.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.87.1">In FL, the ML model is deployed and executed directly on the local data sources or devices where the data resides. </span><span class="kobospan" id="kobo.87.2">This eliminates the need to transfer raw data to a central server, addressing privacy concerns and regulatory requirements. </span><span class="kobospan" id="kobo.87.3">The model is trained locally using the data on each device, and only the model updates, such as gradients or weights, are securely transmitted to a </span><span><span class="kobospan" id="kobo.88.1">central aggregator.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.89.1">By keeping the data decentralized and performing computations locally, FL ensures data privacy and reduces the risks associated with data transfer. </span><span class="kobospan" id="kobo.89.2">It allows organizations to leverage the collective knowledge and insights from distributed data sources without compromising individual data privacy. </span><span class="kobospan" id="kobo.89.3">This approach is particularly beneficial in scenarios where data cannot be easily shared due to legal, regulatory, or </span><span><span class="kobospan" id="kobo.90.1">privacy constraints.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.91.1">FL represents a paradigm shift in ML, enabling collaborative and privacy-preserving model training. </span><span class="kobospan" id="kobo.91.2">It promotes a distributed approach where data remains under the control of the data owners while contributing to a shared model. </span><span class="kobospan" id="kobo.91.3">This decentralized and privacy-conscious framework opens up possibilities to harness the power of large-scale data without sacrificing privacy </span><span><span class="kobospan" id="kobo.92.1">and security.</span></span></p>
<h2 id="_idParaDest-116" class="calibre7"><a id="_idTextAnchor124" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.93.1">FL definition</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.94.1">The following is the formal definition of FL proposed as per the </span><em class="italic"><span class="kobospan" id="kobo.95.1">Advances and Open Problems in Federated Learning</span></em><span class="kobospan" id="kobo.96.1"> paper published </span><span><span class="kobospan" id="kobo.97.1">at </span></span><span><span class="kobospan" id="kobo.98.1">arxiv/1912.04977</span></span><span><span class="kobospan" id="kobo.99.1">:</span></span></p>
<p class="author-quote"><span class="kobospan" id="kobo.100.1">“Federated learning is a machine learning setting where multiple entities (clients) collaborate in solving a machine learning problem, under the coordination of a central server or service provider. </span><span class="kobospan" id="kobo.100.2">Each client’s raw data is stored locally and not exchanged or transferred; instead, focused updates intended for immediate aggregation are used to achieve the learning objective”</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.101.1">As per this definition, these are the characteristics </span><span><span class="kobospan" id="kobo.102.1">of FL:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.103.1">Multiple clients (entities) collaborate to solve an </span><span><span class="kobospan" id="kobo.104.1">ML problem.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.105.1">A service provider or central server coordinates with </span><span><span class="kobospan" id="kobo.106.1">these entities.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.107.1">Raw data (data with samples) is stored locally at each client location and is not transferred to </span><span><span class="kobospan" id="kobo.108.1">the servers.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.109.1">The learning objective (or loss function) is defined. </span><span class="kobospan" id="kobo.109.2">To minimize the loss (predictions versus actual), focused updates (weights and biases) are sent to the server from clients, the aggregation of weights (either average or dynamic aggregation) is done at the server, and these updates are sent back </span><span><span class="kobospan" id="kobo.110.1">to clients.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.111.1">Let’s delve further into each one of these in detail to understand </span><span><span class="kobospan" id="kobo.112.1">them better.</span></span></p>
<h2 id="_idParaDest-117" class="calibre7"><a id="_idTextAnchor125" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.113.1">Characteristics of FL</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.114.1">The following subsections will cover the characteristics of FL </span><span><span class="kobospan" id="kobo.115.1">in depth.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.116.1">Multiple clients (entities) collaborate to solve an ML problem</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.117.1">In FL, the participation requirement typically involves a minimum of two clients, while the maximum number of clients can vary based on the specific use cases and </span><span><span class="kobospan" id="kobo.118.1">client types.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.119.1">Clients participating in FL can be broadly classified into two categories – cross-device </span><span><span class="kobospan" id="kobo.120.1">and cross-silo:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.121.1">Cross-device</span></strong><span class="kobospan" id="kobo.122.1"> clients are individual devices, such as smartphones, laptops, or IoT devices, that contribute their local data for model training. </span><span class="kobospan" id="kobo.122.2">These devices act as clients in the FL framework, allowing their data to be utilized while </span><span><span class="kobospan" id="kobo.123.1">preserving privacy.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.124.1">Cross-silo</span></strong><span class="kobospan" id="kobo.125.1"> clients, on the other hand, represent data sources that are distributed across different organizational silos or entities. </span><span class="kobospan" id="kobo.125.2">These silos can be different departments within an organization, separate institutions, or even distinct geographical regions. </span><span class="kobospan" id="kobo.125.3">Each silo acts as a client, contributing its local data for collaborative </span><span><span class="kobospan" id="kobo.126.1">model training.</span></span></li>
</ul>
<div class="calibre2">
<div class="img---figure" id="_idContainer080">
<span class="kobospan" id="kobo.127.1"><img alt="Figure 6.4 – A classification of FL clients" src="image/B16573_06_04.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.128.1">Figure 6.4 – A classification of FL clients</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.129.1">The maximum number of clients in an FL setup depends on the specific use cases and the scale of the distributed data sources. </span><span class="kobospan" id="kobo.129.2">For instance, in scenarios where multiple organizations collaborate to build a global model while maintaining data privacy, the number of participating clients can be substantial. </span><span class="kobospan" id="kobo.129.3">On the other hand, in more focused or localized use cases, the number of clients may be limited to a </span><span><span class="kobospan" id="kobo.130.1">smaller group.</span></span></p>
<h4 class="calibre17"><span class="kobospan" id="kobo.131.1">Cross-silo FL clients</span></h4>
<p class="calibre3"><span class="kobospan" id="kobo.132.1">Cross-silo clients are entities such as financial banks, institutions, hospitals, and pharmacy companies. </span><span class="kobospan" id="kobo.132.2">These clients can be further categorized into </span><span><span class="kobospan" id="kobo.133.1">two groups:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.134.1">Different clients within the same institution</span></strong><span class="kobospan" id="kobo.135.1">: This includes different branches of the same bank, different branches within a hospital network, and similar setups where multiple branches or divisions of a single institution participate </span><span><span class="kobospan" id="kobo.136.1">in FL.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.137.1">Different clients across different institutions</span></strong><span class="kobospan" id="kobo.138.1">: This involves different organizations, such as different banks or hospitals, collaborating and contributing their data to the FL process. </span><span class="kobospan" id="kobo.138.2">These clients represent </span><span><span class="kobospan" id="kobo.139.1">inter-institutional collaborations.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.140.1">The maximum number of clients in the cross-silo category can vary based on the specific use case, but typically, it ranges from tens to hundreds. </span><span class="kobospan" id="kobo.140.2">The number of participating clients is usually limited due to the nature of collaborations and the scale of the </span><span><span class="kobospan" id="kobo.141.1">institutions involved.</span></span></p>
<h4 class="calibre17"><span class="kobospan" id="kobo.142.1">Cross-device FL clients</span></h4>
<p class="calibre3"><span class="kobospan" id="kobo.143.1">Cross-device clients, on the other hand, encompass various devices that participate as clients or nodes in FL. </span><span class="kobospan" id="kobo.143.2">These devices can be either homogenous or heterogenous, and examples include devices such as Apple iPhones, Google phones, and the </span><span><span class="kobospan" id="kobo.144.1">Brave browser.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.145.1">In the case of cross-device FL clients, each device runs its own ML model based on the local data available on that specific device. </span><span class="kobospan" id="kobo.145.2">Only the model weights and biases are transmitted to the server based on device conditions and other </span><span><span class="kobospan" id="kobo.146.1">configuration settings.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.147.1">In this scenario, the maximum number of clients can reach thousands or even millions, as it encompasses a wide range of devices participating in FL across different locations and </span><span><span class="kobospan" id="kobo.148.1">user bases.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.149.1">By accommodating both cross-silo and cross-device clients, FL enables collaboration and knowledge sharing while respecting data privacy and ensuring scalable participation across institutions </span><span><span class="kobospan" id="kobo.150.1">and devices.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.151.1">A service provider or central server coordinates with these entities</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.152.1">The server in FL makes decisions based on the network topology of the participating clients and the total number of clients involved in the process. </span><span class="kobospan" id="kobo.152.2">The server determines when to distribute the initial model or updated models to the clients, considering factors such as the network structure and the specific number of participating clients. </span><span class="kobospan" id="kobo.152.3">It decides whether to send the model updates to all clients or only a subset of them, based on the requirements of the </span><span><span class="kobospan" id="kobo.153.1">learning task.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.154.1">After the clients receive the model, they compute and update the weights and biases based on their local data. </span><span class="kobospan" id="kobo.154.2">The clients then send these updated weights and biases back to the server. </span><span class="kobospan" id="kobo.154.3">The server aggregates the received data and performs computations using an objective function to minimize the loss or optimize the </span><span><span class="kobospan" id="kobo.155.1">learning objective.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.156.1">Based on the aggregated information, the server generates an updated model. </span><span class="kobospan" id="kobo.156.2">It decides which clients need to be updated with the new model and which clients can continue running the existing model without any changes. </span><span class="kobospan" id="kobo.156.3">This decision is based on factors such as the learning progress, the need for updates, or the compatibility of clients with the </span><span><span class="kobospan" id="kobo.157.1">updated model.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.158.1">By carefully orchestrating these steps, the server manages the distribution of models, collects client updates, aggregates data, and ultimately, sends back the updated model to the appropriate clients. </span><span class="kobospan" id="kobo.158.2">This iterative process in FL ensures collaborative model improvement while accounting for the individual requirements and capabilities of the </span><span><span class="kobospan" id="kobo.159.1">participating clients.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.160.1">Raw data (data with samples) is stored locally at each client location and is not transferred to the servers</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.161.1">In FL, raw data is stored locally at each client location instead of being centralized in a single server. </span><span class="kobospan" id="kobo.161.2">This decentralized approach ensures that the data remains under the control and ownership of the respective clients, preserving privacy and complying with </span><span><span class="kobospan" id="kobo.162.1">data regulations.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.163.1">The data at each client location exhibits a specific distribution, which can vary across different clients. </span><span class="kobospan" id="kobo.163.2">The distribution of the data refers to the statistical characteristics and patterns present within the dataset. </span><span class="kobospan" id="kobo.163.3">The data samples within a client’s dataset can be independent of each other, meaning that they are unrelated or do not rely on each other for their values or properties. </span><span class="kobospan" id="kobo.163.4">Alternatively, the data samples can be dependent, indicating that there is some form of correlation or relationship </span><span><span class="kobospan" id="kobo.164.1">between them.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.165.1">Furthermore, the data distribution can be either identical or non-identical among the clients. </span><span class="kobospan" id="kobo.165.2">Identical data distribution implies that the statistical properties of the datasets are the same across different clients. </span><span class="kobospan" id="kobo.165.3">On the other hand, non-identical data distribution suggests that the datasets exhibit variations in their statistical characteristics, such as mean, variance, or other </span><span><span class="kobospan" id="kobo.166.1">relevant parameters.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.167.1">The presence of diverse data distributions, whether independent or dependent, identical or non-identical, introduces challenges and complexities in FL. </span><span class="kobospan" id="kobo.167.2">Nevertheless, FL methods are designed to handle these variations and enable collaborative model training across decentralized data sources, leveraging the collective knowledge while respecting data privacy and </span><span><span class="kobospan" id="kobo.168.1">distribution characteristics.</span></span></p>
<h4 class="calibre17"><span class="kobospan" id="kobo.169.1">Datasets with IID and non-IID data</span></h4>
<p class="calibre3"><span class="kobospan" id="kobo.170.1">Independent and identically distributed (IID) data refers to a dataset in which the data samples are independent of each other, and the distribution of the data is identical across all samples. </span><span class="kobospan" id="kobo.170.2">In this case, the outcomes of each data sample are not dependent on previous samples, and the statistical properties of the data </span><span><span class="kobospan" id="kobo.171.1">remain consistent.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.172.1">For example, consider a dataset where a coin is tossed five times and the number of times it turns up heads is recorded. </span><span class="kobospan" id="kobo.172.2">In this scenario, each coin toss is independent of the previous tosses, and the probability of getting heads is identical for each toss. </span><span class="kobospan" id="kobo.172.3">This results in an IID dataset where the distribution of outcomes is the same for every </span><span><span class="kobospan" id="kobo.173.1">coin toss.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.174.1">In FL, the data across different clients may exhibit </span><strong class="bold"><span class="kobospan" id="kobo.175.1">non-IID</span></strong><span class="kobospan" id="kobo.176.1"> characteristics. </span><span class="kobospan" id="kobo.176.2">This means that the data samples are not identically distributed, and they may also be dependent on each other. </span><span class="kobospan" id="kobo.176.3">Various factors can contribute to non-IID data, such as variations in the amount of labeled data, differences in the features present in the samples, data drift, concept drift, or </span><span><span class="kobospan" id="kobo.177.1">imbalanced data.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.178.1">For example, in the case of cross-silo entities within a company, each client may have the same kind of features and labels for classification. </span><span class="kobospan" id="kobo.178.2">However, the number of data samples at each location may vary, resulting in imbalanced data. </span><span class="kobospan" id="kobo.178.3">Additionally, each location may not have data for all classes or may exhibit different distributions </span><span><span class="kobospan" id="kobo.179.1">of examples.</span></span></p>
<h4 class="calibre17"><span class="kobospan" id="kobo.180.1">Raw data in cross-silo entities in FL</span></h4>
<p class="calibre3"><span class="kobospan" id="kobo.181.1">When dealing with cross-silo entities in FL, the raw data exhibits certain characteristics. </span><span class="kobospan" id="kobo.181.2">Specifically, in the case of intra-company scenarios, the following can </span><span><span class="kobospan" id="kobo.182.1">be observed:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.183.1">Each client within the cross-silo entities will possess the same kind of features. </span><span class="kobospan" id="kobo.183.2">This means that the types of data attributes or variables available for analysis will be consistent across </span><span><span class="kobospan" id="kobo.184.1">all clients.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.185.1">The labels or classes used for classification tasks will also be the same among the clients. </span><span class="kobospan" id="kobo.185.2">This ensures that the target categories or outcomes for classification are consistent throughout the </span><span><span class="kobospan" id="kobo.186.1">participating entities.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.187.1">The number of data samples at each client location may vary. </span><span class="kobospan" id="kobo.187.2">This implies that the amount of available data may differ across different locations or branches within the same company. </span><span class="kobospan" id="kobo.187.3">Some clients may have more extensive datasets, while others may have </span><span><span class="kobospan" id="kobo.188.1">fewer samples.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.189.1">Not all classes or categories may be represented in each client’s data. </span><span class="kobospan" id="kobo.189.2">This results in imbalanced data, where certain classes may be overrepresented or underrepresented compared to others. </span><span class="kobospan" id="kobo.189.3">Such imbalances can pose challenges for model training </span><span><span class="kobospan" id="kobo.190.1">and evaluation.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.191.1">The distribution of examples may not be the same across all clients. </span><span class="kobospan" id="kobo.191.2">This means that the statistical characteristics, such as the mean, variance, or other properties, may vary between different client locations. </span><span class="kobospan" id="kobo.191.3">Each client’s data may exhibit unique distributional patterns, which need to be accounted for during the </span><span><span class="kobospan" id="kobo.192.1">FL process.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.193.1">Considering these characteristics, FL techniques must address the variability in data samples, imbalanced class distributions, and divergent data distributions across the </span><span><span class="kobospan" id="kobo.194.1">cross-silo entities.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.195.1">In the context of the banking example we discussed, since it is the same bank operating in different countries, the features (such as customer ID, amount, transaction date, source account, destination account, and address) and labels (</span><em class="italic"><span class="kobospan" id="kobo.196.1">fraud</span></em><span class="kobospan" id="kobo.197.1"> or </span><em class="italic"><span class="kobospan" id="kobo.198.1">non-fraud</span></em><span class="kobospan" id="kobo.199.1">) will be the same. </span><span class="kobospan" id="kobo.199.2">However, the distribution of data samples and labels may vary at each location, based on factors such as the number of customers and the types of transactions. </span><span class="kobospan" id="kobo.199.3">This introduces non-IID characteristics to the data, requiring careful handling in </span><span><span class="kobospan" id="kobo.200.1">FL approaches.</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer081">
<span class="kobospan" id="kobo.201.1"><img alt="Figure 6.5 – The ML model in a financial bank in three locations" src="image/B16573_06_05.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.202.1">Figure 6.5 – The ML model in a financial bank in three locations</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.203.1">Data is distributed in the following way to each client. </span><span class="kobospan" id="kobo.203.2">There is skewness in the label data but samples with all features exist in </span><span><span class="kobospan" id="kobo.204.1">each location/client/entity.</span></span></p>
<table class="no-table-style" id="table001-6">
<colgroup class="calibre12">
<col class="calibre13"/>
<col class="calibre13"/>
<col class="calibre13"/>
<col class="calibre13"/>
<col class="calibre13"/>
<col class="calibre13"/>
</colgroup>
<tbody class="calibre14">
<tr class="no-table-style1">
<td class="no-table-style2" rowspan="2">
<p class="calibre3"><span class="kobospan" id="kobo.205.1">Data at </span><span><span class="kobospan" id="kobo.206.1">different clients</span></span></p>
</td>
<td class="no-table-style2" colspan="4">
<p class="calibre3"><span><span class="kobospan" id="kobo.207.1">Features</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.208.1">X={ X1, X2, </span><span><span class="kobospan" id="kobo.209.1">X3, …Xn}</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.210.1">Label</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.211.1">y = { y1, </span><span><span class="kobospan" id="kobo.212.1">y2…, ym}</span></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.213.1">X1</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.214.1">X2</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.215.1">X3</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.216.1">X4</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.217.1">Fraud data </span><span><span class="kobospan" id="kobo.218.1">label counts</span></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.219.1">Europe</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.220.1">(</span><span><span class="kobospan" id="kobo.221.1">Client 1)</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.222.1">yes</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.223.1">yes</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.224.1">yes</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.225.1">yes</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.226.1">Fraud count = N, Non-fraud = 0</span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.227.1">US</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.228.1">(</span><span><span class="kobospan" id="kobo.229.1">Client 2</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.230.1">yes</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.231.1">yes</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.232.1">yes</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.233.1">yes</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.234.1">Fraud count = 0, Non-fraud = N</span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.235.1">India</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.236.1">(</span><span><span class="kobospan" id="kobo.237.1">Client 3)</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.238.1">yes</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.239.1">yes</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.240.1">yes</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.241.1">yes</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.242.1">Fraud count = N/2, Non-fraud = </span><span><span class="kobospan" id="kobo.243.1">N/4</span></span></p>
</td>
</tr>
</tbody>
</table>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.244.1">Table 6.1 – Label data skewness</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.245.1">In the case of intra-institutions, where different institutions within the same industry participate in FL to offer similar ML services, the data may exhibit the </span><span><span class="kobospan" id="kobo.246.1">following characteristics:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.247.1">Each client, representing a different institution, may or may not have the same kind of features. </span><span class="kobospan" id="kobo.247.2">This means that the available data attributes or variables may differ between institutions, based on their specific contexts or data </span><span><span class="kobospan" id="kobo.248.1">collection practices.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.249.1">The number of data samples at each client location may vary. </span><span class="kobospan" id="kobo.249.2">This indicates that the amount of data available for analysis could differ between different institutions. </span><span class="kobospan" id="kobo.249.3">Some institutions may have larger datasets, while others may have relatively </span><span><span class="kobospan" id="kobo.250.1">smaller ones.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.251.1">Not all classes or categories may be present in each client’s data. </span><span class="kobospan" id="kobo.251.2">This can result in imbalanced data, where certain classes may be underrepresented or missing altogether in some institutions’ datasets. </span><span class="kobospan" id="kobo.251.3">Handling imbalanced data is an important consideration in the </span><span><span class="kobospan" id="kobo.252.1">FL process.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.253.1">The distribution of examples may also differ among the participating institutions. </span><span class="kobospan" id="kobo.253.2">Each institution’s data may have its own unique distributional patterns, including variations in mean, variance, or other statistical properties. </span><span class="kobospan" id="kobo.253.3">These differences need to be taken into account during the collaborative model </span><span><span class="kobospan" id="kobo.254.1">training process.</span></span><div class="img---figure" id="_idContainer082"><span class="kobospan" id="kobo.255.1"><img alt="Figure 6.6 – FL client and server communication (send and receive) model parameters" src="image/B16573_06_06.jpg" class="calibre4"/></span></div></li>
</ul>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.256.1">Figure 6.6 – FL client and server communication (send and receive) model parameters</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.257.1">Data is distributed in the following </span><a id="_idIndexMarker519" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.258.1">way to each client. </span><span class="kobospan" id="kobo.258.2">In this scenario, there is skewness in features and </span><span><span class="kobospan" id="kobo.259.1">label data.</span></span></p>
<table class="no-table-style" id="table002-5">
<colgroup class="calibre12">
<col class="calibre13"/>
<col class="calibre13"/>
<col class="calibre13"/>
<col class="calibre13"/>
<col class="calibre13"/>
<col class="calibre13"/>
</colgroup>
<thead class="calibre18">
<tr class="no-table-style1">
<td class="no-table-style2" rowspan="2">
<p class="calibre3"><span class="kobospan" id="kobo.260.1">Data at </span><span><span class="kobospan" id="kobo.261.1">different clients</span></span></p>
</td>
<td class="no-table-style2" colspan="4">
<p class="calibre3"><span><span class="kobospan" id="kobo.262.1">Features</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.263.1">X={ X1, X2, </span><span><span class="kobospan" id="kobo.264.1">X3, …Xn}</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.265.1">Label</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.266.1">y = { y1, </span><span><span class="kobospan" id="kobo.267.1">y2…, yn}</span></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.268.1">X1</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.269.1">X2</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.270.1">X3</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.271.1">X4</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.272.1">Fraud data </span><span><span class="kobospan" id="kobo.273.1">label counts</span></span></p>
</td>
</tr>
</thead>
<tbody class="calibre14">
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.274.1">Client 1</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.275.1">yes</span></span></p>
</td>
<td class="no-table-style2"/>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.276.1">yes</span></span></p>
</td>
<td class="no-table-style2"/>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.277.1">No (</span><span><span class="kobospan" id="kobo.278.1">Non-Fraud)= 70%</span></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.279.1">Client 2</span></span></p>
</td>
<td class="no-table-style2"/>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.280.1">yes</span></span></p>
</td>
<td class="no-table-style2"/>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.281.1">yes</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.282.1">Yes (</span><span><span class="kobospan" id="kobo.283.1">Fraud)= 100%</span></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.284.1">Client 3</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.285.1">yes</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.286.1">yes</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.287.1">yes</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.288.1">yes</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.289.1">Yes (Fraud) = 50%, </span><span><span class="kobospan" id="kobo.290.1">No (Non-Fraud)=50%</span></span></p>
</td>
</tr>
</tbody>
</table>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.291.1">Table 6.2 – Feature and label data skewness at different clients</span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.292.1">Learning objective</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.293.1">In FL, the central server takes on the responsibility of executing the learning objective and minimizing the loss function. </span><span class="kobospan" id="kobo.293.2">It achieves this by leveraging the model weights (</span><em class="italic"><span class="kobospan" id="kobo.294.1">Wt</span></em><span class="kobospan" id="kobo.295.1">) and biases received from the participating clients. </span><span class="kobospan" id="kobo.295.2">The server determines the number of rounds of data it needs from</span><a id="_idIndexMarker520" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.296.1"> the clients and the specific clients that need </span><span><span class="kobospan" id="kobo.297.1">to participate.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.298.1">Let’s consider an example where there are three clients involved in the FL process. </span><span class="kobospan" id="kobo.298.2">Each client sends its respective model weights and biases to the central server. </span><span class="kobospan" id="kobo.298.3">The server then performs the following objective or learning function to minimize </span><span><span class="kobospan" id="kobo.299.1">the loss:</span></span></p>
<p class="calibre3"><em class="italic"><span class="kobospan" id="kobo.300.1">minimize loss (</span></em><span><em class="italic"><span class="kobospan" id="kobo.301.1">Wt, biases)</span></em></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.302.1">The objective of the server is to optimize the model parameters, represented by the weights (</span><em class="italic"><span class="kobospan" id="kobo.303.1">Wt</span></em><span class="kobospan" id="kobo.304.1">) and biases, to minimize the loss function. </span><span class="kobospan" id="kobo.304.2">By utilizing the received weights and biases from the participating clients, the server performs iterative updates to refine the model and improve </span><span><span class="kobospan" id="kobo.305.1">its performance.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.306.1">The specific details of the learning objective and loss function depend on the specific ML algorithm and the task at hand. </span><span class="kobospan" id="kobo.306.2">The central server orchestrates the aggregation of client updates, manages the training process, and sends back the updated model to the clients. </span><span class="kobospan" id="kobo.306.3">This collaborative approach enables the clients to collectively contribute their local knowledge while benefiting from the improved global model provided by </span><span><span class="kobospan" id="kobo.307.1">the server.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.308.1">This is the </span><span><span class="kobospan" id="kobo.309.1">objective function:</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.310.1">Min f(w) = </span><span><span class="kobospan" id="kobo.311.1">∑</span></span><span><span class="kobospan" id="kobo.312.1"> </span></span><span><span class="kobospan" id="kobo.313.1">i</span></span><span><span class="kobospan" id="kobo.314.1">=</span></span><span><span class="kobospan" id="kobo.315.1">1</span></span><span><span class="kobospan" id="kobo.316.1"> </span></span><span><span class="kobospan" id="kobo.317.1">n</span></span><span><span class="kobospan" id="kobo.318.1"> </span></span><span><span class="kobospan" id="kobo.319.1"> </span></span><span> </span><span><span class="kobospan" id="kobo.320.1">£</span></span><span><span class="kobospan" id="kobo.321.1">i</span></span><span> </span><span><span class="kobospan" id="kobo.322.1">*</span></span><span> </span><span><span><span class="kobospan" id="kobo.323.1">F</span></span></span><span><span><span class="kobospan" id="kobo.324.1">i</span></span></span><span><span><span class="kobospan" id="kobo.325.1">(</span></span></span><span><span><span class="kobospan" id="kobo.326.1">w</span></span></span><span><span><span class="kobospan" id="kobo.327.1">)</span></span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.328.1">Here, </span><em class="italic"><span class="kobospan" id="kobo.329.1">w</span></em><span class="kobospan" id="kobo.330.1"> is the model parameters (weights, and so on), </span><em class="italic"><span class="kobospan" id="kobo.331.1">f(w)</span></em><span class="kobospan" id="kobo.332.1"> is the objective function, and </span><em class="italic"><span class="kobospan" id="kobo.333.1">n</span></em><span class="kobospan" id="kobo.334.1"> is the number of clients participating </span><span><span class="kobospan" id="kobo.335.1">in FL.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.336.1">A few more mathematical terms will be used in the next section including </span><span><span class="kobospan" id="kobo.337.1">the following.</span></span></p>
<ul class="calibre10">
<li class="calibre11"><em class="italic"><span class="kobospan" id="kobo.338.1">Wt</span></em><span class="kobospan" id="kobo.339.1">: Model weights in the communication round </span><em class="italic"><span class="kobospan" id="kobo.340.1">t</span></em><span class="kobospan" id="kobo.341.1"> (client </span><span><span class="kobospan" id="kobo.342.1">to server)</span></span></li>
<li class="calibre11"><em class="italic"><span class="kobospan" id="kobo.343.1">Wt k</span></em><span class="kobospan" id="kobo.344.1">: Model weights in the communication round on </span><span><span class="kobospan" id="kobo.345.1">client </span></span><span><em class="italic"><span class="kobospan" id="kobo.346.1">k</span></em></span></li>
<li class="calibre11"><em class="italic"><span class="kobospan" id="kobo.347.1">C</span></em><span class="kobospan" id="kobo.348.1">: The number of clients participating in each round to update the model and compute </span><span><span class="kobospan" id="kobo.349.1">the weights</span></span></li>
<li class="calibre11"><em class="italic"><span class="kobospan" id="kobo.350.1">B</span></em><span class="kobospan" id="kobo.351.1">: The local clients’ batch size of the </span><span><span class="kobospan" id="kobo.352.1">data samples</span></span></li>
<li class="calibre11"><em class="italic"><span class="kobospan" id="kobo.353.1">Pk</span></em><span class="kobospan" id="kobo.354.1">: The set of data samples at </span><span><span class="kobospan" id="kobo.355.1">client </span></span><span><em class="italic"><span class="kobospan" id="kobo.356.1">k</span></em></span></li>
<li class="calibre11"><em class="italic"><span class="kobospan" id="kobo.357.1">nk</span></em><span class="kobospan" id="kobo.358.1">: The number of data points at </span><span><span class="kobospan" id="kobo.359.1">client </span></span><span><em class="italic"><span class="kobospan" id="kobo.360.1">k</span></em></span></li>
<li class="calibre11"><em class="italic"><span class="kobospan" id="kobo.361.1">fi (w)</span></em><span class="kobospan" id="kobo.362.1">: </span><em class="italic"><span class="kobospan" id="kobo.363.1">loss  L ( xi, yi, w)</span></em><span class="kobospan" id="kobo.364.1"> – the </span><span><span class="kobospan" id="kobo.365.1">loss function</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.366.1">On the server side, various objective functions can be implemented, depending on the specific requirements and</span><a id="_idIndexMarker521" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.367.1"> goals of the </span><span><span class="kobospan" id="kobo.368.1">FL process.</span></span></p>
<h1 id="_idParaDest-118" class="calibre5"><a id="_idTextAnchor126" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.369.1">FL algorithms</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.370.1">FL algorithms, such as FedSGD, FedAvg, and Adaptive Federated Optimization, play a crucial role in the distributed </span><a id="_idIndexMarker522" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.371.1">training of ML models while ensuring privacy and security. </span><span class="kobospan" id="kobo.371.2">In this section, we will explore these algorithms and their </span><span><span class="kobospan" id="kobo.372.1">key characteristics.</span></span></p>
<h2 id="_idParaDest-119" class="calibre7"><a id="_idTextAnchor127" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.373.1">FedSGD</span></h2>
<p class="calibre3"><strong class="bold"><span class="kobospan" id="kobo.374.1">Federated stochastic gradient descent</span></strong><span class="kobospan" id="kobo.375.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.376.1">FedSGD</span></strong><span class="kobospan" id="kobo.377.1">) is a fundamental algorithm used in FL. </span><span class="kobospan" id="kobo.377.2">It extends the</span><a id="_idIndexMarker523" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.378.1"> traditional SGD optimization method to the federated </span><a id="_idIndexMarker524" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.379.1">setting. </span><span class="kobospan" id="kobo.379.2">In FedSGD, each client (entity) computes the gradients on its local data and sends them to the central server. </span><span class="kobospan" id="kobo.379.3">The server aggregates the gradients and updates the global model parameters accordingly. </span><span class="kobospan" id="kobo.379.4">FedSGD is efficient for large-scale distributed training but may suffer from issues related to non-IID data and </span><span><span class="kobospan" id="kobo.380.1">communication efficiency.</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer083">
<span class="kobospan" id="kobo.381.1"><img alt="Figure 6.7 – The FedSGD model weights exchange with the server" src="image/B16573_06_07.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.382.1">Figure 6.7 – The FedSGD model weights exchange with the server</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.383.1">Let’s look at the </span><span><span class="kobospan" id="kobo.384.1">FedSGD</span></span><span><a id="_idIndexMarker525" class="pcalibre1 calibre6 pcalibre"/></span><span><span class="kobospan" id="kobo.385.1"> algorithm:</span></span></p>
<table class="no-table-style" id="table003-5">
<colgroup class="calibre12">
<col class="calibre13"/>
<col class="calibre13"/>
</colgroup>
<tbody class="calibre14">
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><strong class="bold"><span class="kobospan" id="kobo.386.1">Server-side algorithm</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><strong class="bold"><span class="kobospan" id="kobo.387.1">Client-side algorithm</span></strong></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.388.1">Initialize </span><span><span class="kobospan" id="kobo.389.1">weights (w0)</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.390.1">for each round t = </span><span><span class="kobospan" id="kobo.391.1">1,2, …</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.392.1">m = max (C, </span><span><span class="kobospan" id="kobo.393.1">K, 1)</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.394.1">st = random set of </span><span><span class="kobospan" id="kobo.395.1">m clients</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.396.1">for client k </span><span><span class="kobospan" id="kobo.397.1">in st,</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.398.1">w</span><span class="subscript"><span class="kobospan1" id="kobo.399.1">t+1 = </span></span><span class="kobospan" id="kobo.400.1">client-side function (</span><span><span class="kobospan" id="kobo.401.1">k, w</span></span><span><span class="subscript"><span class="kobospan1" id="kobo.402.1">t</span></span></span><span><span class="kobospan" id="kobo.403.1">)</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.404.1">w</span><span class="subscript"><span class="kobospan1" id="kobo.405.1">t+1 = </span></span><span class="kobospan" id="kobo.406.1">average </span><span><span class="kobospan" id="kobo.407.1">of weights</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.408.1"> Client-side function (</span><span><span class="kobospan" id="kobo.409.1">k, w):</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.410.1">Split the data in </span><em class="italic"><span class="kobospan" id="kobo.411.1">k</span></em><span class="kobospan" id="kobo.412.1"> batches, with each batch based on the batch size </span><em class="italic"><span class="kobospan" id="kobo.413.1">B</span></em><span class="kobospan" id="kobo.414.1"> (complete </span><span><span class="kobospan" id="kobo.415.1">local dataset)</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.416.1">For </span><span><span class="kobospan" id="kobo.417.1">each batch:</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.418.1">f</span><span class="subscript1"><span class="kobospan1" id="kobo.419.1">i (w) = </span></span><span class="kobospan" id="kobo.420.1">loss L (xi, </span><span><span class="kobospan" id="kobo.421.1">yi, w)</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.422.1">w = w – learning rate * </span><span><span class="kobospan" id="kobo.423.1">loss</span></span></li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.424.1">Table 6.3 - FedSGD Algorithem</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.425.1">On the client side, each participating</span><a id="_idIndexMarker526" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.426.1"> client performs the </span><span><span class="kobospan" id="kobo.427.1">following steps:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.428.1">Data partitioning</span></strong><span class="kobospan" id="kobo.429.1">: Clients have their </span><a id="_idIndexMarker527" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.430.1">own local datasets and partition them into smaller subsets to </span><span><span class="kobospan" id="kobo.431.1">ensure privacy.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.432.1">Local model training</span></strong><span class="kobospan" id="kobo.433.1">: Each client independently trains the shared model using its local data. </span><span class="kobospan" id="kobo.433.2">This involves computing the gradients of the model parameters (weights and biases) on the local dataset using SGD or </span><span><span class="kobospan" id="kobo.434.1">a variant.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.435.1">Model update</span></strong><span class="kobospan" id="kobo.436.1">: After the local model training, the client sends the computed gradients to the server </span><span><span class="kobospan" id="kobo.437.1">for aggregation.</span></span></li>
</ol>
<p class="calibre3"><span class="kobospan" id="kobo.438.1">On the server side, the central server performs the </span><span><span class="kobospan" id="kobo.439.1">following steps:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.440.1">Aggregation</span></strong><span class="kobospan" id="kobo.441.1">: The server receives the</span><a id="_idIndexMarker528" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.442.1"> gradients from all participating clients and aggregates them using various aggregation techniques, such as averaging or </span><span><span class="kobospan" id="kobo.443.1">weighted averaging.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.444.1">Model update</span></strong><span class="kobospan" id="kobo.445.1">: The aggregated gradients are used to update the global model’s parameters. </span><span class="kobospan" id="kobo.445.2">The server applies the received gradients to the global model, adjusting its weights and biases to reflect the collective knowledge from </span><span><span class="kobospan" id="kobo.446.1">all clients.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.447.1">Model distribution</span></strong><span class="kobospan" id="kobo.448.1">: The updated global model is then sent back to the clients for the next round of training, ensuring that each client benefits from the collective knowledge while preserving </span><span><span class="kobospan" id="kobo.449.1">data privacy.</span></span></li>
</ol>
<p class="calibre3"><span class="kobospan" id="kobo.450.1">FedSGD aims to minimize the communication overhead between the clients and the server by exchanging only the model gradients rather than the raw data. </span><span class="kobospan" id="kobo.450.2">This allows for distributed model training while maintaining data privacy and security. </span><span class="kobospan" id="kobo.450.3">However, it is important to address challenges such as data heterogeneity and non-IID data distribution, which can impact the convergence and performance of the </span><span><span class="kobospan" id="kobo.451.1">FL process.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.452.1">Overall, FedSGD enables collaborative model training in a decentralized manner, leveraging the computational resources of multiple clients while preserving data privacy. </span><span class="kobospan" id="kobo.452.2">It serves as a foundational algorithm for FL and has paved the way for more advanced techniques to</span><a id="_idIndexMarker529" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.453.1"> improve the efficiency and effectiveness of </span><span><span class="kobospan" id="kobo.454.1">distributed ML.</span></span></p>
<h2 id="_idParaDest-120" class="calibre7"><a id="_idTextAnchor128" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.455.1">FedAvg</span></h2>
<p class="calibre3"><strong class="bold"><span class="kobospan" id="kobo.456.1">Federated averaging</span></strong><span class="kobospan" id="kobo.457.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.458.1">FedAvg</span></strong><span class="kobospan" id="kobo.459.1">) is a widely adopted FL algorithm designed to address the challenges of non-IID data and communication efficiency. </span><span class="kobospan" id="kobo.459.2">In FedAvg, similar to FedSGD, each client computes</span><a id="_idIndexMarker530" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.460.1"> the gradients on its local data. </span><span class="kobospan" id="kobo.460.2">However, instead of directly updating the global model with the individual gradients, FedAvg</span><a id="_idIndexMarker531" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.461.1"> employs weighted averaging to combine the client models’ parameters. </span><span class="kobospan" id="kobo.461.2">This approach allows for better handling of data heterogeneity and reduces the communication overhead between the clients and </span><span><span class="kobospan" id="kobo.462.1">the server.</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer084">
<span class="kobospan" id="kobo.463.1"><img alt="Figure 6.8 – The FedAvg model weights exchange with the server" src="image/B16573_06_08.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.464.1">Figure 6.8 – The FedAvg model weights exchange with the server</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.465.1">Let’s look at the </span><span><span class="kobospan" id="kobo.466.1">FedAvg</span></span><span><a id="_idIndexMarker532" class="pcalibre1 calibre6 pcalibre"/></span><span><span class="kobospan" id="kobo.467.1"> algorithm:</span></span></p>
<table class="no-table-style" id="table004-5">
<colgroup class="calibre12">
<col class="calibre13"/>
<col class="calibre13"/>
</colgroup>
<tbody class="calibre14">
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><strong class="bold"><span class="kobospan" id="kobo.468.1">Server-side algorithm</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><strong class="bold"><span class="kobospan" id="kobo.469.1">Client-side algorithm</span></strong></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.470.1">Initialize </span><span><span class="kobospan" id="kobo.471.1">weights (w</span></span><span><span class="subscript"><span class="kobospan1" id="kobo.472.1">0</span></span></span><span><span class="kobospan" id="kobo.473.1">)</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.474.1">for each round t = </span><span><span class="kobospan" id="kobo.475.1">1,2, …</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.476.1">m = max (C, </span><span><span class="kobospan" id="kobo.477.1">K, 1)</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.478.1">st = random set of </span><span><span class="kobospan" id="kobo.479.1">m clients</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.480.1">for client k </span><span><span class="kobospan" id="kobo.481.1">in st,</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.482.1">w</span><span class="subscript"><span class="kobospan1" id="kobo.483.1">t+1 = </span></span><span class="kobospan" id="kobo.484.1">client-side function (</span><span><span class="kobospan" id="kobo.485.1">k, w</span></span><span><span class="subscript"><span class="kobospan1" id="kobo.486.1">t</span></span></span><span><span class="kobospan" id="kobo.487.1">)</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.488.1">w</span><span class="subscript"><span class="kobospan1" id="kobo.489.1">t+1 = </span></span><span class="kobospan" id="kobo.490.1">average </span><span><span class="kobospan" id="kobo.491.1">of gradients</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.492.1">Client-side function (</span><span><span class="kobospan" id="kobo.493.1">k, w):</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.494.1">Split the data into </span><em class="italic"><span class="kobospan" id="kobo.495.1">k</span></em><span class="kobospan" id="kobo.496.1"> batches, with each batch based on the batch </span><span><span class="kobospan" id="kobo.497.1">size </span></span><span><em class="italic"><span class="kobospan" id="kobo.498.1">B</span></em></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.499.1">For each epoch in </span><span><span class="kobospan" id="kobo.500.1">training E</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.501.1">For </span><span><span class="kobospan" id="kobo.502.1">each batch:</span></span><ul class="calibre16"><li class="calibre11"><span class="kobospan" id="kobo.503.1"> f</span><span class="subscript1"><span class="kobospan1" id="kobo.504.1">i (w) = </span></span><span class="kobospan" id="kobo.505.1">loss  L (xi, </span><span><span class="kobospan" id="kobo.506.1">yi, w)</span></span></li><li class="calibre11"><span class="kobospan" id="kobo.507.1">w = w – learning rate * </span><span><span class="kobospan" id="kobo.508.1">loss</span></span></li></ul></li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.509.1">Table 6.4 – FedAVG Algorithm</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.510.1">FedAvg leverages the concept of averaging to combine the locally trained models of different clients, which helps mitigate the impact of data heterogeneity and non-IID data distribution. </span><span class="kobospan" id="kobo.510.2">By averaging the model parameters, FedAvg effectively creates a global model that captures insights from all participating clients while preserving the privacy of individual data. </span><span class="kobospan" id="kobo.510.3">The iterative nature of FedAvg allows the shared model to progressively improve with each round of training. </span><span class="kobospan" id="kobo.510.4">As the process continues, the global model becomes more refined and represents the collective knowledge of </span><span><span class="kobospan" id="kobo.511.1">all clients.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.512.1">Overall, FedAvg enables collaborative training of a shared model in a privacy-preserving manner. </span><span class="kobospan" id="kobo.512.2">It addresses challenges associated with data privacy and distribution, allowing multiple clients to contribute to the model’s improvement without sharing their raw data. </span><span class="kobospan" id="kobo.512.3">FedAvg has been instrumental in advancing the field of FL, enabling applications in various domains while maintaining data privacy </span><span><span class="kobospan" id="kobo.513.1">and security.</span></span></p>
</div>


<div id="_idContainer095" class="calibre2">
<h2 id="_idParaDest-121" class="calibre7"><a id="_idTextAnchor129" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.514.1">Fed Adaptative Optimization</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.515.1">In cross-device FL, a multitude of clients communicate with a central server, and each client possesses a unique set </span><span><span class="kobospan" id="kobo.516.1">of data.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.517.1">For instance, in the context of next-word prediction on phones, different users’ phones contain distinct word sets based on factors such as country, region, and language. </span><span class="kobospan" id="kobo.517.2">However, traditional FL algorithms such as FedSGD and FedAvg may not perform optimally when confronted with heterogeneous data from diverse clients. </span><span class="kobospan" id="kobo.517.3">The challenge arises from the inherent differences in data distribution and characteristics among the clients. </span><span class="kobospan" id="kobo.517.4">Heterogeneous data introduces complexities that can impact the convergence and performance of FL algorithms. </span><span class="kobospan" id="kobo.517.5">As a result, handling heterogeneous data poses a considerable obstacle compared to scenarios where the clients have </span><span><span class="kobospan" id="kobo.518.1">homogeneous data.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.519.1">Efforts are being made to address the challenges associated with heterogeneous data in </span><span><span class="kobospan" id="kobo.520.1">cross-device FL.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.521.1">In order to overcome this, researchers at Google (</span><em class="italic"><span class="kobospan" id="kobo.522.1">Sashank J. </span><span class="kobospan" id="kobo.522.2">Reddi et al., 2021</span></em><span class="kobospan" id="kobo.523.1">) proposed new adaptative optimizations in the research paper published </span><span><span class="kobospan" id="kobo.524.1">at </span></span><span><span class="kobospan" id="kobo.525.1">arxiv.org/abs/2003.00295</span></span><span><span class="kobospan" id="kobo.526.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.527.1">Here is the detailed algorithm (the image is sourced from the </span><span><span class="kobospan" id="kobo.528.1">preceding URL):</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer085">
<span class="kobospan" id="kobo.529.1"><img alt="Figure 6.9 – The Fed Adaptive Optimization algorithm proposed by Google researchers" src="image/B16573_06_09.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.530.1">Figure 6.9 – The Fed Adaptive Optimization algorithm proposed by Google researchers</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.531.1">Please refer to the article for a detailed explanation of the Adaptive Optimization algorithm. </span><span class="kobospan" id="kobo.531.2">In a nutshell, the idea is to optimize the communication cost like FEDAVG and work in </span><span><span class="kobospan" id="kobo.532.1">cross-device settings.</span></span></p>
<h1 id="_idParaDest-122" class="calibre5"><a id="_idTextAnchor130" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.533.1">The steps involved in implementing FL</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.534.1">The following are the five steps that are typically followed to implement FL.  </span><span class="kobospan" id="kobo.534.2">There can be alternatives/changes to these steps, but initially, these are the steps that need to </span><span><span class="kobospan" id="kobo.535.1">be followed:</span></span></p>
<p class="calibre3"><strong class="bold"><span class="kobospan" id="kobo.536.1">The server side – the initialization of the global model</span></strong><span class="kobospan" id="kobo.537.1">: In this step, the server starts and accepts the client requests. </span><span class="kobospan" id="kobo.537.2">Before actually starting the server, the model on the server side will be initiated with model parameters. </span><span class="kobospan" id="kobo.537.3">Typically, model parameters will be initiated with zeros or from the previous </span><span><span class="kobospan" id="kobo.538.1">checkpoint model.</span></span></p>
<p class="calibre3"><strong class="bold"><span class="kobospan" id="kobo.539.1">The server sends model parameters to all or a subset of clients</span></strong><span class="kobospan" id="kobo.540.1">: In this step, the server sends the initial model parameters to all clients (for cross-silo FL clients, they will be within the same institutions and may only be numbered in the tens) or a subset of clients (in the case of cross-device FL where devices are in the millions, the server decides to select only a subset from the total devices). </span><span class="kobospan" id="kobo.540.2">Each client will make use of these initial model parameters for the local training of </span><span><span class="kobospan" id="kobo.541.1">the model.</span></span></p>
<p class="calibre3"><strong class="bold"><span class="kobospan" id="kobo.542.1">The clients train the model and send the model weights/parameters back to the server</span></strong><span class="kobospan" id="kobo.543.1">: In this step, each client will train the model with their local data, making use of the entire local data in one shot, dividing the data into several batches, or splitting the data randomly and making use of the different splits for different rounds (a multiple rounds of exchanges of model parameters between the client and server). </span><span class="kobospan" id="kobo.543.2">The clients will send the model parameters or weights only to </span><span><span class="kobospan" id="kobo.544.1">the server.</span></span></p>
<p class="calibre3"><strong class="bold"><span class="kobospan" id="kobo.545.1">The server executes one of the FL algorithms, updates the global model, and sends the updated weights to the client for the next round</span></strong><span class="kobospan" id="kobo.546.1">: In this step, the server will run one of the FL algorithms and make use of the weights received by the clients to update the global model. </span><span class="kobospan" id="kobo.546.2">In the case of FedAvg, it will calculate the weighted average of the weights received from clients and send the updated weights back to the client for the </span><span><span class="kobospan" id="kobo.547.1">next round.</span></span></p>
<p class="calibre3"><strong class="bold"><span class="kobospan" id="kobo.548.1">Repeat steps 2 to 4 based on the number of rounds configured</span></strong><span class="kobospan" id="kobo.549.1">: Repeat </span><em class="italic"><span class="kobospan" id="kobo.550.1">steps 2</span></em><span class="kobospan" id="kobo.551.1"> to </span><em class="italic"><span class="kobospan" id="kobo.552.1">4</span></em><span class="kobospan" id="kobo.553.1"> for each round. </span><span class="kobospan" id="kobo.553.2">If five rounds are configured, then repeat </span><em class="italic"><span class="kobospan" id="kobo.554.1">steps 2</span></em><span class="kobospan" id="kobo.555.1"> to </span><em class="italic"><span class="kobospan" id="kobo.556.1">4</span></em><span class="kobospan" id="kobo.557.1"> five times, and after the last round, clients will make use of the weights received by the server for the final ML model. </span><span class="kobospan" id="kobo.557.2">Clients can make use of these model weights either at the end of the last round or in each round and evaluate the model’s accuracy with the </span><span><span class="kobospan" id="kobo.558.1">test data.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.559.1">The following sequence diagram shows these steps </span><span><span class="kobospan" id="kobo.560.1">in detail:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer086">
<span class="kobospan" id="kobo.561.1"><img alt="Figure 6.10 – The steps in the FL sequence diagram" src="image/B16573_06_10.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.562.1">Figure 6.10 – The steps in the FL sequence diagram</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.563.1">The sequence diagram shows the detailed interactions between the server and the clients participating in the FL, performing four high-level steps as explained in </span><span><span class="kobospan" id="kobo.564.1">this section.</span></span></p>
<h1 id="_idParaDest-123" class="calibre5"><a id="_idTextAnchor131" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.565.1">Open source frameworks to implement FL</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.566.1">There are a few open source frameworks to implement FL at scale. </span><span class="kobospan" id="kobo.566.2">The following are some of the </span><span><span class="kobospan" id="kobo.567.1">most popular.</span></span></p>
<p class="calibre3"><strong class="bold"><span class="kobospan" id="kobo.568.1">PySyft</span></strong><span class="kobospan" id="kobo.569.1"> (</span><a href="https://github.com/OpenMined/PySyft" class="pcalibre1 calibre6 pcalibre"><span class="kobospan" id="kobo.570.1">https://github.com/OpenMined/PySyft</span></a><span class="kobospan" id="kobo.571.1">), developed by OpenMined, is an open source stack that offers secure and private data science capabilities in Python. </span><span class="kobospan" id="kobo.571.2">It introduces a separation between private data and model training, enabling functionalities such as FL, differential privacy, and encrypted computation. </span><span class="kobospan" id="kobo.571.3">Initially, PySyft utilized the Opacus framework to support differential privacy, as discussed in the Differential privacy chapter. </span><span class="kobospan" id="kobo.571.4">However, the latest version of PySyft incorporates its own differential privacy component to provide enhanced functionality and efficiency in preserving privacy while performing data </span><span><span class="kobospan" id="kobo.572.1">analysis tasks.</span></span></p>
<h2 id="_idParaDest-124" class="calibre7"><a id="_idTextAnchor132" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.573.1">TensorFlow Federated</span></h2>
<p class="calibre3"><strong class="bold"><span class="kobospan" id="kobo.574.1">TensorFlow Federated</span></strong><span class="kobospan" id="kobo.575.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.576.1">TFF</span></strong><span class="kobospan" id="kobo.577.1">) is a library developed by Google that facilitates the training of shared ML models across multiple clients using their local data (</span><a href="https://www.tensorflow.org/federated" class="pcalibre1 calibre6 pcalibre"><span class="kobospan" id="kobo.578.1">https://www.tensorflow.org/federated</span></a><span class="kobospan" id="kobo.579.1">). </span><span class="kobospan" id="kobo.579.2">TFF consists of two layers – the Federated Core API and the Federated </span><span><span class="kobospan" id="kobo.580.1">Learning API.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.581.1">The Federated Core API offers low-level interfaces for tasks such as data serialization, distribution communication between the server and clients, and implementation of FL algorithms. </span><span class="kobospan" id="kobo.581.2">It provides the foundational components necessary to build </span><span><span class="kobospan" id="kobo.582.1">FL systems.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.583.1">Conversely, the Federated Learning API provides a higher-level interface that allows users to easily construct FL models or wrap existing models as FL models. </span><span class="kobospan" id="kobo.583.2">It offers a set of APIs for training and evaluating models using federated computations and datasets. </span><span class="kobospan" id="kobo.583.3">This higher-level interface abstracts away some of the complexities involved in building and training FL models, making it more accessible and convenient </span><span><span class="kobospan" id="kobo.584.1">for developers.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.585.1">By providing these two layers, TFF empowers researchers and developers to leverage the power of FL in their projects. </span><span class="kobospan" id="kobo.585.2">It simplifies the process of building and training models on decentralized data while ensuring privacy and </span><span><span class="kobospan" id="kobo.586.1">data security.</span></span></p>
<h2 id="_idParaDest-125" class="calibre7"><a id="_idTextAnchor133" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.587.1">Flower</span></h2>
<p class="calibre3"><strong class="bold"><span class="kobospan" id="kobo.588.1">Flower</span></strong><span class="kobospan" id="kobo.589.1"> (</span><a href="https://flower.dev/" class="pcalibre1 calibre6 pcalibre"><span class="kobospan" id="kobo.590.1">https://flower.dev/</span></a><span class="kobospan" id="kobo.591.1">) is an open source framework that aims to provide a user-friendly experience. </span><span class="kobospan" id="kobo.591.2">It supports ML and DL models developed using various frameworks, such as scikit-learn, TensorFlow, PyTorch, PyTorch Lightning, MXNet, and JAX. </span><span class="kobospan" id="kobo.591.3">Flower makes it easy to convert these models into </span><span><span class="kobospan" id="kobo.592.1">FL models.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.593.1">One of the key features of Flower is its communication implementation, which is built on top of bidirectional gRPC streams. </span><span class="kobospan" id="kobo.593.2">This enables an efficient and seamless exchange of multiple messages between clients and the server without the need to establish a new connection for each </span><span><span class="kobospan" id="kobo.594.1">message request.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.595.1">Flower offers a range of strategies and implements several FL algorithms on the server side. </span><span class="kobospan" id="kobo.595.2">These algorithms include FedAvg, FedSGD, Fault Tolerance FedAvg, FedProxy, and FedOptim (which consists of FedAdagrad, FedYogi, and FedAdam). </span><span class="kobospan" id="kobo.595.3">These algorithms provide different approaches to model aggregation and training in </span><span><span class="kobospan" id="kobo.596.1">FL scenarios.</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer087">
<span class="kobospan" id="kobo.597.1"><img alt="Figure 6.11 – The Flower framework architecture diagram (simplified)" src="image/B16573_06_11.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.598.1">Figure 6.11 – The Flower framework architecture diagram (simplified)</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.599.1">To validate its performance, Flower has been extensively benchmarked. </span><span class="kobospan" id="kobo.599.2">The framework has demonstrated the ability to scale up to 15 million clients using only two GPU servers. </span><span class="kobospan" id="kobo.599.3">These experiments</span><a id="_idIndexMarker533" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.600.1"> were compared with FedScale, another FL engine and benchmark suite, to evaluate Flower’s performance and</span><a id="_idIndexMarker534" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.601.1"> efficiency in large-scale </span><span><span class="kobospan" id="kobo.602.1">FL settings.</span></span></p>
<h1 id="_idParaDest-126" class="calibre5"><a id="_idTextAnchor134" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.603.1">An end-to-end use case of implementing fraud detection using FL</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.604.1">Fraud detection is a critical task </span><a id="_idIndexMarker535" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.605.1">for many industries, including finance, e-commerce, and healthcare. </span><span class="kobospan" id="kobo.605.2">Traditional fraud</span><a id="_idIndexMarker536" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.606.1"> detection methods often rely on centralized data collection, where sensitive customer information is gathered and analyzed in a single location. </span><span class="kobospan" id="kobo.606.2">However, this approach raises concerns about data privacy and security, as well as compliance with regulations such as </span><span><span class="kobospan" id="kobo.607.1">the GDPR.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.608.1">FL offers a promising solution to address these challenges. </span><span class="kobospan" id="kobo.608.2">By leveraging the power of distributed computing and collaborative learning, FL enables fraud detection models to be trained directly on the devices or local servers of individual institutions, without the need for data sharing. </span><span class="kobospan" id="kobo.608.3">This decentralized approach ensures that sensitive customer data remains private and secure, as it never leaves the </span><span><span class="kobospan" id="kobo.609.1">local environment.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.610.1">Implementing fraud detection using FL involves several key steps. </span><span class="kobospan" id="kobo.610.2">Firstly, a consortium of institutions or organizations, such as banks or e-commerce platforms, need to establish an FL framework that enables them to collaborate on model training while preserving data privacy. </span><span class="kobospan" id="kobo.610.3">This may involve the adoption of FL libraries or platforms such as TFF </span><span><span class="kobospan" id="kobo.611.1">or Flower.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.612.1">Next, the participating institutions define a common fraud detection objective and develop a shared model architecture. </span><span class="kobospan" id="kobo.612.2">Each institution then trains its local model using its own private data, which may include transaction records, user behavior patterns, and other relevant features. </span><span class="kobospan" id="kobo.612.3">The models are trained locally, ensuring that sensitive data remains under the control of the </span><span><span class="kobospan" id="kobo.613.1">respective institutions.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.614.1">To facilitate collaborative learning, the institutions periodically share model updates with a central server. </span><span class="kobospan" id="kobo.614.2">These updates, which typically include model weights and parameters, are aggregated using federated averaging or other aggregation techniques to create a global model that captures insights from all participants, while preserving the privacy of </span><span><span class="kobospan" id="kobo.615.1">individual data.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.616.1">The central server, which </span><a id="_idIndexMarker537" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.617.1">oversees the aggregation process, ensures that the global model is refined based on the collective knowledge of the participating institutions. </span><span class="kobospan" id="kobo.617.2">This process allows the model to learn from a diverse range of fraud patterns and adapt to evolving fraudulent activities while maintaining data privacy and compliance </span><span><span class="kobospan" id="kobo.618.1">with regulations.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.619.1">Implementing fraud</span><a id="_idIndexMarker538" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.620.1"> detection using FL offers several advantages. </span><span class="kobospan" id="kobo.620.2">It allows institutions to leverage a larger and more diverse dataset, leading to improved fraud detection accuracy. </span><span class="kobospan" id="kobo.620.3">It also reduces the risks associated with data breaches or unauthorized access, since sensitive data remains under the control of the respective institutions. </span><span class="kobospan" id="kobo.620.4">Additionally, FL enables real-time updates and faster model deployment, allowing institutions to respond quickly to emerging </span><span><span class="kobospan" id="kobo.621.1">fraud patterns.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.622.1">Implementing fraud detection using FL offers a privacy-preserving and collaborative approach to combat fraud in various industries. </span><span class="kobospan" id="kobo.622.2">By combining the power of distributed computing and shared learning, organizations can enhance fraud detection capabilities while safeguarding sensitive </span><span><span class="kobospan" id="kobo.623.1">customer data.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.624.1">Let’s implement this use case using the Flower framework and the open </span><span><span class="kobospan" id="kobo.625.1">source dataset.</span></span></p>
<h2 id="_idParaDest-127" class="calibre7"><a id="_idTextAnchor135" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.626.1">Developing an FL model for fraud detection using the Flower framework</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.627.1">In this example, we will leverage</span><a id="_idIndexMarker539" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.628.1"> the Flower framework to develop an FL model for fraud detection. </span><span class="kobospan" id="kobo.628.2">The implementation will involve </span><a id="_idIndexMarker540" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.629.1">both server-side and client-side components. </span><span class="kobospan" id="kobo.629.2">To illustrate the process, we will set up one server and </span><span><span class="kobospan" id="kobo.630.1">two clients.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.631.1">The communication between the server and clients will occur over several rounds, with the exchange of weights and parameters. </span><span class="kobospan" id="kobo.631.2">The exact number of rounds may vary depending on the specific scenario, but typically, the communication continues until the weights converge or a predetermined convergence criterion </span><span><span class="kobospan" id="kobo.632.1">is met.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.633.1">On the server side, we will </span><a id="_idIndexMarker541" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.634.1">implement the FedAvg algorithm to aggregate the weights received from the clients. </span><span class="kobospan" id="kobo.634.2">FedAvg is a widely used algorithm in FL that combines the knowledge from multiple clients to create a </span><span><span class="kobospan" id="kobo.635.1">global model.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.636.1">For the fraud detection task, we will develop an actual linear regression model using the scikit-learn library. </span><span class="kobospan" id="kobo.636.2">This model will be trained using the data available at each client, which consists of transaction records and relevant features. </span><span class="kobospan" id="kobo.636.3">The goal is to classify whether a transaction is fraudulent </span><span><span class="kobospan" id="kobo.637.1">or not.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.638.1">The client-side implementation will involve training the local linear regression models using the respective client’s data. </span><span class="kobospan" id="kobo.638.2">The clients will then communicate with the server, exchanging their model weights and parameters over the predefined rounds. </span><span class="kobospan" id="kobo.638.3">This collaborative learning </span><a id="_idIndexMarker542" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.639.1">process allows the clients to contribute their local insights to the global model while preserving the privacy of </span><span><span class="kobospan" id="kobo.640.1">their data.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.641.1">The server will receive the model updates from the clients and perform the aggregation step using the FedAvg algorithm. </span><span class="kobospan" id="kobo.641.2">This aggregation process ensures that the global model incorporates the knowledge learned from all the participating clients, resulting in an enhanced fraud </span><span><span class="kobospan" id="kobo.642.1">detection capability.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.643.1">Throughout the implementation, the Flower framework provides the necessary infrastructure for the communication between the server and clients. </span><span class="kobospan" id="kobo.643.2">It abstracts the underlying complexities of distributed computing and handles the synchronization of model updates. </span><span class="kobospan" id="kobo.643.3">By developing an FL model for fraud detection, we can leverage the distributed knowledge and data from multiple clients to improve the accuracy of fraud classification. </span><span class="kobospan" id="kobo.643.4">The federated approach also addresses privacy concerns by keeping the sensitive transaction data local to </span><span><span class="kobospan" id="kobo.644.1">each client.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.645.1">In summary, this project demonstrates the implementation of an FL model using the Flower framework. </span><span class="kobospan" id="kobo.645.2">The server and clients collaborate to train a global model for fraud detection, exchanging model weights and parameters over multiple communication rounds. </span><span class="kobospan" id="kobo.645.3">By aggregating the client models using FedAvg, we can leverage the collective intelligence of multiple participants while ensuring </span><span><span class="kobospan" id="kobo.646.1">data privacy.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.647.1">The dataset used in the example</span></h3>
<p class="calibre3"><em class="italic"><span class="kobospan" id="kobo.648.1">Lopez, Elmir, and Axelsson</span></em><span class="kobospan" id="kobo.649.1"> developed a mobile money dataset for fraud detection, and it is featured on Kaggle as well (E. </span><span class="kobospan" id="kobo.649.2">A. </span><span class="kobospan" id="kobo.649.3">Lopez-Rojas, A. </span><span class="kobospan" id="kobo.649.4">Elmir, and S. </span><span class="kobospan" id="kobo.649.5">Axelsson, </span><em class="italic"><span class="kobospan" id="kobo.650.1">PaySim: A financial mobile money simulator for fraud detection</span></em><span class="kobospan" id="kobo.651.1">, 28th European Modeling and Simulation Symposium-EMSS, Larnaca, </span><span><span class="kobospan" id="kobo.652.1">Cyprus. </span><span class="kobospan" id="kobo.652.2">2016).</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.653.1">We will make use of this dataset for the detection of fraud using FL, but the same can be extended to anti-money laundering use cases as well, with minor changes to the model. </span><span class="kobospan" id="kobo.653.2">The dataset can be</span><a id="_idIndexMarker543" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.654.1"> found </span><span><span class="kobospan" id="kobo.655.1">at </span></span><a href="https://github.com/EdgarLopezPhD/PaySim" class="pcalibre1 calibre6 pcalibre"><span><span class="kobospan" id="kobo.656.1">https://github.com/EdgarLopezPhD/PaySim</span></span></a><span><span class="kobospan" id="kobo.657.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.658.1">Download this</span><a id="_idIndexMarker544" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.659.1"> dataset and keep the file in the </span><a href="B16573_06_split_000.xhtml#_idTextAnchor120" class="pcalibre1 calibre6 pcalibre"><span><em class="italic"><span class="kobospan" id="kobo.660.1">Chapter 6</span></em></span></a><span class="kobospan" id="kobo.661.1"> directory with the </span><span><span class="kobospan" id="kobo.662.1">name </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.663.1">PS_20174392719_1491204439457_log.csv</span></strong></span><span><span class="kobospan" id="kobo.664.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.665.1">This dataset consists of 6.3 million records of transactions and has the </span><span><span class="kobospan" id="kobo.666.1">following features:</span></span></p>
<table class="no-table-style" id="table005-4">
<colgroup class="calibre12">
<col class="calibre13"/>
<col class="calibre13"/>
<col class="calibre13"/>
</colgroup>
<thead class="calibre18">
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><strong class="bold"><span class="kobospan" id="kobo.667.1">Field</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><strong class="bold"><span class="kobospan" id="kobo.668.1">Data type</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><strong class="bold"><span class="kobospan" id="kobo.669.1">Details</span></strong></span></p>
</td>
</tr>
</thead>
<tbody class="calibre14">
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><strong class="source-inline"><span class="kobospan" id="kobo.670.1">Step</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.671.1">Numerical</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.672.1">The unit of time in the real world. </span><span class="kobospan" id="kobo.672.2">One step is </span><span><span class="kobospan" id="kobo.673.1">1 hour.</span></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><strong class="source-inline"><span class="kobospan" id="kobo.674.1">Type</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.675.1">Object</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><strong class="source-inline"><span class="kobospan" id="kobo.676.1">CASH-IN</span></strong><span class="kobospan" id="kobo.677.1">, </span><strong class="source-inline"><span class="kobospan" id="kobo.678.1">CASH-OUT</span></strong><span class="kobospan" id="kobo.679.1">, </span><strong class="source-inline"><span class="kobospan" id="kobo.680.1">DEBIT</span></strong><span class="kobospan" id="kobo.681.1">, </span><strong class="source-inline"><span class="kobospan" id="kobo.682.1">PAYMENT</span></strong><span class="kobospan" id="kobo.683.1">, </span><span><span class="kobospan" id="kobo.684.1">and </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.685.1">TRANSFER</span></strong></span><span><span class="kobospan" id="kobo.686.1">.</span></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><strong class="source-inline"><span class="kobospan" id="kobo.687.1">Amount</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.688.1">Numerical</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.689.1">The amount of </span><span><span class="kobospan" id="kobo.690.1">the transaction.</span></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><strong class="source-inline"><span class="kobospan" id="kobo.691.1">nameOrig</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.692.1">Object</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.693.1">The customer who started </span><span><span class="kobospan" id="kobo.694.1">the transaction.</span></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><strong class="source-inline"><span class="kobospan" id="kobo.695.1">nameDest</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.696.1">Object</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.697.1">The recipient ID of </span><span><span class="kobospan" id="kobo.698.1">the transaction.</span></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><strong class="source-inline"><span class="kobospan" id="kobo.699.1">oldbalanceOrg</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.700.1">Numerical</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.701.1">The initial balance before </span><span><span class="kobospan" id="kobo.702.1">the transaction.</span></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><strong class="source-inline"><span class="kobospan" id="kobo.703.1">newbalanceOrig</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.704.1">Numerical</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.705.1">The customer’s balance after </span><span><span class="kobospan" id="kobo.706.1">the transaction.</span></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><strong class="source-inline"><span class="kobospan" id="kobo.707.1">oldbalanceDest</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.708.1">Numerical</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.709.1">The initial recipient’s balance before </span><span><span class="kobospan" id="kobo.710.1">the transaction.</span></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><strong class="source-inline"><span class="kobospan" id="kobo.711.1">newbalanceDest</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.712.1">Numerical</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.713.1">The recipient’s balance after </span><span><span class="kobospan" id="kobo.714.1">the transaction.</span></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><strong class="source-inline"><span class="kobospan" id="kobo.715.1">isFraud</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.716.1">Boolean</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.717.1">Identifies fraudulent (</span><strong class="source-inline"><span class="kobospan" id="kobo.718.1">1</span></strong><span class="kobospan" id="kobo.719.1">) and non-fraudulent (</span><span><strong class="source-inline"><span class="kobospan" id="kobo.720.1">0</span></strong></span><span><span class="kobospan" id="kobo.721.1">) transactions.</span></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><strong class="source-inline"><span class="kobospan" id="kobo.722.1">isFlaggedFraud</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.723.1">Boolean</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.724.1">Flags illegal attempts to transfer more than 200,000 amount in a </span><span><span class="kobospan" id="kobo.725.1">single transaction.</span></span></p>
</td>
</tr>
</tbody>
</table>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.726.1">Table 6.5 – The dataset features</span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.727.1">The installation of Flower</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.728.1">Install </span><a id="_idIndexMarker545" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.729.1">Flower </span><a id="_idIndexMarker546" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.730.1">using the </span><strong class="source-inline"><span class="kobospan" id="kobo.731.1">python -m pip install </span></strong><span><strong class="source-inline"><span class="kobospan" id="kobo.732.1">flwr</span></strong></span><span><span class="kobospan" id="kobo.733.1"> command.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.734.1">The implementation of a server</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.735.1">The server-side implementation </span><a id="_idIndexMarker547" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.736.1">of the FL model for fraud detection involves several high-level steps. </span><span class="kobospan" id="kobo.736.2">We will utilize the sample code </span><a id="_idIndexMarker548" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.737.1">provided by the Flower framework and extend it to fit our specific </span><span><span class="kobospan" id="kobo.738.1">use case.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.739.1">The following steps outline </span><span><span class="kobospan" id="kobo.740.1">the process:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.741.1">Initialize the </span></strong><span><strong class="bold"><span class="kobospan" id="kobo.742.1">model parameters</span></strong></span><span><span class="kobospan" id="kobo.743.1">:</span></span><ol class="calibre20"><li class="alphabets"><span class="kobospan" id="kobo.744.1">Set the initial model weights to </span><strong class="source-inline1"><span class="kobospan" id="kobo.745.1">0</span></strong><span class="kobospan" id="kobo.746.1"> and initialize the intercept as </span><strong class="source-inline1"><span class="kobospan" id="kobo.747.1">0</span></strong><span class="kobospan" id="kobo.748.1"> (since we are working with a </span><span><span class="kobospan" id="kobo.749.1">regression model).</span></span></li><li class="alphabets"><span class="kobospan" id="kobo.750.1">Determine the number of classes or labels </span><span><span class="kobospan" id="kobo.751.1">for classification.</span></span></li><li class="alphabets"><span class="kobospan" id="kobo.752.1">Determine the number of features used in </span><span><span class="kobospan" id="kobo.753.1">the model.</span></span></li><li class="alphabets"><span class="kobospan" id="kobo.754.1">Determine the number of </span><span><span class="kobospan" id="kobo.755.1">participating clients.</span></span></li></ol></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.756.1">Define the supporting functions</span></strong><span class="kobospan" id="kobo.757.1">: Develop additional functions to load the data from clients, define the loss function, and evaluate the model’s performance. </span><span class="kobospan" id="kobo.757.2">These functions will help facilitate data handling, calculate the loss during training, and assess the </span><span><span class="kobospan" id="kobo.758.1">model’s accuracy.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.759.1">Choose the server-side strategy</span></strong><span class="kobospan" id="kobo.760.1">: Select the FedAvg algorithm as the strategy to aggregate the weights received from the clients. </span><span class="kobospan" id="kobo.760.2">FedAvg is a popular choice to combine model updates from multiple clients and generate an updated </span><span><span class="kobospan" id="kobo.761.1">global model.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.762.1">Start </span></strong><span><strong class="bold"><span class="kobospan" id="kobo.763.1">the server</span></strong></span><span><span class="kobospan" id="kobo.764.1">:</span></span><ol class="calibre20"><li class="alphabets"><span class="kobospan" id="kobo.765.1">Initiate the server-side</span><a id="_idIndexMarker549" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.766.1"> component, which will orchestrate the </span><span><span class="kobospan" id="kobo.767.1">FL process.</span></span></li><li class="alphabets"><span class="kobospan" id="kobo.768.1">The server will communicate with the participating clients, receive their model updates, and </span><a id="_idIndexMarker550" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.769.1">aggregate the weights using the </span><span><span class="kobospan" id="kobo.770.1">FedAvg algorithm.</span></span></li><li class="alphabets"><span class="kobospan" id="kobo.771.1">It will also </span><a id="_idIndexMarker551" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.772.1">handle the synchronization of the model updates between the clients and ensure the convergence of the </span><span><span class="kobospan" id="kobo.773.1">global model.</span></span></li></ol></li>
</ol>
<p class="calibre3"><span class="kobospan" id="kobo.774.1">By following these steps, we can implement the server-side functionality of our FL model. </span><span class="kobospan" id="kobo.774.2">The initialization of model parameters, definition of supporting functions, selection of the server-side strategy (FedAvg), and starting the server itself are crucial in facilitating the collaborative training process among the clients. </span><span class="kobospan" id="kobo.774.3">Through this implementation, the server will act as the central coordinator, receiving and aggregating the model updates from the clients. </span><span class="kobospan" id="kobo.774.4">It plays a crucial role in ensuring the model’s convergence and generating an updated global model that incorporates the knowledge from all </span><span><span class="kobospan" id="kobo.775.1">participating clients.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.776.1">Save the following code </span><span><span class="kobospan" id="kobo.777.1">as </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.778.1">FL_AML_Server.py</span></strong></span><span><span class="kobospan" id="kobo.779.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.780.1">
import pandas as pd
url ="PS_20174392719_1491204439457_log.csv"
df_actual = pd.read_csv(url, sep=",")
df_actual</span></pre>
<p class="calibre3"><span class="kobospan" id="kobo.781.1">This results in the </span><span><span class="kobospan" id="kobo.782.1">following output:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer088">
<span class="kobospan" id="kobo.783.1"><img alt="Figure 6.12 – Dataset information with few rows and columns" src="image/B16573_06_12.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.784.1">Figure 6.12 – Dataset information with few rows and columns</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.785.1">Instead of using all 6 million </span><a id="_idIndexMarker552" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.786.1">records, we will use </span><a id="_idIndexMarker553" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.787.1">only the first 25,000</span><a id="_idIndexMarker554" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.788.1"> records in this </span><span><span class="kobospan" id="kobo.789.1">example implementation:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.790.1">
df_transactions=df_actual.head(25000)
from sklearn.model_selection import train_test_split
from sklearn.model_selection import StratifiedShuffleSplit
print("No of Fraud Transactions:",
df_transactions["isFraud"].value_counts()[0])
print("No of Non Fraud Transactions:",
df_transactions["isFraud"].value_counts()[1])
print('No Frauds',
round(df_transactions['isFraud'].value_counts()[0]/len(df_t
ransactions) * 100,2), '% of the dataset')
print('Frauds',
round(df_transactions['isFraud'].value_counts()[1]/len(df_t
ransactions) * 100,2), '% of the dataset')</span></pre>
<p class="calibre3"><span class="kobospan" id="kobo.791.1">This results in the </span><span><span class="kobospan" id="kobo.792.1">following output:</span></span></p>
<pre class="console"><span class="kobospan1" id="kobo.793.1">
No of Fraud Transactions: 24917
No of Non Fraud Transactions: 83
No Frauds 99.67 % of the dataset
Frauds 0.33 % of the dataset</span></pre>
<p class="calibre3"><span class="kobospan" id="kobo.794.1">Let’s find the data</span><a id="_idIndexMarker555" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.795.1"> types of each field in </span><span><span class="kobospan" id="kobo.796.1">the</span></span><span><a id="_idIndexMarker556" class="pcalibre1 calibre6 pcalibre"/></span><span><span class="kobospan" id="kobo.797.1"> dataset:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.798.1">
df_transactions.dtypes</span></pre>
<p class="calibre3"><span class="kobospan" id="kobo.799.1">This results in the </span><a id="_idIndexMarker557" class="pcalibre1 calibre6 pcalibre"/><span><span class="kobospan" id="kobo.800.1">following output:</span></span></p>
<pre class="console"><span class="kobospan1" id="kobo.801.1">
step                int64
type               object
amount            float64
nameOrig           object
oldbalanceOrg     float64
newbalanceOrig    float64
nameDest           object
oldbalanceDest    float64
newbalanceDest    float64
isFraud             int64
isFlaggedFraud      int64
dtype: object</span></pre>
<p class="calibre3"><span class="kobospan" id="kobo.802.1">Encode the object data</span><a id="_idIndexMarker558" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.803.1"> type fields as labels </span><span><span class="kobospan" id="kobo.804.1">using </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.805.1">LabelEncoder</span></strong></span><span><span class="kobospan" id="kobo.806.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.807.1">
from sklearn.preprocessing import LabelEncoder
encoder = {}
for i in df_transactions.select_dtypes('object').columns:
    encoder[i] = LabelEncoder()
    df_transactions[i] = encoder[i].fit_transform(df_transactions[i])
X = df_transactions.drop('isFraud', axis=1)
y = df_transactions['isFraud'
from typing import Tuple, Union, List
import numpy as np
from sklearn.linear_model import LogisticRegression
XY = Tuple[np.ndarray, np.ndarray]
Dataset = Tuple[XY, XY]
LogRegParams = Union[XY, Tuple[np.ndarray]]
XYList = List[XY]
def get_model_parameters(model: LogisticRegression) -&gt; LogRegParams:
    if model.fit_intercept:
        params = [
            model.coef_,
            model.intercept_,
        ]
    else:
        params = [
            model.coef_,
        ]
    return params
def set_model_params(
    model: LogisticRegression, params: LogRegParams
) -&gt; LogisticRegression:
    model.coef_ = params[0]
    if model.fit_intercept:
        model.intercept_ = params[1]
    return model
def shuffle(X: np.ndarray, y: np.ndarray) -&gt; XY:
    rng = np.random.default_rng()
    idx = rng.permutation(len(X))
    return X[idx], y[idx]
def partition(X: np.ndarray, y: np.ndarray, num_partitions: int) -&gt; XYList:
    return list(
        zip(np.array_split(X, num_partitions), np.array_split(y, num_partitions))
    )
def set_initial_params(model: LogisticRegression):
    n_classes = 2  # Fraud Detection has only  classes
    n_features = 9  # Number of features in dataset
    model.classes_ = np.array([i for i in range(n_classes)])
    model.coef_ = np.zeros((n_classes, n_features))
    if model.fit_intercept:
        model.intercept_ = np.zeros((n_classes,))
import flwr as fl
from sklearn.metrics import log_loss
from sklearn.linear_model import LogisticRegression
from typing import Dict
def fit_round(server_round: int) -&gt; Dict:
    """Send round number to client."""
</span><span class="kobospan1" id="kobo.807.2">    return {"server_round": server_round}
def get_evaluate_fn(model: LogisticRegression,X_test,y_test):
# The `evaluate` function will be called after every round
    def evaluate(server_round, parameters: fl.common.NDArrays, config):
        # Update model with the latest parameters
        set_model_params(model, parameters)
        loss = log_loss(y_test, model.predict_proba(X_test))
        accuracy = model.score(X_test, y_test)
        return loss, {"accuracy": accuracy}
    return evaluate
# Start Flower server for five rounds of federated learning
def Server():
    model = LogisticRegression(max_iter=10000)
    set_initial_params(model)
    strategy = fl.server.strategy.FedAvg(
        min_available_clients=2,
        evaluate_fn=get_evaluate_fn(model,X_test,y_test),
        on_fit_config_fn=fit_round,
    )
    fl.server.start_server(
        server_address="0.0.0.0:8080",
        strategy=strategy,
        config=fl.server.ServerConfig(num_rounds=5),
    )
Server()</span></pre>
<p class="calibre3"><span class="kobospan" id="kobo.808.1">Open a terminal </span><a id="_idIndexMarker559" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.809.1">and run this program (</span><span><strong class="source-inline"><span class="kobospan" id="kobo.810.1">python3 FL_AML_Server.py</span></strong></span><span><span class="kobospan" id="kobo.811.1">)</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.812.1">This results</span><a id="_idIndexMarker560" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.813.1"> in the </span><span><span class="kobospan" id="kobo.814.1">following output:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer089">
<span class="kobospan" id="kobo.815.1"><img alt="Figure 6.13 – Server startup logs" src="image/B16573_06_13.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.816.1">Figure 6.13 – Server startup logs</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.817.1">Server will run and </span><a id="_idIndexMarker561" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.818.1">wait for data from clients </span><span><span class="kobospan" id="kobo.819.1">to process.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.820.1">The implementation of clients</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.821.1">The client-side implementation of the FL model for fraud detection involves the following steps. </span><span class="kobospan" id="kobo.821.2">We will utilize the provided </span><strong class="source-inline"><span class="kobospan" id="kobo.822.1">NumPyClient</span></strong><span class="kobospan" id="kobo.823.1"> from the Flower samples. </span><span class="kobospan" id="kobo.823.2">The steps are </span><span><span class="kobospan" id="kobo.824.1">as</span></span><span><a id="_idIndexMarker562" class="pcalibre1 calibre6 pcalibre"/></span><span><span class="kobospan" id="kobo.825.1"> follows:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.826.1">Load </span></strong><span><strong class="bold"><span class="kobospan" id="kobo.827.1">the data</span></strong></span><span><span class="kobospan" id="kobo.828.1">:</span></span><ol class="calibre20"><li class="alphabets"><span class="kobospan" id="kobo.829.1">Load the relevant data to train and test the fraud </span><span><span class="kobospan" id="kobo.830.1">detection model.</span></span></li><li class="alphabets"><span class="kobospan" id="kobo.831.1">Ensure the data is properly formatted and available </span><span><span class="kobospan" id="kobo.832.1">for processing.</span></span></li></ol></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.833.1">Split </span></strong><span><strong class="bold"><span class="kobospan" id="kobo.834.1">the data</span></strong></span><span><span class="kobospan" id="kobo.835.1">:</span></span><p class="calibre3"><span class="kobospan" id="kobo.836.1">Split the loaded data into training and testing sets. </span><span class="kobospan" id="kobo.836.2">This division allows you to evaluate the model’s performance on </span><span><span class="kobospan" id="kobo.837.1">unseen data.</span></span></p></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.838.1">Shuffle/partition </span></strong><span><strong class="bold"><span class="kobospan" id="kobo.839.1">the data</span></strong></span><span><span class="kobospan" id="kobo.840.1">:</span></span><ol class="calibre20"><li class="alphabets"><span class="kobospan" id="kobo.841.1">Shuffle or partition</span><a id="_idIndexMarker563" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.842.1"> the training data </span><span><span class="kobospan" id="kobo.843.1">into batches.</span></span></li><li class="alphabets"><span class="kobospan" id="kobo.844.1">Randomly select a partition for each round of communication with the server. </span><span class="kobospan" id="kobo.844.2">This </span><a id="_idIndexMarker564" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.845.1">ensures that different subsets of the training data are used in </span><span><span class="kobospan" id="kobo.846.1">each round.</span></span></li></ol></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.847.1">Create the linear </span></strong><span><strong class="bold"><span class="kobospan" id="kobo.848.1">regression model</span></strong></span><span><span class="kobospan" id="kobo.849.1">:</span></span><ol class="calibre20"><li class="alphabets"><span class="kobospan" id="kobo.850.1">Develop a simple linear regression model using the chosen framework (for </span><span><span class="kobospan" id="kobo.851.1">example, scikit-learn).</span></span></li><li class="alphabets"><span class="kobospan" id="kobo.852.1">Configure the model with appropriate settings for the fraud </span><span><span class="kobospan" id="kobo.853.1">detection task.</span></span></li></ol></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.854.1">Establish a connection with </span></strong><span><strong class="bold"><span class="kobospan" id="kobo.855.1">the server</span></strong></span><span><span class="kobospan" id="kobo.856.1">:</span></span><ol class="calibre20"><li class="alphabets"><span class="kobospan" id="kobo.857.1">Establish a connection with the server to send and receive </span><span><span class="kobospan" id="kobo.858.1">model weights.</span></span></li><li class="alphabets"><span class="kobospan" id="kobo.859.1">Utilize the provided communication protocol (for example, gRPC) to </span><span><span class="kobospan" id="kobo.860.1">exchange information.</span></span></li></ol></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.861.1">Train </span></strong><span><strong class="bold"><span class="kobospan" id="kobo.862.1">the model</span></strong></span><span><span class="kobospan" id="kobo.863.1">:</span></span><ol class="calibre20"><li class="alphabets"><span class="kobospan" id="kobo.864.1">Initialize the model with the initial weights received from </span><span><span class="kobospan" id="kobo.865.1">the server.</span></span></li><li class="alphabets"><span class="kobospan" id="kobo.866.1">Train the model </span><a id="_idIndexMarker565" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.867.1">using the client’s local data and the weights updated by the server for </span><span><span class="kobospan" id="kobo.868.1">each round.</span></span></li><li class="alphabets"><span class="kobospan" id="kobo.869.1">Apply appropriate optimization techniques (for example, gradient descent) to update the </span><span><span class="kobospan" id="kobo.870.1">model parameters.</span></span></li></ol></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.871.1">Test </span></strong><span><strong class="bold"><span class="kobospan" id="kobo.872.1">the model</span></strong></span><span><span class="kobospan" id="kobo.873.1">:</span></span><ol class="calibre20"><li class="alphabets"><span class="kobospan" id="kobo.874.1">Evaluate the trained model</span><a id="_idIndexMarker566" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.875.1"> using the testing data to assess </span><span><span class="kobospan" id="kobo.876.1">its performance.</span></span></li><li class="alphabets"><span class="kobospan" id="kobo.877.1">Calculate relevant</span><a id="_idIndexMarker567" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.878.1"> metrics such as accuracy, precision, recall, or </span><span><span class="kobospan" id="kobo.879.1">F1 score.</span></span></li><li class="alphabets"><span class="kobospan" id="kobo.880.1">Determine the model’s effectiveness in detecting </span><span><span class="kobospan" id="kobo.881.1">fraudulent transactions.</span></span></li></ol></li>
</ol>
<p class="calibre3"><span class="kobospan" id="kobo.882.1">By following these steps, we can implement the client-side functionality of the FL model. </span><span class="kobospan" id="kobo.882.2">The client will load and partition the data, create the linear regression model, establish a connection with the server, train the model using local data and updated weights, and evaluate its performance. </span><span class="kobospan" id="kobo.882.3">The client’s role is crucial in contributing local knowledge while preserving data privacy. </span><span class="kobospan" id="kobo.882.4">By training on their respective local data and participating in the FL process, clients collectively improve the global fraud detection model without sharing </span><span><span class="kobospan" id="kobo.883.1">sensitive information.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.884.1">Creating a non-IID dataset</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.885.1">To transform the </span><a id="_idIndexMarker568" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.886.1">dataset into a non-IID setting, we can apply the </span><span><span class="kobospan" id="kobo.887.1">following approach:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.888.1">First client (</span></strong><span><strong class="bold"><span class="kobospan" id="kobo.889.1">client 1)</span></strong></span><span><span class="kobospan" id="kobo.890.1">:</span></span><ul class="calibre16"><li class="calibre11"><span class="kobospan" id="kobo.891.1">Apply the </span><strong class="bold"><span class="kobospan" id="kobo.892.1">Synthetic Minority Oversampling Technique</span></strong><span class="kobospan" id="kobo.893.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.894.1">SMOTE</span></strong><span class="kobospan" id="kobo.895.1">) to oversample the </span><span><span class="kobospan" id="kobo.896.1">fraud </span></span><span><a id="_idIndexMarker569" class="pcalibre1 calibre6 pcalibre"/></span><span><span class="kobospan" id="kobo.897.1">transactions</span></span></li><li class="calibre11"><span class="kobospan" id="kobo.898.1">This technique generates synthetic examples of the minority class (fraudulent transactions) to balance </span><span><span class="kobospan" id="kobo.899.1">the dataset</span></span></li><li class="calibre11"><span class="kobospan" id="kobo.900.1">As a result, client 1 will have a training dataset with 50,000 samples, consisting of 25,000 original transactions and 25,000 synthetic fraud examples created </span><span><span class="kobospan" id="kobo.901.1">using SMOTE</span></span></li><li class="calibre11"><span class="kobospan" id="kobo.902.1">The distribution</span><a id="_idIndexMarker570" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.903.1"> of fraud versus non-fraud transactions will be balanced at 50% for </span><span><span class="kobospan" id="kobo.904.1">each class</span></span></li></ul></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.905.1">Second client (</span></strong><span><strong class="bold"><span class="kobospan" id="kobo.906.1">client 2)</span></strong></span><span><span class="kobospan" id="kobo.907.1">:</span></span><ul class="calibre16"><li class="calibre11"><span class="kobospan" id="kobo.908.1">Leave the transactions as they are without any oversampling </span><span><span class="kobospan" id="kobo.909.1">or modification</span></span></li><li class="calibre11"><span class="kobospan" id="kobo.910.1">Client 2 will have a training dataset with the last </span><span><span class="kobospan" id="kobo.911.1">25,000 transactions</span></span></li><li class="calibre11"><span class="kobospan" id="kobo.912.1">The class distribution will reflect the original distribution, with only 2% of the transactions classified </span><span><span class="kobospan" id="kobo.913.1">as fraud</span></span></li></ul></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.914.1">By employing this approach, we introduce non-identical and imbalanced datasets across the two clients. </span><span class="kobospan" id="kobo.914.2">Client 1 will </span><a id="_idIndexMarker571" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.915.1">have a balanced dataset with equal representation of fraud and non-fraud</span><a id="_idIndexMarker572" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.916.1"> transactions, while client 2 will have a dataset that mirrors the </span><span><span class="kobospan" id="kobo.917.1">original distribution.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.918.1">This non-IID setup allows us to simulate real-world scenarios where different clients may have varying distributions of data. </span><span class="kobospan" id="kobo.918.2">Through FL, both clients can contribute their local knowledge while training their models on distinct datasets, ultimately improving the overall fraud </span><span><span class="kobospan" id="kobo.919.1">detection model.</span></span></p>
<table class="no-table-style" id="table006-4">
<colgroup class="calibre12">
<col class="calibre13"/>
<col class="calibre13"/>
<col class="calibre13"/>
</colgroup>
<thead class="calibre18">
<tr class="no-table-style1">
<td class="no-table-style2"/>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.920.1">Client 1</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.921.1">Client 2</span></span></p>
</td>
</tr>
</thead>
<tbody class="calibre14">
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.922.1">Original transactions</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.923.1">25,000</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.924.1">25,000</span></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.925.1">Transactions generated </span><span><span class="kobospan" id="kobo.926.1">using SMOTE</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.927.1">25,000</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.928.1">0</span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.929.1">Total transactions</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.930.1">50,000</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.931.1">25,000</span></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.932.1">Fraud </span><span><span class="kobospan" id="kobo.933.1">versus non-fraud</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.934.1">50% </span><span><span class="kobospan" id="kobo.935.1">and 50%</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.936.1">Fraud: 2.43%</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.937.1">(</span><span><span class="kobospan" id="kobo.938.1">608)</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.939.1">Non-fraud: </span><span><span class="kobospan" id="kobo.940.1">97.57% (24,392)</span></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.941.1">Train and </span><span><span class="kobospan" id="kobo.942.1">test split</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.943.1">70:30</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.944.1">70:30</span></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.945.1">Number of partitions after shuffling the train data with equal size in </span><span><span class="kobospan" id="kobo.946.1">each partition</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.947.1">10</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.948.1">10</span></span></p>
</td>
</tr>
</tbody>
</table>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.949.1">Table 6.6 – Training data distribution on the client side as non-IID data</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.950.1">Here is</span><a id="_idIndexMarker573" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.951.1"> the code </span><a id="_idIndexMarker574" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.952.1">for client 1. </span><span class="kobospan" id="kobo.952.2">Save this</span><a id="_idIndexMarker575" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.953.1"> code </span><span><span class="kobospan" id="kobo.954.1">as </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.955.1">FL_AML_Client1.py</span></strong></span><span><span class="kobospan" id="kobo.956.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.957.1">
import pandas as pd
import torch
url ="PS_20174392719_1491204439457_log.csv"
df_actual = pd.read_csv(url, sep=",")
df_actual
df_transactions=df_actual.head(25000)
from sklearn.model_selection import train_test_split
from sklearn.model_selection import StratifiedShuffleSplit
print("No of Fraud Transactions:", df_transactions["isFraud"].value_counts()[0])
print("No of Non Fraud Transactions:", df_transactions["isFraud"].value_counts()[1])
print('No Frauds', round(df_transactions['isFraud'].value_counts()[0]/len(df_transactions) * 100,2), '% of the dataset')
print('Frauds', round(df_transactions['isFraud'].value_counts()[1]/len(df_transactions) * 100,2), '% of the dataset')</span></pre>
<p class="calibre3"><span class="kobospan" id="kobo.958.1">This results in the </span><span><span class="kobospan" id="kobo.959.1">following </span></span><span><a id="_idIndexMarker576" class="pcalibre1 calibre6 pcalibre"/></span><span><span class="kobospan" id="kobo.960.1">output:</span></span></p>
<pre class="console"><span class="kobospan1" id="kobo.961.1">
No of Fraud Transactions: 24917
No of Non Fraud Transactions: 83
No Frauds 99.67 % of the dataset
Frauds 0.33 % of the dataset</span></pre>
<p class="calibre3"><span class="kobospan" id="kobo.962.1">In this dataset, fraudulent transactions account for 0.33% of the total data, indicating a highly imbalanced</span><a id="_idIndexMarker577" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.963.1"> dataset. </span><span class="kobospan" id="kobo.963.2">This imbalance is typical in real-world scenarios, where fraud transactions are </span><a id="_idIndexMarker578" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.964.1">much less frequent compared to genuine (</span><span><span class="kobospan" id="kobo.965.1">non-fraud) transactions.</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.966.1">
df_transactions.dtypes</span></pre>
<p class="calibre3"><span class="kobospan" id="kobo.967.1">This results in the </span><span><span class="kobospan" id="kobo.968.1">following output:</span></span></p>
<pre class="console"><span class="kobospan1" id="kobo.969.1">
step                int64
type               object
amount            float64
nameOrig           object
oldbalanceOrg     float64
newbalanceOrig    float64
nameDest           object
oldbalanceDest    float64
newbalanceDest    float64
isFraud             int64
isFlaggedFraud      int64
dtype: object</span></pre>
<p class="calibre3"><span class="kobospan" id="kobo.970.1">Encode </span><a id="_idIndexMarker579" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.971.1">the object</span><a id="_idIndexMarker580" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.972.1"> types as labels using </span><a id="_idIndexMarker581" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.973.1">sci-kit </span><span><span class="kobospan" id="kobo.974.1">learn’s </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.975.1">LabelEncoder</span></strong></span><span><span class="kobospan" id="kobo.976.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.977.1">
from sklearn.preprocessing import LabelEncoder
encoder = {}
for i in df_transactions.select_dtypes('object').columns:
    encoder[i] = LabelEncoder()
    df_transactions[i] = encoder[i].fit_transform(df_transactions[i])
X = df_transactions.drop('isFraud', axis=1)
y = df_transactions['isFraud']</span></pre>
<p class="calibre3"><span class="kobospan" id="kobo.978.1">Apply SMOTE to generate </span><span><span class="kobospan" id="kobo.979.1">synthetic data:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.980.1">
from imblearn.over_sampling import SMOTE
over_sample = SMOTE(random_state=0)
X,y = over_sample.fit_resample(X,y)
y.value_counts()</span></pre>
<p class="calibre3"><span class="kobospan" id="kobo.981.1">This results in the </span><span><span class="kobospan" id="kobo.982.1">following output:</span></span></p>
<pre class="console"><span class="kobospan1" id="kobo.983.1">
0    24917
1    24917
Name: isFraud, dtype: int64
X = df_transactions[['step', 'type', 'amount','nameOrig', 'oldbalanceOrg', 'newbalanceOrig','nameDest', 'oldbalanceDest', 'isFlaggedFraud']]
y= df_transactions['isFraud']
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)
X_train = X_train.values
X_test = X_test.values
y_train = y_train.values
y_test = y_test.values
from typing import Tuple, Union, List
import numpy as np
from sklearn.linear_model import LogisticRegression
XY = Tuple[np.ndarray, np.ndarray]
Dataset = Tuple[XY, XY]
LogRegParams = Union[XY, Tuple[np.ndarray]]
XYList = List[XY]
def get_model_parameters(model: LogisticRegression) -&gt; LogRegParams:
    if model.fit_intercept:
        params = [
            model.coef_,
            model.intercept_,
        ]
    else:
        params = [
            model.coef_,
        ]
    return params
def set_model_params(
    model: LogisticRegression, params: LogRegParams
) -&gt; LogisticRegression:
    model.coef_ = params[0]
    if model.fit_intercept:
        model.intercept_ = params[1]
    return model
def shuffle(X: np.ndarray, y: np.ndarray) -&gt; XY:
    rng = np.random.default_rng()
    idx = rng.permutation(len(X))
    return X[idx], y[idx]
def partition(X: np.ndarray, y: np.ndarray, num_partitions: int) -&gt; XYList:
    return list(
        zip(np.array_split(X, num_partitions), np.array_split(y, num_partitions))
    )
def set_initial_params(model: LogisticRegression):
    n_classes = 2  # only 2 classes  Fraud or Genuine
    n_features = 9  # Number of features in dataset
    model.classes_ = np.array([i for i in range(n_classes)])
    model.coef_ = np.zeros((n_classes, n_features))
    if model.fit_intercept:
        model.intercept_ = np.zeros((n_classes,))
partition_id = np.random.choice(10)
(X_train, y_train) = partition(X_train, y_train, 10)[partition_id]
from sklearn.linear_model import LogisticRegression
model = LogisticRegression(
        penalty="l2",
        max_iter=1,  # local epoch
        warm_start=True,  # prevent refreshing weights when fitting
    )
model.fit(X_train, y_train)
class AML_Detection_Client(fl.client.NumPyClient):
        def get_parameters(self, config):
            return get_model_parameters(model)
        def fit(self, parameters, config):
            set_model_params(model, parameters)
            with warnings.catch_warnings():
                warnings.simplefilter("ignore")
                model.fit(X_train, y_train)
            print(f"Training finished for round {config['server_round']}")
            return get_model_parameters(model), len(X_train), {}
        def evaluate(self, parameters, config):
            set_model_params(model, parameters)
            loss = log_loss(y_test, model.predict_proba(X_test))
            accuracy = model.score(X_test, y_test)
            print(loss,accuracy)
            return loss, len(X_test), {"accuracy": accuracy}
fl.client.start_numpy_client(server_address="0.0.0.0:8080", client=AML_Detection_Client())</span></pre>
<p class="calibre3"><span class="kobospan" id="kobo.984.1">Open a </span><a id="_idIndexMarker582" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.985.1">second terminal and </span><a id="_idIndexMarker583" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.986.1">run the client 1 code (</span><span><strong class="source-inline"><span class="kobospan" id="kobo.987.1">python3 FL_AML_Client1.py</span></strong></span><span><span class="kobospan" id="kobo.988.1">)</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.989.1">This results in the </span><span><span class="kobospan" id="kobo.990.1">following output:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer090">
<span class="kobospan" id="kobo.991.1"><img alt="Figure 6.14 – The execution of client 1 and the logs" src="image/B16573_06_14.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.992.1">Figure 6.14 – The execution of client 1 and the logs</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.993.1">Now, let’s look at the code for client 2. </span><span class="kobospan" id="kobo.993.2">Save this code as </span><strong class="source-inline"><span class="kobospan" id="kobo.994.1">FL_AML_Client2.py</span></strong><span class="kobospan" id="kobo.995.1">. </span><span class="kobospan" id="kobo.995.2">The client 2 code will be the</span><a id="_idIndexMarker584" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.996.1"> same as client 1, but fraud transactions are not increased using the SMOTE method. </span><span class="kobospan" id="kobo.996.2">For thoroughness, here is</span><a id="_idIndexMarker585" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.997.1"> the complete code for the</span><a id="_idIndexMarker586" class="pcalibre1 calibre6 pcalibre"/> <span><span class="kobospan" id="kobo.998.1">second client:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.999.1">
import pandas as pd
import torch
url ="PS_20174392719_1491204439457_log.csv"
df_actual = pd.read_csv(url, sep=",")
df_actual
df_transactions=df_actual.head(25000)
from sklearn.model_selection import train_test_split
ffrom sklearn.model_selection import StratifiedShuffleSplit
print("No of Fraud Transactions:", df_transactions["isFraud"].value_counts()[0])
print("No of Non Fraud Transactions:", df_transactions["isFraud"].value_counts()[1])
print('No Frauds', round(df_transactions['isFraud'].value_counts()[0]/len(df_transactions) * 100,2), '% of the dataset')
print('Frauds', round(df_transactions['isFraud'].value_counts()[1]/len(df_transactions) * 100,2), '% of the dataset')</span></pre>
<p class="calibre3"><span class="kobospan" id="kobo.1000.1">This results in the </span><span><span class="kobospan" id="kobo.1001.1">following output:</span></span></p>
<pre class="console"><span class="kobospan1" id="kobo.1002.1">
No of Fraud Transactions: 24917
No of Non Fraud Transactions: 83
No Frauds 99.67 % of the dataset
Frauds 0.33 % of the dataset
df_transactions.dtypes
step                int64
type               object
amount            float64
nameOrig           object
oldbalanceOrg     float64
newbalanceOrig    float64
nameDest           object
oldbalanceDest    float64
newbalanceDest    float64
isFraud             int64
isFlaggedFraud      int64
dtype: object</span></pre>
<p class="calibre3"><span class="kobospan" id="kobo.1003.1">Encode the object </span><a id="_idIndexMarker587" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.1004.1">types as </span><a id="_idIndexMarker588" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.1005.1">labels using </span><a id="_idIndexMarker589" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.1006.1">sci-kit </span><span><span class="kobospan" id="kobo.1007.1">learn’s </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.1008.1">LabelEncoder</span></strong></span><span><span class="kobospan" id="kobo.1009.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.1010.1">
from sklearn.preprocessing import LabelEncoder
encoder = {}
for i in df_transactions.select_dtypes('object').columns:
    encoder[i] = LabelEncoder()
    df_transactions[i] = encoder[i].fit_transform(df_transactions[i])
X = df_transactions.drop('isFraud', axis=1)
y = df_transactions['isFraud']
y.value_counts()</span></pre>
<p class="calibre3"><span class="kobospan" id="kobo.1011.1">This</span><a id="_idIndexMarker590" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.1012.1"> results in the</span><a id="_idIndexMarker591" class="pcalibre1 calibre6 pcalibre"/> <span><span class="kobospan" id="kobo.1013.1">following</span></span><span><a id="_idIndexMarker592" class="pcalibre1 calibre6 pcalibre"/></span><span><span class="kobospan" id="kobo.1014.1"> output:</span></span></p>
<pre class="console"><span class="kobospan1" id="kobo.1015.1">
0    24392
1      608
Name: isFraud, dtype: int64
X = df_transactions[['step', 'type', 'amount','nameOrig', 'oldbalanceOrg', 'newbalanceOrig','nameDest', 'oldbalanceDest', 'isFlaggedFraud']]
y= df_transactions['isFraud']
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)
X_train = X_train.values
X_test = X_test.values
y_train = y_train.values
y_test = y_test.values
from typing import Tuple, Union, List
import numpy as np
from sklearn.linear_model import LogisticRegression
XY = Tuple[np.ndarray, np.ndarray]
Dataset = Tuple[XY, XY]
LogRegParams = Union[XY, Tuple[np.ndarray]]
XYList = List[XY]
def get_model_parameters(model: LogisticRegression) -&gt; LogRegParams:
    if model.fit_intercept:
        params = [
            model.coef_,
            model.intercept_,
        ]
    else:
        params = [
            model.coef_,
        ]
    return params
def set_model_params(
    model: LogisticRegression, params: LogRegParams
) -&gt; LogisticRegression:
    model.coef_ = params[0]
    if model.fit_intercept:
        model.intercept_ = params[1]
    return model
def shuffle(X: np.ndarray, y: np.ndarray) -&gt; XY:
    rng = np.random.default_rng()
    idx = rng.permutation(len(X))
    return X[idx], y[idx]
def partition(X: np.ndarray, y: np.ndarray, num_partitions: int) -&gt; XYList:
    return list(
        zip(np.array_split(X, num_partitions), np.array_split(y, num_partitions))
    )
def set_initial_params(model: LogisticRegression):
    n_classes = 2  # only 2 classes  Fraud or Geninue
    n_features = 9  # Number of features in dataset
    model.classes_ = np.array([i for i in range(n_classes)])
    model.coef_ = np.zeros((n_classes, n_features))
    if model.fit_intercept:
        model.intercept_ = np.zeros((n_classes,))
partition_id = np.random.choice(10)
(X_train, y_train) = partition(X_train, y_train, 10)[partition_id]
from sklearn.linear_model import LogisticRegression
model = LogisticRegression(
        penalty="l2",
        max_iter=1,  # local epoch
        warm_start=True,  # prevent refreshing weights when fitting
    )
model.fit(X_train, y_train)
class AML_Detection_Client(fl.client.NumPyClient):
        def get_parameters(self, config):
            return get_model_parameters(model)
        def fit(self, parameters, config):
            set_model_params(model, parameters)
            with warnings.catch_warnings():
                warnings.simplefilter("ignore")
                model.fit(X_train, y_train)
            print(f"Training finished for round {config['server_round']}")
            return get_model_parameters(model), len(X_train), {}
        def evaluate(self, parameters, config):
            set_model_params(model, parameters)
            loss = log_loss(y_test, model.predict_proba(X_test))
            accuracy = model.score(X_test, y_test)
            print(loss,accuracy)
            return loss, len(X_test), {"accuracy": accuracy}
fl.client.start_numpy_client(server_address="0.0.0.0:8080", client=AML_Detection_Client())</span></pre>
<p class="calibre3"><span class="kobospan" id="kobo.1016.1">Open another</span><a id="_idIndexMarker593" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.1017.1"> terminal and run the client </span><a id="_idIndexMarker594" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.1018.1">2 code (</span><span><strong class="source-inline"><span class="kobospan" id="kobo.1019.1">python3 FL_AML_Client2.py</span></strong></span><span><span class="kobospan" id="kobo.1020.1">):</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer091">
<span class="kobospan" id="kobo.1021.1"><img alt="Figure 6.15 – Running client 2 and the logs" src="image/B16573_06_15.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.1022.1">Figure 6.15 – Running client 2 and the logs</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1023.1">Once you run the client </span><a id="_idIndexMarker595" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.1024.1">2 code, pay close attention</span><a id="_idIndexMarker596" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.1025.1"> to the log statements on </span><a id="_idIndexMarker597" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.1026.1">the server side. </span><span class="kobospan" id="kobo.1026.2">The server will initiate communication with both clients, enabling the exchange of the initial parameters and, subsequently, the updated weights for each round. </span><span class="kobospan" id="kobo.1026.3">Monitoring </span><a id="_idIndexMarker598" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.1027.1">the server logs will provide insights into the progress of the FL </span><a id="_idIndexMarker599" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.1028.1">process and the </span><a id="_idIndexMarker600" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.1029.1">information shared between the clients and </span><span><span class="kobospan" id="kobo.1030.1">the server:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer092">
<span class="kobospan" id="kobo.1031.1"><img alt="Figure 6.16 – The server-side logs" src="image/B16573_06_16.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.1032.1">Figure 6.16 – The server-side logs</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1033.1">Observe the logs on both clients as well as the server side. </span><span class="kobospan" id="kobo.1033.2">These metrics provide an overview of the loss (indicating</span><a id="_idIndexMarker601" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.1034.1"> the model’s performance) and accuracy (representing</span><a id="_idIndexMarker602" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.1035.1"> the model’s</span><a id="_idIndexMarker603" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.1036.1"> correctness) for each client across multiple rounds of the </span><span><span class="kobospan" id="kobo.1037.1">FL process:</span></span></p>
<table class="no-table-style" id="table007-3">
<colgroup class="calibre12">
<col class="calibre13"/>
<col class="calibre13"/>
<col class="calibre13"/>
</colgroup>
<thead class="calibre18">
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><strong class="bold"><span class="kobospan" id="kobo.1038.1">Server</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><strong class="bold"><span class="kobospan" id="kobo.1039.1">Client 1</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><strong class="bold"><span class="kobospan" id="kobo.1040.1">Client 2</span></strong></span></p>
</td>
</tr>
</thead>
<tbody class="calibre14">
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.1041.1">INFO flwr 2023-03-14 17:46:49,202 | app.py:139 | Starting Flower server, config: </span><span><span class="kobospan" id="kobo.1042.1">ServerConfig(num_rounds=5, round_</span></span>
<span><span class="kobospan" id="kobo.1043.1">timeout=None)</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1044.1">INFO flwr 2023-03-14 17:51:21,810 | server.py:101 | </span><span><span class="kobospan" id="kobo.1045.1">FL starting</span></span></p>
</td>
<td class="no-table-style2"/>
<td class="no-table-style2"/>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2"/>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.1046.1">DEBUG flwr 2023-03-14 17:51:21,778 | connection.py:38 | </span><span><span class="kobospan" id="kobo.1047.1">ChannelConnectivity.READY</span></span></p>
</td>
<td class="no-table-style2"/>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2"/>
<td class="no-table-style2"/>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.1048.1">ChannelConnectivity. </span><span class="kobospan" id="kobo.1048.2">DEBUG flwr 2023-03-14 17:53:46,338 | connection.py:38 | </span><span><span class="kobospan" id="kobo.1049.1">ChannelConnectivity.READY</span></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.1050.1">DEBUG flwr 2023-03-14 17:53:46,338 | server.py:215 | fit_round 1: strategy sampled 2 clients (out </span><span><span class="kobospan" id="kobo.1051.1">of 2)</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1052.1">DEBUG flwr 2023-03-14 17:53:46,351 | server.py:229 | fit_round 1 received 2 results and </span><span><span class="kobospan" id="kobo.1053.1">0 failures</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1054.1">WARNING flwr 2023-03-14 17:53:46,354 | fedavg.py:242 | No </span><span><span class="kobospan" id="kobo.1055.1">fit_metrics_aggregation_fn provided</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1056.1">INFO flwr 2023-03-14 17:53:46,362 | server.py:116 | fit progress: (1, 0.06756539217831908, {‘accuracy’: </span><span><span class="kobospan" id="kobo.1057.1">0.9962666666666666}, 144.549737353)</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1058.1">DEBUG flwr 2023-03-14 17:53:46,363 | server.py:165 | evaluate_round 1: strategy sampled 2 clients (out </span><span><span class="kobospan" id="kobo.1059.1">of 2)</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1060.1">DEBUG flwr 2023-03-14 17:53:46,377 | server.py:179 | evaluate_round 1 received 2 results and </span><span><span class="kobospan" id="kobo.1061.1">0 failures</span></span></p>
</td>
<td class="no-table-style2"/>
<td class="no-table-style2"/>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.1062.1">INFO flwr 2023-03-14 17:53:46,400 | server.py:116 | fit progress: (2, 0.40485776608772656, {‘accuracy’: </span><span><span class="kobospan" id="kobo.1063.1">0.9633333333333334}, 144.58791799899996)</span></span></p>
</td>
<td class="no-table-style2"/>
<td class="no-table-style2"/>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.1064.1">INFO flwr 2023-03-14 17:53:46,432 | server.py:116 | fit progress: (3, 0.11833075507570899, {‘accuracy’: </span><span><span class="kobospan" id="kobo.1065.1">0.9962666666666666}, 144.61946266499996)</span></span></p>
</td>
<td class="no-table-style2"/>
<td class="no-table-style2"/>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.1066.1">INFO flwr 2023-03-14 17:53:46,465 | server.py:116 | fit progress: (4, 0.1145626928425223, {‘accuracy’: </span><span><span class="kobospan" id="kobo.1067.1">0.9962666666666666}, 144.65267561899998)</span></span></p>
</td>
<td class="no-table-style2"/>
<td class="no-table-style2"/>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.1068.1">INFO flwr 2023-03-14 17:53:46,497 | server.py:116 | fit progress: (5, 0.27867744042157033, {‘accuracy’: </span><span><span class="kobospan" id="kobo.1069.1">0.9861333333333333}, 144.68508043599996)</span></span></p>
</td>
<td class="no-table-style2"/>
<td class="no-table-style2"/>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.1070.1">INFO flwr 2023-03-14 17:53:46,511 | app.py:202 | app_fit: losses_distributed [(1, 0.4398987330496311), (2, 0.4606742262840271), (3, 0.5105149038136005), (4, 0.5070083439350128), (</span><span><span class="kobospan" id="kobo.1071.1">5, 0.5951354652643204)]</span></span></p>
</td>
<td class="no-table-style2"/>
<td class="no-table-style2"/>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2"/>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.1072.1">Training finished for </span><span><span class="kobospan" id="kobo.1073.1">round 1:</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1074.1">0.06756539217831908 </span><span><span class="kobospan" id="kobo.1075.1">0.9962666666666666</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1076.1">Training finished for </span><span><span class="kobospan" id="kobo.1077.1">round 2:</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1078.1">0.40485776608772656 </span><span><span class="kobospan" id="kobo.1079.1">0.9633333333333334</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1080.1">Training finished for </span><span><span class="kobospan" id="kobo.1081.1">round 3:</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1082.1">0.11833075507570899 </span><span><span class="kobospan" id="kobo.1083.1">0.9962666666666666</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1084.1">Training finished for </span><span><span class="kobospan" id="kobo.1085.1">round 4:</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1086.1">0.1145626928425223 </span><span><span class="kobospan" id="kobo.1087.1">0.9962666666666666</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1088.1">Training finished for </span><span><span class="kobospan" id="kobo.1089.1">round 5:</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1090.1">0.27867744042157033 </span><span><span class="kobospan" id="kobo.1091.1">0.9861333333333333</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.1092.1">Training finished for </span><span><span class="kobospan" id="kobo.1093.1">round 1:</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1094.1">0.8122320748323023 </span><span><span class="kobospan" id="kobo.1095.1">0.9745333333333334</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1096.1">Training finished for </span><span><span class="kobospan" id="kobo.1097.1">round 2:</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1098.1">0.5164906830160562 </span><span><span class="kobospan" id="kobo.1099.1">0.9541333333333334</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1100.1">Training finished for </span><span><span class="kobospan" id="kobo.1101.1">round 3:</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1102.1">0.9026990471833415 </span><span><span class="kobospan" id="kobo.1103.1">0.9745333333333334</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1104.1">Training finished for </span><span><span class="kobospan" id="kobo.1105.1">round 4:</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1106.1">0.8994540131249842 </span><span><span class="kobospan" id="kobo.1107.1">0.9745333333333334</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1108.1">Training finished for </span><span><span class="kobospan" id="kobo.1109.1">round 5:</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1110.1">0.9115935132282235 </span><span><span class="kobospan" id="kobo.1111.1">0.9736</span></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2"/>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.1112.1">DEBUG flwr 2023-03-14 17:53:46,521 | connection.py:109 | gRPC </span><span><span class="kobospan" id="kobo.1113.1">channel closed</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1114.1">INFO flwr 2023-03-14 17:53:46,522 | app.py:153 | Disconnect and </span><span><span class="kobospan" id="kobo.1115.1">shut down</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.1116.1">DEBUG flwr 2023-03-14 17:53:46,521 | connection.py:109 | gRPC </span><span><span class="kobospan" id="kobo.1117.1">channel closed</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1118.1">INFO flwr 2023-03-14 17:53:46,522 | app.py:153 | Disconnect and </span><span><span class="kobospan" id="kobo.1119.1">shut down</span></span></p>
</td>
</tr>
</tbody>
</table>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.1120.1">Table 6.8 – Log data at Server and Clients</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1121.1">As per the log, there</span><a id="_idIndexMarker604" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.1122.1"> are 5 rounds of communication </span><a id="_idIndexMarker605" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.1123.1">between clients </span><a id="_idIndexMarker606" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.1124.1">and the server, and in each round, accuracy results and loss change based on </span><span><span class="kobospan" id="kobo.1125.1">the weights.</span></span></p>
<table class="no-table-style" id="table008-2">
<colgroup class="calibre12">
<col class="calibre13"/>
<col class="calibre13"/>
<col class="calibre13"/>
</colgroup>
<thead class="calibre18">
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><strong class="bold"><span class="kobospan" id="kobo.1126.1">Client 1</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><strong class="bold"><span class="kobospan" id="kobo.1127.1">Loss</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><strong class="bold"><span class="kobospan" id="kobo.1128.1">Accuracy</span></strong></span></p>
</td>
</tr>
</thead>
<tbody class="calibre14">
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.1129.1">Round 1</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.1130.1">0.06756539217831908</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.1131.1">0.9962666666666666</span></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.1132.1">Round 2</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.1133.1">0.40485776608772656</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.1134.1">0.9633333333333334</span></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.1135.1">Round 3</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.1136.1">0.11833075507570899</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.1137.1">0.9962666666666666</span></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.1138.1">Round 4</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.1139.1">0.1145626928425223</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.1140.1">0.9962666666666666</span></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.1141.1">Round 5</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.1142.1">0.27867744042157033</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.1143.1">0.9861333333333333</span></span></p>
</td>
</tr>
</tbody>
</table>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.1144.1">Table 6.9 – Accuracy and Loss metrics at Client 1</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1145.1">As per the debug logs, loss </span><a id="_idIndexMarker607" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.1146.1">and accuracy vary on client 1. </span><span class="kobospan" id="kobo.1146.2">Let’s observe the loss and accuracy results on Client 2 </span><span><span class="kobospan" id="kobo.1147.1">as well.</span></span></p>
<table class="no-table-style" id="table009-2">
<colgroup class="calibre12">
<col class="calibre13"/>
<col class="calibre13"/>
<col class="calibre13"/>
</colgroup>
<thead class="calibre18">
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><strong class="bold"><span class="kobospan" id="kobo.1148.1">Client 2</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><strong class="bold"><span class="kobospan" id="kobo.1149.1">Loss</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><strong class="bold"><span class="kobospan" id="kobo.1150.1">Accuracy</span></strong></span></p>
</td>
</tr>
</thead>
<tbody class="calibre14">
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.1151.1">Round 1</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.1152.1">0.8122320748323023</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.1153.1">0.9745333333333334</span></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.1154.1">Round 2</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.1155.1">0.5164906830160562</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.1156.1">0.9541333333333334</span></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.1157.1">Round 3</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.1158.1">0.9026990471833415</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.1159.1">0.9745333333333334</span></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.1160.1">Round 4</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.1161.1">0.8994540131249842</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.1162.1">0.9745333333333334</span></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.1163.1">Round 5</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.1164.1">0.9115935132282235</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.1165.1">0.9736</span></span></p>
</td>
</tr>
</tbody>
</table>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.1166.1">Table 6.10 – Accuracy and Loss metrics at Client 2</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1167.1">We have implemented a sample fraud detection application using Federated Learning and made use of open-source frameworks like Flower. </span><span class="kobospan" id="kobo.1167.2">In the next section, let’s try to learn and implement federated learning using </span><span><span class="kobospan" id="kobo.1168.1">differential privacy.</span></span></p>
<h1 id="_idParaDest-128" class="calibre5"><a id="_idTextAnchor136" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.1169.1">FL with differential privacy</span></h1>
<p class="calibre3"><strong class="bold"><span class="kobospan" id="kobo.1170.1">Federated Learning with Differential Privacy</span></strong><span class="kobospan" id="kobo.1171.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.1172.1">FL-DP</span></strong><span class="kobospan" id="kobo.1173.1">) is an approach that combines the</span><a id="_idIndexMarker608" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.1174.1"> principles of FL and </span><strong class="bold"><span class="kobospan" id="kobo.1175.1">Differential Privacy</span></strong><span class="kobospan" id="kobo.1176.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.1177.1">DP</span></strong><span class="kobospan" id="kobo.1178.1">) to ensure privacy and security in distributed ML </span><a id="_idIndexMarker609" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.1179.1">systems. </span><span class="kobospan" id="kobo.1179.2">FL-DP aims to protect sensitive data while enabling collaborative model training across multiple devices </span><span><span class="kobospan" id="kobo.1180.1">or entities.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1181.1">The goal of FL-DP is to achieve accurate model training without compromising the privacy of individual data contributors. </span><span class="kobospan" id="kobo.1181.2">It addresses the challenge of preventing data leakage during the aggregation of model updates from different participants. </span><span class="kobospan" id="kobo.1181.3">By incorporating DP techniques, FL-DP provides strong privacy guarantees by adding noise or perturbation to the model updates or gradients before </span><span><span class="kobospan" id="kobo.1182.1">aggregating them.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1183.1">There are different approaches to implementing FL-DP. </span><span class="kobospan" id="kobo.1183.2">One common approach involves each client training a local ML model using their own data. </span><span class="kobospan" id="kobo.1183.3">The client applies techniques such as clipping and noise addition to the gradients or weights of the model. </span><span class="kobospan" id="kobo.1183.4">The client then sends the updated data to the server. </span><span class="kobospan" id="kobo.1183.5">On the server side, the updates are aggregated while preserving privacy using techniques such as secure aggregation or privacy-preserving FL </span><a id="_idIndexMarker610" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.1184.1">algorithms. </span><span class="kobospan" id="kobo.1184.2">This ensures that individual client data remains private while enabling collaborative </span><span><span class="kobospan" id="kobo.1185.1">model training.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1186.1">FL-DP algorithms may vary depending on the specific differential privacy mechanisms used, such as Gaussian noise </span><a id="_idIndexMarker611" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.1187.1">addition, subsampling, or advanced techniques such as </span><strong class="bold"><span class="kobospan" id="kobo.1188.1">Private Aggregation of Teacher Ensembles</span></strong><span class="kobospan" id="kobo.1189.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.1190.1">PATE</span></strong><span class="kobospan" id="kobo.1191.1">). </span><span class="kobospan" id="kobo.1191.2">The choice of techniques depends on the level of privacy required and the characteristics of the </span><span><span class="kobospan" id="kobo.1192.1">distributed dataset.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1193.1">Implementing FL-DP requires careful consideration of privacy, accuracy, and computational overhead. </span><span class="kobospan" id="kobo.1193.2">It involves striking a balance between preserving privacy and maintaining model utility. </span><span class="kobospan" id="kobo.1193.3">Various frameworks and libraries, such as Flower and TensorFlow Privacy, provide tools and techniques to facilitate the implementation </span><span><span class="kobospan" id="kobo.1194.1">of FL-DP.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1195.1">FL-DP has the potential to unlock the benefits of collaborative ML in scenarios where data privacy and security are paramount. </span><span class="kobospan" id="kobo.1195.2">By preserving privacy, FL-DP enables organizations and individuals to collaborate on model training while safeguarding </span><span><span class="kobospan" id="kobo.1196.1">sensitive information.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1197.1">FL-DP provides a way to implement privacy-preserving techniques in the FL process, ensuring that client-side data </span><span><span class="kobospan" id="kobo.1198.1">remains protected.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1199.1">In this section, we will explore two general approaches to implementing FL-DP, although specific frameworks and implementations</span><a id="_idIndexMarker612" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.1200.1"> may have </span><span><span class="kobospan" id="kobo.1201.1">slight variations.</span></span></p>
<h2 id="_idParaDest-129" class="calibre7"><a id="_idTextAnchor137" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.1202.1">Approach one</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.1203.1">This approach shares similarities with </span><strong class="bold"><span class="kobospan" id="kobo.1204.1">Differentially Private Federated Averaging</span></strong><span class="kobospan" id="kobo.1205.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.1206.1">DP-FedAvg</span></strong><span class="kobospan" id="kobo.1207.1">), which was introduced by the </span><a id="_idIndexMarker613" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.1208.1">Google research team. </span><span class="kobospan" id="kobo.1208.2">By following these approaches, FL-DP allows you to train ML models on client data while preserving privacy through techniques such as</span><a id="_idIndexMarker614" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.1209.1"> clipping and </span><span><span class="kobospan" id="kobo.1210.1">noise addition.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1211.1">Each client does </span><span><span class="kobospan" id="kobo.1212.1">the following:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.1213.1">Trains an ML/DL model using its </span><span><span class="kobospan" id="kobo.1214.1">local data.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.1215.1">Computes gradients/weights using a standard </span><span><span class="kobospan" id="kobo.1216.1">SGD algorithm.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.1217.1">Applies clipping to the weights to limit </span><span><span class="kobospan" id="kobo.1218.1">their sensitivity.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.1219.1">Adds noise to the weights to introduce randomness </span><span><span class="kobospan" id="kobo.1220.1">and privacy.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.1221.1">Sends the modified weights to </span><span><span class="kobospan" id="kobo.1222.1">the server.</span></span></li>
</ol>
<p class="calibre3"><span class="kobospan" id="kobo.1223.1">The server does </span><span><span class="kobospan" id="kobo.1224.1">the following:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.1225.1">Computes the average of the weights received from </span><span><span class="kobospan" id="kobo.1226.1">each client.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.1227.1">Broadcasts back the updated weights to </span><span><span class="kobospan" id="kobo.1228.1">the clients.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.1229.1">Alternatively to step 1, applies clipping and adds noise to the final weights </span><span><span class="kobospan" id="kobo.1230.1">before broadcasting.</span></span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer093">
<span class="kobospan" id="kobo.1231.1"><img alt="Figure 6.17 – The DP-FedAvg model weights exchanged with the server" src="image/B16573_06_17.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.1232.1">Figure 6.17 – The DP-FedAvg model weights exchanged with the server</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1233.1">In this approach, each client trains</span><a id="_idIndexMarker615" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.1234.1"> its model on local data and work on the updated average weights sent by </span><span><span class="kobospan" id="kobo.1235.1">the server.</span></span></p>
<h2 id="_idParaDest-130" class="calibre7"><a id="_idTextAnchor138" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.1236.1">Approach two</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.1237.1">In this approach, each client trains its model on local data and applies privacy-preserving techniques to compute the gradients/weights. </span><span class="kobospan" id="kobo.1237.2">The server then incorporates these noisy weights and performs aggregation using the FD-SGD algorithm, ensuring privacy is maintained throughout the </span><span><span class="kobospan" id="kobo.1238.1">FL process.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1239.1">Each client does </span><span><span class="kobospan" id="kobo.1240.1">the following:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.1241.1">Trains an ML model using its </span><span><span class="kobospan" id="kobo.1242.1">local data.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.1243.1">Computes the gradients/weights using either noisy SGD or DP-SGD (DP stochastic gradient) algorithms, which incorporate noise during gradient computation to </span><span><span class="kobospan" id="kobo.1244.1">preserve privacy.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.1245.1">Sends the weights to </span><span><span class="kobospan" id="kobo.1246.1">the server.</span></span></li>
</ol>
<p class="calibre3"><span class="kobospan" id="kobo.1247.1">The server does </span><span><span class="kobospan" id="kobo.1248.1">the following:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.1249.1">Utilizes the noisy weights received from </span><span><span class="kobospan" id="kobo.1250.1">the clients.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.1251.1">Follows the </span><strong class="bold"><span class="kobospan" id="kobo.1252.1">Federated Differential SGD</span></strong><span class="kobospan" id="kobo.1253.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.1254.1">FD-SGD</span></strong><span class="kobospan" id="kobo.1255.1">) algorithm, which incorporates </span><a id="_idIndexMarker616" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.1256.1">privacy-preserving techniques during the aggregation process on </span><span><span class="kobospan" id="kobo.1257.1">the server.</span></span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer094">
<span class="kobospan" id="kobo.1258.1"><img alt="Figure 6.18 – The DP-FedSGD model weights exchanged with the server" src="image/B16573_06_18.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.1259.1">Figure 6.18 – The DP-FedSGD model weights exchanged with the server</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1260.1">There are various variants of Differential Privacy Federated Learning (FL-DP) algorithms designed to address different scenarios, such as cross-device and cross-silo FL, with both homogeneous and heterogeneous </span><a id="_idIndexMarker617" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.1261.1">data. </span><span class="kobospan" id="kobo.1261.2">In our implementation, we will apply FL-DP to the same example as before, ensuring privacy preservation throughout the </span><span><span class="kobospan" id="kobo.1262.1">FL process.</span></span></p>
<h2 id="_idParaDest-131" class="calibre7"><a id="_idTextAnchor139" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.1263.1">A sample application using FL-DP</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.1264.1">At the time of writing, the Flower framework (version 1.3) currently offers experimental support for FL-DP. </span><span class="kobospan" id="kobo.1264.2">It provides a</span><a id="_idIndexMarker618" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.1265.1"> strategy class (similar to FedAvg, FedYogi, and so on) specifically designed to support FL-DP. </span><span class="kobospan" id="kobo.1265.2">The class name designed to support this </span><span><span class="kobospan" id="kobo.1266.1">is </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.1267.1">DPFedAvg</span></strong></span><span><span class="kobospan" id="kobo.1268.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1269.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.1270.1">DPFedAvg</span></strong><span class="kobospan" id="kobo.1271.1"> class in the Flower framework is a component specifically designed to support FL-DP. </span><span class="kobospan" id="kobo.1271.2">It extends the functionality of the FedAvg algorithm by incorporating differential privacy techniques to protect the privacy of individual client data during </span><span><span class="kobospan" id="kobo.1272.1">model aggregation.</span></span></p>
<p class="calibre3"><strong class="source-inline"><span class="kobospan" id="kobo.1273.1">DPFedAvg</span></strong><span class="kobospan" id="kobo.1274.1"> implements a privacy-preserving mechanism that ensures the privacy of client updates while enabling collaborative model training. </span><span class="kobospan" id="kobo.1274.2">It achieves this by adding noise or perturbation to the model updates or gradients received from each client, before aggregating them on the </span><a id="_idIndexMarker619" class="pcalibre1 calibre6 pcalibre"/><span><span class="kobospan" id="kobo.1275.1">server side.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1276.1">The key features and functionalities of the </span><strong class="source-inline"><span class="kobospan" id="kobo.1277.1">DPFedAvg</span></strong><span class="kobospan" id="kobo.1278.1"> class include </span><span><span class="kobospan" id="kobo.1279.1">the following:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.1280.1">DP</span></strong><span class="kobospan" id="kobo.1281.1">: </span><strong class="source-inline1"><span class="kobospan" id="kobo.1282.1">DPFedAvg</span></strong><span class="kobospan" id="kobo.1283.1"> integrates DP techniques into the FL process, ensuring that the privacy of individual client data is preserved during </span><span><span class="kobospan" id="kobo.1284.1">model training.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.1285.1">Noise addition</span></strong><span class="kobospan" id="kobo.1286.1">: </span><strong class="source-inline1"><span class="kobospan" id="kobo.1287.1">DPFedAvg</span></strong><span class="kobospan" id="kobo.1288.1"> applies noise to the gradients or model updates received from each client before aggregating them. </span><span class="kobospan" id="kobo.1288.2">The amount of noise added is determined based on privacy parameters and privacy </span><span><span class="kobospan" id="kobo.1289.1">budget allocation.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.1290.1">Privacy budget management</span></strong><span class="kobospan" id="kobo.1291.1">: </span><strong class="source-inline1"><span class="kobospan" id="kobo.1292.1">DPFedAvg</span></strong><span class="kobospan" id="kobo.1293.1"> incorporates mechanisms to manage and allocate the privacy budget effectively, ensuring that the desired privacy guarantees are maintained throughout the </span><span><span class="kobospan" id="kobo.1294.1">training process.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.1295.1">Privacy parameters</span></strong><span class="kobospan" id="kobo.1296.1">: </span><strong class="source-inline1"><span class="kobospan" id="kobo.1297.1">DPFedAvg</span></strong><span class="kobospan" id="kobo.1298.1"> allows users to customize the privacy parameters such as privacy budget, noise distribution, and sensitivity of the model updates. </span><span class="kobospan" id="kobo.1298.2">These parameters enable fine-grained control over the level of privacy and </span><span><span class="kobospan" id="kobo.1299.1">utility trade-off.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.1300.1">Model aggregation</span></strong><span class="kobospan" id="kobo.1301.1">: </span><strong class="source-inline1"><span class="kobospan" id="kobo.1302.1">DPFedAvg</span></strong><span class="kobospan" id="kobo.1303.1"> performs the aggregation of client updates using the DP averaging algorithm. </span><span class="kobospan" id="kobo.1303.2">This ensures that the privacy of individual updates is preserved while generating an updated </span><span><span class="kobospan" id="kobo.1304.1">global model.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.1305.1">Compatibility with the Flower framework</span></strong><span class="kobospan" id="kobo.1306.1">: </span><strong class="source-inline1"><span class="kobospan" id="kobo.1307.1">DPFedAvg</span></strong><span class="kobospan" id="kobo.1308.1"> is designed to seamlessly integrate with the Flower framework, allowing users to incorporate DP into their FL pipelines using the existing </span><span><span class="kobospan" id="kobo.1309.1">Flower infrastructure.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.1310.1">By using the </span><strong class="source-inline"><span class="kobospan" id="kobo.1311.1">DPFedAvg</span></strong><span class="kobospan" id="kobo.1312.1"> class in the Flower framework, developers and ML engineers can implement FL-DP straightforwardly and efficiently. </span><span class="kobospan" id="kobo.1312.2">It provides a powerful tool to ensure privacy in distributed ML scenarios while maintaining the collaborative benefits </span><span><span class="kobospan" id="kobo.1313.1">of FL.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1314.1">Let’s walk through the Flower-provided class </span><span><span class="kobospan" id="kobo.1315.1">in detail.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.1316.1">The DPFedAvgFixed class</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.1317.1">This class is a wrapper class and </span><a id="_idIndexMarker620" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.1318.1">adds clipping and Gaussian noise to the weights. </span><span class="kobospan" id="kobo.1318.2">The constructor of this class supports parameters to set server-side noise, a clip norm value, and the </span><span><span class="kobospan" id="kobo.1319.1">noise multiplier.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1320.1">Let’s use this class on the server side. </span><span class="kobospan" id="kobo.1320.2">The server code is </span><span><span class="kobospan" id="kobo.1321.1">as follows:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.1322.1">
def DP_Fed_Server():
    model = LogisticRegression(max_iter=10000)
    set_initial_params(model)
    strategy = fl.server.strategy.FedAvg(
        min_available_clients=2,
        evaluate_fn=get_evaluate_fn(model,X_test,y_test),
        on_fit_config_fn=fit_round,
    )
</span><strong class="bold1"><span class="kobospan1" id="kobo.1323.1">dps = DPFedAvgFixed(strategy,</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.1324.1">num_sampled_clients=2,</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.1325.1">clip_norm=0.03,</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.1326.1">noise_multiplier=0.5)</span></strong><span class="kobospan1" id="kobo.1327.1">
fl.server.start_server(
        server_address="0.0.0.0:8080",
          strategy=dps,
         config=fl.server.ServerConfig(num_rounds=5),
    )
DP_Fed_Server()</span></pre>
<p class="calibre3"><span class="kobospan" id="kobo.1328.1">The source code of the Jupyter notebooks for the server and clients is located in the </span><a href="B16573_06_split_000.xhtml#_idTextAnchor120" class="pcalibre1 calibre6 pcalibre"><span><em class="italic"><span class="kobospan" id="kobo.1329.1">Chapter </span></em></span><span><em class="italic"><span class="kobospan" id="kobo.1330.1">6</span></em></span></a><span><span class="kobospan" id="kobo.1331.1"> folder:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.1332.1">Server code:  </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.1333.1">Fed-DP-AML-Server.ipynb</span></strong></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.1334.1">Client 1 </span><span><span class="kobospan" id="kobo.1335.1">code: </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.1336.1">DP-FL-AML_Client1.ipynb</span></strong></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.1337.1">Client 2 </span><span><span class="kobospan" id="kobo.1338.1">code: </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.1339.1">DP-FL-AML-Client2.ipynb</span></strong></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.1340.1">Let’s look at the accuracy</span><a id="_idIndexMarker621" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.1341.1"> of the model for the clients </span><span><span class="kobospan" id="kobo.1342.1">and server:</span></span></p>
<table class="no-table-style" id="table010-2">
<colgroup class="calibre12">
<col class="calibre13"/>
<col class="calibre13"/>
<col class="calibre13"/>
</colgroup>
<thead class="calibre18">
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><strong class="bold"><span class="kobospan" id="kobo.1343.1">Client 1</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><strong class="bold"><span class="kobospan" id="kobo.1344.1">Client 2</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><strong class="bold"><span class="kobospan" id="kobo.1345.1">Server</span></strong></span></p>
</td>
</tr>
</thead>
<tbody class="calibre14">
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.1346.1">0.9962666666666666</span></span></p>
<p class="calibre3"><span><span class="kobospan" id="kobo.1347.1">0.7162666666666667</span></span></p>
<p class="calibre3"><span><span class="kobospan" id="kobo.1348.1">0.9876</span></span></p>
<p class="calibre3"><span><span class="kobospan" id="kobo.1349.1">0.9372</span></span></p>
<p class="calibre3"><span><span class="kobospan" id="kobo.1350.1">0.7714666666666666</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.1351.1">0.9745333333333334</span></span></p>
<p class="calibre3"><span><span class="kobospan" id="kobo.1352.1">0.5978666666666667</span></span></p>
<p class="calibre3"><span><span class="kobospan" id="kobo.1353.1">0.9693333333333334</span></span></p>
<p class="calibre3"><span><span class="kobospan" id="kobo.1354.1">0.9448</span></span></p>
<p class="calibre3"><span><span class="kobospan" id="kobo.1355.1">0.7708</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.1356.1">0.9962666666666666</span></span></p>
<p class="calibre3"><span><span class="kobospan" id="kobo.1357.1">0.7162666666666667</span></span></p>
<p class="calibre3"><span><span class="kobospan" id="kobo.1358.1">0.9876</span></span></p>
<p class="calibre3"><span><span class="kobospan" id="kobo.1359.1">0.9372</span></span></p>
<p class="calibre3"><span><span class="kobospan" id="kobo.1360.1">0.7714666666666666</span></span></p>
</td>
</tr>
</tbody>
</table>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.1361.1">Table 6.11 – Accracy results at Sever and Clients</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1362.1">Applying DP to FL introduces some overhead in terms of computational cost, communication overhead, and potentially reduced model performance. </span><span class="kobospan" id="kobo.1362.2">In our example case, by the fourth round, the accuracy was 93%, but in the fifth round, the accuracy suddenly dropped. </span><span class="kobospan" id="kobo.1362.3">This tells us that we need to monitor the accuracy during training to help us decide on the number of rounds each client needs to participate in and stop further rounds when the </span><span><span class="kobospan" id="kobo.1363.1">accuracy drops.</span></span></p>
<h1 id="_idParaDest-132" class="calibre5"><a id="_idTextAnchor140" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.1364.1">Summary</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.1365.1">In this chapter, we explained why FL is needed and looked at its definition and characteristics in detail. </span><span class="kobospan" id="kobo.1365.2">We covered the steps involved in implementing FL and discussed IID and non-IID datasets and FL algorithms. </span><span class="kobospan" id="kobo.1365.3">We implemented a sample application using an open source FL framework. </span><span class="kobospan" id="kobo.1365.4">Finally, we converted the same application </span><span><span class="kobospan" id="kobo.1366.1">using DP.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1367.1">In the next chapter, we will learn about FL benchmarks and look at key start-ups that are working on or already have </span><span><span class="kobospan" id="kobo.1368.1">FL products.</span></span></p>
</div>
</body></html>