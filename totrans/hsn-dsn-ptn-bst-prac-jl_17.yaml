- en: Assessments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Chapter 1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**What are the benefits of using design patterns?**'
  prefs: []
  type: TYPE_NORMAL
- en: Design patterns help the programmer apply already-proven approaches to common
    problems. There will be less time wasted in searching for the proper solution
    or fixing a design issue after a sub-optimal implementation. Anti-patterns provide
    additional guidance for avoiding common design flaws.
  prefs: []
  type: TYPE_NORMAL
- en: '**What are some of the key design principles?**'
  prefs: []
  type: TYPE_NORMAL
- en: The key design principles include SOLID, DRY, KISS, POLA, YAGNI, and POLP. These
    principles are widely recognized as good guidance for object-oriented programming,
    but they can be applied equally well in other programming paradigms.
  prefs: []
  type: TYPE_NORMAL
- en: '**What problem does the open/closed principle solve?**'
  prefs: []
  type: TYPE_NORMAL
- en: The open/closed principle encourages the programmer to design a system that
    is easy to extend without having to modify the component that is being extended.
    It promotes better reusability of software components.
  prefs: []
  type: TYPE_NORMAL
- en: '**Why is interface segregation important for software reusability?**'
  prefs: []
  type: TYPE_NORMAL
- en: Interface segregation promotes a minimalistic design for interfaces so that software
    components can implement the respective interfaces more easily. A large, complex
    interface is difficult to implement and it makes the component less reusable.
  prefs: []
  type: TYPE_NORMAL
- en: What are the simplest ways to develop maintainable software?
  prefs: []
  type: TYPE_NORMAL
- en: The simplest way to is to adhere to the general design principles such as KISS,
    DRY, POLA, and SOLID.
  prefs: []
  type: TYPE_NORMAL
- en: '**What is a good practice for avoiding over-engineering and bloated software?**'
  prefs: []
  type: TYPE_NORMAL
- en: The best way to avoid over-engineering and bloated software is to only implement
    functionalities that are absolutely necessary according to the YAGNI principle.
    Also, keep it simple (KISS) and avoid duplicate code (DRY).
  prefs: []
  type: TYPE_NORMAL
- en: '**How does memory usage affect system performance?**'
  prefs: []
  type: TYPE_NORMAL
- en: When the system allocates more memory, it also triggers the **Garbage Collector**
    (**GC**) more frequently. Garbage collection is a relatively expensive operation
    and, hence, it can slow down the system. Avoiding over memory allocation is usually
    one of the best ways to optimize application performance.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**How do we create a new namespace?**'
  prefs: []
  type: TYPE_NORMAL
- en: A namespace is created using a module block. Typically, a module is defined
    as part of a Julia package.
  prefs: []
  type: TYPE_NORMAL
- en: '**How do we expose the functions of a module to the outside world?**'
  prefs: []
  type: TYPE_NORMAL
- en: Functions and other objects defined within a module can be exposed using an
    export statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**How do we reference the proper function when the same function name is exported
    from different packages?**'
  prefs: []
  type: TYPE_NORMAL
- en: We can just prefix the function name with the package name. As an alternative,
    we can use a `using` statement for one package, and an import statement for the
    other, so that we can use the function name directly for the first package but
    use the prefix syntax for the other.
  prefs: []
  type: TYPE_NORMAL
- en: '**When do we separate code into multiple modules?**'
  prefs: []
  type: TYPE_NORMAL
- en: It is time to consider separating code into modules when the code becomes too
    big and too difficult to manage. We expect some refactoring to ensure the proper
    level of coupling between modules.
  prefs: []
  type: TYPE_NORMAL
- en: '**Why is semantic versioning important in managing package dependencies?**'
  prefs: []
  type: TYPE_NORMAL
- en: Semantic versioning defines a clear contract about when a breaking change is
    introduced in a new version. When used properly and consistently, it helps programmers
    to determine whether the change is compatible with the existing software and whether
    additional testing is required.
  prefs: []
  type: TYPE_NORMAL
- en: '**How is defining functional behavior for abstract types useful?**'
  prefs: []
  type: TYPE_NORMAL
- en: It is useful to define functional behavior for abstract types because the same
    behavior can be applied for the respective subtypes.
  prefs: []
  type: TYPE_NORMAL
- en: '**When should we make a type mutable?**'
  prefs: []
  type: TYPE_NORMAL
- en: It is appropriate to make a type mutable when some parts of the data type are
    expected to be changed. It is also useful when memory allocation needs to be reduced
    for performance reasons.
  prefs: []
  type: TYPE_NORMAL
- en: '**How are parametric types useful?**'
  prefs: []
  type: TYPE_NORMAL
- en: Parametric types allow a concrete type to be defined without hardcoding the
    type of its fields, so the same type can be used to generate new variations for
    different purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**How are positional arguments different from keyword arguments?**'
  prefs: []
  type: TYPE_NORMAL
- en: Position arguments must be passed in the same order as they are defined in the
    function signature. They are typically mandatory, but can be made optional when
    default values are provided. Keyword arguments can be passed in any order that
    they are written, and they are optional when default value is not provided.
  prefs: []
  type: TYPE_NORMAL
- en: '**What is the difference between splatting and slurping?**'
  prefs: []
  type: TYPE_NORMAL
- en: Splatting and slurping have the same syntax but mean different things in different
    contexts. Splatting refers to the automatic assignment of function arguments from
    a tuple or array. Slurping refers to the process of passing multiple function
    arguments, which becomes a single tuple variable accessible from the body of the
    function.
  prefs: []
  type: TYPE_NORMAL
- en: '**What is the purpose of do-syntax?**'
  prefs: []
  type: TYPE_NORMAL
- en: Do-syntax is a convenient way of formatting a block of code that is needed to
    be wrapped as an anonymous function and passed to another function. It makes the
    code much more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '**What tool is available for detecting method ambiguities as related to multiple
    dispatch?**'
  prefs: []
  type: TYPE_NORMAL
- en: The `detect_ambiguities` function from the `Test` package can be used to detect
    method ambiguities within a single module or across multiple modules.
  prefs: []
  type: TYPE_NORMAL
- en: '**How do we ensure that the same concrete type is passed to a function in a
    parametric method?**'
  prefs: []
  type: TYPE_NORMAL
- en: A convenient way to ensure that the same concrete type is passed for the arguments
    of a function is to designate these arguments as a type parameter (for example, `T`).
    Note that this works as long as the type parameter is used as a standalone type
    rather than part of a parametric type, for example, `AbstractVector{T}`.
  prefs: []
  type: TYPE_NORMAL
- en: '**How are interfaces implemented without any formal language syntax?**'
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces can be implemented according to the contract specified by the designer
    of the interface even though there is no formal syntax in Julia for specifying
    interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: '**How do we implement traits, and how are traits useful?**'
  prefs: []
  type: TYPE_NORMAL
- en: A trait can be implemented by a function that takes the specific data type(s)
    and returns a flag. Normally, a trait is defined to return a Boolean value, that
    is, whether the trait exists or not. However, it can also be designed to return
    multiple values to indicate various kinds of trait. Traits are useful if the developer
    needs to programmatically figure out whether a data type (or combination of data
    types) exhibits a specific behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**What are the two ways to quote expressions so the code can be manipulated
    later?**'
  prefs: []
  type: TYPE_NORMAL
- en: One way is to enclose an expression with `:(` and `)`. Another way is to put
    the code between `quote` and `end` keywords. In general, a quote block is used
    for multiline expressions.
  prefs: []
  type: TYPE_NORMAL
- en: '**In which scope does the `eval` function execute the code on?**'
  prefs: []
  type: TYPE_NORMAL
- en: The `eval` function evaluates the code in the global scope. So, if it is used
    from a function inside a module, then the code that is evaluated will be within
    the scope of the module.
  prefs: []
  type: TYPE_NORMAL
- en: '**How do we interpolate physical symbols into quoted expressions rather than
    being misinterpreted as source code?**'
  prefs: []
  type: TYPE_NORMAL
- en: To interpolate symbols into quoted expressions, create a `QuoteNode` object
    and interpolate that object normally.
  prefs: []
  type: TYPE_NORMAL
- en: '**What is the naming convention for a macro where it defines non-standard string
    literals?**'
  prefs: []
  type: TYPE_NORMAL
- en: Non-standard string literals are defined as macros having names ending with `_str`.
    For example, when an `ip_str` macro is defined for an IP address, it can be written: `ip"192.168.1.1"`.
  prefs: []
  type: TYPE_NORMAL
- en: '**When do we use the `esc` function?**'
  prefs: []
  type: TYPE_NORMAL
- en: The `esc` function is needed to ensure that the quoted expression is evaluated
    at the call site, which could be in the local scope of a function.
  prefs: []
  type: TYPE_NORMAL
- en: '**How are generated functions different from macros?**'
  prefs: []
  type: TYPE_NORMAL
- en: Generated functions have access to the types of the arguments. They are functions
    by definition so, unlike macros, they do not have access to the source code. Macros
    operate at the syntax level and do not have any runtime information. Both generated
    functions and macros are expected to return expressions.
  prefs: []
  type: TYPE_NORMAL
- en: '**How do we debug metaprogramming code?**'
  prefs: []
  type: TYPE_NORMAL
- en: Debugging macros can be challenging. It comes down to making sure that the expression
    being returned is correct. We can use the `@macroexpand` macro (or the corresponding `macroexpand` function)
    to verify results. Also, because a macro or generated function is defined using
    regular Julia code, the same debugging technique, such as `println`, can be used.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**How does delegation pattern work?**'
  prefs: []
  type: TYPE_NORMAL
- en: Delegation pattern can be implemented by wrapping a parent object in a new object.
    The function for the new objects can be forwarded (or delegated) to the parent
    object.
  prefs: []
  type: TYPE_NORMAL
- en: '**What is the purpose of traits?**'
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of traits is to formally define the behavior of certain objects.
    Once a trait is defined, we can programmatically examine whether an object exhibits
    the trait.
  prefs: []
  type: TYPE_NORMAL
- en: '**Are traits always binary?**'
  prefs: []
  type: TYPE_NORMAL
- en: Traits are typically binary, but there is no mandatory requirement. It would
    be fine as long as the traits are mutually exclusive. Julia's `Base.IteratorSize`
    trait is a good example of a multi-valued trait.
  prefs: []
  type: TYPE_NORMAL
- en: '**Can traits be used for objects from a different type hierarchy?**'
  prefs: []
  type: TYPE_NORMAL
- en: Yes, traits are not restricted by how the abstract type hierarchy is defined.
    The same trait can be assigned to objects coming from different type hierarchies.
  prefs: []
  type: TYPE_NORMAL
- en: '**What are the benefits of parametric types?**'
  prefs: []
  type: TYPE_NORMAL
- en: Parametric types allow us to define a template for data types. New data types
    can be created programmatically by filling in parameters. The primary benefit
    of parametric type is that the code becomes shorter because we do not need to
    spell out every possible concrete type.
  prefs: []
  type: TYPE_NORMAL
- en: '**How do we store information with a parametric type?**'
  prefs: []
  type: TYPE_NORMAL
- en: Additional information can be *stored* in the type itself as a parameter. It
    is quite convenient to access such data because it is first-class and is available
    in the function that takes parametric type arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Why does the use of global variables impact performance?**'
  prefs: []
  type: TYPE_NORMAL
- en: Global variables are not typed. Whenever it is used, the compiler must generate
    code that handles any possible data types that it may encounter. Hence, the compiler
    cannot generate highly-optimized code.
  prefs: []
  type: TYPE_NORMAL
- en: '**What would be a good alternative to using a global variable when it cannot
    be replaced by a constant?**'
  prefs: []
  type: TYPE_NORMAL
- en: We can define a typed global constant as a placeholder. The `Ref` type may also
    be used to hold a single value for the variable. Because `Ref` contains the type
    of data, the compiler can generate more optimized code.
  prefs: []
  type: TYPE_NORMAL
- en: '**Why does a struct of arrays perform better than an array of structs?**'
  prefs: []
  type: TYPE_NORMAL
- en: Modern CPUs can perform many numerical calculations in parallel. When the memory
    is aligned and packed together as in an array, the hardware cache can quickly
    look them up. An array of structs may have the objects scattered around in memory,
    which hurts performance.
  prefs: []
  type: TYPE_NORMAL
- en: '**What are the limitations of** `SharedArray`**?**'
  prefs: []
  type: TYPE_NORMAL
- en: '`SharedArray` only supports bit types. If we need to process non-bits type
    data in parallel, then we cannot use SharedArrays.'
  prefs: []
  type: TYPE_NORMAL
- en: '**What is an alternative to multi-core computation instead of using parallel
    processes?**'
  prefs: []
  type: TYPE_NORMAL
- en: An alternative is to use the multithreading facility. The Julia 1.3 release
    implemented a state-of-the-art multi-threading scheduler that supports multiple
    levels of parallelism.
  prefs: []
  type: TYPE_NORMAL
- en: '**What kind of care must be taken when using the memoization pattern?**'
  prefs: []
  type: TYPE_NORMAL
- en: Memoization trades space with time. The use of a cache demands more memory space.
    Depending on the function result, it may or may not impact the memory footprint
    of the application. If memory is already constrained in the system, it may not
    be the best option.
  prefs: []
  type: TYPE_NORMAL
- en: '**What is the magic behind the barrier function in improving performance?**'
  prefs: []
  type: TYPE_NORMAL
- en: When using the `barrier` function, the compiler can specialize the function
    based upon the types of arguments being passed to the function. Even though the
    type of argument is unstable, when a new type is encountered, a new specialized
    function is compiled automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**What are afferent and efferent couplings?**'
  prefs: []
  type: TYPE_NORMAL
- en: Afferent coupling represents how many external components are depending on the
    current component. By contrast, efferent coupling represents how many external
    components the current one depends on. These measurements are useful in determining
    how tightly the current component is coupled with other ones.
  prefs: []
  type: TYPE_NORMAL
- en: '**Why are bi-directional dependencies bad from a maintainability perspective?**'
  prefs: []
  type: TYPE_NORMAL
- en: Bi-directional dependencies tend to introduce messy, spaghetti code. To comprehend
    a single component, the developer must work through and understand the other components 
    that it both uses and depends on.
  prefs: []
  type: TYPE_NORMAL
- en: '**What is an easy way to generate code on the fly?**'
  prefs: []
  type: TYPE_NORMAL
- en: The `@eval` macro can be used to generate code. For example, it can be used
    inside a `for` loop so that variables can be interpolated into the definition
    of a function. The result is that multiple functions are defined, and they are
    all similar in terms of code structure and logic.
  prefs: []
  type: TYPE_NORMAL
- en: '**What would be an alternative to code generation?**'
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, code generation is not needed. Instead, the developer can choose
    to use a functional programming technique, such as closure, to reuse existing
    logic. Code generation may increase the program footprint and makes the program
    more difficult to debug. So, it would be prudent for a developer to consider other
    options before plunging into code generation technique.
  prefs: []
  type: TYPE_NORMAL
- en: '**When and why should we consider building a domain-specific language?**'
  prefs: []
  type: TYPE_NORMAL
- en: A **Domain-Specific Language** (**DSL**) is often used for writing code that
    is clean and easy to understand for people in that particular domain. For example,
    the `DifferentialEquations` package allows the developer to write code in a syntax
    that is very similar to the corresponding mathematical equations. Because the
    syntax is user friendly, it allows the developer to focus on mathematic modeling
    rather than the coding aspect.
  prefs: []
  type: TYPE_NORMAL
- en: '**What are the tools available for developing a domain-specific language?**'
  prefs: []
  type: TYPE_NORMAL
- en: The `MacroTools` package provides several convenient macros that are very helpful
    in writing macros and, in particular, domain-specific languages. The `@capture`
    macro allows users to perform pattern matching and parse source code. The `prewalk`
    and `postwalk` functions allow us to surgically replace expressions in an abstract
    syntax tree. The combination of `@capture` and `prewalk`/`postwalk` makes it a
    very powerful tool for developing domain-specific languages.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**What are the benefits of developing assessor functions?**'
  prefs: []
  type: TYPE_NORMAL
- en: Assessor functions are a great way to provide an official API to users of the
    particular object. The underlying implementation is therefore decoupled from the
    interface. Should there be any changes to the implementation, there will be zero
    impact on users of the object as long as the contract of the assessor functions
    is unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: '**What would be an easy way to discourage the use of internal fields of an
    object?**'
  prefs: []
  type: TYPE_NORMAL
- en: The easiest way to discourage the use of internal fields of an object is to
    have a special naming convention. A commonly used convention is to have an underscore
    as the prefix of the field name. If the programmer tries to use the field, then
    they are reminded that the field is supposed to be private.
  prefs: []
  type: TYPE_NORMAL
- en: '**Which functions may be extended as part of the property interface?**'
  prefs: []
  type: TYPE_NORMAL
- en: There are three functions from the `Base` package that can be extended to provide
    specific functionalities to the dot notation for field access. The functions are
    `getproperty`, `setproperty!`, and `propertynames`. An important point to remember
    is that once these functions are defined, all direct field access has to be changed
    to `getfield` and `setfield!` to avoid the recursion problem.
  prefs: []
  type: TYPE_NORMAL
- en: '**How can we capture the stack trace from a catch-block after an exception
    has been caught?**'
  prefs: []
  type: TYPE_NORMAL
- en: Once an exception is caught, we can use the `catch_backtrace` function to capture
    the stack frames right before the exception was caught. We can then pass the result
    to the `stacktrace` function to retrieve an array of `StackFrame` objects.
  prefs: []
  type: TYPE_NORMAL
- en: '**What is the best way to avoid the performance impact of a try-catch block
    for a system that requires optimal performance?**'
  prefs: []
  type: TYPE_NORMAL
- en: The best way to avoid the performance impact of a try-catch block is to not
    use it at all. We should find other ways to handle exceptions. For example, we
    can check for any condition that might cause a subsequent function to fail. In
    that case, we can proactively handle such a scenario. Another option is to catch
    the exception outside of a loop; hence, we would handle the exception at a higher
    level.
  prefs: []
  type: TYPE_NORMAL
- en: '**What are the benefits of using the `retry` function?**'
  prefs: []
  type: TYPE_NORMAL
- en: The `retry` function is a great way to automatically repeat an operation that
    may fail. Doing this ensures that important tasks are guaranteed to be completed,
    barring other types of unrecoverable exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: '**How do we hide away global variables and functions that are used internally
    in a module?**'
  prefs: []
  type: TYPE_NORMAL
- en: We can use a let-block so that global variables are bound as part of the let-block
    and not exposed to the global scope of the module. Functions that are defined
    inside the let-block can be declared as global when we need to expose them to
    the module.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**What predefined data type can be used to conveniently create new singleton
    types?**'
  prefs: []
  type: TYPE_NORMAL
- en: The built-in `Val` type can be used to create new singleton types easily. The `Val` constructor
    function can accept any bits-type value and return a singleton of type `Val{X}`,
    where `X` is the value being passed to the constructor function.
  prefs: []
  type: TYPE_NORMAL
- en: '**What are the benefits of using singleton type dispatch?**'
  prefs: []
  type: TYPE_NORMAL
- en: Using singleton type dispatch, we can eliminate conditional statements that
    depend on the data type. It also allows us to add new functionalities by just
    defining new functions, without having to modify an existing function. Because
    Julia does the dispatch natively, there is no need to create any custom function
    just for dispatch.
  prefs: []
  type: TYPE_NORMAL
- en: '**Why do we want to create stubs?**'
  prefs: []
  type: TYPE_NORMAL
- en: Stubs are very useful indeed in automated testing. First, if a function requires
    connecting to a remote web service, then it can be inconvenient or even costly
    to connect to the live service all of the time. In that case, a stub can be used
    to replace the service. Second, a stub can be designed to exercise all positive
    and negative scenarios so that desired tests can be included in the automated
    testing process.
  prefs: []
  type: TYPE_NORMAL
- en: '**What is the difference between mocking and stubbing?**'
  prefs: []
  type: TYPE_NORMAL
- en: Stubbing focuses on state verification, that is, what comes out of the **Function
    Under Test** (**FUT**) after the stub is used. Mocking, on the other hand, focuses
    on behavior verification, that is, how the mocked function was used by the FUT.
    In general, mocking also includes state verification just like stubs.
  prefs: []
  type: TYPE_NORMAL
- en: '**What does composability mean?**'
  prefs: []
  type: TYPE_NORMAL
- en: Composability means how easy functions can be combined to create something greater.
    Composable functions allow applications to be built by reusing existing code.
    Because functions are first-class in Julia, they can be combined easily, as long
    as the functions accept only a single argument.
  prefs: []
  type: TYPE_NORMAL
- en: '**What is the primary constraint for using functional pipes?**'
  prefs: []
  type: TYPE_NORMAL
- en: The primary constraint of functional pipes is that functions participating in
    the pipe can only accept a single argument. Functions that need more than one
    argument can be transformed to a `curried` function such that the higher-order
    function can participate in the pipe.
  prefs: []
  type: TYPE_NORMAL
- en: '**How are functional pipes useful?**'
  prefs: []
  type: TYPE_NORMAL
- en: Functional pipes can be useful for data processing pipelines, especially if
    the process is linear in nature. The syntax is easy to read for some people.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**What are the risks and potential benefits of Type I piracy?**'
  prefs: []
  type: TYPE_NORMAL
- en: Type I piracy refers to a situation where a third-party function is redefined
    with a custom implementation. The risk is that custom implementation may not conform
    to the contract as expected by the third-party module. Coded incorrectly, the
    system may become unstable and crash.
  prefs: []
  type: TYPE_NORMAL
- en: '**What kind of problems can arise due to Type II piracy?**'
  prefs: []
  type: TYPE_NORMAL
- en: Type II piracy refers to a situation where a third-party function is extended
    without using your own types in the function arguments. It can be problematic
    because there is no guarantee that another dependent package also implements Type
    II piracy, conflicting with your pirate function. The result can be an unstable
    system.
  prefs: []
  type: TYPE_NORMAL
- en: '**How does Type III piracy cause trouble?**'
  prefs: []
  type: TYPE_NORMAL
- en: Type III piracy refers to a situation where a third-party function is extended
    with your own types but for a different purpose. While the function is defined
    using a custom type in the argument, there is no guarantee that the third-party
    module does not end up using your own function due to duck typing. Hence, your
    pirate function leaks into the third-party module and causes unexpected results.
  prefs: []
  type: TYPE_NORMAL
- en: '**What should we watch out for when specifying function arguments?**'
  prefs: []
  type: TYPE_NORMAL
- en: When specifying function arguments, we should avoid making the argument types
    too narrow. Arguments that are too narrow limit the reusability of the function.
  prefs: []
  type: TYPE_NORMAL
- en: '**How is system performance affected by using abstract function arguments?**'
  prefs: []
  type: TYPE_NORMAL
- en: System performance is not affected when function arguments are specified with
    abstract types. Julia always specifies the function depending on the type that
    is passed into the function. Hence, there is no runtime overhead.
  prefs: []
  type: TYPE_NORMAL
- en: '**How is system performance affected by using abstract field types for composite
    types?**'
  prefs: []
  type: TYPE_NORMAL
- en: System performance is affected negatively when abstract types are used for fields
    in a composite type. The Julia compiler must store pointers in memory for these
    objects because it has to support any data types relevant to those fields. Because
    pointers must be dereferenced to get to the data, system performance can be degraded
    greatly.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**What technique can we use to implement the abstract factory pattern?**'
  prefs: []
  type: TYPE_NORMAL
- en: To implement the abstract factory pattern, we can create a hierarchy of abstract
    types. Then, we can implement concrete functions that take a singleton type in
    the argument. By way of multiple dispatches, we should be able to call the right
    function for the right platform or environment.
  prefs: []
  type: TYPE_NORMAL
- en: '**How do we avoid a singleton from being initialized multiple times in a multithreaded
    application?**'
  prefs: []
  type: TYPE_NORMAL
- en: To avoid multiple initializations of a singleton, we can use a reentrant lock
    to synchronize the threads. The first thread would be able to obtain the lock
    and initialize the singleton, while the other threads should wait until the initialization
    is finished. The lock must be released at the end of the initialization.
  prefs: []
  type: TYPE_NORMAL
- en: '**What Julia feature is essential for implementing the observer pattern?**'
  prefs: []
  type: TYPE_NORMAL
- en: We can implement the `setproperty!` function so that all updates to an object's
    field can be monitored and additional actions can be triggered.
  prefs: []
  type: TYPE_NORMAL
- en: '**How can we customize an operation using the template method pattern?**'
  prefs: []
  type: TYPE_NORMAL
- en: We can design the template function to take in customized functions via keyword
    arguments. A keyword argument may be defaulted to a standard implementation, and
    at the same time a custom function can be passed by the caller. The expected interface
    of the function should be clearly documented.
  prefs: []
  type: TYPE_NORMAL
- en: '**How do we make an adapter to implement a target interface?**'
  prefs: []
  type: TYPE_NORMAL
- en: We can make an adapter by creating a new type that wraps the original type.
    Then, we can implement the expected interface on the new type. Using a delegation
    pattern, the new type can reuse existing functionality by forwarding specific
    functions to the original type.
  prefs: []
  type: TYPE_NORMAL
- en: '**What are the benefits of the flyweight pattern and what strategy can we use
    to achieve that?**'
  prefs: []
  type: TYPE_NORMAL
- en: We can potentially save a lot of memory space when using the flyweight pattern
    because objects are shared. The general technique is to maintain a reference table
    that uses a more compact data element as a lookup key. The key is used to look
    up the more memory-intensive objects.
  prefs: []
  type: TYPE_NORMAL
- en: '**What Julia feature can we use to implement the strategy pattern?**'
  prefs: []
  type: TYPE_NORMAL
- en: We can implement the strategy pattern using singleton types as functional arguments.
    The function with the proper algorithm (strategy) is automatically selected at
    runtime by multiple dispatch.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**How does implementation inheritance differ from behavior subtyping?**'
  prefs: []
  type: TYPE_NORMAL
- en: Implementation inheritance allows a subclass to inherit both fields and methods
    from a super-class. Behavior subtyping allows a subtype to inherit methods defined
    for a super-type.
  prefs: []
  type: TYPE_NORMAL
- en: '**What are some major issues associated with implementation inheritance?**'
  prefs: []
  type: TYPE_NORMAL
- en: Implementation inheritance is problematic because sometimes, the subclass may
    not want to inherit the fields from a super-class even when it makes logical sense
    to define the parent-child relationship. As demonstrated from the square-rectangle
    problem, a subclass may be more restrictive and take away features rather than
    adding new functionality on top of the super-class. Second, implementation inheritance
    suffers from the fragile base class issue, for which changes to the super-class
    may unintentionally modify the behavior of the subclass.
  prefs: []
  type: TYPE_NORMAL
- en: '**What is duck typing?**'
  prefs: []
  type: TYPE_NORMAL
- en: Duck typing is a dynamic feature that allows a method to be dispatched without
    strong type checking. A function may be dispatched as long as it adheres to the
    expected interface contract.
  prefs: []
  type: TYPE_NORMAL
- en: '**What is the variance of method arguments and why?**'
  prefs: []
  type: TYPE_NORMAL
- en: Method arguments are covariant as they are consistent with the Liskov Substitution
    Principle, which states that a function that is defined to accept type *S* should
    be able to work with any subtype of *S*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Why are parametric types invariant in Julia?**'
  prefs: []
  type: TYPE_NORMAL
- en: Parametric types are invariant in Julia for a very practical reason. The type
    parameter unambiguously determines the memory layout of the underlying container.
    When it is invariant, there is an opportunity to achieve high performance by compacting
    storage data consecutively without having to dereference pointers.
  prefs: []
  type: TYPE_NORMAL
- en: '**When does the diagonal rule apply?**'
  prefs: []
  type: TYPE_NORMAL
- en: The diagonal rule is applied whenever a type variable occurs more than once
    in a covariance position. There is an exception to the rule when the same type
    variable is unambiguously determined from an invariant position such as in a parametric
    type.
  prefs: []
  type: TYPE_NORMAL
