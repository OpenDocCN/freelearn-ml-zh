<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Design Patterns and Related Principles</h1>
                </header>
            
            <article>
                
<p>Nowadays, learning and applying design patterns is an important aspect of software engineering. Design patterns are like water – you can't live without them. Don't believe me? Just ask hiring managers, and you will find that many of them have design patterns in their job postings as well as related questions in job interviews. It is a common belief that design patterns are important ingredients for software development and everyone should know them.</p>
<p><span>In this chapter, we will provide some context about why design patterns are useful and how they have served us well in the past few decades. By understanding the motivation behind design patterns, we will be able to set forth a set of guiding principles for developing software. </span><span>The following topics will be discussed in this chapter:</span></p>
<ul>
<li><span>The history of design patterns </span></li>
<li><span>Software design principles</span></li>
<li><span>Software quality objectives </span></li>
</ul>
<div>
<p>Let's get started!</p>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The history of design patterns</h1>
                </header>
            
            <article>
                
<p>Design patterns is not a new concept to computer programmers. <span>Since personal computers became more affordable and popular in the 1980s, the programming profession flourished and a lot of code was written for a variety of applications.</span></p>
<p><span>I remember that, when I was 14 years old, learning the GOTO statement for a BASIC program was one of the coolest things. It literally allowed me to take a control flow to a different part of the code at any time. Perhaps not too surprisingly, when I learned about structured programming and the Pascal language in college, I started to realize how GOTO statements produce messy spaghetti code. </span><span>Using GOTO for branching purposes is a pattern. It's just a bad one because it makes code difficult to understand, follow, and debug. In today's <em>lingua franca,</em> we call them anti-patterns. When it comes to structured programming techniques, organizing code in small functions is a pattern as well, one that has been taught as a mainstream subject in programming courses. </span></p>
<p>When I graduated from college, I started my programming career and spent plenty of time <em>hacking away</em>. I had the opportunity to do various kinds of research and find out how systems are designed. For example, I realized that the Unix operating system has a beautiful design. That is because it consists of many small programs, which individually do not have a ton of functionality, but you can compose them in any number of ways to solve more complex problems. I was also fond of the Scheme programming language, which came out of MIT's AI Lab. The simplicity and versatility of the language still amazes me today. Scheme's heritage can be traced to Lisp, which had some influence on how the Julia language was designed.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The rise of design patterns</h1>
                </header>
            
            <article>
                
<p><span><span>In 1994, while</span></span><span> I was diving deep into C++ and distributed computing for a financial application, </span>four software professionals, also known as the Gang of Four or GoF, came together and published a book about design patterns, and it took the object-oriented programming community by storm. The group<span> collected and classified 23 design patterns that were commonly utilized when developing large-scale systems. They also chose to explain the concepts using <strong>Unified Modeling Language</strong> (<strong>UML</strong>) and C++ and Smalltalk.</span></p>
<p><span>For the first time, a set of design patterns had been collected, organized, explained, and widely distributed to software developers. Perhaps one of the most significant decisions by the group was to organize these patterns in a highly structured and easily consumable format. Since then, programmers have been able to communicate with each other easily about how they design their software. In addition, they can visually present software design with a universal notation. When one person talks about the Singleton pattern, another person can immediately understand and even visualize in his/her mind how that component works. Isn't that convenient?</span></p>
<p class="mce-root"/>
<p><span>Even more surprisingly, design patterns suddenly became the gospel when it come to building good software. In some ways, using them was even perceived as the only way to write good software. </span><span>GoF patterns were so widely preached across the development community that many people abused them and used them everywhere without good reason. The problem is – <em>When all you have is a hammer, everything looks like a nail! </em>Not everything can be solved or should be solved by the same patterns. When design patterns are overused or misused, the code becomes more abstract, more complicated, and more difficult to manage.</span></p>
<p>So, what have we learned from the past? <span>We recognize that every abstraction comes with a cost. Every design pattern comes with its own pros and cons. One of the main objectives of this book is to discuss not just the how but also the why and why not, and under what circumstances a pattern should be used or not used. We, as software professionals, will then be equipped with the information we need to make good judgment calls about when to apply these patterns.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">More thoughts about GoF patterns</h1>
                </header>
            
            <article>
                
<p>GoF design patterns are classified into three main categories:</p>
<ul>
<li><span><strong>Creational patterns</strong>: These cover how to construct objects in various ways. Since object-oriented programming brings together data and behavior, and a class may inherit the structure and behavior of an ancestor class, there are some complexities involved when building a large application. Creational patterns help standardize object creation methods in various situations.</span></li>
<li><span><strong>Structural patterns</strong>:</span><span> These cover how objects can be extended or composed to make bigger thing. The purpose of these patterns is to allow software components to be reused or replaced more easily.</span></li>
<li><span><strong>Behavioral patterns</strong>:</span> This cover how objects can be designed to perform separate tasks and communicate with each other. A large application can be decomposed into independent components and the code becomes easier to maintain. The o<span>bject-oriented programming paradigm requires solid interaction between objects. The purpose of these patterns is to make software components more flexible and more convenient for collaboration with each other. </span></li>
</ul>
<p>One school of thought is that design patterns are created to address limitations in their respective programming language. Two years after the GoF book was published, Peter Norvig published research showing that 16 of the 23 design patterns are either unnecessary or can be simplified in a dynamic programming language such as Lisp.</p>
<p class="mce-root"/>
<p><em>This is not an unimportant observation</em>. In the context of object-oriented programming, additional abstraction from a class hierarchy requires the software designer to think about how objects are instantiated and interact with each other. In a strong, statically typed language such as Java, it is even more necessary to reason about the behavior and interaction of objects. I<span>n </span><a href="9984b03e-c2c1-4b65-8f07-6240804db32d.xhtml">Chapter 11</a>, <em>Traditional Object-Oriented Patterns</em><span>, we will circle back to this topic and discuss how Julia works differently compared to object-oriented programming.</span></p>
<p>For now, we will start with the basics and review some software design principles. These principles are like the North star, guiding us as we build applications.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How do we describe patterns in this book?</h1>
                </header>
            
            <article>
                
<p><span>If you are new to Julia programming, this book will help you understand how to write more idiomatic Julia code. We will also focus on describing some of the most useful patterns that are already used in the existing open source Julia ecosystem. That includes Julia's own Base and</span> <kbd>stdlib</kbd> <span>packages as the Julia runtime is largely written in Julia itself. We will also reference other packages that are used for numerical computing and web programming. </span></p>
<p><span>For ease of reference, we will organize our patterns</span><span> by name. For example, the Holy Traits pattern refers to a specific method for implementing traits. The Domain-Specific Language pattern talks about how to build new syntax to represent specific domain concepts. The sole purpose of having a name is just ease of reference.</span></p>
<p>When we discuss these design patterns in this book, we will try to understand the motivation behind them. What specific problem are we trying to solve? What would be a real-world situation where such a pattern would be useful? Then, we will get into the details of how to solve these problems. Sometimes, there may be several ways to solve the same problem, in which case we will look into each possible solution and discuss the pros and cons.</p>
<p>Having said that, it is important for us to understand the ultimate goal of using design patterns. <span>Why do we want to use design patterns in the first place? To answer this question, it would be useful for us to first understand some key software design principles</span><span>.</span></p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Software design principles</h1>
                </header>
            
            <article>
                
<p><span>While this book does not cover object-oriented programming, some object-oriented design principles are universal and could be applied to any programming language and paradigm. Here, we will take a look at some of the most well-known design principles. In particular, we will cover the following:</span></p>
<ul>
<li><strong>SOLID</strong>: Single Responsibility, Open/Closed, Liskov Substitution, Interface Segregation, Dependency Inversion</li>
<li><strong>DRY</strong>: Don't Repeat Yourself</li>
<li><strong>KISS</strong>: Keep It Simple, Stupid!</li>
<li><strong>POLA</strong>: Principle of Least Astonishment</li>
<li><strong>YAGNI</strong>: You Aren't Gonna Need It</li>
<li><strong>POLP</strong>: Principle of Least Privilege</li>
</ul>
<p>Let's start with SOLID.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">SOLID</h1>
                </header>
            
            <article>
                
<div>
<div>
<p><span>The SOLID principle consists of the following:</span></p>
</div>
</div>
<ul>
<li><strong>S</strong>: Single Responsibility Principle</li>
<li><strong>O</strong>: Open/Closed Principle</li>
<li><strong>L</strong>: Liskov Substitution Principle</li>
<li><strong>I</strong>: Interface Segregation Principle</li>
<li><strong>D</strong>: Dependency Inversion Principle</li>
</ul>
<p>Let's understand each concept in detail.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Single Responsibility Principle</h1>
                </header>
            
            <article>
                
<p><span>The </span><span>Single Responsibility Principle</span><span> </span><span>states that e</span><span>very module, class, and function should be responsible for a single functional objective. There should be only one reason to make any changes.</span></p>
<p><span>The benefits of this principle are listed here:</span><em><span> </span></em></p>
<ul>
<li><span>The programmer can focus on a single context during development.</span></li>
<li><span>The size of each component is smaller.</span></li>
<li><span>The code is easier to understand.</span></li>
<li><span>The code can be tested more easily.</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Open/Closed Principle</h1>
                </header>
            
            <article>
                
<p><span>The </span><span>Open/Closed Principle</span><span> </span><span>states that every module should be open for extension but closed for modification. It is necessary to distinguish between enhancement and extension—enhancement refers to a core improvement of the existing module, while an extension is considered an add-on that provides additional functionality.</span></p>
<p><span>The following are the benefits of this principle</span>: </p>
<ul>
<li>Existing components can be easily reused to derive new functionalities.</li>
<li>Components are loosely coupled so it is easier to replace them without affecting the existing functionality.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Liskov Substitution Principle</h1>
                </header>
            
            <article>
                
<p>The <span>Liskov Substitution Principle</span><span> </span><span>states that a program that accepts type <em>T</em> can also accept type <em>S</em> (which is a subtype of <em>T</em>), without any change in behavior or intended outcome.</span></p>
<p><span>The following are the benefits of this principle</span>: </p>
<ul>
<li><span>A function can be reused for any subtype passed in the arguments.</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Interface Segregation Principle</h1>
                </header>
            
            <article>
                
<p><span>The </span><span>Interface Segregation Principle</span><span> </span><span>states that a client should not be forced to implement interfaces that it does not need to use.</span></p>
<p><span>The following are the benefits of this principle:</span><span> </span></p>
<ul>
<li><span>Software components are more modular and reusable.</span></li>
<li>New implementations can be created more easily.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Dependency Inversion Principle</h1>
                </header>
            
            <article>
                
<p><span>The Dependency Inversion</span><span> Principle</span><span> </span><span>states that high-level classes should not depend on low-level classes; instead, high-level classes should depend on an abstraction that low-level classes implement.</span></p>
<p><span>The following are the benefits of this principle:</span><span> </span></p>
<ul>
<li><span>Components are more decoupled.</span></li>
<li><span>The system becomes more flexible and can adapt to changes more easily. </span><span>Low-level components can be replaced without affecting high-level components.</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">DRY</h1>
                </header>
            
            <article>
                
<p><span>We'll now cover the DRY principle:</span></p>
<ul>
<li><strong>D</strong>: Don't</li>
<li><strong>R</strong>: Repeat</li>
<li><strong>Y</strong>: Yourself</li>
</ul>
<p>This acronym is a good way of reminding programmers that duplicate code is bad. It is obvious that duplicate code can be difficult to maintain—whenever logic is changed, multiple places in the code are affected.</p>
<p>What do we do when duplicate code is found? Eliminate it and create a common function that is reusable from multiple source files. </p>
<p>In addition, sometimes code is not 100% duplicated but instead is 90% similar. That is not an uncommon scenario. In that case, consider redesigning the relevant components, possibly refactoring code to a common interface.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">KISS</h1>
                </header>
            
            <article>
                
<p>Let's talk about the KISS principle:</p>
<ul>
<li><strong>K</strong>: Keep</li>
<li><strong>I</strong>: It</li>
<li><strong>S</strong>: Simple</li>
<li><strong>S</strong>: Stupid!</li>
</ul>
<p>Often, when we design software, we like to think ahead and try to deal with all kinds of future scenarios. The trouble with building such <em>future-proof </em>software is that it takes exponentially more effort to design and code properly. Practically speaking, it's a conundrum—there is no 100% future-proof solution because technology changes, business changes, and people change. Also, over-engineering could lead to excessive abstraction and indirection, making a system more difficult to test and maintain.</p>
<p>In addition, when using Agile software development methods, we value faster and high-quality delivery over perfection or excess engineering. Keeping the design and code simple is a virtue that every programmer should keep in mind.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">POLA</h1>
                </header>
            
            <article>
                
<p>Let's look at the POLA principle:</p>
<ul>
<li><strong>P</strong>: Principle</li>
<li><strong>O</strong>: Of</li>
<li><strong>L</strong>: Least</li>
<li><strong>A</strong>: Astonishment</li>
</ul>
<p>POLA states that a software component should be easy to understand and its behavior should never be a surprise (or, more accurately, <em>astonishing</em>) to the client. How do we do that?</p>
<p><span>The following are</span> some things to keep in mind:</p>
<ul>
<li>Make sure that the names of the module, function, or function arguments are clear and unambiguous.</li>
<li>Ensure that modules are right-sized and well maintained.</li>
<li>Ensure that interfaces are small and easy to understand.</li>
<li>Ensure that functions have few positional arguments. </li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">YAGNI</h1>
                </header>
            
            <article>
                
<p>Let's move on to the YAGNI principle:</p>
<ul>
<li><strong>Y</strong>: You</li>
<li><strong>A</strong>: Aren't</li>
<li><strong>G</strong>: Gonna</li>
<li><strong>N</strong>: Need</li>
<li><strong>I</strong>: It</li>
</ul>
<p>YAGNI says you should only develop software that is needed today. This principle came from <strong><span>Extreme Programming</span></strong> (<strong>XP</strong>). See what Ron Jeffries, co-founder of XP, wrote in his blog:</p>
<div class="packt_quote"><span>"Always implement things when you actually need them, never when you just</span> foresee <span>that you need them."</span></div>
<p>Software engineers are sometimes tempted to develop functionality that they feel the customer will need in the future. It's been proven time and time again that this is not the most effective way to develop software. Consider the following scenarios:</p>
<ul>
<li>The functionality is never needed by the customer and so the code is never used.</li>
<li>The business environment changes and the system has to be redesigned or replaced.</li>
<li>The technology changes and the system has to be upgraded to use a new library, a new framework, or a new language. </li>
</ul>
<p>The cheapest software is the one that you didn't write. <em>You aren't gonna need it!</em></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">POLP</h1>
                </header>
            
            <article>
                
<p>Now, for POLP:</p>
<ul>
<li><strong>P</strong>: Principle</li>
<li><strong>O</strong>: Of</li>
<li><strong>L</strong>: Least </li>
<li><strong>P</strong>: Privilege</li>
</ul>
<p>POLP states that a client must be given access only to the information or functions that they need. <span>POLP is one of the most important pillars for building secure applications, and it is widely adopted by cloud infrastructure vendors such as Amazon, Microsoft, and Google.</span></p>
<p>There are quite a few benefits when POLP is applied:</p>
<ul>
<li>Sensitive data is protected and not exposed to non-privileged users.</li>
<li>The system can be tested more easily since the number of use cases is limited.</li>
<li>The system becomes less prone to misuse because only limited access is given and the interface is simpler.</li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The software design principles that we have learned about so far are great tools. Although SOLID, DRY, KISS, POLA, YAGNI, and POLP seem to be just a bunch of acronyms, they are useful in designing better software. While SOLID principles came from the object-oriented programming paradigm, SOLID's concepts can still be applied to other languages and environments. As we work through the rest of the chapters in this book, I would encourage you to keep them in mind.</p>
<p>In the next section, we will go over several software quality objectives when designing software.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Software quality objectives</h1>
                </header>
            
            <article>
                
<p>Everyone likes beautiful design. I do, too. But, the use of design patterns is not just to make something look good. Everything we do should have a purpose.</p>
<p>The GoF classified object-oriented design patterns as creational, structural, and behavioral. For Julia, let's take a different perspective and classify our patterns by their respective software quality objectives as follows:</p>
<ul>
<li>Reusability</li>
<li>Performance</li>
<li>Maintenance</li>
<li>Safety</li>
</ul>
<p>Let's understand each of these in the following sections.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reusability</h1>
                </header>
            
            <article>
                
<p>People often talk about top-down and bottom-up approaches when designing software.</p>
<p>The <strong>top-down approach</strong> starts with a large problem and breaks it down into a set of smaller problems. Then, if the problems are not small enough, as discussed when we looked at the Single Responsibility Principle, we further break down the problem into even smaller ones. The process repeats and eventually the problem is small enough to design and code.</p>
<p>The <strong>bottom-up approach</strong> works in the opposite direction. Given domain knowledge, you can start creating building blocks, and then create more complex ones by composing from these building blocks.</p>
<p>Regardless of how it is done, eventually there will be a set of components that work with each other, thereby forming the basis of the application. </p>
<p>I like the metaphor. E<span>ven a 5-year old child can build a variety of structures u</span>sing just several kinds of Lego block. Imagination is the limit. Do you ever wonder why it is so powerful? Well, if you recall, every Lego block has a standard set of connectors: one, two, four, six, eight, or more. Using these connectors, each block can plug into another block easily. When you create a new structure, you can combine it with other structures to create even larger, more complex structures.</p>
<p>When building applications, the key design principle is to create pluggable interfaces so every component can be reused easily.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Characteristics of reusable components</h1>
                </header>
            
            <article>
                
<p>The following are important characteristics of reusable components:</p>
<ul>
<li>Each component serves a single purpose (the S in SOLID).</li>
<li>Each component is well defined and ready for reuse (the O in SOLID).</li>
<li>An abstract type hierarchy is designed for parent-child relationships (the L in SOLID).</li>
<li>Interfaces are defined as a small set of functions (the I in SOLID).</li>
<li>Interfaces are used to bridge between components (the D in SOLID).</li>
<li>Modules and functions are designed with simplicity in mind (KISS).</li>
</ul>
<p>Reusability is important because it means we can avoid duplicated code and wasted effort. The less code we write, the less work we need to do to maintain software. That includes not just the development effort but also the time testing, packaging, and upgrading. Reusability is also one of the reasons why open source software is so successful. In particular, the Julia ecosystem contains many open source packages and they tend to borrow functionalities from each other.</p>
<p>Next, we will discuss another software quality objective—<span>performance</span>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Performance</h1>
                </header>
            
            <article>
                
<p>The Julia language is designed for high-performance computing. It does not come for free, however. When it comes to performance, it takes practice to write code that is more compiler-friendly, thus making it more likely to translate the program into optimized machine code.</p>
<p>For the past few decades, computers have seemed to become faster and faster every year. What used to be performance bottlenecks are more easily solved using today's hardware. At the same time, we are also facing more challenges due to the explosion of data. A good example is the field of big data and data science. As the amount of data grows, we need even more computing power to handle these new use cases.</p>
<p>Unfortunately, the speed of computers has not grown as rapidly as it did in the past. Moore's Law states that the number of transistors on a microchip doubles roughly every 18 months, and since 1960 it has been correlated with the growth in CPU speed. However, it is well known that Moore's Law will no longer be applicable soon due to a physical limitation: the number of transistors that can be fitted to a chip and the precision of the fabrication process.</p>
<p>In order to address today's computational needs, especially in the world of artificial intelligence, machine learning, and data science, practitioners have been gearing toward a <em>scale-out</em> strategy that utilizes multiple CPU cores across many servers, and looking at exploiting the efficiency of GPUs and TPUs.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Characteristics of high-performance code</h1>
                </header>
            
            <article>
                
<p>The following are characteristics of high-performance code:</p>
<ul>
<li>Functions are small and can be optimized easily (S in SOLID).</li>
<li>Functions contains simple logic rather than complex logic (KISS).</li>
<li>Numeric data is laid out in contiguous memory space so the compiler can fully utilize CPU hardware.</li>
<li>Memory allocation should be kept to a minimum to avoid excessive garbage collection.</li>
</ul>
<p><span>Performance is an important aspect of any software project. It is particularly important for data science, machine learning, and scientific computing use cases. A small design change can make a big difference—depending on the situation, it could possibly turn a 24-hour process into a 30-minute process. It could also give users real-time experience when using a web application rather than a <span class="packt_screen">please wait...</span> dialog.</span></p>
<p> </p>
<p>Next, we will discuss software maintainability as another software quality objective.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Maintainability</h1>
                </header>
            
            <article>
                
<p>Software can be <span>maintained </span>more easily when it is designed properly. Generally speaking, if you are able to <span>effectively </span>use the design principles listed previously (SOLID, KISS, DRY, POLA, YAGNI, and POLP), then your application is more likely to be well architected and designed for long-term maintenance.</p>
<p>Maintainability is an important ingredient for large-scale applications. A research project from graduate school may not last long. On the contrary, an enterprise application may last for decades. Re<span>cently, </span>I heard from a colleague that COBOL is still in use and COBOL programmers are still making a good living.</p>
<p>We often hear about technical debt. Similar to monetary debt in real life, technical debt is something that you must pay for whenever code is changed. And the longer the technical debt stays in place, the more effort you have to spend. </p>
<p>To understand why, consider a module that is bloated with duplicate code or unnecessary dependencies. Whenever a new functionality is added, you have to update multiple parts of the source code, and you have to perform regression testing for a larger area of the system. So, you end up paying (in terms of programming time and effort) for the debt every time the code is changed until the debt is fully repaid (that is, until the code is fully refactored).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Characteristics of maintainable code</h1>
                </header>
            
            <article>
                
<p>The following are characteristics of maintainable code:</p>
<ul>
<li>No unused code (YAGNI).</li>
<li>No duplicate code (DRY).</li>
<li>Code is concise and short (KISS).</li>
<li>Code is clear and easy to understand (KISS).</li>
<li>Every function has a single purpose (the S in SOLID).</li>
<li>Every module contains functions that relate to and work with each other (the S in SOLID).</li>
</ul>
<p><span>Maintainability is an important aspect of any application. When designed properly, even large applications can be changed frequently and easily without fear. Applications can also last a long time, reducing the cost of the software.</span></p>
<p><span>Next, we will discuss software safety as another quality objective.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Safety</h1>
                </header>
            
            <article>
                
<div class="packt_quote">"Safety—<span>the condition of being safe from undergoing or causing hurt, injury, or loss."</span></div>
<div class="packt_quote CDPAlignCenter CDPAlign">– Merriam-Webster Dictionary</div>
<p>Applications are expected to function correctly. When an application malfunctions, there could be undesired consequences and some of those could be fatal. Consider a mission-critical rocket-launch subsystem used by NASA<span class="hvr">. A single defect could cause the launch to be delayed; or, in the worst-case scenario, it could cause the rocket to explode in mid-air.</span></p>
<p>Programming languages are designed to allow flexibility but at the same time provide safety features so software engineers can make fewer mistakes. For example, the compiler's static type checking ensures that the correct types are passed to functions that expect those types. In addition, most computer programs operate on data, and as we know, data is not always clean or available. Hence, the ability to handle bad or missing data is an important software quality. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Characteristics of safe applications</h1>
                </header>
            
            <article>
                
<p>Some characteristics of safe applications follow:</p>
<ul>
<li>Each module exposes a minimum set of types, functions, and variables.</li>
<li class="sb has-num">Each function is called with arguments such that the respective types implement the expected behavior of the function (the L in SOLID; POLA).</li>
<li>The return value of a function is clear and documented (POLA).</li>
<li>Missing data is handled properly (POLA).</li>
<li>Variables are limited to the smallest scope.</li>
<li>Exceptions are caught and handled accordingly.</li>
</ul>
<p>Safety is one of the most important objectives here. An erroneous application can cause major disasters. It can even cost a company millions of dollars. In 2010, Toyota recalled over 400,000 of its Prius hybrid cars due to a software defect with the <strong>Anti-lock Braking System</strong> (<strong>ABS</strong>). In 1996, the <span>Ariane 5 rocket launched by the European Space Agency exploded just 40 seconds after launch. Of course, these are only a few more extreme examples. By utilizing best practices, we can avoid getting into these kinds of embarrassing and costly incidents.</span></p>
<p class="mce-root">Now, we understand the importance of <span>software design principles and </span>software quality objectives.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we started by going back in time and reviewing the history of design patterns. We discussed why design patterns can be useful for software professionals and how we would like to organize design patterns in this book given what we have learned in the past. </p>
<p>We went over several key software design principles that can be applied universally in any programming language, as it is important that we keep them in mind when developing code and applying design patterns in Julia. We covered SOLID, DRY, KISS, POLA, YAGNI, and POLP. These design principles are well known and well received by the object-oriented programming community.</p>
<p>Finally, we discussed some software quality objectives that we want to achieve by using design patterns. In this book, we have decided to focus on reusability, maintainability, performance, and safety objectives. We also appreciated the benefits of these objectives and reviewed some general guidelines for achieving these objectives.</p>
<p>The next chapter is going to be exciting! We will get our hands dirty and look into how Julia programs are organized and how to use Julia's type system, along with <span>some basics about Julia.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<p><span>Review the following questions t</span>o reinforce your understanding of the subjects in this chapter. Answers are provided at the back of the book:</p>
<ol>
<li>What are the benefits of using design patterns?</li>
<li>Name some key design principles.</li>
<li>What problem does the Open/Closed Principle solve?</li>
<li>Why is interface segregation important for software reusability?</li>
<li>What are the simplest ways to keep an application maintainable?</li>
<li>What is a good practice for avoiding over-engineered and bloated software?</li>
<li>How does memory usage affect system performance?</li>
</ol>


            </article>

            
        </section>
    </body></html>