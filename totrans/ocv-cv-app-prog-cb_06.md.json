["```py\n   cv::blur(image,result,\n            cv::Size(5,5)); // size of the filter\n```", "```py\ncv::GaussianBlur(image,\n        result, cv::Size(5,5), // size of the filter\n        1.5);   // parameter controlling \n                // the shape of the Gaussian\n```", "```py\n[0.0 0.0 0.00026 0.10645 0.78657 0.10645 0.00026 0.0 0.0]\n```", "```py\n[0.00761 0.036075 0.10959 0.21345 0.26666 \n 0.21345 0.10959 0.03608 0.00761 ]\n```", "```py\ncv::Mat gauss= cv::getGaussianKernel(9, sigma,CV_32F);\n```", "```py\n  // first remove high frequency component\n  cv::GaussianBlur(image,image,cv::Size(11,11),2.0);\n  // keep only 1 of every 4 pixels\n  cv::Mat reduced2(image.rows/4,image.cols/4,CV_8U);\n  for (int i=0; i<reduced2.rows; i++)\n    for (int j=0; j<reduced2.cols; j++)\n      reduced2.at<uchar>(i,j)= image.at<uchar>(i*4,j*4);\n```", "```py\ncv::Mat reducedImage;  // to contain reduced image\ncv::pyrDown(image,reducedImage); // reduce image size by half\n```", "```py\ncv::Mat resizedImage;  // to contain resized image\ncv::resize(image,resizedImage,\n     cv::Size(image.cols/4,image.rows/4)); // 1/4 resizing\n```", "```py\ncv::resize(image,resizedImage,\n           cv::Size(), 1.0/4.0, 1.0/4.0); // 1/4 resizing\n```", "```py\n  cv::resize(reduced, newImage, \n               cv::Size(), 3, 3,cv::INTER_NEAREST);\n```", "```py\n  cv::resize(reduced2, newImage, \n               cv::Size(), 3, 3, cv::INTER_LINEAR);\n```", "```py\n   cv::medianBlur(image,result,5); // size of the filter\n```", "```py\n  cv::Sobel(image,    // input\n           sobelX,    // output\n           CV_8U,     // image type\n           1, 0,      // kernel specification\n           3,         // size of the square kernel \n           0.4, 128); // scale and offset\n```", "```py\n  cv::Sobel(image,    // input\n           sobelY,    // output\n           CV_8U,     // image type\n           0, 1,      // kernel specification\n           3,         // size of the square kernel \n           0.4, 128); // scale and offset\n```", "```py\n   // Compute norm of Sobel\n   cv::Sobel(image,sobelX,CV_16S,1,0);\n   cv::Sobel(image,sobelY,CV_16S,0,1);\n   cv::Mat sobel;\n   //compute the L1 norm\n   sobel= abs(sobelX)+abs(sobelY);\n```", "```py\n   // Find Sobel max value\n   double sobmin, sobmax;\n   cv::minMaxLoc(sobel,&sobmin,&sobmax);\n   // Conversion to 8-bit image\n   // sobelImage = -alpha*sobel + 255\n   cv::Mat sobelImage;\n   sobel.convertTo(sobelImage,CV_8U,-255./sobmax,255);\n```", "```py\n   cv::threshold(sobelImage, sobelThresholded, \n                      threshold, 255, cv::THRESH_BINARY);\n```", "```py\n   cv::Sobel(image,  // input\n             sobel,  // output\n             image_depth,   // image type\n             xorder,yorder, // kernel specification\n             kernel_size,   // size of the square kernel \n             alpha, beta);  // scale and offset\n```", "```py\n   //compute the L1 norm\n   sobel= abs(sobelX)+abs(sobelY);\n```", "```py\n   // Sobel must be computed in floating points\n   cv::Sobel(image,sobelX,CV_32F,1,0);\n   cv::Sobel(image,sobelY,CV_32F,0,1);\n   // Compute the L2 norm and direction of the gradient\n   cv::Mat norm, dir;   \n   cv::cartToPolar(sobelX,sobelY,norm,dir);\n```", "```py\n   cv::Sobel(image,sobelX,CV_16S,1,0, CV_SCHARR);\n```", "```py\n   cv::Scharr(image,scharrX,CV_16S,1,0,3);\n```", "```py\nclass LaplacianZC {\n\n  private:\n    // laplacian\n    cv::Mat laplace;\n    // Aperture size of the laplacian kernel\n    int aperture;\n\n  public:\n\n     LaplacianZC() : aperture(3) {}\n\n     // Set the aperture size of the kernel\n     void setAperture(int a) {\n        aperture= a;\n     }\n\n     // Compute the floating point Laplacian\n     cv::Mat computeLaplacian(const cv::Mat& image) {\n\n        // Compute Laplacian\n        cv::Laplacian(image,laplace,CV_32F,aperture);\n        return laplace;\n     }\n```", "```py\n     // Get the Laplacian result in 8-bit image \n     // zero corresponds to gray level 128\n     // if no scale is provided, then the max value will be\n     // scaled to intensity 255\n     // You must call computeLaplacian before calling this\n     cv::Mat getLaplacianImage(double scale=-1.0) {\n        if (scale<0) {\n           double lapmin, lapmax;\n           // get min and max laplacian values\n           cv::minMaxLoc(laplace,&lapmin,&lapmax);\n           // scale the laplacian to 127\n           scale= 127/ std::max(-lapmin,lapmax);\n        }\n\n        // produce gray-level image\n        cv::Mat laplaceImage;\n        laplace.convertTo(laplaceImage,CV_8U,scale,128);\n        return laplaceImage;\n     }\n```", "```py\n   // Compute Laplacian using LaplacianZC class\n   LaplacianZC laplacian;\n   laplacian.setAperture(7); // 7x7 laplacian\n   cv::Mat flap= laplacian.computeLaplacian(image);\n   laplace= laplacian.getLaplacianImage();\n```", "```py\n    // Get a binary image of the zero-crossings\n    // laplacian image should be CV_32F\n    cv::Mat getZeroCrossings(cv::Mat laplace) {\n\n      // threshold at 0\n      // negative values in black\n      // positive values in white\n      cv::Mat signImage;\n      cv::threshold(laplace,signImage,0,255,cv::THRESH_BINARY);\n\n      // convert the +/- image into CV_8U\n      cv::Mat binary;\n      signImage.convertTo(binary,CV_8U);\n      // dilate the binary image of +/- regions\n      cv::Mat dilated;\n      cv::dilate(binary,dilated,cv::Mat());\n\n      // return the zero-crossing contours\n      return dilated-binary;\n    }\n```", "```py\n  cv::GaussianBlur(image,gauss20,cv::Size(),2.0);\n  cv::GaussianBlur(image,gauss22,cv::Size(),2.2);\n\n  // compute a difference of Gaussians \n  cv::subtract(gauss22, gauss20, dog, cv::Mat(), CV_32F);\n\n  // Compute the zero-crossings of DoG \n  zeros= laplacian.getZeroCrossings(dog);\n```"]