["```py\nimport numpy as np\n```", "```py\nnp.array([1,3,5,7])\n```", "```py\narray([1, 3, 5, 7])\n```", "```py\nA = np.mat([[1,2],[3,3]])\nA\n```", "```py\nmatrix([[1, 2],\n        [3, 3]])\n```", "```py\nA + A\n```", "```py\nmatrix([[2, 4],\n        [6, 6]])\n```", "```py\nA - A\n```", "```py\nmatrix([[0, 0],\n        [0, 0]])\n```", "```py\nA * A\n```", "```py\nmatrix([[ 7, 8],\n        [12, 15]])\n```", "```py\nnp.linalg.det( A )\n```", "```py\nnp.matrix.transpose(A)\n```", "```py\nmatrix([[1, 3],\n        [2, 3]])\n```", "```py\n    import numpy as np\n    ```", "```py\n    A = np.mat([[1,2,3],[4,5,6],[7,8,9]])\n    ```", "```py\n    A * A\n    ```", "```py\n    matrix([[ 30, 36, 42],\n             [ 66, 81, 96],\n             [102, 126, 150]])\n    ```", "```py\n    1 * 1 + 2 * 4 + 3 * 7\n    ```", "```py\n    np.linalg.det( A )\n    ```", "```py\n    1*5*9 + 2*6*7 + 3*4*8 - 1*6*8 - 2*4*9 - 3*5*7\n    ```", "```py\n    np.matrix.transpose(A)\n    ```", "```py\n    matrix([[1, 4, 7],\n             [2, 5, 8],\n             [3, 6, 9]])\n    ```", "```py\nroot = {'value': 1, 'depth': 1}\ndef succ(node):\n    if node['value'] == 5:\nreturn []\nelif node['value'] == 4:\nreturn [{'value': 5,'depth': node['depth']+1}]\nelse:\nreturn [\n{'value': node['value']+1, 'depth':node['depth']+1},\n{'value': node['value']+2, 'depth':node['depth']+1}\n]\n```", "```py\ndef bfs_tree(node):\nnodes_to_visit = [node]\nvisited_nodes = []\nwhile len(nodes_to_visit) > 0:\ncurrent_node = nodes_to_visit.pop(0)\nvisited_bodes.append(current_node)\nnodes_to_visit.extend(succ(current_node))\nreturn visited_nodes\nbfs_tree(root)\n```", "```py\n[{'depth': 1, 'value': 1},\n{'depth': 2, 'value': 2},\n{'depth': 2, 'value': 3},\n{'depth': 3, 'value': 3},\n{'depth': 3, 'value': 4},\n{'depth': 3, 'value': 4},\n{'depth': 3, 'value': 5},\n{'depth': 4, 'value': 4},\n{'depth': 4, 'value': 5},\n{'depth': 4, 'value': 5},\n{'depth': 4, 'value': 5},\n{'depth': 5, 'value': 5}]\n```", "```py\ndef dfs_tree(node):\nnodes_to_visit = [node]\nvisited_nodes = []\nwhile len(nodes_to_visit) > 0:\ncurrent_node = nodes_to_visit.pop()\nvisited_nodes.append(current_node)\nnodes_to_visit.extend(succ(current_node))\nreturn visited_nodes\ndfs_tree(root)\n```", "```py\n[{'depth': 1, 'value': 1},\n{'depth': 2, 'value': 3},\n{'depth': 3, 'value': 5},\n{'depth': 3, 'value': 4},\n{'depth': 4, 'value': 5},\n{'depth': 2, 'value': 2},\n{'depth': 3, 'value': 4},\n{'depth': 4, 'value': 5},\n{'depth': 3, 'value': 3},\n{'depth': 4, 'value': 5},\n{'depth': 4, 'value': 4},\n{'depth': 5, 'value': 5}]\n```", "```py\nfrom random import choice\nchoice([2, 4, 6, 8])\n```", "```py\n    from random import choice\n    ```", "```py\n    combo_indices = [\n        [0, 1, 2],\n        [3, 4, 5],\n        [6, 7, 8],\n        [0, 3, 6],\n        [1, 4, 7],\n        [2, 5, 8],\n        [0, 4, 8],\n        [2, 4, 6]\n    ]\n    ```", "```py\n    EMPTY_SIGN = '.'\n    AI_SIGN = 'X'\n    OPPONENT_SIGN = 'O'\n    ```", "```py\n    def print_board(board):\n        print(\" \")\n        print(' '.join(board[:3]))\n        print(' '.join(board[3:6]))\n        print(' '.join(board[6:]))\n        print(\" \")\n    ```", "```py\n    def opponent_move(board, row, column):\n        index = 3 * (row - 1) + (column - 1)\n        if board[index] == EMPTY_SIGN:\n            return board[:index] + OPPONENT_SIGN + board[index+1:]\n        return board\n    ```", "```py\n    def all_moves_from_board_list(board, sign):\n        move_list = []\n        for i, v in enumerate(board):\n            if v == EMPTY_SIGN:\n                move_list.append(board[:i] + sign + board[i+1:])\n        return move_list\n    def ai_move(board):\n        return choice(all_moves_from_board(board, AI_SIGN))\n    ```", "```py\n    def game_won_by(board):\n        for index in combo_indices:\n            if board[index[0]] == board[index[1]] == board[index[2]] != EMPTY_SIGN:\n                return board[index[0]]\n        return EMPTY_SIGN\n    ```", "```py\n    def game_loop():\n        board = EMPTY_SIGN * 9\n        empty_cell_count = 9\n        is_game_ended = False\n        while empty_cell_count > 0 and not is_game_ended:\n            if empty_cell_count % 2 == 1:\n                board = ai_move(board)\n            else:\n                row = int(input('Enter row: '))\n                col = int(input('Enter column: '))\n                board = opponent_move(board,&#9; row, col)\n            print_board(board)\n            is_game_ended = game_won_by(board) != EMPTY_SIGN\n        empty_cell_count = sum(\n                1 for cell in board if cell == EMPTY_SIGN\n            )\n        print('Game has been ended.')\n    ```", "```py\n    game_loop()\n    ```"]