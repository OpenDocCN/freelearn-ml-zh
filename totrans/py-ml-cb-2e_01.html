<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">The Realm of Supervised Learning</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will cover the following recipes:</p>
<ul>
<li>Array creation in Python</li>
<li>Data preprocessing using mean removal</li>
<li>Data scaling</li>
<li>Normalization</li>
<li>Binarization</li>
<li>One-hot encoding</li>
<li>Label encoding</li>
<li>Building a linear regressor</li>
<li>Computing regression accuracy</li>
<li>Achieving model persistence</li>
<li>Building a ridge regressor</li>
<li>Building a polynomial regressor</li>
<li>Estimating housing prices</li>
<li>Computing the relative importance of features</li>
<li>Estimating bicycle demand distribution</li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p class="mce-root">We will use various Python packages, such as NumPy, SciPy, scikit-learn, and Matplotlib, during the course of this book to build various things. If you use Windows, it is recommended that you use a SciPy-stack-compatible version of Python. You can check the list of compatible versions at<span> </span><a href="http://www.scipy.org/install.html">http://www.scipy.org/install.html</a><a href="http://www.scipy.org/install.html">.</a><span> </span>These distributions come with all the necessary packages already installed. If you use MacOS X or Ubuntu, installing these packages is fairly straightforward. Here are some useful links for installation and documentation:</p>
<ul>
<li>NumPy: <a href="https://www.numpy.org/devdocs/user/install.html">https://www.numpy.org/devdocs/user/install.html</a>.</li>
<li>SciPy:<span> </span><a href="http://www.scipy.org/install.html">http://www.scipy.org/install.html.</a></li>
<li>Scikit-learn: <a href="https://scikit-learn.org/stable/install.html">https://scikit-learn.org/stable/install.html</a>.</li>
<li>Matplotlib: <a href="https://matplotlib.org/users/installing.html">https://matplotlib.org/users/installing.html</a>.</li>
</ul>
<p>Make sure that you have these packages installed on your machine before you proceed. In each recipe, we will give a detailed explanation of the functions that we will use in order to make it simple and fast.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p><span>Machine learning is a multidisciplinary field created at the intersection of, and with synergy between, computer science, statistics, neurobiology, and control theory. It has played a key role in various fields and has radically changed the vision of programming software. For humans, and more generally, for every living being, learning is a form of adaptation of a system to its environment through experience. This adaptation process must lead to improvement without human intervention. To achieve this goal, the system must be able to learn, which means that it must be able to extract useful information on a given problem by examining a series of examples associated with it.</span></p>
<p>If you are familiar with the basics of machine learning, you will certainly know what supervised learning is all about. To give you a quick refresher, <strong>supervised learning</strong> refers to building a machine learning model that is based on labeled samples. The algorithm generates a function which connects input values to a desired output via of a set of labeled examples, where each data input has its relative output data. This is used to construct predictive models. For example, if we build a system to estimate the price of a house based on various parameters, such as size, locality, and so on, we first need to create a database and label it. We need to tell our algorithm what parameters correspond to what prices. Based on this data, our algorithm will learn how to calculate the price of a house using the input parameters.</p>
<p><strong>Unsupervised learning</strong> is in stark contrast to what we just discussed. There is no labeled data available here. The algorithm tries to acquire knowledge from general input without the help of a set of pre-classified examples that are used to build descriptive models. Let's assume that we have a bunch of data points, and we just want to separate them into multiple groups. We don't exactly know what the criteria of separation would be. So, an unsupervised learning algorithm will try to separate the given dataset into a fixed number of groups in the best possible way. We will discuss unsupervised learning in the upcoming chapters.</p>
<p>In the following recipes, we will look at various data preprocessing techniques.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Array creation in Python</h1>
                </header>
            
            <article>
                
<p>Arrays are the essential elements of many programming languages. Arrays are sequential objects that behave very similarly to lists, except that the types of elements contained in them are constrained. The type is specified when the object is created using a single character called <strong>type code</strong>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>In this recipe, we will cover an array creation procedure. We will first create an array using the NumPy library, and then display its structure.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it…</h1>
                </header>
            
            <article>
                
<p>Let's see how to create an array in Python:</p>
<ol>
<li>To start off, import the NumPy library as follows<span>:</span></li>
</ol>
<pre style="padding-left: 60px"><strong>&gt;&gt; import numpy as np</strong></pre>
<p style="padding-left: 60px">We just imported a necessary package, <kbd>numpy</kbd>. This is the fundamental package for scientific computing with Python. It contains, among other things, the following:</p>
<ul style="padding-left: 60px">
<li>A powerful N-dimensional array object</li>
<li>Sophisticated broadcasting functions</li>
<li>Tools for integrating C, C++, and FORTRAN code</li>
<li>Useful linear algebra, Fourier transform, and random number capabilities</li>
</ul>
<p class="mce-root"/>
<p style="padding-left: 60px">Besides its obvious uses, NumPy is also used as an efficient multidimensional container of generic data. Arbitrary data types can be found. This enables NumPy to integrate with different types of databases.  </p>
<div class="packt_tip">Remember, to import a library that is not present in the initial distribution of Python, you must use the <kbd>pip install</kbd> command followed by the name of the library. This command should be used only once and not every time you run the code.</div>
<ol start="2">
<li>Let's create some sample data. Add the following line to the Python Terminal:</li>
</ol>
<pre style="padding-left: 60px"><strong>&gt;&gt; data = np.array([[3, -1.5, 2, -5.4], [0, 4, -0.3, 2.1], [1, 3.3, -1.9, -4.3]])</strong></pre>
<p style="padding-left: 60px">The <kbd>np.array</kbd> function creates a NumPy array. A NumPy array is a grid of values, all of the same type, indexed by a tuple of non-negative integers. <kbd>rank</kbd><span> and </span><kbd>shape</kbd> are essential features of a NumPy array. The <kbd>rank</kbd> variable is the number of dimensions of the array. The <kbd>shape</kbd> variable is a tuple of integers that returns the size of the array along each dimension.</p>
<ol start="3">
<li>We display the newly created array with this snippet:</li>
</ol>
<pre style="padding-left: 60px"><strong>&gt;&gt; print(data)</strong></pre>
<p style="padding-left: 60px">The following result is returned:</p>
<pre style="padding-left: 60px"><strong>[[ 3. -1.5  2.  -5.4]</strong><br/><strong> [ 0.  4.  -0.3  2.1]</strong><br/><strong> [ 1.  3.3 -1.9 -4.3]]</strong></pre>
<p style="padding-left: 60px">We are now ready to operate on this data.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works…</h1>
                </header>
            
            <article>
                
<p>NumPy is an extension package in the Python environment that is fundamental for scientific calculation. This is because it adds to the tools that are already available, the typical features of N-dimensional arrays, <span>element-by-element </span>operations, a massive number of mathematical operations in linear algebra, and the ability to integrate and recall source code written in C, C++, and FORTRAN. In this recipe, we learned how to create an array using the NumPy library.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>NumPy provides us with various tools for creating an array. For example, to create a one-dimensional array of equidistant values with numbers from 0 to 10, we would use the <span><kbd>arange()</kbd> </span><span>function, as follows:</span></p>
<pre><strong>&gt;&gt; NpArray1 = np.arange(10)</strong><br/><strong>&gt;&gt; print(NpArray1)</strong></pre>
<p>The following result is returned:</p>
<pre><strong>[0 1 2 3 4 5 6 7 8 9]</strong></pre>
<p>To create a numeric array from 0 to 50, with a step of 5 (using a predetermined step between successive values), we will write the following code:</p>
<pre><strong>&gt;&gt; NpArray2 = np.arange(10, 100, 5)</strong><br/><strong>&gt;&gt; print(NpArray2)</strong></pre>
<p><span>The following array</span> <span>is printed:</span></p>
<pre><strong>[10 15 20 25 30 35 40 45 50 55 60 65 70 75 80 85 90 95]</strong></pre>
<p>Also, to create a one-dimensional array of 50 numbers between two limit values and that are equidistant in this range, we will use the <kbd>linspace()</kbd> function:</p>
<pre><strong>&gt;&gt; NpArray3 = np.linspace(0, 10, 50)</strong><br/><strong>&gt;&gt; print(NpArray3)</strong></pre>
<p><span>The following result is returned:</span></p>
<pre><strong>[ 0. 0.20408163 0.40816327 0.6122449 0.81632653 1.02040816</strong><br/><strong> 1.2244898 1.42857143 1.63265306 1.83673469 2.04081633 2.24489796</strong><br/><strong> 2.44897959 2.65306122 2.85714286 3.06122449 3.26530612 3.46938776</strong><br/><strong> 3.67346939 3.87755102 4.08163265 4.28571429 4.48979592 4.69387755</strong><br/><strong> 4.89795918 5.10204082 5.30612245 5.51020408 5.71428571 5.91836735</strong><br/><strong> 6.12244898 6.32653061 6.53061224 6.73469388 6.93877551 7.14285714</strong><br/><strong> 7.34693878 7.55102041 7.75510204 7.95918367 8.16326531 8.36734694</strong><br/><strong> 8.57142857 8.7755102 8.97959184 9.18367347 9.3877551 9.59183673</strong><br/><strong> 9.79591837 10. ]</strong></pre>
<p>These are just some simple samples of NumPy. In the following sections, we will delve deeper into the topic.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li>NumPy developer guide (<a href="https://docs.scipy.org/doc/numpy/dev/">https://docs.scipy.org/doc/numpy/dev/</a>).</li>
<li>NumPy tutorial (<a href="https://docs.scipy.org/doc/numpy/user/quickstart.html">https://docs.scipy.org/doc/numpy/user/quickstart.html</a>).</li>
<li>NumPy reference (<a href="https://devdocs.io/numpy~1.12/">https://devdocs.io/numpy~1.12/</a>).</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Data preprocessing using mean removal</h1>
                </header>
            
            <article>
                
<p><span>In the real world, we usually have to deal with a lot of raw data. This raw data is not readily ingestible by machine learning algorithms. To prepare data for machine learning, we have to preprocess it before we feed it into various algorithms. This is an intensive process that takes plenty of time, almost 80 percent of the entire data analysis process, in some scenarios. However, it is vital for the rest of the data analysis workflow, so it is necessary to learn the best practices of these techniques. Before sending our data to any machine learning algorithm, we need to cross check the quality and accuracy of the data. If we are unable to reach the data stored in Python correctly, or if we can't switch from raw data to something that can be analyzed, we cannot go ahead. </span>Data can be preprocessed in many ways—standardization, scaling, normalization, binarization, and one-hot encoding are some examples of preprocessing techniques. We will address them through simple examples.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p><strong>Standardization</strong> or <strong>mean removal</strong> is a technique that simply centers data by removing the average value of each characteristic, and then scales it by dividing non-constant characteristics by their standard deviation. It's usually beneficial to remove the mean from each feature so that it's centered on zero. This helps us remove bias from features. The formula used to achieve this is the following:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/8282b2fb-9150-4786-8efd-2ec5f41423be.png" style="width:12.25em;height:3.08em;"/></p>
<p>Standardization results in the rescaling of features, which in turn represents the properties of a standard normal distribution:</p>
<ul>
<li><strong>mean </strong>= 0</li>
<li><strong>sd </strong>= 1</li>
</ul>
<p>In this formula, <strong>mean</strong> is the mean and <strong>sd</strong> is the standard deviation from the mean. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p><span>Let's see how to preprocess data in Python:</span></p>
<ol>
<li>Let's start by importing the library:</li>
</ol>
<pre style="padding-left: 60px"><strong>&gt;&gt; from sklearn import preprocessing</strong></pre>
<p style="padding-left: 60px"><span>The <kbd>sklearn</kbd> library is a free software machine learning library for the Python programming language. It features various classification, regression, and clustering algorithms, including <strong>support vector machines</strong> (<strong>SVMs</strong>), random forests, gradient boosting, k-means, and DBSCAN, and is designed to interoperate with the Python numerical and scientific libraries, NumPy and SciPy. </span></p>
<ol start="2">
<li>To understand the outcome of mean removal on our data, we first visualize the mean and standard deviation of the vector we have just created:</li>
</ol>
<pre style="padding-left: 60px"><strong>&gt;&gt; print("Mean: ",data.mean(axis=0))</strong><br/><strong>&gt;&gt; print("Standard Deviation: ",data.std(axis=0))</strong></pre>
<p style="padding-left: 60px">The <kbd>mean()</kbd> function returns the sample arithmetic mean of data, which can be a sequence or an iterator. The <kbd>std()</kbd> function returns the standard deviation, a measure of the distribution of the array elements. The <kbd>axis</kbd> parameter specifies the axis along which these functions are computed (<kbd>0</kbd> for columns, and <kbd>1</kbd> for rows).</p>
<p style="padding-left: 60px">The following results are returned:</p>
<pre style="padding-left: 60px"><strong>Mean: [ 1.33333333 1.93333333 -0.06666667 -2.53333333]</strong><br/><strong>Standard Deviation: [1.24721913 2.44449495 1.60069429 3.30689515]</strong></pre>
<p class="mce-root"/>
<ol start="3">
<li>Now we can proceed with standardization:</li>
</ol>
<pre style="padding-left: 60px"><strong>&gt;&gt; data_standardized = preprocessing.scale(data)</strong></pre>
<p style="padding-left: 60px">The <kbd>preprocessing.scale()</kbd> function standardizes a dataset along any axis. This method centers the data on the mean and resizes the components in order to have a unit variance. </p>
<ol start="4">
<li>Now we recalculate the mean and standard deviation on the standardized data:</li>
</ol>
<pre style="padding-left: 60px"><strong>&gt;&gt; print("Mean standardized data: ",data_standardized.mean(axis=0))</strong><br/><strong>&gt;&gt; print("Standard Deviation standardized data: ",data_standardized.std(axis=0))</strong></pre>
<p style="padding-left: 60px"><span>The following results are returned:</span></p>
<pre style="padding-left: 60px"><strong>Mean standardized data: [ 5.55111512e-17 -1.11022302e-16 -7.40148683e-17 -7.40148683e-17]</strong><br/><strong>Standard Deviation standardized data: [1. 1. 1. 1.]</strong></pre>
<p style="padding-left: 60px">You can see that the mean is almost 0 and the standard deviation is 1.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p><span>The </span><kbd>sklearn.preprocessing</kbd><span> package provides several common utility functions and </span><span>transformer classes to modify the features available in a representation that best suits our </span><span>needs. In this recipe, the <kbd>scale()</kbd> function has been used (z-score standardization).  In summary, the z-score (also called the standard score) represents the number of standard deviations by which the value of an observation point or data is greater than the mean value of what is observed or measured. Values more than the mean have positive z-scores, while values less than the mean have negative z-scores. The z-score is a quantity without dimensions that is obtained by subtracting the population's mean from a single rough score and then dividing the difference by the standard deviation of the population.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>Standardization is particularly useful when we do not know the minimum and maximum for data distribution. In this case, it is not possible to use other forms of data transformation. As a result of the transformation, the normalized values do not have a minimum and a fixed maximum. Moreover, this technique is not influenced by the presence of outliers, or at least not the same as other methods.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li><span>Scikit-learn's </span><span>official documentation of the </span><kbd>sklearn.preprocessing.scale()</kbd> function: <a href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.scale.html">https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.scale.html</a>.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Data scaling</h1>
                </header>
            
            <article>
                
<p>The values of each feature in a dataset can vary between random values. So, sometimes it is important to scale them so that this becomes a level playing field. Through this statistical procedure, it's possible to compare identical variables belonging to different distributions and different variables.</p>
<div class="packt_tip">Remember, it is good practice to rescale data before training a machine learning algorithm. With rescaling, data units are eliminated, allowing you to easily compare data from different locations.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We'll use the <strong>min-max</strong> method (usually called <strong>feature scaling</strong>) to get all of the scaled data in the range [0, 1]. The formula used to achieve this is as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/8da27764-09bf-477e-8b25-1e8a0e956188.png" style="width:13.67em;height:3.25em;"/></p>
<p>To scale features between a given minimum and maximum value—in our case, between 0 and 1—so that the maximum absolute value of each feature is scaled to unit size, the <kbd>preprocessing.MinMaxScaler()</kbd> function can be used. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p><span>Let's see how to scale data in Python:</span></p>
<ol>
<li>Let's start by defining the <kbd>data_scaler</kbd> variable:</li>
</ol>
<pre style="padding-left: 60px"><strong>&gt;&gt; data_scaler = preprocessing.MinMaxScaler(feature_range=(0, 1))</strong></pre>
<p class="mce-root"/>
<ol start="2">
<li>Now we will use the <kbd>fit_transform()</kbd> method, which fits the data and then transforms it (we will use the same data as in the previous recipe):</li>
</ol>
<pre style="padding-left: 60px"><strong>&gt;&gt; data_scaled = data_scaler.fit_transform(data)</strong></pre>
<p style="padding-left: 60px"><span>A NumPy array of a specific shape is </span><span>returned. To understand how this function has transformed data, we display the minimum and maximum of each column in the array.</span></p>
<ol start="3">
<li><span>First, for the starting data and then for the processed data:</span></li>
</ol>
<pre style="padding-left: 60px"><strong>&gt;&gt; print("Min: ",data.min(axis=0))</strong><br/><strong>&gt;&gt; print("Max: ",data.max(axis=0))</strong></pre>
<p style="padding-left: 60px"><span>The following results are returned:</span></p>
<pre style="padding-left: 60px"><strong>Min: [ 0. -1.5 -1.9 -5.4]</strong><br/><strong>Max: [3. 4. 2. 2.1]</strong></pre>
<ol start="4">
<li>Now, let's do the same for the scaled data using the following code:</li>
</ol>
<pre style="padding-left: 60px"><strong>&gt;&gt; print("Min: ",data_scaled.min(axis=0))</strong><br/><strong>&gt;&gt; print("Max: ",data_scaled.max(axis=0))</strong></pre>
<p style="padding-left: 60px"><span>The following results are returned:</span></p>
<pre style="padding-left: 60px"><strong>Min: [0. 0. 0. 0.]</strong><br/><strong>Max: [1. 1. 1. 1.]</strong></pre>
<p style="padding-left: 60px">After scaling, all the feature values range between the specified values. </p>
<ol start="5">
<li><span>To display the scaled array, we will use the following code:</span></li>
</ol>
<pre style="padding-left: 60px"><strong>&gt;&gt; print(data_scaled)</strong></pre>
<p style="padding-left: 60px">The output will be displayed as follows:</p>
<pre style="padding-left: 60px"><strong>[[ 1.          0.          1.          0.        ] </strong><br/><strong> [ 0.          1.          0.41025641  1.        ]</strong><br/><strong> [ 0.33333333  0.87272727  0.          0.14666667]]</strong></pre>
<p style="padding-left: 60px">Now, all the data is included in the same interval.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>When data has different ranges, the impact on response variables might be higher than the one with a lesser numeric range, which can affect the prediction accuracy. Our goal is to improve predictive accuracy and ensure this doesn't happen. Hence, we may need to scale values under different features so that they fall within a similar range. Through this statistical procedure, it's possible to compare identical variables belonging to different distributions and different variables or variables expressed in different units.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p><span>Feature scaling </span>consists of limiting the excursion of a set of values within a certain predefined interval. It guarantees that all functionalities have the exact same scale, but does not handle anomalous values well. This is because extreme values become the extremes of the new range of variation. In this way, the actual values are compressed by keeping the distance to the anomalous values.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li><span>Scikit-learn's </span><span>official documentation</span> of the <kbd>sklearn.preprocessing.MinMaxScaler()</kbd> function: <a href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.MinMaxScaler.html">https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.MinMaxScaler.html</a>.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Normalization</h1>
                </header>
            
            <article>
                
<p>Data normalization is used when you want to adjust the values in the feature vector so that they can be measured on a common scale. One of the most common forms of normalization that is used in machine learning adjusts the values of a feature vector so that they sum up to 1.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p><span>To normalize data, </span><span>the </span><kbd>preprocessing.normalize()</kbd><span> function can be used.  </span>This function<span> </span><span>scales input vectors individually to a unit norm (vector length). Three types of norms are provided, <strong>l<sub>1</sub></strong>, <strong>l<sub>2</sub></strong>, or <strong>max</strong>, and they are explained next. If <em>x</em> is the vector of covariates of length <em>n</em>, the normalized vector is <em>y=x/z</em>, where <em>z</em> is defined as follows:</span></p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/de658bc4-42c5-4a71-b740-b2b037556c0b.png" style="width:84.17em;height:18.33em;"/></p>
<p>The <strong>norm</strong> is a function that assigns <span>a positive length </span>to each vector belonging to a vector space, except 0.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p><span>Let's see how to normalize data in Python:</span></p>
<ol>
<li>As we said, to normalize data, <span>the </span><kbd>preprocessing.normalize()</kbd><span> function can be used as follows (we will use the same data as in the previous recipe)</span>:</li>
</ol>
<pre style="padding-left: 60px"><strong>&gt;&gt; data_normalized = preprocessing.normalize(data, norm='l1', axis=0)</strong></pre>
<ol start="2">
<li><span>To display the normalized array, we will use the following code:</span></li>
</ol>
<pre style="padding-left: 60px"><strong>&gt;&gt; print(data_normalized)</strong></pre>
<p style="padding-left: 60px">The following output is returned:</p>
<pre style="padding-left: 60px"><strong>[[ 0.75 -0.17045455  0.47619048  -0.45762712]</strong><br/><strong> [ 0.    0.45454545 -0.07142857   0.1779661 ]</strong><br/><strong> [ 0.25  0.375      -0.45238095  -0.36440678]]</strong></pre>
<p style="padding-left: 60px">This is used a lot to make sure that datasets don't get boosted artificially due to the fundamental nature of their features. </p>
<p class="mce-root"/>
<ol start="3">
<li>As already mentioned, the normalized array along the columns (features) must return a sum equal to 1. Let's check <span>this for each column</span>:</li>
</ol>
<pre style="padding-left: 60px"><strong>&gt;&gt; data_norm_abs = np.abs(data_normalized)</strong><br/><strong>&gt;&gt; print(data_norm_abs.sum(axis=0))</strong></pre>
<p style="padding-left: 60px">In the first line of code, we used the <kbd>np.abs()</kbd> function to evaluate the absolute value of each element in the array. In the second row of code, we used the <kbd>sum()</kbd> function to calculate the sum of each column (<kbd>axis=0</kbd>). The following results are returned:</p>
<pre style="padding-left: 60px"><strong>[1. 1. 1. 1.]</strong></pre>
<p style="padding-left: 60px">Therefore, the sum of the absolute value of the elements of each column is equal to 1, so the data is normalized.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>In this recipe, we normalized the data at our disposal to the unitary norm. Each sample with at least one non-zero component was rescaled independently of other samples so that its norm was equal to one.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>Scaling inputs to a unit norm is a very common task in text classification and clustering problems.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li><span>Scikit-learn's </span><span>official documentation</span> of the <kbd>sklearn.preprocessing.normalize()</kbd> function: <a href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.normalize.html">https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.normalize.html</a>.</li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Binarization</h1>
                </header>
            
            <article>
                
<p>Binarization is used when you want to convert a numerical feature vector into a Boolean vector. In the field of digital image processing, image binarization is the process by which a color or grayscale image is transformed into a binary image, that is, an image with only two colors (typically, black and white).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>This technique is used for the recognition of objects, shapes, and, specifically, characters. Through binarization, it is possible to distinguish the object of interest from the background on which it is found. Skeletonization is instead an essential and schematic representation of the object, which generally preludes the subsequent real recognition.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p><span>Let's see how to binarize data in Python:</span></p>
<ol>
<li>To binarize data, we will use the  <kbd>preprocessing.Binarizer()</kbd><span> func</span><span>tion as follows </span>(<span>we will use the same data as in the previous recipe</span>):</li>
</ol>
<pre style="padding-left: 60px"><strong>&gt;&gt; data_binarized = preprocessing.Binarizer(threshold=1.4).transform(data)</strong></pre>
<p style="padding-left: 60px">The <kbd>preprocessing.Binarizer()</kbd> func<span>tion binarizes data according to an imposed <kbd>threshold</kbd>. Values greater than the <kbd>threshold</kbd> map to 1, while values less than or equal to the <kbd>threshold</kbd> map to 0. With the default <kbd>threshold</kbd> of 0, only positive values map to 1. In our case, the <kbd>threshold</kbd> imposed is <kbd>1.4</kbd>, so values greater than <kbd>1.4</kbd> are mapped to 1, while values less than <kbd>1.4</kbd> are mapped to 0.</span></p>
<ol start="2">
<li><span>To display the binarized array, we will use the following code:</span></li>
</ol>
<pre style="padding-left: 60px"><strong>&gt;&gt; print(data_binarized)</strong></pre>
<p style="padding-left: 60px">The following output is returned:</p>
<pre style="padding-left: 60px"><strong>[[ 1.  0.  1.  0.]</strong><br/><strong> [ 0.  1.  0.  1.]</strong><br/><strong> [ 0.  1.  0.  0.]]</strong></pre>
<p class="mce-root"/>
<p style="padding-left: 60px">This is a very useful technique that's usually used when we have some prior knowledge of the data.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>In this recipe, we binarized the data. The fundamental idea of ​​this technique is to draw a fixed demarcation line. It is therefore a matter of finding an appropriate threshold and affirming that all the points of the image whose light intensity is below a certain value belong to the object (background), and all the points with greater intensity belong to the background (object).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>Binarization is a widespread operation on count data, in which the analyst can decide to consider only the presence or absence of a characteristic rather than a quantified number of occurrences. Otherwise, it can be used as a preprocessing step for estimators that consider random Boolean variables.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li><span>Scikit-learn's </span><span>official documentati</span>on of the <kbd>sklearn.preprocessing.Binarizer()</kbd> function: <a href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.Binarizer.html">https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.Binarizer.html</a>.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">One-hot encoding</h1>
                </header>
            
            <article>
                
<p>We often deal with numerical values that are sparse and scattered all over the place. We don't really need to store these values. This is where one-hot encoding comes into the picture. We can think of <span>one-hot encoding</span> as a tool that tightens feature vectors. It looks at each feature and identifies the total number of distinct values. It uses a <em>one-of-k</em> scheme to encode values. Each feature in the feature vector is encoded based on this scheme. This helps us <span>to </span>be more efficient in terms of space.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Let's say we are dealing with four-dimensional feature vectors. To encode the <em>nth</em> feature in a feature vector, the encoder will go through the <em>nth</em> feature in each feature vector and count the number of distinct values. If the number of distinct values is <em>k</em>, it will transform the feature into a <em>k</em>-dimensional vector where only one value is 1 and all other values are 0. Let's take a simple example to understand how this works.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p><span>Let's see how to encode data in Python:</span></p>
<ol>
<li>Let's take an array with four rows (vectors) and three columns (features):</li>
</ol>
<pre style="padding-left: 60px"><strong>&gt;&gt; data = np.array([[1, 1, 2], [0, 2, 3], [1, 0, 1], [0, 1, 0]])</strong><br/><strong>&gt;&gt; print(data)</strong></pre>
<p style="padding-left: 60px">The following result is printed:</p>
<pre style="padding-left: 60px"><strong>[[1 1 2]</strong><br/><strong> [0 2 3]</strong><br/><strong> [1 0 1]</strong><br/><strong> [0 1 0]]</strong></pre>
<p style="padding-left: 60px">Let's analyze the values present in each column (feature):</p>
<ul style="padding-left: 60px">
<li>The first feature has two possible values: 0, 1</li>
<li>The second feature has three possible values: 0, 1, 2</li>
<li>The third feature has four possible values: 0, 1, 2, 3</li>
</ul>
<p style="padding-left: 60px">So, overall, the sum of the possible values present in each feature is given by 2 + 3 + 4 = 9. This means that 9 entries are required to uniquely represent any vector. The three features will be represented as follows:</p>
<ul style="padding-left: 60px">
<li>Feature 1 starts at index <kbd>0</kbd></li>
<li>Feature 2 starts at index <kbd>2</kbd></li>
<li>Feature 3 starts at index <kbd>5</kbd></li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>
<ol start="2">
<li>To encode categorical integer features as a one-hot numeric array, the <kbd>preprocessing.OneHotEncoder()</kbd> function can be used as follows:</li>
</ol>
<pre style="padding-left: 60px"><strong>&gt;&gt; encoder = preprocessing.OneHotEncoder()</strong><br/><strong>&gt;&gt; encoder.fit(data)</strong></pre>
<p style="padding-left: 60px">The first row of code sets the encoder, then the <kbd>fit()</kbd> function fits the <kbd>OneHotEncoder</kbd> object to a data array. </p>
<ol start="3">
<li>Now we can transform the data array using one-hot encoding. To do this, the <kbd>transform()</kbd> function will be used as follows:</li>
</ol>
<pre style="padding-left: 60px"><strong>&gt;&gt; encoded_vector = encoder.transform([[1, 2, 3]]).toarray()</strong></pre>
<p style="padding-left: 60px">If you were to print <kbd>encoded_vector</kbd>, the expected output would be:</p>
<pre style="padding-left: 60px"><strong>[[0. 1. 0. 0. 1. 0. 0. 0. 1.]]</strong></pre>
<p style="padding-left: 60px">The result is clear: the first feature (1) has an index of 1, the second feature (3) has an index of 4, and the third feature (3) has an index of 8. As we can verify, only these positions are occupied by a 1; all the other positions have a 0. Remember that Python indexes the positions starting from 0, so the 9 entries will have indexes from 0 to 8.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The <kbd>preprocessing.OneHotEncoder()</kbd> function encodes categorical integer features as a one-hot numeric array. Starting from an array of integers or strings that denotes the values assumed by categorical characteristics (discrete), this function encodes the characteristics using a one-hot coding scheme, returning dummy variables. This creates a binary column for each category and returns a sparse array or a dense array.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>It often happens that you have to convert categorical data. This is due to the fact that many machine learning algorithms can't work directly with categorical data. To use these methods, it is necessary to first transform categorical data into numerical data. This is required for both input and output variables.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li><span>Scikit-learn's </span><span>official documentatio</span>n of the <kbd>sklearn.preprocessing.OneHotEncoder()</kbd> function: <a href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.OneHotEncoder.html">https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.OneHotEncoder.html</a>.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Label encoding</h1>
                </header>
            
            <article>
                
<p>In supervised learning, we usually deal with a variety of labels. These can be either numbers or words. If they are numbers, then the algorithm can use them directly. However, labels often need to be in a human-readable form. So, people usually label the training data with words.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p><span>Label encoding refers to transforming word labels into a numerical form so that algorithms can understand how to operate on them. Let's take a look at how to do this.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it…</h1>
                </header>
            
            <article>
                
<p><span>Let's see how to carry out label encoding in Python:</span></p>
<ol>
<li>Create a new Python file and import the <kbd>preprocessing()</kbd> package:</li>
</ol>
<pre style="padding-left: 60px"><strong>&gt;&gt; from sklearn import preprocessing</strong></pre>
<ol start="2">
<li>This package contains various functions that are needed for data preprocessing. To encode labels with a value between 0 and <kbd>n_classes</kbd>-1, the <kbd>preprocessing.LabelEncoder()</kbd> function can be used. Let's define the label encoder, as follows:</li>
</ol>
<pre style="padding-left: 60px"><strong>&gt;&gt; label_encoder = preprocessing.LabelEncoder()</strong></pre>
<ol start="3">
<li>The <kbd>label_encoder</kbd> object knows how to understand word labels. Let's create some labels:</li>
</ol>
<pre style="padding-left: 60px"><strong>&gt;&gt; input_classes = ['audi', 'ford', 'audi', 'toyota', 'ford', 'bmw']</strong></pre>
<p class="mce-root"/>
<ol start="4">
<li>We are now ready to encode these labels—first, the <kbd>fit()</kbd> function is used to <span>fit the label encoder, and then the class mapping encoders are printed:</span></li>
</ol>
<pre style="padding-left: 60px"><strong>&gt;&gt; label_encoder.fit(input_classes)</strong><br/><strong>&gt;&gt; print("Class mapping: ")</strong><br/><strong>&gt;&gt; for i, item in enumerate(label_encoder.classes_):</strong><br/><strong>...    print(item, "--&gt;", i)</strong></pre>
<ol start="5">
<li>Run the code, and you will see the following output on your Terminal:</li>
</ol>
<pre style="padding-left: 60px"><strong>Class mapping:</strong><br/><strong>audi --&gt; 0</strong><br/><strong>bmw --&gt; 1</strong><br/><strong>ford --&gt; 2</strong><br/><strong>toyota --&gt; 3</strong></pre>
<ol start="6">
<li>As shown in the preceding output, the words have been transformed into zero-indexed numbers. Now, when you encounter a set of labels, you can simply transform them, as follows:</li>
</ol>
<pre style="padding-left: 60px"><strong>&gt;&gt; labels = ['toyota', 'ford', 'audi']</strong><br/><strong>&gt;&gt; encoded_labels = label_encoder.transform(labels)</strong><br/><strong>&gt;&gt; print("Labels =", labels)</strong><br/><strong>&gt;&gt; print("Encoded labels =", list(encoded_labels))</strong></pre>
<p style="padding-left: 60px">Here is the output that you'll see on your Terminal:</p>
<pre style="padding-left: 60px"><strong>Labels = ['toyota', 'ford', 'audi']</strong><br/><strong>Encoded labels = [3, 2, 0]</strong></pre>
<ol start="7">
<li>This is way easier than manually maintaining mapping between words and numbers. You can check the correctness by transforming numbers back into word labels:</li>
</ol>
<pre style="padding-left: 60px"><strong>&gt;&gt; encoded_labels = [2, 1, 0, 3, 1]</strong><br/><strong>&gt;&gt; decoded_labels = label_encoder.inverse_transform(encoded_labels)</strong><br/><strong>&gt;&gt; print("Encoded labels =", encoded_labels)</strong><br/><strong>&gt;&gt; print("Decoded labels =", list(decoded_labels))</strong></pre>
<p style="padding-left: 60px">To transform labels back to their original encoding, the <kbd>inverse_transform()</kbd> function has been applied.  Here is the output:</p>
<pre style="padding-left: 60px"><strong>Encoded labels = [2, 1, 0, 3, 1]</strong><br/><strong>Decoded labels = ['ford', 'bmw', 'audi', 'toyota', 'bmw']</strong></pre>
<p style="padding-left: 60px">As you can see, the mapping is preserved perfectly.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>In this recipe, we used the <kbd>preprocessing.LabelEncoder()</kbd> <span>function </span>to transform word labels into numerical form. To do this, we first set up a series of labels to as many car brands. We then turned these labels into numerical values. Finally, to verify the operation of the procedure, we printed the values corresponding to each class labeled.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>In the last two recipes, <em>Label encoding</em> and <em>One-hot encoding</em>, we have seen how to transform data. Both methods are suitable for dealing with categorical data. But what are the pros and cons of the two methodologies? Let's take a look:</p>
<ul>
<li>Label encoding can transform categorical data into numeric data, but the imposed ordinality creates problems if the obtained values are submitted to mathematical operations.</li>
<li>One-hot encoding has the advantage that the result is binary rather than ordinal, and that everything is in an orthogonal vector space. The disadvantage is that for high cardinality, the feature space can explode.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li><span>Scikit-learn's </span><span>official documentatio</span>n on the <kbd>sklearn.preprocessing.LabelEncoder()</kbd> funct<span>ion: </span><a href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.LabelEncoder.html">https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.LabelEncoder.html</a>.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building a linear regressor</h1>
                </header>
            
            <article>
                
<p>Linear regression refers to finding the underlying function with the help of linear combination of input variables. The previous example had an input variable and an output variable. A simple linear regression is easy to understand, but represents the basis of regression techniques. Once these concepts are understood, it will be easier for us to address the other types of regression.</p>
<p>Consider the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-936 image-border" src="assets/4706fcd1-824e-488d-9851-6b16480b4150.png" style="width:37.50em;height:34.58em;"/></p>
<p>The linear regression method consists of precisely identifying a line that is capable of representing point distribution in a two-dimensional plane, that is, if the points corresponding to the observations are near the line, then the chosen model will be able to describe the link between the variables effectively. </p>
<p>In theory, there are an infinite number of lines that may approximate the observations, while in practice, there is only one mathematical model that optimizes the representation of the data. In the case of a linear mathematical relationship, the observations of the<span> <em>y</em></span> variable can be obtained by a linear function of the observations of the<span> </span><em>x</em> variable. For each observation, we will use the following formula:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/0b7ea69c-14c8-4875-bd76-5d3b11f596ff.png" style="width:7.75em;height:1.42em;"/></p>
<p>In the preceding formula, <em>x</em> is the explanatory variable and <em>y</em> is the response variable. The α and β<span> parameters</span>, which represent the slope of the line and the intercept with the y-axis respectively, must be estimated based on the observations collected for the two variables included in the model.</p>
<p>The slope, α, is of particular interest, that is, the variation of the mean response for every single increment of the explanatory variable. What about a change in this coefficient? If the slope is positive, the regression line increases from left to right, and if the slope is negative, the line decreases from left to right. When the slope is zero, the explanatory variable has no effect on the value of the response. But it is not just the sign of α that establishes the weight of the relationship between the variables. More generally, its value is also important. In the case of a positive slope, the mean response is higher when the explanatory variable is higher, while in the case of a negative slope, the mean response is lower when the explanatory variable is higher.</p>
<p>The main aim of linear regression is to get the underlying linear model that connects the input variable to the output variable. This in turn reduces the sum of squares of differences between the actual output and the predicted output using a linear function. This method is called <strong>ordinary least squares</strong>. In this method, the coefficients are estimated by determining numerical values that minimize the sum of the squared deviations between the observed responses and the fitted responses, according to the following equation:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/777ee9f3-007c-4b3d-b8f0-676da7e107ae.png" style="width:16.42em;height:3.83em;"/></p>
<p>This quantity represents the sum of the squares of the distances to each experimental datum (x<sub>i</sub>, y<sub>i</sub>) from the corresponding point on the straight line.</p>
<p>You might say that there might be a curvy line out there that fits these points better, but linear regression doesn't allow this. The main advantage of linear regression is that it's not complex. If you go into non-linear regression, you may get more accurate models, but they will be slower. As shown in the preceding diagram, the model tries to approximate the input data points using a straight line. Let's see how to build a linear regression model in Python.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Regression is used to find out the relationship between input data and the continuously-valued output data. This is generally represented as real numbers, and our aim is to estimate the core function that calculates the mapping from the input to the output. Let's start with a very simple example. Consider the following mapping between input and output:</p>
<pre>1 --&gt; 2<br/>3 --&gt; 6<br/>4.3 --&gt; 8.6<br/>7.1 --&gt; 14.2</pre>
<p>If I ask you to estimate the relationship between the inputs and the outputs, you can easily do this by analyzing the pattern. We can see that the output is twice the input value in each case, so the transformation would be as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/2c8db7e1-fd67-41f7-85cc-68043b1121bf.png" style="width:5.17em;height:1.42em;"/></p>
<p>This is a simple function, relating the input values with the output values. However, in the real world, this is usually not the case. Functions in the real world are not so straightforward!</p>
<p><span>You have been provided with a data file called <kbd>VehiclesItaly.txt</kbd>. This contains comma-separated lines, where the first element is the input value and the second element is the output value that corresponds to this input value. Our goal is to find the linear </span><span>regression relation between the vehicle registrations in a state and the population of a state. You should use this as the input argument. As anticipated, the <kbd>Registrations</kbd> variable contains the number of vehicles registered in Italy and the <kbd>Population</kbd> variable contains the population of the different regions.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it…</h1>
                </header>
            
            <article>
                
<p><span>Let's see how to build a linear regressor in Python:</span></p>
<ol>
<li>Create a file called <kbd>regressor.py</kbd> and add the following lines:</li>
</ol>
<pre style="padding-left: 60px">filename = "VehiclesItaly.txt"<br/>X = []<br/>y = []<br/>with open(filename, 'r') as f:<br/>    for line in f.readlines():<br/>        xt, yt = [float(i) for i in line.split(',')]<br/>        X.append(xt)<br/>        y.append(yt)</pre>
<p style="padding-left: 60px">We just loaded the input data into <kbd>X</kbd> and <kbd>y</kbd>, where <kbd>X</kbd> refers to the independent variable (explanatory variables) and <kbd>y</kbd> refers to the dependent variable (response variable). Inside the loop in the preceding code, we parse each line and split it based on the comma operator. We then convert them into floating point values and save them in <kbd>X</kbd> and <kbd>y</kbd>.</p>
<ol start="2">
<li>When we build a machine learning model, we need a way to validate our model and check whether it is performing at a satisfactory level. To do this, we need to separate our data into two groups—a training dataset and a testing dataset. The training dataset will be used to build the model, and the testing dataset will be used to see how this trained model performs on unknown data. So, let's go ahead and split this data into training and testing datasets:</li>
</ol>
<pre style="padding-left: 60px">num_training = int(0.8 * len(X))<br/>num_test = len(X) - num_training<br/><br/>import numpy as np<br/><br/># Training data<br/>X_train = np.array(X[:num_training]).reshape((num_training,1))<br/>y_train = np.array(y[:num_training])<br/><br/># Test data<br/>X_test = np.array(X[num_training:]).reshape((num_test,1))<br/>y_test = np.array(y[num_training:])</pre>
<p style="padding-left: 60px">First, we have put aside 80% of the data for the training dataset and the remaining 20% is for the testing dataset. Then, we have built four arrays: <kbd>X_train</kbd>, <kbd>X_test</kbd>,<kbd>y_train</kbd>, and <kbd>y_test</kbd>. </p>
<ol start="3">
<li>We are now ready to train the model. Let's create a <kbd>regressor</kbd> object, as follows:</li>
</ol>
<pre>from sklearn import linear_model<br/><br/># Create linear regression object<br/>linear_regressor = linear_model.LinearRegression()<br/><br/># Train the model using the training sets<br/>linear_regressor.fit(X_train, y_train)</pre>
<p style="padding-left: 60px">First, we have imported <kbd>linear_model</kbd> methods from the <kbd>sklearn</kbd> library, which are methods used for regression, wherein the target value is expected to be a linear combination of the input variables. Then, we have used the <kbd>LinearRegression()</kbd> function, which performs <span>ordinary least squares linear regression. Finally, the <kbd>fit()</kbd> function is used to fit the linear model. Two parameters are passed—training data (<kbd>X_train</kbd>), and target values (<kbd>y_train</kbd>).</span></p>
<ol start="4">
<li>We just trained the linear regressor, based on our training data. The <kbd>fit()</kbd> method takes the input data and trains the model. To see how it all fits, we have to predict the training data with the model fitted:</li>
</ol>
<pre style="padding-left: 60px">y_train_pred = linear_regressor.predict(X_train)</pre>
<ol start="5">
<li>To plot the outputs, we will use the <kbd>matplotlib</kbd> library as follows:</li>
</ol>
<pre style="padding-left: 60px">import matplotlib.pyplot as plt<br/>plt.figure()<br/>plt.scatter(X_train, y_train, color='green')<br/>plt.plot(X_train, y_train_pred, color='black', linewidth=4)<br/>plt.title('Training data')<br/>plt.show()</pre>
<p style="padding-left: 60px">When you run this in the Terminal, the following diagram is shown:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-937 image-border" src="assets/ae90be23-b653-4c31-b7cb-25464dd69853.png" style="width:33.33em;height:23.83em;"/></p>
<p class="mce-root"/>
<ol start="6">
<li>In the preceding code, we used the trained model to predict the output for our training data. This wouldn't tell us how the model performs on unknown data, because we are running it on the training data. This just gives us an idea of how the model fits on training data. Looks like it's doing okay, as you can see in the preceding diagram!</li>
<li>Let's predict the test dataset output based on this model and plot it, as follows:</li>
</ol>
<pre style="padding-left: 60px">y_test_pred = linear_regressor.predict(X_test)<br/>plt.figure()<br/>plt.scatter(X_test, y_test, color='green')<br/>plt.plot(X_test, y_test_pred, color='black', linewidth=4)<br/>plt.title('Test data')<br/>plt.show()</pre>
<p style="padding-left: 60px">When you run this in the Terminal, the following output is returned:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-938 image-border" src="assets/50b4e413-27d5-47e8-a76b-7a8ccdf158d5.png" style="width:33.42em;height:25.50em;"/></p>
<p class="CDPAlignLeft CDPAlign">As you might expect, there's a positive association between a state's population and the number of vehicle registrations.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>In this recipe, we looked for the linear regression relation between the vehicle registrations in a state and the population of a state. To do this we used the <kbd>LinearRegression()</kbd> function of the <kbd>linear_model</kbd> method of the <kbd>sklearn</kbd> library. After constructing the model, we first used the data involved in training the model to visually verify how well the model fits the data. Then, we used the test data to verify the results.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>The best way to appreciate the results of a simulation is to display those using special charts. In fact, we have already used this technique in this section. I am referring to the chart in which we drew the scatter plot of the distribution with the regression line. In <a href="">Chapter 5</a>, <em>Visualizing Data</em>, we will see other plots that will allow us to check the model's hypotheses.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li>Scikit-learn's official documentation of the <kbd>sklearn.linear_model.LinearRegression()</kbd> function: <a href="https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.LinearRegression.html">https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.LinearRegression.html</a>.</li>
<li><span><em>Regression Analysis with R</em>, Giuseppe Ciaburro,</span> Packt Publishing<span>.</span></li>
<li><em>Linear regression</em>: <a href="https://en.wikipedia.org/wiki/Linear_regression">https://en.wikipedia.org/wiki/Linear_regression</a>.</li>
<li><em>Introduction to Linear Regression</em>: <a href="http://onlinestatbook.com/2/regression/intro.html">http://onlinestatbook.com/2/regression/intro.html</a>.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Computing regression accuracy</h1>
                </header>
            
            <article>
                
<p>Now that we know how to build a regressor, it's important to understand how to evaluate the quality of a regressor as well. In this context, an error is defined as the difference between the actual value and the value that is predicted by the regressor.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Let's quickly take a look at the metrics that can be used to measure the quality of a regressor. <span>A regressor can be evaluated using many different metrics. </span><span>There is a module in the <kbd>scikit-learn</kbd> library that provides functionalities to compute all the following metrics. This is the </span><kbd>sklearn.metrics</kbd><span> </span><span>module, which includes score functions, performance metrics, pairwise metrics, and distance computations.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it…</h1>
                </header>
            
            <article>
                
<p>Let's see how to compute regression accuracy in Python:</p>
<ol>
<li><span>Now we will use the functions available to evaluate the performance of the linear regression model we developed in the previous recipe</span>:</li>
</ol>
<pre style="padding-left: 60px">import sklearn.metrics as sm<br/>print("Mean absolute error =", round(sm.mean_absolute_error(y_test, y_test_pred), 2)) <br/>print("Mean squared error =", round(sm.mean_squared_error(y_test, y_test_pred), 2)) <br/>print("Median absolute error =", round(sm.median_absolute_error(y_test, y_test_pred), 2)) <br/>print("Explain variance score =", round(sm.explained_variance_score(y_test, y_test_pred), 2)) <br/>print("R2 score =", round(sm.r2_score(y_test, y_test_pred), 2))</pre>
<p style="padding-left: 60px">The following results are returned:</p>
<pre style="padding-left: 60px"><strong>Mean absolute error = 241907.27</strong><br/><strong>Mean squared error = 81974851872.13</strong><br/><strong>Median absolute error = 240861.94</strong><br/><strong>Explain variance score = 0.98</strong><br/><strong>R2 score = 0.98</strong></pre>
<p style="padding-left: 60px">An R2 score near 1 means that the model is able to predict the data very well. Keeping track of every single metric can get tedious, so we pick one or two metrics to evaluate our model. A good practice is to make sure that the mean squared error is low and the explained variance score is high.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>A regressor can be evaluated using many different metrics, such as the following:</p>
<ul>
<li><strong>Mean absolute error</strong>: This is the average of absolute errors of all the data points in the given dataset.</li>
<li><strong>Mean squared error</strong>: This is the average of the squares of the errors of all the data points in the given dataset. It is one of the most popular metrics out there!</li>
<li><strong>Median absolute error</strong>: This is the median of all the errors in the given dataset. The main advantage of this metric is that it's robust to outliers. A single bad point in the test dataset wouldn't skew the entire error metric, as opposed to a mean error metric.</li>
<li><strong>Explained variance score</strong>: This score measures how well our model can account for the variation in our dataset. A score of 1.0 indicates that our model is perfect.</li>
<li><strong>R2 score</strong>: This is pronounced as R-squared, and this score refers to the coefficient of determination. This tells us how well the unknown samples will be predicted by our model. The best possible score is 1.0, but the score can be negative as well.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>The <kbd>sklearn.metrics</kbd> module contains a series of simple functions that measure prediction error:</p>
<ul>
<li>Functions ending with  <kbd>_score</kbd> return a value to maximize; the higher the better</li>
<li>Functions ending with <kbd>_error</kbd> or <kbd>_loss</kbd> return a value to minimize; the lower the better</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li>Scikit-learn's official documentation of the <kbd>sklearn.metrics</kbd> module: <a href="https://scikit-learn.org/stable/modules/classes.html#module-sklearn.metrics">https://scikit-learn.org/stable/modules/classes.html#module-sklearn.metrics</a>.</li>
<li><em>Regression Analysis with R</em>, Giuseppe Ciaburro, Packt Publishing.</li>
</ul>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Achieving model persistence</h1>
                </header>
            
            <article>
                
<p>When we train a model, it would be nice if we could save it as a file so that it can be used later by simply loading it again.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p><span>Let's see how to achieve model persistence programmatically. To do this, the <kbd>pickle</kbd> module can be used. The </span><kbd>pickle</kbd><span> module is used to store Python objects. This module is a part of the standard library with your installation of Python.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it…</h1>
                </header>
            
            <article>
                
<p>Let's see how to achieve model persistence in Python:</p>
<ol>
<li>Add the following lines to the <kbd>regressor.py</kbd> file:</li>
</ol>
<pre style="padding-left: 60px">import pickle<br/><br/>output_model_file = "3_model_linear_regr.pkl"<br/><br/>with open(output_model_file, 'wb') as f:<br/>    pickle.dump(linear_regressor, f) </pre>
<ol start="2">
<li>The regressor object will be saved in the <kbd>saved_model.pkl</kbd> file. Let's look at how to load it and use it, as follows:</li>
</ol>
<pre style="padding-left: 60px">with open(output_model_file, 'rb') as f:<br/>    model_linregr = pickle.load(f)<br/><br/>y_test_pred_new = model_linregr.predict(X_test)<br/>print("New mean absolute error =", round(sm.mean_absolute_error(y_test, y_test_pred_new), 2))</pre>
<p style="padding-left: 60px">The following result is returned:</p>
<pre style="padding-left: 60px"><strong>New mean absolute error = 241907.27</strong></pre>
<p style="padding-left: 60px">Here, we just loaded the regressor from the file into the <kbd>model_linregr</kbd> variable. You can compare the preceding result with the earlier result to confirm that it's the same.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The <kbd>pickle</kbd> module transforms an arbitrary Python object into a series of bytes. This process is also called the serialization of the object. The byte stream representing the object can be transmitted or stored, and subsequently rebuilt to create a new object with the same characteristics. The inverse operation is called <strong>unpickling</strong>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>In Python, there is also another way to perform serialization, by using the <kbd>marshal</kbd> module. In general, the <kbd>pickle</kbd> module is recommended for serializing Python objects. The <kbd>marshal</kbd> module can be used to support Python <kbd>.pyc</kbd> files.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li>Python's official documentation of the <kbd>pickle</kbd> module: <a href="https://docs.python.org/3/library/pickle.html">https://docs.python.org/3/library/pickle.html</a></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building a ridge regressor</h1>
                </header>
            
            <article>
                
<p>One of the main problems of linear regression is that it's sensitive to outliers. During data collection in the real world, it's quite common to wrongly measure output. Linear regression uses ordinary least squares, which tries to minimize the squares of errors. The outliers tend to cause problems because they contribute a lot to the overall error. This tends to disrupt the entire model.</p>
<p>Let's try to deepen our understanding of the concept of outliers: outliers are values that, compared to others, are particularly extreme (values that are clearly distant from the other observations). Outliers are an issue because they might distort data analysis results; more specifically, descriptive statistics and correlations. We need to find these in the data cleaning phase, however, we can also get started on them in the next stage of data analysis. Outliers can be univariate when they have an extreme value for a single variable, or multivariate when they have a unique combination of values for a number of variables. Let's consider the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-939 image-border" src="assets/8aca32b8-8e7e-4825-a2ff-6de47b89e32c.png" style="width:37.42em;height:35.08em;"/></p>
<p>The two points on the bottom right are clearly outliers, but this model is trying to fit all the points. Hence, the overall model tends to be inaccurate. Outliers are the extreme values of a distribution that are characterized by being extremely high or extremely low compared to the rest of the distribution, and thus representing isolated cases with respect to the rest of the distribution. By visual inspection, we can see that the following output is a better model:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-940 image-border" src="assets/d2f0a320-f45e-407c-9d06-249bb6f1cb72.png" style="width:36.92em;height:34.00em;"/></p>
<p>Ordinary least squares considers every single data point when it's building the model. Hence, the actual model ends up looking like the dotted line shown in the preceding graph. We can clearly see that this model is suboptimal. </p>
<p>The <kbd>regularization</kbd> method involve<span>s</span> modifying the performance function, normally selected as the sum of the squares of regression errors on the training set. When a large number of variables are available, the least square estimates of a linear model often have a low bias but a high variance with respect to models with fewer variables. Under these conditions, there is an overfitting problem. To improve precision prediction by allowing greater bias but a small variance, we can use variable selection methods and dimensionality reduction, but these methods may be unattractive for computational burdens in the first case or provide a difficult interpretation in the other case.</p>
<p>Another way to address the problem of overfitting is to modify the estimation method by neglecting the requirement of an unbiased parameter estimator and instead considering the possibility of using a biased estimator, which may have smaller variance. There are several biased estimators, most of which are based on regularization: <kbd>Ridge</kbd>, <kbd>Lasso</kbd>, and <kbd>ElasticNet</kbd> are the most popular methods.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p><strong>Ridge regression</strong> is a regularization method<span> where a penalty is imposed on the size of the coefficients. As we said in the <em>Building a linear regressor</em> section, in the ordinary least squares method, the coefficients are estimated by determining numerical values that minimize the sum of the squared deviations between the observed responses and the fitted responses, according to the following equation:</span></p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/8a08263f-c6fb-480e-8c55-43a5438c9acb.png" style="width:16.67em;height:3.67em;"/></p>
<p>Ridge regression, in order to estimate the β coefficients, starts from the basic formula of the <strong>residual sum of squares</strong> (<strong>RSS</strong>) and adds the penalty term. λ (≥ 0) is defined as the tuning parameter, which is multiplied by the sum of the <span>β </span>coefficients squared (excluding the intercept) to define the penalty period, as shown in the following equation:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/111a48a2-b8e3-4a99-abd0-64e7c095d4f7.png" style="width:26.25em;height:3.67em;"/></p>
<p>It is evident that having λ = 0 means not having a penalty in the model, that is, we would produce the same estimates as the least squares. On the other hand, having a λ tending toward infinity means having a high penalty effect, which will bring many coefficients close to zero, but will not imply their exclusion from the model. <span>Let's see how to build a ridge regressor in Python.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it…</h1>
                </header>
            
            <article>
                
<p>Let's see how to build a ridge regressor in Python:</p>
<ol>
<li>You can use the data already used in the previous example: <em>Building a linear regressor</em> (<kbd>VehiclesItaly.txt</kbd>). This file contains two values in each line. The first value is the explanatory variable, and the second is the response variable.</li>
<li>Add the following lines to <kbd>regressor.py</kbd>. Let's initialize a ridge regressor with some parameters:</li>
</ol>
<pre style="padding-left: 60px">from sklearn import linear_model<br/>ridge_regressor = linear_model.Ridge(alpha=0.01, fit_intercept=True, max_iter=10000)</pre>
<ol start="3">
<li>The <kbd>alpha</kbd> parameter controls the complexity. As <kbd>alpha</kbd> gets closer to 0, the ridge regressor tends to become more like a linear regressor with ordinary least squares. So, if you want to make it robust against outliers, you need to assign a higher value to <kbd>alpha</kbd>. We considered a value of <kbd>0.01</kbd>, which is moderate.</li>
<li>Let's train this regressor, as follows:</li>
</ol>
<pre style="padding-left: 60px">ridge_regressor.fit(X_train, y_train)<br/>y_test_pred_ridge = ridge_regressor.predict(X_test)<br/>print( "Mean absolute error =", round(sm.mean_absolute_error(y_test, y_test_pred_ridge), 2))<br/>print( "Mean squared error =", round(sm.mean_squared_error(y_test, y_test_pred_ridge), 2))<br/>print( "Median absolute error =", round(sm.median_absolute_error(y_test, y_test_pred_ridge), 2))<br/>print( "Explain variance score =", round(sm.explained_variance_score(y_test, y_test_pred_ridge), 2))<br/>print( "R2 score =", round(sm.r2_score(y_test, y_test_pred_ridge), 2))</pre>
<p style="padding-left: 60px">Run this code to view the error metrics. You can build a linear regressor to compare and contrast the results on the same data to see the effect of introducing regularization into the model.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p><strong>Ridge regression</strong><span> is a regularization method</span><span> where a penalty is imposed on the size of the coefficients. Ridge regression is identical to least squares, barring the fact that ridge coefficients are computed by decreasing a quantity that is somewhat different. In ridge </span><span>regression</span><span>, a scale transformation has a substantial effect. Therefore, to </span><span>avoid obtaining different results depending on the predicted scale of measurement, it is advisable to standardize all predictors before estimating the model. To standardize the variables, we must subtract their means and divide by their standard deviations.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li><span>Scikit-learn's official documentation of</span><span> the </span><kbd>linear_model.Ridge</kbd> function: <a href="https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.Ridge.html">https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.Ridge.html</a></li>
<li><em>Ridge Regression</em>, Columbia University: <a href="https://www.mailman.columbia.edu/research/population-health-methods/ridge-regression">https://www.mailman.columbia.edu/research/population-health-methods/ridge-regression</a></li>
<li><em>Multicollinearity and Other Regression Pitfalls</em>, The Pennsylvania State University: <a href="https://newonlinecourses.science.psu.edu/stat501/node/343/">https://newonlinecourses.science.psu.edu/stat501/node/343/</a></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building a polynomial regressor</h1>
                </header>
            
            <article>
                
<p>One of the main constraints of a linear regression model is the fact that it tries to fit a linear function to the input data. The polynomial regression model overcomes this issue by allowing the function to be a polynomial, thereby increasing the accuracy of the model.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Polynomial models should be applied where the relationship between response and explanatory variables is curvilinear. Sometimes, polynomial models can also be used to model a non-linear relationship in a small range of explanatory variable. A polynomial quadratic (squared) or cubic (cubed) term converts a linear regression model into a polynomial curve. However, since it is the explanatory variable that is squared or cubed and not the beta coefficient, it is still considered as a linear model. This makes it a simple and easy way to model curves, without needing to create big non-linear models. Let's consider the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-941 image-border" src="assets/fedb0c26-3b38-490a-a9cb-7122ebb501e8.png" style="width:33.33em;height:31.92em;"/></p>
<p>We can see that there is a natural curve to the pattern of data points. This linear model is unable to capture this. Let's see what a polynomial model would look like:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-942 image-border" src="assets/4cb0ae6a-1e8a-486f-ab37-3ec49ae2560e.png" style="width:33.25em;height:31.17em;"/></p>
<p>The dotted line represents the linear regression model, and the solid line represents the polynomial regression model. The curviness of this model is controlled by the degree of the polynomial. As the curviness of the model increases, it gets more accurate. However, curviness adds complexity to the model as well, making it slower. This is a trade-off: you have to decide how accurate you want your model to be given the computational constraints.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it…</h1>
                </header>
            
            <article>
                
<p>Let's see how to build a polynomial regressor in Python:</p>
<ol>
<li>In this example, we will only deal with second-degree parabolic regression. Now, we'll show how to model data with a polynomial. We measured the temperature for a few hours of the day. We want to know the temperature trend even at times of the day when we did not measure it. Those times are, however, between the initial time and the final time at which our measurements took place:</li>
</ol>
<pre style="padding-left: 60px">import numpy as np<br/><br/>Time = np.array([6, 8, 11, 14, 16, 18, 19])<br/>Temp = np.array([4, 7, 10, 12, 11.5, 9, 7])</pre>
<ol start="2">
<li>Now, we will show the temperature at a few points during the day:</li>
</ol>
<pre style="padding-left: 60px">import matplotlib.pyplot as plt<br/>plt.figure()<br/>plt.plot(Time, Temp, 'bo')<br/>plt.xlabel("Time")<br/>plt.ylabel("Temp")<br/>plt.title('Temperature versus time')<br/>plt.show()</pre>
<p style="padding-left: 60px">The following graph is produced:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-943 image-border" src="assets/25d15503-2c7c-465a-8f43-6993180067b9.png" style="width:31.00em;height:24.08em;"/></p>
<p style="padding-left: 60px">If we analyze the graph, it is possible to note a curvilinear pattern of the data that can be modeled through a second-degree polynomial such as the following equation:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/b0086aae-d6df-4f4d-8bd0-7e4818aab3dd.png" style="width:19.75em;height:1.42em;"/></p>
<p style="padding-left: 60px">The unknown coefficients, β<sub>0</sub>, β<sub>1</sub>, and β<sub>2</sub>, are estimated by decreasing the value of the sum of the squares. This is obtained by minimizing the deviations of the data from the model to its lowest value (least squares fit).</p>
<ol start="3">
<li>Let's calculate the polynomial coefficients:</li>
</ol>
<pre style="padding-left: 60px">beta = np.polyfit(Time, Temp, 2)</pre>
<p style="padding-left: 60px">The <kbd>numpy.polyfit()</kbd><span> function returns the </span><span>coefficients for a polynomial of degree <em>n</em> (given by us) that is the best fit for the data. </span><span>The coefficients returned by the function are in descending </span><span>powers (</span><span>highest power first</span><span>), and their length is <em>n+1</em> if <em>n</em> is the degree of the polynomial.</span></p>
<ol start="4">
<li>After creating the model, let's verify that it actually fits our data. To do this, use the model to evaluate the polynomial at uniformly spaced times. To evaluate the model at the specified points, we can use the <kbd>poly1d()</kbd> function. This function returns the value of a polynomial of degree <em>n</em> evaluated at the points provided by us. The input argument is a vector of length <em>n+1</em> whose elements are the coefficients in descending powers of the polynomial to be evaluated:</li>
</ol>
<pre style="padding-left: 60px">p = np.poly1d(beta)</pre>
<p style="padding-left: 60px">As you can see in the upcoming graph, this is close to the output value. If we want it to get closer, we need to increase the degree of the polynomial.</p>
<ol start="5">
<li>Now we can plot the original data and the model on the same plot:</li>
</ol>
<pre style="padding-left: 60px">xp = np.linspace(6, 19, 100)<br/>plt.figure()<br/>plt.plot(Time, Temp, 'bo', xp, p(xp), '-')<br/>plt.show()</pre>
<p style="padding-left: 60px">The following graph is printed:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-944 image-border" src="assets/9b9f0864-acfc-4e76-a48d-d213ea82599e.png" style="width:30.17em;height:23.75em;"/></p>
<p class="CDPAlignLeft CDPAlign">If we analyze the graph, we can see that the curve fits our data sufficiently. This model fits the data to a greater extent than a simple linear regression model. In regression analysis, it's important to keep the order of the model as low as possible. In the first analysis, we keep the model as a first order polynomial. If this is not satisfactory, then a second-order polynomial is tried. The use of <span>higher-order </span><span>polynomials can lead to incorrect evaluations.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Polynomial regression should be used when linear regression is not good enough. With polynomial regression, we approached a model in which some predictors appear in degrees equal to or greater than two to fit the data with a curved line. Polynomial regression is usually used when the relationship between variables looks curved.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>At what degree of the polynomial must we stop? It depends on the degree of precision we are looking for. The higher the degree of the polynomial, the greater the precision of the model, but the more difficult it is to calculate. In addition, it is necessary to verify the significance of the coefficients that are found, but let's get to it right away.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li>Python's official documentation of the <kbd>numpy.polyfit()</kbd> <span>function</span> <span>(<a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.polyfit.html">https://docs.scipy.org/doc/numpy/reference/generated/numpy.polyfit.html</a>)</span></li>
<li><span>Python's official documentation of the </span><kbd>numpy.poly1d()</kbd><span> </span><span>function (<a href="https://docs.scipy.org/doc/numpy-1.14.0/reference/generated/numpy.poly1d.html">https://docs.scipy.org/doc/numpy-1.14.0/reference/generated/numpy.poly1d.html</a>)</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Estimating housing prices</h1>
                </header>
            
            <article>
                
<p>It's time to apply our knowledge to a real-world problem. Let's apply all these principles to estimate house prices. This is one of the most popular examples that is used to understand regression, and it serves as a good entry point. This is intuitive and relatable, hence making it easier to understand the concepts before we perform more complex things in machine learning. We will use a decision tree regressor with AdaBoost to solve this problem.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>A decision tree is a tree where each node makes a simple decision that contributes to the final output. The leaf nodes represent the output values, and the branches represent the intermediate decisions that were made, based on input features. <strong>AdaBoost</strong> stands for <strong>adaptive boosting</strong>, and this is a technique that is used to boost the accuracy of the results from another system. This combines the outputs from different versions of the algorithms, called weak learners, using a weighted summation to get the final output. The information that's collected at each stage of the AdaBoost algorithm is fed back into the system so that the learners at the latter stages focus on training samples that are difficult to classify. In this way, it increases the accuracy of the system.</p>
<p>Using AdaBoost, we fit a regressor on the dataset. We compute the error and then fit the regressor on the same dataset again, based on this error estimate. We can think of this as fine-tuning of the regressor until the desired accuracy is achieved. You are given a dataset that contains various parameters that affect the price of a house. Our goal is to estimate the relationship between these parameters and the house price so that we can use this to estimate the price given unknown input parameters.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it…</h1>
                </header>
            
            <article>
                
<p>Let's see how to estimate housing prices in Python:</p>
<ol>
<li>Create a new file called <kbd>housing.py</kbd> and add the following lines:</li>
</ol>
<pre style="padding-left: 60px">import numpy as np<br/>from sklearn.tree import DecisionTreeRegressor<br/>from sklearn.ensemble import AdaBoostRegressor<br/>from sklearn import datasets<br/>from sklearn.metrics import mean_squared_error, explained_variance_score<br/>from sklearn.utils import shuffle<br/>import matplotlib.pyplot as plt</pre>
<ol start="2">
<li>There is a standard housing dataset that people tend to use to get started with machine learning. You can download it at <a href="https://archive.ics.uci.edu/ml/machine-learning-databases/housing/">https://archive.ics.uci.edu/ml/machine-learning-databases/housing/</a>. We will be using a slightly modified version of the dataset, which has been provided along with the code files.<br/>
The good thing is that <kbd>scikit-learn</kbd> provides a function to directly load this dataset:</li>
</ol>
<pre style="padding-left: 60px">housing_data = datasets.load_boston()</pre>
<p style="padding-left: 60px">Each data point has 12 input parameters that affect the price of a house. You can access the input data using <kbd>housing_data.data</kbd> and the corresponding price using <kbd>housing_data.target</kbd>. The following attributes are available:</p>
<ul style="padding-left: 60px">
<li><kbd>crim</kbd>: Per capita crime rate by town</li>
<li><kbd>zn</kbd>: Proportion of residential land zoned for lots that are over 25,000 square feet</li>
<li><kbd>indus</kbd>: Proportion of non-retail business acres per town</li>
<li><kbd>chas</kbd>: Charles River dummy variable (= 1 if tract bounds river; 0 otherwise)</li>
<li><kbd>nox</kbd>: Nitric oxides concentration (parts per ten million)</li>
<li><kbd>rm</kbd>: Average number of rooms per dwelling</li>
<li><kbd>age</kbd>: Proportion of owner-occupied units built prior to 1940</li>
<li><kbd>dis</kbd>: Weighted distances to the five Boston employment centers</li>
<li><kbd>rad</kbd>: Index of accessibility to radial highways</li>
<li><kbd>tax</kbd>: Full-value property-tax rate per $10,000</li>
<li><kbd>ptratio</kbd>: Pupil-teacher ratio by town</li>
<li><kbd>lstat</kbd>: Percent of the lower status of the population</li>
<li><kbd>target</kbd>: Median value of owner-occupied homes in $1000 </li>
</ul>
<p style="padding-left: 60px">Of these, <kbd>target</kbd> is the response variable, while the other 12 variables are possible predictors. The goal of this analysis is to fit a regression model that best explains the variation in <kbd>target</kbd>.</p>
<ol start="3">
<li>Let's separate this into input and output. To make this independent of the ordering of the data, let's shuffle it as well:</li>
</ol>
<pre style="padding-left: 60px">X, y = shuffle(housing_data.data, housing_data.target, random_state=7)</pre>
<p style="padding-left: 60px" class="mce-root">The <kbd>sklearn.utils.shuffle()</kbd> function shuffles arrays or sparse matrices in a consistent way to do random permutations of collections. Shuffling data reduces variance and makes sure that the patterns remain general and less overfitted. <span>The </span><kbd>random_state</kbd><span> parameter controls how we shuffle data so that we can have reproducible results. </span></p>
<ol start="4">
<li>Let's divide the data into training and testing. We'll allocate 80% for training and 20% for testing:</li>
</ol>
<pre style="padding-left: 60px">num_training = int(0.8 * len(X))<br/>X_train, y_train = X[:num_training], y[:num_training]<br/>X_test, y_test = X[num_training:], y[num_training:]</pre>
<p style="padding-left: 60px">Remember, machine learning algorithms, train models by using a finite set of training data. In the training phase, the model is evaluated based on its predictions of the training set. But the goal of the algorithm is to produce a model that predicts previously unseen observations, in other words, one that is able to generalize the problem by starting from known data and unknown data. For this reason, the data is divided into two datasets: training and test. The training set is used to train the model, while the test set is used to verify the ability of the system to generalize.</p>
<ol start="5">
<li>We are now ready to fit a decision tree regression model.  Let's pick a tree with a maximum depth of 4, which means that we are not letting the tree become arbitrarily deep:</li>
</ol>
<pre style="padding-left: 60px">dt_regressor = DecisionTreeRegressor(max_depth=4)<br/>dt_regressor.fit(X_train, y_train)</pre>
<p style="padding-left: 60px">The <kbd>DecisionTreeRegressor</kbd> function has been used to build a decision tree regressor.  </p>
<p class="mce-root"/>
<ol start="6">
<li>Let's also fit the decision tree regression model with AdaBoost:</li>
</ol>
<pre style="padding-left: 60px">ab_regressor = AdaBoostRegressor(DecisionTreeRegressor(max_depth=4), n_estimators=400, random_state=7)<br/>ab_regressor.fit(X_train, y_train)</pre>
<p style="padding-left: 60px">The <kbd>AdaBoostRegressor</kbd> <span>function has been used to compare the results and see how AdaBoost really boosts the performance of a decision tree regressor.</span></p>
<ol start="7">
<li>Let's evaluate the performance of the decision tree regressor:</li>
</ol>
<pre style="padding-left: 60px">y_pred_dt = dt_regressor.predict(X_test)<br/>mse = mean_squared_error(y_test, y_pred_dt)<br/>evs = explained_variance_score(y_test, y_pred_dt)<br/>print("#### Decision Tree performance ####")<br/>print("Mean squared error =", round(mse, 2))<br/>print("Explained variance score =", round(evs, 2))</pre>
<p style="padding-left: 60px">First, we used the <kbd>predict()</kbd> function to predict the response variable based on the test data. Next, we calculated mean squared error and explained variance. <kbd>Mean squared error</kbd> is the average of the squared difference between actual and predicted values across all data points in the input. The <kbd>explained variance</kbd> is an indicator that, in the form of proportion, indicates how much variability of our data is explained by the model in question.</p>
<ol start="8">
<li>Now, let's evaluate the performance of AdaBoost:</li>
</ol>
<pre style="padding-left: 60px">y_pred_ab = ab_regressor.predict(X_test)<br/>mse = mean_squared_error(y_test, y_pred_ab)<br/>evs = explained_variance_score(y_test, y_pred_ab)<br/>print("#### AdaBoost performance ####")<br/>print("Mean squared error =", round(mse, 2))<br/>print("Explained variance score =", round(evs, 2))</pre>
<p style="padding-left: 60px">Here is the output on the Terminal:</p>
<pre style="padding-left: 60px"><strong>#### Decision Tree performance ####</strong><br/><strong>Mean squared error = 14.79</strong><br/><strong>Explained variance score = 0.82</strong><br/><br/><strong>#### AdaBoost performance ####</strong><br/><strong>Mean squared error = 7.54</strong><br/><strong>Explained variance score = 0.91</strong></pre>
<p style="padding-left: 60px">The error is lower and the variance score is closer to 1 when we use AdaBoost, as shown in the preceding output.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p><kbd>DecisionTreeRegressor</kbd><span> builds a decision tree regressor.  Decision trees are used to predict a response or class <em>y</em>, from several input variables; <em>x1</em>, <em>x2</em>,…,<em>xn</em>. If y is a continuous response, it's called a regression tree, if <em>y</em> is categorical, it's called a classification tree. The algorithm is based on the following procedure: We see the value of the input <em>x<sub>i</sub></em> at each node of the tree, and based on the answer, we continue to the left or to the right branch. When we reach a leaf, we will find the prediction. In regression trees, we try to divide the data space into tiny parts, where we can equip a simple different model on each of them. The non-leaf part of the tree is just the way to find out which model we will use for predicting it.</span></p>
<p><span>A regression tree is formed by a series of nodes that split the root branch into two child branches. Such subdivision continues to cascade. Each new branch, then, can go in another node, or remain a leaf with the predicted value.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p><span>An AdaBoost regressor is a meta-estimator that starts by equipping a regressor on the actual dataset and adding additional copies of the regressor on the same dataset, but where the weights of instances are adjusted according to the error of the current prediction. As such, consecutive regressors look at difficult cases. This will help us compare the results and see how AdaBoost really boosts the performance of a decision tree regressor.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li><span>Scikit-learn's official documentation of the</span> <kbd>DecisionTreeRegressor</kbd> function (<a href="https://scikit-learn.org/stable/modules/generated/sklearn.tree.DecisionTreeRegressor.html">https://scikit-learn.org/stable/modules/generated/sklearn.tree.DecisionTreeRegressor.html</a>)</li>
<li><span>Scikit-learn's official documentation of</span> the <kbd>AdaBoostRegressor</kbd> function (<a href="https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.AdaBoostRegressor.html">https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.AdaBoostRegressor.html</a>)</li>
</ul>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Computing the relative importance of features</h1>
                </header>
            
            <article>
                
<p>Are all features equally important? In this case, we used 13 input features, and they all contributed to the model. However, an important question here is, <em>How do we know which features are more important?</em> Obviously, not all features contribute equally to the output. In case we want to discard some of them later, we need to know which features are less important. We have this functionality available in scikit-learn.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p><span>Let's calculate the relative importance of the features. Feature importance provides a measure that indicates the value of each feature in the construction of the model. The more an attribute is used to build the model, the greater its relative importance. This importance is explicitly calculated for each attribute in the dataset, allowing you to classify and compare attributes to each other.  Feature </span><span>importance </span><span>is an attribute contained in the model (<kbd>feature_importances_</kbd>).</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it…</h1>
                </header>
            
            <article>
                
<p>Let's see how to compute the relative importance of features:</p>
<ol>
<li><span>Let's see how to extract this. </span>Add the following lines to <kbd>housing.py</kbd>:</li>
</ol>
<pre style="padding-left: 60px">DTFImp= dt_regressor.feature_importances_<br/>DTFImp= 100.0 * (DTFImp / max(DTFImp))<br/>index_sorted = np.flipud(np.argsort(DTFImp))<br/>pos = np.arange(index_sorted.shape[0]) + 0.5</pre>
<p style="padding-left: 60px">The regressor object has a callable <kbd>feature_importances_</kbd> method that gives us the relative importance of each feature. To compare the results, the importance values have been normalized. Then, we ordered the index values and turned them upside down so that they are arranged in descending order of importance. Finally, for display purposes, the location of the labels on the <em>x</em>-axis has been centered.</p>
<p class="mce-root"/>
<ol start="2">
<li>To visualize the results, we will plot the bar graph:</li>
</ol>
<pre style="padding-left: 60px">plt.figure()<br/>plt.bar(pos, DTFImp[index_sorted], align='center')<br/>plt.xticks(pos, housing_data.feature_names[index_sorted])<br/>plt.ylabel('Relative Importance')<br/>plt.title("Decision Tree regressor")<br/>plt.show()</pre>
<ol start="3">
<li>We just take the values from the <kbd>feature_importances_</kbd> method and scale them so that they range between 0 and 100. Let's see what we will get for a decision tree-based regressor in the following output:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-945 image-border" src="assets/c0bbaef3-09d7-4963-9707-0836cc795d1e.png" style="width:131.33em;height:66.92em;"/></p>
<p style="padding-left: 60px">So, the decision tree regressor says that the most important feature is RM.</p>
<ol start="4">
<li>Now, we carry out a similar procedure for the <span>AdaBoost </span>model:</li>
</ol>
<pre style="padding-left: 60px">ABFImp= ab_regressor.feature_importances_ <br/>ABFImp= 100.0 * (ABFImp / max(ABFImp))<br/>index_sorted = np.flipud(np.argsort(ABFImp))<br/>pos = np.arange(index_sorted.shape[0]) + 0.5</pre>
<p class="mce-root"/>
<ol start="5">
<li>To visualize the results, we will plot the bar graph:</li>
</ol>
<pre style="padding-left: 60px">plt.figure()<br/>plt.bar(pos, ABFImp[index_sorted], align='center')<br/>plt.xticks(pos, housing_data.feature_names[index_sorted])<br/>plt.ylabel('Relative Importance')<br/>plt.title("AdaBoost regressor")<br/>plt.show()</pre>
<p style="padding-left: 60px" class="CDPAlignLeft CDPAlign">Let's take a look at what AdaBoost has to say in the following output:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-946 image-border" src="assets/4e104325-5dd2-46a6-a499-aedd8dd7b96e.png" style="width:132.25em;height:67.00em;"/></p>
<p>According to AdaBoost, the most important feature is LSTAT. In reality, if you build various regressors on this data, you will see that the most important feature is in fact LSTAT. This shows the advantage of using AdaBoost with a decision tree-based regressor.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p><span>Feature importance provides a measure that indicates the value of each feature in the construction of a model. The more an attribute is used to build a model, the greater its relative importance. </span>In this recipe, the <span><kbd>feature_importances_</kbd> attribute was used to extract the relative importance of the features from the model.</span></p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>Relative importance returns the utility of each characteristic in the construction of decision trees. The more an attribute is used to make predictions with decision trees, the greater its relative importance. This importance is explicitly calculated for each attribute in the dataset, allowing you to classify and compare attributes to each other.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li><span>Scikit-learn's official documentation of</span><span> the </span><kbd>DecisionTreeRegressor</kbd> function: <a href="https://scikit-learn.org/stable/modules/generated/sklearn.tree.DecisionTreeRegressor.html">https://scikit-learn.org/stable/modules/generated/sklearn.tree.DecisionTreeRegressor.html</a></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Estimating bicycle demand distribution</h1>
                </header>
            
            <article>
                
<p>Let's use a different regression method to solve the bicycle demand distribution problem. We will use the random forest regressor to estimate the output values. A random forest is a collection of decision trees. This basically uses a set of decision trees that are built using various subsets of the dataset, and then it uses averaging to improve the overall performance. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We will use the <kbd>bike_day.csv</kbd> file that is provided to you. This is also available at <a href="https://archive.ics.uci.edu/ml/datasets/Bike+Sharing+Dataset">https://archive.ics.uci.edu/ml/datasets/Bike+Sharing+Dataset</a>. There are 16 columns in this dataset. The first two columns correspond to the serial number and the actual date, so we won't use them for our analysis. The last three columns correspond to different types of outputs. The last column is just the sum of the values in the fourteenth and fifteenth columns, so we can leave those two out when we build our model. <span>Let's go ahead and see how to do this in Python. We will analyze the code line by line to understand each step.</span></p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it…</h1>
                </header>
            
            <article>
                
<p>Let's see how to estimate bicycle demand distribution:</p>
<ol>
<li>We first need to import a couple of new packages, as follows:</li>
</ol>
<pre style="padding-left: 60px">import csv<br/>import numpy as np</pre>
<ol start="2">
<li>We are processing a CSV file, so the CSV package for useful in handling these files. Let's import the data into the Python environment:</li>
</ol>
<pre style="padding-left: 60px">filename="bike_day.csv"<br/>file_reader = csv.reader(open(filename, 'r'), delimiter=',')<br/>X, y = [], []<br/>for row in file_reader:<br/>    X.append(row[2:13])<br/>    y.append(row[-1])</pre>
<p style="padding-left: 60px">This piece of code just read all the data from the CSV file. <span>The <kbd>csv.reader()</kbd> function returns a <kbd>reader</kbd> object, which will iterate over lines in the given </span>CSV file<span>. Each row read from the CSV file is returned as a list of strings. So, two lists are returned: <kbd>X</kbd> and <kbd>y</kbd>. We have separated the data from the output values and returned them. Now we will extract feature names:</span></p>
<pre style="padding-left: 60px">feature_names = np.array(X[0])</pre>
<p style="padding-left: 60px">The feature names are useful when we display them on a graph. So, we have to remove the first row from X and y because they are feature names:</p>
<pre style="padding-left: 60px">X=np.array(X[1:]).astype(np.float32)<br/>y=np.array(y[1:]).astype(np.float32)</pre>
<p style="padding-left: 60px">We have also converted the two lists into two arrays.</p>
<ol start="3">
<li>Let's shuffle these two arrays to make them independent of the order in which the data is arranged in the file:</li>
</ol>
<pre style="padding-left: 60px">from sklearn.utils import shuffle<br/>X, y = shuffle(X, y, random_state=7)  </pre>
<ol start="4">
<li>As we did earlier, we need to separate the data into training and testing data. This time, let's use 90% of the data for training and the remaining 10% for testing:</li>
</ol>
<pre style="padding-left: 60px">num_training = int(0.9 * len(X))<br/>X_train, y_train = X[:num_training], y[:num_training]<br/>X_test, y_test = X[num_training:], y[num_training:]</pre>
<ol start="5">
<li>Let's go ahead and train the regressor:</li>
</ol>
<pre style="padding-left: 60px">from sklearn.ensemble import RandomForestRegressor<br/>rf_regressor = RandomForestRegressor(n_estimators=1000, max_depth=10, min_samples_split=2)<br/>rf_regressor.fit(X_train, y_train)</pre>
<p style="padding-left: 60px">The <kbd>RandomForestRegressor()</kbd> function builds a random forest regressor. Here, <kbd>n_estimators</kbd> refers to the number of estimators, which is the number of decision trees that we want to use in our random forest. The <kbd>max_depth</kbd> parameter refers to the maximum depth of each tree, and the <kbd>min_samples_split</kbd> parameter refers to the number of data samples that are needed to split a node in the tree.</p>
<ol start="6">
<li>Let's evaluate the performance of the random forest regressor:</li>
</ol>
<pre style="padding-left: 60px">y_pred = rf_regressor.predict(X_test)<br/>from sklearn.metrics import mean_squared_error, explained_variance_score<br/>mse = mean_squared_error(y_test, y_pred)<br/>evs = explained_variance_score(y_test, y_pred)<br/>print( "#### Random Forest regressor performance ####")<br/>print("Mean squared error =", round(mse, 2))<br/>print("Explained variance score =", round(evs, 2))</pre>
<p style="padding-left: 60px">The following results are returned:</p>
<pre style="padding-left: 60px"><strong>#### Random Forest regressor performance ####</strong><br/><strong>Mean squared error = 357864.36</strong><br/><strong>Explained variance score = 0.89</strong></pre>
<ol start="7">
<li><span>Let's extract the relative importance of the features</span>:</li>
</ol>
<pre style="padding-left: 60px">RFFImp= rf_regressor.feature_importances_ <br/>RFFImp= 100.0 * (RFFImp / max(RFFImp))<br/>index_sorted = np.flipud(np.argsort(RFFImp))<br/>pos = np.arange(index_sorted.shape[0]) + 0.5</pre>
<p style="padding-left: 60px"><span>To visualize the results, we will plot a bar graph</span>:</p>
<pre style="padding-left: 60px">import matplotlib.pyplot as plt<br/>plt.figure()<br/>plt.bar(pos, RFFImp[index_sorted], align='center')<br/>plt.xticks(pos, feature_names[index_sorted])<br/>plt.ylabel('Relative Importance')<br/>plt.title("Random Forest regressor")<br/>plt.show()</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p style="padding-left: 60px">The following output is plotted:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-947 image-border" src="assets/39f8941f-eaaa-4222-bbbf-ec944eb99161.png" style="width:100.08em;height:54.67em;"/></p>
<p style="padding-left: 60px">Looks like the temperature is the most important factor controlling bicycle rentals.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>A random forest is a special regressor formed of a set of simple regressors (decision trees), represented as independent and identically distributed random vectors, where each one chooses the mean prediction of the individual trees. This type of structure has made significant improvements in regression accuracy and falls within the sphere of ensemble learning. Each tree within a random forest is constructed and trained from a random subset of the data in the training set. The trees therefore do not use the complete set, and the best attribute is no longer selected for each node, but the best attribute is selected from a set of randomly selected attributes.</p>
<p>Randomness is a factor that then becomes part of the construction of regressors and aims to increase their diversity and thus reduce correlation. The final result returned by the random forest is nothing but the average of the numerical result returned by the different trees in the case of a regression, or the class returned by the largest number of trees if the random forest algorithm was used to perform classification.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more…</h1>
                </header>
            
            <article>
                
<p>Let's see what happens when you include the fourteenth and fifteenth columns in the dataset. In the feature importance graph, every feature other than these two has to go to zero. The reason is that the output can be obtained by simply summing up the fourteenth and fifteenth columns, so the algorithm doesn't need any other features to compute the output. Make the following change inside the <kbd>for</kbd> loop (the rest of the code remains unchanged):</p>
<pre>X.append(row[2:15])</pre>
<p>If you plot the feature importance graph now, you will see the following:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-948 image-border" src="assets/51725b53-5281-49a8-af7f-9f9621ba88d9.png" style="width:100.25em;height:56.42em;"/></p>
<p class="mce-root"/>
<p>As expected, it says that only these two features are important. This makes sense intuitively because the final output is a simple summation of these two features. So, there is a direct relationship between these two variables and the output value. Hence, the regressor says that it doesn't need any other variable to predict the output. This is an extremely useful tool to eliminate redundant variables in your dataset. But this is not the only difference from the previous model. If we analyze the model's performance, we can see a substantial improvement:</p>
<pre><strong>#### Random Forest regressor performance ####</strong><br/><strong>Mean squared error = 22552.26</strong><br/><strong>Explained variance score = 0.99</strong></pre>
<p>We therefore have 99% of the variance explained: a very good result.</p>
<p>There is another file, called <kbd>bike_hour.csv</kbd>, that contains data about how the bicycles are shared hourly. We need to consider columns 3 to 14, so let's make this change in the code <span>(</span><span>the rest of the code remains unchanged)</span>:</p>
<pre>filename="<span>bike_hour</span>.csv"<br/>file_reader = csv.reader(open(filename, 'r'), delimiter=',')<br/>X, y = [], []<br/>for row in file_reader:<br/>    X.append(row[2:14])<br/>    y.append(row[-1])</pre>
<p>If you run the new code, you will see the performance of the regressor displayed, as follows:</p>
<pre><strong>#### Random Forest regressor performance ####</strong><br/><strong>Mean squared error = 2613.86</strong><br/><strong>Explained variance score = 0.92</strong></pre>
<p>The feature importance graph will look like the following:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-949 image-border" src="assets/fe9a90c7-f085-47e7-9706-9b0e92b13a00.png" style="width:100.75em;height:55.75em;"/></p>
<p>This shows that the hour of the day is the most important feature, which makes sense intuitively if you think about it! The next important feature is temperature, which is consistent with our earlier analysis. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li><span>Scikit-learn's official documentation of</span> the <kbd>RandomForestRegressor</kbd> function: <a href="https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.RandomForestRegressor.html">https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.RandomForestRegressor.html</a></li>
</ul>


            </article>

            
        </section>
    </body></html>