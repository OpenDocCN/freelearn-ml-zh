- en: '*Chapter 8*: TPOT Model Deployment'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you'll learn how to deploy any automated machine learning model,
    both to localhost and the cloud. You'll learn why the deployment step is necessary
    if you aim to make machine learning-powered software. It's assumed you know how
    to train basic regression and classification models with TPOT. Knowledge of the
    topics of the last couple of chapters (Dask and neural networks) isn't required,
    as we won't deal with those here.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout the chapter, you'll learn how easy it is to wrap your models in an
    API and expose their predictive capabilities to other users that aren't necessarily
    data scientists. You'll also learn which cloud providers are the best to get you
    started entirely for free.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Why do we need model deployment?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing `Flask` and `Flask-RESTful`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Best practices for deploying automated models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying machine learning models to localhost
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying machine learning models to the cloud
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As briefly said earlier, you need to know how to build basic machine learning
    models with TPOT. Don't worry if you don't feel too comfortable with the library
    yet, as we'll develop the model from scratch. If you're entirely new to TPOT,
    please refer to [*Chapter 2*](B16954_02_Final_SK_ePub.xhtml#_idTextAnchor036),
    *Deep Dive into TPOT*, [*Chapter 3*](B16954_03_Final_SK_ePub.xhtml#_idTextAnchor051),
    *Exploring Regression with TPOT*, and [*Chapter 4*](B16954_04_Final_SK_ePub.xhtml#_idTextAnchor058),
    *Exploring Classification with TPOT*.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will be quite code-heavy, so you can refer to the official GitHub
    repository if you get stuck: [https://github.com/PacktPublishing/Machine-Learning-Automation-with-TPOT/tree/main/Chapter08](https://github.com/PacktPublishing/Machine-Learning-Automation-with-TPOT/tree/main/Chapter08).'
  prefs: []
  type: TYPE_NORMAL
- en: Why do we need model deployment?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you're already going through the hassle of training and optimizing machine
    learning models, why don't you take it a step further and deploy it so everyone
    can use it?
  prefs: []
  type: TYPE_NORMAL
- en: Maybe you want to have the model's predictive capabilities available in a web
    application. Perhaps you're a mobile app developer who wants to bring machine
    learning to Android and iOS. The options are endless and different, but all of
    them share one similarity – the need to be deployed.
  prefs: []
  type: TYPE_NORMAL
- en: Now, machine learning model deployment has nothing to do with machine learning.
    The aim is to write a simple REST API (preferably in Python, since that's the
    language used throughout the book) and expose any form of endpoint that calls
    a `predict()` function to the world. You want parameters sent to your application
    in JSON format, and then to use them as inputs to your model. Once the prediction
    is made, you can simply return it to the user.
  prefs: []
  type: TYPE_NORMAL
- en: Yes, that's all there is to machine learning model deployment. Of course, things
    could get more technical, but keeping things simple will get us 95% of the way,
    and you can always explore further to squeeze that extra 5%.
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the technical side of model deployment, Python provides you
    with a bunch of options. You can use either `Flask` and `Flask-RESTful`, `FastAPI`,
    `Django`, or `Pyramid`. There are other options, sure, but their "market share"
    is more or less negligible. You'll use the first option in this chapter, starting
    from the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The section that follows aims to introduce you to the libraries with a couple
    of basic hands-on examples. We'll dive into machine learning afterward.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Flask and Flask-RESTful
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Flask` is a lightweight framework for building web applications. It enables
    you to start simple and scale when needed. `Flask-RESTful` is an extension for
    `Flask` that allows you to build REST APIs in no time.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started with these two, you''ll need to install them. You can execute
    the following line from the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'And that''s all you need to get started. Let''s explore the basics of `Flask`
    first:'
  prefs: []
  type: TYPE_NORMAL
- en: Believe it or not, you'll need only seven lines of code to create your first
    web application with `Flask`. It won't do anything useful, but it's still a step
    in the right direction.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To start, you'll need to import the library and create an application instance.
    You'll then have to make a function that returns what you want to be displayed
    on the website and decorate the function with an `@app.route(route_url)` decorator.
    Keep in mind that you should replace `route_url` with the URL string at which
    the function should display the result. If you pass in a forward slash (`/`),
    the results will be displayed on the root page – but more about that in a bit.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Finally, you'll have to make the Python file runnable with an `if __name__ ==
    '__main__'` check. The application will run on localhost on port `8000`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Refer to the following code snippet for your first `Flask` application:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To run the application, you''ll have to execute the Python file from the terminal.
    The file is named `flask_basics.py` on my machine, so to run it, please execute
    the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: By now, you know how to build the simplest application with `Flask` – but that's
    not why you're here. We want to make APIs instead of apps, and that's a bit of
    a different story. The difference between them is quite obvious – APIs don't come
    with a user interface (except for the documentation page), whereas web apps do.
    APIs are just a service. As it turns out, you can build APIs with `Flask` out
    of the box. We'll explore how to do so and explain why it isn't the best option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To start, create a new Python file. This file will be referenced as `flask_basics2.py`.
    Inside it, we''ll have a single route for two possible API call types. Both have
    the task of adding two numbers and returning the results, but they do so differently.
    Let''s list the differences:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: a) `/adding` (GET) relies on the logic implemented earlier. To be more precise,
    a GET request is made when the endpoint is called. The only difference is that
    this time, the parameters are passed in the URL. For example, calling `/adding?num1=3&num2=5`
    should display `8` onscreen. The parameter values are extracted directly from
    the URL. You'll see this in action, so everything will be clear immediately.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: b) `/adding` (POST) is quite similar to the first endpoint but makes a POST
    request instead. This is a more secure communication method, as parameter values
    aren't passed in the URL directly but in the request body instead. This endpoint
    returns the summation as JSON, so you'll need to wrap the results inside the `flask.jsonify()`
    function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Both functions aim to complete an identical task – sum two numbers and return
    the result. Here''s one example of how you might implement this logic:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, the `add_get()` function returns a string formatted as HTML.
    You can return entire HTML documents if you want, but that's not something that
    interests us now, so we won't look further into it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To run the application, you''ll have to execute the Python file from the terminal.
    The file is named `flask_basics2.py` on my machine, so to run it, please execute
    the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: import requests
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: req = requests.post(
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: url='http://localhost:8000/adding',
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'json={''num1'': 3, ''num2'': 5}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: )
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: res = req.content
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: print(res)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You already have `Flask-RESTful` installed. The syntax when using it is a bit
    different. It uses the `get()`, `post()`, and `put()`, which represent what happens
    when a request of a particular type is made.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All API classes inherit from the `Flask-RESTful.Resource` class and each endpoint
    must be manually bound to a specific URL string via the `add_resource()` method.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To summarize, we''ll have the `Add` class, which has two methods: `get()` and
    `post()`. All of the logic inside these methods is identical to what we had earlier,
    with a single exception – we won''t return HTML anywhere.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Here''s the entire code snippet:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Everything inside the `Adding` class is available on the `/adding` endpoint.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As you can see, the API will run on a different port, just to easily distinguish
    between this API and the previous one.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If you were to open `http://localhost:8000/adding` now, you''d see the following
    message:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.7 – Flask-RESTful GET without parameters'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16954_08_7.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.7 – Flask-RESTful GET without parameters
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have the same error as with the default `Flask` API, and the reason
    is that no parameter values were given in the URL. If you were to change it and
    call `http://localhost:8000/adding?num1=5&num2=10`, you''d see the following in
    your browser window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.8 – Flask-RESTful GET with parameters'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16954_08_8.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.8 – Flask-RESTful GET with parameters
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned earlier, communicating with an API straight from the browser is
    not considered to be a good practice, but you can still do it with GET request
    types. You're better off using a tool such as Postman, and you already know how
    to do so.
  prefs: []
  type: TYPE_NORMAL
- en: 'As for the POST method, you can call the same URL as previously, `http://localhost:8000/adding`,
    and pass the parameters as JSON in the request body. Here''s how you can do so
    with Postman:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.9 – Flask-RESTful POST with Postman'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16954_08_9.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.9 – Flask-RESTful POST with Postman
  prefs: []
  type: TYPE_NORMAL
- en: You can do the same through Python, but you should already know how to do so
    by now.
  prefs: []
  type: TYPE_NORMAL
- en: You now know the basics of REST API development with Python, `Flask`, and `Flask-RESTful`.
    This was a relatively quick, hands-on section that served as a primer for what's
    about to follow. In the next section, we'll go over a couple of best practices
    for deploying machine learning models, and in the last two sections, we'll explore
    how you can train and deploy models to localhost and the cloud, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Best practices for deploying automated models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The deployment of automated models is more or less identical to the deployment
    of your normal machine learning models. It boils down to training the model first
    and then saving the model in some format. In the case of normal machine learning
    models, you could easily save the model to a `.model` or `.h5` file. There's no
    reason not to do the same with TPOT models.
  prefs: []
  type: TYPE_NORMAL
- en: If you remember from previous chapters, TPOT can export the best pipeline to
    a Python file so this pipeline can be used to train the model if it isn't trained
    already, and the model can be saved afterward. If the model is already trained,
    only the prediction is obtained.
  prefs: []
  type: TYPE_NORMAL
- en: The check for whether a model has been trained or not can be made by checking
    whether a file exists or not. If a model file exists, we can assume the model
    was trained, so we can load it and make a prediction. Otherwise, the model should
    be trained and saved first, and only then can the prediction be made.
  prefs: []
  type: TYPE_NORMAL
- en: It's also a good idea to use a POST request type when connecting to a machine
    learning API. It's a better option than GET because parameter values aren't passed
    directly in the URL. As you might know, parameter values can be sensitive, so
    it's a good idea to hide them whenever possible.
  prefs: []
  type: TYPE_NORMAL
- en: For example, maybe you need to authenticate with the API before making predictions.
    It's easy to understand why sending your username and password credentials directly
    in a URL isn't a good idea. POST has you covered, and the rest of the chapter
    will make good use of it.
  prefs: []
  type: TYPE_NORMAL
- en: In a nutshell, you should always check whether the model is trained before making
    predictions and train it if required. The other take-home point is that POST is
    better than GET in our case. You now know a couple of basic best practices for
    deploying machine learning models. In the next section, we will train and deploy
    the model to localhost.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying machine learning models to localhost
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll have to train a model before we can deploy it. You already know everything
    about training with TPOT, so we won''t spend too much time here. The goal is to
    train a simple Iris classifier and export the predictive functionality somehow.
    Let''s go through the process step by step:'
  prefs: []
  type: TYPE_NORMAL
- en: 'As always, the first step is to load in the libraries and the dataset. You
    can use the following piece of code to do so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This is what the first few rows look like:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.10 – The first few rows of the Iris dataset'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B16954_08_10.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.10 – The first few rows of the Iris dataset
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The next step is to separate the features from the target variable. This time,
    we won''t split the dataset into training and testing subsets, as we don''t intend
    to evaluate the model''s performance. In other words, we know the model performs
    well, and now we want to retrain it on the entire dataset. Also, string values
    in the target variables will be remapped to their integer representation as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) Setosa – 0
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: b) Virginica – 1
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: c) Versicolor – 2
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The following lines of code do everything that was described:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here''s what the target variable looks like now:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.11 – The target variable after value remapping'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B16954_08_11.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.11 – The target variable after value remapping
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Next stop – model training. We'll train the model with TPOT for 15 minutes.
    This part should be familiar to you, as we're not using any parameters that weren't
    used or described in previous chapters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following piece of code will train the model on the entire dataset:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You''ll see many outputs during the training process, but it shouldn''t take
    too long to achieve 100% accuracy, as shown in the following figure:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.12 – TPOT training process'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B16954_08_12.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.12 – TPOT training process
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'How many generations will pass in the 15-minute time frame depends on your
    hardware, but once finished, you should see something similar to this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.13 – TPOT output after training'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B16954_08_13.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.13 – TPOT output after training
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once the training process is complete, you''ll have access to the `fitted_pipeline_`
    property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It''s a pipeline object that can be exported for later use. Here''s what it
    should look like (keep in mind that you could see something different on your
    machine):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.14 – TPOT fitted pipeline'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B16954_08_14.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.14 – TPOT fitted pipeline
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To demonstrate how this pipeline works, please take a look at the following
    code snippet. It calls the `predict()` function of the `fitted_pipeline_` property
    with a 2D array of input data, representing a single flower species:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The results are displayed in the following figure:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.15 – TPOT prediction'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B16954_08_15.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.15 – TPOT prediction
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Remember our remapping strategy from a couple of pages ago? `0` indicates that
    this species was classified as `setosa`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The final step we have to do is save the predictive capabilities of this model
    to a file. The `joblib` library makes this step easy to do, as you just have to
    call the `dump()` function to save the model and the `load()` function to load
    the model.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here''s a quick demonstration. The goal is to save the `fitted_pipeline_` property
    to a file called `iris.model`. You can use the following code to do so:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And that''s all there is to it! You''ll see the following output once the model
    is saved to a file:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.16 – Saving TPOT models'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16954_08_16.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.16 – Saving TPOT models
  prefs: []
  type: TYPE_NORMAL
- en: 'Just to verify that the model will still work, you can use the `load()` function
    to load the model in a new variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code is shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.17 – Prediction of a saved model'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16954_08_17.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.17 – Prediction of a saved model
  prefs: []
  type: TYPE_NORMAL
- en: And that's how easy it is to save machine learning models for later use. We
    now have everything needed to deploy this model, so let's do that next.
  prefs: []
  type: TYPE_NORMAL
- en: 'The model deployment process will be quite similar to what we''ve done previously
    with `Flask` and `Flask-RESTful`. Before proceeding to the step-by-step guide,
    you should create a directory for your API with the following directory/file structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.18 – API directory structure'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16954_08_18.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.18 – API directory structure
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the root folder is called `api` and it has two Python files
    inside – `app.py` and `helpers.py`. The folder also has another folder for storing
    the model trained previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s build the API one step at a time next:'
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with the `helpers.py` file. The goal of this Python file is to remove
    all calculations and data operations from `app.py`. The ladder is used only to
    declare and manage the API itself, and everything else is performed elsewhere.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `helpers.py` file will have two functions – `int_to_species(in_species)`
    and `predict_single(model, X)`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The goal of the first function is to reverse our previously declared mappings
    and to return the actual flower species name given the integer representation.
    Here''s a concrete list of strings returned when given the integer input:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: a) 0 – `setosa`
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: b) 1 – `virginica`
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: c) 2 – `versicolor`
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If some other number is passed, an empty string is returned. You can find the
    code for this function as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'On to the `predict_single(model, X)` function now. It aims to return a prediction
    and its probability given the model and a list of input values. The function also
    makes the following checks:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: a) Is `X` a list? If not, raise an exception.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: b) Does `X` have four items (sepal length, sepal width, petal length, and petal
    width)? If not, raise an exception.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: These checks are required because we don't want bad or misformatted data going
    in our model and crashing the API.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If all of the checks pass, the prediction and probability are returned to the
    user as a dictionary, alongside the entered data for each parameter. Here''s how
    to implement this function:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here''s one example of calling the `predict_single()` function:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The results are shown in the following figure:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.19 – Results of calling the predict_single() function'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B16954_08_19.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.19 – Results of calling the predict_single() function
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: On to `app.py` now. If you have been following along from the beginning of this
    chapter, coding out this file will be a piece of cake. The goal is to have the
    model loaded at all times and to trigger the `post()` method of the `PredictSpecies`
    class when a `/predict` endpoint is called. You'll have to implement both the
    class and the method yourself.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The user has to pass input data as JSON. To be more precise, every flower measurement
    value is passed separately, so the user will have to specify values for four parameters
    in total.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If everything goes well, the `predict_single()` function from `helpers.py` is
    called, and the results are returned to the user.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s take a look at the implementation of `app.py`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You now have everything needed to run the API. You can do so the same way that
    you did with the previous APIs, and that is by executing the following line in
    the terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If everything went well, you''ll get the following message:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.20 – Running the API'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B16954_08_20.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.20 – Running the API
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The API is now running on `http://localhost:8000`. We'll use the Postman application
    to test the API.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here''s the first example:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.21 – API testing example 1'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16954_08_21.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.21 – API testing example 1
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the model is 100% confident that this species belongs to the
    `setosa` class. Let''s try another one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.22 – API testing example 2'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16954_08_22.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.22 – API testing example 2
  prefs: []
  type: TYPE_NORMAL
- en: 'This has an identical confidence level but a different prediction class. Let''s
    mix things up a beat and pass values a bit different than anything in the training
    set:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.23 – API testing example 3'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16954_08_23.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.23 – API testing example 3
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the model isn't 100% confident this time, as the input data
    is a lot different from the data seen at training.
  prefs: []
  type: TYPE_NORMAL
- en: And there you have it – TPOT model deployment to localhost! The only thing left
    to do in this chapter is to bring the model to the cloud and make it accessible
    from anywhere. Let's do that next.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying machine learning models to the cloud
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Cloud deployment of machine learning models means creating a cloud virtual
    machine, transferring our API to it, and running it. It''s a tedious process that
    gets easier with repetition since a lot of steps are involved. If you follow every
    step precisely from this section, everything will work fine. Just make sure not
    to miss any minor details:'
  prefs: []
  type: TYPE_NORMAL
- en: To start, head over to [https://portal.aws.amazon.com/billing/signup#/start](https://portal.aws.amazon.com/billing/signup#/start)
    and create an account (assuming you don't already have one). Here's what the website
    currently looks like (as of February 2021):![Figure 8.24 – AWS registration website
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16954_08_24.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.24 – AWS registration website
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The registration process will take some time, and you will have to enter your
    credit card information. Don't worry; we'll create entirely free virtual machine
    instances so you won't be charged a dime.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once the registration process is complete, click on the `ubuntu` in the search
    bar:![Figure 8.26 – Ubuntu Server 20.04
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16954_08_26.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.26 – Ubuntu Server 20.04
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once you click on **Select**, you''ll have to specify the type. Make sure to
    select the free version if you don''t want to get charged:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 2.27 – Ubuntu instance type'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B16954_08_27.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 2.27 – Ubuntu instance type
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, click on the **Review and Launch** button. You''ll be taken to the following
    screen:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 2.28 – Ubuntu instance confirmation'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B16954_08_28.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 2.28 – Ubuntu instance confirmation
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once you click on **Launch**, the following window will appear. Make sure to
    select the identical options, but the key pair name is up to you:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.29 – Ubuntu key pair'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B16954_08_29.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.29 – Ubuntu key pair
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Click on the **Download Key Pair** button after you enter the details. After
    the download is complete, you''ll be able to click on the **Launch Instances**
    button:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.30 – Launching the Ubuntu instance'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B16954_08_30.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.30 – Launching the Ubuntu instance
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, after everything is done, you can click on the **View Instances**
    button:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.31 – View Instances'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B16954_08_31.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.31 – View Instances
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You will be presented with your created instance immediately. It might take
    some time before you see that the instance is running, so please be patient:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.32 – Running instance'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B16954_08_32.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.32 – Running instance
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To obtain the connection parameter, click on the instance row and select the
    `.ppk` file in the **Key file** option. After the **Connect** button is pressed,
    you'll see the following:![Figure 8.36 – FileZilla host key
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16954_08_36.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.36 – FileZilla host key
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Just press **OK** and you''re good to go. The connection was successful, as
    visible from the following figure:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.37 – FileZilla successful connection'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B16954_08_37.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.37 – FileZilla successful connection
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You can now drag the **api** folder to the **ubuntu** folder on the remote
    virtual machine, as shown here:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.38 – Transferring API data to a remote virtual machine'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B16954_08_38.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.38 – Transferring API data to a remote virtual machine
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Before further configuring and starting the API, let's explore how you can obtain
    the connection through the terminal.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open up a new terminal window right where your `.pem` file is stored. Once
    there, execute the following command to change the permission:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: sudo apt-get update && sudo apt-get install python3-pip
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: pip3 install virtualenv
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: virtualenv tpotapi_env
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: source tpotapi_env/bin/activate
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: pip3 install joblib flask flask-restful sklearn tpot
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you were to run the API now, no errors would be raised, but you wouldn't
    be able to access the API in any way. That's because we need to "fix" a couple
    of permissions first. Put simply, our API needs to be accessible from anywhere,
    and it isn't by default.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To start, navigate to **Network & Security** | **Security Groups** on the sidebar:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.40 – Security Groups'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B16954_08_40.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.40 – Security Groups
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You should see the **Create security group** button in the top-right corner
    of the browser window:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.41 – The Create security group button'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B16954_08_41.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.41 – The Create security group button
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once the new window pops up, you''ll have to specify a couple of things. The
    **Security group name** and **Description** fields are entirely arbitrary. On
    the other hand, the **Inbound rules** group isn''t arbitrary. You''ll have to
    add a new rule with the following options:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'a) **Type**: **All traffic**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'b) **Source**: **Anywhere**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Refer to the following figure for more information:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.42 – Creating a security group'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B16954_08_42.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.42 – Creating a security group
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'After specifying the correct values, you have to scroll down to the end of
    the screen and click on the **Create security group** option:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.43 – Verifying a security group'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B16954_08_43.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.43 – Verifying a security group
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We''re not done yet. The next step is to go to the **Network & Security** |
    **Network Interfaces** option on the sidebar:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.44 – The Network Interfaces option'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B16954_08_44.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.44 – The Network Interfaces option
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once there, right-click the only available network interface (assuming this
    is your first time in the AWS console) and select the **Change security groups**
    option:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.45 – Changing security groups'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B16954_08_45.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.45 – Changing security groups
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The whole point of this is to assign the "access from anywhere" rule to our
    virtual machine. Once a window pops up, select the previously declared security
    group from the dropdown of options:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.46 – Selecting the security group'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B16954_08_46.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.46 – Selecting the security group
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once added, click on the **Save** button to save this association:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.47 – Saving security associations'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B16954_08_47.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.47 – Saving security associations
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Configuring our virtual machine was quite a lengthy process, but you can now
    finally start the `Flask` application (REST API). To do so, navigate to the `/api`
    folder and execute the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should see the following, by now a familiar message:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.48 – Starting the REST API through the terminal'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B16954_08_48.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.48 – Starting the REST API through the terminal
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: And that's it! The API is now running, and we can test whether it works properly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Before making a request through Postman, we first need to find the complete
    URL for our remote virtual machine. You can find yours by right-clicking the instance
    under **Instances** and clicking on the **Connect** option. There, you''ll see
    the **SSH client** tab:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.49 – Virtual machine URL'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16954_08_49.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.49 – Virtual machine URL
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we know the complete URL: `http://ec2-18-220-113-224.us-east-2.compute.amazonaws.com:8000/predict`.
    The procedure from now is identical to as it was on localhost, as visible in the
    following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.50 – Testing our deployed API'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16954_08_50.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.50 – Testing our deployed API
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the connection went through, and the API returned a response
    just as it did with the locally deployed version.
  prefs: []
  type: TYPE_NORMAL
- en: And there you have it – the complete procedure for deploying machine learning
    models to an AWS virtual machine. The process can be quite tedious to do and even
    tricky if this is your first time. It will get easier as you deploy more and more
    machine learning models, as the procedure is identical.
  prefs: []
  type: TYPE_NORMAL
- en: You could play around with the permissions if you don't want your API to be
    accessible from anywhere by anyone, but that's beyond the scope of this book.
    This chapter is more or less over – great work! What follows is a summary of everything
    learned and then yet another interesting, hands-on chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter was the longest one so far and quite intensive with the hands-on
    tasks. You've hopefully managed to follow along and learned how machine learning
    models built with TPOT can be deployed – both locally and to the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: You are now capable of deploying any sort of machine learning model built with
    Python. Besides, you also know how to deploy basic Python web applications, provided
    that you have the necessary knowledge of frontend technologies, such as HTML,
    CSS, and JavaScript. We didn't dive into this area, as it's beyond the scope of
    this book.
  prefs: []
  type: TYPE_NORMAL
- en: In the following chapter, [*Chapter 9*](B16954_09_Final_SK_ePub.xhtml#_idTextAnchor102),
    *Using the Deployed TPOT Model in Production*, you'll learn how to build a basic
    application around this REST API. To be more precise, you'll learn how to make
    a simple and decent-looking web interface that predicts flower species based on
    the input data. But before that, you'll practice making a request to our API with
    Python.
  prefs: []
  type: TYPE_NORMAL
- en: As always, feel free to study model deployment in more detail, as AWS isn't
    the only option. There are many cloud providers that offer some sort of a free
    tier, and AWS is just a single fish in the pond.
  prefs: []
  type: TYPE_NORMAL
- en: Question
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Why do we need (and want) model deployment?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What's the role of REST APIs in model deployment?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name a couple of Python libraries that can be used to deploy machine learning
    models.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What's the difference between the GET and POST request types?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What's the general idea behind the `joblib` library in Python?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Explain in your own words what a virtual machine is.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which free tool can be used to test REST APIs?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
