<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis">
<head>
  <meta charset="UTF-8"/>
  <title>Machine Learning for Computer Vision</title>
  <link type="text/css" rel="stylesheet" media="all" href="style.css"/>
  <link type="text/css" rel="stylesheet" media="all" href="core.css"/>
</head>
<body>
  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Machine Learning for Computer Vision</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will get an overview of the relevant machine learning theory and tools that are useful when developing applications such as image classification, object detection, and so on. With widespread communication tools and the wide availability of camera sensors, we are now bombarded with large amounts of image data. Utilizing this data to create computer vision applications requires an understanding of some basic machine learning concepts.</p>
<p>Let's begin by first explaining what machine learning <span>is,&#160;</span>and then we will see the different types of algorithms in it.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">What is machine learning?</h1>
                </header>
            
            <article>
                
<p>Let's say we have scanned images of several handwritten digits and want to make a piece of software that would recognize handwritten digits from an image scan. For simplicity, let's assume that we have only one digit. The target software that we develop takes in this image and outputs a number corresponding to that image. We can create an algorithm with several checks, such as: if there is a single vertical line, then output it as 1, or if there is an oval shape, then show it as zero. However, this is very naive and is a bad solution because we can have vertical lines for other digits too: 7, 9, and so on. The following figure explains the overall process, taking in one of the samples from the MNIST handwritten digit dataset:</p>
<div class="CDPAlignCenter CDPAlign"><img height="133" width="382" class="alignnone size-full wp-image-754 image-border" src="images/bf938706-48ba-400d-94a7-79e814034409.png"/></div>
<p>There are several ways to model such a problem. We know that an image is made up of arrays of pixels and each pixel stores a value. In the previous figure, the value of each pixel is binary and an initial approach would be to compute the mean value of the image. Based on this mean value, we can define a function such that if the mean value lies between a range, then the image is of <strong>9</strong>; we can do the same for other digits. In this whole process, our parameters are the ranges for each digit image, and these ranges can be either add intuitively or learned through experience.</p>
<p>However, such a method of detecting digits in an image is prone to errors and is not efficient. The parameters for the model may work only on a specific set of images and it is hard to find the right set of values for the ranges just from experience. The machine learning technique plays an important role here. In this setup, let's use a function that will output an array of size 10, corresponding to the digits we are trying to find. Each array value represents the probability of that digit in the image. The highest probability digit will be the identified digit. Now, we have modeled the output but our input is still the mean value of the image, which may not vary much between different images. So, instead of using the mean value, we can use whole image pixels and map the pixel values directly to the output probabilities. This way, we can capture more variations in the image, and this is the usual way in computer vision.</p>
<p>Our understanding of machine learning can be further strengthened by a mathematical method for modeling the problem, as follows:</p>
<p style="padding-left: 210px"><img height="20" width="81" class="fm-editor-equation" src="images/40276c5c-ba1f-447d-804e-1262a44c0ef8.png"/></p>
<p>Here,&#160;<img height="16" width="16" class="fm-editor-equation" src="images/e24f0411-0c91-4ab1-8328-8ea8e8c34690.png"/>&#160;is the input and <img height="15" width="14" class="fm-editor-equation" src="images/4eb00261-1f31-4629-81fc-b0c15fb3caad.png"/>&#160;is the output of the model. In our previous case, these are the images and probability array respectively. <img height="16" width="14" class="fm-editor-equation" src="images/ef19589b-5035-4772-a341-ce0efd0cbe69.png"/>&#160;is the machine learning model that we would like to create and <img height="15" width="8" class="fm-editor-equation" src="images/c006ccff-daaa-4f7e-b8b3-cf819d4d8be0.png"/>&#160;are the parameters of <img height="16" width="14" class="fm-editor-equation" src="images/03c68248-56f1-4e10-b3b2-ac59a911dc5b.png"/>.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Kinds of machine learning techniques</h1>
                </header>
            
            <article>
                
<p>In the previous section, we saw an introduction to machine learning and an example modeling of a digit image. Now, we will see the different styles of machine learning techniques.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Supervised learning</h1>
                </header>
            
            <article>
                
<p>In supervised learning, we are given a dataset of both the inputs and required outputs for the model; our goal is to create a model that will take any previously unseen data and output values that are true to the actual as much as possible. There are two kinds of supervised learning.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Classification</h1>
                </header>
            
            <article>
                
<p>This is the term for cases when the output of the model is categorical. For example, in the case of digit classification, the output is one of the 10 different digits.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Regression</h1>
                </header>
            
            <article>
                
<p>This is the term for cases when the output has continuous values, for example, a line fitting model. In it, the goal is to approximate the curve as much as possible so that the output of the model would be a value within a certain range.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Unsupervised learning</h1>
                </header>
            
            <article>
                
<p>In this type of machine learning, we are not given any dataset with specific outputs; instead, the model should be able to find the possible outputs given an input. For example, in the previous handwritten digit image, we would like to estimate all possible digits in some ancient text. The assumption here is that we don't know how many different kinds of digits exist in that text. In such a case, the model should understand what a digit looks like. An example approach could be to segment the regions of the digit in the image and fit approximately basic shapes like lines, circles, rectangles, and so on.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Dimensionality's curse</h1>
                </header>
            
            <article>
                
<p>Given the different kinds of machine learning techniques, it is highly important to know the challenges in modeling. We will use the previous digit classification method. We previously tried to model it using all pixels as the available input. The dimensions for the input are the image size, that is, h x w. It ranges from several hundreds to a few thousand. This size is considered as the input dimension, and as it increases, the computation as well as uncertainty in estimation increase. We need a bigger model to perform better estimation if the input dimension increases. This is termed&#160;<strong>curse of dimensionality</strong>.&#160;</p>
<p>In order to resolve this curse, it is highly recommended to reduce the input dimensions. For example, instead of using pixel values as input, we can extract strong features and use them as input to the model. This will reduce the input dimensions significantly and may improve the overall performance of the model.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">A rolling-ball view of learning</h1>
                </header>
            
            <article>
                
<p>To learn the parameters of the model, we create a <kbd>cost</kbd> function or <kbd>objective</kbd> function and minimize its value. The minimum value of <kbd>objective</kbd> will give the best parameters for the model. For example, let model <img height="17" width="39" class="fm-editor-equation" src="images/cbda72ff-a37b-4353-9215-6f0c6cdfde00.png"/>&#160;predicts a value <img height="13" width="12" class="fm-editor-equation" src="images/12d1df00-4788-46bf-bca4-9450dc4f17fb.png"/>and also let we are given with the dataset of both the model input and the output. Then, learning a model requires updating the parameters <img height="15" width="8" class="fm-editor-equation" src="images/d9580831-a1bf-44ea-a416-3b243393d3a8.png"/>&#160;such that we get the best performance.</p>
<p>To make the model learn, we use parameter update rule. It works by estimating how far the model-estimated values are away from the target values and then updates the parameter such that this difference reduces. After several iterations, the difference gets smaller, and once it is small enough, we say our model has learnt the parameters. A figurative explanation is given here:</p>
<div class="CDPAlignCenter CDPAlign"><img height="589" width="1021" class="alignnone size-full wp-image-755 image-border" src="images/2fb6a99e-0246-4322-9ca8-4aaeacdf2bbe.png"/></div>
<p>The learning of the model is similar to a rolling ball. It is an iterative process, and after each process, the parameters are updated. The update pushes the parameters to minimize an <kbd>objective</kbd> function. This minimization is represented as pushing the ball downwards on the slope. The best parameters are equivalent to model state at the bottom of the slope.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Useful tools</h1>
                </header>
            
            <article>
                
<p>In this section, we will see some of the tools that are used while creating machine learning models. Here, we will be using the scikit-learn package, but these are available in many other libraries too. The overall functioning and the purpose remain the same.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Preprocessing</h1>
                </header>
            
            <article>
                
<p>Preprocessing the input as well as target labels in settings such as classification or regression is as important as the model itself. Some of the techniques used are explained as follows.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Normalization</h1>
                </header>
            
            <article>
                
<p>For the ease of the model to learn proper parameters through a training set, it is highly essential to normalize the values in a small range, usually 0 to 1.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Noise</h1>
                </header>
            
            <article>
                
<p>For making the system more robust, the input can also be added with small Gaussian noise. In the case of images as input, the noise corresponds to salt and pepper noise.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Postprocessing</h1>
                </header>
            
            <article>
                
<p>In the case of classification, the output of the model is an array of probabilities. To compute the predicted label for the input, we use an index with the maximum value of the array.</p>
<p>In the case of regression, the output of the model is usually normalized values between the range 0-1. This requires rescaling of the output to the original domain.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Evaluation</h1>
                </header>
            
            <article>
                
<p>Once we have trained a model, to evaluate, it is highly necessary to check its overall validity. In a binary classification problem, setting the evaluation is done by using the following output values. Here, we want to evaluate the model's performance for category A:</p>
<ul>
<li><strong>True positive&#160;</strong>(<strong>TP</strong>): Given a sample from label A, the output is also categorized as A</li>
<li><strong>True negative</strong> (<strong>TN</strong>): Given a sample from label A, the output is categorized into B</li>
<li><strong>False positive</strong> (<strong>FP</strong>): Given a sample from label B, the output is categorized into A</li>
<li><strong>False negative</strong> (<strong>FN</strong>): Given a sample from B, the output is also categorized into B</li>
</ul>
<p>This is done for the evaluation set, and based on it, we compute the following parameters.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Precision</h1>
                </header>
            
            <article>
                
<p>The precision value tells us how much the result is relevant to our goal in accuracy. This is computed as follows:</p>
<p style="padding-left: 150px"><img height="38" width="163" class="fm-editor-equation" src="images/c8cf6d9d-c869-4f16-bf21-5d8d3491f5bb.png"/></p>
<p>Using scikit-learn, we can do this as:</p>
<pre><strong>from </strong><strong>sklearn.metrics </strong><strong>import</strong> precision_score<br/>true_y = .... # ground truth values<br/>pred_y = .... # output of the model<br/><br/><br/>precision = precision_score(true_y, pred_y, average='micro')</pre>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Recall</h1>
                </header>
            
            <article>
                
<p>Recall tells us how many of the results are truly relevant. This is computed as follows:</p>
<p style="padding-left: 150px"><img height="38" width="141" class="fm-editor-equation" src="images/9587bbf1-945e-4ecb-832b-aaba7a2fbab2.png"/></p>
<p>Using scikit-learn:</p>
<pre><strong>from </strong><strong>sklearn.metrics </strong><strong>import</strong> recall_score<br/>true_y = .... # ground truth values<br/>pred_y = .... # output of the model<br/><br/><br/>recall = recall_score(true_y, pred_y, average='micro')</pre>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">F-measure</h1>
                </header>
            
            <article>
                
<p>Using both the precision and recall values, F-measure (specifically F1-score for the overall evaluation) is computed. This is given as follows:</p>
<p style="padding-left: 150px"><img height="38" width="234" class="fm-editor-equation" src="images/5088628f-e014-46f3-8e86-6b3cbcada60f.png"/></p>
<p>Using scikit-learn, this can be computed as:</p>
<pre><strong>from </strong><strong>sklearn.metrics </strong><strong>import</strong> f1_score<br/>true_y = .... # ground truth values<br/>pred_y = .... # output of the model<br/><br/><br/>f1_value = f1_score(true_y, pred_y, average='micro')</pre>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, an overview of machine learning was explained with relevant tools. The explanation here complements several algorithms presented in the chapter.</p>
<p>Taking into account <span>the&#160;</span>curse of dimensionality, learning overview, and evaluation of the model, we can create better computer vision applications that use machine learning techniques.</p>
<p>&#160;</p>


            </article>

            
        </section>
    </div>
</body>
</html>