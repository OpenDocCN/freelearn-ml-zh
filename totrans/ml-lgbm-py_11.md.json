["```py\ncluster = LocalCluster(n_workers=4, threads_per_worker=2)\nclient = Client(cluster)\n```", "```py\nimport dask.dataframe as dd\ndf = dd.read_csv(\"covtype/covtype.csv\", blocksize=\"64MB\")\n```", "```py\ndf.shape\n# (Delayed('int-a0031d1f-945d-42b4-af29-ea5e40148f3f'), 55)\n```", "```py\ndf.shape[0].compute()\n# 581012\n```", "```py\nX = df.iloc[:, :-1]\ny = df.iloc[:, -1]\nX_train, X_test, y_train, y_test = dask_ml.model_selection.train_test_split(X, y)\n```", "```py\ndask_model = lgb.DaskLGBMClassifier(n_estimators=200, client=client)\ndask_model.fit(X_train, y_train)\n```", "```py\nwith open(\"dask-model.pkl\", \"wb\") as f:\n        pickle.dump(dask_model, f)\n```", "```py\npredictions = dask_model.predict(X_test)\n```", "```py\npredictions.compute()\n```", "```py\nsudo apt install --no-install-recommends\nsudo apt install --no-install-recommends nvidia-opencl-dev opencl-headers\n```", "```py\nsudo apt install --no-install-recommends git cmake build-essential libboost-dev libboost-system-dev libboost-filesystem-dev\n```", "```py\ngit clone --recursive https://github.com/microsoft/LightGBM\ncd LightGBM\nmkdir build\ncd build\ncmake -DUSE_GPU=1 ..\nmake -j$(nproc)\ncd ..\n```", "```py\ncd python-package/\npython setup.py install --user --precompile\n```", "```py\nmodel = lgb.LGBMClassifier(\n        n_estimators=150,\n        device=\"cuda\",\n        is_enable_sparse=False\n)\nmodel = model.fit(X_train, y_train)\n```", "```py\nMetric multi_logloss is not implemented in cuda version. Fall back to evaluation on CPU.\n```", "```py\ndef objective(trial):\n        lambda_l1 = trial.suggest_float(\n                'lambda_l1', 1e-8, 10.0, log=True),\n        lambda_l2 = trial.suggest_float(\n                'lambda_l2', 1e-8, 10.0, log=True),\n...\n```", "```py\nmodel = lgb.LGBMClassifier(\n    force_row_wise=True,\n    boosting_type=boosting_type,\n    n_estimators=n_estimators,\n    lambda_l1=lambda_l1,\n    lambda_l2=lambda_l2,\n...\n    learning_rate=learning_rate,\n    max_bin=max_bin,\n    device=\"cuda\")\n```", "```py\nscores = cross_val_score(model, X_train, y_train, scoring=\"f1_macro\")\nreturn scores.mean()\n```", "```py\nsampler = optuna.samplers.TPESampler()\npruner = optuna.pruners.HyperbandPruner(\n        min_resource=10, max_resource=400, reduction_factor=3)\nstudy = optuna.create_study(\n        direction='maximize', sampler=sampler,\n        pruner=pruner\n)\nstudy.optimize(objective(), n_trials=10, gc_after_trial=True, n_jobs=1)\n```"]