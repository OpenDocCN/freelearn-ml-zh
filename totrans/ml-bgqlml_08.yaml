- en: '*Chapter 6*: Classifying Trees with Multiclass Logistic Regression'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第6章*：使用多类逻辑回归对树木进行分类'
- en: Multiclass logistic regression is the **Machine Learning** (**ML**) algorithm
    used to classify events, entities, and behaviors into a fixed number of categories.
    It can be used across different industries and business scenarios when it's necessary
    to predict the classification of an entity into multiple groups. A typical classification
    use case is represented by the desire to segment the customer base of a company
    according to their profitability and preferences in order to target the right
    customers with the most effective marketing campaigns.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 多类逻辑回归是用于将事件、实体和行为分类到固定数量类别的**机器学习（ML**）算法。当需要预测实体分类到多个组时，它可用于不同的行业和业务场景。一个典型的分类用例是，根据公司的盈利能力和偏好对公司客户群进行细分，以便针对最有效的营销活动定位正确的客户。
- en: This kind of technique is an extension of the binary logistic regression that
    allows us to overcome the limits of two possible labels and opens the applicability
    to other contexts where we can find multiple categories to identify.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术是二分类逻辑回归的扩展，使我们能够克服两个可能标签的限制，并使适用性扩展到其他可以找到多个类别进行识别的上下文中。
- en: In this chapter, we'll see all the stages necessary to implement, evaluate,
    and test a multiclass logistic regression model leveraging BigQuery ML.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看到实现、评估和测试多类逻辑回归模型所需的所有阶段，利用BigQuery ML。
- en: 'In this chapter, we''ll go through the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: Introducing the business scenario
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍业务场景
- en: Discovering multiclass logistic regression
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发现多类逻辑回归
- en: Exploring and understanding the dataset
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索和理解数据集
- en: Training the multiclass logistic regression model
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 训练多类逻辑回归模型
- en: Evaluating the multiclass logistic regression model
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评估多类逻辑回归模型
- en: Using the multiclass logistic regression model
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用多类逻辑回归模型
- en: Drawing business conclusions
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提炼业务结论
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'This chapter requires you to access a web browser and to have the possibility
    to leverage the following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章要求您访问网络浏览器，并具备利用以下功能的能力：
- en: A GCP account to access the Google Cloud Console
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个GCP账户以访问Google Cloud控制台
- en: A GCP project to host the BigQuery datasets
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于托管BigQuery数据集的GCP项目
- en: Now that we're ready with the technical requirements, let's dive into the analysis
    and development of our BigQuery ML logistic regression model.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了技术要求，让我们深入分析和发展我们的BigQuery ML逻辑回归模型。
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/3h4w7xG](https://bit.ly/3h4w7xG)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，了解代码的实际应用：[https://bit.ly/3h4w7xG](https://bit.ly/3h4w7xG)
- en: Introducing the business scenario
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍业务场景
- en: For this business scenario, we can imagine being a ML expert in New York City.
    Among all the activities that the city should perform, a census of the trees and
    verifying their condition is one of the most time-consuming.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个业务场景，我们可以想象自己是一名纽约市的ML专家。在市应执行的所有活动中，对树木进行普查和验证其状况是最耗时的之一。
- en: The trees are spread across different areas of New York City and the process
    of collecting information about each tree is performed manually by volunteers
    or New York City employees. After the collection of the information, the data
    is stored in a database and made publicly available through a BigQuery public
    dataset for further analyses ([https://console.cloud.google.com/marketplace/details/city-of-new-york/nyc-tree-census](https://console.cloud.google.com/marketplace/details/city-of-new-york/nyc-tree-census)).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这些树木分布在新泽西市的不同区域，收集每棵树的信息是由志愿者或纽约市员工手动完成的。信息收集完成后，数据存储在数据库中，并通过BigQuery公共数据集公开，以便进行进一步分析([https://console.cloud.google.com/marketplace/details/city-of-new-york/nyc-tree-census](https://console.cloud.google.com/marketplace/details/city-of-new-york/nyc-tree-census))。
- en: 'In the following figure, we can see a picture from Central Park, one of the
    areas with more trees in New York City:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下图中，我们可以看到中央公园的一张照片，这是纽约市树木最多的区域之一：
- en: '![Figure 6.1 – Trees in Central Park, New York City'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.1 – 纽约市中央公园的树木'
- en: '](img/B16722_06_001.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16722_06_001.jpg)'
- en: Figure 6.1 – Trees in Central Park, New York City
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1 – 纽约市中央公园的树木
- en: In order to support and accelerate the job of the people in charge of classifying
    the trees and assessing their condition, one of your managers may ask you to build
    a ML model.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持和加速负责分类树木和评估其状况的人员的工作，你们的一位经理可能要求你构建一个机器学习模型。
- en: The goal of the ML model would be to automatically classify the trees into different
    species according to their characteristics, such as their position, size, and
    health status.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 机器学习模型的目标是根据树木的特征，如位置、大小和健康状况，自动将树木分类到不同的种类。
- en: For this use case, we can focus our attention only on the five species of trees
    most present in the city.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个用例，我们只需关注城市中最常见的五种树木种类。
- en: Now that we've briefly explained and understood the business scenario, let's
    take a look at the ML technique that we can use to classify objects or events
    into multiple classes.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经简要解释并理解了业务场景，让我们看看我们可以用来将对象或事件分类到多个类别的机器学习技术。
- en: Discovering multiclass logistic regression
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发现多类逻辑回归
- en: In this section, we'll learn the basics of multiclass logistic regression and
    when this technique can be applied.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习多类逻辑回归的基础知识以及何时可以应用这项技术。
- en: '**Multiclass logistic regression** is a classification technique that can be
    used to categorize events, objects, customers, or other entities into multiple
    classes. Different from binary logistic regression, this ML algorithm can be used
    to classify output values into more than two discrete classes.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**多类逻辑回归**是一种分类技术，可以用来将事件、对象、客户或其他实体分类到多个类别。与二元逻辑回归不同，这个机器学习算法可以将输出值分类到超过两个离散类别。'
- en: In order to predict one of the multiple labels, this ML algorithm calculates
    the probability of each outcome and selects the label with the highest probability.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了预测多个标签中的一个，这个机器学习算法计算每个结果的概率，并选择概率最高的标签。
- en: Being a regression algorithm, the prediction of the label is based on a set
    of independent variables called features that are used to predict the dependent
    variable, called a label.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种回归算法，标签的预测基于一组称为特征的独立变量，这些变量用于预测称为标签的因变量。
- en: 'This ML technique can be used to answer business questions, such as the following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这种机器学习技术可以用来回答以下业务问题：
- en: Is the comment of my customer *neutral*, *positive*, or *negative*?
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我的客户的评论是*中性*、*正面*还是*负面*？
- en: Does my customer belong to the *Gold*, *Silver*, or *Bronze* level?
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我的客户属于*金*、*银*还是*铜*等级？
- en: Is the probability of churn for a specific customer *high*, *medium*, or *low*?
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特定客户的流失概率是*高*、*中*还是*低*？
- en: Does the image recognition algorithm identify a *cat*, a *dog*, a *mouse*, or
    a *cow*?
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像识别算法识别的是*猫*、*狗*、*老鼠*还是*牛*？
- en: In our business scenario, since there are a limited number of species of trees
    and we'll focus only on five species, we can leverage multiclass logistic regression.
    Specifically, we're interested in classifying a tree into one of the five species
    according to its characteristics in terms of size, position, and health status.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的业务场景中，由于树木的种类有限，我们只关注五种，我们可以利用多类逻辑回归。具体来说，我们感兴趣的是根据树木的大小、位置和健康状况特征将其分类到五种种类之一。
- en: Training a multiclass logistic regression model means trying to find the values
    of the coefficients that can be used in the equation between the input variables,
    called features, and the output variable, called a label.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 训练多类逻辑回归模型意味着尝试找到可以用于输入变量（称为特征）和输出变量（称为标签）之间方程的系数值。
- en: After the training, we'll leverage a **Confusion Matrix** to evaluate the performances
    of our multiclass logistic regression model. In multiclass logistic regression,
    multiple rows and multiple columns compose the confusion matrix.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 训练完成后，我们将利用**混淆矩阵**来评估我们的多类逻辑回归模型的表现。在多类逻辑回归中，混淆矩阵由多行和多列组成。
- en: To evaluate the performances of our ML model, we'll again use the **Area Under
    the Curve** (**AUC**) **Receiver Operating Characteristic** (**ROC**).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为了评估我们的机器学习模型的表现，我们还将使用**曲线下面积**（**AUC**）**接收者操作特征**（**ROC**）。
- en: Now that we've learned the basics of multiclass logistic regression, it's time
    to take a look at the dataset that we'll use to build our ML model.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学习了多类逻辑回归的基础知识，是时候看看我们将用于构建机器学习模型的那个数据集了。
- en: Exploring and understanding the dataset
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索和理解数据集
- en: As we've already done in the previous use cases, before diving into the development
    of the ML model, it's necessary to analyze the data that can be used to solve
    our use case.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的用例中所做的那样，在深入开发机器学习模型之前，分析可用于解决我们用例的数据是必要的。
- en: We'll start with the analysis of the table structure to have a clear understanding
    of the data that can be used for our business scenario.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先分析表结构，以便清楚地了解可用于我们业务场景的数据。
- en: Understanding the data
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解数据
- en: In this section, we'll look take a look at the data to understand its structure
    and how it can be used to build our ML model.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将查看数据以了解其结构以及如何用它来构建我们的机器学习模型。
- en: 'To start exploring the data, we need to do the following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始探索数据，我们需要做以下几步：
- en: Log in to the Google Cloud Console and access the **BigQuery** user interface
    from the navigation menu.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录Google Cloud控制台，并通过导航菜单访问**BigQuery**用户界面。
- en: Create a new dataset under the project that we created in [*Chapter 2*](B16722_02_Final_ASB_ePub.xhtml#_idTextAnchor039),
    *Setting Up Your GCP and BigQuery Environment*. For this use case, we'll create
    the dataset `06_nyc_trees` with the default options.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们创建的项目下创建一个新的数据集，该项目在[*第2章*](B16722_02_Final_ASB_ePub.xhtml#_idTextAnchor039)，*设置您的GCP和BigQuery环境*中提到。对于此用例，我们将使用默认选项创建数据集`06_nyc_trees`。
- en: Open the GCP project `new_york_trees`.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开GCP项目`new_york_trees`。
- en: As we can see in the following screenshot, the BigQuery public dataset contains
    multiple tables to host the data collected every 10 years:![Figure 6.2 – The New
    York City Trees Public dataset contains the census
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如以下截图所示，BigQuery公共数据集包含多个表，用于存储每10年收集的数据：![图6.2 – 纽约市树木公共数据集包含了每10年收集的树木普查数据
- en: of the trees collected every 10 years
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 的树木普查数据
- en: '](img/B16722_06_002.jpg)'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16722_06_002.jpg)'
- en: Figure 6.2 – The New York City Trees Public dataset contains the census of the
    trees collected every 10 years
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图6.2 – 纽约市树木公共数据集包含了每10年收集的树木普查数据
- en: 'We''ll use the most recent one: `tree_census_2015`. This table contains all
    the information about the trees planted in New York City and registered in 2015.'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用最新的一个：`tree_census_2015`。这个表包含了2015年在纽约市种植并注册的所有树木信息。
- en: Let's click on the table name `tree_census_2015` in the BigQuery navigation
    menu to access the schema of the table:![Figure 6.3 – The structure of the tree_census_2015
    table lists all the fields
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在BigQuery导航菜单中点击表名`tree_census_2015`以访问表的架构：![图6.3 – tree_census_2015表的结构列出了所有字段
- en: that can be used as labels and features
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可以用作标签和特征的
- en: '](img/B16722_06_003.jpg)'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16722_06_003.jpg)'
- en: Figure 6.3 – The structure of the tree_census_2015 table lists all the fields
    that can be used as labels and features
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图6.3 – tree_census_2015表的结构列出了所有可以作为标签和特征的字段
- en: Each field is well described in the **Description** column.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个字段都在**描述**列中有很好的描述。
- en: The table contains the **spc_latin** column represented by a **STRING** that
    indicates the scientific name of the species of each tree. This field will be
    the label of our ML model.
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 表中包含表示每种树木物种的科学名称的**spc_latin**列，该列以**STRING**形式表示。这个字段将是我们的机器学习模型的标签。
- en: In order to classify each tree, we can leverage the information present in other
    fields. Some columns describe the size of the tree. For example, **tree_dbh**
    measures the diameter of the tree and **stump_diam** represents the diameter of
    the stump. We can also leverage information about the **health** of the tree.
    We can imagine that some species are more robust than others and more suited to
    the New York City weather.
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了对每棵树进行分类，我们可以利用其他字段中的信息。一些列描述了树木的大小。例如，**tree_dbh**测量树木的直径，**stump_diam**代表树桩的直径。我们还可以利用关于树木**健康状况**的信息。我们可以想象，一些物种比其他物种更健壮，更适合纽约市的天气。
- en: 'Other fields are more related to the position of the tree in the city and to
    the context where it lives. In order to train our ML model, we can use the zip
    area where the tree resides: **zip_city**. Some other examples are the **boroname**
    column, which contains the name of the borough where the tree was planted, and
    **nta_name**, which represents the neighborhood the tree falls into.'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 其他字段与树木在城市中的位置以及其生活环境的背景关系更为密切。为了训练我们的机器学习模型，我们可以使用树木所在的邮编区域：**zip_city**。其他一些例子包括包含树木种植区域名称的**boroname**列，以及代表树木所属地区的**nta_name**。
- en: We can also assume that some species are more intrusive than others – the **sidewalk**
    field indicates whether a sidewalk adjacent to the tree was damaged, cracked,
    or lifted by the roots of the tree.
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们还可以假设某些物种比其他物种更具侵入性——`sidewalk` 字段表示树木旁边的人行道是否因树木的根而受损、开裂或抬起。
- en: From a schema perspective, this table includes a lot of useful information that
    can be used to develop our classification model. Let's proceed with our analysis,
    diving more into the data.
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从架构的角度来看，此表包含大量可用于开发我们的分类模型的有用信息。让我们继续我们的分析，更深入地了解数据。
- en: In this section, we've analyzed the metadata of the **tree_census_2015** table,
    now it's time to look at the actual data and start querying it.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们已经分析了 `tree_census_2015` 表的元数据，现在是我们查看实际数据并开始查询的时候了。
- en: Checking the data quality
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查数据质量
- en: 'As we''ve already understood from the previous use cases, the quality of data
    is fundamental to build effective ML models. In this section, we''ll apply some
    data quality checks in order to identify the right records to use:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们从之前的用例中已经理解的那样，数据质量对于构建有效的机器学习模型至关重要。在本节中，我们将应用一些数据质量检查，以确定应使用的正确记录：
- en: 'First of all, we''ll check if the table `tree_census_2015` contains records
    with `spc_latin` equals to NULL. This is fundamental because the field `spc_latin`
    will be used as label of our machine learning model:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将检查表 `tree_census_2015` 是否包含 `spc_latin` 等于 NULL 的记录。这是基本的，因为字段 `spc_latin`
    将用作我们机器学习模型的标签：
- en: '[PRE0]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The code block will COUNT all the records in the table ``bigquery-public-data.new_york_trees.tree_census_2015``
    where the field `spc_latin` is empty.
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 代码块将统计表 ``bigquery-public-data.new_york_trees.tree_census_2015`` 中字段 `spc_latin`
    为空的记录数量。
- en: 'In the following screenshot, you can see the results of the query where we
    got a value higher than thirty one thousand:'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在下面的屏幕截图中，您可以查看查询结果，其中我们得到了超过三千一的结果：
- en: '![Figure 6.4 – The result of the query shows that some rows contain empty labels'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 6.4 – 查询结果显示某些行包含空标签'
- en: '](img/B16722_06_004.jpg)'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16722_06_004.jpg)'
- en: Figure 6.4 – The result of the query shows that some rows contain empty labels
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 6.4 – 查询结果显示某些行包含空标签
- en: For this reason, in the next queries we'll exclude the records where the field
    `spc_latin` is empty.
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，在接下来的查询中，我们将排除字段 `spc_latin` 为空的记录。
- en: 'Focusing only on the rows where the field `spc_latin` is `NOT NULL`, we can
    check the presence of empty values on all the other fields that are potential
    features of our ML model:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仅关注字段 `spc_latin` 为 `NOT NULL` 的行，我们可以检查所有其他潜在特征字段上空值的存在：
- en: '[PRE1]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Also, in this case, the result of the query is not zero. In fact, we can easily
    identify three records that present `NULL` values in the `health` and `sidewalk`
    fields.
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此外，在这种情况下，查询的结果不是零。事实上，我们可以轻松地识别出三个在 `health` 和 `sidewalk` 字段中呈现 `NULL` 值的记录。
- en: We'll filter these records in the following stages of the ML model life cycle.
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将在机器学习模型生命周期的后续阶段过滤这些记录。
- en: Now that we've applied some quality checks to our dataset and we've understood
    which records should be filtered, let's focus on segmenting our dataset to focus
    the creation of our BigQuery ML model only on the five most frequent species of
    trees.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对我们的数据集进行了质量检查，并了解了哪些记录应该被过滤，让我们专注于分割我们的数据集，以便只针对树木的五种最频繁出现的物种创建我们的 BigQuery
    机器学习模型。
- en: Segmenting the dataset
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据集分割
- en: In this section, we'll prepare the tables that we'll use to train, evaluate,
    and test our ML model.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将准备我们将用于训练、评估和测试我们的机器学习模型的表。
- en: 'For our purposes, we''ll extract the five most frequent species that appear
    in the dataset. After that, we''ll create the BigQuery tables that will be used
    to train, evaluate, and test our ML model:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了我们的目的，我们将从数据集中提取出现频率最高的五种物种。之后，我们将创建用于训练、评估和测试我们的机器学习模型的 BigQuery 表：
- en: 'First of all, we''ll identify only the five most frequent species in the `tree_census_2015`
    table with the following query:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将使用以下查询仅识别 `tree_census_2015` 表中的五种最频繁出现的物种：
- en: '[PRE2]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The SQL statement counts the number of occurrences of each species in the `tree_census_2015`
    table using the `GROUP BY spc_latin` clause and the `COUNT(*)` operator.
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: SQL 语句使用 `GROUP BY spc_latin` 子句和 `COUNT(*)` 操作符计算 `tree_census_2015` 表中每种物种出现的次数。
- en: The query orders the records in descending mode according to the value of the
    field `total` field, which contains the result of the `COUNT`. Finally, the result
    set of the query is limited to the first five records of the result set with the
    `LIMIT 5` clause at the end of the query.
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 查询按照`total`字段（包含`COUNT`的结果）的值以降序排列记录，最后，查询的结果集通过查询末尾的`LIMIT 5`子句限制为结果集的前五条记录。
- en: The SQL statement is based on the BigQuery public table `tree_census_2015` properly
    filtered with the data quality checks that we identified in the previous, *Checking
    the data quality* section.
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: SQL语句基于BigQuery公共表`tree_census_2015`，经过我们在前面的*检查数据质量*部分中确定的数据质量检查适当过滤。
- en: 'In the following screenshot, we can see the results of the query and the most
    common species of tree in our dataset:'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在下面的屏幕截图中，我们可以看到查询结果和我们的数据集中最常见的树木物种：
- en: '![Figure 6.5 – The result of the query shows the most common trees in New York
    City'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图6.5 – 查询的结果显示了纽约市最常见的树木'
- en: '](img/B16722_06_005.jpg)'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16722_06_005.jpg)'
- en: Figure 6.5 – The result of the query shows the most common trees in New York
    City
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图6.5 – 查询的结果显示了纽约市最常见的树木
- en: From the query result, we can easily read the Latin name of the trees ordered
    from the most to the least common.
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从查询结果中，我们可以轻松地读取从最常见到最不常见的树木的拉丁学名。
- en: 'Since we''ll use this subset of five species in the next SQL queries, we can
    add a `CREATE TABLE` statement at the beginning of our `SELECT` statement in order
    to materialize the results in the `top5_species` table:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们将在接下来的SQL查询中使用这五种物种的子集，我们可以在我们的`SELECT`语句的开头添加一个`CREATE TABLE`语句，以便将结果物化到`top5_species`表中：
- en: '[PRE3]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: By executing the query, we'll get the creation of a new table that contains
    only two fields and five records. `spc_latin` represents the species of the tree,
    while `total` counts the number of occurrences of each species in the original
    dataset.
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过执行查询，我们将得到创建一个新表的创建，该表仅包含两个字段和五条记录。`spc_latin`代表树木的物种，而`total`计算每个物种在原始数据集中的出现次数。
- en: 'Now, we can leverage the `top5_species` table to filter only the species on
    which we''re focusing and create the training table:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以利用`top5_species`表来过滤仅关注物种，并创建训练表：
- en: '[PRE4]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The query creates a table with all the columns available in the original dataset
    through the `SELECT *` statement. It applies all the filters necessary to get
    not empty values for the `spc_latin` label and all the other potential features.
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 查询通过`SELECT *`语句创建一个包含原始数据集中所有列的表。它应用了所有必要的过滤器，以获取`spc_latin`标签的非空值以及所有其他潜在特征。
- en: With the usage of the `IN` clause, `training_table` will contain only the records
    related to the most five frequent species in the dataset.
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用`IN`子句，`training_table`将只包含与数据集中最频繁的五种物种相关的记录。
- en: The last line of the query, with the clause `MOD(tree_id,11)<=8`, allows us
    to only pick up 80% of the records from the entire set of records. `MOD` stands
    for modulo and returns the remainder of the division of `tree_id` by 11.
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 查询的最后一条语句，带有`MOD(tree_id,11)<=8`子句，使我们能够只从整个记录集中选择80%的记录。`MOD`代表模运算，返回`tree_id`除以11的余数。
- en: 'With a similar approach, we can create the table that will be used for the
    evaluation of our ML model:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用类似的方法，我们可以创建用于评估我们的机器学习模型的表：
- en: '[PRE5]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: For the `evaluation_table`, we will pick up only 10% of the records with the
    filter `MOD(tree_id,11)=9`.
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于`evaluation_table`，我们将通过`MOD(tree_id,11)=9`过滤器选择仅10%的记录。
- en: 'Finally, we''ll execute the following SQL statement in order to create the
    table that will be used to apply our multiclass classification model:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将执行以下SQL语句以创建用于应用我们的多类分类模型的表：
- en: '[PRE6]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`classification_table` is very similar to the previous segments of the dataset,
    but thanks to the `MOD` function will contain the remaining 10% percent of the
    dataset.'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`classification_table`与数据集的前几部分非常相似，但多亏了`MOD`函数，它将包含数据集剩余的10%。'
- en: In this section, we've analyzed the `new_york_trees` dataset, which contains
    information about the trees in New York City. We applied some data quality checks
    to exclude empty values. Then, we segmented the data, focusing on the five most
    common species that appear in the table. Now that we've completed the preparatory
    steps, it's time to move on and start the training of our BigQuery ML model.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们分析了包含有关纽约市树木信息的`new_york_trees`数据集。我们对数据进行了一些数据质量检查，以排除空值。然后，我们分割了数据，重点关注表中出现的五种最常见的物种。现在我们已经完成了准备工作，是时候继续前进并开始训练我们的BigQuery
    ML模型了。
- en: Training the multiclass logistic regression model
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 训练多类逻辑回归模型
- en: 'Now that we''ve clearly understood the structure of the data and we''ve segmented
    it into multiple tables to support the different stages of the ML model life cycle,
    let''s focus on the training of our multiclass logistic regression model. We''ll
    execute the SQL queries to create our multiclass logistic regression models:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经清楚地理解了数据结构，并且将其分割成多个表格以支持ML模型生命周期的不同阶段，让我们专注于我们多类逻辑回归模型的训练。我们将执行SQL查询来创建我们的多类逻辑回归模型：
- en: 'Let''s start creating the first version of our ML model:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们开始创建我们ML模型的第一版本：
- en: '[PRE7]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The query used to create the `classification_model_version_1` model is based
    only on two features: the zip area and the diameter of the tree.'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 创建`classification_model_version_1`模型所使用的查询仅基于两个特征：邮编区域和树木直径。
- en: The SQL statement starts with the keywords `CREATE OR REPLACE MODEL`, which
    are used to run the training, followed by the `OPTIONS` clause. Among the options,
    we can specify the model type equals `LOGISTIC_REG` and `auto_class_weights=TRUE`.
    This option can be particularly useful when we're in front of unbalanced training
    datasets with some labels that appear more frequently than others. In our case,
    the occurrences of the most common species are more than double the occurrences
    of the fifth one. For this reason, we've applied this kind of adjustment.
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: SQL语句以关键字`CREATE OR REPLACE MODEL`开始，用于运行训练，后面跟着`OPTIONS`子句。在选项中，我们可以指定模型类型等于`LOGISTIC_REG`和`auto_class_weights=TRUE`。这个选项在我们面对不平衡的训练数据集，某些标签出现频率高于其他标签时尤其有用。在我们的案例中，最常见的物种的出现次数是第五个物种的两倍以上。因此，我们应用了这种调整。
- en: Important note
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 重要提示
- en: The BigQuery ML syntax does not distinguish between binary logistic regression
    and multiclass logistic regression. In both cases, the BigQuery ML model type
    is `LOGISTIC_REG`. The difference is caused by the number of distinct values that
    appear in the column label of the training dataset. If the label presents only
    two values, BigQuery ML will train a binary logistic regression. If the label
    contains more than two distinct values, the model will be trained as a multiclass
    logistic regression.
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: BigQuery ML语法在二元逻辑回归和多类逻辑回归之间没有区别。在两种情况下，BigQuery ML模型类型都是`LOGISTIC_REG`。差异是由训练数据集列标签中出现的不同值的数量引起的。如果标签只包含两个值，BigQuery
    ML将训练二元逻辑回归。如果标签包含超过两个不同值，模型将作为多类逻辑回归进行训练。
- en: After the execution of the training, we can access the information of our first
    ML model by clicking on **classification_model_version_1** from the navigation
    menu and selecting the **Evaluation** tab.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 训练执行后，我们可以通过点击导航菜单中的**classification_model_version_1**并选择**评估**选项卡来访问我们第一个ML模型的信息。
- en: 'The following screenshot presents the key performance indicators of our first
    attempt:'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下截图展示了我们第一次尝试的关键性能指标：
- en: '![Figure 6.6 – The Evaluation tab shows the performance metrics related'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![Figure 6.6 – The Evaluation tab shows the performance metrics related'
- en: to the selected BigQuery ML model
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 到选定的BigQuery ML模型
- en: '](img/B16722_06_006.jpg)'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/B16722_06_006.jpg]'
- en: Figure 6.6 – The Evaluation tab shows the performance metrics related to the
    selected BigQuery ML model
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Figure 6.6 – The Evaluation tab shows the performance metrics related to the
    selected BigQuery ML model
- en: To have an idea of the effectiveness of our ML model, we can look at the **ROC
    AUC** value of **0.7383**.
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了了解我们ML模型的有效性，我们可以查看**ROC AUC**值为**0.7383**。
- en: By scrolling down with the mouse in the **Evaluation** tab, we can take a look
    at the confusion matrix of our multiclass logistic regression model.
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过在**评估**选项卡中用鼠标向下滚动，我们可以查看我们多类逻辑回归模型的混淆矩阵。
- en: 'In the following figure, the confusion matrix shows the percentage of predicted
    and actual labels on the training dataset:'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在以下图中，混淆矩阵显示了训练数据集中预测和实际标签的百分比：
- en: '![Figure 6.7 – The Evaluation tab shows the confusion matrix related to the
    selected BigQuery ML model'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图6.7 – 评估选项卡显示了与所选BigQuery ML模型相关的混淆矩阵'
- en: '](img/B16722_06_007.jpg)'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16722_06_007.jpg)'
- en: Figure 6.7 – The Evaluation tab shows the confusion matrix related to the selected
    BigQuery ML model
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图6.7 – 评估选项卡显示了与所选BigQuery ML模型相关的混淆矩阵
- en: 'Looking at the confusion matrix, we can visually notice that our ML model works
    quite well for some species but performs very poorly for others. For example,
    when the actual label is **Quercus palustris**, in 40% of the cases the ML model
    suggests a different species: **Platanus x acerifolia**.'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过查看混淆矩阵，我们可以直观地注意到，我们的机器学习模型在某些物种上表现相当好，但在其他物种上表现非常差。例如，当实际标签是**Quercus palustris**时，在40%的情况下，机器学习模型建议的是不同的物种：**Platanus
    x acerifolia**。
- en: 'Let''s try to improve our model by adding new features with the following BigQuery
    ML SQL statement:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们尝试通过以下BigQuery ML SQL语句添加新特征来改进我们的模型：
- en: '[PRE8]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In comparison with the first attempt, we've included additional features in
    the training of our model. In fact, we've added the name of the borough contained
    in the `boroname` field and `nta_name` to the list of features.
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与第一次尝试相比，我们在模型的训练中加入了额外的特征。实际上，我们将`boroname`字段和`nta_name`中包含的区名添加到了特征列表中。
- en: After the execution of the SQL statement, let's access the **Evaluation** tab
    of the new model to see if we're improving its performance. Taking a look at the
    **ROC AUC** value of **0.7667**, we can see a slight increase in the performance
    of our model.
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 执行SQL语句后，让我们访问新模型的**评估**选项卡，看看我们是否提高了其性能。查看**ROC AUC**值为**0.7667**，我们可以看到我们模型性能的轻微提升。
- en: 'As a last attempt, we''ll enrich our ML model with additional features. The
    new fields are related to the health of the tree and to the size of the roots:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为最后的尝试，我们将通过添加额外的特征来丰富我们的机器学习模型。新字段与树木的健康状况和根的大小相关：
- en: '[PRE9]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Compared to the previous ML model, in `classification_model_version_3` we've
    included the fields `health`, which describes the health status of our tree, and
    `sidewalk`, used to specify whether the roots of the tree are damaging the adjacent
    pavements.
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与之前的机器学习模型相比，在`classification_model_version_3`中，我们包括了`health`字段，它描述了我们的树木的健康状况，以及`sidewalk`字段，用于指定树木的根是否损坏了相邻的人行道。
- en: Looking at the performance of our last ML model in the `0.7696`.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看我们最后一个机器学习模型在`0.7696`的性能。
- en: Tip
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 小贴士
- en: Although the usage of more features can increase the ROC AUC value of a BigQuery
    ML classification model, we need to take into consideration the balance between
    the performance improvement and the resources spent to achieve it. In real-life
    scenarios, especially when the volumes are really high, we need to select only
    the features that can have the highest impact on the performance of our BigQuery
    ML model.
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 尽管使用更多特征可以增加BigQuery ML分类模型的ROC AUC值，但我们需要考虑性能提升和实现它所花费的资源之间的平衡。在现实场景中，尤其是在数据量真的很大时，我们需要选择那些可能对我们BigQuery
    ML模型性能产生最高影响的特征。
- en: 'In this section, we''ve created different ML models trying to use different
    features in our dataset. In the next sections, we''ll use the model with the highest
    ROC AUC value: `classification_model_version_3`.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们创建了不同的机器学习模型，尝试在我们的数据集中使用不同的特征。在下一节中，我们将使用具有最高ROC AUC值的模型：`classification_model_version_3`。
- en: Next, let's evaluate the performance of our ML model leveraging the evaluation
    dataset.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们利用评估数据集评估我们的机器学习模型的表现。
- en: Evaluating the multiclass logistic regression model
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评估多类逻辑回归模型
- en: In this section, we'll execute queries to check the performance of the multiclass
    logistic regression model.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将执行查询以检查多类逻辑回归模型的表现。
- en: For the evaluation phase of our BigQuery ML model, we'll use the `ML.EVALUATE`
    function and the `evaluation_table` table, expressly created to host the evaluation
    records.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的BigQuery ML模型的评估阶段，我们将使用`ML.EVALUATE`函数和`evaluation_table`表，该表专门创建用于托管评估记录。
- en: As we can see, the evaluation is performed on the same fields that were used
    during the training phase of the model but are extracted from the `evaluation_table`
    table that was created completely disjoint from the training dataset.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，评估是在模型训练阶段使用的相同字段上进行的，但这些字段是从完全独立于训练数据集创建的`evaluation_table`表中提取的。
- en: The external `SELECT` statement extracts the `roc_auc` value returned by the
    `ML.EVALUATE` function. It also provides a meaningful description of the quality
    of the model that starts from `'POOR'` and goes up to the `'EXCELLENT'` grade,
    passing through some intermediate stages such as `'NEEDS IMPROVEMENTS'` and `'GOOD'`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s execute the following query to extract the key performance indicator
    of our ML model:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'From the following screenshot, we can see the results of the query – the **roc_auc**
    value achieved more than 0.77\. The result of our BigQuery ML model can be considered
    **GOOD**:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.8 – The query extracts the ROC AUC value of the BigQuery ML model'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: and a short description of the model quality
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16722_06_008.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.8 – The query extracts the ROC AUC value of the BigQuery ML model and
    a short description of the model quality
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've verified that the ML model maintains its performance on the disjoint
    evaluation dataset too, we can start using it to classify the trees in our `classification_table`
    table.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Using the multiclass logistic regression model
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll test our ML model and analyze the results.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: 'To use our BigQuery ML model, we''ll use the `ML.PREDICT` function and the
    `classification_table` table, which hosts the records, to test our model, as seen
    in the following code block:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The query statement is composed of the `SELECT` keyword, which extracts the
    `tree_id`, the actual value of the species in the field, `actual_label`, and the
    predicted fields `predicted_label_probs` and `predicted_label`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: The `ML.PREDICT` function is applied to the `SELECT` statement, which extracts
    the features and the actual species from the `classification_table`. The `actual_label`
    field will be used only as a benchmark for our predictions and not during the
    prediction phase.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following screenshot, we can see the structure of a record gotten from
    the execution of the previous query:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.9 – A record of the output dataset generated by the classification
    model'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16722_06_009.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.9 – A record of the output dataset generated by the classification
    model
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: In this case, **tree_id** is equal to **857**, the tree is a **Quercus palustris**,
    and is correctly classified by the BigQuery ML model because **predicted_label**
    is exactly the same. **predicted_label_probs** indicates confidence of 45% for
    the highest classification label. All the other possible species are characterized
    by lower probabilities.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've applied our model, let's formulate some final considerations
    about our classification use case.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Drawing business conclusions
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using the results that we got from the previous section, *Using the multiclass
    logistic regression model*, we'll draw some conclusions about the effectiveness
    of our ML model.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Enriching the previous query with a parent `SELECT COUNT` statement, we can
    count how many predictions are right compared to the total number of records.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s execute the following query to calculate how often our BigQuery ML model
    is able to correctly classify the trees in the `classification_table` table:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下查询来计算我们的BigQuery ML模型在`classification_table`表中正确分类树木的频率：
- en: '[PRE12]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The result of the `SELECT COUNT` query returns a value of 13,323 predictions
    with a correctly predicted label.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`SELECT COUNT`查询的结果返回了13,323个预测值，其中正确预测的标签值为13,323。'
- en: Considering that the total size of the `classification_table` table is 27,182,
    we can declare that in 49% of cases, our ML model is able to predict the right
    species of tree based on its characteristics and its position.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到`classification_table`表的总大小为27,182，我们可以声明在49%的情况下，我们的ML模型能够根据其特征和位置预测正确的树种。
- en: This could seem like a bad result, but we need to consider that multiclass logistic
    regression is more complex than a binary one because there are multiple options
    that could deceive the results of our model.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来是一个不好的结果，但我们需要考虑多分类逻辑回归比二分类更复杂，因为存在多个选项可能会误导我们模型的结果。
- en: Summary
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we've built our first multiclass classification model. After
    a brief introduction to the use case, we discovered what multiclass logistic regression
    is and how it can be used to classify events, behaviors, and objects according
    to their features into more than two categories.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们构建了我们的第一个多分类模型。在简要介绍用例之后，我们发现了多分类逻辑回归是什么以及它是如何根据特征将事件、行为和对象分类到两个以上类别的。
- en: Before diving into the development of the ML model, we analyzed the schema of
    the dataset related to the trees in New York City and applied some data quality
    checks necessary to build an effective ML model.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入开发ML模型之前，我们分析了与纽约市树木相关的数据集模式，并应用了一些必要的质量检查，以构建一个有效的ML模型。
- en: During the training stage, we trained three different ML models using different
    features to gradually improve the performance of the BigQuery ML model.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在训练阶段，我们使用不同的特征训练了三个不同的ML模型，以逐步提高BigQuery ML模型的表现。
- en: Then, we chose the third ML model and we evaluated it against the evaluation
    dataset. In this phase, we noticed that the ML model was able to maintain its
    performance on new records also and was ready to pass to the next phase.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们选择了第三个ML模型，并对其进行了评估。在这个阶段，我们注意到ML模型能够在新记录上保持其性能，并准备进入下一阶段。
- en: In the last step, we used our ML model to classify the trees in New York City
    into five different categories and leveraged their characteristics, such as size,
    health status, and position in the city.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一步，我们使用我们的ML模型将纽约市的树木分类为五个不同的类别，并利用它们的特征，如大小、健康状况和在城市中的位置。
- en: We also calculated that our classification model is able to classify the right
    species of tree in 49% of cases.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还计算出我们的分类模型在49%的情况下能够正确分类树种。
- en: In the next chapter, we'll introduce unsupervised ML and the K-Means clustering
    technique.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍无监督ML和K-Means聚类技术。
- en: Further resources
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步资源
- en: '**NYC Trees Census Public Dataset**: [https://console.cloud.google.com/marketplace/product/city-of-new-york/nyc-tree-census](https://console.cloud.google.com/marketplace/product/city-of-new-york/nyc-tree-census)'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**纽约市树木普查公共数据集**：[https://console.cloud.google.com/marketplace/product/city-of-new-york/nyc-tree-census](https://console.cloud.google.com/marketplace/product/city-of-new-york/nyc-tree-census)'
- en: '**BigQuery ML Create Model**: [https://cloud.google.com/bigquery-ml/docs/reference/standard-sql/bigqueryml-syntax-create](https://cloud.google.com/bigquery-ml/docs/reference/standard-sql/bigqueryml-syntax-create)'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**BigQuery ML创建模型**：[https://cloud.google.com/bigquery-ml/docs/reference/standard-sql/bigqueryml-syntax-create](https://cloud.google.com/bigquery-ml/docs/reference/standard-sql/bigqueryml-syntax-create)'
- en: '**BigQuery ML Evaluate Model**: [https://cloud.google.com/bigquery-ml/docs/reference/standard-sql/bigqueryml-syntax-evaluate](https://cloud.google.com/bigquery-ml/docs/reference/standard-sql/bigqueryml-syntax-evaluate)'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**BigQuery ML评估模型**：[https://cloud.google.com/bigquery-ml/docs/reference/standard-sql/bigqueryml-syntax-evaluate](https://cloud.google.com/bigquery-ml/docs/reference/standard-sql/bigqueryml-syntax-evaluate)'
- en: '**BigQuery ML Predict**: [https://cloud.google.com/bigquery-ml/docs/reference/standard-sql/bigqueryml-syntax-predict](https://cloud.google.com/bigquery-ml/docs/reference/standard-sql/bigqueryml-syntax-predict)'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**BigQuery ML预测**：[https://cloud.google.com/bigquery-ml/docs/reference/standard-sql/bigqueryml-syntax-predict](https://cloud.google.com/bigquery-ml/docs/reference/standard-sql/bigqueryml-syntax-predict)'
- en: '**BigQuery ML Multiclass Logistic Example**: [https://cloud.google.com/bigquery-ml/docs/logistic-regression-prediction](https://cloud.google.com/bigquery-ml/docs/logistic-regression-prediction)'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**BigQuery ML 多类逻辑回归示例**: [https://cloud.google.com/bigquery-ml/docs/logistic-regression-prediction](https://cloud.google.com/bigquery-ml/docs/logistic-regression-prediction)'
