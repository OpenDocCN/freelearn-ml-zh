["```py\nvoid salt(cv::Mat image, int n) {\n\n  int i,j;\n  for (int k=0; k<n; k++) {\n\n    // rand() is the random number generator\n    i= std::rand()%image.cols;\n    j= std::rand()%image.rows;\n\n    if (image.type() == CV_8UC1) { // gray-level image\n\n      image.at<uchar>(j,i)= 255; \n\n    } else if (image.type() == CV_8UC3) { // color image\n\n      image.at<cv::Vec3b>(j,i)[0]= 255; \n      image.at<cv::Vec3b>(j,i)[1]= 255; \n      image.at<cv::Vec3b>(j,i)[2]= 255; \n    }\n  }\n}\n```", "```py\n   // open the image\n   cv::Mat image= cv::imread(\"boldt.jpg\");\n\n   // call function to add noise\n   salt(image,3000);\n\n   // display image\n   cv::namedWindow(\"Image\");\n   cv::imshow(\"Image\",image);\n```", "```py\n         image.at<uchar>(j,i)= 255;\n```", "```py\n         image.at<cv::Vec3b>(j,i)[channel]= value; \n```", "```py\n  // use image with a Mat_ template\n  cv::Mat_<uchar> im2(image);\n  im2(50,100)= 0; // access to row 50 and column 100\n```", "```py\nvoid colorReduce(cv::Mat image, int div=64);\n```", "```py\nvoid colorReduce(cv::Mat image, int div=64) {\n\n     int nl= image.rows; // number of lines\n     // total number of elements per line\n     int nc= image.cols * image.channels(); \n\n     for (int j=0; j<nl; j++) {\n\n        // get the address of row j\n        uchar* data= image.ptr<uchar>(j);\n\n        for (int i=0; i<nc; i++) {\n\n            // process each pixel ---------------------\n\n            data[i]=    data[i]/div*div + div/2;\n\n            // end of pixel processing ----------------\n\n        } // end of line\n     }\n}\n```", "```py\n   // read the image\n   image= cv::imread(\"boldt.jpg\");\n   // process the image\n   colorReduce(image,64);\n   // display the image\n   cv::namedWindow(\"Image\");\n   cv::imshow(\"Image\",image);\n```", "```py\n     int nc= image.cols * image.channels();\n```", "```py\n     uchar* data= image.ptr<uchar>(j);\n```", "```py\n     *data= *data/div*div + div2; data++;\n```", "```py\n     data[i]= (data[i]/div)*div + div/2;\n```", "```py\n     data[i]= data[i] â€“ data[i]%div + div/2;\n```", "```py\n     // mask used to round the pixel value\n     uchar mask= 0xFF<<n; // e.g. for div=16, mask= 0xF0\n```", "```py\n      *data &= mask;      // masking\n      *data++ += div>>1;  // add div/2\n```", "```py\n   // read the image\n   image= cv::imread(\"boldt.jpg\");\n   // clone the image\n   cv::Mat imageClone= image.clone();\n   // process the clone\n   // orginal image remains untouched\n   colorReduce(imageClone);\n   // display the image result\n   cv::namedWindow(\"Image Result\");\n   cv::imshow(\"Image Result\",imageClone);\n```", "```py\nvoid colorReduce(const cv::Mat &image, // input image \n                 cv::Mat &result,      // output image\n                 int div=64);\n```", "```py\ncolorReduce(image,image);\n```", "```py\ncv::Mat result;   \ncolorReduce(image,result);\n```", "```py\n     result.create(image.rows,image.cols,image.type());\n```", "```py\n   for (int j=0; j<nl; j++) {\n\n        // get the addresses of input and output row j\n        const uchar* data_in= image.ptr<uchar>(j);\n        uchar* data_out= result.ptr<uchar>(j);\n\n        for (int i=0; i<nc*nchannels; i++) {\n\n            // process each pixel ---------------------\n\n            data_out[i]= data_in[i]/div*div + div/2;\n\n            // end of pixel processing ----------------\n\n        } // end of line\n  }\n```", "```py\n// check if size of a line (in bytes)\n// equals the number of columns times pixel size in bytes\nimage.step == image.cols*image.elemSize();\n```", "```py\nvoid colorReduce(cv::Mat &image, int div=64) {\n\n     int nl= image.rows; // number of lines\n     int nc= image.cols * image.channels(); \n\n     if (image.isContinuous()) \n     {\n        // then no padded pixels\n        nc= nc*nl; \n        nl= 1;  // it is now a long 1D array\n     }\n\n     // this loop is executed only once\n     // in case of continuous images\n     for (int j=0; j<nl; j++) { \n\n          uchar* data= image.ptr<uchar>(j);\n\n          for (int i=0; i<nc; i++) {\n\n            // process each pixel ---------------------\n\n            data[i]= data[i]/div*div + div/2;\n\n            // end of pixel processing ----------------\n\n          } // end of line                   \n     }\n}\n```", "```py\n     if (image.isContinuous()) \n     {\n        // no padded pixels\n        image.reshape(1,   // new number of channels\n                      1); // new number of rows\n     }\n\n     int nl= image.rows; // number of lines\n     int nc= image.cols * image.channels(); \n```", "```py\nuchar *data= image.data;\n```", "```py\ndata+= image.step;  // next line\n```", "```py\n// address of pixel at (j,i) that is &image.at(j,i)     \ndata= image.data+j*image.step+i*image.elemSize();    \n```", "```py\n     cv::MatIterator_<cv::Vec3b> it;\n```", "```py\n     cv::Mat_<cv::Vec3b>::iterator it;\n```", "```py\nvoid colorReduce(cv::Mat &image, int div=64) {\n\n     // obtain iterator at initial position\n     cv::Mat_<cv::Vec3b>::iterator it= \n               image.begin<cv::Vec3b>();\n     // obtain end position\n     cv::Mat_<cv::Vec3b>::iterator itend= \n               image.end<cv::Vec3b>();\n\n     // loop over all pixels\n     for ( ; it!= itend; ++it) {\n        // process each pixel ---------------------\n\n       (*it)[0]= (*it)[0]/div*div + div/2;\n       (*it)[1]= (*it)[1]/div*div + div/2;\n       (*it)[2]= (*it)[2]/div*div + div/2;\n\n        // end of pixel processing ----------------\n     }\n}\n```", "```py\n     while (it!= itend) { \n\n        // process each pixel ---------------------\n\n        // end of pixel processing ----------------\n\n        ++it;\n     }\n```", "```py\n     cv::MatConstIterator_<cv::Vec3b> it;\n```", "```py\n     cv::Mat_<cv::Vec3b>::const_iterator it;\n```", "```py\n     cv::Mat_<cv::Vec3b> cimage(image);\n     cv::Mat_<cv::Vec3b>::iterator it= cimage.begin();\n     cv::Mat_<cv::Vec3b>::iterator itend= cimage.end();\n```", "```py\nconst int64 start = cv::getTickCount();\ncolorReduce(image); // a function call\n// elapsed time in seconds\ndouble duration = (cv::getTickCount()-start)/\n                               cv::getTickFrequency();\n```", "```py\n int nc= image.cols * image.channels();\n uchar div2= div>>1; \n\n for (int i=0; i<nc; i++) {\n```", "```py\n for (int i=0; i<image.cols * image.channels(); i++) {\n // . . .\n *data++ += div>>1;\n```", "```py\nfor (int j=0; j<nl; j++) {\n  for (int i=0; i<nc; i++) {\n\n    // process each pixel ---------------------\n\n    image.at<cv::Vec3b>(j,i)[0]=\n               image.at<cv::Vec3b>(j,i)[0]/div*div + div/2;\n    image.at<cv::Vec3b>(j,i)[1]=    \n              image.at<cv::Vec3b>(j,i)[1]/div*div + div/2;\n    image.at<cv::Vec3b>(j,i)[2]=    \n              image.at<cv::Vec3b>(j,i)[2]/div*div + div/2;\n\n    // end of pixel processing ----------------\n\n  } // end of line\n}\n```", "```py\nsharpened_pixel= 5*current-left-right-up-down;\n```", "```py\nvoid sharpen(const cv::Mat &image, cv::Mat &result) {\n\n   // allocate if necessary\n  result.create(image.size(), image.type()); \n  int nchannels= image.channels(); // get number of channels\n\n   // for all rows (except first and last)\n  for (int j= 1; j<image.rows-1; j++) { \n\n    const uchar* previous= \n        image.ptr<const uchar>(j-1);     // previous row\n    const uchar* current= \n        image.ptr<const uchar>(j);       // current row\n    const uchar* next= \n        image.ptr<const uchar>(j+1);     // next row\n\n    uchar* output= result.ptr<uchar>(j); // output row\n\n    for (int i=nchannels; i<(image.cols-1)*nchannels; i++) {\n\n       *output++= cv::saturate_cast<uchar>(\n                  5*current[i]-current[i-nchannels]-\n                  current[i+nchannels]-previous[i]-next[i]); \n    }\n  }\n\n  // Set the unprocessed pixels to 0\n  result.row(0).setTo(cv::Scalar(0));\n  result.row(result.rows-1).setTo(cv::Scalar(0));\n  result.col(0).setTo(cv::Scalar(0));\n  result.col(result.cols-1).setTo(cv::Scalar(0));\n}\n```", "```py\n   result.row(0).setTo(cv::Scalar(0));\n```", "```py\nvoid sharpen2D(const cv::Mat &image, cv::Mat &result) {\n\n   // Construct kernel (all entries initialized to 0)\n   cv::Mat kernel(3,3,CV_32F,cv::Scalar(0));\n   // assigns kernel values\n   kernel.at<float>(1,1)= 5.0;\n   kernel.at<float>(0,1)= -1.0;\n   kernel.at<float>(2,1)= -1.0;\n   kernel.at<float>(1,0)= -1.0;\n   kernel.at<float>(1,2)= -1.0;\n\n   //filter the image\n   cv::filter2D(image,result,image.depth(),kernel);\n}\n```", "```py\n   cv::addWeighted(image1,0.7,image2,0.9,0.,result);\n```", "```py\n   // c[i]= a[i]+b[i];\n   cv::add(imageA,imageB,resultC); \n   // c[i]= a[i]+k;\n   cv::add(imageA,cv::Scalar(k),resultC); \n   // c[i]= k1*a[1]+k2*b[i]+k3; \n   cv::addWeighted(imageA,k1,imageB,k2,k3,resultC);\n   // c[i]= k*a[1]+b[i]; \n   cv::scaleAdd(imageA,k,imageB,resultC);\n```", "```py\n   // if (mask[i]) c[i]= a[i]+b[i];\n   cv::add(imageA,imageB,resultC,mask);\n```", "```py\nresult= 0.7*image1+0.9*image2;\n```", "```py\n     image=(image&cv::Scalar(mask,mask,mask))\n                  +cv::Scalar(div/2,div/2,div/2);\n```", "```py\n   // create vector of 3 images\n   std::vector<cv::Mat> planes;\n   // split 1 3-channel image into 3 1-channel images\n   cv::split(image1,planes);\n   // add to blue channel\n   planes[0]+= image2;\n   // merge the 3 1-channel images into 1 3-channel image\n   cv::merge(planes,result);\n```", "```py\n// remapping an image by creating wave effects\nvoid wave(const cv::Mat &image, cv::Mat &result) {\n\n  // the map functions\n  cv::Mat srcX(image.rows,image.cols,CV_32F);\n  cv::Mat srcY(image.rows,image.cols,CV_32F);\n\n  // creating the mapping\n  for (int i=0; i<image.rows; i++) {\n    for (int j=0; j<image.cols; j++) {\n\n      // new location of pixel at (i,j)\n      srcX.at<float>(i,j)= j; // remain on same column\n                // pixels originally on row i are now\n                // moved following a sinusoid\n      srcY.at<float>(i,j)= i+5*sin(j/10.0);\n    }\n  }\n\n  // applying the mapping\n  cv::remap(image, result, srcX, srcY, cv::INTER_LINEAR);\n}\n```", "```py\n  // the map functions\n  cv::Mat srcX(image.rows,image.cols,CV_32F); // x-map\n  cv::Mat srcY(image.rows,image.cols,CV_32F); // y-map\n```", "```py\n  ( srcX.at<float>(i,j) , srcY.at<float>(i,j) )\n```", "```py\n  // creating the mapping\n  for (int i=0; i<image.rows; i++) {\n    for (int j=0; j<image.cols; j++) {\n\n      // horizontal flipping\n      srcX.at<float>(i,j)= image.cols-j-1;\n      srcY.at<float>(i,j)= i;\n    }\n  }\n```", "```py\n  // applying the mapping\n  cv::remap(image,             // source image\n            result,            // destination image\n            srcX,              // x map\n            srcY,              // y map\n            cv::INTER_LINEAR); // interpolation method\n```"]