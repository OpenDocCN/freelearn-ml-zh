<html><head></head><body>
  <div class="Basic-Text-Frame" id="_idContainer370">
    <h1 class="chapterNumber">7</h1>
    <h1 class="chapterTitle" id="_idParaDest-166">Black-Box Methods – Neural Networks and Support Vector Machines</h1>
    <p class="normal">The late science fiction author Arthur C. Clarke wrote, “Any sufficiently advanced technology is indistinguishable from magic.” This chapter covers a pair of machine learning methods that may appear at first glance to be magic. Though they are extremely powerful, their inner workings can be difficult to understand.</p>
    <p class="normal">In engineering, these are referred to as black-box processes because the mechanism that transforms the input into the output is obfuscated by an imaginary box. For instance, the black box of closed-source software intentionally conceals proprietary algorithms, the black box of political lawmaking is rooted in bureaucratic processes, and the black box of sausage-making involves a bit of purposeful (but tasty) ignorance. In the case of machine learning, the black box is due to the complex mathematics allowing them to function.</p>
    <p class="normal">Although they may not be easy to understand, it is dangerous to apply black-box models blindly. Thus, in this chapter, we’ll peek inside the box and investigate the statistical sausage-making involved in fitting such models. You’ll discover how:</p>
    <ul>
      <li class="bulletList">Neural networks mimic living brains to model mathematic functions</li>
      <li class="bulletList">Support vector machines use multidimensional surfaces to define the relationship between features and outcomes</li>
      <li class="bulletList">Despite their complexity, these can be applied easily to real-world problems</li>
    </ul>
    <p class="normal">With any luck, you’ll realize that you don’t need a black belt in statistics to tackle black-box machine learning methods—there’s no need to be intimidated!</p>
    <h1 class="heading-1" id="_idParaDest-167">Understanding neural networks</h1>
    <p class="normal">An <strong class="keyWord">artificial neural network</strong> (<strong class="keyWord">ANN</strong>) models<a id="_idIndexMarker790"/> the relationship between<a id="_idIndexMarker791"/> a set of input signals and an output signal using a model derived from our understanding of how a biological brain responds to stimuli from sensory inputs. Just like a brain uses a network of interconnected cells <a id="_idIndexMarker792"/>called <strong class="keyWord">neurons</strong> to provide vast learning capability, an ANN uses a network of<a id="_idIndexMarker793"/> artificial neurons or <strong class="keyWord">nodes</strong> to solve challenging learning problems.</p>
    <p class="normal">The human brain is made up of about 85 billion neurons, resulting in a network capable of representing a tremendous amount of knowledge. As you might expect, this dwarfs the brains of other living creatures. For instance, a cat has roughly a billion neurons, a mouse has about 75 million neurons, and a cockroach has only about 1 million neurons. In contrast, many ANNs contain far fewer neurons, typically only hundreds or thousands, so we’re in no danger of creating an artificial brain in the near future—even a fruit fly with 100,000 neurons far exceeds a state-of-the-art ANN on standard computing hardware. Some of the largest ANNs ever designed run on clusters of tens of thousands of CPU cores and have millions of nodes, but these are still dwarfed by the brains of small animals, let alone human beings—and the biological brains fit inside a much smaller package!</p>
    <p class="normal">Though it may be infeasible to completely model a cockroach’s brain, a neural network may still provide an adequate heuristic model of certain behaviors. Suppose that we develop an algorithm that can mimic how a roach flees when discovered. If the behavior of the robot roach is convincing, does it matter whether its brain is as sophisticated as the living creature? Similarly, if the written text produced by neural <a id="_idIndexMarker794"/>network-based tools like ChatGPT (<a href="https://openai.com/blog/chatgpt/"><span class="url">https://openai.com/blog/chatgpt/</span></a>) can pass for human-produced text most of the time, does it matter if the neural network isn’t a perfect model of a human brain? This question is at the heart of the<a id="_idIndexMarker795"/> controversial <strong class="keyWord">Turing test</strong>, proposed in 1950 by the pioneering computer scientist Alan Turing, which grades a machine as intelligent if a human being cannot distinguish its behavior from a living creature’s.</p>
    <div class="note">
      <p class="normal">For more about the intrigue and controversy that surrounds the <a id="_idIndexMarker796"/>Turing test, refer to the <em class="italic">Stanford Encyclopedia of Philosophy</em>: <a href="https://plato.stanford.edu/entries/turing-test/"><span class="url">https://plato.stanford.edu/entries/turing-test/</span></a>.</p>
    </div>
    <p class="normal">Rudimentary<a id="_idIndexMarker797"/> ANNs have been used for over 60 years to simulate the brain’s approach to problem-solving. At first, this involved learning simple functions like the logical AND function or the logical OR function. These early exercises were used primarily to help scientists understand how biological brains might operate. However, as computers have become increasingly powerful in recent years, the complexity of ANNs has likewise increased so much that they are now frequently applied to more practical problems, including:</p>
    <ul>
      <li class="bulletList">Speech, handwriting, and image recognition programs like those used by smartphone applications, mail-sorting machines, and search engines</li>
      <li class="bulletList">The automation of smart devices, such as an office building’s environmental controls, or the control of self-driving cars and self-piloting drones</li>
      <li class="bulletList">Sophisticated models of weather and climate patterns, tensile strength, fluid dynamics, and many other scientific, social, or economic phenomena</li>
    </ul>
    <p class="normal">Broadly speaking, ANNs are versatile learners that can be applied to nearly any learning task: classification, numeric prediction, and even unsupervised pattern recognition.</p>
    <div class="packt_tip">
      <p class="normal">Whether deserving or not, ANN learners are often reported in the media with great fanfare. For instance, an “artificial brain” developed by Google was touted for its ability to identify cat videos on YouTube. Such hype may have less to do with anything unique to ANNs and more to do with the fact that ANNs are captivating because of their similarities to living minds.</p>
    </div>
    <p class="normal">ANNs are often applied to problems where the input data and output data are well defined, yet the process that relates the input to the output is extremely complex and hard to define. As a black-box method, ANNs work well for these types of black-box problems.</p>
    <h2 class="heading-2" id="_idParaDest-168">From biological to artificial neurons</h2>
    <p class="normal">Because ANNs were intentionally <a id="_idIndexMarker798"/>designed as conceptual models of human brain activity, it is helpful to first understand how biological neurons function. As illustrated in the following figure, incoming signals are received by the cell’s <strong class="keyWord">dendrites</strong> through<a id="_idIndexMarker799"/> a biochemical process. The process allows the impulse to be weighted according to its relative importance or frequency. As the <strong class="keyWord">cell body</strong> begins <a id="_idIndexMarker800"/>to accumulate the incoming signals, a threshold is reached at which the cell fires, and the output signal is transmitted via an electrochemical process down the axon. At the axon’s terminals, the electric signal is again processed as a chemical signal to be passed to the neighboring neurons across a tiny gap known<a id="_idIndexMarker801"/> as a <strong class="keyWord">synapse</strong>.</p>
    <figure class="mediaobject"><img alt="Diagram  Description automatically generated" src="../Images/B17290_07_01.png"/></figure>
    <p class="packt_figref">Figure 7.1: An artistic depiction of a biological neuron</p>
    <p class="normal">The model of a <a id="_idIndexMarker802"/>single<a id="_idIndexMarker803"/> artificial neuron can be understood in terms very similar to the biological model. As depicted in the following figure, a directed network diagram defines a relationship between the input signals received by the dendrites (<em class="italic">x</em> variables) and the output signal (<em class="italic">y</em> variable). Just as with the biological neuron, each dendrite’s signal is weighted (<em class="italic">w</em> values) according to its importance—ignore, for now, how these weights are determined. The input signals are summed by the cell body and the signal is passed on according to an <strong class="keyWord">activation function</strong> denoted by <em class="italic">f</em>.</p>
    <figure class="mediaobject"><img alt="Diagram  Description automatically generated" src="../Images/B17290_07_02.png"/></figure>
    <p class="packt_figref">Figure 7.2: An artificial neuron is designed to mimic the structure and function of a biological neuron</p>
    <p class="normal">A typical <a id="_idIndexMarker804"/>artificial neuron<a id="_idIndexMarker805"/> with <em class="italic">n</em> input dendrites can be represented by the formula that follows. The <em class="italic">w</em> weights allow each of the <em class="italic">n</em> inputs (denoted by <em class="italic">x</em><sub class="subscript-italic" style="font-style: italic;">i</sub>) to contribute a greater or lesser amount to the sum of input signals. The net total is used by the activation function <em class="italic">f(x)</em> and the resulting signal, <em class="italic">y(x)</em>, is the output axon:</p>
    <p class="center"><img alt="" src="../Images/B17290_07_001.png"/></p>
    <p class="normal">Neural networks use neurons defined in this way as building blocks to construct complex models of data. Although there are numerous variants of neural networks, each can be defined in terms <a id="_idIndexMarker806"/>of the following characteristics:</p>
    <ul>
      <li class="bulletList">An <strong class="keyWord">activation function</strong>, which<a id="_idIndexMarker807"/> transforms a neuron’s net input signal into a single output signal to be broadcasted further in the network</li>
      <li class="bulletList">A <strong class="keyWord">network topology</strong> (or architecture), which <a id="_idIndexMarker808"/>describes the number of neurons in the model, as well as the number of layers and the manner in which they are connected</li>
      <li class="bulletList">The <strong class="keyWord">training algorithm</strong>, which<a id="_idIndexMarker809"/> specifies how connection weights are set to inhibit or excite neurons in proportion to the input signal</li>
    </ul>
    <p class="normal">Let’s take a look at some of the variations within each of these categories to see how they can be used to construct typical neural network models.</p>
    <h2 class="heading-2" id="_idParaDest-169">Activation functions</h2>
    <p class="normal">The <strong class="keyWord">activation function</strong> is <a id="_idIndexMarker810"/>the mechanism by which the<a id="_idIndexMarker811"/> artificial neuron processes incoming information and determines whether to pass the signal to other neurons in the network. Just as an artificial neuron is modeled after the biological version, so too is the activation function modeled after nature’s design.</p>
    <p class="normal">In the biological case, the activation function could be imagined as a process that involves summing the total input signal and determining whether it meets the firing threshold. If so, the neuron passes on the signal; otherwise, it does nothing. In ANN terms, this is known as<a id="_idIndexMarker812"/> a <strong class="keyWord">threshold activation function</strong>, as it results <a id="_idIndexMarker813"/>in an output signal only once a specified input threshold has been attained.</p>
    <p class="normal">The following figure depicts a typical threshold function; in this case, the neuron fires when the sum of input signals is at least zero. Because its shape resembles a stair, it is sometimes <a id="_idIndexMarker814"/>called<a id="_idIndexMarker815"/> a <strong class="keyWord">unit step activation function</strong>.</p>
    <figure class="mediaobject"><img alt="Chart, histogram  Description automatically generated" src="../Images/B17290_07_03.png"/></figure>
    <p class="packt_figref">Figure 7.3: The threshold activation function is “on” only after the input signals meet a threshold</p>
    <p class="normal">Although the threshold activation function is interesting due to its parallels with biology, it is rarely used in ANNs. Freed from the limitations of biochemistry, ANN activation functions can be chosen based on their ability to demonstrate desirable mathematical characteristics and their ability to accurately model relationships among data.</p>
    <p class="normal">Perhaps the most <a id="_idIndexMarker816"/>common alternative is <a id="_idIndexMarker817"/>the <strong class="keyWord">sigmoid activation function</strong> (more specifically the <em class="italic">logistic</em> sigmoid) shown in the following figure. Note that in the formula shown, <em class="italic">e</em> is the base of the natural logarithm (a value of approximately 2.72). Although it shares a similar step or “S” shape with the threshold activation function, the output signal is no longer binary; output values can fall anywhere in the range from zero to one. Additionally, the sigmoid is <strong class="keyWord">differentiable</strong>, which means that it is possible to calculate the derivative (the slope of the tangent line for a point on the curve) across the entire range of inputs. As you will learn later, this feature is crucial for creating efficient ANN optimization algorithms.</p>
    <figure class="mediaobject"><img alt="Chart  Description automatically generated" src="../Images/B17290_07_04.png"/></figure>
    <p class="packt_figref">Figure 7.4: The sigmoid activation function uses a smooth curve to mimic the unit step activation function found in nature</p>
    <p class="normal">Although the sigmoid is perhaps the most commonly used activation function and is often used by default, some neural network algorithms allow a choice of alternatives. A selection of such activation functions is shown in <em class="italic">Figure 7.5</em>:</p>
    <figure class="mediaobject"><img alt="Chart, line chart  Description automatically generated" src="../Images/B17290_07_05.png"/></figure>
    <p class="packt_figref">Figure 7.5: Several common neural network activation functions</p>
    <p class="normal">The primary detail that differentiates these activation functions is the output signal range. Typically, this is one of (0, 1), (-1, +1), or (-inf, +inf). The choice of activation function biases the neural network such that it may fit certain types of data more appropriately, allowing the construction of specialized neural networks. For<a id="_idIndexMarker818"/> instance, a linear activation function <a id="_idIndexMarker819"/>results in a neural network very similar to a linear regression model, while a <a id="_idIndexMarker820"/>Gaussian activation function is<a id="_idIndexMarker821"/> the basis of a <strong class="keyWord">radial basis function</strong> (<strong class="keyWord">RBF</strong>) network. Each of <a id="_idIndexMarker822"/>these has strengths better suited for certain learning tasks and not others.</p>
    <div class="packt_tip">
      <p class="normal">Neural networks use nonlinear activation functions almost exclusively since this is what allows the network to become more intelligent as more nodes are added. Limited to linear activation functions only, a network is limited to linear solutions and will perform no better than the much simpler regression methods.</p>
    </div>
    <p class="normal">It’s important to recognize that for many of the activation functions, the range of input values that affect the output signal is relatively narrow. For example, in the case of the sigmoid, the output signal is very near 0 for an input signal below -5 and very near 1 for an input signal above 5. The compression of the signal in this way results in a saturated signal at the high and low ends of very dynamic inputs, just as turning a guitar amplifier up too high results in a distorted sound due to clipping of the peaks of sound waves. Because this essentially squeezes the input values into a smaller range of outputs, activation functions like the sigmoid are sometimes<a id="_idIndexMarker823"/> called <strong class="keyWord">squashing functions</strong>.</p>
    <p class="normal">One solution to the squashing problem is to transform all neural network inputs such that the feature values fall within a small range around zero. This may involve standardizing or normalizing the features. By restricting the range of input values, the activation function will be able to work across the entire range. A side benefit is that the model may also be faster to train since the algorithm can iterate more quickly through the actionable range of input values.</p>
    <div class="packt_tip">
      <p class="normal">Although theoretically, a neural network can adapt to a very dynamic feature by adjusting its weight over many iterations, in extreme cases, many algorithms will stop iterating long before this occurs. If your model is failing to converge, double-check that you’ve correctly standardized the input data. Choosing a different activation function may also be appropriate.</p>
    </div>
    <h2 class="heading-2" id="_idParaDest-170">Network topology</h2>
    <p class="normal">The capacity <a id="_idIndexMarker824"/>of a neural network to learn is rooted in its <a id="_idIndexMarker825"/>topology, or the patterns and structures of interconnected neurons. Although there are countless forms of network architecture, they can be differentiated by three key<a id="_idIndexMarker826"/> characteristics:</p>
    <ul>
      <li class="bulletList">The number of layers</li>
      <li class="bulletList">Whether information in the network is allowed to travel backward</li>
      <li class="bulletList">The number of nodes within each layer of the network</li>
    </ul>
    <p class="normal">The topology determines the complexity of tasks that can be learned by the network. Generally, larger and more complex networks can identify more subtle patterns and more complex decision boundaries. However, the power of a network is not only a function of the network size but also the way units are arranged.</p>
    <h3 class="heading-3" id="_idParaDest-171">The number of layers</h3>
    <p class="normal">To <a id="_idIndexMarker827"/>define topology, we need terminology that distinguishes artificial neurons based on their position in the network. <em class="italic">Figure 7.6</em> illustrates the topology of a very simple network. A set of <a id="_idIndexMarker828"/>neurons called <strong class="keyWord">input nodes</strong> receives unprocessed signals directly from the input data. Each input node is responsible for processing a single feature in the dataset; the feature’s value will be transformed by the corresponding node’s activation function. The signals sent by the input nodes are received by<a id="_idIndexMarker829"/> the <strong class="keyWord">output node</strong>, which uses its own activation function to generate a final prediction (denoted here as <em class="italic">p</em>).</p>
    <p class="normal">The input and output nodes are arranged in groups <a id="_idIndexMarker830"/>known as <strong class="keyWord">layers</strong>. Because the input nodes process the incoming data exactly as received, the network has only one set of connection weights (labeled here as <em class="italic">w</em><sub class="subscript">1</sub>, <em class="italic">w</em><sub class="subscript">2</sub>, and <em class="italic">w</em><sub class="subscript">3</sub>). It is therefore<a id="_idIndexMarker831"/> termed a <strong class="keyWord">single-layer network</strong>. Single-layer networks can be used for basic pattern classification, particularly for patterns that are linearly separable, but more sophisticated networks are required for most learning tasks.</p>
    <figure class="mediaobject"><img alt="Diagram  Description automatically generated" src="../Images/B17290_07_06.png"/></figure>
    <p class="packt_figref">Figure 7.6: A simple single-layer ANN with three input nodes</p>
    <p class="normal">As you might expect, an obvious way to create more complex networks is by adding additional layers. As depicted in <em class="italic">Figure 7.7</em>, a <strong class="keyWord">multilayer network</strong> adds<a id="_idIndexMarker832"/> one or more <strong class="keyWord">hidden layers</strong> that <a id="_idIndexMarker833"/>process the signals from the input nodes prior to reaching the output node. Hidden nodes get their name from the fact that they are obscured in the heart of the network and their relationship to the data and output is much more difficult to understand. The hidden layers are what make ANNs a black-box model; knowing what is happening<a id="_idIndexMarker834"/> inside these layers is practically impossible, particularly as the topology becomes more complicated.</p>
    <figure class="mediaobject"><img alt="Diagram  Description automatically generated" src="../Images/B17290_07_07.png"/></figure>
    <p class="packt_figref">Figure 7.7: A multilayer network with a single two-node hidden layer</p>
    <p class="normal">Examples of more complex topologies are depicted in <em class="italic">Figure 7.8</em>. Multiple output nodes can be used to represent outcomes with multiple categories. Multiple hidden layers can be used to allow even more complexity inside the black box, and thus model more challenging problems.</p>
    <figure class="mediaobject"><img alt="A picture containing text, scissors, tool  Description automatically generated" src="../Images/B17290_07_08.png"/></figure>
    <p class="packt_figref">Figure 7.8: Complex ANNs can have multiple output nodes or multiple hidden layers</p>
    <p class="normal">A neural network with multiple hidden layers is called a <strong class="keyWord">deep neural network</strong> (<strong class="keyWord">DNN</strong>), and the practice of <a id="_idIndexMarker835"/>training such networks is referred to<a id="_idIndexMarker836"/> as <strong class="keyWord">deep learning</strong>. DNNs trained on large datasets are capable of human-like performance on complex tasks like image recognition and text processing. Deep learning has thus been hyped as the next big leap in machine learning, but deep learning is better suited to some tasks than others.</p>
    <p class="normal">Though<a id="_idIndexMarker837"/> deep learning performs quite well on complex learning tasks that conventional models tend to struggle with, it requires much larger datasets with much richer feature sets than found in most projects. Typical learning tasks include modeling unstructured data like images, audio, or text, as well as outcomes measured repeatedly over time, such as stock market prices or energy consumption. Building DNNs on these types of data requires specialized computing software (and sometimes also hardware) that is more challenging to use than a simple R package. <em class="chapterRef">Chapter 15</em>, <em class="italic">Making Use of Big Data</em>, provides details on how to use these tools to perform deep learning and image recognition in R.</p>
    <h3 class="heading-3" id="_idParaDest-172">The direction of information travel</h3>
    <p class="normal">Simple multilayer <a id="_idIndexMarker838"/>networks are usually <strong class="keyWord">fully connected</strong>, which means that every node in one layer is connected to every node in the next layer, but this is not required. Much larger deep learning models, such as the <strong class="keyWord">convolutional neural network</strong> (<strong class="keyWord">CNN</strong>) for<a id="_idIndexMarker839"/> image recognition that will be introduced in <em class="chapterRef">Chapter 15</em>, <em class="italic">Making Use of Big Data</em>, are only partially connected. Removing some connections helps limit the amount of overfitting that can occur inside the numerous hidden layers. However, this is not the only way we can manipulate the topology. In addition to whether nodes are connected at all, we can also dictate the direction of information flow throughout the connections and produce neural networks suited to different types of learning tasks.</p>
    <p class="normal">You may have noticed that in the prior examples, arrowheads were used to indicate signals traveling in only one direction. Networks in which the input signal is fed continuously in one direction from the input layer to the output layer are called <strong class="keyWord">feedforward networks</strong>. Despite <a id="_idIndexMarker840"/>the restriction on information flow, feedforward networks offer a surprising amount of flexibility. </p>
    <p class="normal">For instance, the number of levels and nodes at each level can be varied, multiple outcomes can be modeled simultaneously, or multiple hidden layers can be applied.</p>
    <p class="normal">In contrast to feedforward <a id="_idIndexMarker841"/>networks, a <strong class="keyWord">recurrent neural network</strong> (<strong class="keyWord">RNN</strong>) (or <strong class="keyWord">feedback network</strong>) allows<a id="_idIndexMarker842"/> signals to travel backward using loops. This property, which more closely mirrors how a biological neural network works, allows extremely complex patterns to be learned. The addition of a short-term memory, or <strong class="keyWord">delay</strong>, increases the power of recurrent networks immensely. Notably, this includes the capability to understand sequences of events over time. This could be used for stock market prediction, speech comprehension, or weather forecasting. A simple recurrent network is depicted as follows:</p>
    <figure class="mediaobject"><img alt="Diagram  Description automatically generated" src="../Images/B17290_07_09.png"/></figure>
    <p class="packt_figref">Figure 7.9: Allowing information to travel backward in the network can model a time delay</p>
    <p class="normal">As the <a id="_idIndexMarker843"/>short-term memory of an RNN is, unsurprisingly, short by definition, one form of RNN known as <strong class="keyWord">long short-term memory</strong> (<strong class="keyWord">LSTM</strong>) adapts <a id="_idIndexMarker844"/>the model to have substantially longer recall—much like living creatures that have both short- and long-term memory. While this may seem to be an obvious enhancement, computers have perfect memory and thus need to be explicitly told when to forget and when to remember. The challenge was striking a balance between forgetting too soon and remembering for too long, which is easier said than done because the mathematical functions used to train the model are naturally pulled toward either of these extremes for reasons that will become clearer as you continue in this chapter.</p>
    <div class="note">
      <p class="normal">For more information about LSTM neural networks, see <em class="italic">Understanding LSTM—a tutorial into Long Short-Term Memory Recurrent Neural Networks, Staudemeyer RC and Morris ER, 2019</em>. <a href="https://arxiv.org/abs/1909.09586"><span class="url">https://arxiv.org/abs/1909.09586</span></a>.</p>
    </div>
    <p class="normal">The development of LSTM neural networks <a id="_idIndexMarker845"/>has led to advances in artificial intelligence such as the ability for robots to mimic sequences of human behaviors necessary for controlling machinery, driving, and playing video games. The LSTM model also shows aptitude for speech and text recognition, understanding language semantics and translating between languages, and learning complex strategies. DNNs and recurrent networks are increasingly being used for a variety of high-profile applications and consequently have become much more popular since the first edition of this book was published. However, building such networks uses techniques and software outside the scope of this book, and often requires access to specialized computing hardware or cloud servers.</p>
    <p class="normal">On the other hand, simpler<a id="_idIndexMarker846"/> feedforward networks are also very capable of modeling many real-world tasks, though the tasks may not be quite as exciting as autonomous vehicles and computers playing video games. While deep learning is quickly becoming the status quo, the multilayer feedforward network, also known as<a id="_idIndexMarker847"/> the <strong class="keyWord">multilayer perceptron</strong> (<strong class="keyWord">MLP</strong>), may still be the de facto standard ANN topology for conventional learning tasks. Furthermore, understanding the MLP topology provides a strong theoretical basis for building more complex deep learning models later.</p>
    <h3 class="heading-3" id="_idParaDest-173">The number of nodes in each layer</h3>
    <p class="normal">In addition<a id="_idIndexMarker848"/> to variations in the number of layers and the direction of information travel, neural networks can also vary in complexity by the number of nodes in each layer. The number of input nodes is predetermined by the number of features in the input data. Similarly, the number of output nodes is predetermined by the number of outcomes to be modeled or the number of class levels in the outcome. However, the number of hidden nodes is left to the user to decide prior to training the model.</p>
    <p class="normal">Unfortunately, there is no reliable rule for determining the number of neurons in the hidden layer. The appropriate number depends on the number of input nodes, the amount of training data, the amount of noisy data, and the complexity of the learning task, among many other factors.</p>
    <p class="normal">In general, more complex network topologies with a greater number of network connections allow the learning of more complex problems. A greater number of neurons will result in a model that more closely mirrors the training data, but this runs a risk of overfitting; it may generalize poorly to future data. Large neural networks can also be computationally expensive and slow to train. The best practice is to use the fewest nodes that result in adequate performance on a validation dataset. In most cases, even with only a small number of hidden nodes—often as few as a handful—the neural network can demonstrate a tremendous ability to learn.</p>
    <p class="normal">It has been proven that a neural network with at least one hidden layer of sufficiently many neurons with nonlinear activation functions<a id="_idIndexMarker849"/> is a <strong class="keyWord">universal function approximator</strong>. This means that neural networks can be used to approximate any continuous function to an arbitrary level of precision over a finite interval. This is where a neural network gains the ability to perform the type of “magic” described in the chapter introduction; put a set of inputs into the black box of a neural network and it can learn to produce any set of outputs, no matter how complex the relationships are between the inputs and outputs. Of <a id="_idIndexMarker850"/>course, this assumes “sufficiently many neurons” as well as enough data to reasonably train the network—all while avoiding overfitting to noise so that the approximation will generalize beyond the training examples. We’ll peek further into the black box that allows this magic to happen in the next section.</p>
    <div class="note">
      <p class="normal">To see a real-time visualization of how changes to network topology allow neural networks to <a id="_idIndexMarker851"/>become a universal function approximator, visit the Deep Learning Playground at <a href="http://playground.tensorflow.org/"><span class="url">http://playground.tensorflow.org/</span></a>. The playground allows you to experiment with predictive models where the relationship between the features and target is complex and nonlinear. While methods like regression and decision trees would struggle to find any solution to these problems, you will find that adding more hidden nodes and layers allows the network to come up with a reasonable approximation for each of the examples given enough training time. Note, especially, that choosing the linear activation function rather than a sigmoid or hyperbolic tangent (tanh) prevents the network from learning a reasonable solution regardless of the complexity of the network topology.</p>
    </div>
    <h2 class="heading-2" id="_idParaDest-174">Training neural networks with backpropagation</h2>
    <p class="normal">The <a id="_idIndexMarker852"/>network topology is a blank slate that by itself has not learned anything. Like a newborn child, it must be trained with experience. As the neural network processes the input data, connections between the neurons are strengthened or weakened, similar to how a baby’s brain develops as they experience the environment. The network’s connection weights are adjusted to reflect the patterns observed over time.</p>
    <p class="normal">Training a neural network by adjusting connection weights is very computationally intensive. Consequently, though they had been studied for decades prior, ANNs were rarely applied to real-world learning tasks until the mid-to-late 1980s, when an efficient method of training an ANN was discovered. The algorithm, which used a strategy of back-propagating errors, is now known <a id="_idIndexMarker853"/>simply as <strong class="keyWord">backpropagation</strong>.</p>
    <div class="note">
      <p class="normal">Coincidentally, several research teams independently discovered and published the backpropagation algorithm around the same time. Among them, perhaps the most often cited work is <em class="italic">Learning representations by back-propagating errors, Rumelhart, DE, Hinton, GE, Williams, RJ, Nature, 1986, Vol. 323, pp. 533-566</em>.</p>
    </div>
    <p class="normal">Although still somewhat computationally expensive relative to many other machine learning algorithms, the backpropagation method led to a resurgence of interest in ANNs. As a result, multilayer feedforward networks that use the backpropagation algorithm are now common in the field of data mining. Such models offer the following strengths and weaknesses:</p>
    <table class="table-container" id="table001-5">
      <tbody>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Strengths</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Weaknesses</strong></p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <ul>
              <li class="bulletList">Can be adapted to classification or numeric prediction problems</li>
              <li class="bulletList">A “universal approximator” capable of modeling more complex patterns than nearly any algorithm</li>
              <li class="bulletList">Makes few assumptions about the data’s underlying relationships</li>
            </ul>
          </td>
          <td class="table-cell">
            <ul>
              <li class="bulletList">Extremely computationally intensive and slow to train, particularly if the network topology is complex</li>
              <li class="bulletList">Very prone to overfitting training data, leading to poor generalization</li>
              <li class="bulletList">Results in a complex black-box model that is difficult, if not impossible, to interpret</li>
            </ul>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="normal">In its most general form, the backpropagation algorithm iterates through many cycles of two processes. Each cycle is known as an <strong class="keyWord">epoch</strong>. Because<a id="_idIndexMarker854"/> the network contains no <em class="italic">a priori</em> (existing) knowledge, the starting weights are typically set at random. Then, the algorithm iterates through the processes until a stopping criterion is reached. Each <a id="_idIndexMarker855"/>epoch in the backpropagation algorithm includes:</p>
    <ul>
      <li class="bulletList">A <strong class="keyWord">forward phase</strong>, in <a id="_idIndexMarker856"/>which the neurons are activated in sequence from the input layer to the output layer, applying each neuron’s weights and activation function along the way. Upon reaching the final layer, an output signal is produced.</li>
      <li class="bulletList">A <strong class="keyWord">backward phase</strong>, in <a id="_idIndexMarker857"/>which the network’s output signal resulting from the forward phase is compared to the true target value in the training data. The difference between the network’s output signal and the true value results in an error that is propagated backward in the network to modify the connection weights between neurons and reduce future errors.</li>
    </ul>
    <p class="normal">Over time, the algorithm uses the information sent backward to reduce the total errors made by the network. Yet one question remains: because the relationship between each neuron’s inputs and outputs is complex, how does the algorithm determine how much a weight should be changed? </p>
    <p class="normal">The <a id="_idIndexMarker858"/>answer to this question involves a technique called <strong class="keyWord">gradient descent</strong>. Conceptually, this works similarly to how an explorer trapped in the jungle might find a path to water. By examining the terrain and continually walking in the direction with the greatest downward slope, the explorer will eventually reach the lowest valley, which is likely to be a riverbed.</p>
    <p class="normal">In a similar process, the backpropagation algorithm uses the derivative of each neuron’s activation function to identify the gradient in the direction of each of the incoming weights—hence the importance of having a differentiable activation function. The gradient suggests how steeply the error will be reduced or increased for a change in the weight. The algorithm will attempt to change the weights that result in the greatest reduction in error by an amount known as<a id="_idIndexMarker859"/> the <strong class="keyWord">learning rate</strong>. The greater the learning rate, the faster the algorithm will attempt to descend down the gradients, which could reduce the training time at the risk of overshooting the valley.</p>
    <figure class="mediaobject"><img alt="Diagram  Description automatically generated" src="../Images/B17290_07_10.png"/></figure>
    <p class="packt_figref">Figure 7.10: The gradient descent algorithm seeks the minimum error but may also find a local minimum</p>
    <p class="normal">Although the <a id="_idIndexMarker860"/>math needed to find the minimum error rate using gradient descent is complex and therefore outside the scope of this book, it is easy to apply in practice via its implementation in neural network algorithms in R. Let’s apply our understanding of multilayer feedforward networks to a real-world problem.</p>
    <h1 class="heading-1" id="_idParaDest-175">Example – modeling the strength of concrete with ANNs</h1>
    <p class="normal">In the <a id="_idIndexMarker861"/>field of engineering, it is crucial to have accurate estimates of the performance of building materials. These estimates are required in order to develop safety guidelines governing the materials used in the construction of buildings, bridges, and roadways.</p>
    <p class="normal">Estimating the <a id="_idIndexMarker862"/>strength of concrete is a challenge of particular interest. Although it is used in nearly every construction project, concrete performance varies greatly due to a wide variety of ingredients that interact in complex ways. As a result, it is difficult to accurately predict the strength of the final product. A model that could reliably predict concrete strength given a listing of the composition of the input materials could result in safer construction practices.</p>
    <h2 class="heading-2" id="_idParaDest-176">Step 1 – collecting data</h2>
    <p class="normal">For this analysis, we<a id="_idIndexMarker863"/> will utilize data on the compressive strength of concrete donated to the UCI Machine Learning Repository (<a href="http://archive.ics.uci.edu/ml"><span class="url">http://archive.ics.uci.edu/ml</span></a>) by I-Cheng Yeh. As he found success using neural networks to model this data, we will attempt to replicate Yeh’s work using a simple neural network model in R.</p>
    <div class="note">
      <p class="normal">For more information on Yeh’s approach to this learning task, refer to <em class="italic">Modeling of Strength of High-Performance Concrete Using Artificial Neural Networks, Yeh, IC, Cement and Concrete Research, 1998, Vol. 28, pp. 1797-1808</em>.</p>
    </div>
    <p class="normal">According to the website, the dataset contains 1,030 examples of concrete, with 8 features describing the components used in the mixture. These features are thought to be related to the final compressive strength and include the amount (in kilograms per cubic meter) of cement, slag, ash, water, superplasticizer, coarse aggregate, and fine aggregate used in the product, in addition to the aging time (measured in days).</p>
    <div class="packt_tip">
      <p class="normal">To follow along with this example, download the <code class="inlineCode">concrete.csv</code> file from the Packt Publishing website and save it to your R working directory.</p>
    </div>
    <h2 class="heading-2" id="_idParaDest-177">Step 2 – exploring and preparing the data</h2>
    <p class="normal">As usual, we’ll <a id="_idIndexMarker864"/>begin our analysis by loading the data into an R object using the <code class="inlineCode">read.csv()</code> function and confirming that it <a id="_idIndexMarker865"/>matches the expected structure:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-operator">&gt;</span> concrete <span class="hljs-operator">&lt;-</span> read.csv<span class="hljs-punctuation">(</span><span class="hljs-string">"</span><span class="hljs-string">concrete.csv"</span><span class="hljs-punctuation">)</span>
<span class="hljs-operator">&gt;</span> str<span class="hljs-punctuation">(</span>concrete<span class="hljs-punctuation">)</span>
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">'data.frame': 1030 obs. of  9 variables:
 $ cement      : num  141 169 250 266 155 ...
 $ slag        : num  212 42.2 0 114 183.4 ...
 $ ash         : num  0 124.3 95.7 0 0 ...
 $ water       : num  204 158 187 228 193 ...
 $ superplastic: num  0 10.8 5.5 0 9.1 0 0 6.4 0 9 ...
 $ coarseagg   : num  972 1081 957 932 1047 ...
 $ fineagg     : num  748 796 861 670 697 ...
 $ age         : int  28 14 28 28 28 90 7 56 28 28 ...
 $ strength    : num  29.9 23.5 29.2 45.9 18.3 ...
</code></pre>
    <p class="normal">The nine variables in the data frame correspond to the eight features and one outcome we expected, although a problem has become apparent. Neural networks work best when the input data is scaled to a narrow range around zero, and here we see values ranging anywhere from zero to over a thousand.</p>
    <p class="normal">Typically, the <a id="_idIndexMarker866"/>solution to this <a id="_idIndexMarker867"/>problem is to rescale the data with a normalizing or standardization function. If the data follows a bell-shaped curve (a normal distribution, as described in <em class="chapterRef">Chapter 2</em>, <em class="italic">Managing and Understanding Data</em>), then it may make sense to use standardization via R’s built-in <code class="inlineCode">scale()</code> function. On the other hand, if the data follows a uniform distribution or is severely non-normal, then normalization to a zero-to-one range may be more appropriate. In this case, we’ll use the latter.</p>
    <p class="normal">In <em class="chapterRef">Chapter 3</em>, <em class="italic">Lazy Learning – Classification Using Nearest Neighbors</em>, we defined our own <code class="inlineCode">normalize()</code> function as:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-operator">&gt;</span> normalize <span class="hljs-operator">&lt;-</span> <span class="hljs-keyword">function</span><span class="hljs-punctuation">(</span>x<span class="hljs-punctuation">)</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-built_in">return</span><span class="hljs-punctuation">((</span>x <span class="hljs-operator">-</span> <span class="hljs-built_in">min</span><span class="hljs-punctuation">(</span>x<span class="hljs-punctuation">))</span> <span class="hljs-operator">/</span> <span class="hljs-punctuation">(</span><span class="hljs-built_in">max</span><span class="hljs-punctuation">(</span>x<span class="hljs-punctuation">)</span> <span class="hljs-operator">-</span> <span class="hljs-built_in">min</span><span class="hljs-punctuation">(</span>x<span class="hljs-punctuation">)))</span>
<span class="hljs-punctuation">}</span>
</code></pre>
    <p class="normal">After executing this code, our <code class="inlineCode">normalize()</code> function can be applied to every column in the concrete data frame using the <code class="inlineCode">lapply()</code> function as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-operator">&gt;</span> concrete_norm <span class="hljs-operator">&lt;-</span> as.data.frame<span class="hljs-punctuation">(</span>lapply<span class="hljs-punctuation">(</span>concrete<span class="hljs-punctuation">,</span> normalize<span class="hljs-punctuation">))</span>
</code></pre>
    <p class="normal">To confirm that the normalization worked, we can see that the minimum and maximum strength are now zero and one, respectively:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-operator">&gt;</span> summary<span class="hljs-punctuation">(</span>concrete_norm<span class="hljs-operator">$</span>strength<span class="hljs-punctuation">)</span>
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
 0.0000  0.2664  0.4001  0.4172  0.5457  1.0000
</code></pre>
    <p class="normal">In comparison, the original minimum and maximum values were 2.33 and 82.60:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-operator">&gt;</span> summary<span class="hljs-punctuation">(</span>concrete<span class="hljs-operator">$</span>strength<span class="hljs-punctuation">)</span>
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">   Min.  1st Qu.  Median    Mean   3rd Qu.    Max. 
   2.33   23.71    34.45   35.82    46.13     82.60
</code></pre>
    <div class="packt_tip">
      <p class="normal">Any transformation applied to the data prior to training the model must be applied in reverse to convert it back into the original units of measurement. To facilitate the rescaling, it is wise to save the original data, or at least the summary statistics of the original data.</p>
    </div>
    <p class="normal">Following Yeh’s <a id="_idIndexMarker868"/>precedent in <a id="_idIndexMarker869"/>the original publication, we will partition the data into a training set with 75 percent of the examples and a testing set with 25 percent. The CSV file we used was already sorted in random order, so we simply need to divide it into two portions:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-operator">&gt;</span> concrete_train <span class="hljs-operator">&lt;-</span> concrete_norm<span class="hljs-punctuation">[</span><span class="hljs-number">1</span><span class="hljs-operator">:</span><span class="hljs-number">773</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">]</span>
<span class="hljs-operator">&gt;</span> concrete_test <span class="hljs-operator">&lt;-</span> concrete_norm<span class="hljs-punctuation">[</span><span class="hljs-number">774</span><span class="hljs-operator">:</span><span class="hljs-number">1030</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">]</span>
</code></pre>
    <p class="normal">We’ll use the training dataset to build the neural network and the testing dataset to evaluate how well the model generalizes to future results. As it is easy to overfit a neural network, this step is very important.</p>
    <h2 class="heading-2" id="_idParaDest-178">Step 3 – training a model on the data</h2>
    <p class="normal">To model the <a id="_idIndexMarker870"/>relationship between the ingredients used in concrete and the strength of the finished product, we will use a multilayer feedforward neural network. The <code class="inlineCode">neuralnet</code> package by Stefan Fritsch and Frauke Guenther provides a standard and easy-to-use implementation of such networks. It also offers a function to plot the network topology. For these reasons, the <code class="inlineCode">neuralnet</code> implementation is a strong choice for learning more about neural networks, though that’s not to say that it cannot be used to accomplish real work as well—it’s quite a powerful tool, as you will soon see.</p>
    <div class="packt_tip">
      <p class="normal">There are several other commonly used packages to train simple ANN models in R, each with unique strengths and weaknesses. Because it ships as part of the standard R installation, the <code class="inlineCode">nnet</code> package is perhaps the most frequently cited ANN implementation. It uses a slightly more sophisticated algorithm than standard backpropagation. Another option is the <code class="inlineCode">RSNNS</code> package, which offers a complete suite of neural network functionality, with the downside being that it is more difficult to learn. The specialized software for building or using deep learning neural networks is covered in <em class="chapterRef">Chapter 15</em>, <em class="italic">Making Use of Big Data</em>.</p>
    </div>
    <p class="normal">As <code class="inlineCode">neuralnet</code> is not included in base R, you will need to install it by typing <code class="inlineCode">install.packages</code><code class="inlineCode">("neuralnet")</code> and load it with the <code class="inlineCode">library(neuralnet)</code> command. The <a id="_idIndexMarker871"/>included <code class="inlineCode">neuralnet()</code> function can be used for training neural networks for numeric prediction using the following syntax:</p>
    <figure class="mediaobject"><img alt="Text, letter  Description automatically generated" src="../Images/B17290_07_11.png"/></figure>
    <p class="packt_figref">Figure 7.11: Neural network syntax</p>
    <p class="normal">We’ll begin by training the simplest multilayer feedforward network with the default settings using only a single hidden node. Because the process of training an ANN involves<a id="_idIndexMarker872"/> randomization, the <code class="inlineCode">set.seed()</code> function used here will ensure the same result is produced when the <code class="inlineCode">neuralnet()</code> function is run:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-operator">&gt;</span> set.seed<span class="hljs-punctuation">(</span><span class="hljs-number">12345</span><span class="hljs-punctuation">)</span>
<span class="hljs-operator">&gt;</span> concrete_model <span class="hljs-operator">&lt;-</span> neuralnet<span class="hljs-punctuation">(</span>strength <span class="hljs-operator">~</span> cement <span class="hljs-operator">+</span> slag +
  ash + water + superplastic + coarseagg + fineagg + age,
  data = concrete_train)
</code></pre>
    <p class="normal">We can then visualize the network topology using the <code class="inlineCode">plot()</code> function on the resulting model object:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-operator">&gt;</span> plot<span class="hljs-punctuation">(</span>concrete_model<span class="hljs-punctuation">)</span>
</code></pre>
    <figure class="mediaobject"><img alt="Diagram  Description automatically generated" src="../Images/B17290_07_12.png"/></figure>
    <p class="packt_figref">Figure 7.12: Topology visualization of a simple multilayer feedforward network</p>
    <p class="normal">In this simple model, there is one input node for each of the eight features, followed by a single hidden node and a single output node that predicts the concrete strength. The weights for each of the connections are also depicted, as are<a id="_idIndexMarker873"/> the <strong class="keyWord">bias terms</strong> indicated by the nodes labeled with the number <code class="inlineCode">1</code>. The bias terms are numeric constants that allow the value at the indicated nodes to be shifted upward or downward, much like the intercept in a linear equation. In a linear equation of the form <em class="italic">y = ax + b</em>, the intercept <em class="italic">b</em> allows <em class="italic">y</em> to<a id="_idIndexMarker874"/> have a value other than 0 when <em class="italic">x = 0</em>. Similarly, the bias terms in a neural network allow the node to pass a value other than zero when the inputs are zero. This gives more flexibility for learning the true patterns found in the data, which in turn helps the model fit better. In the specific case of our concrete model, even though it isn’t feasible in the real world to have a case where all inputs to the concrete such as cement, age, and water are all zero, we wouldn’t necessarily expect strength to cross the origin exactly at zero even as the values of these factors approach zero. We might expect a model of body weight versus age to have a bias term above zero because the weight at birth (<em class="italic">age = 0</em>) is greater than zero.</p>
    <div class="packt_tip">
      <p class="normal">A neural network with a single hidden node can be thought of as a cousin of the linear regression models we studied in <em class="chapterRef">Chapter 6</em>, <em class="italic">Forecasting Numeric Data – Regression Methods</em>. The weight between each input node and the hidden node is similar to the beta coefficients, and the weight for the bias term is similar to the intercept. If a linear activation function is used, the neural network is almost exactly linear regression. A key difference, however, is that the ANN is trained using gradient descent while linear regression typically uses the least squares approach.</p>
    </div>
    <p class="normal">At the bottom of the figure, R reports the number of training steps and an error measure called <a id="_idIndexMarker875"/>the <strong class="keyWord">sum of squared errors</strong> (<strong class="keyWord">SSE</strong>), which, as you might expect, is the sum of the squared differences between the predicted and actual values. The lower the SSE, the more closely the model conforms to the training data, which tells us about performance on the training data but little about how it will perform on unseen data.</p>
    <h2 class="heading-2" id="_idParaDest-179">Step 4 – evaluating model performance</h2>
    <p class="normal">The <a id="_idIndexMarker876"/>network topology diagram gives us a peek into the black box of the ANN, but it doesn’t provide much information about how well the model fits future data. To generate predictions on the test dataset, we can use the <code class="inlineCode">compute()</code> function as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-operator">&gt;</span> model_results <span class="hljs-operator">&lt;-</span> compute<span class="hljs-punctuation">(</span>concrete_model<span class="hljs-punctuation">,</span> concrete_test<span class="hljs-punctuation">[</span><span class="hljs-number">1</span><span class="hljs-operator">:</span><span class="hljs-number">8</span><span class="hljs-punctuation">])</span>
</code></pre>
    <p class="normal">The <code class="inlineCode">compute()</code> function works a bit differently from the <code class="inlineCode">predict()</code> functions we’ve used so far. It returns a list with two components: <code class="inlineCode">$neurons</code>, which stores the neurons for each layer in the network, and <code class="inlineCode">$net.result</code>, which stores the predicted values. We’ll want the latter:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-operator">&gt;</span> predicted_strength <span class="hljs-operator">&lt;-</span> model_results<span class="hljs-operator">$</span>net.result
</code></pre>
    <p class="normal">Because this is a <a id="_idIndexMarker877"/>numeric prediction problem rather than a classification problem, we cannot use a confusion matrix to examine model accuracy. Instead, we’ll measure the correlation between our predicted concrete strength and the true value. If the predicted and actual values are highly correlated, the model is likely to be a useful gauge of concrete strength.</p>
    <p class="normal">Recall that the <code class="inlineCode">cor()</code> function is used to obtain a correlation between two numeric vectors:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-operator">&gt;</span> cor<span class="hljs-punctuation">(</span>predicted_strength<span class="hljs-punctuation">,</span> concrete_test<span class="hljs-operator">$</span>strength<span class="hljs-punctuation">)</span>
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">          [,1]
[1,] 0.8064656
</code></pre>
    <p class="normal">Correlations close to one indicate strong linear relationships between two variables. Therefore, the correlation here of about 0.806 indicates a fairly strong relationship. This implies that our model is doing a fairly good job, even with only a single hidden node. Yet, given that we only used one hidden node, it is likely that we can improve the performance of our model. Let’s try to do a bit better.</p>
    <h2 class="heading-2" id="_idParaDest-180">Step 5 – improving model performance</h2>
    <p class="normal">As<a id="_idIndexMarker878"/> networks with more complex topologies are capable of learning more difficult concepts, let’s see what happens when we increase the number of hidden nodes to five. We use the <code class="inlineCode">neuralnet()</code> function as before, but add the parameter <code class="inlineCode">hidden = 5</code>. Note that due to the increased complexity of this neural network, depending on the capabilities of your computer, the new model may take 30 to 60 seconds to train:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-operator">&gt;</span> set.seed<span class="hljs-punctuation">(</span><span class="hljs-number">12345</span><span class="hljs-punctuation">)</span>
<span class="hljs-operator">&gt;</span> concrete_model2 <span class="hljs-operator">&lt;-</span> neuralnet<span class="hljs-punctuation">(</span>strength <span class="hljs-operator">~</span> cement <span class="hljs-operator">+</span> slag <span class="hljs-operator">+</span>
                               ash <span class="hljs-operator">+</span> water <span class="hljs-operator">+</span> superplastic <span class="hljs-operator">+</span>
                               coarseagg <span class="hljs-operator">+</span> fineagg <span class="hljs-operator">+</span> age<span class="hljs-punctuation">,</span>
                               data <span class="hljs-operator">=</span> concrete_train<span class="hljs-punctuation">,</span> hidden <span class="hljs-operator">=</span> <span class="hljs-number">5</span><span class="hljs-punctuation">)</span>
</code></pre>
    <p class="normal">Plotting the network again, we see a drastic increase in the number of connections. How did this impact performance?</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-operator">&gt;</span> plot<span class="hljs-punctuation">(</span>concrete_model2<span class="hljs-punctuation">)</span>
</code></pre>
    <figure class="mediaobject"><img alt="Diagram  Description automatically generated" src="../Images/B17290_07_13.png"/></figure>
    <p class="packt_figref">Figure 7.13: Topology visualization of a neural network with additional hidden nodes</p>
    <p class="normal">Notice<a id="_idIndexMarker879"/> that the reported error (measured again by the SSE) has been reduced from 5.08 in the previous model to 1.63 here. Additionally, the number of training steps rose from 4,882 to 86,849, which should come as no surprise given how much more complex the model has become. More complex networks take many more iterations to find the optimal weights.</p>
    <p class="normal">Applying the same steps to compare the predicted values to the true values, we now obtain a correlation of around 0.92, which is a considerable improvement over the previous result of 0.80 with a single hidden node:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-operator">&gt;</span> model_results2 <span class="hljs-operator">&lt;-</span> compute<span class="hljs-punctuation">(</span>concrete_model2<span class="hljs-punctuation">,</span> concrete_test<span class="hljs-punctuation">[</span><span class="hljs-number">1</span><span class="hljs-operator">:</span><span class="hljs-number">8</span><span class="hljs-punctuation">])</span>
<span class="hljs-operator">&gt;</span> predicted_strength2 <span class="hljs-operator">&lt;-</span> model_results2<span class="hljs-operator">$</span>net.result
<span class="hljs-operator">&gt;</span> cor<span class="hljs-punctuation">(</span>predicted_strength2<span class="hljs-punctuation">,</span> concrete_test<span class="hljs-operator">$</span>strength<span class="hljs-punctuation">)</span>
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">             [,1]
[1,] 0.9244533426
</code></pre>
    <p class="normal">Despite these substantial improvements, there is still more we can do to attempt to improve the model’s performance. In particular, we have the ability to add additional hidden layers and change the network’s activation function. In making these changes, we create the foundations of a very simple DNN.</p>
    <p class="normal">The choice<a id="_idIndexMarker880"/> of activation function is usually very important for deep learning. The best function for a particular learning task is typically identified through experimentation, then shared more widely within the machine learning research community. As deep learning has become more studied, an activation function known as a <strong class="keyWord">rectifier</strong> has become extremely popular due to its success in complex tasks such as image recognition. A <a id="_idIndexMarker881"/>node in a neural network that uses the rectifier activation function is known as a <strong class="keyWord">rectified linear unit</strong> (<strong class="keyWord">ReLU</strong>). As depicted in the following figure, the ReLU activation function is defined such that it returns <em class="italic">x</em> if <em class="italic">x</em> is at least zero, and zero otherwise. The popularity of this function for deep learning is due to the fact that it is nonlinear yet has simple mathematical properties that make it both computationally inexpensive and highly efficient for gradient descent. Unfortunately, its derivative is undefined at <em class="italic">x = 0</em> and therefore cannot be used with the <code class="inlineCode">neuralnet()</code> function.</p>
    <p class="normal">Instead, we can use a smooth approximation of the ReLU known<a id="_idIndexMarker882"/> as <strong class="keyWord">softplus</strong> or <strong class="keyWord">SmoothReLU</strong>, an<a id="_idIndexMarker883"/> activation function defined as <em class="italic">log</em>(<em class="italic">1 + e</em><sup class="superscript-italic" style="font-style: italic;">x</sup>). As shown in the following figure, the softplus function is nearly zero for <em class="italic">x</em> less than zero and approximately <em class="italic">x</em> when <em class="italic">x</em> is greater than zero:</p>
    <figure class="mediaobject"><img alt="Chart, line chart  Description automatically generated" src="../Images/B17290_07_14.png"/></figure>
    <p class="packt_figref">Figure 7.14: The softplus activation function provides a smooth, differentiable approximation of ReLU</p>
    <p class="normal">To define a <code class="inlineCode">softplus()</code> function in R, use the following code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-operator">&gt;</span> softplus <span class="hljs-operator">&lt;-</span> <span class="hljs-keyword">function</span><span class="hljs-punctuation">(</span>x<span class="hljs-punctuation">)</span> <span class="hljs-punctuation">{</span> <span class="hljs-built_in">log</span><span class="hljs-punctuation">(</span><span class="hljs-number">1</span> <span class="hljs-operator">+</span> <span class="hljs-built_in">exp</span><span class="hljs-punctuation">(</span>x<span class="hljs-punctuation">))</span> <span class="hljs-punctuation">}</span>
</code></pre>
    <p class="normal">This <a id="_idIndexMarker884"/>activation function can be provided to <code class="inlineCode">neuralnet()</code> using the <code class="inlineCode">act.fct</code> parameter. Additionally, we will add a second hidden layer of five nodes by supplying the <code class="inlineCode">hidden</code> parameter the integer vector <code class="inlineCode">c(5, 5)</code>. This creates a two-layer network, each having five nodes, all using the softplus activation function. As before, this may take a minute or so to run:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-operator">&gt;</span> set.seed<span class="hljs-punctuation">(</span><span class="hljs-number">12345</span><span class="hljs-punctuation">)</span>
<span class="hljs-operator">&gt;</span> concrete_model3 <span class="hljs-operator">&lt;-</span> neuralnet<span class="hljs-punctuation">(</span>strength <span class="hljs-operator">~</span> cement <span class="hljs-operator">+</span> slag <span class="hljs-operator">+</span>
                               ash <span class="hljs-operator">+</span> water <span class="hljs-operator">+</span> superplastic <span class="hljs-operator">+</span>
                               coarseagg <span class="hljs-operator">+</span> fineagg <span class="hljs-operator">+</span> age<span class="hljs-punctuation">,</span>
                               data <span class="hljs-operator">=</span> concrete_train<span class="hljs-punctuation">,</span>
                               hidden <span class="hljs-operator">=</span> <span class="hljs-built_in">c</span><span class="hljs-punctuation">(</span><span class="hljs-number">5</span><span class="hljs-punctuation">,</span> <span class="hljs-number">5</span><span class="hljs-punctuation">),</span>
                               act.fct <span class="hljs-operator">=</span> softplus<span class="hljs-punctuation">)</span>
</code></pre>
    <p class="normal">The network visualization now shows a topology of two hidden layers of five nodes each:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-operator">&gt;</span> plot<span class="hljs-punctuation">(</span>concrete_model3<span class="hljs-punctuation">)</span>
</code></pre>
    <figure class="mediaobject"><img alt="Diagram  Description automatically generated" src="../Images/B17290_07_15.png"/></figure>
    <p class="packt_figref">Figure 7.15: Visualizing our network with two layers of hidden nodes using the softplus activation function</p>
    <p class="normal">Again, let’s compute the correlation between the predicted and actual concrete strength:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-operator">&gt;</span> model_results3 <span class="hljs-operator">&lt;-</span> compute<span class="hljs-punctuation">(</span>concrete_model3<span class="hljs-punctuation">,</span> concrete_test<span class="hljs-punctuation">[</span><span class="hljs-number">1</span><span class="hljs-operator">:</span><span class="hljs-number">8</span><span class="hljs-punctuation">])</span>
<span class="hljs-operator">&gt;</span> predicted_strength3 <span class="hljs-operator">&lt;-</span> model_results3<span class="hljs-operator">$</span>net.result
<span class="hljs-operator">&gt;</span> cor<span class="hljs-punctuation">(</span>predicted_strength3<span class="hljs-punctuation">,</span> concrete_test<span class="hljs-operator">$</span>strength<span class="hljs-punctuation">)</span>
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">             [,1]
[1,] 0.9348395359
</code></pre>
    <p class="normal">The <a id="_idIndexMarker885"/>correlation between the predicted and actual strength was 0.935, which is our best performance yet. Interestingly, in the original publication, Yeh reported a correlation of 0.885. This means that with relatively little effort, we were able to match and even exceed the performance of a subject matter expert. Of course, Yeh’s results were published in 1998, giving us the benefit of 25 years of additional neural network research!</p>
    <p class="normal">One important thing to be aware of is that, because we had normalized the data prior to training the model, the predictions are also on a normalized scale from zero to one. For example, the following code shows a data frame comparing the original dataset’s concrete strength values to their corresponding predictions side by side:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-operator">&gt;</span> strengths <span class="hljs-operator">&lt;-</span> data.frame<span class="hljs-punctuation">(</span>
    actual <span class="hljs-operator">=</span> concrete<span class="hljs-operator">$</span>strength<span class="hljs-punctuation">[</span><span class="hljs-number">774</span><span class="hljs-operator">:</span><span class="hljs-number">1030</span><span class="hljs-punctuation">],</span>
    pred <span class="hljs-operator">=</span> predicted_strength3
  <span class="hljs-punctuation">)</span>
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">&gt; head(strengths, n = 3)
    actual         pred
774  30.14 0.2860639091
775  44.40 0.4777304648
776  24.50 0.2840964250
</code></pre>
    <p class="normal">Using correlation as a performance metric, the choice of normalized or unnormalized data does not affect the result. For example, the correlation of 0.935 is the same whether the predicted strengths are compared to the original, unnormalized concrete strength values (<code class="inlineCode">strengths$actual</code>) or to the normalized values (<code class="inlineCode">concrete_test$strength</code>):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-operator">&gt;</span> cor<span class="hljs-punctuation">(</span>strengths<span class="hljs-operator">$</span>pred<span class="hljs-punctuation">,</span> strengths<span class="hljs-operator">$</span>actual<span class="hljs-punctuation">)</span>
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">[1] 0.9348395
</code></pre>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-operator">&gt;</span> cor<span class="hljs-punctuation">(</span>strengths<span class="hljs-operator">$</span>pred<span class="hljs-punctuation">,</span> concrete_test<span class="hljs-operator">$</span>strength<span class="hljs-punctuation">)</span>
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">[1] 0.9348395
</code></pre>
    <p class="normal">However, if we were to compute a different performance metric, such as the percentage difference between the predicted and actual values, the choice of scale would matter quite a bit.</p>
    <p class="normal">With this<a id="_idIndexMarker886"/> in mind, we can create an <code class="inlineCode">unnormalize()</code> function that reverses the min-max normalization procedure and allow us to convert the normalized predictions into the original scale:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-operator">&gt;</span> unnormalize <span class="hljs-operator">&lt;-</span> <span class="hljs-keyword">function</span><span class="hljs-punctuation">(</span>x<span class="hljs-punctuation">)</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-built_in">return</span><span class="hljs-punctuation">(</span>x <span class="hljs-operator">*</span> <span class="hljs-punctuation">(</span><span class="hljs-built_in">max</span><span class="hljs-punctuation">(</span>concrete<span class="hljs-operator">$</span>strength<span class="hljs-punctuation">)</span> <span class="hljs-operator">-</span>
            <span class="hljs-built_in">min</span><span class="hljs-punctuation">(</span>concrete<span class="hljs-operator">$</span>strength<span class="hljs-punctuation">))</span> <span class="hljs-operator">+</span> <span class="hljs-built_in">min</span><span class="hljs-punctuation">(</span>concrete<span class="hljs-operator">$</span>strength<span class="hljs-punctuation">))</span>
<span class="hljs-punctuation">}</span>
</code></pre>
    <p class="normal">After applying the custom <code class="inlineCode">unnormalize()</code> function to the predictions, we can see that the new predictions (<code class="inlineCode">pred_new</code>) are on a similar scale to the original concrete strength values. This allows us to compute a meaningful percentage error value. The resulting <code class="inlineCode">error_pct</code> is the percentage difference between the true and predicted values:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-operator">&gt;</span> strengths<span class="hljs-operator">$</span>pred_new <span class="hljs-operator">&lt;-</span> unnormalize<span class="hljs-punctuation">(</span>strengths<span class="hljs-operator">$</span>pred<span class="hljs-punctuation">)</span>
<span class="hljs-operator">&gt;</span> strengths<span class="hljs-operator">$</span>error_pct <span class="hljs-operator">&lt;-</span> <span class="hljs-punctuation">(</span>strengths<span class="hljs-operator">$</span>pred_new <span class="hljs-operator">-</span> strengths<span class="hljs-operator">$</span>actual<span class="hljs-punctuation">) </span><span class="hljs-operator">/ </span>
                            strengths<span class="hljs-operator">$</span>actual
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">&gt; head(strengths, n = 3)
    actual      pred pred_new  error_pct
774  30.14 0.2860639 25.29235 -0.16083776
775  44.40 0.4777305 40.67742 -0.08384179
776  24.50 0.2840964 25.13442 -0.02589470
</code></pre>
    <p class="normal">Unsurprisingly, the correlation remains the same despite reversing the normalization:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-operator">&gt;</span> cor<span class="hljs-punctuation">(</span>strengths<span class="hljs-operator">$</span>pred_new<span class="hljs-punctuation">,</span> strengths<span class="hljs-operator">$</span>actual<span class="hljs-punctuation">)</span>
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">[1] 0.9348395
</code></pre>
    <p class="normal">When applying neural networks to your own projects, you will need to perform a similar series of steps to return the data to its original scale.</p>
    <p class="normal">You may also find that neural networks quickly become much more complicated as they are applied to more challenging learning tasks. For example, you may find that you run into the so-called <strong class="keyWord">vanishing gradient problem</strong> and <a id="_idIndexMarker887"/>closely <a id="_idIndexMarker888"/>related <strong class="keyWord">exploding gradient problem</strong>, where the backpropagation algorithm fails to find a useful solution due to an inability to <a id="_idIndexMarker889"/>converge in a reasonable amount of time. </p>
    <p class="normal">As a remedy to these problems, one may perhaps try varying the number of hidden nodes, applying different activation functions such as the ReLU, adjusting the learning rate, and so on. The <code class="inlineCode">?neuralnet</code> help page provides more information on the various parameters that can be adjusted. This leads to another problem, however, in which testing many parameters becomes a bottleneck to building a strong-performing model. This is the tradeoff of ANNs and, even more so, DNNs: harnessing their great potential requires a great investment of time and computing power.</p>
    <div class="packt_tip">
      <p class="normal">Just as is often the case in life more generally, it is possible to trade time and money in machine learning. Using paid cloud computing resources such as <strong class="keyWord">Amazon Web Services</strong> (<strong class="keyWord">AWS</strong>) and <a id="_idIndexMarker890"/>Microsoft Azure allows one to build more complex models or test many models more quickly.</p>
    </div>
    <h1 class="heading-1" id="_idParaDest-181">Understanding support vector machines</h1>
    <p class="normal">A <strong class="keyWord">support vector machine</strong> (<strong class="keyWord">SVM</strong>) can<a id="_idIndexMarker891"/> be imagined as a surface that creates a boundary between points of data plotted in a multidimensional space representing examples and their feature values. The goal of an SVM is to create a flat boundary called<a id="_idIndexMarker892"/> a <strong class="keyWord">hyperplane</strong>, which divides the space to create fairly homogeneous partitions on either side. In this way, SVM learning combines aspects of both the instance-based nearest neighbor learning presented in <em class="chapterRef">Chapter 3</em>, <em class="italic">Lazy Learning – Classification Using Nearest Neighbors</em>, and the linear regression modeling described in <em class="chapterRef">Chapter 6</em>, <em class="italic">Forecasting Numeric Data – Regression Methods</em>. The combination is extremely powerful, allowing SVMs to model highly complex relationships.</p>
    <p class="normal">Although the basic mathematics that drive SVMs has been around for decades, interest in them grew greatly after they were adopted by the machine learning community. Their popularity exploded after high-profile success stories about difficult learning problems, as well as the development of award-winning SVM algorithms that were implemented in well-supported libraries across many programming languages, including R. SVMs have thus been adopted by a wide audience, which might have otherwise been unable to apply the somewhat complex mathematics needed to implement an SVM. The good news is that although the mathematics may be difficult, the basic concepts are understandable.</p>
    <p class="normal">SVMs can be adapted for use with nearly any type of learning task, including both classification and numeric prediction. Many of the algorithm’s key successes have been in pattern recognition. Notable applications include:</p>
    <ul>
      <li class="bulletList">Classification of microarray gene expression data in the field of bioinformatics to identify cancer or other genetic diseases</li>
      <li class="bulletList">Text categorization, such as identification of the language used in a document or classification of documents by subject matter</li>
      <li class="bulletList">The detection of rare yet important events like engine failure, security breaches, or earthquakes</li>
    </ul>
    <p class="normal">SVMs are most easily understood when used for binary classification, which is how the method has been traditionally applied. Therefore, in the remaining sections, we will focus only on SVM classifiers. Principles like those presented here also apply when adapting SVMs for numeric prediction.</p>
    <h2 class="heading-2" id="_idParaDest-182">Classification with hyperplanes</h2>
    <p class="normal">As noted previously, SVMs <a id="_idIndexMarker893"/>use a boundary called a <strong class="keyWord">hyperplane</strong> to partition data into groups of similar class values. For example, the following figure depicts hyperplanes <a id="_idIndexMarker894"/>that separate groups of circles and squares in two and three dimensions. Because the circles and squares can be separated perfectly by a straight line or flat surface, they are said <a id="_idIndexMarker895"/>to be <strong class="keyWord">linearly separable</strong>. At first, we’ll consider only a simple case where this is true, but SVMs can also be extended to problems where the points are not linearly separable.</p>
    <figure class="mediaobject"><img alt="" src="../Images/B17290_07_16.png"/></figure>
    <p class="packt_figref">Figure 7.16: The squares and circles are linearly separable in both two and three dimensions</p>
    <div class="packt_tip">
      <p class="normal">For convenience, the hyperplane is traditionally depicted as a line in 2D space, but this is simply because it is difficult to illustrate space in greater than 2 dimensions. In reality, the hyperplane is a flat surface in a high-dimensional space—a concept that can be difficult to get your mind around.</p>
    </div>
    <p class="normal">In two dimensions, the task of the SVM algorithm is to identify a line that separates the two classes. As shown in the following figure, there is more than one choice of dividing line between the groups of circles and squares. Three such possibilities are labeled <em class="italic">a</em>, <em class="italic">b</em>, and <em class="italic">c</em>. How does the algorithm choose?</p>
    <figure class="mediaobject"><img alt="Diagram  Description automatically generated with low confidence" src="../Images/B17290_07_17.png"/></figure>
    <p class="packt_figref">Figure 7.17: Three of many potential lines dividing the squares and circles</p>
    <p class="normal">The answer<a id="_idIndexMarker896"/> to that question involves a search for the <strong class="keyWord">maximum margin hyperplane</strong> (<strong class="keyWord">MMH</strong>) that <a id="_idIndexMarker897"/>creates the greatest separation between the two classes. Although any of the three lines separating the circles and squares would correctly classify all the data points, the line that leads to the greatest separation is expected to generalize the best to future data. The maximum margin will improve the chance that even if random noise is added, each class will remain on its own side of the boundary.</p>
    <p class="normal">The <strong class="keyWord">support vectors</strong> (indicated by arrows in the figure that follows) are <a id="_idIndexMarker898"/>the points from each class that are the closest to the MMH. Each class must have at least one support vector, but it is possible to have more than one. The support vectors alone define the MMH. This is a key feature of SVMs; the support vectors provide a very compact way to store a classification model, even if the number of features is extremely large.</p>
    <figure class="mediaobject"><img alt="Diagram  Description automatically generated" src="../Images/B17290_07_18.png"/></figure>
    <p class="packt_figref">Figure 7.18: The MMH is defined by the support vectors</p>
    <p class="normal">The <a id="_idIndexMarker899"/>algorithm<a id="_idIndexMarker900"/> to identify the support vectors relies on vector geometry and involves some tricky mathematics outside the scope of this book. However, the basic principles of the process are straightforward.</p>
    <div class="note">
      <p class="normal">More information on the mathematics of SVMs can be found in the classic paper <em class="italic">Support-Vector Networks, Cortes, C and Vapnik, V, Machine Learning, 1995, Vol. 20, pp. 273-297</em>. A beginner-level discussion can be found in <em class="italic">Support Vector Machines: Hype or Hallelujah?, Bennett, KP and Campbell, C, SIGKDD Explorations, 2000, Vol. 2, pp. 1-13</em>. A more in-depth look can be found in <em class="italic">Support Vector Machines, Steinwart, I and Christmann, A, New York: Springer, 2008</em>.</p>
    </div>
    <h3 class="heading-3" id="_idParaDest-183">The case of linearly separable data</h3>
    <p class="normal">Finding the maximum <a id="_idIndexMarker901"/>margin is easiest under the assumption that the classes are linearly separable. In this case, the MMH is as far away as <a id="_idIndexMarker902"/>possible from the outer boundaries of the two groups of data points. These outer boundaries are known as <a id="_idIndexMarker903"/>the <strong class="keyWord">convex hull</strong>. The MMH is then the perpendicular bisector of the shortest line between the two convex hulls. Sophisticated computer algorithms that use a technique known as <strong class="keyWord">quadratic optimization</strong> can<a id="_idIndexMarker904"/> find the maximum margin in this way.</p>
    <figure class="mediaobject"><img alt="Diagram  Description automatically generated" src="../Images/B17290_07_19.png"/></figure>
    <p class="packt_figref">Figure 7.19: The MMH is the perpendicular bisector of the shortest path between convex hulls</p>
    <p class="normal">An<a id="_idIndexMarker905"/> alternative (but equivalent) approach involves a search through the space of every possible hyperplane in order to find a set of two parallel planes that divide the points into homogeneous groups yet themselves are as far apart as possible. To use a metaphor, one can imagine this process as like trying to find the thickest mattress that can fit up a stairwell to your bedroom.</p>
    <p class="normal">To understand <a id="_idIndexMarker906"/>this search process, we’ll need to define exactly what we mean by a hyperplane. In <em class="italic">n</em>-dimensional space, the following equation is used:</p>
    <p class="center"><img alt="" src="../Images/B17290_07_002.png"/></p>
    <p class="normal">If you aren’t familiar with this notation, the arrows above the letters indicate that they are vectors rather than single numbers. In particular, <em class="italic">w</em> is a vector of <em class="italic">n</em> weights, that is, {<em class="italic">w</em><sub class="subscript-italic" style="font-style: italic;">1</sub><em class="italic">, w</em><sub class="subscript-italic" style="font-style: italic;">2</sub><em class="italic">, ..., w</em><sub class="subscript-italic" style="font-style: italic;">n</sub>}, and <em class="italic">b</em> is a single number known as the bias. The bias is conceptually equivalent to the intercept term in the slope-intercept form discussed in <em class="chapterRef">Chapter 6</em>, <em class="italic">Forecasting Numeric Data – Regression Methods</em>.</p>
    <div class="packt_tip">
      <p class="normal">If you’re having trouble imagining the plane in multidimensional space, don’t worry about the details. Simply think of the equation as a way to specify a surface, much like the slope-intercept form (<em class="italic">y = mx + b</em>) is used to specify lines in 2D space.</p>
    </div>
    <p class="normal">Using this formula, the goal of the process is to find a set of weights that specify two hyperplanes, as follows:</p>
    <p class="center"><img alt="" src="../Images/B17290_07_003.png"/></p>
    <p class="center"><img alt="" src="../Images/B17290_07_004.png"/></p>
    <p class="normal">We will <a id="_idIndexMarker907"/>also require that these hyperplanes are specified such <a id="_idIndexMarker908"/>that all the points of one class fall above the first hyperplane and all the points of the other class fall beneath the second hyperplane. The two planes should create a gap such that there are no points from either class in the space between them. This is possible so long as the data is linearly separable. Vector geometry defines the distance between these two planes—the distance we want as large as possible—as:</p>
    <p class="center"><img alt="" src="../Images/B17290_07_005.png"/></p>
    <p class="normal">Here, ||<em class="italic">w</em>|| indicates the <strong class="keyWord">Euclidean norm</strong> (the distance from the origin to vector <em class="italic">w</em>). Because ||<em class="italic">w</em>|| is the denominator, to maximize distance, we need to minimize ||<em class="italic">w</em>||. The task is typically re-expressed as a set of constraints, as follows:</p>
    <p class="center"><img alt="" src="../Images/B17290_07_006.png"/></p>
    <p class="center"><img alt="" src="../Images/B17290_07_007.png"/></p>
    <p class="normal">Although this looks messy, it’s really not too complicated to understand conceptually. Basically, the first line implies that we need to minimize the Euclidean norm (squared and divided by two to make the calculation easier). The second line notes that this is subject to (<em class="italic">s.t.</em>) the condition that each of the <em class="italic">y</em><sub class="subscript-italic" style="font-style: italic;">i</sub> data points is correctly classified. Note that <em class="italic">y</em> indicates the class value (transformed into either +1 or -1) and the upside-down “A” is shorthand for “for all.”</p>
    <p class="normal">As with the other method for finding the maximum margin, finding a solution to this problem is a task best left for quadratic optimization software. Although it can be processor-intensive, specialized algorithms can solve these problems quickly even on large datasets.</p>
    <h3 class="heading-3" id="_idParaDest-184">The case of nonlinearly separable data</h3>
    <p class="normal">As we’ve<a id="_idIndexMarker909"/> worked through the theory behind SVMs, you<a id="_idIndexMarker910"/> may be wondering about the elephant in the room: what happens in a case where that the data is not linearly separable? The solution to this problem is the use <a id="_idIndexMarker911"/>of a <strong class="keyWord">slack variable</strong>, which creates a soft margin that allows some points to fall on the incorrect side of the margin. The figure that follows illustrates two points falling on the wrong side of the line with the corresponding slack terms (denoted by the Greek letter Xi):</p>
    <figure class="mediaobject"><img alt="A picture containing text, clock  Description automatically generated" src="../Images/B17290_07_20.png"/></figure>
    <p class="packt_figref">Figure 7.20: Points falling on the wrong side of the boundary come with a cost penalty</p>
    <p class="normal">A cost value (denoted as <em class="italic">C</em>) is applied to all points that violate the constraints and rather than finding the maximum margin, the algorithm attempts to minimize the total cost. We can therefore revise the optimization problem to:</p>
    <p class="center"><img alt="" src="../Images/B17290_07_008.png"/></p>
    <p class="center"><img alt="" src="../Images/B17290_07_009.png"/></p>
    <p class="normal">If you’re confused by now, don’t worry, you’re not alone. Luckily, SVM packages will happily optimize this for you without you having to understand the technical details. The important piece to understand is the addition of the cost parameter, <em class="italic">C</em>. Modifying this value <a id="_idIndexMarker912"/>will adjust the penalty for points that fall on the wrong side of the hyperplane. The greater the cost parameter, the harder the <a id="_idIndexMarker913"/>optimization will try to achieve 100 percent separation. On the other hand, a lower cost parameter will place the emphasis on a wider overall margin. It is important to strike a balance between these two in order to create a model that generalizes well to future data.</p>
    <h2 class="heading-2" id="_idParaDest-185">Using kernels for nonlinear spaces</h2>
    <p class="normal">In many <a id="_idIndexMarker914"/>real-world datasets, the relationships between variables are nonlinear. As we just discovered, an SVM can still be trained on such data through the addition of a slack variable, which allows some examples to<a id="_idIndexMarker915"/> be misclassified. However, this is not the only way to approach the problem of nonlinearity. A key feature of SVMs is their ability to map the problem into a higher dimension space using a process known as<a id="_idIndexMarker916"/> the <strong class="keyWord">kernel trick</strong>. In doing so, a nonlinear relationship may suddenly appear to be quite linear.</p>
    <p class="normal">Though this seems like nonsense, it is actually quite easy to illustrate with an example. In the following figure, the scatterplot on the left depicts a nonlinear relationship between a weather class (Sunny or Snowy) and two features: Latitude and Longitude. The points at the center of the plot are members of the Snowy class, while the points at the margins are all Sunny. Such data could have been generated from a set of weather reports, some of which were obtained from stations near the top of a mountain, while others were obtained from stations around the base of the mountain.</p>
    <figure class="mediaobject"><img alt="Diagram  Description automatically generated" src="../Images/B17290_07_21.png"/></figure>
    <p class="packt_figref">Figure 7.21: The kernel trick can help transform a nonlinear problem into a linear one</p>
    <p class="normal">On the right side of the figure, after the kernel trick has been applied, we look at the data through the lens of a new dimension: Altitude. With the addition of this feature, the classes are now perfectly linearly separable. This is possible because we have obtained a new <a id="_idIndexMarker917"/>perspective on the data. In the left figure, we are viewing the mountain from a bird’s-eye view, while on the right, we are viewing the mountain from a distance at ground level. Here, the trend is obvious: snowy weather is found at higher altitudes.</p>
    <p class="normal">In this <a id="_idIndexMarker918"/>way, SVMs with nonlinear kernels add additional dimensions to the data in order to create separation. Essentially, the kernel trick involves a process of constructing new features that express mathematical relationships between measured characteristics. For instance, the Altitude feature can be expressed mathematically as an interaction between Latitude and Longitude—the closer the point is to the center of each of these scales, the greater the Altitude. This allows the SVM to learn concepts that were not explicitly measured in the original data.</p>
    <p class="normal">SVMs with nonlinear kernels are extremely powerful classifiers, although they do have some downsides, as <a id="_idIndexMarker919"/>shown in <a id="_idIndexMarker920"/>the following table:</p>
    <table class="table-container" id="table002-5">
      <tbody>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Strengths</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Weaknesses</strong></p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <ul>
              <li class="bulletList">Can be used for classification or numeric prediction problems</li>
              <li class="bulletList">Not overly influenced by noisy data and not very prone to overfitting</li>
              <li class="bulletList">May be easier to use than neural networks, particularly due to the existence of several well-supported SVM algorithms</li>
              <li class="bulletList">Gained popularity due to their high accuracy and high-profile wins in data mining competitions</li>
            </ul>
          </td>
          <td class="table-cell">
            <ul>
              <li class="bulletList">Finding the best model requires the testing of various combinations of kernels and model parameters</li>
              <li class="bulletList">Can be slow to train, particularly if the input dataset has a large number of features or examples</li>
              <li class="bulletList">Results in a complex black-box model that is difficult, if not impossible, to interpret</li>
            </ul>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="normal">Kernel functions, in general, are of the following form. The function denoted by the Greek letter phi, that is, <img alt="" src="../Images/B17290_07_010.png"/>, is a mapping of the data into another space. Therefore, the general kernel function applies some transformation to the feature vectors <em class="italic">x</em><sub class="subscript-italic" style="font-style: italic;">i</sub> and <em class="italic">x</em><sub class="subscript-italic" style="font-style: italic;">j</sub>, and combines them using the <strong class="keyWord">dot product</strong>, which takes two vectors and returns a single number:</p>
    <p class="center"><img alt="" src="../Images/B17290_07_011.png"/></p>
    <p class="normal">Using <a id="_idIndexMarker921"/>this form, kernel functions have been developed for many different domains. A few of the most commonly used kernel functions are listed as follows. Nearly all SVM software packages will include these kernels, among many others.</p>
    <p class="normal">The <strong class="keyWord">linear kernel</strong> does <a id="_idIndexMarker922"/>not transform the data at all. Therefore, it can<a id="_idIndexMarker923"/> be expressed simply as the dot product of the features:</p>
    <p class="center"><img alt="" src="../Images/B17290_07_012.png"/></p>
    <p class="normal">The <strong class="keyWord">polynomial kernel</strong> of<a id="_idIndexMarker924"/> degree <em class="italic">d</em> adds a simple nonlinear<a id="_idIndexMarker925"/> transformation of the data:</p>
    <p class="center"><img alt="" src="../Images/B17290_07_013.png"/></p>
    <p class="normal">The <strong class="keyWord">sigmoid kernel</strong> results in <a id="_idIndexMarker926"/>an SVM model somewhat analogous to a <a id="_idIndexMarker927"/>neural network using a sigmoid activation function. The Greek letters kappa and delta are used as kernel parameters:</p>
    <p class="center"><img alt="" src="../Images/B17290_07_014.png"/></p>
    <p class="normal">The <strong class="keyWord">Gaussian RBF kernel</strong> is<a id="_idIndexMarker928"/> similar to an RBF neural network. The <a id="_idIndexMarker929"/>RBF kernel performs well on many types of data and is thought to be a reasonable starting point for many learning tasks:</p>
    <p class="center"><img alt="" src="../Images/B17290_07_015.png"/></p>
    <p class="normal">There is no reliable rule for matching a kernel to a particular learning task. The fit depends heavily on the concept to be learned, as well as the amount of training data and the relationships between the features. Often, a bit of trial and error is required by training and evaluating several SVMs on a validation dataset. That said, in many cases, the choice of the kernel is arbitrary, as the performance may vary only slightly. To see how this works in practice, let’s apply our understanding of SVM classification to a real-world problem.</p>
    <h1 class="heading-1" id="_idParaDest-186">Example – performing OCR with SVMs</h1>
    <p class="normal">Image processing is a <a id="_idIndexMarker930"/>difficult task for many types of machine learning algorithms. The relationships linking patterns of pixels to higher concepts are extremely complex and hard to define. For instance, it’s easy for a human being to recognize a face, a cat, or the letter “A,” but defining these patterns in strict rules is difficult. Furthermore, image data is often noisy. There can be many slight variations in how the image was captured depending on the lighting, orientation, and positioning of the subject.</p>
    <p class="normal">SVMs are well suited to tackle the challenges of image data. Capable of learning complex patterns without being overly sensitive to noise, they can recognize visual patterns with a high degree of accuracy. Moreover, the key weakness of SVMs—the black-box model representation—is less critical for image processing. If an SVM can differentiate a cat from a dog, it does not matter much how it is doing so.</p>
    <p class="normal">In this section, we will develop a model like those used at the core of the <strong class="keyWord">optical character recognition</strong> (<strong class="keyWord">OCR</strong>) software often bundled with desktop document scanners or smartphone applications. The purpose of such software is to process paper-based documents by converting printed or handwritten text into an electronic form to be saved in a database.</p>
    <p class="normal">Of course, this is a difficult problem due to the many variants in handwriting style and printed fonts. Even so, software users expect perfection, as errors or typos can result in embarrassing or costly mistakes in a business environment. Let’s see whether our SVM is up to the task.</p>
    <h2 class="heading-2" id="_idParaDest-187">Step 1 – collecting data</h2>
    <p class="normal">When OCR software<a id="_idIndexMarker931"/> first processes a document, it divides the paper into a matrix such that each cell in the grid contains a <a id="_idIndexMarker932"/>single <strong class="keyWord">glyph</strong>, which is a term referring to a letter, symbol, or number. Next, for each cell, the software will attempt to match the glyph to a set of all characters it recognizes. Finally, the individual characters can be combined into words, which optionally could be spell-checked against a dictionary in the document’s language.</p>
    <p class="normal">In this exercise, we’ll assume that we have already developed the algorithm to partition the document into rectangular regions, each consisting of a single glyph. We will also assume the document contains only alphabetic characters in English. Therefore, we’ll simulate a process that involves matching glyphs to 1 of the 26 letters, A to Z.</p>
    <p class="normal">To this end, we’ll use a dataset donated to the UCI Machine Learning Repository (<a href="http://archive.ics.uci.edu/ml"><span class="url">http://archive.ics.uci.edu/ml</span></a>) by W. Frey and D. J. Slate. The dataset contains 20,000 examples of 26 English alphabet capital letters as printed using 20 different randomly reshaped and distorted black-and-white fonts.</p>
    <div class="note">
      <p class="normal">For more information about this data, refer to <em class="italic">Letter Recognition Using Holland-Style Adaptive Classifiers, Slate, DJ and Frey, PW, Machine Learning, 1991, Vol. 6, pp. 161-182</em>.</p>
    </div>
    <p class="normal">The following figure, published by Frey and Slate, provides an example of some of the printed glyphs. Distorted in this way, the letters are challenging for a computer to identify, yet are easily recognized by a human being:</p>
    <figure class="mediaobject"><img alt="Text  Description automatically generated" src="../Images/B17290_07_22.png"/></figure>
    <p class="packt_figref">Figure 7.22: Examples of glyphs the SVM algorithm will attempt to identify</p>
    <h2 class="heading-2" id="_idParaDest-188">Step 2 – exploring and preparing the data</h2>
    <p class="normal">According<a id="_idIndexMarker933"/> to the documentation provided by Frey and Slate, when the glyphs are scanned into the computer, they are converted into pixels and 16 statistical attributes are recorded.</p>
    <p class="normal">The attributes<a id="_idIndexMarker934"/> measure characteristics such as the horizontal and vertical dimensions of the glyph; the proportion of black (versus white) pixels; and the average horizontal and vertical position of the pixels. Presumably, differences in the concentration of black pixels across various areas of the box should provide a way to differentiate between the 26 letters of the alphabet.</p>
    <div class="packt_tip">
      <p class="normal">To follow along with this example, download the <code class="inlineCode">letterdata.csv</code> file from the Packt Publishing website and save it to your R working directory.</p>
    </div>
    <p class="normal">Reading the data into R, we confirm that we have received the data with the 16 features that define each example of the letter class. As expected, it has 26 levels:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-operator">&gt;</span> <span class="hljs-built_in">letters</span> <span class="hljs-operator">&lt;-</span> read.csv<span class="hljs-punctuation">(</span><span class="hljs-string">"letterdata.csv"</span><span class="hljs-punctuation">,</span> stringsAsFactors <span class="hljs-operator">=</span> <span class="hljs-literal">TRUE</span><span class="hljs-punctuation">)</span>
<span class="hljs-operator">&gt;</span> str<span class="hljs-punctuation">(</span><span class="hljs-built_in">letters</span><span class="hljs-punctuation">)</span>
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">'data.frame':	20000 obs. of  17 variables:
 $ letter: Factor w/ 26 levels "A","B","C","D",..: 20 9 4 14 ...
 $ xbox  : int  2 5 4 7 2 4 4 1 2 11 ...
 $ ybox  : int  8 12 11 11 1 11 2 1 2 15 ...
 $ width : int  3 3 6 6 3 5 5 3 4 13 ...
 $ height: int  5 7 8 6 1 8 4 2 4 9 ...
 $ onpix : int  1 2 6 3 1 3 4 1 2 7 ...
 $ xbar  : int  8 10 10 5 8 8 8 8 10 13 ...
 $ ybar  : int  13 5 6 9 6 8 7 2 6 2 ...
 $ x2bar : int  0 5 2 4 6 6 6 2 2 6 ...
 $ y2bar : int  6 4 6 6 6 9 6 2 6 2 ...
 $ xybar : int  6 13 10 4 6 5 7 8 12 12 ...
 $ x2ybar: int  10 3 3 4 5 6 6 2 4 1 ...
 $ xy2bar: int  8 9 7 10 9 6 6 8 8 9 ...
 $ xedge : int  0 2 3 6 1 0 2 1 1 8 ...
 $ xedgey: int  8 8 7 10 7 8 8 6 6 1 ...
 $ yedge : int  0 4 3 2 5 9 7 2 1 1 ...
 $ yedgex: int  8 10 9 8 10 7 10 7 7 8 ...
</code></pre>
    <p class="normal">SVM learners require all features to be numeric, and moreover, that each feature is scaled to a fairly small interval. In this case, every feature is an integer, so we do not need to convert any factors into numbers. On the other hand, some of the ranges for these integer variables appear wide. This indicates that we need to normalize or standardize the data. However, we can skip this step for now because the R package that we will use for fitting the SVM model will perform rescaling automatically.</p>
    <p class="normal">Given that <a id="_idIndexMarker935"/>there is no data<a id="_idIndexMarker936"/> preparation left to perform, we can move directly to the training and testing phases of the machine learning process. In previous analyses, we randomly divided the data between the training and testing sets. Although we could do so here, Frey and Slate have already randomized the data and therefore suggest using the first 16,000 records (80 percent) for building the model and the next 4,000 records (20 percent) for testing. Following their advice, we can create training and testing data frames as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-operator">&gt;</span> letters_train <span class="hljs-operator">&lt;-</span> <span class="hljs-built_in">letters</span><span class="hljs-punctuation">[</span><span class="hljs-number">1</span><span class="hljs-operator">:</span><span class="hljs-number">16000</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">]</span>
<span class="hljs-operator">&gt;</span> letters_test  <span class="hljs-operator">&lt;-</span> <span class="hljs-built_in">letters</span><span class="hljs-punctuation">[</span><span class="hljs-number">16001</span><span class="hljs-operator">:</span><span class="hljs-number">20000</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">]</span>
</code></pre>
    <p class="normal">With our data ready to go, let’s start building our classifier.</p>
    <h2 class="heading-2" id="_idParaDest-189">Step 3 – training a model on the data</h2>
    <p class="normal">When it <a id="_idIndexMarker937"/>comes to fitting an SVM model in R, there are several outstanding packages to choose from. The <code class="inlineCode">e1071</code> package from the Department of Statistics at the <strong class="keyWord">Vienna University of Technology</strong> (<strong class="keyWord">TU Wien</strong>) provides an R interface to the <a id="_idIndexMarker938"/>award-winning LIBSVM library, a widely used open-source SVM program written in C++. If you are already familiar with LIBSVM, you may want to start here.</p>
    <div class="note">
      <p class="normal">For more information on LIBSVM, refer to the authors’ website at <a href="http://www.csie.ntu.edu.tw/~cjlin/libsvm/"><span class="url">http://www.csie.ntu.edu.tw/~cjlin/libsvm/</span></a>.</p>
    </div>
    <p class="normal">Similarly, if you’re already invested in the SVMlight algorithm, the <code class="inlineCode">klaR</code> package from the Department of Statistics at the <strong class="keyWord">Dortmund University of Technology</strong> (<strong class="keyWord">TU Dortmund</strong>) provides functions for working with this SVM implementation directly from R.</p>
    <div class="note">
      <p class="normal">For information <a id="_idIndexMarker939"/>on SVMlight, see <a href="https://www.cs.cornell.edu/people/tj/svm_light/"><span class="url">https://www.cs.cornell.edu/people/tj/svm_light/</span></a>.</p>
    </div>
    <p class="normal">Finally, if you are starting from scratch, it is perhaps best to begin with the SVM functions in the <code class="inlineCode">kernlab</code> package. An interesting advantage of this package is that it was developed natively in R rather than C or C++, which allows it to be easily customized; none of the <a id="_idIndexMarker940"/>internals are hidden behind the scenes. Perhaps even more importantly, unlike the other options, <code class="inlineCode">kernlab</code> can be used with the <code class="inlineCode">caret</code> package, which allows SVM models to be trained and evaluated using a variety of automated methods (covered in <em class="chapterRef">Chapter 14</em>, <em class="italic">Building Better Learners</em>).</p>
    <div class="note">
      <p class="normal">For a more thorough <a id="_idIndexMarker941"/>introduction to <code class="inlineCode">kernlab</code>, please refer to the authors’ paper at <a href="http://www.jstatsoft.org/v11/i09/"><span class="url">http://www.jstatsoft.org/v11/i09/</span></a>.</p>
    </div>
    <p class="normal">The syntax for training SVM classifiers with <code class="inlineCode">kernlab</code> is as follows. If you do happen to be using one of the other packages, the commands are largely similar. By default, the <code class="inlineCode">ksvm()</code> function uses the Gaussian RBF kernel, but a number of other options are provided:</p>
    <figure class="mediaobject"><img alt="Text, letter  Description automatically generated" src="../Images/B17290_07_23.png"/></figure>
    <p class="packt_figref">Figure 7.23: SVM syntax</p>
    <p class="normal">To provide a baseline measure of SVM performance, let’s begin by training a simple linear SVM classifier. If you haven’t already, install the <code class="inlineCode">kernlab</code> package to your library using the <code class="inlineCode">install.packages("kernlab")</code> command. Then, we can call the <code class="inlineCode">ksvm()</code> function on the<a id="_idIndexMarker942"/> training data and specify the linear (that is, “vanilla”) kernel using the <code class="inlineCode">vanilladot</code> option, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-operator">&gt;</span> library<span class="hljs-punctuation">(</span>kernlab<span class="hljs-punctuation">)</span>
<span class="hljs-operator">&gt;</span> letter_classifier <span class="hljs-operator">&lt;-</span> ksvm<span class="hljs-punctuation">(</span>letter <span class="hljs-operator">~</span> .<span class="hljs-punctuation">,</span> data <span class="hljs-operator">=</span> letters_train<span class="hljs-punctuation">,</span>
                            kernel <span class="hljs-operator">=</span> <span class="hljs-string">"vanilladot"</span><span class="hljs-punctuation">)</span>
</code></pre>
    <p class="normal">Depending on the performance of your computer, this operation may take some time to complete. When it finishes, type the name of the stored model to see some basic information about the training parameters and the fit of the model:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-operator">&gt;</span> letter_classifier
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">Support Vector Machine object of class "ksvm"
SV type: C-svc  (classification)
 parameter : cost C = 1
Linear (vanilla) kernel function.
Number of Support Vectors : 7037
Objective Function Value : -14.1746 -20.0072 -23.5628 -6.2009 -7.5524
-32.7694 -49.9786 -18.1824 -62.1111 -32.7284 -16.2209...
Training error : 0.130062
</code></pre>
    <p class="normal">This information tells us very little about how well the model will perform in the real world. We’ll need to examine its performance on the testing dataset to know whether it generalizes well to unseen data.</p>
    <h2 class="heading-2" id="_idParaDest-190">Step 4 – evaluating model performance</h2>
    <p class="normal">The <code class="inlineCode">predict()</code> function<a id="_idIndexMarker943"/> allows us to use the letter classification model to make predictions on the testing dataset:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-operator">&gt;</span> letter_predictions <span class="hljs-operator">&lt;-</span> predict<span class="hljs-punctuation">(</span>letter_classifier<span class="hljs-punctuation">,</span> letters_test<span class="hljs-punctuation">)</span>
</code></pre>
    <p class="normal">Because we didn’t specify the <code class="inlineCode">type</code> parameter, the default <code class="inlineCode">type = "response"</code> was used. This <a id="_idIndexMarker944"/>returns a vector containing a predicted letter for each row of values in the testing data. Using the <code class="inlineCode">head()</code> function, we can see that the first six predicted letters were <code class="inlineCode">U</code>, <code class="inlineCode">N</code>, <code class="inlineCode">V</code>, <code class="inlineCode">X</code>, <code class="inlineCode">N</code>, and <code class="inlineCode">H</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-operator">&gt;</span> head<span class="hljs-punctuation">(</span>letter_predictions<span class="hljs-punctuation">)</span>
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">[1] U N V X N H
Levels: A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
</code></pre>
    <p class="normal">To examine how well our classifier performed, we need to compare the predicted letter with the true letter in the testing dataset. We’ll use the <code class="inlineCode">table()</code> function for this purpose (only a portion of the full table is shown here):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-operator">&gt;</span> table<span class="hljs-punctuation">(</span>letter_predictions<span class="hljs-punctuation">,</span> letters_test<span class="hljs-operator">$</span>letter<span class="hljs-punctuation">)</span>
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">letter_predictions   A   B   C   D   E
                 A 144   0   0   0   0
                 B   0 121   0   5   2
                 C   0   0 120   0   4
                 D   2   2   0 156   0
                 E   0   0   5   0 127
</code></pre>
    <p class="normal">The diagonal values of <code class="inlineCode">144</code>, <code class="inlineCode">121</code>, <code class="inlineCode">120</code>, <code class="inlineCode">156</code>, and <code class="inlineCode">127</code> indicate the total number of records where the predicted letter matches the true value. Similarly, the number of mistakes is also listed. For example, the value of <code class="inlineCode">5</code> in row <code class="inlineCode">B</code> and column <code class="inlineCode">D</code> indicates that there were 5 cases where the letter <code class="inlineCode">D</code> was misidentified as a <code class="inlineCode">B</code>.</p>
    <p class="normal">Looking at each type of mistake individually may reveal some interesting patterns about the specific types of letters the model has trouble with, but this is time-consuming. We can simplify our evaluation by instead calculating the overall accuracy. This considers only whether the prediction was correct or incorrect and ignores the type of error.</p>
    <p class="normal">The following command returns a vector of <code class="inlineCode">TRUE</code> or <code class="inlineCode">FALSE</code> values indicating whether the model’s predicted letter agrees with (that is, matches) the actual letter in the test dataset:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-operator">&gt;</span> agreement <span class="hljs-operator">&lt;-</span> letter_predictions <span class="hljs-operator">==</span> letters_test<span class="hljs-operator">$</span>letter
</code></pre>
    <p class="normal">Using the <code class="inlineCode">table()</code> function, we see that the classifier correctly identified the letter in 3,357 out of the 4,000 test records:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-operator">&gt;</span> table<span class="hljs-punctuation">(</span>agreement<span class="hljs-punctuation">)</span>
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">agreement
FALSE  TRUE
643 3357
</code></pre>
    <p class="normal">In percentage terms, the accuracy is about 84 percent:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-operator">&gt;</span> prop.table<span class="hljs-punctuation">(</span>table<span class="hljs-punctuation">(</span>agreement<span class="hljs-punctuation">))</span>
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">agreement
  FALSE    TRUE
0.16075 0.83925
</code></pre>
    <p class="normal">Note that <a id="_idIndexMarker945"/>when Frey and Slate published the dataset in 1991, they reported a recognition accuracy of about 80 percent. Using just a few lines of R code, we were able to surpass their result, although we also have the benefit of decades of additional machine learning research. With that in mind, it is likely that we can do even better.</p>
    <h2 class="heading-2" id="_idParaDest-191">Step 5 – improving model performance</h2>
    <p class="normal">Let’s take a <a id="_idIndexMarker946"/>moment to contextualize the performance of the SVM model we trained to identify letters of the alphabet from image data. With 1 line of R code, the model was able to achieve an accuracy of nearly 84 percent, which slightly surpassed the benchmark percent published by academic researchers in 1991. Although an accuracy of 84 percent is not nearly high enough to be useful for OCR software, the fact that a relatively simple model can reach this level is a remarkable accomplishment in itself. Keep in mind that the probability the model’s prediction would match the actual value by dumb luck alone is quite small at under four percent. This implies that our model performs over 20 times better than random chance. As remarkable as this is, perhaps by adjusting the SVM function parameters to train a slightly more complex model, we can also find that the model is useful in the real world.</p>
    <div class="packt_tip">
      <p class="normal">To calculate the probability of the SVM model’s predictions matching the actual values by chance alone, apply the joint probability rule for independent events covered in <em class="chapterRef">Chapter 4</em>, <em class="italic">Probabilistic Learning – Classification Using Naive Bayes</em>. Because there are 26 letters, each appearing at approximately the same rate in the test set, the chance that any one letter is predicted correctly is <em class="italic">(1 / 26) * (1 / 26)</em>. Since there are 26 different letters, the total probability of agreement is <em class="italic">26 * (1 / 26) * (1 / 26) = 0.0384</em>, or 3.84 percent.</p>
    </div>
    <h3 class="heading-3" id="_idParaDest-192">Changing the SVM kernel function</h3>
    <p class="normal">Our <a id="_idIndexMarker947"/>previous SVM model used the simple linear kernel function. By using a more complex kernel function, we can map the data into a higher dimensional space, and potentially obtain a better model fit.</p>
    <p class="normal">It can be challenging, however, to choose from the many different kernel functions. A popular convention is to begin with the Gaussian RBF kernel, which has been shown to perform well for many types of data. </p>
    <p class="normal">We can train an RBF-based SVM using the <code class="inlineCode">ksvm()</code> function as shown here. Note that, much like other methods used previously, we need to set the random seed to ensure the results are reproducible:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-operator">&gt;</span> set.seed<span class="hljs-punctuation">(</span><span class="hljs-number">12345</span><span class="hljs-punctuation">)</span>
<span class="hljs-operator">&gt;</span> letter_classifier_rbf <span class="hljs-operator">&lt;-</span> ksvm<span class="hljs-punctuation">(</span>letter <span class="hljs-operator">~</span> .<span class="hljs-punctuation">,</span> data <span class="hljs-operator">=</span> letters_train<span class="hljs-punctuation">,</span>
                                kernel <span class="hljs-operator">=</span> <span class="hljs-string">"rbfdot"</span><span class="hljs-punctuation">)</span>
</code></pre>
    <p class="normal">Next, we make predictions as before:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-operator">&gt;</span> letter_predictions_rbf <span class="hljs-operator">&lt;-</span> predict<span class="hljs-punctuation">(</span>letter_classifier_rbf<span class="hljs-punctuation">,</span>
                                    letters_test<span class="hljs-punctuation">)</span>
</code></pre>
    <p class="normal">Finally, we’ll compare the accuracy to our linear SVM:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-operator">&gt;</span> agreement_rbf <span class="hljs-operator">&lt;-</span> letter_predictions_rbf <span class="hljs-operator">==</span> letters_test<span class="hljs-operator">$</span>letter
<span class="hljs-operator">&gt;</span> table<span class="hljs-punctuation">(</span>agreement_rbf<span class="hljs-punctuation">)</span>
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">agreement_rbf
FALSE  TRUE
  278  3722
</code></pre>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-operator">&gt;</span> prop.table<span class="hljs-punctuation">(</span>table<span class="hljs-punctuation">(</span>agreement_rbf<span class="hljs-punctuation">))</span>
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">agreement_rbf
  FALSE    TRUE
0.0695 0.9305
</code></pre>
    <p class="normal">Simply by changing the kernel function, we were able to increase the accuracy of our character recognition model from 84 percent to 93 percent.</p>
    <h3 class="heading-3" id="_idParaDest-193">Identifying the best SVM cost parameter</h3>
    <p class="normal">If this level of<a id="_idIndexMarker948"/> performance is still unsatisfactory for the OCR program, it is certainly possible to test additional kernels. However, another fruitful approach is to vary the cost parameter, which modifies the width of the SVM decision boundary. This governs the model’s balance between overfitting and underfitting the training data—the larger the cost value, the harder the learner will try to perfectly classify every training instance, as <a id="_idIndexMarker949"/>there is a higher penalty for each mistake. On the one hand, a high cost can lead the learner to overfit the training data. On the other hand, a cost parameter set too small can cause the learner to miss important, subtle patterns in the training data and underfit the true pattern.</p>
    <p class="normal">There is no rule of thumb for knowing the ideal value beforehand, so instead, we will examine how the model performs for various values of <code class="inlineCode">C</code>, the cost parameter. Rather than repeating the training and evaluation process repeatedly, we can use the <code class="inlineCode">sapply()</code> function to apply a custom function to a vector of potential cost values. We begin by using the <code class="inlineCode">seq()</code> function to generate this vector as a sequence counting from 5 to 40 by 5. Then, as shown in the following code, the custom function trains the model as before, each time using the cost value and making predictions on the test dataset. Each model’s accuracy is computed as the number of predictions that match the actual values divided by the total number of predictions. The result is visualized using the <code class="inlineCode">plot()</code> function. Note that depending on the capabilities of your computer, this may take a few minutes to complete:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-operator">&gt;</span> cost_values <span class="hljs-operator">&lt;-</span> <span class="hljs-built_in">c</span><span class="hljs-punctuation">(</span><span class="hljs-number">1</span><span class="hljs-punctuation">,</span> seq<span class="hljs-punctuation">(</span>from <span class="hljs-operator">=</span> <span class="hljs-number">5</span><span class="hljs-punctuation">,</span> to <span class="hljs-operator">=</span> <span class="hljs-number">40</span><span class="hljs-punctuation">,</span> by <span class="hljs-operator">=</span> <span class="hljs-number">5</span><span class="hljs-punctuation">))</span>
<span class="hljs-operator">&gt;</span> accuracy_values <span class="hljs-operator">&lt;-</span> sapply<span class="hljs-punctuation">(</span>cost_values<span class="hljs-punctuation">,</span> <span class="hljs-keyword">function</span><span class="hljs-punctuation">(</span>x<span class="hljs-punctuation">)</span> <span class="hljs-punctuation">{</span>
    set.seed<span class="hljs-punctuation">(</span><span class="hljs-number">12345</span><span class="hljs-punctuation">)</span>
    m <span class="hljs-operator">&lt;-</span> ksvm<span class="hljs-punctuation">(</span>letter <span class="hljs-operator">~</span> .<span class="hljs-punctuation">,</span> data <span class="hljs-operator">=</span> letters_train<span class="hljs-punctuation">,</span>
              kernel <span class="hljs-operator">=</span> <span class="hljs-string">"rbfdot"</span><span class="hljs-punctuation">,</span> C <span class="hljs-operator">=</span> x<span class="hljs-punctuation">)</span>
    pred <span class="hljs-operator">&lt;-</span> predict<span class="hljs-punctuation">(</span>m<span class="hljs-punctuation">,</span> letters_test<span class="hljs-punctuation">)</span>
    agree <span class="hljs-operator">&lt;-</span> ifelse<span class="hljs-punctuation">(</span>pred <span class="hljs-operator">==</span> letters_test<span class="hljs-operator">$</span>letter<span class="hljs-punctuation">,</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span> <span class="hljs-number">0</span><span class="hljs-punctuation">)</span>
    accuracy <span class="hljs-operator">&lt;-</span> <span class="hljs-built_in">sum</span><span class="hljs-punctuation">(</span>agree<span class="hljs-punctuation">)</span> <span class="hljs-operator">/</span> nrow<span class="hljs-punctuation">(</span>letters_test<span class="hljs-punctuation">)</span>
    <span class="hljs-built_in">return</span> <span class="hljs-punctuation">(</span>accuracy<span class="hljs-punctuation">)</span>
  <span class="hljs-punctuation">})</span>
<span class="hljs-operator">&gt;</span> plot<span class="hljs-punctuation">(</span>cost_values<span class="hljs-punctuation">,</span> accuracy_values<span class="hljs-punctuation">,</span> type <span class="hljs-operator">=</span> <span class="hljs-string">"b"</span><span class="hljs-punctuation">)</span>
</code></pre>
    <figure class="mediaobject"><img alt="Shape  Description automatically generated" src="../Images/B17290_07_24.png"/></figure>
    <p class="packt_figref">Figure 7.24: Mapping accuracy against the SVM cost for the RBF kernel</p>
    <p class="normal">As<a id="_idIndexMarker950"/> depicted in the visualization, with an accuracy of 93 percent, the default SVM cost parameter of <code class="inlineCode">C = 1</code> resulted in by far the least accurate model among the 9 models evaluated. Instead, setting <code class="inlineCode">C</code> to a value of 10 or higher results in an accuracy of around 97 percent, which is quite an improvement in performance! Perhaps this is close enough to perfect for the model to be deployed in a real-world environment, though it may still be worth experimenting further with various kernels to see if it is possible to get even closer to 100 percent accuracy. Each additional improvement in accuracy will result in fewer mistakes for the OCR software and a better overall experience for the end user.</p>
    <h1 class="heading-1" id="_idParaDest-194">Summary</h1>
    <p class="normal">In this chapter, we examined two machine learning methods that offer a great deal of potential but are often overlooked due to their complexity. Hopefully, you now see that this reputation is at least somewhat undeserved. The basic concepts that drive ANNs and SVMs are not too difficult to understand.</p>
    <p class="normal">On the other hand, because ANNs and SVMs have been around for many decades, each of them has numerous variations. This chapter just scratches the surface of what is possible with these methods. By utilizing the terminology that you learned here, you should be capable of picking up the nuances that distinguish the many advancements that are being developed every day, including the ever-growing field of deep learning. We will revisit deep learning in <em class="chapterRef">Chapter 15</em>, <em class="italic">Making Use of Big Data</em>, to see how it can solve some of machine learning’s most challenging problems.</p>
    <p class="normal">In the past several chapters, we have learned about many different types of predictive models, from those based on simple heuristics like nearest neighbors to sophisticated black-box models and many others. In the next chapter, we will begin to consider methods for another type of learning task. These unsupervised learning techniques will bring to light fascinating patterns within the data as they assist us with finding needles in haystacks.</p>
    <h1 class="heading-1" id="_idParaDest-195">Join our book’s Discord space</h1>
    <p class="normal">Join our Discord community to meet like-minded people and learn alongside more than 4000 people at:</p>
    <p class="normal"><a href="https://packt.link/r"><span class="url">https://packt.link/r</span></a></p>
    <p class="normal"><img alt="" src="../Images/r.jpg"/></p>
  </div>
</body></html>