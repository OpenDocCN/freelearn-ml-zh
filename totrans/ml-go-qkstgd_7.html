<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Conclusion - Successful ML Projects</h1>
                </header>
            
            <article>
                
<p class="mce-root">So far in this book, we have focused on how to prepare and use ML algorithms in Go. This included the preparation of data in <a href="532d8304-b31d-41ef-81c1-b13f4c692824.xhtml" target="_blank">Chapter 2</a>, <em>Setting Up the Development Environment</em>, and the use of data to build models in <a href="48817ff3-5622-4f43-88e7-d3dfccacb25d.xhtml" target="_blank">Chapter 3</a>, <em>Supervised Learning</em>, and <a href="26788e93-3614-413f-bcde-5580516f9c5f.xhtml" target="_blank">Chapter 4</a>, <em>Unsupervised Learning</em>. We also looked at how to integrate an existing ML model into a Go application in <a href="815e42bb-64e4-4f04-9dbd-c58af28f2580.xhtml" target="_blank">Chapter 5</a>, <em>Using Pretrained Models</em>. Finally, we covered how to integrate ML into production systems in <a href="a48ed496-8a06-4293-80fb-0413d05e7a3e.xhtml" target="_blank">Chapter 6</a>, <em>Deploying Machine Learning Applications</em>. To conclude, we will take a look at the different stages in a typical project, and how to manage the end-to-end process of developing and deploying a successful ML system.</p>
<p>AI expert Andrej Karparthy has written<sup>[1]</sup> about how ML can be used to simplify what were previously very complex systems. Often, it is simpler to allow a machine to learn from data than it is to express all the logic we need in code. For example, Google's automatic translation application was simplified from 500,000 lines of conventional code to 500 lines of ML code using a neural network system. Changing from conventional code to a ML system requires different skill sets, and a different approach to software development.</p>
<p>Much of the technical literature on ML focuses on how to optimize or choose models to achieve the best performance, as measured against a test dataset. While this is important in advancing state-of-the-art ML, most real-world projects will succeed or fail against very different criteria. For example, it is crucial to understand how business needs are best translated into ML tasks, what the limitations of your ML systems are, and how best to manage the overall process of designing and maintaining ML applications.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>When to use ML</li>
<li>Typical stages in a ML project</li>
<li>When to combine ML with traditional code</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">When to use ML</h1>
                </header>
            
            <article>
                
<p>At the outset of any new project, you will need to identify whether ML is the correct approach. This depends on three key factors:</p>
<ul>
<li>First of all, it is crucial to understand your business requirements, and whether it can indeed be tackled by ML. Think about what the goals of your project are. For example, do you want to reduce the cost of a process that currently requires significant manual work and cost? Are you trying to create a better experience for your end customer, for example, by adding personalized features that would be too time-consuming to build using traditional code? </li>
<li>Next, ask yourself whether you have the data required to make your proposed ML system work. If not, how will you acquire the data you need, and what potential issues will need to be solved? For example, you might need to bring together datasets from different areas within your organization, or you may find that privacy issues will impact how you can make appropriate use of your data.</li>
<li>Finally, consider the limitations of ML and how these might impact your end product. For example, if you are going to use information from a customer database that contains many more men than women, then any ML system that you build from it may show a bias in its output unless you take steps to correct it. Typically, ML systems can generate unpredictable outputs when presented with data that is very different from that used in training and development. If you design a system to trade financial securities, think about what will happen if the input data changes suddenly, for example, following a market crash? How will you make sure that your system behaves safely, and does not emit nonsensical or catastrophic output?</li>
</ul>
<p>In many cases, you will not be able to know the answers to all of these questions at the start. A good approach in this situation is to start by identifying and building a <strong>proof-of-concept</strong> (<strong>PoC</strong>). Think of this as the simplest and cheapest possible demonstration that you can build of your ML application. With a good PoC, you should be able to do the following:</p>
<ul>
<li>Answer questions about whether ML is the right approach, and whether it addresses your business needs.</li>
<li>Uncover potential problems that you will have to address when building your full system.</li>
<li>Create a demonstration for stakeholders within your organization, allowing you to get feedback on whether your system will be fit-for-purpose, and what improvements and changes will need to be considered.</li>
</ul>
<div class="packt_infobox">A PoC or <strong>minimum viable product</strong> (<strong>MVP</strong>) is a simple and cheap demonstration of a ML product. Use it to answer questions you have about how your product will work before you spend time and money building a full production system.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Typical stages in a ML project</h1>
                </header>
            
            <article>
                
<p>As we have seen throughout this book, ML is highly dependent on the data that is used for training and testing. For this reason, we find it helpful to view a typical project through the stages in the following diagram, which comes from the <strong>Cross Industry Standard Process for Data Mining</strong> (<strong>CRISP-DM</strong>), a popular method for managing data science projects<sup>[3]</sup><span>:</span></p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-242 image-border" src="assets/8f6bb152-5824-4ccc-af13-bd01366218bc.png" style="width:33.67em;height:33.50em;"/></p>
<p>In contrast to some other engineering systems, ML normally never produces perfect output, so, for this reason, projects are often iterative. Refinements to the datasets and models allow you to produce progressively better results, provided they are justified by your business needs.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Business and data understanding</h1>
                </header>
            
            <article>
                
<p>Having decided to use ML, a crucial step in planning your project involves translating your <strong>business success criteria</strong> into <strong>technical requirements</strong> and objectives for the model. For example, what <strong>performance metrics</strong> should you use to build your model, both in terms of its accuracy and other factors, like computational speed and cost? What other systems does your product need to integrate with? Do you need to make sure that its predictions are free from bias, and, if so how, will you test for this?</p>
<p>While business understanding helps you design a product that will be valuable, <strong>data understanding</strong> helps you determine what is possible from the data that you have. By working with your data scientists, you can identify any problems with your datasets, and start to identify promising insights which may form the basis of your model.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Data preparation</h1>
                </header>
            
            <article>
                
<p>As we have seen throughout this book, having access to correctly prepared data is essential when building a ML application. Too often, the challenges in this area of <strong>data engineering</strong> are overlooked, resulting in slow progress as more and more time is spent on ad hoc work to integrate data sources and fix quality issues. </p>
<p>For this reason, it is worth thinking about how you will build your <strong>data pipeline</strong>: where does your data come from, what preprocessing will it require, and where will you store it? What checks should you run on your data to make sure any quality problems get identified quickly, before getting baked-in to a trained model?</p>
<p>A variety of tools now exist to help automate and simplify data pipelines, for example, the Apache Airflow project<sup>[4]</sup>, and managed services such as Google's Cloud Composer<sup>[5]</sup> and Amazon's AWS data pipeline<sup>[6]</sup>. </p>
<div class="packt_infobox">A <strong>data pipeline</strong> is a system that collects, transforms, and stores data in a common format, allowing it to be used as the input to your ML application.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Modelling and evaluation</h1>
                </header>
            
            <article>
                
<p>At this stage, you need to develop, fine-tune, and evaluate models for your data. Usually, there are three options regarding how to do this:</p>
<ul>
<li>Use an off-the-shelf ML solution with your own data. For example, Google Vision<sup>[7]</sup><span> </span>provides an API for a fully managed image classification system. Often, these services are a good way to get fast results at the PoC stage, but should be approached with caution on bigger projects. Because you have not trained the model yourself, it is often difficult to be sure that it captures the important features of your own data.</li>
<li>Take an existing open source model and retrain/customize it for your own purposes. For example, if you want to build a system that detects objects in images, it makes sense to leverage all the R&amp;D effort that large organizations have already put into this problem<sup>[8]</sup>. You can use these models to give you a head-start, and then retrain them on your own datasets.</li>
<li>Develop and train a model from scratch using the techniques that we learned about in <a href="48817ff3-5622-4f43-88e7-d3dfccacb25d.xhtml" target="_blank"/><a href="48817ff3-5622-4f43-88e7-d3dfccacb25d.xhtml" target="_blank">C<span>hapter 3</span></a><span>, <em>Supervised Learning</em>, and <a href="26788e93-3614-413f-bcde-5580516f9c5f.xhtml" target="_blank">Chapter 4</a>, <em>Unsupervised Learning</em>. While this can be the most time-consuming approach, it often yields the best results if your problem is unique to your organization.</span></li>
</ul>
<p>Regardless of the option you choose, it is important to ensure that your model's development and testing are <strong>reproducible</strong>. Make sure it is documented, and that both the model and its data requirements are captured in a version control system. Doing so will allow different team members to work on the same model and be confident in getting the same results.</p>
<div class="packt_infobox">A <strong>reproducible</strong> <strong>model</strong> is one that has sufficient code and documentation to allow it to be retrained easily on the same dataset that was used during development. It should also include the version numbers of all the software libraries and frameworks that it depends on.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Deployment</h1>
                </header>
            
            <article>
                
<p>A ML model is only useful if it can be deployed into a production system. In <span><a href="a48ed496-8a06-4293-80fb-0413d05e7a3e.xhtml" target="_blank">Chapter 6</a>, <em>Deploying Machine Learning Applications</em>, we explored techniques for how to achieve this in Go. Following these techniques will allow you to deploy your model reliably. As you start to iterate through the project stages to improve your product, it is also important to track the different model versions as they enter production. One option is to check all of your saved models into a version control system such as Git, although this can be problematic if your model contains large files. Another option is to use <strong>Data Version Control</strong> (<strong>DVC</strong>), which is able to track the code, models, and datasets that they depend on.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">When to combine ML with traditional code</h1>
                </header>
            
            <article>
                
<p>While most of this book has focused on how to write and use ML code, you will have also noticed that a lot of traditional, non-ML code is needed to support what we have done. Much of this is hidden inside the software libraries we have used, but there are cases where you may need to add to this.</p>
<p>One example is where you need to enforce certain constraints on your model output, for instance, to handle an edge case or implement some safety-critical constraints. Suppose you are writing software for a self-driving car: you might use ML to process image data from the cars cameras, but when it comes to actuating the vehicles steering, engine, and brake controls, you will most likely need to use traditional code to ensure that the car is controlled safely. Similarly, unless your ML system is trained to handle unexpected data inputs, for example, from a failed sensor, then you will want to add logic to deal with these cases. Make sure that you test your models with outlier data and edge cases before deployment so that you understand the circumstances under which its performance will degrade.</p>
<p>In all real-world systems, you need to think carefully about what you have trained your ML model to do, what its limitations are, and how to make sure your end-to-end system behaves as expected.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this book, you have learned about many important techniques that are required to develop ML applications in Go, and deploy them as production systems. The best way to develop your knowledge is with hands-on experience, so dive in and start adding ML software into your own Go applications. The skills you have learned here will allow you to start adding cutting-edge ML capabilities to the projects that you are working on.</p>
<p>ML is a rapidly evolving field with new algorithms and datasets being published every week, both by academics and technology companies. We recommend that you read the technical blogs, papers, and code repositories that cover this research, many of which we have referenced throughout this book. You might find a new state-of-the-art model that solves a problem you have been working on, waiting for you to implement it in Go. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further readings</h1>
                </header>
            
            <article>
                
<ol>
<li><a href="https://medium.com/@karpathy/software-2-0-a64152b37c35">https://medium.com/@karpathy/software-2-0-a64152b37c35</a>. Retrieved May 17, 2019.</li>
<li><a href="https://jack-clark.net/2017/10/09/import-ai-63-google-shrinks-language-translation-code-from-500000-to-500-lines-with-ai-only-25-of-surveyed-people-believe-automationbetter-jobs/">https://jack-clark.net/2017/10/09/import-ai-63-google-shrinks-language-translation-code-from-500000-to-500-lines-with-ai-only-25-of-surveyed-people-believe-automationbetter-jobs/</a>. Retrieved May 17, 2019.</li>
<li><a href="https://pdfs.semanticscholar.org/48b9/293cfd4297f855867ca278f7069abc6a9c24.pdf">https://pdfs.semanticscholar.org/48b9/293cfd4297f855867ca278f7069abc6a9c24.pdf</a>. Retrieved May 18, 2019.</li>
<li><a href="https://airflow.apache.org/">https://airflow.apache.org/</a>. Retrieved May 18, 2019.</li>
<li><a href="https://cloud.google.com/composer/">https://cloud.google.com/composer/</a>. Retrieved May 18,  2019.</li>
<li><a href="https://aws.amazon.com/datapipeline/">https://aws.amazon.com/datapipeline/</a>. Retrieved May 18, 2019.</li>
<li><a href="https://cloud.google.com/vision/">https://cloud.google.com/vision/</a>. Retrieved May 18, 2019.</li>
<li><a href="https://github.com/tensorflow/models/tree/master/research/object_detection">https://github.com/tensorflow/models/tree/master/research/object_detection</a>. Retrieved May 18, 2019.</li>
<li><a href="https://dvc.org/">https://dvc.org/</a>. Retrieved May 22, 2019.</li>
<li><a href="https://becominghuman.ai/how-to-version-control-your-machine-learning-task-ii-d37da60ef570">https://becominghuman.ai/how-to-version-control-your-machine-learning-task-ii-d37da60ef570</a>. Retrieved May 22, 2019.</li>
</ol>


            </article>

            
        </section>
    </body></html>