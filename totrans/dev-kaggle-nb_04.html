<html><head></head><body>
<div class="Basic-Text-Frame" id="_idContainer106">
<h1 class="chapterNumber"><span class="koboSpan" id="kobo.1.1">4</span></h1>
<h1 class="chapterTitle" id="_idParaDest-49"><span class="koboSpan" id="kobo.2.1">Take a Break and Have a Beer or Coffee in London</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.3.1">We continue our journey around the world using data by exploring two datasets in this chapter with geographically distributed information. </span><span class="koboSpan" id="kobo.3.2">The first dataset is </span><em class="italic"><span class="koboSpan" id="kobo.4.1">Every Pub in England</span></em><span class="koboSpan" id="kobo.5.1"> (see </span><em class="italic"><span class="koboSpan" id="kobo.6.1">Reference 1</span></em><span class="koboSpan" id="kobo.7.1">). </span><span class="koboSpan" id="kobo.7.2">This dataset contains the unique ID, name, address, postcode, and information regarding the geographical position of almost every pub in England. </span><span class="koboSpan" id="kobo.7.3">The second dataset is called </span><em class="italic"><span class="koboSpan" id="kobo.8.1">Starbucks Locations Worldwide</span></em><span class="koboSpan" id="kobo.9.1"> (see </span><em class="italic"><span class="koboSpan" id="kobo.10.1">Reference 3</span></em><span class="koboSpan" id="kobo.11.1">) which contains store number, name, and ownership details, as well as street address, city, and geographical information (latitude and longitude) for all Starbucks stores in the world.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.12.1">Apart from combining these two datasets, we will also add additional geographical support data. </span><span class="koboSpan" id="kobo.12.2">We will learn how to work with missing data, how to perform imputation if needed, how to visualize geographical data, how to clip and merge polygon data, how to generate custom maps, and how to create multiple layers over them. </span><span class="koboSpan" id="kobo.12.3">These are just a few tricks that we will learn in this chapter, but in a nutshell, the following topics will be covered:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.13.1">Detailed data analysis for pubs in England and Starbucks across the world</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.14.1">Combined geospatial analysis of pubs and Starbucks in London</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.15.1">The pretext for this chapter’s exploration of geospatial analysis tools and techniques is to analyze how the pubs and Starbucks coffee shops geographically interwind, answering such questions as “If somebody had enjoyed a few pints of ale in a pub in downtown London and then fancied a coffee, how far would they have to go to the nearest Starbucks coffee shop?” </span><span class="koboSpan" id="kobo.15.2">Or, to give another example, “For the current Starbucks shop, which pubs are closer to this one than to any other Starbucks coffee shop?” </span><span class="koboSpan" id="kobo.15.3">Of course, these are not the only questions we will try to answer, but we wanted to give you a glimpse of what we will achieve by the end of this chapter.</span></p>
<h1 class="heading-1" id="_idParaDest-50"><span class="koboSpan" id="kobo.16.1">Pubs in England</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.17.1">The </span><em class="italic"><span class="koboSpan" id="kobo.18.1">Every Pub in England</span></em><span class="koboSpan" id="kobo.19.1"> dataset (</span><em class="italic"><span class="koboSpan" id="kobo.20.1">Reference 1</span></em><span class="koboSpan" id="kobo.21.1">) contains data about 51,566 pubs in England, including the pub name, the address, the postal code, the geographical position (both by easting and northing and by latitude and longitude), and the local authority. </span><span class="koboSpan" id="kobo.21.2">I created a notebook, </span><em class="italic"><span class="koboSpan" id="kobo.22.1">Every Pub in England – Data Exploration</span></em><span class="koboSpan" id="kobo.23.1"> (</span><em class="italic"><span class="koboSpan" id="kobo.24.1">Reference 2</span></em><span class="koboSpan" id="kobo.25.1">) to investigate this data. </span><span class="koboSpan" id="kobo.25.2">The code </span><a id="_idIndexMarker111"/><span class="koboSpan" id="kobo.26.1">snippets in the current section are mainly from this notebook. </span><span class="koboSpan" id="kobo.26.2">It might be easier for you to follow the notebook in parallel with the explanations in the book.</span></p>
<h2 class="heading-2" id="_idParaDest-51"><span class="koboSpan" id="kobo.27.1">Data quality check</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.28.1">For the data quality check, we will use</span><a id="_idIndexMarker112"/><span class="koboSpan" id="kobo.29.1"> the </span><code class="inlineCode"><span class="koboSpan" id="kobo.30.1">info()</span></code><span class="koboSpan" id="kobo.31.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.32.1">describe()</span></code><span class="koboSpan" id="kobo.33.1"> functions to get a first glimpse. </span><span class="koboSpan" id="kobo.33.2">These two can be considered the first place to start. </span><span class="koboSpan" id="kobo.33.3">Then, we can also use our custom data quality statistics functions defined in the previous chapter. </span><span class="koboSpan" id="kobo.33.4">Because we will keep using them, we will group them in a utility script. </span><span class="koboSpan" id="kobo.33.5">I call this utility script </span><code class="inlineCode"><span class="koboSpan" id="kobo.34.1">data_quality_stats</span></code><span class="koboSpan" id="kobo.35.1">, and I defined in this module the functions </span><code class="inlineCode"><span class="koboSpan" id="kobo.36.1">missing_data</span></code><span class="koboSpan" id="kobo.37.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.38.1">most_frequent_values</span></code><span class="koboSpan" id="kobo.39.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.40.1">unique_values</span></code><span class="koboSpan" id="kobo.41.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.42.1">To use the functions defined in this utility script, we need to first add it to the notebook. </span><span class="koboSpan" id="kobo.42.2">From the </span><strong class="screenText"><span class="koboSpan" id="kobo.43.1">File</span></strong><span class="koboSpan" id="kobo.44.1"> menu, we will select the </span><strong class="screenText"><span class="koboSpan" id="kobo.45.1">Add utility script</span></strong><span class="koboSpan" id="kobo.46.1"> menu item, and then add the utility script by selecting it in the </span><strong class="screenText"><span class="koboSpan" id="kobo.47.1">Add Data</span></strong><span class="koboSpan" id="kobo.48.1"> panel on the right-hand side of the editor window:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.49.1"><img alt="" role="presentation" src="../Images/B20963_04_01.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.50.1">Figure 4.1: Adding a utility script to the notebook</span></p>
<p class="normal"><span class="koboSpan" id="kobo.51.1">Then, we will add </span><code class="inlineCode"><span class="koboSpan" id="kobo.52.1">import</span></code><span class="koboSpan" id="kobo.53.1"> to one of the first notebook cells:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.54.1">from</span></span><span class="koboSpan" id="kobo.55.1"> data_quality_stats </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.56.1">import</span></span><span class="koboSpan" id="kobo.57.1"> missing_data, most_frequent_values, unique_values
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.58.1">Let’s check the results after </span><a id="_idIndexMarker113"/><span class="koboSpan" id="kobo.59.1">applying this function to our </span><code class="inlineCode"><span class="koboSpan" id="kobo.60.1">pub_df</span></code><span class="koboSpan" id="kobo.61.1"> dataframe. </span><em class="italic"><span class="koboSpan" id="kobo.62.1">Figure.4.2</span></em><span class="koboSpan" id="kobo.63.1"> shows the missing values:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.64.1"><img alt="" role="presentation" src="../Images/B20963_04_02.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.65.1">Figure 4.2: Missing values</span></p>
<p class="normal"><span class="koboSpan" id="kobo.66.1">We can see that there are two missing values for local authorities. </span><span class="koboSpan" id="kobo.66.2">Other than that, it appears that there are no others. </span><span class="koboSpan" id="kobo.66.3">We need to be alert with regard to the missing values, as some might be hidden; for instance, a missing value could be replaced according to a convention with a specific value (like using “-1” to indicate null values for positive numbers or “NA” for categorical</span><a id="_idIndexMarker114"/><span class="koboSpan" id="kobo.67.1"> cases).</span></p>
<p class="normal"><em class="italic"><span class="koboSpan" id="kobo.68.1">Figure 4.3</span></em><span class="koboSpan" id="kobo.69.1"> depicts the most frequent values:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.70.1"><img alt="" role="presentation" src="../Images/B20963_04_03.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.71.1">Figure 4.3: Most frequent values</span></p>
<p class="normal"><span class="koboSpan" id="kobo.72.1">If we look now at the most frequent values, we can observe that for both </span><strong class="screenText"><span class="koboSpan" id="kobo.73.1">latitude</span></strong><span class="koboSpan" id="kobo.74.1"> and </span><strong class="screenText"><span class="koboSpan" id="kobo.75.1">longitude</span></strong><span class="koboSpan" id="kobo.76.1">, there are 70 items with the value </span><strong class="screenText"><span class="koboSpan" id="kobo.77.1">\N</span></strong><span class="koboSpan" id="kobo.78.1">. </span><span class="koboSpan" id="kobo.78.2">It’s interesting that, there are </span><strong class="screenText"><span class="koboSpan" id="kobo.79.1">70</span></strong><span class="koboSpan" id="kobo.80.1"> most frequent values for </span><strong class="screenText"><span class="koboSpan" id="kobo.81.1">easting</span></strong><span class="koboSpan" id="kobo.82.1"> and </span><strong class="screenText"><span class="koboSpan" id="kobo.83.1">northing</span></strong><span class="koboSpan" id="kobo.84.1">. </span><span class="koboSpan" id="kobo.84.2">Easting and northing are geographic Cartesian coordinates: easting refers to the eastward-measured distance, while northing refers to the northward-measured distance. </span><span class="koboSpan" id="kobo.84.3">According to the </span><strong class="keyWord"><span class="koboSpan" id="kobo.85.1">Universal Transverse Mercator</span></strong><span class="koboSpan" id="kobo.86.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.87.1">UTM</span></strong><span class="koboSpan" id="kobo.88.1">) coordinate system, northing is the </span><a id="_idIndexMarker115"/><span class="koboSpan" id="kobo.89.1">distance to the Equator; Easting, in the same coordinate system, is the distance to the “false easting,” which is uniquely defined in each UTM zone. </span><span class="koboSpan" id="kobo.89.2">We can also observe that the most frequently used name for a pub is </span><strong class="screenText"><span class="koboSpan" id="kobo.90.1">The Red Lion</span></strong><span class="koboSpan" id="kobo.91.1">, and that there are </span><strong class="screenText"><span class="koboSpan" id="kobo.92.1">8</span></strong><span class="koboSpan" id="kobo.93.1"> pubs in </span><strong class="screenText"><span class="koboSpan" id="kobo.94.1">Lancaster University</span></strong><span class="koboSpan" id="kobo.95.1">. </span><span class="koboSpan" id="kobo.95.2">As for the unique values, we can observe that there are more addresses than postcodes and more latitudes and longitudes than postcodes.</span></p>
<p class="normal"><em class="italic"><span class="koboSpan" id="kobo.96.1">Figure 4.4</span></em><span class="koboSpan" id="kobo.97.1"> depicts the unique values:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.98.1"><img alt="" role="presentation" src="../Images/B20963_04_04.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.99.1">Figure 4.4: Unique values</span></p>
<p class="normal"><span class="koboSpan" id="kobo.100.1">The number of unique values for </span><strong class="screenText"><span class="koboSpan" id="kobo.101.1">address</span></strong><span class="koboSpan" id="kobo.102.1"> is larger than the one for </span><strong class="screenText"><span class="koboSpan" id="kobo.103.1">postcode</span></strong><span class="koboSpan" id="kobo.104.1"> (more addresses on the same postcode). </span><span class="koboSpan" id="kobo.104.2">The total number of different local authorities is </span><strong class="screenText"><span class="koboSpan" id="kobo.105.1">376</span></strong><span class="koboSpan" id="kobo.106.1">. </span><span class="koboSpan" id="kobo.106.2">Additionally, notice that the number of unique names is smaller than the number of unique addresses (presumably, there are several popular pub names).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.107.1">Let’s check a bit more about the two missing local authority values. </span><span class="koboSpan" id="kobo.107.2">It is odd, since there are only two missing values, which</span><a id="_idIndexMarker116"/><span class="koboSpan" id="kobo.108.1"> is not expected. </span><span class="koboSpan" id="kobo.108.2">We also know that we have 70 missing values for both </span><strong class="screenText"><span class="koboSpan" id="kobo.109.1">latitude</span></strong><span class="koboSpan" id="kobo.110.1"> and </span><strong class="screenText"><span class="koboSpan" id="kobo.111.1">longitude</span></strong><span class="koboSpan" id="kobo.112.1">, and those are marked with </span><strong class="screenText"><span class="koboSpan" id="kobo.113.1">\N</span></strong><span class="koboSpan" id="kobo.114.1">. </span><span class="koboSpan" id="kobo.114.2">Look at the rows containing this missing local authority information:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.115.1"><img alt="Graphical user interface, application  Description automatically generated with medium confidence" src="../Images/B20963_04_05.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.116.1">Figure 4.5: Rows with local authority information missing</span></p>
<p class="normal"><span class="koboSpan" id="kobo.117.1">It appears that the information is missing because when the parser used by pandas to read the CSV file encountered the sequence </span><strong class="screenText"><span class="koboSpan" id="kobo.118.1">\”,”</span></strong><span class="koboSpan" id="kobo.119.1">, it was not able to distinguish the comma separator (</span><strong class="screenText"><span class="koboSpan" id="kobo.120.1">,</span></strong><span class="koboSpan" id="kobo.121.1">). </span><span class="koboSpan" id="kobo.121.2">Therefore, for those two lines, it merged </span><strong class="screenText"><span class="koboSpan" id="kobo.122.1">name</span></strong><span class="koboSpan" id="kobo.123.1"> with </span><strong class="screenText"><span class="koboSpan" id="kobo.124.1">address</span></strong><span class="koboSpan" id="kobo.125.1"> and then shifted left every column by one position, thus corrupting every column, from </span><strong class="screenText"><span class="koboSpan" id="kobo.126.1">address</span></strong><span class="koboSpan" id="kobo.127.1"> to </span><strong class="screenText"><span class="koboSpan" id="kobo.128.1">local_authority</span></strong><span class="koboSpan" id="kobo.129.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.130.1">We have two options to address this issue:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.131.1">One option is to try and give a list of separators to the parser. </span><span class="koboSpan" id="kobo.131.2">In our case, it will be a bit tricky, since we have only a comma separator. </span><span class="koboSpan" id="kobo.131.3">Also, if we try to use a multi-character separator, we will need to switch to a different engine, Python, because the default engine does not work with multi-character separators.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.132.1">The second option, and the preferred one, is to write a small piece of code to fix the issue in the two rows where we spotted it.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.133.1">Here is the piece of code to fix the issue with the two rows. </span><span class="koboSpan" id="kobo.133.2">We use the indexes of the two rows (we can see them in </span><em class="italic"><span class="koboSpan" id="kobo.134.1">Figure 4.5</span></em><span class="koboSpan" id="kobo.135.1"> – the first column, without a name) to identify them and perform the correction only on these rows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.136.1">columns = [</span><span class="hljs-string"><span class="koboSpan" id="kobo.137.1">'local_authority'</span></span><span class="koboSpan" id="kobo.138.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.139.1">'longitude'</span></span><span class="koboSpan" id="kobo.140.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.141.1">'latitude'</span></span><span class="koboSpan" id="kobo.142.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.143.1">'northing'</span></span><span class="koboSpan" id="kobo.144.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.145.1">'easting'</span></span><span class="koboSpan" id="kobo.146.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.147.1">'postcode'</span></span><span class="koboSpan" id="kobo.148.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.149.1">'address'</span></span><span class="koboSpan" id="kobo.150.1">]
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.151.1"># use the rows indexes to locate the rows</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.152.1">for</span></span><span class="koboSpan" id="kobo.153.1"> index </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.154.1">in</span></span><span class="koboSpan" id="kobo.155.1"> [</span><span class="hljs-number"><span class="koboSpan" id="kobo.156.1">768</span></span><span class="koboSpan" id="kobo.157.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.158.1">43212</span></span><span class="koboSpan" id="kobo.159.1">]:
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.160.1">for</span></span><span class="koboSpan" id="kobo.161.1"> idx </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.162.1">in</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.163.1">range</span></span><span class="koboSpan" id="kobo.164.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.165.1">len</span></span><span class="koboSpan" id="kobo.166.1">(columns) - </span><span class="hljs-number"><span class="koboSpan" id="kobo.167.1">1</span></span><span class="koboSpan" id="kobo.168.1">):
        </span><span class="hljs-comment"><span class="koboSpan" id="kobo.169.1"># we use `at` to make sure the changes are done on the actual dataframe, not on a copy of it</span></span><span class="koboSpan" id="kobo.170.1">
        pub_df.at[index, columns[idx]] = pub_df.loc[index][columns[idx + </span><span class="hljs-number"><span class="koboSpan" id="kobo.171.1">1</span></span><span class="koboSpan" id="kobo.172.1">]]
    
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.173.1"># split the corrupted name and assign the name and address</span></span><span class="koboSpan" id="kobo.174.1">
    name_and_addresse = pub_df.loc[index][</span><span class="hljs-string"><span class="koboSpan" id="kobo.175.1">'name'</span></span><span class="koboSpan" id="kobo.176.1">].split(</span><span class="hljs-string"><span class="koboSpan" id="kobo.177.1">"\",\""</span></span><span class="koboSpan" id="kobo.178.1">)
    pub_df.at[index, </span><span class="hljs-string"><span class="koboSpan" id="kobo.179.1">'name'</span></span><span class="koboSpan" id="kobo.180.1">] = name_and_addresse[</span><span class="hljs-number"><span class="koboSpan" id="kobo.181.1">0</span></span><span class="koboSpan" id="kobo.182.1">]
    pub_df.at[index, </span><span class="hljs-string"><span class="koboSpan" id="kobo.183.1">'address'</span></span><span class="koboSpan" id="kobo.184.1">] = name_and_addresse[</span><span class="hljs-number"><span class="koboSpan" id="kobo.185.1">1</span></span><span class="koboSpan" id="kobo.186.1">]
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.187.1">In </span><em class="italic"><span class="koboSpan" id="kobo.188.1">Figure 4.6</span></em><span class="koboSpan" id="kobo.189.1">, we can see that the name and address are now split and assigned to the correct column, and the rest of </span><a id="_idIndexMarker117"/><span class="koboSpan" id="kobo.190.1">the columns were shifted to the right:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.191.1"><img alt="Graphical user interface  Description automatically generated" src="../Images/B20963_04_06.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.192.1">Figure 4.6: Rows with local authority information after correction</span></p>
<p class="normal"><span class="koboSpan" id="kobo.193.1">If we check the missing data again, it will appear that no other data is missing. </span><span class="koboSpan" id="kobo.193.2">We already know that, in fact, there are 70 missing latitudes and longitudes; they are just marked with </span><strong class="screenText"><span class="koboSpan" id="kobo.194.1">\N</span></strong><span class="koboSpan" id="kobo.195.1">. </span><span class="koboSpan" id="kobo.195.2">If we check separately the latitude or longitude columns that have this value and then the rows where both columns have the same value, we can conclude that there are only 70 rows in total with this anomaly. </span><span class="koboSpan" id="kobo.195.3">For the same rows, we see that </span><strong class="screenText"><span class="koboSpan" id="kobo.196.1">northing</span></strong><span class="koboSpan" id="kobo.197.1"> and </span><strong class="screenText"><span class="koboSpan" id="kobo.198.1">easting</span></strong><span class="koboSpan" id="kobo.199.1"> have unique values, and these values are not correct.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.200.1">Consequently, we will not be able to reconstruct the latitude and longitude from </span><strong class="screenText"><span class="koboSpan" id="kobo.201.1">easting</span></strong><span class="koboSpan" id="kobo.202.1"> and </span><strong class="screenText"><span class="koboSpan" id="kobo.203.1">northing</span></strong><span class="koboSpan" id="kobo.204.1">. </span><span class="koboSpan" id="kobo.204.2">When checking the corresponding postcode, address, and local authority for these rows, we can see that there are multiple locations, in multiple local authority regions. </span><span class="koboSpan" id="kobo.204.3">There are 65 different postcodes in these 70 rows. </span><span class="koboSpan" id="kobo.204.4">Since we do have the postcodes, we will be able to use them to reconstruct the latitude and longitude.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.205.1">For this purpose, we will include the </span><strong class="screenText"><span class="koboSpan" id="kobo.206.1">Open Postcode Geo</span></strong><span class="koboSpan" id="kobo.207.1"> dataset (see </span><em class="italic"><span class="koboSpan" id="kobo.208.1">Reference 4</span></em><span class="koboSpan" id="kobo.209.1">) in our analysis. </span><span class="koboSpan" id="kobo.209.2">This dataset contains more than 2.5 million rows and many other columns, besides the postcode, latitude, and longitude. </span><span class="koboSpan" id="kobo.209.3">We read the CSV file from the </span><strong class="screenText"><span class="koboSpan" id="kobo.210.1">Open Postcode Geo</span></strong><span class="koboSpan" id="kobo.211.1"> dataset, select only four columns (</span><strong class="screenText"><span class="koboSpan" id="kobo.212.1">postcode</span></strong><span class="koboSpan" id="kobo.213.1">, </span><strong class="screenText"><span class="koboSpan" id="kobo.214.1">country</span></strong><span class="koboSpan" id="kobo.215.1">, </span><strong class="screenText"><span class="koboSpan" id="kobo.216.1">latitude</span></strong><span class="koboSpan" id="kobo.217.1">, and </span><strong class="screenText"><span class="koboSpan" id="kobo.218.1">longitude</span></strong><span class="koboSpan" id="kobo.219.1">), and filter out any rows with postcodes that are not included in the list of postcodes, from the 70 rows we targeted in our original dataset with pubs. </span><span class="koboSpan" id="kobo.219.2">We set as </span><code class="inlineCode"><span class="koboSpan" id="kobo.220.1">None</span></code><span class="koboSpan" id="kobo.221.1"> the values of </span><code class="inlineCode"><span class="koboSpan" id="kobo.222.1">longitude</span></code><span class="koboSpan" id="kobo.223.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.224.1">latitude</span></code><span class="koboSpan" id="kobo.225.1"> for </span><a id="_idIndexMarker118"/><span class="koboSpan" id="kobo.226.1">the 70 rows with missing geographical data:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.227.1">post_code_df = pd.read_csv(</span><span class="hljs-string"><span class="koboSpan" id="kobo.228.1">"/kaggle/input/open-postcode-geo/open_postcode_geo.csv"</span></span><span class="koboSpan" id="kobo.229.1">, header=</span><span class="hljs-literal"><span class="koboSpan" id="kobo.230.1">None</span></span><span class="koboSpan" id="kobo.231.1">, low_memory=</span><span class="hljs-literal"><span class="koboSpan" id="kobo.232.1">False</span></span><span class="koboSpan" id="kobo.233.1">)
post_code_df = post_code_df[[</span><span class="hljs-number"><span class="koboSpan" id="kobo.234.1">0</span></span><span class="koboSpan" id="kobo.235.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.236.1">6</span></span><span class="koboSpan" id="kobo.237.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.238.1">7</span></span><span class="koboSpan" id="kobo.239.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.240.1">8</span></span><span class="koboSpan" id="kobo.241.1">]]
post_code_df.columns = [</span><span class="hljs-string"><span class="koboSpan" id="kobo.242.1">'postcode'</span></span><span class="koboSpan" id="kobo.243.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.244.1">'country'</span></span><span class="koboSpan" id="kobo.245.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.246.1">'latitude'</span></span><span class="koboSpan" id="kobo.247.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.248.1">'longitude'</span></span><span class="koboSpan" id="kobo.249.1">]
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.250.1">We merge the two resulting datasets (the one with pubs and the one with postcodes), and we fill in the missing values for </span><strong class="screenText"><span class="koboSpan" id="kobo.251.1">latitude</span></strong><span class="koboSpan" id="kobo.252.1"> and </span><strong class="screenText"><span class="koboSpan" id="kobo.253.1">longitude</span></strong><span class="koboSpan" id="kobo.254.1"> in the </span><em class="italic"><span class="koboSpan" id="kobo.255.1">left</span></em><span class="koboSpan" id="kobo.256.1"> columns with the values from the </span><em class="italic"><span class="koboSpan" id="kobo.257.1">right</span></em><span class="koboSpan" id="kobo.258.1"> columns:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.259.1">pub_df = pub_df.merge(post_code_df, on=</span><span class="hljs-string"><span class="koboSpan" id="kobo.260.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.261.1">postcode"</span></span><span class="koboSpan" id="kobo.262.1">, how=</span><span class="hljs-string"><span class="koboSpan" id="kobo.263.1">"left"</span></span><span class="koboSpan" id="kobo.264.1">)
pub_df[</span><span class="hljs-string"><span class="koboSpan" id="kobo.265.1">'latitude'</span></span><span class="koboSpan" id="kobo.266.1">] = pub_df[</span><span class="hljs-string"><span class="koboSpan" id="kobo.267.1">'latitude_x'</span></span><span class="koboSpan" id="kobo.268.1">].fillna(pub_df[</span><span class="hljs-string"><span class="koboSpan" id="kobo.269.1">'latitude_y'</span></span><span class="koboSpan" id="kobo.270.1">])
pub_df[</span><span class="hljs-string"><span class="koboSpan" id="kobo.271.1">'longitude'</span></span><span class="koboSpan" id="kobo.272.1">] = pub_df[</span><span class="hljs-string"><span class="koboSpan" id="kobo.273.1">'longitude_x'</span></span><span class="koboSpan" id="kobo.274.1">].fillna(pub_df[</span><span class="hljs-string"><span class="koboSpan" id="kobo.275.1">'longitude_y'</span></span><span class="koboSpan" id="kobo.276.1">])
pub_df = pub_df.drop([</span><span class="hljs-string"><span class="koboSpan" id="kobo.277.1">"country"</span></span><span class="koboSpan" id="kobo.278.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.279.1">"latitude_x"</span></span><span class="koboSpan" id="kobo.280.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.281.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.282.1">latitude_y"</span></span><span class="koboSpan" id="kobo.283.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.284.1">"longitude_x"</span></span><span class="koboSpan" id="kobo.285.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.286.1">"longitude_y"</span></span><span class="koboSpan" id="kobo.287.1">], axis=</span><span class="hljs-number"><span class="koboSpan" id="kobo.288.1">1</span></span><span class="koboSpan" id="kobo.289.1">)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.290.1">Now, we’ve replaced all the missing data in the targeted rows with valid latitude and longitude values. </span><em class="italic"><span class="koboSpan" id="kobo.291.1">Figure 4.7</span></em><span class="koboSpan" id="kobo.292.1"> is a snapshot of what the combined dataset looks like.</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.293.1"><img alt="A screenshot of a computer  Description automatically generated" src="../Images/B20963_04_07.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.294.1">Figure 4.7: Combined dataset snapshot (every pub in England and Open Postcode)</span></p>
<p class="normal"><span class="koboSpan" id="kobo.295.1">Now with imputation done, we can continue with data exploration.</span></p>
<h2 class="heading-2" id="_idParaDest-52"><span class="koboSpan" id="kobo.296.1">Data exploration</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.297.1">We will start by exploring the frequency of each pub name and local authority. </span><span class="koboSpan" id="kobo.297.2">To represent this information, we will</span><a id="_idIndexMarker119"/><span class="koboSpan" id="kobo.298.1"> reuse the </span><code class="inlineCode"><span class="koboSpan" id="kobo.299.1">colormap</span></code><span class="koboSpan" id="kobo.300.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.301.1">plot</span></code><span class="koboSpan" id="kobo.302.1"> functions developed in the previous chapter. </span><span class="koboSpan" id="kobo.302.2">I created a utility script that is imported in the same way as the data statistics utility script:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.303.1">from</span></span><span class="koboSpan" id="kobo.304.1"> plot_utils </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.305.1">import</span></span><span class="koboSpan" id="kobo.306.1"> set_color_map, plot_count, show_wordcloud
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.307.1">After importing, we will extract the county and the city (if the address line contains more than two commas) and analyze the word frequency for those. </span><span class="koboSpan" id="kobo.307.2">The city is extracted with the simple code </span><a id="_idIndexMarker120"/><span class="koboSpan" id="kobo.308.1">shown here:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.309.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.310.1">get_city</span></span><span class="koboSpan" id="kobo.311.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.312.1">text</span></span><span class="koboSpan" id="kobo.313.1">):
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.314.1">try</span></span><span class="koboSpan" id="kobo.315.1">:
        split_text = text.split(</span><span class="hljs-string"><span class="koboSpan" id="kobo.316.1">","</span></span><span class="koboSpan" id="kobo.317.1">)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.318.1">if</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.319.1">len</span></span><span class="koboSpan" id="kobo.320.1">(split_text) &gt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.321.1">3</span></span><span class="koboSpan" id="kobo.322.1">:
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.323.1">return</span></span><span class="koboSpan" id="kobo.324.1"> split_text[-</span><span class="hljs-number"><span class="koboSpan" id="kobo.325.1">2</span></span><span class="koboSpan" id="kobo.326.1">]
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.327.1">except</span></span><span class="koboSpan" id="kobo.328.1">:
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.329.1">return</span></span> <span class="hljs-literal"><span class="koboSpan" id="kobo.330.1">None</span></span><span class="koboSpan" id="kobo.331.1">
pub_df[</span><span class="hljs-string"><span class="koboSpan" id="kobo.332.1">"address_city"</span></span><span class="koboSpan" id="kobo.333.1">] = pub_df[</span><span class="hljs-string"><span class="koboSpan" id="kobo.334.1">"address"</span></span><span class="koboSpan" id="kobo.335.1">].apply(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.336.1">lambda</span></span><span class="koboSpan" id="kobo.337.1"> x: get_city(x))
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.338.1">In </span><em class="italic"><span class="koboSpan" id="kobo.339.1">Figure 4.8</span></em><span class="koboSpan" id="kobo.340.1">, we show the top 10 pubs per local authority:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.341.1"><img alt="A bar graph with different colored bars  Description automatically generated" src="../Images/B20963_04_08.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.342.1">Figure 4.8: Pubs per local authority (top 10)</span></p>
<p class="normal"><em class="italic"><span class="koboSpan" id="kobo.343.1">Figure 4.9</span></em><span class="koboSpan" id="kobo.344.1"> shows the top 10 pubs per county. </span><span class="koboSpan" id="kobo.344.2">We extract the county by retrieving the last substring after the comma from the address. </span><span class="koboSpan" id="kobo.344.3">In some cases, it is not a county but a large municipality, like London:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.345.1"><img alt="A bar graph with different colored bars  Description automatically generated" src="../Images/B20963_04_09.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.346.1">Figure 4.9: Pubs per county (top 10)</span></p>
<p class="normal"><em class="italic"><span class="koboSpan" id="kobo.347.1">Figure 4.10</span></em><span class="koboSpan" id="kobo.348.1"> shows the distribution </span><a id="_idIndexMarker121"/><span class="koboSpan" id="kobo.349.1">of words in pub names and addresses:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.350.1"><img alt="" role="presentation" src="../Images/B20963_04_10.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.351.1">Figure 4.10: Distribution of words in the pub names (left) and addresses (right)</span></p>
<p class="normal"><span class="koboSpan" id="kobo.352.1">Because we have the geographical position of pubs, we would like to visualize this information. </span><span class="koboSpan" id="kobo.352.2">We can represent the positions of the pubs using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.353.1">folium</span></code><span class="koboSpan" id="kobo.354.1"> Python library and </span><code class="inlineCode"><span class="koboSpan" id="kobo.355.1">folium plugin</span></code> <code class="inlineCode"><span class="koboSpan" id="kobo.356.1">MarkerCluster</span></code><span class="koboSpan" id="kobo.357.1">. </span><span class="koboSpan" id="kobo.357.2">Folium (which wraps some of the most popular Leaflet external plugins) is an excellent way to display geographically distributed information.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.358.1">The code to show the UK map is given here:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.359.1">import</span></span><span class="koboSpan" id="kobo.360.1"> folium
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.361.1">from</span></span><span class="koboSpan" id="kobo.362.1"> folium.plugins </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.363.1">import</span></span><span class="koboSpan" id="kobo.364.1"> MarkerCluster
uk_coords = [</span><span class="hljs-number"><span class="koboSpan" id="kobo.365.1">55</span></span><span class="koboSpan" id="kobo.366.1">, -</span><span class="hljs-number"><span class="koboSpan" id="kobo.367.1">3</span></span><span class="koboSpan" id="kobo.368.1">]
uk_map = folium.Map(location = uk_coords, zoom_start = </span><span class="hljs-number"><span class="koboSpan" id="kobo.369.1">6</span></span><span class="koboSpan" id="kobo.370.1">)
uk_map
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.371.1">To add markers, we can add the </span><a id="_idIndexMarker122"/><span class="koboSpan" id="kobo.372.1">following code (the code to initialize the folium map layer is not included):</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.373.1">locations_data = np.array(pub_map_df[[</span><span class="hljs-string"><span class="koboSpan" id="kobo.374.1">"latitude"</span></span><span class="koboSpan" id="kobo.375.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.376.1">"longitude"</span></span><span class="koboSpan" id="kobo.377.1">]].astype(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.378.1">float</span></span><span class="koboSpan" id="kobo.379.1">))
marker_cluster = MarkerCluster(locations = locations_data)
marker_cluster.add_to(uk_map)
uk_map
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.380.1">We can also add, besides locations, pop-up information for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.381.1">MarkerCluster</span></code><span class="koboSpan" id="kobo.382.1">, as well as custom icons.</span></p>
<p class="normal"><em class="italic"><span class="koboSpan" id="kobo.383.1">Figure 4.11</span></em><span class="koboSpan" id="kobo.384.1"> shows the folium (leaflet) map for the British Isles based on OpenStreetMap, without the pub information layer:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.385.1"><img alt="Map  Description automatically generated" src="../Images/B20963_04_11.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.386.1">Figure 4.11: Map of the British Isles without the pub information layer</span></p>
<p class="normal"><em class="italic"><span class="koboSpan" id="kobo.387.1">Figure 4.12</span></em><span class="koboSpan" id="kobo.388.1"> shows a map of the British Isles with the pub information layer added, using the MarkerCluster plugin. </span><span class="koboSpan" id="kobo.388.2">With MarkerCluster, the markers are replaced dynamically, with a widget showing the number of markers in a certain area. </span><span class="koboSpan" id="kobo.388.3">When zooming in on an area, the MarkerCluster display </span><a id="_idIndexMarker123"/><span class="koboSpan" id="kobo.389.1">changes dynamically, showing a more detailed view of the markers’ distribution:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.390.1"><img alt=" Map  Description automatically generated" src="../Images/B20963_04_12.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.391.1">Figure 4.12: Map of the British Isles with the pub information layer added</span></p>
<p class="normal"><em class="italic"><span class="koboSpan" id="kobo.392.1">Figure 4.13</span></em><span class="koboSpan" id="kobo.393.1"> shows a zoomed-in version of the previous map. </span><span class="koboSpan" id="kobo.393.2">The region that we zoom in on is the southern part of the British mainland:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.394.1"><img alt="Map  Description automatically generated" src="../Images/B20963_04_13.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.395.1">Figure 4.13: Map of the British Isles with the pub information layer added, zoomed in on the southern region, including the London area</span></p>
<p class="normal"><em class="italic"><span class="koboSpan" id="kobo.396.1">Figure 4.14</span></em><span class="koboSpan" id="kobo.397.1"> zooms in on the</span><a id="_idIndexMarker124"/><span class="koboSpan" id="kobo.398.1"> London area. </span><span class="koboSpan" id="kobo.398.2">The clusters are broken into smaller groups, which appear as individual markers as we zoom in:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.399.1"><img alt="Chart, map  Description automatically generated" src="../Images/B20963_04_14.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.400.1">Figure 4.14: Zooming in on the London area</span></p>
<p class="normal"><span class="koboSpan" id="kobo.401.1">An alternative way to visualize the pub concentration is by using a heatmap. </span><span class="koboSpan" id="kobo.401.2">Heatmaps can create a very good intuition of the spatial distribution of data. </span><span class="koboSpan" id="kobo.401.3">They show distribution density with color shades, as shown in </span><em class="italic"><span class="koboSpan" id="kobo.402.1">Figure 4.15</span></em><span class="koboSpan" id="kobo.403.1">. </span><span class="koboSpan" id="kobo.403.2">Heatmaps are useful to show the density of data points continuously, and it is also easier to evaluate their intensity at different locations using heatmaps. </span><span class="koboSpan" id="kobo.403.3">Because heatmaps use interpolation techniques to create a smooth transition between data points, they can provide a more visually appealing representation </span><a id="_idIndexMarker125"/><span class="koboSpan" id="kobo.404.1">of the data distribution. </span><span class="koboSpan" id="kobo.404.2">You can see two zoom levels with a heatmap view of the pub distribution for all of Great Britain (left) and for the southwest tip of the mainland (right):</span></p>
<figure class="mediaobject"> <span class="koboSpan" id="kobo.405.1"><img alt="" role="presentation" src="../Images/B20963_04_15.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.406.1">Figure 4.15: Maps using folium and Heatmap to show location density distribution</span></p>
<p class="normal"><span class="koboSpan" id="kobo.407.1">Notice that there are no pubs from Northern Ireland included. </span><span class="koboSpan" id="kobo.407.2">This is because the collection of the pub data excluded it as it isn’t part of Great Britain.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.408.1">Another way to represent the spatial distribution of the pub data is using the Voronoi polygons (or a Voronoi diagram) associated </span><a id="_idIndexMarker126"/><span class="koboSpan" id="kobo.409.1">with the pubs’ positions. </span><strong class="keyWord"><span class="koboSpan" id="kobo.410.1">Voronoi polygons</span></strong><span class="koboSpan" id="kobo.411.1"> represent the dual graph </span><a id="_idIndexMarker127"/><span class="koboSpan" id="kobo.412.1">of a </span><strong class="keyWord"><span class="koboSpan" id="kobo.413.1">Delaunay tessellation</span></strong><span class="koboSpan" id="kobo.414.1">. </span><span class="koboSpan" id="kobo.414.2">Let’s explain these two concepts that we just introduced: Voronoi polygons and Delaunay tessellation.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.415.1">If we have a distribution of points in a plane, we can use the Delaunay tessellation to generate the triangular tessellation for this set of points. </span><span class="koboSpan" id="kobo.415.2">This graph is a set of triangles whose edges connect all the points, without crossing over. </span><span class="koboSpan" id="kobo.415.3">If we draw the mediators of the edges in the Delaunay graph, the network generated from the intersection of those new lines’ segments forms the Voronoi polygons mesh. </span><span class="koboSpan" id="kobo.415.4">In </span><em class="italic"><span class="koboSpan" id="kobo.416.1">Figure 4.16</span></em><span class="koboSpan" id="kobo.417.1">, we show a set of points and then the Voronoi diagram associated with these points:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.418.1"><img alt="" role="presentation" src="../Images/B20963_04_16.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.419.1">Figure 4.16: A set of points in a plane and the Voronoi polygons generated from this set of points</span></p>
<p class="normal"><span class="koboSpan" id="kobo.420.1">This Voronoi polygon graph has an interesting property. </span><span class="koboSpan" id="kobo.420.2">Inside a Voronoi polygon, all points are closer to the weight center of the polygon (which is one of the vertices of the original graph) than to any of the weight centers of any other neighboring polygon. </span><span class="koboSpan" id="kobo.420.3">Therefore, the Voronoi </span><a id="_idIndexMarker128"/><span class="koboSpan" id="kobo.421.1">polygons drawn from our pubs’ geographical position will accurately represent the pubs’ concentration and will also show, with a good approximation, the area “covered” by a certain pub. </span><span class="koboSpan" id="kobo.421.2">We will use the Voronoi diagram, formed from the Voronoi polygons, to show the virtual area covered by each pub.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.422.1">First, we extract the Voronoi polygons using the </span><em class="italic"><span class="koboSpan" id="kobo.423.1">Voronoi</span></em><span class="koboSpan" id="kobo.424.1"> function </span><code class="inlineCode"><span class="koboSpan" id="kobo.425.1">from</span></code> <code class="inlineCode"><span class="koboSpan" id="kobo.426.1">scipy.spatial</span></code><span class="koboSpan" id="kobo.427.1">: </span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.428.1">from</span></span><span class="koboSpan" id="kobo.429.1"> scipy.spatial </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.430.1">import</span></span><span class="koboSpan" id="kobo.431.1"> Voronoi, voronoi_plot_2d
locations_data = np.array(pub_map_df[[</span><span class="hljs-string"><span class="koboSpan" id="kobo.432.1">"longitude"</span></span><span class="koboSpan" id="kobo.433.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.434.1">"latitude"</span></span><span class="koboSpan" id="kobo.435.1">]].astype(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.436.1">float</span></span><span class="koboSpan" id="kobo.437.1">))
pub_voronoi = Voronoi(locations_data)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.438.1">We can represent the Voronoi polygons associated with the pubs (from </span><code class="inlineCode"><span class="koboSpan" id="kobo.439.1">pub_voronoi</span></code><span class="koboSpan" id="kobo.440.1">) using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.441.1">voronoi_plot_2d</span></code><span class="koboSpan" id="kobo.442.1"> function (see </span><em class="italic"><span class="koboSpan" id="kobo.443.1">Figure 4.17</span></em><span class="koboSpan" id="kobo.444.1">). </span><span class="koboSpan" id="kobo.444.2">However, the graph has a few problems. </span><span class="koboSpan" id="kobo.444.3">First, there are many polygons that are very difficult to distinguish. </span><span class="koboSpan" id="kobo.444.4">Then, the pubs’ locations (with dots in the graph) are not very legible. </span><span class="koboSpan" id="kobo.444.5">Another issue is that the polygons on the border are not aligned with the territory, creating unwanted artifacts that are not informative of the real area “covered” by a certain pub inside the Great Britain territory. </span><span class="koboSpan" id="kobo.444.6">We will apply a series of transformations to eliminate the aforementioned problems with the graph.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.445.1">The following code creates an image of Voronoi polygons, as shown in </span><em class="italic"><span class="koboSpan" id="kobo.446.1">Figure 4.17</span></em><span class="koboSpan" id="kobo.447.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.448.1">fig = voronoi_plot_2d(pub_voronoi,
                     show_vertices=</span><span class="hljs-literal"><span class="koboSpan" id="kobo.449.1">False</span></span><span class="koboSpan" id="kobo.450.1">)
plt.xlim([-</span><span class="hljs-number"><span class="koboSpan" id="kobo.451.1">8</span></span><span class="koboSpan" id="kobo.452.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.453.1">3</span></span><span class="koboSpan" id="kobo.454.1">])
plt.ylim([</span><span class="hljs-number"><span class="koboSpan" id="kobo.455.1">49</span></span><span class="koboSpan" id="kobo.456.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.457.1">60</span></span><span class="koboSpan" id="kobo.458.1">])
plt.show()
</span></code></pre>
<figure class="mediaobject"><span class="koboSpan" id="kobo.459.1"><img alt="" role="presentation" src="../Images/B20963_04_17.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.460.1">Figure 4.17: 2D plot of Voronoi polygons, extended outside the territory (not clipped)</span></p>
<p class="normal"><span class="koboSpan" id="kobo.461.1">If we want to represent the geographical area “covered” by each polygon only inside the territorial boundaries of </span><a id="_idIndexMarker129"/><span class="koboSpan" id="kobo.462.1">Great Britain, we will have to clip the Voronoi polygons generated from the pubs’ position with the polygons describing the territory boundary.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.463.1">Fortunately, we have access to Kaggle for shapefile data file formats for various countries. </span><span class="koboSpan" id="kobo.463.2">For our purpose, we will import the UK ESRI shapefile data from the </span><em class="italic"><span class="koboSpan" id="kobo.464.1">GADM Data for UK</span></em><span class="koboSpan" id="kobo.465.1"> dataset (see </span><em class="italic"><span class="koboSpan" id="kobo.466.1">Reference 5</span></em><span class="koboSpan" id="kobo.467.1">). </span><span class="koboSpan" id="kobo.467.2">This dataset provides incrementally detailed shapefile data, ranging from external boundaries (level 0) to country level (level 1) and county level (level 2) for the entire territory. </span><span class="koboSpan" id="kobo.467.3">Shapefiles can be read with several libraries; in this case, I preferred to use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.468.1">geopandas</span></code><span class="koboSpan" id="kobo.469.1"> library. </span><span class="koboSpan" id="kobo.469.2">This library has multiple useful features for our analysis. </span><span class="koboSpan" id="kobo.469.3">One of the advantages of selecting this library is that, while it adds functionality for manipulating and visualizing geospatial data, it keeps the user-friendliness and versatility </span><a id="_idIndexMarker130"/><span class="koboSpan" id="kobo.470.1">of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.471.1">pandas</span></code><span class="koboSpan" id="kobo.472.1"> library. </span><span class="koboSpan" id="kobo.472.2">We load the files with incremental resolution for the territory information:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.473.1">import</span></span><span class="koboSpan" id="kobo.474.1"> geopandas </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.475.1">as</span></span><span class="koboSpan" id="kobo.476.1"> gpd
uk_all = gpd.read_file(</span><span class="hljs-string"><span class="koboSpan" id="kobo.477.1">"/kaggle/input/gadm-data-for-uk/GBR_adm0.shp"</span></span><span class="koboSpan" id="kobo.478.1">)
uk_countries = gpd.read_file(</span><span class="hljs-string"><span class="koboSpan" id="kobo.479.1">"/kaggle/input/gadm-data-for-uk/GBR_adm1.shp"</span></span><span class="koboSpan" id="kobo.480.1">)
uk_counties = gpd.read_file(</span><span class="hljs-string"><span class="koboSpan" id="kobo.481.1">"/kaggle/input/gadm-data-for-uk/GBR_adm2.shp"</span></span><span class="koboSpan" id="kobo.482.1">)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.483.1">The data is loaded using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.484.1">geopandas</span></code> <code class="inlineCode"><span class="koboSpan" id="kobo.485.1">read_file</span></code><span class="koboSpan" id="kobo.486.1"> function. </span><span class="koboSpan" id="kobo.486.2">This returns a </span><code class="inlineCode"><span class="koboSpan" id="kobo.487.1">GeoDataFrame</span></code><span class="koboSpan" id="kobo.488.1"> object, a special type of DataFrame. </span><span class="koboSpan" id="kobo.488.2">It’s an extension of the DataFrame objects used with </span><code class="inlineCode"><span class="koboSpan" id="kobo.489.1">pandas</span></code><span class="koboSpan" id="kobo.490.1"> and includes geospatial data. </span><span class="koboSpan" id="kobo.490.2">If a DataFrame typically includes columns of type integer, float, text, and date, a GeoDataFrame will also include columns with data specific for spatial analysis, for example, polygons associated with the representation of geospatial regions.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.491.1">It is useful to inspect the geospatial data before using it to clip the Voronoi polygons. </span><span class="koboSpan" id="kobo.491.2">Let’s visualize the three different</span><a id="_idIndexMarker131"/><span class="koboSpan" id="kobo.492.1"> resolution data. </span><span class="koboSpan" id="kobo.492.2">We can do this using the plot function associated with each </span><strong class="keyWord"><span class="koboSpan" id="kobo.493.1">GeoDataFrame</span></strong><span class="koboSpan" id="kobo.494.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.495.1">fig, ax = plt.subplots(</span><span class="hljs-number"><span class="koboSpan" id="kobo.496.1">1</span></span><span class="koboSpan" id="kobo.497.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.498.1">3</span></span><span class="koboSpan" id="kobo.499.1">, figsize = (</span><span class="hljs-number"><span class="koboSpan" id="kobo.500.1">15</span></span><span class="koboSpan" id="kobo.501.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.502.1">6</span></span><span class="koboSpan" id="kobo.503.1">))
uk_all.plot(ax = ax[</span><span class="hljs-number"><span class="koboSpan" id="kobo.504.1">0</span></span><span class="koboSpan" id="kobo.505.1">], color = color_list[</span><span class="hljs-number"><span class="koboSpan" id="kobo.506.1">2</span></span><span class="koboSpan" id="kobo.507.1">], edgecolor = color_list[</span><span class="hljs-number"><span class="koboSpan" id="kobo.508.1">6</span></span><span class="koboSpan" id="kobo.509.1">])
uk_countries.plot(ax = ax[</span><span class="hljs-number"><span class="koboSpan" id="kobo.510.1">1</span></span><span class="koboSpan" id="kobo.511.1">], color = color_list[</span><span class="hljs-number"><span class="koboSpan" id="kobo.512.1">1</span></span><span class="koboSpan" id="kobo.513.1">], edgecolor = color_list[</span><span class="hljs-number"><span class="koboSpan" id="kobo.514.1">6</span></span><span class="koboSpan" id="kobo.515.1">])
uk_counties.plot(ax = ax[</span><span class="hljs-number"><span class="koboSpan" id="kobo.516.1">2</span></span><span class="koboSpan" id="kobo.517.1">], color = color_list[</span><span class="hljs-number"><span class="koboSpan" id="kobo.518.1">0</span></span><span class="koboSpan" id="kobo.519.1">], edgecolor = color_list[</span><span class="hljs-number"><span class="koboSpan" id="kobo.520.1">6</span></span><span class="koboSpan" id="kobo.521.1">])
plt.suptitle(</span><span class="hljs-string"><span class="koboSpan" id="kobo.522.1">"United Kingdom territory (all, countries and counties level)"</span></span><span class="koboSpan" id="kobo.523.1">)
plt.show()
</span></code></pre>
<figure class="mediaobject"><span class="koboSpan" id="kobo.524.1"><img alt="" role="presentation" src="../Images/B20963_04_18.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.525.1">Figure 4.18: Shapefile data for the UK for the entire territory, country level, and county level (left to right)</span></p>
<p class="normal"><span class="koboSpan" id="kobo.526.1">We already observed that the pubs are only in England, Scotland, and Wales, not in Northern Ireland. </span><span class="koboSpan" id="kobo.526.2">If we clip the Voronoi polygons for the pubs using the UK-level data, we could encounter a situation </span><a id="_idIndexMarker132"/><span class="koboSpan" id="kobo.527.1">where Voronoi polygons containing pubs from the western coast of England and Wales might spill over into the territory of Northern Ireland. </span><span class="koboSpan" id="kobo.527.2">This could result in an unwanted artifact. </span><span class="koboSpan" id="kobo.527.3">To avoid this, we can process the data as follows:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.528.1">Extract from the country-level shapefile only the data for England, Scotland, and Wales.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.529.1">Merge the polygon data from the three countries using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.530.1">dissolve</span></code><span class="koboSpan" id="kobo.531.1"> method from </span><code class="inlineCode"><span class="koboSpan" id="kobo.532.1">geopandas</span></code><span class="koboSpan" id="kobo.533.1">.</span></li>
</ul>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.534.1">uk_countries_selected = uk_countries.loc[~uk_countries.NAME_1.isin([</span><span class="hljs-string"><span class="koboSpan" id="kobo.535.1">"Northern Ireland"</span></span><span class="koboSpan" id="kobo.536.1">])]
uk_countries_dissolved = uk_countries_selected.dissolve()
fig, ax = plt.subplots(</span><span class="hljs-number"><span class="koboSpan" id="kobo.537.1">1</span></span><span class="koboSpan" id="kobo.538.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.539.1">1</span></span><span class="koboSpan" id="kobo.540.1">, figsize = (</span><span class="hljs-number"><span class="koboSpan" id="kobo.541.1">6</span></span><span class="koboSpan" id="kobo.542.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.543.1">6</span></span><span class="koboSpan" id="kobo.544.1">))
uk_countries_dissolved.plot(ax = ax, color = color_list[</span><span class="hljs-number"><span class="koboSpan" id="kobo.545.1">1</span></span><span class="koboSpan" id="kobo.546.1">], edgecolor = color_list[</span><span class="hljs-number"><span class="koboSpan" id="kobo.547.1">6</span></span><span class="koboSpan" id="kobo.548.1">])
plt.suptitle(</span><span class="hljs-string"><span class="koboSpan" id="kobo.549.1">"Great Britain territory (without Northern Ireland)"</span></span><span class="koboSpan" id="kobo.550.1">)
plt.show()
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.551.1">The resulting content is shown here:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.552.1"><img alt="" role="presentation" src="../Images/B20963_04_19.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.553.1">Figure 4.19: Shapefile data with England, Scotland, and Wales after filtering Northern Ireland and using dissolve to merge the polygons</span></p>
<p class="normal"><span class="koboSpan" id="kobo.554.1">Now, we have the right clipping </span><a id="_idIndexMarker133"/><span class="koboSpan" id="kobo.555.1">polygon for the Voronoi polygons from the three countries. </span><span class="koboSpan" id="kobo.555.2">Before clipping the polygons, we need to extract them from the Voronoi object. </span><span class="koboSpan" id="kobo.555.3">The following code does just that:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.556.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.557.1">extract_voronoi_polygon_list</span></span><span class="koboSpan" id="kobo.558.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.559.1">voronoi_polygons</span></span><span class="koboSpan" id="kobo.560.1">):
    voronoi_poly_list = []
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.561.1">for</span></span><span class="koboSpan" id="kobo.562.1"> region </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.563.1">in</span></span><span class="koboSpan" id="kobo.564.1"> voronoi_polygons.regions:
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.565.1">if</span></span><span class="koboSpan" id="kobo.566.1"> -</span><span class="hljs-number"><span class="koboSpan" id="kobo.567.1">1</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.568.1">in</span></span><span class="koboSpan" id="kobo.569.1"> region:
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.570.1">continue</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.571.1">else</span></span><span class="koboSpan" id="kobo.572.1">:
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.573.1">pass</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.574.1">if</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.575.1">len</span></span><span class="koboSpan" id="kobo.576.1">(region) != </span><span class="hljs-number"><span class="koboSpan" id="kobo.577.1">0</span></span><span class="koboSpan" id="kobo.578.1">:
            voronoi_poly_region = Polygon(voronoi_polygons.vertices[region])
            voronoi_poly_list.append(voronoi_poly_region)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.579.1">else</span></span><span class="koboSpan" id="kobo.580.1">:
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.581.1">continue</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.582.1">return</span></span><span class="koboSpan" id="kobo.583.1"> voronoi_poly_list
voronoi_poly_list = extract_voronoi_polygon_list(pub_voronoi)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.584.1">With that, we have everything we need to perform the clipping operation. </span><span class="koboSpan" id="kobo.584.2">We start by converting the list of Voronoi polygons into a </span><code class="inlineCode"><span class="koboSpan" id="kobo.585.1">GeoDataFrame</span></code><span class="koboSpan" id="kobo.586.1"> object, similar to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.587.1">uk_countries_dissolved</span></code><span class="koboSpan" id="kobo.588.1"> object that we will use to clip them. </span><span class="koboSpan" id="kobo.588.2">We are clipping the polygons so that, when we represent them, the polygons will not extend over the boundary. </span><span class="koboSpan" id="kobo.588.3">For the clipping operation to be performed correctly, and without errors, we will have to use the same </span><a id="_idIndexMarker134"/><span class="koboSpan" id="kobo.589.1">projection as for the clipping object. </span><span class="koboSpan" id="kobo.589.2">We use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.590.1">clip</span></code><span class="koboSpan" id="kobo.591.1"> function from the </span><code class="inlineCode"><span class="koboSpan" id="kobo.592.1">geopandas</span></code><span class="koboSpan" id="kobo.593.1"> library. </span><span class="koboSpan" id="kobo.593.2">This operation is highly time- and CPU-intensive. </span><span class="koboSpan" id="kobo.593.3">On Kaggle infrastructure, running the entire operation (with the CPU) for the 45,000 polygons in our list takes 35 minutes:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.594.1">voronoi_polygons = gpd.GeoDataFrame(voronoi_poly_list, columns = [</span><span class="hljs-string"><span class="koboSpan" id="kobo.595.1">'geometry'</span></span><span class="koboSpan" id="kobo.596.1">], crs=uk_countries_dissolved.crs)
start_time = time.time()
voronoi_polys_clipped = gpd.clip(voronoi_polygons, uk_countries_dissolved)
end_time = time.time()
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.597.1">print</span></span><span class="koboSpan" id="kobo.598.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.599.1">f"Total time: </span></span><span class="hljs-subst"><span class="koboSpan" id="kobo.600.1">{</span></span><span class="hljs-built_in"><span class="koboSpan" id="kobo.601.1">round</span></span><span class="hljs-subst"><span class="koboSpan" id="kobo.602.1">(end_time - start_time, </span></span><span class="hljs-number"><span class="koboSpan" id="kobo.603.1">4</span></span><span class="hljs-subst"><span class="koboSpan" id="kobo.604.1">)}</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.605.1"> sec."</span></span><span class="koboSpan" id="kobo.606.1">)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.607.1">The following code plots the entire collection of clipped polygons:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.608.1">fig, ax = plt.subplots(</span><span class="hljs-number"><span class="koboSpan" id="kobo.609.1">1</span></span><span class="koboSpan" id="kobo.610.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.611.1">1</span></span><span class="koboSpan" id="kobo.612.1">, figsize = (</span><span class="hljs-number"><span class="koboSpan" id="kobo.613.1">20</span></span><span class="koboSpan" id="kobo.614.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.615.1">20</span></span><span class="koboSpan" id="kobo.616.1">))
plt.style.use(</span><span class="hljs-string"><span class="koboSpan" id="kobo.617.1">'bmh'</span></span><span class="koboSpan" id="kobo.618.1">)
uk_all.plot(ax = ax, color = </span><span class="hljs-string"><span class="koboSpan" id="kobo.619.1">'none'</span></span><span class="koboSpan" id="kobo.620.1">, edgecolor = </span><span class="hljs-string"><span class="koboSpan" id="kobo.621.1">'</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.622.1">dimgray'</span></span><span class="koboSpan" id="kobo.623.1">)
voronoi_polys_clipped.plot(ax = ax, cmap = cmap_custom, edgecolor = </span><span class="hljs-string"><span class="koboSpan" id="kobo.624.1">'black'</span></span><span class="koboSpan" id="kobo.625.1">, linewidth = </span><span class="hljs-number"><span class="koboSpan" id="kobo.626.1">0.25</span></span><span class="koboSpan" id="kobo.627.1">)
plt.title(</span><span class="hljs-string"><span class="koboSpan" id="kobo.628.1">"All pubs in England - Voronoi polygons with each pub area"</span></span><span class="koboSpan" id="kobo.629.1">)
plt.show()
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.630.1">In </span><em class="italic"><span class="koboSpan" id="kobo.631.1">Figure 4.20</span></em><span class="koboSpan" id="kobo.632.1">, we can see the resulting plot. </span><span class="koboSpan" id="kobo.632.2">There are areas with a larger concentration of pubs (smaller polygons) and areas where there is a large distance between two pubs (in certain areas of Scotland, for example).</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.633.1"><img alt="" role="presentation" src="../Images/B20963_04_20.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.634.1">Figure 4.20: Voronoi polygons from the pub geospatial distribution, clipped using the dissolved country-level data from the three countries selected (England, Wales, and Scotland)</span></p>
<p class="normal"><span class="koboSpan" id="kobo.635.1">Another modality to show the</span><a id="_idIndexMarker135"/><span class="koboSpan" id="kobo.636.1"> spatial distribution of pubs is to aggregate the data at the local authority level and to build Voronoi polygons around the geospatial center of the pub distribution for that local authority. </span><span class="koboSpan" id="kobo.636.2">Each new Voronoi polygon center is the mean latitude/longitude coordinates for each pub in the current local authority. </span><span class="koboSpan" id="kobo.636.3">The resulting polygon mesh does not reconstruct the spatial distribution of the local authorities, but it represents with good accuracy the relative pub distribution. </span><span class="koboSpan" id="kobo.636.4">The resulting Voronoi polygon set is clipped using the same clipping polygons as before. </span><span class="koboSpan" id="kobo.636.5">To be more precise, before we used clipping polygons, the contours were obtained by dissolving the country-level shapefile data. </span><span class="koboSpan" id="kobo.636.6">We can use a graded colormap to represent the density of the pubs per area. </span><span class="koboSpan" id="kobo.636.7">Let’s see the code to create and</span><a id="_idIndexMarker136"/><span class="koboSpan" id="kobo.637.1"> visualize this mesh.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.638.1">First, we create a dataset that contains, for each local authority, the number of pubs and the average latitude and longitude of the pub locations:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.639.1">pub_df[</span><span class="hljs-string"><span class="koboSpan" id="kobo.640.1">"latitude"</span></span><span class="koboSpan" id="kobo.641.1">] = pub_df[</span><span class="hljs-string"><span class="koboSpan" id="kobo.642.1">"latitude"</span></span><span class="koboSpan" id="kobo.643.1">].apply(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.644.1">lambda</span></span><span class="koboSpan" id="kobo.645.1"> x: </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.646.1">float</span></span><span class="koboSpan" id="kobo.647.1">(x))
pub_df[</span><span class="hljs-string"><span class="koboSpan" id="kobo.648.1">"longitude"</span></span><span class="koboSpan" id="kobo.649.1">] = pub_df[</span><span class="hljs-string"><span class="koboSpan" id="kobo.650.1">"longitude"</span></span><span class="koboSpan" id="kobo.651.1">].apply(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.652.1">lambda</span></span><span class="koboSpan" id="kobo.653.1"> x: </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.654.1">float</span></span><span class="koboSpan" id="kobo.655.1">(x))
pubs_df = pub_df.groupby([</span><span class="hljs-string"><span class="koboSpan" id="kobo.656.1">"local_authority"</span></span><span class="koboSpan" id="kobo.657.1">])[</span><span class="hljs-string"><span class="koboSpan" id="kobo.658.1">"name"</span></span><span class="koboSpan" id="kobo.659.1">].count().reset_index()
pubs_df.columns = [</span><span class="hljs-string"><span class="koboSpan" id="kobo.660.1">"local_authority"</span></span><span class="koboSpan" id="kobo.661.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.662.1">"pubs"</span></span><span class="koboSpan" id="kobo.663.1">]
lat_df = pub_df.groupby([</span><span class="hljs-string"><span class="koboSpan" id="kobo.664.1">"local_authority"</span></span><span class="koboSpan" id="kobo.665.1">])[</span><span class="hljs-string"><span class="koboSpan" id="kobo.666.1">"latitude"</span></span><span class="koboSpan" id="kobo.667.1">].mean().reset_index()
lat_df.columns = [</span><span class="hljs-string"><span class="koboSpan" id="kobo.668.1">"local_authority"</span></span><span class="koboSpan" id="kobo.669.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.670.1">"latitude"</span></span><span class="koboSpan" id="kobo.671.1">]
long_df = pub_df.groupby([</span><span class="hljs-string"><span class="koboSpan" id="kobo.672.1">"local_authority"</span></span><span class="koboSpan" id="kobo.673.1">])[</span><span class="hljs-string"><span class="koboSpan" id="kobo.674.1">"longitude"</span></span><span class="koboSpan" id="kobo.675.1">].mean().reset_index()
long_df.columns = [</span><span class="hljs-string"><span class="koboSpan" id="kobo.676.1">"local_authority"</span></span><span class="koboSpan" id="kobo.677.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.678.1">"longitude"</span></span><span class="koboSpan" id="kobo.679.1">]
pubs_df = pubs_df.merge(lat_df)
pubs_df = pubs_df.merge(long_df)
mean_loc_data = np.array(pubs_df[[</span><span class="hljs-string"><span class="koboSpan" id="kobo.680.1">"longitude"</span></span><span class="koboSpan" id="kobo.681.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.682.1">"latitude"</span></span><span class="koboSpan" id="kobo.683.1">]].astype(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.684.1">float</span></span><span class="koboSpan" id="kobo.685.1">))
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.686.1">Then, we calculate the Voronoi polygons associated with this distribution:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.687.1">mean_loc_data = np.array(pubs_df[[</span><span class="hljs-string"><span class="koboSpan" id="kobo.688.1">"longitude"</span></span><span class="koboSpan" id="kobo.689.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.690.1">"latitude"</span></span><span class="koboSpan" id="kobo.691.1">]].astype(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.692.1">float</span></span><span class="koboSpan" id="kobo.693.1">))
pub_mean_voronoi = Voronoi(mean_loc_data)
mean_pub_poly_list = extract_voronoi_polygon_list(pub_mean_voronoi)
mean_voronoi_polygons = gpd.GeoDataFrame(mean_pub_poly_list, columns = [</span><span class="hljs-string"><span class="koboSpan" id="kobo.694.1">'geometry'</span></span><span class="koboSpan" id="kobo.695.1">], crs=uk_countries_dissolved.crs)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.696.1">We clip the resulting polygons with the same polygon used before for clipping (a result of selecting England, Wales, and Scotland and dissolving the shapefiles into one single shapefile):</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.697.1">mean_voronoi_polys_clipped = gpd.clip(mean_voronoi_polygons, uk_countries_dissolved)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.698.1">The following code plots the Voronoi polygons from the aggregated pub geospatial distribution at a local authority level (the center of a Voronoi polygon is the average latitude/longitude for all pubs</span><a id="_idIndexMarker137"/><span class="koboSpan" id="kobo.699.1"> in the local authority area), clipped using the dissolved country-level (three countries are selected: England, Scotland, and Wales) data. </span><span class="koboSpan" id="kobo.699.2">We use a green color gradient for the pub density per area (see </span><em class="italic"><span class="koboSpan" id="kobo.700.1">Figure 4.21</span></em><span class="koboSpan" id="kobo.701.1">):</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.702.1">fig, ax = plt.subplots(</span><span class="hljs-number"><span class="koboSpan" id="kobo.703.1">1</span></span><span class="koboSpan" id="kobo.704.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.705.1">1</span></span><span class="koboSpan" id="kobo.706.1">, figsize = (</span><span class="hljs-number"><span class="koboSpan" id="kobo.707.1">10</span></span><span class="koboSpan" id="kobo.708.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.709.1">10</span></span><span class="koboSpan" id="kobo.710.1">))
plt.style.use(</span><span class="hljs-string"><span class="koboSpan" id="kobo.711.1">'bmh'</span></span><span class="koboSpan" id="kobo.712.1">)
uk_all.plot(ax = ax, color = </span><span class="hljs-string"><span class="koboSpan" id="kobo.713.1">'none'</span></span><span class="koboSpan" id="kobo.714.1">, edgecolor = </span><span class="hljs-string"><span class="koboSpan" id="kobo.715.1">'dimgray'</span></span><span class="koboSpan" id="kobo.716.1">)
mean_voronoi_polys_clipped.plot(ax = ax, cmap = </span><span class="hljs-string"><span class="koboSpan" id="kobo.717.1">"Greens_r"</span></span><span class="koboSpan" id="kobo.718.1">)
plt.title(</span><span class="hljs-string"><span class="koboSpan" id="kobo.719.1">"All pubs in England\nPubs density per local authority\nVoronoi polygons for mean of pubs positions"</span></span><span class="koboSpan" id="kobo.720.1">)
plt.show()
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.721.1">We used Voronoi polygons to visualize the pubs’ geographical distribution. </span><span class="koboSpan" id="kobo.721.2">In </span><em class="italic"><span class="koboSpan" id="kobo.722.1">Figure 4.20</span></em><span class="koboSpan" id="kobo.723.1">, we show each polygon with a different color. </span><span class="koboSpan" id="kobo.723.2">Because the points inside a Voronoi polygon are closer to the polygon center than to any other neighboring polygon center, each polygon is approximately the area covered by the pub positioned in the center of the polygon. </span><span class="koboSpan" id="kobo.723.3">In </span><em class="italic"><span class="koboSpan" id="kobo.724.1">Figure 4.21</span></em><span class="koboSpan" id="kobo.725.1">, we use Voronoi polygons to build around the geometrical center of the pubs’ distribution inside each local authority. </span><span class="koboSpan" id="kobo.725.2">We then use a color gradient to represent the relative pub density for each local authority. </span><span class="koboSpan" id="kobo.725.3">By using these original visualization techniques, we were able to represent more intuitively the spatial distribution of the pubs.</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.726.1"><img alt="" role="presentation" src="../Images/B20963_04_21.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.727.1">Figure 4.21: Voronoi polygons with a color intensity proportional to the pub density per local authority area</span></p>
<p class="normal"><span class="koboSpan" id="kobo.728.1">We will continue to investigate this data in the upcoming section, when we mix data from the pub dataset with the data from the Starbucks dataset. </span><span class="koboSpan" id="kobo.728.2">We intend to combine the information from the two </span><a id="_idIndexMarker138"/><span class="koboSpan" id="kobo.729.1">datasets, using the Voronoi polygon areas to evaluate the relative distances between pubs and Starbucks in the London area. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.730.1">By manipulating Voronoi polygons generated for pubs and Starbucks coffee shops, we will analyze the relative spatial distribution of pubs and Starbucks, generating maps where we can see, for example, a group of pubs that are closest to a Starbucks. </span><span class="koboSpan" id="kobo.730.2">The geometric properties of Voronoi polygons will prove to be extremely useful to do this.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.731.1">With that in mind, let’s </span><a id="_idIndexMarker139"/><span class="koboSpan" id="kobo.732.1">proceed and explore the Starbucks dataset.</span></p>
<h1 class="heading-1" id="_idParaDest-53"><span class="koboSpan" id="kobo.733.1">Starbucks around the world</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.734.1">We start the analysis for the </span><em class="italic"><span class="koboSpan" id="kobo.735.1">Starbucks Locations Worldwide</span></em><span class="koboSpan" id="kobo.736.1"> dataset with a detailed </span><strong class="keyWord"><span class="koboSpan" id="kobo.737.1">Exploratory Data Analysis</span></strong><span class="koboSpan" id="kobo.738.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.739.1">EDA</span></strong><span class="koboSpan" id="kobo.740.1">) in the notebook </span><em class="italic"><span class="koboSpan" id="kobo.741.1">Starbucks Location Worldwide - Data Exploration</span></em><span class="koboSpan" id="kobo.742.1">. </span><span class="koboSpan" id="kobo.742.2">(see </span><em class="italic"><span class="koboSpan" id="kobo.743.1">Reference 6</span></em><span class="koboSpan" id="kobo.744.1">). </span><span class="koboSpan" id="kobo.744.2">You might </span><a id="_idIndexMarker140"/><span class="koboSpan" id="kobo.745.1">want to follow the notebook in parallel with the text in the current section. </span><span class="koboSpan" id="kobo.745.2">The tools </span><a id="_idIndexMarker141"/><span class="koboSpan" id="kobo.746.1">used in this dataset are imported from the </span><code class="inlineCode"><span class="koboSpan" id="kobo.747.1">data_quality_stats</span></code><span class="koboSpan" id="kobo.748.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.749.1">plot_style_utils</span></code><span class="koboSpan" id="kobo.750.1"> utility scripts. </span><span class="koboSpan" id="kobo.750.2">Before starting our analysis, it is important to explain that the dataset used for this analysis is from Kaggle and was collected 6 years ago.</span></p>
<h2 class="heading-2" id="_idParaDest-54"><span class="koboSpan" id="kobo.751.1">Preliminary data analysis</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.752.1">The dataset has 25,600 rows. </span><span class="koboSpan" id="kobo.752.2">Some fields have just a few missing values. </span><strong class="screenText"><span class="koboSpan" id="kobo.753.1">Latitude</span></strong><span class="koboSpan" id="kobo.754.1"> and </span><strong class="screenText"><span class="koboSpan" id="kobo.755.1">Longitude</span></strong><span class="koboSpan" id="kobo.756.1"> have 1 value </span><a id="_idIndexMarker142"/><span class="koboSpan" id="kobo.757.1">missing each, while there are 2 missing values for </span><strong class="screenText"><span class="koboSpan" id="kobo.758.1">Street Address</span></strong><span class="koboSpan" id="kobo.759.1"> and 15 missing values for </span><strong class="screenText"><span class="koboSpan" id="kobo.760.1">City</span></strong><span class="koboSpan" id="kobo.761.1">. </span><span class="koboSpan" id="kobo.761.2">The fields that have the most missing data are </span><strong class="screenText"><span class="koboSpan" id="kobo.762.1">Postcode</span></strong><span class="koboSpan" id="kobo.763.1"> (5.9%) and </span><strong class="screenText"><span class="koboSpan" id="kobo.764.1">Phone Number</span></strong><span class="koboSpan" id="kobo.765.1"> (26.8%). </span><span class="koboSpan" id="kobo.765.2">In </span><em class="italic"><span class="koboSpan" id="kobo.766.1">Figure 4.22</span></em><span class="koboSpan" id="kobo.767.1">, we can see a sample of the data:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.768.1"><img alt="Graphical user interface  Description automatically generated with medium confidence" src="../Images/B20963_04_22.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.769.1">Figure 4.22: First rows of the Starbucks Locations Worldwide dataset</span></p>
<p class="normal"><span class="koboSpan" id="kobo.770.1">Looking at the most frequent values report, we can learn a few interesting things:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.771.1"><img alt="A screenshot of a computer  Description automatically generated" src="../Images/B20963_04_23.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.772.1">Figure 4.23: The most frequent values for the Starbucks Locations Worldwide dataset</span></p>
<p class="normal"><span class="koboSpan" id="kobo.773.1">As expected, the state with the greatest number of Starbucks coffee shops is CA (USA). </span><span class="koboSpan" id="kobo.773.2">As per the city, the largest</span><a id="_idIndexMarker143"/><span class="koboSpan" id="kobo.774.1"> number of shops are in Shanghai. </span><span class="koboSpan" id="kobo.774.2">There is a unique address with up to 11 shops. </span><span class="koboSpan" id="kobo.774.3">Additionally, most of the shops per timezone are in the New York timezone .</span></p>
<h2 class="heading-2" id="_idParaDest-55"><span class="koboSpan" id="kobo.775.1">Univariate and bivariate data analysis</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.776.1">For this dataset, I chose a color map blending the colors of Starbucks with green and shades of brown, like those </span><a id="_idIndexMarker144"/><span class="koboSpan" id="kobo.777.1">of the high-quality roasted coffee they offer to their clients:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.778.1"><img alt="Shape  Description automatically generated" src="../Images/B20963_04_24.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.779.1">Figure 4.24: Notebook color map, blending Starbucks colors with the shades of roasted coffee</span></p>
<p class="normal"><span class="koboSpan" id="kobo.780.1">We will use the preceding custom colormap for the univariate analysis graphs. </span><span class="koboSpan" id="kobo.780.2">In the following figure, we show the distribution of coffee shops by country code. </span><span class="koboSpan" id="kobo.780.3">Most Starbucks are in the United States, with over 13,000 entries, followed by China, Canada and Japan:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.781.1"><img alt="" role="presentation" src="../Images/B20963_04_25.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.782.1">Figure 4.25: Coffee shops by country code. </span><span class="koboSpan" id="kobo.782.2">The US has the most, followed by China, Canada, and Japan</span></p>
<p class="normal"><span class="koboSpan" id="kobo.783.1">If we look at the distribution by state/province in </span><em class="italic"><span class="koboSpan" id="kobo.784.1">Figure 4.26</span></em><span class="koboSpan" id="kobo.785.1">, we can see that in first place is California, with more than 25,000. </span><span class="koboSpan" id="kobo.785.2">In second place is Texas, with over 1,000 coffee shops, and in third place is England, with fewer than 1,000. </span><span class="koboSpan" id="kobo.785.3">Distribution by timezone shows that the most</span><a id="_idIndexMarker145"/><span class="koboSpan" id="kobo.786.1"> represented is the US East Coast timezone (the New York timezone).</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.787.1"><img alt="" role="presentation" src="../Images/B20963_04_26.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.788.1">Figure 4.26: Coffee shops by State/Province code. </span><span class="koboSpan" id="kobo.788.2">California (CA) has the largest number of coffee shops, followed by Texas (TX)</span></p>
<p class="normal"><span class="koboSpan" id="kobo.789.1">Additionally, the majority of the coffee shops are in the New York (US East Coast) timezone:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.790.1"><img alt="" role="presentation" src="../Images/B20963_04_27.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.791.1">Figure 4.27: Coffee shops by timezone code, with the majority in the New York (US East Coast) timezone</span></p>
<p class="normal"><span class="koboSpan" id="kobo.792.1">Moving on, the ownership of </span><a id="_idIndexMarker146"/><span class="koboSpan" id="kobo.793.1">Starbucks coffee shops is shown in </span><em class="italic"><span class="koboSpan" id="kobo.794.1">Figure 4.28</span></em><span class="koboSpan" id="kobo.795.1">. </span><span class="koboSpan" id="kobo.795.2">We can observe that most of the coffee shops are company-owned (12,000), followed by licensed (more than 9,000), joint ventures (4,000), and franchises (fewer than 1,000):</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.796.1"><img alt="" role="presentation" src="../Images/B20963_04_28.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.797.1">Figure 4.28: Coffee shop ownership types</span></p>
<p class="normal"><span class="koboSpan" id="kobo.798.1">It will be interesting to see next how the ownership type varies depending on the country. </span><span class="koboSpan" id="kobo.798.2">Let’s represent the company ownership by country. </span><span class="koboSpan" id="kobo.798.3">The following figure shows the number of coffee shops per country for the top 10 countries. </span><span class="koboSpan" id="kobo.798.4">We use a logarithmic scale, due to data skewness (a</span><a id="_idIndexMarker147"/><span class="koboSpan" id="kobo.799.1"> measure of the asymmetry of the probability distribution). </span><span class="koboSpan" id="kobo.799.2">In other words, in a small number of countries, there are many coffee shops, while in the rest of the countries, there is a much smaller number. </span><span class="koboSpan" id="kobo.799.3">The United States has two types of ownership: company-owned and licensed. </span><span class="koboSpan" id="kobo.799.4">China has mostly joint ventures and company-owned, with a smaller number of licensed. </span><span class="koboSpan" id="kobo.799.5">In Japan, the majority of shops are joint ventures, with almost an equal amount of licensed and company-owned.</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.800.1"><img alt="A graph of a number of countries/regions  Description automatically generated" src="../Images/B20963_04_29.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.801.1">Figure 4.29: Coffee shops per country, grouped by ownership type</span></p>
<p class="normal"><span class="koboSpan" id="kobo.802.1">In the following figure, we show the number of coffee shops per city, grouped by ownership type. </span><span class="koboSpan" id="kobo.802.2">Because the city’s names are written in multiple forms (with vernacular characters in lowercase and uppercase), I first unified the notation (and aligned all with an English name). </span><span class="koboSpan" id="kobo.802.3">The </span><a id="_idIndexMarker148"/><span class="koboSpan" id="kobo.803.1">first cities are Shanghai, Seoul, and Beijing. </span><span class="koboSpan" id="kobo.803.2">Shanghai and Seoul have joint-venture coffee shops, while Beijing has only company-owned Starbucks coffee shops.</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.804.1"><img alt="A graph of different colored bars  Description automatically generated" src="../Images/B20963_04_30.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.805.1">Figure 4.30: Coffee shops per city, grouped by ownership type</span></p>
<p class="normal"><span class="koboSpan" id="kobo.806.1">We performed univariate and bivariate analyses on the Starbucks coffee shops dataset. </span><span class="koboSpan" id="kobo.806.2">Now, we have a good understanding of the feature distribution and interactions. </span><span class="koboSpan" id="kobo.806.3">Moving on, let’s perform another geospatial analysis, using and extending the tools that we already tested with the analysis of the pubs in England.</span></p>
<h2 class="heading-2" id="_idParaDest-56"><span class="koboSpan" id="kobo.807.1">Geospatial analysis</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.808.1">We start by observing the distribution of Starbucks in the world. </span><span class="koboSpan" id="kobo.808.2">We use the folium library and MarkerCluster to</span><a id="_idIndexMarker149"/><span class="koboSpan" id="kobo.809.1"> represent on a dynamic map the geospatial distribution of coffee shops in the entire world. </span><span class="koboSpan" id="kobo.809.2">The code is shown here:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.810.1">coffee_df = coffee_df.loc[(~coffee_df.Latitude.isna()) &amp; (~coffee_df.Longitude.isna())]
locations_data = np.array(coffee_df[[</span><span class="hljs-string"><span class="koboSpan" id="kobo.811.1">"Latitude"</span></span><span class="koboSpan" id="kobo.812.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.813.1">"Longitude"</span></span><span class="koboSpan" id="kobo.814.1">]])
popups = coffee_df.apply(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.815.1">lambda</span></span><span class="koboSpan" id="kobo.816.1"> row: </span><span class="hljs-string"><span class="koboSpan" id="kobo.817.1">f"Name: </span></span><span class="hljs-subst"><span class="koboSpan" id="kobo.818.1">{row[</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.819.1">'Store Name'</span></span><span class="hljs-subst"><span class="koboSpan" id="kobo.820.1">]}</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.821.1">"</span></span><span class="koboSpan" id="kobo.822.1">, axis=</span><span class="hljs-number"><span class="koboSpan" id="kobo.823.1">1</span></span><span class="koboSpan" id="kobo.824.1">)
marker_cluster = MarkerCluster(
    locations = locations_data,
)
world_coords = [</span><span class="hljs-number"><span class="koboSpan" id="kobo.825.1">0.</span></span><span class="koboSpan" id="kobo.826.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.827.1">0.</span></span><span class="koboSpan" id="kobo.828.1">]
world_map = folium.Map(location = world_coords, zoom_start = </span><span class="hljs-number"><span class="koboSpan" id="kobo.829.1">1</span></span><span class="koboSpan" id="kobo.830.1">)
marker_cluster.add_to(world_map) 
world_map
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.831.1">Folium/leaflet maps are browsable. </span><span class="koboSpan" id="kobo.831.2">We can pan, zoom in, and zoom out. </span><span class="koboSpan" id="kobo.831.3">In </span><em class="italic"><span class="koboSpan" id="kobo.832.1">Figure 4.31</span></em><span class="koboSpan" id="kobo.833.1">, we show the entire world’s distribution of coffee shops:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.834.1"><img alt="Map  Description automatically generated" src="../Images/B20963_04_31.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.835.1">Figure 4.31: Worldwide Starbucks coffee shop distribution using folium over leaflets and MarkerCluster</span></p>
<p class="normal"><span class="koboSpan" id="kobo.836.1">In </span><em class="italic"><span class="koboSpan" id="kobo.837.1">Figure 4.32</span></em><span class="koboSpan" id="kobo.838.1">, we show a zoom-in on the continental United States and Canada area. </span><span class="koboSpan" id="kobo.838.2">Clearly, the East and West</span><a id="_idIndexMarker150"/><span class="koboSpan" id="kobo.839.1"> coasts dominate Starbucks coffee shop distribution in the United States.</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.840.1"><img alt="Chart, bubble chart  Description automatically generated" src="../Images/B20963_04_32.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.841.1">Figure 4.32: Starbucks coffee shop distribution in the United States</span></p>
<p class="normal"><span class="koboSpan" id="kobo.842.1">Another way to represent the spatial distribution of Starbucks coffee shops is to use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.843.1">geopandas</span></code><span class="koboSpan" id="kobo.844.1"> plot function. </span><span class="koboSpan" id="kobo.844.2">First, we will show the number of shops per country. </span><span class="koboSpan" id="kobo.844.3">For this, we aggregate the coffee shops per country:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.845.1">coffee_agg_df = coffee_df.groupby([</span><span class="hljs-string"><span class="koboSpan" id="kobo.846.1">"Country"</span></span><span class="koboSpan" id="kobo.847.1">])[</span><span class="hljs-string"><span class="koboSpan" id="kobo.848.1">"Brand"</span></span><span class="koboSpan" id="kobo.849.1">].count().reset_index()
coffee_agg_df.columns = [</span><span class="hljs-string"><span class="koboSpan" id="kobo.850.1">"Country"</span></span><span class="koboSpan" id="kobo.851.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.852.1">"Shops"</span></span><span class="koboSpan" id="kobo.853.1">]
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.854.1">To represent the geospatial distribution with </span><code class="inlineCode"><span class="koboSpan" id="kobo.855.1">geopandas</span></code><span class="koboSpan" id="kobo.856.1">, we need to use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.857.1">ISO3</span></code><span class="koboSpan" id="kobo.858.1"> country codes (country codes with three letters). </span><span class="koboSpan" id="kobo.858.2">In the Starbucks distribution dataset, we have only </span><code class="inlineCode"><span class="koboSpan" id="kobo.859.1">ISO2</span></code><span class="koboSpan" id="kobo.860.1"> (country codes with two letters). </span><span class="koboSpan" id="kobo.860.2">We can include a dataset that contains the equivalences, or we can import a Python package that will do the conversions for us. </span><span class="koboSpan" id="kobo.860.3">We will opt for the second solution and </span><code class="inlineCode"><span class="koboSpan" id="kobo.861.1">pip install</span></code><span class="koboSpan" id="kobo.862.1">, and then import the </span><code class="inlineCode"><span class="koboSpan" id="kobo.863.1">country-conversion</span></code><span class="koboSpan" id="kobo.864.1"> Python package:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.865.1">import</span></span><span class="koboSpan" id="kobo.866.1"> geopandas </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.867.1">as</span></span><span class="koboSpan" id="kobo.868.1"> gpd
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.869.1">import</span></span><span class="koboSpan" id="kobo.870.1"> matplotlib
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.871.1">import</span></span><span class="koboSpan" id="kobo.872.1"> country_converter </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.873.1">as</span></span><span class="koboSpan" id="kobo.874.1"> cc
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.875.1"># convert ISO2 to ISO3 country codes - to be used with geopandas plot of countries</span></span><span class="koboSpan" id="kobo.876.1">
coffee_agg_df[</span><span class="hljs-string"><span class="koboSpan" id="kobo.877.1">"iso_a3"</span></span><span class="koboSpan" id="kobo.878.1">] = coffee_agg_df[</span><span class="hljs-string"><span class="koboSpan" id="kobo.879.1">"Country"</span></span><span class="koboSpan" id="kobo.880.1">].apply(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.881.1">lambda</span></span><span class="koboSpan" id="kobo.882.1"> x: cc.convert(x, to=</span><span class="hljs-string"><span class="koboSpan" id="kobo.883.1">'ISO3'</span></span><span class="koboSpan" id="kobo.884.1">))
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.885.1">Then, using </span><code class="inlineCode"><span class="koboSpan" id="kobo.886.1">geopandas</span></code><span class="koboSpan" id="kobo.887.1">, we load a dataset with polygon shapes for all countries, with low resolution. </span><span class="koboSpan" id="kobo.887.2">We then </span><a id="_idIndexMarker151"/><span class="koboSpan" id="kobo.888.1">merge the two datasets (with shops and polygons):</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.889.1">world = gpd.read_file(gpd.datasets.get_path(</span><span class="hljs-string"><span class="koboSpan" id="kobo.890.1">'naturalearth_lowres'</span></span><span class="koboSpan" id="kobo.891.1">))
world_shop = world.merge(coffee_agg_df, on=</span><span class="hljs-string"><span class="koboSpan" id="kobo.892.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.893.1">iso_a3"</span></span><span class="koboSpan" id="kobo.894.1">, how=</span><span class="hljs-string"><span class="koboSpan" id="kobo.895.1">"right"</span></span><span class="koboSpan" id="kobo.896.1">)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.897.1">Before displaying the country polygons, with the fill color adjusted to represent proportionally the number of Starbucks coffee shops in the current country, we will display a wireframe with all the countries so that we can also see on the map the countries without Starbucks:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.898.1">world_shop.loc[world_shop.Shops.isna(), </span><span class="hljs-string"><span class="koboSpan" id="kobo.899.1">"Shops"</span></span><span class="koboSpan" id="kobo.900.1">] = </span><span class="hljs-number"><span class="koboSpan" id="kobo.901.1">0</span></span><span class="koboSpan" id="kobo.902.1">
f, ax = plt.subplots(</span><span class="hljs-number"><span class="koboSpan" id="kobo.903.1">1</span></span><span class="koboSpan" id="kobo.904.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.905.1">1</span></span><span class="koboSpan" id="kobo.906.1">, figsize=(</span><span class="hljs-number"><span class="koboSpan" id="kobo.907.1">12</span></span><span class="koboSpan" id="kobo.908.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.909.1">5</span></span><span class="koboSpan" id="kobo.910.1">))
world_cp = world.copy()
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.911.1">With </span><code class="inlineCode"><span class="koboSpan" id="kobo.912.1">geopandas</span></code><span class="koboSpan" id="kobo.913.1">, we can apply a logarithmic colormap, which helps in representing the total number of Starbucks coffee shops across countries with a skewed distribution more effectively. </span><span class="koboSpan" id="kobo.913.2">It ensures a well-distributed color scheme, allowing us to differentiate between countries with a smaller number of coffee shops and those at the top in this regard. </span><span class="koboSpan" id="kobo.913.3">We also draw some of the latitude lines:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.914.1"># transform, in the copied data, the projection in Cylindrical equal-area,</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.915.1"># which preserves the areas </span></span><span class="koboSpan" id="kobo.916.1">
world_cp= world_cp.to_crs({</span><span class="hljs-string"><span class="koboSpan" id="kobo.917.1">'proj'</span></span><span class="koboSpan" id="kobo.918.1">:</span><span class="hljs-string"><span class="koboSpan" id="kobo.919.1">'cea'</span></span><span class="koboSpan" id="kobo.920.1">})
world_cp[</span><span class="hljs-string"><span class="koboSpan" id="kobo.921.1">"area"</span></span><span class="koboSpan" id="kobo.922.1">] = world_cp[</span><span class="hljs-string"><span class="koboSpan" id="kobo.923.1">'geometry'</span></span><span class="koboSpan" id="kobo.924.1">].area / </span><span class="hljs-number"><span class="koboSpan" id="kobo.925.1">10</span></span><span class="koboSpan" id="kobo.926.1">**</span><span class="hljs-number"><span class="koboSpan" id="kobo.927.1">6</span></span> <span class="hljs-comment"><span class="koboSpan" id="kobo.928.1"># km^2</span></span><span class="koboSpan" id="kobo.929.1">
world[</span><span class="hljs-string"><span class="koboSpan" id="kobo.930.1">"area"</span></span><span class="koboSpan" id="kobo.931.1">] = world_cp[</span><span class="hljs-string"><span class="koboSpan" id="kobo.932.1">"area"</span></span><span class="koboSpan" id="kobo.933.1">]=</span><span class="hljs-string"><span class="koboSpan" id="kobo.934.1">'black'</span></span><span class="koboSpan" id="kobo.935.1">, linewidth=</span><span class="hljs-number"><span class="koboSpan" id="kobo.936.1">0.25</span></span><span class="koboSpan" id="kobo.937.1">, ax=ax) 
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.938.1"># draw countries polygons with log scale colormap</span></span><span class="koboSpan" id="kobo.939.1">
world_shop.plot(column=</span><span class="hljs-string"><span class="koboSpan" id="kobo.940.1">'Shops'</span></span><span class="koboSpan" id="kobo.941.1">, legend=</span><span class="hljs-literal"><span class="koboSpan" id="kobo.942.1">True</span></span><span class="koboSpan" id="kobo.943.1">,\
           norm=matplotlib.colors.LogNorm(vmin=world_shop.Shops.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.944.1">min</span></span><span class="koboSpan" id="kobo.945.1">(),\
                                          vmax=world_shop.Shops.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.946.1">max</span></span><span class="koboSpan" id="kobo.947.1">()), 
           cmap=</span><span class="hljs-string"><span class="koboSpan" id="kobo.948.1">"rainbow"</span></span><span class="koboSpan" id="kobo.949.1">,
           ax=ax)
plt.grid(color=</span><span class="hljs-string"><span class="koboSpan" id="kobo.950.1">"black"</span></span><span class="koboSpan" id="kobo.951.1">, linestyle=</span><span class="hljs-string"><span class="koboSpan" id="kobo.952.1">":"</span></span><span class="koboSpan" id="kobo.953.1">, linewidth=</span><span class="hljs-number"><span class="koboSpan" id="kobo.954.1">0.1</span></span><span class="koboSpan" id="kobo.955.1">, axis=</span><span class="hljs-string"><span class="koboSpan" id="kobo.956.1">"y"</span></span><span class="koboSpan" id="kobo.957.1">, which=</span><span class="hljs-string"><span class="koboSpan" id="kobo.958.1">"major"</span></span><span class="koboSpan" id="kobo.959.1">)
plt.xlabel(</span><span class="hljs-string"><span class="koboSpan" id="kobo.960.1">"Longitude"</span></span><span class="koboSpan" id="kobo.961.1">); plt.ylabel(</span><span class="hljs-string"><span class="koboSpan" id="kobo.962.1">"Latitude"</span></span><span class="koboSpan" id="kobo.963.1">)
plt.title(</span><span class="hljs-string"><span class="koboSpan" id="kobo.964.1">"Starbucks coffee shops distribution at country level"</span></span><span class="koboSpan" id="kobo.965.1">)
plt.show()
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.966.1">This map is informative, but these countries have very different areas, populations, and population densities. </span><span class="koboSpan" id="kobo.966.2">To understand better the density of Starbucks coffee shops, we will also plot the number </span><a id="_idIndexMarker152"/><span class="koboSpan" id="kobo.967.1">of shops per million citizens (for each country) and the number of shops per 1,000 square kilometers.</span></p>
<p class="packt_figref"><span class="koboSpan" id="kobo.968.1"><img alt="" role="presentation" src="../Images/B20963_04_33.png"/></span></p>
<p class="packt_figref"><span class="koboSpan" id="kobo.969.1">Figure 4.33: geopandas map showing the coffee shop density (the log scale) at the world level</span></p>
<p class="normal"><span class="koboSpan" id="kobo.970.1">For the preceding map, we chose </span><code class="inlineCode"><span class="koboSpan" id="kobo.971.1">geopanda</span></code><span class="koboSpan" id="kobo.972.1">s precisely because it allows us to represent regions with color intensity on a logarithmic scale.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.973.1">In the </span><code class="inlineCode"><span class="koboSpan" id="kobo.974.1">world</span></code><span class="koboSpan" id="kobo.975.1"> dataset, we have the population estimate but we do not have the country area information. </span><span class="koboSpan" id="kobo.975.2">To calculate the Starbucks density per square kilometers, we need to also include the area. </span><span class="koboSpan" id="kobo.975.3">We can include a new dataset, with the country area, or we can use the features of </span><code class="inlineCode"><span class="koboSpan" id="kobo.976.1">geopandas</span></code><span class="koboSpan" id="kobo.977.1"> to obtain the area from the polygons. </span><span class="koboSpan" id="kobo.977.2">With the current Mercator projection adapted to display the map in a way that is legible, the area is not calculated correctly.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.978.1">We will copy the </span><code class="inlineCode"><span class="koboSpan" id="kobo.979.1">world</span></code><span class="koboSpan" id="kobo.980.1"> dataset so that the transformation does not distort the polygons in the Mercator projection. </span><span class="koboSpan" id="kobo.980.2">We will</span><a id="_idIndexMarker153"/><span class="koboSpan" id="kobo.981.1"> then apply the transformation on the copy using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.982.1">Cylindrical equal-area</span></code><span class="koboSpan" id="kobo.983.1"> projection. </span><span class="koboSpan" id="kobo.983.2">This projection preserves the areas, and this is what we need for our calculations. </span><span class="koboSpan" id="kobo.983.3">After we perform the transformation, we concatenate the area to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.984.1">world</span></code><span class="koboSpan" id="kobo.985.1"> dataset:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.986.1">world_cp = world.copy()
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.987.1"># transform, in the copied data, the projection in Cylindrical equal-area,</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.988.1"># which preserves the areas </span></span><span class="koboSpan" id="kobo.989.1">
world_cp= world_cp.to_crs({</span><span class="hljs-string"><span class="koboSpan" id="kobo.990.1">'proj'</span></span><span class="koboSpan" id="kobo.991.1">:</span><span class="hljs-string"><span class="koboSpan" id="kobo.992.1">'cea'</span></span><span class="koboSpan" id="kobo.993.1">})
world_cp[</span><span class="hljs-string"><span class="koboSpan" id="kobo.994.1">"area"</span></span><span class="koboSpan" id="kobo.995.1">] = world_cp[</span><span class="hljs-string"><span class="koboSpan" id="kobo.996.1">'geometry'</span></span><span class="koboSpan" id="kobo.997.1">].area / </span><span class="hljs-number"><span class="koboSpan" id="kobo.998.1">10</span></span><span class="koboSpan" id="kobo.999.1">**</span><span class="hljs-number"><span class="koboSpan" id="kobo.1000.1">6</span></span> <span class="hljs-comment"><span class="koboSpan" id="kobo.1001.1"># km^2</span></span><span class="koboSpan" id="kobo.1002.1">
world[</span><span class="hljs-string"><span class="koboSpan" id="kobo.1003.1">"area"</span></span><span class="koboSpan" id="kobo.1004.1">] = world_cp[</span><span class="hljs-string"><span class="koboSpan" id="kobo.1005.1">"area"</span></span><span class="koboSpan" id="kobo.1006.1">]
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1007.1">Let’s verify that we have calculated the area correctly. </span><span class="koboSpan" id="kobo.1007.2">We sample a few countries, and we verify that the areas match official records:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1008.1">world.loc[world.iso_a3.isin([</span><span class="hljs-string"><span class="koboSpan" id="kobo.1009.1">"GBR"</span></span><span class="koboSpan" id="kobo.1010.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1011.1">"USA"</span></span><span class="koboSpan" id="kobo.1012.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1013.1">"ROU"</span></span><span class="koboSpan" id="kobo.1014.1">])]
</span></code></pre>
<p class="packt_figref"><span class="koboSpan" id="kobo.1015.1"><img alt="Graphical user interface, table, calendar  Description automatically generated with medium confidence" src="../Images/B20963_04_34.png"/></span></p>
<p class="packt_figref"><span class="koboSpan" id="kobo.1016.1">Figure 4.34: Area verification for the United States of America, Romania, and the UK</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1017.1">As you can see, for all the countries, the calculated area with the method used yielded correct surfaces that match the values in official records.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1018.1">Now, we have all we need to prepare and display the maps with Starbucks densities per country, relative to area and population. </span><span class="koboSpan" id="kobo.1018.2">The code for the calculation of the Starbucks densities is as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1019.1">world_shop = world.merge(coffee_agg_df, on=</span><span class="hljs-string"><span class="koboSpan" id="kobo.1020.1">"iso_a3"</span></span><span class="koboSpan" id="kobo.1021.1">, how=</span><span class="hljs-string"><span class="koboSpan" id="kobo.1022.1">"right"</span></span><span class="koboSpan" id="kobo.1023.1">)
world_shop[</span><span class="hljs-string"><span class="koboSpan" id="kobo.1024.1">"Shops / Population"</span></span><span class="koboSpan" id="kobo.1025.1">] = world_shop[</span><span class="hljs-string"><span class="koboSpan" id="kobo.1026.1">"Shops"</span></span><span class="koboSpan" id="kobo.1027.1">] / world_shop[</span><span class="hljs-string"><span class="koboSpan" id="kobo.1028.1">"pop_est"</span></span><span class="koboSpan" id="kobo.1029.1">] * </span><span class="hljs-number"><span class="koboSpan" id="kobo.1030.1">10</span></span><span class="koboSpan" id="kobo.1031.1">**</span><span class="hljs-number"><span class="koboSpan" id="kobo.1032.1">6</span></span> <span class="hljs-comment"><span class="koboSpan" id="kobo.1033.1"># shops/1 million population</span></span><span class="koboSpan" id="kobo.1034.1">
world_shop[</span><span class="hljs-string"><span class="koboSpan" id="kobo.1035.1">"Shops / Area"</span></span><span class="koboSpan" id="kobo.1036.1">] = world_shop[</span><span class="hljs-string"><span class="koboSpan" id="kobo.1037.1">"Shops"</span></span><span class="koboSpan" id="kobo.1038.1">] / world_shop[</span><span class="hljs-string"><span class="koboSpan" id="kobo.1039.1">"area"</span></span><span class="koboSpan" id="kobo.1040.1">] * </span><span class="hljs-number"><span class="koboSpan" id="kobo.1041.1">10</span></span><span class="koboSpan" id="kobo.1042.1">**</span><span class="hljs-number"><span class="koboSpan" id="kobo.1043.1">3.</span></span> <span class="hljs-comment"><span class="koboSpan" id="kobo.1044.1"># shops / 1000 Km^2</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1045.1">Then, using the following </span><a id="_idIndexMarker154"/><span class="koboSpan" id="kobo.1046.1">code, we draw the distribution of Starbucks per 1 million people at the country level:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1047.1">f, ax = plt.subplots(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1048.1">1</span></span><span class="koboSpan" id="kobo.1049.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1050.1">1</span></span><span class="koboSpan" id="kobo.1051.1">, figsize=(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1052.1">12</span></span><span class="koboSpan" id="kobo.1053.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1054.1">5</span></span><span class="koboSpan" id="kobo.1055.1">))
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.1056.1"># show all countries contour with black and color while</span></span><span class="koboSpan" id="kobo.1057.1">
world.plot(column=</span><span class="hljs-literal"><span class="koboSpan" id="kobo.1058.1">None</span></span><span class="koboSpan" id="kobo.1059.1">, color=</span><span class="hljs-string"><span class="koboSpan" id="kobo.1060.1">"white"</span></span><span class="koboSpan" id="kobo.1061.1">, edgecolor=</span><span class="hljs-string"><span class="koboSpan" id="kobo.1062.1">'black'</span></span><span class="koboSpan" id="kobo.1063.1">, linewidth=</span><span class="hljs-number"><span class="koboSpan" id="kobo.1064.1">0.25</span></span><span class="koboSpan" id="kobo.1065.1">, ax=ax) 
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.1066.1"># draw countries polygons</span></span><span class="koboSpan" id="kobo.1067.1">
world_shop.plot(column=</span><span class="hljs-string"><span class="koboSpan" id="kobo.1068.1">'Shops / Population'</span></span><span class="koboSpan" id="kobo.1069.1">, legend=</span><span class="hljs-literal"><span class="koboSpan" id="kobo.1070.1">True</span></span><span class="koboSpan" id="kobo.1071.1">,\
           cmap=</span><span class="hljs-string"><span class="koboSpan" id="kobo.1072.1">"rainbow"</span></span><span class="koboSpan" id="kobo.1073.1">,
           ax=ax)
plt.grid(color=</span><span class="hljs-string"><span class="koboSpan" id="kobo.1074.1">"black"</span></span><span class="koboSpan" id="kobo.1075.1">, linestyle=</span><span class="hljs-string"><span class="koboSpan" id="kobo.1076.1">":"</span></span><span class="koboSpan" id="kobo.1077.1">, linewidth=</span><span class="hljs-number"><span class="koboSpan" id="kobo.1078.1">0.1</span></span><span class="koboSpan" id="kobo.1079.1">, axis=</span><span class="hljs-string"><span class="koboSpan" id="kobo.1080.1">"y"</span></span><span class="koboSpan" id="kobo.1081.1">, which=</span><span class="hljs-string"><span class="koboSpan" id="kobo.1082.1">"major"</span></span><span class="koboSpan" id="kobo.1083.1">)
plt.xlabel(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1084.1">"Longitude"</span></span><span class="koboSpan" id="kobo.1085.1">); plt.ylabel(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1086.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1087.1">Latitude"</span></span><span class="koboSpan" id="kobo.1088.1">)
plt.title(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1089.1">"Starbucks coffee shops / 1 million population - distribution at country level"</span></span><span class="koboSpan" id="kobo.1090.1">)
plt.show()
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1091.1">We show the graph drawn with the preceding code in </span><em class="italic"><span class="koboSpan" id="kobo.1092.1">Figure 4.35</span></em><span class="koboSpan" id="kobo.1093.1">. </span><span class="koboSpan" id="kobo.1093.2">The countries with the highest number of Starbucks per million people are the United States, Canada, and the United Emirates, followed by Taiwan, South Korea, the UK, and Japan.</span></p>
<p class="packt_figref"><span class="koboSpan" id="kobo.1094.1"><img alt="A picture containing chart  Description automatically generated" src="../Images/B20963_04_35.png"/></span></p>
<p class="packt_figref"><span class="koboSpan" id="kobo.1095.1">Figure 4.35: Starbucks per 1 million people – distribution per country</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1096.1">For each country, the number of Starbucks coffee shops per 1,000 square kilometers is displayed in the following </span><a id="_idIndexMarker155"/><span class="koboSpan" id="kobo.1097.1">figure:</span></p>
<p class="packt_figref"><span class="koboSpan" id="kobo.1098.1"><img alt="A picture containing chart  Description automatically generated" src="../Images/B20963_04_36.png"/></span></p>
<p class="packt_figref"><span class="koboSpan" id="kobo.1099.1">Figure 4.36: Starbucks per 1,000 square kilometers – distribution per country</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1100.1">We can see that the highest concentration of coffee shops is in countries like South Korea, Taiwan, Japan, and the UK.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1101.1">Let’s do a quick summary to wrap up this section. </span><span class="koboSpan" id="kobo.1101.2">We analyzed the two datasets with pubs in England and Starbucks worldwide to get a good understanding of the data distribution in the two datasets. </span><span class="koboSpan" id="kobo.1101.3">We also introduced several techniques and tools for geospatial data manipulation and analysis. </span><span class="koboSpan" id="kobo.1101.4">We learned how to draw shapefile data, how to extract polygons from a shapefile, how to clip polygon sets using another set of polygons, and how to generate Voronoi polygons. </span><span class="koboSpan" id="kobo.1101.5">This was all preparation for the main part of the analysis in this chapter, where we will combine the two datasets and learn how to generate multi-layer maps, where the information from the two datasets is combined creatively. </span><span class="koboSpan" id="kobo.1101.6">Our goal is twofold: to introduce you to more advanced ways to analyze geospatial data, and to use creatively the methods introduced to see how we can get insights from both data sources, once combined.</span></p>
<h1 class="heading-1" id="_idParaDest-57"><span class="koboSpan" id="kobo.1102.1">Pubs and Starbucks in London</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1103.1">Until now, our analysis was focused on the individual datasets </span><code class="inlineCode"><span class="koboSpan" id="kobo.1104.1">Every Pub in England</span></code><span class="koboSpan" id="kobo.1105.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1106.1">Starbucks Locations Worldwide</span></code><span class="koboSpan" id="kobo.1107.1">. </span><span class="koboSpan" id="kobo.1107.2">To support some of the data analysis tasks related to these two separate datasets, we have also added two more datasets, one with the geographical position of postal </span><a id="_idIndexMarker156"/><span class="koboSpan" id="kobo.1108.1">codes, replacing the missing latitude and longitude data, and one with shapefile data for the UK to clip the Voronoi polygons generated from pubs’ positions, aligning them with the land contour of the island.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1109.1">In the current section, we will combine the information from the two main data sources analyzed separately and apply methods developed during this preliminary analysis, supporting the objective of our study. </span><span class="koboSpan" id="kobo.1109.2">This will focus on a smaller region, where we have both a high density of pubs and a concentration of Starbucks coffee shops, in London. </span><span class="koboSpan" id="kobo.1109.3">We can already hypothesize that the geospatial concentration of Starbucks is smaller than the concentration of pubs.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1110.1">We would like to see where the closest Starbucks is so that we can sober up with a coffee after we’ve had a few pints of ale. </span><span class="koboSpan" id="kobo.1110.2">We already learned that Voronoi polygons have an interesting characteristic – any point inside a polygon is closer to its center than to any neighboring center. </span><span class="koboSpan" id="kobo.1110.3">We will represent the pub locations in the London area, superposed over the Voronoi polygons generated from the Starbucks locations in the same area.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1111.1">The notebook associated with this section is </span><code class="inlineCode"><span class="koboSpan" id="kobo.1112.1">Coffee or Beer in London – Your Choice!</span></code><span class="koboSpan" id="kobo.1113.1">, (see </span><em class="italic"><span class="koboSpan" id="kobo.1114.1">Reference 11</span></em><span class="koboSpan" id="kobo.1115.1">). </span><span class="koboSpan" id="kobo.1115.2">You might find it useful to follow the notebook along with the text in this section.</span></p>
<h2 class="heading-2" id="_idParaDest-58"><span class="koboSpan" id="kobo.1116.1">Data preparation</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1117.1">We start by reading the CSV files from the two datasets, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1118.1">Every Pub in England</span></code><span class="koboSpan" id="kobo.1119.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1120.1">Starbucks Locations Worldwide</span></code><span class="koboSpan" id="kobo.1121.1">. </span><span class="koboSpan" id="kobo.1121.2">We </span><a id="_idIndexMarker157"/><span class="koboSpan" id="kobo.1122.1">also now read the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1123.1">GBR_adm2.shp</span></code><span class="koboSpan" id="kobo.1124.1"> shapefile (with Great Britain local authorities’ borders data) from </span><code class="inlineCode"><span class="koboSpan" id="kobo.1125.1">GDM Data for the UK</span></code><span class="koboSpan" id="kobo.1126.1"> and the data from </span><code class="inlineCode"><span class="koboSpan" id="kobo.1127.1">Open Postcode Geo</span></code><span class="koboSpan" id="kobo.1128.1">. </span><span class="koboSpan" id="kobo.1128.2">In this last file, we just filter four columns (postcode, country, latitude, and longitude).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1129.1">From the pub data, we only select the </span><a id="_idIndexMarker158"/><span class="koboSpan" id="kobo.1130.1">entries that have as a local authority one of the 32 London boroughs. </span><span class="koboSpan" id="kobo.1130.2">We add to this subset the City of London, which is not one of the boroughs. </span><span class="koboSpan" id="kobo.1130.3">The City of London is in the center of London, and some of the pubs are located there, which we would like to include. </span><span class="koboSpan" id="kobo.1130.4">We use the same list to filter the data in the shapefile data. </span><span class="koboSpan" id="kobo.1130.5">To check that we have correctly selected all the shapefile data, we display the boroughs (and the City of London) polygons:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1131.1">boroughs_df = counties_df.loc[counties_df.NAME_2.isin(london_boroughs)]
boroughs_df.plot(color=color_list[</span><span class="hljs-number"><span class="koboSpan" id="kobo.1132.1">0</span></span><span class="koboSpan" id="kobo.1133.1">], edgecolor=color_list[</span><span class="hljs-number"><span class="koboSpan" id="kobo.1134.1">4</span></span><span class="koboSpan" id="kobo.1135.1">])
plt.show()
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1136.1">In the following figure, observe that the City of London is missing (left). </span><span class="koboSpan" id="kobo.1136.2">We have London in shapefile names, so we will just </span><a id="_idIndexMarker159"/><span class="koboSpan" id="kobo.1137.1">replace London with the City of London in the shapefile data. </span><span class="koboSpan" id="kobo.1137.2">After the correction (right), we can see that by unifying the notation for the City of London, we now have all local authorities correctly represented on our map. </span><span class="koboSpan" id="kobo.1137.3">Now, we have selected all </span><a id="_idIndexMarker160"/><span class="koboSpan" id="kobo.1138.1">areas that we want to include in our analysis of pubs and Starbucks coffee shops in the London area.</span></p>
<p class="packt_figref"><span class="koboSpan" id="kobo.1139.1"><img alt="" role="presentation" src="../Images/B20963_04_37.png"/></span></p>
<p class="packt_figref"><span class="koboSpan" id="kobo.1140.1">Figure 4.37: London boroughs (left) and the London boroughs and the City of London (right)</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1141.1">We also select Starbucks coffee shop data for the same sub-regions. </span><span class="koboSpan" id="kobo.1141.2">For Starbucks data, the selection is shown in the following code:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1142.1">coffee_df = coffee_df.loc[(coffee_df.City.isin(london_boroughs + [</span><span class="hljs-string"><span class="koboSpan" id="kobo.1143.1">"London"</span></span><span class="koboSpan" id="kobo.1144.1">])) &amp;\
             (coffee_df.Country==</span><span class="hljs-string"><span class="koboSpan" id="kobo.1145.1">"GB"</span></span><span class="koboSpan" id="kobo.1146.1">)]
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1147.1">We incorporate country information into the filtering criteria because London and the names of various other London boroughs are found across North America, where many cities borrow names from Great Britain.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1148.1">We are aware, based on our previous analysis of the pub data, that some pubs have missing latitude and longitude, marked with </span><strong class="screenText"><span class="koboSpan" id="kobo.1149.1">\\N</span></strong><span class="koboSpan" id="kobo.1150.1">. </span><span class="koboSpan" id="kobo.1150.2">Carry out the same transformations, including merging with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1151.1">Open Postcode Geo</span></code><span class="koboSpan" id="kobo.1152.1"> data and cleaning, as discussed in the previous subsection for these pub </span><a id="_idIndexMarker161"/><span class="koboSpan" id="kobo.1153.1">rows. </span><span class="koboSpan" id="kobo.1153.2">This process will involve assigning latitude and longitude data based on postcode matching.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1154.1">Then, using the following </span><a id="_idIndexMarker162"/><span class="koboSpan" id="kobo.1155.1">code, we check that the pubs and Starbucks selected with the preceding criteria are all within the boundaries (or very close to those) of the London boroughs:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1156.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1157.1">verify_data_availability</span></span><span class="koboSpan" id="kobo.1158.1">():
    f, ax = plt.subplots(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1159.1">1</span></span><span class="koboSpan" id="kobo.1160.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1161.1">1</span></span><span class="koboSpan" id="kobo.1162.1">, figsize=(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1163.1">10</span></span><span class="koboSpan" id="kobo.1164.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1165.1">10</span></span><span class="koboSpan" id="kobo.1166.1">))
    boroughs_df.plot(color=</span><span class="hljs-string"><span class="koboSpan" id="kobo.1167.1">"white"</span></span><span class="koboSpan" id="kobo.1168.1">, edgecolor=color_list[</span><span class="hljs-number"><span class="koboSpan" id="kobo.1169.1">4</span></span><span class="koboSpan" id="kobo.1170.1">], ax=ax)
    plt.scatter(x=pub_df[</span><span class="hljs-string"><span class="koboSpan" id="kobo.1171.1">"longitude"</span></span><span class="koboSpan" id="kobo.1172.1">],y=pub_df[</span><span class="hljs-string"><span class="koboSpan" id="kobo.1173.1">"latitude"</span></span><span class="koboSpan" id="kobo.1174.1">], color=color_list[</span><span class="hljs-number"><span class="koboSpan" id="kobo.1175.1">0</span></span><span class="koboSpan" id="kobo.1176.1">], marker=</span><span class="hljs-string"><span class="koboSpan" id="kobo.1177.1">"+"</span></span><span class="koboSpan" id="kobo.1178.1">, label=</span><span class="hljs-string"><span class="koboSpan" id="kobo.1179.1">"Pubs"</span></span><span class="koboSpan" id="kobo.1180.1">)
    plt.scatter(x=coffee_df[</span><span class="hljs-string"><span class="koboSpan" id="kobo.1181.1">"Longitude"</span></span><span class="koboSpan" id="kobo.1182.1">],y=coffee_df[</span><span class="hljs-string"><span class="koboSpan" id="kobo.1183.1">"Latitude"</span></span><span class="koboSpan" id="kobo.1184.1">], color=color_list[</span><span class="hljs-number"><span class="koboSpan" id="kobo.1185.1">5</span></span><span class="koboSpan" id="kobo.1186.1">], marker=</span><span class="hljs-string"><span class="koboSpan" id="kobo.1187.1">"o"</span></span><span class="koboSpan" id="kobo.1188.1">, label=</span><span class="hljs-string"><span class="koboSpan" id="kobo.1189.1">"Starbucks"</span></span><span class="koboSpan" id="kobo.1190.1">)
    plt.xlabel(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1191.1">"Longitude"</span></span><span class="koboSpan" id="kobo.1192.1">); plt.ylabel(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1193.1">"Latitude"</span></span><span class="koboSpan" id="kobo.1194.1">); plt.title(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1195.1">"London boroughs - verify data availability"</span></span><span class="koboSpan" id="kobo.1196.1">)
    plt.grid(color=</span><span class="hljs-string"><span class="koboSpan" id="kobo.1197.1">"black"</span></span><span class="koboSpan" id="kobo.1198.1">, linestyle=</span><span class="hljs-string"><span class="koboSpan" id="kobo.1199.1">":"</span></span><span class="koboSpan" id="kobo.1200.1">, linewidth=</span><span class="hljs-number"><span class="koboSpan" id="kobo.1201.1">0.1</span></span><span class="koboSpan" id="kobo.1202.1">, axis=</span><span class="hljs-string"><span class="koboSpan" id="kobo.1203.1">"both"</span></span><span class="koboSpan" id="kobo.1204.1">, which=</span><span class="hljs-string"><span class="koboSpan" id="kobo.1205.1">"major"</span></span><span class="koboSpan" id="kobo.1206.1">)
    plt.legend()
    plt.show()
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1207.1">We observe that there are two Starbucks that are quite remote from London. </span><span class="koboSpan" id="kobo.1207.2">We set an additional condition for the selected Starbucks:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1208.1">coffee_df = coffee_df.loc[coffee_df.Latitude&lt;=</span><span class="hljs-number"><span class="koboSpan" id="kobo.1209.1">51.7</span></span><span class="koboSpan" id="kobo.1210.1">]
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1211.1">In the resulting figure, you’ll see the pubs (cross) and Starbucks (points) in the London boroughs and the City of London, after filtering items outside these local authorities’ zones and correcting the misattributions.</span></p>
<p class="packt_figref"><span class="koboSpan" id="kobo.1212.1"><img alt="" role="presentation" src="../Images/B20963_04_38.png"/></span></p>
<p class="packt_figref"><span class="koboSpan" id="kobo.1213.1">Figure 4.38: Pubs (cross) and Starbucks (points) in the London boroughs and the City of London after filtering items</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1214.1">There are still a few points outside the boundaries, but for now, we should be fine. </span><span class="koboSpan" id="kobo.1214.2">These points will be filtered </span><a id="_idIndexMarker163"/><span class="koboSpan" id="kobo.1215.1">out once we use the local authority polygons to clip the Voronoi polygons associated with each pub and coffee shop. </span><span class="koboSpan" id="kobo.1215.2">We observed a strange artifact regarding the alignment of </span><a id="_idIndexMarker164"/><span class="koboSpan" id="kobo.1216.1">Starbucks. </span><span class="koboSpan" id="kobo.1216.2">All Starbucks shops seem to be aligned horizontally. </span><span class="koboSpan" id="kobo.1216.3">This is because Starbucks positions are given with only two decimals (Starbucks coffee shops are from a global geolocation dataset, where the location is given with smaller precision), while the pubs are given six decimals. </span><span class="koboSpan" id="kobo.1216.4">Consequently, the Starbucks shops appear to be aligned. </span><span class="koboSpan" id="kobo.1216.5">Their positions are rounded to two decimals, and due to the close position of the coffee shops, they appear to be aligned, especially along the latitude lines.</span></p>
<h2 class="heading-2" id="_idParaDest-59"><span class="koboSpan" id="kobo.1217.1">Geospatial analysis</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1218.1">Now, let’s represent the Voronoi polygons for pubs and Starbucks shops in London and its boroughs. </span><span class="koboSpan" id="kobo.1218.2">We start by generating those polygons, using the same code we used before for our data analysis</span><a id="_idIndexMarker165"/><span class="koboSpan" id="kobo.1219.1"> on </span><code class="inlineCode"><span class="koboSpan" id="kobo.1220.1">Every Pub in England</span></code><span class="koboSpan" id="kobo.1221.1">. </span><span class="koboSpan" id="kobo.1221.2">First, let’s do the pubs in the area. </span><span class="koboSpan" id="kobo.1221.3">The code in the notebook is now more compact, since </span><a id="_idIndexMarker166"/><span class="koboSpan" id="kobo.1222.1">we are using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1223.1">geospatial_utils</span></code><span class="koboSpan" id="kobo.1224.1"> utility script. </span><span class="koboSpan" id="kobo.1224.2">The following code generates the object with the Voronoi polygons collection and then visualizes the collection:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1225.1">pub_voronoi = get_voronoi_polygons(pub_df)
plot_voronoi_polygons(pub_voronoi, 
                      title=</span><span class="hljs-string"><span class="koboSpan" id="kobo.1226.1">"Voronoi polygons from pubs locations in London"</span></span><span class="koboSpan" id="kobo.1227.1">,
                      lat_limits=[</span><span class="hljs-number"><span class="koboSpan" id="kobo.1228.1">51.2</span></span><span class="koboSpan" id="kobo.1229.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1230.1">51.7</span></span><span class="koboSpan" id="kobo.1231.1">],
                      long_limits=[-</span><span class="hljs-number"><span class="koboSpan" id="kobo.1232.1">0.5</span></span><span class="koboSpan" id="kobo.1233.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1234.1">0.3</span></span><span class="koboSpan" id="kobo.1235.1">])
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1236.1">For this, the preceding code uses two functions defined in </span><code class="inlineCode"><span class="koboSpan" id="kobo.1237.1">geospatial_utils</span></code><span class="koboSpan" id="kobo.1238.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1239.1">The first function, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1240.1">get_voronoi_polygons</span></code><span class="koboSpan" id="kobo.1241.1">, creates a list of Voronoi polygons from a list of points, with the </span><em class="italic"><span class="koboSpan" id="kobo.1242.1">x</span></em><span class="koboSpan" id="kobo.1243.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.1244.1">y</span></em><span class="koboSpan" id="kobo.1245.1"> coordinates representing the longitude and latitude, respectively. </span><span class="koboSpan" id="kobo.1245.2">To do this, it uses the Voronoi function in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1246.1">scipy.spatial</span></code><span class="koboSpan" id="kobo.1247.1"> library:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1248.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1249.1">get_voronoi_polygons</span></span><span class="koboSpan" id="kobo.1250.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.1251.1">data_df, latitude=</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1252.1">"latitude"</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1253.1">, longitude=</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1254.1">"longitude"</span></span><span class="koboSpan" id="kobo.1255.1">):
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.1256.1">"""</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1257.1">    Create a list of Voronoi polygons from a list of points</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1258.1">    Args</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1259.1">        data_df: dataframe containing lat/long</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1260.1">        latitude: latitude feature</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1261.1">        longitude: longitude feature</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1262.1">    Returns</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1263.1">        Voronoi polygons graph (points, polygons) from the seed points in data_df</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1264.1">        (a scipy.spatial.Voronoi object)</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1265.1">    """</span></span><span class="koboSpan" id="kobo.1266.1">
    
    locations_data = np.array(data_df[[latitude, longitude]].astype(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1267.1">float</span></span><span class="koboSpan" id="kobo.1268.1">))
    data_voronoi = [[x[</span><span class="hljs-number"><span class="koboSpan" id="kobo.1269.1">1</span></span><span class="koboSpan" id="kobo.1270.1">], x[</span><span class="hljs-number"><span class="koboSpan" id="kobo.1271.1">0</span></span><span class="koboSpan" id="kobo.1272.1">]] </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1273.1">for</span></span><span class="koboSpan" id="kobo.1274.1"> x </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1275.1">in</span></span><span class="koboSpan" id="kobo.1276.1"> locations_data]
    voronoi_polygons = Voronoi(data_voronoi)
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1277.1">print</span></span><span class="koboSpan" id="kobo.1278.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1279.1">f"Voronoi polygons: </span></span><span class="hljs-subst"><span class="koboSpan" id="kobo.1280.1">{</span></span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1281.1">len</span></span><span class="hljs-subst"><span class="koboSpan" id="kobo.1282.1">(voronoi_polygons.points)}</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1283.1">"</span></span><span class="koboSpan" id="kobo.1284.1">)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1285.1">return</span></span><span class="koboSpan" id="kobo.1286.1"> voronoi_polygons
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1287.1">The second function, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1288.1">plot_voronoi_polygons</span></code><span class="koboSpan" id="kobo.1289.1">, plots a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1290.1">spacy.spatial.Voronoi</span></code><span class="koboSpan" id="kobo.1291.1"> object, which is a collection of Voronoi </span><a id="_idIndexMarker167"/><span class="koboSpan" id="kobo.1292.1">polygons:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1293.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1294.1">plot_voronoi_polygons</span></span><span class="koboSpan" id="kobo.1295.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.1296.1">voronoi_polygons, title, lat_limits, long_limits</span></span><span class="koboSpan" id="kobo.1297.1">):
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.1298.1">"""</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1299.1">    Plot Voronoi polygons (visualization tool)</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1300.1">    Args</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1301.1">        voronoi_polygons: Voronoi polygons object (a scipy.spatial.Voronoi object)</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1302.1">        title: graph title</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1303.1">        lat_limits: graph latitude (y) limits</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1304.1">        long_limits: graph longitude (x) limits</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1305.1">    Returns</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1306.1">        None</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1307.1">    """</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1308.1"># do not show the vertices, only show edges and centers</span></span><span class="koboSpan" id="kobo.1309.1">
    fig = voronoi_plot_2d(voronoi_polygons,
                     show_vertices=</span><span class="hljs-literal"><span class="koboSpan" id="kobo.1310.1">False</span></span><span class="koboSpan" id="kobo.1311.1">)
    plt.xlim(long_limits)
    plt.ylim(lat_limits)    
    plt.title(title)
    plt.show()
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1312.1">The collection of polygons </span><a id="_idIndexMarker168"/><span class="koboSpan" id="kobo.1313.1">generated is first extracted as a list of polygons, using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1314.1">extract_voronoi_polygon_list</span></code><span class="koboSpan" id="kobo.1315.1"> function already defined in the previous section (and which was just moved to the new utility script). </span><span class="koboSpan" id="kobo.1315.2">Then, the polygons are clipped using the external boundary of London boroughs, obtained by dissolving the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1316.1">borroughs_df</span></code><span class="koboSpan" id="kobo.1317.1"> GeoDataFrame:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1318.1">boroughs_dissolved = boroughs_df.dissolve()
voronoi_polys_clipped = clip_polygons(voronoi_poly_list, boroughs_df)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1319.1">The code for </span><code class="inlineCode"><span class="koboSpan" id="kobo.1320.1">clip_polygons</span></code><span class="koboSpan" id="kobo.1321.1"> is defined as well in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1322.1">geospatial_utils</span></code><span class="koboSpan" id="kobo.1323.1"> utility script. </span><span class="koboSpan" id="kobo.1323.2">In the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1324.1">clip_polygons</span></code><span class="koboSpan" id="kobo.1325.1"> function, we use a list of polygons, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1326.1">poly_clipping</span></code><span class="koboSpan" id="kobo.1327.1">, to clip polygons in another list, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1328.1">poly_list_origin</span></code><span class="koboSpan" id="kobo.1329.1">. </span><span class="koboSpan" id="kobo.1329.2">We transform the list with original polygons, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1330.1">poly_list_origin</span></code><span class="koboSpan" id="kobo.1331.1">, in a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1332.1">geopandas</span></code><span class="koboSpan" id="kobo.1333.1"> DataFrame. </span><span class="koboSpan" id="kobo.1333.2">We perform the clipping operation using the geopandas </span><code class="inlineCode"><span class="koboSpan" id="kobo.1334.1">clip</span></code><span class="koboSpan" id="kobo.1335.1"> function. </span><span class="koboSpan" id="kobo.1335.2">The resulting list </span><a id="_idIndexMarker169"/><span class="koboSpan" id="kobo.1336.1">of polygons clipped, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1337.1">polygons_clipped</span></code><span class="koboSpan" id="kobo.1338.1">, is returned by the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1339.1">clip_polygons</span></code><span class="koboSpan" id="kobo.1340.1"> function:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1341.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1342.1">clip_polygons</span></span><span class="koboSpan" id="kobo.1343.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.1344.1">poly_list_origin, poly_clipping</span></span><span class="koboSpan" id="kobo.1345.1">):
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.1346.1">"""</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1347.1">    Clip a list of polygons using an external polygon</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1348.1">    Args:</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1349.1">        poly_list_origin: list of polygons to clip</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1350.1">        poly_clipping: polygon used to clip the original list</span></span>
<span class="hljs-string"> </span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1351.1">    Returns:</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1352.1">        The original list of polygons, with the polygons clipped using the clipping polygon</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1353.1">    """</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1354.1">#convert the initial polygons list to a geodataframe</span></span><span class="koboSpan" id="kobo.1355.1">
    polygons_gdf = gpd.GeoDataFrame(poly_list_origin, columns = [</span><span class="hljs-string"><span class="koboSpan" id="kobo.1356.1">'geometry'</span></span><span class="koboSpan" id="kobo.1357.1">], crs=poly_clipping.crs)
    start_time = time.time()
    polygons_clipped = gpd.clip(polygons_gdf, poly_clipping)
    end_time = time.time()
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1358.1">print</span></span><span class="koboSpan" id="kobo.1359.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1360.1">f"Total time: </span></span><span class="hljs-subst"><span class="koboSpan" id="kobo.1361.1">{</span></span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1362.1">round</span></span><span class="hljs-subst"><span class="koboSpan" id="kobo.1363.1">(end_time - start_time, </span></span><span class="hljs-number"><span class="koboSpan" id="kobo.1364.1">4</span></span><span class="hljs-subst"><span class="koboSpan" id="kobo.1365.1">)}</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1366.1"> sec."</span></span><span class="koboSpan" id="kobo.1367.1">)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1368.1">return</span></span><span class="koboSpan" id="kobo.1369.1"> polygons_clipped
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1370.1">The following figure shows</span><a id="_idIndexMarker170"/><span class="koboSpan" id="kobo.1371.1"> the Voronoi polygons from pub locations in London (left) and the boroughs’ boundary (right):</span></p>
<p class="packt_figref"><span class="koboSpan" id="kobo.1372.1"><img alt="" role="presentation" src="../Images/B20963_04_39.png"/></span></p>
<p class="packt_figref"><span class="koboSpan" id="kobo.1373.1">Figure 4.39: Pubs’ Voronoi polygons in the London boroughs and the City of London (left) and the London boroughs’ boundary (right). </span><span class="koboSpan" id="kobo.1373.2">We use the boundary polygon to clip the Voronoi polygons</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1374.1">The following figure shows the boroughs’ boundary and the pubs’ position, as well as the Voronoi polygons associated with these locations. </span><span class="koboSpan" id="kobo.1374.2">We can observe that the areas with the greatest pub density</span><a id="_idIndexMarker171"/><span class="koboSpan" id="kobo.1375.1"> are in the City of London and its neighboring boroughs to the west, except for Tower Hamlets, which has only one pub.</span></p>
<p class="packt_figref"><span class="koboSpan" id="kobo.1376.1"><img alt="Map  Description automatically generated" src="../Images/B20963_04_40.png"/></span></p>
<p class="packt_figref"><span class="koboSpan" id="kobo.1377.1">Figure 4.40: Pubs’ Voronoi polygons in the London boroughs and the City of London (clipped), showing pubs’ locations and boroughs’ boundaries</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1378.1">Next, we perform the same operations for the Starbucks coffee shop locations. </span><span class="koboSpan" id="kobo.1378.2">We generate the Voronoi </span><a id="_idIndexMarker172"/><span class="koboSpan" id="kobo.1379.1">polygons and clip them with the same London borough border polygon, obtained by dissolving all the boroughs’ polygons. </span><span class="koboSpan" id="kobo.1379.2">The following figure shows the boroughs’ boundaries and the Starbucks shops’ positions, as well as the Voronoi polygons associated with these locations:</span></p>
<p class="packt_figref"><span class="koboSpan" id="kobo.1380.1"><img alt="Map  Description automatically generated" src="../Images/B20963_04_41.png"/></span></p>
<p class="packt_figref"><span class="koboSpan" id="kobo.1381.1">Figure 4.41: Starbucks’ Voronoi polygons in the London boroughs and the City of London (clipped), showing the shops’ locations and boroughs’ boundaries</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1382.1">The code for generating</span><a id="_idIndexMarker173"/><span class="koboSpan" id="kobo.1383.1"> the Voronoi polygons object, visualizing it, extracting from it the list of polygons, and then clipping it is </span><a id="_idIndexMarker174"/><span class="koboSpan" id="kobo.1384.1">given here. </span><span class="koboSpan" id="kobo.1384.2">First, let’s see the code to generate the Voronoi polygons:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1385.1">coffee_voronoi = get_voronoi_polygons(coffee_df, latitude=</span><span class="hljs-string"><span class="koboSpan" id="kobo.1386.1">"Latitude"</span></span><span class="koboSpan" id="kobo.1387.1">, longitude=</span><span class="hljs-string"><span class="koboSpan" id="kobo.1388.1">"Longitude"</span></span><span class="koboSpan" id="kobo.1389.1">)
plot_voronoi_polygons(coffee_voronoi, 
                      title=</span><span class="hljs-string"><span class="koboSpan" id="kobo.1390.1">"Voronoi polygons from Starbucks locations in London"</span></span><span class="koboSpan" id="kobo.1391.1">,
                      lat_limits=[</span><span class="hljs-number"><span class="koboSpan" id="kobo.1392.1">51.2</span></span><span class="koboSpan" id="kobo.1393.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1394.1">51.7</span></span><span class="koboSpan" id="kobo.1395.1">],
                      long_limits=[-</span><span class="hljs-number"><span class="koboSpan" id="kobo.1396.1">0.5</span></span><span class="koboSpan" id="kobo.1397.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1398.1">0.3</span></span><span class="koboSpan" id="kobo.1399.1">])
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1400.1">Next is the code for extracting the list of polygons from the Voronoi polygons object and the code for clipping the polygons, using the borroughs’ boundary:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1401.1">coffee_voronoi_poly_list = extract_voronoi_polygon_list(coffee_voronoi)
coffee_voronoi_polys_clipped = clip_polygons(coffee_voronoi_poly_list, boroughs_df)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1402.1">Using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1403.1">within_polygon</span></code><span class="koboSpan" id="kobo.1404.1"> function, we can identify the locations that are inside a polygon. </span><span class="koboSpan" id="kobo.1404.2">The function is implemented</span><a id="_idIndexMarker175"/><span class="koboSpan" id="kobo.1405.1"> in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1406.1">geospatial_utils</span></code><span class="koboSpan" id="kobo.1407.1"> module. </span><span class="koboSpan" id="kobo.1407.2">The function uses the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1408.1">within</span></code><span class="koboSpan" id="kobo.1409.1"> property of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1410.1">Point</span></code><span class="koboSpan" id="kobo.1411.1"> object from the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1412.1">shapely.geometry</span></code><span class="koboSpan" id="kobo.1413.1"> library module. </span><span class="koboSpan" id="kobo.1413.2">We apply the operation, for a given polygon, to all the points created from the longitude/latitude of all</span><a id="_idIndexMarker176"/><span class="koboSpan" id="kobo.1414.1"> items (in our case, the pubs), getting the status (</span><code class="inlineCode"><span class="koboSpan" id="kobo.1415.1">within</span></code><span class="koboSpan" id="kobo.1416.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1417.1">outside</span></code><span class="koboSpan" id="kobo.1418.1">) of points relative to the reference polygon:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1419.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1420.1">within_polygon</span></span><span class="koboSpan" id="kobo.1421.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.1422.1">data_original_df, polygon, latitude=</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1423.1">"latitude"</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1424.1">, longitude=</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1425.1">"longitude"</span></span><span class="koboSpan" id="kobo.1426.1">):
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.1427.1">"""</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1428.1">    Args</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1429.1">        data_original_df: dataframe with latitude / longitude</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1430.1">        polygon: polygon (Polygon object)</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1431.1">        latitude: feature name for latitude n data_original_df</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1432.1">        longitude: feature name for longitude in data_original_df</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1433.1">    Returns</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1434.1">        coordinates of points inside polygon</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1435.1">        coordinates of points outside polygon</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1436.1">        polygon transformed into a geopandas dataframe</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1437.1">    """</span></span><span class="koboSpan" id="kobo.1438.1">
    data_df = data_original_df.copy()
    data_df[</span><span class="hljs-string"><span class="koboSpan" id="kobo.1439.1">"in_poly"</span></span><span class="koboSpan" id="kobo.1440.1">] = data_df.apply(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1441.1">lambda</span></span><span class="koboSpan" id="kobo.1442.1"> x: Point(x[longitude], x[latitude]).within(polygon), axis=</span><span class="hljs-number"><span class="koboSpan" id="kobo.1443.1">1</span></span><span class="koboSpan" id="kobo.1444.1">)
    data_in_df = data_df[[longitude, latitude]].loc[data_df[</span><span class="hljs-string"><span class="koboSpan" id="kobo.1445.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1446.1">in_poly"</span></span><span class="koboSpan" id="kobo.1447.1">]==</span><span class="hljs-literal"><span class="koboSpan" id="kobo.1448.1">True</span></span><span class="koboSpan" id="kobo.1449.1">]
    data_out_df = data_df[[longitude, latitude]].loc[data_df[</span><span class="hljs-string"><span class="koboSpan" id="kobo.1450.1">"in_poly"</span></span><span class="koboSpan" id="kobo.1451.1">]==</span><span class="hljs-literal"><span class="koboSpan" id="kobo.1452.1">False</span></span><span class="koboSpan" id="kobo.1453.1">]
    data_in_df.columns = [</span><span class="hljs-string"><span class="koboSpan" id="kobo.1454.1">"long"</span></span><span class="koboSpan" id="kobo.1455.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1456.1">"lat"</span></span><span class="koboSpan" id="kobo.1457.1">]
    data_out_df.columns = [</span><span class="hljs-string"><span class="koboSpan" id="kobo.1458.1">"long"</span></span><span class="koboSpan" id="kobo.1459.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1460.1">"lat"</span></span><span class="koboSpan" id="kobo.1461.1">]
    sel_polygon_gdf = gpd.GeoDataFrame([polygon], columns = [</span><span class="hljs-string"><span class="koboSpan" id="kobo.1462.1">'geometry'</span></span><span class="koboSpan" id="kobo.1463.1">])
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1464.1">return</span></span><span class="koboSpan" id="kobo.1465.1"> data_in_df, data_out_df, sel_polygon_gdf
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1466.1">The following code applies the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1467.1">within_polygon</span></code><span class="koboSpan" id="kobo.1468.1"> function:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1469.1">data_in_df, data_out_df, sel_polygon_gdf = within_polygon(pub_df, coffee_voronoi_poly_list[</span><span class="hljs-number"><span class="koboSpan" id="kobo.1470.1">6</span></span><span class="koboSpan" id="kobo.1471.1">])
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1472.1">In the following figure, the pubs within the selected area (shown in the notebook associated with the book by a light brown and dark green fill color) are closer to the position of the Starbucks coffee </span><a id="_idIndexMarker177"/><span class="koboSpan" id="kobo.1473.1">shop centered on the selected area than to any other neighboring Starbucks coffee shop. </span><span class="koboSpan" id="kobo.1473.2">The rest of the pubs are shown with a light green color. </span><span class="koboSpan" id="kobo.1473.3">We can repeat the</span><a id="_idIndexMarker178"/><span class="koboSpan" id="kobo.1474.1"> procedure for all polygons (and also for the boroughs’ polygons).</span></p>
<p class="packt_figref"><span class="koboSpan" id="kobo.1475.1"><img alt="Map  Description automatically generated" src="../Images/B20963_04_42.png"/></span></p>
<p class="packt_figref"><span class="koboSpan" id="kobo.1476.1">Figure 4.42: Pubs outside and inside a Starbucks Voronoi polygon area</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1477.1">We can represent the same items, pubs and Starbucks coffee shops, using folium maps too. </span><span class="koboSpan" id="kobo.1477.2">These maps will allow interactions, including zooming in, zooming out, and panning. </span><span class="koboSpan" id="kobo.1477.3">We can add multiple layers over a base map. </span><span class="koboSpan" id="kobo.1477.4">Let’s start by representing the London boroughs as the first layer of the map. </span><span class="koboSpan" id="kobo.1477.5">On top of that, we will show the pubs in the London area. </span><span class="koboSpan" id="kobo.1477.6">Each pub will have a popup as well, displaying the name of the pub and the address. </span><span class="koboSpan" id="kobo.1477.7">We can select from multiple map tile providers.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1478.1">Because I prefer to have a clearer background, I opted for two tile sources: “Stamen toner” and “CartoDB positron.” </span><span class="koboSpan" id="kobo.1478.2">For both options, the tiles are either black and white or pale colors, so the overlapping </span><a id="_idIndexMarker179"/><span class="koboSpan" id="kobo.1479.1">layers can be seen more easily. </span><span class="koboSpan" id="kobo.1479.2">The following is the code to show the tiles (with “Stamen toner”) in the London area, the contour of London boroughs (first layer of </span><a id="_idIndexMarker180"/><span class="koboSpan" id="kobo.1480.1">the map), and each pub location with </span><code class="inlineCode"><span class="koboSpan" id="kobo.1481.1">CircleMarker</span></code><span class="koboSpan" id="kobo.1482.1"> (the second layer over the map). </span><span class="koboSpan" id="kobo.1482.2">Each pub will have a popup, showing the pub name and address:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.1483.1"># map with zoom on London area</span></span><span class="koboSpan" id="kobo.1484.1">
m = folium.Map(location=[</span><span class="hljs-number"><span class="koboSpan" id="kobo.1485.1">51.5</span></span><span class="koboSpan" id="kobo.1486.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1487.1">0</span></span><span class="koboSpan" id="kobo.1488.1">], zoom_start=</span><span class="hljs-number"><span class="koboSpan" id="kobo.1489.1">10</span></span><span class="koboSpan" id="kobo.1490.1">, tiles=</span><span class="hljs-string"><span class="koboSpan" id="kobo.1491.1">"Stamen Toner"</span></span><span class="koboSpan" id="kobo.1492.1">)
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.1493.1"># London boroughs geo jsons</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1494.1">for</span></span><span class="koboSpan" id="kobo.1495.1"> _, r </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1496.1">in</span></span><span class="koboSpan" id="kobo.1497.1"> boroughs_df.iterrows():
    simplified_geo = gpd.GeoSeries(r[</span><span class="hljs-string"><span class="koboSpan" id="kobo.1498.1">'geometry'</span></span><span class="koboSpan" id="kobo.1499.1">]).simplify(tolerance=</span><span class="hljs-number"><span class="koboSpan" id="kobo.1500.1">0.001</span></span><span class="koboSpan" id="kobo.1501.1">)
    geo_json = simplified_geo.to_json()
    geo_json = folium.GeoJson(data=geo_json,
                           style_function=</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1502.1">lambda</span></span><span class="koboSpan" id="kobo.1503.1"> x: {</span><span class="hljs-string"><span class="koboSpan" id="kobo.1504.1">'fillColor'</span></span><span class="koboSpan" id="kobo.1505.1">: color_list[</span><span class="hljs-number"><span class="koboSpan" id="kobo.1506.1">1</span></span><span class="koboSpan" id="kobo.1507.1">],
                                                    </span><span class="hljs-string"><span class="koboSpan" id="kobo.1508.1">'color'</span></span><span class="koboSpan" id="kobo.1509.1">: color_list[</span><span class="hljs-number"><span class="koboSpan" id="kobo.1510.1">2</span></span><span class="koboSpan" id="kobo.1511.1">],
                                                    </span><span class="hljs-string"><span class="koboSpan" id="kobo.1512.1">'weight'</span></span><span class="koboSpan" id="kobo.1513.1">: </span><span class="hljs-number"><span class="koboSpan" id="kobo.1514.1">1</span></span><span class="koboSpan" id="kobo.1515.1">})
    geo_json.add_to(m)
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.1516.1"># pubs as CircleMarkers with popup with Name &amp; Address info    </span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1517.1">for</span></span><span class="koboSpan" id="kobo.1518.1"> _, r </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1519.1">in</span></span><span class="koboSpan" id="kobo.1520.1"> pub_df.iterrows():
    folium.CircleMarker(location=[r[</span><span class="hljs-string"><span class="koboSpan" id="kobo.1521.1">'latitude'</span></span><span class="koboSpan" id="kobo.1522.1">], r[</span><span class="hljs-string"><span class="koboSpan" id="kobo.1523.1">'longitude'</span></span><span class="koboSpan" id="kobo.1524.1">]],
                        fill=</span><span class="hljs-literal"><span class="koboSpan" id="kobo.1525.1">True</span></span><span class="koboSpan" id="kobo.1526.1">,
                        color=color_list[</span><span class="hljs-number"><span class="koboSpan" id="kobo.1527.1">4</span></span><span class="koboSpan" id="kobo.1528.1">],
                        fill_color=color_list[</span><span class="hljs-number"><span class="koboSpan" id="kobo.1529.1">5</span></span><span class="koboSpan" id="kobo.1530.1">],
                        weight=</span><span class="hljs-number"><span class="koboSpan" id="kobo.1531.1">0.5</span></span><span class="koboSpan" id="kobo.1532.1">,
                        radius=</span><span class="hljs-number"><span class="koboSpan" id="kobo.1533.1">4</span></span><span class="koboSpan" id="kobo.1534.1">,
                        popup=</span><span class="hljs-string"><span class="koboSpan" id="kobo.1535.1">"&lt;strong&gt;Name&lt;/strong&gt;: &lt;font color='red'&gt;{}&lt;/font&gt; &lt;br&gt; &lt;strong&gt;Address&lt;/strong&gt;: {}"</span></span><span class="koboSpan" id="kobo.1536.1">.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1537.1">format</span></span><span class="koboSpan" id="kobo.1538.1">(r[</span><span class="hljs-string"><span class="koboSpan" id="kobo.1539.1">'name'</span></span><span class="koboSpan" id="kobo.1540.1">], r[</span><span class="hljs-string"><span class="koboSpan" id="kobo.1541.1">'address'</span></span><span class="koboSpan" id="kobo.1542.1">])).add_to(m)
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.1543.1"># display map</span></span><span class="koboSpan" id="kobo.1544.1">
m 
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1545.1">The following figure displays the map created with the preceding code. </span><span class="koboSpan" id="kobo.1545.2">On this map, we show on superposed layers the following information:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1546.1">The London boroughs and City of London map areas, using “Stamen Toner” tiles</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1547.1">The London boroughs and City of London boundaries</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1548.1">The pubs in the preceding areas, shown with </span><code class="inlineCode"><span class="koboSpan" id="kobo.1549.1">CircleMarker</span></code></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1550.1">Optionally, for each</span><a id="_idIndexMarker181"/><span class="koboSpan" id="kobo.1551.1"> pub, if selected, one popup showing the pub name and address</span></li>
</ul>
<figure class="mediaobject"><span class="koboSpan" id="kobo.1552.1"><img alt="Map  Description automatically generated" src="../Images/B20963_04_43.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.1553.1">Figure 4.43: Leaflet map with the boroughs’ borders and the pub locations in the London area</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1554.1">In the notebook, I show more images with Starbucks Voronoi polygons and locations, as well as maps with multiple layers of polygons and markers.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1555.1">Another useful operation that we can perform is to calculate the area of polygons. </span><span class="koboSpan" id="kobo.1555.2">The function to calculate areas</span><a id="_idIndexMarker182"/><span class="koboSpan" id="kobo.1556.1"> for all polygons in a GeoDataFrame is </span><code class="inlineCode"><span class="koboSpan" id="kobo.1557.1">get_polygons_area</span></code><span class="koboSpan" id="kobo.1558.1">, which is also defined in </span><code class="inlineCode"><span class="koboSpan" id="kobo.1559.1">geospatial_utils</span></code><span class="koboSpan" id="kobo.1560.1">. </span><span class="koboSpan" id="kobo.1560.2">It applies a transformation to the projection, in </span><code class="inlineCode"><span class="koboSpan" id="kobo.1561.1">cylindrical equal area</span></code><span class="koboSpan" id="kobo.1562.1">, on a copy of the GeoDataFrame. </span><span class="koboSpan" id="kobo.1562.2">This projection will preserve the areas. </span><span class="koboSpan" id="kobo.1562.3">We then add the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1563.1">area</span></code><span class="koboSpan" id="kobo.1564.1"> column to the original GeoDataFrame:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1565.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1566.1">get_polygons_area</span></span><span class="koboSpan" id="kobo.1567.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.1568.1">data_gdf</span></span><span class="koboSpan" id="kobo.1569.1">):
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.1570.1">"""</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1571.1">    Add a column with polygons area to a GeoDataFrame</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1572.1">    A Cylindrical equal area projection is used to calculate </span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1573.1">    polygons area</span></span>
<span class="hljs-string"> </span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1574.1">    Args</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1575.1">        data_gdf: a GeoDataFrame</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1576.1">    Returns</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1577.1">        the original data_gdf with an `area` column added</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1578.1">    """</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1579.1"># copy the data, to not affect initial data projection</span></span><span class="koboSpan" id="kobo.1580.1">
    data_cp = data_gdf.copy()
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1581.1"># transform, in the copied data, the projection in Cylindrical equal-area,</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1582.1"># which preserves the areas </span></span><span class="koboSpan" id="kobo.1583.1">
    data_cp = data_cp.to_crs({</span><span class="hljs-string"><span class="koboSpan" id="kobo.1584.1">'proj'</span></span><span class="koboSpan" id="kobo.1585.1">:</span><span class="hljs-string"><span class="koboSpan" id="kobo.1586.1">'cea'</span></span><span class="koboSpan" id="kobo.1587.1">})
    data_cp[</span><span class="hljs-string"><span class="koboSpan" id="kobo.1588.1">"area"</span></span><span class="koboSpan" id="kobo.1589.1">] = data_cp[</span><span class="hljs-string"><span class="koboSpan" id="kobo.1590.1">'geometry'</span></span><span class="koboSpan" id="kobo.1591.1">].area / </span><span class="hljs-number"><span class="koboSpan" id="kobo.1592.1">10</span></span><span class="koboSpan" id="kobo.1593.1">**</span><span class="hljs-number"><span class="koboSpan" id="kobo.1594.1">6</span></span> <span class="hljs-comment"><span class="koboSpan" id="kobo.1595.1"># km^2</span></span><span class="koboSpan" id="kobo.1596.1">
    data_gdf[</span><span class="hljs-string"><span class="koboSpan" id="kobo.1597.1">"area"</span></span><span class="koboSpan" id="kobo.1598.1">] = data_cp[</span><span class="hljs-string"><span class="koboSpan" id="kobo.1599.1">"area"</span></span><span class="koboSpan" id="kobo.1600.1">]
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1601.1"># returns the initial data, with added area columns</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1602.1">return</span></span><span class="koboSpan" id="kobo.1603.1"> data_gdf
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1604.1">We calculate the area for the</span><a id="_idIndexMarker183"/><span class="koboSpan" id="kobo.1605.1"> boroughs, and then we count the number of pubs per borough. </span><span class="koboSpan" id="kobo.1605.2">Then, we divide the number of pubs/boroughs by the borough area to obtain the pub density (in pubs per square kilometer):</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1606.1">boroughs_df = get_polygons_area(boroughs_df)
agg_pub_df = pub_df.groupby(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1607.1">"local_authority"</span></span><span class="koboSpan" id="kobo.1608.1">)[</span><span class="hljs-string"><span class="koboSpan" id="kobo.1609.1">"name"</span></span><span class="koboSpan" id="kobo.1610.1">].count().reset_index()
agg_pub_df.columns = [</span><span class="hljs-string"><span class="koboSpan" id="kobo.1611.1">"NAME_2"</span></span><span class="koboSpan" id="kobo.1612.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1613.1">"pubs"</span></span><span class="koboSpan" id="kobo.1614.1">]
boroughs_df = boroughs_df.merge(agg_pub_df)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1615.1">We now need to represent</span><a id="_idIndexMarker184"/><span class="koboSpan" id="kobo.1616.1"> the density with a continuous color scale, but we would like to use colors from our custom colormap. </span><span class="koboSpan" id="kobo.1616.2">We can create our own continuous color map and use as seeds a few of the colors in our color list:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1617.1">vmin = boroughs_df.pubs.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1618.1">min</span></span><span class="koboSpan" id="kobo.1619.1">()
vmax = boroughs_df.pubs.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1620.1">max</span></span><span class="koboSpan" id="kobo.1621.1">()
norm=plt.Normalize(vmin, vmax)
custom_cmap = matplotlib.colors.LinearSegmentedColormap.from_list(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1622.1">""</span></span><span class="koboSpan" id="kobo.1623.1">, [</span><span class="hljs-string"><span class="koboSpan" id="kobo.1624.1">"white"</span></span><span class="koboSpan" id="kobo.1625.1">, color_list[</span><span class="hljs-number"><span class="koboSpan" id="kobo.1626.1">0</span></span><span class="koboSpan" id="kobo.1627.1">], color_list[</span><span class="hljs-number"><span class="koboSpan" id="kobo.1628.1">2</span></span><span class="koboSpan" id="kobo.1629.1">]])
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1630.1">For the pub density graph, we would like to use, with this custom colormap, a logarithmic scale. </span><span class="koboSpan" id="kobo.1630.2">We can achieve this with the following code:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1631.1">fig, ax = plt.subplots(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1632.1">1</span></span><span class="koboSpan" id="kobo.1633.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1634.1">1</span></span><span class="koboSpan" id="kobo.1635.1">, figsize = (</span><span class="hljs-number"><span class="koboSpan" id="kobo.1636.1">10</span></span><span class="koboSpan" id="kobo.1637.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1638.1">5</span></span><span class="koboSpan" id="kobo.1639.1">))
ax.set_facecolor(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1640.1">"white"</span></span><span class="koboSpan" id="kobo.1641.1">)
boroughs_df.plot(ax = ax, column=</span><span class="hljs-string"><span class="koboSpan" id="kobo.1642.1">"pubs per sq.km"</span></span><span class="koboSpan" id="kobo.1643.1">, 
                 norm=matplotlib.colors.LogNorm(vmin=boroughs_df[</span><span class="hljs-string"><span class="koboSpan" id="kobo.1644.1">"pubs per sq.km"</span></span><span class="koboSpan" id="kobo.1645.1">].</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1646.1">min</span></span><span class="koboSpan" id="kobo.1647.1">(),\
                                          vmax=boroughs_df[</span><span class="hljs-string"><span class="koboSpan" id="kobo.1648.1">"pubs per sq.km"</span></span><span class="koboSpan" id="kobo.1649.1">].</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1650.1">max</span></span><span class="koboSpan" id="kobo.1651.1">()),
                 cmap = custom_cmap, edgecolor = color_list[</span><span class="hljs-number"><span class="koboSpan" id="kobo.1652.1">3</span></span><span class="koboSpan" id="kobo.1653.1">], 
                 linewidth = </span><span class="hljs-number"><span class="koboSpan" id="kobo.1654.1">1</span></span><span class="koboSpan" id="kobo.1655.1">, legend=</span><span class="hljs-literal"><span class="koboSpan" id="kobo.1656.1">True</span></span><span class="koboSpan" id="kobo.1657.1">),
plt.xlabel(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1658.1">"Longitude"</span></span><span class="koboSpan" id="kobo.1659.1">); plt.ylabel(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1660.1">"Latitude"</span></span><span class="koboSpan" id="kobo.1661.1">);
plt.title(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1662.1">"Pubs density (pubs / sq.km) in London"</span></span><span class="koboSpan" id="kobo.1663.1">)
plt.show()
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1664.1">The following figure shows the pub </span><a id="_idIndexMarker185"/><span class="koboSpan" id="kobo.1665.1">numbers in each borough (left) and the pub density per borough (right):</span></p>
<p class="packt_figref"><span class="koboSpan" id="kobo.1666.1"><img alt="" role="presentation" src="../Images/B20963_04_44.png"/></span></p>
<p class="packt_figref"><span class="koboSpan" id="kobo.1667.1">Figure 4.44: Pub numbers (left) and pub density on a logarithmic scale (right) per London borough</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1668.1">In the notebook associated </span><a id="_idIndexMarker186"/><span class="koboSpan" id="kobo.1669.1">with this section, </span><em class="italic"><span class="koboSpan" id="kobo.1670.1">Coffee or Beer in London – Your Choice!</span></em><span class="koboSpan" id="kobo.1671.1"> (see </span><em class="italic"><span class="koboSpan" id="kobo.1672.1">Reference 11</span></em><span class="koboSpan" id="kobo.1673.1">), I also show the pub numbers and pub density per Starbucks Voronoi polygons area. </span><span class="koboSpan" id="kobo.1673.2">The various techniques displayed in this section have hopefully equipped you with a starting toolset for the analysis and visualization of geospatial data.</span></p>
<h1 class="heading-1" id="_idParaDest-60"><span class="koboSpan" id="kobo.1674.1">Summary</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1675.1">In this chapter, we learned how to work with geographical information and maps, how to manipulate geometry data (clip and merge polygon data, cluster data to generate maps with fewer details, and remove subsets of geospatial data), and superpose several layers of data over maps. </span><span class="koboSpan" id="kobo.1675.2">We also learned how to modify and extract information from a shapefile using </span><code class="inlineCode"><span class="koboSpan" id="kobo.1676.1">geopandas</span></code><span class="koboSpan" id="kobo.1677.1"> and custom code, as well as creating or calculating geospatial features, like terrain area or geospatial object density. </span><span class="koboSpan" id="kobo.1677.2">Additionally, we extracted reusable functions and grouped them in two utility scripts, which is Kaggle terminology for independent Python modules. </span><span class="koboSpan" id="kobo.1677.3">These utility scripts can be imported like any other library and integrated with your notebook code.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1678.1">In the next chapter, we are going to put to try out some of the tools and techniques for geospatial analysis, for a data analytics competition.</span></p>
<h1 class="heading-1" id="_idParaDest-61"><span class="koboSpan" id="kobo.1679.1">References</span></h1>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.1680.1">Every Pub in England, Kaggle Datasets: </span><a href="https://www.kaggle.com/datasets/rtatman/every-pub-in-england"><span class="url"><span class="koboSpan" id="kobo.1681.1">https://www.kaggle.com/datasets/rtatman/every-pub-in-england</span></span></a></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1682.1">Every Pub in England – Data Exploration, Kaggle Notebook: </span><a href="https://github.com/PacktPublishing/Developing-Kaggle-Notebooks/blob/develop/Chapter-04/every-pub-in-england-data-exploration.ipynb"><span class="url"><span class="koboSpan" id="kobo.1683.1">https://github.com/PacktPublishing/Developing-Kaggle-Notebooks/blob/develop/Chapter-04/every-pub-in-england-data-exploration.ipynb</span></span></a></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1684.1">Starbucks Locations Worldwide, Kaggle Datasets: </span><a href="https://www.kaggle.com/datasets/starbucks/store-locations"><span class="url"><span class="koboSpan" id="kobo.1685.1">https://www.kaggle.com/datasets/starbucks/store-locations</span></span></a></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1686.1">Open Postcode Geo, Kaggle Datasets: </span><a href="https://www.kaggle.com/datasets/danwinchester/open-postcode-geo"><span class="url"><span class="koboSpan" id="kobo.1687.1">https://www.kaggle.com/datasets/danwinchester/open-postcode-geo</span></span></a></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1688.1">GADM Data for UK, Kaggle Datasets: </span><a href="https://www.kaggle.com/datasets/gpreda/gadm-data-for-uk"><span class="url"><span class="koboSpan" id="kobo.1689.1">https://www.kaggle.com/datasets/gpreda/gadm-data-for-uk</span></span></a></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1690.1">Starbucks Location Worldwide – Data Exploration, Kaggle Notebook: </span><a href="https://github.com/PacktPublishing/Developing-Kaggle-Notebooks/blob/develop/Chapter-04/starbucks-location-worldwide-data-exploration.ipynb"><span class="url"><span class="koboSpan" id="kobo.1691.1">https://github.com/PacktPublishing/Developing-Kaggle-Notebooks/blob/develop/Chapter-04/starbucks-location-worldwide-data-exploration.ipynb</span></span></a></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1692.1">Polygon overlay in Leaflet Map: </span><a href="https://stackoverflow.com/questions/59303421/polygon-overlay-in-leaflet-map"><span class="url"><span class="koboSpan" id="kobo.1693.1">https://stackoverflow.com/questions/59303421/polygon-overlay-in-leaflet-map</span></span></a></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1694.1">Geopandas area: </span><a href="https://geopandas.org/en/stable/docs/reference/api/geopandas.GeoSeries.area.html"><span class="url"><span class="koboSpan" id="kobo.1695.1">https://geopandas.org/en/stable/docs/reference/api/geopandas.GeoSeries.area.html</span></span></a> </li>
<li class="numberedList"><span class="koboSpan" id="kobo.1696.1">Scipy Spatial Voronoi – extract Voronoi polygons and represent them: </span><a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.Voronoi.html"><span class="url"><span class="koboSpan" id="kobo.1697.1">https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.Voronoi.html</span></span></a></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1698.1">Getting polygon areas using GeoPandas: </span><a href="https://gis.stackexchange.com/questions/218450/getting-polygon-areas-using-geopandas"><span class="url"><span class="koboSpan" id="kobo.1699.1">https://gis.stackexchange.com/questions/218450/getting-polygon-areas-using-geopandas</span></span></a></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1700.1">Coffee or Beer in London – Your Choice!, Kaggle Notebook: </span><a href="https://github.com/PacktPublishing/Developing-Kaggle-Notebooks/blob/develop/Chapter-04/coffee-or-beer-in-london-your-choice.ipynb"><span class="url"><span class="koboSpan" id="kobo.1701.1">https://github.com/PacktPublishing/Developing-Kaggle-Notebooks/blob/develop/Chapter-04/coffee-or-beer-in-london-your-choice.ipynb</span></span></a></li>
</ol>
<h1 class="heading-1"><span class="koboSpan" id="kobo.1702.1">Join our book’s Discord space</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1703.1">Join our Discord community to meet like-minded people and learn alongside more than 5000 members at:</span></p>
<p class="normal"><a href="https://packt.link/kaggle"><span class="url"><span class="koboSpan" id="kobo.1704.1">https://packt.link/kaggle</span></span></a></p>
<p class="normal"><span class="koboSpan" id="kobo.1705.1"><img alt="" role="presentation" src="../Images/QR_Code9220780366773140.png"/></span></p>
</div>
</body></html>