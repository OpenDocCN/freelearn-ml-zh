<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer086">
			<h1 id="_idParaDest-116"><em class="italic"><a id="_idTextAnchor119"/>Chapter 6</em>: Processing and Consuming Data on the Cloud</h1>
			<p>The value proposition of edge computing is to process data closer to the source and deliver intelligent near real-time responsiveness for different kinds of applications across different use cases. Additionally, edge computing reduces the amount of data that is required to be transferred to the cloud, thus saving on network bandwidth costs. Often, high-performance edge applications require local compute, local storage, network, data analytics, and machine learning capabilities to process high-fidelity data in low latencies. Although AWS IoT Greengrass allows you to run sophisticated edge applications on devices and gateways, it will be resource-constrained compared to the horsepower from the cloud. Therefore, for different use cases, it's quite common to leverage the scale of cloud computing for high-volume complex data processing needs. </p>
			<p>In the previous chapter, you learned about the different design patterns around data transformation strategies on the edge. This chapter will focus on explaining how you can build different data workflows on the cloud based on the data velocity, data variety, and data volume collected from the HBS hub running a Greengrass instance. Specifically, you will learn how to persist data in a transactional data store, develop API driven access, and build a serverless data warehouse to serve data to end users. Therefore, the chapter is divided into the following topics:</p>
			<ul>
				<li>Defining big data for IoT workloads</li>
				<li>Introduction to <strong class="bold">Domain-Driven Design</strong> (<strong class="bold">DDD</strong>) concepts</li>
				<li>Design data flow patterns on the cloud</li>
				<li>Remembering data flow anti-patterns for edge workloads</li>
			</ul>
			<h1 id="_idParaDest-117"><a id="_idTextAnchor120"/>Technical requirements </h1>
			<p>The technical requirements for this chapter are the same as those outlined in <a href="B17595_02_Final_SS_ePub.xhtml#_idTextAnchor032"><em class="italic">Chapter 2</em></a><em class="italic">, Foundations of Edge Workloads</em>. See the full requirements in that chapter.</p>
			<h1 id="_idParaDest-118"><a id="_idTextAnchor121"/>Defining big data for IoT workloads</h1>
			<p>The term <em class="italic">Big</em> in <strong class="bold">Big data</strong> is relative, as the influx of data has grown substantially in the last two decades <a id="_idIndexMarker523"/>from terabytes to exabytes due to the digital<a id="_idIndexMarker524"/> transformation of enterprises and connected ecosystems. The advent of big data technologies has allowed people (<em class="italic">think social media</em>) and enterprises (<em class="italic">think digital transformation</em>) to generate, store, and analyze huge amounts of data. To analyze datasets of this volume, sophisticated computing infrastructure is required that can scale elastically based on the amount of input data and required outcome. This characteristic of big data workloads, along with the availability of cloud computing, democratized the adoption of big data technologies by companies of all sizes. Even with the evolution of edge computing, big data processing on the cloud plays a key role in IoT workloads, as data is more valuable when it's adjacent and enriched with other data systems. In this chapter, we will learn how the big data ecosystem allows for advanced processing and analytical capabilities on the huge volume of raw measurements or events collected from the edge to enable the consumption of actionable information by different personas. </p>
			<p>The integration of IoT with big data ecosystems has opened up a diverse set of analytical capabilities that allows the generation of additional business insights. These include the following: </p>
			<ul>
				<li><strong class="bold">Descriptiv<a id="_idTextAnchor122"/>e analytics</strong>: This type <a id="_idIndexMarker525"/>of analytics helps users answer the question of <em class="italic">what happened and why?</em> Examples of this include traditional queries and reporting dashboards.</li>
				<li><strong class="bold">Predictive analytics</strong>: This form <a id="_idIndexMarker526"/>of analytics helps users predict the probability of a given event in the future based on historical events or detected anomalies. Examples of this include early fraud detection in banking transactions and preventive maintenance for different systems.</li>
				<li><strong class="bold">Prescriptive analytics</strong>: This <a id="_idIndexMarker527"/>kind of analytics helps users provide specific (clear) recommendations. They address the question of <em class="italic">what should I do if x happens?</em> Examples of this include an election campaign to reach out to targeted voters or statistical modeling in wealth management to maximize returns. </li>
			</ul>
			<p>The outcome of these processes allows organizations to have increased visibility to new information, emerging trends, or hidden data correlation to improve efficiencies or generate new revenue streams. In this chapter, you will learn about the approaches of both descriptive and predictive analytics on data collected from the edge. In addition to this, you will learn how to implement design patterns such as streaming to a data lake or a transactional data store on the cloud, along with leveraging API driven access, which are considered anti-patterns for the edge. So, let's get started with the design methodologies of big data that are relevant for IoT workloads.</p>
			<h2 id="_idParaDest-119"><a id="_idTextAnchor123"/>What is big data processing?</h2>
			<p>Big data processing<a id="_idIndexMarker528"/> is generally categorized in terms of the three Vs: the volume of data (for example, a terabyte, petabyte, or more), the variety of data (that is, structured, semi-structured, or unstructured), and the velocity of data (that is, the speed with which it's produced or consumed). However, as more organizations begin to adopt big data technologies, there have been additions to the list of Vs, such as the following:</p>
			<ul>
				<li><strong class="bold">Viscosity</strong>: This <a id="_idIndexMarker529"/>emphasizes the ease of usability of data; for example, there could be noisy data collected from the edge that's not easy to parse.</li>
				<li><strong class="bold">Volatility</strong>: This refers <a id="_idIndexMarker530"/>to how often data changes occur and, therefore, how long the data is useful; for example, capturing specific events at home can be more useful than every other activity.</li>
				<li><strong class="bold">Veracity</strong>: This refers to <a id="_idIndexMarker531"/>how trustworthy the data is, for example, if images captured from outdoor cameras are of poor quality, they cannot be trusted to identify intrusion.</li>
			</ul>
			<p>For edge <a id="_idIndexMarker532"/>computing and the <strong class="bold">Internet of Things</strong> (<strong class="bold">IoT</strong>), all six Vs are relevant. The following diagram presents a visual summary of the range of data that has become available with the advent of IoT and big data<a id="_idIndexMarker533"/> technologies. This requires you to consider different ways in which to organize data at scale based on its respective characteristics:</p>
			<div>
				<div id="_idContainer077" class="IMG---Figure">
					<img src="Images/B17595_06_01.jpg" alt="Figure 6.1 – The evolution of big data&#13;&#10;" width="1650" height="1082"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.1 – The evolution of big data</p>
			<p>So, you have already learned about data modeling concepts in <a href="B17595_05_Final_SS_ePub.xhtml#_idTextAnchor090"><em class="italic">Chapter 5</em></a><em class="italic">, Ingesting and Streaming Data from the Edge</em>, which is a standard way of organizing data into meaningful structures based on data types and relationships and extracting value out of it. However, collecting data, storing it in a stream or a persistent layer, and processing it quickly to take intelligent actions is only one side of the story. The next challenge is to work out how to keep a high quality of data throughout its life cycle so that it continues to generate business value for downstream applications over inconsistency or risk. For IoT workloads, this aspect is critical as the devices or gateways reside in a physical world, with intermittent connectivity, at times, being susceptible to different forms of interference. This is where the domain-driven design (DDD) approach can help. </p>
			<h2 id="_idParaDest-120"><a id="_idTextAnchor124"/>What is domain-driven design? </h2>
			<p>To manage the quality of the data better, we need to learn how to organize data by content such as data domains or subject areas. One of the most common approaches in which to do that is through<a id="_idIndexMarker534"/> DDD, which was introduced by Eric Evans in 2003. In his book, Eric states <em class="italic">The heart of software is its ability to solve domain-related problems for its user. All other features, vital though they may be, support this basic purpose</em>. Therefore, DDD is an approach to software development centering around the requirements, rules, and processes of a business domain.</p>
			<p>The DDD approach includes two core concepts: bounded context and ubiquitous language. Let's dive deeper into each of them:</p>
			<ul>
				<li><strong class="bold">Bounded context</strong>: Bounded contexts help you to define the logical boundaries of a solution. They can be implemented on the application or business layer, as per the <a id="_idIndexMarker535"/>requirements of the organization. However, the <a id="_idIndexMarker536"/>core concept is that a bounded context should have its own application, data, and process. This allows the respective teams to clearly define the components they own in a specific domain. These boundaries are important in managing data quality and minimizing data silos, as they grow with different Vs and get redistributed with different consumers within or outside an organization. For example, with a connected HBS solution, there can be different business capabilities required by the internal business functions of HBS and their end consumers. This could include the following:<ul><li>Internal capabilities (for the organizational entities):<ul><li><em class="italic">Product engineering</em>: The utilization of different services or features</li><li><em class="italic">Fleet operation</em>: Monitoring fleet health </li><li><em class="italic">Information security</em>: Monitoring the adherence to different regulatory requirements, such as GDPR</li><li>More such as CRM, ERP, and marketing</li></ul></li><li>External capabilities (for the end consumer):<ul><li><em class="italic">Fleet telemetry</em>: The processing of data feeds such as a thermostat or HVAC readings from devices in near real time </li><li><em class="italic">Fleet monitoring</em>: Capturing fleet health information or critical events such as the malfunctioning of sensors </li><li><em class="italic">Fleet analytics</em>: Enriching telemetry data with other metadata to perform analysis factoring in different environmental factors such as time, location, and altitude</li></ul></li></ul><p>The following<a id="_idIndexMarker537"/> diagram is an illustration of a bounded<a id="_idIndexMarker538"/> context:</p></li>
			</ul>
			<div>
				<div id="_idContainer078" class="IMG---Figure">
					<img src="Images/B17595_06_02.jpg" alt="Figure 6.2 – A bounded context &#13;&#10;" width="1405" height="657"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.2 – A bounded context </p>
			<p>All of these different business capabilities can be defined as a bounded context. So, now the business capabilities have been determined, we can define the technology requirements within this bounded context to deliver the required business outcome. The general rule of thumb is that the applications, data, or processes should be cohesive and not span for consumption by other contexts. In this chapter, we are going to primarily focus on building bounded contexts for external capabilities that are required by end consumers using different technologies. </p>
			<p class="callout-heading">Note </p>
			<p class="callout">However, in the real world, there can be many additional factors to bear in mind when it comes to defining a bounded context, such as an organizational structure, product ownership, and more. We will not be diving deep into these factors as they are not relevant to the topic being discussed here. </p>
			<ul>
				<li><strong class="bold">Ubiquitous language</strong>: The <a id="_idIndexMarker539"/>second concept in DDD is <a id="_idIndexMarker540"/>ubiquitous language. Each bounded context is supposed to have its own ubiquitous language. Applications that belong together within a bounded context should all follow the same language. If the bounded context changes, the ubiquitous language is also expected to be different. This allows the bounded context to be developed and managed by one team and, therefore, aligns with the DevOps methodology as well. This operating model makes it easier for a single team, familiar with the ubiquitous language, to own and resolve different applications or data dependencies quicker.Later in this chapter, you will discover how the different bounded contexts (or workflows) are implemented using a diverse set of languages.<p class="callout-heading">Note</p><p class="callout">The DDD model doesn't mandate how to determine the bounded context within application or data management. Therefore, it's recommended that you work backward from your use case and determine the appropriate cohesion.</p></li>
			</ul>
			<p>So, with this foundation, let's define some design principles of data management on the cloud – some of these will be used for the remainder of the chapter. </p>
			<h2 id="_idParaDest-121"><a id="_idTextAnchor125"/>What are the principles to design data workflows using DDD?</h2>
			<p>We will outline a set of<a id="_idIndexMarker541"/> guardrails (that is principles) to understand how to design data workloads using DDD:</p>
			<ul>
				<li><em class="italic">Principle 1: Manage data ownership through domains</em> – The quality of the data along with the ease of usability are the advantages of using domains. The team that knows the data best, owns and manages it. Therefore, the data ownership is distributed as opposed to being centralized.</li>
				<li><em class="italic">Principle 2: Define domains using bounded contexts</em> – A domain implements a bounded context, which, in turn, is linked to a business capability. </li>
				<li><em class="italic">Principle 3: Link a bounded context to one or many application workloads</em> – A bounded context can include one or many applications. If there are multiple applications, all of them are expected to deliver value for the same business capability.</li>
				<li>\<em class="italic">Principle 4: Share the ubiquitous language within the bounded context</em> – Applications that are responsible for distributing data within their bounded context use the same ubiquitous language to ensure that different terminologies and data semantics do not conflict. Each bounded context has a one-to-one relationship with a conceptual data model.</li>
				<li><em class="italic">Principle 5: Preserve the original sourced data</em> – Ingested raw data needs to be preserved as a source of truth in a centralized solution. This is often referred to as the golden dataset. This will allow different bounded contexts to repeat the processing of data in the case of failures. </li>
				<li><em class="italic">Principle 6: Associate data with metadata</em> – With the growth of data in terms of variety and volume, it's necessary for any dataset to be easily discoverable and classified. This eases the reusability of data by different downstream applications along with establishing a data lineage.</li>
				<li><em class="italic">Principle 7: Use the right tool for the right job</em> – Based on the data workflow such as the speed layer or the batch layer, the persistence and compute tools will be different. </li>
				<li><em class="italic">Principle 8: Tier data storage</em> – Choose the optimal storage layer for your data based on its access patterns. By distributing the datasets into different storage services, you can build a cost-optimized storage infrastructure.</li>
				<li><em class="italic">Principle 9: Secure and govern the data pipeline</em> – Implement control to secure and govern all data at rest and in transit. A mechanism is required to only allow authorized entities to visualize, access, process, and modify data assets. This helps us to protect data confidentiality and data security. </li>
				<li><em class="italic">Principle 10: Design for Scale</em> – Last but not least, the cloud is all about the economies of<a id="_idIndexMarker542"/> scale. So, take advantage of the managed services to scale elastically and handle any volume of data reliably. </li>
			</ul>
			<p>In the remainder of the chapter, we will touch upon most of these design principles (if not all) as we dive deeper into the different design patterns, data flows, and hands-on labs.</p>
			<h1 id="_idParaDest-122"><a id="_idTextAnchor126"/>Designing data patterns on the cloud</h1>
			<p>As data flows from<a id="_idIndexMarker543"/> the edge to the cloud securely over<a id="_idIndexMarker544"/> different channels (such as through speed or batch layers), it is a common practice to store the data in different staging areas or a centralized location based on the data velocity or data variety.These data sources act as a single source of truth and help to ensure the quality of the data for their respective bounded contexts. Therefore, in this section, we will discuss different data storage options, data flow patterns, and anti-patterns on the cloud. Let's begin with data storage.</p>
			<h2 id="_idParaDest-123"><a id="_idTextAnchor127"/>Data storage</h2>
			<p>As we learned, in earlier <a id="_idIndexMarker545"/>chapters, since edge solutions are constrained in terms of computing resources, it's important to optimize the number of applications or the amount of data persisted locally based on the use case. On the other hand, the cloud doesn't have that constraint, as it comes with virtually unlimited resources with different compute and storage options. This makes it a perfect fit for big data applications to grow and contract based on the demand. In addition to this, it provides easy access to a global infrastructure to orchestrate data required by different downstream or end consumers in the region that is closer to them. Finally, data is more valuable when it's augmented with other data or metadata; thus, in recent times, patterns such as data lakes have become very popular. So, what is a data lake? </p>
			<p>A data lake<a id="_idIndexMarker546"/> is a centralized, secure, and durable storage platform that allows you to ingest, store structured and unstructured data, and transform the raw data as required. You can think of data lake as a superset of the data pond concepts introduced in <a href="B17595_05_Final_SS_ePub.xhtml#_idTextAnchor090"><em class="italic">Chapter 5</em></a><em class="italic">,</em><em class="italic"> Ingesting and Streaming Data from the Edge</em>. Since the IoT devices or gateways are relatively low in storage, only highly valuable data that's relevant for the edge operations can be persisted locally in a data pond:</p>
			<div>
				<div id="_idContainer079" class="IMG---Figure">
					<img src="Images/B17595_06_03.jpg" alt="Figure 6.3 – The data lake architecture&#13;&#10;" width="1421" height="704"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.3 – The data lake architecture</p>
			<p>Some of the foundational characteristics<a id="_idIndexMarker547"/> of the data lake architecture are explained here: </p>
			<ul>
				<li>There is central storage for storing raw data with minimal or no transformation securely. This is a single source of truth of data. The choice of compute, storage layer, schema, ingestion frequency, and data quality is left to the data producer. Amazon S3 is commonly chosen as the central storage since it's a highly scalable, highly durable, and cost-effective service that allows the decoupling of the compute and storage layers. AWS offers different tiering options within Amazon S3 along with a full-fledged archival service referred to as Amazon Glacier.</li>
				<li>There is a persistence layer for storing domain-specific data marts or transformed data in a columnar format (such as Parquet, ORC, or Avro) to achieve isolation by bounded contexts, faster performance, or lower cost. AWS offers different services such as AWS Glue for data transformation and data catalogs, Amazon Athena or Amazon Redshift for data warehouses and data marts, and Amazon EMR or Spark on EMR for managing big data processing. </li>
				<li>There is a<a id="_idIndexMarker548"/> persistence layer for storing transactional data ingested from the edge securely. This layer is often referred to as <a id="_idIndexMarker549"/>the <strong class="bold">Operational Data Store</strong> (<strong class="bold">ODS</strong>). AWS offers different services that can be leveraged here based on the given data structures and access patterns, such as Amazon DynamoDB, Amazon RDS, and Amazon Timestream. </li>
			</ul>
			<p>You must be wondering how data from a data lake is made available to a data warehouse or an ODS. That's where data integration patterns play a key role.</p>
			<h2 id="_idParaDest-124"><a id="_idTextAnchor128"/>Data integration patterns</h2>
			<p><strong class="bold">Data Integration and Interoperability</strong> (<strong class="bold">DII</strong>) happens through <a id="_idIndexMarker550"/>the batch, speed, and serving layers. A common <a id="_idIndexMarker551"/>methodology in the big data world that intertwines all these layers<a id="_idIndexMarker552"/> is <strong class="bold">Extract, Transform, and Load</strong> (<strong class="bold">ETL</strong>) or <strong class="bold">Extract, Load, and Transform</strong> (<strong class="bold">ELT</strong>). We have already explained these concepts, in detail, in <a href="B17595_05_Final_SS_ePub.xhtml#_idTextAnchor090"><em class="italic">Chapter 5</em></a>, <em class="italic">Ingesting and Streaming Data from the Edge</em>, and discussed how they <a id="_idIndexMarker553"/>have evolved with time into different data flow patterns such as event-driven, batch, lambda, and complex event processing. Therefore, we will not be repeating the concepts here. But in the next section, we will explain how they relate to data workflows in the cloud.</p>
			<h2 id="_idParaDest-125"><a id="_idTextAnchor129"/>Data flow patterns</h2>
			<p>Earlier in this chapter, we <a id="_idIndexMarker554"/>discussed how bounded contexts can be used to segregate different external capabilities for end consumers, such as <em class="italic">fleet telemetry</em>, <em class="italic">fleet monitoring</em>, or <em class="italic">fleet analytics</em>. Now, it's time to learn how these concepts can be implemented using different data flow patterns.</p>
			<h3>Batch (or aggregated processing) </h3>
			<p>Let's consider a scenario; you discover that you have been getting a higher electricity bill for the last six months, and you would like to compare the utilization of different equipment for that time period. Alternatively, you want visibility of more granular information, such as how many times did the washing machine run during the day in the last six months? And for how long? This led to how many X watts of consumption? </p>
			<p>This is where batch processing<a id="_idIndexMarker555"/> helps. It had been the de facto<a id="_idIndexMarker556"/> standard of the industry before event-driven architecture gained popularity and is still heavily used for different use cases such as order management, billing, payroll, financial statements, and more. In this mode of processing, a large volume of data, such as thousands or hundreds of thousands of records (or more), is typically transmitted in a file format (such as <strong class="source-inline">TXT</strong> or <strong class="source-inline">CSV</strong>), cleaned, transformed, and loaded into a relational database or data warehouse. Thereafter, the data is used for data reconciliation or analytical purposes. A typical batch processing environment also includes a job scheduler that can trigger an analytical workflow based on schedules of feed availability or those that are required by the business.</p>
			<p>To design the <em class="italic">fleet analytics</em> bounded context, we have designed a batch workflow, as follows: </p>
			<div>
				<div id="_idContainer080" class="IMG---Figure">
					<img src="Images/B17595_06_04.jpg" alt="Figure 6.4 – The batch architecture &#13;&#10;" width="1629" height="544"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.4 – The batch architecture </p>
			<p>In this pattern, the following activities are taking place:</p>
			<ul>
				<li>Events streamed from the edge are routed through a streaming service (that is, Amazon Kinesis) to a data lake (that is, Amazon S3).</li>
				<li>Amazon Kinesis allows the preprocessing or enrichment of the data (if required) with additional metadata prior to persisting it to a data lake. </li>
				<li>The data can be crawled or transformed through an ETL engine (that is, AWS Glue) and be easily queried using a serverless analytical service (that is, Amazon Athena). Amazon Athena uses a Presto engine under the hood and is compatible with ANSI SQL. </li>
				<li>Different <a id="_idIndexMarker557"/>services such as Amazon S3 and Amazon Athena offer integrations with Amazon QuickSight and different third-party <strong class="bold">Business Intelligence</strong> (<strong class="bold">BI</strong>) tools through JDBC and ODBC connectors. </li>
				<li>Amazon S3 is <a id="_idIndexMarker558"/>highly available and durable object storage that integrates with other big data services such as a fully managed Hadoop cluster (that is, Amazon EMR) or a data warehouse (that is, Amazon Redshift). <p class="callout-heading">Fun fact</p><p class="callout">Amazon EMR and Amazon Redshift support big data processing through decoupling of the compute layer and the storage layer, which means there is no need to copy all the data to local storage from the data lake. Therefore, processing becomes more cost-efficient and operationally optimal.</p></li>
			</ul>
			<p>The ubiquitous language used in this bounded context includes the following:</p>
			<ul>
				<li>A REST API for stream processing on Amazon Kinesis, data processing on Amazon S3 buckets, and ETL processing on AWS Glue</li>
				<li>SQL for data analytics on Amazon Athena and Amazon Redshift </li>
				<li>MapReduce or Spark for data processing on Amazon EMR</li>
				<li>Rest APIs, JDBC, or ODBC connectors with Amazon QuickSight or third-party BI tools</li>
			</ul>
			<p>Batch processing is <a id="_idIndexMarker559"/>powerful since it doesn't have any windowing<a id="_idIndexMarker560"/> restrictions. There is a lot of flexibility in terms of how to correlate individual data points with the entire dataset, whether it's terabytes or exabytes in size for desired analytical outcomes. </p>
			<h3>Event-driven processing</h3>
			<p>Let's consider the<a id="_idIndexMarker561"/> following scenario: you have rushed out of your home, and you get a notification after boarding your commute that you left the cooking stove on. Since you have a connected stove, you can<a id="_idIndexMarker562"/> immediately turn it off remotely from an app to avoid fire hazards. Bingo!</p>
			<p>This looks easy, but there is a certain level of intelligence required at the local hub (such as HBS hub) and a chain of events to facilitate this workflow. These might include the following:</p>
			<ul>
				<li>Detect from motion sensors, occupancy sensors, or cameras that no one is at home.</li>
				<li>Capture multiple measurements from stove sensors over a period of time.</li>
				<li>Correlate the events to identify this as a hazard scenario using local processes at the edge.</li>
				<li>Stream an event to a message broker and persist it in an ODS.</li>
				<li>Trigger a microservice(s) to notify this event to the end user.</li>
				<li>Remediate the issue based on user response.</li>
			</ul>
			<p>So, as you can <a id="_idIndexMarker563"/>observe, a lot is happening in a matter of seconds between the<a id="_idIndexMarker564"/> edge, the cloud, and the end user to help mitigate the hazard. This is where patterns such as event-driven architectures became very popular in the last decade or so. </p>
			<p>Prior to EDA, polling and Webhooks were the common mechanisms in which to communicate events between different components. Polling is inefficient since there is always a lag in terms of how to fetch new updates from the data source and sync them with downstream services. Webhooks are not always the first choice, as they might require custom authorization and authentication configurations. In short, both of these methods require additional work to be integrated or have scaling issues. Therefore, you have the concept of events, which can be filtered, routed, and pushed to different other services or systems with less bandwidth and lower resource utilization since the data is transmitted as a stream of small events or datasets. Similar to the edge, streaming allows the data to be processed as it arrives without incurring any delay. </p>
			<p>Generally, event-driven architectures come in two topologies, the mediator topology and the broker topology. We have explained them here:</p>
			<ul>
				<li><strong class="bold">The mediator topology</strong>: There is a need for a central controller or coordinator for event<a id="_idIndexMarker565"/> processing. This is generally useful when there is a chain of steps for processing events.</li>
				<li><strong class="bold">The broker topology</strong>: There is no mediator, as the events are broadcast through a broker to <a id="_idIndexMarker566"/>different backend consumers.</li>
			</ul>
			<p>The broker topology is very common with edge workloads since it decouples the edge from the cloud and allows the overall solution to scale better. Therefore, for the fleet telemetry bounded context, we have designed an event-driven architecture using a broker topology, as shown in the following diagram. </p>
			<p>In the following data flow, the events streamed from a connected HBS hub (that is, the edge) are routed over MQTT to an IoT gateway (that is, AWS IoT Core), which allows the filtering of data (if required) through an in-built rules engine and persists the data to an ODS (that is, Amazon DynamoDB). Amazon DynamoDB is a highly performant nonrelational database service that can scale automatically based on the volume of data streamed from millions of edge devices. From the previous chapter, you should already be familiar with how to model data and optimize NoSQL databases for time series data. Once the data is persisted in Amazon DynamoDB, <strong class="bold">Create, Read, Update, and Delete</strong> (<strong class="bold">CRUD</strong>) operations can be performed on top of the data using serverless functions (that is, AWS Lambda). Finally, the data is made available through an API access layer (that is, the Amazon API gateway) in a synchronous or asynchronous manner:</p>
			<div>
				<div id="_idContainer081" class="IMG---Figure">
					<img src="Images/B17595_06_05.jpg" alt="Figure 6.5 – Streaming architecture&#13;&#10;" width="1500" height="374"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.5 – Streaming architecture</p>
			<p>The ubiquitous language used in this bounded context includes the following:</p>
			<ul>
				<li>SQL for DynamoDB table access</li>
				<li>Python for developing a lambda function</li>
				<li>A REST API for API gateway and DynamoDB access</li>
			</ul>
			<p>Stream processing and EDA is powerful for many IoT use cases that require near-real-time attention such as alerting, anomaly detection, and more, as it analyzes the data as soon as it arrives. However, there is a trade-off with every architecture and EDA is no exception either. With a stream, since the processed results are made available immediately, the analysis of a particular data point cannot consider future values. Even for past values, it's restricted to a shorter time interval, which is generally specified through different windowing mechanisms (such as sliding, tumbling, and more). And that's where batch processing plays a key role. </p>
			<h3>Complex event processing</h3>
			<p>Let's consider the following scenario where you plan to reduce food wastage at your home. Therefore, every time you check-in at a grocery store, you receive a notification with a list of perishable items in your refrigerator (or food shelf), as they have not even been opened or are underutilized and are nearing their expiry date. </p>
			<p>This might sound <a id="_idIndexMarker567"/>like an easy problem to solve, but there is a certain amount of intelligence required at the local hub (such as HBS hub) and a complex event processing<a id="_idIndexMarker568"/> workflow on the cloud to facilitate this. It might include the following: </p>
			<ul>
				<li>Based on location sharing and user behavior, the ability to recognize the pattern (or a special event) that the user plans to do grocery shopping.</li>
				<li>Detect from camera sensors installed in the refrigerator or on the food shelves that some of the perishable items are due to expire. Alternatively, use events from smell sensors to detect a pattern of rotten food items.</li>
				<li>Correlate all these patterns (that is, the user, location, and food expiry date) through state machines and apply business rules to identify the list of items that requires attention.</li>
				<li>Trigger a microservice(s) to notify this information to the end user.</li>
			</ul>
			<p>This problem might become further complicated for a restaurant business due to the volume of perishable items and the scale at which they operate. In such a scenario, having near real-time visibility to identify waste based on current practices can help the business optimize its supply chain and save a lot of costs. So, as you can imagine, the convergence of edge and IoT with big data processing capabilities such as CEP can help unblock challenging use cases. </p>
			<p>Processing and querying events as they arrive in small chunks or in bulk is relatively easier compared to recognizing patterns by correlating events. That's where CEP is useful. It's considered as a subset of stream processing with the focus to identify special (or complex) events by correlating events from multiple sources or by listening to telemetry data for a longer period of time. One of the common patterns to implement CEP is by building state machines.</p>
			<p>In the following flow, the<a id="_idIndexMarker569"/> events streamed from a connected<a id="_idIndexMarker570"/> HBS hub (that is, the edge) are routed over MQTT to an IoT gateway (that is, AWS IoT Core), which filters the complex events based on set criteria and pushes them to different state machines defined within the complex event processing engine (that is, AWS IoT events). AWS IoT events is a fully managed CEP service that allows you to monitor equipment or device fleets for failure or changes in operation and, thereafter, trigger actions based on defined events:</p>
			<div>
				<div id="_idContainer082" class="IMG---Figure">
					<img src="Images/B17595_06_06.jpg" alt="Figure 6.6 – CEP architecture&#13;&#10;" width="1355" height="351"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.6 – CEP architecture</p>
			<p>The ubiquitous language used in the fleet monitoring bounded context includes the following:</p>
			<ul>
				<li>State machines for complex event processing</li>
				<li>A REST API for notifications or subscriptions through <strong class="bold">Amazon Simple Notification Service</strong> (<strong class="bold">SNS</strong>) </li>
			</ul>
			<p>CEP can be useful for many IoT use cases that require attention based on events from multiple sensors, timelines, or other environmental factors. </p>
			<p>There can be many other design patterns that you need to consider in order to design a real-life IoT workload. Those could be functional or non-functional requirements such as data archival for regulatory requirements, data replication for redundancy, and disaster recovery for achieving required RTO or RPO; however, that's beyond the scope of this book, as these are general principles and not necessarily related to edge computing or IoT workloads. There are many other books or resources available on those topics if they are of interest to you.</p>
			<h2 id="_idParaDest-126"><a id="_idTextAnchor130"/>Data flow anti-patterns for the cloud</h2>
			<p>The anti-patterns for processing data on the cloud from edge devices can be better explained using three laws – the law of physics, the law of economics, and the law of the land:</p>
			<ul>
				<li><strong class="bold">Law of physics</strong>: For use cases where latency is critical, keeping data processing closer to the <a id="_idIndexMarker571"/>event source is usually the best approach, since we cannot beat the speed of light, and thus, the round-trip latency might not be affordable. Let's consider a scenario where an autonomous vehicle needs to apply a hard brake after detecting a pedestrian; it cannot afford the round-trip latency from the cloud. This factor is also relevant for physically remote environments, such as mining, oil, and gas facilities where there is poor or intermittent network coverage. Even for our use case here, with connected HBS, if there is a power or network outage, the hub is still required to be intelligent enough to detect intrusion by analyzing local events. </li>
				<li><strong class="bold">Law of economics</strong>: The cost of compute and storage has reduced exponentially in the las<a id="_idIndexMarker572"/>t few decades compared to networking cost, which might still become prohibitive at scale. Although digital transformation has led to data proliferation across different industries, much of the data is of low quality. Therefore, local aggregation and the filtering of data on the edge will allow you to publish high-value data to the cloud only reducing networking bandwidth costs. </li>
				<li><strong class="bold">Law of the land</strong>: Most industries need to comply with regulations or compliance requirements<a id="_idIndexMarker573"/> related to data sovereignty. Therefore, the local retention of data in a specific facility, region, or country might turn out to be a key factor in the processing of data. Even for our use case here with connected HBS, the workload might need to be in compliance with GDPR requirements. </li>
			</ul>
			<p>AWS offers different edge services for supporting use cases that need to comply with the preceding laws and are not limited to IoT services only. For example, consider the following:</p>
			<ul>
				<li><strong class="bold">Infrastructure</strong>: AWS Local Zones, AWS Outposts, and AWS Wavelength</li>
				<li><strong class="bold">Networking</strong>: Amazon CloudFront, and POP locations </li>
				<li><strong class="bold">Storage</strong>: AWS Storage Gateway</li>
				<li><strong class="bold">Rugged and disconnected edge devices</strong>: AWS Snowball Edge and AWS Snowcone</li>
				<li><strong class="bold">Robotics</strong>: AWS Robomaker</li>
				<li><strong class="bold">Video analytics</strong>: Amazon Kinesis Video Streams</li>
				<li><strong class="bold">Machine learning</strong>: Amazon Sagemaker Neo, Amazon Sagemaker Edge Manager, Amazon Monitron, and AWS Panorama</li>
			</ul>
			<p>The preceding services are beyond the scope of the book, and the information is only provided for you to be well informed of the breadth and depth of AWS edge services.</p>
			<h1 id="_idParaDest-127"><a id="_idTextAnchor131"/>A hands-on approach with the lab</h1>
			<p>In this section, you will learn how to design a piece of architecture on the cloud leveraging the concepts that you have learned in this chapter. Specifically, you will continue to use the lambda architecture pattern introduced in <a href="B17595_05_Final_SS_ePub.xhtml#_idTextAnchor090"><em class="italic">Chapter 5</em></a>, <em class="italic">Ingesting and Streaming Data from the Edge</em>, to process the data on the cloud:</p>
			<div>
				<div id="_idContainer083" class="IMG---Figure">
					<img src="Images/B17595_06_07.jpg" alt="Figure 6.7 – Hands-on architecture&#13;&#10;" width="1333" height="613"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.7 – Hands-on architecture</p>
			<p>In the previous chapter, you already completed steps 1 and 4. This chapter will help you to complete steps 2, 3, 5, 6, and 7, which includes consuming the telemetry data and building an analytics pipeline for performing BI: </p>
			<div>
				<div id="_idContainer084" class="IMG---Figure">
					<img src="Images/B17595_06_08.jpg" alt="Figure 6.8 – Hands-on lab components &#13;&#10;" width="969" height="383"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.8 – Hands-on lab components </p>
			<p>In this hands-on section, your objectives include the following:</p>
			<ol>
				<li>Query the ODS.</li>
				<li>Build an API interface layer to enable data consumption.</li>
				<li>Build an ETL layer for processing telemetry data in the data lake.</li>
				<li>Visualize the data through a BI tool.</li>
			</ol>
			<h2 id="_idParaDest-128"><a id="_idTextAnchor132"/>Building cloud resources</h2>
			<p>This lab builds on top of the <a id="_idIndexMarker574"/>cloud resources that you have already deployed in <a href="B17595_05_Final_SS_ePub.xhtml#_idTextAnchor090"><em class="italic">Chapter 5</em></a>, <em class="italic">Ingesting and Streaming Data from the Edge</em>. So, please ensure you have completed the hands-on section there prior to proceeding with the following steps here. In addition, please go ahead and deploy the CloudFormation template from the <strong class="source-inline">chapter 6/cfn</strong> folder to create the resources required in this lab, such as the AWS API gateway, lambda functions, and AWS Glue crawler. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">Please retrieve the parameters required for this CloudFormation template (such as an S3 bucket) from the <em class="italic">Output</em> section of the deployed CloudFormation stack of <a href="B17595_05_Final_SS_ePub.xhtml#_idTextAnchor090"><em class="italic">Chapter 5</em></a>, <em class="italic">Ingesting and Streaming Data from the Edge</em>. </p>
			<p class="callout">In addition to this, you can always find the specific resource names required for this lab (such as lambda functions) from the <em class="italic">Resources</em> or <em class="italic">Output</em> sections of the deployed CloudFormation stack. It is a good practice to copy those into a notepad locally so that you can refer to them quickly.</p>
			<p>Once the CloudFormation has been deployed successfully, please continue with the following steps. </p>
			<h2 id="_idParaDest-129"><a id="_idTextAnchor133"/>Querying the ODS</h2>
			<p>Navigate to the AWS <a id="_idIndexMarker575"/>console and try to generate insights from the data persisted in the operational (or transactional) data store. As you learned in the previous chapter, all the near real-time data processed is persisted in a DynamoDB table (<strong class="source-inline">packt_sensordata</strong>):</p>
			<ol>
				<li value="1">To query the data, navigate to <strong class="bold">DynamoDB Console</strong>, select <strong class="bold">Tables</strong> (from the left-hand pane), click on the table, and then click on <strong class="bold">View items</strong>. </li>
				<li>Click on the <strong class="bold">Query</strong> tab. Put a value of <strong class="source-inline">1</strong> into the <strong class="source-inline">device_id</strong> partition key and click on <strong class="bold">Run</strong>. This should return a set of data points with all the attributes. </li>
				<li>Expand the filters section, and add filters to the following attributes:  <ul><li><strong class="bold">Attribute name</strong> – <strong class="source-inline">temperature</strong>.</li><li><strong class="bold">Type</strong> – <strong class="bold">Number</strong>.</li><li><strong class="bold">Condition</strong> – <strong class="bold">Greater than or Equal</strong>. </li><li><strong class="bold">Value</strong> – <strong class="bold">50</strong>.  </li><li>Click <strong class="bold">Add filter</strong>.</li><li><strong class="bold">Attribute name</strong> – <strong class="source-inline">humidity</strong>.</li><li><strong class="bold">Type</strong> – <strong class="bold">Number</strong>.</li><li><strong class="bold">Condition</strong> – <strong class="bold">Greater than or Equal</strong>. </li><li><strong class="bold">Value</strong> – <strong class="bold">35</strong>.  </li><li>Click on <strong class="bold">Run</strong>. </li></ul><p>Here, the query interface allows you to filter the data quickly based on different criteria. If you are familiar with SQL, you can also try the PartiQL editor, which is on the DynamoDB console. </p></li>
				<li>Additionally, DynamoDB allows you to scan an entire table or index, but this is generally an expensive operation, particularly for a large dataset. To scan a table, click on the <strong class="bold">Scan</strong> tab (which is adjacent to <strong class="bold">Query</strong>) and then click on <strong class="bold">Run</strong>. </li>
			</ol>
			<p>For better performance and faster response times, we recommend that you use <strong class="bold">Query</strong> over <strong class="bold">Scan</strong>. </p>
			<h3>AWS Lambda </h3>
			<p>In addition to having interactive <a id="_idIndexMarker576"/>query capabilities on data, you will often need to build a presentation layer and business logic for various other personas (such as consumers, fleet operators, and more) to access data. You can define the business logic layer using Lambda:</p>
			<ol>
				<li value="1">Navigate to the <strong class="bold">AWS Lambda</strong> console. Click on <strong class="bold">Functions</strong> (from the left-hand pane), and choose the function created using the CloudFormation template earlier.</li>
				<li>Do you remember that we created two facets (<strong class="source-inline">getItems</strong> and <strong class="source-inline">putItems</strong>) during the data modeling exercise in <a href="B17595_05_Final_SS_ePub.xhtml#_idTextAnchor090"><em class="italic">Chapter 5</em></a>, <em class="italic">Ingesting and Streaming Data from the Edge</em>, to access data? The following is the logic embedded in a lambda function to implement the equivalent functional construct. Please review the code to understand how the <strong class="source-inline">get</strong> and <strong class="source-inline">put</strong> functionalities work:<p class="source-code">  try {</p><p class="source-code">    switch (event.routeKey) {</p><p class="source-code">      case "GET /items/{device_id}":</p><p class="source-code">        var nid = String(event.pathParameters.id);</p><p class="source-code">        body = await dynamo</p><p class="source-code">          .query({</p><p class="source-code">            TableName: "&lt;table-name&gt;",</p><p class="source-code">            KeyConditionExpression: "id = :nid",</p><p class="source-code">            ExpressionAttributeValues: {</p><p class="source-code">              ":nid" : nid</p><p class="source-code">            }</p><p class="source-code">          })</p><p class="source-code">          .promise();</p><p class="source-code">        break;</p><p class="source-code">      case "GET /items":</p><p class="source-code">        body = await dynamo.scan({ TableName: "&lt;table-name&gt;" }).promise();</p><p class="source-code">        break;</p><p class="source-code">      case "PUT /items":</p><p class="source-code">        let requestJSON = JSON.parse(event.body);</p><p class="source-code">        await dynamo</p><p class="source-code">          .put({</p><p class="source-code">            TableName: "&lt;table-name&gt;",</p><p class="source-code">            Item: {</p><p class="source-code">              device_id: requestJSON.id,</p><p class="source-code">              temperature: requestJSON.temperature,</p><p class="source-code">              humidity: requestJSON.humidity,</p><p class="source-code">              device_name: requestJSON.device_name</p><p class="source-code">            }</p><p class="source-code">          })</p><p class="source-code">          .promise();</p><p class="source-code">        body = `Put item ${requestJSON.id}`;</p><p class="source-code">        break;</p><p class="source-code">      default:</p><p class="source-code">        throw new Error(`Unsupported route: "${event.routeKey}"`);</p><p class="source-code">    }</p><p class="source-code">  } catch (err) {</p><p class="source-code">    statusCode = 400;</p><p class="source-code">    body = err.message;</p><p class="source-code">  } finally {</p><p class="source-code">    body = JSON.stringify(body);</p><p class="source-code">  }</p><p class="source-code">  return {</p><p class="source-code">    statusCode,</p><p class="source-code">    body,</p><p class="source-code">    headers</p><p class="source-code">  };};</p></li>
			</ol>
			<p>Please note that <a id="_idIndexMarker577"/>here, we are using lambda functions. This is because serverless functions have become a common pattern to process event-driven data in near real time. Since it alleviates the need for you to manage or operate any servers throughout the life cycle of the application, your only responsibility is to write the code in a supported language and upload it to the Lambda console. </p>
			<p class="callout-heading">Fun fact</p>
			<p class="callout">AWS IoT Greengrass<a id="_idIndexMarker578"/> provides a Lambda runtime environment for the edge along with different languages such as Python, Java, Node.js, and C++. That means you don't need to manage two different code bases (such as embedded and cloud) or multiple development teams. This will cut down your development time, enable a uniform development stack from the edge to the cloud, and accelerate your time to market.</p>
			<h3>Amazon API gateway</h3>
			<p>Now the business logic has been<a id="_idIndexMarker579"/> developed using the lambda function, let's create the HTTP interface (aka the presentation layer) using Amazon API gateway. This is a managed service for creating, managing, and deploying APIs at scale:</p>
			<ol>
				<li value="1">Navigate to the <strong class="bold">Amazon API Gateway</strong> console, click on <strong class="bold">APIs</strong> (from the left-hand pane), and choose the API (<strong class="source-inline">MyPacktAPI</strong>) created using the CloudFormation template. </li>
				<li>Expand the <strong class="bold">Develop</strong> section (in the left-hand pane). Click on <strong class="bold">Routes</strong> to check the created <strong class="source-inline">REST</strong> methods.</li>
				<li>You should observe the following operations:<p class="source-code">/items GET – allows accessing all the items on the DynamoDB table (can be an expensive operation)</p></li>
				<li>Continue underneath the <strong class="bold">Develop</strong> drop-down menu. Click on <strong class="bold">Authorization</strong> and check the respective operations. We have not attached any authorizer in this lab, but it's recommended for real-world workloads. API gateway offers different forms of authorizers, including built-in IAM integrations, <strong class="bold">JSON Web Tokens</strong> (<strong class="bold">JWT</strong>), or <a id="_idIndexMarker580"/>custom logic using lambda functions. </li>
				<li>Next, click on <strong class="bold">Integrations</strong> (underneath <strong class="bold">Develop</strong>) and explore the different REST operations (such as <strong class="source-inline">/items GET</strong>). On the right-hand pane, you will see the associated lambda functions. For simplicity, we are using the same lambda function here for all operations, but you can choose other functions or targets such as Amazon SQS, Amazon Kinesis, a private resource in your VPC, or any other HTTP URI if required for your real-world use case.</li>
				<li>There are many additional options offered by API gateway that relate to CORS, reimport/export, and throttling, but they are not considered in the scope of this lab. Instead, we will focus on executing the HTTP APIs and retrieving the sensor data.</li>
				<li>Click on the <strong class="bold">API</strong> tab (in the left-hand pane), copy the invoke URL underneath <strong class="bold">Stages</strong>, and run the following commands to retrieve (or <strong class="source-inline">GET</strong>) items from your device Terminal:<p class="source-code">a. Query all items from the table </p><p class="source-code">curl https://xxxxxxxx.executeapi.&lt;region&gt;.amazonaws.com/items</p><p>You should see a <a id="_idIndexMarker581"/>long list of items on our Terminal that has been retrieved from the <strong class="source-inline">dynamodb</strong> table. </p></li>
			</ol>
			<p>Amazon API gateway allows you to create different types of APIs, and the one configured earlier falls into the HTTP API category that allows access to lambda functions and other HTTP endpoints. Additionally, we could have used the REST APIs here, but the HTTP option was chosen for its simplicity of use, as it can automatically stage and deploy the required APIs without any additional effort and can be more cost-effective. In summary, you have now completed implementing the bounded context of an ODS through querying or API interfaces. </p>
			<h2 id="_idParaDest-130"><a id="_idTextAnchor134"/>Building the analytics workflow </h2>
			<p>In this next section, you will <a id="_idIndexMarker582"/>build an analytics pipeline on the batch data persisted on Amazon S3 (that is, the data lake). To achieve this, you can use AWS Glue to crawl data and generate a data catalog. Thereafter, you will use Athena for interactive querying and use QuickSight for visualizing data through charts/dashboards.</p>
			<h3>AWS Glue</h3>
			<p>AWS Glue is a<a id="_idIndexMarker583"/> managed service that offers many ETL functionalities, such as data crawlers, data catalogs, batch jobs, integration with CI/CD pipelines, Jupyter notebook integration, and more. Primarily, you will use the data crawler and cataloging capabilities in this lab. We feel that might be sufficient for IoT professionals since data engineers will be mostly responsible for these activities in the real world. However, if you believe in learning and are curious, please feel free to play with the other features:</p>
			<ol>
				<li value="1">Navigate to the <strong class="bold">AWS Glue</strong> console, click on <strong class="bold">Crawlers</strong> (from the left-hand pane), and select the crawler created earlier using the CloudFormation template. </li>
				<li>Review some of the key attributes of the crawler definition, such as the following:<ul><li>State: Is the crawler ready to run? </li><li>Schedule: Is the frequency of the crawler set correctly? </li><li>Data store: S3.</li><li>Include path: Is the location of the dataset correct? This should point to the raw sensor data bucket. </li><li>Configuration options: Is the table definition being updated in the catalog based on upstream changes?</li></ul></li>
				<li>Additionally, Glue<a id="_idIndexMarker584"/> allows you to process different data formats through its classifier functionality. You can process the most common data formats such as Grok, XML, JSON, and CSV with its built-in classifiers along with specifying custom patterns if you have data in a proprietary format.</li>
				<li>Here, the crawler should run on the specified schedule configured through CloudFormation; however, you can also run it on demand by clicking on <strong class="bold">Run Crawler</strong>. If you do the same, please wait for the crawler to complete the transition from the <strong class="bold">starting</strong> -&gt; <strong class="bold">running</strong> -&gt; <strong class="bold">stopping</strong> -&gt; <strong class="bold">ready</strong> status. </li>
				<li>Now the data crawling is complete, navigate to <strong class="bold">Tables</strong> (from the left-hand pane) and confirm whether a table (or tables) resembling the name of <strong class="source-inline">*packt*</strong> has been created. If you have a lot of tables already created, another quick option is to use the search button and filter on <strong class="bold">Database</strong>: <strong class="source-inline">packt_gluedb</strong>. </li>
				<li>Click on the table to verify the properties, such as the database, the location, the input/output formats, and the table schema. Confirm the schema is showing the attributes that you are interested in retaining. If not, you can click on <strong class="bold">Edit</strong> schema and make the necessary changes:<div id="_idContainer085" class="IMG---Figure"><img src="Images/B17595_06_09.jpg" alt="Figure 6.9 – The table schema in Glue&#13;&#10;" width="780" height="540"/></div><p class="figure-caption">Figure 6.9 – The table schema in Glue</p></li>
				<li>Keep a note <a id="_idIndexMarker585"/>of the database and the table name, as you will need them in the next two sections.</li>
			</ol>
			<p>In this lab, you used a crawler with a single data source only; however, you can add multiple data sources if required by your use case. Once the data catalog is updated and the data (or metadata) is available, you can consume it through different AWS services. You might need to often clean, filter, or transform your data as well. However, these responsibilities are not generally performed by the IoT practitioners and, primarily, fall with the data analysts or data scientists. </p>
			<h3>Amazon Athena</h3>
			<p>Amazon Athena <a id="_idIndexMarker586"/>acts as a serverless data warehouse where you run analytical queries on the data that's curated by an ETL engine such as Glue. Athena uses a schema-on-read approach; thus, a schema is projected onto your data when you run a query. And since Athena enables the decoupling of the compute and storage layers, you can connect to different data lake services such as S3 to run these queries on. Athena uses Apache Hive for DDL operations such as defining tables and creating databases. For the different functions supported through queries, Presto is used under the hood. Both Hive and Presto are open source SQL engines:</p>
			<ol>
				<li value="1">Navigate to the <strong class="bold">AWS Athena</strong> console, and choose <strong class="bold">Data Sources</strong> from the left-hand pane.</li>
				<li>Keep the data source as <strong class="bold">default</strong> and choose the database name of <strong class="source-inline">packt_gluedb</strong>:<ul><li>This was created in the previous section by the Glue crawler automatically after scanning the S3 destination bucket, which is storing the batched sensor data.</li></ul></li>
				<li>This should populate the list of tables created under this database.</li>
				<li>Click on the three dots adjacent to the table resembling the name of <strong class="source-inline">*mysensordatabucket*</strong> and select <strong class="bold">Preview table</strong>. This should automatically build and execute the SQL query.</li>
			</ol>
			<p>This should <a id="_idIndexMarker587"/>bring up the data results with only 10 records. If you would like to view the entire dataset, please remove the 10-parameter limit from the end of the query. If you are familiar with SQL, please feel free to tweak the query and play with different attributes or join conditions. </p>
			<p class="callout-heading">Note </p>
			<p class="callout">Here, you processed JSON data streamed from an HBS hub device. But what if your organization wants to leverage a more lightweight data format? Athena offers native support for<a id="_idIndexMarker588"/> various data formats such as <strong class="source-inline">CSV</strong>, <strong class="source-inline">AVRO</strong>, <strong class="source-inline">Parquet</strong>, and <strong class="source-inline">ORC</strong> through the use of <strong class="bold">serializer-deserializer</strong> (<strong class="bold">SerDe</strong>) libraries. Even complex schemas are supported through regular expressions.  </p>
			<p>So far, you have crawled the data from the data lake, created the tables, and successfully queried the data. Now, in the final step, let's learn how to build dashboards and charts that can enable BI on this data.</p>
			<h3>QuickSight</h3>
			<p>As an IoT practitioner, building<a id="_idIndexMarker589"/> business dashboards might not be part of your core responsibilities. However, some basic knowledge is always useful. If you think of traditional BI solutions, it might take data engineers weeks or months to build complex interactive ad hoc data exploration and visualization capabilities. Therefore, business users are constrained to pre-canned reports and preselected queries. Also, these traditional BI solutions require significant upfront investments and don't perform as well at scale as the size of data sources grow. That's where Amazon QuickSight helps. It's a managed service that's easy to use, highly scalable, and supports complex capabilities required for business:</p>
			<ol>
				<li value="1">Navigate to the Amazon QuickSight console and complete the one-time setup, as explained here:<ul><li>Enroll for the Standard Edition (if you have not used it before).</li><li>Purchase SPICE capacity for the lab</li><li><em class="italic">Note that this has a 60-day trial, so be sure to cancel the subscription after the workshop to prevent getting charged</em>.</li><li>Click on your login user (in the upper-right corner), and select <strong class="bold">Manage QuickSight</strong> | <strong class="bold">Security &amp; Permissions</strong> | <strong class="bold">Add and Remove</strong> | <strong class="bold">Check Amazon Athena</strong> | <strong class="bold">Apply</strong>.</li><li>Click on the QuickSight logo (in the upper-left corner) to navigate to the home page.</li><li>Click on your login user (in the upper-right corner) and you will observe that your region preference is listed beneath your language preference. </li><li>Confirm or update the region so that it matches your working region.</li></ul></li>
				<li>Click on <strong class="bold">New Analysis</strong>, then <strong class="bold">New dataset</strong>, and choose <strong class="bold">Athena</strong>.</li>
				<li>Enter the data source name as <strong class="source-inline">packt-data-visualization</strong>, keep the workgroup as its default setting, and click on <strong class="bold">Create Data Source</strong>.</li>
				<li>Keep the Catalog as <strong class="bold">default</strong>, choose <strong class="bold">Database</strong>, and then select the table created in <em class="italic">step 5</em> of the <em class="italic">AWS Glue</em> section.</li>
				<li>Click on <strong class="bold">Select</strong>, choose to <a id="_idIndexMarker590"/>directly query your data, and then click on <strong class="bold">Visualize</strong> again.</li>
				<li>Now build the dashboard:<ul><li>Choose a timestamp for the <em class="italic">X</em>-axis (select <strong class="bold">MINUTE</strong> from the <strong class="bold">Value</strong> drop-down menu).</li><li>Choose the other readings such as <strong class="bold">device_id</strong>, <strong class="bold">temperature</strong>, and <strong class="bold">humidity</strong> for the <em class="italic">Y</em>-axis (select <strong class="bold">Average</strong> from the <strong class="bold">Value</strong> drop-down menu for each reading).</li></ul></li>
			</ol>
			<p>Feel free to play with different fields or visual types to visualize other smart home-related information. As you might have observed, while creating the dataset, QuickSight natively supports different AWS and third-party data sources such as Salesforce, ServiceNow, Adobe Analytics, Twitter, Jira, and more. Additionally, it allows instant access to the data through mobile apps (such as iOS and Android) for business users or operations to quickly infer data insights for a specific workload along with integrations to machine learning augmentation. </p>
			<p>Congratulations! You have completed the entire life cycle of data processing and data consumption on the cloud using different AWS applications and data services. Now, let's wrap up this chapter with a summary and knowledge-check questions. </p>
			<p class="callout-heading">Challenge zone (Optional) </p>
			<p class="callout">In the <em class="italic">Amazon API gateway</em> section, you built an interface to retrieve all the items from the <strong class="source-inline">dynamodb</strong> table. However, what if you need to extract a specific item (or set of items) for a particular device such as HVAC? That can be a less costly operation compared to scanning all data. </p>
			<p class="callout"><strong class="bold">Hint</strong>: You need to define a route such as <strong class="source-inline">GET /items {device_id}</strong>. Check the lambda function to gain a better understanding of how it will map to the backend logic.</p>
			<h1 id="_idParaDest-131"><a id="_idTextAnchor135"/>Summary</h1>
			<p>In this chapter, you were introduced to big data concepts relevant to IoT workloads. You learned how to design data flows using DDD approach along with different data storage and data integration patterns that are common with IoT workloads. You implemented a lambda architecture to process fleet telemetry data and an analytical pipeline. Finally, you validated the workflow by consuming data through the APIs and visualizing it through business dashboards. In the next chapter, you will learn how all of this data can be used to build, train, and deploy machine learning models. </p>
			<h1 id="_idParaDest-132"><a id="_idTextAnchor136"/>Knowledge check</h1>
			<p>Before moving on to the next chapter, test your knowledge by answering these questions. The answers can be found at the end of the book:</p>
			<ol>
				<li value="1">Can you think of at least two benefits of domain-driven design from the standpoint of edge workloads?</li>
				<li>True or false: bounded context and ubiquitous language are the same.</li>
				<li>What do you think is necessary to have an operational datastore or a data lake/data warehouse?</li>
				<li>Can you recall the design pattern name that brings together streaming and batch workflows?</li>
				<li>What strategy could you incorporate to transform raw data on the cloud?</li>
				<li>True or false: You cannot access data from a NoSQL data store through APIs.</li>
				<li>When would you use a mediator versus broker topology for the event-driven workload?</li>
				<li>Can you think of at least one benefit of using a serverless function for processing IoT data?</li>
				<li>What <strong class="bold">business intelligence</strong> (<strong class="bold">BI</strong>) services can you use for data exposition to end consumers?</li>
				<li>True or false: JSON is the most optimized data format for big data processing on the cloud.</li>
				<li>How would you build an API interface on top of your operational data store (or data lake)?</li>
			</ol>
			<h1 id="_idParaDest-133"><a id="_idTextAnchor137"/>References</h1>
			<p>Take a look at the following resources for additional information on the concepts discussed in this chapter:</p>
			<ul>
				<li><em class="italic">Data Management – Body of Knowledge</em>: <a href="https://www.dama.org/cpages/body-of-knowledge">https://www.dama.org/cpages/body-of-knowledge</a> </li>
				<li><em class="italic">Domain-Driven Design</em> by Eric Evans: <a href="https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software-ebook/dp/B00794TAUG">https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software-ebook/dp/B00794TAUG</a></li>
				<li><em class="italic">Domain Language</em>: <a href="https://www.domainlanguage.com/ddd">https://www.domainlanguage.com/ddd</a></li>
				<li><em class="italic">Big Data on AWS</em>: <a href="https://aws.amazon.com/big-data/use-cases/">https://aws.amazon.com/big-data/use-cases/</a></li>
				<li><em class="italic">AWS Serverless Data Analytics Pipeline</em>: <a href="https://d1.awsstatic.com/whitepapers/aws-serverless-data-analytics-pipeline.pdf">https://d1.awsstatic.com/whitepapers/aws-serverless-data-analytics-pipeline.pdf</a></li>
				<li>Modern serverless architecture on AWS: <a href="https://d1.awsstatic.com/architecture-diagrams/ArchitectureDiagrams/mobile-web-serverless-RA.pdf?did=wp_card&amp;trk=wp_card">https://d1.awsstatic.com/architecture-diagrams/ArchitectureDiagrams/mobile-web-serverless-RA.pdf?did=wp_card&amp;trk=wp_card</a></li>
				<li><em class="italic">BI Tools</em>: <a href="https://aws.amazon.com/blogs/big-data/tag/bi-tools/">https://aws.amazon.com/blogs/big-data/tag/bi-tools/</a></li>
			</ul>
		</div>
	</div></body></html>