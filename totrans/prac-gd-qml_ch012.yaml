- en: Chapter 4
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章
- en: Adiabatic Quantum Computing and Quantum Annealing
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 退火量子计算与量子退火
- en: '*Love’s a different sort of thing, hot enough to make you flow into* *something,
    interflow, cool and anneal and be a weld stronger than* *what you started with.*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 爱情是一种不同类型的东西，热烈到足以让你融入*某种东西，相互融合，冷却并退火，成为比*你开始时*更坚固的焊接。
- en: — Theodore Sturgeon
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: —— 西奥多·斯特金
- en: In the previous chapter, we studied how to formulate different combinatorial
    optimization problems as QUBO instances that, in turn, could be rewritten as the
    optimization problem of finding a state with minimum energy in an Ising model
    system. In this chapter, we will use this fact to introduce a way of using **quantum
    annealers** — a special type of quantum computer — to try to find (approximate)
    solutions to those combinatorial optimization problems.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们研究了如何将不同的组合优化问题表述为QUBO实例，这些实例反过来又可以重写为在伊辛模型系统中寻找具有最小能量的状态的优化问题。在这一章中，我们将利用这一事实来介绍一种使用**量子退火器**——一种特殊的量子计算机——的方法，试图找到（近似）解决这些组合优化问题的方案。
- en: But, in order to do that, we first need to talk a little bit more about Hamiltonians
    and their ground states, as well as the central role they play in adiabatic quantum
    computing.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，为了做到这一点，我们首先需要更多地讨论哈密顿量和它们的基态，以及它们在退火量子计算中扮演的核心角色。
- en: 'The topics that we will cover in this chapter are as follows:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Adiabatic quantum computing
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 退火量子计算
- en: Quantum annealing
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 量子退火
- en: Using Ocean to formulate and transform optimization problems
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Ocean来表述和转换优化问题
- en: Solving optimization problems on quantum annealers with Leap
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Leap在量子退火器上解决优化问题
- en: Here we go!
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始了！
- en: 4.1 Adiabatic quantum computing
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.1 退火量子计算
- en: In *Chapter* *[*1*](ch008.xhtml#x1-180001), *Foundations of Quantum Computing*,
    we focused mainly on quantum circuits but we briefly mentioned that there were
    other equivalent quantum computing models. One of them is adiabatic quantum computing,
    introduced in 2000 by Farhi, Goldstone, Gutmann, and Sipser in a widely influential
    paper [[36](ch030.xhtml#Xfarhi2000quantum)].*
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第* *[*1*](ch008.xhtml#x1-180001)，*量子计算基础*这一章中，我们主要关注量子电路，但简要提到了还有其他等效的量子计算模型。其中之一是2000年由Farhi、Goldstone、Gutmann和Sipser在具有广泛影响力的论文[[36](ch030.xhtml#Xfarhi2000quantum)]中提出的退火量子计算。
- en: '*When using quantum circuits, we apply operations (our beloved quantum gates)
    through discrete, sequential steps. However, adiabatic quantum computing relies
    on the use of continuous transformations. Namely, we will use a Hamiltonian ![H(t)](img/file541.png
    "H(t)") that will vary with time and that will be the driving force to change
    the state of our qubits according to the time-dependent Schrödinger equation:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*当使用量子电路时，我们通过离散的、顺序的步骤应用操作（我们心爱的量子门）。然而，退火量子计算依赖于连续变换的使用。具体来说，我们将使用一个随时间变化的哈密顿量
    ![H(t)](img/file541.png "H(t)")，它将是根据时间依赖的薛定谔方程改变我们量子比特状态的驱动力：'
- en: '![H(t)\left| {\psi(t)} \right\rangle = i\hslash\frac{\partial}{\partial t}\left|
    {\psi(t)} \right\rangle.](img/file542.png "H(t)\left| {\psi(t)} \right\rangle
    = i\hslash\frac{\partial}{\partial t}\left| {\psi(t)} \right\rangle.")'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![H(t)\left| {\psi(t)} \right\rangle = i\hslash\frac{\partial}{\partial t}\left|
    {\psi(t)} \right\rangle.](img/file542.png "H(t)\left| {\psi(t)} \right\rangle
    = i\hslash\frac{\partial}{\partial t}\left| {\psi(t)} \right\rangle.")'
- en: To learn more…
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 了解更多...
- en: As you may remember, in *Chapter* *[*1*](ch008.xhtml#x1-180001), *Foundations
    of Quantum* *Computing*, we talked about the **time-independent** Schrödinger
    equation. In that case, the Hamiltonian — which you can think of as a mathematical
    object that can describe the energy of the system — remained unchanged throughout
    the process. Now, we’ll consider situations in which this energy can vary with
    time. This is the case, for instance, if you are applying an electromagnetic pulse
    to your qubits and you change its intensity or its frequency.*
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所记，在*第* *[*1*](ch008.xhtml#x1-180001)，*量子计算基础*这一章中，我们讨论了**时间独立**的薛定谔方程。在这种情况下，哈密顿量——你可以将其视为一个可以描述系统能量的数学对象——在整个过程中保持不变。现在，我们将考虑这种能量可以随时间变化的情况。例如，如果你正在对你的量子比特应用电磁脉冲，并改变其强度或频率，这就是这种情况。
- en: '*The terms in this equation are the time-dependent Hamiltonian ![H(t)](img/file541.png
    "H(t)"), the state vector of the system ![\left| {\psi(t)} \right\rangle](img/file47.png
    "\left| {\psi(t)} \right\rangle"), the imaginary unit ![i](img/file49.png "i")
    (defined by ![i^{2} = - 1](img/file543.png "i^{2} = - 1")), and the reduced Planck’s
    constant ![\hslash](img/file50.png "\hslash").*  *In addition to using time-dependent
    Hamiltonians, there is another ingredient that we need for our new quantum computing
    model: the idea of **adiabatic** **evolution**. Roughly speaking, an adiabatic
    process is one in which the ”energy configuration” of the system changes ”very
    gently” (there are quite a few quotation marks here, aren’t there?). But…what
    does this have to do with quantum computing and how does it help us in finding
    solutions to our problems?'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*这个方程中的项是时变哈密顿量 ![H(t)](img/file541.png "H(t)"),系统的状态向量 ![\left| {\psi(t)}
    \right\rangle](img/file47.png "\left| {\psi(t)} \right\rangle"),虚数单位 ![i](img/file49.png
    "i")（定义为 ![i^{2} = - 1](img/file543.png "i^{2} = - 1"))，以及约化普朗克常数 ![\hslash](img/file50.png
    "\hslash")。*  *除了使用时变哈密顿量之外，我们还需要另一个新量子计算模型中的元素：**绝热****演化**的概念。粗略地说，绝热过程是一个系统“能量配置”变化“非常温和”的过程（这里有很多引号，不是吗？）。但是……这与量子计算有什么关系？它是如何帮助我们找到问题的解的呢？'
- en: 'The key observation is that we will be considering problems whose optimal solutions
    will correspond to minimum-energy or ground states of some Hamiltonian of an Ising
    model. So, if we start with our system in the ground state (for some Hamiltonian)
    and we evolve it adiabatically, we know that it will remain in a ground state
    through the whole process. We won’t be adding enough energy for the system to
    ”jump” to the next energy level: this is, in more ”physical” terms, to go from
    the ground state to an **excited state**. And we can use that to our advantage,
    because if we engineer the procedure so that the final Hamiltonian of the system
    is the one whose ground state will yield the solution to our problem, then we
    only need to measure the system to get the solution we are looking for.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 关键观察是，我们将考虑的问题，其最优解将对应于某些伊辛模型哈密顿量的最小能量或基态。因此，如果我们从一个基态（对于某个哈密顿量）的系统开始，并以绝热的方式演化它，我们知道它将在整个过程中保持在基态。我们不会添加足够的能量使系统“跳跃”到下一个能级：这在更“物理”的术语中，是从基态到**激发态**。我们可以利用这一点，因为如果我们设计程序，使得系统的最终哈密顿量的基态将给出我们问题的解，那么我们只需要测量系统以获得我们想要的解。
- en: Important note
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 重要注意事项
- en: To put it in a nutshell, the idea behind adiabatic quantum computing is to start
    with a simple Hamiltonian, one for which we can easily obtain — and prepare! —
    the ground state, and evolve it ”carefully.” We do this so that we remain in the
    ground state all the time, slowly changing our system until the ground state of
    its Hamiltonian is the solution to our problem. And then, bang, we perform a measurement
    and get our result!
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，绝热量子计算背后的想法是从一个简单的哈密顿量开始，我们可以轻松地获得——并准备！——其基态，然后“小心”地演化它。我们这样做是为了保持始终处于基态，缓慢地改变我们的系统，直到其哈密顿量的基态成为我们问题的解。然后，砰！我们进行测量并得到我们的结果！
- en: 'Of course, the crucial thing here is how to perform the evolution to ensure
    that it is, indeed, adiabatic. But don’t worry, the **adiabatic theorem** has
    got our backs there. This result, originally proved by Max Born and Vladimir Fock
    [[18](ch030.xhtml#Xborn1928beweis)], two of the fathers of quantum mechanics,
    says that for your process to be adiabatic, it should be slow enough. You may
    ask: how slow? Well, the total time should be inversely proportional to the square
    of the **spectral** **gap**, which is the minimum difference in energy between
    the ground state and the first excited state of the Hamiltonian during the whole
    evolution.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这里的关键是如何执行演化过程以确保它确实是绝热的。但别担心，**绝热定理**在这里为我们提供了支持。这个结果最初是由量子力学的两位创始人Max Born和Vladimir
    Fock证明的[[18](ch030.xhtml#Xborn1928beweis)]，他们说，为了使你的过程是绝热的，它应该足够慢。你可能想知道：有多慢？嗯，总时间应该与**光谱****间隙**的平方成反比，这是在整个演化过程中哈密顿量的基态和第一个激发态之间能量的最小差值。
- en: This makes perfect intuitive sense. If there is always a big difference in energy
    between the ground state and the first excited state, then you can speed things
    up a little bit — you won’t risk jumping to the next energy level. However, if
    the difference is small, you’d better be careful, lest you accidentally go up
    a step (or several!) on the energy ladder.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这在直观上是非常合理的。如果基态和第一个激发态之间的能量总是有很大的差异，那么你可以稍微加快速度——你不会冒险跳到下一个能级。然而，如果差异很小，你最好小心行事，以免不小心走上能量阶梯的一步（或几步）！
- en: Now that we have a clear understanding of the ideas behind adiabatic quantum
    computing, let’s make things a little bit more formal. Suppose that you have a
    problem for which ![H_{1}](img/file544.png "H_{1}") is the Hamiltonian whose ground
    state encodes the result that you want to find. For instance, ![H_{1}](img/file544.png
    "H_{1}") could be an Ising Hamiltonian that you obtained from transforming a QUBO
    problem. Now, imagine that your system is in the ground state of some initial
    Hamiltonian ![H_{0}](img/file545.png "H_{0}"). We will soon discuss how to choose
    ![H_{0}](img/file545.png "H_{0}"), but for now just think that you can prepare
    its ground state easily enough so that it is a natural choice for you.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经清楚地理解了绝热量子计算背后的思想，让我们使事情变得更加正式一些。假设你有一个问题，其哈密顿量![H_{1}](img/file544.png
    "H_{1}")的基态编码了你想要找到的结果。例如，![H_{1}](img/file544.png "H_{1}")可能是一个从QUBO问题转换而来的伊辛哈密顿量。现在，想象一下你的系统处于某个初始哈密顿量![H_{0}](img/file545.png
    "H_{0}")的基态。我们很快就会讨论如何选择![H_{0}](img/file545.png "H_{0}")，但在此我们先假设你能够足够容易地准备其基态，使其成为你的一个自然选择。
- en: Suppose that we run the process for total time ![T](img/file74.png "T"). The
    time-dependent Hamiltonian that we will consider will be of the form
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们运行整个过程的总时间为![T](img/file74.png "T")。我们将考虑的时间相关哈密顿量将具有以下形式
- en: '![H(t) = A(t)H_{0} + B(t)H_{1},](img/file546.png "H(t) = A(t)H_{0} + B(t)H_{1},")'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![H(t) = A(t)H_{0} + B(t)H_{1},](img/file546.png "H(t) = A(t)H_{0} + B(t)H_{1},")'
- en: where ![A](img/file183.png "A") and ![B](img/file184.png "B") are real-valued
    functions that accept inputs over the interval ![\lbrack 0,T\rbrack](img/file547.png
    "\lbrack 0,T\rbrack") such that ![A(0) = B(T) = 1](img/file548.png "A(0) = B(T)
    = 1") and ![A(T) = B(0) = 0](img/file549.png "A(T) = B(0) = 0"). Notice that it
    holds that ![H(0) = H_{0}](img/file550.png "H(0) = H_{0}") and ![H(T) = H_{1}](img/file551.png
    "H(T) = H_{1}"), exactly as we desired. A common choice for the functions ![A](img/file183.png
    "A") and ![B](img/file184.png "B") is to set ![\left. A(t) = 1 - t\slash T \right.](img/file552.png
    "\left. A(t) = 1 - t\slash T \right.") and ![\left. B(t) = t\slash T \right.](img/file553.png
    "\left. B(t) = t\slash T \right."). Nonetheless, as we will see later in this
    chapter, sometimes we also use other options, under the requirement that they
    satisfy the aforementioned boundary conditions.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 其中![A](img/file183.png "A")和![B](img/file184.png "B")是接受区间![\lbrack 0,T\rbrack](img/file547.png
    "\lbrack 0,T\rbrack")内输入的实值函数，满足![A(0) = B(T) = 1](img/file548.png "A(0) = B(T)
    = 1")和![A(T) = B(0) = 0](img/file549.png "A(T) = B(0) = 0")。请注意，![H(0) = H_{0}](img/file550.png
    "H(0) = H_{0}")和![H(T) = H_{1}](img/file551.png "H(T) = H_{1}")正好符合我们期望的结果。![A](img/file183.png
    "A")和![B](img/file184.png "B")函数的一个常见选择是设置![\left. A(t) = 1 - t\slash T \right.](img/file552.png
    "\left. A(t) = 1 - t\slash T \right.")和![\left. B(t) = t\slash T \right.](img/file553.png
    "\left. B(t) = t\slash T \right.")。然而，正如我们将在本章后面看到的，有时我们也会使用其他选项，前提是它们满足上述边界条件。
- en: Adiabatic quantum computing is polynomially equivalent to other quantum computing
    models, as proved by Aharonov et al. [[4](ch030.xhtml#Xaharonov2007adiabatic)],
    including the quantum circuit model. This means that anything that is efficiently
    computable in one of these models is also efficiently computable in adiabatic
    quantum computing, and vice versa. Consequently, you can choose to use any of
    these models depending on the particulars of your problem or, as we will see in
    the next section, on the kind of quantum computer that you have access to.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 阿哈罗诺夫等人证明了绝热量子计算与其它量子计算模型在多项式时间内等价，包括量子电路模型[[4](ch030.xhtml#Xaharonov2007adiabatic)]。这意味着在这些模型中任何一种模型中能够高效计算的问题，在绝热量子计算中也能高效计算，反之亦然。因此，你可以根据你问题的具体情况选择使用这些模型中的任何一种，或者，正如我们将在下一节中看到的，根据你所拥有的量子计算机的类型。
- en: 4.2 Quantum annealing
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.2 量子退火
- en: Although we have just seen that adiabatic quantum computing is, theoretically,
    a perfectly viable alternative to the quantum circuit model, in its practical
    incarnation it is usually implemented in a restricted version called **quantum**
    **annealing**.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们刚刚看到，绝热量子计算在理论上是一个完美的量子电路模型的替代方案，但在其实际应用中，它通常以一个称为**量子****退火**的受限版本来实现。
- en: 'Quantum annealing relies on the same core idea as adiabatic quantum computing:
    it takes an initial Hamiltonian ![H_{0}](img/file545.png "H_{0}"), a final Hamiltonian
    ![H_{1}](img/file544.png "H_{1}") whose ground state encodes the solution to the
    problem of interest, and it gradually changes the acting Hamiltonian from the
    initial to the final one by using some functions ![A](img/file183.png "A") and
    ![B](img/file184.png "B") (as described in the previous section) to decrease the
    action of ![H_{0}](img/file545.png "H_{0}") and to increase the action of ![H_{1}](img/file544.png
    "H_{1}"). However, quantum annealing deviates from full adiabatic quantum computing
    in two ways. First of all, in practical implementations of quantum annealing,
    the final Hamiltonian ![H_{1}](img/file544.png "H_{1}") that can be realized cannot
    be chosen completely at will, but has to be selected from a certain, restricted
    class. A typical option is an Ising Hamiltonian of the form'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 量子退火依赖于与绝热量子计算相同的核心理念：它从一个初始哈密顿量![H_{0}](img/file545.png "H_{0}")开始，一个最终哈密顿量![H_{1}](img/file544.png
    "H_{1}")，其基态编码了感兴趣问题的解，并通过使用某些函数![A](img/file183.png "A")和![B](img/file184.png
    "B")（如前节所述）逐渐改变作用哈密顿量从初始到最终，以减少![H_{0}](img/file545.png "H_{0}")的作用并增加![H_{1}](img/file544.png
    "H_{1}")的作用。然而，量子退火在两个方面偏离了完整的绝热量子计算。首先，在量子退火的实际实现中，可以实现的最终哈密顿量![H_{1}](img/file544.png
    "H_{1}")不能完全随意选择，而必须从某个特定的、受限的类别中选择。一个典型的选择是形式为Ising哈密顿量的选项
- en: '![- \sum\limits_{j,k}J_{jk}Z_{j}Z_{k} - \sum\limits_{j}h_{j}Z_{j},](img/file554.png
    "- \sum\limits_{j,k}J_{jk}Z_{j}Z_{k} - \sum\limits_{j}h_{j}Z_{j},")'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '[![ - \sum\limits_{j,k}J_{jk}Z_{j}Z_{k} - \sum\limits_{j}h_{j}Z_{j},](img/file554.png
    "- \sum\limits_{j,k}J_{jk}Z_{j}Z_{k} - \sum\limits_{j}h_{j}Z_{j},")](img/file554.png
    "- \sum\limits_{j,k}J_{jk}Z_{j}Z_{k} - \sum\limits_{j}h_{j}Z_{j},")'
- en: which is the quantum version of the one we introduced in *Section* *[*3.1.3*](ch011.xhtml#x1-630003.1.3).
    In this case, the user has the freedom of selecting the ![J_{jk}](img/file342.png
    "J_{jk}") and ![h_{j}](img/file343.png "h_{j}") coefficients within certain ranges.
    Due to this restriction in the choice of the final Hamiltonian, quantum annealing,
    unlike adiabatic quantum computing, is not universal and can only be used to solve
    a specific (but still very important!) type of problem. On the bright side, physical
    quantum devices based on quantum annealing are simpler to construct, making it
    possible to scale the size of these **quantum annealers** up to hundreds or even
    thousands of qubits.*
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们之前在*第3.1.3节*中介绍过的量子版本。[![J_{jk}](img/file342.png "J_{jk}")](img/file342.png
    "J_{jk}")和[![h_{j}](img/file343.png "h_{j}")](img/file343.png "h_{j}")系数可以在一定范围内自由选择。由于这种对最终哈密顿选择范围的限制，量子退火与绝热量子计算不同，不是通用的，只能用来解决特定（但仍然非常重要！）类型的问题。另一方面，基于量子退火的物理量子设备构建起来更简单，使得将这些**量子退火器**的规模扩大到数百甚至数千个量子比特成为可能。
- en: '*The initial Hamiltonian in the quantum annealing setup is also usually fixed
    to be ![H_{0} = - {\sum}_{j = 0}^{n - 1}X_{j}](img/file555.png "H_{0} = - {\sum}_{j
    = 0}^{n - 1}X_{j}"), where ![n](img/file244.png "n") is the number of qubits,
    and ![X_{j}](img/file556.png "X_{j}") stands for the tensor product in which the
    ![X](img/file9.png "X") matrix is acting on qubit ![j](img/file258.png "j") with
    the rest of positions occupied by ![I](img/file53.png "I"), the identity matrix.
    The ground state of ![H_{0}](img/file545.png "H_{0}") is easily seen to be ![{\otimes}_{i
    = 0}^{n - 1}\left| + \right\rangle](img/file557.png "{\otimes}_{i = 0}^{n - 1}\left|
    + \right\rangle") , the tensor product of ![n](img/file244.png "n") copies of
    the plus state, which is relatively easy to prepare because it is completely unentangled.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*在量子退火设置中，初始哈密顿量通常也固定为![H_{0} = - {\sum}_{j = 0}^{n - 1}X_{j}](img/file555.png
    "H_{0} = - {\sum}_{j = 0}^{n - 1}X_{j}")，其中![n](img/file244.png "n")是量子比特的数量，而![X_{j}](img/file556.png
    "X_{j}")表示张量积，其中![X](img/file9.png "X")矩阵作用于量子比特![j](img/file258.png "j")，其余位置由![I](img/file53.png
    "I")，即单位矩阵占据。![H_{0}](img/file545.png "H_{0}")的基态很容易看出是![{\otimes}_{i = 0}^{n
    - 1}\left| + \right\rangle](img/file557.png "{\otimes}_{i = 0}^{n - 1}\left| +
    \right\rangle")，即正态的n个副本的张量积，这相对容易制备，因为它完全未纠缠。'
- en: Exercise 4.1
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 练习4.1
- en: Prove that ![\left| \psi_{0} \right\rangle = {\otimes}_{i = 0}^{n - 1}\left|
    + \right\rangle](img/file558.png "\left| \psi_{0} \right\rangle = {\otimes}_{i
    = 0}^{n - 1}\left| + \right\rangle") has the minimum possible energy for ![H_{0}
    = - {\sum}_{j = 0}^{n - 1}X_{j}](img/file555.png "H_{0} = - {\sum}_{j = 0}^{n
    - 1}X_{j}") by first showing that, for each ![j](img/file258.png "j") and each
    state ![\left| \psi \right\rangle](img/file43.png "\left| \psi \right\rangle"),
    it holds that ![\left\langle \psi \right|X_{j}\left| \psi \right\rangle \leq 1](img/file559.png
    "\left\langle \psi \right|X_{j}\left| \psi \right\rangle \leq 1") and then showing
    that ![\left\langle \psi_{0} \right|X_{j}\left| \psi_{0} \right\rangle = 1](img/file560.png
    "\left\langle \psi_{0} \right|X_{j}\left| \psi_{0} \right\rangle = 1") for each
    ![j](img/file258.png "j").
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 证明![\left| \psi_{0} \right\rangle = {\otimes}_{i = 0}^{n - 1}\left| + \right\rangle](img/file558.png
    "\left| \psi_{0} \right\rangle = {\otimes}_{i = 0}^{n - 1}\left| + \right\rangle")对于![H_{0}
    = - {\sum}_{j = 0}^{n - 1}X_{j}](img/file555.png "H_{0} = - {\sum}_{j = 0}^{n
    - 1}X_{j}")具有可能的最小能量，首先需要证明，对于每个![j](img/file258.png "j")和每个状态![\left| \psi \right\rangle](img/file43.png
    "\left| \psi \right\rangle")，都有![\left\langle \psi \right|X_{j}\left| \psi \right\rangle
    \leq 1](img/file559.png "\left\langle \psi \right|X_{j}\left| \psi \right\rangle
    \leq 1")，然后证明对于每个![j](img/file258.png "j")，都有![\left\langle \psi_{0} \right|X_{j}\left|
    \psi_{0} \right\rangle = 1](img/file560.png "\left\langle \psi_{0} \right|X_{j}\left|
    \psi_{0} \right\rangle = 1")。
- en: Thus, the Hamiltonian used in quantum annealing is given by
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，量子退火中使用的哈密顿量由以下公式给出
- en: '![H(t) = - A(t)\sum\limits_{j = 0}^{n - 1}X_{j} - B(t)\sum\limits_{j,k}J_{jk}Z_{j}Z_{k}
    - B(t)\sum\limits_{j}h_{j}Z_{j},](img/file561.png "H(t) = - A(t)\sum\limits_{j
    = 0}^{n - 1}X_{j} - B(t)\sum\limits_{j,k}J_{jk}Z_{j}Z_{k} - B(t)\sum\limits_{j}h_{j}Z_{j},")'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![H(t) = - A(t)\sum\limits_{j = 0}^{n - 1}X_{j} - B(t)\sum\limits_{j,k}J_{jk}Z_{j}Z_{k}
    - B(t)\sum\limits_{j}h_{j}Z_{j},](img/file561.png "H(t) = - A(t)\sum\limits_{j
    = 0}^{n - 1}X_{j} - B(t)\sum\limits_{j,k}J_{jk}Z_{j}Z_{k} - B(t)\sum\limits_{j}h_{j}Z_{j},")'
- en: where ![J_{jk}](img/file342.png "J_{jk}") and ![h_{j}](img/file343.png "h_{j}")
    are some adjustable coefficients, and ![A](img/file183.png "A") and ![B](img/file184.png
    "B") are functions such that ![A(0) = B(T) = 1](img/file548.png "A(0) = B(T) =
    1") and ![A(T) = B(0) = 0](img/file549.png "A(T) = B(0) = 0"), with ![T](img/file74.png
    "T") being the total **annealing time**. In this context, ![A](img/file183.png
    "A") and ![B](img/file184.png "B") are called the **annealing schedule**.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 其中![J_{jk}](img/file342.png "J_{jk}")和![h_{j}](img/file343.png "h_{j}")是某些可调系数，而![A](img/file183.png
    "A")和![B](img/file184.png "B")是满足![A(0) = B(T) = 1](img/file548.png "A(0) = B(T)
    = 1")和![A(T) = B(0) = 0](img/file549.png "A(T) = B(0) = 0")的函数，其中![T](img/file74.png
    "T")是总的**退火时间**。在这种情况下，![A](img/file183.png "A")和![B](img/file184.png "B")被称为**退火计划**。
- en: The other important deviation from the adiabatic quantum computing model is
    that, in quantum annealing, evolution is no longer guaranteed to be adiabatic.
    There are two main reasons for this decision. As you surely remember, the spectral
    gap is the minimum of the difference between the ground state and the first excited
    state of ![H(t)](img/file541.png "H(t)") for ![t \in \lbrack 0,T\rbrack](img/file562.png
    "t \in \lbrack 0,T\rbrack"). Computing this spectral gap can be very difficult.
    Actually, it can be even harder than finding the ground state that we are looking
    for, as proved by Cubitt et al. [[27](ch030.xhtml#Xcubitt2015undecidability)].
    The second reason is that, even if we are able to compute the time that we need
    for the process to be adiabatic, it can be so big that it wouldn’t be practical
    — or even possible! — to run the system evolution for so long.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 与绝热量子计算模型相比，另一个重要的差异是，在量子退火中，演化过程不再保证是绝热的。这一决策有两个主要原因。正如你肯定记得的那样，谱隙是![H(t)](img/file541.png
    "H(t)")在![t \in \lbrack 0,T\rbrack](img/file562.png "t \in \lbrack 0,T\rbrack")范围内基态与第一个激发态之间差的最小值。计算这个谱隙可能非常困难。实际上，它可能比寻找我们正在寻找的基态还要困难，正如Cubitt等人所证明的[[27](ch030.xhtml#Xcubitt2015undecidability)]。第二个原因是，即使我们能够计算出过程成为绝热所需的时间，这个时间可能如此之大，以至于长时间运行系统演化既不实用，甚至可能不可能！
- en: Thus, in quantum annealing, we run the evolution for a certain amount of time
    that need not satisfy the conditions for adiabaticity, and hope to still be able
    to find good approximations of the optimal solution to our problem. In fact, we
    don’t strictly need to remain in the ground state of ![H(t)](img/file541.png "H(t)").
    Since, at the end, we are going to measure the state, it would be enough if the
    amplitude of an optimal or sufficiently good solution in our final state were
    big enough. That’s because, then, the probability of obtaining a useful result
    will still be high. And, of course, we can always repeat the process several times
    and keep the best of all measurements!
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在量子退火中，我们运行演化过程一定的时间，这个时间不需要满足绝热性的条件，并希望仍然能够找到我们问题的最优解的近似解。实际上，我们并不严格需要保持在![H(t)](img/file541.png
    "H(t)")的基态。因为，最后，我们将要测量状态，只要我们最终状态中一个最优或足够好的解的振幅足够大就足够了。这是因为，那么，获得有用结果的可能性仍然很高。而且，当然，我们可以重复这个过程几次，并保留所有测量中的最佳结果！
- en: In 2011, the Canadian company D-Wave was the first to ever commercialize a quantum
    device that implemented quantum annealing as we have just described it. That quantum
    annealer, called D-Wave One, had ![128](img/file563.png "128") qubits, while one
    of D-Wave’s most recent quantum devices, the Advantage, has more than ![5000](img/file564.png
    "5000") qubits, and it’s available for you to use online!
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在2011年，加拿大公司D-Wave是第一家将量子退火商业化，正如我们刚才所描述的那样。这个量子退火器被称为D-Wave One，它有![128](img/file563.png
    "128")个量子位，而D-Wave最新的量子设备之一，Advantage，有超过![5000](img/file564.png "5000")个量子位，并且你可以在线使用它！
- en: We need to keep in mind that, with these quantum computers, the evolution process
    will not be adiabatic in general, so there is no guarantee that the exact solution
    will be found in all cases. But, all over the world, many research teams and prominent
    companies — from sectors as diverse as finance, logistics, and aircraft manufacturing
    — are actively exploring the practical applications of quantum annealers. We will
    devote the rest of this chapter to showing you how you can also try them for your
    own optimization problems.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要记住，在这些量子计算机中，演化过程通常不会是绝热的，因此不能保证在所有情况下都能找到精确解。但是，全世界许多研究团队和知名公司——从金融、物流到飞机制造等各个行业——都在积极探索量子退火器的实际应用。我们将在本章的剩余部分向你展示你如何尝试将它们用于自己的优化问题。
- en: Using D-Wave’s quantum annealers is much easier than you may think. First of
    all, you need to follow the instructions in *Appendix* *[*D*](ch027.xhtml#x1-240000D),
    *Installing the Tools*, to install Ocean, which is D-Wave’s quantum annealing
    Python library, and to create a free account on D-Wave Leap, a cloud service where
    you can get one minute per month of free computing time on D-Wave’s quantum annealers.
    This may not seem like much, but you will see that it is enough to run quite a
    number of experiments.*
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 使用D-Wave的量子退火器比你想象的要简单得多。首先，你需要遵循*附录* *[*D*](ch027.xhtml#x1-240000D)，*安装工具*中的说明来安装Ocean，这是D-Wave的量子退火Python库，并在D-Wave
    Leap上创建一个免费账户，这是一个云服务，你可以在这里每月获得一分钟免费计算时间，用于D-Wave的量子退火器。这可能看起来不多，但你将会看到这足以运行相当多的实验。
- en: '*To learn more…'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*了解更多信息…'
- en: If one minute per month proves not to be enough for your annealing necessities,
    both D-Wave Leap and Amazon Braket offer paid access to quantum annealers. Obviously,
    the pricing of these services varies from time to time, so please check their
    websites to check the current rates and conditions.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果每月一分钟对于你的退火需求来说不够，D-Wave Leap和Amazon Braket都提供付费访问量子退火器。显然，这些服务的定价会随时间而变化，所以请检查他们的网站以查看当前的费率和条件。
- en: Once you have everything set up, you can access quantum annealers to find an
    approximation of a solution to any combinatorial optimization problem that you
    may have written as either an instance of finding the ground state of an Ising
    model or as a QUBO problem. For instance, let’s try to solve the MaxCut problem
    for the graph in *Figure* *[*3.5*](ch011.xhtml#Figure3.5). As you surely remember,
    we can pose it as finding the ground state of*
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦一切设置完毕，你就可以访问量子退火器，以找到任何组合优化问题的近似解，无论你是将其编写为寻找伊辛模型基态的实例，还是将其编写为QUBO问题。例如，让我们尝试解决*图*
    *[*3.5*](ch011.xhtml#Figure3.5)中图的MaxCut问题。正如你肯定记得的，我们可以将其表述为寻找以下基态：
- en: '*![Z_{0}Z_{1} + Z_{0}Z_{2},](img/file565.png "Z_{0}Z_{1} + Z_{0}Z_{2},")'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*![Z_{0}Z_{1} + Z_{0}Z_{2},](img/file565.png "Z_{0}Z_{1} + Z_{0}Z_{2},")'
- en: which is, of course, an Ising Hamiltonian in which ![J_{01} = J_{02} = 1](img/file566.png
    "J_{01} = J_{02} = 1") and the rest of the coefficients are ![0](img/file12.png
    "0").
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这当然是一个伊辛哈密顿量，其中![J_{01} = J_{02} = 1](img/file566.png "J_{01} = J_{02} = 1")，其余的系数都是![0](img/file12.png
    "0")。
- en: 'All we need to tell the quantum annealer is that those are the coefficients
    we want to use, and then we can perform the annealing multiple times to obtain
    some results that will hopefully solve our problem. To specify the problem, we
    can use the `dimod` package, included in the Ocean library, as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要告诉量子退火器的是这些是我们想要使用的系数，然后我们可以多次进行退火以获得一些可能解决我们问题的结果。为了指定问题，我们可以使用Ocean库中包含的`dimod`包，如下所示：
- en: '[PRE0]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The output will be the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将是以下内容：
- en: '[PRE1]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'There are a couple of things to notice here. First, we have used `J` for the
    coefficients of the degree ![2](img/file302.png "2") terms — `(0,1):1` sets the
    ![J_{01}](img/file567.png "J_{01}") coefficient to 1 and `(0,2):1` sets ![J_{02}
    = 1](img/file568.png "J_{02} = 1") — and `h` for the linear ones. Those coefficients
    that we do not specify are automatically set to ![0](img/file12.png "0") by the
    `BinaryQuadraticModel` constructor, but we still need to pass both the `J` and
    the `h` parameters (even in our case, where the latter is empty). Notice that
    in the output we get `(1,` `0):` `1.0,` `(2,` `0):` `1.0`, which seems to be the
    reverse of what we used. But they are exactly the same, because ![Z_{0}Z_{1} =
    Z_{1}Z_{0}](img/file569.png "Z_{0}Z_{1} = Z_{1}Z_{0}") and, thus, the situation
    is symmetrical. Second, we have used `0.0` as the value for the **offset**, which
    is a constant term that can be added to the Hamiltonian. Finally, we have used
    the `dimod``.``SPIN` parameter because we are working with an Ising Hamiltonian
    and, thus, the values of our variables are ![1](img/file13.png "1") and ![- 1](img/file312.png
    "- 1"). In just a minute, we will see how to use binary variables instead. But,
    before that, let’s use the following code to run the annealing process on one
    of the quantum annealers:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里有几个需要注意的事项。首先，我们使用了`J`来表示二次项系数![2](img/file302.png "2") — `(0,1):1`将![J_{01}](img/file567.png
    "J_{01}")系数设置为1，`(0,2):1`将![J_{02} = 1](img/file568.png "J_{02} = 1")设置为1 — 并且使用`h`来表示线性项。那些我们没有指定的系数会自动由`BinaryQuadraticModel`构造函数设置为![0](img/file12.png
    "0")，但我们仍然需要传递`J`和`h`两个参数（即使在我们这个例子中，后者是空的）。注意，在输出中我们得到`(1,` `0):` `1.0,` `(2,`
    `0):` `1.0`，这似乎与我们使用的相反。但它们实际上是相同的，因为![Z_{0}Z_{1} = Z_{1}Z_{0}](img/file569.png
    "Z_{0}Z_{1} = Z_{1}Z_{0}")，因此情况是对称的。其次，我们使用了`0.0`作为**偏移量**的值，这是一个可以添加到哈密顿量中的常数项。最后，我们使用了`dimod``.``SPIN`参数，因为我们正在处理一个伊辛哈密顿量，因此我们的变量值是![1](img/file13.png
    "1")和![- 1](img/file312.png "- 1")。在一分钟内，我们将看到如何使用二进制变量。但在那之前，让我们使用以下代码在一个量子退火器上运行退火过程：
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'What we are doing here is, first, importing `DWaveSampler`, which will give
    us access to the quantum annealers, and then `EmbeddingComposite`, which will
    allow us to **map** or **embed** our problem into the actual qubits of the annealer
    — don’t worry, we will explain this in detail later. For now, you can think of
    this as an automatic way of selecting a few qubits in the computer that will be
    used to represent our variables. After that, we create an object `sampler` that
    we then use to obtain ![10](img/file161.png "10") samples or possible solutions
    to our problem. This is where the actual execution on the actual quantum annealer
    happens. After that, we just print the result, which will vary from execution
    to execution. This is because we are using an actual quantum computer, which is,
    as you know, essentially probabilistic. In our case, we obtained the following:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的是，首先导入`DWaveSampler`，这将使我们能够访问量子退火器，然后是`EmbeddingComposite`，这将允许我们将问题**映射**或**嵌入**到退火器的实际量子比特中——不要担心，我们稍后会详细解释。现在，你可以将其视为一种在计算机中选择一些量子比特的自动方式，这些量子比特将用来表示我们的变量。之后，我们创建了一个对象`sampler`，然后我们使用它来获取![10](img/file161.png
    "10")个样本或可能的解决方案。这就是实际在量子退火器上执行的地方。之后，我们只是打印结果，这些结果会因执行而异。这是因为我们正在使用实际的量子计算机，正如你所知，它本质上是一种概率性的。在我们的例子中，我们得到了以下结果：
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This means that we obtained two different solutions: ![z_{0} = 1](img/file570.png
    "z_{0} = 1"), ![z_{1} = - 1](img/file571.png "z_{1} = - 1"), and ![z_{2} = - 1](img/file572.png
    "z_{2} = - 1"), and ![z_{0} = - 1](img/file573.png "z_{0} = - 1"), ![z_{1} = 1](img/file574.png
    "z_{1} = 1"), and ![z_{2} = 1](img/file575.png "z_{2} = 1"), both with energy
    ![- 2](img/file333.png "- 2"); the first one was measured in ![6](img/file576.png
    "6") of the executions and the second in the remaining ![4](img/file143.png "4")
    — we will explain what the `chain_`'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们得到了两个不同的解：![z_{0} = 1](img/file570.png "z_{0} = 1")，![z_{1} = - 1](img/file571.png
    "z_{1} = - 1")，和![z_{2} = - 1](img/file572.png "z_{2} = - 1")，以及![z_{0} = - 1](img/file573.png
    "z_{0} = - 1")，![z_{1} = 1](img/file574.png "z_{1} = 1")，和![z_{2} = 1](img/file575.png
    "z_{2} = 1")，它们都具有能量![ - 2](img/file333.png "- 2")；第一个在![6](img/file576.png "6")次执行中被测量，第二个在剩余的![4](img/file143.png
    "4")次执行中被测量——我们将解释`chain_`
- en: '`.` data means later in the chapter. But meanwhile, we can rejoice. These two
    solutions are, indeed, maximum cuts in our graph, as you can easily check!'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`.` 数据表示章节中的后续内容。但与此同时，我们可以感到高兴。这两个解确实是我们图中的最大割，正如你可以轻松检查的那样！'
- en: We can get some additional information from the `result` variable. In fact,
    we can access the best solution through `result``.``first` and the total time
    that we used the quantum annealer for, with `result``.``info``[``’``timing``’``][``’``qpu_access_time``’``]`.
    This is the amount that will be subtracted from your monthly 60 seconds…or that
    you will be charged for if you have a paying plan. In our case, the time that
    we used the annealer for was ![15\, 832.16](img/file577.png "15\, 832.16"), which
    may look like a huge number if you don’t realize that it is actually measured
    in microseconds. So for the 10 samples we used about ![0.016](img/file578.png
    "0.016") seconds. That minute of access doesn’t seem so short anymore, right?
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以从`result`变量中获取一些额外的信息。实际上，我们可以通过`result``.``first`访问最佳解，以及我们使用量子退火器的时间，通过`result``.``info``[``’``timing``’``][``’``qpu_access_time``’``]`。这是将从你的月度60秒中扣除的金额……或者如果你有付费计划，你将被收取的费用。在我们的例子中，我们使用退火器的时间是![15\,
    832.16](img/file577.png "15\, 832.16")，如果你没有意识到这实际上是以微秒为单位测量的，这个数字可能看起来很大。所以对于10个样本，我们使用了大约![0.016](img/file578.png
    "0.016")秒。那么，那一分钟的访问时间似乎不再那么短了，对吧？
- en: We can also use `dimod` to work with QUBO problems. We will need to specify
    the coefficients of the degree ![2](img/file302.png "2") terms, the linear coefficients
    — remember that, in QUBO, we are using binary variables, so expressions like ![x_{3}^{2}](img/file579.png
    "x_{3}^{2}") can be simplified to ![x_{3}](img/file580.png "x_{3}") — and the
    independent coefficient, exactly as in the Ising case. The only change is that
    we will use the `dimod``.``BINARY` parameter when creating our problem with the
    `BinaryQuadraticModel` constructor.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`dimod`来处理QUBO问题。我们需要指定二次项![2](img/file302.png "2")的系数、线性系数——记住，在QUBO中，我们使用二进制变量，所以像![x_{3}^{2}](img/file579.png
    "x_{3}^{2}")这样的表达式可以被简化为![x_{3}](img/file580.png "x_{3}")——以及独立系数，这与Ising情况完全相同。唯一的区别是，在创建我们的`BinaryQuadraticModel`构造函数问题时，我们将使用`dimod``.``BINARY`参数。
- en: Exercise 4.2
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 练习4.2
- en: Create an instance of a simple QUBO problem and solve it with an annealer. Notice
    that the values for the variables in the solution will be ![0](img/file12.png
    "0") and ![1](img/file13.png "1") instead of ![1](img/file13.png "1") and ![-
    1](img/file312.png "- 1").
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个简单的QUBO问题实例，并使用退火器解决它。请注意，解决方案中变量的值将是![0](img/file12.png "0")和![1](img/file13.png
    "1")，而不是![1](img/file13.png "1")和![ - 1](img/file312.png "- 1")。
- en: This is just the simplest kind of execution that we can run on a quantum annealer,
    in which we have used all the default parameters. But the Ocean software implements
    many other functionalities that allow us, for instance, to work more comfortably
    with optimization problems and to control the settings of our experiments more
    precisely, including the annealing time and other important values. The rest of
    this chapter will guide you through the most important features and options to
    help you get the most of your time with annealers, starting with how to use Ocean
    to work with optimization problems.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是我们可以在量子退火器上运行的 simplest 类型的执行，其中我们使用了所有默认参数。但Ocean软件实现了许多其他功能，使我们能够更舒适地处理优化问题，并更精确地控制实验设置，包括退火时间和其他重要值。本章的其余部分将引导你了解最重要的功能和选项，帮助你最大限度地利用退火器的时间，从如何使用Ocean处理优化问题开始。
- en: 4.3 Using Ocean to formulate and transform optimization problems
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.3 使用Ocean来制定和转换优化问题
- en: As we have just seen, the `BinaryQuadraticModel` class can be used to define
    both Ising and QUBO problems. But `dimod` also offers other models and utilities
    that will make our lives a little bit easier. Let’s start by studying how we can
    conveniently define problems with linear restrictions.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们刚才看到的，`BinaryQuadraticModel`类可以用来定义Ising和QUBO问题。但`dimod`还提供了其他模型和工具，这将使我们的生活变得容易一些。让我们首先研究如何方便地定义具有线性约束的问题。
- en: 4.3.1 Constrained quadratic models in Ocean
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.3.1 海洋中的约束二次模型
- en: You surely remember that a problem like
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你肯定记得一个像
- en: '![\begin{array}{rlrl} {\text{Minimize}\quad} & {- 5x_{0} + 3x_{1} - 2x_{2}\qquad}
    & & \qquad \\ {\text{subject~to}\quad} & {x_{0} + x_{2} \leq 1,\qquad} & & \qquad
    \\ & {3x_{0} - x_{1} + 3x_{2} \leq 4\qquad} & & \qquad \\ & {x_{j} \in \{ 0,1\},\qquad
    j = 0,1,2\qquad} & & \qquad \\ & \qquad & & \\ \end{array}](img/file581.png "\begin{array}{rlrl}
    {\text{Minimize}\quad} & {- 5x_{0} + 3x_{1} - 2x_{2}\qquad} & & \qquad \\ {\text{subject~to}\quad}
    & {x_{0} + x_{2} \leq 1,\qquad} & & \qquad \\  & {3x_{0} - x_{1} + 3x_{2} \leq
    4\qquad} & & \qquad \\  & {x_{j} \in \{ 0,1\},\qquad j = 0,1,2\qquad} & & \qquad
    \\  & \qquad & & \\ \end{array}")'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![\begin{array}{rlrl} {\text{Minimize}\quad} & {- 5x_{0} + 3x_{1} - 2x_{2}\qquad}
    & & \qquad \\ {\text{subject~to}\quad} & {x_{0} + x_{2} \leq 1,\qquad} & & \qquad
    \\ & {3x_{0} - x_{1} + 3x_{2} \leq 4\qquad} & & \qquad \\ & {x_{j} \in \{ 0,1\},\qquad
    j = 0,1,2\qquad} & & \qquad \\ & \qquad & & \\ \end{array}](img/file581.png "\begin{array}{rlrl}
    {\text{Minimize}\quad} & {- 5x_{0} + 3x_{1} - 2x_{2}\qquad} & & \qquad \\ {\text{subject~to}\quad}
    & {x_{0} + x_{2} \leq 1,\qquad} & & \qquad \\  & {3x_{0} - x_{1} + 3x_{2} \leq
    4\qquad} & & \qquad \\  & {x_{j} \in \{ 0,1\},\qquad j = 0,1,2\qquad} & & \qquad
    \\  & \qquad & & \\ \end{array}")'
- en: is an instance of binary linear programming. In *Section* *[*3.4.1*](ch011.xhtml#x1-690003.4.1),
    we studied this family of problems in detail and we showed that they can be transformed
    into the QUBO and Ising models by using slack variables and penalty terms.*
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个二元线性规划的一个例子。在*第* *3.4.1* *节* *[*3.4.1*](ch011.xhtml#x1-690003.4.1)，我们详细研究了这个问题族，并展示了通过使用松弛变量和惩罚项，可以将它们转换成QUBO和Ising模型。
- en: '*So, imagine that you want to solve the preceding problem in a quantum annealer.
    Do you need to perform all those boring transformations in order to obtain the
    QUBO coefficients and then use them to define a `BinaryQuadraticModel` object?
    No! Fortunately, `dimod` provides the `ConstrainedQuadraticModel` class, which
    simplifies the process of working with problems that involve linear constraints.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*所以，想象一下你想在一个量子退火器中解决上述问题。你需要执行所有那些无聊的转换来获得QUBO系数，然后使用它们来定义一个`BinaryQuadraticModel`对象吗？不！幸运的是，`dimod`提供了`ConstrainedQuadraticModel`类，它简化了处理涉及线性约束的问题的过程。'
- en: 'In order to instantiate our binary linear program as a `ConstrainedQuadraticModel`
    object, the first thing that we need to do is to define the variables that we
    want to use and their types. In our case, we have three binary variables that
    we can define with the following piece of code:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将我们的二元线性规划实例化为`ConstrainedQuadraticModel`对象，我们首先需要定义我们想要使用的变量及其类型。在我们的情况下，我们有三个二元变量，我们可以用以下代码片段定义它们：
- en: '[PRE4]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: With these instructions, we have simply created three binary variables and we
    have labeled them so that we can use them in mathematical expressions and easily
    identify them when we print them.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这些说明，我们仅仅创建了三个二元变量，并且给它们标上了标签，这样我们就可以在数学表达式中使用它们，并在打印时容易识别它们。
- en: To learn more…
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多...
- en: If you have used symbolic mathematics libraries (for instance, SymPy), you will
    recognize that the principles at work here are very similar.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用过符号数学库（例如，SymPy），你会认识到这里的工作原理非常相似。
- en: 'Now, we are going to define a `ConstrainedQuadraticModel` object and we are
    going to set the **objective** (the function that we seek to minimize) and also
    fix the constraints of the problem. For that, we will use the variables that we
    have just created. This can be achieved with the following instructions:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将定义一个`ConstrainedQuadraticModel`对象，并设置**目标**（我们寻求最小化的函数）以及问题的约束。为此，我们将使用我们刚刚创建的变量。这可以通过以下指令实现：
- en: '[PRE5]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Setting the objective or adding constraints automatically adds all the variables
    involved to the problem object. Notice also that we have provided labels to identify
    the constraints. If you prefer not to do it, then `dimod` will randomly assign
    an alphanumeric string to each constraint and it will be used as its name, should
    you need it. If, later on, you want to rename any of them, you can use the `relabel_constraints`
    method.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 设置目标或添加约束会自动将所有涉及的变量添加到问题对象中。请注意，我们还提供了标签来识别约束。如果您不想这样做，那么`dimod`将随机为每个约束分配一个字母数字字符串，并将其用作其名称，如果您需要的话。如果您稍后想重命名任何一个，可以使用`relabel_constraints`方法。
- en: 'We can inspect the elements of `blp` by accessing its `variables`, `objective`,
    and `constraints` attributes. Thus, we can execute these instructions:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过访问`blp`的`variables`、`objective`和`constraints`属性来检查`blp`的元素。因此，我们可以执行以下指令：
- en: '[PRE6]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'And we will obtain something like this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到类似以下的内容：
- en: '[PRE7]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Notice that both the objective and the constraints are internally represented
    as quadratic functions and, therefore, they formally have quadratic terms, linear
    terms, and an offset or independent term. In our case, only the linear part of
    the constraints is non-empty, and the offset is ![0](img/file12.png "0") in both
    cases.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，目标和约束在内部都表示为二次函数，因此它们正式具有二次项、线性项和一个偏移量或独立项。在我们的情况下，约束的线性部分是非空的，两种情况下的偏移量都是![0](img/file12.png
    "0")。
- en: To learn more…
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多...
- en: As you can see from the output, the constraints that we have created are instances
    of the `dimod``.``sym``.``Le` class, where `Le` stands for *less* *than or equal
    to*. You can also create equality constraints, which will belong to the `dimod``.``sym``.``Eq`
    class or inequality constraints with ![\geq](img/file582.png "\geq"), which will
    be `dimod``.``sym``.` `Ge` objects. Of course, an equality constraint is equivalent
    to one `Le` constraint plus one `Ge` constraint with the same left- and right-hand
    sides. And we can transform `Le` constraints into `Ge` constraints — and the other
    way around — by multiplying everything by ![- 1](img/file312.png "- 1").
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从输出中可以看到，我们创建的约束是`dimod``.``sym``.``Le`类的实例，其中`Le`代表*小于或等于*。您也可以创建等式约束，这些约束将属于`dimod``.``sym``.``Eq`类，或者具有![\geq](img/file582.png
    "\geq")的不等式约束，这些约束将是`dimod``.``sym``.` `Ge`对象。当然，一个等式约束相当于一个`Le`约束加上一个具有相同左右两边的`Ge`约束。我们可以通过将所有内容乘以![−
    1](img/file312.png "- 1")将`Le`约束转换为`Ge`约束——反之亦然。
- en: Now, we know how to construct problems with constraints using `dimod`. In the
    next subsection, we will learn how to use the problems that we have defined to
    compute the cost of different value assignments, check if those assignments satisfy
    the constraints, and to also find the optimal solution to the problem.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们知道如何使用`dimod`构建有约束的问题。在下一个小节中，我们将学习如何使用我们定义的问题来计算不同值赋值的成本，检查这些赋值是否满足约束，以及找到问题的最优解。
- en: 4.3.2 Solving constrained quadratic models with dimod
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.3.2 使用dimod解决约束二次模型
- en: 'The `dimod` package provides many tools to work with the constrained quadratic
    problems that we have just introduced. For instance, we can define an assignment
    of values to the variables, check if it is feasible, and compute its cost for
    the problem defined in the previous subsection by using the following instructions:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`dimod`包提供了许多工具来处理我们刚刚介绍的约束二次问题。例如，我们可以定义变量的值赋值，检查其是否可行，并使用以下指令计算之前小节中定义的问题的成本：'
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We are using the assignment ![x_{0} = x_{1} = x_{2} = 1](img/file583.png "x_{0}
    = x_{1} = x_{2} = 1"), so when we execute the code we obtain the following output:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的是![x_{0} = x_{1} = x_{2} = 1](img/file583.png "x_{0} = x_{1} = x_{2} =
    1")的赋值，因此当我们执行代码时，我们获得以下输出：
- en: '[PRE9]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This tells us that the assignment is not feasible, and the `violations` method
    gives us the amount by which the left-hand side of each inequality is bigger than
    the right-hand side.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们赋值不可行，`violations`方法告诉我们每个不等式左边比右边大多少。
- en: 'If, on the other hand, we want to try the ![x_{0} = x_{1} = 0,x_{2} = 1](img/file584.png
    "x_{0} = x_{1} = 0,x_{2} = 1") assignment, we can use the following code:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果我们想尝试![x_{0} = x_{1} = 0,x_{2} = 1](img/file584.png "x_{0} = x_{1} =
    0,x_{2} = 1")的赋值，我们可以使用以下代码：
- en: '[PRE10]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The result that we obtain is the following:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到的结果如下：
- en: '[PRE11]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this case, the assignment is feasible and, therefore, no violation term is
    positive.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，赋值是可行的，因此没有违反项是正的。
- en: The `dimod` package also provides a brute-force solver that tries all possible
    assignments and sorts them according to their cost, from lowest to highest. Using
    it with our example is as simple as running
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`dimod`包还提供了一个穷举搜索求解器，它会尝试所有可能的赋值，并按照它们的成本从低到高进行排序。使用它和我们的例子一样简单，只需运行'
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: to obtain
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 以获得
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The first number is just an identifier of the assignment. It is followed by
    the values given to the variables. Then, we find the cost of the assignment —
    or, rather, its energy, if interpreted in terms of the Hamiltonian. After that,
    comes the times this solution has been found, which will always be ![1](img/file13.png
    "1") with this solver. Finally, we find information about which constraints are
    satisfied and whether the solution is feasible or not. It is very important to
    notice that the assignments are ordered by cost, but some of them may be unfeasible,
    even the first one, as in this case.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个数字只是赋值的标识符。其后是赋予变量的值。然后，我们找到赋值的成本——或者更准确地说，如果从哈密顿量的角度来解释，就是其能量。之后，是找到这个解决方案的次数，在这个求解器中这总是![1](img/file13.png
    "1")。最后，我们找到关于哪些约束得到满足以及解决方案是否可行等信息。非常重要的一点是，赋值是按照成本排序的，但其中一些可能不可行，甚至第一个也可能，就像在这个例子中一样。
- en: 'In fact, if we execute `solution``.``first`, we will obtain this output:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，如果我们执行`solution``.``first`，我们将获得以下输出：
- en: '[PRE14]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'where we can see that this assignment does not satisfy either of the two constraints
    of our problem. If you want the optimal solution to the problem, you should always
    remove the unfeasible solutions first with the `filter` method, using an instruction
    like the following:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 其中我们可以看到这个赋值没有满足我们问题的两个约束中的任何一个。如果你想要问题的最优解，你应该始终先使用`filter`方法删除不可行的解，如下面的指令所示：
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Then, if you access `feasible_sols``.``first`, you will get
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，如果你访问`feasible_sols``.``first`，你将得到
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: which is, indeed, the optimal solution to our binary linear program.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实是我们的二进制线性规划问题的最优解。
- en: Of course, all these computations are done with a (very inefficient) classical
    algorithm. In the next subsection, we explain how to use actual quantum annealers
    to try to solve the problems that we have defined.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，所有这些计算都是用（非常低效的）经典算法完成的。在下一个小节中，我们将解释如何使用实际的量子退火器来尝试解决我们定义的问题。
- en: 4.3.3 Running constrained problems on quantum annealers
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.3.3 在量子退火器上运行约束问题
- en: As useful as the `ConstrainedQuadraticModel` class is, we cannot use it to define
    problems that can be run on quantum annealers. In order to do that, we first need
    to eliminate the constraints and create a `BinaryQuadraticModel` object that we
    can later execute on actual quantum hardware as we did in *Section* *[*4.2*](#x1-770004.2).
    Fortunately, the process is really simple thanks to the utilities provided in
    the Ocean library. Let’s see how this works with an example.*
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`ConstrainedQuadraticModel`类很有用，但我们不能用它来定义可以在量子退火器上运行的问题。为了做到这一点，我们首先需要消除约束，并创建一个`BinaryQuadraticModel`对象，我们可以在稍后将其在实际量子硬件上执行，就像我们在*第*
    *[*4.2*](#x1-770004.2) *节中所做的那样。幸运的是，多亏了Ocean库提供的实用工具，这个过程实际上非常简单。让我们通过一个例子来看看它是如何工作的。*
- en: '*To illustrate the general procedure, let’s define a simple constrained problem
    with the following code:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '*为了说明一般步骤，让我们用以下代码定义一个简单的约束问题：'
- en: '[PRE17]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We can transform this constrained problem into an unconstrained one by using
    the `cqm_to_bqm` method as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用`cqm_to_bqm`方法将这个约束问题转化为一个无约束问题，具体操作如下：
- en: '[PRE18]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In a moment, we will explain what `invert` is and how it is used, but for now
    let’s focus on the output of those instructions, which will be something similar
    to the following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在不久的将来，我们将解释`invert`是什么以及它是如何使用的，但现在让我们专注于这些指令的输出，它将类似于以下内容：
- en: '[PRE19]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: That is quite a mouthful, but we promise that it is not nearly as complicated
    as it seems. In fact, with what you already know from *Chapter* *[*3*](ch011.xhtml#x1-590003),
    *QUBO:* *Quadratic Unconstrained Binary Optimization*, you could have computed
    a similar output yourself! Let’s unpack it.*
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来可能有些复杂，但我们保证它并不像看起来那么复杂。实际上，如果你已经从*第* *[*3*](ch011.xhtml#x1-590003) *章中了解到*QUBO:*
    *二次无约束二进制优化*，你完全可以自己计算出类似的结果！让我们来分解它。*
- en: '*Since this is an unconstrained problem, what we are seeing is the specification
    of the cost function. First, we have the linear part, which starts with `’``y0``’:`'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '*由于这是一个无约束问题，我们看到的是成本函数的指定。首先，我们有线性部分，它以`’``y0``’`开头：*'
- en: '`-17.0`. It tells us that, in the objective function, ![y_{0}](img/file445.png
    "y_{0}") has coefficient ![- 17](img/file585.png "- 17"), ![y_{1}](img/file460.png
    "y_{1}") has coefficient ![- 23](img/file586.png "- 23"), and the two other variables
    have coefficient ![- 15](img/file587.png "- 15"). Then comes the quadratic part,
    with coefficient ![20](img/file588.png "20") for the ![y_{0}y_{1}](img/file589.png
    "y_{0}y_{1}") term, something that we deduce from the `(’``y1``’,` `’``y0``’):`
    `20.0` value, and with coefficients ![10](img/file161.png "10") and ![20](img/file588.png
    "20") for the other products of two variables. Finally, ![20](img/file588.png
    "20") is the independent term or offset, and we are also told that all the variables
    are binary.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`-17.0`。它告诉我们，在目标函数中，![y_{0}](img/file445.png "y_{0}")的系数是![ - 17](img/file585.png
    "- 17")，![y_{1}](img/file460.png "y_{1}")的系数是![ - 23](img/file586.png "- 23")，另外两个变量的系数是![
    - 15](img/file587.png "- 15")。然后是二次部分，对于![y_{0}y_{1}](img/file589.png "y_{0}y_{1}")项，系数是![20](img/file588.png
    "20")，这是我们从`(’``y1``’，` `’``y0``’):` `20.0`值推断出来的，其他两个变量的乘积的系数是![10](img/file161.png
    "10")和![20](img/file588.png "20")。最后，![20](img/file588.png "20")是独立项或偏移量，我们还被告知所有变量都是二进制的。'
- en: But, where do all these coefficients come from? What our good friend `dimod`
    is doing here is nothing but applying the transformations that we studied in *Section*
    *[*3.4.1*](ch011.xhtml#x1-690003.4.1). First, two slack variables — with quite
    ugly random names — are introduced to transform the inequality constraint into
    an equality one. Then, the equality constraint is incorporated into the cost function
    as a penalty term with a penalty coefficient (the `lagrange_multiplier` parameter),
    which equals ![5](img/file296.png "5"). And that’s all! It wasn’t that mysterious
    after all, was it?*
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，所有这些系数从何而来？我们的好朋友`dimod`在这里所做的不外乎是应用我们在*第3.4.1节*中研究的转换。首先，引入两个松弛变量——带有相当丑陋的随机名称——将不等式约束转换为等式约束。然后，将等式约束作为惩罚项纳入成本函数中，惩罚系数（`lagrange_multiplier`参数）等于![5](img/file296.png
    "5")。就是这样！其实并没有那么神秘，对吧？
- en: '*Exercise 4.3'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*练习4.3'
- en: Check that the QUBO problem returned by `cqm_to_bqm` coincides with what you
    would obtain should you apply the transformations explained in *Section* *[*3.4.1*](ch011.xhtml#x1-690003.4.1).
    Don’t forget the offset!*
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 请检查`cqm_to_bqm`返回的QUBO问题是否与你在*第3.4.1节*中解释的转换所得到的结果一致。别忘了偏移量！
- en: '*We can now use a quantum annealer to solve the problem defined in the `qubo`
    object just as we did in *Section* *[*4.2*](#x1-770004.2). For instance, we can
    run the following code:*'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*现在我们可以使用量子退火器来解决在`qubo`对象中定义的问题，就像我们在*第4.2节*中做的那样。例如，我们可以运行以下代码：*'
- en: '*[PRE20]'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE20]'
- en: 'Do not forget to import `EmbeddingComposite` and `DWaveSampler` if you haven’t
    done it yet. If you run these instructions, you will obtain an output similar
    to the following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有导入`EmbeddingComposite`和`DWaveSampler`，请务必导入。如果你运行这些指令，你将得到以下类似的输出：
- en: '[PRE21]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We can all agree that this is not very informative. The problem here is that
    we are looking at solutions to the transformed problem, which include the slack
    variables with all those long, cryptic names. Of course, we don’t really care
    about the slack variable values — we only introduced them in order to write our
    problem without any constraints. So, what can we do? Here’s where the `invert`
    object comes to our rescue! It allows us to retrieve the solutions to the original
    problem from the solutions to the transformed one. Thus, we can run the following
    instructions:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都可以同意这并不很有信息量。这里的问题是我们在看转换后问题的解，其中包括所有那些长而晦涩的松弛变量。当然，我们并不真正关心松弛变量的值——我们只是引入它们以便在不添加任何约束的情况下编写我们的问题。那么，我们能做什么呢？这就是`invert`对象发挥作用的地方！它允许我们从转换后问题的解中检索原始问题的解。因此，我们可以运行以下指令：
- en: '[PRE22]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'and obtain the following output, which now only shows the original variables:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 并获得以下输出，现在只显示原始变量：
- en: '[PRE23]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here, we have created a new `SampleSet` object — the type of structure in which
    `dimod` stores the results of solvers or samplers — from the samples obtained
    with the transformed problem. Notice that we use `invert` to eliminate the slack
    variables and that, by passing the `cqm` problem to the `from_samples_cqm` method,
    the energy without the penalties is computed, as well as the feasibility status
    of each assignment. In fact, notice that when printing the solutions that we sampled
    for the transformed problem, we obtained a solution with ![0](img/file12.png "0")
    energy. It corresponds to the assignment ![y_{0} = 1](img/file450.png "y_{0} =
    1") and ![y_{1} = 1](img/file590.png "y_{1} = 1"), which, on the original problem,
    had energy ![- 5](img/file591.png "- 5"). The difference in the two energies comes
    from the fact that this assignment is unfeasible, and in the unconstrained problem
    it receives a penalty for it. Notice that we have also used the number of occurrences
    to keep track of how many times each solution is sampled.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个新的`SampleSet`对象——这是`dimod`存储求解器或采样器结果的结构的类型——从变换问题获得的样本中。请注意，我们使用`invert`来消除松弛变量，并且通过将`cqm`问题传递给`from_samples_cqm`方法，计算了没有惩罚的能量以及每个分配的可行性状态。实际上，请注意，当我们打印变换问题的采样解时，我们获得了一个具有![0](img/file12.png
    "0")能量的解。它对应于分配![y_{0} = 1](img/file450.png "y_{0} = 1")和![y_{1} = 1](img/file590.png
    "y_{1} = 1")，在原始问题中，它们的能量是![- 5](img/file591.png "- 5")。这两种能量之间的差异来自于这个分配是不可行的，在无约束问题中，它因此受到惩罚。请注意，我们还使用了出现次数来跟踪每个解被采样的次数。
- en: 'So, in this way, we have recovered some solutions to the original problem,
    but there are a couple of details that we still need to fix. The first one is
    that if we want to only retain the feasible solutions, we need to use the `filter`
    method as we did in the previous subsection when using `ExactCMQSolver`. The second
    has to do with the repetition — which we can observe in the last two outputs —
    of the solution that sets ![y_{0} = 1](img/file450.png "y_{0} = 1") and ![y_{0}
    = 0](img/file455.png "y_{0} = 0"). These two solutions come from two different
    assignments in the transformed problem, but they only differed in the values given
    to the slack variables. So, when those slack variables are eliminated, they produce
    exactly the same assignment. If we want them to be considered together, as they
    should be, we can use the `aggregate` method. Putting it all together, we can
    execute this code:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们恢复了一些原始问题的解，但还有一些细节我们需要修复。第一个细节是，如果我们只想保留可行解，我们需要使用`filter`方法，就像我们在使用`ExactCMQSolver`时的前一小节中所做的那样。第二个细节与重复有关——我们可以在最后两个输出中观察到——设置![y_{0}
    = 1](img/file450.png "y_{0} = 1")和![y_{0} = 0](img/file455.png "y_{0} = 0")的解重复出现。这两个解来自变换问题的两个不同的分配，但它们只在松弛变量的值上有所不同。因此，当这些松弛变量被消除时，它们会产生完全相同的分配。如果我们想将它们视为应该一起考虑的解，我们可以使用`aggregate`方法。将所有这些放在一起，我们可以执行以下代码：
- en: '[PRE24]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This will print
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印
- en: '[PRE25]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: which is something that we can indeed use to solve our problem.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实是我们用来解决我们问题的东西。
- en: In this section, we have learned how to work with constrained problems and how
    to solve them both by brute force and with quantum annealers, transforming them
    into something that the quantum computer can use and then getting back to the
    original formulation. In the next section, we will study how to have more control
    over what the quantum annealer is doing in order to find the ground state of our
    Hamiltonians. Let’s fiddle a little bit with the inner workings of those shiny
    quantum computers!
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何处理约束问题以及如何通过穷举法和量子退火器来解决它们，将它们转化为量子计算机可以使用的东西，然后再回到原始公式。在下一节中，我们将研究如何更好地控制量子退火器的行为，以便找到我们哈密顿量的基态。让我们稍微调整一下那些闪亮的量子计算机的内部工作原理吧！
- en: 4.4 Solving optimization problems on quantum annealers with Leap
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.4 使用Leap在量子退火器上解决优化问题
- en: So far, we have run a couple of different optimization problems on actual quantum
    annealers. However, we have always used the default parameters and we do not even
    know the characteristics of the quantum computers that we are using. In this section,
    we shall remedy that. We will explain the different types of annealers that we
    can access through D-Wave Leap. We will also explore several hyperparameters that
    we can tweak when we are using these devices, and we will explain how to adjust
    the way in which our problems are embedded in the physical qubits — we will finally
    learn what that mysterious `EmbeddingComposite` object is used for!
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在实际的量子退火器上运行了几个不同的优化问题。然而，我们始终使用默认参数，甚至不知道我们使用的量子计算机的特性。在本节中，我们将纠正这一点。我们将解释我们可以通过
    D-Wave Leap 访问的不同类型的退火器。我们还将探索我们在使用这些设备时可以调整的几个超参数，并解释如何调整我们的问题在物理量子比特中的嵌入方式——我们最终将了解那个神秘的
    `EmbeddingComposite` 对象的用途！
- en: 4.4.1 The Leap annealers
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.4.1 The Leap annealers
- en: 'You can list the devices to which you have access with your Leap account by
    using the `get_solvers` method in this way:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用此处的 `get_solvers` 方法列出您可以使用 Leap 账户访问的设备：
- en: '[PRE26]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The results will depend on your actual access privileges, but for a typical
    free account you will see something like this:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将取决于您的实际访问权限，但对于一个典型的免费账户，您将看到如下内容：
- en: '[PRE27]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In this case, there are seven different solvers in total, of three different
    types. First, we have those with the word *hybrid* in their identifier. We will
    talk about them later in the chapter, but, for now, it suffices to know that they
    combine classical and quantum resources to solve problems. The other four, called
    `DW_2000Q_6`, `Advantage_system4``.1`, `Advantage_system6``.1`, and `Advantage2_prototype1``.1`,
    are pure quantum annealers. These are the devices that are selected when we use
    `DWaveSampler` to solve a problem, as we have been doing so far in this chapter.
    Let’s explore their properties in more detail.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，总共有七种不同的求解器，分为三种类型。首先，我们有标识符中包含单词 *hybrid* 的那些。我们将在本章后面讨论它们，但现在，只需知道它们结合经典和量子资源来解决问题即可。其他四种，称为
    `DW_2000Q_6`、`Advantage_system4.1`、`Advantage_system6.1` 和 `Advantage2_prototype1.1`，是纯量子退火器。这些是我们使用
    `DWaveSampler` 解决问题时所选择的设备，正如我们在本章中迄今为止所做的那样。让我们更详细地探索它们的属性。
- en: We can select a particular annealer by using the `solver` parameter in the `DWaveSampler`
    constructor and then access the properties of the device with the `properties`
    attribute. For instance, for the `DW_2000Q_6` annealer, we can run the following
    instructions
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在 `DWaveSampler` 构造函数中使用 `solver` 参数来选择特定的退火器，然后使用 `properties` 属性访问设备的属性。例如，对于
    `DW_2000Q_6` 退火器，我们可以运行以下指令
- en: '[PRE28]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'to obtain this output:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 以获得以下输出：
- en: '[PRE29]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: If we do the same but with the `Advantage_system4`
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们用 `Advantage_system4` 做同样的事情
- en: '`.1` solver, we obtain:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`.1` 求解器，我们得到：'
- en: '[PRE30]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The properties of the `Advantage_system6`
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`Advantage_system6` 的属性'
- en: '`.1` solver will be exactly the same — except for the name, of course.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`.1` 求解器将与名称不同之外完全相同。'
- en: Finally, for the `Advantage2_prototype1`
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于 `Advantage2_prototype1`
- en: '`.1` solver, we obtain the following output:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`.1` 求解器，我们得到以下输出：'
- en: '[PRE31]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: To learn more…
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多...
- en: 'The solvers have many other properties that we haven’t yet discussed; we will
    study some of the most relevant ones in *Sections* *[*4.4.2*](#x1-840004.4.2),
    [*4.4.3*](#x1-850004.4.3), and [*4.4.4*](#x1-860004.4.4). You can nonetheless
    access all of them through the `properties` dictionary, printing it directly.
    But be careful: some of them can be huge to print, such as `properties``[``"``qubits``"`
    `]`, which contains information about all the potentially thousands of qubits
    in a device!*'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 求解器还有许多我们尚未讨论的其他属性；我们将在 *第 4.4.2 节*[*4.4.2*](#x1-840004.4.2)，[*4.4.3 节*](#x1-850004.4.3)，和
    [*4.4.4 节*](#x1-860004.4.4) 中研究一些最相关的属性。不过，您仍然可以通过 `properties` 字典访问它们，直接打印出来。但请注意：其中一些可能非常大，例如
    `properties["qubits"]`，它包含有关设备中所有可能成千上万的量子比特的信息！
- en: '*Some properties are the same for the four devices. For instance, as we can
    see, all are of type **qpu**, which means that they are **quantum processing units**
    or quantum annealers. Also, all of them accept problems in the QUBO or Ising formats
    — but not constrained problems; that is why we had to transform them before running
    them in the previous section — and all can be used to obtain between ![1](img/file13.png
    "1") and ![10\, 000](img/file592.png "10\, 000") samples at a time. The main difference,
    other than the number of qubits — which is notably bigger in the `Advantage_system4``.1`
    and `Advantage_system6``.1` devices — is the **topology**. This refers to the
    way in which the qubits are connected to each other in the machine, and determines
    which **couplings** — or connections between variables — can be used to define
    our problems…unless we use an embedding, which will help us in mapping our coefficients
    to actual qubit connections.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '*一些属性对于这四种设备是相同的。例如，我们可以看到，它们都是**qpu**类型，这意味着它们是**量子处理单元**或量子退火器。此外，它们都接受QUBO或Ising格式的**问题**——但不接受约束问题；这就是为什么我们不得不在上一节运行之前将它们转换的原因——并且都可以用来一次获得![1](img/file13.png
    "1")到![10,000](img/file592.png "10,000")个样本。除了量子比特的数量——在`Advantage_system4.1`和`Advantage_system6.1`设备中特别多——主要区别是**拓扑结构**。这指的是量子比特在机器中相互连接的方式，并决定了哪些**耦合**——或变量之间的连接——可以用来定义我们的问题……除非我们使用嵌入，这将帮助我们将系数映射到实际的量子比特连接。*'
- en: The `Advantage2_prototype1`
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`Advantage2_prototype1`'
- en: '`.1` solver is a little bit special. As can be inferred from the name, it is
    a prototype of a new family of annealers that D-Wave will introduce in 2023-2024
    — that’s why, for now, it has fewer qubits than the rest of the devices, but the
    full version has been announced to have more than ![7000](img/file593.png "7000")
    qubits. It uses a new topology, called Zephyr, which is designed to increase connectivity
    and decrease errors. At the time of writing, the available device is not a final
    version. For this reason, we will not use it in the examples that we will be working
    with, nor will we describe its properties and topology in detail. Notice, however,
    that everything that we explain about how to work with the devices translates,
    with no changes, to this new annealer.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`.1`求解器有一点特别。从名称中可以推断出，它是D-Wave将在2023-2024年推出的一系列新退火器的原型——这就是为什么现在它的量子比特数量比其他设备少，但完整版本已宣布将拥有超过![7000](img/file593.png
    "7000")个量子比特。它使用一种新的拓扑结构，称为Zephyr，旨在增加连接性并减少错误。在撰写本文时，可用的设备不是最终版本。因此，我们不会在我们将要处理的示例中使用它，也不会详细描述其属性和拓扑结构。然而，请注意，我们关于如何与设备一起工作的所有解释，都可以无变化地应用于这个新的退火器。'
- en: We have summarized some of the annealer properties in *Table* *[*4.1*](#x1-83047r1).*
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在*表* *[*4.1*](#x1-83047r1)中总结了退火器的某些属性。
- en: '*| Annealer name | Number of qubits | Topology |'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '*| 退火器名称 | 量子比特数量 | 拓扑结构 |'
- en: '| `DW``_2000Q`_6 | 2048 | Chimera |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| `DW_2000Q_6` | 2048 | Chimera |'
- en: '| `Advantage``_system4.1` | 5760 | Pegasus |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| `Advantage_system4.1` | 5760 | Pegasus |'
- en: '| `Advantage``_system6.1` | 5760 | Pegasus |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| `Advantage_system6.1` | 5760 | Pegasus |'
- en: '| `Advantage2``_prototype1.1` | 576 | Zephyr |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| `Advantage2_prototype1.1` | 576 | Zephyr |'
- en: '**Table 4.1**: Summary of annealer properties'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 4.1**: 退火器属性摘要'
- en: In the next subsection, we shall explore in more detail the annealers’ topologies
    and how we can embed our problems in them.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一小节中，我们将更详细地探讨退火器的拓扑结构以及我们如何在其中嵌入我们的问题。
- en: 4.4.2 Embeddings and annealer topologies
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.4.2 嵌入和退火器拓扑
- en: In current quantum computers, be they annealers or gate-based devices, technological
    difficulties prevent qubits from being connected in an all-to-all way. In fact,
    each qubit is usually connected exclusively to some of its neighbours and we can
    only apply two-qubit gates or use couplings (that is, use non-zero coefficients
    in the Ising model) between those qubits that are actually linked. The particular
    way in which the qubits are connected in a certain quantum chip is called its
    **topology** and sometimes it is important to be aware of it when we design our
    algorithms or when we anneal our problems.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前的量子计算机中，无论是退火器还是基于门控的设备，技术困难阻止了量子比特以全连接的方式连接。事实上，每个量子比特通常仅与其邻居中的某些量子比特连接，我们只能在这些实际连接的量子比特之间应用两量子比特门或使用耦合（即在Ising模型中使用非零系数）。量子比特在特定量子芯片中的特定连接方式被称为其**拓扑结构**，有时在设计我们的算法或退火我们的问题时，了解这一点很重要。
- en: For instance, the topology of the `DW_2000Q_6` annealer is called, as we saw
    in the previous subsection, Chimera. It consists of cells of 8 qubits organized
    into two groups of 4 qubits each. All the qubits in one group are connected to
    all the qubits in the other group, but there are no connections inside each group.
    For graph connoisseurs, the connections follow a complete bipartite graph ![K_{4,4}](img/file594.png
    "K_{4,4}"), which is depicted in *Figure* * [*4.1*](#Figure4.1).*
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`DW_2000Q_6` 热退火机的拓扑结构被称为 Chimera，正如我们在前一小节中看到的。它由 8 个量子比特组成的单元格组成，分为每组 4
    个量子比特的两个组。一个组中的所有量子比特都连接到另一个组中的所有量子比特，但每个组内没有连接。对于图论爱好者来说，连接遵循一个完全二部图 ![K_{4,4}](img/file594.png
    "K_{4,4}")，这在 *图* *[*4.1*](#Figure4.1) 中有所描述。
- en: '*![Figure 4.1: Qubit connections in a Chimera cell](img/file595.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '*![图 4.1: Chimera 单元中的量子比特连接](img/file595.jpg)'
- en: '**Figure 4.1**: Qubit connections in a Chimera cell'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 4.1**: Chimera 单元中的量子比特连接'
- en: The `DW_2000Q_6` computer has ![256](img/file596.png "256") of these cells,
    organized in a ![16 \times 16](img/file597.png "16 \times 16") grid, making for
    a total of ![8 \cdot 16 \cdot 16 = 2048](img/file598.png "8 \cdot 16 \cdot 16
    = 2048") qubits, as expected. Each of the qubits that occupy the positions ![0](img/file12.png
    "0") to ![3](img/file472.png "3") in a cell is also connected to the qubits in
    the same position of the vertically adjacent cells. In a similar way, each qubit
    in positions ![4](img/file143.png "4") to ![7](img/file465.png "7") is also connected
    to the qubit in the same position of the horizontally adjacent cells. In total,
    each qubit will be connected to four other qubits in the same cell and to two
    other qubits (or one, if it lives in a border cell) from other cells.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`DW_2000Q_6` 计算机有 ![256](img/file596.png "256") 个这样的单元格，组织成一个 ![16 \times 16](img/file597.png
    "16 \times 16") 的网格，总共 ![8 \cdot 16 \cdot 16 = 2048](img/file598.png "8 \cdot
    16 \cdot 16 = 2048") 个量子比特，正如预期的那样。每个占据单元格中 ![0](img/file12.png "0") 到 ![3](img/file472.png
    "3") 位置的量子比特也连接到垂直相邻单元格中相同位置的量子比特。以类似的方式，每个位于 ![4](img/file143.png "4") 到 ![7](img/file465.png
    "7") 位置的量子比特也连接到水平相邻单元格中相同位置的量子比特。总共，每个量子比特将与同一单元格中的另外四个量子比特以及来自其他单元格的两个其他量子比特（或一个，如果它位于边界单元格中）相连。'
- en: 'We can obtain a list enumerating all the connections by using the `properties``[``"``couplers``"``]`
    attribute as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用 `properties``[``"``couplers``"``]` 属性来获取所有连接的列表，如下所示：
- en: '[PRE32]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Running this, we will get a very long list that begins like this:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此操作，我们将得到一个非常长的列表，其开头如下所示：
- en: '[PRE33]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'A slightly more readable way of obtaining the same information is by using
    `sampler``.``adjacency`, which will we give us a dictionary indexed by qubit numbers
    and values that specify the qubits that are connected to the qubit in the key.
    In our case, it starts like this:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 获取相同信息的另一种稍微更易读的方法是使用 `sampler``.``adjacency`，这将为我们提供一个按量子比特编号和值索引的字典，其中值指定了与键中的量子比特相连的量子比特。在我们的例子中，它开始如下所示：
- en: '[PRE34]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Exercise 4.4
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 4.4
- en: Pick the qubits numbered from ![0](img/file12.png "0") to ![7](img/file465.png
    "7") and check that their connections correspond to the description of the Chimera
    topology that we have made in the text. Notice that they all lie in the top-left
    corner cell, so they will be connected to one cell on the right and one cell below.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 选择编号从 ![0](img/file12.png "0") 到 ![7](img/file465.png "7") 的量子比特，并检查它们的连接是否与我们在文本中描述的
    Chimera 拓扑相符合。注意，它们都位于左上角的单元格中，因此它们将与右侧的一个单元格和下方的一个单元格相连。
- en: To learn more…
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多…
- en: The `Advantage_system4``.1` and `Advantage_system6` `.1` annealers use a topology
    called **Pegasus**. It also groups qubits into cells, but their structure is more
    involved than that of the Chimera cells. Every qubit is connected to up to ![15](img/file599.png
    "15") qubits, compared to the maximum of ![6](img/file576.png "6") in `DW_2000Q_6`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`Advantage_system4``.1` 和 `Advantage_system6` `.1` 热退火机使用一个称为 **Pegasus** 的拓扑结构。它也将量子比特分组到单元格中，但它们的结构比
    Chimera 单元更复杂。每个量子比特最多连接到 ![15](img/file599.png "15") 个量子比特，而 `DW_2000Q_6` 中的最大连接数是
    ![6](img/file576.png "6")。'
- en: This topology also contains groups of 4 qubits that are all connected to each
    other, making it much easier to embed problems into it, as we will see later in
    the *Section* *[*4.4.2*](#x1-840004.4.2).*
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这种拓扑还包含 4 个量子比特的组，它们都相互连接，这使得将问题嵌入其中变得容易得多，正如我们将在 *第* *[*4.4.2*](#x1-840004.4.2)
    *节中看到的。
- en: '*Describing the Pegasus topology in detail would get us too far out from our
    path, but you can find all the information in *Section 2.3* of the *QPU-Specific
    Physical Properties* document for the `Advantage_system4``.1` and `Advantage_system6`
    `.1` annealers. You can download it, together with the corresponding documents
    for the rest of the D-Wave quantum computers, at [https://docs.dwavesys.com/docs/latest/doc_physical_properties.html](https://docs.dwavesys.com/docs/latest/doc_physical_properties.html).*
    *One important thing to note about the Chimera topology is that it does not contain
    triangles. That is, there are no three vertices all connected to each other. Thus,
    if our Ising Hamiltonian is something like ![Z_{0}Z_{1} + Z_{0}Z_{2} + Z_{1}Z_{2}](img/file600.png
    "Z_{0}Z_{1} + Z_{0}Z_{2} + Z_{1}Z_{2}"), we cannot directly map it to qubits in
    the `DW_2000Q_6` annealer. What can we do then? Is it impossible to solve such
    a problem with this computer? Don’t worry, embeddings are here to save the day!'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 详细描述Pegasus拓扑结构会让我们偏离我们的路径太远，但你可以在`Advantage_system4``.1`和`Advantage_system6`
    `.1`退火器对应的`QPU-Specific Physical Properties`文档的*第2.3节*中找到所有信息。你可以在[https://docs.dwavesys.com/docs/latest/doc_physical_properties.html](https://docs.dwavesys.com/docs/latest/doc_physical_properties.html)下载它，以及D-Wave量子计算机其他部分的相应文档。*关于Chimera拓扑的一个重要注意事项是它不包含三角形。也就是说，没有三个顶点都相互连接。因此，如果我们的Ising哈密顿量类似于![Z_{0}Z_{1}
    + Z_{0}Z_{2} + Z_{1}Z_{2}](img/file600.png "Z_{0}Z_{1} + Z_{0}Z_{2} + Z_{1}Z_{2}")，我们无法直接将其映射到`DW_2000Q_6`退火器中的量子比特。那么我们该怎么办？用这台计算机解决这样的问题是不可能的吗？别担心，嵌入技术就在这里来拯救这一天！
- en: An **embedding** is, essentially, a way of mapping the qubits in our problem
    Hamiltonian to the physical qubits in the annealer. The trick here is that this
    mapping need not be one to one. In fact, we can use several physical qubits (what
    we call a **chain**) to represent a single qubit from our problem. In that case,
    though, we want all the qubits in the same chain to have the same value when we
    measure them. To guarantee that, we need to use coupling strengths that are negative
    and big in absolute value.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '**嵌入**本质上是一种将我们问题哈密顿量中的量子比特映射到退火器中的物理量子比特的方法。这里的技巧是这个映射不必是一对一的。实际上，我们可以使用几个物理量子比特（我们称之为**链**）来表示我们问题中的一个量子比特。在这种情况下，尽管如此，我们希望同一链中的所有量子比特在测量时都具有相同的值。为了确保这一点，我们需要使用负值且绝对值大的耦合强度。'
- en: For instance, if qubits ![12](img/file601.png "12") and ![20](img/file588.png
    "20") are part of the same chain, the coefficient for ![(12,20)](img/file602.png
    "(12,20)") could be, for instance, ![- 15](img/file587.png "- 15"). Then, the
    term ![- 15Z_{12}Z_{20}](img/file603.png "- 15Z_{12}Z_{20}") will be part of the
    spin Hamiltonian that we want to minimize and it will make it very likely for
    ![Z_{12}](img/file604.png "Z_{12}") and ![Z_{20}](img/file605.png "Z_{20}") to
    be equal to each other, because that will make the total energy significantly
    lower.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果量子比特![12](img/file601.png "12")和![20](img/file588.png "20")是同一链的一部分，那么![(12,20)](img/file602.png
    "(12,20)")的系数可以是，例如，![- 15](img/file587.png "- 15")。然后，项![- 15Z_{12}Z_{20}](img/file603.png
    "- 15Z_{12}Z_{20}")将成为我们想要最小化的自旋哈密顿量的一部分，并且它将使![Z_{12}](img/file604.png "Z_{12}")和![Z_{20}](img/file605.png
    "Z_{20}")相等变得非常可能，因为这将使总能量显著降低。
- en: 'Of course, the embedding needs to define the physical qubits (chains) used
    to represent each problem qubit, ensure that they can be connected correctly,
    and compute some appropriate coupling strengths for the chains. This may seem
    very complicated, but Ocean can compute embeddings automatically for us. Let’s
    see, with an example, how to do it for a simple case. We could use the following
    code:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，嵌入需要定义用于表示每个问题量子比特的物理量子比特（链），确保它们可以正确连接，并为链计算一些适当的耦合强度。这看起来可能非常复杂，但Ocean可以为我们自动计算嵌入。让我们看看，通过一个例子，我们如何为一个简单的情况来做这件事。我们可以使用以下代码：
- en: '[PRE35]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In these instructions, we first define a problem that requires three qubits
    to be connected together, something that we know is not directly possible with
    the annealer that we have selected. But, since we are using `EmbeddingComposite`,
    a way of embedding our graph in the actual annealer topology is automatically
    found for us, and we can run the annealing process and obtain some samples. By
    setting the `return_embedding` parameter to `True`, we also recover the embedding
    information. Let’s see what the output of running this code may look like:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些说明中，我们首先定义了一个需要三个量子位连接在一起的问题，我们知道这直接使用我们选择的退火器是不可能的。但是，由于我们正在使用`EmbeddingComposite`，一种将我们的图嵌入实际退火器拓扑的方法会自动为我们找到，我们可以运行退火过程并获得一些样本。通过将`return_embedding`参数设置为`True`，我们还可以恢复嵌入信息。让我们看看运行此代码的输出可能是什么样子：
- en: '[PRE36]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As you can see, `EmbeddingComposite` performs the embedding in a way that is
    completely transparent for the user and, in fact, the samples returned only refer
    to the variables in the original problem. However, underneath the hood, variable
    ![0](img/file12.png "0") has been mapped to qubit ![1011](img/file606.png "1011"),
    variable ![2](img/file302.png "2") has been mapped to qubit ![1012](img/file607.png
    "1012"), and variable ![1](img/file13.png "1") is represented by the chain formed
    by qubits ![1008](img/file608.png "1008") and ![1015](img/file609.png "1015").
    The coupling strength for these two qubits was almost ![2](img/file302.png "2"),
    which is bigger than the coefficients of the original problem in order to prevent
    the qubits in the chain from having different values. If, for whatever reason,
    these two qubits in the chain happen to receive different values, the chain is
    said to be **broken** and the method specified in `’``chain_break_method``’` would
    be used to assign a value to variable ![1](img/file13.png "1"). In this case,
    that value would be a simple majority vote between the qubits in the chain.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`EmbeddingComposite`以对用户完全透明的方式执行嵌入，实际上返回的样本仅指向原始问题中的变量。然而，在底层，变量![0](img/file12.png
    "0")已被映射到量子位![1011](img/file606.png "1011")，变量![2](img/file302.png "2")已被映射到量子位![1012](img/file607.png
    "1012")，而变量![1](img/file13.png "1")则由量子位![1008](img/file608.png "1008")和![1015](img/file609.png
    "1015")形成的链表示。这两个量子位的耦合强度几乎为![2](img/file302.png "2")，这比原始问题的系数要大，以防止链中的量子位具有不同的值。如果由于任何原因，链中的这两个量子位恰好接收不同的值，则称链为**断裂**，并且会使用`’``chain_break_method``’`中指定的方法为变量![1](img/file13.png
    "1")分配一个值。在这种情况下，该值将是链中量子位的简单多数投票。
- en: To learn more…
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多信息…
- en: Finding a suitable embedding is an ![NP](img/file2.png "NP")-hard problem. However,
    the `minorminer` package included with Ocean provides heuristics for finding embeddings
    that usually work well in practice. These are used by `EmbeddingComposite`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找一个合适的嵌入是一个![NP](img/file2.png "NP")-难问题。然而，Ocean附带包含的`minorminer`包提供了寻找嵌入的启发式方法，这些方法在实践中通常效果良好。这些被`EmbeddingComposite`使用。
- en: In addition to `EmbeddingComposite`, there are other classes in Ocean that allow
    you to find embeddings for your problems. For instance, `AutoEmbeddingComposite`
    first tries to run the problem on the annealer directly, not using an embedding,
    and only looks for one if it is needed; this can save some computing time in some
    cases. The `FixedEmbeddingComposite` class doesn’t compute an embedding, but uses
    whichever one is passed as a parameter; in this case, the embedding should be
    a Python dictionary with the format shown in the previous output. We also can
    use `LazyFixedEmbeddingComposite`, which only computes the embedding for a problem
    on the first call to the `sample` method, storing it for future calls; `EmbeddingComposite`,
    on the other hand, recomputes the embedding with each call to `sample`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`EmbeddingComposite`，Ocean中还有其他类允许您为问题找到嵌入。例如，`AutoEmbeddingComposite`首先尝试直接在退火器上运行问题，不使用嵌入，只有在需要时才寻找一个；这可以在某些情况下节省一些计算时间。`FixedEmbeddingComposite`类不计算嵌入，而是使用作为参数传递的任何一个；在这种情况下，嵌入应该是一个具有之前输出所示格式的Python字典。我们还可以使用`LazyFixedEmbeddingComposite`，它只在第一次调用`sample`方法时为问题计算嵌入，并将其存储以供后续调用；另一方面，`EmbeddingComposite`在每次调用`sample`时都会重新计算嵌入。
- en: So, that should cover most of your needs for embedding problems into any annealer
    topology. But we’re not done yet! There are still some additional parameters that
    we can control when running problems with Ocean on actual quantum devices. We
    will study some of the most important ones in the next subsection.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这应该涵盖了将问题嵌入到任何退火拓扑结构中的大部分需求。但我们还没有完成！当在真实的量子设备上使用Ocean运行问题时，我们仍然可以控制一些额外的参数。我们将在下一小节中研究其中一些最重要的参数。
- en: 4.4.3 Controlling annealing parameters
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.4.3 控制退火参数
- en: You surely remember from the beginning of this chapter that for an evolution
    to be adiabatic (and, hence, for the system to remain in a state of minimal energy),
    it needs to be slow enough. However, this condition is difficult to meet in practice,
    so we just resort to running the evolution for a short period of time, resulting
    in what we call quantum annealing.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 你一定记得，从本章的开头开始，为了使演化是绝热的（因此，系统保持在最小能量状态），它需要足够慢。然而，在实践中很难满足这个条件，所以我们只是运行演化过程的一小段时间，这就是我们所说的量子退火。
- en: 'The question is: to what extent can we control the annealing process with D-Wave’s
    quantum annealers? It turns out that there are quite a number of things that we
    can do in order to try to improve the results for our combinatorial optimization
    problems. The first (and most obvious) is changing the duration of the annealing
    process.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是：我们能在多大程度上控制D-Wave量子退火器的退火过程？结果是，我们可以做很多事情来尝试改善我们的组合优化问题的结果。首先（也是最明显的）是改变退火过程的持续时间。
- en: 'You can easily check the range of annealing times that a device supports, as
    well as its default annealing time, using instructions like the following:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下指令轻松检查设备支持的退火时间范围以及其默认退火时间：
- en: '[PRE37]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The output, in this case, will be as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，输出将如下所示：
- en: '[PRE38]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Exercise 4.5
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 练习4.5
- en: Check the default annealing time and the annealing time range for the `DW_2000Q_6`
    annealer.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 检查`DW_2000Q_6`退火器的默认退火时间和退火时间范围。
- en: 'Modifying the annealing time for a problem couldn’t be easier. For instance,
    imagine that we want to increase it to ![100](img/file389.png "100") microseconds
    and sample from the triangle problem that we defined in the previous subsection.
    Then, the only modification that we would need to apply is adding the `annealing_time`
    parameter when calling the `sample` method. We could run, for instance, the following
    code:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 修改问题的退火时间非常简单。例如，假设我们想将其增加到![100](img/file389.png "100")微秒，并从我们在上一小节中定义的三角形问题中进行采样。那么，我们唯一需要做的修改就是在调用`sample`方法时添加`annealing_time`参数。例如，我们可以运行以下代码：
- en: '[PRE39]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Important note
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'In order to try to obtain better and better solutions, you may be tempted to
    increase the annealing time to its maximum possible value. However, be warned
    that this may have two unwanted consequences. On the one hand, the longer you
    run the annealing process, the higher the possibility that external interactions
    will affect the system state and ruin your computation: you might get worse results
    instead of better ones! On the other hand, by increasing the annealing time, you
    will obviously spend more time using the quantum processing unit…and you will
    be charged accordingly!'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 为了尝试获得更好的解决方案，你可能想将退火时间增加到其最大可能值。然而，警告你，这可能会产生两个不希望的结果。一方面，你运行退火过程的时间越长，外部相互作用影响系统状态并破坏计算的可能性就越高：你可能会得到更差的结果而不是更好的结果！另一方面，通过增加退火时间，你显然会花费更多的时间使用量子处理单元……并且你将相应地被收费！
- en: With Ocean, the options to control the annealing process are not reduced to
    just modifying the annealing time. You can also tailor, to some extent, the annealing
    schedule itself. As we already know, this refers to the ![A](img/file183.png "A")
    and ![B](img/file184.png "B") functions in the expression
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Ocean，控制退火过程的选择并不仅限于修改退火时间。你还可以在一定程度上定制退火计划本身。正如我们已经知道的，这指的是表达式中的![A](img/file183.png
    "A")和![B](img/file184.png "B")函数。
- en: '![H(t) = - A(t)\sum\limits_{j = 0}^{n - 1}X_{j} - B(t)\sum\limits_{j,k}J_{jk}Z_{j}Z_{k}
    - B(t)\sum\limits_{j}h_{j}Z_{j},](img/file561.png "H(t) = - A(t)\sum\limits_{j
    = 0}^{n - 1}X_{j} - B(t)\sum\limits_{j,k}J_{jk}Z_{j}Z_{k} - B(t)\sum\limits_{j}h_{j}Z_{j},")'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![H(t) = - A(t)\sum\limits_{j = 0}^{n - 1}X_{j} - B(t)\sum\limits_{j,k}J_{jk}Z_{j}Z_{k}
    - B(t)\sum\limits_{j}h_{j}Z_{j},](img/file561.png "H(t) = - A(t)\sum\limits_{j
    = 0}^{n - 1}X_{j} - B(t)\sum\limits_{j,k}J_{jk}Z_{j}Z_{k} - B(t)\sum\limits_{j}h_{j}Z_{j},")'
- en: which defines the Hamiltonian that we use in the annealing process.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这定义了我们在退火过程中使用的哈密顿量。
- en: You may remember that we only required ![A](img/file183.png "A") and ![B](img/file184.png
    "B") to satisfy that ![A(0) = B(T) = 1](img/file548.png "A(0) = B(T) = 1") and
    ![A(T) = B(0) = 0](img/file549.png "A(T) = B(0) = 0"), where ![T](img/file74.png
    "T") is the total annealing time, but we did not restrict in any way how ![A](img/file183.png
    "A") and ![B](img/file184.png "B") should behave except for these boundary conditions.
    D-Wave’s annealers have default schedules. You can find them at [https://docs.dwavesys.com/docs/latest/doc_physical_properties.html](https://docs.dwavesys.com/docs/latest/doc_physical_properties.html)
    and in the annealing schedule sections of the user manuals for the devices, which
    you can find on that same web page. We can modify those default schedules by specifying
    the values that we want the functions to take at some intermediate times.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能记得，我们只要求![A](img/file183.png "A")和![B](img/file184.png "B")满足![A(0) = B(T)
    = 1](img/file548.png "A(0) = B(T) = 1")和![A(T) = B(0) = 0](img/file549.png "A(T)
    = B(0) = 0")，其中![T](img/file74.png "T")是总的退火时间，但我们并没有以任何方式限制![A](img/file183.png
    "A")和![B](img/file184.png "B")的行为，除了这些边界条件。D-Wave的退火器有默认的计划。你可以在[https://docs.dwavesys.com/docs/latest/doc_physical_properties.html](https://docs.dwavesys.com/docs/latest/doc_physical_properties.html)找到它们，以及设备用户手册的退火计划部分，这些都可以在同一个网页上找到。我们可以通过指定我们希望在某个中间时间函数取的值来修改这些默认计划。
- en: We can define a custom annealing schedule through a list of pairs of real numbers.
    The first number of each pair needs to be a time value given in microseconds and
    the second one has to be a number between ![0](img/file12.png "0") and ![1](img/file13.png
    "1"). This second number is called the **anneal fraction**, usually denoted by
    ![s](img/file610.png "s"). The higher the value of ![s](img/file610.png "s") is,
    the higher the value of ![B](img/file184.png "B") and the lower the value of ![A](img/file183.png
    "A") will be. As a consequence, when ![s = 1](img/file611.png "s = 1"), we can
    interpret that ![B](img/file184.png "B") is ![1](img/file13.png "1") and ![A](img/file183.png
    "A") is 0; when ![s = 0](img/file612.png "s = 0"), we can interpret that ![A](img/file183.png
    "A") is ![1](img/file13.png "1") and ![B](img/file184.png "B") is ![0](img/file12.png
    "0").
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过一个实数对的列表定义一个自定义退火计划。每个对的第一个数字需要是一个以微秒为单位的时间值，第二个数字必须在![0](img/file12.png
    "0")和![1](img/file13.png "1")之间。这个第二个数字被称为**退火分数**，通常用![s](img/file610.png "s")表示。![s](img/file610.png
    "s")的值越高，![B](img/file184.png "B")的值就越高，而![A](img/file183.png "A")的值就越低。因此，当![s
    = 1](img/file611.png "s = 1")时，我们可以理解为![B](img/file184.png "B")是![1](img/file13.png
    "1")，而![A](img/file183.png "A")是0；当![s = 0](img/file612.png "s = 0")时，我们可以理解为![A](img/file183.png
    "A")是![1](img/file13.png "1")，而![B](img/file184.png "B")是![0](img/file12.png "0")。
- en: There are two types of annealing schedules that we can use. The first one is
    called **forward annealing** and corresponds to the usual annealing process that
    we have been studying since the beginning of this chapter. It starts with ![(0,0)](img/file613.png
    "(0,0)") and ends at ![(T,1)](img/file614.png "(T,1)"), where ![T](img/file74.png
    "T") is the total annealing time — which, of course, must not be bigger than the
    maximum annealing time allowed by the device. In addition, the values of ![s](img/file610.png
    "s") must monotonically increase over the time points.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用两种类型的退火计划。第一种被称为**正向退火**，对应于我们从本章开始就一直在研究的常规退火过程。它从![[(0,0)](img/file613.png
    "(0,0)")]开始，到![[(T,1)](img/file614.png "(T,1)")]结束，其中![T](img/file74.png "T")是总的退火时间——当然，这个时间不能超过设备允许的最大退火时间。此外，![s](img/file610.png
    "s")的值必须随时间点单调增加。
- en: 'An example of a forward annealing schedule could be the following:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 一个正向退火计划的例子可能是以下这样：
- en: '[PRE40]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In this case, ![s](img/file610.png "s") starts at ![0](img/file12.png "0"),
    gets value ![0.25](img/file615.png "0.25") at 5 microseconds, ![0.75](img/file616.png
    "0.75") at 25 microseconds and, finally, ![1](img/file13.png "1") at 30 microseconds,
    which is the end of the annealing process. The growth of ![s](img/file610.png
    "s") will be linear between the points specified in the schedule. To use this
    custom schedule in a device, you only need to pass it as the `anneal_schedule`
    parameter. For instance, you can do something like the following:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，![s](img/file610.png "s")从![0](img/file12.png "0")开始，在5微秒时取值为![0.25](img/file615.png
    "0.25")，在25微秒时取值为![0.75](img/file616.png "0.75")，最后在30微秒时取值为![1](img/file13.png
    "1")，这是退火过程的结束。![s](img/file610.png "s")的增长将在计划中指定的点之间是线性的。要在设备中使用这个自定义计划，你只需要将其作为`anneal_schedule`参数传递。例如，你可以做如下操作：
- en: '[PRE41]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Here, `triangle` is the problem that we defined in the previous code block.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`triangle`是我们之前定义的问题。
- en: To learn more…
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多...
- en: Controlling the annealing schedule can be useful for certain problems, especially
    if you know that at some points the ground state and the first excited state are
    closer. In this case, you can use a custom schedule to slow the annealing process
    down on those ”dangerous” regions, while allowing it to go faster on other, less
    problematic, time intervals.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 控制退火时间表对于某些问题可能是有用的，特别是如果你知道在某些点上基态和第一个激发态更接近。在这种情况下，你可以使用自定义的时间表来减慢那些“危险”区域的退火过程，同时允许在其他不太有问题的时间间隔内加快退火。
- en: In addition to forward annealing, we can also use **reverse annealing**. In
    reverse annealing, ![s](img/file610.png "s") starts at ![1](img/file13.png "1"),
    decreases for some time, and then increases back to ![1](img/file13.png "1") at
    the end of the annealing process. An example of a reverse annealing schedule could
    be
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 除了正向退火，我们还可以使用**反向退火**。在反向退火中，![s](img/file610.png "s")从![1](img/file13.png
    "1")开始，经过一段时间后减小，然后在退火过程的最后回到![1](img/file13.png "1")。一个反向退火的时间表示例可能是
- en: '[PRE42]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: where, as in the case of forward annealing, the values of ![s](img/file610.png
    "s") are linearly interpolated between the points given in the list.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，与正向退火的情况一样，![s](img/file610.png "s")的值在列表中给出的点之间进行线性插值。
- en: When using reverse annealing, you also need to specify an initial state. This
    is because now we do not start with a Hamiltonian whose ground state is known
    to us. You can do that with the `initial_state` parameter of the `sample` method.
    Reverse annealing is commonly used on an approximate solution that we already
    have in an attempt to find a better one. In this case, we take that solution to
    be the initial state, we decrease the intensity of the final Hamiltonian for some
    time, and then we increase it again in an attempt to obtain a new solution with
    a lower energy.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用反向退火时，你还需要指定一个初始状态。这是因为现在我们不是从一个我们已知基态的哈密顿量开始。你可以通过`sample`方法的`initial_state`参数来实现这一点。反向退火通常用于对已经拥有的近似解进行尝试，以找到更好的解。在这种情况下，我们将该解作为初始状态，我们降低最终哈密顿量的强度一段时间，然后再次增加，试图获得一个能量更低的新的解。
- en: There are two different ways in which we can use reverse annealing. We can run
    several repetitions of the annealing process on the same initial state with the
    `reinitialize_state``=``True` option when calling `sample`. Alternatively, we
    can use the final (measured) state of one execution as the initial state of the
    next one by setting `reinitialize_state``=``False`.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用两种不同的方式来使用反向退火。我们可以在调用`sample`时使用`reinitialize_state``=``True`选项，在相同的初始状态下运行多次退火过程。或者，我们可以通过设置`reinitialize_state``=``False`，将一次执行的最终（测量）状态作为下一次的初始状态。
- en: 'Let’s now look at an example in which we will apply reverse annealing to a
    simple problem. The following code, in which we use the `triangle` problem defined
    previously, is almost self-explanatory:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在看看一个例子，我们将在这个例子中应用反向退火到一个简单的问题上。以下代码，其中我们使用了之前定义的`triangle`问题，几乎是自解释的：
- en: '[PRE43]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'A possible output of these instructions could be the following:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令的可能输出可能是以下内容：
- en: '[PRE44]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: To learn more…
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多...
- en: Some researchers have found that reverse annealing can be more effective than
    forward annealing for some problems. For a very illuminating example, please check
    the paper by Carugno et al. [[23](ch030.xhtml#Xcarugno2022evaluating)].
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 一些研究人员发现，对于某些问题，反向退火可能比正向退火更有效。对于一个非常启发性的例子，请参阅Carugno等人撰写的论文[[23](ch030.xhtml#Xcarugno2022evaluating)]。
- en: Now, we know how to control both the annealing time and the schedule. In the
    next subsection, we will explain why it is important to set the coupling strengths
    and the penalty terms wisely, something that is easily overlooked, but that can
    greatly affect the results of our executions.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们知道如何控制退火时间和时间表。在下一小节中，我们将解释为什么明智地设置耦合强度和惩罚项很重要，这是容易被忽视的，但可能会极大地影响我们执行的结果。
- en: 4.4.4 The importance of coupling strengths
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.4.4 耦合强度的重要性
- en: You surely remember that there are a couple of situations in which we have to
    select values for some arbitrary constants that are used to set coupling strengths
    in the annealer. The first situation is having to introduce constraints as penalty
    terms in the objective function, using the `lagrange_multiplier` parameter in
    the `cqm_to_bqm` method of the `dimod` package. The second one is having to select
    the coupling strengths for the chains in a particular embedding, which is usually
    handled automatically by classes such as `EmbeddingComposite`.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 您肯定记得，在两种情况下，我们必须为一些任意常数选择值，这些常数用于设置退火器的耦合强度。第一种情况是在目标函数中引入约束作为惩罚项，使用`dimod`包中的`cqm_to_bqm`方法的`lagrange_multiplier`参数。第二种情况是在特定嵌入中为链选择耦合强度，这通常由`EmbeddingComposite`等类自动处理。
- en: It would be very natural to think that you would want these constants to be
    as big as possible. After all, you are not interested in solutions that do not
    satisfy the problem constraints and you do not want your chains to be broken.
    However, there is an important detail that makes choosing the values of these
    constants a little bit trickier than expected.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 很自然地，您会认为您希望这些常数尽可能大。毕竟，您对不满足问题约束的解不感兴趣，您也不希望您的链断裂。然而，有一个重要的细节使得选择这些常数的值比预期的要复杂一些。
- en: It turns out that the range of values that you use for qubit couplings in D-Wave’s
    annealers is not arbitrarily large. For example, the following instructions allow
    us to check what the possible values are for the case of the `Advantage_system4`
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，您在D-Wave退火器中使用的量子比特耦合值的范围并不是任意大的。例如，以下指令允许我们检查`Advantage_system4`案例的可能值。
- en: '`.1` device — and, of course, if you change the solver name, you can get the
    values for any other annealers as well:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`.1` 设备——当然，如果您更改求解器名称，您也可以获取任何其他退火器的值：'
- en: '[PRE45]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The output that you will get if you run these instructions is the following:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这些指令后，您将得到以下输出：
- en: '[PRE46]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This means that, if you set coupling strengths (that is, ![J](img/file617.png
    "J") coefficients) that in absolute value are bigger than ![4](img/file143.png
    "4"), the largest one will be scaled down to ![4](img/file143.png "4")…and the
    rest of the coefficients in your model will be scaled down accordingly. This can
    cause some of the values to be very close together, even closer than the resolution
    of the device, affecting the results of the annealing process. Let’s illustrate
    it with an example.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，如果您设置耦合强度（即![J](img/file617.png "J")系数），其绝对值大于![4](img/file143.png "4")，最大的一个将被缩放到![4](img/file143.png
    "4")……并且您模型中的其余系数也将相应缩放。这可能导致一些值非常接近，甚至比设备的分辨率还要接近，从而影响退火过程的结果。让我们用一个例子来说明。
- en: The following code defines a constrained problem, converts it into an unconstrained
    model using the penalty constant ![M = 10](img/file618.png "M = 10"), and then
    runs it on `Advantage_system4`
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码定义了一个约束问题，将其转换为使用惩罚常数![M = 10](img/file618.png "M = 10")的无约束模型，并在`Advantage_system4`上运行它
- en: '`.1` taking 100 samples. Then, it converts the samples back to the variables
    of the original problem, aggregates the results, as we did in *Section* *[*4.3.3*](#x1-810004.3.3),
    and shows the frequency of each obtained solution:*'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`.1` 采集100个样本。然后，它将样本转换回原始问题的变量，汇总结果，就像我们在*第4.3.3节*中做的那样，并显示每个获得的解决方案的频率：*'
- en: '*[PRE47]'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE47]'
- en: 'When we ran this code, we obtained the following output:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这段代码时，我们得到了以下输出：
- en: '[PRE48]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: So, in 21 out of 100 samples, we have obtained the optimal solution, and, in
    43 more cases, we obtained solutions with the second lowest energy. Not too bad…but
    not very good either. The not-so-obvious problem behind this result is that the
    penalty constant (the `lagrange_multiplier` parameter) is too big compared to
    the range of energies of the objective function. In fact, if you use `ExactSolver`
    on the transformed problem, you can easily check that all the assignments that
    are unfeasible on the original problem get energy ![16](img/file619.png "16")
    or higher on the transformed one, while the feasible solutions always get energy
    ![3](img/file472.png "3") or lower. That is a huge gap!
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在 100 个样本中有 21 个我们得到了最优解，在 43 个更多的情况下，我们得到了第二低能量的解。还不错……但也不算很好。这个结果背后的不那么明显的问题是惩罚常数（`lagrange_multiplier`
    参数）与目标函数能量范围相比太大。实际上，如果你在转换问题中使用 `ExactSolver`，你可以很容易地检查出在原始问题中不可行的所有分配在转换问题中的能量至少为
    ![16](img/file619.png "16") 或更高，而可行解总是得到 ![3](img/file472.png "3") 或更低的能量。这是一个巨大的差距！
- en: 'But notice what happened when we ran the same code after reducing the penalty
    constant to ![4](img/file143.png "4"). In that case, we obtained the following
    result:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 但请注意，当我们把惩罚常数降低到 ![4](img/file143.png "4") 后再次运行相同的代码时发生了什么。在这种情况下，我们得到了以下结果：
- en: '[PRE49]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: As you can see, the frequency of the optimal solution has increased to ![30](img/file620.png
    "30") and the two solutions with the second lowest energy appear, more or less,
    the same number of times as in the experiment with `lagrange_multiplier`
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，最优解的频率已增加到 ![30](img/file620.png "30")，并且具有第二低能量的两个解，或多或少，与 `lagrange_multiplier`
    实验中的次数相同。
- en: '`=10`. In this case (check it by using `ExactSolver`), the unfeasible solutions
    all have energy that is at least ![4](img/file143.png "4") in the transformed
    problem, so all the feasible solutions have lower energy. Notice, though, that
    the gap is now much smaller and we only recovered ![98](img/file621.png "98")
    feasible solutions from the ![100](img/file389.png "100") samples.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`=10`. 在这种情况下（通过使用 `ExactSolver` 检查），所有不可行解在转换问题中的能量至少为 ![4](img/file143.png
    "4")，因此所有可行解的能量都更低。但请注意，现在差距要小得多，我们只从 ![100](img/file389.png "100") 个样本中恢复了 ![98](img/file621.png
    "98") 个可行解。'
- en: We even tried a more extreme experiment, setting `lagrange_multiplier`
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至尝试了一个更极端的实验，设置了 `lagrange_multiplier`
- en: '`=1`. When we ran it, we obtained the following output:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '`=1`. 当我们运行它时，我们得到了以下输出：'
- en: '[PRE50]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The frequency of the optimal solution has dramatically improved, up to ![76](img/file622.png
    "76") out of ![100](img/file389.png "100") samples. However, we also ”lost” 6
    samples because they corresponded to unfeasible solutions. In this case, there
    are some unfeasible solutions with energy as low as ![- 2](img/file333.png "-
    2") in the transformed problem. This is still bigger than the optimal energy,
    which is ![- 5](img/file591.png "- 5"), but the low energy of these unfeasible
    solutions can fool the annealer into selecting them at times, as we have seen.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 优解的频率显著提高，高达 ![76](img/file622.png "76") 个样本中的 ![100](img/file389.png "100")。然而，我们也“丢失”了
    6 个样本，因为它们对应于不可行解。在这种情况下，在转换问题中存在一些能量低至 ![- 2](img/file333.png "- 2") 的不可行解。这仍然比最优能量
    ![- 5](img/file591.png "- 5") 要大，但这些不可行解的低能量有时会欺骗退火器选择它们，正如我们所看到的。
- en: Setting a good penalty constant can be difficult, because it involves having
    some information about the energy distribution of the solutions to the problem.
    But let the examples here serve as a warning that you should not just use any
    value for `lagrange_multiplier`, because setting it too high can affect the quality
    of your solutions. In case of doubt, try some different options and keep the one
    that offers the best results.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 设置一个好的惩罚常数可能很困难，因为它涉及到对问题解的能量分布有一些信息。但让这里的例子作为一个警告，你不应该为 `lagrange_multiplier`
    使用任何值，因为设置得太高可能会影响你解的质量。如果有疑问，尝试一些不同的选项，并保留提供最佳结果的那个。
- en: To learn more…
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多……
- en: Something similar may happen when the value of the coupling strength for chains
    in an embedding is too big. Fortunately, the methods used by `EmbeddingComposite`
    and its relatives take this into account and will try to keep the value as low
    as possible without risking breaking many chains. But should you need, for some
    reason, to create your own embedding, do not take the choice of the coupling strength
    lightly.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 当嵌入链的耦合强度值过大时，可能会发生类似的情况。幸运的是，`EmbeddingComposite`及其相关方法已经考虑了这一点，并将尝试将值保持在尽可能低，同时避免破坏许多链。但如果你出于某种原因需要创建自己的嵌入，不要轻率地选择耦合强度。
- en: You now know how to adjust the most important parameters that govern quantum
    annealing and, more importantly, you understand the implications of such adjustments.
    But it turns out that D-Wave offers other ways of solving optimization problems
    beyond ”pure” quantum annealing. Let us study them in the following subsection.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经知道了如何调整控制量子退火的最重要参数，更重要的是，你理解了这些调整的含义。但结果证明，D-Wave提供了除“纯”量子退火之外解决优化问题的其他方法。让我们在下面的子节中研究它们。
- en: 4.4.5 Classical and hybrid samplers
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.4.5 经典和混合采样器
- en: We have already seen that `dimod` provides a **classical** solver called `ExactSolver`.
    And it’s not alone! In Ocean, we can also find solvers such as, for example, `SimulatedAnnealing`
    or `SteepestDescentSolver` that do not rely on any quantum resources whatsoever.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，`dimod`提供了一个名为`ExactSolver`的经典求解器。而且它并不孤单！在Ocean中，我们还可以找到像`SimulatedAnnealing`或`SteepestDescentSolver`这样的求解器，它们根本不依赖于任何量子资源。
- en: The purpose of including these classical solvers in a quantum optimization library
    is two-fold. On the one hand, it allows you to try and use different methods to
    solve your problems. On the other hand, they can be used in combination with quantum
    annealers in what D-Wave calls **hybrid solvers**. Let’s briefly study these two
    aspects.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在量子优化库中包含这些经典求解器的目的是双重的。一方面，它允许你尝试使用不同的方法来解决你的问题。另一方面，它们可以与量子退火器结合使用，D-Wave称之为**混合求解器**。让我们简要研究这两个方面。
- en: Classical solvers
  id: totrans-271
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 经典求解器
- en: Using classical solvers with Ocean couldn’t be simpler. As long as you have
    a QUBO or Ising problem, you can use the `sample` method of any classical solver
    to get (approximate) solutions to it, exactly like you would do with a quantum
    annealer. In fact, you can also use the `num_reads` parameter to specify the number
    of samples that you want.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Ocean中的经典求解器非常简单。只要你有QUBO或Ising问题，你就可以使用任何经典求解器的`sample`方法来获取（近似）解决方案，就像你使用量子退火器一样。实际上，你还可以使用`num_reads`参数来指定你想要的样本数量。
- en: We will devote the rest of this subsection to describing the classical solvers
    included in Ocean at the time of writing.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这个子节中剩余的部分描述Ocean在撰写时的经典求解器。
- en: '`SteepestDescentSolver` This is included in the `greedy` package and it is
    a discrete version of the gradient descent algorithm for continuous optimization
    (more on that in *Chapter* [*8*](ch017.xhtml#x1-1390008), *What is Quantum Machine
    Learning?*). At each step, it selects one direction (that is, one variable flip)
    in which the decrease in energy is bigger. We can use it as shown in the following
    piece of code, where we first define a simple Ising problem and then we sample
    from it:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '`SteepestDescentSolver` 这包括在`greedy`包中，它是连续优化中梯度下降算法的离散版本（更多关于这一点在*第8章*[*8*](ch017.xhtml#x1-1390008)，*什么是量子机器学习？*）。在每一步中，它选择一个方向（即一个变量翻转），在这个方向上能量的减少更大。我们可以像以下代码片段所示那样使用它，我们首先定义一个简单的Ising问题，然后从中采样：'
- en: '[PRE51]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The output of running these instructions will be similar to the following:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这些指令的输出将类似于以下内容：
- en: '[PRE52]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: As you can see, this is exactly the format the we already know and love from
    using quantum solvers.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，这正是我们从使用量子求解器中已经熟知并喜爱的格式。
- en: To learn more…
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多...
- en: In addition to the `num_reads` parameter, you can also set `initial_states`
    to specify the solutions from which the descent is going to start. If you don’t
    use this parameter, then the initial states will be selected at random. In that
    case, you can use the `seed` argument should you want your results to be reproducible.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`num_reads`参数之外，你还可以设置`initial_states`来指定下降将开始的解决方案。如果你不使用此参数，则初始状态将随机选择。在这种情况下，如果你希望结果可重复，可以使用`seed`参数。
- en: '`TabuSolver` This solver is included in the `tabu` package. It is an example
    of a **local** **search** algorithm. That is, it tries to improve a solution by
    exploring its neighbors — the solutions that can be obtained by flipping one variable,
    for instance. In this, the method is somewhat similar to the greedy descent algorithm
    implemented in `SteepestDescentSolver`, but it tries to avoid falling into local
    minima by sometimes accepting solutions with higher energy than the current one,
    and it also ”remembers” solutions it has already visited in order not to explore
    them again — that is where the name *tabu* comes from.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`TabuSolver` 这个求解器包含在 `tabu` 包中。它是一个 **局部** **搜索** 算法的例子。也就是说，它试图通过探索其邻居（例如，通过翻转一个变量可以获得的解决方案）来改进一个解决方案。在这方面，这种方法与
    `SteepestDescentSolver` 中实现的贪婪下降算法有些相似，但它试图通过有时接受比当前解决方案能量更高的解决方案来避免陷入局部最小值，并且它还会“记住”已经访问过的解决方案，以便不再探索它们——这就是“禁忌”这个名字的由来。'
- en: 'Ocean implements the multistart tabu algorithm described in [[72](ch030.xhtml#Xpalubeckis2004multistart)].
    It can be used with the following instructions:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: Ocean 实现了在 [[72](ch030.xhtml#Xpalubeckis2004multistart)] 中描述的多起点禁忌算法。它可以按照以下说明使用：
- en: '[PRE53]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The tabu algorithm also accepts `initial_states` and `seed` parameters.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 禁忌算法也接受 `initial_states` 和 `seed` 参数。
- en: '`SimulatedAnnealingSampler` This is included in the `neal` package and it implements
    the heuristic algorithm known as **simulated annealing** [[59](ch030.xhtml#Xkirkpatrick1983optimization)].
    It is another local search algorithm that explores the neighbourhood of the candidate
    solution that it is considering at a given moment. With that, it tries to move
    to solutions with lower energy. However, like tabu search, it can move to solutions
    with higher energy with some probability. This probability is bounded by a global
    ”temperature” parameter that decreases with time, eventually reaching ![0](img/file12.png
    "0"), inspired by the way in which metals become less malleable when they cool
    down during annealing — hence the name of the method. In fact, quantum annealing
    is seen by some people as a quantum version of simulated annealing. The analogy
    they make is that the intensity of the initial Hamiltonian ![H_{0}](img/file545.png
    "H_{0}") can be understood as analogous to the temperature in simulated annealing:
    it allows the solutions to move or ”tunnel” to some neighboring ones and it decreases
    over time. Simulated annealing can be used in Ocean as follows:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '`SimulatedAnnealingSampler` 这是在 `neal` 包中包含的，它实现了被称为 **模拟退火** 的启发式算法 [[59](ch030.xhtml#Xkirkpatrick1983optimization)]。它是一种探索在给定时刻考虑的候选解决方案的邻域的局部搜索算法。通过这种方式，它试图移动到能量更低的解决方案。然而，像禁忌搜索一样，它以一定的概率移动到能量更高的解决方案。这个概率由一个随时间减少的全球“温度”参数所限制，最终达到
    ![0](img/file12.png "0")，这受到了金属在退火过程中冷却时变得不那么可塑的方式的启发——因此，该方法得名。实际上，有些人将量子退火视为模拟退火的一种量子版本。他们所做的类比是，初始哈密顿量
    ![H_{0}](img/file545.png "H_{0}") 的强度可以理解为与模拟退火中的温度类似：它允许解决方案移动或“隧道”到某些邻近的解决方案，并且随着时间的推移而减少。模拟退火可以在
    Ocean 中按以下方式使用：'
- en: '[PRE54]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: As you surely guessed, the `initial_states` and `seed` parameters are also supported.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所猜，`initial_states` 和 `seed` 参数也受到支持。
- en: These samplers are all classical algorithms that do not use quantum resources.
    However, they can be combined with quantum annealers, as we show in the next subsection.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这些采样器都是不使用量子资源的经典算法。然而，它们可以与量子退火器结合，正如我们在下一小节中所示。
- en: Hybrid solvers
  id: totrans-289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 混合求解器
- en: In addition to quantum annealers and classical solvers, Ocean also provides
    the programmer with hybrid solvers that try to combine the best of both worlds.
    You may remember that, back in *Section* *[*4.4.1*](#x1-830004.4.1), these hybrid
    solvers were listed among the devices available through your Leap account. Finally,
    the time to learn how to use them has come!*
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 除了量子退火器和经典求解器之外，Ocean 还为程序员提供了混合求解器，这些求解器试图结合两者的优点。你可能记得，在 *第 * *4.4.1* *节*
    *[*4.4.1*](#x1-830004.4.1)* 中，这些混合求解器被列为通过你的 Leap 账户可用的设备之一。最后，学习如何使用它们的时候终于到了！
- en: '*Let’s start with `LeapHybridSampler`. This sampler accepts QUBO and Ising
    problems and can scale up to a high number of variables because, internally, it
    divides the problem, assigns different parts to classical solvers and quantum
    annealers, and then reconstructs a global solution from the local ones. Its use
    is very similar to that of the samplers that we have studied so far. For instance,
    you can run the following instructions, with `problem` as defined in the previous
    subsection — or just any other QUBO or Ising problem:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '*让我们从 `LeapHybridSampler` 开始。这个采样器接受 QUBO 和 Ising 问题，并且可以扩展到大量的变量，因为，在内部，它将问题分割，将不同的部分分配给经典求解器和量子退火器，然后从局部解中重建全局解。它的使用方式与我们迄今为止研究的采样器非常相似。例如，你可以运行以下指令，其中
    `problem` 如前一小节定义——或者任何其他 QUBO 或 Ising 问题：'
- en: '[PRE55]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'One interesting property of `LeapHybridSampler` and the rest of the hybrid
    samplers is what is called the **quota conversion rate**. It can be checked through
    the following property:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '`LeapHybridSampler` 和其他混合采样器的一个有趣特性被称为**配额转换率**。可以通过以下特性进行检查：'
- en: '[PRE56]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: In the case of `LeapHybridSampler`, it is 20\. This means that for each 20 microseconds
    that you use this hybrid sampler, you will get charged just 1 microsecond of quantum
    processor access because the quantum annealers are not used for the whole computation.
    Neat, right?
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `LeapHybridSampler` 的情况下，它是 20。这意味着对于你使用的每个 20 微秒的混合采样器，你将只需支付 1 微秒的量子处理器访问费用，因为量子退火器并没有在整个计算中使用。很酷，对吧？
- en: Ocean also provides `LeapHybridCQMSampler`, which is used similarly to `LeapHybridSampler`,
    but with constrained problems like the ones we defined in *Section* *[*4.3.3*](#x1-810004.3.3).
    Finally, there is also `LeapHybridDQMSampler`, which works with discrete quadratic
    problems defined as objects of the `DiscreteQuadraticModel` class.*
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: Ocean 还提供了 `LeapHybridCQMSampler`，其使用方式与 `LeapHybridSampler` 类似，但用于有约束的问题，如我们在
    *第* *4.3.3节* *中定义的。最后，还有 `LeapHybridDQMSampler`，它与定义为 `DiscreteQuadraticModel`
    类对象的离散二次问题一起工作。
- en: '*To learn more…'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '*要了解更多…'
- en: We have not worked with the `DiscreteQuadraticModel` class, but it is very similar
    to `BinaryQuadraticModel`. The main difference is that it accepts variables that
    take a finite amount of different values instead of just ![0](img/file12.png "0")
    and ![1](img/file13.png "1"). The problems defined through this class can be converted
    to binary quadratic problems by **one-hot encoding**; that is, each discrete variable
    is represented by a vector of ![n](img/file244.png "n") binary variables, where
    ![n](img/file244.png "n") is the total number of values that the original discrete
    variable can take. The restriction is that only one of those variables can take
    the value ![1](img/file13.png "1") at a given time. So, if binary variable number
    ![3](img/file472.png "3") is ![1](img/file13.png "1"), this means that the original
    variable takes the value ![3](img/file472.png "3").
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 我们尚未使用 `DiscreteQuadraticModel` 类，但它与 `BinaryQuadraticModel` 非常相似。主要区别在于它接受有限数量的不同值而不是仅仅
    ![0](img/file12.png "0") 和 ![1](img/file13.png "1") 的变量。通过此类定义的问题可以通过**独热编码**转换为二值二次问题；也就是说，每个离散变量由一个
    ![n](img/file244.png "n") 个二进制变量的向量表示，其中 ![n](img/file244.png "n") 是原始离散变量可以取的总值数。限制是，在给定时间只有一个这些变量可以取
    ![1](img/file13.png "1") 的值。所以，如果二进制变量编号 ![3](img/file472.png "3") 是 ![1](img/file13.png
    "1")，这意味着原始变量取值为 ![3](img/file472.png "3")。
- en: This ends our study of quantum annealing and its use in combinatorial optimization.
    But this kind of problem can also be solved with algorithms designed for quantum
    computers based on the quantum circuit model. That will be the topic of our next
    chapter.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 这标志着我们对量子退火及其在组合优化中的应用的研究结束。但这类问题也可以通过基于量子电路模型的量子计算机设计的算法来解决。这将是下一章的主题。
- en: Summary
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you have learned about the adiabatic quantum computing model,
    which is equivalent to the quantum circuit model that we had already studied.
    Instead of discrete quantum gates, adiabatic quantum computing uses continuous
    evolution through a time-dependent Hamiltonian. You have learned how to select
    this Hamiltonian to encode combinatorial optimization problems and how, if the
    evolution is slow enough, the adiabatic theorem guarantees that we will measure
    the ground state at the end of the process.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了绝热量子计算模型，该模型与我们之前已经研究过的量子电路模型等价。绝热量子计算使用的是通过时间依赖的哈密顿量的连续演化，而不是离散量子门。你学习了如何选择这个哈密顿量来编码组合优化问题，以及如果演化足够慢，绝热定理将保证我们在过程的最后测量到基态。
- en: You have also learned that, in practice, quantum annealing is used instead of
    adiabatic quantum computing, because adiabatic evolution can take too long for
    the process to be feasible. What is more, you now know how to use actual quantum
    annealers through D-Wave Leap to find approximate solutions to combinatorial optimization
    problems in several different ways.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 你还了解到，在实践中，量子退火被用来代替绝热量子计算，因为绝热演化可能需要太长时间，使得整个过程变得不可行。更重要的是，你现在知道如何通过D-Wave
    Leap使用实际的量子退火器以多种不同的方式找到组合优化问题的近似解。
- en: You also know how to control several parameters of the annealing process, in
    order to improve the quality of the solutions that you can find with quantum annealers.
    Finally, you have also learned how to use hybrid solvers that divide big problems
    into smaller pieces and combine classical and quantum techniques to find a global
    solution to the original problem.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 你还知道如何控制退火过程的几个参数，以提高你使用量子退火器可以找到的解决方案的质量。最后，你还学习了如何使用混合求解器，将大问题分解成更小的部分，并结合经典和量子技术来找到原始问题的全局解。
- en: We will now turn to using quantum computers based on the quantum circuit model.
    But we will not forget about optimization problems and Hamiltonians. In fact,
    as you will soon see, the topic of our next chapter will be how to discretize
    quantum annealing so that it can be implemented with quantum gates.******************
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将转向使用基于量子电路模型的量子计算机。但我们不会忘记优化问题和哈密顿量。实际上，正如你很快就会看到的，我们下一章的主题将是如何将量子退火离散化，以便可以使用量子门来实现。******************
