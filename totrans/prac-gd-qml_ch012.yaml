- en: Chapter 4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Adiabatic Quantum Computing and Quantum Annealing
  prefs: []
  type: TYPE_NORMAL
- en: '*Love’s a different sort of thing, hot enough to make you flow into* *something,
    interflow, cool and anneal and be a weld stronger than* *what you started with.*'
  prefs: []
  type: TYPE_NORMAL
- en: — Theodore Sturgeon
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, we studied how to formulate different combinatorial
    optimization problems as QUBO instances that, in turn, could be rewritten as the
    optimization problem of finding a state with minimum energy in an Ising model
    system. In this chapter, we will use this fact to introduce a way of using **quantum
    annealers** — a special type of quantum computer — to try to find (approximate)
    solutions to those combinatorial optimization problems.
  prefs: []
  type: TYPE_NORMAL
- en: But, in order to do that, we first need to talk a little bit more about Hamiltonians
    and their ground states, as well as the central role they play in adiabatic quantum
    computing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics that we will cover in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Adiabatic quantum computing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quantum annealing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Ocean to formulate and transform optimization problems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Solving optimization problems on quantum annealers with Leap
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here we go!
  prefs: []
  type: TYPE_NORMAL
- en: 4.1 Adiabatic quantum computing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *Chapter* *[*1*](ch008.xhtml#x1-180001), *Foundations of Quantum Computing*,
    we focused mainly on quantum circuits but we briefly mentioned that there were
    other equivalent quantum computing models. One of them is adiabatic quantum computing,
    introduced in 2000 by Farhi, Goldstone, Gutmann, and Sipser in a widely influential
    paper [[36](ch030.xhtml#Xfarhi2000quantum)].*
  prefs: []
  type: TYPE_NORMAL
- en: '*When using quantum circuits, we apply operations (our beloved quantum gates)
    through discrete, sequential steps. However, adiabatic quantum computing relies
    on the use of continuous transformations. Namely, we will use a Hamiltonian ![H(t)](img/file541.png
    "H(t)") that will vary with time and that will be the driving force to change
    the state of our qubits according to the time-dependent Schrödinger equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![H(t)\left| {\psi(t)} \right\rangle = i\hslash\frac{\partial}{\partial t}\left|
    {\psi(t)} \right\rangle.](img/file542.png "H(t)\left| {\psi(t)} \right\rangle
    = i\hslash\frac{\partial}{\partial t}\left| {\psi(t)} \right\rangle.")'
  prefs: []
  type: TYPE_IMG
- en: To learn more…
  prefs: []
  type: TYPE_NORMAL
- en: As you may remember, in *Chapter* *[*1*](ch008.xhtml#x1-180001), *Foundations
    of Quantum* *Computing*, we talked about the **time-independent** Schrödinger
    equation. In that case, the Hamiltonian — which you can think of as a mathematical
    object that can describe the energy of the system — remained unchanged throughout
    the process. Now, we’ll consider situations in which this energy can vary with
    time. This is the case, for instance, if you are applying an electromagnetic pulse
    to your qubits and you change its intensity or its frequency.*
  prefs: []
  type: TYPE_NORMAL
- en: '*The terms in this equation are the time-dependent Hamiltonian ![H(t)](img/file541.png
    "H(t)"), the state vector of the system ![\left| {\psi(t)} \right\rangle](img/file47.png
    "\left| {\psi(t)} \right\rangle"), the imaginary unit ![i](img/file49.png "i")
    (defined by ![i^{2} = - 1](img/file543.png "i^{2} = - 1")), and the reduced Planck’s
    constant ![\hslash](img/file50.png "\hslash").*  *In addition to using time-dependent
    Hamiltonians, there is another ingredient that we need for our new quantum computing
    model: the idea of **adiabatic** **evolution**. Roughly speaking, an adiabatic
    process is one in which the ”energy configuration” of the system changes ”very
    gently” (there are quite a few quotation marks here, aren’t there?). But…what
    does this have to do with quantum computing and how does it help us in finding
    solutions to our problems?'
  prefs: []
  type: TYPE_NORMAL
- en: 'The key observation is that we will be considering problems whose optimal solutions
    will correspond to minimum-energy or ground states of some Hamiltonian of an Ising
    model. So, if we start with our system in the ground state (for some Hamiltonian)
    and we evolve it adiabatically, we know that it will remain in a ground state
    through the whole process. We won’t be adding enough energy for the system to
    ”jump” to the next energy level: this is, in more ”physical” terms, to go from
    the ground state to an **excited state**. And we can use that to our advantage,
    because if we engineer the procedure so that the final Hamiltonian of the system
    is the one whose ground state will yield the solution to our problem, then we
    only need to measure the system to get the solution we are looking for.'
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: To put it in a nutshell, the idea behind adiabatic quantum computing is to start
    with a simple Hamiltonian, one for which we can easily obtain — and prepare! —
    the ground state, and evolve it ”carefully.” We do this so that we remain in the
    ground state all the time, slowly changing our system until the ground state of
    its Hamiltonian is the solution to our problem. And then, bang, we perform a measurement
    and get our result!
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, the crucial thing here is how to perform the evolution to ensure
    that it is, indeed, adiabatic. But don’t worry, the **adiabatic theorem** has
    got our backs there. This result, originally proved by Max Born and Vladimir Fock
    [[18](ch030.xhtml#Xborn1928beweis)], two of the fathers of quantum mechanics,
    says that for your process to be adiabatic, it should be slow enough. You may
    ask: how slow? Well, the total time should be inversely proportional to the square
    of the **spectral** **gap**, which is the minimum difference in energy between
    the ground state and the first excited state of the Hamiltonian during the whole
    evolution.'
  prefs: []
  type: TYPE_NORMAL
- en: This makes perfect intuitive sense. If there is always a big difference in energy
    between the ground state and the first excited state, then you can speed things
    up a little bit — you won’t risk jumping to the next energy level. However, if
    the difference is small, you’d better be careful, lest you accidentally go up
    a step (or several!) on the energy ladder.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a clear understanding of the ideas behind adiabatic quantum
    computing, let’s make things a little bit more formal. Suppose that you have a
    problem for which ![H_{1}](img/file544.png "H_{1}") is the Hamiltonian whose ground
    state encodes the result that you want to find. For instance, ![H_{1}](img/file544.png
    "H_{1}") could be an Ising Hamiltonian that you obtained from transforming a QUBO
    problem. Now, imagine that your system is in the ground state of some initial
    Hamiltonian ![H_{0}](img/file545.png "H_{0}"). We will soon discuss how to choose
    ![H_{0}](img/file545.png "H_{0}"), but for now just think that you can prepare
    its ground state easily enough so that it is a natural choice for you.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose that we run the process for total time ![T](img/file74.png "T"). The
    time-dependent Hamiltonian that we will consider will be of the form
  prefs: []
  type: TYPE_NORMAL
- en: '![H(t) = A(t)H_{0} + B(t)H_{1},](img/file546.png "H(t) = A(t)H_{0} + B(t)H_{1},")'
  prefs: []
  type: TYPE_IMG
- en: where ![A](img/file183.png "A") and ![B](img/file184.png "B") are real-valued
    functions that accept inputs over the interval ![\lbrack 0,T\rbrack](img/file547.png
    "\lbrack 0,T\rbrack") such that ![A(0) = B(T) = 1](img/file548.png "A(0) = B(T)
    = 1") and ![A(T) = B(0) = 0](img/file549.png "A(T) = B(0) = 0"). Notice that it
    holds that ![H(0) = H_{0}](img/file550.png "H(0) = H_{0}") and ![H(T) = H_{1}](img/file551.png
    "H(T) = H_{1}"), exactly as we desired. A common choice for the functions ![A](img/file183.png
    "A") and ![B](img/file184.png "B") is to set ![\left. A(t) = 1 - t\slash T \right.](img/file552.png
    "\left. A(t) = 1 - t\slash T \right.") and ![\left. B(t) = t\slash T \right.](img/file553.png
    "\left. B(t) = t\slash T \right."). Nonetheless, as we will see later in this
    chapter, sometimes we also use other options, under the requirement that they
    satisfy the aforementioned boundary conditions.
  prefs: []
  type: TYPE_NORMAL
- en: Adiabatic quantum computing is polynomially equivalent to other quantum computing
    models, as proved by Aharonov et al. [[4](ch030.xhtml#Xaharonov2007adiabatic)],
    including the quantum circuit model. This means that anything that is efficiently
    computable in one of these models is also efficiently computable in adiabatic
    quantum computing, and vice versa. Consequently, you can choose to use any of
    these models depending on the particulars of your problem or, as we will see in
    the next section, on the kind of quantum computer that you have access to.
  prefs: []
  type: TYPE_NORMAL
- en: 4.2 Quantum annealing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although we have just seen that adiabatic quantum computing is, theoretically,
    a perfectly viable alternative to the quantum circuit model, in its practical
    incarnation it is usually implemented in a restricted version called **quantum**
    **annealing**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Quantum annealing relies on the same core idea as adiabatic quantum computing:
    it takes an initial Hamiltonian ![H_{0}](img/file545.png "H_{0}"), a final Hamiltonian
    ![H_{1}](img/file544.png "H_{1}") whose ground state encodes the solution to the
    problem of interest, and it gradually changes the acting Hamiltonian from the
    initial to the final one by using some functions ![A](img/file183.png "A") and
    ![B](img/file184.png "B") (as described in the previous section) to decrease the
    action of ![H_{0}](img/file545.png "H_{0}") and to increase the action of ![H_{1}](img/file544.png
    "H_{1}"). However, quantum annealing deviates from full adiabatic quantum computing
    in two ways. First of all, in practical implementations of quantum annealing,
    the final Hamiltonian ![H_{1}](img/file544.png "H_{1}") that can be realized cannot
    be chosen completely at will, but has to be selected from a certain, restricted
    class. A typical option is an Ising Hamiltonian of the form'
  prefs: []
  type: TYPE_NORMAL
- en: '![- \sum\limits_{j,k}J_{jk}Z_{j}Z_{k} - \sum\limits_{j}h_{j}Z_{j},](img/file554.png
    "- \sum\limits_{j,k}J_{jk}Z_{j}Z_{k} - \sum\limits_{j}h_{j}Z_{j},")'
  prefs: []
  type: TYPE_IMG
- en: which is the quantum version of the one we introduced in *Section* *[*3.1.3*](ch011.xhtml#x1-630003.1.3).
    In this case, the user has the freedom of selecting the ![J_{jk}](img/file342.png
    "J_{jk}") and ![h_{j}](img/file343.png "h_{j}") coefficients within certain ranges.
    Due to this restriction in the choice of the final Hamiltonian, quantum annealing,
    unlike adiabatic quantum computing, is not universal and can only be used to solve
    a specific (but still very important!) type of problem. On the bright side, physical
    quantum devices based on quantum annealing are simpler to construct, making it
    possible to scale the size of these **quantum annealers** up to hundreds or even
    thousands of qubits.*
  prefs: []
  type: TYPE_NORMAL
- en: '*The initial Hamiltonian in the quantum annealing setup is also usually fixed
    to be ![H_{0} = - {\sum}_{j = 0}^{n - 1}X_{j}](img/file555.png "H_{0} = - {\sum}_{j
    = 0}^{n - 1}X_{j}"), where ![n](img/file244.png "n") is the number of qubits,
    and ![X_{j}](img/file556.png "X_{j}") stands for the tensor product in which the
    ![X](img/file9.png "X") matrix is acting on qubit ![j](img/file258.png "j") with
    the rest of positions occupied by ![I](img/file53.png "I"), the identity matrix.
    The ground state of ![H_{0}](img/file545.png "H_{0}") is easily seen to be ![{\otimes}_{i
    = 0}^{n - 1}\left| + \right\rangle](img/file557.png "{\otimes}_{i = 0}^{n - 1}\left|
    + \right\rangle") , the tensor product of ![n](img/file244.png "n") copies of
    the plus state, which is relatively easy to prepare because it is completely unentangled.'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 4.1
  prefs: []
  type: TYPE_NORMAL
- en: Prove that ![\left| \psi_{0} \right\rangle = {\otimes}_{i = 0}^{n - 1}\left|
    + \right\rangle](img/file558.png "\left| \psi_{0} \right\rangle = {\otimes}_{i
    = 0}^{n - 1}\left| + \right\rangle") has the minimum possible energy for ![H_{0}
    = - {\sum}_{j = 0}^{n - 1}X_{j}](img/file555.png "H_{0} = - {\sum}_{j = 0}^{n
    - 1}X_{j}") by first showing that, for each ![j](img/file258.png "j") and each
    state ![\left| \psi \right\rangle](img/file43.png "\left| \psi \right\rangle"),
    it holds that ![\left\langle \psi \right|X_{j}\left| \psi \right\rangle \leq 1](img/file559.png
    "\left\langle \psi \right|X_{j}\left| \psi \right\rangle \leq 1") and then showing
    that ![\left\langle \psi_{0} \right|X_{j}\left| \psi_{0} \right\rangle = 1](img/file560.png
    "\left\langle \psi_{0} \right|X_{j}\left| \psi_{0} \right\rangle = 1") for each
    ![j](img/file258.png "j").
  prefs: []
  type: TYPE_NORMAL
- en: Thus, the Hamiltonian used in quantum annealing is given by
  prefs: []
  type: TYPE_NORMAL
- en: '![H(t) = - A(t)\sum\limits_{j = 0}^{n - 1}X_{j} - B(t)\sum\limits_{j,k}J_{jk}Z_{j}Z_{k}
    - B(t)\sum\limits_{j}h_{j}Z_{j},](img/file561.png "H(t) = - A(t)\sum\limits_{j
    = 0}^{n - 1}X_{j} - B(t)\sum\limits_{j,k}J_{jk}Z_{j}Z_{k} - B(t)\sum\limits_{j}h_{j}Z_{j},")'
  prefs: []
  type: TYPE_IMG
- en: where ![J_{jk}](img/file342.png "J_{jk}") and ![h_{j}](img/file343.png "h_{j}")
    are some adjustable coefficients, and ![A](img/file183.png "A") and ![B](img/file184.png
    "B") are functions such that ![A(0) = B(T) = 1](img/file548.png "A(0) = B(T) =
    1") and ![A(T) = B(0) = 0](img/file549.png "A(T) = B(0) = 0"), with ![T](img/file74.png
    "T") being the total **annealing time**. In this context, ![A](img/file183.png
    "A") and ![B](img/file184.png "B") are called the **annealing schedule**.
  prefs: []
  type: TYPE_NORMAL
- en: The other important deviation from the adiabatic quantum computing model is
    that, in quantum annealing, evolution is no longer guaranteed to be adiabatic.
    There are two main reasons for this decision. As you surely remember, the spectral
    gap is the minimum of the difference between the ground state and the first excited
    state of ![H(t)](img/file541.png "H(t)") for ![t \in \lbrack 0,T\rbrack](img/file562.png
    "t \in \lbrack 0,T\rbrack"). Computing this spectral gap can be very difficult.
    Actually, it can be even harder than finding the ground state that we are looking
    for, as proved by Cubitt et al. [[27](ch030.xhtml#Xcubitt2015undecidability)].
    The second reason is that, even if we are able to compute the time that we need
    for the process to be adiabatic, it can be so big that it wouldn’t be practical
    — or even possible! — to run the system evolution for so long.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, in quantum annealing, we run the evolution for a certain amount of time
    that need not satisfy the conditions for adiabaticity, and hope to still be able
    to find good approximations of the optimal solution to our problem. In fact, we
    don’t strictly need to remain in the ground state of ![H(t)](img/file541.png "H(t)").
    Since, at the end, we are going to measure the state, it would be enough if the
    amplitude of an optimal or sufficiently good solution in our final state were
    big enough. That’s because, then, the probability of obtaining a useful result
    will still be high. And, of course, we can always repeat the process several times
    and keep the best of all measurements!
  prefs: []
  type: TYPE_NORMAL
- en: In 2011, the Canadian company D-Wave was the first to ever commercialize a quantum
    device that implemented quantum annealing as we have just described it. That quantum
    annealer, called D-Wave One, had ![128](img/file563.png "128") qubits, while one
    of D-Wave’s most recent quantum devices, the Advantage, has more than ![5000](img/file564.png
    "5000") qubits, and it’s available for you to use online!
  prefs: []
  type: TYPE_NORMAL
- en: We need to keep in mind that, with these quantum computers, the evolution process
    will not be adiabatic in general, so there is no guarantee that the exact solution
    will be found in all cases. But, all over the world, many research teams and prominent
    companies — from sectors as diverse as finance, logistics, and aircraft manufacturing
    — are actively exploring the practical applications of quantum annealers. We will
    devote the rest of this chapter to showing you how you can also try them for your
    own optimization problems.
  prefs: []
  type: TYPE_NORMAL
- en: Using D-Wave’s quantum annealers is much easier than you may think. First of
    all, you need to follow the instructions in *Appendix* *[*D*](ch027.xhtml#x1-240000D),
    *Installing the Tools*, to install Ocean, which is D-Wave’s quantum annealing
    Python library, and to create a free account on D-Wave Leap, a cloud service where
    you can get one minute per month of free computing time on D-Wave’s quantum annealers.
    This may not seem like much, but you will see that it is enough to run quite a
    number of experiments.*
  prefs: []
  type: TYPE_NORMAL
- en: '*To learn more…'
  prefs: []
  type: TYPE_NORMAL
- en: If one minute per month proves not to be enough for your annealing necessities,
    both D-Wave Leap and Amazon Braket offer paid access to quantum annealers. Obviously,
    the pricing of these services varies from time to time, so please check their
    websites to check the current rates and conditions.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have everything set up, you can access quantum annealers to find an
    approximation of a solution to any combinatorial optimization problem that you
    may have written as either an instance of finding the ground state of an Ising
    model or as a QUBO problem. For instance, let’s try to solve the MaxCut problem
    for the graph in *Figure* *[*3.5*](ch011.xhtml#Figure3.5). As you surely remember,
    we can pose it as finding the ground state of*
  prefs: []
  type: TYPE_NORMAL
- en: '*![Z_{0}Z_{1} + Z_{0}Z_{2},](img/file565.png "Z_{0}Z_{1} + Z_{0}Z_{2},")'
  prefs: []
  type: TYPE_NORMAL
- en: which is, of course, an Ising Hamiltonian in which ![J_{01} = J_{02} = 1](img/file566.png
    "J_{01} = J_{02} = 1") and the rest of the coefficients are ![0](img/file12.png
    "0").
  prefs: []
  type: TYPE_NORMAL
- en: 'All we need to tell the quantum annealer is that those are the coefficients
    we want to use, and then we can perform the annealing multiple times to obtain
    some results that will hopefully solve our problem. To specify the problem, we
    can use the `dimod` package, included in the Ocean library, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a couple of things to notice here. First, we have used `J` for the
    coefficients of the degree ![2](img/file302.png "2") terms — `(0,1):1` sets the
    ![J_{01}](img/file567.png "J_{01}") coefficient to 1 and `(0,2):1` sets ![J_{02}
    = 1](img/file568.png "J_{02} = 1") — and `h` for the linear ones. Those coefficients
    that we do not specify are automatically set to ![0](img/file12.png "0") by the
    `BinaryQuadraticModel` constructor, but we still need to pass both the `J` and
    the `h` parameters (even in our case, where the latter is empty). Notice that
    in the output we get `(1,` `0):` `1.0,` `(2,` `0):` `1.0`, which seems to be the
    reverse of what we used. But they are exactly the same, because ![Z_{0}Z_{1} =
    Z_{1}Z_{0}](img/file569.png "Z_{0}Z_{1} = Z_{1}Z_{0}") and, thus, the situation
    is symmetrical. Second, we have used `0.0` as the value for the **offset**, which
    is a constant term that can be added to the Hamiltonian. Finally, we have used
    the `dimod``.``SPIN` parameter because we are working with an Ising Hamiltonian
    and, thus, the values of our variables are ![1](img/file13.png "1") and ![- 1](img/file312.png
    "- 1"). In just a minute, we will see how to use binary variables instead. But,
    before that, let’s use the following code to run the annealing process on one
    of the quantum annealers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'What we are doing here is, first, importing `DWaveSampler`, which will give
    us access to the quantum annealers, and then `EmbeddingComposite`, which will
    allow us to **map** or **embed** our problem into the actual qubits of the annealer
    — don’t worry, we will explain this in detail later. For now, you can think of
    this as an automatic way of selecting a few qubits in the computer that will be
    used to represent our variables. After that, we create an object `sampler` that
    we then use to obtain ![10](img/file161.png "10") samples or possible solutions
    to our problem. This is where the actual execution on the actual quantum annealer
    happens. After that, we just print the result, which will vary from execution
    to execution. This is because we are using an actual quantum computer, which is,
    as you know, essentially probabilistic. In our case, we obtained the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that we obtained two different solutions: ![z_{0} = 1](img/file570.png
    "z_{0} = 1"), ![z_{1} = - 1](img/file571.png "z_{1} = - 1"), and ![z_{2} = - 1](img/file572.png
    "z_{2} = - 1"), and ![z_{0} = - 1](img/file573.png "z_{0} = - 1"), ![z_{1} = 1](img/file574.png
    "z_{1} = 1"), and ![z_{2} = 1](img/file575.png "z_{2} = 1"), both with energy
    ![- 2](img/file333.png "- 2"); the first one was measured in ![6](img/file576.png
    "6") of the executions and the second in the remaining ![4](img/file143.png "4")
    — we will explain what the `chain_`'
  prefs: []
  type: TYPE_NORMAL
- en: '`.` data means later in the chapter. But meanwhile, we can rejoice. These two
    solutions are, indeed, maximum cuts in our graph, as you can easily check!'
  prefs: []
  type: TYPE_NORMAL
- en: We can get some additional information from the `result` variable. In fact,
    we can access the best solution through `result``.``first` and the total time
    that we used the quantum annealer for, with `result``.``info``[``’``timing``’``][``’``qpu_access_time``’``]`.
    This is the amount that will be subtracted from your monthly 60 seconds…or that
    you will be charged for if you have a paying plan. In our case, the time that
    we used the annealer for was ![15\, 832.16](img/file577.png "15\, 832.16"), which
    may look like a huge number if you don’t realize that it is actually measured
    in microseconds. So for the 10 samples we used about ![0.016](img/file578.png
    "0.016") seconds. That minute of access doesn’t seem so short anymore, right?
  prefs: []
  type: TYPE_NORMAL
- en: We can also use `dimod` to work with QUBO problems. We will need to specify
    the coefficients of the degree ![2](img/file302.png "2") terms, the linear coefficients
    — remember that, in QUBO, we are using binary variables, so expressions like ![x_{3}^{2}](img/file579.png
    "x_{3}^{2}") can be simplified to ![x_{3}](img/file580.png "x_{3}") — and the
    independent coefficient, exactly as in the Ising case. The only change is that
    we will use the `dimod``.``BINARY` parameter when creating our problem with the
    `BinaryQuadraticModel` constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 4.2
  prefs: []
  type: TYPE_NORMAL
- en: Create an instance of a simple QUBO problem and solve it with an annealer. Notice
    that the values for the variables in the solution will be ![0](img/file12.png
    "0") and ![1](img/file13.png "1") instead of ![1](img/file13.png "1") and ![-
    1](img/file312.png "- 1").
  prefs: []
  type: TYPE_NORMAL
- en: This is just the simplest kind of execution that we can run on a quantum annealer,
    in which we have used all the default parameters. But the Ocean software implements
    many other functionalities that allow us, for instance, to work more comfortably
    with optimization problems and to control the settings of our experiments more
    precisely, including the annealing time and other important values. The rest of
    this chapter will guide you through the most important features and options to
    help you get the most of your time with annealers, starting with how to use Ocean
    to work with optimization problems.
  prefs: []
  type: TYPE_NORMAL
- en: 4.3 Using Ocean to formulate and transform optimization problems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have just seen, the `BinaryQuadraticModel` class can be used to define
    both Ising and QUBO problems. But `dimod` also offers other models and utilities
    that will make our lives a little bit easier. Let’s start by studying how we can
    conveniently define problems with linear restrictions.
  prefs: []
  type: TYPE_NORMAL
- en: 4.3.1 Constrained quadratic models in Ocean
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You surely remember that a problem like
  prefs: []
  type: TYPE_NORMAL
- en: '![\begin{array}{rlrl} {\text{Minimize}\quad} & {- 5x_{0} + 3x_{1} - 2x_{2}\qquad}
    & & \qquad \\ {\text{subject~to}\quad} & {x_{0} + x_{2} \leq 1,\qquad} & & \qquad
    \\ & {3x_{0} - x_{1} + 3x_{2} \leq 4\qquad} & & \qquad \\ & {x_{j} \in \{ 0,1\},\qquad
    j = 0,1,2\qquad} & & \qquad \\ & \qquad & & \\ \end{array}](img/file581.png "\begin{array}{rlrl}
    {\text{Minimize}\quad} & {- 5x_{0} + 3x_{1} - 2x_{2}\qquad} & & \qquad \\ {\text{subject~to}\quad}
    & {x_{0} + x_{2} \leq 1,\qquad} & & \qquad \\  & {3x_{0} - x_{1} + 3x_{2} \leq
    4\qquad} & & \qquad \\  & {x_{j} \in \{ 0,1\},\qquad j = 0,1,2\qquad} & & \qquad
    \\  & \qquad & & \\ \end{array}")'
  prefs: []
  type: TYPE_IMG
- en: is an instance of binary linear programming. In *Section* *[*3.4.1*](ch011.xhtml#x1-690003.4.1),
    we studied this family of problems in detail and we showed that they can be transformed
    into the QUBO and Ising models by using slack variables and penalty terms.*
  prefs: []
  type: TYPE_NORMAL
- en: '*So, imagine that you want to solve the preceding problem in a quantum annealer.
    Do you need to perform all those boring transformations in order to obtain the
    QUBO coefficients and then use them to define a `BinaryQuadraticModel` object?
    No! Fortunately, `dimod` provides the `ConstrainedQuadraticModel` class, which
    simplifies the process of working with problems that involve linear constraints.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to instantiate our binary linear program as a `ConstrainedQuadraticModel`
    object, the first thing that we need to do is to define the variables that we
    want to use and their types. In our case, we have three binary variables that
    we can define with the following piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: With these instructions, we have simply created three binary variables and we
    have labeled them so that we can use them in mathematical expressions and easily
    identify them when we print them.
  prefs: []
  type: TYPE_NORMAL
- en: To learn more…
  prefs: []
  type: TYPE_NORMAL
- en: If you have used symbolic mathematics libraries (for instance, SymPy), you will
    recognize that the principles at work here are very similar.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we are going to define a `ConstrainedQuadraticModel` object and we are
    going to set the **objective** (the function that we seek to minimize) and also
    fix the constraints of the problem. For that, we will use the variables that we
    have just created. This can be achieved with the following instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Setting the objective or adding constraints automatically adds all the variables
    involved to the problem object. Notice also that we have provided labels to identify
    the constraints. If you prefer not to do it, then `dimod` will randomly assign
    an alphanumeric string to each constraint and it will be used as its name, should
    you need it. If, later on, you want to rename any of them, you can use the `relabel_constraints`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can inspect the elements of `blp` by accessing its `variables`, `objective`,
    and `constraints` attributes. Thus, we can execute these instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'And we will obtain something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Notice that both the objective and the constraints are internally represented
    as quadratic functions and, therefore, they formally have quadratic terms, linear
    terms, and an offset or independent term. In our case, only the linear part of
    the constraints is non-empty, and the offset is ![0](img/file12.png "0") in both
    cases.
  prefs: []
  type: TYPE_NORMAL
- en: To learn more…
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from the output, the constraints that we have created are instances
    of the `dimod``.``sym``.``Le` class, where `Le` stands for *less* *than or equal
    to*. You can also create equality constraints, which will belong to the `dimod``.``sym``.``Eq`
    class or inequality constraints with ![\geq](img/file582.png "\geq"), which will
    be `dimod``.``sym``.` `Ge` objects. Of course, an equality constraint is equivalent
    to one `Le` constraint plus one `Ge` constraint with the same left- and right-hand
    sides. And we can transform `Le` constraints into `Ge` constraints — and the other
    way around — by multiplying everything by ![- 1](img/file312.png "- 1").
  prefs: []
  type: TYPE_NORMAL
- en: Now, we know how to construct problems with constraints using `dimod`. In the
    next subsection, we will learn how to use the problems that we have defined to
    compute the cost of different value assignments, check if those assignments satisfy
    the constraints, and to also find the optimal solution to the problem.
  prefs: []
  type: TYPE_NORMAL
- en: 4.3.2 Solving constrained quadratic models with dimod
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `dimod` package provides many tools to work with the constrained quadratic
    problems that we have just introduced. For instance, we can define an assignment
    of values to the variables, check if it is feasible, and compute its cost for
    the problem defined in the previous subsection by using the following instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We are using the assignment ![x_{0} = x_{1} = x_{2} = 1](img/file583.png "x_{0}
    = x_{1} = x_{2} = 1"), so when we execute the code we obtain the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This tells us that the assignment is not feasible, and the `violations` method
    gives us the amount by which the left-hand side of each inequality is bigger than
    the right-hand side.
  prefs: []
  type: TYPE_NORMAL
- en: 'If, on the other hand, we want to try the ![x_{0} = x_{1} = 0,x_{2} = 1](img/file584.png
    "x_{0} = x_{1} = 0,x_{2} = 1") assignment, we can use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The result that we obtain is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the assignment is feasible and, therefore, no violation term is
    positive.
  prefs: []
  type: TYPE_NORMAL
- en: The `dimod` package also provides a brute-force solver that tries all possible
    assignments and sorts them according to their cost, from lowest to highest. Using
    it with our example is as simple as running
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: to obtain
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The first number is just an identifier of the assignment. It is followed by
    the values given to the variables. Then, we find the cost of the assignment —
    or, rather, its energy, if interpreted in terms of the Hamiltonian. After that,
    comes the times this solution has been found, which will always be ![1](img/file13.png
    "1") with this solver. Finally, we find information about which constraints are
    satisfied and whether the solution is feasible or not. It is very important to
    notice that the assignments are ordered by cost, but some of them may be unfeasible,
    even the first one, as in this case.
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, if we execute `solution``.``first`, we will obtain this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'where we can see that this assignment does not satisfy either of the two constraints
    of our problem. If you want the optimal solution to the problem, you should always
    remove the unfeasible solutions first with the `filter` method, using an instruction
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Then, if you access `feasible_sols``.``first`, you will get
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: which is, indeed, the optimal solution to our binary linear program.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, all these computations are done with a (very inefficient) classical
    algorithm. In the next subsection, we explain how to use actual quantum annealers
    to try to solve the problems that we have defined.
  prefs: []
  type: TYPE_NORMAL
- en: 4.3.3 Running constrained problems on quantum annealers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As useful as the `ConstrainedQuadraticModel` class is, we cannot use it to define
    problems that can be run on quantum annealers. In order to do that, we first need
    to eliminate the constraints and create a `BinaryQuadraticModel` object that we
    can later execute on actual quantum hardware as we did in *Section* *[*4.2*](#x1-770004.2).
    Fortunately, the process is really simple thanks to the utilities provided in
    the Ocean library. Let’s see how this works with an example.*
  prefs: []
  type: TYPE_NORMAL
- en: '*To illustrate the general procedure, let’s define a simple constrained problem
    with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We can transform this constrained problem into an unconstrained one by using
    the `cqm_to_bqm` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In a moment, we will explain what `invert` is and how it is used, but for now
    let’s focus on the output of those instructions, which will be something similar
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: That is quite a mouthful, but we promise that it is not nearly as complicated
    as it seems. In fact, with what you already know from *Chapter* *[*3*](ch011.xhtml#x1-590003),
    *QUBO:* *Quadratic Unconstrained Binary Optimization*, you could have computed
    a similar output yourself! Let’s unpack it.*
  prefs: []
  type: TYPE_NORMAL
- en: '*Since this is an unconstrained problem, what we are seeing is the specification
    of the cost function. First, we have the linear part, which starts with `’``y0``’:`'
  prefs: []
  type: TYPE_NORMAL
- en: '`-17.0`. It tells us that, in the objective function, ![y_{0}](img/file445.png
    "y_{0}") has coefficient ![- 17](img/file585.png "- 17"), ![y_{1}](img/file460.png
    "y_{1}") has coefficient ![- 23](img/file586.png "- 23"), and the two other variables
    have coefficient ![- 15](img/file587.png "- 15"). Then comes the quadratic part,
    with coefficient ![20](img/file588.png "20") for the ![y_{0}y_{1}](img/file589.png
    "y_{0}y_{1}") term, something that we deduce from the `(’``y1``’,` `’``y0``’):`
    `20.0` value, and with coefficients ![10](img/file161.png "10") and ![20](img/file588.png
    "20") for the other products of two variables. Finally, ![20](img/file588.png
    "20") is the independent term or offset, and we are also told that all the variables
    are binary.'
  prefs: []
  type: TYPE_NORMAL
- en: But, where do all these coefficients come from? What our good friend `dimod`
    is doing here is nothing but applying the transformations that we studied in *Section*
    *[*3.4.1*](ch011.xhtml#x1-690003.4.1). First, two slack variables — with quite
    ugly random names — are introduced to transform the inequality constraint into
    an equality one. Then, the equality constraint is incorporated into the cost function
    as a penalty term with a penalty coefficient (the `lagrange_multiplier` parameter),
    which equals ![5](img/file296.png "5"). And that’s all! It wasn’t that mysterious
    after all, was it?*
  prefs: []
  type: TYPE_NORMAL
- en: '*Exercise 4.3'
  prefs: []
  type: TYPE_NORMAL
- en: Check that the QUBO problem returned by `cqm_to_bqm` coincides with what you
    would obtain should you apply the transformations explained in *Section* *[*3.4.1*](ch011.xhtml#x1-690003.4.1).
    Don’t forget the offset!*
  prefs: []
  type: TYPE_NORMAL
- en: '*We can now use a quantum annealer to solve the problem defined in the `qubo`
    object just as we did in *Section* *[*4.2*](#x1-770004.2). For instance, we can
    run the following code:*'
  prefs: []
  type: TYPE_NORMAL
- en: '*[PRE20]'
  prefs: []
  type: TYPE_NORMAL
- en: 'Do not forget to import `EmbeddingComposite` and `DWaveSampler` if you haven’t
    done it yet. If you run these instructions, you will obtain an output similar
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We can all agree that this is not very informative. The problem here is that
    we are looking at solutions to the transformed problem, which include the slack
    variables with all those long, cryptic names. Of course, we don’t really care
    about the slack variable values — we only introduced them in order to write our
    problem without any constraints. So, what can we do? Here’s where the `invert`
    object comes to our rescue! It allows us to retrieve the solutions to the original
    problem from the solutions to the transformed one. Thus, we can run the following
    instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'and obtain the following output, which now only shows the original variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have created a new `SampleSet` object — the type of structure in which
    `dimod` stores the results of solvers or samplers — from the samples obtained
    with the transformed problem. Notice that we use `invert` to eliminate the slack
    variables and that, by passing the `cqm` problem to the `from_samples_cqm` method,
    the energy without the penalties is computed, as well as the feasibility status
    of each assignment. In fact, notice that when printing the solutions that we sampled
    for the transformed problem, we obtained a solution with ![0](img/file12.png "0")
    energy. It corresponds to the assignment ![y_{0} = 1](img/file450.png "y_{0} =
    1") and ![y_{1} = 1](img/file590.png "y_{1} = 1"), which, on the original problem,
    had energy ![- 5](img/file591.png "- 5"). The difference in the two energies comes
    from the fact that this assignment is unfeasible, and in the unconstrained problem
    it receives a penalty for it. Notice that we have also used the number of occurrences
    to keep track of how many times each solution is sampled.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in this way, we have recovered some solutions to the original problem,
    but there are a couple of details that we still need to fix. The first one is
    that if we want to only retain the feasible solutions, we need to use the `filter`
    method as we did in the previous subsection when using `ExactCMQSolver`. The second
    has to do with the repetition — which we can observe in the last two outputs —
    of the solution that sets ![y_{0} = 1](img/file450.png "y_{0} = 1") and ![y_{0}
    = 0](img/file455.png "y_{0} = 0"). These two solutions come from two different
    assignments in the transformed problem, but they only differed in the values given
    to the slack variables. So, when those slack variables are eliminated, they produce
    exactly the same assignment. If we want them to be considered together, as they
    should be, we can use the `aggregate` method. Putting it all together, we can
    execute this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This will print
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: which is something that we can indeed use to solve our problem.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have learned how to work with constrained problems and how
    to solve them both by brute force and with quantum annealers, transforming them
    into something that the quantum computer can use and then getting back to the
    original formulation. In the next section, we will study how to have more control
    over what the quantum annealer is doing in order to find the ground state of our
    Hamiltonians. Let’s fiddle a little bit with the inner workings of those shiny
    quantum computers!
  prefs: []
  type: TYPE_NORMAL
- en: 4.4 Solving optimization problems on quantum annealers with Leap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have run a couple of different optimization problems on actual quantum
    annealers. However, we have always used the default parameters and we do not even
    know the characteristics of the quantum computers that we are using. In this section,
    we shall remedy that. We will explain the different types of annealers that we
    can access through D-Wave Leap. We will also explore several hyperparameters that
    we can tweak when we are using these devices, and we will explain how to adjust
    the way in which our problems are embedded in the physical qubits — we will finally
    learn what that mysterious `EmbeddingComposite` object is used for!
  prefs: []
  type: TYPE_NORMAL
- en: 4.4.1 The Leap annealers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can list the devices to which you have access with your Leap account by
    using the `get_solvers` method in this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The results will depend on your actual access privileges, but for a typical
    free account you will see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In this case, there are seven different solvers in total, of three different
    types. First, we have those with the word *hybrid* in their identifier. We will
    talk about them later in the chapter, but, for now, it suffices to know that they
    combine classical and quantum resources to solve problems. The other four, called
    `DW_2000Q_6`, `Advantage_system4``.1`, `Advantage_system6``.1`, and `Advantage2_prototype1``.1`,
    are pure quantum annealers. These are the devices that are selected when we use
    `DWaveSampler` to solve a problem, as we have been doing so far in this chapter.
    Let’s explore their properties in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: We can select a particular annealer by using the `solver` parameter in the `DWaveSampler`
    constructor and then access the properties of the device with the `properties`
    attribute. For instance, for the `DW_2000Q_6` annealer, we can run the following
    instructions
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'to obtain this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: If we do the same but with the `Advantage_system4`
  prefs: []
  type: TYPE_NORMAL
- en: '`.1` solver, we obtain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The properties of the `Advantage_system6`
  prefs: []
  type: TYPE_NORMAL
- en: '`.1` solver will be exactly the same — except for the name, of course.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, for the `Advantage2_prototype1`
  prefs: []
  type: TYPE_NORMAL
- en: '`.1` solver, we obtain the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: To learn more…
  prefs: []
  type: TYPE_NORMAL
- en: 'The solvers have many other properties that we haven’t yet discussed; we will
    study some of the most relevant ones in *Sections* *[*4.4.2*](#x1-840004.4.2),
    [*4.4.3*](#x1-850004.4.3), and [*4.4.4*](#x1-860004.4.4). You can nonetheless
    access all of them through the `properties` dictionary, printing it directly.
    But be careful: some of them can be huge to print, such as `properties``[``"``qubits``"`
    `]`, which contains information about all the potentially thousands of qubits
    in a device!*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Some properties are the same for the four devices. For instance, as we can
    see, all are of type **qpu**, which means that they are **quantum processing units**
    or quantum annealers. Also, all of them accept problems in the QUBO or Ising formats
    — but not constrained problems; that is why we had to transform them before running
    them in the previous section — and all can be used to obtain between ![1](img/file13.png
    "1") and ![10\, 000](img/file592.png "10\, 000") samples at a time. The main difference,
    other than the number of qubits — which is notably bigger in the `Advantage_system4``.1`
    and `Advantage_system6``.1` devices — is the **topology**. This refers to the
    way in which the qubits are connected to each other in the machine, and determines
    which **couplings** — or connections between variables — can be used to define
    our problems…unless we use an embedding, which will help us in mapping our coefficients
    to actual qubit connections.'
  prefs: []
  type: TYPE_NORMAL
- en: The `Advantage2_prototype1`
  prefs: []
  type: TYPE_NORMAL
- en: '`.1` solver is a little bit special. As can be inferred from the name, it is
    a prototype of a new family of annealers that D-Wave will introduce in 2023-2024
    — that’s why, for now, it has fewer qubits than the rest of the devices, but the
    full version has been announced to have more than ![7000](img/file593.png "7000")
    qubits. It uses a new topology, called Zephyr, which is designed to increase connectivity
    and decrease errors. At the time of writing, the available device is not a final
    version. For this reason, we will not use it in the examples that we will be working
    with, nor will we describe its properties and topology in detail. Notice, however,
    that everything that we explain about how to work with the devices translates,
    with no changes, to this new annealer.'
  prefs: []
  type: TYPE_NORMAL
- en: We have summarized some of the annealer properties in *Table* *[*4.1*](#x1-83047r1).*
  prefs: []
  type: TYPE_NORMAL
- en: '*| Annealer name | Number of qubits | Topology |'
  prefs: []
  type: TYPE_NORMAL
- en: '| `DW``_2000Q`_6 | 2048 | Chimera |'
  prefs: []
  type: TYPE_TB
- en: '| `Advantage``_system4.1` | 5760 | Pegasus |'
  prefs: []
  type: TYPE_TB
- en: '| `Advantage``_system6.1` | 5760 | Pegasus |'
  prefs: []
  type: TYPE_TB
- en: '| `Advantage2``_prototype1.1` | 576 | Zephyr |'
  prefs: []
  type: TYPE_TB
- en: '**Table 4.1**: Summary of annealer properties'
  prefs: []
  type: TYPE_NORMAL
- en: In the next subsection, we shall explore in more detail the annealers’ topologies
    and how we can embed our problems in them.
  prefs: []
  type: TYPE_NORMAL
- en: 4.4.2 Embeddings and annealer topologies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In current quantum computers, be they annealers or gate-based devices, technological
    difficulties prevent qubits from being connected in an all-to-all way. In fact,
    each qubit is usually connected exclusively to some of its neighbours and we can
    only apply two-qubit gates or use couplings (that is, use non-zero coefficients
    in the Ising model) between those qubits that are actually linked. The particular
    way in which the qubits are connected in a certain quantum chip is called its
    **topology** and sometimes it is important to be aware of it when we design our
    algorithms or when we anneal our problems.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, the topology of the `DW_2000Q_6` annealer is called, as we saw
    in the previous subsection, Chimera. It consists of cells of 8 qubits organized
    into two groups of 4 qubits each. All the qubits in one group are connected to
    all the qubits in the other group, but there are no connections inside each group.
    For graph connoisseurs, the connections follow a complete bipartite graph ![K_{4,4}](img/file594.png
    "K_{4,4}"), which is depicted in *Figure* * [*4.1*](#Figure4.1).*
  prefs: []
  type: TYPE_NORMAL
- en: '*![Figure 4.1: Qubit connections in a Chimera cell](img/file595.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Figure 4.1**: Qubit connections in a Chimera cell'
  prefs: []
  type: TYPE_NORMAL
- en: The `DW_2000Q_6` computer has ![256](img/file596.png "256") of these cells,
    organized in a ![16 \times 16](img/file597.png "16 \times 16") grid, making for
    a total of ![8 \cdot 16 \cdot 16 = 2048](img/file598.png "8 \cdot 16 \cdot 16
    = 2048") qubits, as expected. Each of the qubits that occupy the positions ![0](img/file12.png
    "0") to ![3](img/file472.png "3") in a cell is also connected to the qubits in
    the same position of the vertically adjacent cells. In a similar way, each qubit
    in positions ![4](img/file143.png "4") to ![7](img/file465.png "7") is also connected
    to the qubit in the same position of the horizontally adjacent cells. In total,
    each qubit will be connected to four other qubits in the same cell and to two
    other qubits (or one, if it lives in a border cell) from other cells.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can obtain a list enumerating all the connections by using the `properties``[``"``couplers``"``]`
    attribute as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this, we will get a very long list that begins like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'A slightly more readable way of obtaining the same information is by using
    `sampler``.``adjacency`, which will we give us a dictionary indexed by qubit numbers
    and values that specify the qubits that are connected to the qubit in the key.
    In our case, it starts like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Exercise 4.4
  prefs: []
  type: TYPE_NORMAL
- en: Pick the qubits numbered from ![0](img/file12.png "0") to ![7](img/file465.png
    "7") and check that their connections correspond to the description of the Chimera
    topology that we have made in the text. Notice that they all lie in the top-left
    corner cell, so they will be connected to one cell on the right and one cell below.
  prefs: []
  type: TYPE_NORMAL
- en: To learn more…
  prefs: []
  type: TYPE_NORMAL
- en: The `Advantage_system4``.1` and `Advantage_system6` `.1` annealers use a topology
    called **Pegasus**. It also groups qubits into cells, but their structure is more
    involved than that of the Chimera cells. Every qubit is connected to up to ![15](img/file599.png
    "15") qubits, compared to the maximum of ![6](img/file576.png "6") in `DW_2000Q_6`.
  prefs: []
  type: TYPE_NORMAL
- en: This topology also contains groups of 4 qubits that are all connected to each
    other, making it much easier to embed problems into it, as we will see later in
    the *Section* *[*4.4.2*](#x1-840004.4.2).*
  prefs: []
  type: TYPE_NORMAL
- en: '*Describing the Pegasus topology in detail would get us too far out from our
    path, but you can find all the information in *Section 2.3* of the *QPU-Specific
    Physical Properties* document for the `Advantage_system4``.1` and `Advantage_system6`
    `.1` annealers. You can download it, together with the corresponding documents
    for the rest of the D-Wave quantum computers, at [https://docs.dwavesys.com/docs/latest/doc_physical_properties.html](https://docs.dwavesys.com/docs/latest/doc_physical_properties.html).*
    *One important thing to note about the Chimera topology is that it does not contain
    triangles. That is, there are no three vertices all connected to each other. Thus,
    if our Ising Hamiltonian is something like ![Z_{0}Z_{1} + Z_{0}Z_{2} + Z_{1}Z_{2}](img/file600.png
    "Z_{0}Z_{1} + Z_{0}Z_{2} + Z_{1}Z_{2}"), we cannot directly map it to qubits in
    the `DW_2000Q_6` annealer. What can we do then? Is it impossible to solve such
    a problem with this computer? Don’t worry, embeddings are here to save the day!'
  prefs: []
  type: TYPE_NORMAL
- en: An **embedding** is, essentially, a way of mapping the qubits in our problem
    Hamiltonian to the physical qubits in the annealer. The trick here is that this
    mapping need not be one to one. In fact, we can use several physical qubits (what
    we call a **chain**) to represent a single qubit from our problem. In that case,
    though, we want all the qubits in the same chain to have the same value when we
    measure them. To guarantee that, we need to use coupling strengths that are negative
    and big in absolute value.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, if qubits ![12](img/file601.png "12") and ![20](img/file588.png
    "20") are part of the same chain, the coefficient for ![(12,20)](img/file602.png
    "(12,20)") could be, for instance, ![- 15](img/file587.png "- 15"). Then, the
    term ![- 15Z_{12}Z_{20}](img/file603.png "- 15Z_{12}Z_{20}") will be part of the
    spin Hamiltonian that we want to minimize and it will make it very likely for
    ![Z_{12}](img/file604.png "Z_{12}") and ![Z_{20}](img/file605.png "Z_{20}") to
    be equal to each other, because that will make the total energy significantly
    lower.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, the embedding needs to define the physical qubits (chains) used
    to represent each problem qubit, ensure that they can be connected correctly,
    and compute some appropriate coupling strengths for the chains. This may seem
    very complicated, but Ocean can compute embeddings automatically for us. Let’s
    see, with an example, how to do it for a simple case. We could use the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'In these instructions, we first define a problem that requires three qubits
    to be connected together, something that we know is not directly possible with
    the annealer that we have selected. But, since we are using `EmbeddingComposite`,
    a way of embedding our graph in the actual annealer topology is automatically
    found for us, and we can run the annealing process and obtain some samples. By
    setting the `return_embedding` parameter to `True`, we also recover the embedding
    information. Let’s see what the output of running this code may look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, `EmbeddingComposite` performs the embedding in a way that is
    completely transparent for the user and, in fact, the samples returned only refer
    to the variables in the original problem. However, underneath the hood, variable
    ![0](img/file12.png "0") has been mapped to qubit ![1011](img/file606.png "1011"),
    variable ![2](img/file302.png "2") has been mapped to qubit ![1012](img/file607.png
    "1012"), and variable ![1](img/file13.png "1") is represented by the chain formed
    by qubits ![1008](img/file608.png "1008") and ![1015](img/file609.png "1015").
    The coupling strength for these two qubits was almost ![2](img/file302.png "2"),
    which is bigger than the coefficients of the original problem in order to prevent
    the qubits in the chain from having different values. If, for whatever reason,
    these two qubits in the chain happen to receive different values, the chain is
    said to be **broken** and the method specified in `’``chain_break_method``’` would
    be used to assign a value to variable ![1](img/file13.png "1"). In this case,
    that value would be a simple majority vote between the qubits in the chain.
  prefs: []
  type: TYPE_NORMAL
- en: To learn more…
  prefs: []
  type: TYPE_NORMAL
- en: Finding a suitable embedding is an ![NP](img/file2.png "NP")-hard problem. However,
    the `minorminer` package included with Ocean provides heuristics for finding embeddings
    that usually work well in practice. These are used by `EmbeddingComposite`.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to `EmbeddingComposite`, there are other classes in Ocean that allow
    you to find embeddings for your problems. For instance, `AutoEmbeddingComposite`
    first tries to run the problem on the annealer directly, not using an embedding,
    and only looks for one if it is needed; this can save some computing time in some
    cases. The `FixedEmbeddingComposite` class doesn’t compute an embedding, but uses
    whichever one is passed as a parameter; in this case, the embedding should be
    a Python dictionary with the format shown in the previous output. We also can
    use `LazyFixedEmbeddingComposite`, which only computes the embedding for a problem
    on the first call to the `sample` method, storing it for future calls; `EmbeddingComposite`,
    on the other hand, recomputes the embedding with each call to `sample`.
  prefs: []
  type: TYPE_NORMAL
- en: So, that should cover most of your needs for embedding problems into any annealer
    topology. But we’re not done yet! There are still some additional parameters that
    we can control when running problems with Ocean on actual quantum devices. We
    will study some of the most important ones in the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: 4.4.3 Controlling annealing parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You surely remember from the beginning of this chapter that for an evolution
    to be adiabatic (and, hence, for the system to remain in a state of minimal energy),
    it needs to be slow enough. However, this condition is difficult to meet in practice,
    so we just resort to running the evolution for a short period of time, resulting
    in what we call quantum annealing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The question is: to what extent can we control the annealing process with D-Wave’s
    quantum annealers? It turns out that there are quite a number of things that we
    can do in order to try to improve the results for our combinatorial optimization
    problems. The first (and most obvious) is changing the duration of the annealing
    process.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can easily check the range of annealing times that a device supports, as
    well as its default annealing time, using instructions like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The output, in this case, will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Exercise 4.5
  prefs: []
  type: TYPE_NORMAL
- en: Check the default annealing time and the annealing time range for the `DW_2000Q_6`
    annealer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modifying the annealing time for a problem couldn’t be easier. For instance,
    imagine that we want to increase it to ![100](img/file389.png "100") microseconds
    and sample from the triangle problem that we defined in the previous subsection.
    Then, the only modification that we would need to apply is adding the `annealing_time`
    parameter when calling the `sample` method. We could run, for instance, the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to try to obtain better and better solutions, you may be tempted to
    increase the annealing time to its maximum possible value. However, be warned
    that this may have two unwanted consequences. On the one hand, the longer you
    run the annealing process, the higher the possibility that external interactions
    will affect the system state and ruin your computation: you might get worse results
    instead of better ones! On the other hand, by increasing the annealing time, you
    will obviously spend more time using the quantum processing unit…and you will
    be charged accordingly!'
  prefs: []
  type: TYPE_NORMAL
- en: With Ocean, the options to control the annealing process are not reduced to
    just modifying the annealing time. You can also tailor, to some extent, the annealing
    schedule itself. As we already know, this refers to the ![A](img/file183.png "A")
    and ![B](img/file184.png "B") functions in the expression
  prefs: []
  type: TYPE_NORMAL
- en: '![H(t) = - A(t)\sum\limits_{j = 0}^{n - 1}X_{j} - B(t)\sum\limits_{j,k}J_{jk}Z_{j}Z_{k}
    - B(t)\sum\limits_{j}h_{j}Z_{j},](img/file561.png "H(t) = - A(t)\sum\limits_{j
    = 0}^{n - 1}X_{j} - B(t)\sum\limits_{j,k}J_{jk}Z_{j}Z_{k} - B(t)\sum\limits_{j}h_{j}Z_{j},")'
  prefs: []
  type: TYPE_IMG
- en: which defines the Hamiltonian that we use in the annealing process.
  prefs: []
  type: TYPE_NORMAL
- en: You may remember that we only required ![A](img/file183.png "A") and ![B](img/file184.png
    "B") to satisfy that ![A(0) = B(T) = 1](img/file548.png "A(0) = B(T) = 1") and
    ![A(T) = B(0) = 0](img/file549.png "A(T) = B(0) = 0"), where ![T](img/file74.png
    "T") is the total annealing time, but we did not restrict in any way how ![A](img/file183.png
    "A") and ![B](img/file184.png "B") should behave except for these boundary conditions.
    D-Wave’s annealers have default schedules. You can find them at [https://docs.dwavesys.com/docs/latest/doc_physical_properties.html](https://docs.dwavesys.com/docs/latest/doc_physical_properties.html)
    and in the annealing schedule sections of the user manuals for the devices, which
    you can find on that same web page. We can modify those default schedules by specifying
    the values that we want the functions to take at some intermediate times.
  prefs: []
  type: TYPE_NORMAL
- en: We can define a custom annealing schedule through a list of pairs of real numbers.
    The first number of each pair needs to be a time value given in microseconds and
    the second one has to be a number between ![0](img/file12.png "0") and ![1](img/file13.png
    "1"). This second number is called the **anneal fraction**, usually denoted by
    ![s](img/file610.png "s"). The higher the value of ![s](img/file610.png "s") is,
    the higher the value of ![B](img/file184.png "B") and the lower the value of ![A](img/file183.png
    "A") will be. As a consequence, when ![s = 1](img/file611.png "s = 1"), we can
    interpret that ![B](img/file184.png "B") is ![1](img/file13.png "1") and ![A](img/file183.png
    "A") is 0; when ![s = 0](img/file612.png "s = 0"), we can interpret that ![A](img/file183.png
    "A") is ![1](img/file13.png "1") and ![B](img/file184.png "B") is ![0](img/file12.png
    "0").
  prefs: []
  type: TYPE_NORMAL
- en: There are two types of annealing schedules that we can use. The first one is
    called **forward annealing** and corresponds to the usual annealing process that
    we have been studying since the beginning of this chapter. It starts with ![(0,0)](img/file613.png
    "(0,0)") and ends at ![(T,1)](img/file614.png "(T,1)"), where ![T](img/file74.png
    "T") is the total annealing time — which, of course, must not be bigger than the
    maximum annealing time allowed by the device. In addition, the values of ![s](img/file610.png
    "s") must monotonically increase over the time points.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of a forward annealing schedule could be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, ![s](img/file610.png "s") starts at ![0](img/file12.png "0"),
    gets value ![0.25](img/file615.png "0.25") at 5 microseconds, ![0.75](img/file616.png
    "0.75") at 25 microseconds and, finally, ![1](img/file13.png "1") at 30 microseconds,
    which is the end of the annealing process. The growth of ![s](img/file610.png
    "s") will be linear between the points specified in the schedule. To use this
    custom schedule in a device, you only need to pass it as the `anneal_schedule`
    parameter. For instance, you can do something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Here, `triangle` is the problem that we defined in the previous code block.
  prefs: []
  type: TYPE_NORMAL
- en: To learn more…
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the annealing schedule can be useful for certain problems, especially
    if you know that at some points the ground state and the first excited state are
    closer. In this case, you can use a custom schedule to slow the annealing process
    down on those ”dangerous” regions, while allowing it to go faster on other, less
    problematic, time intervals.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to forward annealing, we can also use **reverse annealing**. In
    reverse annealing, ![s](img/file610.png "s") starts at ![1](img/file13.png "1"),
    decreases for some time, and then increases back to ![1](img/file13.png "1") at
    the end of the annealing process. An example of a reverse annealing schedule could
    be
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: where, as in the case of forward annealing, the values of ![s](img/file610.png
    "s") are linearly interpolated between the points given in the list.
  prefs: []
  type: TYPE_NORMAL
- en: When using reverse annealing, you also need to specify an initial state. This
    is because now we do not start with a Hamiltonian whose ground state is known
    to us. You can do that with the `initial_state` parameter of the `sample` method.
    Reverse annealing is commonly used on an approximate solution that we already
    have in an attempt to find a better one. In this case, we take that solution to
    be the initial state, we decrease the intensity of the final Hamiltonian for some
    time, and then we increase it again in an attempt to obtain a new solution with
    a lower energy.
  prefs: []
  type: TYPE_NORMAL
- en: There are two different ways in which we can use reverse annealing. We can run
    several repetitions of the annealing process on the same initial state with the
    `reinitialize_state``=``True` option when calling `sample`. Alternatively, we
    can use the final (measured) state of one execution as the initial state of the
    next one by setting `reinitialize_state``=``False`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now look at an example in which we will apply reverse annealing to a
    simple problem. The following code, in which we use the `triangle` problem defined
    previously, is almost self-explanatory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'A possible output of these instructions could be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: To learn more…
  prefs: []
  type: TYPE_NORMAL
- en: Some researchers have found that reverse annealing can be more effective than
    forward annealing for some problems. For a very illuminating example, please check
    the paper by Carugno et al. [[23](ch030.xhtml#Xcarugno2022evaluating)].
  prefs: []
  type: TYPE_NORMAL
- en: Now, we know how to control both the annealing time and the schedule. In the
    next subsection, we will explain why it is important to set the coupling strengths
    and the penalty terms wisely, something that is easily overlooked, but that can
    greatly affect the results of our executions.
  prefs: []
  type: TYPE_NORMAL
- en: 4.4.4 The importance of coupling strengths
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You surely remember that there are a couple of situations in which we have to
    select values for some arbitrary constants that are used to set coupling strengths
    in the annealer. The first situation is having to introduce constraints as penalty
    terms in the objective function, using the `lagrange_multiplier` parameter in
    the `cqm_to_bqm` method of the `dimod` package. The second one is having to select
    the coupling strengths for the chains in a particular embedding, which is usually
    handled automatically by classes such as `EmbeddingComposite`.
  prefs: []
  type: TYPE_NORMAL
- en: It would be very natural to think that you would want these constants to be
    as big as possible. After all, you are not interested in solutions that do not
    satisfy the problem constraints and you do not want your chains to be broken.
    However, there is an important detail that makes choosing the values of these
    constants a little bit trickier than expected.
  prefs: []
  type: TYPE_NORMAL
- en: It turns out that the range of values that you use for qubit couplings in D-Wave’s
    annealers is not arbitrarily large. For example, the following instructions allow
    us to check what the possible values are for the case of the `Advantage_system4`
  prefs: []
  type: TYPE_NORMAL
- en: '`.1` device — and, of course, if you change the solver name, you can get the
    values for any other annealers as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The output that you will get if you run these instructions is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This means that, if you set coupling strengths (that is, ![J](img/file617.png
    "J") coefficients) that in absolute value are bigger than ![4](img/file143.png
    "4"), the largest one will be scaled down to ![4](img/file143.png "4")…and the
    rest of the coefficients in your model will be scaled down accordingly. This can
    cause some of the values to be very close together, even closer than the resolution
    of the device, affecting the results of the annealing process. Let’s illustrate
    it with an example.
  prefs: []
  type: TYPE_NORMAL
- en: The following code defines a constrained problem, converts it into an unconstrained
    model using the penalty constant ![M = 10](img/file618.png "M = 10"), and then
    runs it on `Advantage_system4`
  prefs: []
  type: TYPE_NORMAL
- en: '`.1` taking 100 samples. Then, it converts the samples back to the variables
    of the original problem, aggregates the results, as we did in *Section* *[*4.3.3*](#x1-810004.3.3),
    and shows the frequency of each obtained solution:*'
  prefs: []
  type: TYPE_NORMAL
- en: '*[PRE47]'
  prefs: []
  type: TYPE_NORMAL
- en: 'When we ran this code, we obtained the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: So, in 21 out of 100 samples, we have obtained the optimal solution, and, in
    43 more cases, we obtained solutions with the second lowest energy. Not too bad…but
    not very good either. The not-so-obvious problem behind this result is that the
    penalty constant (the `lagrange_multiplier` parameter) is too big compared to
    the range of energies of the objective function. In fact, if you use `ExactSolver`
    on the transformed problem, you can easily check that all the assignments that
    are unfeasible on the original problem get energy ![16](img/file619.png "16")
    or higher on the transformed one, while the feasible solutions always get energy
    ![3](img/file472.png "3") or lower. That is a huge gap!
  prefs: []
  type: TYPE_NORMAL
- en: 'But notice what happened when we ran the same code after reducing the penalty
    constant to ![4](img/file143.png "4"). In that case, we obtained the following
    result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the frequency of the optimal solution has increased to ![30](img/file620.png
    "30") and the two solutions with the second lowest energy appear, more or less,
    the same number of times as in the experiment with `lagrange_multiplier`
  prefs: []
  type: TYPE_NORMAL
- en: '`=10`. In this case (check it by using `ExactSolver`), the unfeasible solutions
    all have energy that is at least ![4](img/file143.png "4") in the transformed
    problem, so all the feasible solutions have lower energy. Notice, though, that
    the gap is now much smaller and we only recovered ![98](img/file621.png "98")
    feasible solutions from the ![100](img/file389.png "100") samples.'
  prefs: []
  type: TYPE_NORMAL
- en: We even tried a more extreme experiment, setting `lagrange_multiplier`
  prefs: []
  type: TYPE_NORMAL
- en: '`=1`. When we ran it, we obtained the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The frequency of the optimal solution has dramatically improved, up to ![76](img/file622.png
    "76") out of ![100](img/file389.png "100") samples. However, we also ”lost” 6
    samples because they corresponded to unfeasible solutions. In this case, there
    are some unfeasible solutions with energy as low as ![- 2](img/file333.png "-
    2") in the transformed problem. This is still bigger than the optimal energy,
    which is ![- 5](img/file591.png "- 5"), but the low energy of these unfeasible
    solutions can fool the annealer into selecting them at times, as we have seen.
  prefs: []
  type: TYPE_NORMAL
- en: Setting a good penalty constant can be difficult, because it involves having
    some information about the energy distribution of the solutions to the problem.
    But let the examples here serve as a warning that you should not just use any
    value for `lagrange_multiplier`, because setting it too high can affect the quality
    of your solutions. In case of doubt, try some different options and keep the one
    that offers the best results.
  prefs: []
  type: TYPE_NORMAL
- en: To learn more…
  prefs: []
  type: TYPE_NORMAL
- en: Something similar may happen when the value of the coupling strength for chains
    in an embedding is too big. Fortunately, the methods used by `EmbeddingComposite`
    and its relatives take this into account and will try to keep the value as low
    as possible without risking breaking many chains. But should you need, for some
    reason, to create your own embedding, do not take the choice of the coupling strength
    lightly.
  prefs: []
  type: TYPE_NORMAL
- en: You now know how to adjust the most important parameters that govern quantum
    annealing and, more importantly, you understand the implications of such adjustments.
    But it turns out that D-Wave offers other ways of solving optimization problems
    beyond ”pure” quantum annealing. Let us study them in the following subsection.
  prefs: []
  type: TYPE_NORMAL
- en: 4.4.5 Classical and hybrid samplers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have already seen that `dimod` provides a **classical** solver called `ExactSolver`.
    And it’s not alone! In Ocean, we can also find solvers such as, for example, `SimulatedAnnealing`
    or `SteepestDescentSolver` that do not rely on any quantum resources whatsoever.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of including these classical solvers in a quantum optimization library
    is two-fold. On the one hand, it allows you to try and use different methods to
    solve your problems. On the other hand, they can be used in combination with quantum
    annealers in what D-Wave calls **hybrid solvers**. Let’s briefly study these two
    aspects.
  prefs: []
  type: TYPE_NORMAL
- en: Classical solvers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using classical solvers with Ocean couldn’t be simpler. As long as you have
    a QUBO or Ising problem, you can use the `sample` method of any classical solver
    to get (approximate) solutions to it, exactly like you would do with a quantum
    annealer. In fact, you can also use the `num_reads` parameter to specify the number
    of samples that you want.
  prefs: []
  type: TYPE_NORMAL
- en: We will devote the rest of this subsection to describing the classical solvers
    included in Ocean at the time of writing.
  prefs: []
  type: TYPE_NORMAL
- en: '`SteepestDescentSolver` This is included in the `greedy` package and it is
    a discrete version of the gradient descent algorithm for continuous optimization
    (more on that in *Chapter* [*8*](ch017.xhtml#x1-1390008), *What is Quantum Machine
    Learning?*). At each step, it selects one direction (that is, one variable flip)
    in which the decrease in energy is bigger. We can use it as shown in the following
    piece of code, where we first define a simple Ising problem and then we sample
    from it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of running these instructions will be similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this is exactly the format the we already know and love from
    using quantum solvers.
  prefs: []
  type: TYPE_NORMAL
- en: To learn more…
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the `num_reads` parameter, you can also set `initial_states`
    to specify the solutions from which the descent is going to start. If you don’t
    use this parameter, then the initial states will be selected at random. In that
    case, you can use the `seed` argument should you want your results to be reproducible.
  prefs: []
  type: TYPE_NORMAL
- en: '`TabuSolver` This solver is included in the `tabu` package. It is an example
    of a **local** **search** algorithm. That is, it tries to improve a solution by
    exploring its neighbors — the solutions that can be obtained by flipping one variable,
    for instance. In this, the method is somewhat similar to the greedy descent algorithm
    implemented in `SteepestDescentSolver`, but it tries to avoid falling into local
    minima by sometimes accepting solutions with higher energy than the current one,
    and it also ”remembers” solutions it has already visited in order not to explore
    them again — that is where the name *tabu* comes from.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Ocean implements the multistart tabu algorithm described in [[72](ch030.xhtml#Xpalubeckis2004multistart)].
    It can be used with the following instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The tabu algorithm also accepts `initial_states` and `seed` parameters.
  prefs: []
  type: TYPE_NORMAL
- en: '`SimulatedAnnealingSampler` This is included in the `neal` package and it implements
    the heuristic algorithm known as **simulated annealing** [[59](ch030.xhtml#Xkirkpatrick1983optimization)].
    It is another local search algorithm that explores the neighbourhood of the candidate
    solution that it is considering at a given moment. With that, it tries to move
    to solutions with lower energy. However, like tabu search, it can move to solutions
    with higher energy with some probability. This probability is bounded by a global
    ”temperature” parameter that decreases with time, eventually reaching ![0](img/file12.png
    "0"), inspired by the way in which metals become less malleable when they cool
    down during annealing — hence the name of the method. In fact, quantum annealing
    is seen by some people as a quantum version of simulated annealing. The analogy
    they make is that the intensity of the initial Hamiltonian ![H_{0}](img/file545.png
    "H_{0}") can be understood as analogous to the temperature in simulated annealing:
    it allows the solutions to move or ”tunnel” to some neighboring ones and it decreases
    over time. Simulated annealing can be used in Ocean as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: As you surely guessed, the `initial_states` and `seed` parameters are also supported.
  prefs: []
  type: TYPE_NORMAL
- en: These samplers are all classical algorithms that do not use quantum resources.
    However, they can be combined with quantum annealers, as we show in the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Hybrid solvers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In addition to quantum annealers and classical solvers, Ocean also provides
    the programmer with hybrid solvers that try to combine the best of both worlds.
    You may remember that, back in *Section* *[*4.4.1*](#x1-830004.4.1), these hybrid
    solvers were listed among the devices available through your Leap account. Finally,
    the time to learn how to use them has come!*
  prefs: []
  type: TYPE_NORMAL
- en: '*Let’s start with `LeapHybridSampler`. This sampler accepts QUBO and Ising
    problems and can scale up to a high number of variables because, internally, it
    divides the problem, assigns different parts to classical solvers and quantum
    annealers, and then reconstructs a global solution from the local ones. Its use
    is very similar to that of the samplers that we have studied so far. For instance,
    you can run the following instructions, with `problem` as defined in the previous
    subsection — or just any other QUBO or Ising problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'One interesting property of `LeapHybridSampler` and the rest of the hybrid
    samplers is what is called the **quota conversion rate**. It can be checked through
    the following property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: In the case of `LeapHybridSampler`, it is 20\. This means that for each 20 microseconds
    that you use this hybrid sampler, you will get charged just 1 microsecond of quantum
    processor access because the quantum annealers are not used for the whole computation.
    Neat, right?
  prefs: []
  type: TYPE_NORMAL
- en: Ocean also provides `LeapHybridCQMSampler`, which is used similarly to `LeapHybridSampler`,
    but with constrained problems like the ones we defined in *Section* *[*4.3.3*](#x1-810004.3.3).
    Finally, there is also `LeapHybridDQMSampler`, which works with discrete quadratic
    problems defined as objects of the `DiscreteQuadraticModel` class.*
  prefs: []
  type: TYPE_NORMAL
- en: '*To learn more…'
  prefs: []
  type: TYPE_NORMAL
- en: We have not worked with the `DiscreteQuadraticModel` class, but it is very similar
    to `BinaryQuadraticModel`. The main difference is that it accepts variables that
    take a finite amount of different values instead of just ![0](img/file12.png "0")
    and ![1](img/file13.png "1"). The problems defined through this class can be converted
    to binary quadratic problems by **one-hot encoding**; that is, each discrete variable
    is represented by a vector of ![n](img/file244.png "n") binary variables, where
    ![n](img/file244.png "n") is the total number of values that the original discrete
    variable can take. The restriction is that only one of those variables can take
    the value ![1](img/file13.png "1") at a given time. So, if binary variable number
    ![3](img/file472.png "3") is ![1](img/file13.png "1"), this means that the original
    variable takes the value ![3](img/file472.png "3").
  prefs: []
  type: TYPE_NORMAL
- en: This ends our study of quantum annealing and its use in combinatorial optimization.
    But this kind of problem can also be solved with algorithms designed for quantum
    computers based on the quantum circuit model. That will be the topic of our next
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you have learned about the adiabatic quantum computing model,
    which is equivalent to the quantum circuit model that we had already studied.
    Instead of discrete quantum gates, adiabatic quantum computing uses continuous
    evolution through a time-dependent Hamiltonian. You have learned how to select
    this Hamiltonian to encode combinatorial optimization problems and how, if the
    evolution is slow enough, the adiabatic theorem guarantees that we will measure
    the ground state at the end of the process.
  prefs: []
  type: TYPE_NORMAL
- en: You have also learned that, in practice, quantum annealing is used instead of
    adiabatic quantum computing, because adiabatic evolution can take too long for
    the process to be feasible. What is more, you now know how to use actual quantum
    annealers through D-Wave Leap to find approximate solutions to combinatorial optimization
    problems in several different ways.
  prefs: []
  type: TYPE_NORMAL
- en: You also know how to control several parameters of the annealing process, in
    order to improve the quality of the solutions that you can find with quantum annealers.
    Finally, you have also learned how to use hybrid solvers that divide big problems
    into smaller pieces and combine classical and quantum techniques to find a global
    solution to the original problem.
  prefs: []
  type: TYPE_NORMAL
- en: We will now turn to using quantum computers based on the quantum circuit model.
    But we will not forget about optimization problems and Hamiltonians. In fact,
    as you will soon see, the topic of our next chapter will be how to discretize
    quantum annealing so that it can be implemented with quantum gates.******************
  prefs: []
  type: TYPE_NORMAL
