- en: Chapter 2. Bootstrapping
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章. 自举
- en: As seen in the previous chapter, statistical inference is enhanced to a very
    large extent with the use of computational power. We also looked at the process
    of permutation tests, wherein the same test is applied multiple times for the
    resamples of the given data under the (null) hypothesis. The rationale behind
    resampling methods is also similar; we believe that if the sample is truly random
    and the observations are generated from the same identical distribution, we have
    a valid reason to resample the same set of observations with replacements. This
    is because any observation might as well occur multiple times rather than as a
    single instance.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一章所见，统计推断在计算能力的帮助下得到了极大的增强。我们还探讨了排列检验的过程，其中相同的检验被多次应用于给定数据的重采样（在零假设下）。重采样方法背后的原理也类似；我们相信，如果样本确实是随机的，并且观测是从相同的相同分布中生成的，我们就有一个有效的理由用替换的方式重采样同一组观测。这是因为任何观测都可能多次发生，而不是作为一个单独的实例。
- en: This chapter will begin with a formal definition of resampling, followed by
    a look at the jackknife technique. This will be applied to multiple, albeit relatively
    easier, problems, and we will look at the definition of the pseudovalues first.
    The bootstrap method, invented by Efron, is probably the most useful resampling
    method. We will study this concept thoroughly and vary the applications from simple
    cases to regression models.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将从重采样的正式定义开始，接着探讨删层技术。这将被应用于多个问题，尽管相对较简单，我们首先将查看伪值的定义。由Efron发明的自举方法可能是最有用的重采样方法。我们将彻底研究这个概念，并将应用从简单案例扩展到回归模型。
- en: 'In this chapter, we will cover the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下内容：
- en: '**The jackknife technique**: Our first resampling method that enables bias
    reduction'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**删层技术**：我们的第一个重采样方法，能够减少偏差'
- en: '**Bootstrap**: A statistical method and generalization of the jackknife method'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自举**：一种统计方法，也是删层方法的推广'
- en: '**The boot package**: The main R package for bootstrap methods'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**boot包**：自举方法的主要R包'
- en: '**Bootstrap and testing hypothesis**: Using the bootstrap method for hypothesis
    testing'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自举和假设检验**：使用自举方法进行假设检验'
- en: '**Bootstrapping regression models**: Applying the bootstrap method to the general
    regression model'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自举回归模型**：将自举方法应用于一般回归模型'
- en: '**Bootstrapping survival models**: Applying the bootstrap method for the survival
    data'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自举生存模型**：应用自举方法处理生存数据'
- en: '**Bootstrapping time series models**: The bootstrap method for the time series
    data – observations are dependent here'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自举时间序列模型**：时间序列数据的自举方法——这里的观测是相关的'
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'We will be using the following libraries in the chapter:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用以下库：
- en: '`ACSWR`'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ACSWR`'
- en: '`boot`'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boot`'
- en: '`car`'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`car`'
- en: '`gee`'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gee`'
- en: '`mvtnorm`'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mvtnorm`'
- en: '`pseudo`'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pseudo`'
- en: '`RSADBE`'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RSADBE`'
- en: '`survival`'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`survival`'
- en: The jackknife technique
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删层技术
- en: Quenouille (1949) invented the jackknife technique. The purpose of this was
    to reduce bias by looking at multiple samples of data in a methodical way. The
    name jackknife seems to have been coined by the well-known statistician John W.
    Tukey. Due mainly to the lack of computational power, the advances and utility
    of the jackknife method were restricted. Efron invented the bootstrap method in
    1979 (see the following section for its applications) and established the connection
    with the jackknife method. In fact, these two methods have a lot in common and
    are generally put under the umbrella of *resampling methods*.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Quenouille（1949年）发明了删层技术。其目的是通过有系统地查看多个数据样本来减少偏差。删层技术的名字似乎是由著名的统计学家John W. Tukey提出的。主要由于计算能力的缺乏，删层方法的进步和实用性受到了限制。Efron在1979年发明了自举方法（参见下文的应用），并建立了与删层方法之间的联系。实际上，这两种方法有很多共同之处，通常被归类为*重采样方法*。
- en: Suppose that we draw a random sample ![The jackknife technique](img/00044.jpeg)of
    size *n* from a probability distribution *F*, and we denote by ![The jackknife
    technique](img/00045.jpeg) the parameter of interest. Let ![The jackknife technique](img/00046.jpeg)
    be an estimator of ![The jackknife technique](img/00047.jpeg), and here we don't
    have the probability distribution of ![The jackknife technique](img/00048.jpeg)
    for a given ![The jackknife technique](img/00049.jpeg). Resampling methods will
    help in carrying out statistical inference when the probability distribution is
    unknown. A formal definition of the concept is in order.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们从概率分布*F*中抽取一个大小为*n*的随机样本![Jackknife技术](img/00044.jpeg)，并用![Jackknife技术](img/00045.jpeg)表示感兴趣的参数。令![Jackknife技术](img/00046.jpeg)为![Jackknife技术](img/00047.jpeg)的估计量，在此我们并没有给定![Jackknife技术](img/00048.jpeg)的概率分布。当概率分布未知时，重采样方法有助于进行统计推断。有必要对这个概念给出一个正式的定义。
- en: 'Definition: *Resampling methods* are ways of estimating the bias and variance
    of the estimator ![The jackknife technique](img/00050.jpeg) that uses the values
    of ![The jackknife technique](img/00051.jpeg) based on subsamples from the available
    observations ![The jackknife technique](img/00052.jpeg).'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 定义：**重采样方法**是估计估计量![Jackknife技术](img/00050.jpeg)的偏差和方差的途径，它使用基于可用观测值的子样本![Jackknife技术](img/00051.jpeg)的值。
- en: The **jackknife technique** is a resampling method, and we will lay down its
    general procedure in the ensuing discussion. As stated previously, ![The jackknife
    technique](img/00053.jpeg) is an estimator of ![The jackknife technique](img/00054.jpeg).
    For simplicity, we define the vector of the given observations by ![The jackknife
    technique](img/00055.jpeg). The important quantity in setting up this procedure
    is the *pseudovalue*, and we will define this mathematically next.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**Jackknife技术**是一种重采样方法，我们将在接下来的讨论中阐述其一般步骤。如前所述，![Jackknife技术](img/00053.jpeg)是![Jackknife技术](img/00054.jpeg)的估计量。为了简化，我们定义给定观测值的向量为![Jackknife技术](img/00055.jpeg)。设置此程序的重要量是**伪值**，我们将在下文中对其进行数学定义。'
- en: '**Definition**: Let ![The jackknife technique](img/00056.jpeg), that is, ![The
    jackknife technique](img/00057.jpeg) is the vector ![The jackknife technique](img/00058.jpeg)
    without the *i-th* observation. The *i-th pseudovalue* of ![The jackknife technique](img/00059.jpeg)
    is then defined as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**定义**：令![Jackknife技术](img/00056.jpeg)，即![Jackknife技术](img/00057.jpeg)是去掉第*i*个观测值的向量![Jackknife技术](img/00058.jpeg)。![Jackknife技术](img/00059.jpeg)的第*i*个伪值定义为以下内容：'
- en: '![The jackknife technique](img/00060.jpeg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![Jackknife技术](img/00060.jpeg)'
- en: 'It can be mathematically demonstrated that the *pseudovalue* is equivalent
    to the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 可以从数学上证明**伪值**等同于以下内容：
- en: '![The jackknife technique](img/00061.jpeg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![Jackknife技术](img/00061.jpeg)'
- en: 'Thus, the *pseudovalue* is seen as the bias-corrected version of ![The jackknife
    technique](img/00062.jpeg). The pseudovalues defined here are also referred to
    as *delete-one* jackknife. The jackknife method treats the pseudovalues as independent
    observations with mean ![The jackknife technique](img/00063.jpeg), and then applies
    the *central limit theorem* for carrying out the statistical inference. The mean
    and (sampling) variance of the pseudovalues is given as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，**伪值**被视为![Jackknife技术](img/00062.jpeg)的偏差校正版本。这里定义的伪值也被称为**删除一个**的Jackknife。Jackknife方法将伪值视为具有均值![Jackknife技术](img/00063.jpeg)的独立观测值，然后应用**中心极限定理**进行统计推断。伪值的均值和（抽样）方差如下所示：
- en: '![The jackknife technique](img/00064.jpeg)![The jackknife technique](img/00065.jpeg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![Jackknife技术](img/00064.jpeg)![Jackknife技术](img/00065.jpeg)'
- en: The jackknife method for mean and variance
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 均值和方差的Jackknife方法
- en: Suppose the probability distribution is unknown, and the histogram and other
    visualization techniques suggest that the assumption of normal distribution is
    not appropriate. However, we don't have rich information either to formulate a
    reasonable probability model for the problem at hand. Here, we can put the jackknife
    technique to good use.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 假设概率分布是未知的，直方图和其他可视化技术表明正态分布的假设不合适。然而，我们也没有足够的信息来为手头的问题制定一个合理的概率模型。在这里，我们可以充分利用Jackknife技术。
- en: 'We define mean and variance estimators as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将均值和方差估计量定义为如下：
- en: '![The jackknife method for mean and variance](img/00066.jpeg)![The jackknife
    method for mean and variance](img/00067.jpeg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![杰克knife方法用于均值和方差](img/00066.jpeg)![杰克knife方法用于均值和方差](img/00067.jpeg)'
- en: 'The pseudovalues associated with ![The jackknife method for mean and variance](img/00068.jpeg)
    and ![The jackknife method for mean and variance](img/00069.jpeg) are respectively
    given in the following expressions:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 与![杰克knife方法用于均值和方差](img/00068.jpeg)和![杰克knife方法用于均值和方差](img/00069.jpeg)相关的伪值分别在以下表达式中给出：
- en: '![The jackknife method for mean and variance](img/00070.jpeg)![The jackknife
    method for mean and variance](img/00071.jpeg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![杰克knife方法用于均值和方差](img/00070.jpeg)![杰克knife方法用于均值和方差](img/00071.jpeg)'
- en: The mean of ![The jackknife method for mean and variance](img/00072.jpeg) will
    be the sample mean, and the mean of ![The jackknife method for mean and variance](img/00073.jpeg)
    will be sampling variance. However, the application of the jackknife method lies
    in the details. Based on the estimated mean alone, we would not be able to infer
    about the population mean, and based on the sample variance, we would not be able
    to exact inference about the population variance. To see what is happening with
    these formulas of pseudovalues and how their variances will be useful, we will
    set up an elegant R program next.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '![杰克knife方法用于均值和方差](img/00072.jpeg)的均值将是样本均值，而![杰克knife方法用于均值和方差](img/00073.jpeg)的均值将是样本方差。然而，杰克knife方法的应用在于细节。仅基于估计的均值，我们无法推断关于总体均值的信息，仅基于样本方差，我们无法精确推断关于总体方差的信息。为了了解这些伪值公式的具体情况以及它们的方差如何有用，我们将在下一个优雅的R程序中设置。'
- en: We will simulate *n = 1000* observations from the Weibull distribution with
    some scale and shape parameters. In the standard literature, we will be able to
    find the estimates of these two parameters. However, a practitioner is seldom
    interested in these parameters and would prefer to infer about the mean and variance
    of the lifetimes. The density function is a complex form. Furthermore, the theoretical
    mean and variance of a Weibull random variable in terms of the scale and shape
    parameter is easily found to be too complex, and the expressions involving Gamma
    integrals do not help the case any further. If the reader tries to search for
    the string *statistical inference for the mean of Weibull distribution* in a search
    engine, the results will not be satisfactory, and it won't be easy to proceed
    any further, except for individuals who are mathematically adept. In this complex
    scenario, we will look at how the jackknife method saves the day for us.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从具有一些规模和形状参数的威布尔分布中模拟 *n = 1000* 个观测值。在标准文献中，我们将能够找到这两个参数的估计值。然而，从业者很少对这些参数感兴趣，他们更愿意推断寿命的均值和方差。密度函数是一个复杂的形式。此外，从规模和形状参数的角度来看，威布尔随机变量的理论均值和方差很容易发现过于复杂，涉及伽马积分的表达式并不能进一步帮助这个案例。如果读者试图在搜索引擎中搜索字符串
    *威布尔分布均值的统计推断*，结果将不会令人满意，而且进一步推进不会很容易，除非是数学上熟练的人。在这个复杂的场景中，我们将探讨杰克knife方法是如何为我们解围的。
- en: A note is in order before we proceed. The reader might wonder, *who cares about
    Weibull distribution in this era of brawny super-computational machines?* However,
    any reliability engineer will vouch for the usefulness of lifetime distributions,
    and Weibull is an important member of this class. The second point might be that
    the normal approximation will hold well for large samples. However, when we have
    moderate samples to carry out the inference, the normal approximation for a highly
    skewed distribution such as Weibull might lose out on the power and confidence
    of the tests. Besides, the question is that if we firmly believe that the underlying
    distribution is Weibull (without parameters) it remains a monumental mathematical
    task to obtain the exact distributions of the mean and variance of the Weibull
    distribution.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，有一个注意事项。读者可能会想，“在这个强大的超级计算机器时代，谁会在乎威布尔分布呢？”然而，任何可靠性工程师都会证实寿命分布的有用性，而威布尔是这个类别中的重要成员。第二点可能是，对于大样本，正态近似将很好地成立。然而，当我们有适中的样本进行推断时，对于像威布尔这样高度偏斜的分布的正态近似可能会失去测试的力度和信心。此外，问题是，如果我们坚信基础分布是威布尔（没有参数），那么获得威布尔分布的均值和方差的精确分布仍然是一个巨大的数学任务。
- en: 'The R program will implement the jackknife technique for the mean and variance
    for given raw data:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: R程序将实现针对给定原始数据的均值和方差的杰克knife技术：
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As mentioned in earlier simulation scenarios, we plant the seed for the sake
    of reproducible results. The `rweibull` function helps to enact the task of simulating
    observations from the Weibull distribution. We calculate the mean, standard deviation,
    and variance of the sample. Next, we define the `pv_mean` function that will enable
    computation of `pseudovalues` of mean and variance:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的模拟场景中提到的，我们播种是为了可重复的结果。`rweibull`函数有助于执行从威布尔分布模拟观察值的任务。我们计算样本的均值、标准差和方差。接下来，我们定义`pv_mean`函数，它将使计算均值和方差的`伪值`成为可能：
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Note that the values and `pseudovalues` of the mean and the value of the observation
    are the same for all observations. In fact, this is anticipated, as the statistic
    we are looking at is the mean, which is simply the average. Removing the average
    of other observations from that should return the value. Consequently, the mean
    of the `pseudovalues` and the sample mean would be the same too. However, that
    does not imply that the efforts are futile. We will continue with the computations
    for the variance term as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，对于所有观察值，平均值和`伪值`的值与观察值的值相同。实际上，这是预期的，因为我们正在查看的统计量是平均值，它只是平均。从其他观察值的平均中减去应该会得到该值。因此，`伪值`的平均值和样本平均值也将相同。然而，这并不意味着努力是徒劳的。我们将继续对方差项进行以下计算：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now, there is no counterpart to the `pseudovalue` of the observation in the
    actual data. Here, the mean of the `pseudovalues` will approximately equal the
    sample variance. This is the standard deviation `sd(pv_var)` which will help in
    carrying out the inference related to the variance or standard deviation.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，实际数据中没有观察到的`伪值`的对应物。在这里，`伪值`的平均值将大约等于样本方差。这是标准差`sd(pv_var)`，它将有助于进行与方差或标准差相关的推断。
- en: We have seen how the jackknife is useful in inferring the mean and variance.
    In the next part of this section, we will see how the `pseudovalues` can be useful
    in solving problems in the context of a survival regression problem.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到夹具在推断均值和方差方面的有用性。在本节下一部分，我们将看到`伪值`如何在生存回归问题的背景下解决问题。
- en: Pseudovalues method for survival data
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生存数据的伪值方法
- en: The primary biliary cirrhosis data, `pbc`, was introduced in [Chapter 1](part0012_split_000.html#BE6O2-2006c10fab20488594398dc4871637ee
    "Chapter 1. Introduction to Ensemble Techniques"), *Introduction to Ensemble Techniques*,
    in *Section 2*, and we made a note that the data is special in that it is survival
    data and the variable of interest time is subject to censoring, which complicates
    further analysis. Specialized methods for dealing with survival data will be dealt
    with in [Chapter 10](part0070_split_000.html#22O7C2-2006c10fab20488594398dc4871637ee
    "Chapter 10. Ensembling Survival Models"), *Ensembling Survival Models*. The specialized
    methods include the hazards regression, and the impact of covariates is measured
    on the hazard rate and not on the lifetime. It has been observed that practitioners
    find these concepts a tad difficult, and hence we will briefly discuss an alternative
    approach based on the pseudovalues.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的胆汁性肝硬化数据，`pbc`，在[第一章](part0012_split_000.html#BE6O2-2006c10fab20488594398dc4871637ee
    "第一章。集成技术简介")，*集成技术简介*，第二部分中被引入，我们做了笔记，指出这些数据是特殊的，因为它是生存数据，感兴趣的时间变量可能受到截尾，这增加了进一步分析复杂性。处理生存数据的专用方法将在[第十章](part0070_split_000.html#22O7C2-2006c10fab20488594398dc4871637ee
    "第十章。集成生存模型")，*集成生存模型*中讨论。这些专用方法包括风险回归，协变量的影响是在风险率上而不是在寿命上测量的。观察到从业者发现这些概念有点难以理解，因此我们将简要讨论基于伪值的替代方法。
- en: 'Andersen and Klein have effectively used the notion of pseudovalues for various
    problems in a series of papers:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 安德森和克莱因在一系列论文中有效地使用了伪值的概念来解决各种问题：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Bootstrap – a statistical method
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自举 – 一种统计方法
- en: In this section, we will explore complex statistical functional. What is the
    statistical distribution of the correlation between two random variables? If normality
    assumption does not hold for the multivariate data, then what is an alternative
    way to obtain the standard error and confidence interval? Efron (1979) invented
    the *bootstrap technique*, which provides the solutions that enable statistical
    inference related to complex statistical functionals. In [Chapter 1](part0012_split_000.html#BE6O2-2006c10fab20488594398dc4871637ee
    "Chapter 1. Introduction to Ensemble Techniques"), *Introduction to Ensemble Techniques*,
    the permutation test, which repeatedly draws samples of the given sample and carries
    out the test for each of the resamples, was introduced. In theory, the permutation
    test requires ![Bootstrap – a statistical method](img/00074.jpeg) number of resamples,
    where *m* and *n* are the number of observations in the two samples, though one
    does take their foot off the pedal after having enough resamples. The bootstrap
    method works in a similar way and is an important resampling method.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨复杂的统计函数。两个随机变量之间的相关性的统计分布是什么？如果多元数据的正态性假设不成立，那么获得标准误差和置信区间的替代方法是什么？Efron（1979）发明了*自助法*（bootstrap
    technique），它提供了解决与复杂统计函数相关的统计推断问题的方法。在[第1章](part0012_split_000.html#BE6O2-2006c10fab20488594398dc4871637ee
    "第1章。集成技术介绍")《集成技术介绍》中，介绍了**排列检验**，它反复抽取给定样本的样本，并对每个重采样进行测试。从理论上讲，排列检验需要![Bootstrap
    – 统计方法](img/00074.jpeg)数量的重采样，其中*m*和*n*是两个样本中的观测数，尽管在获得足够多的重采样后，人们会稍微放松一些。自助法以类似的方式工作，并且是一种重要的重采样方法。
- en: Let ![Bootstrap – a statistical method](img/00075.jpeg) be an independent random
    sample from a probability distribution F, the parameter of interest be ![Bootstrap
    – a statistical method](img/00076.jpeg), and an estimator of the parameter be
    denoted by ![Bootstrap – a statistical method](img/00077.jpeg). If the probability
    distribution of ![Bootstrap – a statistical method](img/00077.jpeg) for the ![Bootstrap
    – a statistical method](img/00078.jpeg) parameter is either unknown or intractable,
    then the statistical inference about the parameter can't be carried out. Consequently,
    we need a generic technique that will aid in the inference.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 设![Bootstrap – 统计方法](img/00075.jpeg)是从概率分布F中独立抽取的随机样本，感兴趣的参数为![Bootstrap – 统计方法](img/00076.jpeg)，参数的估计值用![Bootstrap
    – 统计方法](img/00077.jpeg)表示。如果![Bootstrap – 统计方法](img/00077.jpeg)参数的概率分布要么是未知的，要么是不可处理的，那么关于参数的统计推断就无法进行。因此，我们需要一种通用的技术来帮助进行推断。
- en: Efron's method unfolds as follows. The estimate provided by ![Bootstrap – a
    statistical method](img/00077.jpeg) is a single value. Given the data and based
    on the assumption that we have an IID sample, the bootstrap method explores the
    possibility that any observed value is as likely as any other observed value.
    Thus, a random sample of size *n* drawn *with replacement* is intuitively expected
    to carry the same information as the actual sample, and we can obtain an estimate
    of the ![Bootstrap – a statistical method](img/00079.jpeg) parameter based on
    this sample. This step can then be repeated a large number of times, and we will
    produce a varied number of estimates of the parameter. Using this distribution
    of estimates, statistical inference can then be performed. A formal description
    of this method is in order.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Efron的方法如下展开。由![Bootstrap – 统计方法](img/00077.jpeg)提供的估计值是一个单一值。给定数据并基于我们有一个独立同分布（IID）样本的假设，自助法（bootstrap
    method）探索了任何观察到的值与任何其他观察到的值一样可能性的可能性。因此，随机抽取的样本大小为*n*，且是**有放回地**抽取的，直观上期望它携带与实际样本相同的信息，我们可以根据这个样本获得![Bootstrap
    – 统计方法](img/00079.jpeg)参数的估计值。然后，这一步骤可以重复进行多次，我们将产生参数的多个估计值。使用这个估计值的分布，然后可以进行统计推断。这种方法的一个正式描述是必要的。
- en: 'Draw a random sample with replacement of size *n* from ![Bootstrap – a statistical
    method](img/00080.jpeg) and denote it by ![Bootstrap – a statistical method](img/00081.jpeg).
    The sample ![Bootstrap – a statistical method](img/00082.jpeg) is referred to
    as the *first bootstrap sample*. Compute the estimate ![Bootstrap – a statistical
    method](img/00083.jpeg) for this sample ![Bootstrap – a statistical method](img/00084.jpeg)
    and denote it by ![Bootstrap – a statistical method](img/00085.jpeg). Repeat the
    steps a large number of times and obtain ![Bootstrap – a statistical method](img/00086.jpeg).
    The inference for ![Bootstrap – a statistical method](img/00087.jpeg) can then
    be based on the bootstrap estimates ![Bootstrap – a statistical method](img/00088.jpeg).
    We can put this description in the form of an algorithm:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 从 ![Bootstrap – 统计方法](img/00080.jpeg) 中随机抽取带替换的样本大小 *n*，并用 ![Bootstrap – 统计方法](img/00081.jpeg)
    表示。这个样本 ![Bootstrap – 统计方法](img/00082.jpeg) 被称为 *第一个 bootstrap 样本*。计算这个样本 ![Bootstrap
    – 统计方法](img/00084.jpeg) 的估计值 ![Bootstrap – 统计方法](img/00083.jpeg)，并用 ![Bootstrap
    – 统计方法](img/00085.jpeg) 表示。重复执行步骤多次，并得到 ![Bootstrap – 统计方法](img/00086.jpeg)。然后，![Bootstrap
    – 统计方法](img/00087.jpeg) 的推断可以基于 bootstrap 估计值 ![Bootstrap – 统计方法](img/00088.jpeg)。我们可以将这个描述以算法的形式表示：
- en: Given data ![Bootstrap – a statistical method](img/00089.jpeg), the parameter
    of interest ![Bootstrap – a statistical method](img/00090.jpeg), calculate the
    estimate ![Bootstrap – a statistical method](img/00091.jpeg).
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给定数据 ![Bootstrap – 统计方法](img/00089.jpeg)，感兴趣的参数 ![Bootstrap – 统计方法](img/00090.jpeg)，计算估计值
    ![Bootstrap – 统计方法](img/00091.jpeg)。
- en: Draw a bootstrap sample of size *n* with replacement from ![Bootstrap – a statistical
    method](img/00092.jpeg), and denote it by ![Bootstrap – a statistical method](img/00093.jpeg).
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 ![Bootstrap – 统计方法](img/00092.jpeg) 中随机抽取带替换的样本大小 *n*，并用 ![Bootstrap – 统计方法](img/00093.jpeg)
    表示。
- en: Calculate the statistic ![Bootstrap – a statistical method](img/00094.jpeg)
    for the bootstrap sample.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算bootstrap样本的统计量 ![Bootstrap – 统计方法](img/00094.jpeg)。
- en: Repeat *Repeat Steps 2 and 3 'B – 1'* number of times to produce ![Bootstrap
    – a statistical method](img/00095.jpeg).
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复执行 *重复步骤 2 和 3 'B – 1'* 的次数以生成 ![Bootstrap – 统计方法](img/00095.jpeg)。
- en: Use ![Bootstrap – a statistical method](img/00096.jpeg) to carry out the statistical
    inference related to ![Bootstrap – a statistical method](img/00097.jpeg).
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 ![Bootstrap – 统计方法](img/00096.jpeg) 来执行与 ![Bootstrap – 统计方法](img/00097.jpeg)
    相关的统计推断。
- en: 'What does *Step 5* convey here? We have each of the ![Bootstrap – a statistical
    method](img/00098.jpeg) values estimate the parameter of interest, *B* estimates
    to be precise. Since the estimate (based on the sample) is ![Bootstrap – a statistical
    method](img/00099.jpeg), we (intuitively) expect that the average of the bootstrap
    estimates ![Bootstrap – a statistical method](img/00100.jpeg) will be very close
    to ![Bootstrap – a statistical method](img/00101.jpeg), hence the variance of
    the bootstrap estimates also gives a ''good'' measure of the variance of the estimator
    too. The bootstrap mean and standard deviation are then computed as the following:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的 *步骤 5* 传达了什么？我们使用每个 ![Bootstrap – 统计方法](img/00098.jpeg) 的值来估计感兴趣的参数 *B*，估计值要精确。由于估计（基于样本）是
    ![Bootstrap – 统计方法](img/00099.jpeg)，我们（直观上）预期 bootstrap 估计值的平均值 ![Bootstrap –
    统计方法](img/00100.jpeg) 将非常接近 ![Bootstrap – 统计方法](img/00101.jpeg)，因此 bootstrap 估计值的标准差也提供了对估计值方差的“良好”度量。然后计算
    bootstrap 均值和标准差如下：
- en: '![Bootstrap – a statistical method](img/00102.jpeg)![Bootstrap – a statistical
    method](img/00103.jpeg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![Bootstrap – 统计方法](img/00102.jpeg)![Bootstrap – 统计方法](img/00103.jpeg)'
- en: Using ![Bootstrap – a statistical method](img/00104.jpeg) and ![Bootstrap –
    a statistical method](img/00105.jpeg), we can carry out inference for ![Bootstrap
    – a statistical method](img/00106.jpeg).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 ![Bootstrap – 统计方法](img/00104.jpeg) 和 ![Bootstrap – 统计方法](img/00105.jpeg)，我们可以对
    ![Bootstrap – 统计方法](img/00106.jpeg) 进行推断。
- en: It should be noted that the bootstrap method is a very generic algorithm, and
    the execution of this is illustrated to address occasions when faced with certain
    interesting problems.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意的是，bootstrap 方法是一个非常通用的算法，这里的执行示例是为了说明面对某些有趣问题时的情况。
- en: The idea of sampling with replacement needs to be elucidated here. For the purpose
    of simplicity, assume that we have only five observations, for example ![Bootstrap
    – a statistical method](img/00107.jpeg). Now, when we draw the first bootstrap
    sample with a replacement size of 5, we might get the labels *2*, *4*, *4*, *1*,
    *3*. This means that, from the original sample, we select ![Bootstrap – a statistical
    method](img/00108.jpeg), and consequently the observations labeled *2*, *1*, and
    *3* are selected once and *4* is selected twice. This is the same as ![Bootstrap
    – a statistical method](img/00109.jpeg). In the bootstrap notation, it would be
    ![Bootstrap – a statistical method](img/00110.jpeg). The second bootstrap might
    be ![Bootstrap – a statistical method](img/00111.jpeg), and the third might be
    ![Bootstrap – a statistical method](img/00112.jpeg), and so on.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 需要在此阐明有放回抽样的概念。为了简化，假设我们只有五个观测值，例如![自助法 – 一种统计方法](img/00107.jpeg)。现在，当我们用5个有放回样本的大小抽取第一个自助样本时，我们可能会得到标签*2*、*4*、*4*、*1*、*3*。这意味着，从原始样本中，我们选择了![自助法
    – 一种统计方法](img/00108.jpeg)，因此标签为*2*、*1*和*3*的观测值各被选中一次，而*4*被选中两次。这与![自助法 – 一种统计方法](img/00109.jpeg)相同。在自助法符号中，它将是![自助法
    – 一种统计方法](img/00110.jpeg)。第二个自助样本可能是![自助法 – 一种统计方法](img/00111.jpeg)，第三个可能是![自助法
    – 一种统计方法](img/00112.jpeg)，依此类推。
- en: 'Next, we will illustrate this technique and clarify its implementation. The
    bootstrap method will be applied to two problems:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将阐述这一技术并阐明其实现方法。我们将应用自助法解决两个问题：
- en: Standard error of correlation coefficient
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相关系数的标准误差
- en: Eigenvalue of the covariance/correlation matrix
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协方差/相关矩阵的特征值
- en: The standard error of correlation coefficient
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关系数的标准误差
- en: Consider a hypothetical scenario where we are trying to study the relationship
    between two variables. The historical information, intuition, and scatterplot
    all align, showing that there is a linear relationship between the two variables,
    and the only problem is that the histogram of each of the two variables suggests
    a shape that is anything but a bell shape. In other words, the assumption of normal
    distribution looks very unlikely, and since it fails in the univariate cases (of
    each variable), the analyst is skeptical about the joint bivariate normality holding
    true for the two variables.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个假设场景，我们试图研究两个变量之间的关系。历史信息、直觉和散点图都一致，表明两个变量之间存在线性关系，唯一的问题是每个变量的直方图都呈现出非钟形形状。换句话说，正态分布的假设看起来非常不可能，并且由于它在单变量情况（每个变量）中失败，分析师对两个变量的联合双变量正态性持怀疑态度。
- en: 'Let ![The standard error of correlation coefficient](img/00113.jpeg) be *n*
    pairs of observations. The sample correlation coefficient is easily calculated
    using the following formula:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 设![相关系数的标准误差](img/00113.jpeg)为*n*对观测值。样本相关系数可以通过以下公式轻松计算：
- en: '![The standard error of correlation coefficient](img/00114.jpeg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![相关系数的标准误差](img/00114.jpeg)'
- en: Here we have ![The standard error of correlation coefficient](img/00115.jpeg).
    An estimate of any parameter is no good if we can't carry out the relevant statistical
    inference. A confidence interval suffices with the relevant results to perform
    the statistical inference. We will now learn how the bootstrap method helps us
    to do that. We will use the vector notation to maintain consistency, and toward
    this define ![The standard error of correlation coefficient](img/00116.jpeg),
    that is, ![The standard error of correlation coefficient](img/00117.jpeg) is a
    vector now. The first bootstrap sample is obtained by selecting n pairs of observations
    randomly and with replacement, and we will denote the first bootstrap sample by
    ![The standard error of correlation coefficient](img/00118.jpeg). Now, using the
    bootstrap sample, we will estimate the correlation coefficient by ![The standard
    error of correlation coefficient](img/00119.jpeg). Repeating the process of obtaining
    the bootstrap samples *B – 1* more times, we will compute the correlation coefficients
    ![The standard error of correlation coefficient](img/00120.jpeg).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们有 ![相关系数的标准误差](img/00115.jpeg)。如果我们无法进行相关的统计推断，任何参数的估计都是没有用的。一个置信区间就足以提供相关结果以进行统计推断。我们将学习如何通过自助法帮助我们做到这一点。我们将使用向量符号来保持一致性，并为此定义
    ![相关系数的标准误差](img/00116.jpeg)，即 ![相关系数的标准误差](img/00117.jpeg) 现在是一个向量。第一个自助样本是通过随机选择
    n 对观测值并重复选择得到的，我们将第一个自助样本表示为 ![相关系数的标准误差](img/00118.jpeg)。现在，使用自助样本，我们将通过 ![相关系数的标准误差](img/00119.jpeg)
    来估计相关系数。重复获取自助样本的过程 *B – 1* 更多次，我们将计算相关系数 ![相关系数的标准误差](img/00120.jpeg)。
- en: 'The law school data is used here, drawn from Table 3.1 of Efron and Tibshirani
    (1990, p.19). In this study, fifteen schools are randomly selected from a pool
    of 82 law schools. Two variables measured for the schools include the average
    score for the class on a national law test (LSAT) and the average undergraduate
    grade point (GPA). We will first import the data from the CSV file, display it,
    and then visualize the histograms of the two variables along with the scatterplot:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用的是法学院数据，来自 Efron 和 Tibshirani (1990, p.19) 的第 3.1 表。在这项研究中，从 82 所法学院中随机选择了
    15 所学校。对学校测量的两个变量包括班级在国家法律考试（LSAT）上的平均分数和平均本科成绩点（GPA）。我们首先从 CSV 文件导入数据，显示它，然后可视化两个变量的直方图以及散点图：
- en: '[PRE4]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We will look at the code first. The `read.csv` file helps in importing the
    dataset from the chapter''s `Data` folder, as unzipped from the code bundle and
    stored in the `LS` object. The `LS` is then displayed in the console. Here, we
    give the first and last three observations. The `windows` function creates a new
    graphical device with specified `height` and `weight`. Note that this function
    will only work on the Windows OS. Next, we specify the `layout` for the graphical
    device. To confirm that it''s working, running the line `matrix(c(1,2,3,3),byrow=TRUE,
    nrow=2)` in R terminal gives the following result:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先查看代码。`read.csv` 文件有助于从章节的 `Data` 文件夹导入数据集，该数据集已从代码包中解压并存储在 `LS` 对象中。然后 `LS`
    在控制台中显示。在这里，我们给出前三个和最后三个观测值。`windows` 函数创建一个具有指定 `height` 和 `weight` 的新图形设备。请注意，此函数仅在
    Windows 操作系统上工作。接下来，我们指定图形设备的 `layout`。为了确认其工作状态，在 R 终端运行 `matrix(c(1,2,3,3),byrow=TRUE,
    nrow=2)` 行会得到以下结果：
- en: '[PRE5]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This means that the first graphical output, as a consequence of running any
    code that results in a graph, is displayed in region 1 (upper left) of the device.
    The second graphical output is displayed in the right upper part, while the third
    will be spread across the lower part. It is a convenient manipulation for visual
    displays. The histogram of the two variables does not suggest normal distribution,
    though it may be argued that the number of observations is much less; fifteen,
    in this case. However, the scatter plot suggests that as `LSAT` increases, the
    `GPA` does too. Consequently, the correlation coefficient is a meaningful measure
    of the linear relationship between the two variables. However, the normal distribution
    assumption is not suitable here, or at least we need more observations that are
    not available as of now, and hence it remains a challenge to carry out the statistical
    inference. To overcome this, we will use the bootstrap technique. Take a look
    at the following figure:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着运行任何产生图形的代码后的第一个图形输出显示在设备的区域1（左上角）。第二个图形输出显示在右上部分，而第三个将分布在下半部分。这对于视觉显示来说是一种方便的操作。两个变量的直方图并不表明呈正态分布，尽管可能会争辩说观测数量要少得多；在这种情况下是十五。然而，散点图表明，随着`LSAT`的增加，`GPA`也增加。因此，相关系数是衡量两个变量之间线性关系的有意义的度量。然而，正态分布的假设在这里不适用，或者至少我们需要更多的观测数据，而这些数据目前尚未获得，因此进行统计推断仍然是一个挑战。为了克服这一点，我们将使用自举技术。看看下面的图：
- en: '![The standard error of correlation coefficient](img/00121.jpeg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![相关系数的标准误差](img/00121.jpeg)'
- en: 'Figure 1: LSAT and GPA variables visualization'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图1：LSAT和GPA变量可视化
- en: 'Imitating Efron and Tibshirani''s illustration, we fix the number of bootstrap
    samples at 3200, and we will be interested when the number of bootstrap samples
    is at 25, 50, 100, 200, 400, 800, 1600, and 3200\. The R program approach is as
    follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 模仿Efron和Tibshirani的插图，我们将自举样本的数量固定在3200，我们将对自举样本数量为25、50、100、200、400、800、1600和3200的情况感兴趣。R程序方法如下：
- en: After finding the number of observations, fixing the number of bootstrap samples,
    and bootstrap samples of interest, we will initialize the bootstrap mean and standard
    vector.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在找到观测数量、固定自举样本数量和感兴趣的样本之后，我们将初始化自举均值和标准向量。
- en: For the purpose of replicating the results, we will fix the initial seed at
    54321\. The seed will be stepped up by an increment of 1 for obtaining the bootstrap
    sample, which will ensure that all the bootstrap samples are different.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了复制结果，我们将初始种子值固定为54321。种子值将增加1以获得自举样本，这将确保所有自举样本都是不同的。
- en: The value of the correlation coefficient is computed for each of the bootstrap
    samples, and thus we will have B = 3200 correlation coefficients.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算了每个自举样本的相关系数值，因此我们将有B = 3200个相关系数。
- en: The mean and standard deviation of the correlation coefficients up to the desired
    number of bootstrap samples is calculated.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算了达到所需自举样本数量的相关系数的均值和标准差。
- en: For comparisons with Efron and Tibshirani (1990, p.50), the results are reported
    for bootstrap samples 25, 50, 100, 200, 400, 800, 1600, and 3200.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了与Efron和Tibshirani（1990，第50页）进行比较，报告了25、50、100、200、400、800、1600和3200个自举样本的结果。
- en: 'The R program along with the output is given next:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 下文给出了R程序及其输出：
- en: '[PRE6]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The time series plot is displayed as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 时间序列图如下所示：
- en: '![The standard error of correlation coefficient](img/00122.jpeg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![相关系数的标准误差](img/00122.jpeg)'
- en: 'Figure 2: The nonparametric bootstrap standard error for correlation coefficient'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图2：相关系数的非参数自举标准误差
- en: 'The standard error of the correlation coefficient can be seen to stabilize
    at around `0.13`. Finally, to carry out the statistical inference, we can use
    the bootstrap confidence intervals. A `naïve` method is to simply obtain the 95%
    coverage of the correlation coefficient estimates in the bootstrap samples. This
    is easily achieved in the software. We will use the quantile function to achieve
    the result, as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 相关系数的标准误差可以看到稳定在大约`0.13`。最后，为了进行统计推断，我们可以使用自举置信区间。一种`天真`的方法是简单地从自举样本中获得相关系数估计的95%覆盖范围。这在软件中很容易实现。我们将使用分位数函数来实现结果，如下所示：
- en: '[PRE7]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We have learned how to carry out statistical inference using the bootstrap technique.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学会了如何使用自举技术进行统计推断。
- en: One of the main reasons for carrying out the bootstrap method here is that we
    can't assume bivariate normal distribution for the LSAT and GPA variables. Now,
    if we are told that the distribution of LSAT and GPA historically follows bivariate
    normal distribution, then technically the probability distribution of the sample
    correlation coefficient ![The standard error of correlation coefficient](img/00123.jpeg)
    can be derived. However, as a practitioner, suppose that you are unable to derive
    the probability distribution of the sample correlation coefficient. How do you
    then carry out the statistical inference? Using the same technique as discussed
    here might seem tempting. We will continue to explore this matter in the next
    subsection.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里执行引导方法的一个主要原因是，我们不能假设LSAT和GPA变量服从双变量正态分布。现在，如果我们被告知LSAT和GPA的历史分布遵循双变量正态分布，那么从技术上讲，可以推导出样本相关系数
    ![相关系数的标准误差](img/00123.jpeg) 的概率分布。然而，作为一个从业者，假设你无法推导出样本相关系数的概率分布。那么你将如何进行统计推断？使用此处讨论的相同技术可能看起来很有吸引力。我们将在下一小节继续探讨这个问题。
- en: The parametric bootstrap
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参数引导
- en: As mentioned in the previous subsection, it might be tempting to carry out the
    usual *nonparametric* bootstrap method. However, nonparametric methods are traditionally
    known to be somewhat inefficient compared with the parametric methods. We will
    now look at a mixture of both of these methods.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一小节所述，执行常规的 *非参数* 引导方法可能很有吸引力。然而，非参数方法与参数方法相比，传统上被认为效率较低。我们现在将探讨这两种方法的混合。
- en: 'We have seen that the bootstrap method relies heavily on the resamples. The
    bootstrap samples and the consequent estimates are then expected to meet the true
    underlying probability distributions. However, we might occasionally know more
    about the shape of the underlying probability distributions, except for a few
    parameters. The approach for mixing up these two methods will require a modification.
    The parametric bootstrap method is set up and run as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，引导方法在很大程度上依赖于重采样。因此，引导样本及其后续估计预计将符合真实的潜在概率分布。然而，我们可能偶尔会更多地了解潜在概率分布的形状，除了几个参数之外。混合这两种方法的方法需要修改。参数引导方法设置和运行如下：
- en: Let ![The parametric bootstrap](img/00124.jpeg) be the IID sample from ![The
    parametric bootstrap](img/00125.jpeg), and let ![The parametric bootstrap](img/00126.jpeg)
    denote an estimator of the parameter based on an appropriate method, say maximum
    likelihood estimation or method of moments, for example.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 令 ![参数引导](img/00124.jpeg) 为来自 ![参数引导](img/00125.jpeg) 的独立同分布样本，令 ![参数引导](img/00126.jpeg)
    表示基于适当方法的参数估计器，例如最大似然估计或矩估计法。
- en: Simulate the first bootstrap sample ![The parametric bootstrap](img/00127.jpeg)
    of size *n* from ![The parametric bootstrap](img/00128.jpeg), and obtain the first
    bootstrap estimate ![The parametric bootstrap](img/00129.jpeg) based on ![The
    parametric bootstrap](img/00130.jpeg) using the same estimation technique as used
    in the previous step.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 ![参数引导](img/00128.jpeg) 模拟大小为 *n* 的第一个引导样本 ![参数引导](img/00127.jpeg)，并使用与上一步相同的估计技术，基于
    ![参数引导](img/00130.jpeg) 获得第一个引导估计 ![参数引导](img/00129.jpeg)。
- en: Repeat the previous step *B – 1* number of times to obtain ![The parametric
    bootstrap](img/00131.jpeg) respectively, based on the bootstrap samples ![The
    parametric bootstrap](img/00132.jpeg).
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重复执行上一步 *B – 1* 次以分别获得 ![参数引导](img/00131.jpeg)，基于引导样本 ![参数引导](img/00132.jpeg)。
- en: Carry out the inference based on the *B* bootstrap estimates ![The parametric
    bootstrap](img/00133.jpeg).
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于参数 *B* 的引导估计 ![参数引导](img/00133.jpeg) 进行推断。
- en: 'The parametric bootstrap technique will be illustrated using the earlier example
    of `LSAT` and `GPA` variables. For the bivariate normal distribution, the mean
    vector is an estimator of the population mean, and it enjoys statistical properties
    as being the unbiased estimator and MLE. Similarly, the sample variance-covariance
    matrix also gives an important estimate of the population variance-covariance
    matrix. The `colMeans` is applied on the data frame to obtain the vector mean
    and the `var` function to compute the sample variance-covariance matrix. The R
    code block easily follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 参数自举技术将通过先前的`LSAT`和`GPA`变量的例子来展示。对于二元正态分布，均值向量是总体均值的估计量，它具有无偏估计量和MLE的统计特性。同样，样本方差-协方差矩阵也给出了对总体方差-协方差矩阵的重要估计。在数据框上应用`colMeans`以获得向量均值，并使用`var`函数来计算样本方差-协方差矩阵。R代码块很容易跟随：
- en: '[PRE8]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Thus, we have the mean and variance-covariance matrix estimators. We now look
    at the parametric bootstrap computations. Now, using the `rmvnorm` function from
    the `mvtnorm` package, we are able to simulate observations from a multivariate
    (bivariate) normal distribution. With the (parametric) bootstrap sample available,
    the rest of the program and conclusion is similar. The complete R program with
    the resulting diagram is as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有了均值和方差-协方差矩阵估计量。现在我们来看参数自举的计算。现在，使用`mvtnorm`包中的`rmvnorm`函数，我们能够从多变量（二元）正态分布中模拟观测值。有了（参数）自举样本，程序和结论的其余部分是相似的。完整的R程序和结果图如下：
- en: '[PRE9]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The difference between parametric and nonparametric bootstrap can easily be
    seen. The confidence intervals are very short, and the standard error decreases
    to zero as the number of bootstrap samples increases. In spite of the advantage,
    we generally need bootstrap methods when the parametric methods fail. Take a look
    at the following figure:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 参数自举和非参数自举之间的差异很容易看出。置信区间非常短，随着自举样本数量的增加，标准误差降低到零。尽管有优势，但我们通常在参数方法失败时需要自举方法。看看下面的图：
- en: '![The parametric bootstrap](img/00134.jpeg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![参数自举](img/00134.jpeg)'
- en: 'Figure 3: The parametric bootstrap standard error for correlation coefficient'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图3：相关系数的参数自举标准误差
- en: Next, we will consider a slightly complex problem for the application of the
    bootstrap method.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将考虑一个稍微复杂的问题，用于自举方法的应用。
- en: Eigen values
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特征值
- en: Multivariate statistics is the arm of Statistics which deals with a vector of
    random variables. In the previous example, we have bivariate data, where LSAT
    and GPA scores are obtained for fifteen schools. Now we will consider another
    example, where we have more than two variables; namely we have five observations
    here. The description and bootstrap technique-related details are drawn from [Chapter
    7](part0051_split_000.html#1GKCM1-2006c10fab20488594398dc4871637ee "Chapter 7. The
    General Ensemble Technique"), *The General Ensemble Technique*, of Efron and Tibshirani
    (1990). The chapter discusses the score data from the classic multivariate book
    by Mardia, Kent, and Bibby (1979).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 多变量统计是统计学的一个分支，它处理随机变量的向量。在先前的例子中，我们有二元数据，其中为十五所学校获得了LSAT和GPA分数。现在我们将考虑另一个例子，其中我们有多于两个变量；也就是说，这里有五个观测值。描述和自举技术相关的细节来自Efron和Tibshirani
    (1990)的《一般集成技术》第7章，[第7章](part0051_split_000.html#1GKCM1-2006c10fab20488594398dc4871637ee
    "第7章。一般集成技术")，该章节讨论了Mardia, Kent, 和 Bibby (1979)的经典多变量书籍中的得分数据。
- en: A quick brief of notation is as follows. We will denote the vector of random
    variables by ![Eigen values](img/00135.jpeg), and for the *ith* observation, the
    vector will be ![Eigen values](img/00136.jpeg). Here, each component *Xi* is assumed
    to be a continuous random variable. Most often, and for practical and theoretical
    purposes, we assume that the random vector follows a multivariate normal distribution
    with mean vector ![Eigen values](img/00137.jpeg) and variance-covariance matrix
    ![Eigen values](img/00138.jpeg). Since it is not feasible to go into the details
    of multivariate statistics here, the interested reader might simply consult Mardia,
    Kent, and Bibby (1979).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 符号的简要说明如下。我们将用![特征值](img/00135.jpeg)表示随机变量的向量，对于第*i*个观测值，向量将是![特征值](img/00136.jpeg)。在这里，每个分量*Xi*被假定为连续随机变量。通常，出于实际和理论目的，我们假设随机向量遵循具有均值向量![特征值](img/00137.jpeg)和方差-协方差矩阵![特征值](img/00138.jpeg)的多变量正态分布。由于在这里无法详细介绍多变量统计，感兴趣的读者可以简单地查阅Mardia,
    Kent, 和 Bibby (1979)的著作。
- en: 'In this example, *n = 88* students'' scores are noted for the five subjects
    of mechanics, vectors, algebra, analysis, and statistics, and a further difference
    in the test is that the first two subjects, mechanics and vectors, were closed-book
    tests while algebra, analysis, and statistics were open-book exams. We will first
    perform the simple preliminary task here of calculating the mean vector, the variance-covariance
    matrix, and the correlation matrix:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，*n = 88*名学生的五门科目（力学、向量、代数、分析和统计学）的分数被记录下来，并且测试的一个进一步差异是，前两门科目（力学和向量）是闭卷考试，而代数、分析和统计学是开卷考试。我们首先在这里执行一个简单的初步任务，即计算均值向量、方差-协方差矩阵和相关性矩阵：
- en: '[PRE10]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here, the data is imported from a `.csv` file, and using the `colMeans`, `cov`,
    and `cor` functions, we obtain the mean vector, variance-covariance matrix, and
    correlation matrix. Clearly, we can see from the output of the correlation matrix
    that a strong association exists between all variables. The visual depiction of
    the data is obtained by the `pairs` function, which gives us a matrix of scatter
    plots. This plot is as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，数据是从`.csv`文件导入的，通过使用`colMeans`、`cov`和`cor`函数，我们得到了均值向量、方差-协方差矩阵和相关性矩阵。显然，我们可以从相关性矩阵的输出中看到，所有变量之间存在强烈的关联。数据的可视化描述是通过`pairs`函数获得的，它给我们提供了一个散点图的矩阵。这个图如下所示：
- en: '![Eigen values](img/00139.jpeg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![特征值](img/00139.jpeg)'
- en: 'Figure 4: Matrix of scatter plots for the five subjects scores'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图4：五门科目分数的散点图矩阵
- en: 'Dimensionality reduction is one of the goals of multivariate statistics. Given
    a large number of variables, the intent of dimensionality reduction is to find
    a set of variables that will explain most of the variability in the overall data.
    A method of dimensionality reduction is *principal component analysis*. Here,
    we try to find a new random vector ![Eigen values](img/00140.jpeg), which is a
    *vector of principal components*. Each component of this new random vector is
    some linear combination of the original variables which will achieve two objectives:
    (a) the components ![Eigen values](img/00141.jpeg) will be ordered in the sense
    that the first component will have variance larger than the second, the second
    larger than the third, and so on, and (b) each principal component is uncorrelated
    with the others. The core working of the principal components is tied with the
    `eigen` values of the variance-covariance matrix or the correlation matrix. The
    `eigen` values of the variance-covariance matrix indicates the importance of the
    associated principal components. Consequently, if have p related random variables,
    and the estimated variance-covariance matrix is not singular, the normalized p
    `eigen` values will give us the fraction of the variation explained by the principal
    component. For the purpose of the data, we will explain this here:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 维度降低是多变量统计的一个目标。给定大量变量，维度降低的目的是找到一组变量，这些变量将解释整体数据中的大部分变异性。一种维度降低的方法是*主成分分析*。在这里，我们试图找到一个新随机向量![特征值](img/00140.jpeg)，这是一个*主成分向量*。这个新随机向量的每个分量都是原始变量的某种线性组合，这将实现两个目标：(a)这些特征值![特征值](img/00141.jpeg)将按顺序排列，即第一个分量的方差将大于第二个，第二个大于第三个，依此类推；(b)每个主成分与其他主成分不相关。主成分的核心工作与方差-协方差矩阵或相关性矩阵的`eigen`值相关联。方差-协方差矩阵的`eigen`值表示相关主成分的重要性。因此，如果有p个相关随机变量，并且估计的方差-协方差矩阵不是奇异的，那么归一化的p个`eigen`值将给出由主成分解释的变异性分数。对于数据的目的，我们在这里解释这一点：
- en: '[PRE11]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The first `eigen` value is `686.9898`, the second one is `202.1111`, and so
    on. Now, these values divided by their cumulative sum gives the percentage of
    variation in the data explained by the principal component. Thus, the total variation
    of data explained by the first principal component is 61.91%, while 18.21% is
    explained by the second principal component. Here comes the important question
    then: how do we conduct the statistical inference related to this quantity? Naturally,
    we will provide the answer using the bootstrap method:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个特征值是`686.9898`，第二个是`202.1111`，依此类推。现在，这些值除以它们的累积和给出了由主成分解释的数据变异性百分比。因此，第一个主成分解释的数据总变异性为61.91%，而第二个主成分解释了18.21%。那么，接下来重要的问题是：我们如何进行与这个数量相关的统计推断？自然地，我们将使用自助法来提供答案：
- en: '[PRE12]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '![Eigen values](img/00142.jpeg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![特征值](img/00142.jpeg)'
- en: 'Figure 5: Bootstrap standard error of the variance explained by the first principal
    component'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图5：第一主成分解释的方差bootstrap标准误差
- en: 'The 95% bootstrap confidence interval is obtained in the usual way:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 95%的bootstrap置信区间通常获得：
- en: '[PRE13]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Rule of thumb
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 经验法则
- en: Generally, the number of B = 25 bootstrap replications is enough and one rarely
    requires more than `200` replications. For more information on this, see Efron
    and Tibshirani (1990, p.52).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，B = 25的bootstrap重复次数就足够了，很少需要超过`200`次重复。有关更多信息，请参阅Efron和Tibshirani（1990，第52页）。
- en: Thus far we have used simulation, resampling, and loops to carry out the bootstrap
    inference. However, earlier in the chapter we mentioned the `boot` package. In
    the following section, we will use the package for some samples and illustrate
    its use.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经使用了模拟、重采样和循环来进行bootstrap推断。然而，在章节的早期，我们提到了`boot`包。在下一节中，我们将使用该包进行一些样本，并说明其用法。
- en: The boot package
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: boot包
- en: The `boot` package is one of the core R packages, and it is optimized for the
    implementation of bootstrap methods. In the previous examples, we mostly used
    loops for carrying out the resampling technique. Here, we will look at how to
    use the `boot` R package.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`boot`包是R的核心包之一，它针对bootstrap方法的实现进行了优化。在前面的例子中，我们主要使用循环来进行重采样技术。在这里，我们将看看如何使用`boot`
    R包。'
- en: 'The main structure of the boot function is as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: boot函数的主要结构如下：
- en: '[PRE14]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The central arguments of the function are `data`, `statistic`, `R`, and `stype`.
    The `data` argument is the standard one, as with most R functions. The `statistic`
    is the most important argument for the implementation of the `boot` function and
    it is this function that will be applied on the bootstrap samples obtained from
    the `data` frame. The argument `R` (and not the software) is used to specify the
    number of bootstrap samples to be drawn, and `stype` will indicate the second
    argument of `statistic`. For any inference to be completed using the `boot` function,
    the critical task is to define the function for the statistic. We will continue
    the illustration using earlier examples.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的核心参数是`data`、`statistic`、`R`和`stype`。`data`参数是标准的，就像大多数R函数一样。`statistic`是实现`boot`函数最重要的参数，它将对从数据框中获得的bootstrap样本应用此函数。参数`R`（而不是软件）用于指定要抽取的bootstrap样本数量，而`stype`将指示`statistic`的第二个参数。要使用`boot`函数完成任何推断，关键任务是定义统计量的函数。我们将继续使用早期示例进行说明。
- en: 'In the study of correlation between the `LSAT` and `GPA` variables, the trick
    is to define the function that will include the correlation coefficient function
    and the data with index specified in a manner that will give us the bootstrap
    sample. After declaring the function for the computation of the correlation coefficient
    for the bootstrap sample, we use the boot function, introduce the function, and
    specify the resampling type as well as the number of required bootstrap samples.
    The `boot` function will be in action now:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在研究`LSAT`和`GPA`变量之间的相关性时，技巧是定义一个函数，该函数将包括相关系数函数和以指定方式包含索引的数据，这将给我们提供bootstrap样本。在声明用于计算bootstrap样本相关系数的函数后，我们使用boot函数，引入该函数，并指定所需的bootstrap样本重采样类型。现在`boot`函数将开始工作：
- en: '[PRE15]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The correlation function is defined through `corx`, and the boot function is
    applied on it with the data frame `LS`. The number of bootstrap samples is `200`
    and the resampling will occur until the next iteration. From the preceding output
    we can obtain the value of the statistic as `0.7763745`, the bias as `-0.01791293`,
    and the bootstrap standard error as `0.1357282`. But what about bias? We have
    made almost no mention of bias in our discussion thus far. To understand what
    the bootstrap bias is, we will first look at the components of the fitted `corboot
    boot` object. The value of the statistic, correlation coefficient here, is stored
    as `t0`, the bootstrap sample estimates (`R` of them) in `t`, and using these
    two quantities we will find the bias:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 相关函数通过`corx`定义，并在数据框`LS`上应用boot函数。bootstrap样本的数量为`200`，并且重采样将在下一次迭代之前发生。从前面的输出中，我们可以获得统计量的值为`0.7763745`，偏差为`-0.01791293`，bootstrap标准误差为`0.1357282`。但偏差如何呢？到目前为止，我们在讨论中几乎没有提到偏差。为了理解bootstrap偏差是什么，我们首先将查看拟合的`corboot
    boot`对象组成部分。统计量的值，即这里的相关系数，存储为`t0`，bootstrap样本估计值（其中`R`个）存储在`t`中，使用这两个数量我们将找到偏差：
- en: '[PRE16]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can see how useful the `boot` function is for the applications. The `confint`
    function can be slapped on the `corboot` object to obtain the bootstrap confidence
    interval:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到`boot`函数在应用中的实用性。可以通过将`confint`函数应用到`corboot`对象上来获得自举置信区间：
- en: '[PRE17]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Next, we will apply the `boot` function for the problem of obtaining the confidence
    interval of the variation explained by the first principal component. To that
    end, we first create the necessary `R` function that can be supplied to the boot
    function:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将应用`boot`函数来解决问题，即获得第一主成分解释的变异的置信区间。为此，我们首先创建必要的`R`函数，该函数可以提供给`boot`函数：
- en: '[PRE18]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Thus, the boot package can be effectively used without having the need to write
    loops. We have used the bootstrap method for the main purpose of estimating the
    parameters and their functions. Hypothesis testing based on bootstrap will be
    covered next.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，无需编写循环即可有效地使用boot包。我们使用自举方法的主要目的是估计参数及其函数。接下来将介绍基于自举的假设检验。
- en: Bootstrap and testing hypotheses
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自举与假设检验
- en: 'We begin the bootstrap hypothesis testing problems with the t-test to compare
    means and the F-test to compare variances. It is understood that, since we are
    assuming normal distribution for the two populations under comparison, the distributional
    properties of the test statistics are well known. To carry out the nonparametric
    bootstrap for the t-statistic based on the t-test, we first define the function,
    and then run the bootstrap function boot on the Galton dataset. The Galton dataset
    is available in the `galton data.frame` from the `RSADBE` package. The `galton`
    dataset consists of `928` pairs of observations, with the pair consisting of the
    height of the parent and the height of their child. First, we define the `t2`
    function, load the Galton dataset, and run the boot function as the following
    unfolds:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从t检验来比较均值和F检验来比较方差的自举假设检验问题开始。理解到，由于我们假设比较的两个总体是正态分布，因此测试统计量的分布特性是已知的。为了执行基于t检验的t统计量的非参数自举，我们首先定义函数，然后运行Galton数据集上的bootstrap函数。Galton数据集可在`RSADBE`包的`galton
    data.frame`中找到。`galton`数据集由`928`对观测值组成，每对观测值由父母的身高和孩子的身高组成。首先，我们定义`t2`函数，加载Galton数据集，并按照以下步骤运行boot函数：
- en: '[PRE19]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The reader should compare the bootstrap confidence interval and the confidence
    interval given by the t-statistic.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 读者应比较自举置信区间和由t统计量给出的置信区间。
- en: 'Next, we will carry out the bootstrap hypothesis testing for the variances.
    The variance function is defined for the `var.test` function and it will then
    be used in the `boot` function:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将对方差进行自举假设检验。方差函数是为`var.test`函数定义的，然后它将被用于`boot`函数中：
- en: '[PRE20]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The confidence interval and the bootstrap confidence interval can be compared
    by the reader. The bootstrap methods have been demonstrated for different estimation
    and hypothesis testing scenarios. In the remaining sections, we will consider
    some regression models where we have additional information on the observations
    in terms of the explanatory variables.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 读者可以通过比较置信区间和自举置信区间来比较。自举方法已在不同的估计和假设检验场景中得到了演示。在接下来的部分，我们将考虑一些回归模型，在这些模型中，我们关于解释变量的观测有额外的信息。
- en: Bootstrapping regression models
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自举回归模型
- en: 'The `US Crime` dataset introduced in [Chapter 1](part0012_split_000.html#BE6O2-2006c10fab20488594398dc4871637ee
    "Chapter 1. Introduction to Ensemble Techniques"), *Introduction to Ensemble Techniques*,
    is an example of why the linear regression model might be a good fit. In this
    example, we are interested in understanding the crime rate (R) as a function of
    thirteen related variables such as average age, the southern state indicator,
    and so on. Mathematically, the linear regression model is as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](part0012_split_000.html#BE6O2-2006c10fab20488594398dc4871637ee "第1章。集成技术简介")中引入的`US
    Crime`数据集，*集成技术简介*，是线性回归模型可能是一个好选择的一个例子。在这个例子中，我们感兴趣的是理解犯罪率（R）作为平均年龄、南方州指标等十三个相关变量的函数。从数学上讲，线性回归模型如下：
- en: '![Bootstrapping regression models](img/00143.jpeg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![自举回归模型](img/00143.jpeg)'
- en: 'Here, ![Bootstrapping regression models](img/00144.jpeg) are the p-covariates,
    ![Bootstrapping regression models](img/00145.jpeg) is the intercept term, ![Bootstrapping
    regression models](img/00146.jpeg) are the regression coefficients, and ![Bootstrapping
    regression models](img/00147.jpeg) is the error term assumed to follow a normal
    distribution ![Bootstrapping regression models](img/00148.jpeg). The covariates
    can be written in a vector form and the *ith* observation can be summarized as
    ![Bootstrapping regression models](img/00149.jpeg), where ![Bootstrapping regression
    models](img/00150.jpeg). The *n* observations ![Bootstrapping regression models](img/00151.jpeg),
    are assumed to be stochastically independent. The linear regression model has
    been detailed in many classical regression books; see Draper and Smith (1999),
    for instance. A recent book that details the implementation of the linear regression
    model in R is Ciaburro (2018). As the reader might have guessed, we will now fit
    a linear regression model to the US Crime dataset to kick off the discussion:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，![Bootstrapping regression models](img/00144.jpeg)是p协变量，![Bootstrapping regression
    models](img/00145.jpeg)是截距项，![Bootstrapping regression models](img/00146.jpeg)是回归系数，而![Bootstrapping
    regression models](img/00147.jpeg)是假设服从正态分布![Bootstrapping regression models](img/00148.jpeg)的误差项。协变量可以写成向量形式，第*i*个观测值可以总结为![Bootstrapping
    regression models](img/00149.jpeg)，其中![Bootstrapping regression models](img/00150.jpeg)。*n*个观测值![Bootstrapping
    regression models](img/00151.jpeg)被假设为随机独立。线性回归模型已在许多经典回归书籍中详细阐述；例如，参见Draper和Smith（1999）。最近一本书详细介绍了在R中实现线性回归模型的方法是Ciaburro（2018）。正如读者可能已经猜到的，我们现在将拟合一个线性回归模型到美国犯罪数据集上，以开启讨论：
- en: '[PRE21]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: It can be seen from the `summary` output that a lot of information is displayed
    about the fitted linear regression model. From the output, we can find the estimated
    regression coefficients in `Estimate`. The standard error of these estimators
    is in `Std`. `Error`, the corresponding value of the t-statistic in `t value`,
    and the p-values in `Pr(>|t|)`. We can further estimate the residual standard
    deviation ![Bootstrapping regression models](img/00152.jpeg) in `Residual standard
    error`. Similarly, we can obtain the respective multiple and adjusted R-square
    values in `Multiple R-squared` and `Adjusted R-squared`, the overall F-statistic
    in `F-statistic`, and finally, the model p-value in `p-value`. Many of these statistics/quantities/summaries
    have clean statistical properties and as such, exact statistical inference regarding
    the parameters can be carried out. However, this is not the case for a few of
    them. For instance, if one asks for a confidence interval of the adjusted R-square
    value, the author is not able to recollect the corresponding statistical distribution.
    Hence, using the convenience of the bootstrap technique, we can obtain the bootstrap
    confidence interval for Adjusted R-square. The reason the confidence interval
    of the Adjusted R-square might be sought is that it has a very good interpretation
    of explaining the variance explained in the Y's by the model. Let us look at its
    implementation in the R software.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 从`summary`输出中可以看出，拟合的线性回归模型显示了很多信息。从输出中，我们可以在`Estimate`中找到估计的回归系数。这些估计量的标准误差在`Std.Error`中，t统计量的对应值在`t
    value`中，以及`Pr(>|t|)`中的p值。我们还可以进一步估计残差标准差![Bootstrapping regression models](img/00152.jpeg)在`Residual
    standard error`中。同样，我们可以在`Multiple R-squared`和`Adjusted R-squared`中获得相应的多重和调整R平方值，在`F-statistic`中获得整体F统计量，最后在`p-value`中获得模型p值。许多这些统计数据/数量/摘要具有清晰的统计特性，因此可以就参数进行精确的统计推断。然而，对于其中的一些，情况并非如此。例如，如果要求调整R平方值的置信区间，作者无法回忆起相应的统计分布。因此，利用bootstrap技术的便利性，我们可以获得调整R平方的bootstrap置信区间。寻求调整R平方的置信区间的理由是，它对解释Y的方差有很好的解释。让我们看看它在R软件中的实现。
- en: 'With complex problems there will be many solutions, and none with a proven
    advantage over the other. Nevertheless, we have two main ways of carrying out
    the bootstrap for the linear regression model: (i) bootstrapping the residuals,
    and (ii) bootstrapping the observations. The two methods can work for any general
    regression scenario too. Before we describe the two methods, let ![Bootstrapping
    regression models](img/00153.jpeg) denote the least squares estimated of ![Bootstrapping
    regression models](img/00154.jpeg), and the fitted model will be as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 对于复杂问题，可能会有许多解决方案，但没有一个在理论上优于其他方案。尽管如此，我们有两种主要的方法来对线性回归模型进行自助： (i) 对残差进行自助，和
    (ii) 对观测值进行自助。这两种方法也可以适用于任何一般的回归场景。在我们描述这两种方法之前，让 ![Bootstrapping regression models](img/00153.jpeg)
    表示 ![Bootstrapping regression models](img/00154.jpeg) 的最小二乘估计，拟合的模型如下：
- en: '![Bootstrapping regression models](img/00155.jpeg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![Bootstrapping regression models](img/00155.jpeg)'
- en: 'Consequently, we will also have an estimate of the variance term of the error
    distribution and will denote it by ![Bootstrapping regression models](img/00156.jpeg).
    Define the vector of residual by ![Bootstrapping regression models](img/00157.jpeg).
    The **residual bootstrapping** method is then carried out in the following steps:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们还将有一个误差分布方差项的估计，并用 ![Bootstrapping regression models](img/00156.jpeg) 表示。定义残差向量为
    ![Bootstrapping regression models](img/00157.jpeg)。然后按照以下步骤进行 **残差自助**：
- en: Draw a sample of size *n* with replacement from ![Bootstrapping regression models](img/00158.jpeg)
    and denote it by ![Bootstrapping regression models](img/00159.jpeg).
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 ![Bootstrapping regression models](img/00158.jpeg) 中有放回地抽取大小为 *n* 的样本，并用 ![Bootstrapping
    regression models](img/00159.jpeg) 表示。
- en: For the resampled ![Bootstrapping regression models](img/00159.jpeg), obtain
    the new regressands using ![Bootstrapping regression models](img/00160.jpeg).
    That is, ![Bootstrapping regression models](img/00161.jpeg) is the (first) bootstrap
    sample **Y** value.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于重新采样的 ![Bootstrapping regression models](img/00159.jpeg)，使用 ![Bootstrapping
    regression models](img/00160.jpeg) 获取新的回归量。也就是说，![Bootstrapping regression models](img/00161.jpeg)
    是（第一个）自助样本 **Y** 值。
- en: Using ![Bootstrapping regression models](img/00162.jpeg) and the covariate matrix
    ![Bootstrapping regression models](img/00163.jpeg), obtain the first bootstrap
    estimate of the regression coefficient vector ![Bootstrapping regression models](img/00164.jpeg).
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 ![Bootstrapping regression models](img/00162.jpeg) 和协变量矩阵 ![Bootstrapping
    regression models](img/00163.jpeg)，获得回归系数向量 ![Bootstrapping regression models](img/00164.jpeg)
    的第一个自助估计。
- en: Repeat the process a large number of times, say *B*.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复这个过程很多次，比如说 *B* 次。
- en: Bootstrapping the observations is the usual bootstrapping method, which does
    not require any further explanation. However, the rank of ![Bootstrapping regression
    models](img/00165.jpeg) might be affected, especially if a covariate is a discrete
    variable and only one factor is chosen. Hence, for any regression problem, bootstrapping
    the residual is the best approach.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 对观测值进行自助是通常的自助方法，不需要进一步解释。然而，![Bootstrapping regression models](img/00165.jpeg)
    的秩可能会受到影响，特别是如果协变量是离散变量且只选择了一个因素时。因此，对于任何回归问题，对残差进行自助是最佳方法。
- en: 'The regular `boot` package won''t be useful, and we will instead use the `Boot`
    function from the `car` package to perform the bootstrap analysis on the linear
    regression model. The `Boot` function will also be required to be a specified
    function whose output will give the value of the required statistic. Consequently,
    we will first define a function `f`, which will return the adjusted R-square value:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 常规的 `boot` 包将不会很有用，我们将改用 `car` 包中的 `Boot` 函数来对线性回归模型进行自助分析。`Boot` 函数还需要是一个指定的函数，其输出将给出所需统计量的值。因此，我们首先定义一个函数
    `f`，它将返回调整后的 R 平方值：
- en: '[PRE22]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Thus, a 95% bootstrap confidence interval for the adjusted R-square is `(0.5244243,
    0.7639986)`. Similarly, inference related to any other parameter of the linear
    regression model can be carried out using the bootstrap technique.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，调整后的 R 平方值的 95% 自助置信区间为 `(0.5244243, 0.7639986)`。同样，可以使用自助技术进行与线性回归模型中任何其他参数相关的推断。
- en: Bootstrapping survival models*
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自助生存模型*
- en: In the first section, we looked at the role of pseudovalues in carrying out
    inference related to survival data. The main idea behind the use of pseudovalues
    is to replace the incomplete observations with an appropriate (expected) value
    and then use the flexible framework of the generalized estimating equation. Survival
    analysis and the related specialized methods for it will be detailed in [Chapter
    10](part0070_split_000.html#22O7C2-2006c10fab20488594398dc4871637ee "Chapter 10. Ensembling
    Survival Models"), *Ensembling Survival Models*, of the book. We will briefly
    introduce the notation here as required to set up the parameters. Let *T* denote
    the survival time, or the time to the event of interest, and we naturally have
    ![Bootstrapping survival models*](img/00166.jpeg), which is a continuous random
    variable. Suppose that the lifetime cumulative distribution is F and the associated
    density function is *f*. Since the lifetimes *T* are incomplete for some of the
    observations and subject to censoring, we will not be able to properly infer about
    interesting parameters such as mean survival time or median survival time. Since
    there are additional complications because of censoring, it suffices to note here
    that we will be borrowing heavily from the material in [Chapter 10](part0070_split_000.html#22O7C2-2006c10fab20488594398dc4871637ee
    "Chapter 10. Ensembling Survival Models"), *Ensembling Survival Models*.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一部分，我们探讨了伪值在执行与生存数据相关的推断中的作用。使用伪值的主要思想是用适当的（期望的）值替换不完整的观察值，然后使用广义估计方程的灵活框架。生存分析和与之相关的专用方法将在本书的第10章[Chapter
    10](part0070_split_000.html#22O7C2-2006c10fab20488594398dc4871637ee "第10章。集成生存模型")，*集成生存模型*中详细说明。在此，我们将简要介绍所需的符号，以设置参数。让*T*表示生存时间，或感兴趣事件发生的时间，我们自然有![Bootstrapping
    survival models*](img/00166.jpeg)，这是一个连续随机变量。假设寿命的累积分布是F，相关的密度函数是*f*。由于某些观察值的寿命是不完整的并且受到截尾的影响，我们将无法正确推断关于平均生存时间或中位生存时间等有趣参数。由于截尾存在额外的复杂性，这里只需指出，我们将大量借鉴[第10章](part0070_split_000.html#22O7C2-2006c10fab20488594398dc4871637ee
    "第10章。集成生存模型")，*集成生存模型*中的材料。
- en: Tip
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '* Asterisked sections can be omitted on the first reading, or you can continue
    if you are already familiar with the related concepts and terminologies.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '* 在第一次阅读时，可以省略带星号的部分，或者如果你已经熟悉相关概念和术语，也可以继续阅读。'
- en: The `censboot` function from the `boot` package is developed to handle survival
    data. In the `pbc` dataset, the time to event of interest is the variable named
    `time` and the completeness of the observation is indicated by `status==2`. The
    package `survival` is required to create the `Surv` objects tenable to handle
    the survival data. The `survfit` function would then give us an estimate of the
    survival function, which is the complement of the cumulative distribution function
    1-F. It is well known that the mean of a continuous non-negative random variable
    is ![Bootstrapping survival models*](img/00167.jpeg), and that the median survival
    time is that time point u which satisfies the condition of ![Bootstrapping survival
    models*](img/00168.jpeg). Since the `summary` of the `survfit` object can be used
    to obtain the survival probabilities at the desired time, we will use it to find
    the median survival time. All these arguments are built in the `Med_Surv` function,
    which will return the median survival time.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`boot`包中的`censboot`函数是为了处理生存数据而开发的。在`pbc`数据集中，感兴趣事件发生的时间是名为`time`的变量，而观察的完整性由`status==2`表示。需要`survival`包来创建可以处理生存数据的`Surv`对象。然后`survfit`函数将给出生存函数的估计，这是累积分布函数1-F的补数。众所周知，连续非负随机变量的平均值是![Bootstrapping
    survival models*](img/00167.jpeg)，中位生存时间是满足条件![Bootstrapping survival models*](img/00168.jpeg)的时间点u。由于`survfit`对象的`summary`可以用来获得所需时间的生存概率，我们将使用它来找到中位生存时间。所有这些参数都内置在`Med_Surv`函数中，它将返回中位生存时间。'
- en: 'Using the `Med_Surv` function as the formula/statistic for the `censboot` function,
    we will be able to obtain the bootstrap estimates of the median survival time;
    subsequently, using the bootstrap estimates, we obtain the confidence interval
    for the median survival time. The R program and the output are as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Med_Surv`函数作为`censboot`函数的公式/统计量，我们将能够获得中位生存时间的自助估计；随后，使用自助估计，我们可以获得中位生存时间的置信区间。R程序和输出如下：
- en: '[PRE23]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: For the actual data, the estimated median survival time is `3395` days. The
    95% bootstrap confidence interval for the median survival time is `(3090, 3853)`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 对于实际数据，估计的中位生存时间为`3395`天。中位生存时间的95%自举置信区间为`(3090, 3853)`。
- en: 'To carry out the inference about the mean survival time, we need to use the
    `survmean` function from the `survival` package and appropriately extract the
    estimated mean survival time. The `Mean_Surv` function delivers this task. The
    R program and its output are given here:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 为了对平均生存时间进行推断，我们需要使用来自`survival`包的`survmean`函数，并适当地提取估计的平均生存时间。`Mean_Surv`函数执行这一任务。以下是R程序及其输出：
- en: '[PRE24]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The reader is left with the task of obtaining the bootstrap confidence interval
    for the mean survival time. The following section will discuss using the bootstrap
    method for time series data.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 读者需要完成的任务是获取平均生存时间的自举置信区间。下一节将讨论使用自举方法对时间序列数据进行处理。
- en: Bootstrapping time series models*
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时间序列模型的自举方法*
- en: 'An example of the time series data was seen in [Chapter 1](part0012_split_000.html#BE6O2-2006c10fab20488594398dc4871637ee
    "Chapter 1. Introduction to Ensemble Techniques"), *Introduction to Ensemble Techniques*,
    in the `New Zealand Overseas` dataset. See [Chapter 10](part0070_split_000.html#22O7C2-2006c10fab20488594398dc4871637ee
    "Chapter 10. Ensembling Survival Models"), *Ensembling Survival Models*, of Tattar
    et al. (2016). Time series is distinctive in that the observations are not stochastically
    independent of each other. For example, the maximum temperature of the day is
    very unlikely to be independent of the previous day''s maximum temperature. However,
    we are likely to believe that the maximum temperature of a block of ten previous
    days is mostly independent of a ten-day block six months ago. Thus, the `bootstrap`
    method is modified to the `block bootstrap` method. The `tsboot` function from
    the `boot` package is useful to bootstrap time series data. The main structure
    of the `tsboot` function appears as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 时间序列数据的一个例子可以在[第1章](part0012_split_000.html#BE6O2-2006c10fab20488594398dc4871637ee
    "第1章。集成技术简介")中找到，即`New Zealand Overseas`数据集中的*集成技术简介*。参见Tattar等人（2016年）的[第10章](part0070_split_000.html#22O7C2-2006c10fab20488594398dc4871637ee
    "第10章。集成生存模型")，*集成生存模型*。时间序列的独特之处在于观测值彼此之间不是随机独立的。例如，一天的最高温度很可能与前一天的最高温度不独立。然而，我们可能会相信，过去十天的最高温度块与六个月前十天的温度块大部分是独立的。因此，`bootstrap`方法被修改为`block
    bootstrap`方法。`boot`包中的`tsboot`函数对自举时间序列数据很有用。`tsboot`函数的主要结构如下：
- en: '[PRE25]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here, `statistic`, `tseries` is the time series data, which is the usual function
    of interest to us. `R` is the number of bootstrap replicates, and `l` is the length
    of the block, which we draw from the time series data. Now, we consider the problem
    of estimating the variance for an autoregressive (AR) time series model and we
    will consider a maximum order, `order.max`, of the AR model at 25\. The `Var.fun`
    function will fit the best AR model and obtain the variance. This function will
    then be fed to the `tsboot` and, using the statistic calculated for each bootstrap
    sample, we will obtain the 95% bootstrap confidence interval:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`statistic`和`tseries`是时间序列数据，这是我们通常感兴趣的功能。`R`是自举重复的次数，`l`是从时间序列数据中抽取的块长度。现在，我们考虑估计自回归（AR）时间序列模型的方差问题，并将考虑AR模型的最大阶数`order.max`为25。`Var.fun`函数将拟合最佳AR模型并获得方差。然后，该函数将被输入到`tsboot`中，并使用为每个自举样本计算的统计量，我们将获得95%的自举置信区间：
- en: '[PRE26]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Consequently, we have been able to apply the bootstrap methods for the time
    series data.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经能够应用自举方法对时间序列数据进行处理。
- en: Summary
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'The main purpose of dealing with the bootstrap method in detail is that it
    lays the foundation for the resampling methods. We began the chapter with a very
    early resampling method: the jackknife method. This method is illustrated for
    the purpose of multiple scenarios, including survival data, which is inherently
    complex. The bootstrap method kicked off for seemingly simpler problems, and then
    we immediately applied it to complex problems, such as principal components and
    regression data. For the regression data, we also illustrated the bootstrap method
    for survival data and time series data. In the next chapter, we will look at the
    central role the bootstrap method plays in resampling decision trees, a quintessential
    machine learning tool.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 详细处理自助法的主要目的是为其在重采样方法中的应用奠定基础。我们本章从一种非常早期的重采样方法开始：Jackknife方法。该方法被用于多个场景的说明，包括生存数据，其本质上很复杂。自助法从看似简单的问题开始，然后我们立即将其应用于复杂问题，例如主成分和回归数据。对于回归数据，我们还展示了自助法在生存数据和时序数据中的应用。在下一章中，我们将探讨自助法在重采样决策树中扮演的核心角色，这是一种典型的机器学习工具。
