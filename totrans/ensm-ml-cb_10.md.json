["```py\n! pip install h2o\n```", "```py\nSuccessfully installed colorama-0.4.1 h2o-3.22.1.2\n```", "```py\nimport pandas as pd\nimport numpy as np\n\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import confusion_matrix, roc_curve, auc\nfrom sklearn import tree\n\nimport h2o\nfrom h2o.estimators.glm import H2OGeneralizedLinearEstimator\nfrom h2o.estimators.random_forest import H2ORandomForestEstimator\nfrom h2o.estimators.gbm import H2OGradientBoostingEstimator\nfrom h2o.grid.grid_search import H2OGridSearch\nfrom h2o.estimators.stackedensemble import H2OStackedEnsembleEstimator\n\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n%matplotlib inline\n```", "```py\n# Initialize H2o\nh2o.init()\n```", "```py\nfrom google.colab import drive\ndrive.mount('/content/drive')\n```", "```py\n# Reading dataset from Google drive\ndf_creditcarddata = h2o.import_file(\"/content/drive/My Drive/Colab Notebooks/UCI_Credit_Card.csv\")\n```", "```py\ndf_creditcarddata.head()\n```", "```py\ndf_creditcarddata.shape\n```", "```py\ndf_creditcarddata.columns\n```", "```py\ndf_creditcarddata.types\n```", "```py\ndf_creditcarddata['default.payment.next.month'].table()\n```", "```py\ndf_creditcarddata = df_creditcarddata.drop([\"ID\"], axis = 1) \n```", "```py\nimport pylab as pl\ndf_creditcarddata[['AGE','BILL_AMT1','BILL_AMT2','BILL_AMT3','BILL_AMT4','BILL_AMT5','BILL_AMT6', 'LIMIT_BAL']].as_data_frame().hist(figsize=(20,20))\npl.show()\n```", "```py\n# Defaulters by Gender\ncolumns = [\"default.payment.next.month\",\"SEX\"]\ndefault_by_gender = df_creditcarddata.group_by(by=columns).count(na =\"all\")\nprint(default_by_gender.get_frame())\n\n# Defaulters by education\ncolumns = [\"default.payment.next.month\",\"EDUCATION\"]\ndefault_by_education = df_creditcarddata.group_by(by=columns).count(na =\"all\")\nprint(default_by_education.get_frame())\n\n# Defaulters by MARRIAGE\ncolumns = [\"default.payment.next.month\",\"MARRIAGE\"]\ndefault_by_marriage = df_creditcarddata.group_by(by=columns).count(na =\"all\")\nprint(default_by_marriage.get_frame())\n```", "```py\n# Convert the categorical variables into factors\n\ndf_creditcarddata['SEX'] = df_creditcarddata['SEX'].asfactor()\ndf_creditcarddata['EDUCATION'] = df_creditcarddata['EDUCATION'].asfactor()\ndf_creditcarddata['MARRIAGE'] = df_creditcarddata['MARRIAGE'].asfactor()\ndf_creditcarddata['PAY_0'] = df_creditcarddata['PAY_0'].asfactor()\ndf_creditcarddata['PAY_2'] = df_creditcarddata['PAY_2'].asfactor()\ndf_creditcarddata['PAY_3'] = df_creditcarddata['PAY_3'].asfactor()\ndf_creditcarddata['PAY_4'] = df_creditcarddata['PAY_4'].asfactor()\ndf_creditcarddata['PAY_5'] = df_creditcarddata['PAY_5'].asfactor()\ndf_creditcarddata['PAY_6'] = df_creditcarddata['PAY_6'].asfactor()\n```", "```py\n# Also, encode the binary response variable as a factor\ndf_creditcarddata['default.payment.next.month'] = df_creditcarddata['default.payment.next.month'].asfactor() \ndf_creditcarddata['default.payment.next.month'].levels()\n```", "```py\n# Define predictors manually\npredictors = ['LIMIT_BAL','SEX','EDUCATION','MARRIAGE','AGE','PAY_0','PAY_2','PAY_3',\\\n 'PAY_4','PAY_5','PAY_6','BILL_AMT1','BILL_AMT2','BILL_AMT3','BILL_AMT4',\\\n 'BILL_AMT5','BILL_AMT6','PAY_AMT1','PAY_AMT2','PAY_AMT3','PAY_AMT4','PAY_AMT5','PAY_AMT6']\n\ntarget = 'default.payment.next.month'\n```", "```py\nsplits = df_creditcarddata.split_frame(ratios=[0.7], seed=1) \n```", "```py\nsplits\n```", "```py\ntrain = splits[0]\ntest = splits[1] \n```", "```py\nGLM_default_settings = H2OGeneralizedLinearEstimator(family='binomial', \\\n                                            model_id='GLM_default',nfolds = 10, \\\n                                            fold_assignment = \"Modulo\", \\\n                                            keep_cross_validation_predictions = True)\n```", "```py\nGLM_default_settings.train(x = predictors, y = target, training_frame = train)\n```", "```py\nGLM_regularized = H2OGeneralizedLinearEstimator(family='binomial', model_id='GLM', \\\n                                                lambda_search=True, nfolds = 10, \\\n                                                fold_assignment = \"Modulo\", \\\n                                                keep_cross_validation_predictions = True)\n\nGLM_regularized.train(x = predictors, y = target, training_frame = train)\n```", "```py\nhyper_parameters = { 'alpha': [0.001, 0.01, 0.05, 0.1, 1.0],\n                     'lambda': [0.001, 0.01, 0.1, 1] }\nsearch_criteria = { 'strategy': \"RandomDiscrete\", 'seed': 1,\n                    'stopping_metric': \"AUTO\",\n                    'stopping_rounds': 5 }\n\nGLM_grid_search = H2OGridSearch(H2OGeneralizedLinearEstimator(family='binomial', \\\n                  nfolds = 10, fold_assignment = \"Modulo\", \\\n                  keep_cross_validation_predictions = True),\\\n                  hyper_parameters, grid_id=\"GLM_grid\", search_criteria=search_criteria)\n\nGLM_grid_search.train(x= predictors,y= target, training_frame=train)\n```", "```py\n# Get the grid results, sorted by validation AUC\nGLM_grid_sorted = GLM_grid_search.get_grid(sort_by='auc', decreasing=True)\nGLM_grid_sorted\n```", "```py\n# Extract the best model from random grid search\nBest_GLM_model_from_Grid = GLM_grid_sorted.model_ids[0]\n\n# model performance\nBest_GLM_model_from_Grid = h2o.get_model(Best_GLM_model_from_Grid)\nprint(Best_GLM_model_from_Grid)\n```", "```py\n# Build a RF model with default settings\nRF_default_settings = H2ORandomForestEstimator(model_id = 'RF_D',\\\n                                nfolds = 10, fold_assignment = \"Modulo\", \\\n                                keep_cross_validation_predictions = True)\n\n# Use train() to build the model\nRF_default_settings.train(x = predictors, y = target, training_frame = train)\n```", "```py\nRF_default_settings.summary()\n```", "```py\nhyper_params = {'sample_rate':[0.7, 0.9],\n                'col_sample_rate_per_tree': [0.8, 0.9],\n                'max_depth': [3, 5, 9],\n                'ntrees': [200, 300, 400]\n               }\n```", "```py\nRF_grid_search = H2OGridSearch(H2ORandomForestEstimator(nfolds = 10, \\\n                             fold_assignment = \"Modulo\", \\\n                             keep_cross_validation_predictions = True, \\\n                             stopping_metric = 'AUC',stopping_rounds = 5), \\\n                             hyper_params = hyper_params, \\\n                             grid_id= 'RF_gridsearch')\n\n# Use train() to start the grid search\nRF_grid_search.train(x = predictors, y = target, training_frame = train)\n```", "```py\n# Sort the grid models\nRF_grid_sorted = RF_grid_search.get_grid(sort_by='auc', decreasing=True)\nprint(RF_grid_sorted)\n```", "```py\nBest_RF_model_from_Grid = RF_grid_sorted.model_ids[0]\n\n# Model performance\nBest_RF_model_from_Grid = h2o.get_model(Best_RF_model_from_Grid) \nprint(Best_RF_model_from_Grid)\n```", "```py\nGBM_default_settings = H2OGradientBoostingEstimator(model_id = 'GBM_default', \\\n                       nfolds = 10, \\\n                       fold_assignment = \"Modulo\", \\\n                       keep_cross_validation_predictions = True)\n\n# Use train() to build the model\nGBM_default_settings.train(x = predictors, y = target, training_frame = train)\n```", "```py\nhyper_params = {'learn_rate': [0.001,0.01, 0.1],\n                'sample_rate': [0.8, 0.9],\n                'col_sample_rate': [0.2, 0.5, 1],\n                'max_depth': [3, 5, 9]}\n```", "```py\nGBM_grid_search = H2OGridSearch(H2OGradientBoostingEstimator(nfolds = 10, \\\n                        fold_assignment = \"Modulo\", \\\n                        keep_cross_validation_predictions = True,\\\n                        stopping_metric = 'AUC', stopping_rounds = 5),\n                        hyper_params = hyper_params, grid_id= 'GBM_Grid')\n\n# Use train() to start the grid search\nGBM_grid_search.train(x = predictors, y = target, training_frame = train)\n```", "```py\n# Sort and show the grid search results\nGBM_grid_sorted = GBM_grid_search.get_grid(sort_by='auc', decreasing=True)\nprint(GBM_grid_sorted)\n```", "```py\nBest_GBM_model_from_Grid = GBM_grid_sorted.model_ids[0]\n\nBest_GBM_model_from_Grid = h2o.get_model(Best_GBM_model_from_Grid) \nprint(Best_GBM_model_from_Grid)\n```", "```py\n# list the best models from each grid\nall_models = [Best_GLM_model_from_Grid, Best_RF_model_from_Grid, Best_GBM_model_from_Grid]\n```", "```py\n# Set up Stacked Ensemble\nensemble = H2OStackedEnsembleEstimator(model_id = \"ensemble\", base_models = all_models, metalearner_algorithm = \"deeplearning\")\n\n# uses GLM as the default metalearner\nensemble.train(y = target, training_frame = train)\n```", "```py\n# Eval ensemble performance on the test data\nEns_model = ensemble.model_performance(test)\nEns_AUC = Ens_model.auc()\n```", "```py\n# Checking the model performance for all GLM models built\nmodel_perf_GLM_default = GLM_default_settings.model_performance(test)\nmodel_perf_GLM_regularized = GLM_regularized.model_performance(test)\nmodel_perf_Best_GLM_model_from_Grid = Best_GLM_model_from_Grid.model_performance(test)\n```", "```py\n# Checking the model performance for all RF models built\nmodel_perf_RF_default_settings = RF_default_settings.model_performance(test)\nmodel_perf_Best_RF_model_from_Grid = Best_RF_model_from_Grid.model_performance(test)\n```", "```py\n# Checking the model performance for all GBM models built\nmodel_perf_GBM_default_settings = GBM_default_settings.model_performance(test)\nmodel_perf_Best_GBM_model_from_Grid = Best_GBM_model_from_Grid.model_performance(test)\n```", "```py\n# Best AUC from the base learner models\nbest_auc = max(model_perf_GLM_default.auc(), model_perf_GLM_regularized.auc(), \\\n model_perf_Best_GLM_model_from_Grid.auc(), \\\n model_perf_RF_default_settings.auc(), \\\n model_perf_Best_RF_model_from_Grid.auc(), \\\n model_perf_GBM_default_settings.auc(), \\\n model_perf_Best_GBM_model_from_Grid.auc())\n\nprint(\"Best AUC out of all the models performed: \", format(best_auc))\n```", "```py\n# Eval ensemble performance on the test data\nEnsemble_model = ensemble.model_performance(test)\nEnsemble_model = Ensemble_model.auc()\n```"]