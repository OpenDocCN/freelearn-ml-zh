- en: 'Chapter 10: Exploring Time Series Analysis'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章：探索时间序列分析
- en: In the previous chapter, we discussed using deep learning and its robust applicability
    when it comes to unstructured data in the form of natural language – a type of
    sequential data. Another type of sequential data that we will now turn our attention
    to is time series data. We can think of time series data as being standard datasets
    yet containing a time-based feature, thus unlocking a new set of possibilities
    when it comes to developing predictive models.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了使用深度学习及其在处理自然语言这种非结构化数据时的强大适用性——一种序列数据。我们现在将关注的另一种序列数据是时间序列数据。我们可以将时间序列数据视为标准数据集，但包含基于时间的特征，从而在开发预测模型时开启了一组新的可能性。
- en: One of the most common applications in time series data is a process known as
    time series analysis. We can define time series analysis as an area of data **exploration**
    and **forecasting** in which datasets are ordered or indexed using a particular
    **time interval** or **timestamp**. There are many examples of time series data
    that we encounter in the biotechnology and life sciences industries daily. Some
    of the more laboratory-based areas of focus include gene expression and chromatography,
    as well as non-lab areas such as demand forecasting and stock price analysis.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 时间序列数据中最常见的一个应用是一个称为时间序列分析的过程。我们可以将时间序列分析定义为数据**探索**和**预测**的一个领域，其中数据集是按照特定的**时间间隔**或**时间戳**进行排序或索引的。我们在生物技术和生命科学行业中每天都会遇到许多时间序列数据的例子。一些更侧重于实验室的领域包括基因表达和色谱法，以及非实验室领域，如需求预测和股价分析。
- en: Throughout this chapter, we will explore several different areas when it comes
    to gaining a better understanding of the analysis of time series data, as well
    as developing a model capable of consuming this data and developing a robust,
    predictive model.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨几个不同领域，以更好地理解时间序列数据的分析，以及开发一个能够消费这些数据并构建一个稳健、预测性模型的方法。
- en: 'As we explore these areas, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们探索这些领域，我们将涵盖以下主题：
- en: Understanding time series data
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解时间序列数据
- en: Exploring the components of a time series dataset
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索时间序列数据集的组成部分
- en: Tutorial – forecasting product demand using Prophet and LSTM
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 教程 - 使用Prophet和LSTM预测产品需求
- en: With that in mind, let’s go ahead and get started!
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，让我们开始吧！
- en: Understanding time series data
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解时间序列数据
- en: When it comes to using **time series** data, there are endless ways to visualize
    and display data to effectively communicate a thought or idea. In most of the
    data we have used so far, we have handled features and labels in which a certain
    set of features generally corresponded to a label of interest. When it comes to
    time series data, we tend to forego the idea of a class or label and focus more
    on trends within the data instead. One of the most common applications of time
    series data is the idea of **demand forecasting**. Demand forecasting, as its
    name suggests, comprises the many methods and tools available to help predict
    demand for a given good or service ahead of time. Throughout this section, we
    will learn about the many aspects of time series analysis using a dataset concerning
    the demand forecasting of a given biotechnology product.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到使用**时间序列**数据时，有无数种方式来可视化和展示数据，以有效地传达一个想法或观点。在我们迄今为止使用的大多数数据中，我们处理了特征和标签，其中一组特征通常对应于感兴趣的标签。当涉及到时间序列数据时，我们往往放弃类别或标签的概念，更多地关注数据中的趋势。时间序列数据最常见的一个应用是**需求预测**的概念。正如其名称所暗示的，需求预测包括许多方法和工具，可以帮助提前预测特定商品或服务的需求。在本节中，我们将通过一个关于特定生物技术产品需求预测的数据集，了解时间序列分析的许多方面。
- en: Treating time series data as a structured dataset
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将时间序列数据视为结构化数据集
- en: 'There are many different biotechnology products on the market today, ranging
    from agricultural genetically modified crops, all the way to monoclonal antibody
    therapeutics. In this section, we will investigate the sales data of a human therapeutic
    by using the `dataset_demand-forecasting_ts.csv` dataset, which belongs to a small
    biotech start-up:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 目前市场上有很多不同的生物技术产品，从农业转基因作物到单克隆抗体疗法应有尽有。在本节中，我们将通过使用`dataset_demand-forecasting_ts.csv`数据集来调查一种人用治疗品的销售数据，该数据集属于一家小型生物技术初创公司：
- en: 'With this in mind, let’s go ahead and dive into the data. We will begin by
    importing the libraries of interest, importing the `CSV` file, and taking a glance
    at the first few rows of data:'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑到这一点，让我们继续深入数据。我们将首先导入感兴趣的库，导入`CSV`文件，并查看数据的前几行：
- en: '[PRE0]'
  id: totrans-14
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This will result in the following output:'
  id: totrans-15
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将导致以下输出：
- en: '![Figure 10.1 – The first few rows of the forecasting dataset ](img/B17761_10_001.jpg)'
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图10.1 – 预测数据集的前几行](img/B17761_10_001.jpg)'
- en: Figure 10.1 – The first few rows of the forecasting dataset
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图10.1 – 预测数据集的前几行
- en: 'Relative to the many other datasets we have worked with in the past, this one
    seems much simpler in the sense that we are working with only two columns: `Date`
    and the number of `Sales` for any given day. We can also see that the sales have
    been aggregated by day, starting on `2014-01-01`. If we check the end of the dataset
    using the `tail()` function, we will see that the dataset ends on `2020-12-23`
    – essentially providing us with 6 years’ worth of sales data to work with.'
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与我们过去使用过的许多其他数据集相比，这个数据集在意义上似乎要简单得多，因为我们只处理两列：`日期`和任何给定日期的`销售额`数量。我们还可以看到销售额是按天聚合的，从`2014-01-01`开始。如果我们使用`tail()`函数检查数据集的末尾，我们将看到数据集在`2020-12-23`结束——基本上为我们提供了6年的销售额数据来工作。
- en: 'We can visualize the time series data using the `Plotly` library:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用`Plotly`库来可视化时间序列数据：
- en: '[PRE1]'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Upon executing the `fig.show()` function, we will receive the following output:'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 执行`fig.show()`函数后，我们将收到以下输出：
- en: '![Figure 10.2 – Time series plot of the sales dataset ](img/B17761_10_002.jpg)'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图10.2 – 销售数据集的时间序列图](img/B17761_10_002.jpg)'
- en: Figure 10.2 – Time series plot of the sales dataset
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图10.2 – 销售数据集的时间序列图
- en: 'We can immediately make a few initial observations regarding the dataset:'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以立即对数据集做出一些初步观察：
- en: There is a significant amount of noise and variability within the data.
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据中存在大量的噪声和变异性。
- en: The sales gradually increase over time (I should have invested in them!).
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 销售额随时间逐渐增加（我应该投资它们！）。
- en: There seems to be an element of seasonality in which sales peak around December.
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 销售额似乎存在季节性因素，销售额在12月达到峰值。
- en: To explore these ideas a bit more and dive deeper into the data, we will need
    to deconstruct the time series aspect. Using the `Date` column, we can break the
    dataset down into years, months, and days to get a better sense of the repetitive
    or **seasonal** nature of this data.
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了更深入地探索这些想法并深入数据，我们需要分解时间序列方面。使用`日期`列，我们可以将数据集分解为年、月和日，以更好地了解数据的重复或**季节性**特征。
- en: Important note
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 重要提示
- en: '**Seasonality** within datasets refers to the seasonal characteristics relating
    to that time of the year. For example, datasets relating to the flu shot often
    show increased rates in the fall relative to the spring or summer in preparation
    for the winter (flu season).'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 数据集中的**季节性**指的是与该年份时间相关的季节性特征。例如，与流感疫苗相关的数据集通常在秋季相对于春季或夏季显示出增加的比率，为冬季（流感季节）做准备。
- en: 'First, we will need to use the `to_datetime()` function to convert `string`
    into the `date` type:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要使用`to_datetime()`函数将`字符串`转换为`日期`类型：
- en: '[PRE2]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Upon executing this command, we will receive the following DataFrame as output:'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 执行此命令后，我们将收到以下DataFrame作为输出：
- en: '![Figure 10.3 – The first five rows of the sales dataset showing new features
    ](img/B17761_10_003.jpg)'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图10.3 – 显示新特征的销售额数据集的前五行](img/B17761_10_003.jpg)'
- en: Figure 10.3 – The first five rows of the sales dataset showing new features
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图10.3 – 显示新特征的销售额数据集的前五行
- en: 'Here, we can see that we were able to break down the time series aspect and
    yield a little more data than we originally started with. Let’s go ahead and plot
    the data by `year`:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们能够分解时间序列方面，并产生比最初开始时更多的数据。让我们继续按`年`绘制数据：
- en: '[PRE3]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'After plotting our data, we will receive the following boxplot, which shows
    the sales for each given year. From a statistical perspective, we can confirm
    our initial observation that the sales are gradually increasing every year:'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在绘制我们的数据后，我们将收到以下箱线图，它显示了每年的销售额。从统计学的角度来看，我们可以证实我们的初步观察，即销售额每年都在逐渐增加：
- en: '![Figure 10.4 – Boxplot showing the increasing sales every year ](img/B17761_10_004.png.jpg)'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图10.4 – 显示每年销售额增长的箱线图](img/B17761_10_004.png.jpg)'
- en: Figure 10.4 – Boxplot showing the increasing sales every year
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图10.4 – 显示每年销售额增长的箱线图
- en: 'Let’s go ahead and plot the same graph for each given `month` instead:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们继续绘制每个给定`月份`的相同图表：
- en: '[PRE4]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Upon changing the *x*-axis from years to months, we will receive the following
    graph, confirming our observation that the sales data tends to peak around the
    January (**1**)/December (**12**) timeframes:'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当我们将*x*-轴从年份改为月份时，我们将收到以下图表，证实我们的观察，即销售数据倾向于在1月（**1**）/12月（**12**）的时间框架内达到峰值：
- en: '![Figure 10.5 – Boxplot showing the seasonal sales for every month ](img/B17761_10_005.jpg)'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图10.5 – 显示每月季节性销售的箱线图](img/B17761_10_005.jpg)'
- en: Figure 10.5 – Boxplot showing the seasonal sales for every month
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图10.5 – 显示每月季节性销售的箱线图
- en: Earlier, we noted that the dataset contained a great deal of noise in the sense
    that there was a great deal of fluctuation within the data. We can address this
    noise and normalize the data by taking a **rolling average** (**moving average**)
    – a calculation that’s used to help us analyze data points by creating a series
    of average values.
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 之前，我们提到数据集中包含大量的噪声，即在数据中存在大量的波动。我们可以通过取**滚动平均**（**移动平均**）来解决这个问题并使数据归一化，这是一种用于帮助我们通过创建一系列平均值来分析数据点的计算方法。
- en: 'We can implement this directly in our DataFrame using the `rolling()` function:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以直接使用`rolling()`函数在我们的DataFrame中实现这一点：
- en: '[PRE5]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Notice that in the preceding code, we used two examples to demonstrate the
    idea of a rolling average by using window values of 20 and 100\. Using `Plotly
    Go`, we can plot the original raw data and the two rolling averages onto a single
    plot:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，在前面的代码中，我们使用了两个示例来通过使用20和100的窗口值来展示滚动平均的概念。使用`Plotly Go`，我们可以将原始原始数据和两个滚动平均值绘制在单个图表上：
- en: '[PRE6]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Upon executing this code, we will receive the following output:'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 执行此代码后，我们将收到以下输出：
- en: '![Figure 10.6 – Boxplot showing the rolling average of the sales data ](img/B17761_10_006.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图10.6 – 显示每月季节性销售的箱线图](img/B17761_10_006.jpg)'
- en: Figure 10.6 – Boxplot showing the rolling average of the sales data
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.6 – 显示销售数据滚动平均的箱线图
- en: Notice that the raw dataset is plotted faintly in the background, overlayed
    by the dashed curve representing the `window` value of 20, as well as the solid
    curve in the foreground representing the `window` value of 100\. Using rolling
    averages can be useful when you’re trying to visualize and understand your data,
    as well as building forecasting models, as we will see later in this chapter.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，原始数据集以淡色在背景中绘制，由表示20个`window`值的虚线曲线覆盖，以及表示100个`window`值的实线曲线在前景中。使用滚动平均值在尝试可视化和理解数据以及构建预测模型时可能很有用，正如我们将在本章后面看到的那样。
- en: Important note
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: A **rolling average** (**moving average**) is a calculation that’s used to smoothen
    out a noisy dataset by taking the moving mean throughout a particular range. The
    range, which is often referred to as the window, is generally the last *x* number
    of data points.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**滚动平均**（**移动平均**）是一种计算方法，通过在整个特定范围内取移动平均值来平滑噪声数据集。这个范围通常被称为窗口，通常是最后*x*个数据点。'
- en: Time series data is very different from much of the datasets we have explored
    so far within this book. Unlike other datasets, time series data is generally
    thought to be consistent with several **components**, all of which we will explore
    in the next section.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 时间序列数据与我们在本书中迄今为止探索的大多数数据集非常不同。与其他数据集不同，时间序列数据通常被认为与几个**组成部分**一致，所有这些我们将在下一节中探讨。
- en: Exploring the components of a time series dataset
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索时间序列数据集的组成部分
- en: In this section, we will explore the four main items that are generally regarded
    as the components of a time series dataset and visualize them. With that in mind,
    let’s go ahead and get started!
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨通常被认为是时间序列数据集组成部分的四个主要项目，并将它们可视化。考虑到这一点，让我们开始吧！
- en: 'Time series datasets generally consist of four main components: **level**,
    **long-term** **trends**, **seasonality**, and **irregular noise**, which we can
    break down into a method known as time series **decomposition**. The main purpose
    behind decomposition is to gain a better perspective of the dataset by thinking
    about the data more abstractly. We can think of time series components as being
    either additive or multiplicative:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 时间序列数据集通常由四个主要组成部分组成：**水平**、**长期**趋势、**季节性**和**不规则噪声**，我们可以将这些分解成一种称为时间序列**分解**的方法。分解背后的主要目的是通过更抽象地思考数据来更好地了解数据集。我们可以将时间序列组成部分视为加法或乘法：
- en: '![](img/Formula_B17761_10_001.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图10.1 – 公式](img/B17761_10_001.png)'
- en: '![](img/Formula_B17761_10_002.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图10.6 – 显示销售数据滚动平均的箱线图](img/B17761_10_002.png)'
- en: 'We can define each of the components as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样定义每个组成部分：
- en: '**Level**: Average values of a dataset over time'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**水平**：数据集随时间变化的平均值'
- en: '**Long-term Trends**: General direction of the data showing an increase or
    decrease'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**长期趋势**：数据的一般方向，显示增加或减少'
- en: '**Seasonal Trends**: Short-term repetitive nature (days, weeks, months)'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**季节性趋势**：短期重复性特征（天数、周数、月数）'
- en: '**Irregular Trends**: The noise within the data showing random fluctuations'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不规则趋势**：数据中的随机波动噪声'
- en: 'We can explore and visualize these compounds a little more closely using the
    `statsmodels` library in conjunction with our dataset by performing the following
    simple steps:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`statsmodels`库结合我们的数据集，通过以下简单步骤来更深入地探索和可视化这些化合物：
- en: 'First, we will need to reshape our dataset by only keeping the sales column,
    dropping any missing values, and setting the date column as the DataFrame’s **index**:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要通过仅保留销售列、删除任何缺失值并将日期列设置为DataFrame的**索引**来调整我们的数据集：
- en: '[PRE7]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We can check the first few rows to see that the date is now our index:![Figure
    10.7 – First few rows of the reshaped dataset ](img/B17761_10_007.jpg)
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以检查前几行以确认日期现在是我们的索引：![图10.7 – 调整后的数据集的前几行](img/B17761_10_007.jpg)
- en: Figure 10.7 – First few rows of the reshaped dataset
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图10.7 – 调整后的数据集的前几行
- en: 'Next, we will import the `seasonal_decompose` function from the `statsmodels`
    library and apply it to our `dataframe`:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将从`statsmodels`库中导入`seasonal_decompose`函数并将其应用于我们的`dataframe`：
- en: '[PRE8]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Finally, we can plot the result using the built-in `plot()` function and view
    the results:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以使用内置的`plot()`函数绘制结果并查看结果：
- en: '[PRE9]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Using the `show()` function will give us the following output:'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用`show()`函数将给出以下输出：
- en: '![Figure 10.8 – Results of the seasonal decomposition function ](img/B17761_10_008.png.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图10.8 – 季节分解函数的结果](img/B17761_10_008.png.jpg)'
- en: Figure 10.8 – Results of the seasonal decomposition function
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.8 – 季节分解函数的结果
- en: Here, we can see the four components we spoke of earlier in this section. In
    the first plot, we can see the rolling average we calculated in the previous section.
    This is then followed by the **long-term trend**, which shows a steady increase
    throughout the dataset. We can then see the **seasonality** behind the dataset,
    confirming that sales tend to increase around the December and January timeframes.
    Finally, we can see the **residual** data or **noise** within the dataset. We
    can define this noise as items that did not contribute to the other main categories.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到本节中提到的四个组成部分。在第一个图表中，我们可以看到我们在上一节中计算的自回归移动平均。然后是**长期趋势**，它显示了整个数据集的稳步增长。然后我们可以看到数据集背后的**季节性**，证实了销售在12月和1月的时间框架内倾向于增加。最后，我们可以看到数据集中的**残差**数据或**噪声**。我们可以将这种噪声定义为未对其他主要类别做出贡献的项目。
- en: Decomposing a dataset is generally done to gain a better sense of the data and
    some of its main characteristics, which can often reshape how you think of the
    dataset and any given forecasting model that can be developed. We will learn how
    to develop two common forecasting models in the next section.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 分解数据集通常是为了更好地理解数据及其一些主要特征，这通常会改变你对数据集以及任何可以开发的给定预测模型的看法。我们将在下一节中学习如何开发两种常见的预测模型。
- en: Tutorial – forecasting demand using Prophet and LSTM
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 教程 – 使用Prophet和LSTM预测需求
- en: In this tutorial, we will use the sales dataset from the previous section to
    develop two robust demand forecasting models. Our main objective will be to use
    the sales data to predict demand at a future date. **Demand forecasting** is generally
    done to predict the number of units to be sold on either a given date or location.
    Companies around the world, especially those that handle temperature-sensitive
    or time-sensitive medications, rely on models such as these to optimize their
    supply chains and ensure patient needs are met.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将使用上一节中的销售数据集来开发两个稳健的需求预测模型。我们的主要目标将是使用销售数据来预测未来的需求。**需求预测**通常用于预测在给定日期或地点要销售的单元数量。全球各地的公司，尤其是那些处理对温度敏感或对时间敏感的药物的公司，依赖于这些模型来优化其供应链并确保满足患者的需求。
- en: First, we will explore Facebook’s famous **Prophet** library, followed by developing
    a custom **Long Short-term Memory** (**LSTM**) deep learning model. With this
    in mind, let’s go ahead and investigate how to use the Prophet model.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将探索Facebook著名的**Prophet**库，然后开发一个定制的**长短期记忆**（**LSTM**）深度学习模型。考虑到这一点，让我们继续研究如何使用Prophet模型。
- en: Using Prophet for time series modeling
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Prophet进行时间序列建模
- en: Prophet is a model that gained a great deal of traction within the data science
    community when it was first released in 2017\. As an open source library available
    in both **R** and **Python**, the model was quickly adopted and widely used as
    one of the main forecasting models for time series data. One of the greatest benefits
    behind this model is also one of its consequences – its high-level nature of abstraction,
    allowing users to make a forecast with only a few lines of code. This limited
    variability can be a great way to make a quick forecast but can hinder the model
    development process, depending on the dataset at hand.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Prophet是一个在2017年首次发布时就获得了数据科学界广泛关注的模型。作为一个既在**R**又在**Python**中可用的开源库，该模型很快被采用并广泛用作时间序列数据的主要预测模型之一。这个模型背后的最大好处之一也是其后果之一——它的高度抽象性质，使用户只需几行代码就能做出预测。这种有限的变异性可以是一种快速预测的好方法，但可能会阻碍模型开发过程，具体取决于手头的数据集。
- en: 'Over the next few pages, we will develop a Prophet model that’s been fitted
    with our data to forecast future sales and validate the results by comparing them
    to the actual sales data. Let’s get started:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几页中，我们将开发一个使用我们的数据进行拟合的Prophet模型，以预测未来的销售并通过对实际销售数据进行比较来验证结果。让我们开始吧：
- en: 'To begin, let’s go ahead and use the `rolling()` function to get a rolling
    average of our dataset. Then, we can overlay this value on the raw values:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们使用`rolling()`函数来获取数据集的滚动平均值。然后，我们可以将这个值叠加到原始值上：
- en: '[PRE10]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This will result in the following output:![Figure 10.9 – The rolling average
    relative to the raw dataset ](img/B17761_10_009.jpg)
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将产生以下输出：![图10.9 – 与原始数据集相关的滚动平均值](img/B17761_10_009.jpg)
- en: Figure 10.9 – The rolling average relative to the raw dataset
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图10.9 – 与原始数据集相关的滚动平均值
- en: 'Here, we can see that the dataset is now far less **noisy** and easier to work
    with. We can use the **Prophet** library with our dataset to create a forecast
    in four basic steps:'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到数据集现在要少得多**噪声**，更容易处理。我们可以使用**Prophet**库和我们的数据集通过以下四个基本步骤来创建预测：
- en: 'First, we will need to reshape the DataFrame to integrate it with the `Prophet`
    library. The library expects the DataFrame to contain two columns – `ds` and `y`
    – in which `ds` is the date stamp and `y` is the value that we are working with.
    We can reshape this DataFrame into a new DataFrame using the following code:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要将DataFrame重塑以与`Prophet`库集成。该库期望DataFrame包含两列——`ds`和`y`，其中`ds`是日期戳，`y`是我们正在处理的价值。我们可以使用以下代码将这个DataFrame重塑为一个新的DataFrame：
- en: '[PRE11]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Similar to the implementation of the `sklearn` library, we can create an instance
    of the Prophet model and `fit` that to our dataset:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与`sklearn`库的实现类似，我们可以创建一个Prophet模型的实例并将其`fit`到我们的数据集上：
- en: '[PRE12]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Next, we can call the `make_future_dataframe()` function and the number of
    periods of interest. This will yield a DataFrame containing a column of dates:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们可以调用`make_future_dataframe()`函数和感兴趣的周期数。这将产生一个包含日期列的DataFrame：
- en: '[PRE13]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Finally, we can use the `predict()` function to make a forecast using the future
    variable as an input parameter. This will return a number of different statistical
    values related to the dataset:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以使用`predict()`函数，将未来变量作为输入参数来做出预测。这将返回与数据集相关的多个统计值：
- en: '[PRE14]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can limit the scope of the dataset to a few of the columns and retrieve
    the following DataFrame:'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以限制数据集的范围到几个列，并检索以下DataFrame：
- en: '![Figure 10.10 – The output of the forecasting function from Prophet ](img/B17761_10_010.jpg)'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图10.10 – Prophet预测函数的输出](img/B17761_10_010.jpg)'
- en: Figure 10.10 – The output of the forecasting function from Prophet
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图10.10 – Prophet预测函数的输出
- en: 'Now, we can visualize our predictions using the built-in `plot()` function
    from our **Prophet** instance:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用**Prophet**实例的内置`plot()`函数来可视化我们的预测：
- en: '[PRE15]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This will result in the following output, which shows the original raw dataset,
    the future forecasting, as well as some upper and lower boundaries:'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将产生以下输出，显示了原始的原始数据集、未来的预测以及一些上限和下限：
- en: '![Figure 10.11 – Graphical representation of the forecasted data ](img/B17761_10_011.jpg)'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图10.11 – 预测数据的图形表示](img/B17761_10_011.jpg)'
- en: Figure 10.11 – Graphical representation of the forecasted data
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图10.11 – 预测数据的图形表示
- en: 'Alternatively, we can test the model’s capabilities by training the model using
    a portion of the data – for example, everything up to 2018\. We can then use the
    forecasting model to predict the remaining time to compare the output with the
    actual data. Upon completing this, we will receive the following output:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 或者，我们可以通过使用数据的一部分来训练模型来测试模型的能力——例如，直到2018年为止的所有数据。然后，我们可以使用预测模型来预测剩余的时间，并将输出与实际数据进行比较。完成此操作后，我们将收到以下输出：
- en: '![Figure 10.12 – Graphical representation of the training and testing data
    ](img/B17761_10_012.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图10.12 – 训练和测试数据的图形表示](img/B17761_10_012.jpg)'
- en: Figure 10.12 – Graphical representation of the training and testing data
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.12 – 训练和测试数据的图形表示
- en: Here, we can see that the dashed line, which represents the forecasted sales,
    was quite close to the actual values. We can also see that the model did not forecast
    the extremes of the curve, so it likely needs additional tuning to reach a more
    realistic forecast. However, the high-level nature of **Prophet** can be limiting
    in this area.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到代表预测销售的虚线与实际值非常接近。我们还可以看到，模型没有预测曲线的极端值，因此可能需要额外的调整以达到更现实的预测。然而，**Prophet**
    的高级特性可能在这方面有所限制。
- en: From this, we can see that preparing the data and implementing the model was
    quite fast and that we were able to complete this in only a few lines of code.
    In the next section, we will learn how to develop an **LSTM** using **Keras**.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，我们可以看到准备数据和实现模型非常快，我们只用几行代码就完成了这项工作。在下一节中，我们将学习如何使用**Keras**开发**LSTM**。
- en: Using LSTM for time series modeling
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用LSTM进行时间序列建模
- en: '**LSTM** models first gained their popularity in 1997, and then again in recent
    years with the increase in computational capabilities. As you may recall, LSTMs
    are a type of **Recurrent Neural Network** (**RNN**) that can remember and forget
    patterns within a dataset. One of the main benefits of this model is its mid to
    low-level nature in the sense that more code is required for a full implementation,
    relative to that of **Prophet**. Users gain a great deal of control over the model
    development process, enabling them to cater the model to almost any type of dataset,
    and any type of use case. With that in mind, let’s get started:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**LSTM**模型首次在1997年获得流行，然后在计算能力增加的近年再次流行。如您所回忆的，LSTMs是一种可以记住和忘记数据集中模式的**循环神经网络**（**RNN**）。这种模型的主要优点是其中到低级的特性，即相对于**Prophet**，需要更多的代码来实现。用户在模型开发过程中获得了极大的控制权，使他们能够将模型定制为几乎任何类型的数据库和任何类型的用例。考虑到这一点，让我们开始：'
- en: 'Using the same dataset, we can go ahead and create a rolling average using
    a `window` of `20` to reduce the noise in our dataset. Then, we can remove the
    missing values that result from this:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用相同的数据库，我们可以继续创建一个使用`20`个窗口的滚动平均值，以减少数据集中的噪声。然后，我们可以移除由此产生的缺失值：
- en: '[PRE16]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Using `MinMaxScaler` from the `sklearn` library, we can go ahead and scale
    our dataset:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用来自`sklearn`库的`MinMaxScaler`，我们可以继续对数据进行缩放：
- en: '[PRE17]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Next, we will need to split the data into our training and testing sets. Remember
    that our objective here is to provide the model with some sample historical data
    and see if we can accurately forecast future demand. Let’s go ahead and use 75%
    of the dataset to train the model and see if we can forecast the remaining 25%:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要将数据分成我们的训练集和测试集。记住，我们的目标是向模型提供一些历史样本数据，并查看我们是否可以准确预测未来的需求。让我们继续使用数据集的75%来训练模型，并查看我们是否可以预测剩余的25%：
- en: '[PRE18]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Given that we are working with time series data, we will need to use a `lookback`
    to train the model in iterations. Let’s go ahead and select a `lookback` value
    of `100` and use our `dataset_generator` function to create our training and testing
    sets. We can think of a `lookback` value as the range of how far back in the data
    the model should look to train:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们正在处理时间序列数据，我们需要使用`lookback`来迭代训练模型。让我们继续选择一个`lookback`值为`100`，并使用我们的`dataset_generator`函数来创建我们的训练和测试集。我们可以将`lookback`值视为模型在数据中回溯的范围，以进行训练：
- en: '[PRE19]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As you may recall from our previous implementation of an LSTM model, we needed
    to `reshape` our data prior to using the data as input:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如您从我们之前实现的LSTM模型中回忆的那样，我们需要在使用数据作为输入之前对数据进行`reshape`：
- en: '[PRE20]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Finally, with the data prepared, we can go ahead and prepare the model itself.
    Given that we are only working with a single feature, we can keep our model relatively
    simple. First, we will use the `Sequential` class from Keras, and then add an
    `LSTM` layer with two nodes, followed by a `Dense` layer with a single output
    value:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，数据准备就绪后，我们可以继续准备模型本身。鉴于我们只处理一个特征，我们可以保持模型相对简单。首先，我们将使用Keras的`Sequential`类，然后添加一个具有两个节点的`LSTM`层，接着是一个具有单个输出值的`Dense`层：
- en: '[PRE21]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Next, we can use an `Adam` optimizer with a learning rate of `0.001` and compile
    the model:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们可以使用学习率为`0.001`的`Adam`优化器并编译模型：
- en: '[PRE22]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Recall that we can use the `summary()` function to take a look at the compiled
    model:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记住，我们可以使用`summary()`函数来查看编译后的模型：
- en: '[PRE23]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This will result in the following output, which provides a glimpse into the
    inner workings of the model:'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将导致以下输出，它提供了对模型内部工作的洞察：
- en: '![Figure 10.13 – Summary of the Keras model ](img/B17761_10_013.jpg)'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图10.13 – Keras模型的摘要](img/B17761_10_013.jpg)'
- en: Figure 10.13 – Summary of the Keras model
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图10.13 – Keras模型的摘要
- en: 'With the model compiled, we can go ahead and begin the training process. We
    can call the `fit()` function to fit the model on the training dataset for 10
    epochs:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模型编译完成后，我们可以开始训练过程。我们可以调用`fit()`函数，将模型在训练数据集上拟合10个epoch：
- en: '[PRE24]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The model training process should be relatively quick. Once it’s been completed,
    we can take a look at the `loss` value by visualizing the results in a graph:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模型训练过程应该相对较快。一旦完成，我们可以通过在图表中可视化结果来查看`loss`值：
- en: '[PRE25]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This will result in the following output, showing the progressive decrease
    in loss over time:'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将导致以下输出，显示了损失随时间逐渐减少的过程：
- en: '![Figure 10.14 – Model loss over time ](img/B17761_10_014.png.jpg)'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图10.14 – 随时间变化的模型损失](img/B17761_10_014.png.jpg)'
- en: Figure 10.14 – Model loss over time
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图10.14 – 随时间变化的模型损失
- en: Here, we can see that the `loss` value decreases quite consistently, finally
    plateauing at around the 9-10 epoch marker. Notice that we specified a learning
    rate of `0.001` in the optimizer. Had we increased this value to 0.01, or decreased
    the value to 0.0001, the output of this graph would be very different. We can
    use the learning rate as a powerful parameter to optimize the performance of our
    model. Go ahead and give this a try to see what the graphical output of the loss
    would be.
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到`loss`值相当一致地下降，最终在9-10个epoch标记处达到平台期。请注意，我们在优化器中指定了学习率为`0.001`。如果我们将其增加到0.01，或者减少到0.0001，此图表的输出将非常不同。我们可以使用学习率作为优化模型性能的强大参数。尝试一下，看看损失的图形输出会是什么样子。
- en: 'With the model training complete, we can go ahead and use the model to forecast
    the values of interest:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模型训练完成后，我们可以继续使用该模型来预测感兴趣的值：
- en: '[PRE26]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'With the data all set, we can visualize the data by plotting the results using
    `matplotlib`. First, let’s plot the original dataset using `lightgrey`:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据准备就绪后，我们可以通过使用`matplotlib`绘制结果来可视化数据。首先，让我们使用`lightgrey`绘制原始数据集：
- en: '[PRE27]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Next, we can plot the training values using `blue`:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们可以使用`blue`绘制训练值：
- en: '[PRE28]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Finally, we can plot the forecasted values using `darkorange` and a dashed
    line to distinguish it from its two counterparts:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以使用`darkorange`和虚线来绘制预测值，以区分其两个对应物：
- en: '[PRE29]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Upon executing this code, we will get the following output:'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 执行此代码后，我们将得到以下输出：
- en: '![Figure 10.15 – Training and testing datasets using the LSTM model ](img/B17761_10_015.png.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图10.15 – 使用LSTM模型的训练和测试数据集](img/B17761_10_015.png.jpg)'
- en: Figure 10.15 – Training and testing datasets using the LSTM model
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.15 – 使用LSTM模型的训练和测试数据集
- en: Here, we can see that this relatively simple **LSTM** model was quite effective
    in making a forecast using the training dataset we provided. The model was not
    only able to capture the general direction of the values, but also managed to
    capture the seasonality of the values as well.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到这个相对简单的**LSTM**模型在利用我们提供的训练数据集进行预测方面非常有效。该模型不仅能够捕捉到值的总体趋势，而且还成功地捕捉到了值的季节性。
- en: Summary
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we attempted to analyze and understand time series data, as
    well as developing two predictive forecasting models in less than 15 pages. We
    began our journey by exploring and decomposing time series data into smaller features
    that can generally be used with shallow machine learning models. We then investigated
    the components of a time series dataset to understand the underlying makeup. Finally,
    we developed two of the most common forecasting models that are used in the industry
    – the Prophet model, by Facebook, and an LSTM model using Keras.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们试图分析和理解时间序列数据，并在不到15页的篇幅内开发了两个预测预测模型。我们的旅程从探索和分解时间序列数据开始，将其分解成更小的特征，这些特征通常可以与浅层机器学习模型一起使用。然后，我们研究了时间序列数据集的组成部分，以了解其底层结构。最后，我们开发了两个在行业中常用的最常见预测模型——Facebook的Prophet模型和基于Keras的LSTM模型。
- en: Throughout the last few chapters, we have developed various technical solutions
    to solve common business problems. In the next chapter, we will explore the first
    step in making models such as these available to end users using the Flask framework.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的几章中，我们开发了各种技术解决方案来解决常见的商业问题。在下一章中，我们将探讨使用Flask框架将这些模型如这些模型提供给最终用户的第一个步骤。
