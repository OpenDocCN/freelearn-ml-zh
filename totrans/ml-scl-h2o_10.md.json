["```py\ninput_csv = \"rawloans.csv\"\n```", "```py\nloans = h2o.import_file(input_csv,\n```", "```py\n             col_types = {\"int_rate\": \"string\",\n```", "```py\n                          \"revol_util\": \"string\",\n```", "```py\n                          \"emp_length\": \"string\",\n```", "```py\n                          \"verification_status\": \"string\"})\n```", "```py\nloans.dim\n```", "```py\nkeep = ['addr_state', 'annual_inc', 'delinq_2yrs',\n```", "```py\n        'dti', 'earliest_cr_line', 'emp_length', 'grade',\n```", "```py\n        'home_ownership', 'inq_last_6mths', 'installment',\n```", "```py\n        'issue_d', 'loan_amnt', 'loan_status',\n```", "```py\n        'mths_since_last_delinq', 'open_acc', 'pub_rec',\n```", "```py\n        'purpose', 'revol_bal', 'revol_util', 'term',\n```", "```py\n        'total_acc', 'verification_status']\n```", "```py\nremove = list(set(loans.columns) - set(keep))\n```", "```py\nloans = loans.drop(remove)\n```", "```py\nloans[\"loan_status\"].table().head(20)\n```", "```py\nongoing_status = [\n```", "```py\n    \"Current\",\n```", "```py\n    \"In Grace Period\",\n```", "```py\n    \"Late (16-30 days)\",\n```", "```py\n    \"Late (31-120 days)\",\n```", "```py\n    \"Does not meet the credit policy.  Status:Current\",\n```", "```py\n    \"Does not meet the credit policy.  Status:In Grace Period\"\n```", "```py\n]\n```", "```py\nloans = loans[~loans[\"loan_status\"].isin(ongoing_status)]\n```", "```py\nloans[\"loan_status\"].table()\n```", "```py\nfully_paid = [\n```", "```py\n    \"Fully Paid\",\n```", "```py\n    \"Does not meet the credit policy.  Status:Fully Paid\"\n```", "```py\n]\n```", "```py\nresponse = \"bad_loan\"\n```", "```py\nloans[response] = ~(loans[\"loan_status\"].isin(fully_paid))\n```", "```py\nloans[response] = loans[response].asfactor()\n```", "```py\nloans = loans.drop(\"loan_status\")\n```", "```py\nloans[[\"revol_util\", \"emp_length\"]].head()\n```", "```py\nx = \"revol_util\"\n```", "```py\nloans[x] = loans[x].gsub(pattern=\"%\", replacement=\"\")\n```", "```py\nloans[x] = loans[x].trim()\n```", "```py\nloans[x] = loans[x].asnumeric()\n```", "```py\nx = \"emp_length\"\n```", "```py\nloans[x] = loans[x].gsub(pattern=\"([ ]*+[a-zA-Z].*)|(n/a)\", \n```", "```py\n                         replacement=\"\") \n```", "```py\nloans[x] = loans[x].trim()\n```", "```py\nloans[x] = loans[x].gsub(pattern=\"< 1\", replacement=\"0\")\n```", "```py\nloans[x] = loans[x].gsub(pattern=\"10\\\\+\", replacement=\"10\") \n```", "```py\nloans[x] = loans[x].asnumeric()\n```", "```py\nloans[\"verification_status\"].head()\n```", "```py\nx = \"verification_status\"\n```", "```py\nloans[x] = loans[x].sub(pattern = \"VERIFIED - income source\",\n```", "```py\n                        replacement = \"verified\")\n```", "```py\nloans[x] = loans[x].sub(pattern = \"VERIFIED - income\",\n```", "```py\n                        replacement = \"verified\")\n```", "```py\nloans[x] = loans[x].asfactor()\n```", "```py\nloans[\"credit_length\"] = loans[\"issue_d\"].year() - \\\n```", "```py\n    loans[\"earliest_cr_line\"].year()\n```", "```py\nloans = loans.drop([\"earliest_cr_line\"])\n```", "```py\nx = \"log_inc_per_acct\"\n```", "```py\nloans[x] = loans['annual_inc'].log() - \\\n```", "```py\n    loans['total_acc'].log()\n```", "```py\nx = \"issue_d\"\n```", "```py\nloans[x + \"_year\"] = loans[x].year()\n```", "```py\nloans[x + \"_month\"] = loans[x].month().asfactor()\n```", "```py\nloans[x + \"_dayOfWeek\"] = loans[x].dayOfWeek().asfactor()\n```", "```py\nweekend = [\"Sat\", \"Sun\"]\n```", "```py\nloans[x + \"_weekend\"] = loans[x + \"_dayOfWeek\"].isin(weekend)\n```", "```py\nloans[x + \"_weekend\"] = loans[x + \"_weekend\"].asfactor()\n```", "```py\nloans = loans.drop(x)\n```", "```py\nx = \"home_ownership\"\n```", "```py\nloans[x].table()\n```", "```py\nloans[x].levels()\n```", "```py\nlvls = [\"MORTGAGE\", \"OTHER\", \"OTHER\", \"OTHER\", \"RENT\"]\n```", "```py\nloans[\"home_3cat\"] = \\\n```", "```py\n    loans[x].set_levels(lvls).ascharacter().asfactor()\n```", "```py\nloans = loans.drop(x)\n```", "```py\nloans[\"emp_length_missing\"] = loans[\"emp_length\"] == None\n```", "```py\ntrain, test = loans.split_frame(ratios = [0.8], seed = 12345)\n```", "```py\nloans[\"split\"] = loans[response].stratified_split(\\\n```", "```py\n    test_frac = 0.2, seed = 12345)\n```", "```py\nloans[[response,\"split\"]].table()\n```", "```py\nmask = loans[\"split\"] == \"train\"\n```", "```py\ntrain = loans[mask, :].drop(\"split\")\n```", "```py\ntest = loans[~mask, :].drop(\"split\")\n```", "```py\nfrom h2o.estimators import H2OTargetEncoderEstimator\n```", "```py\nencoded_columns = [\"purpose\", \"addr_state\"]\n```", "```py\ntrain[\"fold\"] = train.kfold_column(n_folds = 5, seed = 25)\n```", "```py\nte = H2OTargetEncoderEstimator(\n```", "```py\n    data_leakage_handling = \"k_fold\",\n```", "```py\n    fold_column = \"fold\",\n```", "```py\n    noise = 0.05,\n```", "```py\n    blending = True,\n```", "```py\n    inflection_point = 10,\n```", "```py\n    smoothing = 20)\n```", "```py\nte.train(x = encoded_columns,\n```", "```py\n         y = response,\n```", "```py\n         training_frame = train)\n```", "```py\ntrain_te = te.transform(frame = train)\n```", "```py\ntest_te = te.transform(frame = test, noise = 0.0)\n```", "```py\ntrain = train_te.drop(encoded_columns).drop(\"fold\")\n```", "```py\ntest = test_te.drop(encoded_columns)\n```", "```py\nresponse = \"bad_loan\"\n```", "```py\npredictors = train.columns\n```", "```py\npredictors.remove(response)\n```", "```py\nfrom h2o.automl import H2OAutoML\n```", "```py\naml = H2OAutoML(max_runtime_secs = 1800,\n```", "```py\n                exclude_algos = ['DeepLearning'],\n```", "```py\n                seed = 12345)\n```", "```py\naml.train(x = predictors, \n```", "```py\n          y = response, \n```", "```py\n          training_frame = train)\n```", "```py\naml.explain(test)\n```", "```py\nmaml = H2OAutoML(\n```", "```py\n         max_runtime_secs = 1800,\n```", "```py\n         exclude_algos = ['DeepLearning'],\n```", "```py\n         monotone_constraints = {\"annual_inc\": -1}, \n```", "```py\n         seed = 12345)\n```", "```py\nmaml.train(x = predictors, \n```", "```py\n           y = response, \n```", "```py\n           training_frame = train)\n```", "```py\nmaml.explain(test)\n```", "```py\ncandidate = h2o.get_model(maml.leaderboard[3, 'model_id'])\n```", "```py\ncandidate.actual_params\n```", "```py\nfrom h2o.grid.grid_search import H2OGridSearch\n```", "```py\nfrom h2o.estimators import H2OXGBoostEstimator\n```", "```py\nhyperparams_tune = {\n```", "```py\n    'max_depth' : list(range(2, 6, 1)),\n```", "```py\n    'sample_rate' : [x/100\\. for x in range(60,101)],\n```", "```py\n    'col_sample_rate' : [x/100\\. for x in range(40,80)],\n```", "```py\n    'col_sample_rate_per_tree': [x/100\\. for x in\n```", "```py\n         range(80,101)],\n```", "```py\n    'learn_rate' : [x/100\\. for x in range(5,31)]\n```", "```py\n}\n```", "```py\nsearch_criteria_tune = {\n```", "```py\n    'strategy' : \"RandomDiscrete\",\n```", "```py\n    'max_runtime_secs' : 1800,\n```", "```py\n    'stopping_rounds' : 5,\n```", "```py\n    'stopping_metric' : \"AUC\",\n```", "```py\n    'stopping_tolerance': 5e-4\n```", "```py\n}\n```", "```py\nmonotone_xgb_grid = H2OXGBoostEstimator(\n```", "```py\n    ntrees = 90,\n```", "```py\n    nfolds = 5,\n```", "```py\n    score_tree_interval = 10,\n```", "```py\n    monotone_constraints = {\"annual_inc\": -1},\n```", "```py\n    seed = 25)\n```", "```py\nmonotone_grid = H2OGridSearch(\n```", "```py\n    monotone_xgb_grid,\n```", "```py\n    hyper_params = hyperparams_tune,\n```", "```py\n    grid_id = 'monotone_grid',\n```", "```py\n    search_criteria = search_criteria_tune)\n```", "```py\nmonotone_grid.train(\n```", "```py\n    x = predictors,\n```", "```py\n    y = response,\n```", "```py\n    training_frame = train)\n```", "```py\nmonotone_sorted = monotone_grid.get_grid(sort_by = 'logloss',\n```", "```py\n                                         decreasing = False)\n```", "```py\nbest1 = monotone_sorted.models[0]\n```", "```py\nbest2 = monotone_sorted.models[1]\n```", "```py\ncandidate.model_performance(test).logloss()\n```", "```py\nbest1.model_performance(test).logloss()\n```", "```py\nbest2.model_performance(test).logloss()\n```", "```py\nfinal = best2\n```", "```py\nfinal.explain(test)\n```", "```py\nfinal.download_MOJO(\"final_MOJO.zip\")\n```"]