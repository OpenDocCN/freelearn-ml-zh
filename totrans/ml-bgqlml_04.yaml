- en: '*Chapter 3*: Introducing BigQuery Syntax'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The BigQuery dialect is compliant with the standard ANSI 2011 and is quite easy
    to learn for people who know other dialects and have experience with SQL. The
    main differences in terms of syntax are represented by BigQuery extensions, which
    allow us to use advanced features such as **Machine Learning** (**ML**). Bringing
    ML capabilities into SQL allows different roles to access it. This approach has
    the clear goal of democratizing the use of ML across different functions within
    a company, generating as much value as possible. With BigQuery ML, Google Cloud
    is filling the gap between tech-savvy people with ML skills and business analysts
    who know the company's data very well and have been working on it for years.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'To build your confidence with the BigQuery environment and its dialect, we''ll
    go through the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Creating a BigQuery dataset
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discovering BigQuery SQL
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Diving into BigQuery ML
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter requires access to a web browser and the following:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: A GCP account to access Google Cloud Console
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A GCP project to host the BigQuery datasets
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we're ready with the technical requirements, let's dive into the creation
    of a BigQuery dataset.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/3vR8I7f](https://bit.ly/3vR8I7f)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Creating a BigQuery dataset
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before jumping into the BigQuery syntax, it is necessary to create a new BigQuery
    dataset that will employ the data structures created in the next sections. For
    each hands-on chapter, we''ll create a new dataset to segregate each use case
    and maintain a logical separated structure:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Access the BigQuery UI by browsing to the GCP Navigation menu from the GCP console
    and selecting the **BigQuery** service.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After selecting the right GCP project in the navigation menu of the BigQuery
    UI, it is possible to click on the **Create Dataset** button:![Figure 3.1 – Creation
    of a new BigQuery Dataset
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16722_03_001.jpg)'
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 3.1 – Creation of a new BigQuery Dataset
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the overlay window that appears on the right of the screen, choose the `Dataset
    ID` that you prefer and leave all the other options configured with default values.
    To host the data structures of this chapter, we suggest using the name `03_bigquery_syntax`.
    Then, select **Create dataset**:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.2 – Create dataset screen'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16722_03_002.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.2 – Create dataset screen
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've created our first BigQuery dataset, let's take an overview of
    the main characteristics of the BigQuery SQL syntax.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Discovering BigQuery SQL
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'BigQuery supports two different SQL dialects: **standard SQL** and **legacy
    SQL**. In this book, we''ll use Standard SQL, but it could be useful to know what
    Legacy SQL is and how to enable it if you want to test queries coming from legacy
    applications.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: As we have already mentioned, BigQuery was developed as an internal product
    within Google and was initially realized to process log records. The query engine
    Dremel was able to support a limited set of SQL operations that are now defined
    as Legacy SQL.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经提到的，BigQuery是在谷歌内部开发的一个产品，最初是为了处理日志记录而实现的。查询引擎Dremel能够支持现在定义为Legacy SQL的一组有限的SQL操作。
- en: 'In the following screenshot, you can see how to change the **SQL dialect**:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的屏幕截图中，您可以查看如何更改**SQL方言**：
- en: '![Figure 3.3 – Screenshot of the Query Settings menu to change SQL dialect'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.3 – 更改SQL方言的查询设置菜单截图'
- en: '](img/B16722_03_003.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16722_03_003.jpg)'
- en: Figure 3.3 – Screenshot of the Query Settings menu to change SQL dialect
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3 – 更改SQL方言的查询设置菜单截图
- en: By default, the BigQuery UI is configured to use Standard SQL, but you are allowed
    to change the SQL dialect by using the specific option located in the `#legacySQL`
    keyword in the first line of your SQL statement. The **Query Settings** button
    is available under the **More** button in the BigQuery UI.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，BigQuery UI配置为使用Standard SQL，但您可以通过在SQL语句的第一行使用特定的选项来更改SQL方言，即位于`#legacySQL`关键字下的`更多`按钮。**查询设置**按钮位于BigQuery
    UI的**更多**按钮下。
- en: Tip
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: To develop new use cases, we suggest that you adopt BigQuery Standard SQL, but
    keep in mind that you could find existing applications that are still based on
    Legacy SQL. If you find a query that is not validated by the Query Editor, try
    to switch to Legacy SQL before intervening on the SQL statement.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开发新的用例，我们建议您采用BigQuery Standard SQL，但请记住，您可能会发现仍然基于Legacy SQL的现有应用程序。如果您发现查询未通过查询编辑器验证，请在干预SQL语句之前尝试切换到Legacy
    SQL。
- en: CRUD operations
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CRUD操作
- en: In this paragraph, we'll learn how to perform the basic commands in order to
    **Create, Read, Update and Delete** (**CRUD**) objects in BigQuery. This is not
    an exhaustive view of all the operations that you can use with BigQuery, but the
    goal of this section is to provide you with the minimum knowledge needed to effectively
    face the next hands-on chapters of this book.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在本段中，我们将学习如何执行基本命令，以便在BigQuery中**创建、读取、更新和删除**（**CRUD**）对象。这不是所有可以与BigQuery一起使用的操作的详尽视图，但本节的目标是提供您面对本书下一章的实际操作章节所需的最少知识。
- en: Create
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建
- en: 'This category of statements is generally used to create objects in BigQuery
    such as tables, views, **User-Defined Functions** (**UDFs**), and machine learning
    models, or to insert new records into an existing table:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这类语句通常用于在BigQuery中创建对象，如表、视图、**用户定义函数**（**UDFs**）和机器学习模型，或者向现有表中插入新记录：
- en: 'As a first step, let''s create a new empty table in BigQuery:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为第一步，让我们在BigQuery中创建一个新的空表：
- en: '[PRE0]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The first two words of the query statement, `CREATE TABLE`, are self-explanatory
    and are used to start the creation of a new table. After that, we can find the
    identifier of the object that we''re creating. It is composed by the concatenation
    of the following strings separated by the `.` character:'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 查询语句的前两个词`CREATE TABLE`是自解释的，用于开始创建新表的创建。之后，我们可以找到我们正在创建的对象的标识符。它由以下字符串通过`.`字符连接而成：
- en: 'The name of the GCP project: `bigqueryml-packt`'
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: GCP项目的名称：`bigqueryml-packt`
- en: 'The identifier of the BigQuery dataset: `03_bigquery_syntax`'
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: BigQuery数据集的标识符：`03_bigquery_syntax`
- en: 'The name of the table to create: `first_table`'
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要创建的表名：`first_table`
- en: The string of the identifier is also enclosed by the backtick character, ``
    ` ``. This character delimits the beginning and the end of the name of our object.
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 标识符的字符串也被反引号字符包围，即`` ` ``。这个字符界定了我们对象名称的开始和结束。
- en: 'Between the two round brackets, you can see the list of fields with their data
    type separated by the comma character. In this example, the table contains only
    two fields: the numerical `id_key` and the textual `description`.'
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在两个圆括号之间，你可以看到字段列表，字段类型通过逗号字符分隔。在这个例子中，表只包含两个字段：数值型的`id_key`和文本型的`description`。
- en: Tip
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 小贴士
- en: If a table with the same name already exists, it is possible to create a new
    table replacing the existing one using the `CREATE OR REPLACE TABLE` keywords.
    This technique is particularly useful when you need to periodically schedule your
    scripts running them multiple times. These keywords automatically clean the results
    of the previous executions.
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果已经存在具有相同名称的表，则可以使用`CREATE OR REPLACE TABLE`关键字创建一个新表来替换现有的表。这种技术在需要定期安排脚本多次运行时特别有用。这些关键字会自动清理先前执行的结果。
- en: 'Now that we''ve created our first empty table, let''s `INSERT` our first record:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经创建了我们第一个空表，让我们`INSERT`我们的第一条记录：
- en: '[PRE1]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: For the insertion of a new record into our `first_table`, we've used the `INSERT
    INTO` and `VALUES` keywords. Between the round brackets, we've listed the actual
    values to insert. In this case, we've chosen the integer number `1` as `id_key`
    and the string`'This is my first record inserted in BigQuery'` in single quotes.
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于将新记录插入到我们的`first_table`中，我们使用了`INSERT INTO`和`VALUES`关键字。在圆括号之间，我们列出了要插入的实际值。在这种情况下，我们选择了整数`1`作为`id_key`，以及字符串`'This
    is my first record inserted in BigQuery'`，并用单引号括起来。
- en: On top of a table, it is possible to create a `CREATE VIEW` statement is similar
    to the `CREATE TABLE` one, the only difference being that the view structure is
    based on the `SELECT` statement that follows the `AS` keyword. In this case, `first_view`
    has the same structure as `first_table` and doesn't apply any filters or transformations
    on the records stored in the table.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在表上方，可以创建一个类似于`CREATE TABLE`的`CREATE VIEW`语句，唯一的区别在于视图结构基于`AS`关键字后面的`SELECT`语句。在这种情况下，`first_view`具有与`first_table`相同的结构，并且不对存储在表中的记录应用任何过滤器或转换。
- en: Read
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 读取
- en: Read operations are mainly based on `SELECT` statements and can be applied to
    different database objects such as tables and views.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 读取操作主要基于`SELECT`语句，并且可以应用于不同的数据库对象，如表和视图。
- en: 'Let''s execute a `SELECT` statement on the `first_table` table:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`first_table`表上执行一个`SELECT`语句：
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: To read data from a table or a view, it is necessary to use the `SELECT` keyword,
    followed by the list of the fields to read or the wildcard `*`, then the keyword
    `FROM` and the identifier of the source data structure. It is also possible to
    include a `WHERE` clause to express all the logical filters that we want to apply.
    In this case, we're picking up only the records with `id_key=1` that corresponds
    to the only record that we've previously inserted into the table.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要从表或视图中读取数据，必须使用`SELECT`关键字，后跟要读取的字段列表或通配符`*`，然后是`FROM`关键字和源数据结构的标识符。还可以包含一个`WHERE`子句来表示我们想要应用的所有逻辑过滤器。在这种情况下，我们只选择具有`id_key=1`的记录，这与我们之前插入到表中的唯一记录相对应。
- en: Tip
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Using the wildcard `*` is not recommended, especially on tables with a large
    number of columns. Since BigQuery has columnar storage, selecting only the fields
    that are really needed can dramatically improve the performance and decrease the
    computational cost of the query.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 不建议使用通配符`*`，尤其是在具有大量列的表上。由于BigQuery具有列式存储，仅选择真正需要的字段可以显著提高查询的性能并降低计算成本。
- en: 'With hierarchical queries with nested `SELECT` statements, the `WITH` clause
    can be used to improve the readability of the query:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在具有嵌套`SELECT`语句的层次查询中，可以使用`WITH`子句来提高查询的可读性：
- en: 'As the first step, let''s create a nested `SELECT` statement:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为第一步，让我们创建一个嵌套的`SELECT`语句：
- en: '[PRE3]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'After that, we can rewrite the same logic using the `WITH` clause. The query
    becomes this:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们可以使用`WITH`子句重写相同的逻辑。查询变成了这个：
- en: '[PRE4]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the second query, the `WITH` clause embeds the logic that follows the `AS`
    keyword and is enclosed by round brackets. After the definition of the `WITH`
    clause with the name `records_with_clause`, the logic of this query can be recalled
    in the next `SELECT COUNT` statement.
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在第二个查询中，`WITH`子句嵌入了`AS`关键字后面的逻辑，并用圆括号括起来。在定义了名为`records_with_clause`的`WITH`子句之后，这个查询的逻辑可以在下一个`SELECT
    COUNT`语句中再次调用。
- en: Tip
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 小贴士
- en: The `WITH` clause doesn't create a temporary table. Using the `WITH` clause
    improves the readability of the query, especially if there are many nested `SELECT`
    statements, but it doesn't affect the performance of the query.
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`WITH`子句不会创建临时表。使用`WITH`子句可以提高查询的可读性，尤其是在存在多个嵌套`SELECT`语句的情况下，但它不会影响查询的性能。'
- en: 'BigQuery offers the possibility to leverage many other operators that will
    not be described in detail in this chapter because they will not be extensively
    used in the hands-on exercises. These additional operators allow you to do the
    following:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: BigQuery提供了利用许多其他操作符的可能性，这些操作符在本章中不会详细描述，因为它们在动手练习中不会广泛使用。这些附加操作符允许你执行以下操作：
- en: Sort the results of a query according to a specific list of fields with the
    `ORDER BY` clause.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`ORDER BY`子句根据特定的字段列表对查询结果进行排序。
- en: Apply aggregations on the query results with `COUNT`, `SUM`, `MAX`, `AVG`, and
    the `GROUP BY` and `HAVING` clauses.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`COUNT`、`SUM`、`MAX`、`AVG`以及`GROUP BY`和`HAVING`子句对查询结果应用聚合。
- en: Manage the array data type using `NEST`, `UNNEST`, `ARRAY_AGG`, and `ARRAY_LENGTH`.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `NEST`、`UNNEST`、`ARRAY_AGG` 和 `ARRAY_LENGTH` 管理数组数据类型。
- en: Join two or more tables with `INNER JOIN`, `LEFT OUTER JOIN`, `RIGHT OUTER JOIN`,
    and `CROSS JOIN`.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `INNER JOIN`、`LEFT OUTER JOIN`、`RIGHT OUTER JOIN` 和 `CROSS JOIN` 连接两个或多个表。
- en: Update
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新
- en: Although BigQuery was born as an analytic tool, update operations such as `UPDATE`
    and `MERGE` are supported and can be used to change existing records in BigQuery
    tables.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 BigQuery 是作为一个分析工具诞生的，但它支持更新操作，如 `UPDATE` 和 `MERGE`，并且可以用于更改 BigQuery 表中的现有记录。
- en: 'In order to change the value of a record or a set of records, we can use the
    `UPDATE` statement in the following way:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更改记录或记录集的值，我们可以使用以下方式的 `UPDATE` 语句：
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the first two lines of code, the `UPDATE` keyword is followed by the identifier
    of the table on which the operation should be applied. After that, the `SET` keyword
    defines the columns that should be changed. In this case, the `description` will
    be modified.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码的前两行中，`UPDATE` 关键字后面跟着要应用操作的表的标识符。之后，`SET` 关键字定义了应更改的列。在这种情况下，`description`
    将被修改。
- en: The `WHERE` clause allows you to apply the `UPDATE` operations only to the records
    that match the filter. In this case, only the records with an `id_key` equal to
    `1`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`WHERE` 子句允许您仅对匹配过滤器的记录应用 `UPDATE` 操作。在这种情况下，只有 `id_key` 等于 `1` 的记录受到影响。'
- en: The other powerful statement to update a table is the `MERGE` function. This
    function can combine the records of two different tables applying insert, update,
    and delete operations in a single SQL statement.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 更新表的另一个强大语句是 `MERGE` 函数。此函数可以在单个 SQL 语句中应用插入、更新和删除操作，以合并两个不同表的记录。
- en: Delete
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除
- en: 'Delete operations are particularly useful to delete records or remove objects
    from BigQuery preventing storage costs:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 删除操作特别有用，可以删除记录或从 BigQuery 中删除对象以防止存储成本：
- en: 'As a first step, we can delete a record from the `first_table` table, using
    the `DELETE` statement as follows:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为第一步，我们可以使用以下 `DELETE` 语句从 `first_table` 表中删除一条记录：
- en: '[PRE6]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If we analyze the SQL code, we can see that the `DELETE` keyword is followed
    by the identifier of the table on which the operation should be applied. The `WHERE`
    clause filters the set of records to delete. In this case, only the record with
    an `id_key` equal to `1` is affected.
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们分析 SQL 代码，我们可以看到 `DELETE` 关键字后面跟着要应用操作的表的标识符。`WHERE` 子句过滤要删除的记录集。在这种情况下，只有
    `id_key` 等于 `1` 的记录受到影响。
- en: 'Another way to remove records from a table is using the `TRUNCATE TABLE` operator.
    This function allows you to remove all the records with a single statement:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一种从表中删除记录的方法是使用 `TRUNCATE TABLE` 操作符。此函数允许您使用单个语句删除所有记录：
- en: '[PRE7]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: After the `TRUNCATE`, our `first_table` will continue to exist but will not
    contain any records.
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 `TRUNCATE` 之后，我们的 `first_table` 将继续存在，但将不包含任何记录。
- en: 'To delete the entire table, including its structure, we can use the `DROP TABLE`
    keywords:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要删除整个表及其结构，我们可以使用 `DROP TABLE` 关键字：
- en: '[PRE8]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Dropping a table removes it from the dataset, making the data structure inaccessible.
    If we explore the list of objects of the `03_bigquery_syntax` dataset, we can
    see that the `first_table` table is no longer visible:'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 删除表将从数据集中移除它，使得数据结构不可访问。如果我们探索 `03_bigquery_syntax` 数据集的对象列表，我们可以看到 `first_table`
    表不再可见：
- en: '![Figure 3.4 – The table that was affected by the DROP TABLE statement is no
    longer visible'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 3.4 – 受 `DROP TABLE` 语句影响的表不再可见'
- en: '](img/B16722_03_004.jpg)'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B16722_03_004.jpg]'
- en: Figure 3.4 – The table that was affected by the DROP TABLE statement is no longer
    visible
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 3.4 – 受 `DROP TABLE` 语句影响的表不再可见
- en: In this case, an interesting aspect is that `first_view`, created on top of
    the `first_table` table, is still visible.
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这种情况下，一个有趣的方面是，建立在 `first_table` 表之上的 `first_view` 仍然可见。
- en: If we try to execute a `SELECT` statement on it, the following error will be
    raised:![Figure 3.5 – Querying a view when the underlying table was dropped raises
    an error
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们尝试对其执行 `SELECT` 语句，将会引发以下错误：![图 3.5 – 当底层表被删除时查询视图会引发错误
- en: '](img/B16722_03_005.jpg)'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B16722_03_005.jpg]'
- en: Figure 3.5 – Querying a view when the underlying table was dropped raises an
    error
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 3.5 – 当底层表被删除时查询视图会引发错误
- en: The error, generated by BigQuery, notifies the user that the underlying table
    is no longer available and cannot be found.
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由 BigQuery 生成的错误会通知用户，底层表已不再可用且无法找到。
- en: 'To keep our dataset consistent, it is better to also drop the view with the
    `DROP VIEW` statement:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了保持我们的数据集一致性，最好也使用`DROP VIEW`语句删除视图：
- en: '[PRE9]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Dropping a view is similar to dropping a table, but this operation affects only
    the metadata because the view doesn't actually store any records.
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 删除视图类似于删除表，但这个操作只影响元数据，因为视图实际上并不存储任何记录。
- en: In this section of the chapter, we've discovered the main operations that we
    can do with BigQuery SQL; now it's time to dive into BigQuery ML and its syntax.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的这一部分，我们发现了我们可以使用BigQuery SQL执行的主要操作；现在是我们深入BigQuery ML及其语法的时候了。
- en: Diving into BigQuery ML
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入BigQuery ML
- en: 'Developing an ML model in BigQuery involves three main steps:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在BigQuery中开发ML模型涉及三个主要步骤：
- en: '**Model creation**, where you are required to choose the **features** and **labels**
    of your ML model and the options to tune the ML model. At this stage, BigQuery
    runs the training of the ML model on the training set that you''ve chosen.'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**模型创建**，在这个阶段，你需要选择ML模型的**特征**和**标签**以及调整ML模型的选项。在这个阶段，BigQuery将在你选择的训练集上运行ML模型的训练。'
- en: '**Model evaluation** allows you to test the model trained in the previous step
    on a different set of records to prevent any **overfitting**.'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**模型评估**允许你在不同的记录集上测试之前步骤中训练的模型，以防止任何**过拟合**。'
- en: '**Model use**: when the ML model is ready, we can apply it to a new dataset
    in order to make predictions or classifications of the labels according to the
    available features.'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**模型使用**：当ML模型准备就绪时，我们可以将其应用于新的数据集，以便根据可用的特征进行预测或标签分类。'
- en: In the next paragraphs, we'll take a look at the syntax of these three stages
    and how these statements are built using stubs of code.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的段落中，我们将查看这三个阶段的语法以及这些语句是如何使用代码占位符构建的。
- en: Creating the ML model (training)
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建ML模型（训练）
- en: 'When you''ve identified the ML use case and also the set of records to train
    your model, you can start training the model with the following query:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当你确定了ML用例以及用于训练模型的记录集后，你可以开始使用以下查询来训练模型：
- en: '[PRE10]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Very similarly to the creation of a BigQuery table, the statement to train
    a new model consists of the following:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 与创建BigQuery表的创建过程非常相似，训练新模型的语句包括以下内容：
- en: The `CREATE MODEL` keywords.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CREATE MODEL`关键字。'
- en: Then the name of the new ML model. This identifier is composed of the concatenation
    of the project name, dataset name, and ML model name, separated by the `.` character
    and enclosed by backticks.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后是新ML模型的名称。这个标识符由项目名称、数据集名称和ML模型名称的连接组成，由`.`字符分隔，并用反引号包围。
- en: The `TRANSFORM` clause is not mandatory but is very useful. It allows us to
    list all the preprocessing transformations applied to the features before training.
    Putting the preparation functions here allows us to automatically apply the same
    actions during the actual use of the model.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TRANSFORM`子句不是必需的，但非常有用。它允许我们列出在训练之前应用于特征的预处理转换。将这些准备函数放在这里允许我们在实际使用模型时自动应用相同的操作。'
- en: A list of `OPTIONS` requires us to specify the `model_type` that we want to
    use, such as linear regression or logistic regression. This list of options is
    also used to select the list of labels of the ML model through the `input_label_cols`
    keyword. Other options can be used to tune the ML model and will be explained
    in the next chapters of the book, with the hands-on exercises.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`OPTIONS`列表要求我们指定我们想要使用的`model_type`，例如线性回归或逻辑回归。这个选项列表也用于通过`input_label_cols`关键字选择ML模型的标签列表。其他选项可以用来调整ML模型，这些将在本书的下一章节中解释，并伴有实际操作练习。
- en: The `AS` keyword followed by the `SELECT` statement. This statement defines
    the set of records on which the ML model will be trained.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AS`关键字后跟`SELECT`语句。这个语句定义了ML模型将要训练的记录集。'
- en: 'In addition to the `CREATE MODEL` statement, we can also use the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`CREATE MODEL`语句之外，我们还可以使用以下内容：
- en: '`CREATE OR REPLACE MODEL` to create a new model or replace the existing one
    with the same name.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`CREATE OR REPLACE MODEL`创建新模型或用相同名称替换现有模型。
- en: '`CREATE MODEL IF NOT EXISTS` to train the new model only if a model with the
    same name doesn''t exist.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`CREATE MODEL IF NOT EXISTS`仅在不存在具有相同名称的模型时训练新模型。
- en: 'Now that we''ve understood how to create an ML model in BigQuery ML, let''s
    take a look at the next phase: the evaluation of the model.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何在BigQuery ML中创建ML模型，让我们看看下一个阶段：模型的评估。
- en: Evaluating the ML model
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 评估ML模型
- en: After training an ML model on a set of records, it is extremely important to
    evaluate its performances on a second dataset that's different from the training
    one to avoid any **overfitting**.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在一组记录上训练ML模型后，极其重要的是在不同于训练集的第二数据集上评估其性能，以避免任何**过拟合**。
- en: Important note
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: With the term overfitting, we refer to a situation that could happen when the
    ML model learns very well from the training dataset but performs negatively on
    new ones. This usually happens when the model adheres too much to the details
    of the training dataset and remains conditioned by the noise present in it.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在术语过拟合中，我们指的是当ML模型从训练数据集中学习得很好，但在新的数据集上表现不佳的情况。这通常发生在模型过于依赖训练数据集的细节，并受到其中存在的噪声的影响。
- en: According to the ML algorithm that we've chosen during the model creation, we
    can choose among different evaluation functions.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 根据在模型创建过程中选择的ML算法，我们可以选择不同的评估函数。
- en: Evaluate function
  id: totrans-125
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 评估函数
- en: 'This function can be used with linear regression, logistic regression, *k*-means
    clustering, matrix factorization, and time-series models based on ARIMA:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数可用于线性回归、逻辑回归、*k*-均值聚类、矩阵分解和基于ARIMA的时间序列模型：
- en: '[PRE11]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `ML.EVALUATE` function returns only one record with the key performance
    indicators of the ML model that we''ve trained and evaluated. The indicator it
    returns depend on the model type. The query stub is composed of the following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`ML.EVALUATE`函数仅返回一条记录，其中包含我们已训练和评估的ML模型的关键性能指标。它返回的指标取决于模型类型。查询占位符由以下组成：'
- en: An initial `SELECT *` statement that allows us to retrieve all the fields returned
    by the evaluation stage.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个初始的`SELECT *`语句，允许我们检索评估阶段返回的所有字段。
- en: 'The call of the evaluation function from the `ML` package: `ML.EVALUATE`.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从`ML`包中调用评估函数：`ML.EVALUATE`。
- en: 'The identifier of the ML model with the syntax that we already know very well:
    project, dataset, and model name.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们非常熟悉的ML模型标识符的语法：项目、数据集和模型名称。
- en: The `<evaluation_table>` on which the ML model will be evaluated. This table
    can be replaced by a `SELECT` statement and is not mandatory. If you don't provide
    the table for the evaluation stage, BigQuery will use the entire training set
    or a portion of it to evaluate your ML model.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<evaluation_table>`是将在其上评估ML模型的表格。此表可以用`SELECT`语句替换，不是强制的。如果您不提供评估阶段的表，BigQuery将使用整个训练集或其一部分来评估您的ML模型。'
- en: An optional `<threshold>` that can be used to evaluate logistic regression models.
    If this value is not specified, BigQuery will use `0.5` as the default value.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选的`<threshold>`，可用于评估逻辑回归模型。如果此值未指定，BigQuery将使用`0.5`作为默认值。
- en: Tip
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 小贴士
- en: To use the `ML.EVALUATE` function, the name of the fields of the evaluation
    set should correspond to the name of the fields of the training dataset that we've
    used during the model creation.
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要使用`ML.EVALUATE`函数，评估集的字段名称应与在模型创建期间使用的训练数据集的字段名称相匹配。
- en: Confusion matrix function
  id: totrans-136
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 混淆矩阵函数
- en: 'This function returns a confusion matrix to evaluate the performances of logistic
    regression and multiclass logistic regression models:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数返回一个混淆矩阵来评估逻辑回归和多类逻辑回归模型的性能：
- en: '[PRE12]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This function returns two rows and two columns that contain the number of false
    positives, false negatives, true positives, and true negatives. Compared to the
    `EVALUATE` function, the only difference in terms of syntax is represented by
    the use of the `ML.CONFUSION_MATRIX` function.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数返回两行两列，包含假阳性、假阴性、真阳性和真阴性的数量。与`EVALUATE`函数相比，在语法方面的唯一区别是通过使用`ML.CONFUSION_MATRIX`函数来表示。
- en: ROC curve function
  id: totrans-140
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: ROC曲线函数
- en: 'This function can be used only with logistic regression models and returns
    multiple records according to the array of thresholds that are passed as input
    to the function:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数只能用于逻辑回归模型，并根据传递给函数的阈值数组返回多个记录：
- en: '[PRE13]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The only meaningful difference that we can see from the other evaluation functions
    that we analyzed in the previous paragraphs is the presence of an array of thresholds.
    The `GENERATE_ARRAY` function creates an array that contains the values of the
    thresholds separated by the comma character and enclosed by round brackets.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从上一段分析的其他评估函数中看到的唯一有意义的区别是存在一个阈值数组。`GENERATE_ARRAY`函数创建一个数组，其中包含由逗号分隔的阈值值，并用圆括号括起来。
- en: The output of this function includes the threshold passed in input, the recall
    value, the rate of false positives, and the number of true positives, false positives,
    true negatives, and false negatives.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数的输出包括输入的阈值、召回值、假阳性率以及真阳性、假阳性、真阴性和假阴性的数量。
- en: We have been through all the evaluation techniques of BigQuery ML models, now
    it's time to see how to apply them and get the results.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了 BigQuery ML 模型的所有评估技术，现在是时候看看如何应用它们并获取结果了。
- en: Using the ML model
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 ML 模型
- en: When we're satisfied with the performance of our ML model, the next step is
    to use it to achieve our outcomes and finally get business value from the implementation.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们对我们的 ML 模型的性能满意时，下一步就是使用它来实现我们的目标，并最终从实施中获得商业价值。
- en: Predict function
  id: totrans-148
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 预测函数
- en: 'This function is applicable to linear regression, logistic regression, multiclass
    logistic regression, *k*-means clustering, and imported TensorFlow models:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数适用于线性回归、逻辑回归、多类逻辑回归、*k*-均值聚类和导入的 TensorFlow 模型：
- en: '[PRE14]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The query is composed of the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 查询由以下内容组成：
- en: The `SELECT * FROM` statement to get all the records and fields returned by
    `ML.PREDICT` function.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `SELECT * FROM` 语句获取 `ML.PREDICT` 函数返回的所有记录和字段。
- en: The `ML.PREDICT` keyword, which accepts as input the name of the ML model to
    use for the prediction (`<ml_model_name>`) and the table (`<features_table>`)
    that contains the features to execute the predictions.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ML.PREDICT` 关键字，它接受用于预测的 ML 模型名称（`<ml_model_name>`）和包含要执行预测的特征的表（`<features_table>`）作为输入。'
- en: Optionally, you can use a `<threshold>` value for the logistic regression models
    followed by the `AS threshold` keywords.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选地，您可以为逻辑回归模型使用 `<threshold>` 值，后跟 `AS threshold` 关键字。
- en: The `ML.PREDICT` function generates and returns a record for each row present
    in `<features_table>.` Each row is composed of the features and the predicted
    labels.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`ML.PREDICT` 函数为 `<features_table>` 中的每一行生成并返回一个记录。每一行由特征和预测标签组成。'
- en: Forecast function
  id: totrans-156
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 预测函数
- en: 'This function can only be used for time-series ML models:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数只能用于时间序列 ML 模型：
- en: '[PRE15]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Unlike the `PREDICT` statement, it doesn''t require a table as input. It allows
    us to choose the following:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `PREDICT` 语句不同，它不需要表作为输入。它允许我们选择以下内容：
- en: A specific `<horizon_value>`. The horizon represents the number of time points
    that should be forecast. If you don't specify this value, BigQuery will use `3`
    as the default.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个特定的 `<horizon_value>`。范围代表应预测的时间点数量。如果您不指定此值，BigQuery 将使用 `3` 作为默认值。
- en: A `confidence_level`, which represents the percentage of the forecast values
    that reside in the interval of the prediction.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`confidence_level`，表示预测值中位于预测区间内的百分比。'
- en: Recommend function
  id: totrans-162
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 推荐函数
- en: 'This function can only be used for matrix factorization ML models. It returns
    a rating for each combination of user and item in the `<user_item_table>` table
    or in the training table:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数只能用于矩阵分解 ML 模型。它为 `<user_item_table>` 表或训练表中的每个用户和物品组合返回一个评分：
- en: '[PRE16]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The query is composed of the following:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 查询由以下内容组成：
- en: The `SELECT * FROM` statement to get all the records and fields that come from
    the outcome of the `ML.RECOMMEND` function.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `SELECT * FROM` 语句获取来自 `ML.RECOMMEND` 函数结果的记录和字段。
- en: The `ML.RECOMMEND` keyword, which accepts as input the name of the ML model
    to use for the prediction (`<ml_model_name>`) and, optionally, the input table
    (`<user_item_table>`), which contains the user and items. If the table is not
    provided, BigQuery will use the entire training table for the recommendation.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ML.RECOMMEND` 关键字，它接受用于预测的 ML 模型名称（`<ml_model_name>`）作为输入，可选地，还包括包含用户和物品的输入表（`<user_item_table>`）。如果未提供表，BigQuery
    将使用整个训练表进行推荐。'
- en: We've learned how to apply a BigQuery ML model; if the model is no longer needed,
    it is best to delete it to save resources. Let's take a look at how we can do
    that.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了如何应用 BigQuery ML 模型；如果模型不再需要，最好删除它以节省资源。让我们看看我们如何做到这一点。
- en: Deleting an ML model
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除 ML 模型
- en: 'Deleting an ML model is quite straightforward, and the syntax is very similar
    to the cancellation of a table:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 删除 ML 模型相当简单，语法与取消表类似：
- en: '[PRE17]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: With the `DROP MODEL` keywords followed by the identifier of the BigQuery ML
    model, you can remove the asset from your dataset.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `DROP MODEL` 关键字后跟 BigQuery ML 模型的标识符，您可以从数据集中删除该资产。
- en: 'You can also use the `DROP MODEL IF EXISTS` keywords, which prevents errors
    if the BigQuery ML model has been already deleted. This operation removes the
    model only if it is present in the dataset:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 `DROP MODEL IF EXISTS` 关键字，这可以防止如果 BigQuery ML 模型已经被删除时发生错误。此操作仅在模型存在于数据集中时才会删除模型：
- en: '[PRE18]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: When the model is deleted, we can be sure that no resources are consumed to
    keep it active in BigQuery.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当模型被删除时，我们可以确信不会消耗资源来保持它在 BigQuery 中的活跃状态。
- en: Summary
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we've learned the main aspects of the BigQuery syntax. After
    the creation of a dataset, we've discovered how to create tables, insert records,
    and read the rows stored in a table. You've also learned how to update existing
    records and how to remove rows and delete objects that are no longer useful, such
    as tables and views.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了 BigQuery 语法的要点。在创建数据集之后，我们发现了如何创建表、插入记录以及读取存储在表中的行。你还学习了如何更新现有记录以及如何删除不再有用的行和对象，例如表和视图。
- en: Completing the overview of the BigQuery SQL syntax, we dived into the main stages
    of the life cycle of an ML model. The three main phases to realize a use case
    are the creation, the evaluation, and the use of the ML model. For the training
    phase, we have found out how to train and create a new model using SQL. After
    that, we went through all the functions that can be used to monitor the effectiveness
    of a trained model, evaluating its key performance indicators. Finally, we saw
    how to use a trained model on a new dataset to infer the results and get predictions,
    forecasts, or recommendations. At the end of the chapter, we also learned how
    to delete BigQuery ML models that are no longer useful.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 完成对 BigQuery SQL 语法的概述后，我们深入探讨了 ML 模型生命周期的主要阶段。实现用例的三个主要阶段是创建、评估和使用 ML 模型。对于训练阶段，我们了解到如何使用
    SQL 训练和创建新模型。之后，我们了解了所有可以用来监控训练模型有效性的函数，评估其关键性能指标。最后，我们看到了如何在新数据集上使用训练模型进行推断以获得结果和预测、预报或建议。在本章结束时，我们还学习了如何删除不再有用的
    BigQuery ML 模型。
- en: Now that we have a clear understanding of the syntax and all the capabilities
    that we can use in BigQuery, it's time to apply all these concepts to our first
    hands-on use case. In the next chapter, we will develop our first BigQuery ML
    model to predict the estimated duration of a bike trip for an important bike rental
    service in New York City.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经清楚地理解了语法以及我们可以在 BigQuery 中使用的所有功能，是时候将这些概念应用到我们的第一个实际案例中。在下一章中，我们将开发我们的第一个
    BigQuery ML 模型，用于预测纽约市一个重要自行车租赁服务中自行车行程的估计时长。
- en: Further resources
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多资源
- en: '**BigQuery datasets**: [https://cloud.google.com/bigquery/docs/datasets](https://cloud.google.com/bigquery/docs/datasets)'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**BigQuery 数据集**: [https://cloud.google.com/bigquery/docs/datasets](https://cloud.google.com/bigquery/docs/datasets)'
- en: '**BigQuery SQL syntax**: [https://cloud.google.com/bigquery/docs/reference/standard-sql/query-syntax](https://cloud.google.com/bigquery/docs/reference/standard-sql/query-syntax)'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**BigQuery SQL 语法**: [https://cloud.google.com/bigquery/docs/reference/standard-sql/query-syntax](https://cloud.google.com/bigquery/docs/reference/standard-sql/query-syntax)'
- en: '**BigQuery data types**: [https://cloud.google.com/bigquery/docs/reference/standard-sql/data-types](https://cloud.google.com/bigquery/docs/reference/standard-sql/data-types)'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**BigQuery 数据类型**: [https://cloud.google.com/bigquery/docs/reference/standard-sql/data-types](https://cloud.google.com/bigquery/docs/reference/standard-sql/data-types)'
- en: '**Create model syntax**: [https://cloud.google.com/bigquery-ml/docs/reference/standard-sql/bigqueryml-syntax-create](https://cloud.google.com/bigquery-ml/docs/reference/standard-sql/bigqueryml-syntax-create)'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建模型语法**: [https://cloud.google.com/bigquery-ml/docs/reference/standard-sql/bigqueryml-syntax-create](https://cloud.google.com/bigquery-ml/docs/reference/standard-sql/bigqueryml-syntax-create)'
- en: '**Evaluate syntax**: [https://cloud.google.com/bigquery-ml/docs/reference/standard-sql/bigqueryml-syntax-evaluate](https://cloud.google.com/bigquery-ml/docs/reference/standard-sql/bigqueryml-syntax-evaluate)'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**评估语法**: [https://cloud.google.com/bigquery-ml/docs/reference/standard-sql/bigqueryml-syntax-evaluate](https://cloud.google.com/bigquery-ml/docs/reference/standard-sql/bigqueryml-syntax-evaluate)'
- en: '**Confusion matrix syntax**: [https://cloud.google.com/bigquery-ml/docs/reference/standard-sql/bigqueryml-syntax-confusion](https://cloud.google.com/bigquery-ml/docs/reference/standard-sql/bigqueryml-syntax-confusion)'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**混淆矩阵语法**: [https://cloud.google.com/bigquery-ml/docs/reference/standard-sql/bigqueryml-syntax-confusion](https://cloud.google.com/bigquery-ml/docs/reference/standard-sql/bigqueryml-syntax-confusion)'
- en: '**ROC curve syntax**: [https://cloud.google.com/bigquery-ml/docs/reference/standard-sql/bigqueryml-syntax-roc](https://cloud.google.com/bigquery-ml/docs/reference/standard-sql/bigqueryml-syntax-roc)'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ROC曲线语法**: [https://cloud.google.com/bigquery-ml/docs/reference/standard-sql/bigqueryml-syntax-roc](https://cloud.google.com/bigquery-ml/docs/reference/standard-sql/bigqueryml-syntax-roc)'
- en: '**Predict syntax**: [https://cloud.google.com/bigquery-ml/docs/reference/standard-sql/bigqueryml-syntax-predict](https://cloud.google.com/bigquery-ml/docs/reference/standard-sql/bigqueryml-syntax-predict)'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**预测语法**: [https://cloud.google.com/bigquery-ml/docs/reference/standard-sql/bigqueryml-syntax-predict](https://cloud.google.com/bigquery-ml/docs/reference/standard-sql/bigqueryml-syntax-predict)'
- en: '**Forecast syntax**: [https://cloud.google.com/bigquery-ml/docs/reference/standard-sql/bigqueryml-syntax-forecast](https://cloud.google.com/bigquery-ml/docs/reference/standard-sql/bigqueryml-syntax-forecast)'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**预测语法**: [https://cloud.google.com/bigquery-ml/docs/reference/standard-sql/bigqueryml-syntax-forecast](https://cloud.google.com/bigquery-ml/docs/reference/standard-sql/bigqueryml-syntax-forecast)'
- en: '**Recommend syntax**: [https://cloud.google.com/bigquery-ml/docs/reference/standard-sql/bigqueryml-syntax-recommend](https://cloud.google.com/bigquery-ml/docs/reference/standard-sql/bigqueryml-syntax-recommend)'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**推荐语法**: [https://cloud.google.com/bigquery-ml/docs/reference/standard-sql/bigqueryml-syntax-recommend](https://cloud.google.com/bigquery-ml/docs/reference/standard-sql/bigqueryml-syntax-recommend)'
