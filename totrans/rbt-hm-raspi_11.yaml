- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Controlling Motion with Encoders on Raspberry Pi Pico
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far in this book, we’ve added sensors to our robot that can track counts
    as its wheels turn. We’ve also looked at a PID algorithm to close the robot control
    loop. We can combine these concepts to control our motors and wheels more precisely.
  prefs: []
  type: TYPE_NORMAL
- en: This combination will let us maintain a known speed on each motor and correct
    their relative speeds for a straight line. Encoders with some geometry will let
    us drive the robot a predetermined distance.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Converting an encoder count into a speed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using PID to maintain speed and a straight line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Driving a known distance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this chapter, you will require the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The robot from [*Chapter 10*](B18001_10.xhtml#_idTextAnchor210), *Using the
    PID Algorithm to* *Follow Walls*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The robot, encoder, and PID code from [*Chapter 10*](B18001_10.xhtml#_idTextAnchor210)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Around 2 square meters of floor to test the robot on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Digital calipers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A PC or laptop with Python 3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Android/iOS smartphone with Bluetooth LE
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find the code for this chapter at [https://github.com/PacktPublishing/Robotics-at-Home-with-Raspberry-Pi-Pico/tree/main/ch-11](https://github.com/PacktPublishing/Robotics-at-Home-with-Raspberry-Pi-Pico/tree/main/ch-11).
  prefs: []
  type: TYPE_NORMAL
- en: Converting an encoder count into a speed
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 6*](B18001_06.xhtml#_idTextAnchor115), *Measuring Movement with
    Encoders on Raspberry Pi Pico*, we used PIO to retrieve a count from the motor
    encoding sensors. We ended that chapter by measuring for movement and counting
    encoder transitions over some time.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will relate wheel geometry to the encoder. Then, we will
    use that to convert encoder counts into a speed or a distance.
  prefs: []
  type: TYPE_NORMAL
- en: Loose bolts and nuts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Vibration can sometimes cause nuts to drop out – a tiny dab of nail varnish
    across the nut and thread can reduce this.
  prefs: []
  type: TYPE_NORMAL
- en: Robot wheel geometry
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Calculating the distance traveled by a wheel requires its circumference. Let’s
    start by measuring the diameter of the wheel, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1 – Measuring wheels with calipers ](img/Figure_11.1_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.1 – Measuring wheels with calipers
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding diagram shows how you can measure wheel diameter with digital
    calipers. The diameter can be used in our code directly. In `robot.py`, add your
    measurement rounded to the nearest 0.1 mm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code calculates the circumference from the diameter. Each time
    a wheel makes a complete turn, it will move the wheel circumference in that direction,
    so we can already convert between wheel revolutions and distance. Next, we need
    the encoder details.
  prefs: []
  type: TYPE_NORMAL
- en: Encoder geometry
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [*Chapter 6*](B18001_06.xhtml#_idTextAnchor115), *Measuring Movement with
    Encoders on Raspberry Pi Pico*, we found the number of poles on the encoder and
    the number of encoder revolutions per revolution. The N20 built-in magnetic encoders
    produce 28 edges or state changes for each encoder disk revolution. We then multiply
    this by the gear ratio 298:1.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can add these calculations (use your motor gear ratio) to `robot.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We use m and m/s since this puts distances and speeds in the same order as the
    motor speeds.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can use these geometry measurements to get a speed.
  prefs: []
  type: TYPE_NORMAL
- en: Measuring the speed of each wheel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will calculate the speed of each wheel using the speed triangle from physics:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.2 – The speed triangle ](img/Figure_11.2_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.2 – The speed triangle
  prefs: []
  type: TYPE_NORMAL
- en: 'The triangle in the preceding diagram shows distance over speed and time. We
    want speed, so we get distance over time by covering speed. We can also see m/s.
    In our code, we’ll need to convert the difference in encoder ticks into a distance
    in m, then divide that by the time the difference covers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We can use this calculation in an app to demonstrate the principle.
  prefs: []
  type: TYPE_NORMAL
- en: Planning a speed-measurement app
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can build an app to demonstrate this and try different speeds. Using a UART
    command system will make it interactive.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll build the app using `asyncio` – asynchronous input/output. `asyncio`
    lets us run a few tasks simultaneously on the robot. Most tasks sleep between
    events, and CircuitPython can run another task during that time. The app must
    perform the following tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Measure the encoders, convert them into a speed value, and send this value to
    the UART.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accept the control commands to change settings or drive for a while.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stop the robot after a specific time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The command handlers we’ll want for this robot are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`M0.7`: Set the motors speed to 0.7'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`T0.3`: Change the measuring time interval to 0.3'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`G3.0`: Go (start moving) for 3 seconds, then stop'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`G`: Stop the robot from moving immediately'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the design created, let’s build the app.
  prefs: []
  type: TYPE_NORMAL
- en: Speed measurement app
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will use the Adafruit `asyncio` library with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we’ll move the UART into the `robot.py` file. At the imports, add the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'With that, the UART has been set up for any further examples. We will also
    add a convenience function at the end of `robot.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This wraps the usual interaction of adding a new line and encoding a message
    into bytes on the UART.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a new folder, `measuring_wheel_speeds`, make a new `code.py` file starting
    with the following imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: These imports are familiar; however, instead of `time`, we are importing `asyncio`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create a `Settings` class to store the current settings, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This groups the settings; different tasks can access them. `speed` is the motor
    speed, and `time_interval` is how frequently the code will read the encoders.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s learn how to handle the encoders:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We use `async def` to turn the function into an async task. We are computing
    encoder differences, so we keep a last value. We start this with the current encoder
    reading.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we go into the sensor reading loop, which uses `sleep` to keep that time
    interval:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This code performs an asynchronous sleep, allowing other tasks to run. We must
    read both sensors again, getting new values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We get the speed by subtracting the last value from the new one. Then, we convert
    that into meters and divide it by the time interval to get a speed in meters per
    second.
  prefs: []
  type: TYPE_NORMAL
- en: 'We must also remember to update the last value. We can repeat this for the
    right sensor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We can finish the motor speed loop by printing the speeds to the UART:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Notice `,0` at the end of the UART output. We must add this to anchor the graph
    at 0 so that the plot shows the speed relative to zero.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next component we’ll need is the motor stop task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This task will simply wait the given seconds and stop the robot’s motors.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will also need a UART command handler in an async task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Sending `G3.0` instructs the robot to wait 5 seconds, drive, and stop after
    3 seconds. This 5-second wait allows the user to start the plot tab before the
    robot starts moving.
  prefs: []
  type: TYPE_NORMAL
- en: The sleep commands now use `asyncio.sleep`. We also use `asyncio.sleep(0)` to
    let other tasks run while waiting for UART input.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we start the motor speed loop and the command handler, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Is this multithreaded?
  prefs: []
  type: TYPE_NORMAL
- en: Async code is not multithreaded. Instead, when an `asyncio.sleep` is used, control
    is passed to another async block waiting to run. As a result, async code tasks
    do not access variables simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: Send this all to the robot. Now, let’s see how this works and test it.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the speed measurement app
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I recommend propping the robot on a box for the first test so that its wheels
    aren’t in contact with anything.
  prefs: []
  type: TYPE_NORMAL
- en: 'Connect to the robot with the Bluefruit LE Connect app and use the UART menu
    item. You should see zeros. Send `G20`, which should start the motors moving,
    and then press the back button and select the plot mode. You will see a graph
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.3 – Encoder speed with glitches ](img/Figure_11.3_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.3 – Encoder speed with glitches
  prefs: []
  type: TYPE_NORMAL
- en: The preceding plot shows speed versus time from our robot. The *y* axis is the
    speed, while the *x* axis is the time in seconds. There is a clear 0 line. The
    graph then shows the two motor speeds. There are glitches – the speed drops to
    zero and then doubles.
  prefs: []
  type: TYPE_NORMAL
- en: Fixing the encoder glitches
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These glitches are due to an interaction between our read loop and the encoders.
    Plotting on a UART makes 0.2 s (5 times per second) a good time base. However,
    our PIO outputs encoder counts as often as they change. The PIO outputs these
    counts to an RX FIFO queue – see [*Chapter 6*](B18001_06.xhtml#_idTextAnchor115),
    *Measuring Movement with Encoders on Raspberry* *Pi Pico*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The PIO `push nowait` instruction will write no more data when the FIFO queue
    is full, but the encoder code continues counting pulses. We can use another `asyncio`
    task to read data more frequently from the FIFO queue. In the imports at the top
    of `pio_encoder.py`, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following method somewhere under `QuadratureEncoder`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Once started, this will continuously read the data into the buffer as frequently
    as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we must modify the `QuadratureEncoder.__init__` method to create a task
    for this. Add the highlighted line shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `read` method can then return the most recent item from the buffer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We can now use this encoder code in our async code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Reupload the `pio_encoder.py` file so that we can try again. Start the motors
    with `G5` and switch to the plot screen; you should see a plot like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.4 – Speed measurement without the glitches ](img/Figure_11.4_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.4 – Speed measurement without the glitches
  prefs: []
  type: TYPE_NORMAL
- en: The graph now shows the speed of both motors without the glitches. It is a bit
    noisy, and one line is slightly higher than the other. One of the motors is also
    quicker. The robot is moving at around 0.2 m/s. Battery freshness will affect
    the speed.
  prefs: []
  type: TYPE_NORMAL
- en: If you are not seeing this, please check that the encoders are reporting correctly
    with the examples provided in [*Chapter 6*](B18001_06.xhtml#_idTextAnchor115),
    *Measuring Movement with Encoders on Raspberry* *Pi Pico*.
  prefs: []
  type: TYPE_NORMAL
- en: We can use this measurement to drive a known distance, but it’s now clear that
    the robot won’t drive in a straight line like this. So, in the next section, we’ll
    correct the differences between the motors.
  prefs: []
  type: TYPE_NORMAL
- en: Using PID to maintain speed and a straight line
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we’ll learn how to combine the motor distance measurement with
    a PID controller driving each motor, moving at a particular speed, and keeping
    the robot straight. Let’s start by understanding this system.
  prefs: []
  type: TYPE_NORMAL
- en: The speed control system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can set a target speed in meters per second for the robot and compare the
    converted wheel speeds with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows how we’ll use this to regulate the robot’s driving
    speed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.5 – Controlling the speed of two motors ](img/Figure_11.5_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.5 – Controlling the speed of two motors
  prefs: []
  type: TYPE_NORMAL
- en: The preceding diagram shows the control system. It starts at the left from a
    set speed and compares that with the actual speed. The actual speed comes from
    the encoders, with their ticks converted into m/s. The error is the difference
    between the speeds.
  prefs: []
  type: TYPE_NORMAL
- en: The error goes into the PID controller, which then produces an acceleration
    for the motor PWM. The motor power will increase for a positive control signal
    or decrease for a negative one. This control system repeats for each wheel.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are building on the motor start/stop with the timer control we used previously.
    However, with a PID controller, this can cause the integral to wind up and accumulate
    errors. Let’s extend the `PIDController` class in `pid_controller.py` so that
    we can reset this. Make the highlighted change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We’ve moved the initial value settings out to a `reset` method, which we now
    use in the `__init__` method.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand this concept, we can build the code.
  prefs: []
  type: TYPE_NORMAL
- en: Speed control code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s build our speed controller code. In a new folder, `speed_control`, add
    a new `code.py` file. We will start with the regular imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll add settings that we can adjust to control the system when the program
    is running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We have a `speed` in m/s. This should be close to the speed you measured previously.
    We also added a `time_interval` for the loop and specified if the motors should
    currently be driving.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we must add a `SpeedController` class, which we can use for each wheel
    system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We provide each `SpeedController` system with an encoder to read and a motor
    function (`motor_fn`) to apply control signals. The `SpeedController` creates
    a `PIDController`. Each wheel will get an independent `PIDController`. This then
    calls a `reset` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This code puts the first read of the encoder into `last_ticks`, which we’ll
    update when we get a reading. `pwm` is how much power we will give the motors.
    We track `actual_speed` so that we can print this value to the UART later. We
    also reset the PIDs so that any stored integral is gone.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need a method to update this control system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This `update` method takes a delta time in seconds. While this might be close
    to `time_interval`, we need to be accurate when calculating the speed or updating
    the PID.
  prefs: []
  type: TYPE_NORMAL
- en: The method reads the current encoder value and subtracts the previous encoder
    reading to get a distance in encoder ticks. To turn this into a speed, we must
    divide this by time. We must update `self.last_ticks` here for the next cycle.
    The speed is more useful to us in m/s, so we convert it using `ticks_to_m`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now use this to update the PID and control the motors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We multiply the `pwm` output setting with the `enabled` flag so that the motors
    will stop if the motors are disabled. We subtract the actual speed from this to
    get the `error` value.
  prefs: []
  type: TYPE_NORMAL
- en: The code gets `control_signal` from the PID calculation with `error` and delta
    time. We then use this to accelerate/decelerate `pwm`, which goes into the motor
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use this system to control both motors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need an async loop to drive the system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, this loop will sleep every interval and update the time, so we have
    an accurate delta time (`dt`) value. We can use this to update both sides:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: After updating both sides, we can send the expected speed versus the actual
    speed to be plotted via UART.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’ll add a modified `stop_motors_after` async function that updates
    the `motors_enabled` flag; it will not call the `stop` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We want to be able to interact with this. We’ll need the `command_handler`
    function from the speed measuring app with the highlighted differences:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: When we send a `G<n>` command to start the robot moving, we reset left and right,
    resetting both the previous encoder value and PID integrals. Otherwise, we may
    have an old encoder setting, and the integral may still hold a value from a previous
    movement.
  prefs: []
  type: TYPE_NORMAL
- en: 'All that is left is to start this all up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This has been wrapped in an additional `try`/`finally` block that ensures the
    movement task is stopped and the robot is stopped if an error occurs.
  prefs: []
  type: TYPE_NORMAL
- en: This code is complete. Send it to the robot along with `robot.py`, `pid_controller.py`,
    and `pio_encoder.py`.
  prefs: []
  type: TYPE_NORMAL
- en: Ensure the motors are powered on and use the Bluefruit Connect app to send the
    `G10` sequence so that the robot starts moving. I propped the robot up so that
    its wheels could turn without moving it to initially test this code. This test
    also lets me keep it connected via USB to see any code errors.
  prefs: []
  type: TYPE_NORMAL
- en: Speed controller PID tuning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The PID values are likely to need tuning here. The values that worked in my
    experiments were `P`: 3, `I`: 0, and `D`:1\. The `P` factor will continue accelerating
    so long as there’s a difference, with the `D` value damping any sudden changes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'I was able to start with a low `P` value and, using the plot, adjust upward
    if the overshoot wasn’t too great. The following plots show how this system responds:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.6 – Speed controller response plots ](img/Figure_11.6_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.6 – Speed controller response plots
  prefs: []
  type: TYPE_NORMAL
- en: The preceding graphs show the speed controller system. There are two plots –
    one with the robot propped up so that its wheels have no load and another with
    the robot on the floor. The orange line shows the set point, which is raised to
    0.15 m/s by the code. The blue line is the actual speed measured at one of the
    motors. The system is better tuned for running on a floor.
  prefs: []
  type: TYPE_NORMAL
- en: Increase the `D` term to damp the overshoot. Since we are controlling the acceleration
    of this system, a sustained value is not required for it to keep moving, so the
    `I` term can remain at 0.
  prefs: []
  type: TYPE_NORMAL
- en: There may be other troubleshooting issues around motor and encoder connections
    that you can resolve by going back to the previous examples.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you can control the speeds of two motors simultaneously and get a straight
    line while practicing PID tuning. We can now build on this to drive in a straight
    line for a known distance and an expected speed.
  prefs: []
  type: TYPE_NORMAL
- en: Driving a known distance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ll need to bring together some of the previous techniques for this. Then,
    we’ll build a variation of the speed controller – a distance controller – so that
    we can update the distance and let the motor PIDs reach it. This app will use
    a similar structure, including control and asynchronous tasks, as in the previous
    example.
  prefs: []
  type: TYPE_NORMAL
- en: Theory of operation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following diagram shows the theory of operation for this behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.7 – Controlling distance and speed ](img/Figure_11.7_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.7 – Controlling distance and speed
  prefs: []
  type: TYPE_NORMAL
- en: The preceding diagram shows an overview of this system. The distance tracker
    tracks distance over time at a given speed, and the distance controller directly
    controls the motors to try and match a distance. Note the feedback from the motor
    into the distance controller. We will have one of these per motor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a closer look at the distance tracker:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.8 – The distance tracker ](img/Figure_11.8_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.8 – The distance tracker
  prefs: []
  type: TYPE_NORMAL
- en: The left-hand side of the preceding diagram repeats the speed, time, and distance
    triangle. We have the distance and the speed; to get the time, we need to divide
    the distance by speed. The right-hand side shows this distance tracker system.
  prefs: []
  type: TYPE_NORMAL
- en: The tracker system must first convert the distance into `total_time` using distance
    over speed. We must also convert the distance in meters into `total_distance_in_ticks`.
    These two values will remain constant until we set a new speed or distance. This
    lighter portion only needs to run when we update the speed or reset the distance.
  prefs: []
  type: TYPE_NORMAL
- en: If we wish to run the system many times, we need to keep track of the current
    position so that we aren’t counting from a position of 0 each time.
  prefs: []
  type: TYPE_NORMAL
- en: When the system runs, the gray portion will run in a loop, and it will be updating
    the `elapsed_time` since the system was last reset. Dividing `elapsed_time` by
    `total_time` gives us a proportion of `time_proportion`, which will sweep between
    0.0 and 1.0\. We multiply this by `total_distance_in_ticks` to get `expected_distance_in_ticks`,
    tracking the distance the robot should have moved in ticks at any time. Since
    this component is tracking time, it will also pass along a delta time (`dt`) to
    the next component.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next component is the distance controller. Let’s take a closer look at
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.9 – The distance controller ](img/Figure_11.9_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.9 – The distance controller
  prefs: []
  type: TYPE_NORMAL
- en: The preceding diagram shows the update method of a `DistanceController` class.
    `control_signal` directly drives the motor. The `update` method has two inputs
    –`dt` and the `expected` distance in ticks. We subtract the `actual` distance
    in encoder ticks from the `expected` distance to get the `error` value, which
    is used with `dt` to update the `PID`. The output should result in a wheel/motor
    turning faster if it is behind the expected number of ticks or slower if it’s
    ahead.
  prefs: []
  type: TYPE_NORMAL
- en: We will also use the same graphing and control routines as before, but we will
    alter the `G` control handler to specify a distance in meters instead of time
    in seconds – so, `G0.5` would signal the robot to drive half a meter at the current
    speed, then stop.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we have enough information to update the code.
  prefs: []
  type: TYPE_NORMAL
- en: Code to control distance and speed
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s start with a copy of the previous example code. We will update the specific
    changed routines.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to add another number to `robot.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This lets us convert differently so that we can get `m` from ticks. Let’s create
    the new `code.py` file with the familiar imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s add the `DistanceController` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Here, we initialized the `PID` controller and renamed `last_ticks` to `start_ticks`
    – the ticks the encoder is at when we start this behavior. We kept `error` so
    that we can plot it. The code sets `filter_gain` for the derivative to `1` so
    that the derivative is not too slow in catching up.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need an `update` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: First, we have an additional `expected` parameter (in ticks). We get an `actual`
    (in moved ticks) by subtracting `start_ticks` from the current encoder reading.
    We store it as `self.actual` so that we can graph this.
  prefs: []
  type: TYPE_NORMAL
- en: '`error` is far simpler; subtracting `expected` from `actual` gives us the number
    of encoder ticks we are short or ahead of. However, to scale it down, we must
    divide by ticks per revolution. This goes into the PID calculation, along with
    `dt`.'
  prefs: []
  type: TYPE_NORMAL
- en: We use the output of the PID to control the motor.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve completed the `DistanceController` code. Next, we need to create the
    `DistanceTracker` class. We start by storing the controller’s settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: After setting the `speed` and `time_interval` fields, we store a `start_time`
    to count the time elapsed. We also set up initial values for `current_position`,
    `total_distance_in_ticks`, and `total_time`. Note that `total_time` must not be
    zero as we use it in the division.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will need to set these values when we update the distance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The first thing we must do is add any previous movement to `current_position`.
    This means we keep track of the expected position so that the system doesn’t accumulate
    too many errors.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we must calculate a total distance, converting from meters into ticks
    into `total_distance_in_ticks`. The code calculates the total time by dividing
    `new_distance` by `speed`. However, since going backward would be a negative speed,
    we use the `abs` function to get only a positive time. Also, to avoid that division
    by zero, we clamp this value to be above 0.1 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, this resets to a new `start_time`, from which `total_time` will be
    relative.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can build the `DistanceTracker` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'This code creates two `DistanceController` instances and stores a `last_time`
    value for `dt` calculations. The next part of the code is all about time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: First, we sleep for `time_interval`, then get `current_time`. From this, we
    can calculate `dt` and `elapsed_time`. We calculate a `time_proportion` between
    0 and 1 by dividing `current_time` by `total_time`. This `time_proportion` lets
    us track where we are in the current motion. Note that we clamp this to a limit
    of 1 so that the time ratio doesn’t multiply to a value larger than the intended
    distance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we can multiply `time_proportion` by `total_distance_in_ticks` to get
    the relative tick position for the robot. As this is a relatively expected position,
    we add `current_position` again. The `expected` value is an absolute position
    from when we start the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Now, we must update the two `DistanceController` instances and write data to
    the UART to be plotted.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can start this part of the system by creating an instance of `DistanceTracker`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'We can complete this behavior by creating a UART command handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The `G<number>` command now updates a distance instead of time; stopping the
    robot sets a new distance of zero.
  prefs: []
  type: TYPE_NORMAL
- en: 'All that remains is to start the async tasks and handle errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: We now have code that tracks a distance at a given speed; however, you will
    likely need to tune the PID. `DistanceController` needs to provide enough `control_signal`
    to keep up with a changing `expected` position. There will be a non-zero `error`
    value in the `update` method if it’s not completed the motion. This PID system
    will be dominantly proportional so that the motors keep up with the expected position.
    The tips at [https://pidexplained.com/how-to-tune-a-pid-controller/](https://pidexplained.com/how-to-tune-a-pid-controller/)
    help with this tuning.
  prefs: []
  type: TYPE_NORMAL
- en: Note that if you change the motors, the floor type, or the time base, you may
    need to tune this system again.
  prefs: []
  type: TYPE_NORMAL
- en: You should now have a tuned system to drive a specific distance at a specific
    speed.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use the encoder more usefully. You looked
    at how to use wheel geometry to convert encoder pulses into metric measurements
    and then used these measurements to measure speed.
  prefs: []
  type: TYPE_NORMAL
- en: Once we can measure speed, we can use a PID to control the speed of each wheel
    and see significantly less veering.
  prefs: []
  type: TYPE_NORMAL
- en: We could then take this to the next level and drive a specific distance at a
    specific speed, providing fully controlled motion.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will connect an IMU to our robot so that we can measure
    a compass heading and control the robot’s direction.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These exercises will deepen your understanding of the topics covered in this
    chapter and make the robot’s code better:'
  prefs: []
  type: TYPE_NORMAL
- en: All the preceding examples could benefit from the PID modification and printing
    menu in the UART command handler – consider adding it to them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the distance control, we set the derivative filter gain to 1, disabling it.
    How does this system behave with other filter gain values?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instead of starting motions with the phone app, could you chain some of these
    movements together? Or even alter the phone G instruction to make a few motions
    with a single command sequence?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These further study aids will help you learn more and dive deeper into using
    encoders to control robot motion:'
  prefs: []
  type: TYPE_NORMAL
- en: In *Learn Robotics Programming Second Edition*, [*Chapter 11*](B18001_11.xhtml#_idTextAnchor233)*,
    Programming Encoders with Python*, I used simpler encoders but dove into the calculations
    needed to make specific turns with encoders that could be adapted to the Pico.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Arduino-based tutorial at [https://circuitdigest.com/microcontroller-projects/arduino-based-encoder-motor-using-pid-controller](https://circuitdigest.com/microcontroller-projects/arduino-based-encoder-motor-using-pid-controller)
    shows how to use a PID controller.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This Python file at [https://github.com/pimoroni/pimoroni-pico/blob/main/micropython/examples/inventor2040w/motors/position_control.py](https://github.com/pimoroni/pimoroni-pico/blob/main/micropython/examples/inventor2040w/motors/position_control.py)
    from Pimoroni shows a similar Python approach in MicroPython for the Pico.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
