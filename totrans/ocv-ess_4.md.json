["```py\nadaptiveThreshold(InputArray src, OutputArray dst, double maxValue, int adaptiveMethod, int thresholdType, int blockSize, double C)\n```", "```py\n#include \"opencv2/opencv.hpp\"\n#include <iostream>\n\nusing namespace std;\nusing namespace cv;\n\nMat src, dst, adaptDst;\nint threshold_value, block_size, C;\n\nvoid thresholding( int, void* )\n{\n threshold( src, dst, threshold_value, 255, THRESH_BINARY );\n\n  imshow( \"Thresholding\", dst );\n}\n\nvoid adaptThreshAndShow()\n{\n adaptiveThreshold( src, adaptDst, 255, CV_ADAPTIVE_THRESH_MEAN_C, THRESH_BINARY, block_size, C);\n    imshow( \"Adaptive Thresholding\", adaptDst );\n}\n\nvoid adaptiveThresholding1( int, void* )\n{\n  static int prev_block_size=block_size;\n  if ((block_size%2)==0)    // make sure that block_size is odd\n  {\n      if (block_size>prev_block_size) block_size++;\n      if (block_size<prev_block_size) block_size--;\n  }\n  if (block_size<=1) block_size=3;  // check block_size min value\n\n  adaptThreshAndShow();\n}\n\nvoid adaptiveThresholding2( int, void* )\n{\n    adaptThreshAndShow();\n}\n\nint main(int argc, char *argv[])\n{\n    //Read original image and clone it to contain results\n    src = imread(\"left12.jpg\", CV_LOAD_IMAGE_GRAYSCALE );\n    dst=src.clone();\n    adaptDst=src.clone();\n\n    //Create 3 windows\n    namedWindow(\"Source\", WINDOW_AUTOSIZE);\n    namedWindow(\"Thresholding\", WINDOW_AUTOSIZE);\n    namedWindow(\"Adaptive Thresholding\", WINDOW_AUTOSIZE);\n    imshow(\"Source\", src);\n\n    //Create trackbars\n    threshold_value=127;\n    block_size=7;\n    C=10;\n    createTrackbar( \"threshold\", \"Thresholding\", &threshold_value, 255, thresholding );\n    createTrackbar( \"block_size\", \"Adaptive Thresholding\", &block_size, 25, adaptiveThresholding1 );\n    createTrackbar( \"C\", \"Adaptive Thresholding\", &C, 255, adaptiveThresholding2 );\n\n    //Perform operations a first time\n    thresholding(threshold_value,0);\n    adaptiveThresholding1(block_size, 0);\n    adaptiveThresholding2(C, 0);\n\n    // Position windows on screen\n    moveWindow(\"Source\", 0,0);\n    moveWindow(\"Thresholding\", src.cols,0);\n    moveWindow(\"Adaptive Thresholding\", 2*src.cols,0);\n\n    cout << \"Press any key to exit...\\n\";\n    waitKey(); // Wait for key press\n    return 0;\n}\n```", "```py\n#include \"opencv2/opencv.hpp\"\n#include <iostream>\n\nusing namespace std;\nusing namespace cv;\n\nvector<Vec4i> lines;\nvector<float> widths;\nMat input_image, output;\n\ninline float line_length(const Point &a, const Point &b)\n{\n    return (sqrt((b.x-a.x)*(b.x-a.x) + (b.y-a.y)*(b.y-a.y)));\n}\n\nvoid MyDrawSegments(Mat &image, const vector<Vec4i>&lines, const vector<float>&widths,\nconst Scalar& color, const float length_threshold)\n{\n    Mat gray;\n    if (image.channels() == 1)\n    {\n        gray = image;\n    }\n    else if (image.channels() == 3)\n    {\n        cvtColor(image, gray, COLOR_BGR2GRAY);\n    }\n\n    // Create a 3 channel image in order to draw colored lines\n    std::vector<Mat> planes;\n    planes.push_back(gray);\n    planes.push_back(gray);\n    planes.push_back(gray);\n\n    merge(planes, image);\n\n    // Draw segments if length exceeds threshold given\n    for(int i = 0; i < lines.size(); ++i)\n    {\n        const Vec4i& v = lines[i];\n        Point a(v[0], v[1]);\n        Point b(v[2], v[3]);\n        if (line_length(a,b) > length_threshold) line(image, a, b, color, widths[i]);\n    }\n}\n\nvoid thresholding(int threshold, void*)\n{\n    input_image.copyTo(output);\n    MyDrawSegments(output, lines, widths, Scalar(0, 255, 0), threshold);\n    imshow(\"Detected lines\", output);\n}\n\nint main(int argc, char** argv)\n{\n    input_image = imread(\"building.jpg\", IMREAD_GRAYSCALE);\n\n    // Create an LSD detector object\n Ptr<LineSegmentDetector> ls = createLineSegmentDetector();\n\n    // Detect the lines\nls->detect(input_image, lines, widths);\n\n    // Create window to show found lines\n    output=input_image.clone();\n    namedWindow(\"Detected lines\", WINDOW_AUTOSIZE);\n\n    // Create trackbar for line length threshold\n    int threshold_value=50;\n    createTrackbar( \"Line length threshold\", \"Detected lines\", &threshold_value, 1000, thresholding );\n    thresholding(threshold_value, 0);\n\n    waitKey();\n    return 0;\n}\n```", "```py\n#include <opencv2/core/utility.hpp>\n#include \"opencv2/imgproc.hpp\"\n#include \"opencv2/highgui.hpp\"\n#include <iostream>\n\nusing namespace cv;\nusing namespace std;\n\nMat img;\nint threshval = 227;\n\nstatic void on_trackbar(int, void*)\n{\n    Mat bw = threshval < 128 ? (img < threshval) : (img > threshval);\n    Mat labelImage(img.size(), CV_32S);\n\n    Mat stats, centroids;\n int nLabels = connectedComponentsWithStats(bw, labelImage, stats, centroids);\n\n    // Show connected components with random colors\n    std::vector<Vec3b> colors(nLabels);\n    colors[0] = Vec3b(0, 0, 0);//background\n    for(int label = 1; label < nLabels; ++label){\n        colors[label] = Vec3b( (rand()&200), (rand()&200), (rand()&200) );\n    }\n    Mat dst(img.size(), CV_8UC3);\n    for(int r = 0; r < dst.rows; ++r){\n        for(int c = 0; c < dst.cols; ++c){\n            int label = labelImage.at<int>(r, c);\n            Vec3b &pixel = dst.at<Vec3b>(r, c);\n            pixel = colors[label];\n         }\n     }\n    // Text labels with area of each cc (except background)\n    for (int i=1; i< nLabels;i++)\n    {\n        float a=stats.at<int>(i,CC_STAT_AREA);\n        Point org(centroids.at<double>(i,0), centroids.at<double>(i,1));\n        String txtarea;\n        std::ostringstream buff;\n        buff << a;\n        txtarea=buff.str();\n        putText( dst, txtarea, org,FONT_HERSHEY_COMPLEX_SMALL, 1, Scalar(255,255,255), 1);\n    }\n\n    imshow( \"Connected Components\", dst );\n}\n\nint main( int argc, const char** argv )\n{\n    img = imread(\"stuff.jpg\", 0);\n    namedWindow( \"Connected Components\", 1 );\n    createTrackbar( \"Threshold\", \"Connected Components\", &threshval, 255, on_trackbar );\n    on_trackbar(threshval, 0);\n\n    waitKey(0);\n    return 0;\n}\n```", "```py\n#include \"opencv2/opencv.hpp\"\n#include <iostream>\n\nusing namespace std;\nusing namespace cv;\n\nMat image, image1, image_orig;\nint loDiff = 20, upDiff = 30;\nint loCanny=10, upCanny=150;\n\nvoid onMouse( int event, int x, int y, int, void* )\n{\n    if( event != CV_EVENT_LBUTTONDOWN ) return;\n\n    Point seed = Point(x,y);\n    int flags = 4 + CV_FLOODFILL_FIXED_RANGE;\n    int b = (unsigned)theRNG() & 255;\n    int g = (unsigned)theRNG() & 255;\n    int r = (unsigned)theRNG() & 255;\n    Rect ccomp;\n\n    Scalar newVal = Scalar(b, g, r);\n    Mat dst = image;\n\n    // flood fill\n floodFill(dst, seed, newVal, &ccomp, Scalar(loDiff, loDiff, loDiff), Scalar(upDiff, upDiff, upDiff), flags);\n    imshow(\"image\", dst);\n\n    // Using Canny edges as mask\n    Mat mask;\n    Canny(image_orig, mask, loCanny, upCanny);\n    imshow(\"Canny edges\", mask);\n    copyMakeBorder(mask, mask, 1, 1, 1, 1, cv::BORDER_REPLICATE);\n    Mat dst1 = image1;\n    floodFill(dst1, mask, seed, newVal, &ccomp, Scalar(loDiff, loDiff, loDiff), Scalar(upDiff, upDiff, upDiff), flags);\n    imshow(\"FF with Canny\", dst1);\n\n    moveWindow(\"Canny edges\", image.cols,0);\n    moveWindow(\"FF with Canny\", 2*image.cols,0);\n}\n\nint main(int argc, char *argv[])\n{\n    // Read original image and clone it to contain results\n    image = imread(\"lena.jpg\", CV_LOAD_IMAGE_COLOR );\n    image_orig=image.clone();\n    image1=image.clone();\n\n    namedWindow( \"image\", WINDOW_AUTOSIZE );\n\n    imshow(\"image\", image);\n    createTrackbar( \"lo_diff\", \"image\", &loDiff, 255, 0 );\n    createTrackbar( \"up_diff\", \"image\", &upDiff, 255, 0 );\n    createTrackbar( \"lo_Canny\", \"image\", &loCanny, 255, 0 );\n    createTrackbar( \"up_Canny\", \"image\", &upCanny, 255, 0 );\n    setMouseCallback( \"image\", onMouse, 0 );\n\n    moveWindow(\"image\", 0,0);\n\n    cout << \"Press any key to exit...\\n\";\n    waitKey(); // Wait for key press\n    return 0;\n}\n```", "```py\n#include <opencv2/core/utility.hpp>\n#include \"opencv2/imgproc.hpp\"\n#include \"opencv2/highgui.hpp\"\n#include \"opencv2/core.hpp\"\n#include <iostream>\n\nusing namespace std;\nusing namespace cv;\n\nvoid Watershed(const Mat &src)\n{\n    Mat dst=src.clone();\n\n    // Flood fill outer part of the image\n    Point seed(0,0); // top-left corner\n    int loDiff=20;\n    int upDiff=20;\n    int flags=4 + FLOODFILL_FIXED_RANGE + FLOODFILL_MASK_ONLY + (255<<8);\n    Mat mask(src.size(), CV_8UC1);\n    mask.setTo(0);\n    copyMakeBorder(mask, mask, 1, 1, 1, 1, cv::BORDER_REPLICATE);\n    Scalar newVal;\n    Rect ccomp;\n    floodFill(dst, mask, seed, newVal, &ccomp,\n         Scalar(loDiff, loDiff, loDiff), Scalar(upDiff, upDiff, upDiff), flags);\n\n    // Flood fill inner part of the image\n    seed.x=(float)src.cols/2;   // image center x\n    seed.y=(float)src.rows/2;   // image center y\n    Mat mask1=mask.clone();\n    mask1.setTo(0);\n    floodFill(dst, mask1, seed, newVal, &ccomp,\n          Scalar(loDiff, loDiff, loDiff), Scalar(upDiff, upDiff, upDiff), flags);\n\n    // Form image with the two seed regions\n    Mat Mask = mask.clone();\n    mask=mask/2;\n    Mask = mask | mask1;\n    imshow(\"Seed regions\", Mask);\n    moveWindow(\"Seed regions\", src.cols, 0);\n\n    // Perform watershed\n    Mat labelImage(src.size(), CV_32SC1);\n    labelImage=Mask(Rect(1,1, src.cols, src.rows));\n    labelImage.convertTo(labelImage, CV_32SC1);\n watershed(src, labelImage);\n    labelImage.convertTo(labelImage, CV_8U);\n    imshow(\"Watershed\", labelImage);\n    moveWindow(\"Watershed\", 2*src.cols, 0);\n}\n\nint main(int argc, char *argv[])\n{\n    // Read original image and clone it to contain results\n    Mat src = imread(\"hand_sample2.jpg\", IMREAD_COLOR );\n\n    // Create 3 windows\n    namedWindow(\"Source\", WINDOW_AUTOSIZE);\n    imshow(\"Source\", src);\n\n    Watershed(src);\n\n    // Position windows on screen\n    moveWindow(\"Source\", 0,0);\n\n    cout << \"Press any key to exit...\\n\";\n    waitKey(); // Wait for key press\n    return 0;\n}\n```", "```py\n#include \"opencv2/opencv.hpp\"\n#include <iostream>\n\nusing namespace std;\nusing namespace cv;\n\nint main(int argc, char *argv[])\n{\n    // Read original image and clone it\n    Mat src = imread(\"stuff.jpg\" );\n    Mat tgt = src.clone();\n\n    // Create source window\n    namedWindow(\"Source\", WINDOW_AUTOSIZE);\n\n    imshow(\"Source\", src);\n    moveWindow(\"Source\", 0,0);\n\n    // GrabCut segmentation\n    Rect rectangle(180,279,60,60);  // coin position\n    Mat result;                     // segmentation result\n    Mat bgModel,fgModel;            // used internally\ngrabCut(src, result, rectangle, bgModel,fgModel, 1, GC_INIT_WITH_RECT);\n\n    result=(result & GC_FGD);   // leave only obvious foreground\n\n    // Translation operation\n    Mat aff=Mat::eye(2,3,CV_32FC1);\n    aff.at<float>(0,2)=50;\n    warpAffine(tgt, src, aff, result.size());\n    warpAffine(result, result, aff, result.size());\n    src.copyTo(tgt, result);\n\n    // Show target window\n    imshow(\"Target\", tgt);\n    moveWindow(\"Target\", src.cols, 0);\n\n    cout << \"Press any key to exit...\\n\";\n    waitKey(); // Wait for key press\n    return 0;\n}\n```"]