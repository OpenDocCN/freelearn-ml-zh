- en: Learning Graphical User Interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 2](37cf2702-b8c6-41ff-a935-fd4030f8ce64.xhtml), *An Introduction
    to the Basics of OpenCV*, we learned the basic classes and structures of OpenCV
    and the most important class, called `Mat`. We learned how to read and save images
    and videos and the internal structure in the memory of images. We are now ready
    to work with OpenCV, but, in most cases, we need to show our image results and
    retrieve user interaction with our images using a number of user interfaces. OpenCV
    provides us with a few basic user interfaces to facilitate the creation of our
    applications and prototypes. To better understand how the user interface works,
    we are going to create a small application called **PhotoTool** at the end of
    this chapter. In this application, we will learn how to use filters and color
    conversions.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter introduces the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The OpenCV basic user interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The OpenCV Qt interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sliders and buttons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An advanced user interface – OpenGL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Color conversion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic filters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter requires familiarity with the basic C++ programming language.
    All the code used in this chapter can be downloaded from the following GitHub
    link: [https://github.com/PacktPublishing/Learn-OpenCV-4-By-Building-Projects-Second-Edition/tree/master/Chapter_03](https://github.com/PacktPublishing/Learn-OpenCV-4-By-Building-Projects-Second-Edition/tree/master/Chapter_03). The
    code can be executed on any operating system, although it has only been tested
    on Ubuntu.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the code in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://bit.ly/2KH2QXD](http://bit.ly/2KH2QXD)'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the OpenCV user interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OpenCV has its own cross-OS user interface that allows developers to create
    their own applications without the need to learn complex user interface libraries.
    The OpenCV user interface is basic, but it gives computer vision developers the
    basic functions to create and manage their software developments. All of them
    are native and optimized for real-time use.
  prefs: []
  type: TYPE_NORMAL
- en: 'OpenCV provides two user interface options:'
  prefs: []
  type: TYPE_NORMAL
- en: A basic interface based on native user interfaces, cocoa or carbon for Mac OS
    X, and GTK for Linux or Windows user interfaces, selected by default when compiling
    OpenCV.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A slightly more advanced interface based on Qt library that is a cross-platform
    interface. You have to enable the Qt option manually in CMake before compiling
    OpenCV.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following screenshot, you can see the basic user interface window on
    the left, and the Qt user interface on the right:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/70ba76a2-6e26-440a-9a0c-9db64f284983.png)'
  prefs: []
  type: TYPE_IMG
- en: Basic graphical user interface with OpenCV
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to create a basic user interface with OpenCV. The OpenCV user interface
    allows us to create windows, add images to it, and move, resize, and destroy it.
    The user interface is in OpenCV's `highui` module. In the following code, we are
    going to learn how to create and show two images by pressing a key to display
    multiple windows with the image moving in the window on our desktop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Don''t worry about reading the full code; we are going to explain it in small
    chunks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s understand the code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first task we have to do in order to facilitate a graphical user interface
    is to import OpenCV''s `highui` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we are prepared to create our new windows, we have to load some images:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To create the windows, we use the `namedWindow` function. This function has
    two parameters; the first is a constant string with the window''s name, and the
    second is the flags that we require. This second parameter is optional:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In our case, we create two windows: the first is called `Lena`, and the second
    is called `Photo`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There are three flags by default for Qt and native:'
  prefs: []
  type: TYPE_NORMAL
- en: '`WINDOW_NORMAL`: This flag allows the user to resize the window'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WINDOW_AUTOSIZE`: If this flag is set, the window size is automatically adjusted
    to fit the display image and it is not possible to resize the window'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WINDOW_OPENGL`: This flag enables the OpenGL support'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Qt has a number of additional flags:'
  prefs: []
  type: TYPE_NORMAL
- en: '`WINDOW_FREERATIO` or `WINDOW_KEEPRATIO`: If `WINDOW_FREERATIO` is set, the
    image is adjusted with no respect for its ratio. If `WINDOW_FREERATIO` is set,
    the image is adjusted with respect to its ratio.'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WINDOW_GUI_NORMAL` or `WINDOW_GUI_EXPANDED`: The first flag facilitates a
    basic interface without the status bar and the toolbar. The second flag facilitates
    the most advanced graphical user interface, with the status bar and the toolbar.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If we compile OpenCV with Qt, all the windows that we create are, by default,
    in the expanded interface, but we can use native interfaces and more basic ones
    adding the `CV_GUI_NORMAL` flag. By default, the flags are `WINDOW_AUTOSIZE`, `WINDOW_KEEPRATIO`,
    and `WINDOW_GUI_EXPANDED`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we create multiple windows, they are superimposed, but we can move the
    windows to any area of our desktop using the `moveWindow` function, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In our code, we move the `Lena` window `10` pixels to the left, and `10` pixels
    up, and the `Photo` window `520` pixels to the left, and `10` pixels up:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'After showing the images that we loaded previously using the `imshow` function,
    we resize the `Lena` window to `512` pixels, calling the `resizeWindow` function.
    This function has three parameters: the `window name`, `width`, and `height`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The specific window size is for the image area. Toolbars are not counted. Only
    windows without the `WINDOW_AUTOSIZE` flag enabled can be resized.
  prefs: []
  type: TYPE_NORMAL
- en: 'After waiting for a key press with the `waitKey` function, we are going to
    remove or delete our windows using the `destroyWindow` function, where the name
    of the window is the only parameter required:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'OpenCV has a function to remove all windows that we create in only one call.
    The function is called `destroyAllWindows`. To demonstrate how this works, we
    create 10 windows in our sample and await a key press. When the user presses any
    key, it destroys all the windows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In any event, OpenCV handles the destruction of all windows automatically when
    the application is terminated, and it is not necessary to call this function at
    the end of our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result of all this code can be seen in the following images across two
    steps. First, it shows two windows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7b6c21b3-4b79-4f6d-93e1-784f372b2f4f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After pressing any key, the application continues and draws several windows
    changing their positions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d52ca1f9-d77c-4b18-9146-1a24d4d79bc0.png)'
  prefs: []
  type: TYPE_IMG
- en: With a few lines of code, we are able to create and manipulate windows and show
    images. We are now ready to facilitate user interaction with images and add user
    interface controls.
  prefs: []
  type: TYPE_NORMAL
- en: Adding slider and mouse events to our interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Mouse events and slider control are very useful in computer vision and OpenCV.
    Using these control users, we can interact directly with the interface and change
    the properties of the input images or variables. In this section, we are going
    to introduce the mouse events and slider controls for basic interactions. To facilitate
    proper understanding, we have created the following code, by means of which we
    are going to paint green circles in an image, using mouse events, and blur the
    image with the slider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Let's understand the code!
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we create a variable to save the slider position. We need to save the
    slider position for access from other functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we define our callbacks for our slider and mouse event, required for the
    OpenCV functions `setMouseCallback` and `createTrackbar`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In the main function, we load an image and create a new window called `Lena`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now is the time to create the slider. OpenCV has the `createTrackbar` function to
    generate a slider with the following parameters in order:'
  prefs: []
  type: TYPE_NORMAL
- en: Trackbar name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Window name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Integer pointer to use as a value; this parameter is optional. If it is set,
    the slider attains this position when created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Maximum position on slider.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Callback function when the position of the slider changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: User data to send to callback. It can be used to send data to callbacks without
    using global variables.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To this code, we add `trackbar` for the `Lena` window and call the `Lena` trackbar too
    in order to blur the image. The value of the trackbar is stored in the `blurAmount`
    integer that we pass as a pointer and set the maximum value of the bar to `30`.
    We set up `onChange` as a callback function and send the lena mat image as user
    data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'After creating the slider, we add the mouse events to paint circles when a
    user clicks the left button on the mouse. OpenCV has the `setMouseCallback` function.
    This function has three parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: A window name where we get mouse events.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A callback function to call when there is any mouse interaction.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User data**: this is any data that will be sent to the callback function
    when it''s fired. In our example, we''ll send the entire `Lena` image.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using the following code, we can add a mouse callback to the `Lena` window and
    set up `onMouse` as a callback function, passing the lena mat image as user data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'To finalize the main function only, we need to initialize the image with the
    same parameter as the slider. To carry out the initialization, we only need to
    call the `onChange` callback function and wait for events before closing the windows
    with `destroyWindow`*,* as can be seen in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The slider callback applies a basic blur filter to the image using the slider
    value as a blur quantity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This function checks whether the slider value is `0` using the variable `pos`.
    In this case, we do not apply the filter because it generates a bad execution.
    We cannot apply a `0` pixel blur either. After checking the slider value, we create
    an empty matrix called `imgBlur` to store the blur result. To retrieve the image
    sent through user data in the callback function, we have to cast `void* userData` to
    the correct image type pointer `Mat*`.
  prefs: []
  type: TYPE_NORMAL
- en: Now we have the correct variables to apply the blur filter. The blur function
    applies a basic median filter to an input image, `*img` in our case; to an output
    image, the last required parameter is the size of the blur kernel (a kernel is
    a small matrix used to calculate the means of convolution between the kernel and
    the image) that we want to apply. In our case, we are using a squared kernel of `pos` size.
    Finally, we only need to update the image interface using the `imshow` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The mouse events callback has five input parameters: the first parameter defines
    the event type; the second and third define the mouse position; the fourth parameter
    defines the wheel movement; and the fifth parameter defines the user input data.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The mouse event types are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Event type | Description |'
  prefs: []
  type: TYPE_TB
- en: '| `EVENT_MOUSEMOVE` | When the user moves the mouse. |'
  prefs: []
  type: TYPE_TB
- en: '| `EVENT_LBUTTONDOWN` | When the user clicks the left mouse button. |'
  prefs: []
  type: TYPE_TB
- en: '| `EVENT_RBUTTONDOWN` | When the user clicks the right mouse button. |'
  prefs: []
  type: TYPE_TB
- en: '| `EVENT_MBUTTONDOWN` | When the user clicks the middle mouse button. |'
  prefs: []
  type: TYPE_TB
- en: '| `EVENT_LBUTTONUP` | When the user releases the left mouse button. |'
  prefs: []
  type: TYPE_TB
- en: '| `EVENT_RBUTTONUP` | When the user releases the right mouse button. |'
  prefs: []
  type: TYPE_TB
- en: '| `EVENT_MBUTTONUP` | When the user releases the middle mouse button. |'
  prefs: []
  type: TYPE_TB
- en: '| `EVENT_LBUTTONDBLCLK` | When the user double-clicks the left mouse button.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `EVENT_RBUTTONDBLCLK` | When the user double-clicks the right mouse button.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `EVENT_MBUTTONDBLCLK` | When the user double-clicks the middle mouse button.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `EVENTMOUSEWHEEL` | When the user executes a vertical scroll with the mousewheel.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `EVENT_MOUSEHWHEEL` | When the user executes a horizontal scroll with the
    mousewheel. |'
  prefs: []
  type: TYPE_TB
- en: 'In our sample, we only manage events that result from a left-click of the mouse,
    and any event other than `EVENT_LBUTTONDOWN` is discarded. After discarding other
    events, we obtain the input image like that with the slider callback, and with
    a circle in the image using the circle OpenCV function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Graphic user interface with Qt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Qt user interface gives us more control and options to work with our images.
  prefs: []
  type: TYPE_NORMAL
- en: 'The interface is divided into the following three main areas:'
  prefs: []
  type: TYPE_NORMAL
- en: Toolbar
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Image area
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Status bar
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can see these three areas in the following picture. At the top of the image
    is the toolbar, the image is the main area, and the status bar can be seen at
    the bottom of the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/61d3f74e-02a7-4f53-be89-ec396b28a42f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The toolbar has the following buttons from left to right:'
  prefs: []
  type: TYPE_NORMAL
- en: Four buttons for panning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Zoom x1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Zoom x30, show labels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Zoom in
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Zoom out
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Save current image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Show properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These options can be seen clearly in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ffab5642-1bf2-44d6-8cfc-386776bed0b1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The image area shows an image and a contextual menu when we push the right
    mouse button over the image. This area can show an overlay message at the top
    of the area using the `displayOverlay` function. This function accepts three parameters:
    the window name, the text that we want to show, and the period in milliseconds
    for which the overlay text is displayed. If this time is set to `0`, the text
    never disappears:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see the result of the preceding code in the following image. You can
    see a small black box at the top of the image with the sentence Overlay 5secs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9e96283c-36bf-42fb-8b99-2594c1145a0a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, the status bar shows the bottom part of the window and shows the pixel
    value and position of the coordinates in the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/73c772f0-ffb3-4b30-a8a2-e44f9b447069.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can use the status bar to show messages like an overlay. The function that
    can change the status bar message is `displayStatusBar`. This function has the
    same parameters as those of the overlay functions: the window name, the text to
    show, and the period of time for which to show it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/812fe575-7b2a-4d1f-92f7-e5fb119638ff.png)'
  prefs: []
  type: TYPE_IMG
- en: Adding buttons to the user interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous sections, we learned how to create normal or Qt interfaces and
    interact with them using the mouse and sliders, but we can create different types
    of buttons too.
  prefs: []
  type: TYPE_NORMAL
- en: Buttons are only supported in Qt windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'The types of buttons supported by OpenCV Qt are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Push button
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checkbox
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RadioBox
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The buttons only appear in the control panel. The control panel is an independent
    window per program where we can attach buttons and trackbars. To show the control
    panel, we can push the last toolbar button, right-click in any part of the Qt
    window and select the Display properties window, or use the *Ctrl *+ *P* shortcut. Let''s
    create a basic sample with buttons. The code is extensive, and we are going to
    explain the main function first and later each callback separately so as to understand
    everything better. The following code shows us the main code function that generates
    the user interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We are going to apply thee types of filters: blur, a sobel filter, and a color
    conversion to gray. All these are optional and the user can choose each one using
    the buttons that we are going to create. Then, to get the status of each filter,
    we create three global Boolean variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In the main function, after loading the image and creating the window, we have
    to use the `createButton` function to create each button.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three button types defined in OpenCV:'
  prefs: []
  type: TYPE_NORMAL
- en: '`QT_CHECKBOX`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QT_RADIOBOX`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QT_PUSH_BUTTON`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each button has five parameters with the following order:'
  prefs: []
  type: TYPE_NORMAL
- en: The button name
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A callback function
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A pointer to user variable data passed to callback
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The button type
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The default initialized state used for the checkbox and RadioBox button types
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, we create a blur checkbox button, two radio buttons for color conversion,
    and a push button for a sobel filter, as you can see in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'These are the most important parts of the main function. We are going to explore
    the `Callback` functions. Each `Callback` changes its status variable to call
    another function called `applyFilters` in order to add the filters activated to
    the input image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `applyFilters` function checks the status variable for each filter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'To change the color to gray, we use the `cvtColor` function which accepts three
    parameters: input image, output image, and the color conversion type.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The most useful color space conversions are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: RGB or BGR to gray (`COLOR_RGB2GRAY`, `COLOR_BGR2GRAY`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RGB or BGR to YcrCb (or YCC) (`COLOR_RGB2YCrCb`, `COLOR_BGR2YCrCb`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RGB or BGR to HSV (`COLOR_RGB2HSV`, `COLOR_BGR2HSV`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RGB or BGR to Luv (`COLOR_RGB2Luv`, `COLOR_BGR2Luv`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gray to RGB or BGR (`COLOR_GRAY2RGB`, `COLOR_GRAY2BGR`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can see that the codes are easy to memorize.
  prefs: []
  type: TYPE_NORMAL
- en: OpenCV works by default with the BGR format, and the color conversion is different
    for RGB and BGR, even when converted to gray. Some developers think that *R*+*G*+*B*/*3*
    is true for gray, but the optimal gray value is called **luminosity** and has
    the formula *0*,*21***R* + *0*,*72***G* + *0*,*07***B.*
  prefs: []
  type: TYPE_NORMAL
- en: The blur filter was described in the previous section, and finally, if the `applySobel`
    variable is true, we apply the sobel filter. The sobel filter is an image derivate
    obtained using the sobel operator, commonly used to detect edges. OpenCV allows
    us to generate different derivates with kernel size, but the most common is a
    3x3 kernel to calculate the *x* derivates or *y* derivate.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most important sobel parameters are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Input image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Output image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Output image depth (`CV_8U`, `CV_16U`, `CV_32F`, `CV_64F`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Order of the derivate *x*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Order of the derivate *y*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kernel size (a value of 3 by default)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To generate a 3 x 3 kernel and a first *x* order derivate, we have to use the
    following parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The following parameters are used for *y* order derivates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In our example, we use the *x* and *y* derivate simultaneously, overwriting
    the input. The following snippet shows how to generate the *x* and *y* derivates
    simultaneously, adding `1` in the fourth and fifth parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of applying *x* and *y* derivatives simultaneously looks like following
    image applied to the Lena picture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d97827fe-df6a-4482-904c-d438ae87db5a.png)'
  prefs: []
  type: TYPE_IMG
- en: OpenGL support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OpenCV includes OpenGL support. OpenGL is a graphical library integrated in
    almost all graphical cards as a standard. OpenGL allows us to draw 2D up to complex
    3D scenes. OpenCV includes OpenGL support due to the importance of representing
    3D spaces in a number of tasks. To allow window support in OpenGL, we have to
    set up the `WINDOW_OPENGL` flag when we create the window using the `namedWindow`
    call.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code creates a window with OpenGL support and draws a rotate
    plane where we are going to show the web camera frames:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Let's understand the code!
  prefs: []
  type: TYPE_NORMAL
- en: 'The first task is to create the required global variables, where we store the
    video capture, save the frames, and control the animation angle plane and the
    OpenGL texture:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In our main function, we have to create the video camera capture to retrieve
    the camera frames:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'If the camera is opened correctly, we can create our window with OpenGL support
    using the `WINDOW_OPENGL` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In our example, we want to draw the images that come from the web camera in
    a plane; then, we need to enable the OpenGL textures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we are ready to draw with OpenGL in our window, but we need to set up a
    draw OpenGL callback like a typical OpenGL application. OpenCV gives us the `setOpenGLDrawCallback`
    function which has two parameters – the window name and the callback function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'With the OpenCV window and callback function defined, we need to create a loop
    to load the texture, update the window content calling the OpenGL draw callback,
    and finally update the angle position. To update the window content, we use the
    OpenCV function update window with the window name as a parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We are in the loop when the user presses the *Q* key. Before compiling our
    application sample, we need to define the `loadTexture` function and our `on_opengl`
    callback draw function. The `loadTexture` function converts our `Mat` frame to
    an OpenGL texture image ready to load and use in each callback drawing. Before
    loading the image as a texture, we have to ensure that we have data in our frame
    matrix, checking that the data variable object is not empty:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'If we have data in our matrix frame, then we can create the OpenGL texture
    binding and set the OpenGL texture parameter as a linear interpolation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have to define how the pixels are stored in our matrix and generate
    the pixels with the OpenGL `glTexImage2D` function. It''s very important to note
    that OpenGL uses the RGB format, and OpenCV the BGR format, by default, and we
    have to set up the correct format in this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we only need to finish drawing our plane on every callback when we call `updateWindow`
    in the main loop. We use the common OpenGL functions, and then we load the identity
    OpenGL matrix to reset all our previous changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We also have to bring the frame texture to memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Before drawing our plane, we apply all transformations to our scene. In our
    case, we are going to rotate our plane in the `1,1,1` axis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have the scene correctly set to draw our plane, we are going to
    draw quads faces (faces with four vertices) and use `glBegin (GL_QUADS)` for this
    purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will draw a plane centered in the `0,0` position, which is 2 units
    in size. Then, we have to define the texture coordinate to use and the vertex
    position using the `glTextCoord2D` and `glVertex2D` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This OpenGL code becomes obsolete, but it is appropriated to understand better
    the OpenCV and OpenGL integration without complex OpenGL code. By way of an introduction
    to modern OpenGL, read *Introduction to Modern OpenGL*, from *Packt Publishing*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see the result in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/07b18665-27b6-4cdc-b90a-5eb71ea48db6.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to create different types of user interfaces
    to show images or 3D interfaces using OpenGL. We learned how to create sliders
    and buttons or draw in 3D. We learned some basic image processing filters too
    with native OpenCV, but there are new open source alternatives that allow us to
    add more functionalities, such as cvui ([https://dovyski.github.io/cvui/](https://dovyski.github.io/cvui/))
    or OpenCVGUI ([https://damiles.github.io/OpenCVGUI/](https://damiles.github.io/OpenCVGUI/)).
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to construct a complete photo tool application
    where we will be applying all the knowledge that we have learned thus far. With
    the graphical user interface, we are going to learn how to apply multiple filters
    to an input image.
  prefs: []
  type: TYPE_NORMAL
