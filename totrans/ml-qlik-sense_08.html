<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer100">
<h1 class="chapter-number" id="_idParaDest-100"><a id="_idTextAnchor101"/>8</h1>
<h1 id="_idParaDest-101"><a id="_idTextAnchor102"/>Utilizing Qlik AutoML</h1>
<p>Qlik AutoML <a id="_idIndexMarker447"/>leverages the power of artificial intelligence and automation to empower users of all skill levels to build and deploy machine learning models, without the need for extensive coding or data science backgrounds. By automating repetitive tasks and providing intelligent recommendations, Qlik AutoML streamlines the entire machine learning workflow, making it accessible to a <span class="No-Break">broader audience.</span></p>
<p>In this chapter, we will delve into the world of Qlik AutoML, exploring its capabilities, benefits, and practical applications. We will provide a comprehensive overview of the underlying concepts and techniques that enable Qlik AutoML to automate the machine learning process. Moreover, we will guide you through the step-by-step implementation of AutoML models within the Qlik ecosystem, highlighting its seamless integration with the Qlik Sense <span class="No-Break">analytics platform.</span></p>
<p>In this chapter, we will cover the <span class="No-Break">following topics:</span></p>
<ul>
<li>Features of <span class="No-Break">Qlik AutoML</span></li>
<li>Using Qlik AutoML in a <span class="No-Break">cloud environment</span></li>
<li>Creating and monitoring a machine learning model with <span class="No-Break">Qlik AutoML</span></li>
<li>Connecting Qlik AutoML to an <span class="No-Break">on-premises environment</span></li>
<li>Best practices with <span class="No-Break">Qlik AutoML</span></li>
</ul>
<h1 id="_idParaDest-102"><a id="_idTextAnchor103"/>Features of Qlik AutoML</h1>
<p>Qlik AutoML<a id="_idIndexMarker448"/> is a tool within the Qlik Sense analytics platform that automates the process of building and deploying machine learning models. It simplifies the machine learning workflow and allows users to create predictive models, without requiring in-depth knowledge of data science or programming. Some of the key features of Qlik AutoML include <span class="No-Break">the following:</span></p>
<ul>
<li><strong class="bold">Automated model selection</strong>: Qlik AutoML automatically selects the best machine learning algorithm based on data and the prediction task, saving users from manually exploring and comparing <span class="No-Break">different algorithms.</span></li>
<li><strong class="bold">Hyperparameter tuning</strong>: Qlik AutoML optimizes the hyperparameters of the selected machine learning model to improve its performance and accuracy. Hyperparameter tuning helps fine-tune the model’s behavior and makes it more effective in <span class="No-Break">making predictions.</span></li>
<li><strong class="bold">Cross-validation</strong>: Qlik AutoML uses cross-validation techniques to evaluate the performance of models. It splits data into multiple subsets and trains and tests the models on different combinations, providing more robust <span class="No-Break">performance metrics.</span></li>
<li><strong class="bold">Model evaluation</strong>: Qlik AutoML <a id="_idIndexMarker449"/>provides various performance metrics to evaluate models, such as accuracy, precision, recall, and the F1 score. These metrics help users assess the model’s predictive power and choose the best-performing model for their <span class="No-Break">use case.</span></li>
<li><strong class="bold">Model deployment</strong>: Once the model is built and selected, Qlik AutoML enables easy deployment within the Qlik Sense environment. Users can seamlessly integrate the predictive models into their existing Qlik apps and dashboards for real-time insights <span class="No-Break">and decision-making.</span></li>
</ul>
<p class="callout-heading">Note</p>
<p class="callout">Some of the features (including hyperparameter optimization and the prediction API) will require a paid tier of Qlik AutoML. Also, the number of deployments, concurrent tasks, and dataset limits are defined by license tier. Specific tier limits should be verified by <span class="No-Break">Qlik Sales.</span></p>
<p>Qlik AutoML aims to democratize machine learning and empower business users to leverage advanced analytics capabilities, without extensive technical expertise. In <a href="B19863_04.xhtml#_idTextAnchor061"><span class="No-Break"><em class="italic">Chapter 4</em></span></a>, we looked at the general concepts in creating a good machine <span class="No-Break">learning solution.</span></p>
<p>As you might remember from that chapter, there are three types of machine learning problems that Qlik AutoML <a id="_idIndexMarker450"/><span class="No-Break">can solve:</span></p>
<ul>
<li><strong class="bold">Binary classification</strong>: Any question that can be answered with a yes <span class="No-Break">or no</span></li>
<li><strong class="bold">Multi-class classification</strong>: Questions where there could be multiple <span class="No-Break">outcome choices</span></li>
<li><strong class="bold">Regression/numeric</strong>: Predicting a number at a <span class="No-Break">future point</span></li>
</ul>
<p>Qlik AutoML is available as part of the Qlik Cloud offering. In the following section, we will get familiar with the actual process of getting a deployed, production-ready model from our <span class="No-Break">training data.</span></p>
<h1 id="_idParaDest-103"><a id="_idTextAnchor104"/>Using Qlik AutoML in a cloud environment</h1>
<p>There<a id="_idIndexMarker451"/> are several steps when deploying a machine learning model using Qlik AutoML. These steps are illustrated in the <span class="No-Break">following diagram:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer082">
<img alt="Figure 8.1: The AutoML workflow" height="617" src="image/B19863_08_01.jpg" width="772"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.1: The AutoML workflow</p>
<p>As you<a id="_idIndexMarker452"/> might remember from our earlier chapters, the first step of every machine learning project is to define a business problem and question, followed by the steps required for data cleaning, preparation, and modeling. Typically, data cleaning and transformation part can take up 80–90% of the time spent on <span class="No-Break">a project.</span></p>
<p>Once we have a machine-learning-ready dataset, we will continue by creating a machine <span class="No-Break">learning experiment.</span></p>
<p>In automated machine learning, the process of training machine learning algorithms on a specific dataset and target is automated. When you create an experiment and load your dataset, the system automatically examines and prepares data for machine learning. It provides you with statistics and insights about each column, aiding in the selection of a target variable. Once the training begins, multiple algorithms analyze the data, searching <span class="No-Break">for patterns.</span></p>
<p>Upon<a id="_idIndexMarker453"/> completion of the training process, you can assess the performance of the generated machine learning models using scores and rankings. By adjusting parameters and repeating the training, you can generate multiple versions of the models. After carefully evaluating the options, you can choose the model that performs best on your dataset. An experiment can have multiple versions, each using one or more algorithms, and one experiment can result in several machine <span class="No-Break">learning deployments.</span></p>
<p>Simply, during the experiment phase, we will fine-tune the model and try to achieve the best possible accuracy. Once we are happy with the model, we can deploy it into production and start utilizing it in our analysis. We will go through each of these steps in our hands-on example in the <span class="No-Break">following section.</span></p>
<h1 id="_idParaDest-104"><a id="_idTextAnchor105"/>Creating and monitoring a machine learning model with Qlik AutoML</h1>
<p>In this section, we <a id="_idIndexMarker454"/>will create an actual implementation using Qlik AutoML. We will utilize the famous Iris dataset that we <a id="_idIndexMarker455"/>have already used in this book. The data preparation part for Iris dataset is already done, so we <a id="_idIndexMarker456"/>can jump into the model training and <a id="_idIndexMarker457"/>experiment <span class="No-Break">part directly.</span></p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the datasets used in this example in the GitHub repository for <span class="No-Break">this book.</span></p>
<p class="callout-heading">Note</p>
<p class="callout">Only users with Professional entitlement can create experiments.This is a limitation at the <span class="No-Break">license level.</span></p>
<p>Let’s assume that we have already uploaded the <strong class="source-inline">iris</strong> dataset into our cloud tenant. Now, we will start to define a business question. This question defines what we would like to achieve from our machine <span class="No-Break">learning model.</span></p>
<p>As we know, the<a id="_idIndexMarker458"/> Iris dataset consists of <a id="_idIndexMarker459"/>measurements of four<a id="_idIndexMarker460"/> features of three different species of Iris flowers. These features are <span class="No-Break">as follows:</span></p>
<ul>
<li><strong class="bold">Sepal length</strong>: The length of the sepal, which is the outermost part of the flower that protects <span class="No-Break">the petals</span></li>
<li><strong class="bold">Sepal width</strong>: The width of <span class="No-Break">the sepal</span></li>
<li><strong class="bold">Petal length</strong>: The length of the petals, which are the colorful leaf-like structures inside <span class="No-Break">the flower</span></li>
<li><strong class="bold">Petal width</strong>: The width of <span class="No-Break">the petals</span></li>
</ul>
<p>The <a id="_idIndexMarker461"/>dataset contains 150 instances or samples, with 50 samples for each of the three Iris species – <strong class="source-inline">setosa</strong>, <strong class="source-inline">versicolor</strong>, and <strong class="source-inline">virginica</strong>. To define a machine learning question to predict species in<a id="_idIndexMarker462"/> the Iris dataset, we will frame it as a multi-class classification problem. Here is a sample question that we will form before <span class="No-Break">our investigation:</span></p>
<p class="author-quote">Given the measurements of sepal length, sepal width, petal length, and petal width, can we accurately classify the species of Iris flowers into setosa, versicolor, or virginica?</p>
<p>In this case, the machine learning task involves training a model to learn the patterns and relationships between the input features (sepal length, sepal width, petal length, and petal width) and the corresponding output classes (<strong class="source-inline">setosa</strong>, <strong class="source-inline">versicolor</strong>, and <strong class="source-inline">virginica</strong>). The goal is to develop a predictive model that can accurately classify new instances of iris flowers into one of the three species, based on their measurements. AutoML will choose the best-performing model for us, based on the selected target <span class="No-Break">and variables.</span></p>
<p>We will begin the actual model creation by creating a new machine learning experiment. To do that, select <strong class="bold">+ Add new</strong> � <strong class="bold">New ML experiment</strong>, as shown in the <span class="No-Break">following screenshot:</span></p>
<p class="IMG---Figure"> </p>
<div>
<div class="IMG---Figure" id="_idContainer083">
<img alt="Figure 8.2: A new machine learning experiment" height="289" src="image/B19863_08_02.jpg" width="566"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.2: A new machine learning experiment</p>
<p>A new <a id="_idIndexMarker463"/>window will open. Insert a name <a id="_idIndexMarker464"/>for your new <a id="_idIndexMarker465"/>experiment, and select a space for it. In <a id="_idIndexMarker466"/>my example, I will call the experiment <strong class="source-inline">Iris exp</strong>. Select <strong class="bold">Create</strong> <span class="No-Break">to proceed.</span></p>
<p>Then, you can select a dataset for training. Select <strong class="source-inline">iris.csv</strong>, which we uploaded earlier to our tenant. A preview window will open. In this window, we will define our target field. It will also give us important information about the dataset. You should see a preview window like <span class="No-Break">the following:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer084">
<img alt="Figure 8.3: Schema view in the machine learning experiment wizard" height="785" src="image/B19863_08_03.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.3: Schema view in the machine learning experiment wizard</p>
<p>You are<a id="_idIndexMarker467"/> currently in <strong class="bold">schema view</strong>. In <a id="_idIndexMarker468"/>this view, you can see the features (columns) in our dataset as a list. You will also <a id="_idIndexMarker469"/>see the data types that AutoML has recognized – for example, <strong class="source-inline">String</strong> for the <strong class="source-inline">species</strong> field and <strong class="source-inline">Float (Double)</strong> for <span class="No-Break">other fields.</span></p>
<p>All columns <a id="_idIndexMarker470"/>have been recognized as <strong class="source-inline">Numeric</strong> or <strong class="source-inline">Categorical</strong> fields. This can be changed for each field if needed. We<a id="_idIndexMarker471"/> can also see from the <strong class="source-inline">Insights</strong> column that our “species” feature has been automatically one-hot encoded. If there are any warnings related to some of the features, we can also see these. The following information is presented in the <span class="No-Break"><strong class="source-inline">Insights</strong></span><span class="No-Break"> column:</span></p>
<ul>
<li><strong class="bold">Constant</strong>: The column has the same value for all rows. The column can’t be used as a target or included feature. This is a pre-set limitation in Qlik AutoML to prevent <span class="No-Break">incorrect results.</span></li>
<li><strong class="bold">One-hot encoded</strong>: The feature type is categorical, and the column has fewer than 14 <span class="No-Break">unique values.</span></li>
<li><strong class="bold">Impact encoded</strong>: The feature type is categorical, and the column has 14 or more <span class="No-Break">unique values.</span></li>
<li><strong class="bold">High cardinality</strong>: The column has too many unique values and can negatively affect model performance if used as a feature. The column can’t be used as <span class="No-Break">a target.</span></li>
<li><strong class="bold">Sparse data</strong>: The column has too many <strong class="source-inline">null</strong> values. The column can’t be used as a target or <span class="No-Break">included feature.</span></li>
<li><strong class="bold">Underrepresented class</strong>: The column has a class with fewer than 10 rows. Column can’t be used as a target but can be included as <span class="No-Break">a feature.</span></li>
</ul>
<p>Before<a id="_idIndexMarker472"/> selecting our target field, we <a id="_idIndexMarker473"/>can<a id="_idIndexMarker474"/> change our <a id="_idIndexMarker475"/>view to <strong class="bold">data view</strong>. You can do this<a id="_idIndexMarker476"/> from the top-right corner of the data preview area. You should see the <span class="No-Break">following view:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer085">
<img alt="Figure 8.4: Data view in the machine learning experiment wizard" height="656" src="image/B19863_08_04.jpg" width="1454"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.4: Data view in the machine learning experiment wizard</p>
<p>In this view, we can investigate the data content more. We will see a mini-chart representing the distribution of data in each numerical field, as well as the distribution in categorical fields. We will also get information about the distinct and <span class="No-Break"><strong class="source-inline">null</strong></span><span class="No-Break"> values.</span></p>
<p>Let’s now <a id="_idIndexMarker477"/>change back to schema view and <a id="_idIndexMarker478"/>select our <strong class="source-inline">species</strong> feature as a target. To do this, select <strong class="source-inline">species</strong>, as shown in the <span class="No-Break">following screenshot:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer086">
<img alt="Figure 8.5: Target selection" height="254" src="image/B19863_08_05.jpg" width="1322"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.5: Target selection</p>
<p>All the <a id="_idIndexMarker479"/>other features are automatically <a id="_idIndexMarker480"/>included in our experiment. In this case, we want to keep all features included, but typically, we might want to drop some of the fields. On the right side, we can see the summary information about <span class="No-Break">the experiment:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer087">
<img alt="Figure 8.6: The experiment summary" height="633" src="image/B19863_08_06.jpg" width="406"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.6: The experiment summary</p>
<p>First, we get a summary of our training data. We will see the total amount of cells, columns, and rows in a dataset and how many of those have been included in the experiment. In our case, all data is included, since we decided to keep all the features in <span class="No-Break">our experiment.</span></p>
<p>Now, we<a id="_idIndexMarker481"/> can see some information about our target. We can also change the target before running our experiment. In<a id="_idIndexMarker482"/> this case, our target is <strong class="source-inline">species</strong>. The following section will give us a summary of the selected features. We will select all the features from our data as part of <span class="No-Break">our experiment.</span></p>
<p>In the <a id="_idIndexMarker483"/>algorithm section, we can see that <a id="_idIndexMarker484"/>AutoML has identified our model to be a multiclass classification, based on our target field. We can decide to exclude some algorithms from our experiment if we want. Typically, it is recommended to keep all <span class="No-Break">algorithms included.</span></p>
<p>Under model optimization, we can enable hyperparameter optimization and set the maximum time for our experiment to run optimization. Hyperparameter optimization will create a series of models from a methodical search for the optimal combination of algorithm hyperparameters, maximizing model performance. An experiment can take a long time to run if this option is enabled, but results can be <span class="No-Break">more accurate.</span></p>
<p>Ultimately, we will get a reminder <a id="_idIndexMarker485"/>of the preprocessing steps that AutoML will take care of for us. These are <span class="No-Break">as follows:</span></p>
<ol>
<li><strong class="bold">Imputation of nulls</strong>: AutoML automatically fills in missing and <strong class="source-inline">null</strong> values in features that have at least 50% of the values populated. Depending on each feature’s data type, AutoML selects <strong class="source-inline">MEAN</strong> or <span class="No-Break"><strong class="source-inline">OTHER</strong></span><span class="No-Break"> imputation.</span></li>
<li><strong class="bold">Encoding categorical features</strong>: AutoML automatically converts your categorical features to numerical values so that algorithms can effectively process and learn from your categorical training data. For features with 13 or fewer values, AutoML uses one-hot encoding. For features with 14 or more values, AutoML uses <span class="No-Break">impact encoding.</span></li>
<li><strong class="bold">Feature scaling</strong>: AutoML uses feature scaling to normalize the range of independent variables in your training data. AutoML calculates the mean and standard deviation for each column, and then it calculates the number of standard deviations away from the mean for <span class="No-Break">each row.</span></li>
<li><strong class="bold">Automatic holdout of training data</strong>: AutoML extracts 20% of your training dataset to be used for final model evaluation. AutoML <em class="italic">holds</em> that data until after <a id="_idIndexMarker486"/>model training, when it is used to evaluate the performance of the model. The benefit of holdout data is that it is not seen by the model during training (unlike cross-validation data), so it is ideal to validate <span class="No-Break">model performance.</span></li>
<li><strong class="bold">Five-fold cross-validation</strong>: After applying the previous preprocessing steps, AutoML randomly sorts your remaining training data into five distinct groups called “folds” for use in cross-validation. AutoML tests each fold against a model trained using the other four folds. In other words, each trained model is tested on a piece of data that the model has never <span class="No-Break">seen before.</span></li>
</ol>
<p>We are<a id="_idIndexMarker487"/> now<a id="_idIndexMarker488"/> ready with our experiment<a id="_idIndexMarker489"/> setup and can proceed by selecting <strong class="bold">Run experiment</strong>. The <a id="_idIndexMarker490"/>actual model preprocessing and training phase will start; it will take a while to finish. After the experiment has finished running the models, we will see the <strong class="bold">Model metrics</strong> screen, as shown in the <span class="No-Break">following screenshot:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer088">
<img alt="Figure 8.7: Model metrics" height="726" src="image/B19863_08_07.jpg" width="1500"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.7: Model metrics</p>
<p>We can see that the top-performing model was the XGBoost Classification algorithm, with an <strong class="source-inline">F1 Macro</strong> score of <strong class="source-inline">0.967</strong>. We also get information about the <strong class="source-inline">F1 Micro</strong>, <strong class="source-inline">F1</strong> <strong class="source-inline">Weighted</strong>, and <strong class="source-inline">Accuracy</strong> scores. We <a id="_idIndexMarker491"/>covered the meaning of the F1 score in the first chapter. The <a id="_idIndexMarker492"/>difference between the <a id="_idIndexMarker493"/>micro, macro, and weighted F1 scores is <span class="No-Break">the following:</span></p>
<ul>
<li>Macro F1 is the averaged F1 value for each class without weighting (all classes are <span class="No-Break">treated equally).</span></li>
<li>Micro F1 is the F1 value calculated across the entire confusion matrix. Calculating the micro F1 score is equivalent to calculating the global precision or <span class="No-Break">global recall.</span></li>
<li>Weighted F1 corresponds to the binary classification F1. It is calculated for each class and then combined as a weighted average, considering the number of records for <span class="No-Break">each class.</span></li>
</ul>
<p>As you<a id="_idIndexMarker494"/> might remember, accuracy measures how often a model makes a correct prediction on average. In our case, the accuracy score is 0.967, meaning that our model is correct ~97% <span class="No-Break">of cases.</span></p>
<p>Under <strong class="source-inline">Hyperparameters</strong>, we can also investigate the model parameters. For our top-performing model, these look like <span class="No-Break">the following:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer089">
<img alt="Figure 8.8: Hyperparameters for XGBoost classification" height="315" src="image/B19863_08_08.jpg" width="443"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.8: Hyperparameters for XGBoost classification</p>
<p>These<a id="_idIndexMarker495"/> are<a id="_idIndexMarker496"/> meant to give us more <a id="_idIndexMarker497"/>detailed information about the model. Parameters <span class="No-Break">are algorithm-specific.</span></p>
<p>Now, we will <a id="_idIndexMarker498"/>take a closer look at the <strong class="bold">Permutation importance</strong> and <strong class="bold">SHAP importance</strong> diagrams. We explored the basic concept of both diagrams in <a href="B19863_01.xhtml#_idTextAnchor014"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>. The following figure shows an example of <span class="No-Break">the diagrams:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer090">
<img alt="Figure 8.9: The Permutation importance and SHAP importance diagrams" height="468" src="image/B19863_08_09.jpg" width="941"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.9: The Permutation importance and SHAP importance diagrams</p>
<p>As you <a id="_idIndexMarker499"/>might remember, permutation <a id="_idIndexMarker500"/>importance is a measure of how <a id="_idIndexMarker501"/>important a feature is to the overall prediction of a model. Basically, it describes how the model would be affected if you removed its ability to learn from that feature. AutoML uses the scikit-learn toolkit to calculate <span class="No-Break">permutation importance.</span></p>
<p>SHAP importance is a method used to interpret the predictions of machine learning models. It provides insights into the contribution of each feature to the prediction for a specific instance, or a group of instances. Basically, it represents how a feature influences the prediction of a single row, relative to the other features in that row and to the average outcome in the dataset. SHAP importance is measured at the row level, and AutoML uses various algorithms to calculate the SHAP <span class="No-Break">importance score.</span></p>
<p>From the preceding graphs, we can see that <strong class="bold">petal_length</strong> is an important feature in our prediction, both in terms of permutation and SHAP importance. In multiclass problems, we can also investigate the SHAP importance for each class. Let’s investigate our SHAP <a id="_idIndexMarker502"/>values for each feature by class. Change a graph type using the drop-down menu on the SHAP chart, and select <strong class="bold">Feature SHAP by class</strong>. You should see the <span class="No-Break">following graph:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer091">
<img alt="Figure 8.10: SHAP by class" height="467" src="image/B19863_08_10.jpg" width="463"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.10: SHAP by class</p>
<p>From the <a id="_idIndexMarker503"/>preceding graph, we can <a id="_idIndexMarker504"/>see that <strong class="bold">petal_length</strong> can <a id="_idIndexMarker505"/>be used to distinguish <strong class="bold">setosa</strong> from <strong class="bold">versicolor</strong> and <strong class="bold">virginica</strong>. Other features are then used to determine the species further. We can also see the SHAP importance for each specific class if we change the graph type from the <span class="No-Break">drop-down menu.</span></p>
<p>If we want to <a id="_idIndexMarker506"/>change our experiment, we can select <strong class="bold">Configure v2</strong> and modify the parameters for it. In this case, we are happy with our model. To deploy our model, we can select <strong class="bold">Deploy</strong>. We can provide a name for our model if we are not happy with the autogenerated one and decide a space for it. AutoML autofills some details about the model in the <strong class="bold">Description</strong> field. Make sure that the <strong class="bold">Enable real-time API access</strong> option is enabled, and select <strong class="bold">Deploy</strong>. Then, select <strong class="bold">Open</strong> from the popup, and you should get redirected to our new machine learning model. You should then see a view like <span class="No-Break">the following:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer092">
<img alt="Figure 8.11: The deployed machine learning model" height="624" src="image/B19863_08_11.jpg" width="924"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.11: The deployed machine learning model</p>
<p>On the <a id="_idIndexMarker507"/>left-hand side, you can see a<a id="_idIndexMarker508"/> schema <a id="_idIndexMarker509"/>for the deployed model. The schema will tell us what kind of data our model expects when using it for predictions. On<a id="_idIndexMarker510"/> the right side, we can see details about our model. The other two tabs will give us information about predictions that were run manually and the <strong class="source-inline">REST</strong> endpoint connectivity. Take a closer look at these, and return to schema view when you <span class="No-Break">are done.</span></p>
<p>We can use our model directly by selecting <strong class="bold">Create prediction</strong> and uploading a CSV or other data file for our model. This way, we will get our results stored as a file in Qlik Cloud. There is also a possibility to schedule predictions and apply dynamic naming for result files. However, a more robust way to utilize our new model is to use it through a data connector. Let’s take a closer look into <span class="No-Break">that next.</span></p>
<p>For our application, we will use another dataset called <strong class="source-inline">iris_test.csv</strong>. To begin, upload the file to Qlik Cloud. Create a new Qlik application, and add the <strong class="source-inline">iris_test</strong> data to it. Now, we will add the <strong class="source-inline">id</strong> field into our test data. To do that, you can use the <span class="No-Break">following code:</span></p>
<pre class="source-code">
iris:
LOAD
RowNo() as id,
     sepal_length,
     sepal_width,
     petal_length,
     petal_width
FROM [lib://&lt;PATH TO DATAFILE&gt;/iris_test.csv]
(txt, utf8, embedded labels, delimiter is ',', msq);</pre> <p class="callout-heading">Note</p>
<p class="callout">Our <strong class="source-inline">iris_test.csv</strong> dataset is randomly generated to mimic the characteristics of the original <strong class="source-inline">iris</strong> dataset and does not represent the actual data. It should be only used for <span class="No-Break">demonstration purposes.</span></p>
<p>Now, we <a id="_idIndexMarker511"/>will <a id="_idIndexMarker512"/>create a connection to our deployed machine<a id="_idIndexMarker513"/> learning <a id="_idIndexMarker514"/>model. Select <strong class="bold">Create new connection</strong> under the data connections, and then select <strong class="bold">Qlik AutoML</strong>. A view like the following <span class="No-Break">will open:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer093">
<img alt="Figure 8.12: A data connection to the machine learning model" height="606" src="image/B19863_08_12.jpg" width="590"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.12: A data connection to the machine learning model</p>
<p>Select our <a id="_idIndexMarker515"/>deployed model from the <strong class="bold">ML deployment</strong> dropdown. Then, provide a name for the returned response table. In our example, it’s called <strong class="source-inline">predictions</strong>. Select <strong class="bold">Include SHAP</strong> and <strong class="bold">Include Errors</strong>, since <a id="_idIndexMarker516"/>we want our result<a id="_idIndexMarker517"/> table <a id="_idIndexMarker518"/>to also include these columns. SHAP is not available for every algorithm, but it is a good practice to select it. If it’s not available, it will not appear in the results table. In our case, these values are <span class="No-Break">not available.</span></p>
<p>In <strong class="bold">Association Field</strong>, type <strong class="source-inline">id</strong>. This is a field that ties the generated predictions and our original data together. We generated the <strong class="source-inline">id</strong> field in our data earlier. Provide a name for your data connection, and click <strong class="bold">Save</strong>. You should see a new data connection appear in your application; let’s use it. Click <strong class="bold">Select data</strong>, as shown in the <span class="No-Break">following screenshot:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer094">
<img alt="Figure 8.13: Select data in the AutoML connection" height="218" src="image/B19863_08_13.jpg" width="282"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.13: Select data in the AutoML connection</p>
<p>The<a id="_idIndexMarker519"/> data selection wizard will appear, as <a id="_idIndexMarker520"/>shown in the <a id="_idIndexMarker521"/><span class="No-Break">following</span><span class="No-Break"><a id="_idIndexMarker522"/></span><span class="No-Break"> screenshot:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer095">
<img alt="Figure 8.14: The data selection wizard" height="607" src="image/B19863_08_14.jpg" width="1124"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.14: The data selection wizard</p>
<p>In the <strong class="bold">Resident Table</strong> field, type <strong class="source-inline">iris</strong>. This is our original dataset, which we will use to get predictions. Select the <strong class="source-inline">predictions</strong> table under the <strong class="bold">Tables</strong> section. This is our results table. There is no preview available, but you can see the script generated. Select <strong class="bold">Insert script</strong>. We can now see that our connector generated the <span class="No-Break">following script:</span></p>
<pre class="source-code">
[predictions]:
LOAD * EXTENSION endpoints.ScriptEval('{"RequestType":"endpoint", "endpoint":{"connectionname":"ML demos:Iris"}}', iris);</pre> <p>Basically, our<a id="_idIndexMarker523"/> connector uses the API <a id="_idIndexMarker524"/>to send the <strong class="source-inline">iris</strong> table into <a id="_idIndexMarker525"/>our machine learning model and gets the prediction table back. It takes the<a id="_idIndexMarker526"/> connection name as a parameter and our data table (<strong class="source-inline">iris</strong>) as an input. We can now load our application and investigate the data model viewer. You should see a data model like <span class="No-Break">the following:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer096">
<img alt="Figure 8.15: The data model" height="219" src="image/B19863_08_15.jpg" width="372"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.15: The data model</p>
<p>As we can see, our connector returned a predictions table that is connected to our original data table, using <strong class="source-inline">id</strong> as a key. The predictions table contains the actual prediction, a possible error message for each row, and the probability for every <span class="No-Break">Iris species.</span></p>
<p>Now, we <a id="_idIndexMarker527"/>will investigate our prediction <a id="_idIndexMarker528"/>results further. Create a new sheet, and add the following <a id="_idIndexMarker529"/>elements <span class="No-Break">to it:</span></p>
<ul>
<li>A filter pane, with all our features on <span class="No-Break">the top.</span></li>
<li>A scatter plot, with <strong class="source-inline">Avg(petal_width)</strong> on the <em class="italic">y</em> axis and <strong class="source-inline">Avg(petal_length)</strong> on the <em class="italic">x</em> axis and <strong class="source-inline">Id</strong> as a bubble. Color by dimension, and select <strong class="source-inline">species_predicted</strong> as the <span class="No-Break">coloring dimension.</span></li>
<li>A table containing all <span class="No-Break">our features.</span></li>
<li>A bar chart, with <strong class="source-inline">Count(species_predicted)</strong> as the bar height and <strong class="source-inline">species_predicted</strong> as <span class="No-Break">the dimension.</span></li>
<li>Four KPI objects that we will <span class="No-Break">configure later.</span></li>
<li>Four variable inputs, with text and an image container on the left side of each <span class="No-Break">of them.</span></li>
</ul>
<p>You <a id="_idIndexMarker530"/>should end up with a layout like <span class="No-Break">the following:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer097">
<img alt="Figure 8.16: The application layout" height="713" src="image/B19863_08_16.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.16: The application layout</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the complete application in the GitHub repository for <span class="No-Break">this book.</span></p>
<p>As you can <a id="_idIndexMarker531"/>see from the results, we <a id="_idIndexMarker532"/>have managed to predict the species with our model. If we look at the scatter plot, it <a id="_idIndexMarker533"/>seems that our model gives good results, keeping in mind that our data is randomly generated. As a last step, we will create a simulation that will <a id="_idIndexMarker534"/>utilize the API of <span class="No-Break">our model.</span></p>
<p>We will start by creating the <span class="No-Break">following variables:</span></p>
<pre class="source-code">
v_sepal_length
v_sepal_width
v_petal_length
v_petal_width</pre> <p>Make <strong class="source-inline">0</strong> the default value for each variable. Since we have already created our variable input and labels, we can assign the variables into inputs and type the correct labels into place. You should end up with the <span class="No-Break">following view:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer098">
<img alt="Figure 8.17: The simulation view" height="391" src="image/B19863_08_17.jpg" width="638"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.17: The simulation view</p>
<p>Now, we<a id="_idIndexMarker535"/> will <a id="_idIndexMarker536"/>set up the KPI objects. Select <a id="_idIndexMarker537"/>the first KPI, and type <strong class="source-inline">Prediction</strong> as a label. Enter<a id="_idIndexMarker538"/> the following formula in the <span class="No-Break"><strong class="bold">Expression</strong></span><span class="No-Break"> field:</span></p>
<pre class="source-code">
=endpoints.ScriptEvalExStr('NNNN','{"RequestType":"endpoint", "endpoint":{"connectionname":"ML demos:Iris","column":"species_predicted"}}',
v_petal_length as petal_length,
v_petal_width as petal_width,
v_sepal_length as sepal_length,
v_sepal_width as sepal_width
)</pre> <p>This<a id="_idIndexMarker539"/> syntax might look familiar. We used the same principle in our earlier example with R. AutoML connector utilizes <a id="_idIndexMarker540"/>advanced<a id="_idIndexMarker541"/> analytics <a id="_idIndexMarker542"/><span class="No-Break">integration syntax.</span></p>
<p>With the advanced analytics integration, we have two sets of <span class="No-Break">script functions:</span></p>
<ul>
<li><strong class="bold">ScriptEval</strong>: After<a id="_idIndexMarker543"/> the hypercube has been aggregated, all rows in the specified columns are sent to the connector. The response expected is a single column. If multiple columns are returned, the first column that has the same number of rows as the input will be picked. The rows in the returned column must be in the same order as <span class="No-Break">the input.</span></li>
<li><strong class="bold">ScriptAggr</strong>: Before<a id="_idIndexMarker544"/> the hypercube is aggregated, all rows for a single dimension group in the hypercube are sent, and the <strong class="bold">server-side extension</strong> (<strong class="bold">SSE</strong>) is expected to return a single one-column, one-row response. There will be one request sent to the SSE for each dimension value. While there are use cases for this, it is rare for this method to be used, as it can create performance issues if <strong class="source-inline">ScriptAggr</strong> is called with <span class="No-Break">many dimensions.</span></li>
</ul>
<p>For both the preceding sets, there are four different functions based on the <span class="No-Break">data types:</span></p>
<ul>
<li><strong class="source-inline">ScriptEval(Script, Field 1, [Field n])</strong>: The input fields and the response must <span class="No-Break">be numeric.</span></li>
<li><strong class="source-inline">ScriptEvalStr(Script, Field 1, [Field n])</strong>: The input fields and the response must be <span class="No-Break">a string.</span></li>
<li><strong class="source-inline">ScriptEvalEx(DataTypes, Script, Field 1, [Field n])</strong>: The input fields can be either string or numeric, the first parameter is a string of the datatypes, and the response must <span class="No-Break">be numeric.</span></li>
<li><strong class="source-inline">ScriptEvalExStr(DataTypes, Script, Field 1, [Field n])</strong>: The input fields can be either string or numeric, the first parameter is a string of the datatypes, and the response must <span class="No-Break">be string.</span></li>
</ul>
<p>We used the <strong class="source-inline">ScriptEvalExStr</strong> function in the preceding example and defined the data types of our input fields, since they are numeric but the response is a string (<strong class="source-inline">'NNNN'</strong> for <span class="No-Break">numerical fields).</span></p>
<p>Note that our script also contains the details of the connection to <span class="No-Break">be used:</span></p>
<pre class="source-code">
'{"RequestType":"endpoint", "endpoint":{"connectionname":"ML demos:Iris","column":"species_predicted"}}'.</pre> <p>The connection <a id="_idIndexMarker545"/>name refers to the data<a id="_idIndexMarker546"/> connector that we created <a id="_idIndexMarker547"/>earlier. We have also determined the column that we want to get from the model. In our case, it is <strong class="source-inline">species_predicted</strong>. Selecting a correct return value is important. You can see all the <a id="_idIndexMarker548"/>possible fields – for example, from the data manager – if you have also used the model during the <span class="No-Break">data load.</span></p>
<p>In the last part of our script, we will pass the variable values as input to our model. The names should match the names of our model schema. That’s why we will use the <strong class="source-inline">as</strong> operator to rename <span class="No-Break">the variables.</span></p>
<p>After configuring the KPI object, you should see <strong class="source-inline">setosa</strong> appear as a value. Since all our variables are defined to be <strong class="source-inline">0</strong>, our model will give a prediction based on <span class="No-Break">that information.</span></p>
<p>Add the following configurations to the three remaining <span class="No-Break">KPI objects:</span></p>
<ul>
<li><span class="No-Break"><strong class="bold">Label</strong></span><span class="No-Break">: Setosa</span></li>
<li><span class="No-Break"><strong class="bold">Script</strong></span><span class="No-Break">:</span><pre class="source-code">
=endpoints.ScriptEvalEx('NNNN','{"RequestType":"endpoint", "endpoint":{"connectionname":"ML demos:Iris","column":"species_setosa"}}',
v_petal_length as petal_length,
v_petal_width as petal_width,
v_sepal_length as sepal_length,
v_sepal_width as sepal_width
)</pre></li> <li><span class="No-Break"><strong class="bold">Label</strong></span><span class="No-Break">: Versicolor</span></li>
<li><span class="No-Break"><strong class="bold">Script</strong></span><span class="No-Break">:</span><pre class="source-code">
=endpoints.ScriptEvalEx('NNNN','{"RequestType":"endpoint", "endpoint":{"connectionname":"ML demos:Iris","column":"species_versicolor"}}',
v_petal_length as petal_length,
v_petal_width as petal_width,
v_sepal_length as sepal_length,
v_sepal_width as sepal_width
)</pre></li> <li><span class="No-Break"><strong class="bold">Label</strong></span><span class="No-Break">: Virginica</span></li>
<li><span class="No-Break"><strong class="bold">Script</strong></span><span class="No-Break">:</span><pre class="source-code">
=endpoints.ScriptEvalEx('NNNN','{"RequestType":"endpoint", "endpoint":{"connectionname":"ML demos:Iris","column":"species_virginica"}}',
v_petal_length as petal_length,
v_petal_width as petal_width,
v_sepal_length as sepal_length,
v_sepal_width as sepal_width
)</pre></li> </ul>
<p>As you <a id="_idIndexMarker549"/>might<a id="_idIndexMarker550"/> have noticed, the <a id="_idIndexMarker551"/>script is<a id="_idIndexMarker552"/> nearly the same in all our KPIs. We define the output by changing the value of the return column from the model. This way, we will get the probabilities for <span class="No-Break">each species.</span></p>
<p>Try to modify<a id="_idIndexMarker553"/> the values in input fields, and <a id="_idIndexMarker554"/>you should get a prediction and probabilities for each of the species in <span class="No-Break">real time.</span></p>
<p>We have now <a id="_idIndexMarker555"/>successfully finished the application<a id="_idIndexMarker556"/> and learned how to utilize Qlik AutoML in a cloud environment, using both load-time and real-time integration. In the following section, we will look at setting up an on-premises environment to integrate with <span class="No-Break">Qlik AutoML.</span></p>
<h1 id="_idParaDest-105"><a id="_idTextAnchor106"/>Connecting Qlik AutoML to an on-premises environment</h1>
<p>Qlik AutoML<a id="_idIndexMarker557"/> is a cloud tool that integrates tightly with a cloud tenant. However, it is possible to utilize the features from an <a id="_idIndexMarker558"/>on-premises environment. It is important to note that since Qlik AutoML still runs in a cloud environment, all data is also passed into the Qlik Cloud tenant. This approach is not suitable if the data can’t leave the on-premises environment. The connection is encrypted and secure, and Qlik Cloud has all the major security certifications. It is also important to note that this approach will require a valid license for <span class="No-Break">Qlik Cloud.</span></p>
<p class="callout-heading">Note</p>
<p class="callout">More information about Qlik Cloud security and compliance is available at the Qlik Trust <span class="No-Break">site: </span><a href="https://www.qlik.com/us/trust"><span class="No-Break">https://www.qlik.com/us/trust</span></a></p>
<p>We can see the basic architecture of integrating AutoML with an on-premises environment in the <span class="No-Break">following diagram:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer099">
<img alt="Figure 8.18: Qlik AutoML – on-premises and SaaS integration" height="481" src="image/B19863_08_18.jpg" width="817"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.18: Qlik AutoML – on-premises and SaaS integration</p>
<p>In the<a id="_idIndexMarker559"/> preceding diagram, we have our on-premises environment at the bottom. We will handle most of the data loads in the<a id="_idIndexMarker560"/> on-premises environment in this architecture. After preparing a machine-learning-ready dataset, we can utilize Qlik Data Gateway, the Qlik CLI, or manually upload to a cloud tenant. This data can be supplemented using data coming from other cloud sources. When our training data is in the cloud, training the machine learning model will involve the same process from the previous section. It is also possible to automate the whole process using tasks, application automation, and the Qlik CLI. Once the model is trained, we can then utilize the prediction API directly from the <span class="No-Break">on-premises environment.</span></p>
<p>Specific details about implementing the described environment are different in each organization. The preceding diagram can be used as a rough reference, but specific implementation should be planned case <span class="No-Break">by case.</span></p>
<p>The goal of this section was to give some ideas about the usage of Qlik AutoML in hybrid scenarios. In the following section, we will investigate some of the best practices when working with <span class="No-Break">Qlik AutoML.</span></p>
<h1 id="_idParaDest-106"><a id="_idTextAnchor107"/>Best practices with Qlik AutoML</h1>
<p>There are some<a id="_idIndexMarker561"/> general guidelines and best practices when working with Qlik AutoML. Following these practices and principles will make it easier to get accurate results and handle the machine learning project flow. The general principles include <span class="No-Break">the following:</span></p>
<ul>
<li><strong class="bold">Define the problem</strong>: Clearly define the problem you are trying to solve with Qlik AutoML. Identify the variables you want to predict, and understand the available data. This is one of the most important <span class="No-Break">best practices.</span></li>
<li><strong class="bold">Prepare and clean the data</strong>: Ensure that your data is in a format suitable for analysis. This may involve cleaning missing values, handling outliers, transforming variables, cleaning duplicates, and making sure the data is well formatted. This is typically the most time-consuming part of machine <span class="No-Break">learning projects.</span></li>
<li><strong class="bold">Feature engineering</strong>: Explore and create meaningful features from your raw data. Qlik AutoML can automate some feature engineering tasks, but it’s still important to understand your data and apply domain knowledge to generate <span class="No-Break">relevant features.</span></li>
<li><strong class="bold">Interpretability and explainability</strong>: Understand and interpret the results of your models. Qlik AutoML provides tools to interpret generated models, and understands the contribution of different features to <span class="No-Break">the predictions.</span></li>
<li><strong class="bold">Validation and evaluation</strong>: Use proper evaluation metrics to assess the performance of your models. Qlik AutoML can provide default metrics, but always cross-validate results <span class="No-Break">when possible.</span></li>
<li><strong class="bold">Monitoring and maintenance</strong>: Continuously monitor the performance of your models in production. Update and retrain the models periodically as new data <span class="No-Break">becomes available.</span></li>
<li><strong class="bold">Iterative process</strong>: Machine learning is an iterative process, so be prepared to refine and improve your models based on feedback and <span class="No-Break">new insights.</span></li>
</ul>
<p>Qlik AutoML is<a id="_idIndexMarker562"/> a powerful tool to build machine learning models in an automated way, and it can make it easier for end users to understand complex models. When utilizing the tool, and keeping in mind the basic principles described previously, organizations can get more out of their data. Remember that no machine learning tool is a magic box that can solve all the business problems in the world. The better you prepare the problem definition and training data, the more accurate results you will get from <span class="No-Break">a model.</span></p>
<h1 id="_idParaDest-107"><a id="_idTextAnchor108"/>Summary</h1>
<p>In this chapter, we discovered the usage of Qlik AutoML. We first learned what the tool will provide for users and what its key features are. We built our first machine learning model with Qlik AutoML using the famous Iris dataset. In this section, we discovered how to run experiments and deploy a model from experimentation. We also discovered how to utilize the model in a Qlik application, both during a data load and in real time. We learned from different metrics how our <span class="No-Break">model performed.</span></p>
<p>In the latter part of this chapter, we took a quick look at an on-premises environment. We learned how to utilize Qlik AutoML in hybrid scenarios and how to set up our environment in these use cases. We also discovered some of the best practices to be used with <span class="No-Break">Qlik AutoML.</span></p>
<p>In the following chapter, we will dive deep into data visualization. We will discover the techniques to visualize machine-learning-related data and investigate the use of some of the lesser-used graph types. We will also learn about common charts and visualizations, and we will discover some of the settings and configurations that will help us get the most out of <span class="No-Break">our data.</span></p>
</div>
</div></body></html>