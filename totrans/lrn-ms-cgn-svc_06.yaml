- en: Chapter 6. Understanding Text
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous chapter covered the speech APIs. Throughout this chapter, we will
    look closer at more language APIs. We will learn how to use spellcheck features.
    We will then discover how to detect languages, key phrases, and sentiment in text.
    Finally, we will look at the translator text API to see how we can detect languages
    and translate text.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this chapter, we will have covered the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Checking spelling and recognizing slang and informal language, common names,
    homonyms, and brands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting language, key phrases, and sentiment in text
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Translating text on the fly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a common core
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we get into the details, we want to set ourselves up for success. At
    the time of writing, none of the language APIs that we will be covering have NuGet
    client packages. As such, we will need to call directly to the REST endpoints.
    Because of this, we will do some work beforehand to make sure that we get away
    with writing less code.
  prefs: []
  type: TYPE_NORMAL
- en: New project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will not be adding the APIs to our smart-house application. Using the following
    steps, create a new project using the MVVM template that we created in [Chapter
    1](ch01.html "Chapter 1. Getting Started with Microsoft Cognitive Services"),
    *Getting Started with Microsoft Cognitive Services*:'
  prefs: []
  type: TYPE_NORMAL
- en: Go into the NuGet package manager and install `Newtonsoft.Json`. This will help
    us deserialize API responses and serialize request bodies.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on **References**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Assemblies** tab, select **System.Web** and **System.Runtime.Serialization**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `MainView.xaml` file, add a `TabControl` element. All our additional
    views will be added as `TabItems` in the `MainView`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Web requests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All the APIs follow the same pattern. They call on their respective endpoints
    using either `POST` or `GET` requests. Further on, they pass on parameters as
    query strings, and some as request bodies. Since they have these similarities,
    we can create one class that will handle all API requests.
  prefs: []
  type: TYPE_NORMAL
- en: In the `Model` folder, add a new class and call it `WebRequest`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need a few `private` variables, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The constant, `JsonContentTypeHeader`, defines the content type that we want
    to use for all API calls. The `_settings` phrase is a `JsonSerializerSettings`
    object, which specifies how we want JSON data to be (de)serialized.
  prefs: []
  type: TYPE_NORMAL
- en: The `_httpClient` is the object that will be used to make our API requests.
    The last member, `_endpoint`, will hold the API endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in the following code, our constructor will accept two parameters:
    one string for the URI, and one string for the API key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We assign the `uri` to the corresponding member. Next, we create a new object
    of a `HttpClient` type and add one request header. This is the header that contains
    the given `apiKey`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The class will contain one function, `MakeRequest`. This should have the return
    type of `Task<TResponse>`, meaning a type that we specify when calling the function.
    As you can see in the following code, it should accept three parameters: a `HttpMethod`,
    a query `string`, and a `TRequest`, (which is a request body that we specify in
    the call). The function should be asynchronous:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The preceding lines show the complete function signature. Note how we do not
    need to specify a request body, as there are some cases where it may be empty.
    We will cover what `TRequest` and `TResponse` may be in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: 'We enter a `try` clause, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: First, we create a `url`, consisting of our `_endpoint` and the `queryString`.
    Using this and the specified `method`, we create a `HttpRequestMessage` object.
  prefs: []
  type: TYPE_NORMAL
- en: If we have a `requestBody`, we add `Content` to the `request` object by serializing
    the `requestBody`.
  prefs: []
  type: TYPE_NORMAL
- en: With the request in order, we make an asynchronous call to `SendAsync` on the
    `_httpClient` object. This will call the API endpoint, returning a `HttpResponseMessage`
    containing the response.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the `response` is successful, we want to get the `Content` as a string.
    This is done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Make an asynchronous call to `ReadAsStringAsync`. This will return a string.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Deserialize the string as a `TResponse` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return the deserialized object to the caller.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the case that there is no data in `responseContent`, we return a default
    `TResponse`. This will contain default values for all properties, as shown in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If the API response contains any error code, then we try to get the error message
    as a string (`errorObjectString`). In a typical application, you would want to
    deserialize this and propagate it to the user. However, as this is a simple example
    application, we will choose to output it to the `Debug` console window, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Make sure you add the corresponding `catch` clause and output any exceptions
    to the `Debug` console window. Also, make sure that you return a default `TResponse`
    if any exceptions occur.
  prefs: []
  type: TYPE_NORMAL
- en: Data contracts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we need to (de)serialize JSON data as a part of the requests and responses
    to the APIs, we need to create data contracts. These will act as the `TResponse`
    and `TRequest` objects, used in the `WebRequest` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new folder called `Contracts` to the project. A typical data contract
    may look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This correlates to errors in the text analytics API. As you can see, it has
    two string properties for `id` and `message`. Both may appear in an API response.
  prefs: []
  type: TYPE_NORMAL
- en: When discussing each API, we will see all request and response parameters in
    either table form or JSON format. We will not look at how each of these translates
    into a data contract, but it will take a similar form to that previously shown.
    It is then up to you to create the contracts needed.
  prefs: []
  type: TYPE_NORMAL
- en: The most important thing to note is that the property names must be identical
    to the corresponding JSON property.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure that the code compiles and that you can run the application before
    continuing.
  prefs: []
  type: TYPE_NORMAL
- en: Correcting spelling errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Bing Spell Check API leverages the power of machine learning and statistical
    machine translation to train and evolve a highly contextual algorithm for spellchecking.
    Doing so allows us to utilize this to perform spellchecking using context.
  prefs: []
  type: TYPE_NORMAL
- en: A typical spellchecker will follow dictionary-based rule sets. As you can imagine,
    this will need continuous updates and expansions.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Bing Spell Check API, we can recognize and correct slang and informal
    language. It can recognize common naming errors and correct word-breaking issues.
    It can detect and correct words that sound the same, but differ in meaning and
    spelling (homophones). It can also detect and correct brands and popular expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `View` in the `View` folder; call the file `SpellCheckView.xaml`.
    Add a `TextBox` element for the input query. We will also need two `TextBox` elements
    for the pre- and post-context. Add a `TextBox` element to show the result and
    a `Button` element to execute the spellcheck.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new `ViewModel` in the folder named `ViewModel`; call the file `SpellCheckViewModel.cs`.
    Make the class `public`, and let it inherit from the `ObservableObject` class.
    Add the following `private` member:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This is the `WebRequest` class that we created earlier.
  prefs: []
  type: TYPE_NORMAL
- en: We need properties corresponding to our `View`. This means that we need four
    `string` properties and one `ICommand` property.
  prefs: []
  type: TYPE_NORMAL
- en: If you have not already done so, register for a free API key at [https://portal.azure.com](https://portal.azure.com).
  prefs: []
  type: TYPE_NORMAL
- en: 'The constructor should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We create a new object of a `WebRequest` type, specifying the Bing Spell Check
    API endpoint and the API key. We also create a new `DelegateCommand` for our `ExecuteOperationCommand`,
    `ICommand`, property.
  prefs: []
  type: TYPE_NORMAL
- en: The `CanExecuteOperation` property should return `true` if our input query is
    filled in and `false` otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: 'To execute a call to the API, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: First, we create a `queryString` using `HttpUtility`. This will format the string
    so that it can be used in a URI.
  prefs: []
  type: TYPE_NORMAL
- en: As we will be calling the API using a `GET` method, we need to specify all parameters
    in the string. The required parameters are `text` and `mkt`, which are the input
    query and language, respectively. If we have entered `PreContext` and/or `PostContext`,
    then we add these parameters as well. We will look at the different parameters
    in more detail in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make the request, we need to make the following call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We call `MakeRequest` on the `_webRequest` object. As we are making a `GET`
    request, we do not need any request body, and we pass on `object` as `TRequest`.
    We expect a `SpellCheckResponse` contract in return. This will contain the resultant
    data, and we will look at the parameters in greater detail in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we have a response, we pass that on to a function to parse it, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If we do not have any response, we exit the function. Otherwise, we create
    a `StringBuilder` to format the results, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: If we have any corrected spellings, we loop through them. We add all suggestions
    to the `StringBuilder`, making sure that we add the likelihood of the suggestion
    being correct. At the end, we make sure that we output the result to the UI.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table describes all the parameters we can add to the API call:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Parameter | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `text` | The text that we want to check for spelling and grammar errors.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `mode` | The current mode of the spellcheck. It can be either of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Proof**: Spelling corrections for long queries, as typically used in MS Word.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Spell**: Used for search engine corrections. Can be used for queries up to
    nine words long (tokens).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `preContextText` | The string that gives context to the text. The petal parameter
    is valid, but if you specify bike in this parameter, it will be corrected to pedal.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `postContextText` | The string that gives context to the text. The read parameter
    is valid, but if you specify carpet in this parameter, it may be corrected to
    red. |'
  prefs: []
  type: TYPE_TB
- en: '| `mkt` | For proof mode, the language must be specified. It can currently
    be en-us, es-es, or pt-br. For spell mode, all language codes are supported. |'
  prefs: []
  type: TYPE_TB
- en: 'A successful response will be a JSON response, containing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `offset` is where the word appears in the text and `token` is the word that
    contains the error, while `type` describes the type of error. The `suggestions`
    phrase contains an array with the suggested correction and the probability of
    it being correct.
  prefs: []
  type: TYPE_NORMAL
- en: When the `View` and `ViewModel` have been correctly initialized, as seen in
    previous chapters, we should be able to compile and run the example.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example output of running a spellcheck may give the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Correcting spelling errors](img/B12373_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Extracting information through textual analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using the **text analytics** API, we are able to analyze text. We will cover
    language detection, key-phrase analysis, and sentiment analysis. In addition,
    a new feature is the ability to detect topics. This does, however, require a lot
    of sample text, and as such, we will not go into detail on this last feature.
  prefs: []
  type: TYPE_NORMAL
- en: For all our text-analysis tasks, we will be using a new `View`. Add a new `View`
    into the `View` folder called `TextAnalysisView.xaml`. This should contain a `TextBox`
    element for the input query. It should also have a `TextBox` element for the result.
    We will need three `Button` elements, one for each detection analysis that we
    will perform.
  prefs: []
  type: TYPE_NORMAL
- en: We will also need a new `ViewModel`, so add `TextAnalysisViewModel.cs` to the
    `ViewModel` folder. In this, we need two `string` properties, one for each `TextBox`.
    Also add three `ICommand` properties, one for each of our buttons.
  prefs: []
  type: TYPE_NORMAL
- en: If you have not already done so, register for an API key at [https://portal.azure.com](https://portal.azure.com).
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a `private` member called `_webRequest` of a `WebRequest` type. With that
    in place, we can create our constructor, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The constructor creates a new `WebRequest` object, specifying the API endpoint
    and API key. We then go on to create the `DelegateCommand` objects for our `ICommand`
    properties. The `CanExecuteOperation` function should return `true` if we have
    entered the input query and `false` otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting language
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The API can detect which language is used in text from over 120 different languages.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a `POST` call, so we need to send in a request body. A request body
    should consist of `documents`. This is basically an array containing a unique
    `id` for each `text`. It also needs to contain the text itself, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We create a `queryString` specifying the REST endpoint that we want to reach.
    Then we go on to create a `TextRequest` contract, which contains documents. As
    we only want to check one piece of text, we add one `TextDocumentRequest` contract,
    specifying an `id` and the `text`.
  prefs: []
  type: TYPE_NORMAL
- en: When the request is created, we call `MakeRequest`. We expect the response to
    be of a `TextResponse` type and the request body to be of a `TextRequests` type.
    We pass along `POST` as the call method, the `queryString`, and the `request`
    body.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the response is successful, then we loop through the `detectedLanguages`.
    We add the languages to a `StringBuilder`, also outputting the probability of
    that language being correct. This is then displayed in the UI, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'A successful response will contain the following JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This contains an array of `documents` `-`, as many as were provided in the request.
    Each document will be marked with a unique `id` and contain an array of `detectedLanguage`
    instances. These languages will have the `name`, `iso6391Name`, and the probability
    (`score`) of being correct.
  prefs: []
  type: TYPE_NORMAL
- en: If any errors occur for any document, we will get an array of `errors`. Each
    error will contain the `id` of the document where the error occurred and the `message`
    as a string.
  prefs: []
  type: TYPE_NORMAL
- en: 'A successful call will create a result similar to the one shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Detecting language](img/B12373_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Extracting key phrases from text
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Extracting key phrases from text may be useful if we want our application to
    know key talking points. Using this, we can learn what people are discussing in
    articles, discussions, or other such sources of text.
  prefs: []
  type: TYPE_NORMAL
- en: This call also uses the `POST` method, which requires a request body. As with
    language detection, we need to specify documents. Each document will need a unique
    ID, the text, and the language used. At the time of writing, English, German,
    Spanish, and Japanese are the only languages that are supported.
  prefs: []
  type: TYPE_NORMAL
- en: 'To extract key phrases, we use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, it is quite similar to detecting languages. We create a `queryString`
    using `keyPhrases` as the REST endpoint. We create a request object of the `TextRequests`
    type. We add the documents list, creating one new `TextDocumentRequest`. Again,
    we need the `id` and `text`, but we have also added a `language` tag, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If the response contains any key phrases then we loop through them and output
    them to the UI. A successful response will provide the following JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Here we have an array of `documents`. Each document has a unique `id`, corresponding
    to the ID in the request. Each document also contains an array of strings, with
    `keyPhrases`.
  prefs: []
  type: TYPE_NORMAL
- en: As with language detection, any errors will be returned as well.
  prefs: []
  type: TYPE_NORMAL
- en: Learning whether a text is positive or negative
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using sentiment analysis, we can detect whether or not a text is positive. If
    you have a merchandise website where users can submit feedback, this feature can
    automatically analyze whether the feedback is generally positive or negative.
  prefs: []
  type: TYPE_NORMAL
- en: The sentiment scores are returned as a number between 0 and 1, where a high
    number indicates a positive sentiment.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with the previous two analyses, this is a `POST` call, requiring a request
    body. Again, we need to specify the documents, and each document requires a unique
    ID, the text, and the language, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We create a `queryString` pointing to `sentiment` as the REST endpoint. The
    data contract is `TextRequests`, containing `documents`. The document we pass
    on has a unique `id`, the text, and the language:'
  prefs: []
  type: TYPE_NORMAL
- en: A call to `MakeRequest` will require a request body of a `TextSentimentRequests`
    type, and we expect the result to be of a `TextSentimentResponse` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the response contains any `documents`, we loop through them. For each document,
    we check the `score`, and output whether or not the text is positive or negative.
    This is then shown in the UI, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'A successful response will result in the following JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This is an array of `documents`. Each document will have a corresponding `id`
    as the request and the sentiment `score`. If any `errors` have occurred, they
    will be entered as we saw in the language and key-phrase detection sections.
  prefs: []
  type: TYPE_NORMAL
- en: 'A successful test can look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Learning whether a text is positive or negative](img/B12373_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Translating text on the fly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using the translator text API, you can easily add translations to your application.
    The API allows you to automatically detect the language. This can be used to serve
    localized content, or to quickly translate content. It also allows us to look
    up alternative translations that can be used to translate words into different
    contexts.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, the translator text API can be used to build customized translation
    systems. This means that you can improve the existing models. This can be done
    by adding existing human translations related to expressions and vocabulary in
    your industry.
  prefs: []
  type: TYPE_NORMAL
- en: 'The translator text API is available as a REST API. We will cover the four
    endpoints that you can reach. To use the API, the following root URL should be
    used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Sign up for an API key at Microsoft Azure Portal.
  prefs: []
  type: TYPE_NORMAL
- en: Translating text
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To translate text from one language to another, you should call the following
    URL path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The following parameters must be specified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This parameter can be specified multiple times.
  prefs: []
  type: TYPE_NORMAL
- en: The request body must contain the text that is to be translated.
  prefs: []
  type: TYPE_NORMAL
- en: 'A successful call will result in the following JSON output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Converting text script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To translate text from one language script (such as Arabic) to another (such
    as Latin), you should call the following URL path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The following parameters must be specified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The request body must contain the text that is to be translated.
  prefs: []
  type: TYPE_NORMAL
- en: 'A successful call will result in the following JSON output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Working with languages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are two paths that you can use when working with languages. The first
    one is used to detect language in a specific text. The second one is used to get
    a list of languages supported by the other APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting the language
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To detect the language that a certain text uses, you should call the following
    URL path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The request body must contain the text that is to be translated. No parameters
    are needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'A successful call will result in the following JSON output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Getting supported languages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To get a list of supported languages, you should call the following URL path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: No parameters or body are required for this call.
  prefs: []
  type: TYPE_NORMAL
- en: 'A successful call will result in the following JSON output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the two-letter country code is the key for each entry. You can
    also find the four-letter code for each transliterate language. This API path
    can be used as a basis for the other API paths.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have focused on the language APIs. We started by creating
    the parts that are needed to execute the API calls to the different services.
    Following this, we looked at the Bing Spell Check API. We moved on to more analytical
    APIs, where we learned how to detect languages, key phrases, and sentiment. Finally,
    we looked into how we can use the translator text API.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will take us from language APIs to knowledge APIs. In the following
    chapter, we will learn how to recognize and identify entities based on context.
    In addition, we will learn how to use the recommendations API.
  prefs: []
  type: TYPE_NORMAL
