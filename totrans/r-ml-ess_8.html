<html><head></head><body><div class="chapter" title="Chapter&#xA0;8.&#xA0;Machine Learning Examples Applicable to Businesses"><div class="titlepage"><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Machine Learning Examples Applicable to Businesses</h1></div></div></div><p>The purpose of this chapter is to show you how machine learning helps in solving a business problem. Most of the techniques have already been explored in the previous chapter, so the pace of this chapter is fast. The techniques are about unsupervised and supervised learning. Unsupervised algorithms extract hidden structures from data and supervised techniques forecast an attribute. This chapter solves a business challenge using techniques belonging to the two branches.</p><p>In this chapter, you will learn how to:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Apply the machine learning approach to a business problem</li><li class="listitem" style="list-style-type: disc">Segment the customer base of a bank</li><li class="listitem" style="list-style-type: disc">Identify the target of a marketing campaign</li><li class="listitem" style="list-style-type: disc">Choose the technique performing better</li></ul></div><div class="section" title="Overview of the problem"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec43"/>Overview of the problem</h1></div></div></div><p>A <a id="id418" class="indexterm"/>Portuguese banking institution launches a phone call marketing campaign. The institution has limited resources, so it needs to choose the target clients. Starting from the data about a past campaign, we can give some support to the company using machine learning techniques. The data shows personal details of the clients and information about previous marketing campaigns. The target of machine learning algorithms is to identify the clients that are more likely to subscribe. Starting from the data, the algorithms need to understand how to use new clients' data to predict how likely each of them will subscribe.</p><div class="section" title="Data overview"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec45"/>Data overview</h2></div></div></div><p>The data <a id="id419" class="indexterm"/>consists of approximately more than 2,500 clients affected by a marketing campaign consisting of one or more phone calls. We have some details about the clients and we know who subscribed.</p><p>Each row of the table corresponds to a client and there is a column displaying the output that is <code class="literal">yes</code> if the client subscribed and <code class="literal">no</code> otherwise. The other columns are features describing the clients and they are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Personal details</strong></span>: This incudes details such as age, job, marital status, education, credit default, average yearly balance, housing, and personal loan</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Communication with the company</strong></span>: This incudes details such as contact type, last contact month and weekday, last call duration, and number of contacts</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Previous campaigns</strong></span>: This incudes details such as number of days before the previous campaign, number of past contacts, and past outcomes</li></ul></div><p>This is a sample of the table. The <code class="literal">y</code> column displays the attribute to predict <code class="literal">yes</code> if the client subscribed and <code class="literal">no</code> otherwise.</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Age</p>
</th><th style="text-align: left" valign="bottom">
<p>Job</p>
</th><th style="text-align: left" valign="bottom">
<p>Marital status</p>
</th><th style="text-align: left" valign="bottom">
<p>...</p>
</th><th style="text-align: left" valign="bottom">
<p>Contact</p>
</th><th style="text-align: left" valign="bottom">
<p>…</p>
</th><th style="text-align: left" valign="bottom">
<p>y</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>30</p>
</td><td style="text-align: left" valign="top">
<p>services</p>
</td><td style="text-align: left" valign="top">
<p>married</p>
</td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p>cellular</p>
</td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p>no</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>33</p>
</td><td style="text-align: left" valign="top">
<p>management</p>
</td><td style="text-align: left" valign="top">
<p>single</p>
</td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p>telephone</p>
</td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p>yes</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>41</p>
</td><td style="text-align: left" valign="top">
<p>blue-collar</p>
</td><td style="text-align: left" valign="top">
<p>single</p>
</td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p>unknown</p>
</td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p>no</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>35</p>
</td><td style="text-align: left" valign="top">
<p>self-employed</p>
</td><td style="text-align: left" valign="top">
<p>married</p>
</td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p>telephone</p>
</td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p>no</p>
</td></tr></tbody></table></div><p>The data is stored in <code class="literal">bank.csv</code> and we can load them into R building a data table. The <code class="literal">sep=';'</code> field specifies that the fields in the file are separated by a semicolon, as follows:</p><div class="informalexample"><pre class="programlisting">library(data.table)
dtBank &lt;- data.table(read.csv('bank.csv', sep=';'))</pre></div><p>The <code class="literal">duration</code> feature displays the number of seconds in the final call. The target of our analysis is to define which clients to call and we cannot know the duration before contacting the client. In addition, after knowing a call duration, we already know whether the client has subscribed or not, so it is pointless to use this attribute to predict the outcome. For these reasons, we removed the <code class="literal">duration</code> feature, as follows:</p><div class="informalexample"><pre class="programlisting"># remove the duration
dtBank[, duration := NULL]</pre></div><p>The next step is to <a id="id420" class="indexterm"/>explore the data in order to understand the context.</p></div><div class="section" title="Exploring the output"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec46"/>Exploring the output</h2></div></div></div><p>In this <a id="id421" class="indexterm"/>subsection, we quickly explore and transform the data.</p><p>The <code class="literal">y</code> output is categoric and the possible outcomes are <code class="literal">yes</code> and <code class="literal">no</code> and our target is to visualize the proportions. For this purpose, we can build a pie chart using these steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Count how many clients subscribed and how many didn't using <code class="literal">table</code>:<div class="informalexample"><pre class="programlisting">dtBank[, table(y)]
<span class="strong"><strong>y</strong></span>
<span class="strong"><strong>  no  yes</strong></span>
<span class="strong"><strong>4000  521</strong></span>
</pre></div></li><li class="listitem">Determine the percentage of clients subscribing and not subscribing:<div class="informalexample"><pre class="programlisting">dtBank[, table(y) / .N]
<span class="strong"><strong>y</strong></span>
<span class="strong"><strong>     no     yes </strong></span>
<span class="strong"><strong>0.88476 0.11524</strong></span>
</pre></div></li><li class="listitem">Build a function determining the percentages starting from the proportions:<div class="informalexample"><pre class="programlisting">DefPercentage &lt;- function(frequency)
{
  percentage = frequency / sum(frequency)
  percentage = round(percentage * 100)
  percentage = paste(percentage, '%')
  return(percentage)
}</pre></div></li><li class="listitem">Determine the percentages:<div class="informalexample"><pre class="programlisting">defPercentage(dtBank[, table(y) / .N])
<span class="strong"><strong>[1] "88 %" "12 %"</strong></span>
</pre></div></li><li class="listitem">Look at the help of <code class="literal">barplot</code> that is the R function building bar charts:<div class="informalexample"><pre class="programlisting">help(barplot)</pre></div></li><li class="listitem">Define the barplot input:<div class="informalexample"><pre class="programlisting">tableOutput &lt;- dtBank[, table(y)]
colPlot &lt;- rainbow(length(tableOutput))
percOutput &lt;- defPercentage(tableOutput)</pre></div></li><li class="listitem">Build the barplot:<div class="informalexample"><pre class="programlisting">barplot(
  height = tableOutput,
  names.arg = percOutput,
  col = colPlot,
  legend.text = names(tableOutput),
  xlab = 'Subscribing'
  ylab = 'Number of clients',
  main = 'Proportion of clients subscribing'
)</pre></div></li></ol></div><p>The plot obtained <a id="id422" class="indexterm"/>is as follows:</p><div class="mediaobject"><img src="graphics/7740OS_08_01.jpg" alt="Exploring the output"/></div><p>Only 12 percent of the clients subscribed, so the output values are not equally distributed. The next step is to explore all the data.</p></div><div class="section" title="Exploring and transforming features"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec47"/>Exploring and transforming features</h2></div></div></div><p>Similar to the <a id="id423" class="indexterm"/>output, we can build some charts to explore the features. Let's <a id="id424" class="indexterm"/>first take a look at them using <code class="literal">str</code>:</p><div class="informalexample"><pre class="programlisting">str(dtBank)
Classes 'data.table' and 'data.frame':    4521 obs. of  16 variables:
<span class="strong"><strong> $ age      : int  30 33 35 30 59 35 36 39 41 43 ...</strong></span>
<span class="strong"><strong> $ job      : Factor w/ 12 levels "admin.","blue-collar",..: 11 8 5 5 2 5 7 10 3 8 ...</strong></span>
<span class="strong"><strong> $ marital  : Factor w/ 3 levels "divorced","married",..: 2 2 3 2 2 3 2 2 2 2 ...</strong></span>
<span class="strong"><strong>...</strong></span>
</pre></div><p>The features belong to two data types:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Categoric</strong></span>: This <a id="id425" class="indexterm"/>data type stores features in the factor format</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Numeric</strong></span>: This <a id="id426" class="indexterm"/>data type stores features in the integer format</li></ul></div><p>The charts for the categoric features are different from the numeric ones, so we need to split the features in two groups. We can define a vector containing the categoric features and another vector for the numeric features by using the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Define each <a id="id427" class="indexterm"/>column class using <code class="literal">lapply</code>:<div class="informalexample"><pre class="programlisting">classFeatures &lt;- lapply(dtBank, class)</pre></div></li><li class="listitem">Remove the <code class="literal">y</code> column containing the output:<div class="informalexample"><pre class="programlisting">classFeatures &lt;- classFeatures[names(classFeatures) != 'y']</pre></div></li><li class="listitem">Determine the categoric features:<div class="informalexample"><pre class="programlisting">featCategoric &lt;- names(classFeatures)[
  classFeatures == 'factor'
  ]</pre></div></li><li class="listitem">Determine the numeric features:<div class="informalexample"><pre class="programlisting">featNumeric &lt;- names(classFeatures)[
  classFeatures == 'integer'
  ]</pre></div></li></ol></div><p>Similar to the output, we can build a pie chart for each of the nine categoric features. In order to avoid having <a id="id428" class="indexterm"/>too many charts, we can put three pies in the same chart. The R function is <code class="literal">par</code> and it allows a grid of charts to be defined:</p><div class="informalexample"><pre class="programlisting">help(par)</pre></div><p>The input that we need is:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">mfcol</code>: This is a <a id="id429" class="indexterm"/>vector containing the number of columns and rows. For each feature, we build a chart with the pie and one with its legend. We put the pie charts on the bottom row and the legends on the top. Then, we have two rows and three columns.</li><li class="listitem" style="list-style-type: disc"><code class="literal">mar</code>: This is a <a id="id430" class="indexterm"/>vector defining the plot margins:<div class="informalexample"><pre class="programlisting">par(mfcol = c(2, 3), mar = c(3, 4, 1, 2))</pre></div></li></ul></div><p>Now, we can build the histograms using a <code class="literal">for</code> loop:</p><div class="informalexample"><pre class="programlisting">for(feature in featCategoric){</pre></div><p>Perform the following steps inside the <code class="literal">for</code> loop:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Define the pie chart input:<div class="informalexample"><pre class="programlisting">  TableFeature &lt;- dtBank[, table(get(feature))]
  rainbCol &lt;- rainbow(length(tableFeature))
  percFeature &lt;- defPercentage(tableFeature)</pre></div></li><li class="listitem">Define a new <a id="id431" class="indexterm"/>plot with the legend consisting of the feature names matched with their color. We add the feature name as the legend title:<div class="informalexample"><pre class="programlisting">   plot.new()
   legend(
     'top', names(tableFeature),
     col = rainbCol, pch = 16,
     title = feature
   )</pre></div></li><li class="listitem">Build the <a id="id432" class="indexterm"/>histogram that will be displayed on the bottom row:<div class="informalexample"><pre class="programlisting">  barplot(
    height = tableFeature,
    names.arg = percFeature,
    col = colPlot,
    xlab = feature,
    ylab = 'Number of clients'
  )
}</pre></div></li></ol></div><p>We built three charts containing three categoric features each. Let's take a look at the first one:</p><div class="mediaobject"><img src="graphics/7740OS_08_02.jpg" alt="Exploring and transforming features"/></div><p>The <code class="literal">job</code> attribute has different levels and some of them have a significant number of clients. Then, we can define a dummy variable for each relevant job and ignore the others. In order to <a id="id433" class="indexterm"/>identify the most relevant jobs, we determine the percentage of people belonging to each level. Then, we set a threshold and ignore all levels <a id="id434" class="indexterm"/>whose percentage is below the threshold. In this case, the threshold is 0.08, that is, 8 percent. After defining the new dummy columns, we remove <code class="literal">job</code>:</p><div class="informalexample"><pre class="programlisting">percJob &lt;- dtBank[, table(job) / .N]
colRelevant &lt;- names(percJob)[percJob &gt; 0.08]
for(nameCol in colRelevant){
  newCol &lt;- paste('job', nameCol, sep='_')
  dtBank[, eval(newCol) := ifelse(job == nameCol, 1, 0)]
}
dtBank[, job := NULL]</pre></div><p>Here, <code class="literal">marital</code>, defining the marital status, has three levels out of which <code class="literal">divorced</code> and <code class="literal">single</code> have a smaller, although significant, slice. We can define two dummy variables defining the three levels:</p><div class="informalexample"><pre class="programlisting">dtBank[, single := ifelse(marital == 'single', 1, 0)]
dtBank[, divorced := ifelse(marital == 'divorced', 1, 0)]
dtBank[, marital := NULL]</pre></div><p>With regard to <code class="literal">education</code>, more than half of the clients received a secondary education, so we can assume <a id="id435" class="indexterm"/>that the 4 percent of <code class="literal">unknown</code> are <code class="literal">secondary</code>. Then, we have three attributes and we can define two dummy variables:</p><div class="informalexample"><pre class="programlisting">dtBank[, edu_primary := ifelse(education == 'primary', 1, 0)]
dtBank[, edu_tertiary := ifelse(education == 'tertiary', 1, 0)]
dtBank[, education := NULL]</pre></div><p>The <a id="id436" class="indexterm"/>plot obtained is as follows:</p><div class="mediaobject"><img src="graphics/7740OS_08_03.jpg" alt="Exploring and transforming features"/></div><p>The <span class="strong"><strong>default</strong></span>, <span class="strong"><strong>housing</strong></span>, and <span class="strong"><strong>loan</strong></span> attributes have two different levels, so they can be converted <a id="id437" class="indexterm"/>into numerical form using <code class="literal">as.numeric</code>. In order to have <code class="literal">0</code> if the attribute <a id="id438" class="indexterm"/>was <code class="literal">no</code> and <code class="literal">1</code> if the attribute was <code class="literal">yes</code>, we subtract <code class="literal">1</code>, as <a id="id439" class="indexterm"/>follows:</p><div class="informalexample"><pre class="programlisting">dtBank[, housing := as.numeric(housing) - 1]
dtBank[, default := as.numeric(default) - 1]
dtBank[, loan := as.numeric(loan) - 1]</pre></div><p>The histogram obtained is as follows:</p><div class="mediaobject"><img src="graphics/7740OS_08_04.jpg" alt="Exploring and transforming features"/></div><p>Here, <span class="strong"><strong>contact</strong></span> <a id="id440" class="indexterm"/>has three options out of which one is <span class="strong"><strong>unknown</strong></span>. All the options have a significant slice, so we can define two dummy variables, as follows:</p><div class="informalexample"><pre class="programlisting">dtBank[, cellular := ifelse(contact == 'cellular', 1, 0)]
dtBank[, telephone := ifelse(contact == 'telephone', 1, 0)]
dtBank[, contact := NULL]</pre></div><p>We can convert <code class="literal">month</code> into a numeric variable in which January corresponds to <code class="literal">1</code> and December to <code class="literal">12</code>. The <a id="id441" class="indexterm"/>feature values are the month names abbreviated without a capital letter, for example, <code class="literal">jan</code> for <code class="literal">January</code>. In order to define the numeric feature, we <a id="id442" class="indexterm"/>define a vector whose first element is <code class="literal">jan</code>, second element is <code class="literal">feb</code>, and so on. Then, using <code class="literal">which</code>, we can identify the corresponding element of the vector. For instance, <code class="literal">apr</code> is the fourth element of the vector, so using <code class="literal">which</code> we obtain <code class="literal">4</code>. In order to build the vector with the ordered month names, we use <code class="literal">month.abb</code> containing the abbreviated month names and <code class="literal">tolower</code> to uncapitalize the first letter, as follows:</p><div class="informalexample"><pre class="programlisting">Months &lt;- tolower(month.abb)
months &lt;- c(
    'jan', 'feb', 'mar', 'apr', 'may', 'jun',
    'jul', 'aug', 'sep', 'oct', 'nov', 'dec'
)
dtBank[
  , month := which(month == months),
  by=1:nrow(dtBank)
  ]</pre></div><p>In <code class="literal">poutcome</code>, <code class="literal">success</code> and <code class="literal">failure</code> have a small portion of the clients. However, they are very relevant, so we define two dummy variables:</p><div class="informalexample"><pre class="programlisting">dtBank[, past_success := ifelse(poutcome == 'success', 1, 0)]
dtBank[, past_failure := ifelse(poutcome == 'failure', 1, 0)]
dtBank[, poutcome := NULL]</pre></div><p>We converted all the categoric features into the numeric format. The next step is to explore the numeric features and transform them if necessary.</p><p>There are six numeric features and we can build a plot about each of them. The chart is a histogram showing how the values of the feature are distributed. In order to visualize all the figures in the same charts, we can put them in a 3 x 2 grid using <code class="literal">par</code>. The arguments are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">mfrow</code>: Similar to <code class="literal">mfcol</code>, it defines a grid of figures. The difference is just the order in which we add the figures to the grid.</li><li class="listitem" style="list-style-type: disc"><code class="literal">mar</code>: We set the margins to their default, that is, <code class="literal">c(5, 4, 4, 2) + 0.1</code>, as follows:<div class="informalexample"><pre class="programlisting">par(mfrow=c(3, 2), mar=c(5, 4, 4, 2) + 0.1)</pre></div></li></ul></div><p>We can build the <a id="id443" class="indexterm"/>histograms using <code class="literal">hist</code>. The input is as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">x</code>: This is the vector with the data</li><li class="listitem" style="list-style-type: disc"><code class="literal">main</code>: This is the plot title</li><li class="listitem" style="list-style-type: disc"><code class="literal">xlab</code>: This is the label under the x-axis</li></ul></div><p>We can use <code class="literal">hist</code> <a id="id444" class="indexterm"/>directly inside the data table square brackets. In order to build all the charts in one step, we use a <code class="literal">for</code> loop:</p><div class="informalexample"><pre class="programlisting">for(feature in featNumeric){
  dtBank[, hist(x = get(feature), main=feature, xlab = feature)]
}</pre></div><p>The histogram obtained is as follows:</p><div class="mediaobject"><img src="graphics/7740OS_08_05.jpg" alt="Exploring and transforming features"/></div><p>Here, <span class="strong"><strong>age</strong></span> and <span class="strong"><strong>day</strong></span> are evenly distributed across their possible values, so they don't require any treatment. The remaining features are concentrated in the small values, so we need to transform them. The function that we use to define the transformed feature is the logarithm and it <a id="id445" class="indexterm"/>allows us to have more spreaded values. The logarithm works on features having values greater than 0, so we need to remove the negative values from the feature.</p><p>In order to avoid zeros, add <code class="literal">1</code> to the feature before computing the logarithm.</p><p>Accordingly with the data description, <code class="literal">pdays</code> is equal to <code class="literal">-1</code> if the institution has not contacted the client <a id="id446" class="indexterm"/>before. In order to identify the clients contacted for the first time, we can define a new dummy variable that is <code class="literal">1</code> if <code class="literal">pdays</code> is equal to <code class="literal">-1</code>. Then, we replace all the negative values with <code class="literal">0</code>, as follows:</p><div class="informalexample"><pre class="programlisting">dtBank[, not_contacted := ifelse(pdays == -1, 1, 0)]
dtBank[pdays == -1, pdays := 0]</pre></div><p>The <code class="literal">balance</code> feature represents the past balance and we can define a dummy variable that is <code class="literal">1</code>, if the balance is negative. Then, we replace the negative balances with <code class="literal">0</code>:</p><div class="informalexample"><pre class="programlisting">dtBank[, balance_negative := ifelse(balance &lt; 0, 1, 0)]
dtBank[balance &lt; 0, balance := 0]</pre></div><p>Now, we can compute the logarithm to all the features. Since the input of a logarithm must be positive and some features are equal to <code class="literal">0</code>, we add <code class="literal">1</code> to each feature before computing the logarithm:</p><div class="informalexample"><pre class="programlisting">dtBank[, pdays := log(pdays + 1)]
dtBank[, balance := log(balance + 1)]
dtBank[, campaign := log(campaign + 1)]
dtBank[, previous := log(previous + 1)]</pre></div><p>We have converted all the features into the numeric format. Now, we can take a look at the new features table:</p><div class="informalexample"><pre class="programlisting">str(dtBank)
View(dtBank)</pre></div><p>The only column <a id="id447" class="indexterm"/>that is not numeric or integer is the output <code class="literal">y</code>. We can convert it into the numeric format and change its name to output:</p><div class="informalexample"><pre class="programlisting">dtBank[, output := as.numeric(y) – 1]
dtBank[, y := NULL]</pre></div><p>We loaded and <a id="id448" class="indexterm"/>cleaned the data. Now we are ready to build the machine learning models.</p></div></div></div>
<div class="section" title="Clustering the clients"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec44"/>Clustering the clients</h1></div></div></div><p>In order to <a id="id449" class="indexterm"/>address the next marketing campaign, we need to identify the clients that are more likely to subscribe. Since it's hard to evaluate the clients one by one, we can determine homogeneous groups of clients and identify the most promising groups.</p><p>Starting from the past data, we cluster the clients on the basis of their personal details. Then, given a new <a id="id450" class="indexterm"/>client, we identify the most similar group and associate the new client to it. We don't have information about the customer behavior of the new clients, so clustering is based on the personal attributes only.</p><p>There are different techniques performing clustering and in this section we use a relevant algorithm that is hierarchical clustering. A parameter of hierarchical clustering is linkage, which is the way of computing the distance between two groups. The main options are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Single linkage</strong></span>: This <a id="id451" class="indexterm"/>is the minimum distance between an object of the first group and an object of the second group</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Complete linkage</strong></span>: This is the <a id="id452" class="indexterm"/>maximum distance between an object of the first group and an object of the second group</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Average linkage</strong></span>: This <a id="id453" class="indexterm"/>is the average distance between an object of the first group and an object of the second group</li></ul></div><p>In our case, we choose the average linkage and this choice comes from testing the three options.</p><p>We define <code class="literal">dtPers</code> containing the personal features only, as follows:</p><div class="informalexample"><pre class="programlisting">featPers &lt;- c(
  'age', 'default', 'balance', 'balance_negative',
  'housing', 'loan',
  'job_admin.', 'job_blue-collar',	'job_management',
  'job_services', 'job_technician',
  'single', 'divorced', 'edu_primary', 'edu_tertiary'
)
dtPers &lt;- dtBank[, featPers, with=F]</pre></div><p>Now, we can apply hierarchical clustering and the steps are as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Define the dissimilarity matrix:<div class="informalexample"><pre class="programlisting">d &lt;- dist(dtPers, method = 'euclidean')</pre></div></li><li class="listitem">Build the hierarchical clustering model:<div class="informalexample"><pre class="programlisting">hcOut &lt;- hclust(d, method = 'average')</pre></div></li><li class="listitem">Visualize the dendrogram. The <code class="literal">par</code> method defines the plot layout that in this case contains <a id="id454" class="indexterm"/>just one chart and <code class="literal">plot</code> contains an argument improving the appearance. The <code class="literal">labels</code> and <code class="literal">hang</code> features avoid having a <a id="id455" class="indexterm"/>messy chart in the bottom and the other arguments specify the plot title and the axis labels, as shown:<div class="informalexample"><pre class="programlisting">par(mfrow = c(1, 1))
plot(
  hcOut,
  labels = FALSE,
  hang = -1,
  main = 'Dendrogram',
  xlab = 'Client clusters',
  ylab = 'Agglomeration distance'
)</pre></div></li></ol></div><p>The histogram obtained is as follows:</p><div class="mediaobject"><img src="graphics/7740OS_08_06.jpg" alt="Clustering the clients"/></div><p>We can identify three clusters cutting the dendrogram around the height of <span class="strong"><strong>40</strong></span>. There is also another option that is <a id="id456" class="indexterm"/>cutting the dendrogram at a lower level (around 18), identifying seven clusters. We can explore both the options and visualize the two <a id="id457" class="indexterm"/>splits on the dendrogram using <code class="literal">rect.hclust</code>, as follows:</p><div class="informalexample"><pre class="programlisting">k1 &lt;- 3
k2 &lt;- 7
par(mfrow=c(1, 1))
rect.hclust(hcOut, k = k1)
rect.hclust(hcOut, k = k2)</pre></div><p>The histogram obtained is as follows:</p><div class="mediaobject"><img src="graphics/7740OS_08_07.jpg" alt="Clustering the clients"/></div><p>In order to identify the most successful cluster, we can display the proportion of clients that subscribed using a pie chart putting as its title the number of clients in the cluster. Let's see the chart for the three clusters of the first split. The steps to build the pie charts are similar to the <a id="id458" class="indexterm"/>steps we performed earlier:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Define a data <a id="id459" class="indexterm"/>table containing the output attribute:<div class="informalexample"><pre class="programlisting">dtClust &lt;- dtBank[, 'output', with = F]</pre></div></li><li class="listitem">Add two columns defining clusters to the data table. Each column corresponds to a different number of clusters:<div class="informalexample"><pre class="programlisting">dtClust[, clusterHc1 := cutree(hclOut, k = k1)]
dtClust[, clusterHc2 := cutree(hclOut, k = k2)]</pre></div></li><li class="listitem">Define the plot layout with one row and three columns. The <code class="literal">oma</code> argument defines the outer margins:<div class="informalexample"><pre class="programlisting">par(mfrow = c(1, 3), oma = c(0, 0, 10, 0))</pre></div></li><li class="listitem">Using commands similar to the data exploration, build three histograms showing the percentage of clients subscribing or not to each cluster:<div class="informalexample"><pre class="programlisting">for(iCluster in 1:k1){
  tableClust &lt;- dtClust[
    clusterHc1 == iCluster,
    table(output)
    ]
  sizeCluster &lt;- dtClust[, sum(clusterHc1 == iCluster)]
  titlePie &lt;- paste(sizeCluster, 'clients')
  barplot(
    height = tableClust,
    names.arg = defPercentage(tableClust),
    legend.text = c('no', 'yes'),
    col = c('blue', 'red'),
    main = titlePie
  )
}</pre></div></li><li class="listitem">Add the title of the charts:<div class="informalexample"><pre class="programlisting">mtext(
  text = 'Hierarchic clustering, n = 3',
  outer = TRUE, line = 1, cex = 2
)</pre></div></li></ol></div><p>The histogram <a id="id460" class="indexterm"/>obtained is as follows:</p><div class="mediaobject"><img src="graphics/7740OS_08_08.jpg" alt="Clustering the clients"/></div><p>The first and second clusters contain the majority of clients and the campaign hasn't been particularly successful on them. The third cluster is smaller and a significantly higher percentage of its clients subscribed. Then, we can start the marketing campaign targeting new clients similar to the third cluster.</p><p>Using the same R commands, we can visualize the same charts for the seven clusters identified by the second split, as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Define the plot layout with two rows and four columns:<div class="informalexample"><pre class="programlisting">par(mfrow = c(2, 4), oma = c(0, 0, 10, 0))</pre></div></li><li class="listitem">Build the histograms:<div class="informalexample"><pre class="programlisting">for(iCluster in 1:k2){
  tableClust &lt;- dtClust[
    clusterHc2 == iCluster,
    table(output)
    ]
  sizeCluster &lt;- dtClust[, sum(clusterHc2 == iCluster)]
  titlePie &lt;- paste(sizeCluster, 'clients')
  barplot(
    height = tableClust,
    names.arg = defPercentage(tableClust),
    col = c('blue', 'red'),
    main = titlePie
  )
}</pre></div></li><li class="listitem">Add the <a id="id461" class="indexterm"/>title of the charts:<div class="informalexample"><pre class="programlisting">mtext(
  text = 'Hierarchic clustering, n = 7',
  outer = TRUE, line = 1, cex = 2
)</pre></div></li></ol></div><p>The histogram <a id="id462" class="indexterm"/>obtained is as follows:</p><div class="mediaobject"><img src="graphics/7740OS_08_09.jpg" alt="Clustering the clients"/></div><p>The first three clusters contain most of the clients and the marketing campaign hasn't been particularly effective on them. The fourth and fifth cluster has a significantly higher percentage of clients subscribing. The last two clusters are very successful although they are very small. The marketing campaign will start addressing all the new clients similar to the last two clusters and it will target a part of the clients of clusters four and five.</p><p>In conclusion, using clustering, we identified small groups of customers upon which the campaign has been very <a id="id463" class="indexterm"/>successful. However, most of the customers belong to a <a id="id464" class="indexterm"/>big cluster about which we don't have enough information. The reason is that the campaign is successful on a few customers with specific features.</p></div>
<div class="section" title="Predicting the output"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec45"/>Predicting the output</h1></div></div></div><p>The past marketing <a id="id465" class="indexterm"/>campaign targeted part of the customer base. Among other 1,000 clients, how do we identify the 100 that are keener to subscribe? We can build a model that learns from the data and estimates which clients are more similar to the ones that subscribed in the previous campaign. For each client, the model estimates a score that is higher if the client is more likely to subscribe. There are different machine learning models determining the scores and we use two well-performing techniques, as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Logistic regression</strong></span>: This is a variation of the linear regression to predict a binary <a id="id466" class="indexterm"/>output</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Random forest</strong></span>: This is <a id="id467" class="indexterm"/>an ensemble based on a decision tree that works well in presence of many features</li></ul></div><p>In the end, we need to choose one out of the two techniques. There are cross-validation methods that allow us to estimate model accuracy (see <a class="link" href="ch06.html" title="Chapter 6. Step 3 – Validating the Results">Chapter 6</a>, <span class="emphasis"><em>Step 3 – Validating the Results</em></span>). Starting from that, we can measure the accuracy of both the options and pick the one performing better.</p><p>After choosing the most proper machine learning algorithm, we can optimize it using cross validation. However, in order to avoid overcomplicating the model building, we don't perform any feature selection or parameter optimization.</p><p>These are the steps to <a id="id468" class="indexterm"/>build and evaluate the models:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Load the <code class="literal">randomForest</code> package containing the random forest algorithm:<div class="informalexample"><pre class="programlisting">library('randomForest')</pre></div></li><li class="listitem">Define the formula defining the output and the variable names. The formula is in the format <code class="literal">output ~ feature1 + feature2 + ...</code>:<div class="informalexample"><pre class="programlisting">arrayFeatures &lt;- names(dtBank)
arrayFeatures &lt;- arrayFeatures[arrayFeatures != 'output']
formulaAll &lt;- paste('output', '~')
formulaAll &lt;- paste(formulaAll, arrayFeatures[1])
for(nameFeature in arrayFeatures[-1]){
  formulaAll &lt;- paste(formulaAll, '+', nameFeature)
}
formulaAll &lt;- formula(formulaAll)</pre></div></li><li class="listitem">Initialize the table containing all the testing sets:<div class="informalexample"><pre class="programlisting">dtTestBinded &lt;- data.table()</pre></div></li><li class="listitem">Define the number of iterations:<div class="informalexample"><pre class="programlisting">nIter &lt;- 10</pre></div></li><li class="listitem">Start a <code class="literal">for</code> loop:<div class="informalexample"><pre class="programlisting">for(iIter in 1:nIter)
{</pre></div></li><li class="listitem">Define the training and the test datasets:<div class="informalexample"><pre class="programlisting">indexTrain &lt;- sample(
  x = c(TRUE, FALSE),
  size = nrow(dtBank),
  replace = T,
  prob = c(0.8, 0.2)
)
dtTrain &lt;- dtBank[indexTrain]
dtTest &lt;- dtBank[!indexTrain]</pre></div></li><li class="listitem">Select a subset from the test set in such a way that we have the same number of <code class="literal">output == 0</code> and <code class="literal">output == 1</code>. First, we split <code class="literal">dtTest</code> in two parts (<code class="literal">dtTest0</code> and <code class="literal">dtTest1</code>) on the basis of the output and we count the number of rows of each part (<code class="literal">n0</code> and <code class="literal">n1</code>). Then, as <code class="literal">dtTest0</code> has more rows, we randomly select <code class="literal">n1</code> rows. In the end, we redefine <code class="literal">dtTest</code> binding <code class="literal">dtTest0</code> and <code class="literal">dtTest1</code>, as follows:<div class="informalexample"><pre class="programlisting">  dtTest1 &lt;- dtTest[output == 1]
  dtTest0 &lt;- dtTest[output == 0]
  n0 &lt;- nrow(dtTest0)
  n1 &lt;- nrow(dtTest1)
  dtTest0 &lt;- dtTest0[sample(x = 1:n0, size = n1)]
  dtTest &lt;- rbind(dtTest0, dtTest1)</pre></div></li><li class="listitem">Build the random forest model using <code class="literal">randomForest</code>. The formula argument defines the <a id="id469" class="indexterm"/>relationship between variables and the data argument defines the training dataset. In order to avoid overcomplicating the model, all the other parameters are left as their defaults:<div class="informalexample"><pre class="programlisting">modelRf &lt;- randomForest(
  formula = formulaAll,
  data = dtTrain
)</pre></div></li><li class="listitem">Build the logistic regression model using <code class="literal">glm</code>, which is a function used to build <span class="strong"><strong>Generalized Linear Models</strong></span> (<span class="strong"><strong>GLM</strong></span>). GLMs are a generalization of the linear regression and they allow to define a link function that connects the linear <a id="id470" class="indexterm"/>predictor with the outputs. The input is the same as the random forest, with the addition of <code class="literal">family = binomial(logit)</code> defining that the regression is logistic:<div class="informalexample"><pre class="programlisting">modelLr &lt;- glm(
  formula = formulaAll,
  data = dtTest,
  family = binomial(logit)
)</pre></div></li><li class="listitem">Predict the output of the random forest. The function is <code class="literal">predict</code> and its main arguments are <code class="literal">object</code> defining the model and <code class="literal">newdata</code> defining the test set, as follows:<div class="informalexample"><pre class="programlisting">dtTest[, outputRf := predict(
  object = modelRf, newdata = dtTest, type='response'
  )]</pre></div></li><li class="listitem">Predict the output of the logistic regression, using <code class="literal">predict</code> similar to the random forest. The other argument is <code class="literal">type='response'</code> and it is necessary in the case of the logistic regression:<div class="informalexample"><pre class="programlisting">dtTest[, outputLr := predict(
  object = modelLr, newdata = dtTest, type='response'
  )]</pre></div></li><li class="listitem">Add the new test set to <code class="literal">dtTestBinded</code>:<div class="informalexample"><pre class="programlisting">dtTestBinded &lt;- rbind(dtTestBinded, dtTest)</pre></div></li><li class="listitem">End the <code class="literal">for</code> loop:<div class="informalexample"><pre class="programlisting">}</pre></div></li></ol></div><p>We built <code class="literal">dtTestBinded</code> containing the <code class="literal">output</code> column that defines which clients subscribed and the scores estimated by the models. Comparing the scores with the real output, we can validate the model performances.</p><p>In order to explore <code class="literal">dtTestBinded</code>, we can build a chart showing how the scores of the non-subscribing clients are distributed. Then, we add the distribution of the subscribing clients to the chart and compare them. In this way, we can see the difference between the scores of the two groups. Since we use the same chart for the random forest and for the logistic regression, we <a id="id471" class="indexterm"/>define a function building the chart by following the given steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Define the function and its input that includes the data table and the name of the score column:<div class="informalexample"><pre class="programlisting">plotDistributions &lt;- function(dtTestBinded, colPred)
{</pre></div></li><li class="listitem">Compute the distribution density for the clients that didn't subscribe. With <code class="literal">output == 0</code>, we extract the clients not subscribing, and using <code class="literal">density</code>, we define a <code class="literal">density</code> object. The adjust parameter defines the smoothing bandwidth that is a parameter of the way we build the curve starting from the data. The bandwidth can be interpreted as the level of detail:<div class="informalexample"><pre class="programlisting">  densityLr0 &lt;- dtTestBinded[
    output == 0,
    density(get(colPred), adjust = 0.5)
    ]</pre></div></li><li class="listitem">Compute the distribution density for the clients that subscribed:<div class="informalexample"><pre class="programlisting">  densityLr1 &lt;- dtTestBinded[
    output == 1,
    density(get(colPred), adjust = 0.5)
    ]</pre></div></li><li class="listitem">Define the colors in the chart using <code class="literal">rgb</code>. The colors are transparent red and transparent blue:<div class="informalexample"><pre class="programlisting">  col0 &lt;- rgb(1, 0, 0, 0.3)
  col1 &lt;- rgb(0, 0, 1, 0.3)</pre></div></li><li class="listitem">Build the plot with the density of the clients not subscribing. Here, <code class="literal">polygon</code> is a function that adds the area to the chart:<div class="informalexample"><pre class="programlisting">  plot(densityLr0, xlim = c(0, 1), main = 'density')
  polygon(densityLr0, col = col0, border = 'black')</pre></div></li><li class="listitem">Add the clients that subscribed to the chart:<div class="informalexample"><pre class="programlisting">  polygon(densityLr1, col = col1, border = 'black')</pre></div></li><li class="listitem">Add <a id="id472" class="indexterm"/>the legend:<div class="informalexample"><pre class="programlisting">  legend(
    'top',
    c('0', '1'),
    pch = 16,
    col = c(col0, col1)
  )</pre></div></li><li class="listitem">End the function:<div class="informalexample"><pre class="programlisting">  return()
}</pre></div></li></ol></div><p>Now, we can use <code class="literal">plotDistributions</code> on the random forest output:</p><div class="informalexample"><pre class="programlisting">par(mfrow = c(1, 1))
plotDistributions(dtTestBinded, 'outputRf')</pre></div><p>The histogram obtained is as follows:</p><div class="mediaobject"><img src="graphics/7740OS_08_10.jpg" alt="Predicting the output"/></div><p>The x-axis represents the score and the y-axis represents the density that is proportional to the number of clients that subscribed for similar scores. Since we don't have a client for each possible score, assuming a level of detail of 0.01, the density curve is smoothed in the sense that the density of each score is the average between the data with a similar score.</p><p>The red and blue areas represent the non-subscribing and subscribing clients respectively. As can be easily noticed, the violet area comes from the overlapping of the two curves. For each score, we can identify which density is higher. If the highest curve is red, the client will be more likely to subscribe, and vice versa.</p><p>For the random forest, most of the non-subscribing client scores are between <code class="literal">0</code> and <code class="literal">0.2</code> and the density peak is <a id="id473" class="indexterm"/>around <code class="literal">0.05</code>. The subscribing clients have a more spread score, although higher, and their peak is around <code class="literal">0.1</code>. The two distributions overlap a lot, so it's not easy to identify which clients will subscribe starting from their scores. However, if the marketing campaign targets all customers with a score higher than 0.3, they will likely belong to the blue cluster. In conclusion, using random forest, we are able to identify a small set of customers that will subscribe very likely.</p><p>In order to get a comparison, we can build the same chart about the logistic regression output, as shown here:</p><div class="informalexample"><pre class="programlisting">plotDistributions(dtTestBinded, 'outputLr')</pre></div><p>The histogram <a id="id474" class="indexterm"/>obtained is as follows:</p><div class="mediaobject"><img src="graphics/7740OS_08_11.jpg" alt="Predicting the output"/></div><p>For the logistic regression, the two distributions overlap a bit, but they clearly cover two different regions and their peaks are very distant. The clients whose score is higher than 0.8 will very likely subscribe, so we can choose a small set of clients. We are also able to identify a bigger set of clients that will likely subscribe, if we choose the ones that scored above 0.5 or 0.6.</p><p>In conclusion, the logistic regression seems to have performed better. However, the distribution charts are good to just explore the performance and don't provide with a clear evaluation. The next step is to define how to evaluate the model using an index.</p><p>The <a id="id475" class="indexterm"/>validation index that we will use is the AUC and it depends on another chart that is the <span class="strong"><strong>Receiver Operating Characteristic</strong></span> (<span class="strong"><strong>ROC</strong></span>). After building the classification model, we define a threshold and assume that the customers with a score above the threshold will subscribe. The ROC shows the model accuracy depending on the threshold. The curve dimensions are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>True positive rate</strong></span>: This index shows out of the subscribing customers, which percentage <a id="id476" class="indexterm"/>has a score above the threshold. This index should be as high as possible.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>False positive rate</strong></span>: This index shows out of the non-subscribing customers, which <a id="id477" class="indexterm"/>percentage has a score above the threshold. This index should be as low as possible.</li></ul></div><p>The <span class="strong"><strong>Area Under Curve</strong></span> (<span class="strong"><strong>AUC</strong></span>) is the area under the ROC. Given a random client that subscribed and <a id="id478" class="indexterm"/>another random client that did not subscribe, the AUC represents the probability that the score of the client that subscribed is higher than the other.</p><p>We can define a function <a id="id479" class="indexterm"/>that builds the chart and computes the AUC index:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Load the <code class="literal">ROCR</code> package containing the function used to cross validate the model:<div class="informalexample"><pre class="programlisting">library('ROCR')</pre></div></li><li class="listitem">Define the function and its input that includes the data table and the name of the score column:<div class="informalexample"><pre class="programlisting">plotPerformance &lt;- function(dtTestBinded, colPred)
{</pre></div></li><li class="listitem">Define a prediction object that is the starting point to build the ROC chart. The function is <code class="literal">prediction</code> and it is provided by the <code class="literal">ROCR</code> package:<div class="informalexample"><pre class="programlisting">  pred &lt;- dtTestBinded[, prediction(get(colPred), output)]</pre></div></li><li class="listitem">Build the ROC chart. The function provided by the <code class="literal">ROCR</code> package is <code class="literal">performance</code> and it allows you to evaluate the prediction in different ways. In this case, we <a id="id480" class="indexterm"/>want to build a chart with the <code class="literal">true</code> and <code class="literal">false</code> <a id="id481" class="indexterm"/>positive rates, so the input is <span class="strong"><strong>true positive rate</strong></span> (<span class="strong"><strong>tpr</strong></span>) and <span class="strong"><strong>false positive rate</strong></span> (<span class="strong"><strong>fpr</strong></span>):<div class="informalexample"><pre class="programlisting">  perfRates &lt;- performance(pred, 'tpr', 'fpr')
  plot(perfRates)</pre></div></li><li class="listitem">Compute the AUC index using <code class="literal">performance</code>. The input is <code class="literal">auc</code> and it defines that we are computing the AUC index:<div class="informalexample"><pre class="programlisting">  perfAuc &lt;- performance(pred, 'auc')
  auc &lt;- perfAuc@y.values[[1]]</pre></div></li><li class="listitem">Return the AUC index as the function output:<div class="informalexample"><pre class="programlisting">  return(auc)
}</pre></div></li></ol></div><p>Using <code class="literal">plotPerformance</code>, we can build the chart about the random forest and we compute the <code class="literal">auc</code> index that we store in <code class="literal">aucRf</code>:</p><div class="informalexample"><pre class="programlisting">aucRf &lt;- plotPerformance(dtTestBinded, 'outputRf')</pre></div><p>The histogram obtained is as follows:</p><div class="mediaobject"><img src="graphics/7740OS_08_13.jpg" alt="Predicting the output"/></div><p>As anticipated, the chart displays the tpr and the fpr respectively. When the threshold is <code class="literal">1</code>, no clients have a rate higher than it, so there are no positives (clients that are predicted to subscribe). In this situation, we are in the top-right corner and both the indices are equal to 100 percent. As the <a id="id482" class="indexterm"/>threshold decreases, we have more positive customers, so tpr and fpr decrease. In the end, when the threshold is <code class="literal">0</code>, tpr and fpr are equal to <code class="literal">0</code> and we are in the bottom-left corner. In an ideal situation, tpr is equal to <code class="literal">1</code> and fpr is equal to <code class="literal">0</code> (top-left corner). Then, the closest the curve is to the top-left corner, the better.</p><p>Similar to the random forest, we build the chart and compute the AUC index for the logistic regression:</p><div class="informalexample"><pre class="programlisting">aucLr &lt;- plotPerformance(dtTestBinded, 'outputLr')</pre></div><p>The histogram obtained is as follows:</p><div class="mediaobject"><img src="graphics/7740OS_08_14.jpg" alt="Predicting the output"/></div><p>The chart for the logistic regression is similar to the one for the random forest. Looking at the details, we can notice that the curve in the bottom-left is steeper and at the top-right it is less steep, so the area under the curve, defining the AUC, is higher.</p><p>The cross validation contains a random component, so the AUC indices might vary a bit. Setting <code class="literal">nIter = 100</code>, the last time I executed the script the AUC was around 73 percent for the random forest and around the 79 percent for the logistic regression. We can conclude that the logistic regression performed better, so we should use it to build the model.</p><p>In this section, we learned how to build a model that provides a score for the customers. This algorithm allows the <a id="id483" class="indexterm"/>company to identify the customers that are more likely to subscribe and it is also possible to estimate its accuracy. A continuation of this chapter would be selecting a feature subset and optimizing the parameters in order to achieve better performances.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec46"/>Summary</h1></div></div></div><p>In this chapter, you learned how to explore and transform the data related to a business problem. You used a clustering technique to segment the customer base of a bank and a supervised learning technique to identify a score ranking the clients. After building the machine learning model, you were able to cross validate it visualizing the ROC curve and computing the AUC index. In this way, you have been able to choose the most proper technique.</p><p>This book showed how machine learning models can solve business problems. Rather than just a tutorial, the book is a path showing the importance of machine learning, how to develop a solution, and how to solve a business problem using the techniques. I hope that the book has transmitted not only the machine learning concepts, but also the passion for a field that is at the same time valuable and fascinating. I'd like to thank you for following this path. I hope it is just the start of a wonderful journey.</p><p>Please don't hesitate to contact me if you have any queries.</p></div></body></html>