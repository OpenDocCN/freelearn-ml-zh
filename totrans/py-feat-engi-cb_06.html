<html><head></head><body>
		<div id="_idContainer117">
			<h1 id="_idParaDest-168" class="chapter-number"><a id="_idTextAnchor748"/><st c="0">6</st></h1>
			<h1 id="_idParaDest-169"><a id="_idTextAnchor749"/><a id="_idTextAnchor750"/><st c="2">Extracting Features from Date and Time Variables</st></h1>
			<p><st c="50">Date and time variables contain information about dates, times, or both, and in programming, we refer to them collectively as </st><strong class="source-inline"><st c="177">datetime</st></strong><st c="185"> features. </st><st c="196">Date of birth, the time of an event, and the date and time of the last payment are examples of </st><span class="No-Break"><strong class="source-inline"><st c="291">datetime</st></strong></span><span class="No-Break"><st c="299"> variables.</st></span></p>
			<p><st c="310">Because of their nature, </st><strong class="source-inline"><st c="336">datetime</st></strong><st c="344"> features typically exhibit high cardinality. </st><st c="390">This means that they contain a huge number of unique values, each corresponding to a specific date and/or time combination. </st><st c="514">We don’t normally use </st><strong class="source-inline"><st c="536">datetime</st></strong><st c="544"> variables for machine learning models in their raw format. </st><st c="604">Instead, we enrich the dataset by extracting multiple features from these variables. </st><st c="689">These new features will typically have reduced cardinality, and allow us to capture meaningful information, such as trends, seasonality, and important events </st><span class="No-Break"><st c="847">and tendencies.</st></span></p>
			<p><st c="862">In this chapter, we will explore how to extract features from dates and time by utilizing the </st><strong class="source-inline"><st c="957">pandas</st></strong> <strong class="source-inline"><st c="963">dt</st></strong><st c="966"> module, and then automate this procedure </st><span class="No-Break"><st c="1008">with </st></span><span class="No-Break"><strong class="source-inline"><st c="1013">feature-engine</st></strong></span><span class="No-Break"><st c="1027">.</st></span></p>
			<p><st c="1028">This chapter will cover the </st><span class="No-Break"><st c="1057">following recipes:</st></span></p>
			<ul>
				<li><st c="1075">Extracting features from dates </st><span class="No-Break"><st c="1107">with </st></span><span class="No-Break"><strong class="source-inline"><st c="1112">pandas</st></strong></span></li>
				<li><st c="1118">Extracting features from time </st><span class="No-Break"><st c="1149">with </st></span><span class="No-Break"><strong class="source-inline"><st c="1154">pandas</st></strong></span></li>
				<li><st c="1160">Capturing elapsed time between </st><span class="No-Break"><strong class="source-inline"><st c="1192">datetime</st></strong></span><span class="No-Break"><st c="1200"> variables</st></span></li>
				<li><st c="1210">Working with time in different </st><span class="No-Break"><st c="1242">time zones</st></span></li>
				<li><st c="1252">Automating </st><strong class="source-inline"><st c="1264">datetime</st></strong><st c="1272"> feature extraction </st><span class="No-Break"><st c="1292">with </st></span><span class="No-Break"><strong class="source-inline"><st c="1297">feature-engine</st></strong></span></li>
			</ul>
			<h1 id="_idParaDest-170"><a id="_idTextAnchor751"/><a id="_idTextAnchor752"/><st c="1311">Technical requirements</st></h1>
			<p><st c="1334">In this chapter, we will use the </st><strong class="source-inline"><st c="1368">pandas</st></strong><st c="1374">, </st><strong class="source-inline"><st c="1376">numpy</st></strong><st c="1381">, and </st><strong class="source-inline"><st c="1387">feature-engine</st></strong> <span class="No-Break"><st c="1401">Python libraries.</st></span></p>
			<h1 id="_idParaDest-171"><a id="_idTextAnchor753"/><a id="_idTextAnchor754"/><st c="1419">Extracting features from dates with pandas</st></h1>
			<p><st c="1462">The </st><a id="_idIndexMarker423"/><st c="1467">values of </st><strong class="source-inline"><st c="1477">datetime</st></strong><st c="1485"> variables can be dates, time, or </st><a id="_idIndexMarker424"/><st c="1519">both. </st><st c="1525">We’ll begin by focusing on those variables that</st><a id="_idIndexMarker425"/><st c="1572"> contain dates. </st><st c="1588">We rarely use raw dat</st><a id="_idTextAnchor755"/><st c="1609">es with machine learning algorithms. </st><st c="1647">Instead, we extract simpler features, such as the year, month, or day of the week, that allow us to capture insights such as seasonality, periodicity, </st><span class="No-Break"><st c="1798">and trends.</st></span></p>
			<p><st c="1809">The </st><strong class="source-inline"><st c="1814">pandas</st></strong><st c="1820"> Python library is great for working with date and time. </st><st c="1877">Utilizing the </st><strong class="source-inline"><st c="1891">pandas</st></strong> <strong class="source-inline"><st c="1897">dt</st></strong><st c="1900"> module, we can access the </st><strong class="source-inline"><st c="1927">datetime</st></strong><st c="1935"> properties of a </st><strong class="source-inline"><st c="1952">pandas</st></strong><st c="1958"> Series to extract many features. </st><st c="1992">However, to leverage this functionality, the variables need to be cast into a data type that supports these operations, such as </st><strong class="source-inline"><st c="2120">datetime</st></strong> <span class="No-Break"><st c="2128">or </st></span><span class="No-Break"><strong class="source-inline"><st c="2132">timedelta</st></strong></span><span class="No-Break"><st c="2141">.</st></span></p>
			<p class="callout-heading"><st c="2142">Note</st></p>
			<p class="callout"><st c="2147">The </st><strong class="source-inline"><st c="2152">datetime</st></strong><st c="2160"> variables can be cast as objects, particularly when we load the data from a CSV file. </st><st c="2247">To extract the date and time features that we will discuss throughout this chapter, it is necessary to recast the variables </st><span class="No-Break"><st c="2371">as </st></span><span class="No-Break"><strong class="source-inline"><st c="2374">datetime</st></strong></span><span class="No-Break"><st c="2382">.</st></span></p>
			<p><st c="2383">In this recipe, we will learn how to extract features from dates by </st><span class="No-Break"><st c="2452">utilizing </st></span><span class="No-Break"><strong class="source-inline"><st c="2462">panda</st><a id="_idTextAnchor756"/><a id="_idTextAnchor757"/><st c="2467">s</st></strong></span><span class="No-Break"><st c="2469">.</st></span></p>
			<h2 id="_idParaDest-172"><a id="_idTextAnchor758"/><st c="2470">Getting ready</st></h2>
			<p><st c="2484">The following are some of the features that we can extract from the </st><strong class="source-inline"><st c="2553">date</st></strong><st c="2557"> part of the </st><strong class="source-inline"><st c="2570">datetime</st></strong><st c="2578"> variable off the shelf </st><span class="No-Break"><st c="2602">using </st></span><span class="No-Break"><strong class="source-inline"><st c="2608">pandas</st></strong></span><span class="No-Break"><st c="2614">:</st></span></p>
			<ul>
				<li><span class="No-Break"><strong class="source-inline"><st c="2616">pandas.Series.dt.year</st></strong></span></li>
				<li><span class="No-Break"><strong class="source-inline"><st c="2637">pandas.Series.dt.quarter</st></strong></span></li>
				<li><span class="No-Break"><strong class="source-inline"><st c="2662">pandas.Series.dt.month</st></strong></span></li>
				<li><span class="No-Break"><strong class="source-inline"><st c="2685">pandas.Series.dt.isocalendar().week</st></strong></span></li>
				<li><span class="No-Break"><strong class="source-inline"><st c="2721">pandas.Series.dt.day</st></strong></span></li>
				<li><span class="No-Break"><strong class="source-inline"><st c="2742">pandas.Series.dt.day_of_week</st></strong></span></li>
				<li><span class="No-Break"><strong class="source-inline"><st c="2771">pandas.Series.dt.weekday</st></strong></span></li>
				<li><span class="No-Break"><strong class="source-inline"><st c="2796">pandas.Series.dt.dayofyear</st></strong></span></li>
				<li><span class="No-Break"><strong class="source-inline"><st c="2823">pandas.Series.dt.day_of_year</st></strong></span></li>
			</ul>
			<p><st c="2852">We can </st><a id="_idIndexMarker426"/><st c="2860">use the features we’ve obtained with </st><strong class="source-inline"><st c="2897">pandas</st></strong><st c="2903"> to</st><a id="_idIndexMarker427"/><st c="2906"> create even more features, such as the semester or </st><a id="_idIndexMarker428"/><st c="2958">whether it is a weekend. </st><st c="2983">We will learn how to do this in the </st><span class="No-Break"><st c="3019">next sec</st><a id="_idTextAnchor759"/><a id="_idTextAnchor760"/><st c="3027">tion.</st></span></p>
			<h2 id="_idParaDest-173"><a id="_idTextAnchor761"/><st c="3033">How to do it...</st></h2>
			<p><st c="3049">To pr</st><a id="_idTextAnchor762"/><st c="3055">oceed with the recipe, let’s i</st><a id="_idTextAnchor763"/><st c="3086">mport </st><strong class="source-inline"><st c="3093">pandas</st></strong><st c="3099"> and </st><strong class="source-inline"><st c="3104">numpy</st></strong><st c="3109">, and create a </st><span class="No-Break"><st c="3124">sample DataFrame:</st></span></p>
			<ol>
				<li><st c="3141">Let’s import </st><span class="No-Break"><st c="3155">the libraries:</st></span><pre class="source-code"><st c="3169">
import numpy as np
import pandas as pd</st></pre></li>				<li><st c="3208">We’ll start by creating 20 </st><strong class="source-inline"><st c="3236">datetime</st></strong><st c="3244"> values beginning from </st><strong class="source-inline"><st c="3267">2024-05-17</st></strong><st c="3277"> at midnight and followed by increments of 1 day. </st><st c="3327">Then, we’ll capture those values in a </st><strong class="source-inline"><st c="3365">DataFrame</st></strong><st c="3374"> instance and display the top </st><span class="No-Break"><st c="3404">five rows:</st></span><pre class="source-code"><st c="3414">
rng_ = pd.date_range(
    "2024-05-17", periods=20, freq="D")
data = pd.DataFrame({"date": rng_})
data.head()</st></pre><p class="list-inset"><st c="3520">In the following output, we see the variable containing dates that we created in </st><span class="No-Break"><em class="italic"><st c="3602">Ste</st><a id="_idTextAnchor764"/><st c="3605">p 2</st></em></span><span class="No-Break"><st c="3609">:</st></span></p></li>			</ol>
			<div>
				<div id="_idContainer094" class="IMG---Figure">
					<img src="image/B22396_06_1.jpg" alt="Figure 6.1 – Top rows of a DataFrame with a datetime variable containing only dates"/><st c="3611"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="3680">Figure 6.1 – Top rows of a DataFrame with a datetime variable containing only dates</st></p>
			<p class="callout-heading"><st c="3763">Note</st></p>
			<p class="callout"><st c="3768">We can check the data format of the variable by executing </st><strong class="source-inline"><st c="3827">data["date"].dtypes</st></strong><st c="3846">. If the variable is cast as an object, we can convert it into </st><strong class="source-inline"><st c="3909">datetime</st></strong><st c="3917"> format by executing </st><strong class="source-inline"><st c="3938">data["date_dt"] = </st></strong><span class="No-Break"><strong class="source-inline"><st c="3956">pd.to_datetime(data["date"])</st></strong></span><span class="No-Break"><st c="3984">.</st></span></p>
			<ol>
				<li value="3"><st c="3985">L</st><a id="_idTextAnchor765"/><st c="3987">et’s</st><a id="_idIndexMarker429"/><st c="3991"> extract the year pa</st><a id="_idTextAnchor766"/><st c="4011">rt of the date in a </st><a id="_idIndexMarker430"/><st c="4032">new column and display the top five rows of</st><a id="_idIndexMarker431"/><st c="4075"> the </st><span class="No-Break"><st c="4080">resulting DataFrame:</st></span><pre class="source-code"><st c="4100">
data["year"] = data["date"].dt.year
data.head()</st></pre><p class="list-inset"><st c="4148">We see the new </st><strong class="source-inline"><st c="4164">year</st></strong><st c="4168"> variable in the </st><span class="No-Break"><st c="4185">following o</st><a id="_idTextAnchor767"/><st c="4196">utput:</st></span></p></li>			</ol>
			<div>
				<div id="_idContainer095" class="IMG---Figure">
					<img src="image/B22396_06_2.jpg" alt="Figure 6.2 – First five rows of the DataFrame with the year variable extracted from the date"/><st c="4203"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="4303">Figure 6.2 – First five rows of the DataFrame with the year variable extracted from the date</st></p>
			<ol>
				<li value="4"><st c="4395">Let’s extract the quarter of the year out of the date into a new column and display the top </st><span class="No-Break"><st c="4488">five rows:</st></span><pre class="source-code"><st c="4498">
data["quarter"] = data["date"].dt.quarter
data[["date", "quarter"]].head()</st></pre><p class="list-inset"><st c="4573">We see the new </st><strong class="source-inline"><st c="4589">quarter</st></strong><st c="4596"> variable in the </st><span class="No-Break"><st c="4613">following ou</st><a id="_idTextAnchor768"/><st c="4625">tput:</st></span></p></li>			</ol>
			<div>
				<div id="_idContainer096" class="IMG---Figure">
					<img src="image/B22396_06_3.jpg" alt="Figure 6.3 – The first five rows of a DataFrame with the quarter variable extracted from the date"/><st c="4631"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="4722">Figure 6.3 – The first five rows of a DataFrame with the quarter variable extracted from the date</st></p>
			<ol>
				<li value="5"><st c="4819">With </st><strong class="source-inline"><st c="4825">quarte</st><a id="_idTextAnchor769"/><st c="4831">r</st></strong><st c="4833">, we </st><a id="_idIndexMarker432"/><st c="4838">c</st><a id="_idTextAnchor770"/><st c="4839">an</st><a id="_idIndexMarker433"/><st c="4841"> now </st><a id="_idIndexMarker434"/><st c="4846">create the </st><span class="No-Break"><strong class="source-inline"><st c="4857">semester</st></strong></span><span class="No-Break"><st c="4865"> feature:</st></span><pre class="source-code"><st c="4874">
data["semester"] = np.where(data["quarter"] &lt; 3, 1, 2)</st></pre></li>			</ol>
			<p class="callout-heading"><st c="4929">Note</st></p>
			<p class="callout"><st c="4934">You can explore the distinct values of the new variables utilizing </st><strong class="source-inline"><st c="5002">pandas</st></strong><st c="5008">’ </st><strong class="source-inline"><st c="5011">unique()</st></strong><st c="5019">, for example, by executing </st><strong class="source-inline"><st c="5047">df["quarter"].unique()</st></strong> <span class="No-Break"><st c="5069">or </st></span><span class="No-Break"><strong class="source-inline"><st c="5073">df["semester"].unique()</st></strong></span><span class="No-Break"><st c="5096">.</st></span></p>
			<ol>
				<li value="6"><st c="5097">Let’s extract the </st><strong class="source-inline"><st c="5116">month</st></strong><st c="5121"> part of the date in a new column and display the top five rows of </st><span class="No-Break"><st c="5188">the DataFrame:</st></span><pre class="source-code"><st c="5202">
data["month"] = data["date"].dt.month
data[["date", "month"]].head()</st></pre><p class="list-inset"><st c="5271">We </st><a id="_idIndexMarker435"/><st c="5275">see the</st><a id="_idIndexMarker436"/><st c="5282"> new </st><strong class="source-inline"><st c="5287">month</st></strong><st c="5292"> variable</st><a id="_idIndexMarker437"/><st c="5301"> in the </st><span class="No-Break"><st c="5309">followi</st><a id="_idTextAnchor771"/><st c="5316">ng output:</st></span></p></li>			</ol>
			<div>
				<div id="_idContainer097" class="IMG---Figure">
					<img src="image/B22396_06_4.jpg" alt="Figure 6.4 – The first five rows of a DataFrame with the new month vari﻿able"/><st c="5327"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="5411">Figure 6.4 – The first five rows of a DataFrame with the new month vari</st><a id="_idTextAnchor772"/><st c="5482">able</st></p>
			<ol>
				<li value="7"><st c="5487">Let’s extract the week number (a year has 52 weeks) from </st><span class="No-Break"><st c="5545">the date:</st></span><pre class="source-code"><st c="5554">
data["week"] = data["date"].dt.isocalendar().week
data[["date", "week"]]</st><a id="_idTextAnchor773"/><st c="5627">.head()</st></pre><p class="list-inset"><st c="5634">We see the </st><strong class="source-inline"><st c="5646">week</st></strong><st c="5650"> variable in the </st><span class="No-Break"><st c="5667">followin</st><a id="_idTextAnchor774"/><st c="5675">g output:</st></span></p></li>			</ol>
			<div>
				<div id="_idContainer098" class="IMG---Figure">
					<img src="image/B22396_06_5.jpg" alt="Figure 6.5 – The first five rows of a DataFrame with the new week variable"/><st c="5685"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="5773">Figure 6.5 – The first five rows of a DataFrame with the new week variable</st></p>
			<ol>
				<li value="8"><st c="5847">Let’s extract the day of the month, which can take values between </st><strong class="source-inline"><st c="5914">1</st></strong><st c="5915"> and </st><strong class="source-inline"><st c="5920">31</st></strong><st c="5922">, into a </st><span class="No-Break"><st c="5931">new column:</st></span><pre class="source-code"><st c="5942">
data["day_mo"] = data["date"].dt.day
data[["date", "day_mo"]].head()</st></pre><p class="list-inset"><st c="6011">We </st><a id="_idIndexMarker438"/><st c="6015">see the </st><strong class="source-inline"><st c="6023">day_mo</st></strong><st c="6029"> variable</st><a id="_idIndexMarker439"/><st c="6038"> in the </st><a id="_idIndexMarker440"/><span class="No-Break"><st c="6046">follow</st><a id="_idTextAnchor775"/><st c="6052">ing output:</st></span></p></li>			</ol>
			<div>
				<div id="_idContainer099" class="IMG---Figure">
					<img src="image/B22396_06_6.jpg" alt="Figure 6.6 – The top rows of a DataFrame with the new variable capturing the day of the ﻿month"/><st c="6064"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="6154">Figure 6.6 – The top rows of a DataFrame with the new variable capturing the day of the </st><a id="_idTextAnchor776"/><st c="6242">month</st></p>
			<ol>
				<li value="9"><st c="6247">Let’s extract the day of the</st><a id="_idTextAnchor777"/><st c="6276"> week, with values between </st><strong class="source-inline"><st c="6303">0</st></strong><st c="6304"> and </st><strong class="source-inline"><st c="6309">6</st></strong><st c="6310"> (from Monday to Sunday), in a new column, then display the </st><span class="No-Break"><st c="6370">top rows:</st></span><pre class="source-code"><st c="6379">
data["day_week"] = data["date"].dt.dayofweek
data[["date", "day_mo", "day_week"]].head()</st></pre><p class="list-inset"><st c="6468">We see the </st><strong class="source-inline"><st c="6480">day_week</st></strong><st c="6488"> variable in the </st><span class="No-Break"><st c="6505">followi</st><a id="_idTextAnchor778"/><st c="6512">ng output:</st></span></p></li>			</ol>
			<div>
				<div id="_idContainer100" class="IMG---Figure">
					<img src="image/B22396_06_7.jpg" alt="Figure 6.7 – The top rows of a DataFrame with a new variable representing days of a week"/><st c="6523"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="6633">Figure 6.7 – The top rows of a DataFrame with a new variable representing days of a week</st></p>
			<ol>
				<li value="10"><st c="6721">With the variable from </st><em class="italic"><st c="6745">Step 9</st></em><st c="6751">, we can create a binary variable that indicates whether it was </st><span class="No-Break"><st c="6815">a weekend:</st></span><pre class="source-code"><st c="6825">
data["is_weekend"] = (
    data[«date»].dt.dayofweek &gt; 4).astype(int)
data[["date", "day_week", "is_weekend"]].head()</st></pre><p class="list-inset"><st c="6939">We </st><a id="_idIndexMarker441"/><st c="6943">see</st><a id="_idIndexMarker442"/><st c="6946"> the new </st><strong class="source-inline"><st c="6955">is_weekend</st></strong><st c="6965"> variable </st><a id="_idIndexMarker443"/><st c="6975">in the </st><span class="No-Break"><st c="6982">follo</st><a id="_idTextAnchor779"/><st c="6987">wing output:</st></span></p></li>			</ol>
			<div>
				<div id="_idContainer101" class="IMG---Figure">
					<img src="image/B22396_06_8.jpg" alt="Figure 6.8 – The first five rows of a DataFrame with the new is_weekend variable"/><st c="7000"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="7101">Figure 6.8 – The first five rows of a DataFrame with the new is_weekend variable</st></p>
			<p class="callout-heading"><st c="7181">Note</st></p>
			<p class="callout"><st c="7186">We can automate the extraction of all these features by using </st><strong class="source-inline"><st c="7249">feature-engine</st></strong><st c="7263">. Check out the </st><em class="italic"><st c="7279">Automating datetime feature extraction with feature-engine</st></em><st c="7337"> recipe in this chapter for </st><span class="No-Break"><st c="7365">more details.</st></span></p>
			<p><st c="7378">With t</st><a id="_idTextAnchor780"/><st c="7385">hat, we have extracted many </st><a id="_idTextAnchor781"/><st c="7414">new features from the date part of a </st><strong class="source-inline"><st c="7451">datetime</st></strong><st c="7459"> variable using </st><strong class="source-inline"><st c="7475">pandas</st></strong><st c="7481">. These features are useful for data analysis, visualization, and </st><span class="No-Break"><st c="7547">predictiv</st><a id="_idTextAnchor782"/><a id="_idTextAnchor783"/><st c="7556">e modelling.</st></span></p>
			<h2 id="_idParaDest-174"><a id="_idTextAnchor784"/><st c="7569">How it works...</st></h2>
			<p><st c="7585">In this recipe, we</st><a id="_idIndexMarker444"/><st c="7604"> extracted many date-related features from a </st><strong class="source-inline"><st c="7649">datetime</st></strong><st c="7657"> variable</st><a id="_idIndexMarker445"/><st c="7666"> by using the </st><strong class="source-inline"><st c="7680">dt</st></strong><st c="7682"> module from </st><strong class="source-inline"><st c="7695">pandas</st></strong><st c="7701">. First, we </st><a id="_idIndexMarker446"/><st c="7713">created a sample DataFrame with a variable that contained dates. </st><st c="7778">We used </st><strong class="source-inline"><st c="7786">pandas</st></strong><st c="7792">’ </st><strong class="source-inline"><st c="7795">date_range()</st></strong><st c="7807"> to create a range of values starting from an arbitrary date and increasing the time by intervals of </st><strong class="source-inline"><st c="7908">1</st></strong><st c="7909"> day. </st><st c="7915">With the </st><strong class="source-inline"><st c="7924">periods</st></strong><st c="7931"> argument, we indicated the number of values to create in the range – that is, the number of dates. </st><st c="8031">With the </st><strong class="source-inline"><st c="8040">freq</st></strong><st c="8044"> argument, we indicated the size of the steps between the dates. </st><st c="8109">We used </st><strong class="source-inline"><st c="8117">D</st></strong><st c="8118"> for days in our example. </st><st c="8144">Finally, we transformed the date range into a DataFrame with </st><span class="No-Break"><strong class="source-inline"><st c="8205">pandas</st></strong></span><span class="No-Break"> </span><span class="No-Break"><strong class="source-inline"><st c="8211">DataFrame()</st></strong></span><span class="No-Break"><st c="8223">.</st></span></p>
			<p><st c="8224">To extract the different parts of a date, we used </st><strong class="source-inline"><st c="8275">pandas</st></strong><st c="8281">’ </st><strong class="source-inline"><st c="8284">dt</st></strong><st c="8286"> to access the </st><strong class="source-inline"><st c="8301">datetime</st></strong><st c="8309"> properties of a </st><strong class="source-inline"><st c="8326">pandas</st></strong><st c="8332"> Series and then utilized the different properties. </st><st c="8384">We used </st><strong class="source-inline"><st c="8392">year</st></strong><st c="8396">, </st><strong class="source-inline"><st c="8398">month</st></strong><st c="8403">, and </st><strong class="source-inline"><st c="8409">quarter</st></strong><st c="8416"> to capture the year, month, and quarter into new columns of the DataFrame. </st><st c="8492">To find the semester, we created a Boolean using NumPy’s </st><strong class="source-inline"><st c="8549">where()</st></strong><st c="8556"> in combination with the newly created </st><strong class="source-inline"><st c="8595">quarter</st></strong><st c="8602"> variable. </st><st c="8613">NumPy’s </st><strong class="source-inline"><st c="8621">where()</st></strong><st c="8628"> scanned the values of the </st><strong class="source-inline"><st c="8655">quarter</st></strong><st c="8662"> variable; if they were smaller than </st><strong class="source-inline"><st c="8699">3</st></strong><st c="8700">, it returned the value of  </st><strong class="source-inline"><st c="8727">1</st></strong><st c="8728"> for the first semester; otherwise, it returned the value of </st><strong class="source-inline"><st c="8789">2</st></strong><st c="8790">, corresponding to the </st><span class="No-Break"><st c="8813">second semes</st><a id="_idTextAnchor785"/><st c="8825">ter.</st></span></p>
			<p><st c="8830">To extract</st><a id="_idIndexMarker447"/><st c="8841"> the different</st><a id="_idTextAnchor786"/><st c="8855"> representations of days and weeks, we</st><a id="_idIndexMarker448"/><st c="8893"> used the </st><strong class="source-inline"><st c="8903">isocalender().week</st></strong><st c="8921">, </st><strong class="source-inline"><st c="8923">day</st></strong><st c="8926">, and </st><strong class="source-inline"><st c="8932">dayofweek</st></strong><st c="8941"> properties. </st><st c="8954">With the day of the week, we went ahead </st><a id="_idIndexMarker449"/><st c="8994">and created a binary variable to indicate whether it was a weekend. </st><st c="9062">We used </st><strong class="source-inline"><st c="9070">where()</st></strong><st c="9077"> to scan the day of the week, and if the value was greater than </st><strong class="source-inline"><st c="9141">4</st></strong><st c="9142">, which corresponds to Saturday and Sunday, the function returned </st><strong class="source-inline"><st c="9208">True</st></strong><st c="9212"> and otherwise </st><strong class="source-inline"><st c="9227">False</st></strong><st c="9232">. Finally, we cast this Boolean vector as an integer to have a binary variable with 1s and 0s. </st><st c="9327">With that, we created multiple features from dates that we can use for data analysis and </st><span class="No-Break"><st c="9416">pre</st><a id="_idTextAnchor787"/><a id="_idTextAnchor788"/><st c="9419">dictive modelling.</st></span></p>
			<h2 id="_idParaDest-175"><a id="_idTextAnchor789"/><st c="9438">There’s more…</st></h2>
			<p><st c="9452">Using </st><strong class="source-inline"><st c="9459">pandas</st></strong><st c="9465">’ </st><strong class="source-inline"><st c="9468">dt</st></strong><st c="9470"> module, we can</st><a id="_idIndexMarker450"/><st c="9485"> extract many more features from dates out of the</st><a id="_idIndexMarker451"/><st c="9534"> box. </st><st c="9540">For example, we can extract the beginning and end of a month, quarter, or year, whether it is a leap year, and the number of days in a month. </st><st c="9682">These are the functions that allow you to </st><span class="No-Break"><st c="9724">do so:</st></span></p>
			<ul>
				<li><span class="No-Break"><strong class="source-inline"><st c="9730">pandas.Series.dt.is_month_start</st></strong></span></li>
				<li><span class="No-Break"><strong class="source-inline"><st c="9762">pandas.Series.dt.is_month_end</st></strong></span></li>
				<li><span class="No-Break"><strong class="source-inline"><st c="9792">pandas.Series.dt.is_quarter_start</st></strong></span></li>
				<li><span class="No-Break"><strong class="source-inline"><st c="9826">pandas.Series.dt.is_quarter_end</st></strong></span></li>
				<li><span class="No-Break"><strong class="source-inline"><st c="9858">pandas.Series.dt.is_year_start</st></strong></span></li>
				<li><span class="No-Break"><strong class="source-inline"><st c="9889">pandas.Series.dt.is_year_end</st></strong></span></li>
				<li><span class="No-Break"><strong class="source-inline"><st c="9918">pandas.Series.dt.is_leap_year</st></strong></span></li>
				<li><span class="No-Break"><strong class="source-inline"><st c="9948">pandas.Series.dt.days_in_month</st></strong></span></li>
			</ul>
			<p><st c="9979">We can also return the number of days in a specific month with </st><strong class="source-inline"><st c="10043">pd.dt.days_in_month</st></strong><st c="10062"> and the day in a year (from </st><strong class="source-inline"><st c="10091">1</st></strong><st c="10092"> to </st><strong class="source-inline"><st c="10096">365</st></strong><st c="10099">) </st><span class="No-Break"><st c="10102">with </st></span><span class="No-Break"><strong class="source-inline"><st c="10107">pd.dt</st><a id="_idTextAnchor790"/><st c="10112">.dayofyear</st></strong></span><span class="No-Break"><st c="10122">.</st></span></p>
			<p><st c="10123">For </st><a id="_idIndexMarker452"/><st c="10128">more details, visit the </st><strong class="source-inline"><st c="10152">pandas</st></strong><st c="10158">’ </st><strong class="source-inline"><st c="10161">datetime</st></strong> <span class="No-Break"><st c="10169">documentation: </st></span><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#time-date-components"><span class="No-Break"><st c="10185">https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#time-date-components</st></span></a><span class="No-Break"><st c="10277">.</st></span></p>
			<h2 id="_idParaDest-176"><a id="_idTextAnchor791"/><st c="10278">See also</st></h2>
			<p><st c="10287">To learn how to create</st><a id="_idIndexMarker453"/><st c="10310"> different </st><strong class="source-inline"><st c="10321">datetime</st></strong><st c="10329"> ranges with </st><strong class="source-inline"><st c="10342">pandas</st></strong><st c="10348">’ </st><strong class="source-inline"><st c="10351">date_ranges()</st></strong><st c="10364">, </st><span class="No-Break"><st c="10366">visit </st></span><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases"><span class="No-Break"><st c="10372">https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases</st></span></a><span class="No-Break"><st c="10458">.</st></span></p>
			<p><st c="10459">To learn more</st><a id="_idIndexMarker454"/><st c="10473"> about </st><strong class="source-inline"><st c="10480">pandas</st></strong><st c="10486">’ </st><strong class="source-inline"><st c="10489">dt</st></strong><st c="10491">, </st><span class="No-Break"><st c="10493">visit </st></span><a href="https://pandas.pydata.org/pandas-docs/stable/reference/series.html#datetime-properties"><span class="No-Break"><st c="10499">https://pandas.pydata.org/pandas-docs/stable/reference/series.html#datetime-properties</st></span></a><span class="No-Break"><st c="10585">.</st></span></p>
			<h1 id="_idParaDest-177"><st c="10586">Extracting features from time </st><a id="_idTextAnchor792"/><st c="10617">with pandas</st></h1>
			<p><st c="10628">Some </st><a id="_idIndexMarker455"/><st c="10634">events occ</st><a id="_idTextAnchor793"/><st c="10644">ur more often at certain times of the day – for</st><a id="_idIndexMarker456"/><st c="10692"> example, fraudulent activity is more likely to occur</st><a id="_idIndexMarker457"/><st c="10745"> during the night or early morning. </st><st c="10781">Air pollutant concentration also changes with the time of the day, with peaks at rush hour when there are more vehicles on the streets. </st><st c="10917">Therefore, deriving time features is extremely useful for data analysis and predictive modelling. </st><st c="11015">In this recipe, we will extract different time parts of a </st><strong class="source-inline"><st c="11073">datetime</st></strong><st c="11081"> variable by u</st><a id="_idTextAnchor794"/><a id="_idTextAnchor795"/><st c="11095">tilizing </st><strong class="source-inline"><st c="11105">pandas</st></strong> <span class="No-Break"><st c="11111">and NumPy.</st></span></p>
			<h2 id="_idParaDest-178"><a id="_idTextAnchor796"/><st c="11122">Getting ready</st></h2>
			<p><st c="11136">We can extract hours, minutes, and seconds using the following </st><strong class="source-inline"><st c="11200">pandas</st></strong><st c="11206">’ </st><span class="No-Break"><strong class="source-inline"><st c="11209">datetime</st></strong></span><span class="No-Break"><st c="11217"> properties:</st></span></p>
			<ul>
				<li><span class="No-Break"><strong class="source-inline"><st c="11229">pandas.Series.dt.hour</st></strong></span></li>
				<li><span class="No-Break"><strong class="source-inline"><st c="11251">pandas.Series.dt.minu</st><a id="_idTextAnchor797"/><a id="_idTextAnchor798"/><st c="11273">te</st></strong></span></li>
				<li><span class="No-Break"><strong class="source-inline"><st c="11276">pandas.Series.dt.second</st></strong></span></li>
			</ul>
			<h2 id="_idParaDest-179"><a id="_idTextAnchor799"/><st c="11300">How to do it...</st></h2>
			<p><st c="11316">In this </st><a id="_idIndexMarker458"/><st c="11325">recipe, we’ll </st><a id="_idIndexMarker459"/><st c="11339">extract the </st><strong class="source-inline"><st c="11351">hour</st></strong><st c="11355">, </st><strong class="source-inline"><st c="11357">minute</st></strong><st c="11363">, and </st><strong class="source-inline"><st c="11369">second</st></strong><st c="11375"> part of a </st><strong class="source-inline"><st c="11386">time</st></strong><st c="11390"> variable. </st><st c="11401">Let’s begin by importing the</st><a id="_idIndexMarker460"/><st c="11429"> libraries and creating a </st><span class="No-Break"><st c="11455">sample dataset:</st></span></p>
			<ol>
				<li><st c="11470">Let’s import </st><strong class="source-inline"><st c="11484">pandas</st></strong> <span class="No-Break"><st c="11490">and </st></span><span class="No-Break"><strong class="source-inline"><st c="11495">numpy</st></strong></span><span class="No-Break"><st c="11500">:</st></span><pre class="source-code"><st c="11502">
import numpy as np
import pandas as pd</st></pre></li>				<li><st c="11541">Let’s begin by creating 20 </st><strong class="source-inline"><st c="11569">datetime</st></strong><st c="11577"> observations, start</st><a id="_idTextAnchor800"/><st c="11597">ing on </st><strong class="source-inline"><st c="11605">2024-05-17</st></strong><st c="11615"> at midnight and followed by increments of 1 hour, 15 minutes, and 10 seconds. </st><st c="11694">Next,</st><a id="_idTextAnchor801"/><st c="11699"> we’ll capture the time range in a DataFrame and display the top </st><span class="No-Break"><st c="11764">five rows:</st></span><pre class="source-code"><st c="11774">
rng_ = pd.date_range(
    "2024-05-17", periods=20, freq="1h15min10s")
df = pd.DataFrame({"date": rng_})
df.head()</st></pre><p class="list-inset"><st c="11885">In the following output, we see the variable from </st><em class="italic"><st c="11936">Step 2</st></em><st c="11942">, with a </st><strong class="source-inline"><st c="11951">date</st></strong><st c="11955"> part and a </st><strong class="source-inline"><st c="11967">time</st></strong><st c="11971"> part, and the values increasing by intervals of 1 hour,</st><a id="_idTextAnchor802"/><st c="12027"> 15 minutes, and </st><span class="No-Break"><st c="12044">10 seconds:</st></span></p></li>			</ol>
			<div>
				<div id="_idContainer102" class="IMG---Figure">
					<img src="image/B22396_06_9.jpg" alt="Figure 6.9 – The first five rows of a sample DataFrame with a datetime variable"/><st c="12055"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="12169">Figure 6.9 – The first five rows of a sample DataFrame with a datetime variable</st></p>
			<ol>
				<li value="3"><st c="12248">Let’s </st><a id="_idIndexMarker461"/><st c="12255">extract the </st><strong class="source-inline"><st c="12267">hour</st></strong><st c="12271">, </st><strong class="source-inline"><st c="12273">minute</st></strong><st c="12279">, and </st><strong class="source-inline"><st c="12285">second</st></strong><st c="12291"> part</st><a id="_idIndexMarker462"/><st c="12296"> and capture them into three new columns, then </st><a id="_idIndexMarker463"/><st c="12343">display the DataFrame’s top </st><span class="No-Break"><st c="12371">five rows:</st></span><pre class="source-code"><st c="12381">
df["hour"] = df["date"].dt.hour
df["min"] = df["date"].dt.minute
df["sec"] = df["date"].dt.second
df.head()</st></pre><p class="list-inset"><st c="12489">In the following output, we see the three </st><strong class="source-inline"><st c="12532">time</st></strong><st c="12536"> feature</st><a id="_idTextAnchor803"/><st c="12544">s that we extracted in </st><span class="No-Break"><em class="italic"><st c="12568">Step 3</st></em></span><span class="No-Break"><st c="12574">:</st></span></p></li>			</ol>
			<div>
				<div id="_idContainer103" class="IMG---Figure">
					<img src="image/B22396_06_10.jpg" alt="Figure 6.10 – The first five rows of a DataFrame with three variables derived from time"/><st c="12576"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="12738">Figure 6.10 – The first five rows of a DataFrame with three variables derived from time</st></p>
			<p class="callout-heading"><st c="12825">Note</st></p>
			<p class="callout"><st c="12830">Remember that </st><strong class="source-inline"><st c="12845">pandas</st></strong><st c="12851">’ </st><strong class="source-inline"><st c="12854">dt</st></strong><st c="12856"> needs a </st><strong class="source-inline"><st c="12865">datetime</st></strong><st c="12873"> object to work. </st><st c="12890">You can change the data type of an object variable into </st><strong class="source-inline"><st c="12946">datetime</st></strong><st c="12954"> by using </st><span class="No-Break"><strong class="source-inline"><st c="12964">pandas</st></strong></span><span class="No-Break"> </span><span class="No-Break"><strong class="source-inline"><st c="12970">to_datetime()</st></strong></span><span class="No-Break"><st c="12984">.</st></span></p>
			<ol>
				<li value="4"><st c="12985">Let’s perform the same operations that we did in </st><em class="italic"><st c="13035">Step 3</st></em><st c="13041"> but now in one line </st><span class="No-Break"><st c="13062">of code:</st></span><pre class="source-code"><st c="13070">
df[["h", "m", "s"]] = pd.DataFrame(
    [(x.hour, x.minute, x.second) for x in df["date"]]
)
df.head()</st></pre><p class="list-inset"><st c="13169">We see the newly created varia</st><a id="_idTextAnchor804"/><st c="13200">bles in the </st><span class="No-Break"><st c="13213">following output:</st></span></p></li>			</ol>
			<div>
				<div id="_idContainer104" class="IMG---Figure">
					<img src="image/B22396_06_11.jpg" alt="Figure 6.11 – The first five rows of a DataFrame with the variables derived from time"/><st c="13230"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="13440">Figure 6.11 – The first five rows of a DataFrame with the variables derived from time</st></p>
			<p class="callout-heading"><st c="13525">No</st><a id="_idTextAnchor805"/><st c="13528">te</st></p>
			<p class="callout"><st c="13531">You can inspect the unique values of the new variables with </st><strong class="source-inline"><st c="13592">pandas</st></strong><st c="13598">’ </st><strong class="source-inline"><st c="13601">unique()</st></strong><st c="13609">, for example, by </st><span class="No-Break"><st c="13627">executing </st></span><span class="No-Break"><strong class="source-inline"><st c="13637">df['hour'].unique()</st></strong></span><span class="No-Break"><st c="13656">.</st></span></p>
			<ol>
				<li value="5"><st c="13657">Finally, let’s</st><a id="_idIndexMarker464"/><st c="13672"> create a binary variable that </st><a id="_idIndexMarker465"/><st c="13703">flags events that occurred in the morning, between</st><a id="_idIndexMarker466"/><st c="13753"> 6 A.M. </st><st c="13761">and </st><span class="No-Break"><st c="13765">12 P.M.:</st></span><pre class="source-code"><st c="13773">
df["is_morning"] = np.where(
    (df[«hour»] &lt; 12) &amp; (df[«hour»] &gt; 6), 1, 0 )
df.head()</st></pre><p class="list-inset"><st c="13857">We see the </st><strong class="source-inline"><st c="13869">is_morning</st></strong><st c="13879"> va</st><a id="_idTextAnchor806"/><st c="13882">riable in the </st><span class="No-Break"><st c="13897">following output:</st></span></p></li>			</ol>
			<div>
				<div id="_idContainer105" class="IMG---Figure">
					<img src="image/B22396_06_12.jpg" alt="Figure 6.12 – The top rows of a DataFrame with the new variables derived from time"/><st c="13914"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="14145">Figure 6.12 – The top rows of a DataFrame with the new variables derived from time</st></p>
			<p><st c="14227">With that, we extracted multiple features from the time part of a </st><strong class="source-inline"><st c="14294">datetime</st></strong><st c="14302"> variable. </st><st c="14313">These features can be used for data ana</st><a id="_idTextAnchor807"/><a id="_idTextAnchor808"/><st c="14352">lysis and </st><span class="No-Break"><st c="14363">predictive modelling.</st></span></p>
			<h2 id="_idParaDest-180"><a id="_idTextAnchor809"/><st c="14384">How it works...</st></h2>
			<p><st c="14400">In this recipe, we created features that capture representations of time. </st><st c="14475">First, we created a sample DataFrame with a </st><strong class="source-inline"><st c="14519">datetime</st></strong><st c="14527"> variable. </st><st c="14538">We used </st><strong class="source-inline"><st c="14546">pandas</st></strong> <strong class="source-inline"><st c="14552">date_range()</st></strong><st c="14565">to create a range of 20 values </st><a id="_idTextAnchor810"/><st c="14597">starting from an a</st><a id="_idTextAnchor811"/><st c="14615">rbitrary date and increasing by intervals of 1 hour, 15 minutes, and 10 seconds. </st><st c="14697">We used the </st><strong class="source-inline"><st c="14709">1h15min10s</st></strong><st c="14719"> string as the frequency term for the </st><strong class="source-inline"><st c="14757">freq</st></strong><st c="14761"> argument to indicate the desired increments. </st><st c="14807">Next, we transformed the date range into a DataFrame with </st><span class="No-Break"><strong class="source-inline"><st c="14865">pandas</st></strong></span><span class="No-Break"><st c="14871">’ </st></span><span class="No-Break"><strong class="source-inline"><st c="14874">DataFrame()</st></strong></span><span class="No-Break"><st c="14885">.</st></span></p>
			<p><st c="14886">To extract the </st><a id="_idIndexMarker467"/><st c="14902">different time parts, we used </st><strong class="source-inline"><st c="14932">pandas</st></strong><st c="14938">’ </st><strong class="source-inline"><st c="14941">dt</st></strong><st c="14943"> to </st><a id="_idIndexMarker468"/><st c="14947">access the </st><strong class="source-inline"><st c="14958">hour</st></strong><st c="14962">, </st><strong class="source-inline"><st c="14964">minute</st></strong><st c="14970">, and </st><strong class="source-inline"><st c="14976">second</st></strong> <strong class="source-inline"><st c="14982">time</st></strong><st c="14987"> properties. </st><st c="15000">After </st><a id="_idIndexMarker469"/><st c="15006">extracting </st><strong class="source-inline"><st c="15017">hour</st></strong><st c="15021"> from </st><strong class="source-inline"><st c="15027">time</st></strong><st c="15031">, we used it to create a new feature that indicated whether it was morning by using NumPy’s </st><strong class="source-inline"><st c="15123">where()</st></strong><st c="15130">. NumPy’s </st><strong class="source-inline"><st c="15140">where()</st></strong><st c="15147"> scanned the </st><strong class="source-inline"><st c="15160">hour</st></strong><st c="15164"> variable; if its values were smaller than 12 and greater than 6, it assigned a value of </st><strong class="source-inline"><st c="15253">1</st></strong><st c="15254">; otherwise, it assigned a value of </st><strong class="source-inline"><st c="15290">0</st></strong><st c="15291">. With these operations, we added several features to the DataFrame that can be used for data analysis and</st><a id="_idTextAnchor812"/><a id="_idTextAnchor813"/><st c="15397"> to train machine </st><span class="No-Break"><st c="15415">learning models.</st></span></p>
			<h2 id="_idParaDest-181"><a id="_idTextAnchor814"/><st c="15431">There’s more…</st></h2>
			<p><st c="15445">We can also extract microseconds and nanoseconds with the following </st><span class="No-Break"><strong class="source-inline"><st c="15514">pandas</st></strong></span><span class="No-Break"><st c="15520"> properties:</st></span></p>
			<ul>
				<li><span class="No-Break"><strong class="source-inline"><st c="15532">pandas.Series.dt.microsecond</st></strong></span></li>
				<li><span class="No-Break"><strong class="source-inline"><st c="15561">pandas.Series.dt.nanosecond</st></strong></span></li>
			</ul>
			<p><st c="15589">For more </st><a id="_idIndexMarker470"/><st c="15599">details, </st><span class="No-Break"><st c="15608">visit </st></span><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#time-date-components"><span class="No-Break"><st c="15614">https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#time-date-components</st></span></a><span class="No-Break"><st c="15706">.</st></span></p>
			<h1 id="_idParaDest-182"><a id="_idTextAnchor815"/><st c="15707">Capturing the elapsed time between datetime variables</st></h1>
			<p><st c="15761">We can extract </st><a id="_idIndexMarker471"/><st c="15777">powerful features from </st><a id="_idIndexMarker472"/><st c="15800">each </st><strong class="source-inline"><st c="15805">datetime</st></strong><st c="15813"> variable individually, as we did in the previous two recipes. </st><st c="15876">We can create additional features by combining multiple </st><strong class="source-inline"><st c="15932">datetime</st></strong><st c="15940"> variables. </st><st c="15952">A common example consists of extracting the </st><strong class="bold"><st c="15996">age</st></strong><st c="15999"> at the time of an event by comparing the </st><strong class="bold"><st c="16041">date of birth</st></strong><st c="16054"> with the </st><strong class="bold"><st c="16064">date of </st></strong><span class="No-Break"><strong class="bold"><st c="16072">the event</st></strong></span><span class="No-Break"><st c="16081">.</st></span></p>
			<p><st c="16082">In this recipe, we will learn how to capture the time between two </st><strong class="source-inline"><st c="16149">datetime</st></strong><st c="16157"> variables by</st><a id="_idTextAnchor816"/><a id="_idTextAnchor817"/><st c="16170"> utilizing </st><strong class="source-inline"><st c="16181">pandas</st></strong> <span class="No-Break"><st c="16187">and </st></span><span class="No-Break"><strong class="source-inline"><st c="16192">feature-engine</st></strong></span><span class="No-Break"><st c="16206">.</st></span></p>
			<h2 id="_idParaDest-183"><a id="_idTextAnchor818"/><st c="16207">How to do it...</st></h2>
			<p><st c="16223">To proceed with this recipe, we’ll create a DataFrame containing two </st><span class="No-Break"><strong class="source-inline"><st c="16293">datatime</st></strong></span><span class="No-Break"><st c="16301"> variables:</st></span></p>
			<ol>
				<li><st c="16312">Let’s begin by importing </st><strong class="source-inline"><st c="16338">pandas</st></strong><st c="16344">, </st><strong class="source-inline"><st c="16346">numpy</st></strong><st c="16351">, </st><span class="No-Break"><st c="16353">and </st></span><span class="No-Break"><strong class="source-inline"><st c="16357">datetime</st></strong></span><span class="No-Break"><st c="16365">:</st></span><pre class="source-code"><st c="16367">
import datetime
import numpy as np
import pandas as pd</st></pre></li>				<li><st c="16422">We’ll start by creating two </st><strong class="source-inline"><st c="16451">datetime</st></strong><st c="16459"> variables with 20 values each; the values start from </st><strong class="source-inline"><st c="16513">2024-05-17</st></strong><st c="16523"> and increase in intervals of </st><strong class="source-inline"><st c="16553">1</st></strong><st c="16554"> hour for the first variable, and </st><strong class="source-inline"><st c="16588">1</st></strong><st c="16589"> month for the second. </st><st c="16612">Then, we‘ll capture the variables in a DataFrame, add column names, and display the </st><span class="No-Break"><st c="16696">top rows:</st></span><pre class="source-code"><st c="16705">
date = "2024-05-17"
rng_hr = pd.date_range(date, periods=20, freq="h")
rng_month = pd.date_range(date, periods=20, freq="ME")
df = pd.DataFrame(
    {"date1": rng_hr, "date2": rng_month})
df.head()</st></pre><p class="list-inset"><st c="16899">We see the</st><a id="_idIndexMarker473"/><st c="16910"> first five rows of the </st><a id="_idIndexMarker474"/><st c="16934">DataFram</st><a id="_idTextAnchor819"/><st c="16942">e from </st><em class="italic"><st c="16950">Step 2</st></em><st c="16956"> in the </st><span class="No-Break"><st c="16964">following output:</st></span></p></li>			</ol>
			<div>
				<div id="_idContainer106" class="IMG---Figure">
					<img src="image/B22396_06_13.jpg" alt="Figure 6.13 – The first five rows of a DataFrame wit﻿h two datetime variables"/><st c="16981"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="17157">Figure 6.13 – The first five rows of a DataFrame wit</st><a id="_idTextAnchor820"/><st c="17209">h two datetime variables</st></p>
			<ol>
				<li value="3"><st c="17234">Let’s capture the difference in days between the two variables in a new feature, and then display the DataFrame’s </st><span class="No-Break"><st c="17349">top rows:</st></span><pre class="source-code"><st c="17358">
df["elapsed_days"] = (
    df["date2"] - df["date1"]).dt.days
df.head()</st></pre><p class="list-inset"><st c="17426">We see the differ</st><a id="_idTextAnchor821"/><st c="17444">ence in days in the </st><span class="No-Break"><st c="17465">following output:</st></span></p></li>			</ol>
			<div>
				<div id="_idContainer107" class="IMG---Figure">
					<img src="image/B22396_06_14.jpg" alt="Figure 6.14 – Top rows of a DataFrame with a new variable capturing the time difference between the two datetime features"/><st c="17482"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="17687">Figure 6.14 – Top rows of a DataFrame with a new variable capturing the time difference between the two datetime features</st></p>
			<ol>
				<li value="4"><st c="17808">Let’s capture</st><a id="_idIndexMarker475"/><st c="17822"> the difference in </st><a id="_idIndexMarker476"/><st c="17841">weeks between the two </st><strong class="source-inline"><st c="17863">datetime</st></strong><st c="17871"> variables and then display the DataFrame’s </st><span class="No-Break"><st c="17915">top rows:</st></span><pre class="source-code"><st c="17924">
df["weeks_passed"] = (
    (df[«date2»] - df[«date1»]) / np.timedelta64(1, "W"))
df.head()</st></pre><p class="list-inset"><st c="18011">We see the difference in weeks between the </st><a id="_idTextAnchor822"/><st c="18055">variables in the </st><span class="No-Break"><st c="18072">following screenshot:</st></span></p></li>			</ol>
			<div>
				<div id="_idContainer108" class="IMG---Figure">
					<img src="image/B22396_06_15.jpg" alt="Figure 6.15 – A DataFrame with the time difference between the datetime variables expressed in number ﻿of days and number of weeks"/><st c="18093"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="18361">Figure 6.15 – A DataFrame with the time difference between the datetime variables expressed in number </st><a id="_idTextAnchor823"/><st c="18463">of days and number of weeks</st></p>
			<ol>
				<li value="5"><st c="18490">Now, let’s calculate the time in between the variables in minutes and seconds and then display the DataFrame’s </st><span class="No-Break"><st c="18602">top rows:</st></span><pre class="source-code"><st c="18611">
df["diff_seconds"] = (
    df[«date2»] - df[«date1»])/np.timedelta64(1, «s»)
df["diff_minutes"] = (
    df[«date2»] - df[«date1»])/ np.timedelta64(1,»m»)
df.head()</st></pre><p class="list-inset"><st c="18767">We see the </st><a id="_idIndexMarker477"/><a id="_idTextAnchor824"/><st c="18779">new variables in the </st><a id="_idIndexMarker478"/><span class="No-Break"><st c="18800">following output:</st></span></p></li>			</ol>
			<div>
				<div id="_idContainer109" class="IMG---Figure">
					<img src="image/B22396_06_16.jpg" alt="Figure 6.16 – A DataFrame with the time difference between the two datetime variables expressed in different time units"/><st c="18817"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="19205">Figure 6.16 – A DataFrame with the time difference between the two datetime variables expressed in different time units</st></p>
			<ol>
				<li value="6"><st c="19324">Finally, let’s calculate the difference between one variable and the current day, expressed in number of days, and then display the first five rows of </st><span class="No-Break"><st c="19476">the DataFrame:</st></span><pre class="source-code"><st c="19490">
df["to_today"] = (
    datetime.datetime.today() - df["date1"])
df.head()</st></pre><p class="list-inset"><st c="19560">We can find the new variable in the final column of </st><a id="_idTextAnchor825"/><st c="19613">the DataFrame in the </st><span class="No-Break"><st c="19634">following output:</st></span></p></li>			</ol>
			<div>
				<div id="_idContainer110" class="IMG---Figure">
					<img src="image/B22396_06_17.jpg" alt="Figure 6.17 – A DataFrame with the new variable containing the difference between date1 and the day this code was executed"/><st c="19651"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="20059">Figure 6.17 – A DataFrame with the new variable containing the difference between date1 and the day this code was executed</st></p>
			<p class="callout-heading"><st c="20181">Note</st></p>
			<p class="callout"><st c="20186">The </st><strong class="source-inline"><st c="20191">to_today</st></strong><st c="20199"> variable on your computer will be different from the one in this book, due to the difference between the current date (at the time of writing) and when </st><a id="_idTextAnchor826"/><st c="20352">you execute </st><span class="No-Break"><st c="20364">the code.</st></span></p>
			<p><st c="20373">That’s it! </st><st c="20385">We’ve now enriched our dataset with new features that were create</st><a id="_idTextAnchor827"/><a id="_idTextAnchor828"/><st c="20450">d by comparing two </st><span class="No-Break"><strong class="source-inline"><st c="20470">datetime</st></strong></span><span class="No-Break"><st c="20478"> variables.</st></span></p>
			<h2 id="_idParaDest-184"><a id="_idTextAnchor829"/><st c="20489">How it works...</st></h2>
			<p><st c="20505">In this recipe, we </st><a id="_idIndexMarker479"/><st c="20525">captured different representations</st><a id="_idIndexMarker480"/><st c="20559"> of the time between two </st><strong class="source-inline"><st c="20584">datetime</st></strong><st c="20592"> variables. </st><st c="20604">To proceed with this recipe, we created a sample DataFrame with two variables, each with 20 dates starting at an arbitrary date. </st><st c="20733">The first variable increased in intervals of </st><strong class="source-inline"><st c="20778">1</st></strong><st c="20779"> hour, while the second variable increased in intervals of </st><strong class="source-inline"><st c="20838">1</st></strong><st c="20839"> month. </st><st c="20847">We created the variables with </st><strong class="source-inline"><st c="20877">pandas</st></strong><st c="20883">’ </st><strong class="source-inline"><st c="20886">date_range()</st></strong><st c="20898">, which we discussed in the previous two recipes in </st><span class="No-Break"><st c="20950">this chapter.</st></span></p>
			<p><st c="20963">To determine the difference between the variables – that is, to determine the time between them – we directly subtracted one </st><strong class="source-inline"><st c="21089">datetime</st></strong><st c="21097"> variable from the other – that is, one </st><strong class="source-inline"><st c="21137">pandas</st></strong><st c="21143"> Series from the other. </st><st c="21167">The difference between the two </st><strong class="source-inline"><st c="21198">pandas</st></strong><st c="21204"> Series returned a new </st><strong class="source-inline"><st c="21227">pandas</st></strong><st c="21233"> Series. </st><st c="21242">To capture the difference in days, we used </st><strong class="source-inline"><st c="21285">pandas</st></strong><st c="21291">’ </st><strong class="source-inline"><st c="21294">dt</st></strong><st c="21296">, followed by </st><strong class="source-inline"><st c="21310">days</st></strong><st c="21314">. To convert the time difference into months, we used </st><strong class="source-inline"><st c="21368">timedelta()</st></strong><st c="21379"> from NumPy, indicating that we wanted the difference in weeks by passing </st><strong class="source-inline"><st c="21453">W</st></strong><st c="21454"> in the second argument of the method. </st><st c="21493">To capture the difference in seconds and minutes, we passed the </st><strong class="source-inline"><st c="21557">s</st></strong><st c="21558"> and </st><strong class="source-inline"><st c="21563">m</st></strong><st c="21564"> strings to </st><span class="No-Break"><strong class="source-inline"><st c="21576">timedelta()</st></strong></span><span class="No-Break"><st c="21587">, respectively.</st></span></p>
			<p class="callout-heading"><st c="21602">Note</st></p>
			<p class="callout"><st c="21607">The arguments for NumPy’s </st><strong class="source-inline"><st c="21634">timedelta</st></strong><st c="21643"> are a number, </st><strong class="source-inline"><st c="21658">– 1</st></strong><st c="21661">, in our example, to represent the number of units, and a </st><strong class="source-inline"><st c="21719">datetime</st></strong><st c="21727"> unit, such as day (</st><strong class="source-inline"><st c="21747">D</st></strong><st c="21749">), week (</st><strong class="source-inline"><st c="21758">W</st></strong><st c="21760">), hours (</st><strong class="source-inline"><st c="21770">h</st></strong><st c="21772">), minutes (</st><strong class="source-inline"><st c="21784">m</st></strong><st c="21786">), or </st><span class="No-Break"><st c="21792">seconds (</st></span><span class="No-Break"><strong class="source-inline"><st c="21801">s</st></strong></span><span class="No-Break"><st c="21803">).</st></span></p>
			<p><st c="21805">Finally, we </st><a id="_idIndexMarker481"/><st c="21818">captured the difference from</st><a id="_idIndexMarker482"/><st c="21846"> one </st><strong class="source-inline"><st c="21851">date</st><a id="_idTextAnchor830"/><st c="21855">time</st></strong><st c="21860"> variable to today’s date. </st><st c="21887">We obtained the date and time of today (at the time of writing) by using </st><strong class="source-inline"><st c="21960">today()</st></strong><st c="21967"> from the built-in </st><strong class="source-inline"><st c="21986">datetime</st></strong> <span class="No-Break"><st c="21994">Python library.</st></span></p>
			<h2 id="_idParaDest-185"><a id="_idTextAnchor831"/><st c="22010">There's more...</st></h2>
			<p><st c="22026">We can automate the creation of </st><a id="_idIndexMarker483"/><st c="22059">features that capture the time between variables by using the </st><strong class="source-inline"><st c="22121">feature-engine</st></strong><st c="22135">‘s </st><span class="No-Break"><st c="22139">transformer </st></span><span class="No-Break"><strong class="source-inline"><st c="22151">DatetimeSubstraction()</st></strong></span><span class="No-Break"><st c="22173">.</st></span></p>
			<ol>
				<li><st c="22174">Let’s import </st><strong class="source-inline"><st c="22188">pandas</st></strong><st c="22194"> and </st><span class="No-Break"><strong class="source-inline"><st c="22199">feature-engine</st></strong></span><span class="No-Break"><st c="22213">’s transformer:</st></span><pre class="source-code"><st c="22229">
import pandas as pd
from feature_engine.datetime import (
    DatetimeSubtraction
)</st></pre></li>				<li><st c="22309">Let’s re-create the sample dataset that we described in </st><em class="italic"><st c="22366">Step 2</st></em><st c="22372"> of the </st><em class="italic"><st c="22380">How to do </st></em><span class="No-Break"><em class="italic"><st c="22390">it…</st></em></span><span class="No-Break"><st c="22393"> section:</st></span><pre class="source-code"><st c="22402">
date = "2024-05-17"
rng_hr = pd.date_range(date, periods=20, freq="h")
rng_month = pd.date_range(date, periods=20, freq="ME")
df = pd.DataFrame(
    {"date1": rng_hr, "date2": rng_month})</st></pre></li>				<li><st c="22586">Let’s set up </st><strong class="source-inline"><st c="22600">DatetimeSubstraction()</st></strong><st c="22622">to return the time difference between the second date and the first date expressed </st><span class="No-Break"><st c="22706">in days:</st></span><pre class="source-code"><st c="22714">
ds = DatetimeSubtraction(
    variables="date2",
    reference="date1",
    output_unit="D",
)</st></pre></li>			</ol>
			<p class="callout-heading"><st c="22797">Note</st></p>
			<p class="callout"><st c="22802">We can obtain the difference between more than two variables by passing variable lists in the </st><strong class="source-inline"><st c="22897">variables</st></strong><st c="22906"> and </st><span class="No-Break"><strong class="source-inline"><st c="22911">reference</st></strong></span><span class="No-Break"><st c="22920"> parameters.</st></span></p>
			<ol>
				<li value="4"><st c="22932">Let’s create</st><a id="_idIndexMarker484"/><st c="22945"> and then display the </st><span class="No-Break"><st c="22967">new feature:</st></span><pre class="source-code"><st c="22979">
dft = ds.fit_transform(df)
dft.head()</st></pre><p class="list-inset"><st c="23017">In the following output, we see the variable that captures the time difference between the two </st><strong class="source-inline"><st c="23113">datetime</st></strong><st c="23121"> variables </st><span class="No-Break"><st c="23132">in days:</st></span></p></li>			</ol>
			<div>
				<div id="_idContainer111" class="IMG---Figure">
					<img src="image/B22396_06_18.jpg" alt="Figure 6.18 – A DataFrame with the new variable containing the difference between the two datetime variables"/><st c="23140"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="23386">Figure 6.18 – A DataFrame with the new variable containing the difference between the two datetime variables</st></p>
			<p><st c="23494">For more details, check </st><span class="No-Break"><st c="23519">out </st></span><a href="https://feature-engine.trainindata.com/en/latest/api_doc/datetime/DatetimeSubtraction.html"><span class="No-Break"><st c="23523">https://feature-engine.trainindata.com/en/latest/api_doc/datetime/DatetimeSubtraction.html</st></span></a><span class="No-Break"><st c="23613">.</st></span></p>
			<h2 id="_idParaDest-186"><a id="_idTextAnchor832"/><st c="23614">See also</st></h2>
			<p><st c="23623">To learn more </st><a id="_idIndexMarker485"/><st c="23638">about NumPy’s </st><strong class="source-inline"><st c="23652">timedelta</st></strong><st c="23661">, </st><span class="No-Break"><st c="23663">visit </st></span><a href="https://numpy.org/devdocs/reference/arrays.datetime.html#datetime-and-timedelta-arithmetic"><span class="No-Break"><st c="23669">https://numpy.org/devdocs/reference/arrays.datetime.html#datetime-and-timedelta-arithmetic</st></span></a><span class="No-Break"><st c="23759">.</st></span></p>
			<h1 id="_idParaDest-187"><a id="_idTextAnchor833"/><st c="23760">Working with time in different time zones</st></h1>
			<p><st c="23802">Some</st><a id="_idIndexMarker486"/><st c="23807"> organizations operate internationally; therefo</st><a id="_idTextAnchor834"/><st c="23854">re, the information they collect about events may be recorded alongside the time zone of the area where the event took place. </st><st c="23981">To be able to compare events that occurred across different time zones, we typically have to set all of the variables within the same zone. </st><st c="24121">In this recipe, we will learn how to unify the time zones of a </st><strong class="source-inline"><st c="24184">datetime</st></strong><st c="24192"> variable and how to reassign a va</st><a id="_idTextAnchor835"/><a id="_idTextAnchor836"/><st c="24226">riable to a different time </st><a id="_idTextAnchor837"/><st c="24254">zone </st><span class="No-Break"><st c="24259">using </st></span><span class="No-Break"><strong class="source-inline"><st c="24265">pandas</st></strong></span><span class="No-Break"><st c="24271">.</st></span></p>
			<h2 id="_idParaDest-188"><a id="_idTextAnchor838"/><st c="24272">How to do it...</st></h2>
			<p><st c="24288">To proceed with this recipe, we’ll create a sample DataFrame containing two variables in different </st><span class="No-Break"><st c="24388">time zones:</st></span></p>
			<ol>
				<li><st c="24399">Let’s </st><span class="No-Break"><st c="24406">import </st></span><span class="No-Break"><strong class="source-inline"><st c="24413">pandas</st></strong></span><span class="No-Break"><st c="24419">:</st></span><pre class="source-code"><st c="24421">
import pandas as pd</st></pre></li>				<li><st c="24441">Let’s create a DataFrame containing one variable with values in different </st><span class="No-Break"><st c="24516">time zones:</st></span><pre class="source-code"><st c="24527">
df = pd.DataFrame()
df['time1'] = pd.concat([
    pd.Series(
        pd.date_range(
            start='2024-06-10 09:00',
            freq='h',
            periods=3,
            tz='Europe/Berlin')),
    pd.Series(
        pd.date_range(
            start='2024-09-10 09:00',
            freq='h',
            periods=3,
            tz='US/Central'))
    ], axis=0)</st></pre></li>				<li><st c="24770">Let’s add </st><a id="_idIndexMarker487"/><st c="24781">another </st><strong class="source-inline"><st c="24789">datetime</st></strong><st c="24797"> variable to the DataFrame, which also contains values in different </st><span class="No-Break"><st c="24865">time zones:</st></span><pre class="source-code"><st c="24876">
df['time2'] = pd.concat([
    pd.Series(
        pd.date_range(
            start='2024-07-01 09:00',
            freq='h',
            periods=3,
            tz='Europe/Berlin')),
    pd.Series(
        pd.date_range(
            start='2024-08-01 09:00',
            freq='h',
            periods=3,
            tz='US/Central</st><a id="_idTextAnchor839"/><st c="25085">'))
    ], axis=0)</st></pre><p class="list-inset"><st c="25100">If we now execute </st><strong class="source-inline"><st c="25119">df</st></strong><st c="25121">, we’ll see the DataFrame with the variables in the diffe</st><a id="_idTextAnchor840"/><st c="25178">rent time zones like in the </st><span class="No-Break"><st c="25207">following output:</st></span></p></li>			</ol>
			<div>
				<div id="_idContainer112" class="IMG---Figure">
					<img src="image/B22396_06_19.jpg" alt="Figure 6.19 – A DataFrame with two datetime variables in different time zones"/><st c="25224"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="25549">Figure 6.19 – A DataFrame with two datetime variables in different time zones</st></p>
			<p class="callout-heading"><st c="25626">Note</st></p>
			<p class="callout"><st c="25631">The time zone is indicated with the </st><strong class="source-inline"><st c="25668">+02</st></strong><st c="25671"> and </st><strong class="source-inline"><st c="25676">-05</st></strong><st c="25679"> values, respectively, which indicates the time difference to</st><a id="_idIndexMarker488"/><st c="25740"> the </st><strong class="bold"><st c="25745">Coordinated Universal </st></strong><span class="No-Break"><strong class="bold"><st c="25767">Time</st></strong></span><span class="No-Break"><st c="25771"> (</st></span><span class="No-Break"><strong class="bold"><st c="25773">UTC</st></strong></span><span class="No-Break"><st c="25776">).</st></span></p>
			<ol>
				<li value="4"><st c="25779">To work </st><a id="_idIndexMarker489"/><st c="25788">with different time zones, we typically set the variables in the same time zone, in this case, we chose </st><span class="No-Break"><st c="25892">the UTC:</st></span><pre class="source-code"><st c="25900">
df['time1_utc'] = pd.to_datetime(
    df['time1'], utc=True)
df['time2_utc'] = pd.to_datetime(
    df['time2'], utc=True)</st></pre></li>			</ol>
			<p><st c="26014">If we now execute </st><strong class="source-inline"><st c="26033">df</st></strong><st c="26035">, we’ll see the new variables, which have</st><a id="_idTextAnchor841"/><st c="26076"> a difference of </st><strong class="source-inline"><st c="26093">00</st></strong><st c="26095"> hours with respect </st><span class="No-Break"><st c="26115">to UTC:</st></span></p>
			<div>
				<div id="_idContainer113" class="IMG---Figure">
					<img src="image/B22396_06_20.jpg" alt="Figure 6.20 – A DataFrame﻿ containing the new variables in the UTC"/><st c="26122"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="26779">Figure 6.20 – A DataFrame</st><a id="_idTextAnchor842"/><st c="26804"> containing the new variables in the UTC</st></p>
			<ol>
				<li><st c="26844">Let’s calculate the </st><a id="_idIndexMarker490"/><st c="26865">difference in days between the variables and then display the first five rows of </st><span class="No-Break"><st c="26946">the DataFrame:</st></span><pre class="source-code"><st c="26960">
df['elapsed_days'] = (
    df[‹time2_utc›] - df[‹time1_utc›]). </st><st c="27020">dt.days
df['elapsed_days'].head()</st></pre><p class="list-inset"><st c="27053">We see the time difference between the variables in the </st><span class="No-Break"><st c="27110">following output:</st></span></p><pre class="source-code"><strong class="bold"><st c="27127">0    21</st></strong>
<strong class="bold"><st c="27132">1    21</st></strong>
<strong class="bold"><st c="27137">2    21</st></strong>
<strong class="bold"><st c="27142">0   -40</st></strong>
<strong class="bold"><st c="27148">1   -40</st></strong>
<strong class="bold"><st c="27154">Name: elapsed_days, dtype: int64</st></strong></pre></li>				<li><st c="27187">Finally, let’s change the time zone of the </st><strong class="source-inline"><st c="27231">datetime</st></strong><st c="27239"> variables to the </st><strong class="source-inline"><st c="27257">London</st></strong><st c="27263"> and </st><strong class="source-inline"><st c="27268">Berlin</st></strong><st c="27274"> time zones, and then display the </st><span class="No-Break"><st c="27308">resulting variables:</st></span><pre class="source-code"><st c="27328">
df['time1_london'] = df[
    ‹time1_utc›].dt.tz_convert('Europe/London')
df['time2_berlin'] = df[
    ‹time1_utc›].dt.tz_convert('Europe/Berlin')
df[['time1_london', 'time2_berlin']]</st></pre><p class="list-inset"><st c="27503">We see the variables in their </st><a id="_idTextAnchor843"/><st c="27534">respective time zones in the </st><span class="No-Break"><st c="27563">following output:</st></span></p></li>			</ol>
			<div>
				<div id="_idContainer114" class="IMG---Figure">
					<img src="image/B22396_06_21.jpg" alt="Figure 6.21 – Variables reformatted into different time zones"/><st c="27580"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="27919">Figure 6.21 – Variables reformatted into different time zones</st></p>
			<p><st c="27980">When changing</st><a id="_idIndexMarker491"/><st c="27994"> time zones, not only do the values of the zone change – that is, the </st><strong class="source-inline"><st c="28064">+01</st></strong><st c="28067"> and </st><strong class="source-inline"><st c="28072">+02</st></strong><st c="28075"> values in the previous ima</st><a id="_idTextAnchor844"/><a id="_idTextAnchor845"/><st c="28102">ge – but the value of the hour changes </st><span class="No-Break"><st c="28142">as well.</st></span></p>
			<h2 id="_idParaDest-189"><a id="_idTextAnchor846"/><st c="28150">How it works...</st></h2>
			<p><st c="28166">In this recipe, we changed time z</st><a id="_idTextAnchor847"/><st c="28200">ones and performed operations between variables in different time zones. </st><st c="28274">To begin, we created a DataFrame with two variables, the values of which started at an arbitrary date and increased hourly; these were set in different time zones. </st><st c="28438">To combine the different time zone variables in one DataFrame column, we concatenated the series returned by </st><strong class="source-inline"><st c="28547">pandas</st></strong><st c="28553">’ </st><strong class="source-inline"><st c="28556">date_range()</st></strong><st c="28568"> by utilizing </st><strong class="source-inline"><st c="28582">pandas</st></strong><st c="28588">’ </st><strong class="source-inline"><st c="28591">concat()</st></strong><st c="28599">. We set the </st><strong class="source-inline"><st c="28612">axis</st></strong><st c="28616"> argument to </st><strong class="source-inline"><st c="28629">0</st></strong><st c="28630"> to indicate we wanted to concatenate the series vertically in one column. </st><st c="28705">We covered the arguments of </st><strong class="source-inline"><st c="28733">pandas</st></strong><st c="28739">’ </st><strong class="source-inline"><st c="28742">date_range()</st></strong><st c="28754"> extensively in former recipes in this chapter; see the </st><em class="italic"><st c="28810">Extracting features from dates with pandas</st></em><st c="28852"> and </st><em class="italic"><st c="28857">Extracting features from time with pandas</st></em><st c="28898"> recipes for </st><span class="No-Break"><st c="28911">more details.</st></span></p>
			<p><st c="28924">To reset the time zone of the variables to the central zone, we used </st><strong class="source-inline"><st c="28994">pandas</st></strong><st c="29000">’ </st><strong class="source-inline"><st c="29003">to_datetime()</st></strong><st c="29016">, passing </st><strong class="source-inline"><st c="29026">utc=True</st></strong><st c="29034">. Finally, we determined the time difference between the </st><a id="_idIndexMarker492"/><st c="29091">variables by subtracting one series from the other and capturing the difference in days. </st><st c="29180">To reassign a different time zone, we used </st><strong class="source-inline"><st c="29223">pandas</st></strong><st c="29229">’ </st><strong class="source-inline"><st c="29232">tz_convert</st><a id="_idTextAnchor848"/><a id="_idTextAnchor849"/><st c="29242">()</st></strong><st c="29245">, indicating the</st><a id="_idTextAnchor850"/><st c="29261"> new time zone as </st><span class="No-Break"><st c="29279">an argument.</st></span></p>
			<h2 id="_idParaDest-190"><a id="_idTextAnchor851"/><st c="29291">See also</st></h2>
			<p><st c="29300">To</st><a id="_idIndexMarker493"/><st c="29303"> learn more about </st><strong class="source-inline"><st c="29321">pandas</st></strong><st c="29327">’ </st><strong class="source-inline"><st c="29330">to_datetime()</st></strong><st c="29343">, </st><span class="No-Break"><st c="29345">visit </st></span><a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.to_datetime.html"><span class="No-Break"><st c="29351">https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.to_datetime.html</st></span></a><span class="No-Break"><st c="29433">.</st></span></p>
			<p><st c="29434">To learn </st><a id="_idIndexMarker494"/><st c="29444">more about </st><strong class="source-inline"><st c="29455">pandas</st></strong><st c="29461">’ </st><strong class="source-inline"><st c="29464">tz_convert()</st></strong><st c="29476">, </st><span class="No-Break"><st c="29478">visit </st></span><a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.dt.tz_convert.html"><span class="No-Break"><st c="29484">https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.dt.tz_convert.html</st></span></a><span class="No-Break"><st c="29575">.</st></span></p>
			<h1 id="_idParaDest-191"><st c="29576">Automating the datetime fea</st><a id="_idTextAnchor852"/><st c="29604">ture extraction with</st><a id="_idTextAnchor853"/><st c="29625"> Feature-engine</st></h1>
			<p><strong class="source-inline"><st c="29640">feature-engine</st></strong><st c="29655"> is a </st><a id="_idIndexMarker495"/><st c="29661">Python library for feature engineering and selection that is well suited to working with </st><strong class="source-inline"><st c="29750">pandas</st></strong><st c="29756"> DataFrames. </st><st c="29769">The </st><strong class="source-inline"><st c="29773">DatetimeFeatures()</st></strong><st c="29791"> class can extract features from date and time automatically by using </st><strong class="source-inline"><st c="29861">pandas</st></strong><st c="29867">’ </st><strong class="source-inline"><st c="29870">dt</st></strong><st c="29872"> under the hood. </st><strong class="source-inline"><st c="29889">DatetimeFeatures()</st></strong><st c="29907"> allows you to </st><a id="_idIndexMarker496"/><st c="29922">extract the </st><span class="No-Break"><st c="29934">following</st></span><span class="No-Break"><a id="_idIndexMarker497"/></span><span class="No-Break"><st c="29943"> features:</st></span></p>
			<ul>
				<li><span class="No-Break"><st c="29953">Month</st></span></li>
				<li><span class="No-Break"><st c="29959">Quarter</st></span></li>
				<li><span class="No-Break"><st c="29967">Semester</st></span></li>
				<li><span class="No-Break"><st c="29976">Year</st></span></li>
				<li><span class="No-Break"><st c="29981">Week</st></span></li>
				<li><st c="29986">Day of </st><span class="No-Break"><st c="29994">the week</st></span></li>
				<li><st c="30002">Day of </st><span class="No-Break"><st c="30010">the month</st></span></li>
				<li><st c="30019">Day of </st><span class="No-Break"><st c="30027">the year</st></span></li>
				<li><span class="No-Break"><st c="30035">Weekend</st></span></li>
				<li><span class="No-Break"><st c="30043">Month start</st></span></li>
				<li><span class="No-Break"><st c="30055">Month end</st></span></li>
				<li><span class="No-Break"><st c="30065">Quarter start</st></span></li>
				<li><span class="No-Break"><st c="30079">Quarter end</st></span></li>
				<li><span class="No-Break"><st c="30091">Year start</st></span></li>
				<li><span class="No-Break"><st c="30102">Year end</st></span></li>
				<li><span class="No-Break"><st c="30111">Leap year</st></span></li>
				<li><st c="30121">Days in </st><span class="No-Break"><st c="30130">a month</st></span></li>
				<li><span class="No-Break"><st c="30137">Hour</st></span></li>
				<li><span class="No-Break"><st c="30142">Minute</st></span></li>
				<li><span class="No-Break"><st c="30149">Second</st></span></li>
			</ul>
			<p><st c="30156">In this recipe, we will automatically create fea</st><a id="_idTextAnchor854"/><a id="_idTextAnchor855"/><st c="30205">tures from date and time by </st><span class="No-Break"><st c="30234">utilizing </st></span><span class="No-Break"><strong class="source-inline"><st c="30244">feature-engine</st></strong></span><span class="No-Break"><st c="30258">.</st></span></p>
			<h2 id="_idParaDest-192"><a id="_idTextAnchor856"/><st c="30259">How to do it...</st></h2>
			<p><st c="30275">To </st><a id="_idIndexMarker498"/><st c="30279">showcase </st><strong class="source-inline"><st c="30288">feature-engine</st></strong><st c="30302">’s functionality, we’ll </st><a id="_idIndexMarker499"/><st c="30327">create a sample DataFrame with a </st><span class="No-Break"><strong class="source-inline"><st c="30360">datetime</st></strong></span><span class="No-Break"><st c="30368"> variable:</st></span></p>
			<ol>
				<li><st c="30378">Let’s begin by importing </st><strong class="source-inline"><st c="30404">pandas</st></strong> <span class="No-Break"><st c="30410">and </st></span><span class="No-Break"><strong class="source-inline"><st c="30415">DatetimeFeatures()</st></strong></span><span class="No-Break"><st c="30433">:</st></span><pre class="source-code"><st c="30435">
import pandas as pd
from feature_engine.datetime import DatetimeFeatures</st></pre></li>				<li><st c="30508">Let’s create a </st><strong class="source-inline"><st c="30524">datetime</st></strong><st c="30532"> variable with 20 values, beginning from </st><strong class="source-inline"><st c="30573">2024-05-17</st></strong><st c="30583"> at midnight and followed by increments of </st><strong class="source-inline"><st c="30626">1</st></strong><st c="30627"> day. </st><st c="30633">Then, we store this variable in </st><span class="No-Break"><st c="30665">a DataFrame:</st></span><pre class="source-code"><st c="30677">
rng_ = pd.date_range(
    '2024-05-17', periods=20, freq='D')
data = pd.DataFrame({'date': rng_})</st></pre></li>				<li><st c="30771">We’ll</st><a id="_idIndexMarker500"/><st c="30777"> start by setting </st><a id="_idIndexMarker501"/><st c="30795">up the transformer to extract all supported </st><span class="No-Break"><strong class="source-inline"><st c="30839">datetime</st></strong></span><span class="No-Break"><st c="30847"> features:</st></span><pre class="source-code"><st c="30857">
dtfs = DatetimeFeatures(
    variables=None,
    features_to_extract= "all",
)</st></pre></li>			</ol>
			<p class="callout-heading"><st c="30928">Note</st></p>
			<p class="callout"><strong class="source-inline"><st c="30933">DatetimeFeatures()</st></strong><st c="30952"> automatically finds the variables of the </st><strong class="source-inline"><st c="30994">datetime</st></strong><st c="31002"> type, or that could be parsed as </st><strong class="source-inline"><st c="31036">datetime</st></strong><st c="31044"> when the </st><strong class="source-inline"><st c="31054">variables</st></strong><st c="31063"> parameter is set to </st><strong class="source-inline"><st c="31084">None</st></strong><st c="31088">. Alternatively, you can pass a list with the names of the variables from which you want to extract </st><strong class="source-inline"><st c="31188">date</st></strong><st c="31192"> and </st><span class="No-Break"><strong class="source-inline"><st c="31197">time</st></strong></span><span class="No-Break"><st c="31201"> features.</st></span></p>
			<ol>
				<li value="4"><st c="31211">Let’s add the </st><strong class="source-inline"><st c="31226">date</st></strong><st c="31230"> and </st><strong class="source-inline"><st c="31235">time</st></strong><st c="31239"> features to </st><span class="No-Break"><st c="31252">the data:</st></span><pre class="source-code"><st c="31261">
dft = dtfs.fit_transform(data)</st></pre></li>			</ol>
			<p class="callout-heading"><st c="31292">Note</st></p>
			<p class="callout"><st c="31297">By default, </st><strong class="source-inline"><st c="31310">DatetimeFeatures()</st></strong><st c="31328"> extracts the following features from each </st><strong class="source-inline"><st c="31371">datetime</st></strong><st c="31379"> variable: </st><strong class="source-inline"><st c="31390">month</st></strong><st c="31395">, </st><strong class="source-inline"><st c="31397">year</st></strong><st c="31401">, </st><strong class="source-inline"><st c="31403">day_of_week</st></strong><st c="31414">, </st><strong class="source-inline"><st c="31416">day_of_month</st></strong><st c="31428">, </st><strong class="source-inline"><st c="31430">hour</st></strong><st c="31434">, </st><strong class="source-inline"><st c="31436">minute</st></strong><st c="31442">, and </st><strong class="source-inline"><st c="31448">second</st></strong><st c="31454">. We can modify this behavior through the</st><a id="_idTextAnchor857"/> <strong class="source-inline"><st c="31495">features_to_extra</st><a id="_idTextAnchor858"/><st c="31513">ct</st></strong><st c="31516"> parameter as we did in </st><span class="No-Break"><em class="italic"><st c="31540">Step 3</st></em></span><span class="No-Break"><st c="31546">.</st></span></p>
			<ol>
				<li value="5"><st c="31547">Let’s </st><a id="_idIndexMarker502"/><st c="31554">capture the names</st><a id="_idIndexMarker503"/><st c="31571"> of the new variables in </st><span class="No-Break"><st c="31596">a list:</st></span><pre class="source-code"><st c="31603">
vars_ = [v for v in dft.columns if "date" in v]</st></pre></li>			</ol>
			<p class="callout-heading"><st c="31651">Note</st></p>
			<p class="callout"><strong class="source-inline"><st c="31656">DatetimeFeatures()</st></strong><st c="31675"> names the new variables with the original variable name (in this case, </st><strong class="source-inline"><st c="31747">date</st></strong><st c="31751">) followed by an underscore and then the type of feature created, for example, </st><strong class="source-inline"><st c="31831">date_day_of_week</st></strong><st c="31847"> contains the day of the week extracted from the </st><span class="No-Break"><strong class="source-inline"><st c="31896">date</st></strong></span><span class="No-Break"><st c="31900"> variable.</st></span></p>
			<p class="list-inset"><st c="31910">If we execute </st><strong class="source-inline"><st c="31925">vars_</st></strong><st c="31930">, we’ll see the names of the features that </st><span class="No-Break"><st c="31973">were created:</st></span></p>
			<pre class="source-code">
<strong class="bold"><st c="31986">['date_month',</st></strong>
<strong class="bold"><st c="32001"> 'date_quarter',</st></strong>
<strong class="bold"><st c="32017"> 'date_semester',</st></strong>
<strong class="bold"><st c="32034"> 'date_year',</st></strong>
<strong class="bold"><st c="32047"> 'date_week',</st></strong>
<strong class="bold"><st c="32060"> 'date_day_of_week',</st></strong>
<strong class="bold"><st c="32080"> 'date_day_of_month',</st></strong>
<strong class="bold"><st c="32101"> 'date_day_of_year',</st></strong>
<strong class="bold"><st c="32121"> 'date_weekend',</st></strong>
<strong class="bold"><st c="32137"> 'date_month_start',</st></strong>
<strong class="bold"><st c="32157"> 'date_month_end',</st></strong>
<strong class="bold"><st c="32175"> 'date_quarter_start',</st></strong>
<strong class="bold"><st c="32197"> 'date_quarter_end',</st></strong>
 <strong class="bold"><st c="32217">'date_year_start',</st></strong>
<strong class="bold"><st c="32236"> 'date_year_end',</st></strong>
<strong class="bold"><st c="32253"> 'date_leap_year',</st></strong>
<strong class="bold"><st c="32271"> 'date_days_in_month',</st></strong>
<strong class="bold"><st c="32293"> 'date_hour',</st></strong>
<strong class="bold"><st c="32306"> 'date_minute',</st></strong>
<strong class="bold"><st c="32321"> 'date_second']</st></strong></pre>			<p class="list-inset"><st c="32336">To </st><a id="_idIndexMarker504"/><st c="32340">visualize the resulting </st><a id="_idIndexMarker505"/><st c="32364">DataFrame, go ahead and execute </st><strong class="source-inline"><st c="32396">dft[vars_].head()</st></strong><st c="32413">. We can’t show the resulting DataFrame in the book because it is </st><span class="No-Break"><st c="32479">too big.</st></span></p>
			<p class="callout-heading"><st c="32487">Note</st></p>
			<p class="callout"><st c="32492">We can create specific features by passing their names to the </st><span class="No-Break"><strong class="source-inline"><st c="32555">features_to_extract</st></strong></span><span class="No-Break"><st c="32574"> parameter.</st></span></p>
			<p class="callout"><st c="32585">For example, to extract </st><strong class="source-inline"><st c="32610">week</st></strong><st c="32614"> and </st><strong class="source-inline"><st c="32619">year</st></strong><st c="32623">, we set the transformer like this: </st><strong class="source-inline"><st c="32659">dtfs = DatetimeFeatures(features_to_extract=["week", "year"])</st></strong><st c="32720">. We can also extract all supported features by setting the </st><strong class="source-inline"><st c="32780">features_to_extract</st></strong><st c="32799"> parameter </st><span class="No-Break"><st c="32810">to </st></span><span class="No-Break"><strong class="source-inline"><st c="32813">"all"</st></strong></span><span class="No-Break"><st c="32818">.</st></span></p>
			<p class="list-inset"><strong class="source-inline"><st c="32819">DatetimeFe</st><a id="_idTextAnchor859"/><st c="32830">atures()</st></strong><st c="32839"> can also </st><a id="_idTextAnchor860"/><st c="32849">create features from variables in different time zones. </st><st c="32905">Let’s learn how to correctly set up the transformer in </st><span class="No-Break"><st c="32960">this situation.</st></span></p>
			<ol>
				<li value="6"><st c="32975">Let’s create a sample DataFrame with a variable’s values in different </st><span class="No-Break"><st c="33046">time zones:</st></span><pre class="source-code"><st c="33057">
df = pd.DataFrame()
df["time"] = pd.concat(
    [
        pd.Series(
            pd.date_range(
            start="2024-08-01 09:00",
            freq="h",
            periods=3,
            tz="Europe/Berlin"
            )
        ),
        pd.Series(
            pd.date_range(
                start="2024-08-01 09:00",
               freq="h",
               periods=3, tz="US</st><a id="_idTextAnchor861"/><st c="33280">/Central"
          </st><a id="_idTextAnchor862"/><st c="33291">  )
        ),
    ],
    axis=0,
)</st></pre><p class="list-inset"><st c="33308">If we</st><a id="_idIndexMarker506"/><st c="33314"> execute </st><strong class="source-inline"><st c="33323">df</st></strong><st c="33325">, we </st><a id="_idIndexMarker507"/><st c="33330">will se</st><a id="_idTextAnchor863"/><st c="33337">e the DataFrame from </st><em class="italic"><st c="33359">Step 6</st></em><st c="33365">, as shown in the </st><span class="No-Break"><st c="33383">following output:</st></span></p></li>			</ol>
			<div>
				<div id="_idContainer115" class="IMG---Figure">
					<img src="image/B22396_06_22.jpg" alt="Figure 6.22 – A DataFrame with a variable’s values in different time zones"/><st c="33400"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="33562">Figure 6.22 – A DataFrame with a variable’s values in different time zones</st></p>
			<ol>
				<li value="7"><st c="33636">We’ll </st><a id="_idIndexMarker508"/><st c="33643">set the transformer to </st><a id="_idIndexMarker509"/><st c="33666">extract three specific features from this variable after setting it to </st><span class="No-Break"><st c="33737">the UTC:</st></span><pre class="source-code"><st c="33745">
dfts = DatetimeFeatures(
    features_to_extract=
        ["day_of_week", "hour","minute"],
    drop_original=False,
    utc=True,
)</st></pre></li>				<li><st c="33858">Let’s create the </st><span class="No-Break"><st c="33876">new features:</st></span><pre class="source-code"><st c="33889">
dft = dfts.fit_transform(df)</st></pre><p class="list-inset"><strong class="source-inline"><st c="33918">DatetimeFeatures()</st></strong><st c="33937"> will set all variables into UTC before deriving the</st><a id="_idTextAnchor864"/><st c="33989"> features. </st><st c="34000">With </st><strong class="source-inline"><st c="34005">dft.head()</st></strong><st c="34015">, we can see the </st><span class="No-Break"><st c="34032">resulting DataFrame:</st></span></p></li>			</ol>
			<div>
				<div id="_idContainer116" class="IMG---Figure">
					<img src="image/B22396_06_23.jpg" alt="Fig﻿ure 6.23 – A DataFrame with t﻿he original and new variables"/><st c="34052"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="34269">Fig</st><a id="_idTextAnchor865"/><st c="34272">ure 6.23 – A DataFrame with t</st><a id="_idTextAnchor866"/><st c="34302">he original and new variables</st></p>
			<p><st c="34332">With that, we’ve </st><a id="_idIndexMarker510"/><st c="34350">created multiple date </st><a id="_idIndexMarker511"/><st c="34372">and time-related features in a few lines of code. </st><strong class="source-inline"><st c="34422">feature-engine</st></strong><st c="34436"> offers a great alternative to manually creating features per feature with </st><strong class="source-inline"><st c="34511">pandas</st></strong><st c="34517">. In addition, </st><strong class="source-inline"><st c="34532">DatetimeFeatures()</st></strong><st c="34550"> can be integrated in</st><a id="_idTextAnchor867"/><a id="_idTextAnchor868"/><st c="34571">to scikit-learn’s </st><strong class="source-inline"><st c="34590">Pipeline</st></strong><st c="34598"> and </st><strong class="source-inline"><st c="34603">GridSearchCV</st></strong><st c="34615">, among </st><span class="No-Break"><st c="34623">other classes.</st></span></p>
			<h2 id="_idParaDest-193"><a id="_idTextAnchor869"/><st c="34637">How it works...</st></h2>
			<p><strong class="source-inline"><st c="34653">DatetimeFeatures()</st></strong><st c="34672"> extracts several date and time features from </st><strong class="source-inline"><st c="34718">datetime</st></strong><st c="34726"> variables automatically by utilizing </st><strong class="source-inline"><st c="34764">pandas</st></strong><st c="34770">’ </st><strong class="source-inline"><st c="34773">dt</st></strong><st c="34775"> under the hood. </st><st c="34792">It works with variables whose original data types are </st><strong class="source-inline"><st c="34846">datetime</st></strong><st c="34854">, as well as with object-like and categorical variables, provided that they can be parsed into a </st><span class="No-Break"><strong class="source-inline"><st c="34951">datetime</st></strong></span><span class="No-Break"><st c="34959"> format.</st></span></p>
			<p><strong class="source-inline"><st c="34967">DatetimeFeatures()</st></strong><st c="34986"> extracts the following features by default: </st><strong class="source-inline"><st c="35031">month</st></strong><st c="35036">, </st><strong class="source-inline"><st c="35038">year</st></strong><st c="35042">, </st><strong class="source-inline"><st c="35044">day_of_week</st></strong><st c="35055">, </st><strong class="source-inline"><st c="35057">day_of_month</st></strong><st c="35069">, </st><strong class="source-inline"><st c="35071">hour</st></strong><st c="35075">, </st><strong class="source-inline"><st c="35077">minute</st></strong><st c="35083"> and </st><strong class="source-inline"><st c="35088">second</st></strong><st c="35094">. We can make the transformer return all the features it supports by setting the parameter </st><strong class="source-inline"><st c="35185">features_to_extract</st></strong><st c="35204"> to </st><strong class="source-inline"><st c="35208">all</st></strong><st c="35211">. In addition, we can extract a specific subset of features by passing the feature names in a list, as we did in </st><span class="No-Break"><em class="italic"><st c="35324">Step 7</st></em></span><span class="No-Break"><st c="35330">.</st></span></p>
			<p><strong class="source-inline"><st c="35331">DatetimeFeatures()</st></strong><st c="35350"> automatically finds </st><strong class="source-inline"><st c="35371">datetime</st></strong><st c="35379"> variables or variables that can be parsed as </st><strong class="source-inline"><st c="35425">datetime</st></strong><st c="35433"> in the DataFrame passed to the </st><strong class="source-inline"><st c="35465">fit()</st></strong><st c="35470"> method. </st><st c="35479">To extract features from a selected variable or group of variables, we can pass their name in a list to the </st><strong class="source-inline"><st c="35587">variables</st></strong><st c="35596"> parameter when we set up </st><span class="No-Break"><st c="35622">the transformer.</st></span></p>
			<p><st c="35638">With </st><strong class="source-inline"><st c="35644">fit()</st></strong><st c="35649">, </st><strong class="source-inline"><st c="35651">Dat</st><a id="_idTextAnchor870"/><st c="35654">etimeFeatures()</st></strong><st c="35670"> doe</st><a id="_idTextAnchor871"/><st c="35674">s not learn any parameters; instead, it checks that the variables entered by the user are, or can be, parsed into a </st><strong class="source-inline"><st c="35791">datetime</st></strong><st c="35799"> format. </st><st c="35808">If the user does not indicate variable names, </st><strong class="source-inline"><st c="35854">DatetimeFeatures()</st></strong><st c="35872"> finds the </st><strong class="source-inline"><st c="35883">datetime</st></strong><st c="35891"> variables </st><a id="_idIndexMarker512"/><st c="35902">automatically. </st><st c="35917">With </st><strong class="source-inline"><st c="35922">transform()</st></strong><st c="35933">, the </st><a id="_idIndexMarker513"/><st c="35939">tr</st><a id="_idTextAnchor872"/><st c="35941">ansformer adds the date and time-derived variables to </st><span class="No-Break"><st c="35996">the DataFrame.</st></span></p>
		</div>
	<div id="charCountTotal" value="36010"/></body></html>