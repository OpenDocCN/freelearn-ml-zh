- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Measuring Movement with Encoders on Raspberry Pi Pico
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Robots don’t just run code blindly; they need sensors. What sensors do we add
    first? Our robot already has some sensors on board, and in this chapter, we’ll
    see how to use them.
  prefs: []
  type: TYPE_NORMAL
- en: We finished the previous chapter noticing that timing isn’t the most accurate
    way to determine robot movement. So, let’s see how our first sensor, encoders,
    can improve this. Encoders are the first step in getting accurate movement and
    location estimation in robots. We will also learn one of Raspberry Pi Pico’s excellent
    features – **Programmable** **IO** (**PIO**).
  prefs: []
  type: TYPE_NORMAL
- en: We’ll dig into movement fundamentals, odometry and encoding, look at Raspberry
    Pi Pico PIO in CircuitPython, and use this to get data from the encoders on our
    robot.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: About encoders and odometry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wiring in encoders on a Raspberry Pi Pico robot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Programming Raspberry Pi Pico PIO
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Measuring encoder count for movement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this chapter, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: First is the built robot, as made in the previous chapters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 6 x fresh AA batteries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A PC or laptop with a USB micro cable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mu software to write our code and upload it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clear floor space with a meter or so in each direction to test the robot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All code examples are on GitHub at https://github.com/PacktPublishing/Robotics-at-Home-with-Raspberry-Pi-Pico/tree/main/ch-06.
  prefs: []
  type: TYPE_NORMAL
- en: About encoders and odometry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Odometry** is measuring how a position has changed over time. We can combine
    measuring and estimation to determine where you are on a route. **An encoder**
    is a sensor designed to measure distance traveled via wheel turns. They are like
    **tachometers**, but encoders measure position whereas tachometers measure only
    speed. Combined with time, they can make a speed measurement too.'
  prefs: []
  type: TYPE_NORMAL
- en: Absolute and relative sensing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sensors for a robot’s location come in two primary forms. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Absolute sensors** encode a position to a repeatable position. They have
    a limited range or resolution, such as encoding a position along a known line.
    For example, GPS sensors have exact positioning with low resolution, suitable
    for meters but not millimeters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Relative sensors** tend to be cheaper. However, they produce a relative change
    in position, which needs to be combined with the previous state to get an absolute
    estimate – this means that errors can accumulate. Relative encoders are one example
    of relative sensors, also known as **incremental encoders**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a sensor tells you where something is *at*, it is absolute. It is relative
    if it tells you how much something has moved *by*.
  prefs: []
  type: TYPE_NORMAL
- en: Types of encoders
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most encoder designs work by passing markers or code over a sensor that counts
    or decodes the pulses.
  prefs: []
  type: TYPE_NORMAL
- en: 'Encoders come in a few forms. Some example types are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A potentiometer or **variable resistor** can sense an absolute encoder position
    by measuring resistance. Servo motors use them. However, potentiometers are not
    suitable for continuous rotations such as wheels, as their track lengths limit
    them. In addition, regular movement wears them down, as they move contacts across
    each other.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mechanical encoders** pass electrical contacts over each other, producing
    on and off pulses. They are subject to heavy wear, so I do not recommend them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Optical encoders** shine a light through a disk or strip with slots and detect
    the passing of slots in front of light sensors. They can come in absolute and
    relative flavors. They can be susceptible to interference from light sources or
    just dirt.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Magnetic encoders** detect the movements of magnets in a disc using **hall-effect
    sensors**. Dirt, light interference, and physical wear do not affect them so much.
    Hall-effect sensors produce a voltage depending on a magnetic field – encoder
    modules produce pulses from this.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The motors we chose came with rotary magnetic encoders in a convenient and small
    format as part of the package. They are incremental encoders.
  prefs: []
  type: TYPE_NORMAL
- en: Encoder pulse data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can better understand encoders by looking at the pulses they output. Relative
    encoders usually output digital pulse chains, 1s and 0s. The simplest form is
    just to count pulse edges by detecting marks passing a sensor, as the following
    diagram shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 – Simple pulse encoding ](img/Figure_6.01_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.1 – Simple pulse encoding
  prefs: []
  type: TYPE_NORMAL
- en: On the left of *Figure 6**.1* is a disk with a rotation arrow. On the disk are
    four white marks – representing the markers passing a sensor. The black rectangular
    object is the sensor that detects the markers. The sensor produces a value of
    0 when it isn’t detecting a marker and 1 when it is – making a bunch of pulses
    or a stream of binary bits with values of 1 or 0.
  prefs: []
  type: TYPE_NORMAL
- en: We can count the pulses to get an idea of far the wheel has turned. We count
    a high pulse as 1 and a low pulse as 0\. We can also count **edges**, the changes
    from 0 to 1 and 1 to 0\. Counting edges gives us eight steps per wheel turn. The
    graph to the right of the following diagram shows these pulses.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are likely to want to increase that sensitivity and detect which direction
    a wheel is going. To do that, we add a second sensor to the same wheel, as the
    following diagram shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2 – Quadrature pulse encoding ](img/Figure_6.02_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.2 – Quadrature pulse encoding
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 6**.2* adds a second sensor to catch the markers at a slightly different
    time from the first, generating pulses out of phase; this means we have two streams
    of pulses.'
  prefs: []
  type: TYPE_NORMAL
- en: At the top right is the pulse graph for the first sensor, with the digits we
    had read from times between the pulses added, showing a pulse train of 16 bits
    for the same period.
  prefs: []
  type: TYPE_NORMAL
- en: The middle graph shows the additional sensor, with the out-of-phase 16-digit
    pulse train. Below the graphs are the two states combined at each point in time
    as **Gray code**, with 2 bits of information on where we are relative to the last
    position. We have twice as many edges, increasing the sensor resolution and also
    encoding the wheel’s direction. If we reverse the wheel, this sequence will reverse.
    This system is known as **quadrature encoding**.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at the encoders on our robot in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Wiring in encoders on a Raspberry Pi Pico robot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our robot has already got encoders on board, and we have already wired them
    in. We can take a closer look at the motors and how they are wired into Raspberry
    Pi Pico GPIO pins to understand the robot better.
  prefs: []
  type: TYPE_NORMAL
- en: Examining the motors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We use N20 geared motors with encoders. The following diagram labels the motor
    parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3 – The N20 motor parts ](img/Figure_6.03_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.3 – The N20 motor parts
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 6**.3* shows a drawing of the motors we have used. Marked on it are
    essential features that affect how we use the encoders. On the left is a magnetic
    disk with markers in it. This disk is attached to the motor’s driveshaft and sensed
    by the encoder sensor board. On the right are the gearbox and the motor output
    shaft.'
  prefs: []
  type: TYPE_NORMAL
- en: The driveshaft goes through the gearbox, so the output shaft will not make the
    same number of rotations as the disk – the gear ratio will determine this relationship.
    So one revolution of the output wheel could count many pulses; this gives us high
    resolution.
  prefs: []
  type: TYPE_NORMAL
- en: Consult the datasheet for the motors. Some Chinese characters are likely, but
    important numbers are usually in English. You may need translation services built
    into web search engines here. The datasheet and product page have two important
    numbers, the number of encoder counts per disk revolution and the gear ratio.
    The datasheet may note counts per disk revolution as pole count.
  prefs: []
  type: TYPE_NORMAL
- en: In my case, the gear ratio is 298:1, and the pole count is 14\. Interpreting
    these facts means I get 298 turns of my encoder wheel per output wheel revolution.
    Each encoder turn produces 14 poles on each sensor (two sensors), so we get 28
    edges. Multiplying the number of sensor pulses by the gear ratio gives 8344 edges
    per turn.
  prefs: []
  type: TYPE_NORMAL
- en: Examining the wiring
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We saw the wiring for our robot in *Figure 4**.20* of [*Chapter 4*](B18001_04.xhtml#_idTextAnchor080),
    *Building a Robot around Pico*. However, to better illustrate the encoder connections,
    here is a diagram focusing only on the wiring of encoders to Pico:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.4 – Encoders wired to Raspberry Pi Pico ](img/Figure_6.04_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.4 – Encoders wired to Raspberry Pi Pico
  prefs: []
  type: TYPE_NORMAL
- en: The preceding figure takes a closer look at data connections for a robot encoder
    connection schematic. On the left is Raspberry Pi Pico; this has four connections
    from the encoders. These are on GPIO 20, 21, 26, and 27\. Each of these can be
    set as input pins to read the state of the encoder pins.
  prefs: []
  type: TYPE_NORMAL
- en: If we were just reading encoders alone, we could write code to check each pin
    in sequence. However, doing this may tie things up. What if we could get components
    of the Pico to monitor these pins and pulse chains for us so that we could just
    read a counter for them when we need it?
  prefs: []
  type: TYPE_NORMAL
- en: Programming Raspberry Pi Pico PIO
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We saw the PIO system back in [*Chapter 1*](B18001_01.xhtml#_idTextAnchor015).
    We could read encoders in Python on the Pico central cores; however, we can make
    monitoring the encoders the responsibility of PIO, letting those central cores
    do other things. The PIO system can read and decode the Gray code emitted by the
    encoders. This section will show how to program PIO in assembler and load the
    programs with CircuitPython.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to PIO programming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we saw in [*Chapter 1*](B18001_01.xhtml#_idTextAnchor015), Pico has two
    PIO devices, each with four state machines. We program PIO in **assembly language**.
    Instructions command PIO to perform operations such as manipulating IO pins, registers,
    and **first in first out** (**FIFO**) queues. The following diagram is a simplified
    representation of a state machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.5 – The Raspberry Pi Pico PIO state machines ](img/Figure_6.05_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.5 – The Raspberry Pi Pico PIO state machines
  prefs: []
  type: TYPE_NORMAL
- en: The preceding diagram shows Raspberry Pi Pico PIO state machines, highlighting
    registers and other features. It shows the two PIO devices and the state machines
    in them.
  prefs: []
  type: TYPE_NORMAL
- en: 'A **register** is like a variable; they have fixed names, and there are only
    a few per core. PIO registers are 32-bit and specific to each state machine. We
    use an essential subset: **input shift register** (**ISR**), **output shift register**
    (**OSR**), and *X* and *Y* (scratch registers). They can store a number or a binary
    pattern. It is common to refer to 32 bits as **words**.'
  prefs: []
  type: TYPE_NORMAL
- en: Each state machine runs the program independently, so the same code runs four
    times, with independent registers. In addition, mappings (shown as dashed lines)
    connect state machines to IO pins – the tiny rectangles. Code can configure which
    state machines use which pins and a single state machine can read/write from many
    pins.
  prefs: []
  type: TYPE_NORMAL
- en: State machines also have FIFO queues. Data put into a FIFO queue comes out in
    the same order. Each can hold 4 x 32-bit words. These let PIO **transmit** (**TX**)
    data from or **receive** (**RX**) data to other devices within the rest of Pico.
    We can configure FIFO queues in many ways. For this chapter, we will use the RX
    FIFO queue to receive data from PIO to our code.
  prefs: []
  type: TYPE_NORMAL
- en: Each PIO block can run an independent program with 32 instructions – each roughly,
    but not quite, a line of code. But how do we write and use these programs?
  prefs: []
  type: TYPE_NORMAL
- en: Introducing PIOASM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In CircuitPython, we assemble the PIO code using the Adafruit CircuitPython
    `PIOASM` library. This runs on Pico, taking the assembly code in a string and
    outputting a sequence of bytes with the code in it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to put this `PIOASM` library onto Raspberry Pi Pico:'
  prefs: []
  type: TYPE_NORMAL
- en: First, find the `CIRCUITPY` volume on your computer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the Adafruit CircuitPython library (as discussed in [*Chapter 2*](B18001_02.xhtml#_idTextAnchor041)),
    copy `lib/adafruit_pioasm.mpy` into the `lib` folder on `CIRCUITPY`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With that in place, we can write our first PIO-based program. Here’s `pio_led_test.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The first four lines are imports. You’ve seen `time` and `board` before. The
    `rp2pio` library lets us communicate with the PIO blocks and start code and interact
    with state machines. The `adafruit_pioasm` library turns assembly code into bytes
    that PIO state machines can run. Now, let’s get into the assembly code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code puts some PIO assembly into the `led_flash` string. Triple
    quotes in Python declare a long multi-line string.
  prefs: []
  type: TYPE_NORMAL
- en: 'The assembly code starts with the `pull` instruction; this gets a word from
    the TX FIFO queue (removing it) and stores it in the OSR. The `out pins, 1` instruction
    puts 1 bit of data from the OSR onto the configured pins – setting the state of
    a single pin. The code wraps around to run at the first instruction in a loop.
    We need to assemble this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `adafruit_pioasm.assemble` function generates bytecode, which we store
    in the `assembled` variable. We can run this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '`rp2pio.StateMachine` requests a state machine to run this code, telling it
    how fast to run and which output pin to map to – in this case, `board.LED`. Our
    code will be running on the PIO, but we have no data in the FIFO queue, so it
    will be waiting for us to write something to it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can write data with a loop in this program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This loop writes 1s and 0s to the state machine (in the `sm` variable). It must
    wrap the data as a list since a FIFO queue can store more than one data element
    as a `bytes` type.
  prefs: []
  type: TYPE_NORMAL
- en: Send this to Raspberry Pi Pico, and the LED will flash. Let's ensure this works.
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting PIO code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Writing assembler code is somewhat tricky the first time – these tips can help
    you get moving:'
  prefs: []
  type: TYPE_NORMAL
- en: This code uses the Python triple quote, `"""`, for a multi-line string. Ensure
    you have three quotes at both ends of the assembly section, or you will see errors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If Pico cannot load `adafruit_pioasm`, ensure you have followed the setup steps
    to copy the `mpy` file into the `lib` folder on Pico.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that there must be two close brackets after the `sm.write` statements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If Pico is not running your code, remember to import your code in the `code.py`
    file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These tips should get you up and running.
  prefs: []
  type: TYPE_NORMAL
- en: Now we have our first PIO code, we can try reading data back from an I/O pin.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting input with PIO
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Fetching input from PIO is as simple as getting a pin state into a register
    and pushing that onto the RX FIFO queue for the Python code to pick up. Create
    a file called `pio_read_1_pin.py`. We will add one more import to read PIO data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The assembly section looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `in pins,` `1` instruction will read 1 bit of data from 1 input pin and
    store this in the ISR. Following this is a comment starting with a `;` character
    that is for humans to read. The spaces are optional and are there to aid readability
    by aligning the comments. You can also add a `.program` line – effectively another
    comment.
  prefs: []
  type: TYPE_NORMAL
- en: The next instruction is `push noblock`, which will take the ISR register and
    push it as a word onto the RX FIFO queue. `noblock` ensures it will not wait for
    the FIFO queue to be empty – note that data is not written to the FIFO queue if
    it is full.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then assemble this code and load it into a state machine, passing `first_in_pin`
    to map one of our encoder pins as input. Next, we need a buffer to read our FIFO
    queue data where the Python code can use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The array type makes fixed-size data structures in memory. It specifies an unsigned
    32-bit integer with `'I'`. We size it as 1 element and initialize it as `0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `main` loop reads data into the buffer and prints it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `sm.readinto` Python function pulls data from a FIFO queue into a waiting
    buffer. It will wait if there is no new data to fetch.
  prefs: []
  type: TYPE_NORMAL
- en: We then use a fancy print to output our data. Python `f`-strings (prefixed with
    an f) let you use a variable in the string – in this case, extracting the only
    element of `buffer`. The `:032b` format specifier tells Python to format the data
    as 32-digit binary, with the empty digits in front filled with 0s.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run this, you will see a repeating output with one of two states:'
  prefs: []
  type: TYPE_NORMAL
- en: '`10000000000000000000000000000000`, showing the encoder pin is high'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`00000000000000000000000000000000`, showing the encoder pin is low'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Turn the wheels on the robot slowly. One of them will make the pin change states.
    It may be surprising that the 1 bit is at the start of the data (and would be
    there in the ISR before we sent it).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can extend this code to work with two pins easily. Copy this to `pio_read_2_pins.py`
    and make the following modification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The other code remains the same, except that when we run it to turn the wheel
    slowly, the output will now show 2 bits from the encoder, in the following four
    states:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: These are the bits of the quadrature encoding discussed previously!
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This section is the first time we have tried to get information from the encoders,
    and issues may occur. Try these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: If the data values are not changing, check the wiring carefully.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If only 1 bit is changing, 1 encoder wire may be incorrect.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have data, but the PIO can work harder to decode this and count it for us.
    Next, let's look at these PIO instructions and how they interact with registers.
  prefs: []
  type: TYPE_NORMAL
- en: PIO instructions and registers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Understanding how registers are changed and manipulated by PIO instructions
    is crucial to writing and understanding PIO code. The PIO has nine instruction
    types; however, they have several modes, making their use nuanced and complex.
    [*Chapter 3*](B18001_03.xhtml#_idTextAnchor055) of the *RP2040 datasheet* from
    Raspberry Pi serves as a comprehensive reference. We can get familiar with a few
    more here.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging a register
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This next example shows how to store a value in a register and surface it to
    code for printing. We keep the imports as before. Call this file `pio_debugging_registers.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This code uses the `set` instruction, which can put any value less than 32 (5
    bits) into a register. In the example, we store it in the `y` register.
  prefs: []
  type: TYPE_NORMAL
- en: The following line is `mov isr, y`, which copies the right (`y`) register data
    into the ISR. We must store a value in the `push` statement, putting it into a
    FIFO queue.
  prefs: []
  type: TYPE_NORMAL
- en: 'We assemble this and send it to the state machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then pull this data from the FIFO queue and examine the content as decimal
    and binary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This code will run and simply pass the number 21 through the system. Because
    I know the value is low, I have formatted it with 32 leading 0s. Therefore, the
    output should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This feature is handy, and we can use this code with different assemblers as
    a template to test out PIO assembly techniques. We can start by looking at manipulating
    bits in registers.
  prefs: []
  type: TYPE_NORMAL
- en: Bit manipulations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When dealing with registers, we may want to manipulate their content. For example,
    we may want to move bits around, shift them, reverse their order, or flip them
    wholesale. The following diagram shows these operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.6 – PIO bit operations ](img/Figure_6.06_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.6 – PIO bit operations
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 6**.6* shows these frequent operations pictorially. The tables show
    the state of registers as bits, with the register name on the left. The diagram
    shows assembler instructions with their effect on the bits highlighted.'
  prefs: []
  type: TYPE_NORMAL
- en: We have already talked a lot about bit shifting into the ISR. When we use the
    `in` instruction, it makes space for the number of bits to shift in, discarding
    bits at the end. It then copies the new bits into the space. Code can alter this
    shift direction with `StateMachine` parameters, but the operation is essentially
    the same. The example for shifting uses `in` to read the `C1` and `C2` pins from
    our encoder. However, as well as pins, the source can be other registers or null
    to copy in zeros. This operation does not alter the source.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can `::` operation in `mov`; this can be useful to get to bits at the other
    end. The following assembler demonstrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use this example in the same Python code shown in the preceding debug
    registers example. Note that we reverse the `y` register right into the ISR. As
    the code gets more complicated, combining operations like this will be critical,
    as with only 32 instructions, every instruction counts! The output of that code
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '`not` operation. It replaces every bit with its logical opposite – 1s become
    0s and 0s become 1s. If we represent signed numbers with our 32-bit words, this
    will make them negative. Try this assembler code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This code is exactly like the preceding example, producing the inverted result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We can modify our buffer to see how a value becomes negative too. Change the
    array format to a lowercase `i`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'When running this, we can see what the output is like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The binary makes less sense, but we can see that the decimal number is the negative
    plus one. Inverting again gets back to the original number.
  prefs: []
  type: TYPE_NORMAL
- en: Extracting the value of a single bit
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One more thing to do is to combine operations so that we can extract a specific
    bit using a couple of bit shifts. The following diagram shows the operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.7 – Extracting a bit ](img/Figure_6.07_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.7 – Extracting a bit
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us imagine our value starts in `x`; I’ve shaded the bit we want darker
    than the rest. The assembly snippet for this is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The first instruction shifts the bits up to the one we want into the ISR. The
    diagram shows that the bit we want is now leftmost in the ISR. However, as we
    do not want anything to the right of this bit, we use the `in` instruction to
    shift in 31 zeros from `null`. This shift pushes all the other bits away – so
    we have only 0s and the bit we want.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll put this to real use with the OSR instead. Put the following code in
    `extract_a_bit.py`. We start with imports and a variable to tweak the behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember that we store the assembler code in a Python string, so we can perform
    Python string formatting on it with an f-string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Since we cannot use the `set` instruction with values higher than 5 bits, we
    start by pulling data to read, which goes into the OSR.
  prefs: []
  type: TYPE_NORMAL
- en: We then use `in` to shift the bits up to the bit we want to extract, using the
    f-string to substitute the variable here. The bit to extract must be 32 or less.
    The result is in the ISR. We perform a further `in` operation from `null`, using
    0s to drop all but the bit we wanted. Since this result is already on the ISR,
    we can use `push` to send it to the FIFO queue.
  prefs: []
  type: TYPE_NORMAL
- en: 'The remaining code handles assembling this, sending the data, and printing
    the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The result from running this should be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: If we want to use this data for conditional logic, we could use the `jmp` instruction,
    requiring us to use the `mov` instruction to move the data into `x` or `y` scratch
    registers.
  prefs: []
  type: TYPE_NORMAL
- en: Making a counter with PIO
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Counting requires us to be able to add or subtract from a register. We’ll start
    with counting down, as that is easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'At first glance, the datasheet shows no arithmetic instructions in the PIO
    instruction set. So how do we add or subtract? Although we have not used it yet,
    the `jmp` instruction in PIO assembler usually jumps to a label somewhere else
    in our assembler instructions. However, it has a trick – it can subtract from
    a scratch register. We can exploit this side effect to perform simple arithmetic
    for us. Using `pio_debugging_registers.py` as a template, try switching out the
    assembler for the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: I put this with the template in `pio_counting_down.py`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sending it to Pico and running it gives the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Hurrah – we can subtract! We have used a `fake:` label for the subtraction because
    we don’t want to jump anywhere, just perform the arithmetic.
  prefs: []
  type: TYPE_NORMAL
- en: What about adding? This is trickier, but if you recall the bit invert, the number
    flipped from positive to negative. We can exploit this by subtracting 1 and flipping
    it again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use this assembler (in `pio_counting_up.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We still have our fake label, but we flip the `y` value into itself first and
    then flip it again when putting it into the ISR. The output of running this is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: You have seen techniques for working with the PIO, how to read data from pins,
    extract information from it, and perform arithmetic. We have building blocks.
    The following section will see us use them to decode information from the encoder
    pins into a counter.
  prefs: []
  type: TYPE_NORMAL
- en: Measuring encoder count for movement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We know what sequences to expect for our encoder, and we have a working knowledge
    of PIO assembler. So, we can bring these together to create the counter. We’ll
    start simple though; let’s see how to detect when a system has changed.
  prefs: []
  type: TYPE_NORMAL
- en: Making a simple PIO change detection loop
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we saw in the read two pins example, when we output the system’s state in
    a tight loop, it floods off anything interesting. We are interested in state changes,
    a step toward the full decoder. In the `pio_one_encoder_when_changed.py` file,
    we go straight from imports into the assembler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We start by clearing `y –`; we are going to use `y` to store a pin value for
    comparison:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code creates a `read` label; we can loop to this point to get
    new pin readings. It stores the old `y` in x so that we can get a new value. Shifting
    `in null, 32` will fill the ISR with zeros, clearing it. We can then get two pins
    in the ISR:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We want to compare our new value in the ISR with our old value, now in `x`.
    However, `jmp` cannot use the ISR for comparisons, so we first copy the ISR into
    `y`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: As the code shows, we can now use `jmp x!=y` to jump somewhere else when the
    register values are different – to a label named `different`. If we do not find
    them different, we loop back to `read` to try a fresh sample from the pins with
    the unconditional `jmp`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see the code in the `different` label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Although we copied the ISR to `y`, it is still in the ISR so that we can push
    this value, the new changed value, out to the Python code and then jump back around
    to read it again. So, the total effect is that it will spin reading values and,
    if they are different, push them to the Python code and then go back to spinning
    in the `read` loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us continue the Python code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The last half assembles our code and creates a state machine with it, using
    a higher frequency. It sets the state machine to use GP20 as the first input pin.
    Then, it uses `in_pin_count` to set a range of two input pins, matching one of
    the encoders. It then reads data into a buffer and prints it in a loop. The `sm.readinto`
    method waits until there is data, so the Python code only prints when there is
    a change. Try rotating the wheels slowly, and you should see the output change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: We can see the encoder output, and only when it changes. We could just count
    the changes, but our system should count in different directions depending on
    the wheel movement. Let's write code to check this.
  prefs: []
  type: TYPE_NORMAL
- en: Making a bidirectional counter with PIO
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can detect when our sensor is in a new state and store that in `y`, with
    an old state in `x` for comparison. We also need to store a counter, and since
    we aren’t using it, the OSR will suffice. We’ll jump right into the assembler,
    since the imports don’t change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, beyond setting up the OSR, this starts the same as the previous
    example. However, where things are different, we need to be more innovative. Comparing
    the 2 bits with the previous 2 bits is tricky in assembler, and we have a 32-instruction
    limit. What we are trying to evaluate is the sequences in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.8 – Quadrature encoding sequence ](img/Figure_6.08_B18001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.8 – Quadrature encoding sequence
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 6**.8* shows the sequence for encoder signals. Each pair of numbers
    shows the sensor states. A jump from **00** to **10** suggests the encoder is
    going clockwise, and from **00** to **01** is anticlockwise; we can follow the
    sequence around in either direction.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can evaluate an old reading and a new reading with the following conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: If the first bit of the old reading is 0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And the current second bit is 1
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Then it is going anticlockwise
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Else, the current second bit is 0
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It is going clockwise
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If the first bit of the old reading is 1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And the current second bit is 1
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It is going clockwise
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Else, the current second bit is 0
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It is going anticlockwise
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This logic can boil down to a few instructions in the assembler. First, we
    can isolate the bit we want in the `x` register (the old reading) and compare
    that to zero, jumping on the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Note that this uses the preceding bit extraction method; bit 31 would be the
    first pin (`C1`) read in. We now have the old `C1` value in `x`, padded with 0s.
    If the `x` register is zero, the `jmp !x` instruction will jump to the `c1_old_zero`
    label. Otherwise, it will fall through.
  prefs: []
  type: TYPE_NORMAL
- en: 'For clarity, we will start the fall-through section with the `c1_old_non_zero`
    label; this is just a comment, though:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: At this point, we test a pin. We’ll see later that we can set `jmp_pin` when
    creating the state machine, and we’ll set it to the `C2` pin for an encoder, so
    this will have the current second pin in it. The `jmp pin, count_up` instruction
    will jump to the `count_up` label if the current state of the pin is 1\. Otherwise,
    we unconditionally jump to `count_down`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for when `C1` is zero is the opposite:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'However, I am being sneaky – instead of the unconditional jump, the next code
    section will be `count_up`, so we can skip it and save an instruction. `count_up`
    is adding 1, as we’ve seen before, with the twist that the original value is on
    the OSR:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: We invert the OSR into `x`, use jmp to jump to a fake label, subtract 1 from
    `x`, and then invert `x` back. Finally, this code jumps to send the data, with
    the new count now in `x`.
  prefs: []
  type: TYPE_NORMAL
- en: '`count_down` is a little simpler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This code puts the OSR in `x` and subtracts 1 from it, jumping directly to send.
    Regardless of the value of `x`, the `send` part labels the next instruction anyway.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `send` part is just pushing this all back and storing the new value back
    in the OSR:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The final instruction loops back to `read` to recheck the sensor. There is a
    `wrap` directive in other PIO dialects that would save an instruction here; however,
    CircuitPython PIOASM does not implement this at the time of writing.
  prefs: []
  type: TYPE_NORMAL
- en: That was a lot of assembler language. This example is in the chapter repo as
    `pio_encoder_counting.py`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need a little more Python code to assemble the instructions, run it, and
    get the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Here, we create two state machines from the same code! We pass C1 to the state
    machine as the first input pin, and `C2` to the state machine as `jmp_pin`, for
    each encoder based on *Figure 6**.4*. We have also set `frequency=0`, which tells
    the state machine to go at full speed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can still use one buffer to read the two state machines alternately. However,
    this buffer needs to be type `i` (lowercase) to use signed numbers and count negatively.
    We also will make two variables to hold the left and right wheel states:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'In our main loop, we can start with the left sensor, check whether there is
    data waiting in the RX FIFO queue with `.in_waiting`, and print both sides if
    there is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that there is no special format now; we are just printing the raw number
    of counts. The right side is the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run this, you should be able to turn either wheel and see output like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: We can now count pulses for both wheels. So, if you make a complete wheel revolution,
    you should land close to plus or minus 8344 – proving our previous calculation.
  prefs: []
  type: TYPE_NORMAL
- en: You will see that one wheel makes the count go backward. Each motor effectively
    turns in an opposite direction from the encoder’s perspective. We will account
    for this later.
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This example is a lot of code and could go wrong in various ways:'
  prefs: []
  type: TYPE_NORMAL
- en: If the code counts up/down randomly and not consistently, you may need to change
    `jmp_pin` to the other input pin.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It could also mean you have missed putting `x` in `isr` before sending.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check against the source code from git.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You should now be up and running and getting counts.
  prefs: []
  type: TYPE_NORMAL
- en: Making reusable encoder code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Because we will reuse this, we will put it into a module and pick it up in our
    `robot.py`. We will then use this to make a demonstration program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take what we made previously and put it into a module named `pio_encoder.py`.
    The following code should all be familiar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'We need a way to create the state machines with their parameters and a wrapper
    for getting the data. A Python class is an excellent way to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: We will call it `QuadratureEncoder`, as it should work with those types regardless
    of the mechanism. Inside the class is an `__init__` function, which tells Python
    how to make an encoder object – it takes two pins as its parameters and uses them
    to create the state machine. The object also makes a buffer to store the most
    recent return value. Note that the two pins must be in sequence.
  prefs: []
  type: TYPE_NORMAL
- en: There’s also a reversed parameter; this is so we can account for one motor turning
    the opposite way. We cannot just swap pins in the code here, as the `in` instruction
    requires pins in sequence.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need a method to read from the encoder or the old value if there’s
    no change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: By checking the `in_waiting` state, this reading will not block and only update
    the buffer if there’s a new reading; this is a `while` loop because we only want
    the most recent FIFO data. It returns the element in the buffer, returning the
    negative version if the motor is reversed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now add these encoders to the `robot.py` library from the end of [*Chapter
    5*](B18001_05.xhtml#_idTextAnchor098), *Driving Motors with Raspberry Pi Pico*.
    Let''s add encoders to the imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The new code is highlighted. We can also set up the two encoders. Add the bold
    code after the motors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: When we use our robot, we can now use `robot.left_encoder.read()` and an equivalent
    command for the right encoder to get an encoder reading, which we will now use
    in a demonstration.
  prefs: []
  type: TYPE_NORMAL
- en: Measure counts for a known time
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will turn this into a demonstration to see what the count is when driving
    for a second. Because we have put work into preparing our `robot.py`, this code
    is simple. Put the following code in `measure_fixed_time.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: This code loads the `time` library and the `robot` helper. It drives forward
    at 0.8 speed for 1 second. It then stops and prints readings from each encoder.
    While this code sleeps, the encoder code is still running.
  prefs: []
  type: TYPE_NORMAL
- en: Making the encoders this simple to use means we can integrate them with more
    complex behaviors later; this is a good strategy for most sensors.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run this code, be sure to send the `pio_encoders.py` library, the updated
    `robot.py`, and then `measure_fixed_time.py`. Remember to update `code.py` to
    load it, and you should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: You have begun to take sensor readings from your robot, learning PIO on the
    way!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you have learned about measuring distance traveled using encoders,
    including the different types of encoders.
  prefs: []
  type: TYPE_NORMAL
- en: You saw the output that quadrature encoders create and how to interpret this
    as a turning direction.
  prefs: []
  type: TYPE_NORMAL
- en: You were introduced to the powerful PIO state machines present within Pico and
    saw how you can give tasks such as handling encoders to them.
  prefs: []
  type: TYPE_NORMAL
- en: You brought this together to create a reusable handler for the encoders, and
    we had a demonstration to see them working.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will plan and buy more devices for our robot, leading
    to more sensing, and remotely drive it.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These exercises can improve your robot and let you practice your skills:'
  prefs: []
  type: TYPE_NORMAL
- en: You have been able to get readings and a count for each wheel when driving for
    a fixed time. How could you make code that stops the motors after a fixed number
    of counts? You may need to check the encoder readings in a loop regularly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You may have noticed imbalances in the counts – this is normal and due to motor
    and wheel differences. One way you could improve this would be to design and make
    a holder for the breadboard with the styrene rod so that it doesn’t slide around
    on the platform.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Could you write code to slow a motor if it’s overtaken another one in its count?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These further reading items will help you continue your studies:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Raspberry Pi has the definitive reference in [*Chapter 3*](B18001_03.xhtml#_idTextAnchor055)
    of their datasheet on using PIO and its architecture: [https://datasheets.raspberrypi.com/rp2040/rp2040-datasheet.pdf](https://datasheets.raspberrypi.com/rp2040/rp2040-datasheet.pdf).
    They also have PIO code examples in [*Chapter 3*](B18001_03.xhtml#_idTextAnchor055)
    of their C SDK document (including MicroPython but not CircuitPython samples):
    [https://datasheets.raspberrypi.com/pico/raspberry-pi-pico-c-sdk.pdf](https://datasheets.raspberrypi.com/pico/raspberry-pi-pico-c-sdk.pdf).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adafruit documentation for `rp2pio` is at [https://circuitpython.readthedocs.io/en/latest/shared-bindings/rp2pio/](https://circuitpython.readthedocs.io/en/latest/shared-bindings/rp2pio/)
    and is worth consulting for its use, along with their *Introduction to CircuitPython
    RP2040 PIO* at [https://learn.adafruit.com/intro-to-rp2040-pio-with-circuitpython](https://learn.adafruit.com/intro-to-rp2040-pio-with-circuitpython).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A video by YouTuber StackSmasher has a great deep dive into PIO, its architecture,
    and programming at [https://youtu.be/yYnQYF_Xa8g](https://youtu.be/yYnQYF_Xa8g).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
