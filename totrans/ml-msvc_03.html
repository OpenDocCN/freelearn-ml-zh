<html><head></head><body>
		<div id="_idContainer046">
			<h1 id="_idParaDest-40" class="chapter-number"><a id="_idTextAnchor039"/>3</h1>
			<h1 id="_idParaDest-41"><a id="_idTextAnchor040"/>Solving Common MSA Enterprise System Challenges</h1>
			<p>In the previous chapter, we learned how to decompose the monolith and refactor it into an MSA enterprise system. We built a simplified system as an example and then refactored the system to demonstrate this process. By doing so, we resolved some of the challenges of running a monolithic system. However, moving toward MSA introduces a completely different set of issues that need to <span class="No-Break">be addressed.</span></p>
			<p>In this chapter, we will discuss the main challenges introduced in MSA, how to address them, and what specific methodologies we need to apply to maintain the MSA system’s reliability, durability, and <span class="No-Break">smooth operation.</span></p>
			<p>We will cover the following topics in <span class="No-Break">this chapter:</span></p>
			<ul>
				<li>MSA system isolation using an Anti-Corruption <span class="No-Break">Layer (ACL)</span></li>
				<li><span class="No-Break">API gateways</span></li>
				<li>Service catalogs <span class="No-Break">and orchestrators</span></li>
				<li><span class="No-Break">Microservices aggregators</span></li>
				<li>Microservices <span class="No-Break">circuit breaker</span></li>
				<li>Gateways versus orchestrators <span class="No-Break">versus aggregators</span></li>
				<li><span class="No-Break">ABC-MSA enhancements</span></li>
			</ul>
			<h1 id="_idParaDest-42"><a id="_idTextAnchor041"/>MSA isolation using an ACL</h1>
			<p>When adopting MSA <a id="_idIndexMarker094"/>in a brownfield, your migration from the <a id="_idIndexMarker095"/>monolithic system to MSA can either be done as a <strong class="bold">big bang migration</strong> or <span class="No-Break"><strong class="bold">trickle migration</strong></span><span class="No-Break">.</span></p>
			<p>In big bang migration, you keep the old monolith system running as-is while building the entire MSA system. Once the <a id="_idIndexMarker096"/>MSA system has been completed, tested, and deployed, you can then completely switch to the new MSA system during your <a id="_idIndexMarker097"/>organization’s maintenance window, then decommission the old monolith. This type of migration, although usable for some scenarios, is usually not recommended in the case of large <span class="No-Break">enterprise systems.</span></p>
			<p>Switching users from the old to the new system should be done during the corporate’s off-peak hours or the corporate’s standard migration window. And the sudden switch of users can be a complex and cumbersome process due to the high potential for downtime, potential rollbacks, and risks of unexpected results when applying real traffic to the new system, all of which can impose large time constraints during the <span class="No-Break">migration window.</span></p>
			<p>A common and safer migration approach in our case is trickle migration, where you perform a gradual <a id="_idIndexMarker098"/>shift from the old monolithic system to the new MSA <a id="_idIndexMarker099"/>system. A common way of doing that is by gradually extracting functions, services, and/or modules out of your monolith and moving them into standalone microservices as part of your new MSA. Gradually, we phase out the existing monolith’s functions and build an MSA system piece <span class="No-Break">by piece.</span></p>
			<p>To successfully perform a tickle migration, you need what’s called an <strong class="bold">Anti-Corruption Layer</strong> (<strong class="bold">ACL</strong>), which will act as an intermediate layer, a buffer, and a gateway between the old, messy <a id="_idIndexMarker100"/>monolith and your new clean MSA. The ACL layer will help temporarily integrate and glue the new extracted services back into the old system, to be able to communicate with old services, databases, and modules without fouling your new MSA system. You can see the ACL architecture in the <span class="No-Break">following diagram:</span></p>
			<div>
				<div id="_idContainer034" class="IMG---Figure">
					<img src="image/B18934_03_1.jpg" alt="Figure 3.1: Anti-Corruption Layer (ACL)"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.1: Anti-Corruption Layer (ACL)</p>
			<p>The ACL lifespan is as long as the monolith system’s lifespan. Once the migration has been completed <a id="_idIndexMarker101"/>and the monolith has been decommissioned, the ACL will <a id="_idIndexMarker102"/>no longer be needed. Therefore, it is recommended that you have the ACL written either as a standalone service or as part of <span class="No-Break">the monolith.</span></p>
			<p>The ACL has three <span class="No-Break">main components:</span></p>
			<ul>
				<li>The API component, which <a id="_idIndexMarker103"/>allows the ACL to communicate with the MSA system using the same language as the <span class="No-Break">MSA system.</span></li>
				<li><strong class="bold">The ACL Facade</strong>, which is the <a id="_idIndexMarker104"/>interface that enables the ACL to talk to the monolith using the <span class="No-Break">monolith’s language(s).</span></li>
			</ul>
			<p>There are two options where the Facade can be placed; one is shown in <span class="No-Break"><em class="italic">Figure 3</em></span><em class="italic">.1</em>, where the Facade has been placed as part of the new standalone ACL microservice. The other option is placing the Facade as a component within the monolith, as shown in <span class="No-Break"><em class="italic">Figure 3</em></span><span class="No-Break"><em class="italic">.2</em></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer035" class="IMG---Figure">
					<img src="image/B18934_03_2.jpg" alt="Figure 3.2: The Facade’s two implementation options"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.2: The Facade’s two implementation options</p>
			<p>The choice would depend on the architects’ and developers’ preference regarding whether they would like to add more glue code inside the monolith itself, or completely isolate any development effort away from <span class="No-Break">the monolith.</span></p>
			<ul>
				<li><strong class="bold">The ACL Adapter</strong>, which is a part of the ACL, works between the ACL’s northbound API and the <a id="_idIndexMarker105"/>Facade. The main <a id="_idIndexMarker106"/>function of the Adapter is to translate <a id="_idIndexMarker107"/>between the monolith and the MSA using the <strong class="bold">ACL Translator</strong> interface, as shown in <span class="No-Break"><em class="italic">Figure 3</em></span><span class="No-Break"><em class="italic">.1</em></span><span class="No-Break">.</span></li>
			</ul>
			<p>ACL is only needed when a trickle migration is adopted. There is no need for implementing an ACL in the big bang migration case. And since, between both migration styles, there are <a id="_idIndexMarker108"/>resources to be consumed, as well as advantages, risks, <a id="_idIndexMarker109"/>and tradeoffs, MSA project stakeholders will need to decide on which style is more suitable for the project and <span class="No-Break">the organization.</span></p>
			<p>Whether an ACL is implemented or not, MSA systems would still need a component to act as an interface between the MSA system and external clients. Using an API gateway between the MSA and external API calls is considered a good MSA design practice. The next section discusses the roles of the API gateway in MSA systems, and the tradeoffs of having to adopt an API gateway in <span class="No-Break">MSA design.</span></p>
			<h1 id="_idParaDest-43"><a id="_idTextAnchor042"/>Using an API gateway</h1>
			<p>As we explained in <a href="B18934_01.xhtml#_idTextAnchor014"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, microservices can communicate directly with each other without the need for <a id="_idIndexMarker110"/>a centralized manager. As the MSA system becomes more mature, the number of microservices gradually increases, and direct communication between microservices can become a large overhead – especially with calls that need multiple round trips between the API consumer and the <span class="No-Break">API provider.</span></p>
			<p>With the microservices’ autonomy principle, each microservice can use its technology stack and may communicate with a different API contract than the other microservices in the same MSA system. One microservice, for example, may only understand a RESTful API with a JSON data structure, while others may only communicate with Thrift <span class="No-Break">or Avro.</span></p>
			<p>Moreover, the location (IP and listening port) of the active instantiated microservices change dynamically within the MSA system. Therefore, the system will need to have a mechanism to identify the location at which the API consumer can point its <span class="No-Break">calls towards.</span></p>
			<p>There are also situations where you need to tie in your MSA system to legacy systems such as the mainframe, AS400, <span class="No-Break">and more.</span></p>
			<p>All of the previous situations require code to be embedded in each microservice in the MSA system. This code will help the microservices understand the legacy and non-REST communication patterns, discover the network location of other microservices in the system, and understand each microservice’s needs in general. Now, how independent and portable would such a set of <span class="No-Break">microservices be?</span></p>
			<p>A better approach to addressing the preceding challenges is to use an API gateway where all system services talk to each other through that gateway. The API gateway receives API calls from the system’s API consumers, then maps the data received into a data structure and a protocol that API providers can understand <span class="No-Break">and process:</span></p>
			<p class="IMG---Figure"> </p>
			<div>
				<div id="_idContainer036" class="IMG---Figure">
					<img src="image/B18934_03_3.jpg" alt="Figure 3.3: Moving from services direct communication to API gateway communication"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.3: Moving from services direct communication to API gateway communication</p>
			<p>With the API gateway, we significantly reduce direct 1-to-1 communication between services. Moreover, we offload the system’s microservices from having multiple translations, mapping code, and <strong class="bold">Authentication-Authorization-Accounting</strong> (<strong class="bold">AAA</strong>) tasks. Rather, we <a id="_idIndexMarker111"/>move the responsibility of <a id="_idIndexMarker112"/>discovering the location of microservices from the client to the API gateway, which, in turn, further reduces the code overhead and renders microservices as light and independent <span class="No-Break">as possible.</span></p>
			<p class="callout-heading">Important note</p>
			<p class="callout">The MSA system’s availability is as good as the API gateway’s availability. Therefore, it is necessary for the API gateway to be developed, deployed, and managed as a high-performance and highly available <span class="No-Break">mission-critical service.</span></p>
			<p>The API gateway can be deployed as a standalone service that’s part of the MSA system. The main functions of the gateway are <span class="No-Break">as follows:</span></p>
			<ul>
				<li>Minimize <a id="_idIndexMarker113"/>the API calls between microservices, which makes MSA inter-service communication much <span class="No-Break">more efficient.</span></li>
				<li>Minimize API dependencies and breaking changes. In an MSA system with no API gateway, if, for whatever reason, one of the API providers changes its API, a breaking change will likely happen. This means we will need to create a change in every microservice communicating with the API provider. By using an API gateway, a change in the API provider will be limited to the API gateway only, to match the API contract between the provider and <span class="No-Break">the consumers.</span></li>
				<li>Translate and map between API contracts, which offloads the microservices from embedding translation code in their <span class="No-Break">core function.</span></li>
				<li>Run a service discovery mechanism and offload clients from running <span class="No-Break">that function.</span></li>
				<li>Act as the entry point to the MSA system’s external <span class="No-Break">client calls.</span></li>
				<li>Load-balance API calls across the different instances of high-availability microservices, and offload microservices in <span class="No-Break">high-traffic situations.</span></li>
				<li>Offer <a id="_idIndexMarker114"/>better security by throttling sudden increases in API calls during <strong class="bold">Distributed Denial of Service</strong> (<strong class="bold">DDoS</strong>) and <span class="No-Break">similar attacks.</span></li>
				<li>Authenticate <a id="_idIndexMarker115"/>and authorize users to access different components in the <span class="No-Break">MSA system.</span></li>
				<li>Provide comprehensive analytics to provide deep insights into system metrics and logs, which can help further enhance system design <span class="No-Break">and performance.</span></li>
			</ul>
			<p>Despite all these advantages and functions of the API gateway, there are still some drawbacks to having an API gateway in your <span class="No-Break">MSA system:</span></p>
			<ul>
				<li>The most obvious is complexity. The more protocols and API contract data structures we <a id="_idIndexMarker116"/>have in the system, the more complex the <span class="No-Break">gateway becomes.</span></li>
				<li>The MSA’s operation is highly dependent on the API gateway’s performance and availability, which may create an unwanted system <span class="No-Break">performance bottleneck.</span></li>
				<li>Introducing an additional intermediary component such as an API gateway in the path of intra-microservice communication increases service response time. And with chatty services, the increased response time can <span class="No-Break">become considerable.</span></li>
			</ul>
			<p>Even with all the functions the API gateway provides, we still need a way to map each user request to <a id="_idIndexMarker117"/>specific tasks that the MSA system would need to run to fulfill that request. In the next section, we’ll discuss how the MSA system tasks are mapped to specific user services, and how these tasks are orchestrated <span class="No-Break">in MSA.</span></p>
			<h1 id="_idParaDest-44"><a id="_idTextAnchor043"/>Service catalogs and orchestrators</h1>
			<p>Orchestration is one of <a id="_idIndexMarker118"/>the most commonly used communication patterns in MSA systems. We briefly discussed this concept in <a href="B18934_01.xhtml#_idTextAnchor014"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>. In this section, we will dive into more details <span class="No-Break">about orchestration.</span></p>
			<p>Determining the most appropriate communication pattern between the different microservices depends on many factors. Among the factors that will help determine whether choreography or orchestration is the most suited communication pattern for the system, you must consider the number of microservices you have in the system, the level of interactions between the different microservices, the business logic itself, how dynamic business requirements change, and how dynamic system <span class="No-Break">updates are.</span></p>
			<p>Orchestrators act as the central managers controlling all communication between the system’s microservices. They <a id="_idIndexMarker119"/>usually interact with the users through a dashboard interface that contains all service catalogs. The <strong class="bold">Service Catalog</strong> is a set of <a id="_idIndexMarker120"/>services the MSA system offers to users. Each service in the catalog is linked to a set of workflows. <strong class="bold">Workflows</strong> are the actions the orchestrator will trigger and <a id="_idIndexMarker121"/>coordinate between the system’s microservices to deliver the service the user selected from <span class="No-Break">the catalog:</span></p>
			<div>
				<div id="_idContainer037" class="IMG---Figure">
					<img src="image/B18934_03_4.jpg" alt="Figure 3.4: Orchestrators in MSA"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.4: Orchestrators in MSA</p>
			<p>The orchestrator’s functions can be extended beyond managing workflows. Orchestrators can also manage the entire life cycle of microservices; this involves provisioning and deploying microservices, configuring the microservice, and performing upgrades, updates, monitoring, performance audits, and shutdowns <span class="No-Break">when needed.</span></p>
			<p class="callout-heading">Important note</p>
			<p class="callout">The orchestrator is the main brain of the MSA system, and it is imperative to have the orchestrator <a id="_idIndexMarker122"/>deployed and managed as a high-performing and mission-critical component of the <span class="No-Break">MSA system.</span></p>
			<p>Some of the benefits of <a id="_idIndexMarker123"/>running an orchestrator in MSA include <span class="No-Break">the following:</span></p>
			<ul>
				<li>You have a centralized management platform as a single source of truth for all of your workflows. Thus, you can build complex workflows in a complex MSA without having to worry about how many microservices you have and how they <span class="No-Break">can scale.</span></li>
				<li>As in the API gateway, you can tie in your legacy systems or part of your old monolith and completely isolate your microservices from having to couple with any other system component. This saves a lot of effort having to build code into the independent microservices and tremendously helps in scaling <span class="No-Break">your MSA.</span></li>
				<li>Microservices are visible to the orchestrator and hence can be completely managed, audited, and monitored by the orchestrator. This can produce very helpful and insightful analytics that can further enhance the MSA system’s supportability <span class="No-Break">and operations.</span></li>
				<li>The orchestrator’s visibility can help in troubleshooting any operational issues and identifying <span class="No-Break">problems quickly.</span></li>
				<li>Orchestrators can automatically detect and self-resolute some of the operational problems. Orchestrators can, for example, detect resource starvation and reroute requests to a backup microservice. Orchestrators can automatically vertically or horizontally scale a particular microservice when a problem is detected. Orchestrators can also try to automatically restart the service if the service is <span class="No-Break">not responding.</span></li>
			</ul>
			<p>The orchestrator solves many of the MSA operational problems, including some of the data synchronization <a id="_idIndexMarker124"/>challenges. When scaling the system, however, data synchronization and data consistency become a big challenge for the orchestrator to address by itself. Microservices aggregators help address data synchronization issues when the MSA system scales. In the next section, we will discuss what the aggregator pattern is, what it is used for, and how <span class="No-Break">it works.</span></p>
			<h1 id="_idParaDest-45"><a id="_idTextAnchor044"/>Microservices aggregators</h1>
			<p>In <a href="B18934_02.xhtml#_idTextAnchor028"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, we had to copy some schemas across multiple microservices and use saga patterns through <a id="_idIndexMarker125"/>the orchestrator to keep data consistent and preserve the microservice’s autonomy. This solution may be viable in a situation if you have a limited number of microservices within the MSA system. In a large number of microservices systems, copying schemas across different microservices to maintain the synchronization of the individual microservices database doesn’t scale well and can severely impact the system’s <span class="No-Break">overall performance.</span></p>
			<p>Consider an MSA system with 100 microservices and copy schemas across about 20 of those microservices to maintain the microservice’s autonomy. Each time any part of any of the schema’s data is updated, the orchestrator will have to sync those <span class="No-Break">20 schemas.</span></p>
			<p>Moreover, even if we have all 100 microservices perfectly autonomous, what if one of the user’s operations needs to gather information from those 20 microservices? The orchestrator will have to issue at least 20 different API calls to 20 different microservices to get the information the user is looking for. Not to mention that some of these 20 microservices may need to exchange multiple API calls to send the result back to <span class="No-Break">the user.</span></p>
			<p>To put things into perspective, let’s revisit the ABC-MSA system we built in <a href="B18934_02.xhtml#_idTextAnchor028"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>. We have the <strong class="source-inline">order</strong>, <strong class="source-inline">product</strong>, and <strong class="source-inline">inventory</strong> microservices. The <strong class="source-inline">product</strong> microservice is for managing product information, the <strong class="source-inline">inventory</strong> microservice is for managing the product inventory, and the <strong class="source-inline">order</strong> microservice is for placing and <span class="No-Break">managing orders.</span></p>
			<p>Let’s assume we’re in a situation where a sales analyst is generating a report to check a product’s average quantity purchased per order and the product’s inventory level at the time at which the order was placed, as shown in the <span class="No-Break">following diagram:</span></p>
			<div>
				<div id="_idContainer038" class="IMG---Figure">
					<img src="image/B18934_03_5.jpg" alt="Figure 3.5: A sample product order report"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.5: A sample product order report</p>
			<p>The orchestrator <a id="_idIndexMarker126"/>will have to send at least three API calls, one to each of the <strong class="source-inline">order</strong>, <strong class="source-inline">product</strong>, and <strong class="source-inline">inventory</strong> microservices, as shown in the <span class="No-Break">following diagram:</span></p>
			<div>
				<div id="_idContainer039" class="IMG---Figure">
					<img src="image/B18934_03_6.jpg" alt="Figure 3.6: A user operation spanning multiple microservices"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.6: A user operation spanning multiple microservices</p>
			<p>To minimize dependencies and response time, a better approach for this particular situation is to use an <strong class="bold">aggregator</strong>. This aggregator will collect the different pieces of data from <a id="_idIndexMarker127"/>all <strong class="source-inline">order</strong>, <strong class="source-inline">product</strong>, and <strong class="source-inline">inventory</strong> microservices and update its database with the <span class="No-Break">combined information.</span></p>
			<p>The API gateway or consumer will only need to send one API call to the aggregator to get all the information <a id="_idIndexMarker128"/>it needs. The number of API calls is minimized and the overall response time is greatly reduced, especially in cases where the information req<a id="_idTextAnchor045"/>uired is distributed across a large number <span class="No-Break">of microservices:</span></p>
			<div>
				<div id="_idContainer040" class="IMG---Figure">
					<img src="image/B18934_03_7.jpg" alt="Figure 3.7: An aggregator communication pattern"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.7: An aggregator communication pattern</p>
			<p>The aggregator communication pattern reduces the number of API calls users could trigger in <a id="_idIndexMarker129"/>various operational requests and further enhances the data synchronization’s design and performance, as <a id="_idIndexMarker130"/>well as the overall system performance, especially in <span class="No-Break">high-latency networks.</span></p>
			<p>Now, we know the roles of the API gateway, the orchestrator, and the aggregator. In the next section, we will discuss how all these three components interact with each other in <span class="No-Break">the MSA.</span></p>
			<h1 id="_idParaDest-46"><a id="_idTextAnchor046"/>Gateways versus orchestrators versus aggregators</h1>
			<p>From what we <a id="_idIndexMarker131"/>have described so far, there are some overlapping <a id="_idIndexMarker132"/>functions between the API gateway, the <a id="_idIndexMarker133"/>orchestrator, and the aggregator. In this section, we will answer some of the fundamental questions regarding how all three components interact in a single <span class="No-Break">MSA system:</span></p>
			<ul>
				<li>How do these three MSA components <span class="No-Break">work together?</span></li>
				<li>Can an API gateway perform the aggregator and <span class="No-Break">orchestrator functions?</span></li>
				<li>What are the best practices for deploying all these communication patterns in <span class="No-Break">our MSA?</span></li>
			</ul>
			<p>First of all, theoretically <a id="_idIndexMarker134"/>speaking, you can have clients interact <a id="_idIndexMarker135"/>with the MSA microservices directly without <a id="_idIndexMarker136"/>an API gateway. However, this would not be a good practice. By having no gateway in your MSA system, you would need to have most of the gateway functions implemented within each microservice you have in <span class="No-Break">the system.</span></p>
			<p>To keep microservices as light and autonomous as possible, it is highly recommended to have an API gateway <a id="_idIndexMarker137"/>in your MSA system. The API gateway will <a id="_idIndexMarker138"/>handle all ingress and egress API traffic from the <a id="_idIndexMarker139"/>different types of clients. Clients can be a web dashboard, a mobile application, a tablet, a third-party integration system, and <span class="No-Break">so on.</span></p>
			<p>Whether you add an aggregator or not will highly depend on your business logic and system design. You will only need aggregators if you have client use cases where requests need to span across multiple microservices at <span class="No-Break">the backend.</span></p>
			<p>Aggregators can be implemented as part of the gateway itself; however, the best practice is to add an aggregator only whenever it is needed and make it an independent <span class="No-Break">standalone microservice.</span></p>
			<p>An MSA system can have multiple aggregators, each with specific business logic, and fulfilling a specific collection of data from a different set <span class="No-Break">of microservices.</span></p>
			<p>Similarly, orchestration patterns can also be implemented in the API gateway; however, you need the API gateway to focus on doing the main functions it was created for and leave orchestration tasks to the orchestrator. The orchestrator is also best deployed as a <span class="No-Break">standalone microservice:</span></p>
			<div>
				<div id="_idContainer041" class="IMG---Figure">
					<img src="image/B18934_03_8.jpg" alt="Figure 3.8: MSA high-level architecture"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.8: MSA high-level architecture</p>
			<p>The preceding diagram shows the high-level architecture of having all these components working together within the MSA system. Clients always interact with the API gateway, and the API gateway will route the request to the appropriate service within the <span class="No-Break">MSA system.</span></p>
			<p>Client API calls are <a id="_idIndexMarker140"/>routed to the appropriate microservice <a id="_idIndexMarker141"/>based on the API’s configuration. If the client <a id="_idIndexMarker142"/>request is something that is fulfilled by communicating <a id="_idIndexMarker143"/>with a single microservice, then the gateway <a id="_idIndexMarker144"/>will send that request directly to the <a id="_idIndexMarker145"/>microservice. API calls that span multiple microservices and are assigned to a specific aggregator in the system will be forwarded to that particular aggregator. Finally, for API requests that invoke specific workflows, the API gateway will forward those to <span class="No-Break">the orchestrator.</span></p>
			<p>In this section, we learned how the API gateway, the orchestrator, and the aggregator coexist in the same MSA system. In the next section, we will try to apply the concepts of all these three communication patterns to our previously developed <span class="No-Break">ABC-MSA system.</span></p>
			<h1 id="_idParaDest-47"><a id="_idTextAnchor047"/>Microservices circuit breaker</h1>
			<p>Another challenge in MSA systems is the stability and assurance of workflow execution. Saga patterns, which we <a id="_idIndexMarker146"/>discussed in <a href="B18934_01.xhtml#_idTextAnchor014"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, are used to ensure that all transactions within a specific workflow are either all successfully executed, or all fail. But is that enough to ensure the reliable execution <span class="No-Break">of microservices?</span></p>
			<p>Let’s consider a scenario where the called microservice is too slow in responding to API calls. Requests get successfully executed, but the microservice’s response times out. The microservice consumer, in turn, may assume an execution failure, and accordingly repeat the operation, which can be <span class="No-Break">very problematic.</span></p>
			<p>As shown in the following diagram, when a response timeout takes place in the Payment microservice, the Payment microservice will process the payment, but the microservice consumer will assume that the payment has not been processed and may automatically (or upon user request) retry the process. This behavior will cause the payment to be processed multiple times, resulting in multiple charges for the same order, or for the order to be placed <span class="No-Break">multiple times:</span></p>
			<div>
				<div id="_idContainer042" class="IMG---Figure">
					<img src="image/B18934_03_9.jpg" alt="Figure 3.9: Payment microservice with too slow of a response time"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.9: Payment microservice with too slow of a response time</p>
			<p>In MSA, when microservices get instantiated, they start with limited resources and threads to avoid one particular microservice from hogging all the <span class="No-Break">system’s resources.</span></p>
			<p>With system resources in mind, consider another scenario, as shown in <span class="No-Break"><em class="italic">Figure 3</em></span><em class="italic">.10</em>, where the Inventory microservice is part of a service workflow and the Payment microservice is neither processing nor responding to API calls for whatever reason. In this case, both the Order and Payment microservices will keep waiting for confirmation from the inventory before they start releasing <span class="No-Break">their resources.</span></p>
			<p>With the Inventory microservice timing out requests, and under a system heavy load or high order <a id="_idIndexMarker147"/>volume, requests start to pile up for the Order and Payment microservices. Eventually, both the Order and Payment microservices start to run out of resources and become unable to respond <span class="No-Break">to requests:</span></p>
			<div>
				<div id="_idContainer043" class="IMG---Figure">
					<img src="image/B18934_03_10.jpg" alt="Figure 3.10: Inventory microservice is down"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.10: Inventory microservice is down</p>
			<p>Similar scenarios in MSA can result in a domino effect, causing a cascading failure to multiple microservices, which, in turn, causes an entire <span class="No-Break">system failure.</span></p>
			<p>A microservice <strong class="bold">circuit breaker</strong> is used to prevent a system cascading failure from happening. A circuit breaker monitors microservice performance using real traffic metrics. It analyses <a id="_idIndexMarker148"/>parameters such as response time and successful response rate and then determines the health of the microservice in real time. Should the microservice become unhealthy, the circuit breaker immediately starts responding to the microservice consumers with <span class="No-Break">an error.</span></p>
			<p>A circuit breaker does not prevent the microservice being monitored from failing; rather, it averts a cascading failure from <span class="No-Break">taking place:</span></p>
			<div>
				<div id="_idContainer044" class="IMG---Figure">
					<img src="image/B18934_03_11.jpg" alt="Figure 3.11: The Inventory microservice with an inline circuit breaker"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.11: The Inventory microservice with an inline circuit breaker</p>
			<p>When the circuit breaker assumes a microservice is unhealthy, it still needs to monitor and evaluate the microservice’s operational performance. The circuit breaker switches to a <strong class="bold">half-open state</strong>, where it only allows a small portion of requests to pass through to the microservice being monitored. Once the circuit breaker detects a healthy microservice response, the circuit breaker switches its state back to a <strong class="bold">closed state</strong>, where API traffic flows back normally to <span class="No-Break">the microservice.</span></p>
			<p>Circuit breakers are not needed for every single microservice in the MSA system. We only need to deploy a circuit breaker on microservices that can cause a cascading failure. Architects will need to study and determine which microservices need circuit <span class="No-Break">breaker protection.</span></p>
			<p>A circuit breaker can be deployed as a standalone microservice or be part of the API gateway. Whether <a id="_idIndexMarker149"/>circuit breakers are implemented as standalone microservices or part of the API gateway highly depends on the system’s business and operational requirements, as well as the patterns adopted in the <span class="No-Break">architecture itself.</span></p>
			<p>The circuit breaker pattern, as well as the orchestrator, aggregator, ACL, and API gateway, are all enhancements architects that can be applied to the MSA system for better reliability, resilience, and overall performance. In the next section, we will learn how to apply each of the patterns discussed here to our <span class="No-Break">ABC-MSA system.</span></p>
			<h1 id="_idParaDest-48"><a id="_idTextAnchor048"/>ABC-MSA enhancements</h1>
			<p>In <a href="B18934_02.xhtml#_idTextAnchor028"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, we refactored <a id="_idIndexMarker150"/>our ABC-Monolith into a simple ABC-MSA. The ABC-MSA we designed in <a href="B18934_02.xhtml#_idTextAnchor028"><span class="No-Break"><em class="italic">Chapter 2</em></span></a> lacked many of the enhancements we are considering in this chapter. It is time to take what we have learned in this chapter and apply that to the ABC-MSA system to enhance its design <span class="No-Break">and operations.</span></p>
			<p>First of all, in the ABC-MSA from <a href="B18934_02.xhtml#_idTextAnchor028"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, the orchestrator was doing both the API gateway functions and the orchestration function. So far, we have learned that combining both the gateway and orchestration functions in one service is not the best option. Therefore, we will add to our ABC-MSA system an API gateway dedicated to ingress and egress API calls, and other API gateway functions we discussed earlier in this chapter, such as authentication, authorization, audit, monitoring, and <span class="No-Break">so on.</span></p>
			<p>The API gateway will run as a separate standalone microservice serving direct client requests, including the system dashboard and user frontend. The orchestrator will also run as a standalone microservice serving the <span class="No-Break">MSA’s workflows.</span></p>
			<p>The aggregator(s) will depend on the use cases where multiple ABC-MSA microservices are used to fulfill the <span class="No-Break">user requests.</span></p>
			<p>A simple use case for using an aggregator would be a user checking for an order’s shipping status. The status should include the order information, the products included in the order, and the shipping status of <span class="No-Break">that order.</span></p>
			<p>To show all this information to the user, we will need to pull information from three different <a id="_idIndexMarker151"/>microservices: Order Management, Product Management, and Shipping Management. We will deploy an aggregator as a standalone microservice to pull the data from all these microservices and make them available for user <span class="No-Break">API consumption:</span></p>
			<div>
				<div id="_idContainer045" class="IMG---Figure">
					<img src="image/B18934_03_12.jpg" alt="Figure 3.12: The enhanced ABC-MSA architecture"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.12: The enhanced ABC-MSA architecture</p>
			<p>In the preceding diagram, we added the Management and Orchestration layer as part of the ABC-MSA system. This layer will manage the orchestration workflows and the microservice’s life cycle, including, installation, configuration, instantiation, updates, upgrades, <span class="No-Break">and shutdowns.</span></p>
			<p>We will also need <a id="_idIndexMarker152"/>an ACL to be active during the transition from the ABC-Monolith to the ABC-MSA. The ACL will act as a buffer between both systems to maintain the neatness of the architecture and its operations. Once all the ABC-Monolith functions have been redeployed into the ABC-MSA, both the old ABC-Monolith and the ACL can <span class="No-Break">be decommissioned.</span></p>
			<h1 id="_idParaDest-49"><a id="_idTextAnchor049"/>Summary</h1>
			<p>In this chapter, we discussed the different components of the MSA that can be introduced to maintain the system’s stability and enhance <span class="No-Break">its performance.</span></p>
			<p>We discussed how to use the ACL to protect our new MSA during its transition from the old monolithic system. Then, we covered the roles and functions of the API gateway, the aggregator, and the orchestrator. We also covered some of the drawbacks you may experience when adopting the various communication patterns <span class="No-Break">in MSA.</span></p>
			<p>Finally, we redesigned our ABC-MSA to showcase how these different components can all function together in a <span class="No-Break">typical MSA.</span></p>
			<p><a href="B18934_01.xhtml#_idTextAnchor014"><span class="No-Break"><em class="italic">Chapter 1</em></span></a> to <a href="#_idTextAnchor039"><span class="No-Break"><em class="italic">Chapter 3</em></span></a> covered the basics of the MSA. In the next chapter, we will start discussing, with hands-on examples, key machine learning and deep learning algorithms used in MSA enterprise systems, and go over some programming and tool examples of building machine learning and deep <span class="No-Break">learning algorithms.</span></p>
		</div>


		<div id="_idContainer047" class="Content">
			<h1 id="_idParaDest-50"><a id="_idTextAnchor050"/>Part 2: Overview of Machine Learning Algorithms and Applications</h1>
			<p>In this part, we will shift our focus to machine learning. We will learn about the different concepts of machine learning algorithms and how to design and build a machine learning system, maintain the model, and apply machine learning to an intelligent <span class="No-Break">enterprise MSA.</span></p>
			<p>We will first learn the fundamentals when it comes to identifying the difference between different machine learning models and their use cases. Once we’ve covered the basics, we will start to learn how to design a machine learning system pipeline. Once we have established a machine learning system pipeline, we will learn what data shifts are, how they can impact our system, and how we can identify and address them. Finally, having gone through all the basics, we will start to explore the different use cases for building our very own intelligent <span class="No-Break">enterprise MSA.</span></p>
			<p>By the end of <em class="italic">Part 2</em>, we will have a basic understanding of machine learning and the different algorithms, how to build and maintain a machine learning system, and, finally, the different use cases in which we can use machine learning for our intelligent <span class="No-Break">enterprise MSA.</span></p>
			<p>This part comprises the <span class="No-Break">following chapters:</span></p>
			<ul>
				<li><a href="B18934_04.xhtml#_idTextAnchor051"><em class="italic">Chapter 4</em></a>, <em class="italic">Key Machine Learning Algorithms and Concepts</em></li>
				<li><a href="B18934_05.xhtml#_idTextAnchor061"><em class="italic">Chapter 5</em></a>, <em class="italic">Machine Learning System Design</em></li>
				<li><a href="B18934_06.xhtml#_idTextAnchor072"><em class="italic">Chapter 6</em></a>, <em class="italic">Stabilizing the Machine Learning System</em></li>
				<li><a href="B18934_07.xhtml#_idTextAnchor079"><em class="italic">Chapter 7</em></a>, <em class="italic">How Machine Learning and Deep Learning Help in MSA Enterprise Systems</em></li>
			</ul>
		</div>
		<div>
			<div id="_idContainer048">
			</div>
		</div>
		<div>
			<div id="_idContainer049">
			</div>
		</div>
</body></html>