<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Creating Our First Julia App</h1>
                </header>
            
            <article>
                
<p class="calibre2">Now that you have a working Julia installation and your IDE of choice is ready to run, it's time to put them to some good use. In this chapter, you'll learn how to apply Julia for data analysis—a domain that is central to the language, so expect to be impressed!</p>
<p class="calibre2">We will learn to perform exploratory data analysis with Julia. In the process, we'll take a look at <kbd class="calibre12">RDatasets</kbd>, a package that provides access to over 700 learning datasets. We'll load one of them, the Iris flowers dataset, and we'll manipulate it using standard data analysis functions. Then we'll look more closely at the data by employing common visualization techniques. And finally, we'll see how to persist and (re)load our data.</p>
<p class="calibre2">But, in order to do that, first we need to take a look at some of the language's most important building blocks.</p>
<p class="calibre2">We will cover the following topics in this chapter:</p>
<ul class="calibre10">
<li class="calibre11">Declaring variables (and constants)</li>
<li class="calibre11">Working with <kbd class="calibre12">Strings</kbd> of characters and <kbd class="calibre12">regular expressions</kbd></li>
<li class="calibre11">Numbers and numeric types</li>
<li class="calibre11">Our first Julia data structures—<kbd class="calibre12">Tuple</kbd>, <kbd class="calibre12">Range</kbd>, and <kbd class="calibre12">Array</kbd></li>
<li class="calibre11"><kbd class="calibre12">*</kbd> Exploratory data analysis using the Iris flower dataset—<kbd class="calibre12">RDatasets</kbd> and core <kbd class="calibre12">Statistics</kbd></li>
<li class="calibre11">Quick data visualization with <kbd class="calibre12">Gadfly</kbd></li>
<li class="calibre11"><kbd class="calibre12">*</kbd> Saving and loading tabular data with <kbd class="calibre12">CSV</kbd> and <kbd class="calibre12">Feather</kbd></li>
<li class="calibre11">Interacting with MongoDB databases</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p class="calibre2">The Julia package ecosystem is under continuous development and new package versions are released on a daily basis. Most of the times this is great news, as new releases bring new features and bug fixes. However, since many of the packages are still in beta (version 0.x), any new release can introduce breaking changes. As a result, the code presented in the book can stop working. In order to ensure that your code will produce the same results as described in the book, it is recommended to use the same package versions. Here are the external packages used in this chapter and their specific versions:</p>
<pre class="calibre17">CSV@v0.4.3<br class="title-page-name"/>DataFrames@v0.15.2<br class="title-page-name"/>Feather@v0.5.1<br class="title-page-name"/>Gadfly@v1.0.1<br class="title-page-name"/>IJulia@v1.14.1<br class="title-page-name"/>JSON@v0.20.0<br class="title-page-name"/>RDatasets@v0.6.1</pre>
<p class="calibre2">In order to install a specific version of a package you need to run:</p>
<pre class="calibre17"><strong class="calibre1">pkg&gt; add PackageName@vX.Y.Z</strong> </pre>
<p class="calibre2">For example:</p>
<pre class="calibre17"><strong class="calibre1">pkg&gt; add IJulia@v1.14.1</strong></pre>
<p class="calibre2">Alternatively you can install all the used packages by downloading the <kbd class="calibre12">Project.toml</kbd> file provided with the chapter and using <kbd class="calibre12">pkg&gt;</kbd> instantiate as follows:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; download("https://raw.githubusercontent.com/PacktPublishing/Julia-Programming-Projects/master/Chapter02/Project.toml", "Project.toml")</strong><br class="title-page-name"/><strong class="calibre1">pkg&gt; activate . </strong><br class="title-page-name"/><strong class="calibre1">pkg&gt; instantiate</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining variables</h1>
                </header>
            
            <article>
                
<p class="calibre2">We have seen in the previous chapter how to use the REPL in order to execute computations and have the result displayed back to us. Julia even lends a helping hand by setting up the <kbd class="calibre12">ans</kbd> variable, which automatically holds the last computed value.</p>
<p class="calibre2"/>
<p class="calibre2">But, if we want to write anything but the most trivial programs, we need to learn how to define variables ourselves. In Julia, a variable is simply a name associated to a value. There are very few restrictions for naming variables, and the names themselves have no semantic meaning (the language will not treat variables differently based on their names, unlike say Ruby, where a name that is all caps is treated as a constant).</p>
<p class="calibre2">Let's see some examples:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; book = "Julia v1.0 By Example" 
julia&gt; pi = 3.14 
julia&gt; ANSWER = 42 
julia&gt; my_first_name = "Adrian"</strong> </pre>
<div class="packttip">You can follow along through the examples in the chapter by loading the accompanying Jupyter/IJulia notebook provided with this chapter's support files.</div>
<p class="calibre2">The variables, names are case-sensitive, meaning that <kbd class="calibre12">ANSWER</kbd> and <kbd class="calibre12">answer</kbd> (and <kbd class="calibre12">Answer</kbd> and <kbd class="calibre12">aNsWeR</kbd>) are completely different things:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; answer 
ERROR: UndefVarError: answer not defined</strong> 
 </pre>
<p class="calibre2">Unicode names (UTF-8-encoded) are also accepted as variables names:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; δ = 130</strong> 
 </pre>
<p class="calibre2">Remember that you can type many Unicode math symbols by typing backslash (<kbd class="calibre12">\</kbd>) then the name of the symbol and then the <em class="calibre16">Tab</em> key. For example, \pi[<em class="calibre16">Tab</em>] will output π.</p>
<p class="calibre2">Emojis also work, if your terminal supports them:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; <img class="fm-editor-equation" src="assets/66a96d4b-ddc8-4a14-8261-fd28e4c890b6.png"/> = "apollo 11"</strong> </pre>
<p class="calibre2">The only explicitly disallowed names for variables are the names of built-in Julia statements (<kbd class="calibre12">do</kbd>, <kbd class="calibre12">end</kbd>, <kbd class="calibre12">try</kbd>, <kbd class="calibre12">catch</kbd>, <kbd class="calibre12">if</kbd>, and <kbd class="calibre12">else</kbd>, plus a few more):</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; do = 3 
ERROR: syntax: invalid "do" syntax </strong><br class="title-page-name"/><strong class="calibre1">julia&gt; end = "Paris" 
ERROR: syntax: unexpected end 
</strong> </pre>
<p class="calibre2"/>
<p class="calibre2"/>
<p class="calibre2">Attempting to access a variable that hasn't been defined will result in an error:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; MysteryVar 
ERROR: UndefVarError: MysteryVar not defined</strong> 
 </pre>
<p class="calibre2">It's true that the language does not impose many restrictions, but a set of code style conventions is always useful—and even more so for an open source language. The Julia community has distilled a set of best practices for writing code. In regard to naming variables, the names should be lowercase and in just one word; word separation can be done with underscores (<kbd class="calibre12">_</kbd>), but only if the name would be difficult to read without them. For example, <kbd class="calibre12">myvar</kbd> versus <kbd class="calibre12">total_length_horizontal</kbd>.</p>
<div class="packttip">Given that the degree of difficulty in reading a name is a subjective thing, I'm a bit split about this naming style. I normally prefer the crystal-clear clarity of separating at word boundaries. But nevertheless, it is better to follow the recommendation, given that function names in the Julia API adhere to it. By adhering to the same conventions, your code will be consistent throughout.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Constants</h1>
                </header>
            
            <article>
                
<p class="calibre2">Constants are variables that, once declared, can't be changed. They are declared by prefixing them with the <kbd class="calibre12">const</kbd> keyword:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; const firstmonth = "January"</strong> 
 </pre>
<p class="calibre2">Very importantly in Julia, constants are not concerned with their value, but rather with their <em class="calibre16">type</em>. It is a bit too early to discuss types in Julia, so for now it suffices to say that a type represents what kind of a value we're dealing with. For instance, <kbd class="calibre12">"abc"</kbd> (within double quotes) is of type <kbd class="calibre12">String</kbd>, <kbd class="calibre12">'a'</kbd> (within single quotes) is of type <kbd class="calibre12">Char</kbd> , and <kbd class="calibre12">1000</kbd> is of type <kbd class="calibre12">Int</kbd> <span class="calibre5">(because it's an integer)</span>. Thus, in Julia, unlike most other languages, we can change the value assigned to a constant as long as the <kbd class="calibre12">type</kbd> remains the same. For instance, we can at first decide that eggs and milk are acceptable meal choices and go <kbd class="calibre12">vegetarian</kbd>:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; const mealoption = "vegetarian"</strong> </pre>
<p class="calibre2">And we can change our mind later on, if we decide to go <kbd class="calibre12">vegan</kbd>. Julia will let it slide with just a warning:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; mealoption = "vegan" 
WARNING: redefining constant mealoption 
"vegan" 
</strong> </pre>
<p class="calibre2">However, attempting to say that <kbd class="calibre12">mealoption = 2</kbd> will result in an error:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; mealoption = 2 
ERROR: invalid redefinition of constant mealoption</strong> </pre>
<p class="calibre2">This makes sense, right? Who's ever heard of that kind of diet?</p>
<p class="calibre2">However, the nuances can be more subtle than that, most notably when working with numbers:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; const amount = 10.25  
10.25 </strong><br class="title-page-name"/><strong class="calibre1">julia&gt; amount = 10 
ERROR: invalid redefinition of constant amount</strong> </pre>
<p class="calibre2">Julia doesn't allow it because internally <kbd class="calibre12">10</kbd> and <kbd class="calibre12">10.00</kbd>, despite having the same arithmetical value, are values of different types (<kbd class="calibre12">10</kbd> is an integer, while <kbd class="calibre12">10.00</kbd> is a <kbd class="calibre12">float</kbd>). We'll take a closer look at numeric types in just a moment, so it will all become clearer:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; amount = 10.00 
WARNING: redefining constant amount 
10.0 
</strong> </pre>
<p class="calibre2">Thus, we need to pass the new value as <kbd class="calibre12">10.00</kbd>—a <kbd class="calibre12">float</kbd>, in order to obey the same type requirement.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Why are constants important?</h1>
                </header>
            
            <article>
                
<p class="calibre2">It's mostly about performance. Constants can be especially useful as global values. Because global variables are long-lived and can be modified at any time and from any location in your code, the compiler is having a hard time optimizing them. If we tell the compiler that the value is constant and thus that the type of the value won't change, the performance problem can be optimized away.</p>
<div class="packttip">Of course, just because constants alleviate some critical performance problems brought about by global variables, it doesn't mean that we are encouraged to use them. Global values in Julia, like in other languages, must be avoided whenever possible. Besides performance issues, they can create subtle bugs that are hard to catch and understand. Also, keep in mind that, since Julia allows changing the value of a constant, accidental modification becomes possible.</div>
<p class="calibre2"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Comments</h1>
                </header>
            
            <article>
                
<p class="calibre2">Common programming wisdom says the following:</p>
<div class="mce-root1">"Code is read much more often than it is written, so plan accordingly."</div>
<p class="calibre2">Code comments are a powerful tool that make the programs easier to understand later on. In Julia, comments are marked with the <a class="calibre9">#</a> sign. Single-line comments are denoted by a <a class="calibre9"><kbd class="calibre24">#</kbd> </a><a class="calibre9">and everything that follows this, until the end of the line, is ignored by the compiler.</a> Multiline comments are enclosed between <kbd class="calibre12">#= ... =#</kbd>. Everything within the opening and the closing comment tags is also ignored by the compiler. Here is an example:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; #= 
           Our company charges a fixed  
           $10 fee per transaction. 
       =# 
const flatfee = 10 # flat fee, per transaction </strong> 
 </pre>
<p class="calibre2">In the previous snippet, we can see both multiline and single-line comments in action. A single-line comment can also be placed at the beginning of the line.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Strings</h1>
                </header>
            
            <article>
                
<p class="calibre2">A string represents a sequence of characters. We can create a string by enclosing the corresponding sequence of characters between double quotes, as shown in the following:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; "Measuring programming progress by lines of code is like measuring aircraft building progress by weight." 
</strong> </pre>
<p class="calibre2">If the string also includes quotes, we can escape these by prefixing them with a backslash <kbd class="calibre12">\</kbd>:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; "Beta is Latin for \"still doesn't work\"."</strong> </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Triple-quoted strings</h1>
                </header>
            
            <article>
                
<p class="calibre2">However, escaping can get messy, so there's a much better way of dealing with this—by using triple quotes <kbd class="calibre12">"""..."""</kbd>.</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; """Beta is Latin for "still doesn't work"."""</strong> 
 </pre>
<p class="calibre2"/>
<p class="calibre2"/>
<p class="calibre2"/>
<p class="calibre2"/>
<p class="calibre2"/>
<p class="calibre2"/>
<p class="calibre2">Within triple quotes, it is no longer necessary to escape the single quotes. However, make sure that the single quotes and the triple quotes are separated—or else the compiler will get confused:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; """Beta is Latin for "still doesn't work"""" 
syntax: cannot juxtapose string literal</strong> 
 </pre>
<p class="calibre2">The triple quotes come with some extra special powers when used with multiline text. First, if the opening <kbd class="calibre12">"""</kbd> is followed by a newline, this newline is stripped from the string. Also, whitespace is preserved but the string is dedented to the level of the least-indented line:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; """ 
                  Hello 
           Look 
    Here"""</strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1"> 
julia&gt; print(ans) 
Hello 
Look 
Here 
</strong> </pre>
<p class="calibre2">The previous snippet illustrates how the first line is stripped and the whitespace is preserved—but the indentation starts with the least indented line (the space in front of <kbd class="calibre12">Here</kbd> was removed).</p>
<p class="calibre2">Here is how it looks in Jupyter/IJulia:</p>
<p class="CDPAlignCenter"><img src="assets/1eb65198-16e9-4b0e-9044-7cce9cd0bfce.png" class="calibre33"/></p>
<p class="calibre2">The longer arrow stands for a <em class="calibre16">Tab</em> (represented by a <kbd class="calibre12">\t</kbd> in the output), while the shorter arrow is a space. Note that each line had a space as the first character—but it was removed. The least indented line, the last one, was shifted to the left, removing all its whitespace and beginning with <strong class="calibre4">Here</strong>, while the remaining whitespace on the other lines was preserved (now beginning with a <em class="calibre16">Tab</em>).</p>
<p class="calibre2"/>
<p class="calibre2"/>
<p class="calibre2"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Concatenating strings</h1>
                </header>
            
            <article>
                
<p class="calibre2">Two or more strings can be joined together (concatenated) to form a single string by using the star <kbd class="calibre12">*</kbd> operator:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; "Hello " * "world!" "Hello world!"</strong> 
 </pre>
<p class="calibre2">Alternatively, we can invoke the <kbd class="calibre12">string</kbd> function, passing in all the words we want to concatenate:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; string("Itsy", " ", "Bitsy", " ", "Spider") 
"Itsy Bitsy Spider" 
</strong> </pre>
<p class="calibre2">Concatenation works great with variables too:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; username = "Adrian" 
julia&gt; greeting = "Good morning" </strong><br class="title-page-name"/><strong class="calibre1">julia&gt; greeting * ", " * username 
"Good morning, Adrian"</strong> </pre>
<p class="calibre2">However, again, we need to be careful when dealing with types (types are central to Julia, so this will be a recurring topic). Concatenation only works for strings:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; username = 9543794 
julia&gt; greeting = "Good morning" 
julia&gt; greeting * ", " * username 
MethodError: no method matching *(::String, ::Int64)</strong> 
 </pre>
<p class="calibre2">Performing the concatenation by invoking the <kbd class="calibre12">string</kbd> function does work even if not all the arguments are strings:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; string(greeting, ", ", username)</strong><br class="title-page-name"/><strong class="calibre1"> "Good morning, 9543794"</strong><br class="title-page-name"/><br class="title-page-name"/></pre>
<p class="calibre2">Thus, <kbd class="calibre12">string</kbd> has the added advantage that it automatically converts its parameters to strings. The following example works too:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; string(2, " and ", 3) 
"2 and 3"</strong></pre>
<p class="calibre2">But this does not:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; 2 * " and " * 3 
ERROR: MethodError: no method matching *(::Int64, ::String)</strong></pre>
<div class="packttip">There is also a <kbd class="calibre24">String</kbd> method (with capital S). Remember that in Julia names are case-sensitive, so <kbd class="calibre24">string</kbd> and <kbd class="calibre24">String</kbd> are two different things. For most purposes we'll need the lowercase function, <kbd class="calibre24">string</kbd>. You can use Julia's help system to access the documentation for <kbd class="calibre24">String</kbd>, if you want to learn about it.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Interpolating strings</h1>
                </header>
            
            <article>
                
<p class="calibre2">When creating longer, more complex strings, concatenation can be noisy and error-prone. For such cases, we're better off using the <kbd class="calibre12">$</kbd> symbol to perform variable interpolation into strings:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; username = "Adrian" 
julia&gt; greeting = "Good morning" 
julia&gt; "$greeting, $username" 
"Good morning, Adrian"</strong> 
 </pre>
<p class="calibre2">More complex expressions can be interpolated by wrapping them into <kbd class="calibre12">$(...)</kbd>:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; "$(uppercase(greeting)), $(reverse(username))" 
"GOOD MORNING, nairdA"</strong> 
 </pre>
<p class="calibre2">Here we invoke the <kbd class="calibre12">uppercase</kbd> function which changes all the letters of the string into their uppercase counterparts—and the <kbd class="calibre12">reverse</kbd> function which reverses the order of the letters in the word. Their output is then interpolated in a string. Between the <kbd class="calibre12">$(...)</kbd> boundaries, we can use any Julia code we want.</p>
<p class="calibre2">Just like the <kbd class="calibre12">string</kbd> function, interpolation takes care of converting the values to strings:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; "The sum of 1 and 2 is $(1 + 2)" 
"The sum of 1 and 2 is 3"</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Manipulating strings</h1>
                </header>
            
            <article>
                
<p class="calibre2">Strings can be treated as a list of characters, so we can index into them—that is, access the character at a certain position in the word:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; str = "Nice to see you" 
julia&gt; str[1] 
'N': ASCII/Unicode U+004e (category Lu: Letter, uppercase)</strong></pre>
<p class="calibre2">The first character of the string <kbd class="calibre12">Nice to see you</kbd> is <kbd class="calibre12">N</kbd>.</p>
<p class="calibre2">Indexing in Julia is <kbd class="calibre12">1</kbd>-based, which means that the first element of a list is found at index 1. This can be surprising if you've programmed before, given that most programming languages use <kbd class="calibre12">0</kbd>-based indexing. However, I assure you that <kbd class="calibre12">1</kbd>-based indexing makes for a very pleasant and straightforward coding experience.</p>
<div class="packttip">Julia has support for arrays with arbitrary indices, allowing, for example, to start numbering at <kbd class="calibre24">0</kbd>. However, arbitrary indexing is a more advanced feature that we won't cover here. If you are curious, you can check the official documentation at <span><a href="https://docs.julialang.org/en/v1/devdocs/offset-arrays/" class="calibre19">https://docs.julialang.org/en/v1/devdocs/offset-arrays/</a>.</span></div>
<p class="calibre2">We can also extract a part of the string (a substring) by indexing with a <kbd class="calibre12">range</kbd>, providing the starting and the ending positions:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; str[9:11] 
"see"</strong> </pre>
<p class="calibre2">It is important to notice that indexing via a singular value returns a <kbd class="calibre12">Char</kbd> , while indexing via a <kbd class="calibre12">range</kbd> returns a <kbd class="calibre12">String</kbd> (remember, for Julia these are two completely different things):</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; str[1:1] 
"N"</strong> </pre>
<p class="calibre2"><kbd class="calibre12">N</kbd> is a <kbd class="calibre12">String</kbd> of just one letter, as indicated by its double quotes:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; str[1] 
'N': ASCII/Unicode U+004e (category Lu: Letter, uppercase)</strong></pre>
<p class="calibre2"/>
<p class="calibre2"><kbd class="calibre12">N</kbd> is a <kbd class="calibre12">Char</kbd>, as shown by the single quotes:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; str[1:1] == str[1] 
false</strong> </pre>
<p class="calibre2">They are not equal.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Unicode and UTF-8</h1>
                </header>
            
            <article>
                
<p class="calibre2">In Julia, string literals are encoded using UTF-8. UTF-8 is a variable-width encoding, meaning that not all characters are represented using the same number of bytes. For example, ASCII characters are encoded using a single byte—but other characters can use up to four bytes. This means that not every byte index into a UTF-8 string is necessarily a valid index for a corresponding character. If you index into a string at such an invalid byte index, an error will be thrown. Here is what I mean:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; str = "Søren Kierkegaard was a Danish Philosopher" 
julia&gt; str[1] 
'S': ASCII/Unicode U+0053 (category Lu: Letter, uppercase)</strong> </pre>
<p class="calibre2">We can correctly retrieve the character at index <kbd class="calibre12">1</kbd>:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; str[2] 
'ø': Unicode U+00f8 (category Ll: Letter, lowercase)</strong> </pre>
<p class="calibre2">And at index <kbd class="calibre12">2</kbd>, we successfully get the <kbd class="calibre12">ø</kbd> character:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; str[3] 
StringIndexError("Søren Kierkegaard was a Danish Philosopher", 3)</strong> </pre>
<p class="calibre2">However, <kbd class="calibre12">ø</kbd> has two bytes, so index <kbd class="calibre12">3</kbd> is used by <kbd class="calibre12">ø</kbd> as well and we cannot access the string at this position:</p>
<pre class="calibre17"><strong class="calibre1"> 
julia&gt; str[4] 
'r': ASCII/Unicode U+0072 (category Ll: Letter, lowercase)</strong> </pre>
<p class="calibre2">The third letter, <kbd class="calibre12">r</kbd>, is found at position <kbd class="calibre12">4</kbd>.</p>
<p class="calibre2"/>
<p class="calibre2"/>
<p class="calibre2">Thus <kbd class="calibre12">ø</kbd> is a two-byte character that occupies the locations <kbd class="calibre12">2</kbd> and <kbd class="calibre12">3</kbd>—so the index <kbd class="calibre12">3</kbd> is invalid, matching the second byte of <kbd class="calibre12">ø</kbd>. The next valid index can be computed using <kbd class="calibre12">nextind(str, 2)</kbd>—but the recommended way is to use iteration over the characters (we'll discuss <kbd class="calibre12">for</kbd> loops a bit later in this chapter):</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; for s in str 
           println(s) 
       end 
S 
ø 
r 
e 
n 
 
K 
... output truncated...</strong><br class="title-page-name"/><br class="title-page-name"/></pre>
<p class="calibre2">Because of variable-length encodings, the number of characters in a string is not necessarily the same as the last index (as you have seen, the third letter, <kbd class="calibre12">r</kbd>, was at index <kbd class="calibre12">4</kbd>):</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; length(str) 42 </strong><br class="title-page-name"/><strong class="calibre1">julia&gt; str[42] 'e': ASCII/Unicode U+0065 (category Ll: Letter, lowercase)</strong> 
 </pre>
<p class="calibre2">For such cases, Julia provides the <kbd class="calibre12">end</kbd> keyword, which can be used as a shorthand for the last index. You can perform arithmetic and other operations with <kbd class="calibre12">end</kbd>, just like a normal value:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; str[end] 
'r': ASCII/Unicode U+0072 (category Ll: Letter, lowercase) </strong><br class="title-page-name"/><strong class="calibre1">julia&gt; str[end-10:end] 
"Philosopher"</strong><br class="title-page-name"/><br class="title-page-name"/></pre>
<p class="calibre2">The <kbd class="calibre12">end</kbd> value can be computed programmatically using the <kbd class="calibre12">endof(str)</kbd> function. Attempting to index outside the bounds of a string will result in a <kbd class="calibre12">BoundsError</kbd>:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; str[end+1] 
ERROR: BoundsError: attempt to access "Søren Kierkegaard was a Danish Philosopher" 
  at index [44]</strong></pre>
<p class="calibre2"/>
<p class="calibre2"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Regular expressions</h1>
                </header>
            
            <article>
                
<p class="calibre2">Regular expressions are used for powerful pattern-matching of substrings within strings. They can be used to search for a substring in a string, based on patterns—and then to extract or replace the matches. Julia provides support for Perl-compatible regular expressions.</p>
<p class="calibre2">The most common way to input regular expressions is by using the so-called <strong class="calibre4">nonstandard string literals</strong>. These look like regular double-quoted strings, but carry a special prefix. In the case of regular expressions, this prefix is <kbd class="calibre12">"r"</kbd>. The prefix provides for a different behavior, compared to a normal string literal.</p>
<p class="calibre2">For example, in order to define a regular string that matches all the letters, we can use <kbd class="calibre12">r"[a-zA-Z]*".</kbd></p>
<p class="calibre2">Julia provides quite a few nonstandard string literals—and we can even define our own if we want to. The most widely used are for regular expressions (<kbd class="calibre12">r"..."</kbd>), byte array literals (<kbd class="calibre12">b"..."</kbd>), version number literals (<kbd class="calibre12">v"..."</kbd>), and package management commands (<kbd class="calibre12">pkg"..."</kbd>).</p>
<p class="calibre2">Here is how we build a regular expression in Julia—it matches numbers between 0 and 9:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; reg = r"[0-9]+" 
r"[0-9]+" </strong><br class="title-page-name"/><strong class="calibre1">julia&gt; match(reg, "It was 1970") 
RegexMatch("1970")</strong> </pre>
<p class="calibre2">Our regular expression matches the substring <kbd class="calibre12">1970</kbd>.</p>
<p class="calibre2">We can confirm that the nonstandard string literal <kbd class="calibre12">reg</kbd> is in fact a <kbd class="calibre12">Regex</kbd> and not a regular <kbd class="calibre12">String</kbd> by checking its <kbd class="calibre12">type</kbd> with the <kbd class="calibre12">typeof</kbd> function:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; typeof(reg) 
Regex 
</strong> </pre>
<p class="calibre2">This gives away the fact that there's also a <kbd class="calibre12">Regex</kbd> constructor available:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; Regex("[0-9]+") 
r"[0-9]+" 
</strong> </pre>
<p class="calibre2">The two constructs are similar:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; Regex("[0-9]+") == reg 
true</strong></pre>
<p class="calibre2"/>
<p class="calibre2"/>
<p class="calibre2"/>
<p class="calibre2"/>
<div class="packttip">Using the constructor can come in handy when we need to create regular expressions using more complex strings that might include interpolation or concatenation. But in general, the <kbd class="calibre24">r"..."</kbd> format is more used.</div>
<p class="calibre2">The behavior of the regular expression can be affected by using some combination of the flags <kbd class="calibre12">i</kbd>, <kbd class="calibre12">m</kbd>, <kbd class="calibre12">s</kbd>, and <kbd class="calibre12">x.</kbd> These modifiers must be placed right after the closing double quote mark:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; match(r"it was", "It was 1970") # case-sensitive no match </strong><br class="title-page-name"/><strong class="calibre1">julia&gt; match(r"it was"i, "It was 1970") # case-insensitive match 
RegexMatch("It was") 
</strong> </pre>
<p class="calibre2">As you might expect, <kbd class="calibre12">i</kbd> performs a case-insensitive pattern match. Without the <kbd class="calibre12">i</kbd> modifier, <kbd class="calibre12">match</kbd> returns <kbd class="calibre12">nothing</kbd>—a special value that does not print anything at the interactive prompt—to indicate that the regex does not match the given string.</p>
<p class="calibre2">These are the available modifiers:</p>
<ul class="calibre10">
<li class="calibre11"><kbd class="calibre12">i</kbd>—case-insensitive pattern matching.</li>
<li class="calibre11"><kbd class="calibre12">m</kbd>—treats string as multiple lines.</li>
<li class="calibre11"><kbd class="calibre12">s</kbd>—treats string as single line.</li>
<li class="calibre11"><kbd class="calibre12">x</kbd>—tells the regular expression parser to ignore most whitespace that is neither backslashed nor within a character class. You can use this to break up your regular expression into (slightly) more readable parts. The <kbd class="calibre12">#</kbd> character is also treated as a metacharacter introducing a comment, just as in ordinary code.</li>
</ul>
<p class="calibre2">The <kbd class="calibre12">occursin</kbd> function is more concise if all we need is to check if a regex or a substring is contained in a string—if we don't want to extract or replace the matches:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; occursin(r"hello", "It was 1970")  
false </strong><br class="title-page-name"/><strong class="calibre1">julia&gt; occursin(r"19", "It was 1970") 
true</strong> 
 </pre>
<p class="calibre2">When a regular expression does match, it returns a <kbd class="calibre12">RegexMatch</kbd> object. These objects encapsulate how the expression matches, including the substring that the pattern matches and any captured substrings:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; alice_in_wonderland = "Why, sometimes I've believed as many as six impossible things before breakfast." 
 
julia&gt; m = match(r"(\w+)+", alice_in_wonderland) 
RegexMatch("Why", 1="Why") 
 </strong></pre>
<p class="calibre2"/>
<p class="calibre2"/>
<p class="calibre2"/>
<p class="calibre2"/>
<p class="calibre2">The <kbd class="calibre12">\w</kbd> regex will match a <em class="calibre16">word</em>, so in this snippet we captured the first word, <kbd class="calibre12">Why</kbd>.</p>
<p class="calibre2">We also have the option to specify the index at which to start the search:</p>
<pre class="calibre17">m = match(r"(\w+)+", alice_in_wonderland, 6) 
RegexMatch("sometimes", 1="sometimes") 
 </pre>
<p class="calibre2">Let's try something a bit more complex:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; m = match(r"((\w+)(\s+|\W+))", alice_in_wonderland) 
RegexMatch("Why, ", 1="Why, ", 2="Why", 3=", ")</strong> </pre>
<p class="calibre2">The resultant <kbd class="calibre12">RegexMatch</kbd> object <kbd class="calibre12">m</kbd> exposes the following properties (or fields, in Julia's lingo):</p>
<ul class="calibre10">
<li class="calibre11"><kbd class="calibre12">m.match</kbd> (<kbd class="calibre12">Why</kbd>, ) contains the entire substring that matched.</li>
<li class="calibre11"><kbd class="calibre12">m.captures</kbd> (an array of strings containing <kbd class="calibre12">Why</kbd>, <kbd class="calibre12">Why</kbd>, and <kbd class="calibre12">,</kbd> ) represents the captured substrings.</li>
<li class="calibre11"><kbd class="calibre12">m.offset</kbd>, the offset at which the whole match begins (in our case <kbd class="calibre12">1</kbd>).</li>
<li class="calibre11"><kbd class="calibre12">m.offsets</kbd>, the offsets of the captured substrings as an array of integers (for our example being <kbd class="calibre12">[1, 1, 4]</kbd>).</li>
</ul>
<p class="calibre2">Julia does not provide a <kbd class="calibre12">g</kbd> modifier, for a <em class="calibre16">greedy</em> or <em class="calibre16">global</em> match. If you need all the matches, you can iterate over them using <kbd class="calibre12">eachmatch()</kbd>, with a construct like the following:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; for m in eachmatch(r"((\w+)(\s+|\W+))", alice_in_wonderland) 
           println(m) 
end</strong> </pre>
<p class="calibre2">Or, alternatively, we can put all the matches in a list using <kbd class="calibre12">collect()</kbd>:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; collect(eachmatch(r"((\w+)(\s+|\W+))", alice_in_wonderland))</strong><br class="title-page-name"/><strong class="calibre1"> 13-element Array{RegexMatch,1}: 
 RegexMatch("Why, ", 1="Why, ", 2="Why", 3=", ") 
 RegexMatch("sometimes ", 1="sometimes ", 2="sometimes", 3=" ") 
 RegexMatch("I'", 1="I'", 2="I", 3="'") 
 RegexMatch("ve ", 1="ve ", 2="ve", 3=" ") 
 RegexMatch("believed ", 1="believed ", 2="believed", 3=" ") 
 RegexMatch("as ", 1="as ", 2="as", 3=" ") 
 RegexMatch("many ", 1="many ", 2="many", 3=" ") 
 RegexMatch("as ", 1="as ", 2="as", 3=" ") 
 RegexMatch("six ", 1="six ", 2="six", 3=" ") 
 RegexMatch("impossible ", 1="impossible ", 2="impossible", 3=" ") 
 RegexMatch("things ", 1="things ", 2="things", 3=" ") 
 RegexMatch("before ", 1="before ", 2="before", 3=" ") 
 RegexMatch("breakfast.", 1="breakfast.", 2="breakfast", 3=".")</strong></pre>
<p class="calibre2"/>
<p class="calibre2"/>
<p class="calibre2"/>
<p class="calibre2"/>
<p class="calibre2"/>
<p class="calibre2"/>
<p class="calibre2"/>
<p class="calibre2"/>
<div class="packttip">For more info about regular expressions, check the official documentation at <span><a href="https://docs.julialang.org/en/stable/manual/strings/#Regular-Expressions-1" class="calibre19">https://docs.julialang.org/en/stable/manual/strings/#Regular-Expressions-1</a>.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Raw string literals</h1>
                </header>
            
            <article>
                
<p class="calibre2"><span class="calibre5">If you need to define a string that does not perform interpolation or escaping, for example to represent code from another language that might contain</span> <kbd class="calibre12">$</kbd> <span class="calibre5">and</span> <kbd class="calibre12">\</kbd> which can interfere with the Julia parser<span class="calibre5">, you can use raw strings. They are constructed with</span> <kbd class="calibre12">raw"..."</kbd> <span class="calibre5">and create ordinary</span> <kbd class="calibre12">String</kbd> <span class="calibre5">objects that contain the enclosed characters exactly as entered, with no interpolation or escaping:</span></p>
<pre class="calibre17"><strong class="calibre1">julia&gt; "This $will error out" 
ERROR: UndefVarError: will not defined</strong> </pre>
<p class="calibre2">Putting a <kbd class="calibre12">$</kbd> inside the string will cause Julia to perform interpolation and look for a variable called <kbd class="calibre12">will</kbd>:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; raw"This $will work" 
"This \$will work"</strong> </pre>
<p class="calibre2">But by using a raw string, the <kbd class="calibre12">$</kbd> symbol will be ignored (or rather, automatically escaped, as you can see in the output).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Numbers</h1>
                </header>
            
            <article>
                
<p class="calibre2">Julia provides a broad range of primitive numeric types, together with the full range of arithmetic and bitwise operators and standard mathematical functions. We have at our disposal a rich hierarchy of numeric types, with the most generic being <kbd class="calibre12">Number</kbd>—which defines two subtypes, <kbd class="calibre12">Complex</kbd> and <kbd class="calibre12">Real</kbd>. Conversely, <kbd class="calibre12">Real</kbd> has four subtypes—<kbd class="calibre12">AbstractFloat</kbd>, <kbd class="calibre12">Integer</kbd>, <kbd class="calibre12">Irrational</kbd>, and <kbd class="calibre12">Rational</kbd>. Finally, <kbd class="calibre12">Integer</kbd> branches into four other subtypes—<kbd class="calibre12">BigInt</kbd>, <kbd class="calibre12">Bool</kbd>, <kbd class="calibre12">Signed</kbd>, and <kbd class="calibre12">Unsigned</kbd>.</p>
<p class="calibre2">Let's take a look at the most important categories of numbers.</p>
<p class="calibre2"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Integers</h1>
                </header>
            
            <article>
                
<p class="calibre2">Literal integers are represented simply as follows:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; 42</strong> </pre>
<p class="calibre2">The default Integer type, called <kbd class="calibre12">Int</kbd>, depends on the architecture of the system upon which the code is executed. It can be either <kbd class="calibre12">Int32</kbd> or <kbd class="calibre12">Int64</kbd>. On my 64-bit system, I get it as follows:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; typeof(42) 
Int64</strong> </pre>
<p class="calibre2">The <kbd class="calibre12">Int</kbd> type will reflect that, as it's just an alias to either <kbd class="calibre12">Int32</kbd> or <kbd class="calibre12">Int64</kbd>:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; @show Int 
Int = Int64 
</strong> </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Overflow behavior</h1>
                </header>
            
            <article>
                
<p class="calibre2">The minimum and maximum values are given by the <kbd class="calibre12">typemin()</kbd> and <kbd class="calibre12">typemax()</kbd> functions:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; typemin(Int), typemax(Int) 
(-9223372036854775808, 9223372036854775807)</strong> </pre>
<p class="calibre2">Attempting to use values that go beyond the boundaries defined by the minimum and the maximum values will not throw an error (or even a warning), resulting instead in a wraparound behavior (meaning that it will jump over at the other end):</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; typemin(Int) - 1 
9223372036854775807 </strong><br class="title-page-name"/><strong class="calibre1">julia&gt; typemin(Int) - 1 == typemax(Int) </strong><br class="title-page-name"/><strong class="calibre1">true</strong> </pre>
<p class="calibre2">Substracting <kbd class="calibre12">1</kbd> from the minimum value will return the maximum value instead:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; typemax(Int) + 1 == typemin(Int) 
true</strong></pre>
<p class="calibre2">The reverse is also <kbd class="calibre12">true</kbd>—adding <kbd class="calibre12">1</kbd> to the maximum value will return the minimum value.</p>
<p class="calibre2">For working with values outside these ranges, we'll use the <kbd class="calibre12">BigInt</kbd> type:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; BigInt(typemax(Int)) + 1 
9223372036854775808</strong></pre>
<p class="calibre2">No wraparound here; the result is what we expected.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Floating-point numbers</h1>
                </header>
            
            <article>
                
<p class="calibre2">Floating-point numbers are represented by numerical values separated by a dot:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; 3.14 
3.14 </strong><br class="title-page-name"/><strong class="calibre1">julia&gt; -1.0 
-1.0 </strong><br class="title-page-name"/><strong class="calibre1">julia&gt; 0.25 
0.25 </strong><br class="title-page-name"/><strong class="calibre1">julia&gt; .5  
0.5 </strong> </pre>
<p class="calibre2">By default they are <kbd class="calibre12">Float64</kbd> values, but they can be converted to <kbd class="calibre12">Float32</kbd>:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; typeof(1.) 
Float64 </strong><br class="title-page-name"/><strong class="calibre1">julia&gt; f32 = Float32(1.) 
1.0f0 </strong><br class="title-page-name"/><strong class="calibre1">julia&gt; typeof(f32) 
Float32</strong> 
 </pre>
<p class="calibre2">To improve readability, the underscore (<kbd class="calibre12">_</kbd>) separator can be used with both integers and floats:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; 1_000_000, 0.000_000_005 
(1000000, 5.0e-9)</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Rational numbers</h1>
                </header>
            
            <article>
                
<p class="calibre2">Julia also provides a Rational number type. This allows us to work with exact ratios, instead of having to deal with the precision loss inherent in floats. Rational numbers are represented as their numerator and denominator values, separated by two forward slashes <kbd class="calibre12">//</kbd>:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; 3//2 
3//2</strong></pre>
<p class="calibre2">Rational numbers can be converted to other types, if there is no data loss:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; 1//2 + 2//4 
1//1 
 
julia&gt; Int(1//1) 
1 
 
julia&gt; float(1//3) 
0.3333333333333333 
 
julia&gt; Int(1//3) 
ERROR: InexactError: Int64(Int64, 1//3) 
 
julia&gt; float(1//3) == 1/3 
true</strong> </pre>
<div class="packttip">Julia also includes support for Complex numbers. We won't discuss, them but you can read about the topic in the official documentation at <span><a href="https://docs.julialang.org/en/v1/manual/complex-and-rational-numbers/#Complex-Numbers-1" class="calibre19">https://docs.julialang.org/en/v1/manual/complex-and-rational-numbers/#Complex-Numbers-1</a>.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Numerical operators</h1>
                </header>
            
            <article>
                
<p class="calibre2">Julia supports the full range of arithmetic operators for its numeric types:</p>
<ul class="calibre10">
<li class="calibre11"><kbd class="calibre12">+</kbd>—(unary and binary plus)</li>
<li class="calibre11"><kbd class="calibre12">-</kbd>—(unary and binary minus)</li>
<li class="calibre11"><kbd class="calibre12">*</kbd>—(times)</li>
<li class="calibre11"><kbd class="calibre12">/</kbd>—(divide)</li>
<li class="calibre11"><kbd class="calibre12">\</kbd>—(inverse divide)</li>
<li class="calibre11"><kbd class="calibre12">^</kbd>—(power)</li>
<li class="calibre11"><kbd class="calibre12">%</kbd>—(remainder)</li>
</ul>
<p class="calibre2">The language also supports handy update operators for each of these (<kbd class="calibre12">+=</kbd><span class="calibre5">,</span><kbd class="calibre12">-=</kbd><span class="calibre5">,</span><kbd class="calibre12">*=</kbd><span class="calibre5">,</span><kbd class="calibre12">/=</kbd><span class="calibre5">,</span><kbd class="calibre12">\=</kbd><span class="calibre5">,</span><kbd class="calibre12">÷=</kbd><span class="calibre5">,</span><kbd class="calibre12">%=</kbd><span class="calibre5">,and </span><kbd class="calibre12">^=</kbd>). Here they are in the wild:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; a = 2 
2 </strong><br class="title-page-name"/><strong class="calibre1">julia&gt; a *= 3 # equivalent of a = a * 3 
6 </strong><br class="title-page-name"/><strong class="calibre1">julia&gt; a ^= 2 # equivalent of a = a ^ 2 
36 </strong><br class="title-page-name"/><strong class="calibre1">julia&gt; a += 4 # equivalent of a = a + 4 
40 </strong> </pre>
<p class="calibre2">Numerical comparisons can be performed with the following set of operators:</p>
<ul class="calibre10">
<li class="calibre11"><kbd class="calibre12">==</kbd>—(equality)</li>
<li class="calibre11"><kbd class="calibre12">!=</kbd> or <kbd class="calibre12">≠</kbd>—(inequality)</li>
<li class="calibre11"><kbd class="calibre12">&lt;</kbd>—(less than)</li>
<li class="calibre11"><kbd class="calibre12">&lt;=</kbd> or <kbd class="calibre12">≤</kbd>—(less than or equal to)</li>
<li class="calibre11"><kbd class="calibre12">&gt;</kbd>—(greater than)</li>
<li class="calibre11"><kbd class="calibre12">&gt;=</kbd> or <kbd class="calibre12">≥</kbd>—(greater than or equal to)</li>
</ul>
<p class="calibre2">In Julia, the comparisons can also be chained:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; 10 &gt; 5 &lt; 6 == 6 &gt;= 3 != 2 
true</strong> </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Vectorized dot operators</h1>
                </header>
            
            <article>
                
<p class="calibre2">Julia defines corresponding <em class="calibre16">dot</em> operations for every binary operator. These are designed to work element-wise with collections of values (called <strong class="calibre4">vectorized</strong>). That is, the operator that is <em class="calibre16">dotted</em> is applied for each element of the collection.</p>
<p class="calibre2"/>
<p class="calibre2"/>
<p class="calibre2">In the following example, we'll square each element of the <kbd class="calibre12">first_five_fib</kbd> collection:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; first_five_fib = [1, 1, 2, 3, 5] 
5-element Array{Int64,1}: 
 1 
 1 
 2 
 3 
 5 </strong><br class="title-page-name"/><strong class="calibre1">julia&gt; first_five_fib .^ 2 
5-element Array{Int64,1}: 
  1 
  1 
  4 
  9 
 25 
</strong> </pre>
<p class="calibre2">In the previous example, <kbd class="calibre12">first_five_fib</kbd> was not touched and the resultant collection was returned, but <em class="calibre16">dotted</em> updating operators are also available, updating the values in place. They match the previously discussed update operators (with the added <em class="calibre16">dot</em>). For example, to update <kbd class="calibre12">first_five_fib</kbd> in place, we'd use the following:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; first_five_fib .^= 2</strong> </pre>
<div class="packttip">Vectorized code is an important part of the language due to its readability and conciseness, but also because it provides important performance optimizations. For more details, check <span><a href="https://docs.julialang.org/en/stable/manual/functions/#man-vectorized-1" class="calibre19">https://docs.julialang.org/en/stable/manual/functions/#man-vectorized-1</a></span>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more to it</h1>
                </header>
            
            <article>
                
<p class="calibre2">This section barely scratches the surface. For a deeper dive into Julia's numeric types, read the official documentation at <a href="https://docs.julialang.org/en/stable/manual/mathematical-operations/" class="calibre9"><span>https://docs.julialang.org/en/stable/manual/mathematical-operations/</span></a>.</p>
<p class="calibre2"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Tuples</h1>
                </header>
            
            <article>
                
<p class="calibre2">Tuples are one of the simplest data types and data structures in Julia. They can have any length and can contain any kind of value—but they are immutable. Once created, a tuple cannot be modified. A tuple can be created using the literal tuple notation, by wrapping the comma-separated values within brackets <kbd class="calibre12">(...)</kbd>:</p>
<pre class="calibre17">(1, 2, 3)<br class="title-page-name"/><br class="title-page-name"/> 
julia&gt; ("a", 4, 12.5) 
("a", 4, 12.5) 
 </pre>
<p class="calibre2">In order to define a one-element tuple, we must not forget the trailing comma:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; (1,) 
(1,)</strong> 
 </pre>
<p class="calibre2">But it's OK to leave off the parenthesis:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; 'e', 2 
('e', 2) 
 
julia&gt; 1, 
(1,) 
</strong> </pre>
<p class="calibre2">We can index into tuples to access their elements:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; lang = ("Julia", v"1.0") 
("Julia", v"1.0.0") 
 
julia&gt; lang[2] 
v"1.0.0" 
</strong> </pre>
<p class="calibre2">Vectorized <em class="calibre16">dot </em>operations also work with tuples:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; (3,4) .+ (1,1) (4, 5)</strong></pre>
<p class="calibre2"/>
<p class="calibre2"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Named tuples</h1>
                </header>
            
            <article>
                
<p class="calibre2">A named tuple represents a tuple with labeled items. We can access the individual components by label or by index:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; skills = (language = "Julia", version = v"1.0") 
(language = "Julia", version = v"1.0.0") 
 
julia&gt; skills.language 
"Julia"</strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1"> 
julia&gt; skills[1] 
"Julia" 
</strong> </pre>
<p class="calibre2">Named tuples can be very powerful as they are similar to full-blown objects, but with the limitation that they are immutable.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Ranges</h1>
                </header>
            
            <article>
                
<p class="calibre2">We've seen ranges a bit earlier, when learning to index into <kbd class="calibre12">strings</kbd>. They can be as simple as the following:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; r = 1:20 
1:20 
</strong> </pre>
<p class="calibre2">As with previous collections, we can index into ranges:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; abc = 'a':'z' 
'a':1:'z' 
 
julia&gt; abc[10] 
'j': ASCII/Unicode U+006a (category Ll: Letter, lowercase) 
 
julia&gt; abc[end] 
'z': ASCII/Unicode U+007a (category Ll: Letter, lowercase)</strong> 
 </pre>
<p class="calibre2">A range can be expanded into its corresponding values by using the splat operator, <kbd class="calibre12">"..."</kbd>. For example, we can splat it into a tuple:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; (1:20...,) 
(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20) 
</strong> </pre>
<p class="calibre2"/>
<p class="calibre2"/>
<p class="calibre2"/>
<p class="calibre2"/>
<p class="calibre2"/>
<p class="calibre2"/>
<p class="calibre2">We can also splat it into a list:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; [1:20...] 
20-element Array{Int64,1}</strong><br class="title-page-name"/><br class="title-page-name"/></pre>
<div class="packttip">The same is true for Tuples, which can also be splatted into lists, among other things: <kbd class="calibre24">[(1,2,3)...]</kbd>.</div>
<p class="calibre2">We can see that the range steps in increments of one, by default. We can change that by passing it an optional step parameter. Here is an example of a range between <kbd class="calibre12">0</kbd> and <kbd class="calibre12">20</kbd> with a step of five:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; (0:5:20...,)  
(0, 5, 10, 15, 20)</strong> </pre>
<p class="calibre2">Now our values go from <kbd class="calibre12">5</kbd> to <kbd class="calibre12">5</kbd>.</p>
<p class="calibre2">This opens the possibility to also go in descending order, by using a negative step:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; (20:-5:-20...,) 
(20, 15, 10, 5, 0, -5, -10, -15, -20) 
</strong> </pre>
<p class="calibre2">Ranges are not limited to integers—you've seen earlier a range of <kbd class="calibre12">chars</kbd>; and these are ranges of <kbd class="calibre12">floats</kbd>:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; (0.5:10) 
0.5:1.0:9.5 </strong><br class="title-page-name"/><strong class="calibre1">julia&gt; (0.5:10...,) </strong><br class="title-page-name"/><strong class="calibre1">(0.5, 1.5, 2.5, 3.5, 4.5, 5.5, 6.5, 7.5, 8.5, 9.5)</strong><br class="title-page-name"/><br class="title-page-name"/></pre>
<p class="calibre2">We can also use the <kbd class="calibre12">collect</kbd> function to expand the range into a list (an array):</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; collect(0.5:0.5:10) 
20-element Array{Float64,1}</strong> </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Arrays</h1>
                </header>
            
            <article>
                
<p class="calibre2">An array is a data structure (and the corresponding <em class="calibre16">type</em>) that represents an ordered collection of elements. More specifically, in Julia, an array is a collection of objects stored in a multi-dimensional grid.</p>
<p class="calibre2">Arrays can have any number of dimensions and are defined by their type and number of dimensions—<kbd class="calibre12">Array{Type, Dimensions}</kbd>.</p>
<p class="calibre2">A one-dimensional array, also called a <strong class="calibre4">vector</strong>, can be easily defined using the array literal notation, the square brackets <kbd class="calibre12">[...]</kbd>:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; [1, 2, 3]  
3-element Array{Int64,1}: 
 1 
 2 
 3 
</strong> </pre>
<p class="calibre2">You can also constrain the type of the elements:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; Float32[1, 2, 3, 4] 
4-element Array{Float32,1}: 
 1.0 
 2.0 
 3.0 
 4.0</strong> 
 </pre>
<p class="calibre2">A two D array (also called a <strong class="calibre4">matrix</strong>) can be initialized using the same array literal notation, but this time without the commas:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; [1 2 3 4] 
1×4 Array{Int64,2}: 
 1  2  3  4 
</strong> </pre>
<p class="calibre2">We can add more rows using semicolons:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; [1 2 3; 4 5 6; 7 8 9] 
3×3 Array{Int64,2}: 
 1  2  3 
 4  5  6 
 7  8  9 
 </strong></pre>
<p class="calibre2">Julia comes with a multitude of functions that can construct and initialize arrays with different values, such as <kbd class="calibre12">zeroes</kbd>, <kbd class="calibre12">ones</kbd>, <kbd class="calibre12">trues</kbd>, <kbd class="calibre12">falses</kbd>, <kbd class="calibre12">similar</kbd>, <kbd class="calibre12">rand, fill</kbd>, and more<kbd class="calibre12">.</kbd> Here are a few of these in action:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; zeros(Int, 2) 
2-element Array{Int64,1}: 
 0 
 0</strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1"> 
julia&gt; zeros(Float64, 3) 
3-element Array{Float64,1}: 
 0.0 
 0.0 
 0.0 
 
julia&gt; ones(2) 
2-element Array{Float64,1}: 
 1.0 
 1.0 
 
julia&gt; ones(Int, 2) 
2-element Array{Int64,1}: 
 1 
 1 
 
julia&gt; ones(Int, 3, 4) 
3×4 Array{Int64,2}: 
 1  1  1  1 
 1  1  1  1 
 1  1  1  1 
 
julia&gt; trues(2) 
2-element BitArray{1}: 
 true 
 true 
 
julia&gt; rand(Int, 4, 2) 
4×2 Array{Int64,2}: 
  9141724849782088627   6682031028895615978 
 -3827856130755187476  -1731760524632072533 
 -3369983903467340663  -7550830795386270701 
 -3159829068325670125   1153092130078644307 
 
julia&gt; rand(Char, 3, 2) 
3×2 Array{Char,2}: 
 '\U63e7a'  '\Ub8723' 
 '\Uda56f'  <img class="fm-editor-equation1" src="assets/9c79f8c9-996c-43e5-99cb-3056f80192f6.png"/> 
 '\U7b7fd'  '\U5f749' 
 
julia&gt; fill(42, 2, 3) 
2×3 Array{Int64,2}: 
 42  42  42 
 42  42  42</strong></pre>
<p class="calibre2"/>
<p class="calibre2"/>
<p class="calibre2"><kbd class="calibre12">Array</kbd> elements can be accessed by their index, passing in a value for each dimension:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; arr1d = rand(5) 5-element Array{Float64,1}: 0.845359 0.0758361 0.379544 0.382333 0.240184 </strong><br class="title-page-name"/><strong class="calibre1">julia&gt; arr1d[5] </strong><br class="title-page-name"/><strong class="calibre1"> 0.240184 
julia&gt; arr2d = rand(5,2) 
5×2 Array{Float64,2}: 
 0.838952  0.312295 
 0.800917  0.253152 
 0.480604  0.49218 
 0.716717  0.889667 
 0.703998  0.773618 
 
julia&gt; arr2d[4, 1] 
0.7167165812985592 
</strong> </pre>
<p class="calibre2">We can also pass a colon (<kbd class="calibre12">:</kbd>) to select all indices within the entire dimension—or a range to define subselections:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; arr2d = rand(5,5) 
5×5 Array{Float64,2}: 
 0.618041  0.887638   0.633995  0.868588  0.19461 
 0.400213  0.699705   0.719709  0.328922  0.326825 
 0.322572  0.807488   0.866489  0.960801  0.476889 
 0.716221  0.504356   0.206264  0.600758  0.843445 
 0.705491  0.0334613  0.240025  0.235351  0.740302</strong> </pre>
<p class="calibre2">This is how we select rows <kbd class="calibre12">1</kbd> to <kbd class="calibre12">3</kbd> and columns <kbd class="calibre12">3</kbd> to <kbd class="calibre12">5</kbd>:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; arr2d[1:3, 3:5] 
3×3 Array{Float64,2}: 
 0.633995  0.868588  0.19461 
 0.719709  0.328922  0.326825 
 0.866489  0.960801  0.476889</strong> </pre>
<p class="calibre2">The solitary colon <kbd class="calibre12">:</kbd> stands for all—so here we pick all the rows and columns <kbd class="calibre12">3</kbd> to <kbd class="calibre12">5</kbd>:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; arr2d[:, 3:5] 
5×3 Array{Float64,2}: 
 0.633995  0.868588  0.19461 
 0.719709  0.328922  0.326825 
 0.866489  0.960801  0.476889 
 0.206264  0.600758  0.843445 
 0.240025  0.235351  0.740302</strong></pre>
<p class="calibre2">Another option is an <kbd class="calibre12">Array</kbd> of Booleans to select elements at its <kbd class="calibre12">true</kbd> indices. Here we select the rows corresponding to the <kbd class="calibre12">true</kbd> values and the columns <kbd class="calibre12">3</kbd> to <kbd class="calibre12">5</kbd>:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; arr2d[[true, false, true, true, false], 3:5] 
3×3 Array{Float64,2}: 
 0.633995  0.868588  0.19461 
 0.866489  0.960801  0.476889 
 0.206264  0.600758  0.843445</strong><br class="title-page-name"/><br class="title-page-name"/></pre>
<p class="calibre2">In a similar way to indexing into an array, we can also assign values to the selected items:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; arr2d[1, 1] = 0.0 
 
julia&gt; arr2d[[true, false, true, true, false], 3:5] = ones(3, 3) 
julia&gt; arr2d 
5×5 Array{Float64,2}: 
 0.0       0.641646  1.0       1.0        1.0      
 0.750895  0.842909  0.818378  0.484694   0.661247 
 0.938833  0.193142  1.0       1.0        1.0      
 0.195541  0.338319  1.0       1.0        1.0      
 0.546298  0.920886  0.720724  0.0529883  0.238986 </strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Iteration</h1>
                </header>
            
            <article>
                
<p class="calibre2">The simplest way to iterate over an array is with the <kbd class="calibre12">for</kbd> construct:</p>
<pre class="calibre17">for element in yourarray 
    # do something with element 
end 
 </pre>
<p class="calibre2">Here's an example:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; for person in ["Alison", "James", "Cohen"] 
           println("Hello $person") 
       end 
 
Hello Alison 
Hello James 
Hello Cohen 
</strong> </pre>
<p class="calibre2">If you also need the index while iterating, Julia exposes the <kbd class="calibre12"><span>eachindex(yourarray)</span></kbd> iterator:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; people = ["Alison", "James", "Cohen"] 
3-element Array{String,1}: 
 "Alison" 
 "James" 
 "Cohen" 
 
julia&gt; for i in eachindex(people) 
           println("$i. $(people[i])") 
       end</strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1"> 
1. Alison 
2. James 
3. Cohen</strong> </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Mutating arrays</h1>
                </header>
            
            <article>
                
<p class="calibre2">We can add more elements to the end of a collection by using the <kbd class="calibre12">push!</kbd> function:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; arr = [1, 2, 3] 
3-element Array{Int64,1}: 
 1 
 2 
 3</strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1"> 
julia&gt; push!(arr, 4) 
4-element Array{Int64,1}: 
 1 
 2 
 3 
 4 
 
julia&gt; push!(arr, 5, 6, 7) 
7-element Array{Int64,1}: 
  1 
  2 
  3 
  4 
  5 
  6 
  7</strong> 
 </pre>
<p class="calibre2">Note the ending exclamation mark <kbd class="calibre12">!</kbd> for the <kbd class="calibre12">push!</kbd> function. This is a perfectly legal function name in Julia. It is a convention to warn that the function is <em class="calibre16">mutating—</em>that is, it will modify the data passed as argument to it, instead of returning a new value.</p>
<p class="calibre2"/>
<p class="calibre2">We can remove elements from the end of an <kbd class="calibre12">array</kbd> using <kbd class="calibre12">pop!</kbd>:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; pop!(arr) 
7 
 
julia&gt; arr 
6-element Array{Int64,1}: 
 1 
 2 
 3 
 4 
 5 
 6</strong> </pre>
<p class="calibre2">The call to the <kbd class="calibre12">pop!</kbd> function has removed the last element of <kbd class="calibre12">arr</kbd> and returned it.</p>
<p class="calibre2">If we want to remove an element other than the last, we can use the <kbd class="calibre12">deleteat!</kbd> function, indicating the index that we want to be removed:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; deleteat!(arr, 3) 
5-element Array{Int64,1}: 
 1 
 2 
 4 
 5 
 6 
</strong> </pre>
<p class="calibre2">Finally, a word of warning when mutating arrays. In Julia, the arrays are passed to functions by reference. This means that the original array is being sent as the argument to the various mutating functions, and not its copy. Beware not to accidentally make unwanted modifications. Similarly, when assigning an array to a variable, a new reference is created, but the data is not copied. So for instance:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; arr = [1,2,3] 
3-element Array{Int64,1}: 
 1 
 2 
 3 
 
julia&gt; arr2 = arr 
3-element Array{Int64,1}: 
 1 
 2 
 3</strong></pre>
<p class="calibre2"/>
<p class="calibre2"/>
<p class="calibre2">Now we <kbd class="calibre12">pop</kbd> an element off <kbd class="calibre12">arr2</kbd>:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; pop!(arr2) 
3</strong> </pre>
<p class="calibre2">So, <kbd class="calibre12">arr2</kbd> looks like this:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; arr2 
2-element Array{Int64,1}: 
 1 
 2</strong> </pre>
<p class="calibre2">But our original array was modified, too:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; arr 
2-element Array{Int64,1}: 
 1 
 2 
</strong> </pre>
<p class="calibre2">Assigning <kbd class="calibre12">arr</kbd> to <kbd class="calibre12">arr2</kbd> does not copy the values of <kbd class="calibre12">arr</kbd> into <kbd class="calibre12">arr2</kbd> , it only creates a new binding (a new name) that points to the original <kbd class="calibre12">arr</kbd> array. To create a separate array with the same values, we need to use the <kbd class="calibre12">copy</kbd> function:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; arr 
2-element Array{Int64,1}: 
 1 
 2 
 
julia&gt; arr2 = copy(arr) 
2-element Array{Int64,1}: 
 1 
 2</strong> </pre>
<p class="calibre2">Now, if we <kbd class="calibre12">pop</kbd> an element off the copied array:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; pop!(arr2) 
2</strong> </pre>
<p class="calibre2">Our original array is untouched:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; arr 
2-element Array{Int64,1}: 
 1 
 2</strong></pre>
<p class="calibre2"/>
<p class="calibre2">Only the copy was modified:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; arr2 
1-element Array{Int64,1}: 
 1</strong> </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Comprehensions</h1>
                </header>
            
            <article>
                
<p class="calibre2">Array comprehensions provide a very powerful way to construct arrays. It is similar to the previously discussed array literal notation, but instead of passing in the actual values, we use a computation over an iterable object.</p>
<p class="calibre2">An example will make it clear:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; [x += 1 for x = 1:5] 
10-element Array{Int64,1}: 
  2 
  3 
  4 
  5 
  6</strong><br class="title-page-name"/><br class="title-page-name"/></pre>
<p class="calibre2">This can be read as—<em class="calibre16">for each element</em> <kbd class="calibre12">x</kbd> <em class="calibre16">within the range</em> <kbd class="calibre12">1</kbd> <em class="calibre16">to</em> <kbd class="calibre12">5</kbd>, <em class="calibre16">compute</em> <kbd class="calibre12">x+1</kbd> <em class="calibre16">and put the resultant value in the array</em>.</p>
<p class="calibre2">Just like with the <em class="calibre16">plain</em> array literals, we can constrain the type:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; Float64[x+=1 for x = 1:5] 
5-element Array{Float64,1}: 
 2.0 
 3.0 
 4.0 
 5.0 
 6.0 
</strong> </pre>
<p class="calibre2">Similarly, we can create multi-dimensional arrays:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; [x += y for x = 1:5, y = 11:15] 
5×5 Array{Int64,2}: 
 12  13  14  15  16 
 13  14  15  16  17 
 14  15  16  17  18 
 15  16  17  18  19 
 16  17  18  19  20</strong> 
 </pre>
<p class="calibre2"/>
<p class="calibre2"/>
<p class="calibre2">Comprehensions can be filtered using the <kbd class="calibre12">if</kbd> keyword:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; [x += 1 for x = 1:10 if x/2 &gt; 3] 
4-element Array{Int64,1}: 
  8 
  9 
 10 
 11</strong> </pre>
<p class="calibre2">In this case, we only kept the values where <kbd class="calibre12">x/2</kbd> was greater than <kbd class="calibre12">3</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Generators</h1>
                </header>
            
            <article>
                
<p class="calibre2">But the superpower of the comprehensions is activated when they are used for creating generators. Generators can be iterated to produce values on demand, instead of allocating an array and storing all the values in advance. You'll see what that means in a second.</p>
<p class="calibre2">Generators are defined just like array comprehensions, but without the square brackets:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; (x+=1 for x = 1:10) 
Base.Generator{UnitRange{Int64},##41#42}(#41, 1:10)</strong> 
 </pre>
<p class="calibre2">They allow us to work with potentially infinite collections. Check the following example, where we want to print the numbers from one to one million with a cube less than or equal to <kbd class="calibre12">1_000</kbd>:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; for i in [x^3 for x=1:1_000_000] 
           i &gt;= 1_000 &amp;&amp; break 
           println(i) 
end 
1 
8 
27 
64 
125 
216 
343 
512 
729</strong> 
 </pre>
<p class="calibre2">This computation uses significant resources because the comprehension creates the full array of 1 million items, despite the fact that we only iterate over its first nine elements.</p>
<p class="calibre2"/>
<p class="calibre2"/>
<p class="calibre2">We can see that by benchmarking the code using the handy <kbd class="calibre12">@time</kbd> construct:</p>
<pre class="calibre17">@time for i in [x^3 for x=1:1_000_000] 
   i &gt;= 1_000 &amp;&amp; break 
   println(i) 
end 
<br class="title-page-name"/>0.035739 seconds (58.46 k allocations: 10.493 MiB)<br class="title-page-name"/><br class="title-page-name"/></pre>
<p class="calibre2">Over 10 MB of memory and almost 60,000 allocations. Compare this with using a generator:</p>
<pre class="calibre17">@time for i in (x^3 for x=1:1_000_000) 
   i &gt;= 1_000 &amp;&amp; break 
   println(i) 
end 
<br class="title-page-name"/> 
0.019681 seconds (16.63 k allocations: 898.414 KiB)  
 </pre>
<p class="calibre2">Less than 1 MB and a quarter of the number of allocations. The difference will be even more dramatic if we increase from 1 million to 1 billion:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; @time for i in [x^3 for x=1:1_000_000_000] 
          i &gt;= 1_000 &amp;&amp; break 
          println(i) 
       end 
1 
8 
27 
64 
125 
216 
343 
512 
729</strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1"> 
 10.405833 seconds (58.48 k allocations: 7.453 GiB, 3.41% gc time)</strong> </pre>
<p class="calibre2">Over 10 seconds and 7 GB of memory used!</p>
<p class="calibre2">On the other hand, the generator runs practically in constant time:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; @time for i in (x^3 for x=1:1_000_000_000) 
          i &gt;= 1_000 &amp;&amp; break 
          println(i) 
       end 
1 
8 
27 
64 
125 
216 
343 
512 
729 
 
  0.020068 seconds (16.63 k allocations: 897.945 KiB</strong> </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Exploratory data analysis with Julia</h1>
                </header>
            
            <article>
                
<p class="calibre2">Now that you have a good understanding of Julia's basics, we can apply this knowledge to our first project. We'll start by applying <strong class="calibre4">exploratory data analysis</strong> (<strong class="calibre4">EDA</strong>) to the Iris flower dataset.</p>
<p class="calibre2">If you already have experience with data analysis, you might've used the Iris dataset before. If so, that's great! You'll be familiar with the data and the way things are done in your (previous) language of choice, and can now focus on the Julia way.</p>
<p class="calibre2">On the contrary, if this is the first time you've  heard about the Iris flower dataset, no need to worry. This dataset is considered the <kbd class="calibre12">Hello World</kbd> of data science—and we'll take a good look at it using Julia's powerful toolbox. Enjoy!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Iris flower dataset</h1>
                </header>
            
            <article>
                
<p class="calibre2">Also called <strong class="calibre4">Fisher's Iris dataset</strong>, it was first introduced in 1936 by British statistician and biologist Ronald Fisher. The dataset consists of 50 samples from each of three species of Iris flower (Iris setosa, Iris virginica, and Iris versicolor). It is sometimes called <strong class="calibre4">Anderson's Iris dataset</strong> because Edgar Anderson collected the data. Four features were measured—the length and the width of the sepals and petals (in centimeters).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using the RDatasets package</h1>
                </header>
            
            <article>
                
<p class="calibre2">Finding good-quality data for learning, teaching, and statistical software development can be challenging. That's why the industry practically standardized the use of over 10,00 high-quality datasets. These were originally distributed with the statistical software environment R. Hence, they've been aptly named the <kbd class="calibre12">RDatasets</kbd>.</p>
<p class="calibre2"/>
<p class="calibre2"/>
<p class="calibre2"/>
<p class="calibre2"/>
<p class="calibre2"/>
<p class="calibre2"><span class="calibre5">The Iris flower dataset is part of this collection. There are many ways to download it, but the most convenient is through the </span><kbd class="calibre12">RDatasets</kbd> <span class="calibre5">package. This package provides an easy way for Julia users to experiment with most of the standard datasets available in R or included with R's most popular packages. Sounds great; let's add it.</span></p>
<p class="calibre2"><span class="calibre5">First, switch to package management mode:</span></p>
<pre class="calibre17"><strong class="calibre1">    <span>julia&gt; ]</span>
    <span>pkg&gt; add RDatasets</span>
 </strong> </pre>
<p class="calibre2">Once the package is added, let's tell Julia that we want to use it:</p>
<pre class="calibre17"><strong class="calibre1">    <span>julia&gt; using RDatasets</span>
  </strong></pre>
<p class="calibre2">We can peek at the included datasets by calling <kbd class="calibre12">RDatasets.datasets()</kbd>. It returns a list of all the 700+ datasets available with <kbd class="calibre12">RDatasets</kbd>. It includes details about the data package, the name of the dataset, its title (or info), number of rows, and number of columns. These are the first 20 rows:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; RDatasets.datasets()</strong> </pre>
<p class="calibre2">The output is as follows:</p>
<p class="CDPAlignCenter"><img src="assets/0b2c6fea-7db3-4a7f-98a2-c1828440a299.png" class="calibre18"/></p>
<p class="calibre2">You can see that the datasets are part of a <kbd class="calibre12">Package</kbd>—we can use that to filter by it. The Iris flower dataset is part of the <em class="calibre16">datasets</em> package.</p>
<p class="calibre2">All we have to do now is load the data:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; iris = dataset("datasets", "iris")</strong> </pre>
<p class="calibre2">The output is as follows:</p>
<p class="CDPAlignCenter"><img src="assets/24730ac1-e5b6-4be2-9a2c-f942cb6efd3b.png" class="calibre34"/></p>
<p class="calibre2">The returned value is a <kbd class="calibre12">DataFrame</kbd> object with 150 rows and five columns—<kbd class="calibre12">SepalLength</kbd>, <kbd class="calibre12">SepalWidth</kbd>, <kbd class="calibre12">PetalLength</kbd>, <kbd class="calibre12">PetalWidth</kbd>, and <kbd class="calibre12">Species</kbd>, plus an automatically added id column called <kbd class="calibre12">Row</kbd>.</p>
<p class="calibre2">Dataframes are the <em class="calibre16">de facto</em> standard for working with tabular data in Julia. They are a key part of Julia's data analysis toolset and we'll discuss them in detail in the next chapters. For now, it suffices to say that, as you can see in the previous examples, it represents a data structure that looks very much like a table or a spreadsheet.</p>
<p class="calibre2">You can programmatically retrieve the names of the columns using the following:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; names(iris) 
5-element Array{Symbol,1}: 
 :SepalLength 
 :SepalWidth 
 :PetalLength 
 :PetalWidth 
 :Species 
</strong> </pre>
<p class="calibre2">To check the size, use the following:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; size(iris) 
(150, 5)</strong></pre>
<p class="calibre2">The result is a tuple that matches the number of rows and columns—<kbd class="calibre12">(rows, cols)</kbd>. Yep, as already established, <kbd class="calibre12">150</kbd> rows over <kbd class="calibre12">5</kbd> columns.</p>
<p class="calibre2">Let's take a look at the data:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; head(iris)</strong> </pre>
<p class="calibre2">The output is as follows:</p>
<p class="CDPAlignCenter"><img src="assets/7b78cf2e-e2e2-4e20-b09c-caa367d66762.png" class="calibre35"/></p>
<p class="calibre2">The <kbd class="calibre12">head</kbd> function shows the top six rows. Optionally, it takes a second parameter to indicate the number of rows: <kbd class="calibre12">head(iris, 10)</kbd>. There's also its twin, <kbd class="calibre12">tail()</kbd>, which will display the bottom rows of the <kbd class="calibre12">DataFrame</kbd>:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; tail(iris, 10)</strong> </pre>
<p class="calibre2">The output is as follows:</p>
<p class="CDPAlignCenter"><img src="assets/bf1d35bf-2af0-4fc5-87bb-ad0afa39d241.png" class="calibre36"/></p>
<p class="calibre2">In regard to the species present in the dataset, we see <span class="calibre5"><em class="calibre16">setosa</em></span> in the head rows and <span class="calibre5"><em class="calibre16">virginica</em></span> at the bottom. We should have three species, though, according to the description of the data. Let's ask for a row count grouped by <kbd class="calibre12">Species</kbd>:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; by(iris, :Species, nrow)</strong></pre>
<p class="calibre2"/>
<p class="calibre2">The output is as follows:</p>
<p class="CDPAlignCenter"><img src="assets/6e36265b-8e7d-48e5-bf48-ec8d4e03c2b3.png" class="calibre37"/></p>
<p class="calibre2">The <kbd class="calibre12">by</kbd> function takes three parameters—the dataset, the name of the column, and a grouping function—in this case, <kbd class="calibre12">nrow</kbd>, which computes the number of rows. We can see that the third species is <span class="calibre5"><em class="calibre16">versicolor</em>, </span>and for each of the species we have <kbd class="calibre12">50</kbd> records.</p>
<div class="packttip">I'm sure you're wondering why, in the preceding example, the name of the column is prefixed by a colon "<kbd class="calibre24">:</kbd>". It is a <kbd class="calibre24">Symbol</kbd>. We'll discuss more about symbols when we learn about metaprogramming. For now, you can just think of symbols as identifiers or labels.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using simple statistics to better understand our data</h1>
                </header>
            
            <article>
                
<p class="calibre2">Now that it's clear how the data is structured and what is contained in the collection, we can get a better understanding by looking at some basic stats.</p>
<p class="calibre2">To get us started, let's invoke the <kbd class="calibre12">describe</kbd> function:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; describe(iris)</strong></pre>
<p class="calibre2">The output is as follows:</p>
<p class="CDPAlignCenter"><img src="assets/053e3457-e544-496c-aaad-f5cd1f81c961.png" class="calibre18"/></p>
<p class="calibre2">This function summarizes the columns of the <kbd class="calibre12">iris</kbd> <kbd class="calibre12">DataFrame</kbd>. If the columns contain numerical data (such as <kbd class="calibre12">SepalLength</kbd>), it will compute the minimum, median, mean, and maximum. The number of missing and unique values is also included. The last column reports the type of data stored in the row.</p>
<p class="calibre2">A few other stats are available, including the 25<sup class="calibre38">th</sup> and the 75<sup class="calibre38">th</sup> percentile, and the first and the last values. We can ask for them by passing an extra <kbd class="calibre12">stats</kbd> argument, in the form of an array of symbols:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; describe(iris, stats=[:q25, :q75, :first, :last])</strong> </pre>
<p class="calibre2">The output is as follows:</p>
<p class="CDPAlignCenter"><img src="assets/0634a453-5f96-45eb-9df7-a0b496f89aa3.png" class="calibre39"/></p>
<p class="calibre2">Any combination of stats labels is accepted. These are all the options—<kbd class="calibre12">:mean</kbd>, <kbd class="calibre12">:std</kbd>, <kbd class="calibre12">:min</kbd>, <kbd class="calibre12">:q25</kbd>, <kbd class="calibre12">:median</kbd>, <kbd class="calibre12">:q75</kbd>, <kbd class="calibre12">:max</kbd>, <kbd class="calibre12">:eltype</kbd>, <kbd class="calibre12">:nunique</kbd>, <kbd class="calibre12">:first</kbd>, <kbd class="calibre12">:last</kbd>, and <kbd class="calibre12">:nmissing</kbd>.</p>
<p class="calibre2">In order to get all the stats, the special <kbd class="calibre12">:all</kbd> value is accepted:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; describe(iris, stats=:all)</strong></pre>
<p class="calibre2">The output is as follows:</p>
<p class="CDPAlignCenter"><img src="assets/35176292-d49a-4cfa-a733-5387879f8d0a.png" class="calibre18"/></p>
<p class="calibre2">We can also compute these individually by using Julia's <kbd class="calibre12">Statistics</kbd> package. For example, to calculate the <span class="calibre5">mean</span> of the <kbd class="calibre12">SepalLength</kbd> column, we'll execute the following:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; using Statistics 
julia&gt; mean(iris[:SepalLength]) 
5.843333333333334 
</strong> </pre>
<p class="calibre2"/>
<p class="calibre2">In this example, we use <kbd class="calibre12">iris[:SepalLength]</kbd> to select the whole column. The result, not at all surprisingly, is the same as that returned by the corresponding <kbd class="calibre12">describe()</kbd> value.</p>
<p class="calibre2">In a similar way we can compute the <kbd class="calibre12">median()</kbd>:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; median(iris[:SepalLength]) 
5.8</strong> </pre>
<p class="calibre2">And there's (a lot) more, such as, for instance, the standard deviation <kbd class="calibre12">std()</kbd>:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; std(iris[:SepalLength]) 
0.828066127977863</strong> 
 </pre>
<p class="calibre2">Or, we can use another function from the <kbd class="calibre12">Statistics</kbd> package, <kbd class="calibre12">cor(),</kbd> in a simple script to help us understand how the values are correlated:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; for x in names(iris)[1:end-1]    
        for y in names(iris)[1:end-1] 
          println("$x \t $y \t $(cor(iris[x], iris[y]))") 
        end 
        println("-------------------------------------------") 
      end</strong><br class="title-page-name"/><br class="title-page-name"/></pre>
<p class="calibre2">Executing this snippet will produce the following output:</p>
<pre class="calibre17">SepalLength       SepalLength    1.0 
SepalLength       SepalWidth     -0.11756978413300191 
SepalLength       PetalLength    0.8717537758865831 
SepalLength       PetalWidth     0.8179411262715759 
-------------------------------------------<a class="calibre30">-------</a>---------- 
SepalWidth         SepalLength    -0.11756978413300191 
SepalWidth         SepalWidth     1.0 
SepalWidth         PetalLength    -0.42844010433053953 
SepalWidth         PetalWidth     -0.3661259325364388 
------------------------------------------------------------ 
PetalLength       SepalLength    0.8717537758865831 
PetalLength       SepalWidth     -0.42844010433053953 
PetalLength       PetalLength    1.0 
PetalLength       PetalWidth     0.9628654314027963 
------------------------------------------------------------ 
PetalWidth         SepalLength    0.8179411262715759 
PetalWidth         SepalWidth     -0.3661259325364388 
PetalWidth         PetalLength    0.9628654314027963 
PetalWidth         PetalWidth     1.0 
------------------------------------------------------------ 
 </pre>
<p class="calibre2"/>
<p class="calibre2"/>
<p class="calibre2">The script iterates over each column of the dataset with the exception of <kbd class="calibre12">Species</kbd> (the last column, which is not numeric), and generates a basic correlation table. The table shows strong positive correlations between <kbd class="calibre12">SepalLength</kbd> and <kbd class="calibre12">PetalLength</kbd> (87.17%), <kbd class="calibre12">SepalLength</kbd> and <kbd class="calibre12">PetalWidth</kbd> (81.79%), and <kbd class="calibre12">PetalLength</kbd> and <kbd class="calibre12">PetalWidth</kbd> (96.28%). There is no strong correlation between <kbd class="calibre12">SepalLength</kbd> and <kbd class="calibre12">SepalWidth</kbd>.</p>
<p class="calibre2">We can use the same script, but this time employ the <kbd class="calibre12">cov()</kbd> function to compute the covariance of the values in the dataset:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; for x in names(iris)[1:end-1] 
         for y in names(iris)[1:end-1] 
           println("$x \t $y \t $(cov(iris[x], iris[y]))") 
         end 
         println("--------------------------------------------") 
       end</strong> </pre>
<p class="calibre2">This code will generate the following output:</p>
<pre class="calibre17">SepalLength       SepalLength    0.6856935123042507 
SepalLength       SepalWidth     -0.04243400447427293 
SepalLength       PetalLength    1.2743154362416105 
SepalLength       PetalWidth     0.5162706935123043 
------------------------------------------------------- 
SepalWidth         SepalLength    -0.04243400447427293 
SepalWidth         SepalWidth     0.189979418344519 
SepalWidth         PetalLength    -0.3296563758389262 
SepalWidth         PetalWidth     -0.12163937360178968 
------------------------------------------------------- 
PetalLength       SepalLength    1.2743154362416105 
PetalLength       SepalWidth     -0.3296563758389262 
PetalLength       PetalLength    3.1162778523489933 
PetalLength       PetalWidth     1.2956093959731543 
------------------------------------------------------- 
PetalWidth         SepalLength    0.5162706935123043 
PetalWidth         SepalWidth     -0.12163937360178968 
PetalWidth         PetalLength    1.2956093959731543 
PetalWidth         PetalWidth     0.5810062639821031 
------------------------------------------------------- </pre>
<p class="calibre2">The output illustrates that <kbd class="calibre12">SepalLength</kbd> is positively related to <kbd class="calibre12">PetalLength</kbd> and <kbd class="calibre12">PetalWidth</kbd>, while being negatively related to <kbd class="calibre12">SepalWidth</kbd>. <kbd class="calibre12">SepalWidth</kbd> is negatively related to all the other values.</p>
<p class="calibre2">Moving on, if we want a random data sample, we can ask for it like this:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; rand(iris[:SepalLength]) 
7.4</strong></pre>
<p class="calibre2"/>
<p class="calibre2"/>
<p class="calibre2"/>
<p class="calibre2"/>
<p class="calibre2">Optionally, we can pass in the number of values to be sampled:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; rand(iris[:SepalLength], 5) 
5-element Array{Float64,1}: 
 6.9 
 5.8 
 6.7 
 5.0 
 5.6 
</strong> </pre>
<p class="calibre2">We can convert one of the columns to an array using the following:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; sepallength = Array(iris[:SepalLength]) 
150-element Array{Float64,1}: 
 5.1 
 4.9 
 4.7 
 4.6 
 5.0 
 # ... output truncated ...</strong> 
 </pre>
<p class="calibre2">Or we can convert the whole <kbd class="calibre12">DataFrame</kbd> to a matrix:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; irisarr = convert(Array, iris[:,:]) 
150×5 Array{Any,2}: 
 5.1  3.5  1.4  0.2  CategoricalString{UInt8} "setosa"    
 4.9  3.0  1.4  0.2  CategoricalString{UInt8} "setosa"    
 4.7  3.2  1.3  0.2  CategoricalString{UInt8} "setosa"    
 4.6  3.1  1.5  0.2  CategoricalString{UInt8} "setosa"    
 5.0  3.6  1.4  0.2  CategoricalString{UInt8} "setosa"   
 # ... output truncated ...</strong> </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Visualizing the Iris flowers data</h1>
                </header>
            
            <article>
                
<p class="calibre2">Visualization is a powerful tool in exploratory data analysis, helping us to identify patterns that would otherwise be hard to spot just by looking at the numbers. Julia provides access to some excellent plotting packages that are very easy to set up and use.</p>
<p class="calibre2">We'll illustrate with some plots created with Gadfly.</p>
<p class="calibre2"><span class="calibre5">We'll start by adding </span>Gadfly <span class="calibre5">with </span><kbd class="calibre12">pkg&gt; add "Gadfly"</kbd>an<span class="calibre5">d we'll continue with </span><kbd class="calibre12">julia&gt; using Gadfly</kbd><span class="calibre5">. This will bring into scope Gadfly's </span><kbd class="calibre12">plot()</kbd><span class="calibre5">method. Now, let's find some interesting data to visualize.</span></p>
<p class="calibre2"/>
<p class="calibre2"/>
<p class="calibre2">In the previous section, we have identified that there is a strong covariant relation between <kbd class="calibre12">SepalLength</kbd> and <kbd class="calibre12">PetalLength</kbd>. Let's plot the data:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; plot(iris, x=:SepalLength, y=:PetalLength, color=:Species) </strong></pre>
<div class="packttip">At the time of writing, Gadfly support for Julia v1 was still incomplete. If that is still the case, the unstable yet working version of Gadfly can be installed using—<span><kbd class="calibre24">pkg&gt; add Compose#master</kbd>, <kbd class="calibre24">Gadfly#master</kbd>, <kbd class="calibre24">Hexagon</kbd>.</span></div>
<p class="calibre2">Executing the <kbd class="calibre12">plot()</kbd> function will generate the following graph:</p>
<p class="CDPAlignCenter"><img src="assets/e5e56a6c-c9ce-481c-90b7-fd66be5bca88.png" class="calibre40"/></p>
<p class="calibre2">Sure enough, the plot will indicate that <kbd class="calibre12">SepalLength</kbd> and <kbd class="calibre12">PetalLength</kbd> vary together for both Iris versicolor and Iris virginica. For Iris setosa, it's not that obvious, with <kbd class="calibre12">PetalLength</kbd> staying pretty much unchanged while the sepal length grows.</p>
<p class="calibre2">A box plot will confirm the same; the sepal length of Iris setosa has little variation:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; plot(iris, x=:Species, y=:PetalLength, Geom.boxplot)</strong><br class="title-page-name"/><br class="title-page-name"/></pre>
<p class="calibre2">Plotting our values looks like this:</p>
<p class="CDPAlignCenter"><img src="assets/71de0a21-e932-406e-9471-8b014ac3fda1.png" class="calibre41"/></p>
<p class="calibre2"/>
<p class="calibre2"/>
<p class="calibre2">I have a feeling that a histogram would be even better for illustrating the distribution of the <kbd class="calibre12">PetalLength</kbd>:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; plot(iris, x=:PetalLength, color=:Species, Geom.histogram)</strong> </pre>
<p class="calibre2">Generating a histogram using the <kbd class="calibre12">PetalLength</kbd> produces the following:</p>
<p class="CDPAlignCenter"><img src="assets/e9b3d8b8-1a4c-4786-943c-b6776713a4d7.png" class="calibre42"/></p>
<p class="calibre2">If we visualize the <kbd class="calibre12">PetalWidth</kbd> values as a histogram, we'll notice a similar pattern:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; plot(iris, x=:PetalWidth, color=:Species, Geom.histogram)</strong></pre>
<p class="calibre2">The output is as follows:</p>
<p class="CDPAlignCenter"><img src="assets/cbea6825-f0aa-4f35-b41e-51223b2c175f.png" class="calibre43"/></p>
<p class="calibre2">Plotting the petal width and height for the three species should now provide a strong indication that, for example, we can successfully classify Iris setosa based on the two values:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; plot(iris, x=:PetalWidth, y=:PetalLength, color=:Species)</strong></pre>
<p class="calibre2"/>
<p class="calibre2"/>
<p class="calibre2">The output is as follows:</p>
<p class="CDPAlignCenter"><img src="assets/28ab11d2-ba23-4f48-839c-eb529e1679f8.png" class="calibre44"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Loading and saving our data</h1>
                </header>
            
            <article>
                
<p class="calibre2">Julia comes with excellent facilities for reading and storing data out of the box. Given its focus on data science and scientific computing, support for tabular-file formats (CSV, TSV) is first class.</p>
<p class="calibre2">Let's extract some data from our initial dataset and use it to practice persistence and retrieval from various backends.</p>
<p class="calibre2">We can reference a section of a <kbd class="calibre12">DataFrame</kbd> by defining its bounds through the corresponding columns and rows. For example, we can define a new <kbd class="calibre12">DataFrame</kbd> composed only of the <kbd class="calibre12">PetalLength</kbd> and <kbd class="calibre12">PetalWidth</kbd> columns and the first three rows:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; iris[1:3, [:PetalLength, :PetalWidth]] 
3×2 DataFrames.DataFrame 
│ Row │ PetalLength │ PetalWidth │ 
├─────┼─────────────┼────────────┤ 
│ 1   │ 1.4         │ 0.2        │ 
│ 2   │ 1.4         │ 0.2        │ 
│ 3   │ 1.3         │ 0.2        │ 
</strong> </pre>
<p class="calibre2"/>
<p class="calibre2"/>
<p class="calibre2"/>
<p class="calibre2"/>
<p class="calibre2">The generic indexing notation is <kbd class="calibre12">dataframe[rows, cols]</kbd>, where <kbd class="calibre12">rows</kbd> can be a number, a range, or an <kbd class="calibre12">Array</kbd> of <kbd class="calibre12">boolean</kbd> values where <kbd class="calibre12">true</kbd> indicates that the row should be included:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; iris[trues(150), [:PetalLength, :PetalWidth]]</strong> </pre>
<p class="calibre2">This snippet will select all the <kbd class="calibre12">150</kbd> rows since <kbd class="calibre12">trues(150)</kbd> constructs an <kbd class="calibre12">array</kbd> of <kbd class="calibre12">150</kbd> elements that are all initialized as <kbd class="calibre12">true</kbd>. The same logic applies to <kbd class="calibre12">cols</kbd>, with the added benefit that they can also be accessed by name.</p>
<p class="calibre2">Armed with this knowledge, let's take a sample from our original dataset. It will include some 10% of the initial data and only the <kbd class="calibre12">PetalLength</kbd>, <kbd class="calibre12">PetalWidth</kbd>, and <kbd class="calibre12">Species</kbd> columns:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; test_data = iris[rand(150) .&lt;= 0.1, [:PetalLength, :PetalWidth, :Species]] 
10×3 DataFrames.DataFrame 
│ Row │ PetalLength │ PetalWidth │ Species      │ 
├─────┼─────────────┼────────────┼──────────────┤ 
│ 1   │ 1.1         │ 0.1        │ "setosa"     │ 
│ 2   │ 1.9         │ 0.4        │ "setosa"     │ 
│ 3   │ 4.6         │ 1.3        │ "versicolor" │ 
│ 4   │ 5.0         │ 1.7        │ "versicolor" │ 
│ 5   │ 3.7         │ 1.0        │ "versicolor" │ 
│ 6   │ 4.7         │ 1.5        │ "versicolor" │ 
│ 7   │ 4.6         │ 1.4        │ "versicolor" │ 
│ 8   │ 6.1         │ 2.5        │ "virginica"  │ 
│ 9   │ 6.9         │ 2.3        │ "virginica"  │ 
│ 10  │ 6.7         │ 2.0        │ "virginica"  │ 
</strong> </pre>
<p class="calibre2">What just happened here? The secret in this piece of code is <kbd class="calibre12">rand(150) .&lt;= 0.1</kbd>. It does a lot—first, it generates an array of random <kbd class="calibre12">Float</kbd> values between 0 and 1; then, it compares the array, element-wise, against 0.1 (which represents 10% of 1); and finally, the resultant <kbd class="calibre12">Boolean</kbd> array is used to filter out the corresponding rows from the dataset. It's really impressive how powerful and succinct Julia can be!</p>
<p class="calibre2">In my case, the result is a <kbd class="calibre12">DataFrame</kbd> with the preceding 10 rows, but your data will be different since we're picking random rows (and it's quite possible you won't have exactly 10 rows either).</p>
<p class="calibre2"/>
<p class="calibre2"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Saving and loading using tabular file formats</h1>
                </header>
            
            <article>
                
<p class="calibre2">We can easily save this data to a file in a tabular file format (one of CSV, TSV, and others) using the <kbd class="calibre12">CSV</kbd> package. We'll have to add it first and then call the <kbd class="calibre12">write</kbd> method:</p>
<pre class="calibre17"><strong class="calibre1">pkg&gt; add CSV 
julia&gt; using CSV 
julia&gt; CSV.write("test_data.csv", test_data) </strong> </pre>
<p class="calibre2">And, just as easily, we can read back the data from tabular file formats, with the corresponding <kbd class="calibre12">CSV.read</kbd> function:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; td = CSV.read("test_data.csv") 
10×3 DataFrames.DataFrame 
│ Row │ PetalLength │ PetalWidth │ Species      │ 
├─────┼─────────────┼────────────┼──────────────┤ 
│ 1   │ 1.1         │ 0.1        │ "setosa"     │ 
│ 2   │ 1.9         │ 0.4        │ "setosa"     │ 
│ 3   │ 4.6         │ 1.3        │ "versicolor" │ 
│ 4   │ 5.0         │ 1.7        │ "versicolor" │ 
│ 5   │ 3.7         │ 1.0        │ "versicolor" │ 
│ 6   │ 4.7         │ 1.5        │ "versicolor" │ 
│ 7   │ 4.6         │ 1.4        │ "versicolor" │ 
│ 8   │ 6.1         │ 2.5        │ "virginica"  │ 
│ 9   │ 6.9         │ 2.3        │ "virginica"  │ 
│ 10  │ 6.7         │ 2.0        │ "virginica"  │</strong> </pre>
<p class="calibre2">Just specifying the file extension is enough for Julia to understand how to handle the document (CSV, TSV), both when writing and reading.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Working with Feather files</h1>
                </header>
            
            <article>
                
<p class="calibre2"><span class="calibre5">Feather is a binary file format that was specially designed for storing data frames. It is fast, lightweight, and language-agnostic. The project was initially started in order to make it possible to exchange data frames between R and Python. Soon, other languages added support for it, including Julia.</span></p>
<p class="calibre2"><span class="calibre5">Support for Feather files does not come out of the box, but is made available through the homonymous package. Let's go ahead and add it and then bring it into scope:</span></p>
<pre class="calibre17"><strong class="calibre1">pkg&gt; add Feather  
<span>julia&gt; using Feather</span></strong></pre>
<p class="calibre2"/>
<p class="calibre2"/>
<p class="calibre2"/>
<p class="calibre2"/>
<p class="calibre2">Now, saving our <kbd class="calibre12">DataFrame</kbd> is just a matter of calling <kbd class="calibre12">Feather.write</kbd>:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; Feather.write("test_data.feather", test_data)</strong> <br class="title-page-name"/><br class="title-page-name"/></pre>
<p class="calibre2">Next, let's try the reverse operation and load back our Feather file. We'll use the counterpart <kbd class="calibre12">read</kbd> function:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; Feather.read("test_data.feather") 
10×3 DataFrames.DataFrame 
│ Row │ PetalLength │ PetalWidth │ Species      │ 
├─────┼─────────────┼────────────┼──────────────┤ 
│ 1   │ 1.1         │ 0.1        │ "setosa"     │ 
│ 2   │ 1.9         │ 0.4        │ "setosa"     │ 
│ 3   │ 4.6         │ 1.3        │ "versicolor" │ 
│ 4   │ 5.0         │ 1.7        │ "versicolor" │ 
│ 5   │ 3.7         │ 1.0        │ "versicolor" │ 
│ 6   │ 4.7         │ 1.5        │ "versicolor" │ 
│ 7   │ 4.6         │ 1.4        │ "versicolor" │ 
│ 8   │ 6.1         │ 2.5        │ "virginica"  │ 
│ 9   │ 6.9         │ 2.3        │ "virginica"  │ 
│ 10  │ 6.7         │ 2.0        │ "virginica"  │</strong> 
 </pre>
<p class="calibre2">Yeah, that's our sample data all right!</p>
<div class="packttip">In order to provide compatibility with other languages, the Feather format imposes some restrictions on the data types of the columns. You can read more about Feather in the package's official documentation at <span><a href="https://juliadata.github.io/Feather.jl/latest/index.html" class="calibre19">https://juliadata.github.io/Feather.jl/latest/index.html</a>.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Saving and loading with MongoDB</h1>
                </header>
            
            <article>
                
<p class="calibre2">Before closing this chapter, let's take a look at using a NoSQL backend for persisting and retrieving our data. Don't worry, we'll extensively cover interaction with relational databases in the upcoming chapters too.</p>
<p class="calibre2">In order to follow through this chapter, you'll need a working MongoDB installation. You can download and install the correct version for your operating system from the official website, at <span class="calibre5"><a href="https://www.mongodb.com/download-center?jmp=nav#community" class="calibre9">https://www.mongodb.com/download-center?jmp=nav#community</a></span>. I will use a Docker image which I installed and started up through Docker's Kitematic (available for download at <a href="https://github.com/docker/kitematic/releases" class="calibre9"><span>https://github.com/docker/kitematic/releases</span></a>).</p>
<p class="calibre2"/>
<p class="calibre2"/>
<p class="calibre2">Next, we need to make sure to add the <kbd class="calibre12">Mongo</kbd> package. The package also has a dependency on <kbd class="calibre12">LibBSON</kbd>, which is automatically added. <kbd class="calibre12">LibBSON</kbd> is used for handling <kbd class="calibre12">BSON</kbd>, which stands for <em class="calibre16">Binary JSON</em>, a binary-encoded serialization of JSON-like documents. While we're at it, let's add the <kbd class="calibre12">JSON</kbd> package as well; we will need it. I'm sure you know how to do that by now—if not, here is a reminder:</p>
<pre class="calibre17"><strong class="calibre1">pkg&gt; add Mongo, JSON</strong> </pre>
<div class="packttip">At the time of writing, Mongo.jl support for Julia v1 was still a work in progress. This code was tested using Julia v0.6.</div>
<p class="calibre2">Easy! Let's let Julia know that we'll be using all these packages:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; using Mongo, LibBSON, JSON 
 </strong></pre>
<p class="calibre2">We're now ready to connect to MongoDB:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; client = MongoClient() 
 </strong></pre>
<p class="calibre2">Once successfully connected, we can reference a <kbd class="calibre12">dataframes</kbd> collection in the <kbd class="calibre12">db</kbd> database:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; storage = MongoCollection(client, "db", "dataframes") </strong> </pre>
<p class="calibre2">Julia's MongoDB interface uses <span class="calibre5">dictionaries</span> (a data structure called <kbd class="calibre12">Dict</kbd> in Julia) to communicate with the server. We'll look at <kbd class="calibre12">dicts</kbd> in more detail in the next chapter. For now, all we need to do is to convert our <kbd class="calibre12">DataFrame</kbd> to such a <kbd class="calibre12">Dict</kbd>. The simplest way to do it is to sequentially serialize and then deserialize the <kbd class="calibre12">DataFrame</kbd> by using the <kbd class="calibre12">JSON</kbd><span class="calibre5"> pa</span>ckage. It generates a nice structure that we can later use to rebuild our <kbd class="calibre12">DataFrame</kbd>:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; datadict = JSON.parse(JSON.json(test_data))</strong> </pre>
<p class="calibre2">Thinking ahead, to make any future data retrieval simpler, let's add an identifier to our <span class="calibre5">dictionary</span>:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; datadict["id"] = "iris_test_data" 
 </strong></pre>
<p class="calibre2">Now we can insert it into Mongo:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; insert(storage, datadict) 
 </strong></pre>
<p class="calibre2"/>
<p class="calibre2"/>
<p class="calibre2">In order to retrieve it, all we have to do is query the Mongo database using the <span class="calibre5">"id"</span> field we've previously configured:</p>
<pre class="calibre17"><strong class="calibre1">Julia&gt; data_from_mongo = first(find(storage, query("id" =&gt; "iris_test_data")))</strong> </pre>
<p class="calibre2">We get a <kbd class="calibre12">BSONObject</kbd>, which we need to convert back to a <kbd class="calibre12">DataFrame</kbd>. Don't worry, it's straightforward. First, we create an empty <kbd class="calibre12">DataFrame</kbd>:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; df_from_mongo = DataFrame() 
0×0 DataFrames.DataFrame</strong> 
 </pre>
<p class="calibre2">Then we populate it using the data we retrieved from Mongo:</p>
<pre class="calibre17">for i in 1:length(data_from_mongo["columns"]) 
  df_from_mongo[Symbol(data_from_mongo["colindex"]["names"][i])] =  
Array(data_from_mongo["columns"][i]) 
end <br class="title-page-name"/>julia&gt; df_from_mongo <br class="title-page-name"/>10×3 DataFrames.DataFrame 
│ Row │ PetalLength │ PetalWidth │ Species      │ 
├─────┼─────────────┼────────────┼──────────────┤ 
│ 1   │ 1.1         │ 0.1        │ "setosa"     │ 
│ 2   │ 1.9         │ 0.4        │ "setosa"     │ 
│ 3   │ 4.6         │ 1.3        │ "versicolor" │ 
│ 4   │ 5.0         │ 1.7        │ "versicolor" │ 
│ 5   │ 3.7         │ 1.0        │ "versicolor" │ 
│ 6   │ 4.7         │ 1.5        │ "versicolor" │ 
│ 7   │ 4.6         │ 1.4        │ "versicolor" │ 
│ 8   │ 6.1         │ 2.5        │ "virginica"  │ 
│ 9   │ 6.9         │ 2.3        │ "virginica"  │ 
│ 10  │ 6.7         │ 2.0        │ "virginica"  │ 
 </pre>
<p class="calibre2">And that's it! Our data has been loaded back into a <kbd class="calibre12">DataFrame</kbd>.</p>
<p class="calibre2"/>
<p class="calibre2"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p class="calibre2">Julia's intuitive syntax makes for a lean learning curve. The optional typing and the wealth of shorthand constructors result in readable, noise-free code, while the large collection of third-party packages makes accessing, manipulating, visualizing, plotting, and saving data a breeze.</p>
<p class="calibre2">Just by learning Julia's basic data structures and a few related functions, coupled with its powerful data manipulation toolset, we were able to implement an efficient data analysis workflow and extract valuable insight from the Iris flowers dataset. That was all we needed in order to perform efficient exploratory data analysis with Julia.</p>
<p class="calibre2">In the next chapter, we'll continue our journey by learning how to build a web crawler. Web mining, the process of extracting information from the web, is an important part of data mining and a key component of data acquisition in general. Julia is a great choice when building web mining software, given not only its built-in performance and its rapid prototyping features, but also the availability of powerful libraries that cover everything, from HTTP clients, to DOM parsing, to text analysis.</p>


            </article>

            
        </section>
    </body></html>