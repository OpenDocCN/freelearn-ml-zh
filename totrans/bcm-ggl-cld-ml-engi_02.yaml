- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mastering Python Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we train a machine to learn, we need to teach it a language. Computers
    are very good at binary code since they were created to operate in zeros and ones.
    Human beings have invented a language compiler to compile a high-level language
    (such as Python) program into binary code so that a computer can run it. Python
    is a high-level language that is intuitive – it has a simplified syntax very similar
    to natural language. Python is widely used in solving problems using computer
    programming, especially in **machine learning** (**ML**).
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will start with a simple mathematical problem and show how
    Python can solve it directly and concisely. Understanding the solution will help
    us understand the Python basics, including variables, data structures, conditions,
    and controls. Then, we will cover Python’s data processing packages, including
    NumPy and Pandas for data manipulation and Matplotlib and Seaborn for data visualization.
  prefs: []
  type: TYPE_NORMAL
- en: Python is a programming language and practicing is a big portion of mastering
    the language. In [*Appendix 1*](B18333_11.xhtml#_idTextAnchor184) of this book,
    we have provided a step-by-step guide to using Python data processing packages.
    Practicing these steps is essential to mastering Python skills.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The basics of Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python data libraries and packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before we begin, let’s take a look at the prerequisites for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To follow the instructions in this chapter, make sure that you have set up Google
    Colab, a product from Google Research that allows programmers to write and execute
    Python code through a browser ([https://colab.research.google.com](https://colab.research.google.com)).
    Colab is well suited to ML and data analysis, and we will use it to run basic
    Python code in this chapter. Let’s get started!
  prefs: []
  type: TYPE_NORMAL
- en: The basics of Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will cover the basics of Python programming by starting with a simple egg-counting
    problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are less than 2,000 eggs in a big basket. Let’s say that we take the
    eggs out in groups of two each time so that one egg is left in the basket at the
    end. Here, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: If a group of 3 is used, 0 are left.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a group of 4 is used, 1 is left.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a group of 5 is used, 4 are left.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a group of 6 is used, 3 are left.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a group of 7 is used, 0 are left.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a group of 8 is used, 1 is left.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a group of 9 is used, 0 are left.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, how many eggs are in the bucket?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at a solution to this problem using Python programming:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we tell the computer to try each odd number (why?) between 1
    and 2,000 and test it against all the conditions specified in the problem. If,
    for a certain number, all the conditions are met, then we print out the number.
    When all the odd numbers are examined, the numbers that meet the conditions are
    printed out. That’s neat!
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing the preceding program on Colab yields the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If we examine the Python program more closely, we can observe the following:
    we use `i` as a variable that is assigned an odd number at a time, between `1`
    and `2000`, and we use a `for` clause to construct a loop that repeatedly checks
    if the value of `i` satisfies the conditions (the `if` clause) and print the value
    if it does. The variables and their operations, the `if` clause, and the `for`
    clause are the basics of Python. Next, we will examine these basic concepts in
    Python.'
  prefs: []
  type: TYPE_NORMAL
- en: Basic Python variables and operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Programming languages use variables. A Python variable is a reserved memory
    location in a computer that stores values – that is, a variable in a Python program
    gives data to the computer for processing. Every value in Python has a data type.
    The action of placing data in a variable is called **assignment**. The action
    of calling a variable after it is created is called **using the variable**.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following actions are *assignments*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 2.1 – Python variable assignments ](img/Table_2.1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Table 2.1 – Python variable assignments
  prefs: []
  type: TYPE_NORMAL
- en: 'The following actions are *using variables*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 2.2 – Python using variables ](img/Table_2.2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Table 2.2 – Python using variables
  prefs: []
  type: TYPE_NORMAL
- en: 'To further understand the variables’ data types and their operations, let’s
    run some small Python code snippets using Colab:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Please take a moment here and make sure you understand how the preceding code
    snippet was executed to get the results.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Python variables, we can operate on them using mathematical operations.
    The following table lists the arithmetic operations for Python variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 2.3 – Python arithmetic operations](img/Table_2.3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Table 2.3 – Python arithmetic operations
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table lists the Boolean operations for Python variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 2.4 – Python Boolean operations  ](img/Table_2.4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Table 2.4 – Python Boolean operations
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table lists the logical operations for Python variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 2.5 – Python logical operations ](img/Table_2.5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Table 2.5 – Python logical operations
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve introduced Python variables and their basic operations, let’s
    look at Python’s basic data structures and control operations.
  prefs: []
  type: TYPE_NORMAL
- en: Basic Python data structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Python has five basic data types:'
  prefs: []
  type: TYPE_NORMAL
- en: Numbers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tuples
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dictionaries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Since we’ve already covered numbers and strings, we will cover **lists**, **tuples**,
    and **dictionaries** here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A `[ ]`. The following is an example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The basic operations of lists are shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 2.6 – Python list operations  ](img/Table_2.6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Table 2.6 – Python list operations
  prefs: []
  type: TYPE_NORMAL
- en: 'A `()`. The following is an example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A `{}`, and the key-value pairs inside a dictionary are separated by commas
    (`,`). Each key is separated from its value by a colon (`:`). The following is
    an example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Python conditions and loops
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Python programs need to make decisions based on conditions, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**if** (condition) **else** (action)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**while** (condition) **do** (action loop)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**for** (condition) **do** (action loop)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As you saw in the egg-counting program, it contains a `for` loop and `if` statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: With the `for` loop and `if` statements, the problem was solved. These control
    statements manage how the logic flows in Python programs.
  prefs: []
  type: TYPE_NORMAL
- en: Python functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Python functions have two parts in a program: the **function definition** and
    the **function call**. First, a function is defined, and then the function that
    was defined is called. Let’s look at an example to explain function definition
    and calling:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Find all the prime numbers between 1 and 100'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Solution**: Use Python functions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is how function definition and calling are used to solve the given problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Function 1* takes in a number and checks if it’s a prime number:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*Function 2* finds and returns all the prime numbers between the `a` and `b`
    integers. For each integer between `a` and `b`, it checks if it’s a prime number
    by calling *Function 1*. If it is, then it adds it to a list. In the end, the
    list is returned:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `main()` program finds and returns all the prime numbers between `1` and
    `100`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As you can see, when the computer executes the main program, it will call *Function
    2*, `PNlist(1,100)`, to examine the numbers between `1` and `100`: for each number,
    it will call *Function 1*, `Prime(number)`, to see if it is a prime number or
    not – if it is, it’s put into the list. Finally, the `main()` program prints the
    list of prime numbers.'
  prefs: []
  type: TYPE_NORMAL
- en: Opening and closing files in Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following Python code opens an input file and reads it from user inputs:'
  prefs: []
  type: TYPE_NORMAL
- en: Open a file named `“lifeguards.in”` for reading only.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Read a line in the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Convert the text read into integers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following Python code block calculates the answer, writes it to the output
    file, and closes the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have gone over the basics of Python, let’s solve an interesting
    problem using the knowledge and skills we have learned so far.
  prefs: []
  type: TYPE_NORMAL
- en: An interesting problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we’ll use the basic Python knowledge and skills we have learned
    so far to solve the USA Computer Olympiad problem (source: [http://www.usaco.org/index.php?page=viewproblem2&cpid=784](http://www.usaco.org/index.php?page=viewproblem2&cpid=784)).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Farmer John has opened a swimming pool and hired *N* cows as lifeguards, each
    of which has a shift that covers some contiguous interval of time during the day.
    For simplicity, the pool is open from time `t=0` until time `t=1000` daily, and
    each shift can be described by two integers – the starting and ending time. For
    example, a lifeguard starting at time `t=4` and ending at time `t=7` covers three
    time units. Unfortunately, John is over budgeted and must fire exactly one lifeguard.
    What is the maximum amount of time that can still be covered by the shifts of
    the remaining lifeguards? An interval of time is covered if at least one lifeguard
    is present. Let’s take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Input**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first line of input contains *N (1≤N≤100)*. Each of the next *N* lines describes
    a lifeguard in terms of two integers between `0` and `1000` to provide the start/end
    point of a lifeguard’s shift. All such endpoints are distinct. The shifts of different
    lifeguards may overlap.
  prefs: []
  type: TYPE_NORMAL
- en: '**Output**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Write a single number that specifies the maximum amount of time that can still
    be covered if Farmer John fires `1` lifeguard:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s look at the following diagram to understand the problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.7 – Understanding the sample inputs and output ](img/Figure_2.1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.7 – Understanding the sample inputs and output
  prefs: []
  type: TYPE_NORMAL
- en: The preceding diagram shows the sample inputs and output. Here, we can see that
    there are three guards and that their time coverages are 5-9, 1-4, and 3-7, respectively.
    If we remove the first guard, the remaining coverage will be 1-7, which is 6\.
    If we remove the second guard, the remaining coverage will be 3-9, which equals
    6\. If we remove the third guard, the remaining coverage will be 1-4 and 5-9,
    which equals 7\. So, the maximum coverage when removing one guard at a time is
    *max(6,6,7)=7*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Understanding this sample helps us think about the solution. We need to find
    out what the largest coverage is by comparing the remaining coverage after removing
    one guard at a time. The simplest way to do this is by using brute-force and Python
    lists. The following is a solution using Python:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Claim/initialize the variable and arrays:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the input file and read the input data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Read the data and assign it to variables (`start[i]` and `end[i]` are the start/end
    time for guard `i`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use a new list to record the total guard coverage at time `j`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Remove one guard at a time, compare the maximum coverages, and get the maximum:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the output file, write the output data in it, and close the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: While there are many solutions to this problem, this solution shows a simple
    and logical way to tackle the problem. It helps Python beginners follow and learn
    the problem-solving logic and skills that are required.
  prefs: []
  type: TYPE_NORMAL
- en: Python data libraries and packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we mentioned earlier, Python has five standard data types: numbers, strings,
    lists, tuples, and dictionaries. Using these data structures, Python can handle
    many tasks. To extend its ability for data manipulation and visualization, Python
    libraries and packages are created. We will briefly introduce four libraries:
    **NumPy**, **Pandas**, **Matplotlib**, and **Seaborn**.'
  prefs: []
  type: TYPE_NORMAL
- en: NumPy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: NumPy is short for **Numerical Python**. It is a fundamental library in Python
    and is a general-purpose array-processing package. NumPy is very good at basic
    and advanced array operations. It is used to process arrays that store values
    of the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: Pandas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Pandas` is considered the most powerful and flexible open source data analysis
    and manipulation tool available. It is a Python library that’s been optimized
    for data manipulation and analysis. In particular, it offers data structures and
    operations for manipulating multidimensional arrays of data. Pandas contains the
    Series and DataFrame data structures. The Series data structure is for storing
    a 1D array (or vector) of data elements, whereas a DataFrame is a Pandas data
    structure for storing and manipulating 2D arrays. In practice, we often think
    of it as an Excel spreadsheet. Pandas also has a robust set of plotting functions
    that we will also use for dataset visualizing. The plotting features of Pandas
    can be found in the `plotting` module.'
  prefs: []
  type: TYPE_NORMAL
- en: Matplotlib
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Matplotlib is a graphics package for data visualization in Python. It is a plotting
    library for the Python programming language and its numerical mathematics extension,
    NumPy, and it is well integrated with NumPy and Pandas.
  prefs: []
  type: TYPE_NORMAL
- en: Seaborn
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On top of Matplotlib, Seaborn is an open source Python library that is used
    for data visualization and exploratory data analysis. Seaborn works with Pandas
    DataFrames and supports built-in Python types such as lists and dictionaries.
    Most Seaborn functions support objects from the Pandas and NumPy libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we reviewed the Python basics, including variables, data structures,
    condition and loop clauses, and various Python data libraries. It is essential
    to understand the Python code snippets in this chapter and go through the examples
    in [*Appendix 2*](B18333_12.xhtml#_idTextAnchor195), *Practicing with Python Data
    Libraries*, where we have provided examples to help you practice using Python
    data libraries, step by step. By doing so, you can develop Python code with Google
    Colab.
  prefs: []
  type: TYPE_NORMAL
- en: Now we have built up the foundation of GCP and Python, it is time to conclude
    *Part 1* of this book. In *Part 2*, we will explore the ML process, including
    problem framing, data preparation and feature engineering, ML model development,
    neural networks, and deep learning. In this next chapter, we will look at ML problem
    framing.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To learn more about the topics that were covered in this chapter, take a look
    at the following resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://colab.research.google.com/?utm_source=scs-index](https://colab.research.google.com/?utm_source=scs-index)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://colab.research.google.com/github/cs231n/cs231n.github.io/blob/master/python-colab.ipynb](https://colab.research.google.com/github/cs231n/cs231n.github.io/blob/master/python-colab.ipynb)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.geeksforgeeks.org/python-programming-language/](https://www.geeksforgeeks.org/python-programming-language/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.geeksforgeeks.org/top-10-python-libraries-for-data-science-in-2021/](https://www.geeksforgeeks.org/top-10-python-libraries-for-data-science-in-2021/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Appendix 2*](B18333_12.xhtml#_idTextAnchor195), *Practicing with Python Data
    Libraries*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Part 2: Introducing Machine Learning'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This part introduces machine learning (ML) concepts. We start with the preparations
    for the machine learning process, including ML problem definition and data preparations.
    We dive into the ML process, including platform preparation, dataset splitting,
    model training, validation, testing, and deployment. We then introduce the modern
    ML concepts such as neural networks, deep learning, cost function, optimizer algorithm,
    activation function, and so on. We further discuss several neural network models
    and their business use cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part comprises the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 3*](B18333_03.xhtml#_idTextAnchor072), Preparing for ML Development'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 4*](B18333_04.xhtml#_idTextAnchor094), Developing and Deploying ML
    Models'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 5*](B18333_05.xhtml#_idTextAnchor116), Understanding Neural Networks
    and Deep Learning'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
