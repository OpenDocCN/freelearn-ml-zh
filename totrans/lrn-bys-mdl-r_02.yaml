- en: Chapter 2. The R Environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: R is currently one of the most popular programming environments for statistical
    computing. It was evolved as an open source language from the S programming language
    developed at Bell Labs. The main creators of R are two academicians, Robert Gentleman
    and Ross Ihaka, from the University of Auckland in New Zealand.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main reasons for the popularity of R, apart from free software under GNU
    General Public License, are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: R is very easy to use. It is an interpreted language and at the same time can
    be used for procedural programming.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: R supports both functional and object-oriented paradigms. It has very strong
    graphical and data visualization capabilities.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Through its LaTex-like documentation support, R can be used for making high-quality
    documentation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Being an open source software, R has a large number of contributed packages
    that makes almost all statistical modeling possible in this environment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter is intended to give a basic introduction to R so that any reader
    who is not familiar with the language can follow the rest of the book by reading
    through this chapter. It is not possible to give a detailed description of the
    R language in one chapter and the interested reader should consult books specially
    written in R programming. I would recommend *The Art of R Programming* (reference
    1 in the *References* section of this chapter) and *R Cookbook* (reference 2 in
    the *References* section of this chapter) for those users who are mainly interested
    in using R for analyzing and modeling data. For those who are interested in learning
    about the advanced features of R, for example, for writing complex programs or
    R packages, *Advanced R* (reference 3 in the *References* section of this chapter)
    is an excellent book.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the R environment and packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: R is a free software under GNU open source license. R comes with a basic package
    and also has a large number of user-contributed packages for advanced analysis
    and modeling. It also has a nice graphics user interface-based editor called RStudio.
    In this section, we will learn how to download R, set up the R environment in
    your computer, and write a simple R program.
  prefs: []
  type: TYPE_NORMAL
- en: Installing R and RStudio
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**The Comprehensive R Archive Network** (**CRAN**) hosts all releases of R
    and the contributed packages. R for Windows can be installed by downloading the
    binary of the base package from [http://cran.r-project.org](http://cran.r-project.org);
    a standard installation should be sufficient. For Linux and Mac OS X, the webpage
    gives instructions on how to download and install the software. At the time of
    writing this book, the latest release was version 3.1.2\. Various packages need
    to be installed separately from the package page. One can install any package
    from the R command prompt using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'After installing the package, one needs to load the package before using it
    with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'A very useful **integrated development environment** (**IDE**) for R is RStudio.
    It can be downloaded freely from [http://www.rstudio.com/](http://www.rstudio.com/).
    RStudio works on Windows, Linux, and Mac platforms. It has both a desktop version
    and also a server version that can be used for writing R programs through a browser
    interface on a remote server. After installing R and RStudio, it is useful to
    set the default working directory to the directory of your choice. RStudio reads
    and writes files containing R codes into the working directory. To find out what
    the current directory is, use the R command `getwd( )`. To change the working
    directory to a directory of your preference, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You can also set this from the menu bar of RStudio by clicking on **Session**
    | **Set Working Directory**.
  prefs: []
  type: TYPE_NORMAL
- en: Your first R program
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us write a simple program to add two integers `x` and `y` resulting in
    their sum `z`. On the command prompt in RStudio, type the following commands and
    press *Enter*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now, you can assign different values to `x` and `y` and print `z` to see how
    `z` changes. Instead of `print(z)`, you can also simply enter `z` to print its
    values.
  prefs: []
  type: TYPE_NORMAL
- en: Managing data in R
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start any serious programming in R, we need to learn how to import
    data into an R environment and which data types R supports. Often, for a particular
    analysis, we will not use the entire dataset. Therefore, we need to also learn
    how to select a subset of the data for any analysis. This section will cover these
    aspects.
  prefs: []
  type: TYPE_NORMAL
- en: Data Types in R
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'R has five basic data types as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Integer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Numeric (real)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Complex
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Character
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logical (True/False)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The default representation of numbers in R is double precision real number (numeric).
    If you want an integer representation explicitly, you need to add the suffix `L`.
    For example, simply entering `1` on the command prompt will store `1` as a numeric
    object. To store `1` as an integer, you need to enter `1L`. The command `class(x)`
    will give the class (type) of the object `x`. Therefore, entering `class(1)` on
    command prompt will give the answer `numeric` whereas entering `class(1L)` will
    give the answer `integer`.
  prefs: []
  type: TYPE_NORMAL
- en: R also has a special number `Inf` that represents Infinity. The number `NaN`
    (*not a number*) is used to represent an undefined value such as 0/0\. Missing
    values are represented by using the symbol `NA`.
  prefs: []
  type: TYPE_NORMAL
- en: Data structures in R
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The data structures in R can be classified as either homogeneous (all elements
    containing the same data type) or heterogeneous (elements containing different
    data types). Furthermore, each of these have different structures depending upon
    the number of dimensions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Homogeneous:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Atomic vector**: one-dimensional'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Matrix**: two-dimensional'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Array**: N-dimensional'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Heterogeneous:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**List**: one-dimensional'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data frame**: two-dimensional'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The most basic object in R is a vector. To create an empty integer vector of
    size 10, enter the following command on the R prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You can assign the value *m* to *n*th component of the vector using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Readers should note that unlike in many programming languages, the array index
    in R starts with 1 and not 0.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whereas a vector can only contain objects of the same type, a list, although
    similar to the vector, can contain objects of different types. The following command
    will create a list containing integers, real numbers, and characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here, we used the `str()` function in R that shows the structure of any R object.
  prefs: []
  type: TYPE_NORMAL
- en: 'R has a special function `c()` to combine multiple numbers of basic data into
    a vector or list. For example, `c(1,3,6,2,-1)` will produce a vector containing
    numbers from 1,2,3,6,-1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'A matrix is the generalization of a vector into two dimensions. Consider the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This command will generate a matrix `m` of size 3 x 3 containing numbers from
    1 to 9.
  prefs: []
  type: TYPE_NORMAL
- en: The most common data structure used for storing data in R is a data frame. A
    data frame, like the list, can contain data of different types (numeric, integer,
    Boolean, or character). It is essentially a list of vectors of equal length. Therefore,
    it has the same two-dimensional structure as a matrix. The length (found using
    `length( )`) of a data frame is the length of the underlying list that is the
    number of columns in the data frame. There are simple commands `nrow( )` and `ncol(
    )` for finding the number of rows and columns of a data frame. The other two attributes
    of a data frame are `rownames( )` and `colnames( )` that can be used to either
    set or find the names of rows or columns.
  prefs: []
  type: TYPE_NORMAL
- en: Importing data into R
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Data that is in the form of a table can be easily loaded into R using the `read.table(…)`
    function. It has several arguments to make the import very flexible. Some of the
    useful arguments are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`file`: The name of a file or a complete URL'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`header`: A logical value indicating whether the file has a header line containing
    names of the variables'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sep`: A character indicating the column separator field'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`row.names`: A vector of row names'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`col.names`: A vector of names for variables'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`skip`: The number of lines in the data file to be skipped before reading the
    data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nrows`: The number of rows in the dataset'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stringsASFactors`: A logical value indicating if the character variables can
    be coded as factors or not'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For small datasets, one can use `read.table("filename.txt")` without specifying
    other arguments; the rest R will figure out itself. Another useful function is
    `read.csv()` for reading CSV files only.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to loading data from text files, data can be imported into R by
    connecting to external databases through various interfaces. One such popular
    interface is **Open Database Connectivity** (**ODBC**). The **RODBC** package
    in R provides access to different databases through the ODBC interface. This package
    contains different functions for connecting with a database and performing various
    operations. Some of the important functions in the RODBC package are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`odbcConnect(dsn, uid="user_name", pwd="password")`: Used to open a connection
    to an ODBC database having registered data source name `dsn`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sqlFetch(channel, sqtable)`: Used to read a table from an ODBC database to
    a data frame.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sqlQuery(channel, query)`: Used to submit a query to an ODBC database and
    return the results.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sqlSave(channel, mydf, tablename = sqtable, append = FALSE)`: Used to write
    or update (`append = TRUE`) a data frame to a table in the ODBC database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`close(channel)`: Used to close the connection. Here, `channel` is the connection
    handle as returned by `odbcConnect`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Slicing and dicing datasets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Often, in data analysis, one needs to slice and dice the full data frame to
    select a few variables or observations. This is called subsetting. R has some
    powerful and fast methods for doing this.
  prefs: []
  type: TYPE_NORMAL
- en: 'To extract subsets of R objects, one can use the following three operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Single bracket [ ]**: This returns an object of the same class as the original.
    The single bracket operator can be used to select more than one element of an
    object. Some examples are as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Double bracket [[ ]]**: This is used to extract a single element of a list
    or data frame. The returned object need not be the same type as the initial object.
    Some examples are as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Dollar sign $**: This is used to extract elements of a list or data frame
    by name. Some examples are as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Use of negative index values**: This is used to drop a particular index or
    column—one subset with a negative sign for the corresponding index. For example,
    to drop Mary and Bob from the preceding list, use the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Vectorized operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In R, many operations, such as arithmetical operations involving vectors and
    matrices, can be done very efficiently using vectorized operations. For example,
    if you are adding two vectors `x` and `y`, their elements are added in parallel.
    This also makes the code more concise and easier to understand. For example, one
    does not need a `for( )` loop to add two vectors in the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Another very useful example of vectorized operations is in the case of matrices.
    If `X` and `Y` are two matrices, the following operations can be carried out in
    R in a vectorized form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Writing R programs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although much data analysis in R can be carried out in an interactive manner
    using command prompt, often for more complex tasks, one needs to write R scripts.
    As mentioned in the introduction, R has both the perspective of a functional and
    object-oriented programming language. In this section, some of the standard syntaxes
    of the programming in R are described.
  prefs: []
  type: TYPE_NORMAL
- en: Control structures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Control structures are meant for controlling the flow of execution of a program.
    The standard control structures are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`if` and `else`: To test a condition'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`for`: To loop over a set of statements for a fixed number of times'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`while`: To loop over a set of statements while a condition is true'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`repeat`: To execute an infinite loop'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`break`: To break the execution of a loop'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`next`: To skip an iteration of a loop'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`return`: To exit a function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If one wants to use R for more serious programming, it is essential to know
    how to write functions. They make the language more powerful and elegant. R has
    many built-in functions, such as `mean()`, `sort()`, `sin()`, `plot()`, and many
    more, which are written using R commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'A function is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here, `fname` is the name of the function; `arg1`, `arg2`, and so on, are arguments
    passed to the function. Note that unlike in other languages, functions in R do
    not end with a return statement. By default, the last statement executed inside
    the body of the function is returned by the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once a function is defined, it is executed simply by entering the function
    name with the values for the arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The important properties of functions in R are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Functions are first-class citizens
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions can be passed as arguments to other functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One can define a function inside another function (nesting)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The arguments of the functions can be matched by position or name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s consider a simple example of a function, which given an input vector
    `x`, calculates its mean. To write this function, open a new window in RStudio
    for R script from the menu bar through **File** | **New File** | **R Script**.
    In this R script, enter the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Select the entire code and use the keys *Ctrl* + *Enter* to execute the script.
    This completes the definition of the `myMean` function. To use this function on
    the command prompt, enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This will generate the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Scoping rules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In programming languages, it is very important to understand the scopes of
    all variables to avoid errors during execution. There are two types of scoping
    of a variable in a function: lexical scoping and dynamic scoping. In the case
    of lexical scoping, the value of a variable in a function is looked up in the
    environment in which the function was defined. Generally, this is the global environment.
    In the case of dynamic scoping, the value of a variable is looked up in the environment
    in which the function was called (the calling environment).'
  prefs: []
  type: TYPE_NORMAL
- en: 'R uses lexical scoping that makes it possible to write functions inside a function.
    This is illustrated with the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The answer is `4` because while evaluating function `f`, the value of `x` is
    taken from the global environment, which is `0.1`, whereas while evaluating function
    `g`, the value of `x` is taken from the local environment of `g`, which is `5`.
  prefs: []
  type: TYPE_NORMAL
- en: Lexical scoping has some disadvantages. Since the value of a variable is looked
    up from the environment in which the function is defined, all functions must carry
    a pointer to their respective defining environments. Also, all objects must be
    stored in memory during the execution of the program.
  prefs: []
  type: TYPE_NORMAL
- en: Loop functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Often, we have a list containing some objects and we want to apply a function
    to every element of the list. For example, we have a list of results of a survey,
    containing *m* questions from *n* participants. We would like to find the average
    response for each question (assuming that all questions have a response as numeric
    values). One could use a `for` loop over the set of questions and find an average
    among *n* users using the `mean()` function in R. Loop functions come in handy
    in such situations and one can do such computations in a more compact way. These
    are like iterators in other languages such as Java.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the standard loop functions in R:'
  prefs: []
  type: TYPE_NORMAL
- en: '`lapply`: To loop over a list and evaluate a function on each element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sapply`: The same as `lapply`, but with the output in a more simpler form'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mapply`: A multivariate version of `sapply`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`apply`: To apply functions over array margins'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tapply`: To apply a function to each cell of a ragged array'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: lapply
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `lapply()` function is used in the following manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Here, `X` is a list or vector containing data. The `FUN` is the name of a function
    that needs to be applied on each element of the list or vector. The last argument
    represents optional arguments. The result of using `lapply` is always a list,
    regardless of the type of input.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, consider the quarterly revenue of four companies in billions
    of dollars (not real data). We would like to compute the yearly average revenue
    of all four companies as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: sapply
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `sapply()` function is similar to `lapply()` with the additional option
    of simplifying the output into a desired form. For example, `sapply()` can be
    used in the previous dataset as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: mapply
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `lapply()` and `sapply()` functions can only have one argument. If you
    want to apply a function with multiple variable arguments, then `mapply()` becomes
    handy. Here is how it is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, ![mapply](img/image00250.jpeg) are the lists to which the function `FUN`
    needs to be applied. For example, consider the following list generation command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the `rep` function repeats the value of `x` five times. Suppose we want
    to create a list where the number 10 occurs 1 time, the number 20 occurs 2 times,
    and so on, we can use `mapply` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: apply
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `apply()` function is useful for applying a function to the margins of
    an array or matrix. The form of the function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `MARGIN` is a vector giving the subscripts that the function will be
    applied over. For example, in the case of a matrix, `1` indicates rows and `2`
    indicates columns, and `c(1,2)` indicates rows and columns. Consider the following
    example as an illustration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: tapply
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `tapply()` function is used to apply a function over the subsets of a vector.
    The function description is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us consider the earlier example of the quarterly revenue of five companies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `lapply()`, we found the average yearly revenue of each company. Suppose
    we want to find the revenue per quarter averaged over all four companies, we can
    use `tapply()` as follows; here we use the function `c` instead of the list to
    create `X`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: By creating the factor list with levels as quarter values, we can apply the
    `mean` function for each quarter using `tapply()`.
  prefs: []
  type: TYPE_NORMAL
- en: Data visualization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the powerful features of R is its functions for generating high-quality
    plots and visualize data. The graphics functions in R can be divided into three
    groups:'
  prefs: []
  type: TYPE_NORMAL
- en: High-level plotting functions to create new plots, add axes, labels, and titles.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Low-level plotting functions to add more information to an existing plot. This
    includes adding extra points, lines, and labels.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interactive graphics functions to interactively add information to, or extract
    information from, an existing plot.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The R base package itself contains several graphics functions. For more advanced
    graph applications, one can use packages such as **ggplot2**, **grid**, or **lattice**.
    In particular, ggplot2 is very useful for generating visually appealing, multilayered
    graphs. It is based on the concept of *grammar of graphics*. Due to lack of space,
    we are not covering these packages in this book. Interested readers should consult
    the book by Hadley Wickham (reference 4 in the *References* section of this chapter).
  prefs: []
  type: TYPE_NORMAL
- en: High-level plotting functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us start with the most basic plotting functions in R as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`plot( )`: This is the most common plotting function in R. It is a generic
    function where the output depends on the type of the first argument.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`plot(x, y)`: This produces a scatter plot of `y` versus `x`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`plot(x)`: If `x` is a real value vector, the output will be a plot of the
    value of `x` versus its index on the *X* axis. If `x` is a complex number, then
    it will plot the real part versus the imaginary part.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`plot(f, y)`: Here, `f` is a factor object and `y` is a numeric vector. The
    function produces box plots of `y` for each level of `f`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`plot(y ~ expr)`: Here, `y` is any object and `expr` is a list of object names
    separated by *+* (for example, *p + q + r*). The function plots `y` against every
    object named in `expr`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are two useful functions in R for visualizing multivariate data:'
  prefs: []
  type: TYPE_NORMAL
- en: '`pairs(X)`: If `X` is a data frame containing numeric data, then this function
    produces a pair-wise scatter plot matrix of the variables defined by the columns
    of `X`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`coplot(y ~ x | z)`: If `y` and `x` are numeric vectors and `z` is a factor
    object, then this function plots `y` versus `x` for every level of `z`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For plotting distributions of data, one can use the following functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`hist(x)`: This produces a histogram of the numeric vector `x`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`qqplot(x, y)`: This plots the quantiles of `x` versus the quantiles of `y`
    to compare their respective distributions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`qqnorm(x)`: This plots the numeric vector `x` against the expected normal
    order scores.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Low-level plotting commands
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To add points and lines to a plot, the following commands can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '`points(x, y)`: This adds point (x, y) to the current plot.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lines(x, y)`: This adds a connecting line to the current plot.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`abline(a, b)`: This adds a line of the slope `b` and intercepts `a` to the
    current plot.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`polygon(x, y, …)`: This draws a polygon defined by the ordered vertices (x,
    y, …).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To add the text to a plot, use the following functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`text(x, y, labels)`: This adds text to the current plot at point (x, y).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`legend(x, y, legend)`: This adds a legend to the current plot at point (x,
    y).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`title(main, sub)`: This adds a title `main` at the top of the current plot
    in a large font and a subtitle `sub` at the bottom in a smaller font.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`axis(side, …)`: This adds an axis to the current plot on the side given by
    the first argument. The `side` can take values from 1 to 4 counting clockwise
    from the bottom.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following example shows how to plot a scatter plot and add a trend line.
    For this, we will use the famous Iris dataset, created by R. A. Fisher, that is
    available in R itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '![Low-level plotting commands](img/image00251.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Interactive graphics functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are functions in R that enable users to add or extract information from
    a plot using the mouse in an interactive manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '`locator (n , type)`: This waits for the user to select the `n` locations on
    the current plot using the left-mouse button. Here, type is one of `n`, `p`, `l`
    or `o` to plot points or lines at these locations. For example, to place a legend
    *Outlier* near an outlier point, use the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`identify(x, y, label)`: This allows the user to highlight any of the points,
    `x` and `y`, selected using the left-mouse button by placing the label nearby.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sampling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Often, we would be interested in creating a representative dataset, for some
    analysis or design of experiments, by sampling from a population. This is particularly
    the case for Bayesian inference, as we will see in the later chapters, where samples
    are drawn from posterior distribution for inference. Therefore, it would be useful
    to learn how to sample *N* points from some well-known distributions in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Before we use any particular sampling methods, readers should note that R, like
    any other computer program, uses pseudo random number generators for sampling.
    It is useful to supply a starting seed number to get reproducible results. This
    can be done using the `set.seed(n)` command with an integer `n` as the seed.
  prefs: []
  type: TYPE_NORMAL
- en: Random uniform sampling from an interval
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To generate *n* random numbers (numeric) that are uniformly distributed in
    the interval *[a, b]*, one can use the `runif()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Without any arguments, `runif()` will generate uniform random numbers between
    0 and 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to generate random integers uniformly distributed in an interval,
    the function to use is `sample()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The option `replace=T` indicates that the repetition is allowed.
  prefs: []
  type: TYPE_NORMAL
- en: Sampling from normal distribution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Often, we may want to generate data that is distributed according to a particular
    distribution, say normal distribution. In the case of univariate distributions,
    R has several in-built functions for this. For sampling data from a normal distribution,
    the function to be used is `rnorm()`. For example, consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This generates five random numbers distributed according to a normal distribution
    with mean 0 and standard deviation 1.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, one can use the `rbinom()` function for sampling from a binomial
    distribution, `rpois()` to sample from a Poisson distribution, `rbeta()` to sample
    from a Beta distribution, and `rgamma()` to sample from a Gamma distribution to
    mention a few other distributions.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For the following exercises in this chapter, we use the Auto MPG dataset from
    the UCI Machine Learning repository (references 5 and 6 in the *References* section
    of this chapter). The dataset can be downloaded from [https://archive.ics.uci.edu/ml/datasets.html](https://archive.ics.uci.edu/ml/datasets.html).
    The dataset contains the fuel consumption of cars in the US measured during 1970-1982\.
    Along with consumption values, there are attribute variables, such as the number
    of cylinders, displacement, horse power, weight, acceleration, year, origin, and
    the name of the car:'
  prefs: []
  type: TYPE_NORMAL
- en: Load the dataset into R using the `read.table()` function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Produce a box plot of mpg values for each car name.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write a function that will compute the scaled value (subtract the mean and divide
    by standard deviation) of a column whose name is given as an argument of the function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the `lapply()` function to compute scaled values for all variables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Produce a scatter plot of mgp versus acceleration for each car name using `coplot()`.
    Use legends to annotate the graph.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Matloff N. *The Art of R Programming – A Tour of Statistical Software Design*.
    No Starch Press. 2011\. ISBN-10: 1593273843'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Teetor P. *R Cookbook*. O''Reilly Media. 2011\. ISBN-10: 0596809158'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Wickham H. *Advanced R*. Chapman & Hall/CRC The R Series. 2015\. ISBN-10: 1466586966'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Wickham H. *ggplot2: Elegant Graphics for Data Analysis (Use R!)*. Springer.
    2010\. ISBN-10: 0387981403'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Auto MPG Data Set, UCI Machine Learning repository, [https://archive.ics.uci.edu/ml/datasets/Auto+MPG](https://archive.ics.uci.edu/ml/datasets/Auto+MPG)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Quinlan R. "Combining Instance-Based and Model-Based Learning". In: Tenth International
    Conference of Machine Learning. 236-243\. University of Massachusetts, Amherst.
    Morgan Kaufmann. 1993'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example code files from your account at [http://www.packtpub.com](http://www.packtpub.com)
    for all the Packt Publishing books you have purchased. If you purchased this book
    elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you were introduced to the R environment. After reading through
    this chapter, you learned how to import data into R, make a selection of subsets
    of data for their analysis, and write simple R programs using functions and control
    structures. Also, you should now be familiar with the graphical capabilities of
    R and some advanced capabilities, such as loop functions. In the next chapter,
    we will begin the central theme of this book, Bayesian inference.
  prefs: []
  type: TYPE_NORMAL
