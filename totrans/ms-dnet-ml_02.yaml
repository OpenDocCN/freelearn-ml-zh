- en: Chapter 2. AdventureWorks Regression
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章。AdventureWorks回归
- en: 'Imagine you''re a business developer at AdventureWorks, a bicycle manufacturing
    company based in Seattle, Washington. You are responsible for three applications
    that run at the top of a single SQL Server instance. The applications are:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你是一家位于华盛顿州西雅图的自行车制造公司AdventureWorks的商业开发者。你负责三个在单个SQL Server实例上运行的应用程序。这些应用程序包括：
- en: A customer ordering website with a section for direct customer sales and another
    section for resellers to buy in bulk
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个客户订购网站，包括直接客户销售部分和另一个批发购买部分
- en: A desktop inventory control management application
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个桌面库存控制管理应用程序
- en: A reporting solution using Power BI as a frontend
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个使用Power BI作为前端报告解决方案
- en: 'All three of these applications share similar characteristics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个应用程序具有相似的特征：
- en: They are database-first applications where their primary role is to wireframe
    the database
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些是数据库优先的应用程序，它们的主要角色是为数据库构建框架。
- en: They are all .NET applications that use standard Microsoft templating and frameworks,
    such as MVC for the website and Entity Frameworks for both web and desktop solutions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们都是.NET应用程序，使用标准的Microsoft模板和框架，例如MVC用于网站，Entity Frameworks用于Web和桌面解决方案。
- en: One day, your boss calls you into her office and says, "we are concerned about
    the reseller's section of the website. We've noticed through some basic charting
    in the Power BI that many resellers are dropping their order depending on the
    average customer reviews of the product.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 有一天，你的老板叫你到她的办公室说，“我们对网站的批发商部分感到担忧。我们通过Power BI的一些基本图表发现，许多批发商根据产品的平均客户评价来取消订单。”
- en: 'Here is the one of the charts we are looking at:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们正在查看的图表之一：
- en: '![AdventureWorks Regression](img/00020.jpeg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![AdventureWorks回归](img/00020.jpeg)'
- en: Obviously, if we can prevent people from doing this, we will maximize sales.
    We want to maximize our existing code assets, so your solution needs to integrate
    with the existing website and we want our customers to experience the same look
    and feel they currently have."
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，如果我们能阻止人们这样做，我们就能最大化销售额。我们希望最大化我们现有的代码资产，因此你的解决方案需要与现有网站集成，我们希望我们的客户能够体验到他们目前所拥有的相同的视觉和感觉。”
- en: 'This is what the current webpage looks like:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这是当前网页的样貌：
- en: '![AdventureWorks Regression](img/00021.jpeg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![AdventureWorks回归](img/00021.jpeg)'
- en: You tell your boss that you will take a look, think about it for a couple of
    days, and come up with some ideas. Inside, you are thrilled because this will
    take you out of the traditional role of web dev and into data science. After researching
    some different machine learning techniques, you settle on using a simple regression
    to help achieve this goal.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你告诉你的老板，你将看一下，思考几天，然后提出一些想法。在你内心深处，你感到非常兴奋，因为这将让你摆脱传统的前端开发角色，进入数据科学领域。在研究了不同的机器学习技术后，你决定使用简单的回归来帮助实现这一目标。
- en: Simple linear regression
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单线性回归
- en: 'Regressions attempt to predict one number given a set of different numbers.
    For example, imagine we had a box where we enter in a number and another number
    comes out:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 回归试图根据一组不同的数字预测一个数字。例如，想象我们有一个盒子，我们输入一个数字，另一个数字就出来了：
- en: '![Simple linear regression](img/00022.jpeg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![简单线性回归](img/00022.jpeg)'
- en: 'I enter the number 1 into the box, and the number 6 comes out. Then, I enter
    another 1 into the box and the number 7 comes out. I do this five times and I
    get the following results:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我在框中输入数字1，然后数字6就出来了。然后，我再次在框中输入另一个1，数字7就出来了。我这样做了五次，得到了以下结果：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Before entering in another one, what do you think the output will be? You probably
    guessed 6\. However, if I asked you whether you were 100% sure that 6 would come
    out, you would say, "no, but it will probably be 6." In fact, you might say that
    6 has a 60% chance of coming out based on prior experience (three sixes in five
    total attempts).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在输入另一个数字之前，你认为输出会是什么？你可能猜到是6。然而，如果我问你是否100%确定会出来6，你会说，“不，但很可能会是6。”事实上，你可能会说，根据以往的经验（在五次尝试中出现了三个6），6有60%的概率出现。
- en: 'What you are doing mentally is a kind of regression. Typically, linear regressions
    are written using a formula like this:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你在心理上所做的是一种回归。通常，线性回归是用如下公式编写的：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, *y* is the number you want to predict and *x0*, *x1*, and *x2* are some
    numbers that might affect *y*. Back to AdventureWorks, *y* is the number of bikes
    a retail store will order in a month, *x0* is the month of the year, *x1* is the
    order from the previous three months, and *x2* is the number of other bikes that
    are being ordered by their immediate competitors. *E* is all of the things that
    our formula cannot account for that still affects the bike sales—like an individual
    store losing a key sales person. If we knew that *x0 + x1 + x2* accounted for
    75% of *y*, we would know that 25% of *y* cannot be explained.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，*y* 是你想要预测的数字，而 *x0*、*x1* 和 *x2* 是可能影响 *y* 的某些数字。回到 AdventureWorks，*y* 是零售店一个月订购的自行车数量，*x0*
    是一年中的月份，*x1* 是前三个月的订单，而 *x2* 是直接竞争对手订购的其他自行车的数量。*E* 是我们公式无法解释但仍影响自行车销售的所有因素——比如某个门店失去了一位关键的销售人员。如果我们知道
    *x0 + x1 + x2* 解释了 75% 的 *y*，那么我们就知道 25% 的 *y* 无法解释。
- en: Our goal, then, is to find as few *x* parameters as possible that have the greatest
    impact on *y* and then make a reasonable attempt to have our website reflect both
    the predicted value and to influence the users for our benefit.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的目标是找到尽可能少的 *x* 参数，这些参数对 *y* 有最大的影响，然后合理地尝试让我们的网站反映预测值并影响用户以符合我们的利益。
- en: 'There are many types of regressions, and we will start with the most basic,
    though surprisingly powerful one—the simple regression. In a simple regression,
    there is only one input variable and one output, so the formula is *y = x0 + E*.
    Because there are only two variables, we can plot them on a two-dimensional graph.
    For example, if we had this data:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 回归类型有很多，我们将从最基础的、虽然令人惊讶地强大的一种开始——简单回归。在简单回归中，只有一个输入变量和一个输出，因此公式是 *y = x0 + E*。因为只有两个变量，我们可以将它们绘制在二维图上。例如，如果我们有这些数据：
- en: '![Simple linear regression](img/00023.jpeg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![简单线性回归](img/00023.jpeg)'
- en: 'We can plot the data like this:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像这样绘制数据：
- en: '![Simple linear regression](img/00024.jpeg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![简单线性回归](img/00024.jpeg)'
- en: 'What we want to do with a simple regression is find the line that "fits" best
    through all of the data points:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要用简单回归做的，是找到一条“最适合”通过所有数据点的线：
- en: '![Simple linear regression](img/00025.jpeg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![简单线性回归](img/00025.jpeg)'
- en: In this example, you can see that the line goes through points 1, 2, and 5\.
    If the line does not intersect a given point, we want to know the distance from
    the line to the point. In this example, we want to know the distance of the dotted
    red line for points 3 and 4.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你可以看到这条线穿过点 1、2 和 5。如果线没有与一个给定的点相交，我们想知道线到点的距离。在这个例子中，我们想知道点 3 和 4 到虚线红线的距离。
- en: '![Simple linear regression](img/00026.jpeg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![简单线性回归](img/00026.jpeg)'
- en: If we add up the distance of all of the dotted red lines and divide by the number
    of total points on our graph, we have a pretty good idea of how well this line
    represents the plot. If we are then given a number that is on our graph, we can
    make a prediction about where it will land. For example, if we are given another
    2, we can predict that we will probably result in a 2\. Not only that, we can
    make predictions about where the line is headed (slope) for inputs that we have
    not seen before. For example, if we input 6, we can guess that it will probably
    be close to 6.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们把所有虚线红线的距离加起来，然后除以图表上总点的数量，我们就有了一个很好的想法，这条线如何代表这个图表。如果我们得到图表上的一个数字，我们可以预测它将落在何处。例如，如果我们得到另一个
    2，我们可以预测我们可能会得到 2。不仅如此，我们还可以对尚未看到的输入的线（斜率）进行预测。例如，如果我们输入 6，我们可以猜测它可能接近 6。
- en: In a real-word example, we typically don't have a single input for a given number.
    So, we might get a hundred 1s and 90% of the time the output will be 1, 5% of
    the time the output will be 1.25, and 5% of the time, the output will be 0.75\.
    If we placed all the 100s on our scatter plot, we will see lots of points on 1
    (or a really dark dot), some on 1.25, and some on 0.75\. With this mental model
    in place, let's go ahead and create a simple linear regression from scratch.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界的例子中，我们通常不会有一个单一的输入对应一个特定的数字。所以，我们可能会得到一百个 1，90% 的时间输出将是 1，5% 的时间输出将是 1.25，还有
    5% 的时间输出将是 0.75。如果我们把所有的一百个 1 放到我们的散点图上，我们会看到很多点在 1（或一个非常暗的点）上，一些在 1.25 上，一些在
    0.75 上。有了这个心理模型，让我们继续从头开始创建一个简单线性回归。
- en: Setting up the environment
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置环境
- en: 'Open Visual Studio 2015 and create a new F# Library:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 Visual Studio 2015 并创建一个新的 F# 库：
- en: '![Setting up the environment](img/00027.jpeg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![设置环境](img/00027.jpeg)'
- en: Once Visual Studio finishes creating the project and files for you, go into
    the solution explorer, and open `Script1.fsx` and delete all the contents in the
    file. You should now have an empty script file ready for your code.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 Visual Studio 为您创建完项目和相关文件，请进入解决方案资源管理器，打开 `Script1.fsx` 并删除文件中的所有内容。现在您应该有一个空白的脚本文件，准备好编写代码。
- en: Preparing the test data
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备测试数据
- en: 'The first thing we will do is create a dataset that we can use in our regression
    that gives us predictable results. Create an array like this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将创建一个数据集，我们可以在回归中使用它，并给出可预测的结果。创建一个如下所示的数组：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here, `input` is an array of tuples. A tuple is a data structure that contains
    groups of data that are unnamed—usually there are two items. The types do *not*
    have to be the same as a tuple''s items. If you are familiar with the concept
    of a key/value pair, you can use that as a mental model of a tuple. The only real
    "gotcha" is that tuples can have many items so this it is a perfectly valid tuple:
    `2,true,"dog"` where the first position is an `int`, the second is a Boolean,
    and the third is a string.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`input` 是一个元组数组。元组是一种包含数据组的无名称数据结构——通常有两个项目。这些类型不必与元组的项相同。如果您熟悉键/值对的概念，您可以将它用作元组的心理模型。唯一真正的“陷阱”是元组可以有多个项目，因此这是一个完全有效的元组：`2,true,"dog"`，其中第一个位置是
    `int` 类型，第二个是布尔值，第三个是字符串。
- en: 'If you highlight our single line of code and send it to the REPL using *Alt*
    + *Enter*, you will get this back:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您突出显示我们的一行代码，并使用 *Alt* + *Enter* 将其发送到交互式环境（REPL），您将得到以下结果：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The F# compiler is telling us that we have an array that contains tuples of
    type `int` and `float`. In this example, we will use the first value of the tuples
    to be the *X* and the second to be the *Y* of our simple linear regression.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: F# 编译器告诉我们，我们有一个包含 `int` 和 `float` 类型的元组的数组。在这个例子中，我们将使用元组的第一个值作为 *X*，第二个值作为简单线性回归的
    *Y*。
- en: With the data set up, let's think about how to calculate a regression. A more
    mathematical definition than what I used earlier is *y = A + Bx*, where *A* is
    the *Y* intercept of the line and *B* is the slope of the line. Therefore, we
    need to figure out how to calculate the intercept of the line and the slope of
    the line. Turns out that we need to calculate the standard deviation of the *x*
    and *y* values and something called the **Person's correlation**. Let's tackle
    each one of these separately.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 数据集设置好之后，让我们考虑如何计算回归。一个比之前使用的更数学的定义是 *y = A + Bx*，其中 *A* 是直线的 *Y* 截距，*B* 是直线的斜率。因此，我们需要找出如何计算直线的截距和斜率。结果是，我们需要计算
    *x* 和 *y* 值的标准差以及称为 **皮尔逊相关系数** 的东西。让我们分别解决这些问题。
- en: Standard deviation
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标准差
- en: The best explanation of standard deviation that I have run across is at [http://www.mathsisfun.com/data/standard-deviation.html](http://www.mathsisfun.com/data/standard-deviation.html).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我遇到的最佳标准差解释是在 [http://www.mathsisfun.com/data/standard-deviation.html](http://www.mathsisfun.com/data/standard-deviation.html)。
- en: 'Standard deviation is the square root of the variance; to calculate the variance:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 标准差是方差的平方根；要计算方差：
- en: Work out the mean (the simple average of the numbers).
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算平均值（数字的简单平均值）。
- en: Then, for each number, subtract the mean and square the result (the squared
    difference).
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，对于每个数字，减去平均值并平方结果（平方差）。
- en: Then, work out the average of those squared differences.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，计算这些平方差的平均值。
- en: 'So, taking MathIsFun''s explanation and applying it to F#, we can write:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，结合 MathIsFun 的解释并将其应用于 F#，我们可以写出：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Sending that to the REPL gives us:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 将其发送到交互式环境（REPL）会得到：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Notice how there is a one-to-one correspondence between each line of the English
    explanation and the F# code. This is not an accident. F# is really great at matching
    your thought process. In fact, we even resisted to temptation to `for…each` in
    code when we saw those words in the English version.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到英文解释的每一行与 F# 代码之间有一一对应的关系。这不是偶然的。F# 真的非常擅长匹配您的思维过程。事实上，当我们看到英文版本中的那些词时，我们甚至抵制了使用
    `for…each` 代码的诱惑。
- en: 'There is some new F# code here that might be confusing. Notice that when I
    calculated the mean, I called the `Seq.average` function:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些新的 F# 代码可能让人困惑。注意，当我计算平均值时，我调用了 `Seq.average` 函数：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'And hence, the `source` argument came after the function. I could have just
    as well written:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`source` 参数位于函数之后。我也可以这样写：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This is something you will have seen before if you worked through [Chapter
    1](part0015_split_000.html#E9OE1-a18db0be6c20485ba81f22e43ca13055 "Chapter 1. Welcome
    to Machine Learning Using the .NET Framework"), *Welcome to Machine Learning Using
    the .NET Framework*. There is really no consensus in the F# community about which
    way is more idiomatic, though the style guidelines argue for the non-pipe forward
    way. Since both are supported by the languages and widely used, I use both depending
    on the code. Typically, when I have a string of thoughts to push together I use
    the pipe operator, but if there is only one calculation, I just call the function
    directly. Notice that I did this *after syntax* technique in all three lines:
    mean, deltas, and the return of the function.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经完成了[第1章](part0015_split_000.html#E9OE1-a18db0be6c20485ba81f22e43ca13055
    "第1章. 欢迎使用.NET框架进行机器学习")，*欢迎使用.NET框架进行机器学习*，你可能会看到这个。尽管风格指南主张非管道前进的方式，但在F#社区中，关于哪种方式更符合习惯用法并没有达成共识。由于两种方式都由语言支持并且广泛使用，我会根据代码使用它们。通常，当我有一系列想法要一起推动时，我会使用管道操作符，但如果只有一个计算，我就直接调用函数。注意，我在所有三行中使用了这种
    *after syntax* 技术：mean，deltas，和函数的返回值。
- en: 'With variance out of the way, we can make our standard deviation:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在方差处理完毕后，我们可以计算标准差：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Sending that to the REPL gives us:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 将其发送到REPL，我们得到：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'With the standard deviation ready, we can plug in our numbers. Since we will
    be calculating the standard deviation of *X* and *Y* independently, let''s break
    the tuple apart into separate arrays and calculate their average and standard
    deviations:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好标准差后，我们可以输入我们的数字。由于我们将独立计算 *X* 和 *Y* 的标准差，让我们将元组拆分成单独的数组，并计算它们的平均值和标准差：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Sending that to the REPL gives us:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 将其发送到REPL，我们得到：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'There is one thing new here. Notice that when calculating *x*, I used this
    syntax:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一件新的事情。注意，在计算 *x* 时，我使用了这种语法：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: With `float x` as the return. `float` is a function that casts the int into,
    well, a float. If you are coming from VB.NET/C#, the comparable syntax will be
    `(float)x`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 `float x`。`float` 是一个将 int 转换为，嗯，浮点数的函数。如果你来自 VB.NET/C#，相应的语法将是 `(float)x`。
- en: Pearson's correlation
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 皮尔逊相关系数
- en: 'Next, let''s calculate the Pearson''s correlation. The best explanation I have
    found for it is available at [http://onlinestatbook.com/2/describing_bivariate_data/calculation.html](http://onlinestatbook.com/2/describing_bivariate_data/calculation.html).
    You can think of creating the Pearson''s correlation as filling in columns in
    an Excel spreadsheet and then doing some calculations on the column totals. Start
    a grid with *x* and *y* in different rows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们计算皮尔逊相关系数。我找到的最好的解释可以在[http://onlinestatbook.com/2/describing_bivariate_data/calculation.html](http://onlinestatbook.com/2/describing_bivariate_data/calculation.html)找到。你可以把创建皮尔逊相关系数想象成在一个Excel电子表格中填写列，然后对列总计进行一些计算。从
    *x* 和 *y* 在不同行开始创建一个网格：
- en: '![Pearson''s correlation](img/00028.jpeg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![皮尔逊相关系数](img/00028.jpeg)'
- en: 'Then, calculate the mean for *X* and *Y*:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，计算 *X* 和 *Y* 的平均值：
- en: '![Pearson''s correlation](img/00029.jpeg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![皮尔逊相关系数](img/00029.jpeg)'
- en: 'Next, calculate *x* and *y*. *x* is calculated by subtracting the mean of *X*
    from *X* and *y* is calculated by subtracting the mean of *Y* from *Y*:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，计算 *x* 和 *y*。*x* 是通过从 *X* 中减去 *X* 的平均值来计算的，而 *y* 是通过从 *Y* 中减去 *Y* 的平均值来计算的：
- en: '![Pearson''s correlation](img/00030.jpeg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![皮尔逊相关系数](img/00030.jpeg)'
- en: 'Next, fill in *xy*, *x**²*, and *y* *²*:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，填写 *xy*，*x**²*，和 *y* *²*：
- en: '![Pearson''s correlation](img/00031.jpeg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![皮尔逊相关系数](img/00031.jpeg)'
- en: 'With the grid filled in, you can sum up *xy*, *x²*, and *y²*:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在网格填写完毕后，你可以求和 *xy*，*x²*，和 *y²*：
- en: '![Pearson''s correlation](img/00032.jpeg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![皮尔逊相关系数](img/00032.jpeg)'
- en: 'The final answer is computed by dividing the sum of the *xy* column (*Σxy*)
    by the square root of the product of the sum of the *x²* column (*Σx**²*) and
    the sum of the *y**²* column (*Σy**²*). So, in our example, it will be:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 最终答案是通过对 *xy* 列的总和（Σxy）除以 *x²* 列的总和（Σx**²*）和 *y**²* 列的总和（Σy**²*）的乘积的平方根来计算的。所以，在我们的例子中，它将是：
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'I now want to repeat these steps without that grid in English:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我现在想用英语重复这些步骤，而不使用那个网格：
- en: Calculate the mean for *X*.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算 *X* 的平均值。
- en: Calculate the mean for *Y*.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算 *Y* 的平均值。
- en: Calculate *x*.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算 *x*。
- en: Calculate *y*.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算 *y*。
- en: Fill in *xy*, *x**²*, and *y**²*.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 填写 *xy*，*x**²*，和 *y**²*。
- en: Sum up *y**²*.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 求 *y**²* 的和。
- en: Sum up *x**²*.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 求 *x**²* 的和。
- en: Sum up *y**²*.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 求 *y**²* 的和。
- en: Do the final formula.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 做最终的公式。
- en: 'And this is how I would write it in F#:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我会用F#写的样子：
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Sending that to the REPL gives us:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 将其发送到REPL，我们得到：
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Again, you can see that there is almost a one-to-one correspondence between
    the formula and the code. There are a couple of things to note.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，你可以看到公式和代码之间几乎是一对一的对应关系。有几件事情需要注意。
- en: '`Seq.zip x y` is a function that takes in two sequences of equal length and
    combines them together into a single tuple. So for *x* and *y* zipped:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`Seq.zip x y` 是一个函数，它接受两个长度相等的序列并将它们组合成一个单一的元组。所以对于 *x* 和 *y* 的组合：'
- en: '![Pearson''s correlation](img/00033.jpeg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![皮尔逊相关系数](img/00033.jpeg)'
- en: 'Another thing to notice is that there is a three-item tuple being used in the
    `Seq.SumBys`. Each item of the tuple represents a different column in the grid
    we were filling out: *xy*, *x²*, and *y²*. Although I normally don''t like to
    create tuples greater than two items, I can make an exception in this case because
    I am only using the tuple in the context of these higher-order functions. Because
    the data structure is contained and short-lived, a tuple is the best choice. If
    I needed that data structure outside of the higher-order function, a record type
    would have been more appropriate. We''ll get more exposure to a record type later
    in this chapter.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 另一件需要注意的事情是，在 `Seq.SumBys` 中使用了一个三项元组。元组的每个项代表我们在填写的网格中的不同列：*xy*，*x²* 和 *y²*。尽管我通常不喜欢创建超过两项的元组，但在这个情况下我可以例外，因为我只在这些高阶函数的上下文中使用元组。因为数据结构是包含的且短暂的，所以元组是最好的选择。如果我在高阶函数之外需要这个数据结构，记录类型可能更合适。我们将在本章的后面更多地接触到记录类型。
- en: 'A final thing to notice is the `Seq.sumBy` higher-ordered function. As you
    may expect, `sumBy` computes the sum of things. The key thing to realize is that
    the `sumBy` expects a function to be passed, not a data structure. If you just
    want to sum up the values in an array, you can use the `Seq.sum()` function:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要注意的是 `Seq.sumBy` 高阶函数。正如你所期望的，`sumBy` 计算事物的总和。关键是要意识到 `sumBy` 期望传递一个函数，而不是数据结构。如果你只想对数组中的值求和，可以使用
    `Seq.sum()` 函数：
- en: '[PRE16]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'And so to run a Pearson''s correlation for *x* and *y*, type this into the
    script:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要为 *x* 和 *y* 运行皮尔逊相关系数，请在脚本中输入以下内容：
- en: '[PRE17]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Sending that to the REPL gives us:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些发送到交互式解释器（REPL）会给我们：
- en: '[PRE18]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Linear regression
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线性回归
- en: 'With standard deviation and `r` calculated, we are ready for our linear regression:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算了标准差和 `r` 之后，我们就为线性回归做好了准备：
- en: '[PRE19]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'What these two values mean is that our *y* intercept is `-.22`, or very close
    to the origin, and our slope is `1.075`. Laying them out on the same grid, you
    can see that the predicted numbers are close to the actual:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个值的含义是，我们的 *y* 截距是 `-0.22`，或者非常接近原点，我们的斜率是 `1.075`。将它们放在同一个网格上，你可以看到预测的数字接近实际值：
- en: '![Linear regression](img/00034.jpeg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![线性回归](img/00034.jpeg)'
- en: 'These are still different enough on the plot that we eye-balled earlier with
    the red line going directly through 1, 2, 3, 4, 5 (solid line) and the regression
    line taking a slightly different path (dashed line):'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这些在之前的图表中仍然足够不同，我们用红线直接穿过 1, 2, 3, 4, 5（实线）和回归线采取略微不同的路径（虚线）：
- en: '![Linear regression](img/00035.jpeg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![线性回归](img/00035.jpeg)'
- en: We will revisit how good this regression is at describing our data (and making
    predictions) in a bit. Until then, we can safely say that we have a regression,
    which seems to fit our data pretty well.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后重新审视这个回归在描述我们的数据（以及做出预测）方面的好坏。在此之前，我们可以安全地说，我们有一个回归，它似乎很好地拟合了我们的数据。
- en: We now have a library we could compile for our AdventureWorks problem. However,
    we may not want to roll our own because this is a fairly limited implementation.
    For example, when we calculated variance and standard deviation, we were using
    the formula for the variance and standard deviation for an entire population.
    If we had only a small sample of the population, there is a different formula
    that we will implement. Also, linear regressions have several parameters that
    we can enter to try and *tune up* the model in our implementation. As you can
    guess, there is quite a bit of effort in writing your own library, and you still
    may not get it right. If you were wondering in the middle of the prior exercise
    of rolling our own, "is there an easier way?" The answer is "yes."
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个库可以编译来解决我们的 AdventureWorks 问题。然而，我们可能不想自己从头开始，因为这只是一个相当有限的实现。例如，当我们计算方差和标准差时，我们使用的是整个总体的方差和标准差公式。如果我们只有总体的一小部分样本，我们将使用不同的公式来实现。此外，线性回归有几个参数我们可以输入来尝试调整我们实现中的模型。正如你所猜想的，编写自己的库需要相当多的努力，而且你可能仍然无法做到正确。如果你在之前的自己动手实现练习中想知道，“有没有更简单的方法？”答案是“有。”
- en: Math.NET
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Math.NET
- en: We had a brief introduction to Math.Net in [Chapter 1](part0015_split_000.html#E9OE1-a18db0be6c20485ba81f22e43ca13055
    "Chapter 1. Welcome to Machine Learning Using the .NET Framework"), *Welcome to
    Machine Learning Using the .NET Framework*. In this section, we will add it to
    our project and see how it can help us do a simple linear regression. In the solution
    explorer of your open project, add a new script file and name it `MathDotNet.fsx`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 [第 1 章](part0015_split_000.html#E9OE1-a18db0be6c20485ba81f22e43ca13055 "第
    1 章。欢迎使用使用 .NET 框架的机器学习") 中简要介绍了 Math.Net，*欢迎使用使用 .NET 框架的机器学习*。在本节中，我们将将其添加到我们的项目中，看看它如何帮助我们进行简单的线性回归。在你的打开的项目解决方案资源管理器中，添加一个新的脚本文件，并将其命名为
    `MathDotNet.fsx`。
- en: 'Next, open the NuGet Package Manager Console (**Tools** | **NuGet Package Manger**
    | **Package Manager Console**):'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，打开 NuGet 包管理器控制台（**工具** | **NuGet 包管理器** | **包管理器控制台**）：
- en: '![Math.NET](img/00036.jpeg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![Math.NET](img/00036.jpeg)'
- en: 'In the console, enter the following line:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制台中输入以下行：
- en: '[PRE20]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You will see that the package installs successfully:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到包安装成功：
- en: '![Math.NET](img/00037.jpeg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![Math.NET](img/00037.jpeg)'
- en: Close the Package Manager Console and the `readme.txt` file that opens when
    you install Math.NET. In the future, I will assume that you know how to open and
    enter commands to install NuGet packages.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭包管理器控制台以及当你安装 Math.NET 时打开的 `readme.txt` 文件。在未来的操作中，我将假设你知道如何打开并输入命令来安装 NuGet
    包。
- en: Regression try 1
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回归尝试 1
- en: 'In the script file, create the same input that we saw in the hand-rolled script
    and calculate the means of *x* and *y*:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本文件中，创建我们在手写脚本中看到的相同输入，并计算 *x* 和 *y* 的平均值：
- en: '[PRE21]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The following is the output:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是将给出的输出：
- en: '[PRE22]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then, point to the Math.NET library installed with the nugget package and add
    a reference to it:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，指向与 nugget 包一起安装的 Math.NET 库，并添加对其的引用：
- en: '[PRE23]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Next, use Math.Net to calculate the standard deviation of *x* and *y*:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用 Math.Net 来计算 *x* 和 *y* 的标准差：
- en: '[PRE24]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The preceding code statements will give you:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码语句将给出：
- en: '[PRE25]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Finally, use Math.Net to calculate the `r`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用 Math.Net 来计算 `r`：
- en: '[PRE26]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The following will be the output:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 以下将是输出：
- en: '[PRE27]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, you can calculate the regression:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以计算回归：
- en: '[PRE28]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'And here is what you will get in the output:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出中，你将得到以下内容：
- en: '[PRE29]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'There is one new thing I want to point out in the script. You had to type:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本中，我想要指出一个新事物。你不得不输入：
- en: '[PRE30]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `#r` stands for reference and points the FSI to the filesystem to locate
    the assembly that we want to use. The FSI loads with very few libraries installed,
    so you typically have to add a reference the ones you need. Notice the `".."`
    shorthand as the prefix for the file path. This is a relative locator that translates
    into the solution location.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`#r` 代表引用，并将 FSI 指向文件系统以定位我们想要使用的程序集。FSI 在安装了非常少的库的情况下加载，所以你通常需要添加你需要的引用。注意文件路径前缀的
    `".."` 简写，这是一个相对定位器，它转换成解决方案位置。'
- en: The `open` command tells the FSI to open up the `.dll` file that we pointed
    to in the previous line. This is the same as `using` in C#, `Imports` in VB.NET,
    and `library` in R.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`open` 命令告诉 FSI 打开我们在上一行中指向的 `.dll` 文件。这和在 C# 中的 `using`、在 VB.NET 中的 `Imports`
    以及在 R 中的 `library` 相同。'
- en: So, this is a much easier way to calculate the components of a simple linear
    regression than by hand. But wait, there is even more.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这是一个比手工计算简单线性回归的成分要简单得多的方法。但是等等，还有更多。
- en: Regression try 2
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回归尝试 2
- en: 'Math.NET makes it even easier to calculate the regression without going into
    the components. In the script, enter the following code:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Math.NET 使得在不深入组件的情况下计算回归变得更加容易。在脚本中输入以下代码：
- en: '[PRE31]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You will get the following output:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到以下输出：
- en: '[PRE32]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '`Math.Numerics` already has the regression available via the `Fit()` function.
    `Fit()` takes in two arrays (in our case, *x* and *y*) and returns a tuple. The
    first item of the tuple is the intercept and the second is the slope. The only
    new code that I introduced here are the `fst` and `snd` operators. These are shorthand
    notations for tuples that have a length of two. Calling `fst` on a tuple returns
    the first item and `snd` returns the second. If you call `fst` and `snd` on a
    tuple that has more than two items, you will get a type mismatch compiler error.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`Math.Numerics` 已经通过 `Fit()` 函数提供了回归功能。`Fit()` 接收两个数组（在我们的例子中是 *x* 和 *y*）并返回一个元组。元组的第一个元素是截距，第二个是斜率。我在这里引入的唯一新代码是
    `fst` 和 `snd` 操作符。这些是长度为二的元组的简写表示法。在元组上调用 `fst` 返回第一个元素，而 `snd` 返回第二个。如果你在包含多于两个元素的元组上调用
    `fst` 和 `snd`，你将得到一个类型不匹配的编译器错误。'
- en: Accord.NET
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Accord.NET
- en: 'With Math.NET doing all of our heavy lifting, we have a better way to get the
    results of a simple linear regression. However, there is another way I want to
    discuss, Accord.NET. Open the NuGet Package Manager and install the following
    three packages:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在Math.NET为我们做所有重活的情况下，我们有一种更好的方法来得到简单线性回归的结果。然而，我想讨论另一种方法，Accord.NET。打开NuGet包管理器并安装以下三个包：
- en: Accord
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Accord
- en: Accord.Statistics
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Accord.Statistics
- en: FSharp.Data
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FSharp.Data
- en: 'Note that you will get a pop-up window when you install FSharp.Data:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当你安装FSharp.Data时，你会得到一个弹出窗口：
- en: '![Accord.NET](img/00038.jpeg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![Accord.NET](img/00038.jpeg)'
- en: Click on **Enable**.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**启用**。
- en: Regression
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回归
- en: 'Back in the script file, enter the following lines of code:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本文件中，输入以下代码行：
- en: '[PRE33]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'When you send this to the REPL, you will see the following code:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将此发送到REPL时，你会看到以下代码：
- en: '[PRE34]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'What you see here is the exact same calculation as before with the formula
    kindly printed out (I have rounded it to three decimal places):'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 你在这里看到的是与之前完全相同的计算，只是这次公式被友好地打印出来了（我已经将它四舍五入到小数点后三位）：
- en: '[PRE35]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Regression evaluation using RMSE
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用RMSE进行回归评估
- en: 'Accord.NET goes one better than Math.NET `Fit()` as it returns the sum of the
    squared errors and the coefficient of determination (called r squared). In this
    case, the sum of squared errors is `1.06875` and the r squared is `0.915` (rounded
    to three decimal places). This is great because we now have two vital pieces of
    information:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: Accord.NET比Math.NET的`Fit()`方法更出色，因为它返回平方误差之和以及确定系数（称为r平方）。在这种情况下，平方误差之和是`1.06875`，r平方是`0.915`（四舍五入到小数点后三位）。这很好，因为我们现在有了两个关键信息：
- en: A model to predict
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个预测模型
- en: Some way to help us evaluate how good the model is at predicting
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些方法可以帮助我们评估模型在预测方面的好坏
- en: 'In machine learning, it is not enough to simply implement a model and get some
    answers. We also have to be able to speak to know how good our answer really is.
    The **sum of squares error**, often called **SSE**, is a common way to evaluate
    a simple linear regression. To start thinking about SSE, we need to know two pieces
    of information for each *y* that we used—what we guessed and what the actual value
    is. Using our existing dataset:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在机器学习中，仅仅实现一个模型并得到一些答案是不够的。我们还需要能够说话，知道我们的答案实际上有多好。**平方和误差**，通常称为**SSE**，是评估简单线性回归的常见方法。为了开始思考SSE，我们需要知道每个*y*所用的两块信息——我们猜测的是什么，实际值是什么。使用我们现有的数据集：
- en: '![Regression evaluation using RMSE](img/00039.jpeg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![使用RMSE进行回归评估](img/00039.jpeg)'
- en: You can see that the model was created based on all of the *y* data points,
    and then Accord.NET went back and checked how close that model *fits* each data
    point. These differences are squared, then the squared values are summed. The
    goal is to get the sums of squares as low as possible. Once we have the SSE, we
    can change our model to try to get the sum of squares lower. For example, what
    if we changed the slope from `1.075x` to `1.000x`, which is what we were eyeballing
    earlier?
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到模型是基于所有的*y*数据点创建的，然后Accord.NET回过头来检查该模型如何接近每个数据点。这些差异被平方，然后平方值被求和。目标是使平方和尽可能低。一旦我们有了SSE，我们就可以改变我们的模型以尝试使平方和更低。例如，如果我们把斜率从`1.075x`改为`1.000x`，这是我们之前用眼睛估计的？
- en: '![Regression evaluation using RMSE](img/00040.jpeg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![使用RMSE进行回归评估](img/00040.jpeg)'
- en: Since we have all five data points that are available for the initial model
    calculation, you are not going to improve on the model by making manual changes
    like this. The original regression is the best way of describing the relationship
    among these five data points. It is important to note that the SSE is a context-free
    measure. This means 1.069 does not have any value in and of itself. We only know
    that 1.069 is better than 1.367\. Basically, we want the SSE to be as low as possible.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经有用于初始模型计算的五个数据点，因此通过手动更改这种方式来改进模型是不可能的。原始回归是描述这五个数据点之间关系的最佳方式。重要的是要注意，SSE是一个无上下文测度。这意味着1.069本身并没有任何价值。我们只知道1.069比1.367好。基本上，我们希望SSE尽可能低。
- en: 'A slightly better variation of the SSE is the **Mean Square Error** (**MSE**).
    The MSE is the SSE divided by the number of observations of the regression:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: SSE的一个稍微更好的变体是**均方误差**（**MSE**）。MSE是SSE除以回归的观测数：
- en: '![Regression evaluation using RMSE](img/00041.jpeg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![使用RMSE进行回归评估](img/00041.jpeg)'
- en: In this case, the MSE is `0.2138`. Like the MSE, the number itself is not particularly
    useful. However, if we take the square root of the MSE, often called the **Root
    Of Mean Square Error**, or **RMSE**, the result is an error measure in the same
    units as our original numbers.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，均方误差（MSE）是`0.2138`。像MSE一样，这个数字本身并不特别有用。然而，如果我们取MSE的平方根，通常称为**均方根误差**（RMSE），结果是一个与原始数字相同单位的误差度量。
- en: '[PRE36]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In our case, the RMSE is `0.462` means that any given guess is likely off by
    0.46\. When you talk to other data scientists at your next cocktail party (you
    do go to cocktail parties with data scientists, don't you?), you will typically
    use the RMSE when evaluating the predictive capabilities of a simple linear model.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，RMSE是`0.462`，这意味着任何给定的猜测都可能偏离0.46。当你下次在鸡尾酒会上与其他数据科学家交谈时（你真的会与数据科学家参加鸡尾酒会，不是吗？），你通常会使用RMSE来评估简单线性模型的预测能力。
- en: Using the RMSE, we now have a measure of how accurate our model is when predicting
    values. We also have a second measure, called the r2, that calculates how much
    correlation our model has. The r2 takes the r (in this case, Pearson's correlation)
    and squares it. The r2 is always between zero and one, with zero meaning that
    there is no correlation between *x* and *y* and one meaning that the regression
    line perfectly fits the data. In practical terms, we want a low as possible RMSE
    with a high as possible r2.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 使用RMSE，我们现在有一个度量，可以衡量我们的模型在预测值时的准确性。我们还有一个第二个度量，称为r2，它计算我们的模型有多少相关性。r2将r（在这种情况下，皮尔逊相关）平方。r2总是在零和一之间，零表示*x*和*y*之间没有相关性，一表示回归线完美地拟合数据。在实践中，我们希望尽可能低的RMSE和尽可能高的r2。
- en: Regression and the real world
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回归与现实世界
- en: So far, we really haven't done any machine learning, in that we can't make our
    model any better. The initial regression is the best and explains 91.5% of the
    data. However, the world does not work in such a straightforward manner.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们实际上并没有进行任何机器学习，因为我们无法使我们的模型变得更好。最初的回归是最好的，解释了91.5%的数据。然而，世界并不总是以这种方式运作。
- en: 'The challenge is that we will start applying a simple linear regression on
    a dataset that represents human activity (in our case, AdventureWorks sales),
    and human activity is fraught with uncertainty. Consider a more realistic data
    frame with a product, its list price, and its customer reviews:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 挑战在于我们将开始在一个代表人类活动（在我们的案例中，是AdventureWorks的销售数据）的数据集上应用简单的线性回归，而人类活动充满了不确定性。考虑一个更现实的数据框，其中包含产品、其列表价格和其客户评价：
- en: '![Regression and the real world](img/00042.jpeg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![回归与现实世界](img/00042.jpeg)'
- en: Notice that the rating seems to have some wide variance. Some customers gave
    the bike a 5 while others gave it a 1 or 2\. You would think for the same product,
    the average reviews would be fairly similar. Perhaps we have a problem with manufacturing
    quality or perhaps the price is such that low-end customers expect more from what
    they perceive to be a very expensive bike and high-end customers are thrilled
    with the value they got from what they perceive to be a low-cost bike. Now can
    we start with our model? Yes! Let's take the data from AdventureWorks and see
    how it stacks up with an initial model using Accord.NET.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到评分似乎有一些很大的差异。一些客户给自行车打了5分，而另一些客户只给了1分或2分。你会认为对于同一产品，平均评价应该是相当相似的。也许我们有一个制造质量的问题，或者也许价格如此之高，低端客户期望从他们认为是昂贵的自行车中获得更多，而高端客户对从他们认为是低成本自行车中获得的价值感到非常满意。现在我们可以开始构建我们的模型了吗？是的！让我们从AdventureWorks的数据开始，看看它如何与使用Accord.NET的初始模型相匹配。
- en: Regression against actual data
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对实际数据的回归
- en: As this is the first time we are using AdventureWorks, there are a couple of
    housekeeping items we need to take care of. We will be using the AdventureWorks
    2014 full database found at [https://msftdbprodsamples.codeplex.com/releases/view/125550](https://msftdbprodsamples.codeplex.com/releases/view/125550).
    If you want to bring the data locally, you can do that by restoring the `.bak`
    file from their website. If you go this route, note that I added some additional
    data to the `Production.ProductReview` table for this chapter. You will need to
    run the `populateProductReview.sql` script found in this chapter's GitHub repository
    after your database is installed to match the examples found in the book. In addition,
    you will have to generate your own connection string. If you just want to use
    the data on our server, you can use the connection string that is in the upcoming
    code sample.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: You might be thinking that I am nuts to put a connection string out in the public
    domain like this. First, don't tell anyone you have it. Second, if by some stroke
    of fortune millions of people buy this book and they all pound on this server
    to do the examples, I will be happy to pay Microsoft more $$ for the compute time.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: 'In Visual Studio, add a new script to your project and call it `AccordDotNet2.fsx`.
    Then, add the following references and open the script file:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Next, add a record type, a list of that record type, a connection string, and
    a query:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'There are three new language features here. The first is a record type called
    `ProductReview`. Record types are immutable named data structures and stand in
    contrast to tuples, which are unnamed. You can think of a record type as an immutable
    DTO/POCO that you might encounter in the VB.NET/C# world. `ProductReview` has
    three members: `ProductId`, `TotalOrders`, and `AvgReviews`. You can think of
    these members as properties of a POCO in the C#/VB.NET world.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: The second new language feature is the attribute added to the `connectionString`
    and query values. Most .NET developers are familiar with attributes, so you should
    be comfortable using them. By making `connectionString` and query literal, I can
    pass them into type providers in the script file.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we will use a `ResizeArray` datatype to keep our `seq` of product reviews.
    Because arrays are immutable in F# and we don't know how many reviews we will
    be getting back from the database, we need to use a special array that does allow
    resizing. This is equivalent to `System.Collections.Generic.List<>` that you might
    be familiar with in your C#/VB.NET code.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add some ADO.Net code to extract the data from the database and put it
    into the list:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This code should be familiar to most .Net developers. Sending it to the REPL,
    we can see:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'With the data coming down, let''s see if our models reflect what our manager
    noticed in the power `bi''` charting:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'You will see the following:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We now see a `0.29 r2` and a `451 rmse`, which shows a weak relationship between
    customer reviews and order quantity and that there is a 450 order margin of error.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Another point is that simple linear regressions tend to have a problem with
    outliers. We'll have a lot to say about this topic in the next chapter. Also,
    by doing a one-shot analysis, we have a large problem with over-fitting. We'll
    be talking about over-fitting extensively in [Chapter 8](part0049_split_000.html#1ENBI2-a18db0be6c20485ba81f22e43ca13055
    "Chapter 8. Feature Selection and Optimization"), *Feature Selection and Optimization*.
    For now, I just wanted to acknowledge that although we have a pretty good model,
    it is far from perfect. However, it is still better than eyeballing a chart and
    it does have some statistical validity. We now have a model and we can predict
    some sales. How do we put this in production?
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: AdventureWorks app
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will start by thinking about how we want to prevent users from abandoning
    orders based on low product reviews. One option would be to drop the review entirely.
    While this will prevent that undesirable effect of people dropping orders because
    of a low rating, it also prevents the desirable effect of people purchasing items
    based on a high rating. We could also hide the ratings for low-score items, but
    that would be seen through very easily. Another possibility is to lower the price
    of low-rated products, but lowering prices is anathema to most companies. Perhaps
    a better way is to have our site have knowledge of low-rated products and give
    people an incentive to order them by prefilling the amount that most people order
    for that given review. Consumer behaviorists have demonstrated that if you prefill
    a quantity, the consumer is less likely to abandon their purchase.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the environment
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Go get a copy of AdventureWorks UI from GitHub at this uri. Next, open the copy
    using Visual Studio 2015.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, follow these steps, which will guide you to set up the environment:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Let's go into our **Solution Explorer** and add an F# project (**File** | **New
    Project**).![Setting up the environment](img/00043.jpeg)
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete the script file and rename `Library1.fs` to `OrderPrediction.fs`.![Setting
    up the environment](img/00044.jpeg)
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open NuGet Package Manager and install Accord.NET to the F# project:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Make sure that the default project is `AdventureWorks.MachineLearning`:![Setting
    up the environment](img/00045.jpeg)
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open up `OrderPrediction.fs` and rename `Class1` to `OrderPrediction`.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Then, rename `X` to `PredictQuantity` with a single integer parameter of `ProductId`
    and a return value of a float. For now, make it `0.0`. Make the type public.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Compile the F# project.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Updating the existing web project
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, go to the C# project in the **Solution Explorer** and add a reference
    to the F# project:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '![Updating the existing web project](img/00046.jpeg)![Updating the existing
    web project](img/00047.jpeg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
- en: 'Go into `PurchaseOrderDetailsController.cs` and add a `using` statement to
    `AdventureWorks.MachineLearning`:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '![Updating the existing web project](img/00048.jpeg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
- en: 'Next, create an endpoint that can take in a `productId` and predict the quantity
    of the order:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Forgive me that this is RPC and not very RESTful. The intention of this exercise
    is about machine learning and not web development. If you want to rewrite, this
    is a more MVC idiomatic form, feel free.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: 'With the controller set up, hop over to the Create view:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '![Updating the existing web project](img/00049.jpeg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
- en: 'Add the following JavaScript at the bottom of the page in the `@section Scripts`
    block:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: With that in place, you should be able to run the project and after selecting
    a new product from the dropdown, the order quantity should populate with a `0.0`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '![Updating the existing web project](img/00050.jpeg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
- en: Implementing the regression
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the app wired up, let's hop back to the F# project and implement the prediction
    for real. First, make sure that you have a reference to `System.Data`.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing the regression](img/00051.jpeg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
- en: 'Next, open up `OrderPrediction.fs` and enter this in the following code:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since this is (almost) verbatim from the REPL project, you can go ahead with
    copying and pasting if you want to avoid some typing.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The only change from the REPL code is that `connection`, `command`, and `reader`
    are now assigned with the `use` keyword and not `let`. This is equivalent to the
    `using` statement in C# so that all resources are cleaned up in the most efficient
    manner.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: 'With that in place, you can run the UI and see the actual value being predicted
    from the regression that uses all of our data:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing the regression](img/00052.jpeg)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
- en: Congratulations! You have successfully wired up a website with a simple linear
    regression. This prediction is dynamic because the regression is calculated on
    every page refresh. This means as more data goes into our database, the websites
    reflect changes in the product reviews at real time. The software architect in
    you should be pulling the alarm because this will have a severe impact on performance;
    we pull the aggregate data and then do the regression calculation on each call.
    We will discuss better strategies later in the book that allow our site to have
    real-time or near-time performance to go with a machine learning algorithm.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter dipped our toes into the water of creating a machine learning model
    and implementing those models in a line of business application. There are many
    things that we glossed over that will get all of your data science friends mad,
    such as my dumbed-down formula for a regression, overfitting, and using a regression
    without dealing with outliers. Also, the web developers in the room have plenty
    to be mad about, including my rudimentary website design and injecting a data-intensive
    operation in a page load. Fear not. We will address these issues (and many more)
    in the coming chapters.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
