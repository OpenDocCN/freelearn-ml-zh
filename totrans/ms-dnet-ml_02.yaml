- en: Chapter 2. AdventureWorks Regression
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Imagine you''re a business developer at AdventureWorks, a bicycle manufacturing
    company based in Seattle, Washington. You are responsible for three applications
    that run at the top of a single SQL Server instance. The applications are:'
  prefs: []
  type: TYPE_NORMAL
- en: A customer ordering website with a section for direct customer sales and another
    section for resellers to buy in bulk
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A desktop inventory control management application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A reporting solution using Power BI as a frontend
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All three of these applications share similar characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: They are database-first applications where their primary role is to wireframe
    the database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are all .NET applications that use standard Microsoft templating and frameworks,
    such as MVC for the website and Entity Frameworks for both web and desktop solutions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One day, your boss calls you into her office and says, "we are concerned about
    the reseller's section of the website. We've noticed through some basic charting
    in the Power BI that many resellers are dropping their order depending on the
    average customer reviews of the product.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the one of the charts we are looking at:'
  prefs: []
  type: TYPE_NORMAL
- en: '![AdventureWorks Regression](img/00020.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Obviously, if we can prevent people from doing this, we will maximize sales.
    We want to maximize our existing code assets, so your solution needs to integrate
    with the existing website and we want our customers to experience the same look
    and feel they currently have."
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what the current webpage looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![AdventureWorks Regression](img/00021.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You tell your boss that you will take a look, think about it for a couple of
    days, and come up with some ideas. Inside, you are thrilled because this will
    take you out of the traditional role of web dev and into data science. After researching
    some different machine learning techniques, you settle on using a simple regression
    to help achieve this goal.
  prefs: []
  type: TYPE_NORMAL
- en: Simple linear regression
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Regressions attempt to predict one number given a set of different numbers.
    For example, imagine we had a box where we enter in a number and another number
    comes out:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Simple linear regression](img/00022.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'I enter the number 1 into the box, and the number 6 comes out. Then, I enter
    another 1 into the box and the number 7 comes out. I do this five times and I
    get the following results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Before entering in another one, what do you think the output will be? You probably
    guessed 6\. However, if I asked you whether you were 100% sure that 6 would come
    out, you would say, "no, but it will probably be 6." In fact, you might say that
    6 has a 60% chance of coming out based on prior experience (three sixes in five
    total attempts).
  prefs: []
  type: TYPE_NORMAL
- en: 'What you are doing mentally is a kind of regression. Typically, linear regressions
    are written using a formula like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here, *y* is the number you want to predict and *x0*, *x1*, and *x2* are some
    numbers that might affect *y*. Back to AdventureWorks, *y* is the number of bikes
    a retail store will order in a month, *x0* is the month of the year, *x1* is the
    order from the previous three months, and *x2* is the number of other bikes that
    are being ordered by their immediate competitors. *E* is all of the things that
    our formula cannot account for that still affects the bike sales—like an individual
    store losing a key sales person. If we knew that *x0 + x1 + x2* accounted for
    75% of *y*, we would know that 25% of *y* cannot be explained.
  prefs: []
  type: TYPE_NORMAL
- en: Our goal, then, is to find as few *x* parameters as possible that have the greatest
    impact on *y* and then make a reasonable attempt to have our website reflect both
    the predicted value and to influence the users for our benefit.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many types of regressions, and we will start with the most basic,
    though surprisingly powerful one—the simple regression. In a simple regression,
    there is only one input variable and one output, so the formula is *y = x0 + E*.
    Because there are only two variables, we can plot them on a two-dimensional graph.
    For example, if we had this data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Simple linear regression](img/00023.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can plot the data like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Simple linear regression](img/00024.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'What we want to do with a simple regression is find the line that "fits" best
    through all of the data points:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Simple linear regression](img/00025.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In this example, you can see that the line goes through points 1, 2, and 5\.
    If the line does not intersect a given point, we want to know the distance from
    the line to the point. In this example, we want to know the distance of the dotted
    red line for points 3 and 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![Simple linear regression](img/00026.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: If we add up the distance of all of the dotted red lines and divide by the number
    of total points on our graph, we have a pretty good idea of how well this line
    represents the plot. If we are then given a number that is on our graph, we can
    make a prediction about where it will land. For example, if we are given another
    2, we can predict that we will probably result in a 2\. Not only that, we can
    make predictions about where the line is headed (slope) for inputs that we have
    not seen before. For example, if we input 6, we can guess that it will probably
    be close to 6.
  prefs: []
  type: TYPE_NORMAL
- en: In a real-word example, we typically don't have a single input for a given number.
    So, we might get a hundred 1s and 90% of the time the output will be 1, 5% of
    the time the output will be 1.25, and 5% of the time, the output will be 0.75\.
    If we placed all the 100s on our scatter plot, we will see lots of points on 1
    (or a really dark dot), some on 1.25, and some on 0.75\. With this mental model
    in place, let's go ahead and create a simple linear regression from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open Visual Studio 2015 and create a new F# Library:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up the environment](img/00027.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Once Visual Studio finishes creating the project and files for you, go into
    the solution explorer, and open `Script1.fsx` and delete all the contents in the
    file. You should now have an empty script file ready for your code.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the test data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first thing we will do is create a dataset that we can use in our regression
    that gives us predictable results. Create an array like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `input` is an array of tuples. A tuple is a data structure that contains
    groups of data that are unnamed—usually there are two items. The types do *not*
    have to be the same as a tuple''s items. If you are familiar with the concept
    of a key/value pair, you can use that as a mental model of a tuple. The only real
    "gotcha" is that tuples can have many items so this it is a perfectly valid tuple:
    `2,true,"dog"` where the first position is an `int`, the second is a Boolean,
    and the third is a string.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you highlight our single line of code and send it to the REPL using *Alt*
    + *Enter*, you will get this back:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The F# compiler is telling us that we have an array that contains tuples of
    type `int` and `float`. In this example, we will use the first value of the tuples
    to be the *X* and the second to be the *Y* of our simple linear regression.
  prefs: []
  type: TYPE_NORMAL
- en: With the data set up, let's think about how to calculate a regression. A more
    mathematical definition than what I used earlier is *y = A + Bx*, where *A* is
    the *Y* intercept of the line and *B* is the slope of the line. Therefore, we
    need to figure out how to calculate the intercept of the line and the slope of
    the line. Turns out that we need to calculate the standard deviation of the *x*
    and *y* values and something called the **Person's correlation**. Let's tackle
    each one of these separately.
  prefs: []
  type: TYPE_NORMAL
- en: Standard deviation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The best explanation of standard deviation that I have run across is at [http://www.mathsisfun.com/data/standard-deviation.html](http://www.mathsisfun.com/data/standard-deviation.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Standard deviation is the square root of the variance; to calculate the variance:'
  prefs: []
  type: TYPE_NORMAL
- en: Work out the mean (the simple average of the numbers).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, for each number, subtract the mean and square the result (the squared
    difference).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, work out the average of those squared differences.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'So, taking MathIsFun''s explanation and applying it to F#, we can write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Sending that to the REPL gives us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Notice how there is a one-to-one correspondence between each line of the English
    explanation and the F# code. This is not an accident. F# is really great at matching
    your thought process. In fact, we even resisted to temptation to `for…each` in
    code when we saw those words in the English version.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is some new F# code here that might be confusing. Notice that when I
    calculated the mean, I called the `Seq.average` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'And hence, the `source` argument came after the function. I could have just
    as well written:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This is something you will have seen before if you worked through [Chapter
    1](part0015_split_000.html#E9OE1-a18db0be6c20485ba81f22e43ca13055 "Chapter 1. Welcome
    to Machine Learning Using the .NET Framework"), *Welcome to Machine Learning Using
    the .NET Framework*. There is really no consensus in the F# community about which
    way is more idiomatic, though the style guidelines argue for the non-pipe forward
    way. Since both are supported by the languages and widely used, I use both depending
    on the code. Typically, when I have a string of thoughts to push together I use
    the pipe operator, but if there is only one calculation, I just call the function
    directly. Notice that I did this *after syntax* technique in all three lines:
    mean, deltas, and the return of the function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With variance out of the way, we can make our standard deviation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Sending that to the REPL gives us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'With the standard deviation ready, we can plug in our numbers. Since we will
    be calculating the standard deviation of *X* and *Y* independently, let''s break
    the tuple apart into separate arrays and calculate their average and standard
    deviations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Sending that to the REPL gives us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'There is one thing new here. Notice that when calculating *x*, I used this
    syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: With `float x` as the return. `float` is a function that casts the int into,
    well, a float. If you are coming from VB.NET/C#, the comparable syntax will be
    `(float)x`.
  prefs: []
  type: TYPE_NORMAL
- en: Pearson's correlation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, let''s calculate the Pearson''s correlation. The best explanation I have
    found for it is available at [http://onlinestatbook.com/2/describing_bivariate_data/calculation.html](http://onlinestatbook.com/2/describing_bivariate_data/calculation.html).
    You can think of creating the Pearson''s correlation as filling in columns in
    an Excel spreadsheet and then doing some calculations on the column totals. Start
    a grid with *x* and *y* in different rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Pearson''s correlation](img/00028.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, calculate the mean for *X* and *Y*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Pearson''s correlation](img/00029.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, calculate *x* and *y*. *x* is calculated by subtracting the mean of *X*
    from *X* and *y* is calculated by subtracting the mean of *Y* from *Y*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Pearson''s correlation](img/00030.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, fill in *xy*, *x**²*, and *y* *²*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Pearson''s correlation](img/00031.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'With the grid filled in, you can sum up *xy*, *x²*, and *y²*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Pearson''s correlation](img/00032.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The final answer is computed by dividing the sum of the *xy* column (*Σxy*)
    by the square root of the product of the sum of the *x²* column (*Σx**²*) and
    the sum of the *y**²* column (*Σy**²*). So, in our example, it will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'I now want to repeat these steps without that grid in English:'
  prefs: []
  type: TYPE_NORMAL
- en: Calculate the mean for *X*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calculate the mean for *Y*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calculate *x*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calculate *y*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fill in *xy*, *x**²*, and *y**²*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sum up *y**²*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sum up *x**²*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sum up *y**²*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do the final formula.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'And this is how I would write it in F#:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Sending that to the REPL gives us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Again, you can see that there is almost a one-to-one correspondence between
    the formula and the code. There are a couple of things to note.
  prefs: []
  type: TYPE_NORMAL
- en: '`Seq.zip x y` is a function that takes in two sequences of equal length and
    combines them together into a single tuple. So for *x* and *y* zipped:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Pearson''s correlation](img/00033.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Another thing to notice is that there is a three-item tuple being used in the
    `Seq.SumBys`. Each item of the tuple represents a different column in the grid
    we were filling out: *xy*, *x²*, and *y²*. Although I normally don''t like to
    create tuples greater than two items, I can make an exception in this case because
    I am only using the tuple in the context of these higher-order functions. Because
    the data structure is contained and short-lived, a tuple is the best choice. If
    I needed that data structure outside of the higher-order function, a record type
    would have been more appropriate. We''ll get more exposure to a record type later
    in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A final thing to notice is the `Seq.sumBy` higher-ordered function. As you
    may expect, `sumBy` computes the sum of things. The key thing to realize is that
    the `sumBy` expects a function to be passed, not a data structure. If you just
    want to sum up the values in an array, you can use the `Seq.sum()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'And so to run a Pearson''s correlation for *x* and *y*, type this into the
    script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Sending that to the REPL gives us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Linear regression
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With standard deviation and `r` calculated, we are ready for our linear regression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'What these two values mean is that our *y* intercept is `-.22`, or very close
    to the origin, and our slope is `1.075`. Laying them out on the same grid, you
    can see that the predicted numbers are close to the actual:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Linear regression](img/00034.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'These are still different enough on the plot that we eye-balled earlier with
    the red line going directly through 1, 2, 3, 4, 5 (solid line) and the regression
    line taking a slightly different path (dashed line):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Linear regression](img/00035.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We will revisit how good this regression is at describing our data (and making
    predictions) in a bit. Until then, we can safely say that we have a regression,
    which seems to fit our data pretty well.
  prefs: []
  type: TYPE_NORMAL
- en: We now have a library we could compile for our AdventureWorks problem. However,
    we may not want to roll our own because this is a fairly limited implementation.
    For example, when we calculated variance and standard deviation, we were using
    the formula for the variance and standard deviation for an entire population.
    If we had only a small sample of the population, there is a different formula
    that we will implement. Also, linear regressions have several parameters that
    we can enter to try and *tune up* the model in our implementation. As you can
    guess, there is quite a bit of effort in writing your own library, and you still
    may not get it right. If you were wondering in the middle of the prior exercise
    of rolling our own, "is there an easier way?" The answer is "yes."
  prefs: []
  type: TYPE_NORMAL
- en: Math.NET
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We had a brief introduction to Math.Net in [Chapter 1](part0015_split_000.html#E9OE1-a18db0be6c20485ba81f22e43ca13055
    "Chapter 1. Welcome to Machine Learning Using the .NET Framework"), *Welcome to
    Machine Learning Using the .NET Framework*. In this section, we will add it to
    our project and see how it can help us do a simple linear regression. In the solution
    explorer of your open project, add a new script file and name it `MathDotNet.fsx`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, open the NuGet Package Manager Console (**Tools** | **NuGet Package Manger**
    | **Package Manager Console**):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Math.NET](img/00036.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the console, enter the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see that the package installs successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Math.NET](img/00037.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Close the Package Manager Console and the `readme.txt` file that opens when
    you install Math.NET. In the future, I will assume that you know how to open and
    enter commands to install NuGet packages.
  prefs: []
  type: TYPE_NORMAL
- en: Regression try 1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the script file, create the same input that we saw in the hand-rolled script
    and calculate the means of *x* and *y*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, point to the Math.NET library installed with the nugget package and add
    a reference to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, use Math.Net to calculate the standard deviation of *x* and *y*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code statements will give you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, use Math.Net to calculate the `r`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The following will be the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can calculate the regression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is what you will get in the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'There is one new thing I want to point out in the script. You had to type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `#r` stands for reference and points the FSI to the filesystem to locate
    the assembly that we want to use. The FSI loads with very few libraries installed,
    so you typically have to add a reference the ones you need. Notice the `".."`
    shorthand as the prefix for the file path. This is a relative locator that translates
    into the solution location.
  prefs: []
  type: TYPE_NORMAL
- en: The `open` command tells the FSI to open up the `.dll` file that we pointed
    to in the previous line. This is the same as `using` in C#, `Imports` in VB.NET,
    and `library` in R.
  prefs: []
  type: TYPE_NORMAL
- en: So, this is a much easier way to calculate the components of a simple linear
    regression than by hand. But wait, there is even more.
  prefs: []
  type: TYPE_NORMAL
- en: Regression try 2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Math.NET makes it even easier to calculate the regression without going into
    the components. In the script, enter the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '`Math.Numerics` already has the regression available via the `Fit()` function.
    `Fit()` takes in two arrays (in our case, *x* and *y*) and returns a tuple. The
    first item of the tuple is the intercept and the second is the slope. The only
    new code that I introduced here are the `fst` and `snd` operators. These are shorthand
    notations for tuples that have a length of two. Calling `fst` on a tuple returns
    the first item and `snd` returns the second. If you call `fst` and `snd` on a
    tuple that has more than two items, you will get a type mismatch compiler error.'
  prefs: []
  type: TYPE_NORMAL
- en: Accord.NET
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With Math.NET doing all of our heavy lifting, we have a better way to get the
    results of a simple linear regression. However, there is another way I want to
    discuss, Accord.NET. Open the NuGet Package Manager and install the following
    three packages:'
  prefs: []
  type: TYPE_NORMAL
- en: Accord
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accord.Statistics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: FSharp.Data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Note that you will get a pop-up window when you install FSharp.Data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Accord.NET](img/00038.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Click on **Enable**.
  prefs: []
  type: TYPE_NORMAL
- en: Regression
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Back in the script file, enter the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'When you send this to the REPL, you will see the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'What you see here is the exact same calculation as before with the formula
    kindly printed out (I have rounded it to three decimal places):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Regression evaluation using RMSE
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Accord.NET goes one better than Math.NET `Fit()` as it returns the sum of the
    squared errors and the coefficient of determination (called r squared). In this
    case, the sum of squared errors is `1.06875` and the r squared is `0.915` (rounded
    to three decimal places). This is great because we now have two vital pieces of
    information:'
  prefs: []
  type: TYPE_NORMAL
- en: A model to predict
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some way to help us evaluate how good the model is at predicting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In machine learning, it is not enough to simply implement a model and get some
    answers. We also have to be able to speak to know how good our answer really is.
    The **sum of squares error**, often called **SSE**, is a common way to evaluate
    a simple linear regression. To start thinking about SSE, we need to know two pieces
    of information for each *y* that we used—what we guessed and what the actual value
    is. Using our existing dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Regression evaluation using RMSE](img/00039.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You can see that the model was created based on all of the *y* data points,
    and then Accord.NET went back and checked how close that model *fits* each data
    point. These differences are squared, then the squared values are summed. The
    goal is to get the sums of squares as low as possible. Once we have the SSE, we
    can change our model to try to get the sum of squares lower. For example, what
    if we changed the slope from `1.075x` to `1.000x`, which is what we were eyeballing
    earlier?
  prefs: []
  type: TYPE_NORMAL
- en: '![Regression evaluation using RMSE](img/00040.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Since we have all five data points that are available for the initial model
    calculation, you are not going to improve on the model by making manual changes
    like this. The original regression is the best way of describing the relationship
    among these five data points. It is important to note that the SSE is a context-free
    measure. This means 1.069 does not have any value in and of itself. We only know
    that 1.069 is better than 1.367\. Basically, we want the SSE to be as low as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'A slightly better variation of the SSE is the **Mean Square Error** (**MSE**).
    The MSE is the SSE divided by the number of observations of the regression:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Regression evaluation using RMSE](img/00041.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In this case, the MSE is `0.2138`. Like the MSE, the number itself is not particularly
    useful. However, if we take the square root of the MSE, often called the **Root
    Of Mean Square Error**, or **RMSE**, the result is an error measure in the same
    units as our original numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: In our case, the RMSE is `0.462` means that any given guess is likely off by
    0.46\. When you talk to other data scientists at your next cocktail party (you
    do go to cocktail parties with data scientists, don't you?), you will typically
    use the RMSE when evaluating the predictive capabilities of a simple linear model.
  prefs: []
  type: TYPE_NORMAL
- en: Using the RMSE, we now have a measure of how accurate our model is when predicting
    values. We also have a second measure, called the r2, that calculates how much
    correlation our model has. The r2 takes the r (in this case, Pearson's correlation)
    and squares it. The r2 is always between zero and one, with zero meaning that
    there is no correlation between *x* and *y* and one meaning that the regression
    line perfectly fits the data. In practical terms, we want a low as possible RMSE
    with a high as possible r2.
  prefs: []
  type: TYPE_NORMAL
- en: Regression and the real world
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we really haven't done any machine learning, in that we can't make our
    model any better. The initial regression is the best and explains 91.5% of the
    data. However, the world does not work in such a straightforward manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'The challenge is that we will start applying a simple linear regression on
    a dataset that represents human activity (in our case, AdventureWorks sales),
    and human activity is fraught with uncertainty. Consider a more realistic data
    frame with a product, its list price, and its customer reviews:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Regression and the real world](img/00042.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Notice that the rating seems to have some wide variance. Some customers gave
    the bike a 5 while others gave it a 1 or 2\. You would think for the same product,
    the average reviews would be fairly similar. Perhaps we have a problem with manufacturing
    quality or perhaps the price is such that low-end customers expect more from what
    they perceive to be a very expensive bike and high-end customers are thrilled
    with the value they got from what they perceive to be a low-cost bike. Now can
    we start with our model? Yes! Let's take the data from AdventureWorks and see
    how it stacks up with an initial model using Accord.NET.
  prefs: []
  type: TYPE_NORMAL
- en: Regression against actual data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As this is the first time we are using AdventureWorks, there are a couple of
    housekeeping items we need to take care of. We will be using the AdventureWorks
    2014 full database found at [https://msftdbprodsamples.codeplex.com/releases/view/125550](https://msftdbprodsamples.codeplex.com/releases/view/125550).
    If you want to bring the data locally, you can do that by restoring the `.bak`
    file from their website. If you go this route, note that I added some additional
    data to the `Production.ProductReview` table for this chapter. You will need to
    run the `populateProductReview.sql` script found in this chapter's GitHub repository
    after your database is installed to match the examples found in the book. In addition,
    you will have to generate your own connection string. If you just want to use
    the data on our server, you can use the connection string that is in the upcoming
    code sample.
  prefs: []
  type: TYPE_NORMAL
- en: You might be thinking that I am nuts to put a connection string out in the public
    domain like this. First, don't tell anyone you have it. Second, if by some stroke
    of fortune millions of people buy this book and they all pound on this server
    to do the examples, I will be happy to pay Microsoft more $$ for the compute time.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Visual Studio, add a new script to your project and call it `AccordDotNet2.fsx`.
    Then, add the following references and open the script file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, add a record type, a list of that record type, a connection string, and
    a query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'There are three new language features here. The first is a record type called
    `ProductReview`. Record types are immutable named data structures and stand in
    contrast to tuples, which are unnamed. You can think of a record type as an immutable
    DTO/POCO that you might encounter in the VB.NET/C# world. `ProductReview` has
    three members: `ProductId`, `TotalOrders`, and `AvgReviews`. You can think of
    these members as properties of a POCO in the C#/VB.NET world.'
  prefs: []
  type: TYPE_NORMAL
- en: The second new language feature is the attribute added to the `connectionString`
    and query values. Most .NET developers are familiar with attributes, so you should
    be comfortable using them. By making `connectionString` and query literal, I can
    pass them into type providers in the script file.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we will use a `ResizeArray` datatype to keep our `seq` of product reviews.
    Because arrays are immutable in F# and we don't know how many reviews we will
    be getting back from the database, we need to use a special array that does allow
    resizing. This is equivalent to `System.Collections.Generic.List<>` that you might
    be familiar with in your C#/VB.NET code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add some ADO.Net code to extract the data from the database and put it
    into the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'This code should be familiar to most .Net developers. Sending it to the REPL,
    we can see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'With the data coming down, let''s see if our models reflect what our manager
    noticed in the power `bi''` charting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: We now see a `0.29 r2` and a `451 rmse`, which shows a weak relationship between
    customer reviews and order quantity and that there is a 450 order margin of error.
  prefs: []
  type: TYPE_NORMAL
- en: Another point is that simple linear regressions tend to have a problem with
    outliers. We'll have a lot to say about this topic in the next chapter. Also,
    by doing a one-shot analysis, we have a large problem with over-fitting. We'll
    be talking about over-fitting extensively in [Chapter 8](part0049_split_000.html#1ENBI2-a18db0be6c20485ba81f22e43ca13055
    "Chapter 8. Feature Selection and Optimization"), *Feature Selection and Optimization*.
    For now, I just wanted to acknowledge that although we have a pretty good model,
    it is far from perfect. However, it is still better than eyeballing a chart and
    it does have some statistical validity. We now have a model and we can predict
    some sales. How do we put this in production?
  prefs: []
  type: TYPE_NORMAL
- en: AdventureWorks app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will start by thinking about how we want to prevent users from abandoning
    orders based on low product reviews. One option would be to drop the review entirely.
    While this will prevent that undesirable effect of people dropping orders because
    of a low rating, it also prevents the desirable effect of people purchasing items
    based on a high rating. We could also hide the ratings for low-score items, but
    that would be seen through very easily. Another possibility is to lower the price
    of low-rated products, but lowering prices is anathema to most companies. Perhaps
    a better way is to have our site have knowledge of low-rated products and give
    people an incentive to order them by prefilling the amount that most people order
    for that given review. Consumer behaviorists have demonstrated that if you prefill
    a quantity, the consumer is less likely to abandon their purchase.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Go get a copy of AdventureWorks UI from GitHub at this uri. Next, open the copy
    using Visual Studio 2015.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, follow these steps, which will guide you to set up the environment:'
  prefs: []
  type: TYPE_NORMAL
- en: Let's go into our **Solution Explorer** and add an F# project (**File** | **New
    Project**).![Setting up the environment](img/00043.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete the script file and rename `Library1.fs` to `OrderPrediction.fs`.![Setting
    up the environment](img/00044.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open NuGet Package Manager and install Accord.NET to the F# project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Make sure that the default project is `AdventureWorks.MachineLearning`:![Setting
    up the environment](img/00045.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open up `OrderPrediction.fs` and rename `Class1` to `OrderPrediction`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Then, rename `X` to `PredictQuantity` with a single integer parameter of `ProductId`
    and a return value of a float. For now, make it `0.0`. Make the type public.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile the F# project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Updating the existing web project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, go to the C# project in the **Solution Explorer** and add a reference
    to the F# project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Updating the existing web project](img/00046.jpeg)![Updating the existing
    web project](img/00047.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Go into `PurchaseOrderDetailsController.cs` and add a `using` statement to
    `AdventureWorks.MachineLearning`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Updating the existing web project](img/00048.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, create an endpoint that can take in a `productId` and predict the quantity
    of the order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Forgive me that this is RPC and not very RESTful. The intention of this exercise
    is about machine learning and not web development. If you want to rewrite, this
    is a more MVC idiomatic form, feel free.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the controller set up, hop over to the Create view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Updating the existing web project](img/00049.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Add the following JavaScript at the bottom of the page in the `@section Scripts`
    block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: With that in place, you should be able to run the project and after selecting
    a new product from the dropdown, the order quantity should populate with a `0.0`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Updating the existing web project](img/00050.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Implementing the regression
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the app wired up, let's hop back to the F# project and implement the prediction
    for real. First, make sure that you have a reference to `System.Data`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing the regression](img/00051.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, open up `OrderPrediction.fs` and enter this in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since this is (almost) verbatim from the REPL project, you can go ahead with
    copying and pasting if you want to avoid some typing.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The only change from the REPL code is that `connection`, `command`, and `reader`
    are now assigned with the `use` keyword and not `let`. This is equivalent to the
    `using` statement in C# so that all resources are cleaned up in the most efficient
    manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'With that in place, you can run the UI and see the actual value being predicted
    from the regression that uses all of our data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing the regression](img/00052.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Congratulations! You have successfully wired up a website with a simple linear
    regression. This prediction is dynamic because the regression is calculated on
    every page refresh. This means as more data goes into our database, the websites
    reflect changes in the product reviews at real time. The software architect in
    you should be pulling the alarm because this will have a severe impact on performance;
    we pull the aggregate data and then do the regression calculation on each call.
    We will discuss better strategies later in the book that allow our site to have
    real-time or near-time performance to go with a machine learning algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter dipped our toes into the water of creating a machine learning model
    and implementing those models in a line of business application. There are many
    things that we glossed over that will get all of your data science friends mad,
    such as my dumbed-down formula for a regression, overfitting, and using a regression
    without dealing with outliers. Also, the web developers in the room have plenty
    to be mad about, including my rudimentary website design and injecting a data-intensive
    operation in a page load. Fear not. We will address these issues (and many more)
    in the coming chapters.
  prefs: []
  type: TYPE_NORMAL
