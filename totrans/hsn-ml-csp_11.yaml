- en: Microbenchmarking and Activation Functions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微基准测试和激活函数
- en: 'In this chapter we are going to learn the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下内容：
- en: What microbenchmarking is
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是微基准测试
- en: How to apply it to your code
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将其应用到您的代码中
- en: What activation functions are
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 激活函数是什么
- en: How to plot and benchmark activation functions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何绘制和基准测试激活函数
- en: Every developer needs to have a good benchmarking tool at their disposal. Qualitative
    benchmarks are everywhere; you hear everyday, *We decreased this by 10% and increased
    that by 25%*. Remember the old adage, *When you hear a number thrown out, 98.4
    percent of the time that number is false*? By the way, I just made up that number
    as well. When you hear a quote like that, ask that person to prove it and what
    do you get? Task manager perhaps? As data scientists, we don't need qualitative
    results; we need quantitative results that can be proven and consistently replicated.
    Reproducible results are incredibly important, not only for consistency but also
    for credibility and accuracy. And that's where microbenchmarking comes in to play.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 每个开发者都需要一个良好的基准测试工具在手。定性基准测试无处不在；你每天都会听到，“我们减少了10%，增加了25%”。记住那句古老的谚语，“当你听到一个数字被抛出来时，98.4%的情况下那个数字是假的”？顺便说一句，那个数字也是我随便编的。当你听到这样的引用时，要求那个人证明它，你得到的是什么？任务管理器吗？作为数据科学家，我们不需要定性结果；我们需要可以证明并一致复制的定量结果。可复现的结果非常重要，不仅因为一致性，还因为可信度和准确性。这正是微基准测试发挥作用的地方。
- en: 'We are going to use the irreplaceable `BenchmarkDotNet` library, which you
    can find here: [https://github.com/dotnet/BenchmarkDotNet](https://github.com/dotnet/BenchmarkDotNet).'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用无可替代的`BenchmarkDotNet`库，您可以在以下链接找到它：[https://github.com/dotnet/BenchmarkDotNet](https://github.com/dotnet/BenchmarkDotNet).
- en: If you are not already using this library, you need to drop what you are doing
    right now and install it. I consider it one of the most irreplaceable frameworks
    you can use, and I consider it in terms of importance, right up there with unit
    and integration testing.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有使用这个库，您需要立即放下手头的工作并安装它。我认为这是您可以使用的最无可替代的框架之一，并且我认为它在重要性上与单元测试和集成测试并列。
- en: To show you just how valuable this tool is, we are going to plot several activation
    functions and compare their runtimes. As part of this, we will consider **warmup**,
    **legacy** and **RyuJIT**, **cold starting**, and more aspects of a program execution.
    In the end, we will have a quantitative set of results that prove the exact measurements
    of our functions. If, say in release 2.0, we see that something is running slower,
    we can rerun the benchmarks and compare.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示这个工具的价值，我们将绘制几个激活函数并比较它们的运行时间。作为其中的一部分，我们将考虑**预热**、**遗留**和**RyuJIT**、**冷启动**以及程序执行的更多方面。最后，我们将得到一组定量结果，证明我们函数的确切测量值。如果，比如说在2.0版本中，我们发现某些东西运行得更慢，我们可以重新运行基准测试并比较。
- en: I would strongly recommend that this be integrated into your continuous integration/continuous
    build process so that at each release, you have benchmark numbers to compare.
    And that's not just our code. I have created massive CI/CD systems that encompassed
    a huge number of programs, microservices, environments, and build and deploy steps.
    We would also regularly benchmark certain .NET library functions that we use all
    the time to verify; in between .NET framework releases, nothing has changed.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈建议将此集成到您的持续集成/持续构建过程中，以便在每次发布时，您都有基准数字进行比较。这不仅仅是我们自己的代码。我创建了一个庞大的CI/CD系统，涵盖了大量的程序、微服务、环境和构建及部署步骤。我们还会定期基准测试我们经常使用的某些.NET库函数，以验证；在.NET框架版本之间，没有任何变化。
- en: In this chapter, we are going to have two samples. The first is an activation
    function viewer; it will plot each activation function so that you can see how
    it looks. You can find this as part of what I consider one of the most valuable
    open source programs, **SharpNEAT**, by Mr. Colin Green. This package is absolutely
    incredible, and there's not a day that goes by when I don't use it. I have created
    new UIs on top of it as well as advanced versions to work with my requirements,
    and it's as flexible a tool as you can find. I work daily with researching the
    integration of mirror and canonical neurons into extendable substrates, and tools
    such as SharpNEAT are incredible. A future advanced book will be highlighting
    SharpNEAT much more, so get familiar with it now! This first sample application
    is available with the latest SharpNEAT package, which can be found at [https://github.com/colgreen/sharpneat](https://github.com/colgreen/sharpneat).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将展示两个示例。第一个是一个激活函数查看器；它将绘制每个激活函数，以便您可以查看其外观。您可以在我认为最有价值的开源程序之一，由科林·格林先生开发的**SharpNEAT**中找到它。这个包绝对令人难以置信，我几乎每天都在使用它。我还在此基础上创建了新的用户界面以及满足我需求的先进版本，这是一个非常灵活的工具。我每天都在研究将镜像神经元和规范神经元集成到可扩展基板中的工作，像SharpNEAT这样的工具是不可思议的。未来的高级书籍将更多地突出SharpNEAT，所以现在就熟悉它吧！这个第一个示例应用程序包含在最新的SharpNEAT包中，您可以在[https://github.com/colgreen/sharpneat](https://github.com/colgreen/sharpneat)找到它。
- en: Visual activation function plotting
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可视化激活函数绘制
- en: Here is a plot of local and global minimum being plotted from a custom version
    of SharpNEAT. It is absolutely amazing what you can do with this product in the
    realm of neural networks and advanced machine learning!
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这是SharpNEAT自定义版本绘制的局部和全局最小值的图。在这个领域，您可以用这个产品做很多事情，真是太令人惊叹了！
- en: '![](img/5e1b0cd5-63fd-4651-8f0e-96b9b2fb805a.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5e1b0cd5-63fd-4651-8f0e-96b9b2fb805a.png)'
- en: As I mentioned, we are going to plot and then benchmark several activation functions.
    We hear this term **activation functions** everywhere, but do we really know what
    it means? Let's start by giving a quick explanation just in case you are not familiar.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我提到的，我们将绘制并基准测试几个激活函数。我们到处都在听到这个术语“激活函数”，但我们真的知道它是什么意思吗？让我们先快速解释一下，以防您不熟悉。
- en: An activation function is used to decide whether a neuron has been activated
    or not. Some people like to replace the word **activated** with **fired**. Whatever
    flips your pickle! Either way, it's what finally determines whether something
    is on or off, fired or not, activated or not.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 激活函数用于决定神经元是否被激活。有些人喜欢用“**激活**”这个词来替换“**触发**”。无论哪种方式，它最终决定了某物是开启还是关闭，是否触发，是否激活。
- en: 'Let''s start by showing you what a plot of a single activation function looks
    like:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从向您展示单个激活函数的图开始：
- en: '![](img/25824019-1323-4dd5-bc88-242fec67a72d.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](img/25824019-1323-4dd5-bc88-242fec67a72d.png)'
- en: 'This is what the **Logistic Steep** approximation and **Swish activation**
    function look like when they are plotted individually, as there are many types
    of activation functions, here''s what all of our activation functions are going
    to look like when they are plotted together:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当单独绘制时，这是**Logistic Steep**近似和**Swish激活**函数的外观，因为存在许多类型的激活函数，所以当它们一起绘制时，这就是我们所有的激活函数将看起来像什么：
- en: '![](img/7c96dcb6-1fe0-4351-a348-8c4f8696d16a.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7c96dcb6-1fe0-4351-a348-8c4f8696d16a.png)'
- en: At this point you may be wondering, *Why do we even care what the plots look
    like?* Great question. We care because you are going to use these quite a bit
    once you progress into neural networks and beyond. It's very handy to be able
    to know whether your activation function will place the value of your neuron in
    on or off state, and what range it will keep or need the values in. You will no
    doubt encounter and/or use activation functions in your career as a machine learning
    developer, and knowing the difference between a `TanH` and a `LeakyReLU` activation
    function is very important.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，您可能想知道，“我们为什么甚至关心这些图看起来像什么？”这是一个很好的问题。我们关心，因为一旦您进入神经网络等领域，您将大量使用这些函数。知道您的激活函数是否会将神经元的值置于开启或关闭状态，以及它将保持或需要的值范围是非常有用的。毫无疑问，您作为机器学习开发者将在职业生涯中遇到并/或使用激活函数，了解`TanH`和`LeakyReLU`激活函数之间的区别非常重要。
- en: Plotting all functions
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制所有函数
- en: 'The plotting of all the activation functions is done within a single function,
    remarkably titled `PlotAllFunctions`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 所有激活函数的绘制都是在单个函数中完成的，这个函数令人惊讶地被命名为`PlotAllFunctions`：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The main Plot function
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主要的绘图函数
- en: 'Behind the scenes, the `Plot` function is what is responsible for executing
    and plotting each function:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，`Plot`函数负责执行和绘制每个函数：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The main point of interest within this code is highlighted in yellow. This is
    where the activation function that we passed in is executed and its value used
    for the *y* axis plot value. The famous **ZedGraph** open source plotting package
    is used for all graph plotting. Once each function is executed, the respective
    plot will be made.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，值得关注的主要部分用黄色突出显示。这是执行我们传递的激活函数并使用其值作为*Y*轴绘图值的地方。著名的**ZedGraph**开源绘图包用于所有图形绘制。每个函数执行后，相应的绘图将被制作。
- en: Benchmarking
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基准测试
- en: '`BenchmarkDotNet` produces several reports, one of which is an HTML report
    similar to what you see here:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`BenchmarkDotNet`生成多个报告，其中之一是类似于您在这里看到的HTML报告：'
- en: '![](img/ec9f37e5-485d-4bd9-8ef2-4038279fb496.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ec9f37e5-485d-4bd9-8ef2-4038279fb496.png)'
- en: 'The Excel report provides the details of every parameter that was used in running
    the program and is your most extensive source of information. In many cases, most
    of these parameters will use the default values and be more than you need, but
    at least you will have the choice to remove what you will:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Excel报告提供了运行程序所使用的每个参数的详细信息，这是您最全面的信息来源。在许多情况下，这些参数的大部分将使用默认值，并且可能比您需要的更多，但至少您将有机会移除不需要的部分：
- en: '![](img/5c10d791-352d-4762-b01a-5a1cb00b301f.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5c10d791-352d-4762-b01a-5a1cb00b301f.png)'
- en: 'We''ll describe some of these parameters in our next section when we review
    the source code for creating what you see before:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，当我们回顾创建您所看到内容的源代码时，我们将描述一些这些参数：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Let's dissect this code a bit more.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更深入地分析这段代码。
- en: 'To begin with, we''ll create a manual configuration object that will hold our
    configuration parameters used for benchmarking:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个手动配置对象，用于保存我们用于基准测试的配置参数：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, we''ll set up an exporter to hold the parameters we will use for exporting
    our results. We will export our results to a `.csv` file using a timing of microseconds
    and size in kilobytes:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将设置一个导出器来保存我们将用于导出结果的参数。我们将使用微秒作为时间单位和千字节作为大小来将结果导出到`.csv`文件：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, we''ll create a benchmark job that will handle the measurements of the
    `LegacyJitX64` on the x64 architecture. You can feel free to change this and any
    other parameter to experiment with or include whatever results you need or want
    for your test scenario. In our case, we will be using the x64 platform; a `LaunchCount`,
    `WarmupCount`, and `TargetCount` of `1`; and `RunStrategy` of `Throughput`. We
    will also do the same for RyuJIT but we won''t show the code here:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个基准作业，用于处理`LegacyJitX64`在x64架构上的测量。您可以随意更改此参数或其他任何参数以进行实验，或包括您测试场景中需要或想要的任何结果。在我们的案例中，我们将使用x64平台；`LaunchCount`、`WarmupCount`和`TargetCount`均为`1`；以及`RunStrategy`为`Throughput`。我们也将对RyuJIT做同样的处理，但在此不展示代码：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Finally, we will run `BenchmarkRunner` to perform our tests:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将运行`BenchmarkRunner`以执行我们的测试：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`BenchmarkDotNet` will run as a DOS command-line application, and the following
    is an example of the preceding code executing:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`BenchmarkDotNet`将以DOS命令行应用程序的形式运行，以下是一个执行先前代码的示例：'
- en: '![](img/28a6f0cd-5d8e-4b78-8b07-7dc8ce300724.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/28a6f0cd-5d8e-4b78-8b07-7dc8ce300724.png)'
- en: 'Let''s take a look at one example of an activation function being plotted:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个激活函数绘制的例子：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You will notice the `[Benchmark]` attribute being used. This indicates to `BenchmarkDotNet`
    that this will be a test that needs to be benchmarked. Internally, it calls the
    following function:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到使用了`[Benchmark]`属性。这表示对于`BenchmarkDotNet`来说，这将是一个需要基准测试的测试。内部，它调用以下函数：
- en: '![](img/1adf0073-45d7-40cc-b866-71f13c747239.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1adf0073-45d7-40cc-b866-71f13c747239.png)'
- en: 'For the `LogisticFunctionSteep` function, the implementation, like most activation
    functions, is simple (assuming you know the formula). In this case we are not
    plotting the activation function but rather benchmarking it. You will notice that
    the function takes and returns `double`. We have also benchmarked the identical
    function by using and returning `float` variables, so we are benchmarking the
    difference between the function using `double` and `float`. Hence, people can
    see that sometimes the performance impact is more than they may think:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`LogisticFunctionSteep`函数，其实现方式，就像大多数激活函数一样，很简单（假设你知道公式）。在这种情况下，我们不是在绘制激活函数，而是在对其进行基准测试。你会注意到该函数接收并返回`double`类型。我们还通过使用和返回`float`变量对相同的函数进行了基准测试，因此我们正在基准测试使用`double`和`float`之间的差异。因此，人们可以看到，有时性能影响可能比他们想象的要大：
- en: '![](img/c3dca76d-77f9-493f-b81c-2306673f2fd8.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c3dca76d-77f9-493f-b81c-2306673f2fd8.png)'
- en: Summary
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter we learned about applying microbenchmarking to your code. We
    also saw how to plot and benchmark activation functions as well as use microbenchmarking
    with that as well. You now have one of the most powerful benchmarking libraries
    which you can add to all your code. In the next chapter, we are going to dive
    into Intuitive Deep Learning and show you one of the most powerful frameworks
    for machine learning testing available to a C# developer.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何将微基准测试应用于你的代码。我们还看到了如何绘制和基准测试激活函数，以及如何使用微基准测试进行这些操作。你现在拥有了一个非常强大的基准测试库，你可以将其添加到所有代码中。在下一章中，我们将深入探讨直观深度学习，并展示一个针对C#开发者可用的最强大的机器学习测试框架之一。
