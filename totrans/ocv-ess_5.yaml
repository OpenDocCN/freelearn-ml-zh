- en: Chapter 5. Focusing on the Interesting 2D Features
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章. 关注有趣的2D特征
- en: In most images, the most useful information is around certain zones that typically
    correspond to salient points and regions. In most applications, local processing
    around these salient points is sufficient as long as these points are stable and
    distinctive. In this chapter, we will cover a basic introduction to the 2D salient
    points and features offered by OpenCV. It is important to note the difference
    between detectors and descriptors. **Detectors** only extract interest points
    (local features) on an image, while descriptors obtain relevant information about
    the neighborhood of these points. **Descriptors**, as their name suggests, describe
    the image by proper features. They describe an interest point in a way that is
    invariant to change in lighting and to small perspective deformations. This can
    be used to match them with other descriptors (typically extracted from other images).
    For this purpose, matchers are used. This, in turn, can be used to detect objects
    and infer the camera transformation between two images. First, we show the internal
    structure of the interest points and provide an explanation of the 2D features
    and descriptor extraction. Finally, the chapter deals with matching, that is,
    putting 2D features of different images into correspondence.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数图像中，最有用的信息通常位于某些区域，这些区域通常对应于显著点和区域。在大多数应用中，只要这些点稳定且独特，对这些显著点周围的局部处理就足够了。在本章中，我们将介绍OpenCV提供的2D显著点和特征的基本概念。需要注意的是，检测器和描述符之间的区别。**检测器**仅从图像中提取兴趣点（局部特征），而描述符则获取这些点的邻域的相关信息。**描述符**，正如其名称所示，通过适当的特征来描述图像。它们以一种对光照变化和小型透视变形不变的方式描述兴趣点。这可以用来将它们与其他描述符（通常从其他图像中提取）匹配。为此，使用匹配器。这反过来可以用来检测对象并推断两张图像之间的相机变换。首先，我们展示兴趣点的内部结构，并解释2D特征和描述符提取。最后，本章处理匹配问题，即把不同图像的2D特征对应起来。
- en: Interest points
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 兴趣点
- en: 'Local features, also called interest points, are characterized by sudden changes
    of intensity in the region. These local features are usually classified in edges,
    corners, and blobs. OpenCV encapsulates interesting point information in the `KeyPoint`
    class, which contains the following data:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 局部特征，也称为兴趣点，其特点是区域强度突然变化。这些局部特征通常分为边缘、角点和块。OpenCV在`KeyPoint`类中封装了有趣点信息，该类包含以下数据：
- en: The coordinates of the interest point (the `Point2f` type)
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 兴趣点的坐标（`Point2f`类型）
- en: Diameter of the meaningful keypoint neighborhood
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有意义的关键点邻域的直径
- en: Orientation of the keypoint
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关键点的方向
- en: Strength of the keypoint, which depends on the keypoint detector that is selected
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关键点的强度，这取决于所选的关键点检测器
- en: Pyramid layer (octave) from which the keypoint has been extracted; octaves are
    used in some descriptors such as `SIFT`, `SURF`, `FREAK`, or `BRISK`
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提取关键点的金字塔层（八度）；八度在`SIFT`、`SURF`、`FREAK`或`BRISK`等一些描述符中使用
- en: Object ID used to perform clustering
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于执行聚类的对象ID
- en: Feature detectors
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特征检测器
- en: 'OpenCV handles several local feature detector implementations through the `FeatureDetector`
    abstract class and its `Ptr<FeatureDetector> FeatureDetector::create(const string&
    detectorType)` method or through the algorithm class directly. In the first case,
    the type of detector is specified (see the following diagram where the detectors
    used in this chapter are indicated in red color). Detectors and the types of local
    features that they detect are as follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV通过`FeatureDetector`抽象类及其`Ptr<FeatureDetector> FeatureDetector::create(const
    string& detectorType)`方法或直接通过算法类处理多个局部特征检测器的实现。在第一种情况下，指定了检测器的类型（以下图中用红色标出了本章中使用的检测器）。检测器和它们检测的局部特征类型如下：
- en: '`FAST` (`FastFeatureDetector`): This feature detects corners and blobs'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FAST` (`FastFeatureDetector`): 这种特征检测器用于检测角点和块'
- en: '`STAR` (`StarFeatureDetector`): This feature detects edges, corners, and blobs'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`STAR` (`StarFeatureDetector`): 这种特征检测器用于检测边缘、角点和块'
- en: '`SIFT` (`SiftFeatureDetector`): This feature detects corners and blobs (part
    of the `nonfree` module)'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SIFT` (`SiftFeatureDetector`): 这种特征检测器用于检测角点和块（`nonfree`模块的一部分）'
- en: '`SURF` (`SurfFeatureDetector`): This feature detects corners and blobs (part
    of the `nonfree` module)'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SURF` (`SurfFeatureDetector`): 这种特征检测器用于检测角点和块（`nonfree`模块的一部分）'
- en: '`ORB` (`OrbFeatureDetector`): This feature detects corners and blobs'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ORB` (`OrbFeatureDetector`): 这种特征检测器用于检测角点和块'
- en: '`BRISK` (`BRISK`): This feature detects corners and blobs'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BRISK` (`BRISK`): 这个特征检测器能够检测角点和块状物'
- en: '`MSER` (`MserFeatureDetector`): This feature detects blobs'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MSER` (`MserFeatureDetector`): 这个特征检测器能够检测块状物'
- en: '`GFTT` (`GoodFeaturesToTrackDetector`): This feature detects edges and corners'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GFTT` (`GoodFeaturesToTrackDetector`): 这个特征检测器能够检测边缘和角点'
- en: '`HARRIS` (`GoodFeaturesToTrackDetector`): This feature detects edges and corners
    (with the Harris detector enabled)'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HARRIS` (`GoodFeaturesToTrackDetector`): 这个特征检测器能够检测边缘和角点（启用 Harris 检测器）'
- en: '`Dense` (`DenseFeatureDetector`): This feature detects the features that are
    distributed densely and regularly on the image'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Dense` (`DenseFeatureDetector`): 这个特征检测器能够检测图像上分布密集且规则的特性'
- en: '`SimpleBlob` (`SimpleBlobDetector`): This feature detects blobs'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SimpleBlob` (`SimpleBlobDetector`): 这个特征检测器能够检测块状物'
- en: '![Feature detectors](img/00028.jpeg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![Feature detectors](img/00028.jpeg)'
- en: 2D feature detectors in OpenCV
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV 中的 2D 特征检测器
- en: We should note that some of these detectors, such as `SIFT`, `SURF`, `ORB`,
    and `BRISK`, are also descriptors.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该注意，其中一些检测器，如 `SIFT`、`SURF`、`ORB` 和 `BRISK`，也是描述符。
- en: Keypoint detection is performed by the `void FeatureDetector::detect(const Mat&
    image, vector<KeyPoint>& keypoints, const Mat& mask)` function, which is another
    method of the `FeatureDetector` class. The first parameter is the input image
    where the keypoints will be detected. The second parameter corresponds to the
    vector where the keypoints will be stored. The last parameter is optional and
    represents an input mask image in which we can specify where to look for keypoints.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `void FeatureDetector::detect(const Mat& image, vector<KeyPoint>& keypoints,
    const Mat& mask)` 函数执行关键点检测，这是 `FeatureDetector` 类的另一种方法。第一个参数是输入图像，其中将检测关键点。第二个参数对应于存储关键点的向量。最后一个参数是可选的，它代表一个输入掩码图像，我们可以指定在其中查找关键点。
- en: Note
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Matthieu Labbé has implemented a Qt-based open source application where you
    can test OpenCV's corner detectors, feature extractors, and matching algorithms
    in a nice GUI. It is available at [https://code.google.com/p/find-object/](https://code.google.com/p/find-object/).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Matthieu Labbé 实现了一个基于 Qt 的开源应用程序，你可以在这个应用程序中测试 OpenCV 的角点检测器、特征提取器和匹配算法，界面友好。它可在
    [https://code.google.com/p/find-object/](https://code.google.com/p/find-object/)
    查找。
- en: The first interest points were historically corners. In 1977, Moravec defined
    corners as interest points where there is a large intensity variation in several
    directions (45 degrees). These interest points were used by Moravec to find matching
    regions in consecutive image frames. Later, in 1988, Harris improved Moravec's
    algorithm using the Taylor expansion to approximate the shifted intensity variation.
    Afterwards, other detectors appeared, such as the detector based on **difference
    of Gaussians** (**DoG**) and **determinant of the Hessian** (**DoH**) (for example,
    `SIFT` or `SURF`, respectively) or the detector based on Moravec's algorithm,
    but considering continuous intensity values in a pixel neighborhood such as `FAST`
    or `BRISK` (scale-space FAST).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 历史上，第一个兴趣点是角点。1977 年，Moravec 将角点定义为在多个方向（45 度）上存在较大强度变化的兴趣点。Moravec 使用这些兴趣点在连续图像帧中找到匹配区域。后来，在
    1988 年，Harris 使用泰勒展开来近似平移强度变化，从而改进了 Moravec 的算法。之后，出现了其他检测器，如基于高斯差分（**DoG**）和
    Hessian 矩阵行列式（**DoH**）（例如，`SIFT` 或 `SURF` 分别）的检测器，或者基于 Moravec 算法的检测器，但考虑像素邻域中的连续强度值，如
    `FAST` 或 `BRISK`（尺度空间 FAST）。
- en: Note
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Lu, in her personal blog, *LittleCheeseCake*, explains some of the most popular
    detectors and descriptors in detail. The blog is available at [http://littlecheesecake.me/blog/13804625/feature-detectors-and-descriptors](http://littlecheesecake.me/blog/13804625/feature-detectors-and-descriptors).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 卢在她的个人博客 *LittleCheeseCake* 中详细解释了一些最受欢迎的检测器和描述符。博客可在 [http://littlecheesecake.me/blog/13804625/feature-detectors-and-descriptors](http://littlecheesecake.me/blog/13804625/feature-detectors-and-descriptors)
    查阅。
- en: The FAST detector
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: The FAST detector
- en: The corner detector is based on the **Features from Accelerated Segment Test**
    (**FAST**) algorithm. It was designed to be very efficient, targeting real-time
    applications. The method is based on considering a circle of 16 pixels (neighborhood)
    around a candidate corner p. The FAST detector will consider p as a corner if
    there is a set of contiguous pixels in the neighborhood that all are brighter
    than p+T or darker than p-T, T being a threshold value. This threshold must be
    properly selected.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 角点检测器基于**加速段测试（FAST**）算法。它被设计得非常高效，针对实时应用。该方法基于考虑候选角点p周围的16像素（邻域）圆。如果邻域中存在一组连续像素，这些像素都比p+T亮或比p-T暗，则FAST检测器将考虑p为角点，其中T是一个阈值值。这个阈值必须适当选择。
- en: OpenCV implements the FAST detector in the `FastFeatureDetector()` class, which
    is a wrapper class for the `FAST()` method. To use this class, we must include
    the `features2d.hpp` header file in our code.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV 在 `FastFeatureDetector()` 类中实现了FAST检测器，这是一个 `FAST()` 方法的包装类。要使用此类，我们必须在我们的代码中包含
    `features2d.hpp` 头文件。
- en: 'Next, we show a code example where the corners are detected using the `FAST`
    method with different threshold values. The `FASTDetector` code example is shown
    as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们展示一个代码示例，其中使用不同阈值的 `FAST` 方法检测角点。以下展示了 `FASTDetector` 代码示例：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The explanation of the code is given as follows. In this and the following
    examples, we usually perform the following three steps:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的解释如下。在本例及以下示例中，我们通常执行以下三个步骤：
- en: Create the 2D feature detector.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建2D特征检测器。
- en: Detect keypoints in the image.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在图像中检测关键点。
- en: Draw the keypoints obtained.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制获得的关键点。
- en: In our sample, `FastFeatureDetector(int threshold=1, bool nonmaxSuppression=
    true, type=FastFeatureDetector::TYPE_9_16)` is the function where the detector
    parameters, such as threshold value, non-maximum suppression, and neighborhoods,
    are defined.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，`FastFeatureDetector(int threshold=1, bool nonmaxSuppression= true,
    type=FastFeatureDetector::TYPE_9_16)` 是定义检测器参数（如阈值值、非最大值抑制和邻域）的函数。
- en: 'The following three types of neighborhoods can be selected:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 可以选择以下三种类型的邻域：
- en: '`FastFeatureDetector::TYPE_9_16`'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FastFeatureDetector::TYPE_9_16`'
- en: '`FastFeatureDetector::TYPE_7_12`'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FastFeatureDetector::TYPE_7_12`'
- en: '`FastFeatureDetector::TYPE_5_8`'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FastFeatureDetector::TYPE_5_8`'
- en: These neighborhoods define the number of neighbors (16, 12, or 8) and the total
    number of contiguous pixels (9, 7, or 5) needed to consider the corner (keypoint)
    valid. An example of `TYPE_9_16` is shown in the next screenshot.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这些邻域定义了考虑角点（关键点）有效所需的邻居数量（16、12或8）和连续像素的总数（9、7或5）。以下截图展示了 `TYPE_9_16` 的示例。
- en: 'In our code, the threshold values `80` and `100` have been selected, while
    the rest of the parameters have their default values, `nonmaxSuppression=true`
    and `type=FastFeatureDetector::TYPE_9_16`, as shown:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码中，已选择阈值值 `80` 和 `100`，而其余参数使用默认值，`nonmaxSuppression=true` 和 `type=FastFeatureDetector::TYPE_9_16`，如下所示：
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Keypoints are detected and saved using the `void detect(const Mat& image, vector<KeyPoint>&
    keypoints, const Mat& mask=Mat())` function. In our case, we create the following
    two FAST feature detectors:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `void detect(const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat())`
    函数检测并保存关键点。在我们的情况下，我们创建了以下两个FAST特征检测器：
- en: '`detector1` saves its keypoints in the `keypoints1` vector'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`detector1` 将其关键点保存到 `keypoints1` 向量中'
- en: '`detector2` saves its keypoints in the `keypoints2`'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`detector2` 将其关键点保存到 `keypoints2`'
- en: 'The `void drawKeypoints(const Mat& image, const vector<KeyPoint>& keypoints,
    Mat& outImage, const Scalar& color=Scalar::all(-1), int flags=DrawMatchesFlags::DEFAULT)`
    function draws the keypoints in the image. The `color` parameter allows us to
    define a color of keypoints, and with the `Scalar:: all(-1)` option, each keypoint
    will be drawn with a different color.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`void drawKeypoints(const Mat& image, const vector<KeyPoint>& keypoints, Mat&
    outImage, const Scalar& color=Scalar::all(-1), int flags=DrawMatchesFlags::DEFAULT)`
    函数用于在图像中绘制关键点。`color` 参数允许我们定义关键点的颜色，使用 `Scalar:: all(-1)` 选项，每个关键点将以不同的颜色绘制。'
- en: 'The keypoints are drawn using the two threshold values on the image. We will
    notice a small difference in the number of keypoints detected. This is due to
    the threshold value in each case. The following screenshot shows a corner detected
    in the sample with a threshold value of 80, which is not detected with a threshold
    value of 100:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 使用图像上的两个阈值值绘制关键点。我们会注意到检测到的关键点数量存在细微差异。这是由于每个情况下的阈值值不同。以下截图显示了在阈值为80的样本中检测到的角点，而在阈值为100时则未检测到：
- en: '![The FAST detector](img/00029.jpeg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![The FAST detector](img/00029.jpeg)'
- en: Keypoint detected with a threshold value of 80 (in the left-hand side). The
    same corner is not detected with a threshold value of 100 (in the right-hand side).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 使用阈值为 80（在左侧）检测到的关键点。相同的角点在阈值为 100（在右侧）时没有被检测到。
- en: 'The difference is due to the fact that the FAST feature detectors are created
    with the default type, that is, `TYPE_9_16`. In the example, the p pixel takes
    a value of 228, so at least nine contiguous pixels must be brighter than p+T or
    darker than p-T. The following screenshot shows the neighborhood pixel values
    in this specific keypoint. The condition of nine contiguous pixels is met if we
    use a threshold value of 80\. However, the condition is not met with a threshold
    value of 100:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 差异是由于 FAST 特征检测器是以默认类型创建的，即 `TYPE_9_16`。在示例中，p 像素取值为 228，因此至少需要九个连续像素比 p+T 更亮或比
    p-T 更暗。以下截图显示了此特定关键点的邻域像素值。如果使用阈值为 80，则满足九个连续像素的条件。然而，使用阈值为 100 时，条件不满足：
- en: '![The FAST detector](img/00030.jpeg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![FAST 检测器](img/00030.jpeg)'
- en: Keypoint pixel values and contiguous pixels all darker than p-T (228-80=148)
    with a threshold value of 80
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 关键点像素值和所有连续像素都比 p-T (228-80=148) 深的像素值，阈值为 80
- en: The SURF detector
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SURF 检测器
- en: The **Speeded Up Robust Features** (**SURF**) detector is based on a Hessian
    matrix to find the interest points. For this purpose, SURF divides the image in
    different scales (levels and octaves) using second-order Gaussian kernels and
    approximates these kernels with a simple box filter. This filter box is mostly
    interpolated in scale and space in order to provide the detector with the scale-invariance
    properties. SURF is a faster approximation of the classic **Scale Invariant Feature
    Transform** (**SIFT**) detector. Both the SURF and SIFT detectors are patented,
    so OpenCV includes them separately in their `nonfree/nonfree.hpp` header file.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**加速鲁棒特征**（**SURF**）检测器基于 Hessian 矩阵来寻找兴趣点。为此，SURF 使用二阶高斯核将图像划分为不同的尺度（级别和八度），并使用简单的盒式滤波器来近似这些核。这个滤波器盒在尺度和空间上主要进行插值，以便为检测器提供尺度不变性属性。SURF
    是经典 **尺度不变特征变换**（**SIFT**）检测器的快速近似。SURF 和 SIFT 检测器都是受专利保护的，因此 OpenCV 在其 `nonfree/nonfree.hpp`
    头文件中分别包含它们。'
- en: 'The following `SURFDetector` code shows an example where the keypoints are
    detected using the SURF detector with a different number of Gaussian pyramid octaves:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的 `SURFDetector` 代码示例展示了使用不同数量的高斯金字塔八度来检测关键点的例子：
- en: '[PRE2]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In the preceding example (and subsequent ones), some portions of code are not
    repeated for simplicity because they are the same as in previous examples.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例（以及随后的示例）中，为了简单起见，没有重复某些代码部分，因为它们与前面的示例相同。
- en: The explanation of the code is given as follows. `SURFFeatureDetector(double
    hessianThreshold, int nOctaves, int nOctaveLayers, bool extended, bool upright)`
    is the main function used to create a SURF detector where we can define the parameter
    values of the detector, such as the Hessian threshold, the number of Gaussian
    pyramid octaves, number of images within each octave of a Gaussian pyramid, number
    of elements in the descriptor, and the orientation of each feature.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的解释如下。`SURFFeatureDetector(double hessianThreshold, int nOctaves, int nOctaveLayers,
    bool extended, bool upright)` 是创建 SURF 检测器的主要函数，其中我们可以定义检测器的参数值，例如 Hessian 阈值、高斯金字塔八度的数量、高斯金字塔中每个八度的图像数量、描述符中的元素数量以及每个特征的朝向。
- en: 'A high threshold value extracts less keypoints but with more accuracy. A low
    threshold value extracts more keypoints but with less accuracy. In this case,
    we have used a large Hessian threshold (`3500`) to show a reduced number of keypoints
    in the image. Also, the number of octaves changes for each image (2 and 5, respectively).
    A larger number of octaves also select keypoints with a larger size. The following
    screenshot shows the result:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 高阈值值提取的关键点较少，但精度更高。低阈值值提取的关键点较多，但精度较低。在这种情况下，我们使用了一个较大的 Hessian 阈值（`3500`），以在图像中显示较少的关键点。此外，每个图像的八度数也会变化（分别为
    2 和 5）。更多的八度也会选择更大尺寸的关键点。以下截图显示了结果：
- en: '![The SURF detector](img/00031.jpeg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![SURF 检测器](img/00031.jpeg)'
- en: The SURF detector with two Gaussian pyramid octaves (in the left-hand side)
    and the SURF detector with five Gaussian pyramid octaves (in the right-hand side)
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧为具有两个高斯金字塔八度的 SURF 检测器，右侧为具有五个高斯金字塔八度的 SURF 检测器
- en: Again, we use the `drawKeypoints` function to draw the keypoints detected, but
    in this case, as the SURF detector has orientation properties, the `DrawMatchesFlags`
    parameter is defined as `DRAW_RICH_KEYPOINTS`. Then, the `drawKeypoints` function
    draws each keypoint with its size and orientation.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提醒，我们使用`drawKeypoints`函数来绘制检测到的关键点，但在此情况下，由于SURF检测器具有方向属性，`DrawMatchesFlags`参数被定义为`DRAW_RICH_KEYPOINTS`。然后，`drawKeypoints`函数会绘制每个关键点及其大小和方向。
- en: The ORB detector
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ORB检测器
- en: '**Binary Robust Independent Elementary Features** (**BRIEF**) is a descriptor
    based on binary strings; it does not find interest points. The **Oriented FAST
    and Rotated BRIEF** (**ORB**) detector is a union of the FAST detector and BRIEF
    descriptor and is considered an alternative to the patented SIFT and SURF detectors.
    The ORB detector uses the FAST detector with pyramids to detect interest points
    and then uses the HARRIS algorithm to rank the features and retain the best ones.
    OpenCV also allows us to use the FAST algorithm to rank the features, but normally,
    this produces less stable keypoints. The following `ORBDetector` code shows a
    simple and clear example of this difference:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**二进制鲁棒独立基本特征**（**BRIEF**）是一种基于二进制字符串的描述符；它不寻找兴趣点。**方向快速和旋转BRIEF**（**ORB**）检测器是FAST检测器和BRIEF描述符的联合，被认为是专利SIFT和SURF检测器的替代品。ORB检测器使用带有金字塔的FAST检测器来检测兴趣点，然后使用HARRIS算法来排序特征并保留最佳特征。OpenCV还允许我们使用FAST算法来排序特征，但通常这会产生更不稳定的特征点。下面的`ORBDetector`代码展示了这种差异的一个简单且清晰的例子：'
- en: '[PRE3]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '![The ORB detector](img/00032.jpeg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![ORB检测器](img/00032.jpeg)'
- en: The ORB detector with the FAST algorithm to select the 300 best features (in
    the left-hand side) and the HARRIS detector to select the 300 best features (in
    the right-hand side)
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 使用FAST算法选择300个最佳特征（在左侧）和使用HARRIS检测器选择300个最佳特征（在右侧）的ORB检测器
- en: 'The explanation of the code is given as follows. The `OrbFeatureDetector(int
    nfeatures=500, float scaleFactor=1.2f, int nlevels=8, int edgeThreshold=31, int
    firstLevel=0, int WTA_K=2, int scoreType=ORB:: HARRIS_SCORE, int patchSize=31)`
    function is the class constructor where we can specify the maximum number of features
    to retain the scale, number of levels, and type of detector (`HARRIS_SCORE` or
    `FAST_SCORE`) used to rank the features.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '以下是代码的解释。`OrbFeatureDetector(int nfeatures=500, float scaleFactor=1.2f, int
    nlevels=8, int edgeThreshold=31, int firstLevel=0, int WTA_K=2, int scoreType=ORB::
    HARRIS_SCORE, int patchSize=31)`函数是类构造函数，其中我们可以指定要保留的最大特征数、缩放比例、级别数以及用于排序特征的检测器类型（`HARRIS_SCORE`或`FAST_SCORE`）。'
- en: 'The following proposed code example shows the difference between the HARRIS
    and FAST algorithms to rank features; the result is shown in the preceding screenshot:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 以下提出的代码示例显示了HARRIS和FAST算法在排序特征方面的差异；结果如前截图所示：
- en: '[PRE4]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The HARRIS corner detector is used more than FAST to rank features, because
    it rejects edges and provides a reasonable score. The rest of the functions are
    the same as in the previous detector examples, keypoint detection and drawing.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: HARRIS角点检测器在特征排序方面比FAST检测器使用得更频繁，因为它能够拒绝边缘并提供一个合理的分数。其余的功能与之前的检测器示例相同，包括关键点检测和绘制。
- en: The KAZE and AKAZE detectors
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: KAZE和AKAZE检测器
- en: The KAZE and AKAZE detectors will be included in the upcoming OpenCV 3.0.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: KAZE和AKAZE检测器将被包含在即将发布的OpenCV 3.0版本中。
- en: Tip
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: OpenCV 3.0 is not yet available. Again, if you want to test this code and use
    the KAZE and AKAZE features, you can work with the latest version already available
    in the OpenCV git repository at [http://code.opencv.org/projects/opencv/repository](http://code.opencv.org/projects/opencv/repository).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV 3.0版本尚未可用。再次提醒，如果您想测试此代码并使用KAZE和AKAZE特征，您可以使用OpenCV git仓库中最新可用的版本，网址为[http://code.opencv.org/projects/opencv/repository](http://code.opencv.org/projects/opencv/repository)。
- en: The KAZE detector is a method that can detect 2D features in a nonlinear scale
    space. This method allows us to keep important image details and remove noise.
    **Additive Operator Splitting** (**AOS**) schemes are used for nonlinear scale
    space. AOS schemes are efficient, stable, and parallelizable. The algorithm computes
    the response of a Hessian matrix at multiple scale levels to detect keypoints.
    On the other hand, the **Accelerated-KAZE** (**AKAZE**) feature detector uses
    fast explicit diffusion to build a nonlinear scale space.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: KAZE检测器是一种可以在非线性尺度空间中检测2D特征的方法。这种方法允许我们保留重要的图像细节并去除噪声。**加性算子分裂**（**AOS**）方案用于非线性尺度空间。AOS方案是高效的、稳定的且可并行化。该算法在多个尺度级别计算Hessian矩阵的响应以检测关键点。另一方面，**加速-KAZE**（**AKAZE**）特征检测器使用快速显式扩散来构建非线性尺度空间。
- en: 'Next, in the `KAZEDetector` code, we see an example of the new KAZE and AKAZE
    feature detectors:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`KAZEDetector`代码中，我们看到KAZE和AKAZE特征检测器的新示例：
- en: '[PRE5]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `KAZE::KAZE(bool extended, bool upright)` function is the KAZE class constructor
    in which two parameters can be selected: `extended` and `upright`. The `extended`
    parameter adds the option to select between 64 or 128 descriptors, while the `upright`
    parameter allows us to select rotation or no invariant. In this case, we use both
    parameters with a `true` value.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`KAZE::KAZE(bool extended, bool upright)`函数是KAZE类的构造函数，其中可以选择两个参数：`extended`和`upright`。`extended`参数增加了选择64或128个描述符的选项，而`upright`参数允许我们选择旋转或无不变性。在这种情况下，我们使用两个参数的`true`值。'
- en: 'On the other hand, the `AKAZE::AKAZE(DESCRIPTOR_TYPE descriptor_type, int descriptor_size=0,
    int descriptor_channels=3)` function is the AKAZE class constructor. This function
    gets the descriptor type, descriptor size, and the channels as input arguments.
    For the descriptor type, the following enumeration is applied:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`AKAZE::AKAZE(DESCRIPTOR_TYPE descriptor_type, int descriptor_size=0, int
    descriptor_channels=3)`函数是AKAZE类的构造函数。此函数获取描述符类型、描述符大小和通道作为输入参数。对于描述符类型，应用以下枚举：
- en: '[PRE6]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The following screenshot shows the results obtained with this example:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了使用此示例获得的结果：
- en: '![The KAZE and AKAZE detectors](img/00033.jpeg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![KAZE和AKAZE检测器](img/00033.jpeg)'
- en: The KAZE detector (in the left-hand side) and the AKAZE detector (in the right-hand
    side)
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: KAZE检测器（在左侧）和AKAZE检测器（在右侧）
- en: Note
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Eugene Khvedchenya's *Computer Vision Talks* blog contains useful reports that
    compare different keypoints in terms of robustness and efficiency. See the posts
    at [http://computer-vision-talks.com/articles/2012-08-18-a-battle-of-three-descriptors-surf-freak-and-brisk/](http://computer-vision-talks.com/articles/2012-08-18-a-battle-of-three-descriptors-surf-freak-and-brisk/)
    and [http://computer-vision-talks.com/articles/2011-07-13-comparison-of-the-opencv-feature-detection-algorithms/](http://computer-vision-talks.com/articles/2011-07-13-comparison-of-the-opencv-feature-detection-algorithms/).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Eugene Khvedchenya的*计算机视觉讲座*博客包含有用的报告，比较了不同关键点的鲁棒性和效率。请参阅以下帖子：[http://computer-vision-talks.com/articles/2012-08-18-a-battle-of-three-descriptors-surf-freak-and-brisk/](http://computer-vision-talks.com/articles/2012-08-18-a-battle-of-three-descriptors-surf-freak-and-brisk/)
    和 [http://computer-vision-talks.com/articles/2011-07-13-comparison-of-the-opencv-feature-detection-algorithms/](http://computer-vision-talks.com/articles/2011-07-13-comparison-of-the-opencv-feature-detection-algorithms/)。
- en: Feature descriptor extractors
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特征描述符提取器
- en: Descriptors describe local image regions and are invariant to image transformations
    such as rotation, scale or translation. They provide a measure and distance function
    for a small patch around an interest point. Therefore, whenever the similarity
    between two image patches needs to be estimated, we compute their descriptors
    and measure their distance. In OpenCV, the basic Mat type is used to represent
    a collection of descriptors, where each row is a keypoint descriptor.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 描述符描述局部图像区域，对图像变换（如旋转、缩放或平移）保持不变。它们为兴趣点周围的小区域提供测量和距离函数。因此，每当需要估计两个图像区域之间的相似性时，我们计算它们的描述符并测量它们的距离。在OpenCV中，基本Mat类型用于表示描述符集合，其中每一行是一个关键点描述符。
- en: 'There are the following two possibilities to use a feature descriptor extractor:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 使用特征描述符提取器有以下两种可能性：
- en: The `DescriptorExtractor` common interface
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DescriptorExtractor`通用接口'
- en: The algorithm class directly
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 算法类直接
- en: (See the following diagram where the descriptors used in this chapter are indicated
    in red color.)
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: （请参见以下图表，其中本章使用的描述符用红色标出。）
- en: The common interface allows us to switch easily between different algorithms.
    This can be very useful when choosing an algorithm to solve a problem, as the
    results of each algorithm can be compared with no effort. On the other hand, depending
    on the algorithm, there are several parameters that can be tweaked only using
    its class.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的接口使我们能够轻松地在不同的算法之间切换。在选择算法来解决问题时，这非常有用，因为可以毫不费力地比较每种算法的结果。另一方面，根据算法的不同，有一些参数只能通过其类进行调整。
- en: '![Feature descriptor extractors](img/00034.jpeg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![特征描述符提取器](img/00034.jpeg)'
- en: 2D feature descriptors in OpenCV
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV 中的 2D 特征描述符
- en: 'The `Ptr<DescriptorExtractor> DescriptorExtractor::create(const String& descriptorExtractorType)`
    function creates a new descriptor extractor of the selected type. Descriptors
    can be grouped in two families: float and binary. Float descriptors store float
    values in a vector; this can lead to a high memory usage. On the other hand, binary
    descriptors store binary strings, thus enabling faster processing times and a
    reduced memory footprint. The current implementation supports the following types:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`Ptr<DescriptorExtractor> DescriptorExtractor::create(const String& descriptorExtractorType)`
    函数创建了一个所选类型的新的描述符提取器。描述符可以分为两类：浮点和二进制。浮点描述符在向量中存储浮点值，这可能导致高内存使用。另一方面，二进制描述符存储二进制字符串，从而实现更快的处理时间和减少内存占用。当前实现支持以下类型：'
- en: 'SIFT: This implementation supports the float descriptor'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SIFT：此实现支持浮点描述符
- en: 'SURF: This implementation supports the float descriptor'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SURF：此实现支持浮点描述符
- en: 'BRIEF: This implementation supports the binary descriptor'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BRIEF：此实现支持二进制描述符
- en: 'BRISK: This implementation supports the binary descriptor'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BRISK：此实现支持二进制描述符
- en: 'ORB: This implementation supports the binary descriptor'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ORB：此实现支持二进制描述符
- en: 'FREAK: This implementation supports the binary descriptor'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FREAK：此实现支持二进制描述符
- en: 'KAZE: This implementation supports the binary descriptor (new in OpenCV 3.0)'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: KAZE：此实现支持二进制描述符（OpenCV 3.0 新增）
- en: 'AKAZE: This implementation supports the binary descriptor (new in OpenCV 3.0)'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AKAZE：此实现支持二进制描述符（OpenCV 3.0 新增）
- en: The other important function of `DescriptorExtractor` is `void DescriptorExtractor::compute(InputArray
    image, vector<KeyPoint>& keypoints, OutputArray descriptors)`, which computes
    the descriptors for a set of keypoints detected in an image on the previous step.
    There is a variant of the function that accepts an image set.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`DescriptorExtractor` 的另一个重要功能是 `void DescriptorExtractor::compute(InputArray
    image, vector<KeyPoint>& keypoints, OutputArray descriptors)`，该功能用于计算在先前步骤中检测到的图像中关键点集的描述符。该函数有一个接受图像集的变体。'
- en: Tip
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Note that it is possible to mix feature detectors and descriptor extractors
    from different algorithms. However, it is recommended that you use both methods
    from the same algorithm, as they should fit better together.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，可以混合来自不同算法的特征检测器和描述符提取器。然而，建议您使用来自同一算法的两种方法，因为它们应该更适合一起使用。
- en: Descriptor matchers
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 描述符匹配器
- en: '`DescriptorMatcher` is an abstract base class to match keypoint descriptors
    that, as happens with `DescriptorExtractor`, make programs more flexible than
    using matchers directly. With the `Ptr<DescriptorMatcher> DescriptorMatcher::create(const
    string& descriptorMatcherType)` function, we can create a descriptor matcher of
    the desired type. The following are the supported types:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`DescriptorMatcher` 是一个抽象基类，用于匹配关键点描述符，正如 `DescriptorExtractor` 所发生的那样，这使得程序比直接使用匹配器更加灵活。使用
    `Ptr<DescriptorMatcher> DescriptorMatcher::create(const string& descriptorMatcherType)`
    函数，我们可以创建所需类型的描述符匹配器。以下支持的类型有：'
- en: '**BruteForce-L1**: This is used for float descriptors. It uses L1 distance
    and is efficient and fast.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**BruteForce-L1**：这是用于浮点描述符的。它使用 L1 距离，既高效又快速。'
- en: '**BruteForce**: This is used for float descriptors. It uses L2 distance and
    can be better than L1, but it needs more CPU usage.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**BruteForce**：这是用于浮点描述符的。它使用 L2 距离，可能比 L1 更好，但需要更多的 CPU 使用量。'
- en: '**BruteForce-SL2**: This is used for float descriptors and avoids square root
    computation from L2, which requires high CPU usage.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**BruteForce-SL2**：这是用于浮点描述符的，并避免了从 L2 计算平方根，这需要高 CPU 使用量。'
- en: '**BruteForce-Hamming**: This is used for binary descriptors and calculates
    the Hamming distance between the compared descriptors.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**BruteForce-Hamming**：这是用于二进制描述符的，并计算比较描述符之间的汉明距离。'
- en: '**BruteForce-Hamming(2)**: This is used for binary descriptors (2 bits version).'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**BruteForce-Hamming(2)**：这是用于二进制描述符（2 位版本）。'
- en: '**FlannBased**: This is used for float descriptors and is faster than brute
    force by pre-computing acceleration structures (as in DB engines) at the cost
    of using more memory.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**FlannBased**：这用于浮点描述符，并且比暴力搜索更快，因为它通过预先计算加速结构（如数据库引擎）来减少内存使用。'
- en: The `void DescriptorMatcher::match(InputArray queryDescriptors, InputArray trainDescriptors,
    vector<DMatch>& matches, InputArray mask=noArray())` and `void DescriptorMatcher::knnMatch(InputArray
    queryDescriptors, InputArray trainDescriptors, vector<vector<DMatch>>& matches,
    int k, InputArray mask=noArray(), bool compactResult=false)` functions give the
    best k matches for each descriptor, k being 1 for the first function.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`void DescriptorMatcher::match(InputArray queryDescriptors, InputArray trainDescriptors,
    vector<DMatch>& matches, InputArray mask=noArray())` 和 `void DescriptorMatcher::knnMatch(InputArray
    queryDescriptors, InputArray trainDescriptors, vector<vector<DMatch>>& matches,
    int k, InputArray mask=noArray(), bool compactResult=false)` 函数为每个描述符提供最佳k个匹配，对于第一个函数，k为1。'
- en: The `void DescriptorMatcher::radiusMatch(InputArray queryDescriptors, InputArray
    trainDescriptors, vector<vector<DMatch>>& matches, float maxDistance, InputArray
    mask=noArray(), bool compactResult=false)` function also finds the matches for
    each query descriptor but not farther than the specified distance. The major drawback
    of this method is that the magnitude of this distance is not normalized, and it
    depends on the feature extractor and descriptor used.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`void DescriptorMatcher::radiusMatch(InputArray queryDescriptors, InputArray
    trainDescriptors, vector<vector<DMatch>>& matches, float maxDistance, InputArray
    mask=noArray(), bool compactResult=false)` 函数也找到每个查询描述符的匹配，但不超过指定的距离。这种方法的主要缺点是此距离的幅度未归一化，并且取决于特征提取器和描述符。'
- en: Tip
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: In order to get the best results, we recommend that you use matchers along with
    descriptors of the same type. Although it is possible to mix binary descriptors
    with float matchers and the other way around, the results might be inaccurate.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得最佳结果，我们建议您使用与描述符类型相同的匹配器。尽管可以将二进制描述符与浮点匹配器混合，反之亦然，但结果可能不准确。
- en: Matching the SURF descriptors
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 匹配SURF描述符
- en: 'SURF descriptors belong to the family of oriented gradients descriptors. They
    encode statistical knowledge about the geometrical shapes present in the patch
    (via histograms of oriented gradients/Haar-like features). They are considered
    as a more efficient substitution for SIFT. They are the best known multiscale
    feature description approaches, and their accuracy has been widely tested. They
    have two main drawbacks though:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: SURF描述符属于方向梯度描述符家族。它们通过方向梯度直方图/Haar-like特征编码关于补丁中存在的几何形状的统计知识。它们被认为是SIFT的更有效替代品。它们是最知名的多尺度特征描述方法，其准确性已经得到广泛测试。尽管如此，它们有两个主要缺点：
- en: They are patented
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是受专利保护的
- en: They are slower than binary descriptors
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们比二进制描述符慢
- en: 'There is a common pipeline in every descriptor matching application that uses
    the components explained earlier in this chapter. It performs the following steps:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 每个描述符匹配应用程序都有一个通用管道，它使用本章前面解释的组件。它执行以下步骤：
- en: Compute interest points in both images.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在两幅图像中计算兴趣点。
- en: Extract descriptors from the two generated interest point sets.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从两个生成的兴趣点集中提取描述符。
- en: Use a matcher to find connections between descriptors.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用匹配器来查找描述符之间的关联。
- en: Filter the results to remove bad matches.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 过滤结果以移除不良匹配。
- en: 'The following is the `matchingSURF` example that follows this pipeline:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是根据此管道的`matchingSURF`示例：
- en: '[PRE7]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The explanation of the code is given as follows. As we described earlier, following
    the application pipeline implies performing these steps:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对代码的解释。正如我们之前所描述的，遵循应用程序管道意味着执行以下步骤：
- en: The first step to be performed is to detect interest points in the input images.
    In this example, the common interface is used to create a SURF detector with the
    line `Ptr<FeatureDetector> detector = FeatureDetector::create("SURF")`.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首步是在输入图像中检测兴趣点。在这个例子中，使用通用接口通过以下行创建了一个SURF检测器：`Ptr<FeatureDetector> detector
    = FeatureDetector::create("SURF")`。
- en: After that, the interest points are detected, and a descriptor extractor is
    created using the common interface `Ptr<DescriptorExtractor> extractor = DescriptorExtractor::create(
    "SURF")`. The SURF algorithm is also used to compute the descriptors.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，检测兴趣点，并使用通用接口创建描述符提取器：`Ptr<DescriptorExtractor> extractor = DescriptorExtractor::create(
    "SURF")`。SURF算法也用于计算描述符。
- en: 'The next step is to match the descriptors of both images, and for this purpose,
    a descriptor matcher is created using the common interface, too. The line, `Ptr<DescriptorMatcher>
    matcher = DescriptorMatcher::create("FlannBased")`, creates a new matcher based
    on the Flann algorithm, which is used to match the descriptors in the following
    way:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是匹配两张图像的描述符，为此，也使用通用接口创建了一个描述符匹配器。以下行，`Ptr<DescriptorMatcher> matcher = DescriptorMatcher::create("FlannBased")`，创建了一个基于
    Flann 算法的新匹配器，该算法用于以下方式匹配描述符：
- en: '[PRE8]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Finally, the results are filtered. Note that two matching sets are computed,
    as a cross-checking filter is performed afterwards. This filtering only stores
    the matches that appear in both sets when using the input images as query and
    train images. In the following screenshot, we can see the difference when a filter
    is used to discard matches:![Matching the SURF descriptors](img/00035.jpeg)
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，结果被过滤。请注意，计算了两个匹配集，因为之后执行了交叉检查过滤器。这种过滤只存储当使用输入图像作为查询图像和训练图像时出现在两个集合中的匹配：![使用过滤器丢弃匹配的
    SURF 描述符](img/00035.jpeg)
- en: Results after matching SURF descriptors with and without a filter
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用和未使用过滤器匹配 SURF 描述符的结果
- en: Matching the AKAZE descriptors
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 匹配 AKAZE 描述符
- en: KAZE and AKAZE are novel descriptors included in the upcoming OpenCV 3.0\. According
    to published tests, both outperform the previous detectors included in the library
    by improving repeatability and distinctiveness for common 2D image-matching applications.
    AKAZE is much faster than KAZE while obtaining comparable results, so if speed
    is critical in an application, AKAZE should be used.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: KAZE 和 AKAZE 是即将包含在 OpenCV 3.0 中的新描述符。根据发布的测试，两者在提高重复性和独特性方面都优于库中包含的先前检测器，适用于常见的二维图像匹配应用。AKAZE
    比 KAZE 快得多，同时获得相似的结果，因此如果速度在应用中至关重要，应使用 AKAZE。
- en: 'The following `matchingAKAZE` example matches descriptors of this novel algorithm:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 `matchingAKAZE` 示例匹配了这种新算法的描述符：
- en: '[PRE9]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The explanation of the code is given as follows. The first two steps are quite
    similar to the previous example; the feature detector and descriptor extractor
    are created through their common interfaces. We only change the string parameter
    passed to the constructor, as this time, the AKAZE algorithm is used.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的解释如下。前两步与前面的例子非常相似；特征检测器和描述符提取器是通过它们的通用接口创建的。我们只更改传递给构造函数的字符串参数，因为这次使用的是
    AKAZE 算法。
- en: Note
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A BruteForce matcher that uses Hamming distance is used this time, as AKAZE
    is a binary descriptor.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这次使用了一个使用汉明距离的 BruteForce 匹配器，因为 AKAZE 是一个二进制描述符。
- en: It is created by executing `Ptr<DescriptorMatcher> matcher = DescriptorMatcher::create("BruteForce-Hamming")`.
    The `matcher.knnMatch(descriptors1, descriptors2, matches, 2)` function computes
    the matches between the image descriptors. It is noteworthy to mention the last
    integer parameter, as it is necessary for the filter processing executed afterwards.
    This filtering is called Ratio Test, and it computes the goodness of the best
    match between the goodness of the second best match. To be considered as a good
    match, this value must be higher than a certain ratio, which can be set in a range
    of values between 0 and 1\. If the ratio tends to be 0, the correspondence between
    descriptors is stronger.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 它是通过执行 `Ptr<DescriptorMatcher> matcher = DescriptorMatcher::create("BruteForce-Hamming")`
    创建的。`matcher.knnMatch(descriptors1, descriptors2, matches, 2)` 函数计算图像描述符之间的匹配。值得注意的是最后一个整数参数，因为它对于之后执行的过滤器处理是必要的。这种过滤称为比率测试，它计算最佳匹配与次佳匹配之间的良好程度。要被认为是良好的匹配，此值必须高于一定比率，该比率可以在0到1之间的值范围内设置。如果比率接近0，描述符之间的对应关系更强。
- en: 'In the following screenshot, we can see the output when matching a book cover
    in an image where the book appears rotated:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下屏幕截图中，我们可以看到当图像中的书出现旋转时匹配书封面的输出：
- en: '![Matching the AKAZE descriptors](img/00036.jpeg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![匹配 AKAZE 描述符](img/00036.jpeg)'
- en: Matching AKAZE descriptors in a rotated image
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在旋转图像中匹配 AKAZE 描述符
- en: 'The following screenshot shows the result when the book does not appear in
    the second image:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了当第二张图像中没有书出现时的结果：
- en: '![Matching the AKAZE descriptors](img/00037.jpeg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![匹配 AKAZE 描述符](img/00037.jpeg)'
- en: Matching AKAZE descriptors when the train image does not appear
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当训练图像不出现时匹配 AKAZE 描述符
- en: Summary
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have covered a widely used OpenCV component. Local features
    are a key part of relevant computer vision algorithms such as object recognition,
    object tracking, image stitching, and camera calibration. An introduction and
    several samples have been provided, thus covering interest points detection using
    different algorithms, extraction of descriptors from interest points, matching
    descriptors, and filtering the results.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了一个广泛使用的OpenCV组件。局部特征是相关计算机视觉算法（如物体识别、物体跟踪、图像拼接和相机标定）的关键部分。我们提供了一些介绍和示例，从而涵盖了使用不同算法进行兴趣点检测、从兴趣点提取描述符、匹配描述符以及过滤结果。
- en: What else?
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有什么？
- en: The powerful Bag-of-Words object categorization framework has not been included.
    This is actually an additional step to what we have covered in this chapter, as
    extracted descriptors are clustered and used to perform categorization. A complete
    sample can be found at `[opencv_source_code]/samples/cpp/bagofwords_classification.cpp`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 强大的词袋模型物体分类框架尚未包括在内。这实际上是我们在本章中介绍内容的一个附加步骤，因为提取的描述符被聚类并用于执行分类。一个完整的示例可以在 `[opencv_source_code]/samples/cpp/bagofwords_classification.cpp`
    找到。
