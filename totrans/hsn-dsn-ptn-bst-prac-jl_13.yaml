- en: Anti-Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Over the last five chapters, we have looked in great detail at reusability,
    performance, maintainability, safety, and some miscellaneous design patterns.
    These patterns are extremely useful and can be applied to various situations for
    different types of applications. While it is important to know what the best practices
    are, it is also beneficial to understand what pitfalls to avoid. To do this, we
    are going to cover several **anti-patterns** in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Anti-patterns are bad practices that programmers may do unintentionally. Sometimes,
    these problems are not severe enough to cause trouble; however, it is possible
    that an application may become unstable or have degraded performance due to improper
    design. In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Piracy anti-pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Narrow argument types anti-pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nonconcrete field types anti-pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have learned how to avoid developing pirate
    functions. You will also be more conscious and smart about the level of abstraction
    when specifying the type of function arguments. Finally, you will be able to leverage
    more parametric types in your design for your own composite types for high-performance
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with the most interesting topic—piracy!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The sample source code is located at [https://github.com/PacktPublishing/Hands-on-Design-Patterns-and-Best-Practices-with-Julia/tree/master/Chapter10](https://github.com/PacktPublishing/Hands-on-Design-Patterns-and-Best-Practices-with-Julia/tree/master/Chapter10)[.](https://github.com/PacktPublishing/Hands-on-Design-Patterns-and-Best-Practices-with-Julia/tree/master/Chapter10)
  prefs: []
  type: TYPE_NORMAL
- en: The code is tested in a Julia 1.3.0 environment.
  prefs: []
  type: TYPE_NORMAL
- en: Piracy anti-pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 2](48061f6f-db77-4db6-9c92-d7550f4317fe.xhtml), *Modules, Packages
    and Data Type Concepts*, we learned how to create new namespaces using modules.
    As you may recall, modules are used to define functions so that they are logically
    separated. It is possible, then, that we can define two different functions—one
    in module X and another in module Y, with both having exactly the same name. In
    fact, these functions do not even need to mean the same thing. For example, in
    a mathematics package, we can define a `trace` function for matrices. In a computer
    graphics package, we can define a `trace` function for doing ray tracing work.
    These two `trace` functions perform different things, and they do not interfere
    with each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, a function can also be designed to be extended from another
    package. For example, in the `Base` package, the `AbstractArray` interface is
    designed to be extended. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have extended the `size` and `getindex` functions from the `Base`
    package so that they can work with our own data types. This is a perfectly good
    usage of the Julia language; however, it can be problematic when we do not extend
    functions from other packages correctly. In particular,* piracy* refers to the
    situation in which a third-party function is replaced or extended in a bad way.
    This is an anti-pattern because it may cause system behavior to become nondeterministic.
    For convenience, we can define three different kinds of piracy:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Type I piracy**: Function is redefined'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Type II piracy**: Function is extended without using your own types in any
    of the arguments'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Type III piracy**: Function is extended but used for a different purpose'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will now drill down into each one in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Type I – Redefining a function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Type I piracy refers to the situation where a programmer redefines a third-party
    function from their own module. Perhaps you did not like the original implementation
    in the third-party module and replaced the function with your own implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The worst form of Type I piracy is when you replace the function without conforming
    to the original function''s interface. Let''s do an experiment and see what could
    happen. We will use the `+` function from `Base` as an example. As you know, when
    the `+` function is passed with two `Int` arguments, it should return an `Int`
    value as a result. What would happen if we replace the function so that it returns
    a string? Let''s open up a REPL and give it a try:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f79f8cb7-b6c1-403c-a428-9b1d907a190c.png)'
  prefs: []
  type: TYPE_IMG
- en: '*Boom! *The Julia REPL crashed immediately as soon as the function was defined. That
    is because the return value of this `+` function is expected to be an integer.
    When we return a string, it violates the contract of this function and all functionalities
    that rely on the `+` function are negatively impacted. Given that `+` is a commonly
    used function, it crashes the system immediately.'
  prefs: []
  type: TYPE_NORMAL
- en: Why does Julia even allow us to do that? For some situations, the ability to
    do this can be useful. Say that you found a bug for a specific function in a third-party
    package—you can inject a fix immediately without having to wait for the bug fix
    upstream. Likewise, you can replace a slow function with a more performant version.
    Ideally, these changes should be sent upstream, but you have the flexibility to
    implement the change immediately.
  prefs: []
  type: TYPE_NORMAL
- en: The only requirement is that the function being replaced should adhere to the
    same contract that was originally intended. Therefore, it requires an intimate
    understanding about how the third-party package is designed. In reality, it is
    even better if you can contact the original author and discuss the change before
    applying piracy.
  prefs: []
  type: TYPE_NORMAL
- en: '*With great power comes great responsibility. *Great care must be taken if
    we ever want to make use of Type I piracy.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will look into Type II piracy, which is more common across packages
    in the Julia ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: Type II piracy – Extending without your own types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Type II piracy is commonly known as *type piracy* by the Julia developer community.
    It refers to the situation where a third-party function is extended without using
    the programmer's own types in any of the function arguments. It usually happens
    when you want to extend the third-party package by injecting your own code. Let's
    go through a hypothetical example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose that you want to mimic the same behavior in JavaScript of adding a
    string and a number together, where the values concatenate as if they are both
    strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/181d749d-f102-4928-ba25-6006356a6a51.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To make it happen in Julia, we would be tempted to do the following in `MyModule`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We can paste the preceding code in the REPL and do a quick test:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a13e987f-88e4-4c69-8b2b-38b551f95014.png)'
  prefs: []
  type: TYPE_IMG
- en: This seems to be working great! But there are some hidden issues with this approach.
    Let's look at why it is still a bad idea.
  prefs: []
  type: TYPE_NORMAL
- en: Conflicting with another pirate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we are using the enhanced version of the `+` function, can we rely
    on the fact that the function will always do exactly what we have made it do?
    Perhaps surprisingly, the answer is no.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say we have found an open source package called `AnotherModule`, and
    we want to use it in our `MyModule` module. The `AnotherModule` module happens
    to do the same kind of type II piracy; however, the author decided to do the *right* thing—instead
    of concatenating the arguments as if they are strings, the string argument is
    parsed into a number and then the two numbers are added together. The code is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If we go back to the REPL and define this module, then we get the new definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5dbbd88c-0b23-4057-9025-d16729e75e80.png)'
  prefs: []
  type: TYPE_IMG
- en: We now have two implementations of the same function with exactly the same signature,
    and they return different results. Who is going to win? Is it the one defined
    in `MyModule` or the one in `AnotherModule`? Only one of them can be in effect.
    That means that either `AnotherModule` or `MyModule` is going to break. This problem
    can lead to a disastrous situation and hard-to-find bugs.
  prefs: []
  type: TYPE_NORMAL
- en: Another reason to avoid type II piracy is the future-proofing problem. We will
    discuss this next.
  prefs: []
  type: TYPE_NORMAL
- en: Future-proofing your code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Say that we have extended the `+` function in `Base` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: It may seem to be a great addition today; however, there is no guarantee that
    the same function will not be implemented in a future version of Julia. It is
    conceivable (which is not to say that it's likely or unlikely) that the `+` function
    will be enhanced to work with strings in the future.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, these kinds of changes would be considered nonbreaking, meaning
    that the Julia dev team can add this feature with just a minor release. Unfortunately,
    your application now breaks for a nonbreaking Julia upgrade. That's not something
    that we normally expect.
  prefs: []
  type: TYPE_NORMAL
- en: '*If you want to future-proof your code, then do not be a pirate!*'
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding type piracy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Type II piracy can be mitigated by creating your own types and using them in
    the function argument. In this case, perhaps we should consider creating a wrapper
    type to hold the string and using this new type for dispatch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have redefined the module with a new `MyString` type that holds a
    string. Then, we can still extend the `+` function to concatenate `MyString` with
    any number. For completeness, we have defined three variations of the `+` function
    for accepting `MyString` and `Number` arguments in any order and another one that
    accepts two `MyString` arguments. We have also defined a `str_str` macro for convenience.
    The new module works properly as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/55f649ff-8e46-490a-b929-0f53af5fbd9e.png)'
  prefs: []
  type: TYPE_IMG
- en: By using your own type in the function argument, we can avoid any conflict with
    other dependent packages, as well as future-proofing our code for Julia upgrades.
  prefs: []
  type: TYPE_NORMAL
- en: The last kind of piracy is somewhat less severe but still worth a look. Let's
    take a look at that next.
  prefs: []
  type: TYPE_NORMAL
- en: Type III piracy – Extending with your own type, but for a different purpose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Type III piracy refers to the situation where a function is extended, but is
    used for a different purpose. It is the right procedure of extending code, but
    done in a bad way. This kind of piracy is also called a *pun *by the Julia developers.
    To understand what it is, let's consider a fun example here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose that we are developing a simple party registration application. The
    type definition and constructor are shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Party` type contains just a title and an array of guest names. The constructor
    just takes the title and initializes the guest array as an empty array. Now, just
    to be cute, we can define a function for joining a party as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This is an extension to the `join` method from `Base`. Why would we want to
    do that? Well, if we create the `join` function in our own namespace, then we
    can get into a naming conflict with the standard `join` function. To avoid handling
    that conflict, maybe it is easier to just extend the function from `Base`.
  prefs: []
  type: TYPE_NORMAL
- en: 'At first glance, it would work as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fe6cd83a-ab76-44ad-9b78-a29c23dcc77b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'However, there is a hidden trap. If we were to let multiple people join the
    party at the same time, then we could get into trouble easily:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/880ac20d-0858-48d9-abad-23375c8ded03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'What happened? Let''s take a look at the original meaning of the `join` function,
    as shown in the `help` screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The purpose of the `join` function is to take multiple strings and put them
    together separated by some kind of delimiter. So the call to the `join` function
    in the preceding code ended up using the `Party` object as a delimiter.
  prefs: []
  type: TYPE_NORMAL
- en: Let's think a little bit about how we got into trouble. When we defined the
    function using our own type (`Party`), we did not expect our function to be used
    by any other code except our own. However, that is not true here. Our function
    was clearly utilized by the string concatenation logic from the `Base` package.
  prefs: []
  type: TYPE_NORMAL
- en: It turns out that we are an unfortunate victim of *duck typing*. If you look
    into the source code of Julia, you will find that some `join` functions are defined
    without specifying any type in the arguments. So, when we pass a `Party` object
    to the `join` function, it leaks into the original `join` logic. Worse yet, no
    error was thrown because everything just *worked*.
  prefs: []
  type: TYPE_NORMAL
- en: It is best to avoid type III piracy altogether. In the preceding example, we
    could have defined the `join` function in our own module rather than extending
    the one from `Base`. If we are bothered by the name conflict issue, we can also
    choose a different function name—for example, `register`. We have to realize that
    the meaning of joining a party is not the same as joining strings together.
  prefs: []
  type: TYPE_NORMAL
- en: All three types of piracy are bad, and they can cause bugs that are surprisingly
    difficult to find or debug. We should avoid them as much as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will go over another anti-pattern related to specifying argument types
    in function definitions.
  prefs: []
  type: TYPE_NORMAL
- en: Narrow argument types anti-pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When designing functions in Julia, we have many options about whether and how
    to provide the type of arguments. The narrow argument types anti-pattern refers
    to the situation in which the types of the arguments are too narrowly specified,
    causing the function to be less useful unnecessarily.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider a simple example function that is used for computing the sum
    of the products of two vectors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: There is nothing wrong with this design, except that the function can only be
    used when the arguments are vectors of `Float64` values. What are the other possible
    options? Let's take a look at that next.
  prefs: []
  type: TYPE_NORMAL
- en: Considering various options for argument types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Julia's dispatch mechanism can select the right function to call as long as
    the type of the arguments being passed matches the signature of the function.
    Based upon the type hierarchy, we can possibly specify abstract types and the
    function still gets selected properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Such flexibility gives us many options. We can consider any of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sumprod(A::Vector{Float64}, B::Vector{Float64})`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sumprod(A::Vector{Number}, B::Vector{Number})`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sumprod(A::Vector{T}, B::Vector{T}) where T <: Number`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sumprod(A::Vector{S}, B::Vector{T}) where {S <: Number, T <: Number}`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sumprod(A::Array{S,N}, B::Array{T,N}) where {N, S <: Number, T <: Number}`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sumprod(A::AbstractArray{S,N}, B::AbstractArray{T,N}) where {N, S <: Number,
    T <: Number}`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sumprod(A, B)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which one is the most appropriate option for our function? We're not sure yet,
    but we can always revisit our requirements and perform some testing before drawing
    a conclusion.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first define what scenarios we plan to support. As we expect, this is
    just a numeric calculation: we would like to support any numeric container that
    supports broadcasting. Broadcasting is required because we use dot notation when
    calculating the product of A and B in the preceding code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our test scenarios involve the following combinations of arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Scenario** | **Argument 1** | **Argument 2** |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | `Array{Float64, 1}` | `Array{Float64, 1}` |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | `Array{Int64, 1}` | `Array{Int64, 1}` |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | `Array{Int, 1}` | `Array{Float64, 1}` |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | `Array{Float64, 2}` | `Array{Float64, 2}` |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | `Array{Number,1}` | `Array{Number,1}` |'
  prefs: []
  type: TYPE_TB
- en: 'To test these scenarios for various function signature options, we can build
    a test harness function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The test harness applies function `f` with the provided arguments `args` for
    a specific `scenario`. If the function is dispatched, it displays a success message
    in the console; otherwise, it displays a failure message. As we want to test the
    preceding listed scenarios, we can define just one more function so that we can
    execute our tests easily:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `test_sumprod` function takes a function and executes the five preceding
    test cases.
  prefs: []
  type: TYPE_NORMAL
- en: Now we are all set. Let's dissect each option and see how well they work for
    us.
  prefs: []
  type: TYPE_NORMAL
- en: Option 1 – Vectors of Float64 values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first option is what we started with at the beginning of this section. It
    has the most specific types of arguments. The drawback is that it can only work
    with a vector of `Float64` values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s define our function as follows so that we can pass it to the testing
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We can try our test harness now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/722c66c6-4c47-4dd5-bfb4-69630ca827e8.png)'
  prefs: []
  type: TYPE_IMG
- en: As expected, this function can work with the first scenario when both arguments
    are vectors of `Float64` values. So it does not satisfy all of our requirements.
    Let's try the next option.
  prefs: []
  type: TYPE_NORMAL
- en: Option 2 – Vectors of instances of Number
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The second option is a little more interesting. We have switched the type parameter
    from `Float64` to `Number`, which is the topmost abstract type in the numeric
    type hierarchy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s test it now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/be78eef1-fd52-43b2-98e9-7f799d0439f2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'At first glance, it may appear that using `Number` as a type parameter would
    make it more generic. It turns that out that it can only accept an array of `Number`
    types, which means that it has to be a heterogenous array where each element can
    be a different type as long as all element types are subtypes of `Number`. For
    that reason, a vector of `Float64` values is not a subtype of a vector of `Number`
    values. Check the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d2da93bb-6858-4bd4-9ad8-b4db15d9ff03.png)'
  prefs: []
  type: TYPE_IMG
- en: For that reason, none of the scenarios was successful except the last one, which
    takes vectors of `Number` exactly as arguments. So this option is not a great
    one either. Let's move on!
  prefs: []
  type: TYPE_NORMAL
- en: Option 3 – Vectors of type T where T is a subtype of Number
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The third option is to take vectors of type `T`, where `T` is just a subtype
    of `Number`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The function can be defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s try it first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/da1489bb-1a10-4dbb-85c2-bc4258a76abb.png)'
  prefs: []
  type: TYPE_IMG
- en: As the type parameter `T` can be any subtype of `Number`, this function comfortably
    handles vectors of `Float64`, `Int64`, and even `Number` types. Unfortunately,
    it cannot handle arguments of different types, but we should be able to improve
    it further. Let's try the next option.
  prefs: []
  type: TYPE_NORMAL
- en: Option 4 – Vectors of type S and T where S and T are subtypes of Number
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This option differs from option 3 only in the way that the types of arguments
    are separately specified. Thus, the function can accept different types for the
    first and second arguments. The function is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We can try it now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/54817012-bf9b-4a6e-9382-4435067dc8aa.png)'
  prefs: []
  type: TYPE_IMG
- en: We have definitely addressed the issue with mixed argument types by now. We're
    getting close to the final destination. Scenario 4 is the case where the arguments
    are matrices rather than vectors. For sure we know how to fix this, so let's do
    that next.
  prefs: []
  type: TYPE_NORMAL
- en: Option 5 – Arrays of type S and type T where S and T are subtypes of Number
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since Julia arrays support broadcasting, we can generalize the function arguments
    from a `Vector{T}` to an `Array{T,N}` signature in order to support multidimensional
    arrays. Let''s now define the function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We have pretty good confidence that this would work. Let''s test it now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2c8503b9-bb20-493c-9990-442b3e64bb31.png)'
  prefs: []
  type: TYPE_IMG
- en: '*Fabulous!* We have finally satisfied all the requirements as listed in the
    test scenarios. Are we done? Maybe not. For the sake of argument, we may want
    to support other types of containers that are not necessarily a dense array. What
    if the input is sparse matrices? Let''s improve the function once again.'
  prefs: []
  type: TYPE_NORMAL
- en: Option 6 – Abstract arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `AbstractArray` is the abstract type for all Julia array containers. Many
    Julia packages implement the array interface and are made to be subtypes of `AbstractArray`.
    It would be a shame if we go so far to make the `sumprod` function versatile enough,
    and yet we cannot support sparse matrices or other types of array-type containers.
    To make it more general, let''s turn our function definition from `Array` to `AbstractArray`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The signature is the same as the previous option, except that the function
    can be dispatched with any `AbstractArray` container types. Let''s make sure that
    the function works as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5635c61d-1a34-464e-a158-c11fd39e2365.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The function is working properly for our existing cases. Let''s just try it
    once again using the sparse matrix type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/159e5aa8-4b96-44ac-8563-39a8cfb6f1b1.png)'
  prefs: []
  type: TYPE_IMG
- en: '*Bravo!* It is working great now, even with a non-dense array type. We are
    almost done. Let''s look at our last option—duck typing.'
  prefs: []
  type: TYPE_NORMAL
- en: Option 7 – Duck typing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our last option basically skips the types in the function arguments. This is
    also called duck typing, as the function will be dispatched as long as two arguments
    are provided. Julia will specialize and compile a new version for different variations
    of the argument types. The function is simply defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'For completeness, we will run the test again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/102bb95c-6403-4519-9065-5a400edd9561.png)'
  prefs: []
  type: TYPE_IMG
- en: The benefit of this option is that the function is free of type information
    in the signature, so it looks very clean. However, the drawback is that the function
    can be dispatched for any type—not even an array or for numeric values. When garbage
    is passed into the function, garbage comes out, or the function just throws an
    error when the objects being passed do not have the `*` operator function defined.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have considered all the options and performed the respective tests,
    let's summarize what we have done so far and what we would want to do next.
  prefs: []
  type: TYPE_NORMAL
- en: Summarizing all options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s now summarize all the options that we have considered so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Option** | **Signature** | **Passed all tests?** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | `sumprod(A::Vector{Float64}, B::Vector{Float64})` | No |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | `sumprod(A::Vector{Number}, B::Vector{Number})` | No |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | `sumprod(A::Vector{T}, B::Vector{T}) where T <: Number` | No |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | `sumprod(A::Vector{S}, B::Vector{T}) where {S <: Number, T <: Number}`
    | No |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | `sumprod(A::Array{S,N}, B::Array{T,N}) where {N, S <: Number, T <: Number}`
    | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | `sumprod(A::AbstractArray{S,N}, B::AbstractArray{T,N}) where {N, S <:
    Number, T <: Number}` | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | `sumprod(A, B)` | Yes |'
  prefs: []
  type: TYPE_TB
- en: Technically speaking, options 5, 6, or 7 could work for all array types. Options
    6 and 7 support other array containers, such as sparse matrix. Option 7 works
    with non-`AbstractArray` types, as long as the type is broadcasting multiplication
    as well as summation.
  prefs: []
  type: TYPE_NORMAL
- en: Before we draw our conclusion, let's do one last test from a performance perspective.
    Do you wonder whether making the function accept more general types would sacrifice
    performance? The only way to know this is to prove it with real experiments. Let's
    do that next.
  prefs: []
  type: TYPE_NORMAL
- en: Evaluating performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Do we sacrifice performance when we make the functions accept more general types
    in their arguments? Let's do some benchmarking tests and see how they perform.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we will benchmark the functions for options 1, 5, 6, and 7 using exactly
    the same input: two `Float64` vectors with 10,000 elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are the test results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a1901151-46ea-4338-810e-3f66c7fb9b88.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, there is no material difference between these options. How the
    argument types are specified does not affect the runtime performance of the function.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, what we have learned about this anti-pattern is that the function
    argument should not be made too narrow unnecessarily. A function can be much more
    useful when the *net* is cast wide. A function that can accept and support more
    input types is automatically more reusable.
  prefs: []
  type: TYPE_NORMAL
- en: Our next anti-pattern relates to how field types should be chosen when designing
    data types. This is an extremely important topic as it can dramatically affect
    system performance.
  prefs: []
  type: TYPE_NORMAL
- en: Nonconcrete field types anti-pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The nonconcrete field types anti-pattern is an anti-pattern in which a struct
    field is not concrete. The main problem with nonconcrete types for fields is that
    they can cause major performance problems. To understand why, let's take a look
    at the memory layout for composite types that have nonconcrete versus concrete
    types, then design and compare the two.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the memory layout of composite data types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s first take a look at a simple example for a composite type for tracking
    the coordinates of a point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'When the field type is not specified, it is implicitly interpreted as `Any`,
    the super type of all types, hence the preceding code is syntactically equivalent
    to the following (except that we have renamed the type name as `Point2` to avoid
    confusion):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The fields `x` and `y` have the `Any` type, meaning that they can be anything:
    `Int64`, `Float64`, or any other data type. To compare the memory layout and utilization,
    it is worth creating a new point type that uses a small concrete type, such as
    `UInt8`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'As we know, `UInt8` should occupy a single byte of storage. Having both `x`
    and `y` fields should consume only two bytes of storage. Perhaps we should just
    prove it to ourselves. Check the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d8c30dcb-bb09-4f8f-946b-a82ad0479b39.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Clearly, a single `Point3` object only occupies two bytes. Let''s do the same
    with the original `Point` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1fdf8554-09ac-4a38-be2a-a858b3e6dea0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `Point` object takes 16 bytes, even though we want to store just two bytes.
    As we know, the `Point` object can take any data type in the `x` and `y` fields.
    Now, let''s do the same exercise with a larger data type, such as `Int128`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5f3561d8-0ee6-42d1-a404-e3cf5fdda73a.png)'
  prefs: []
  type: TYPE_IMG
- en: An `Int128` is a 128-bit integer, which occupies 16 bytes in memory. Interestingly,
    even though we are carrying two `Int128` fields in `Point`, the size of the object
    remains as 16 bytes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Why? It is because `Point` actually stores two 64-bit pointers, each occupying
    eight bytes of storage. We can visualize the memory of a `Point` object as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2c98b9c7-d7ba-4406-90fd-90b099bfa974.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When the field types are concrete, the Julia compiler knows exactly what the
    memory layout looks like. With two `UInt8` fields, it is compactly represented
    with two bytes. With two `Int128` fields, it will occupy 32 bytes. Let''s try
    that in REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9a3be4a1-1026-4805-bdc6-3a5e034f7b5d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The memory layout of `Point4` is compact, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/91ca4f89-99a9-4356-90da-2bb55bc4967f.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that we know the difference in memory layout, we can immediately see the
    benefits of using concrete types. Every time we need to access the `x` or `y`
    field, if it is a concrete type, then the data is right there. If the fields are
    just pointers, then we have to dereference the pointer to find the data. Furthermore,
    the physical memory locations of `x` and `y` may not even be adjacent to each
    other, which may cause hardware cache misses, further hurting performance.
  prefs: []
  type: TYPE_NORMAL
- en: So, do we just follow the rule of using concrete types directly in the field
    definitions? Not necessarily. There are other options that we can consider, which
    we will do in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Designing composite types with concrete types in mind
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Perhaps the reason why we use abstract types in the fields in the first place
    is to support different types of data in the field. Taking the `Point` type in
    the previous section, we can see that the type can be useful in the context of
    computer games, where the coordinates are identified by integer pixel positions
    on the screen. On the other hand, we also think that the same type may be useful
    for storing coordinates of shapes in architectural diagrams, in which case, we
    would want floating-point values.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to be flexible, we would want to support `Point` fields with any
    subtype of the `Real` type. Conceptually, we want something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'However, since `Real` is an abstract type, we would expect poor performance,
    just like we would with `Any`. In order to utilize concrete types without sacrificing
    the flexibility of supporting other numeric types, we can turn `Point` into a
    parametric type. Let''s restart the REPL and define the new `Point` type, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Making it a parametric type has the benefit of being concrete. We can check
    this out easily from the REPL. The following is a basic syntax implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a3d52d8d-c736-41ba-a950-3be3e02c793c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following code shows another example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/26adba53-dedf-4318-88fb-81544d3e20f0.png)'
  prefs: []
  type: TYPE_IMG
- en: So far, we have been assuming that concrete types would outperform nonconcrete
    types in `struct` fields. It would be nice to get an idea of how much difference
    it makes. Let's try that now.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing performance between concrete versus nonconcrete field types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can run a performance test with these two different types, depicted here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our benchmark test function will compute the center of all points from an array,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition, we will also define a function that can be used to make an array
    of points for whatever type we want:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Let's start with a `PointAny` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will generate 100,000 points and use `BenchmarkTools` to measure the time:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ae24af37-f0f9-436e-844b-32fb0928c388.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we will run the performance test for the `Point` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3ad4d592-b2c5-4588-8518-b2b09f27476e.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, there is a huge difference between the two. Using the parametric
    `Point` type is approximately 25 times faster than the one that uses `Any` as
    a field type.
  prefs: []
  type: TYPE_NORMAL
- en: What we have learned from this anti-pattern is that we should use concrete types
    for fields defined in composite types. It is quite easy to *factor out* the abstract
    type we want into a type parameter. Doing this allows us to gain performance benefits
    from concrete types without sacrificing the ability to support other data types.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about several anti-patterns in Julia programming.
    When we went over details for each anti-pattern, we also figured out how to apply
    alternative design solutions.
  prefs: []
  type: TYPE_NORMAL
- en: We began with the piracy anti-pattern, which refers to bad practices as related
    to extending functions from a third-party module. For convenience, we classified
    piracy anti-patterns into three different types—type I, II, and III. Each type
    poses a different problem in causing the system to become unstable or potentially
    invite problems in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we looked into the narrow argument types anti-pattern. When function arguments
    are too narrowly specified, they become less reusable. Because Julia can specialize
    the function for various argument types, it is more beneficial to make argument
    types as general as possible, utilizing abstract types. We went through several
    design options in great detail, and concluded that the most general types can
    be used without sacrificing performance.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we reviewed the nonconcrete field types anti-pattern. We proved that
    having nonconcrete types poses a performance problem because of the resulting
    inefficient memory layout structure. We figured that the problem can be solved easily by
    using parametric types, specifying concrete types as part of the type parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we will turn our attention to traditional object-oriented
    design patterns and see how they can be applied in Julia programming. *Fasten
    your seat belt: if you used to be an OOP programmer, your ride may be a little
    bumpy! *'
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are the risks and potential benefits of type I piracy?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What kind of problems can arise from type II piracy?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does type III piracy cause trouble?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What should we watch out for when specifying function arguments?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How is system performance affected by using abstract function arguments?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How is system performance affected by using abstract field types for composite
    types?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
