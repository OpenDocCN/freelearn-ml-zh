["```py\nconda env create â€“f <ENVIRONMENT_NAME>.yml \n```", "```py\nkind create cluster \n```", "```py\nkind create cluster --config cluster-config-ch08.yaml \n```", "```py\nminikube start \n```", "```py\nimport ray\nimport ray.data\nimport pandas as pd\nfrom prophet import Prophet\n\ndef prep_store_data(\n    df: pd.DataFrame, \n    store_id: int = 4, \n    store_open: int = 1\n) -> pd.DataFrame:\n    df_store = df[\n        (df['Store'] == store_id) &\\\n        (df['Open'] == store_open)\n    ].reset_index(drop=True)\n    df_store['Date'] = pd.to_datetime(df_store['Date'])\n    df_store.rename(columns= {'Date': 'ds', 'Sales': 'y'}, inplace=True)\n    return df_store.sort_values('ds', ascending=True)\n\ndef train_predict(\n    df: pd.DataFrame,\n    train_fraction: float,\n    seasonality: dict\n) -> tuple[pd.DataFrame, pd.DataFrame, pd.DataFrame, int]:\n    # grab split data\n    train_index = int(train_fraction*df.shape[0])\n    df_train = df.copy().iloc[0:train_index]\n    df_test = df.copy().iloc[train_index:]\n#create Prophet model\n    model=Prophet(\n        yearly_seasonality=seasonality['yearly'],\n        weekly_seasonality=seasonality['weekly'],\n        daily_seasonality=seasonality['daily'],\n        interval_width = 0.95\n    )\n# train and predict\n    model.fit(df_train)\n    predicted = model.predict(df_test)\n    return predicted, df_train, df_test, train_index \n```", "```py\n@ray.remote(num_returns=4)\ndef prep_train_predict(\n    df: pd.DataFrame,\n    store_id: int,\n    store_open: int=1,\n    train_fraction: float=0.8,\n    seasonality: dict={'yearly': True, 'weekly': True, 'daily': False}\n) -> tuple[pd.DataFrame, pd.DataFrame, pd.DataFrame, int]:\n    df = prep_store_data(df, store_id=store_id, store_open=store_open)\n    return train_predict(df, train_fraction, seasonality) \n```", "```py\nstore_ids = df['Store'].unique() \n```", "```py\nray.init(num_cpus=4)\ndf_id = ray.put(df) \n```", "```py\npred_obj_refs, train_obj_refs, test_obj_refs, train_index_obj_refs = map(\n    list,\n    zip(*([prep_train_predict.remote(df_id, store_id) for store_id in store_ids])),\n) \n```", "```py\nray_results = {\n    'predictions': ray.get(pred_obj_refs),\n    'train_data': ray.get(train_obj_refs),\n    'test_data': ray.get(test_obj_refs),\n    'train_indices': ray.get(train_index_obj_refs)\n} \n```", "```py\n{\n    \"storeId\": \"4\",\n    \"beginDate\": \"2023-03-01T00:00:00Z\",\n    \"endDate\": \"2023-03-07T00:00:00Z\"\n} \n```", "```py\n[\n  {\n        \"storeId\": \"2\",\n        \"beginDate\": \"2023-03-01T00:00:00Z\",\n        \"endDate\": \"2023-03-07T00:00:00Z\"\n    },\n    {\n        \"storeId\": \"4\",\n        \"beginDate\": \"2023-03-01T00:00:00Z\",\n        \"endDate\": \"2023-03-07T00:00:00Z\"\n    }\n] \n```", "```py\n[\n    {\n        \"storeId\": \"4\",\n    }\n] \n```", "```py\nfrom pydantic import BaseModel\n\nclass ForecastRequest(BaseModel):\n    store_id: str\n    begin_date: str | None = None\n    end_date: str | None = None \n```", "```py\nimport pandas as pd\n\ndef create_forecast_index(begin_date: str = None, end_date: str = None):\n    # Convert forecast begin date\n    if begin_date == None:\n        begin_date = datetime.datetime.now().replace(tzinfo=None)\n    else:\n        begin_date = datetime.datetime.strptime(begin_date,\n                     '%Y-%m-%dT%H:%M:%SZ').replace(tzinfo=None)\n\n    # Convert forecast end date\n    if end_date == None:\n        end_date = begin_date + datetime.timedelta(days=7)\n    else:\n        end_date = datetime.datetime.strptime(end_date, \n                   '%Y-%m-%dT%H:%M:%SZ').replace(tzinfo=None)\n    return pd.date_range(start = begin_date, end = end_date, freq = 'D') \n```", "```py\n[\n    {\n        \"request\": {\n            \"store_id\": \"4\",\n            \"begin_date\": \"2023-03-01T00:00:00Z\",\n            \"end_date\": \"2023-03-07T00:00:00Z\"\n        },\n        \"forecast\": [\n            {\n                \"timestamp\": \"2023-03-01T00:00:00\",\n                \"value\": 20716\n            },\n            {\n                \"timestamp\": \"2023-03-02T00:00:00\",\n                \"value\": 20816\n            },\n            {\n                \"timestamp\": \"2023-03-03T00:00:00\",\n                \"value\": 21228\n            },\n            {\n                \"timestamp\": \"2023-03-04T00:00:00\",\n                \"value\": 21829\n            },\n            {\n                \"timestamp\": \"2023-03-05T00:00:00\",\n                \"value\": 21686\n            },\n            {\n                \"timestamp\": \"2023-03-06T00:00:00\",\n                \"value\": 22696\n            },\n            {\n                \"timestamp\": \"2023-03-07T00:00:00\",\n                \"value\": 21138\n            }\n        ]\n    }\n] \n```", "```py\nimport mlflow \nimport mlflow.pyfunc\nfrom mlflow.client import MlflowClient\nimport os\n\ntracking_uri = os.getenv([\"MLFLOW_TRACKING_URI\"])\nmlflow.set_tracking_uri(tracking_uri)\nclient = MlflowClient(tracking_uri=tracking_uri)\n\ndef get_production_model(store_id:int):\n    model_name = f\"prophet-retail-forecaster-store-{store_id}\"\n    model =mlflow.pyfunc.load_model(\n                         model_uri=f\"models:/{model_name}/production\"\n                       )\n    return model \n```", "```py\nmodel_name = f\"prophet-retail-forecaster-store-{store_id}\"\nlatest_versions_metadata = client.get_latest_versions(\n    name=model_name\n) \n```", "```py\n[<ModelVersion: creation_timestamp=1681378913710, current_stage='Production', description='', last_updated_timestamp=1681378913722, name='prophet-retail-forecaster-store-3', run_id='538c1cbded614598a1cb53eebe3de9f2', run_link='', source='/Users/apmcm/\ndev/Machine-Learning-Engineering-with-Python-Second-Edition/Chapter07/register/artifacts/0/538c1cbded614598a1cb53eebe3de9f2/artifacts/model', status='READY', status_message='', tags={}, user_id='', version='3'>] \n```", "```py\nlatest_model_version_metadata = client.get_model_version(\n    name=model_name,\n    version=latest_versions_metadata.version\n) \n```", "```py\n<ModelVersion: creation_timestamp=1681377954142, current_stage='Production', description='', last_updated_timestamp=1681377954159, name='prophet-retail-forecaster-store-3', run_id='41f163b0a6af4b63852d9218bf07adb3', run_link='', source='/Users/apmcm/dev/Machine-Learning-Engineering-with-Python-Second-Edition/Chapter07/register/artifacts/0/41f163b0a6af4b63852d9218bf07adb3/artifacts/model', status='READY', status_message='', tags={}, user_id='', version='1'> \n```", "```py\nlatest_model_run_id = latest_model_version_metadata.run_id \n```", "```py\n'41f163b0a6af4b63852d9218bf07adb3' \n```", "```py\nclient.get_metric_history(run_id=latest_model_run_id, key='rmse') \n```", "```py\nimport boto3\nimport http.client\nimport base64\nimport ast\n# mwaa_env_name = 'YOUR_ENVIRONMENT_NAME'\n# dag_name = 'YOUR_DAG_NAME'\n\ndef trigger_dag(mwaa_env_name: str, dag_name: str) -> str:\n    client = boto3.client('mwaa')\n\n    # get web token\n    mwaa_cli_token = client.create_cli_token(\n        Name=mwaa_env_name\n    )\n\n    conn = http.client.HTTPSConnection(\n       mwaa_cli_token['WebServerHostname']\n    )\n    mwaa_cli_command = 'dags trigger'\n    payload = mwaa_cli_command + \" \" + dag_name\n    headers = {\n      'Authorization': 'Bearer ' + mwaa_cli_token['CliToken'],\n      'Content-Type': 'text/plain'\n    }\n    conn.request(\"POST\", \"/aws_mwaa/cli\", payload, headers)\n    res = conn.getresponse()\n    data = res.read()\n    dict_str = data.decode(\"UTF-8\")\n    mydata = ast.literal_eval(dict_str)\n    return base64.b64decode(mydata['stdout']).decode('ascii') \n```", "```py\n# Logging\nimport logging\n\nlog_format = \"%(asctime)s - %(name)s - %(levelname)s - %(message)s\" \nlogging.basicConfig(format = log_format, level = logging.INFO)\nhandlers = {}\nmodels = {}\nMODEL_BASE_NAME = f\"prophet-retail-forecaster-store-\" \n```", "```py\nfrom fastapi import FastAPI\nfrom registry.mlflow.handler import MLFlowHandler\n\napp = FastAPI()\n@app.on_event(\"startup\")\nasync def startup():\n    await get_service_handlers()\n    logging.info(\"Updated global service handlers\")\nasync def get_service_handlers():\n    mlflow_handler = MLFlowHandler()\n    global handlers\n    handlers['mlflow'] = mlflow_handler\n    logging.info(\"Retreving mlflow handler {}\".format(mlflow_handler))\n    return handlers \n```", "```py\nimport mlflow\nfrom mlflow.client import MlflowClient\nfrom mlflow.pyfunc import PyFuncModel\nimport os \n\nclass MLFlowHandler:\n    def __init__(self) -> None:\n        tracking_uri = os.getenv('MLFLOW_TRACKING_URI')\n        self.client = MlflowClient(tracking_uri=tracking_uri)\n        mlflow.set_tracking_uri(tracking_uri)\n\n    def check_mlflow_health(self) -> None:\n        try:\n            experiments = self.client.search_experiments()\n            return 'Service returning experiments'\n        except:\n            return 'Error calling MLFlow'\n\n    def get_production_model(self, store_id: str) -> PyFuncModel:\n        model_name = f\"prophet-retail-forecaster-store-{store_id}\"\n        model = mlflow.pyfunc.load_model(\n                             model_uri=f\"models:/{model_name}/production\"\n                             )\n        return model \n```", "```py\n@app.get(\"/health/\", status_code=200)\nasync def healthcheck():\n    global handlers\n    logging.info(\"Got handlers in healthcheck.\")\n    return {\n        \"serviceStatus\": \"OK\",\n        \"modelTrackingHealth\": handlers['mlflow'].check_mlflow_health()\n        } \n```", "```py\nasync def get_model(store_id: str):\n    global handlers\n    global models\n    model_name = MODEL_BASE_NAME + f\"{store_id}\"\n    if model_name not in models:\n        models[model_name] = handlers['mlflow'].\\\n                                   get_production_model(store_id=store_id)\n    return models[model_name] \n```", "```py\n@app.post(\"/forecast/\", status_code=200)\nasync def return_forecast(forecast_request: List[ForecastRequest]):\n    forecasts = []\n    for item in forecast_request:\n        model = await get_model(item.store_id)\n        forecast_input = create_forecast_index(\n            begin_date=item.begin_date, \n            end_date=item.end_date\n            )\n        forecast_result = {}\n        forecast_result['request'] = item.dict()\n        model_prediction = model.predict(forecast_input)[['ds', 'yhat']]\\\n            .rename(columns={'ds': 'timestamp', 'yhat': 'value'})\n        model_prediction['value'] = model_prediction['value'].astype(int)\n        forecast_result['forecast'] = model_prediction.to_dict('records')\n        forecasts.append(forecast_result)\n    return forecasts \n```", "```py\nuvicorn app:app â€“-host 127.0.0.1 --port 8000 \n```", "```py\nFROM tiangolo/uvicorn-gunicorn-fastapi:latest\nCOPY ./requirements.txt requirements.txt\nRUN pip install --no-cache-dir --upgrade -r requirements.txt\nCOPY ./app /app\nCMD [\"uvicorn\", \"main:app\", \"--host\", \"0.0.0.0\", \"--port\", \"8080\"] \n```", "```py\ndocker build -t custom-forecast-service:latest . \n```", "```py\ndocker login\ndocker push <DOCKER_USERNAME>/custom-forecast-service:latest \n```", "```py\ndocker run -d --platform linux/amd64 -p 8000:8080 electricweegie/custom-forecast-service \n```", "```py\nminikube start \n```", "```py\nkubectl apply â€“f direct-kube-deploy.yaml \n```", "```py\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: fast-api-deployment\nspec:\n  replicas: 2\n  selector:\n    matchLabels:\n      app: fast-api\n  template:\n    metadata:\n      labels:\n        app: fast-api\n    spec:\n      containers:\n      - name: fast-api\n        image: electricweegie/custom-forecast-service:latest\n        resources:\n          limits:\n            memory: \"128Mi\"\n            cpu: \"500m\"\n        ports:\n          - containerPort: 8000 \n```", "```py\n    minkube tunnel \n    ```", "```py\n    kubectl expose deployment fast-api-deployment --type=LoadBalancer --port=8080 \n    ```", "```py\n    kubectl get svc \n    ```", "```py\n    NAME                       TYPE                CLUSTER-IP     EXTERNAL-IP  PORT(S)               AGE\n    fast-api-deployment  LoadBalancer   10.96.184.178   10.96.184.178   8080:30791/TCP   59s \n    ```", "```py\napiVersion: v1\nkind: Service\nmetadata:\n  name: fast-api-service\nspec:\n  selector:\n    app: fast-api\n  ports:\n    - protocol: TCP\n      port: 8000\n      targetPort: 8000\n  type: LoadBalancer \n```", "```py\nkubectl expose deployment fast-api-deployment --name=fast-api-service --type=LoadBalancer --port=8000 --target-port=8000 --selector=app=fast-api \n```", "```py\nkubectl patch service fast-api-service -p '{\"spec\":{\"selector\":{\"app\":\"fast-api-green\"}}}' \n```"]