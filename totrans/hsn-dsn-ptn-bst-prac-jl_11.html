<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Robustness Patterns</h1>
                </header>
            
            <article>
                
<p>This chapter will cover several patterns that can be used to improve software robustness. By robustness, we are referring to the quality aspects, that is, can the software perform its functions correctly? Are all possible scenarios handled properly? This is an extremely important factor to consider when writing code for mission-critical systems.</p>
<p>Based on the <strong>Principle of Least Privilege</strong> (<strong>POLP</strong>), we would consider hiding unnecessary implementation details to the client of the interface. However, Julia's data structure is transparent – all fields are automatically exposed and accessible. This poses a potential problem because any improper usage or mutation can break the system. Additionally, by accessing the fields directly, the code becomes more tightly coupled with the underlying implementation of an object. So, what if a field name needs to be changed? What if a field needs to be replaced by another one? Therefore, there is a need to apply abstraction and decouple object implementation from its official interface. <span>We should adopt the more general definition – not only do we want to cover as many lines of code as possible but also every possible scenario as well. An increase in code coverage would give us more confidence about the correctness of our code.</span></p>
<p><span>We have classified these techniques into </span>the following sections:</p>
<ul>
<li><span>Accessor patterns</span></li>
<li><span>Property patterns</span></li>
<li>Let block patterns</li>
<li>Exception handling patterns</li>
</ul>
<p>By the end of this chapter, you will be able to encapsulate data access by developing your own accessor functions and property functions. You will also be able to hide away global variables from unexpected access outside of the module. Finally, you will also know about various exception handling techniques and understand how to retry failed operations.</p>
<p><em>Let's get started!</em></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>The example source code for this chapter can be found at <a href="https://github.com/PacktPublishing/Hands-on-Design-Patterns-and-Best-Practices-with-Julia/tree/master/Chapter08">https://github.com/PacktPublishing/Hands-on-Design-Patterns-and-Best-Practices-with-Julia/tree/master/Chapter08</a>.</p>
<p>The code is tested in a Julia 1.3.0 environment.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Accessor patterns</h1>
                </header>
            
            <article>
                
<p>Julia objects are transparent. What does that mean? Well, currently, the Julia language does not have the ability to apply access control over the fields of an object. Therefore, people coming from a C++ or Java background may find it a little uneasy. In this section, we will explore a number of ways in which to make the language more acceptable for those users who are seeking more access control.</p>
<p>So, perhaps we should define our requirements first. While we write up the requirements, we will also ask ourselves why we want to have them in the first place. Let's just consider any object in a Julia program:</p>
<ul>
<li><strong>Some fields need to be hidden from the outside world</strong>: Some fields are considered to be part of the public interface and are, therefore, fully documented and supported. Other fields are considered implementation details, and they may not be used because they are subject to change in the future.</li>
<li><strong>Some fields require validation before being mutated</strong>: Some fields may <span>only </span>accept a range of values. For example, an <kbd>age</kbd> field of a <kbd>Person</kbd> object may reject anything less than 0 or greater than 120! Avoiding invalid data is paramount to building robust systems.</li>
<li><strong>Some fields require a trigger before they can be read</strong>: Some fields <span>may be lazily loaded, which means they are not loaded until the value is read. Another reason is that some fields</span> may contain sensitive data, and the use of such fields must be logged for audit purposes.</li>
</ul>
<p>We will now discuss how to address these requirements.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Recognizing the implicit interface of an object</h1>
                </header>
            
            <article>
                
<p>Before we dive into the specific patterns, let's first take a quick detour and discuss how and why we have a problem in the first place.</p>
<p>Suppose that we have defined a data type called <kbd>Simulation</kbd> to keep track of some scientific experiment data and related statistics. The syntax for it is as follows:</p>
<pre>mutable struct Simulation{N}<br/>    heatmap::Array{Float64, N}<br/>    stats::NamedTuple{(:mean, :std)}<br/>end</pre>
<p>A <kbd>Simulation</kbd> object contains an N-dimensional array of floating-point values and a named tuple of statistical values. For demonstration purposes, we will create a simple function to perform a simulation and create an object, as follows:</p>
<pre>using Distributions<br/><br/>function simulate(distribution, dims, n) <br/>    tp = ntuple(i -&gt; n, dims)<br/>    heatmap = rand(distribution, tp...)<br/>    return Simulation{dims}(heatmap, (mean = mean(heatmap), std = std(heatmap)))<br/>end</pre>
<p>The simulation data called <kbd>heatmap</kbd> is generated using the <kbd>rand</kbd> function based on a distribution provided by the user. The <kbd>dims</kbd> argument represents the number of dimensions in the array, and the value of <kbd>n</kbd> represents the size of each dimension. Here's how to simulate a normally distributed 2-dimensional heatmap of size 1000 x 1000:</p>
<pre>sim = simulate(Normal(), 2, 1000);</pre>
<p>At this point, we can easily access the <kbd>heatmap</kbd> and <kbd>stats</kbd> fields of the object as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/43488f32-78a0-4369-aa45-06c159ccb5ef.png" style="width:37.50em;height:14.58em;"/></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Let's pause for a second. Is it OK to access the fields directly? We can argue here that it is not. The primary reason is that there is an implicit assumption that the field names represent the public interface of the object. </p>
<p>Unfortunately, such an assumption can be a little brittle in reality. As any seasoned programmer would have pointed out, software is always subject to change. <em>Always to</em> <em>change</em>. The world is not static, and requirements are not set in stone. For example, here are some possible changes that will certainly break our programming interface:</p>
<ul>
<li>Changing the field name of <kbd>heatmap</kbd> to <kbd>heatspace</kbd> because the new name is better suited for 3-dimensional or higher-dimensional data</li>
<li>Changing the data type of <kbd>stats</kbd> from a named tuple to a new <kbd>struct</kbd> type because it has grown to include more complex statistical measures and we want to develop new functions along with that</li>
<li>Removing the <kbd>stats</kbd> field altogether and computing it on the fly</li>
</ul>
<p><span>As you can see, the programming interface cannot be taken lightly. In order to build software that lasts, we need to be clear about every single interface and understand how to support them in the future.</span></p>
<p>One way to provide an interface to an object is to create assessor functions, which are sometimes called getters and setters in other programming languages. So, in the next sections, let's look at how to use them.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing getter functions</h1>
                </header>
            
            <article>
                
<p>In mainstream object-oriented languages, we often implement getters for accessing the fields of an object. In Julia, we can also create getter functions. When implementing getter functions, we can choose which fields to expose as part of the <strong>application programming interface</strong> (<strong>API</strong>). For our example, we will implement getter functions for both fields, as follows:</p>
<pre>get_heatmap(s::Simulation) = s.heatmap<br/>get_stats(s::Simulation) = s.stats</pre>
<p>Our choice of function names here is somewhat non-idiomatic for the Julia language. A better convention is to use the nouns directly:</p>
<pre>heatmap(s::Simulation) = s.heatmap<br/>stats(s::Simulation) = s.stats</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>So, when we read the code that uses the <kbd>heatmap</kbd> function, we can read it as the <em>heatmap of the simulation</em>. Likewise, we can read it as the <em>statistics of the simulation</em> when the <kbd>stats</kbd> function is used.</p>
<p>These getter functions serve the purpose of defining a formal data retrieval interface for the object. If we ever need to change the names (or even the types) of the underlying fields, it would be fine as long as the public interface does not change. Furthermore, we could even remove the <kbd>stats</kbd> field and implement the statistical calculation directly in the <kbd>stats</kbd> function. Backward compatibility can now be easily maintained for any program that uses this object.</p>
<p>Next, we will look at write access for objects.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing setter functions</h1>
                </header>
            
            <article>
                
<p>For mutable types, we may implement setters. The scope would include fields that can only ever be mutated. For our simulation project, suppose that we want to allow the client program to do some transformation of the heatmap and put it back to the object. We can support that use case easily, as shown in the following code snippet:</p>
<pre>function heatmap!(<br/>        s::Simulation{N}, <br/>        new_heatmap::AbstractArray{Float64, N}) where {N}<br/>    s.heatmap = new_heatmap<br/>    s.stats = (mean = mean(new_heatmap), std = std(new_heatmap))<br/>    return nothing<br/>end</pre>
<p>The setter function, <kbd>heatmap!</kbd>, accepts a <kbd>Simulation</kbd> object and a new heatmap array. Because the <kbd>stats</kbd> field contains the statistics of the underlying heatmap, we must maintain consistency within the object by recalculating the statistics and updating the field. Note that such a guarantee for <span>consistency </span>is only possible when we provide a setter function. Otherwise, the object would be in an inconsistent state if we ever to allow users to directly mutate the <kbd>heatmap</kbd> field in the object.</p>
<p>An additional benefit is that we can perform data validation in the setter function. For example, we can control the size of the map and throw an error when the size of the heatmap contains odd shapes:</p>
<pre>function heatmap!(<br/>            s::Simulation{N}, <br/>            new_heatmap::AbstractArray{Float64, N}) where {N}<br/>    if length(unique(size(new_heatmap))) != 1<br/>        error("All dimensions must have same size")<br/>    end<br/>    s.heatmap = new_heatmap<br/>    s.stats = (mean = mean(new_heatmap), std = std(new_heatmap))<br/>    return nothing<br/>end</pre>
<p>Here, we first determine the size of <kbd>new_heatmap</kbd>, which should be returned as a tuple. Then, we find out how many unique values are in this tuple. If there is only a single unique number in the tuple, then we know that the array is square, cubic, and so on. Otherwise, we just throw an error back to the caller.</p>
<p>Just like getter functions, setter functions serve as a public interface where the data of an object may be mutated. After we have both getter and setter functions, we can expect the caller to go through the interfaces. But the original fields can still be accessed directly. So, how do we stop that from happening? Let's explore that next.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Discouraging direct field access</h1>
                </header>
            
            <article>
                
<p>While getter and setter functions are convenient, it is easy to forget about these functions and so the program ends up accessing the fields directly. That would be too bad, as we have just spent all that effort creating getter and setter functions and they end up getting bypassed.</p>
<p>A possible solution is to discourage direct field access by renaming the fields to something that looks obviously private. A common convention is to prepend the field names with underscores.</p>
<p>For our example, we can redefine the struct as follows:</p>
<pre>mutable struct Simulation{N}<br/>    _heatmap::Array{Float64, N}<br/>    _stats::NamedTuple{(:mean, :std)}<br/>end</pre>
<p>These oddly named fields will then only be used within the implementation of the <kbd>Simulation</kbd> type, and all external usages will avoid them. Such a convention discourages the programmer from making the mistake of accessing the fields directly.</p>
<p>However, some of us may not be very satisfied with this solution because the use of a coding convention is a very weak method for enforcing the proper use of the programming interface. Such concern is very valid especially when we hold ourselves to a higher standard of software robustness. So, in the next section, we will explore a stronger technique that will allow us to control access programmatically.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Property patterns</h1>
                </header>
            
            <article>
                
<p>In this section, we will take a deep dive and learn how to enforce more granular control over the fields of an object by using the property interface. Julia's property interface allows you to provide a custom implementation for the dot notation used in field access. By overriding the standard behavior, we can apply any kind of access control and validation against the field being referenced or assigned. To illustrate this concept, we will tackle a new use case here <span>–</span> implementing a lazy file loader.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introducing the lazy file loader</h1>
                </header>
            
            <article>
                
<p><span>Suppose that we are developing a file loading facility that supports lazy loading. By lazy, we are talking about not loading a file until the content is required. </span>Let's take a look at the following code:</p>
<pre>mutable struct FileContent<br/>    path<br/>    loaded<br/>    contents<br/>end</pre>
<p>The <kbd>FileContent</kbd> <span><span>struct</span></span> contains three fields:</p>
<ul>
<li><kbd>path</kbd>: The location of the file</li>
<li><kbd>loaded</kbd>: A Boolean value that indicates whether the file has been loaded into memory</li>
<li><kbd>contents</kbd>: A byte array that contains the contents of the file</li>
</ul>
<p>Here's the constructor for the same struct:</p>
<pre>function FileContent(path) <br/>    ss = lstat(path)<br/>    return FileContent(path, false, zeros(UInt8, ss.size))<br/>end</pre>
<p>As with our current design, we pre-allocate memory for the file but we do not read the file content until later. The size of the file is determined by a call to the <kbd>lstat</kbd> function. When creating the <kbd>FileContent</kbd> object, we initialize the <kbd>loaded</kbd> field with a <kbd>false</kbd> value – an indication that the file has not been loaded into memory.</p>
<p>Eventually, we must load the file content, so we just provide a separate function that reads the file into the pre-allocated byte array:</p>
<pre>function load_contents!(fc::FileContent)<br/>    open(fc.path) do io<br/>        readbytes!(io, fc.contents)<br/>        fc.loaded = true<br/>    end<br/>    nothing<br/>end</pre>
<p>Let's run a quick test to see how it works:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/c2055393-41c1-4d8a-981f-29c97ed5b947.png" style="width:34.08em;height:8.00em;"/></p>
<p><span>Here, we have just created a new <kbd>FileContent</kbd> object. Clearly, the <kbd>loaded</kbd> field contains a <kbd>false</kbd> value because we have not read the file yet. The <kbd>content</kbd> field is also full of zeros.</span></p>
<p><span>Let's load the file content now:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/8fba08b6-09a5-48ca-b8ed-81eabeecc8e2.png" style="width:16.67em;height:14.75em;"/></p>
<p>Now, the <kbd>contents</kbd> field contains some real data, and the <kbd>loaded</kbd> field has the value of <kbd>true</kbd>. Of course, we are just babysitting and running the code manually for now. The idea is to implement lazy loading. W<span>e need a way to intercept any <em>read</em> operation into the <kbd>contents</kbd> field so</span><span> that the file content can be loaded just in time. Ideally, this should happen whenever someone uses the <kbd>fc.contents</kbd> expression.</span> In order to <em>hijack</em> the call to get <kbd>fc.contents</kbd>, we must first understand how Julia's dot notation works. Let's take a detour and go over that now.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding the dot notation for field access</h1>
                </header>
            
            <article>
                
<p>In general, whenever we need to access a specific field of an object, we can conveniently write it as <kbd>object.fieldname</kbd>. As it turns out, this notation is really <em>syntactic sugar</em>, <span>that is,</span> some <em>sweet</em> syntax, for the <kbd>getproperty</kbd> function call. To be clear, whenever we write the code in the following format:</p>
<pre>object.fieldname</pre>
<p>It is translated to a function call to <kbd>getproperty</kbd>:</p>
<pre>getproperty(object, :fieldname)</pre>
<p>For our lazy file loader example, <kbd>fc.path</kbd> is really the same as <kbd>getproperty(fc, :path)</kbd>. </p>
<p>All that magic is performed automatically by the Julia compiler. A great thing about Julia is that this kind of magic is quite transparent. We can actually see what the compiler did by using the <kbd>Meta.lower</kbd> function, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/48bcbdb0-09a0-4218-be37-12df457b886b.png" style="width:22.50em;height:8.25em;"/></p>
<p>Similarly, when we assign a value to a field of an object, the same kind of translation takes place:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/2fc46302-5481-4d5e-a462-ed0a56208428.png" style="width:33.08em;height:9.00em;"/></p>
<p>From the preceding result, we can see when the code assigns a string to <kbd>fc.path</kbd>, it is just translated to a <kbd>setproperty!(fc, :path, "/etc/hosts")</kbd> function call.</p>
<p>Let's not stop there. What do the <kbd>getproperty</kbd> and <kbd>setproperty!</kbd> functions do? Well, they happen to be plain Julia functions defined in the <kbd>Base</kbd> module. The best place to understand how they work is by examining the Julia source code itself. From the Julia REPL, we can easily bring up the source code as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/383f5807-726f-4091-bc02-ef0fcb6ccf7b.png" style="width:12.83em;height:1.67em;"/></p>
<p>From the preceding code, we can see that the <kbd>@edit</kbd> macro is used to locate the source code of the function being called <span>–</span> in this case, <kbd>getproperty</kbd>. From the REPL terminal, it should open your editor and display the code as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/aaf7c948-9132-43c7-a06d-9642db881eb9.png" style="width:62.42em;height:10.92em;"/></p>
<p><em>Aha!</em> We see that the <kbd>getproperty</kbd> function just forwards the call to <kbd>getfield</kbd>, which is used to extract the data from the object. The next line in the same source file shows the definition of <kbd>setproperty!</kbd>. The implementation of <kbd>setproperty!</kbd> is a bit more interesting. Besides using the <kbd>setfield!</kbd> function to mutate the field in the object, it also converts the <kbd>v</kbd> <span>value </span>to the type of the field in object <kbd>x</kbd>, which is determined by a call to <kbd>fieldtype</kbd>.</p>
<p class="mce-root">The <kbd>getfield</kbd> function is a built-in function for getting any field value from an existing object. It takes two arguments <span>–</span> an object and a symbol. For example, to get the path from a <kbd>FileContent</kbd> object, we can use <kbd>getfield(fc, :path)</kbd>. Likewise, the <kbd>setfield!</kbd> function is used to update any field of an existing object. Both <kbd>getfield</kbd> and <kbd>setfield!</kbd> are low-level functions in the Julia implementation.</p>
<div class="packt_infobox">Type conversion is convenient, especially for numerical types. For example, it is quite common for an object to store a <kbd>Float64</kbd> field but the code happens to pass an integer instead. Of course, the conversion logic is more general than just numeric types. For custom types, the same auto-conversion process would work fine as long as a <kbd>convert</kbd> function is defined.</div>
<p>Now that we understand how the dot notation is translated to the <kbd>getproperty</kbd> and <kbd>setproperty!</kbd> function calls, we can develop the lazy loading feature for our file loader.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing read access and lazy loading</h1>
                </header>
            
            <article>
                
<p>In order to implement lazy loading, we can extend the <kbd>getproperty</kbd> function. During the call, we can check whether the file content has been loaded yet. If not, we just load the file content right before returning the data back to the caller.</p>
<p>Extending the <kbd>getproperty</kbd> function is as easy as simply defining it with the <kbd>FileContent</kbd> type and a symbol as the arguments of the function. The following code shows this:</p>
<pre>function Base.getproperty(fc::FileContent, s::Symbol)<br/>    direct_passthrough_fields = (:path, )<br/>    if s in direct_passthrough_fields<br/>        return getfield(fc, s)<br/>    end<br/>    if s === :contents<br/>        !getfield(fc, :loaded) &amp;&amp; load_contents!(fc)<br/>        return getfield(fc, :contents)<br/>    end<br/>    error("Unsupported property: $s")<br/>end</pre>
<p>It is important that we define the function for <kbd>Base.getproperty</kbd> rather than just <kbd>getproperty</kbd>. That is because the compiler will translate the dot notation to <kbd>Base.getproperty</kbd> rather than the <kbd>getproperty</kbd> function in your own module. If this is unclear, you are encouraged to revisit the namespace concept from the <em>Understanding namespaces, modules, and packages</em> section in <a href="48061f6f-db77-4db6-9c92-d7550f4317fe.xhtml">Chapter 2</a>, <em>Modules, Packages, and Data Type Concepts</em>.</p>
<div class="packt_tip">We have chosen to put <kbd>Base</kbd> as a prefix to the function name in the definition. This style of coding is preferred because it is clear from the function definition that we are extending the <kbd>getproperty</kbd> function from the <kbd>Base</kbd> package.<br/>
<br/>
<span>Another way to extend functions from another package is to first import the third-party package. For the preceding example, we could have written it as follows. This coding style is not recommended because it is less obvious that the <kbd>getproperty</kbd> function being defined is an extension of the function from <kbd>Base</kbd>:</span><br/>
<br/>
<kbd><span>import Base: getproperty</span></kbd><br/>
<br/>
<kbd><span>function getproperty(fc::FileContent, s::Symbol)</span></kbd><br/>
<kbd><span> ....</span></kbd><br/>
<kbd><span>end</span></kbd></div>
<p>By contrast, the <kbd>getproperty</kbd> function must handle all possible property names. Let's first consider the following section of code:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/3536077d-b41a-4f7e-9e81-745554338153.png" style="width:32.08em;height:15.08em;"/></p>
<p><span>In this case, we must support</span> <kbd>:path</kbd> <span>and</span> <kbd>:contents</kbd><span>. If the</span> <kbd>s</kbd> <span>symbol is one of those fields that we want to pass through directly, then we just forward the call to the</span> <kbd>getfield</kbd> <span>function.</span></p>
<p>Now, let's consider the next section of code: </p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/29f338e3-569e-4384-8a97-116e021eb3cc.png" style="width:36.25em;height:17.00em;"/></p>
<p><span>If the symbol is </span><kbd>:contents</kbd><span>, then </span>we check the value of the<span> </span><kbd>loaded</kbd><span> field. If the <kbd>loaded</kbd> field contains <kbd>false</kbd></span>, <span>then we call the </span><kbd>load_contents!</kbd><span> function to load the file content into memory.</span></p>
<p>Note that we have used <kbd>getfield</kbd> all over the place in this function. If we had written the code using the normal dot syntax, <span>for example,</span> <kbd>fc.loaded</kbd>, then it would start calling the <kbd>getproperty</kbd> function again and we could end up with infinite recursion. </p>
<p>If the field name is not one of the supported ones, then we just raise an exception, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/01e12635-9f90-40ff-8a33-cc32779c7fb0.png" style="width:32.42em;height:15.25em;"/></p>
<p>One interesting observation is that we have decided to support two property names only – <kbd>path</kbd> and <kbd>contents</kbd> – and we have dropped the support for the <kbd>loaded</kbd> property. The reason for this is that the <kbd>loaded</kbd> field is really used as an internal state of the object. There is no reason to expose it as part of the public programming interface. As we talk about software robustness in this chapter, we can also appreciate developing code that only exposes necessary information. </p>
<div class="packt_infobox">An analogy is that data is always <em>classified</em> but can be released only on a <em>need-to-know basis, </em>which is how government officials usually like to describe highly sensitive data.</div>
<p>We are almost done. The only remaining piece of work is to refactor the <kbd>load_content!</kbd> function to use <kbd>getfield</kbd> and <kbd>setfield!</kbd> instead of the dot notation:</p>
<pre># lazy load<br/>function load_contents!(fc::FileContent)<br/>    open(getfield(fc, :path)) do io<br/>        readbytes!(io, getfield(fc, :contents))<br/>        setfield!(fc, :loaded, true)<br/>    end<br/>    nothing<br/>end</pre>
<p>We can now test the lazy loading functionality:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/89ea2112-43ec-4f69-9099-3b01caf2ea09.png" style="width:32.50em;height:15.42em;"/></p>
<p class="mce-root">Both references to the <kbd>path</kbd> and <kbd>contents</kbd> fields are working properly. In particular, a reference to <kbd>fc.contents</kbd> triggered the file load and then returned the proper content. So, what happened to the <kbd>loaded</kbd> field? Let's try it:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/5396a7f5-c50b-4a5d-b3a5-cfc8a107bb6a.png" style="width:23.00em;height:3.17em;"/></p>
<p class="mce-root"><em>Voila!</em> We have successfully prevented the <kbd>loaded</kbd> field from being accessed directly. </p>
<p>The property interface has enabled us to manage read access and implement the lazy loading feature. Next, we will look at how to manage write access as well.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Controlling write access to object fields</h1>
                </header>
            
            <article>
                
<p>In order to manage write access to the fields of an object, we can extend the <kbd>setproperty!</kbd> function, in a similar way to how we did for read access.</p>
<p>Let's recall how the <kbd>FileContent</kbd> data type was designed:</p>
<pre>mutable struct FileContent<br/>    path<br/>    loaded<br/>    contents<br/>end</pre>
<p>Suppose that we want to allow the user to switch to a different file by mutating the <kbd>path</kbd> field with a new file location. In addition to this, we want to prevent the <kbd>loaded</kbd> and <kbd>contents</kbd> fields from being changed directly using dot notation. To achieve that, we can extend the <kbd>setproperty!</kbd> function as follows:</p>
<pre>function Base.setproperty!(fc::FileContent, s::Symbol, value)<br/>    if s === :path<br/>        ss = lstat(value)<br/>        setfield!(fc, :path, value)<br/>        setfield!(fc, :loaded, false)<br/>        setfield!(fc, :contents, zeros(UInt8, ss.size))<br/>        println("Object re-initialized for $value (size $(ss.size))")<br/>        return nothing<br/>    end<br/>    error("Property $s cannot be changed.")<br/>end</pre>
<p>To extend the <kbd>setproperty!</kbd> function, we must use <kbd>setfield!</kbd> in the function definition whenever we need to change any field in the object.</p>
<p>In this case, when the user tries to assign a value to the <kbd>path</kbd> field, we can just reinitialize the object like how we did in the constructor function. This involves setting the values of the <kbd>path</kbd> and <kbd>loaded</kbd> fields, as well as pre-allocating memory space for the file content. <span>Let's go ahead and test it now:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/ea01bf9b-ac31-46f4-af99-35477c418891.png" style="width:30.17em;height:8.58em;"/></p>
<p><span>If the user tries to assign a value to any other field, an error is thrown:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/f4271bfb-0dfe-477b-9f92-193da206d57b.png" style="width:29.00em;height:3.50em;"/></p>
<p>By extending the <kbd>setproperty!</kbd> function, we have successfully controlled write access to any field for any object.</p>
<div class="packt_tip">While individual field access can be controlled, we cannot prevent additional changes to the underlying data of a field. For example, the <kbd>contents</kbd> property is just an array of bytes and the programmer should be able to change the elements in the array. I<span>f we want to protect the data from being modified, we can return</span><span> a copy of the <kbd>contents</kbd> byte array from the </span><kbd>getproperty</kbd><span> call.</span></div>
<p>By now, we know how to implement the <kbd>getproperty</kbd> and <kbd>setproperty!</kbd> functions so that we can control access to the individual fields of an object. Next, we will look at how to document what properties are available.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reporting accessible fields</h1>
                </header>
            
            <article>
                
<p>A development environment can often help a programmer to enter field names correctly. In the Julia REPL, when I press the <em>Tab</em> key twice after entering the dot character, it will try to autocomplete and display the available field names:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/3f5a7e8f-a25b-40a6-ab61-b07108a07048.png" style="width:31.75em;height:3.25em;"/></p>
<p>Now that we have implemented the <kbd>getproperty</kbd> and <kbd>setproperty!</kbd> functions, the list is no longer accurate. More specifically, the <kbd>loaded</kbd> field should not be displayed because it can neither be accessed nor changed. In order to fix this, we can simply extend the <kbd>propertynames</kbd> function, as follows:</p>
<pre>function Base.propertynames(fc::FileContent)<br/>    return (:path, :contents)<br/>end</pre>
<p>The <kbd>propertynames</kbd> function just needs to return a tuple of valid symbols. After the function is defined, the REPL will only display the valid field names, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/7f4e81eb-f9a4-491a-ad08-c14147d91c4d.png" style="width:32.67em;height:3.25em;"/></p>
<p>In this section, we have learned how to leverage Julia's property interface to control both read and write access to any field of an object. It is an essential technique to write robust programs.</p>
<div class="packt_infobox">While the use of the property interface seems to address most of the requirements we set forth earlier, it is not bulletproof. <br/>
<br/>
For example, there is nothing that prevents the program from calling the <kbd>getfield</kbd> and <kbd>setfield!</kbd> functions directly on any object. It would not be possible to completely hide that from the programmer unless the language is updated to support granular field access controls. Such a feature may be available in the future.</div>
<p>Next, we will look at some patterns related to limiting the scope of variables so that we can minimize the exposure of private variables to the outside world.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Let block patterns</h1>
                </header>
            
            <article>
                
<p>The recurring theme in this chapter is to learn how to improve and gain more control over the visibility and accessibility of data and functions in the public API. By enforcing the access of the programming interface, we can guarantee how the program is utilized. Additionally, we can focus on testing the interface as <em>advertised</em>.</p>
<p class="mce-root"/>
<p>Currently, Julia provides little help in encapsulating implementation details within a module. While we can use the <kbd>export</kbd> keyword to expose certain functions and variables to the other modules, it is not designed to be an access control or data encapsulation feature. You can always <em>peek</em> into a module and access any variable or function even when they are not exported.</p>
<p><span>In this section, we will continue the trend and go over some strategies that we can use to limit access to variables or func</span>tions in a module. Here, we will use a web crawler use case to illustrate the problem and a possible solution.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introducing the web crawler use case</h1>
                </header>
            
            <article>
                
<p>Suppose that we have to build a web crawler that can be used to index content from various websites. The process of doing that involves setting up a list of target sites and then kicking off the crawler. Let's create a module with the structure, as follows:</p>
<pre>module WebCrawler<br/><br/>using Dates<br/><br/># public interface<br/>export Target<br/>export add_site!, crawl_sites!, current_sites, reset_crawler!<br/><br/># == insert global variables and functions here ==<br/><br/>end # module</pre>
<p>Our programming interface is quite simple. Let's see how to do this:</p>
<ol>
<li><kbd>Target</kbd> is a data type that represents the website being crawled. Then, we can use the <kbd>add_site!</kbd> function to add new target sites to the list. </li>
<li>When ready, we just call the <kbd>crawl_sites!</kbd> function to visit all sites.</li>
<li>For convenience, the <kbd>current_sites</kbd> function can be used to review the current list of target sites and their crawling status.</li>
<li>Finally, the <kbd>reset_crawler!</kbd> function can be used to reset the state of the web crawler.</li>
</ol>
<p class="mce-root"/>
<p>Let's take a look at the data structure now. The <kbd>Target</kbd> type is used to maintain the URL of the target website. It also contains a Boolean variable regarding the status and the time it finished crawling. The struct is defined as follows:</p>
<pre>Base.@kwdef mutable struct Target<br/>    url::String<br/>    finished::Bool = false<br/>    finish_time::Union{DateTime,Nothing} = nothing<br/>end</pre>
<p>In order to keep track of the current target sites, a global variable is used:</p>
<pre>const sites = Target[]</pre>
<p>To complete the web crawler implementation, we have the following functions defined in the module:</p>
<pre>function add_site!(site::Target)<br/>    push!(sites, site)<br/>end<br/><br/>function crawl_sites!()<br/>    for s in sites<br/>        index_site!(s)<br/>    end<br/>end<br/><br/>function current_sites()<br/>    copy(sites)<br/>end<br/><br/>function index_site!(site::Target)<br/>    site.finished = true<br/>    site.finish_time = now()<br/>    println("Site $(site.url) crawled.")<br/>end<br/><br/>function reset_crawler!()<br/>    empty!(sites)<br/>end</pre>
<p>To use the web crawler, first, we can add some sites, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/903d8a28-7903-4c04-a716-2f2929610f1d.png" style="width:27.33em;height:12.08em;"/></p>
<p>Then, we can just run the crawler and retrieve the results afterward:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/18e6b756-5470-49a7-aa26-0067eb9913cf.png" style="width:31.92em;height:11.08em;"/></p>
<p>The current implementation is not bad, but it has the following two access-related issues:</p>
<ol>
<li>The global variable, <kbd>sites</kbd>, is visible to the outside world, which means that anyone can get a handle of the variable and mess it up, for example, by inserting a malicious website. </li>
<li>The <kbd>index_site!</kbd> function should be considered a private function and should not be included as part of the public API.</li>
</ol>
<p>Now that we have set the stage, we will demonstrate how to address these problems in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using closure to hide private variables and functions away</h1>
                </header>
            
            <article>
                
<p>Our goal is to hide the global constant, <kbd>sites</kbd>, and the helper function, <kbd>index_site!</kbd>, such that they are not visible in the public API. To achieve that, we can utilize <kbd>let</kbd> blocks.</p>
<p class="mce-root"/>
<p>In the body of the module, we can wrap all of the functions inside a <kbd>let</kbd> block, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/44aea611-8f04-4119-ba7d-0db6f3e1c93f.png" style="width:23.08em;height:35.17em;"/></p>
<p>Now, let's see what has been changed:</p>
<ul>
<li>The <kbd>sites</kbd> <span>constant </span>has been replaced by a bound variable at the beginning of the <kbd>let</kbd> block. The variables in a <kbd>let</kbd> block are bound only in the scope of the block and are not visible to the outside world.</li>
<li>The functions that need to be exposed to the API are prefixed with the <kbd>global</kbd> keyword. This includes <kbd>add_site!</kbd>, <kbd>crawl_sites!</kbd>, <kbd>current_sites</kbd>, and <kbd>reset_crawler!</kbd>. The <kbd>index_site!</kbd> function is left as-is so that it is not exposed.</li>
</ul>
<p>The <kbd>global</kbd> keyword allows us to expose the function names to the global scope of the module, which can be exported and made accessible from the public API.</p>
<p>After reloading the module, we can confirm that neither <kbd>sites</kbd> nor <kbd>index_site!</kbd> are available from the API, as shown in the following output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/dad2113a-1a01-49e0-8e2e-ae5560cdbd6d.png" style="width:28.25em;height:9.50em;"/></p>
<p>As you can see, a <kbd>let</kbd> block is an effective way to control access to global variables or functions in a module. We have the ability to encapsulate functions or variables that we want to prevent access from outside of the module.</p>
<div class="packt_tip">There may be a performance overhead when wrapping functions within a <kbd>let</kbd> block. You may want to run a performance test before using this pattern in any performance-critical section of your code.</div>
<p>As <kbd>let</kbd> blocks are quite useful in limiting the scope, we can often use it in longer scripts and functions. Next, we will look at how it is used in practice.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Limiting the variable scope for long scripts or functions</h1>
                </header>
            
            <article>
                
<p>Another usage of the let block is to limit the scope of variables in a long Julia script or function. In a long script or function, the code could be difficult to follow if we declare a variable at the top and use it throughout the body. Instead, we can write a series of let blocks, which operate independently with their own bound variables. By limiting the bounded variables in smaller blocks, we can follow the code more easily.</p>
<p>While writing long script/functions is not a generally recommended practice, we can find them occasionally in testing code, which tends to be quite repetitive. In test scripts, we may have many test cases that are grouped in the same test set. Here is an example from the <kbd>GtkUtilities</kbd> package:</p>
<pre># Source: GtkUtilities.jl/test/utils.jl<br/><br/>let c = Canvas(), win = Window(c, "Canvas1") <br/>    Gtk.draw(c) do widget<br/>        fill!(widget, RGB(1,0,0))<br/>    end<br/>    showall(win)<br/>end<br/>    <br/>let c = Canvas(), win = Window(c, "Canvas2")<br/>    Gtk.draw(c) do widget<br/>        w, h = Int(width(widget)), Int(height(widget))<br/>        randcol = reshape(reinterpret(RGB{N0f8}, rand(0x00:0xff, 3, w*h)), w, h)<br/>        copy!(widget, randcol)<br/>    end<br/>    showall(win)<br/>end <br/>    <br/>let c = Canvas(), win = Window(c, "Canvas3")<br/>    Gtk.draw(c) do widget <br/>        w, h = Int(width(widget)), Int(height(widget))<br/>        randnum = reshape(reinterpret(N0f8, rand(0x00:0xff, w*h)),w,h)<br/>        copy!(widget, randnum)<br/>    end<br/>    showall(win)<br/>end</pre>
<p>We have a few observations here from the preceding code:</p>
<ul>
<li>The <kbd>c</kbd> <span>variable </span>is bound to a new <kbd>Canvas</kbd> object every time.</li>
<li>The <kbd>win</kbd> <span>variable </span>is <span>bound to </span>a new <kbd>Window</kbd> object having a different title every time.</li>
<li>The <kbd>w</kbd>, <kbd>h</kbd>, <kbd>randcol</kbd>, and <kbd>randnum</kbd> <span>variables </span>are local variables that do not escape from their respective let blocks.</li>
</ul>
<p>By using let blocks, it does not matter how long the test script is. Every let block maintains its own scope and nothing should leak from one block to the next. This kind of programming style immediately provides some comfort to the programmer when it comes to the quality of testing code, as each testing unit is independent from each other.</p>
<p>Next, we will go over some exception handling techniques. Although it is more fun doing programming projects, exception handling is not something that we want to overlook. So, let's take a look at it next.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Exception handling patterns</h1>
                </header>
            
            <article>
                
<p>Robust software requires robust error handling practice. The fact is that an error can be raised at any time, sometimes, unexpectedly. As a responsible programmer, we need to ensure that every path of computation is taken care of, including both the <em>happy paths</em> and <em>unhappy paths</em>. Happy paths refer to program execution that runs normally as expected. Unhappy paths refer to an unexpected outcome due to error conditions.</p>
<p>In this section, we will explore several ways about to catch exceptions and recover from failures effectively.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Catching and handling exceptions</h1>
                </header>
            
            <article>
                
<p>A general technique to catch exceptions is to enclose any logic in a try-catch block. This is the easiest way to ensure that unexpected errors are handled:</p>
<pre>try<br/>    # do something that may possible raise an error<br/>catch ex<br/>    # recover from failure depending on the type of condition<br/>end</pre>
<p>A common question, however, is where this <kbd>try-catch</kbd> block should be placed. Of course, we could have just wrapped every single line of code but that would be impractical. After all, not every line of code would throw an error. </p>
<p>We do want to be smart about choosing where to catch exceptions. We know that adding exception handling increases the code size. Additionally, every line of code requires maintenance. Ironically, the less code we write, the less chance of introducing bugs. After all, we should not introduce more problems by trying to catch problems, right?</p>
<p>Next, we will look at what kind of scenarios we should consider doing error handling for.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Dealing with various types of exceptions</h1>
                </header>
            
            <article>
                
<p>The most obvious places to wrap a try-catch block are in the code blocks that we need to acquire network resources, <span>for example,</span> querying a database or connecting to a web server. Whenever the network is involved, there is a much higher chance of encountering an issue than doing something locally on the same computer.</p>
<p>It is important to understand what kind of errors can be thrown. Suppose that we continue developing the web crawler use case from the previous section. The <kbd>index_sites!</kbd> function is now implemented using the HTTP library as follows:</p>
<pre>function index_site!(site::Target)<br/>    response = HTTP.get(site.url)<br/>    site.finished = true<br/>    site.finish_time = now()<br/>    println("Site $(site.url) crawled. Status=", response.status)<br/>end</pre>
<p>The <kbd>HTTP.get</kbd> function is used to retrieve the content from the website. The code looks pretty innocent but it does not handle any error condition. For example, what happens if the site's URL is wrong or if the site is down? In those cases, we would run into a runtime exception, such as the following:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/0e573f56-ac55-4738-a2b9-48b9d2a6876c.png" style="width:37.92em;height:7.92em;"/></p>
<p>So, at a minimum, we should handle <kbd>IOError</kbd>. It turns out that the HTTP library actually does more than that. If the remote site returns any HTTP status code in the 400- or 500-series, then it also wraps the error code and raises a <kbd>StatusError</kbd> exception, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/b84bd933-2d60-4863-9bc1-2d15dd167ce2.png" style="width:38.50em;height:13.92em;"/></p>
<p>So, how do we know for sure what kind of errors can ever be thrown? Well, we can always <em>read the fine manual</em> or so-called RTFM. From the HTTP package's documentation, we can see that the following exceptions may be thrown when making HTTP requests:</p>
<ul>
<li><kbd>HTTP.ExceptionRequest.StatusError</kbd></li>
<li><kbd>HTTP.Parsers.ParseError</kbd></li>
<li><kbd>HTTP.IOExtras.IOError</kbd></li>
<li><kbd>Sockets.DNSError</kbd></li>
</ul>
<p>In Julia, the try-catch block catches all exceptions regardless of the type of exception. So, we should have the ability to handle any other exception even when it is unknown to us. Here is an example of a function that handles exceptions properly:</p>
<pre>function try_index_site!(site::Target)<br/>    try<br/>        index_site!(site)<br/>    catch ex<br/>        println("Unable to index site: $site")<br/>        if ex isa HTTP.ExceptionRequest.StatusError<br/>            println("HTTP status error (code = ", ex.status, ")")<br/>        elseif ex isa Sockets.DNSError<br/>            println("DNS problem: ", ex)<br/>        else<br/>            println("Unknown error:", ex)<br/>        end<br/>    end<br/>end</pre>
<p>We can see from the preceding code that, in the body of the <kbd>catch</kbd> block, we can check the type of exception and handle it appropriately. <span>The <kbd>else</kbd> part of the block ensures that all types of exceptions are caught, whether we know about them or not.  </span>Let's hook up the <kbd>crawl_site!</kbd> function to this new function:</p>
<pre>global function crawl_sites!()<br/>    for s in sites<br/>        try_index_site!(s)<br/>    end<br/>end</pre>
<p class="mce-root"/>
<p>We can test out the error handling code now:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/7489805c-9eba-4bae-ae58-5cec05979d27.png" style="width:40.50em;height:10.50em;"/></p>
<p>This works well!</p>
<p>So, this is one instance; what other places do we want to inject exception handling logic? Let's explore this next.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Handling exceptions at the top level</h1>
                </header>
            
            <article>
                
<p>Another place where you would normally handle exceptions is at the very top level of the program. Why? One reason is that we may want to avoid the program from crashing due to an uncaught exception. The top level of the program is the very last gate to catch anything, and the program has an option to either recover from the failure (such as doing a <em>soft reset</em>) or gracefully close all the resources and shut down.</p>
<p>When a computer program finishes execution, it normally returns an exit status back to the shell where the program was invoked. In Unix, the usual convention is to indicate successful termination with a zero status and unsuccessful termination with a nonzero status.</p>
<p>Consider the following pseudocode:</p>
<pre>try<br/>    # 1. do some work related to reading writing files<br/>    # 2. invoke an HTTP request to a remote web service<br/>    # 3. create a status report in PDF and save in a network drive<br/>catch ex<br/>    if ex isa FileNotFoundError<br/>        println("Having trouble with reading local file")<br/>        exit(1)<br/>    elseif ex isa HTTPRequestError<br/>        println("Unable to communicate with web service")<br/>        exit(2)<br/>    elseif ex isa NetworkDriveNotReadyError<br/>        println("All done, except that the report cannot be saved")<br/>        exit(3)<br/>    else<br/>        println("An unknown error has occurred, please report. Error=", ex)<br/>        exit(255)<br/>    end<br/>end</pre>
<p>We can see from the previous code that, by design, we can exit the program with a specific status code for different error conditions so that the calling program can handle the exception properly.</p>
<p>Next, we will take a look at how to determine where an exception was originally raised from a deeply nested execution frame.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Walking along the stack frames</h1>
                </header>
            
            <article>
                
<p>Often, an exception is raised from a function but it is not handled in the right away. The exception then travels to the parent calling function. If that function does not catch the exception either, it again travels to the next parent calling function. This process continues until a try-catch block catches the exception. At this point, the program's current <em>stack frame <span>–</span></em> an execution context of where the code is currently running <span>–</span> handles the exception.</p>
<p>It would be tremendously useful if we can see where the exception was originally raised. To do that, let's first try to understand how to retrieve a stack trace that is an array of stack frames. Let's create a simple set of nested function calls such that they throw an error at the end. Consider the following code:</p>
<pre>function foo1()<br/>    foo2()<br/>end<br/><br/>function foo2()<br/>    foo3()<br/>end<br/><br/>function foo3()<br/>    throw(ErrorException("bad things happened"))<br/>end</pre>
<p>Now, if we execute the <kbd>foo1</kbd> function, we should get an error, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/09030407-9dae-422a-9c0b-12dcd16f0e7a.png" style="width:22.00em;height:10.17em;"/></p>
<p>As you can see, the stack trace shows the execution sequence in reversed order. At the top of the stack trace is the <kbd>foo3</kbd> function. Because we're doing this in the REPL, we do not see a source filename; however, the number 2, as in <kbd>REPL[17]:2</kbd>, indicates that an error was thrown from line 2 of the <kbd>foo3</kbd> function.</p>
<p>Let's introduce the <kbd>stacktrace</kbd> function now. This function is part of the <kbd>Base</kbd> package and it can be used to obtain the current stack trace. As the <kbd>stacktrace</kbd> function returns an array of <kbd>StackFrame</kbd>, it would be nice if we could create a function to display it nicely. We can define a function to print the stack trace, as follows:</p>
<pre>function pretty_print_stacktrace(trace)<br/>    for (i,v) in enumerate(trace)<br/>        println(i, " =&gt; ", v)<br/>    end<br/>end</pre>
<p>As we want to handle exceptions properly, we will now update the <kbd>foo1</kbd> function by wrapping the call to <kbd>foo2</kbd> with a <kbd>try-catch</kbd> block. In the <kbd>catch</kbd> block, we will also print the stack trace so that we can further debug the issue:</p>
<pre class="mce-root">function foo1()<br/>    try<br/>        foo2()<br/>    catch<br/>        println("handling error gracefully")<br/>        pretty_print_stacktrace(stacktrace())<br/>    end<br/>end</pre>
<p>Let's run the <kbd>foo1</kbd> function now:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/943390bd-6cfb-4959-a7e3-14e81b21f1f2.png" style="width:33.08em;height:9.58em;"/></p>
<p><em>Oops!</em> What happened to <kbd>foo2</kbd> and <kbd>foo3</kbd>? The exception was thrown from <kbd>foo3</kbd> but we can no longer see them in the stack trace. This is because we have caught the exception, and from Julia's perspective, it is already handled and the current execution context is in <kbd>foo1</kbd> already.</p>
<p>In order to address this issue, there is another function in the <kbd>Base</kbd> package called <kbd>catch_backtrace</kbd>. It gives us the backtrace of the current exception so we know where the exception was originally raised. We just need to update the <kbd>foo1</kbd> function as follows:</p>
<pre>function foo1()<br/>    try<br/>        foo2()<br/>    catch<br/>        println("handling error gracefully")<br/>        pretty_print_stacktrace(stacktrace(catch_backtrace()))<br/>    end<br/>end</pre>
<p>Then, if we run <kbd>foo1</kbd> again, we get the following results, where <kbd>foo3</kbd> and <kbd>foo2</kbd> are back to the stack trace:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/633eeef5-2738-4fd7-be48-9e538be8fd04.png" style="width:35.17em;height:12.75em;"/></p>
<p>Note that the use of <kbd>catch_backtrace</kbd> must be within the <kbd>catch</kbd> block. If it is called outside of a <kbd>catch</kbd> block, it would return an empty backtrace.</p>
<p>Next, we will look at a different aspect of exception handling <span>–</span> performance impact.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding the performance impact of exception handling</h1>
                </header>
            
            <article>
                
<p>There is actually a performance overhead to use a try-catch block. In particular, if the application is doing something in a tight loop, it would be a bad idea to catch exceptions inside the loop. To understand the impact, let's try a simple example.</p>
<p>Consider the following code that simply calculates the sum of the square root of every number in an array:</p>
<pre>function sum_of_sqrt1(xs)<br/>    total = zero(eltype(xs))<br/>    for i in eachindex(xs)<br/>        total += sqrt(xs[i])<br/>    end<br/>    return total<br/>end</pre>
<p>Knowing that <kbd>sqrt</kbd> may throw <kbd>DomainError</kbd> for negative numbers, our first attempt may be to catch such exceptions inside the loop:</p>
<pre>function sum_of_sqrt2(xs)<br/>    total = zero(eltype(xs))<br/>    for i in eachindex(xs)<br/>        try<br/>            total += sqrt(xs[i])<br/>        catch<br/>            # ignore error intentionally<br/>        end<br/>    end<br/>    return total<br/>end</pre>
<p>What would be the performance impact of doing that? Let's use the <kbd>BenchmarkTools</kbd> package to measure the performance for both functions:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/1de1690f-ad25-4112-9674-c6ed3713a7cd.png" style="width:32.75em;height:6.58em;"/></p>
<p>It turns out that just wrapping the code around a try-catch block has made the loop 5 times slower! Perhaps that is not a very good deal. So, what should we do in this case? Well, we can always proactively check the number before calling the <kbd>sqrt</kbd> function and avoid the problem with negative values. Let's write a new <kbd>sum_of_sqrt3</kbd> function as follows:</p>
<pre>function sum_of_sqrt3(xs)<br/>    total = zero(eltype(xs))<br/>    for i in eachindex(xs)<br/>        if xs[i] &gt;= 0.0<br/>            total += sqrt(xs[i])<br/>        end<br/>    end<br/>    return total<br/>end</pre>
<p>Let's measure the performance again:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/9c0414ee-741b-4e9b-96af-ad9d8d9af8f9.png" style="width:22.75em;height:3.17em;"/></p>
<p><em>Fantastic!</em> We have now restored the performance. The moral of the story is that we should be smart about using try-catch blocks, especially when performance is a concern. If there is any way to avoid a try-catch block, then it would certainly be a better option whenever a higher performance is needed.</p>
<p>Next, we will explore how to perform retries, a commonly-used strategy for recovering from failures.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Retrying operations</h1>
                </header>
            
            <article>
                
<p>Sometimes, exceptions are thrown due to unexpected outages or so-called <em>hiccups</em>. It is not an uncommon scenario for a system that is highly integrated with other systems or services. For example, the trading system in a stock exchange may need to publish trade execution data to a messaging system for downstream processing. But if the messaging system experiences just a momentary outage, then the operation could fail. In that case, the most common approach is to sleep for a while and then come back and try again. If the retry fails again, then the operation will be retried again later, until the system fully recovers.</p>
<p>Such retry logic is not difficult to write. Here, we will play with an example. Suppose that we have a function that fails randomly:</p>
<pre>using Dates<br/><br/>function do_something(name::AbstractString)<br/>    println(now(), " Let's do it")<br/>    if rand() &gt; 0.5<br/>        println(now(), " Good job, $(name)!")<br/>    else<br/>        error(now(), " Too bad :-(")<br/>    end<br/>end</pre>
<p>On a good day, we would see this lovely message:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/b0a6a39f-e178-42c1-9184-753bbc6d2f69.png" style="width:24.67em;height:4.42em;"/></p>
<p>On a bad day, we would get this instead:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/1752398e-b12d-491d-8251-2b578c666f98.png" style="width:28.83em;height:4.25em;"/></p>
<p>Naively, we can develop a new function that incorporates the retry logic:</p>
<pre>function do_something_more_robustly(name::AbstractString;<br/>        max_retry_count = 3,<br/>        retry_interval = 2)<br/>    retry_count = 0<br/>    while true<br/>        try<br/>            return do_something(name)<br/>        catch ex<br/>            sleep(retry_interval)<br/>            retry_count += 1<br/>            retry_count &gt; max_retry_count &amp;&amp; rethrow(ex)<br/>        end<br/>    end<br/>end</pre>
<p>This function just calls the <kbd>do_something</kbd> function. If it encounters an exception, it will wait 2 seconds as specified in the <kbd>retry_interval</kbd> keyword argument and try again. It keeps a track of a counter in <kbd>retry_count</kbd>, and so it will just retry up to 3 times by default, as indicated by the <kbd>max_retry_count</kbd> keyword argument:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/fe6d01e6-df13-453d-bc4b-076bc15dcba1.png" style="width:26.75em;height:7.00em;"/></p>
<p>Of course, this code is fairly straightforward and easy to write. But we will get bored quickly if we do this over and over again for many functions. It turns out that Julia comes with a <kbd>retry</kbd> function that solves this problem nicely. We can achieve the exact same functionality with a single line of code:</p>
<pre>retry(do_something, delays=fill(2.0, 3))("John")</pre>
<p>The <kbd>retry</kbd> function takes a function as the first argument. The <kbd>delays</kbd> keyword argument can be any object that supports the iteration interface. In this case, we have provided an array of 3 elements, each containing the number of 2.0. The return value of the <kbd>retry</kbd> function is an anonymous function that takes any number of arguments. Those arguments will be <em>fed</em> into the original function that needs to be called, in this case, <kbd>do_something</kbd>. Here is how it looks using the <kbd>retry</kbd> function:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/bb0f8e8e-da80-40a7-ada7-e1b06359c05b.png" style="width:37.42em;height:7.17em;"/></p>
<p>Since the <kbd>delays</kbd> argument can contain any number, we could utilize a different strategy that comes back with a different waiting time. A common usage is that we would want to retry quickly (<span>that is,</span> sleep less) in the beginning but slow down over time. When connecting to a remote system, it is possible that the remote system is just having a short hiccup, or perhaps it is undergoing an extended outage. In the latter scenario, it does not make sense to flood the system with quick requests as it would be a waste of system resources and get the water muddier when it is already in a mess.</p>
<p>In fact, the default value for the <kbd>delays</kbd> argument is <kbd>ExponentialBackOff</kbd>, which iterates by exponentially increasing the delay time. On a very unlucky day, using <kbd>ExponentialBackOff</kbd> yields the following pattern:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/8aa79787-65c4-4daf-acf8-485426df83b0.png" style="width:39.00em;height:10.92em;"/></p>
<p>Let's pay attention to the wait time between retries. The result should match the default setting of <span><kbd>ExponentialBackOff</kbd> </span>as seen from its signature:</p>
<pre>ExponentialBackOff(; n=1, first_delay=0.05, max_delay=10.0, factor=5.0, jitter=0.1)</pre>
<p>The keyword argument, <kbd>n</kbd>, indicates the number of retries, for which we used the value of 10 in the preceding code. The first retry comes after 0.05 seconds. Then, for every retry, the time of delay grows by a factor of 5 up until it hits a maximum of 10 seconds. The growth rate may be jittered by 10%.</p>
<p>The <kbd>retry</kbd> function is often overlooked but it is a very convenient and powerful way to make the system more robust.</p>
<p>It is easy to throw an exception when something goes wrong. But that's not the only way to handle error conditions. <span>In the next section, we will discuss the concepts of exceptions versus normal negative conditions.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Choosing nothing over exceptions</h1>
                </header>
            
            <article>
                
<p>Given the powerful features of a try-catch block, it is sometimes tempting to handle all negative scenarios with <kbd>Exception</kbd> types. In practice, we want to be very clear about what is truly an exception and what is a normal negative case.</p>
<p>We can turn to the <kbd>match</kbd> function as an example. The <kbd>match</kbd> function from the <kbd>Base</kbd> package can be used to match a regular expression against a string. If there is a match, then it returns a <span class="s1"><kbd>RegexMatch</kbd> object, which contains the captured results. Otherwise, it returns <kbd>nothing</kbd>. The following example illustrates this effect:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e20d6812-ac03-463d-bc3c-f0632ff86b94.png" style="width:26.75em;height:6.67em;"/></p>
<p>The first <kbd>match</kbd> function call returned a <kbd>RegexMatch</kbd> object because it found that <kbd>google.com</kbd> ends with <kbd>.com</kbd>. The second call could not find any match and so it returned <kbd>nothing</kbd>.</p>
<p><span class="s1">By design, the <kbd>match</kbd> function does not throw any exception. Why not? One reason for this is that the function is frequently used for checking whether a string contains another string and then the program decides what to do either way. Doing that would require a simple <kbd>if</kbd> statement; for instance, refer to the following code:</span></p>
<pre>url = "http://google.com"<br/>if match(r"\.com$", url) !== nothing<br/>    # do something about .com sites<br/>elseif match(r"\.org$", url) !== nothing<br/>    # do something about .org sites<br/>else <br/>    # do something different<br/>end</pre>
<p><span>If it were to throw an exception instead, then our code would have to look different, as follows:</span></p>
<pre>url = "http://google.com"<br/>try <br/>    match(r"\.com$", url)<br/>    # do something about .com sites<br/>catch ex1<br/>    try<br/>        match(r"\.org$", url)<br/>        # do something about .org sites<br/>    catch ex2 <br/>        # do something different<br/>    end<br/>end</pre>
<p>As you can see, the code can get very ugly very quickly using a try-catch block.</p>
<p>When designing a programming interface, we should always think about whether an exception is truly an exception or whether it could be just a negative status. In the case of the match function, a negative case is effectively represented by nothing.</p>
<p>In this section, we learned where to place try-catch blocks in our code. Now we should be able to properly catch exceptions and examine the stack frames.</p>
<p>We have come to understand better how performance may be impacted by the exception-handling code. Based on our understanding, we should be able to design and develop more robust software.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we have learned about the various patterns and techniques for building robust software. While Julia is a great language for quick prototypes and research projects, it has all the features to build robust, mission-critical systems.</p>
<p>We began our journey with the idea of encapsulating data with accessor functions, which allow us to design a formal API that we can support. We also discussed a naming convention that discourages people from accessing the internal state of the object.</p>
<p class="mce-root">We looked at Julia's property interface, which allows us to implement new <em>meanings</em> whenever the field access dot notation is used. By extending the <kbd>getproperty</kbd> and <kbd>setproperty!</kbd> functions, we are able to control both read and write access to the fields of an object.</p>
<p>We also learned how to hide specific variables or functions defined in a module. This strategy can be utilized whenever we want to have tighter control of the visibility of variables and functions of a module.</p>
<p>Finally, we wanted to <em>take exception handling seriously!</em> We know robust software needs to be able to handle all kinds of exceptions. We dived deep into the try-catch process and learned how to determine the stack trace properly. We have proved that performance can be negatively impacted by the use of a try-catch block, so we need to be diligent about where to apply exception handling logic. We also learned how to use the standard <kbd>retry</kbd> function as a recovery strategy.</p>
<p>In the next chapter, we will go over a few more miscellaneous patterns commonly used in the Julia programs.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"> Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>What are the benefits of developing assessor functions?</li>
<li>What would be an easy way to discourage the use of internal fields of an object?</li>
<li>Which functions may to be extended as part of the property interface?</li>
<li>How can we capture the stack trace from a catch block after an exception has been caught?</li>
<li>What is the best way to avoid the performance impact of a try-catch block for a system that requires optimal performance?</li>
<li>What is the benefit of using the retry function?</li>
<li class="mce-root">How do we hide away global variables and functions that are used internally in a module?</li>
</ol>


            </article>

            
        </section>
    </body></html>