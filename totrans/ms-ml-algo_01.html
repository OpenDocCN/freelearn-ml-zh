<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Machine Learning Model Fundamentals</h1>
                </header>
            
            <article>
                
<p class="mce-root">Machine learning models are mathematical systems that share many common features. Even if, sometimes, they have been defined only from a theoretical viewpoint, research advancement allows us to apply several concepts to better understand the behavior of complex systems such as deep neural networks. In this chapter, we're going to introduce and discuss some fundamental elements that some skilled readers may already know, but that, at the same time, offer several possible interpretations and applications.</p>
<p>In particular, in this chapter we're discussing the main elements of:</p>
<ul>
<li>Data-generating processes</li>
<li>Finite datasets</li>
<li>Training and test split strategies</li>
<li>Cross-validation</li>
<li>Capacity, bias, and variance of a model</li>
<li><span>Vapnik-Chervonenkis theory</span></li>
<li>Cramér-Rao bound</li>
<li>Underfitting and overfitting</li>
<li>Loss and cost functions</li>
<li>Regularization</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Models and data</h1>
                </header>
            
            <article>
                
<p>Machine learning algorithms work with data. They create associations, find out relationships, discover patterns, generate new samples, and more, working with well-defined datasets. Unfortunately, sometimes the assumptions or the conditions imposed on them are not clear, and a lengthy training process can result in a complete validation failure. Even if this condition is stronger in deep learning contexts, we can think of a model as a gray box (some transparency is guaranteed by the simplicity of many common algorithms), where a vectorial input <img class="fm-editor-equation" src="assets/87da3ad2-7943-4a36-a94e-8af0883a59d2.png" style="width:1.08em;height:1.25em;"/> is transformed into a vectorial output <img class="fm-editor-equation" src="assets/a806507f-a7c6-41d8-95cd-609553341d11.png" style="width:0.92em;height:1.17em;"/>:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/d25b3444-8930-4e86-ae2e-46e3a2da5c0a.png" style="width:26.83em;height:9.67em;"/></div>
<div class="mce-root CDPAlignCenter CDPAlign packt_figref">Schema of a generic model parameterized with the vector θ</div>
<p>In the previous diagram, the model has been represented by a pseudo-function that depends on a set of parameters defined by the vector <em>θ</em>. In this section, we are only considering<span> </span><strong>parametric</strong><span> </span>models, although there's a family of algorithms that are called<span> </span><strong>non-parametric</strong>, because they are based only on the structure of the data. We're going to discuss some of them in upcoming chapters.</p>
<p>The task of a parametric learning process is therefore to find the best parameter set that maximizes a target function whose value is proportional to the accuracy (or the error, if we are trying to minimize them) of the model given a specific input <em>X</em> and output <em>Y</em>. This definition is not very rigorous, and it will be improved in the following sections; however, it's useful as a way to understand the context we're working in.</p>
<p>Then, the first question to ask is: What is the nature of <em>X</em>? A machine learning problem is focused on learning abstract relationships that allow a consistent generalization when new samples are provided. More specifically, we can define a stochastic <strong>data generating process</strong> with an associated joint probability distribution:</p>
<p class="mce-root CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/59525165-8c76-456b-af1a-2125fbd9e19d.png" style="width:12.33em;height:1.42em;"/></p>
<p>Sometimes, it's useful to express the joint probability <em>p(x, y)</em> as a product of the conditional <em>p(y|x)</em>, which expresses the probability of a label given a sample, and the marginal probability of the samples <em>p(x)</em>. This expression is particularly useful when the prior probability <em>p(x)</em> is known in semi-supervised contexts, or when we are interested in solving problems using the <strong>Expectation Maximization</strong> (<strong>EM</strong>) algorithm. We're going to discuss this approach in upcoming chapters.</p>
<p>In many cases, we are not able to derive a precise distribution; however, when considering a dataset, we always assume that it's drawn from the original data-generating distribution. This condition isn't a purely theoretical assumption, because, as we're going to see, whenever our data points are drawn from different distributions, the accuracy of the model can dramatically decrease.</p>
<p>If we sample N <strong>independent and identically distributed</strong> (<span><strong>i.i.d.</strong>)</span> values from <em>p<sub>data</sub></em>, we can create a finite dataset <em>X</em> made up of <em>k</em>-dimensional real vectors:</p>
<p class="mce-root CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/c8318f7c-62e5-4071-982f-71a9ae0d688d.png" style="width:19.00em;height:1.67em;"/></p>
<p>In a supervised scenario, we also need the corresponding labels (with <em>t</em> output values):</p>
<p class="mce-root CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/e8002640-408e-4bc8-9833-24c97d03f68f.png" style="width:21.25em;height:1.75em;"/></p>
<p>When the output has more than two classes, there are different possible strategies to manage the problem. In classical machine learning, one of the most common approaches is <strong>One-vs-All</strong>, which is based on training <em>N</em> different binary classifiers where each label is evaluated against all the remaining ones. In this way, <em>N-1</em> is performed to determine the right class. With shallow and deep neural networks, instead, it's preferable to use a <strong>softmax</strong> function to represent the output probability distribution for all classes:</p>
<p class="mce-root CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/261fd2dc-9e54-428c-8ce5-67fe2215b76e.png" style="width:19.67em;height:3.67em;"/></p>
<p>This kind of output (<em>z<sub>i</sub></em> represents the intermediate values, and the sum of the terms is normalized to <em>1</em>) can be easily managed using the cross-entropy cost function (see the corresponding paragraph in the <em>Loss and cost functions</em> section). </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Zero-centering and whitening</h1>
                </header>
            
            <article>
                
<p>Many algorithms show better performances (above all, in terms of training speed) when the dataset is symmetric (with a zero-mean). Therefore, one of the most important preprocessing steps is so-called <strong>zero-centering</strong>, which consists in subtracting the feature-wise mean <em>E<sub>x</sub>[X]</em> from all samples:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/f19a895a-0cad-4bbc-b15f-7c52a2638ce3.png" style="width:8.92em;height:1.50em;"/></p>
<p>This operation, if necessary, is normally reversible, and doesn't alter relationships both among samples and among components of the same sample. In deep learning scenarios, a zero-centered dataset allows exploiting the symmetry of some activation function, driving to a faster convergence (we're going to discuss these details in the next chapters).</p>
<p>Another very important preprocessing step is called <strong>whitening</strong>, which is the operation of imposing an identity covariance matrix to a zero-centered dataset:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/991b3e6d-7b6a-4361-92bb-8c2c3109369c.png" style="width:5.75em;height:1.25em;"/></p>
<p>As the covariance matrix <em>E<sub>x</sub>[X<sup>T</sup>X]</em> is real and symmetric, it's possible to eigendecompose it without the need to invert the eigenvector matrix:</p>
<p class="mce-root CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/e8ed1207-a036-4a11-a809-c009cfe887b9.png" style="width:8.50em;height:1.42em;"/></p>
<p>The matrix <em>V</em> contains the eigenvectors (as columns), and the diagonal matrix <em>Ω</em> contains the eigenvalues. To solve the problem, we need to find a matrix <em>A,</em> such that:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/dccb1256-8529-4988-a046-e19a5f415b1b.png" style="width:13.17em;height:1.58em;"/></p>
<p>Using the eigendecomposition previously computed, we get:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/cff39904-0475-4866-a9a2-2239b7914843.png" style="width:31.83em;height:1.75em;"/></p>
<p>Hence, the matrix <em>A</em> is:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/0ee7bf5c-1e51-4b78-ab6b-1c745f68d0b9.png" style="width:15.92em;height:1.67em;"/></p>
<p>One of the main advantages of whitening is the decorrelation of the dataset, which allows an easier separation of the components. Furthermore, if <em>X</em> is whitened, any orthogonal transformation induced by the matrix <em>P</em> is also whitened:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/622c081f-b106-4d0c-bbef-7ce9240d4da7.png" style="width:24.17em;height:1.50em;"/></p>
<p>Moreover, many algorithms that need to estimate parameters that are strictly related to the input covariance matrix can benefit from this condition, because it reduces the actual number of independent variables (in general, these algorithms work with matrices that become symmetric after applying the whitening). Another important advantage in the field of deep learning is that the gradients are often higher around the origin, and decrease in those areas where the activation functions (for example, the hyperbolic tangent or the sigmoid) saturate <em>(|x| → ∞)</em>. That's why the convergence is generally faster for whitened (and zero-centered) datasets. </p>
<p><span>In the following graph, it's possible to compare an <strong>original dataset</strong>,</span> <strong>zero-centering</strong>, and <strong>whitening</strong><span>:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/8e2be8a1-6ba2-4eab-aa40-ec1a0b1960d7.png"/></div>
<div class="mce-root CDPAlignCenter CDPAlign packt_figref">Original dataset (left), centered version (center), whitened version (right)</div>
<p>When a whitening is needed, it's important to consider some important details. The first one is that there's a scale difference between the real sample covariance and the estimation <em>X<sup>T</sup>X,</em> often adopted with the <strong>singular value decomposition</strong> (<strong>SVD</strong>). The second one concerns some common classes implemented by many frameworks, like Scikit-Learn's <kbd>StandardScaler</kbd>. In fact, while zero-centering is a feature-wise operation, a whitening filter needs to be computed considering the whole covariance matrix (<kbd>StandardScaler</kbd> implements only unit variance, feature-wise scaling).</p>
<p>Luckily, all Scikit-Learn algorithms that benefit from or need a whitening preprocessing step provide a built-in feature, so no further actions are normally required; however, for all readers who want to implement some algorithms directly, I've written two Python functions that can be used both for zero-centering and whitening. They assume a matrix <em>X</em> with a shape (<em>N<sub>Samples</sub> × n</em>). Moreover, the <kbd>whiten()</kbd> function accepts the parameter <kbd>correct</kbd>, which allows us to apply the scaling correction (the default value is <kbd>True</kbd>):</p>
<pre>import numpy as np<br/><br/>def zero_center(X):<br/>    return X - np.mean(X, axis=0)<br/><br/>def whiten(X, correct=True):<br/>    Xc = zero_center(X)<br/>    _, L, V = np.linalg.svd(Xc)<br/>    W = np.dot(V.T, np.diag(1.0 / L))<br/>    return np.dot(Xc, W) * np.sqrt(X.shape[0]) if correct else 1.0</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Training and validation sets</h1>
                </header>
            
            <article>
                
<p>In real problems, the number of samples is limited, and it's usually necessary to split the initial set <em>X</em> (together with <em>Y</em>) into two subsets as follows:</p>
<ul>
<li><strong>Training set</strong> used to train the model</li>
<li><strong>Validation set</strong> used to assess the score of the model without any bias, with samples never seen before</li>
</ul>
<p>According to the nature of the problem, it's possible to choose a split percentage ratio of 70% – 30% (a good practice in machine learning, where the datasets are relatively small), or a higher training percentage (80%, 90%, up to 99%) for deep learning tasks where the number of samples is very high. In both cases, we are assuming that the training set contains all the information required for a consistent generalization. In many simple cases, this is true and can be easily verified; but with more complex datasets, the problem becomes harder. Even if we think to draw all the samples from the same distribution, it can happen that a randomly selected test set contains features that are not present in other training samples. Such a condition can have a very negative impact on global accuracy and, without other methods, it can also be very difficult to identify. This is one of the reasons why, in deep learning, training sets are huge: considering the complexity of the features and structure of the data generating distributions, choosing large test sets can limit the possibility of learning particular associations.</p>
<p>In Scikit-Learn, it's possible to split the original dataset using the <strong><kbd>train_test_split()</kbd></strong> function, which allows specifying the train/test size, and if we expect to have randomly shuffled sets (default). For example, if we want to split <kbd>X</kbd> and <kbd>Y</kbd>, with 70% training and 30% test, we can use:</p>
<pre>from sklearn.model_selection import train_test_split<br/><br/>X_train, X_test, Y_train, Y_test = train_test_split(X, Y, train_size=0.7, random_state=1)</pre>
<p>Shuffling the sets is always a good practice, in order to reduce the correlation between samples. In fact, we have assumed that <kbd>X</kbd> is made up of i.i.d samples, but several times two subsequent samples have a strong correlation, reducing the training performance. In some cases, it's also useful to re-shuffle the training set after each training epoch; however, in the majority of our examples, we are going to work with the same shuffled dataset throughout the whole process. Shuffling has to be avoided when working with sequences and models with memory: in all those cases, we need to exploit the existing correlation to determine how the future samples are distributed. </p>
<div class="packt_tip">When working with NumPy and Scikit-Learn, it's always a good practice to set the random seed to a constant value, so as to allow other people to reproduce the experiment with the same initial conditions. This can be achieved by calling <kbd>np.random.seed</kbd>(...) and using the <kbd>random-state</kbd> parameter present in many Scikit-Learn methods. </div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Cross-validation</h1>
                </header>
            
            <article>
                
<p>A valid method to detect the problem of wrongly selected test sets is provided by the <strong>cross-validation</strong> technique. In particular, we're going to use the <strong>K-Fold</strong> cross-validation approach. The idea is to split the whole dataset <em>X</em> into a moving test set and a training set (the remaining part). The size of the test set is determined by the number of folds so that, during <em>k</em> iterations, the test set covers the whole original dataset.</p>
<p>In the following diagram, we see a schematic representation of the process:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/612f3964-c562-4515-8f33-0cd32d825f0e.png" style="width:33.33em;height:23.33em;"/></div>
<div class="mce-root CDPAlignCenter CDPAlign packt_figref">K-Fold cross-validation schema</div>
<p>In this way, it's possible to assess the accuracy of the model using different sampling splits, and the training process can be performed on larger datasets; in particular, on <em>(k-1)*N</em> samples. In an ideal scenario, the accuracy should be very similar in all iterations; but in most real cases, the accuracy is quite below average. This means that the training set has been built excluding samples that contain features necessary to let the model fit the separating hypersurface considering the real <em>p<sub>data</sub></em>. We're going to discuss these problems later in this chapter; however, if the standard deviation of the accuracies is too high (a threshold must be set according to the nature of the problem/model), that probably means that <em>X</em> hasn't been drawn uniformly from <em>p<sub>data</sub>,</em> and it's useful to evaluate the impact of the outliers in a preprocessing stage. In the following graph, we see the plot of a 15-fold cross-validation performed on a logistic regression:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/27cd7180-d499-4e47-a364-33f20542a1b8.png" style="width:40.58em;height:24.75em;"/></div>
<div class="mce-root CDPAlignCenter CDPAlign packt_figref"> Cross-validation accuracies</div>
<p>The values oscillate from 0.84 to 0.95, with an average (solid horizontal line) of 0.91. In this particular case, considering the initial purpose was to use a linear classifier, we can say that all folds yield high accuracies, confirming that the dataset is linearly separable; however, there are some samples (excluded in the ninth fold) that are necessary to achieve a minimum accuracy of about 0.88. </p>
<p><strong>K-Fold</strong> cross-validation has different variants that can be employed to solve specific problems:</p>
<ul>
<li><strong>Stratified K-Fold</strong>: A <strong>Standard K-Fold</strong> approach splits the dataset without considering the probability distribution <em>p(y|x)</em>, therefore some folds may theoretically contain only a limited number of labels. Stratified K-Fold, instead, tries to split <em>X</em> so that all the labels are equally represented.</li>
</ul>
<ul>
<li><strong>Leave-one-out</strong> (<strong>LOO</strong>): This approach is the most drastic because it creates <em>N</em> folds, each of them containing <em>N-1</em> training samples and only 1 test sample. In this way, the maximum possible number of samples is used for training, and it's quite easy to detect whether the algorithm is able to learn with sufficient accuracy, or if it's better to adopt another strategy. The main drawback of this method is that <em>N</em> models must be trained, and when <em>N</em> is very large this can cause a performance issue. Moreover, with a large number of samples, the probability that two random values are similar increases, therefore many folds will yield almost identical results. At the same time, LOO limits the possibilities for assessing the generalization ability, because a single test sample is not enough for a reasonable estimation.</li>
<li><strong>Leave-P-out</strong> (<strong>LPO</strong>): In this case, the number of test samples is set to <em>p</em> (non-disjoint sets), so the number of folds is equal to the binomial coefficient of <em>n</em> over <em>p</em>. This approach mitigates LOO's drawbacks, and it's a trade-off between K-Fold and LOO. The number of folds can be very high, but it's possible to control it by adjusting the number <em>p</em> of test samples; however, if <em>p</em> isn't small or big enough, the binomial coefficient can <em>explode</em>. In fact, when <em>p</em> has about <em>n/2</em> samples, the number of folds is maximal:</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/429214fd-f1af-4070-8f50-4d4ff051c3a8.png" style="width:27.33em;height:3.50em;"/></p>
<p class="mce-root">Scikit-Learn implements all those methods (with some other variations), but I suggest always using the <kbd>cross_val_score()</kbd> function, which is a helper that allows applying the different methods to a specific problem. In the following snippet based on a polynomial <strong>Support Vector Machine</strong> (<strong>SVM</strong>) and the MNIST digits dataset, the function is applied specifying the number of folds (parameter <kbd>cv</kbd>). In this way, Scikit-Learn will automatically use Stratified K-Fold for categorical classifications, and <strong>Standard K-Fold</strong> for all other cases:</p>
<pre>from sklearn.datasets import load_digits<br/>from sklearn.model_selection import cross_val_score<br/>from sklearn.svm import SVC<br/><br/>data = load_digits()<br/>svm = SVC(kernel='poly')<br/><br/>skf_scores = cross_val_score(svm, data['data'], data['target'], cv=10)<br/><br/>print(skf_scores)<br/>[ 0.96216216  1.          0.93922652  0.99444444  0.98882682  0.98882682
  0.99441341  0.99438202  0.96045198  0.96590909]<br/><br/>print(skf_scores.mean())<br/>0.978864325583<strong><br/></strong></pre>
<p>The accuracy is very high (&gt; 0.9) in every fold, therefore we expect to have even higher accuracy using the LOO method. As we have 1,797 samples, we expect the same number of accuracies:</p>
<pre>from sklearn.model_selection import cross_val_score, LeaveOneOut<br/><br/>loo_scores = cross_val_score(svm, data['data'], data['target'], cv=LeaveOneOut())<br/><br/>print(loo_scores[0:100])<br/>[ 1.  1.  1.  1.  1.  0.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.
  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.
  1.  0.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.
  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  0.  1.  1.
  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.
  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.]<br/><br/>print(loo_scores.mean())<br/>0.988870339455</pre>
<p>As expected, the average score is very high, but there are still samples that are misclassified. As we're going to discuss, this situation could be a potential candidate for overfitting, meaning that the model is learning perfectly how to map the training set, but it's losing its ability to generalize; however, LOO is not a good method to measure this model ability, due to the size of the validation set.</p>
<p>We can now evaluate our algorithm with the LPO technique. Considering what was explained before, we have selected the smaller Iris dataset and a classification based on a logistic regression. As there are <em>N=150</em> samples, choosing <kbd>p = 3</kbd>, we get 551,300 folds:</p>
<pre>from sklearn.datasets import load_iris<br/>from sklearn.linear_model import LogisticRegression<br/>from sklearn.model_selection import cross_val_score, LeavePOut<br/><br/>data = load_iris()<br/><br/>p = 3<br/>lr = LogisticRegression()<br/><br/>lpo_scores = cross_val_score(lr, data['data'], data['target'], cv=LeavePOut(p))<br/><br/>print(lpo_scores[0:100])<br/>[ 1.          1.          1.          1.          1.          1.          1.
  1.          1.          1.          1.          1.          1.          1.
  1.          1.          1.          1.          1.          1.          1.
  1.          1.          1.          1.          1.          1.          1.
  1.          1.          1.          1.          1.          1.          1.
  1.          1.          1.          1.          1.          1.          1.
  1.          1.          1.          1.          1.          1.          1.
  1.          1.          1.          1.          1.          1.          1.
  1.          1.          1.          1.          1.          1.          1.
  1.          0.66666667  ...<br/><br/>print(lpo_scores.mean())<br/>0.955668420098</pre>
<p>As in the previous example, we have printed only the first 100 accuracies; however, the global trend can be immediately understood with only a few values.</p>
<p>The cross-validation technique is a powerful tool that is particularly useful when the performance cost is not too high. Unfortunately, it's not the best choice for deep learning models, where the datasets are very large and the training processes can take even days to complete. However, as we're going to discuss, in those cases the right choice (the split percentage), together with an accurate analysis of the datasets and the employment of techniques such as normalization and regularization, allows fitting models that show an excellent generalization ability. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Features of a machine learning model</h1>
                </header>
            
            <article>
                
<p>In this section, we're going to consider supervised models, and try to determine how it's possible to measure their theoretical potential accuracy and their ability to generalize correctly over all possible samples drawn from <em>p<sub>data</sub></em>. The majority of these concepts were developed before the <em>deep learning age</em>, but continue to have an enormous influence on research projects. The idea of <em>capacity</em>, for example, is an open-ended question that neuroscientists keep on asking themselves about the human brain. Modern deep learning models with dozens of layers and millions of parameters reopened the theoretical question from a mathematical viewpoint. Together with this, other elements, like the limits for the variance of an estimator, again attracted the limelight because the algorithms are becoming more and more powerful, and performances that once were considered far from any feasible solution are now a reality. Being able to train a model, so as to exploit its full capacity, maximize its generalization ability, and increase the accuracy, overcoming even human performances, is what a deep learning engineer nowadays has to expect from his work.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Capacity of a model</h1>
                </header>
            
            <article>
                
<p>If we consider a supervised model as a set of parameterized functions, we can define <strong>representational capacity</strong> as the intrinsic ability of a certain generic function to map a relatively large number of data distributions. To understand this concept, let's consider a function <em>f(x)</em> that admits infinite derivatives, and rewrite it as a Taylor expansion:</p>
<p class="mce-root CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/c398523d-8a07-40b9-808e-75bcf7d8ce2a.png" style="width:43.75em;height:3.67em;"/></p>
<p>We can decide to take only the first <em>n</em> terms, so to have an <em>n</em>-degree polynomial function. Consider a simple bi-dimensional scenario with six functions (starting from a linear one); we can observe the different behavior with a small set of data points:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/35abc6b6-9950-4d97-928d-4e5c0e9188a0.png" style="width:40.42em;height:23.83em;"/></div>
<div class="mce-root CDPAlignCenter CDPAlign packt_figref">Different behavior produced by six polynomial separating curves</div>
<p>The ability to rapidly change the curvature is proportional to the degree. If we choose a linear classifier, we can only modify its slope (the example is always in a bi-dimensional space) and the intercept. Instead, if we pick a higher-degree function, we have more possibilities to <em>bend</em> the curvature when it's necessary. If we consider <strong>n=1</strong> and <strong>n=2</strong> in the plot (on the top-right, they are the first and the second functions), with <strong>n=1</strong>, we can include the dot corresponding to <em>x=11</em>, but this choice has a negative impact on the dot at <em>x=5</em>.</p>
<p>Only a parameterized non-linear function can solve this problem efficiently, because this simple problem requires a representational capacity higher than the one provided by linear classifiers. Another classical example is the XOR function. For a long time, several researchers opposed perceptrons (linear neural networks), because they weren't able to classify a dataset generated by the XOR function. Fortunately, the introduction of multilayer perceptrons, with non-linear functions, allowed us to overcome this problem, and many whose complexity is beyond the possibilities of any classic machine learning model.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Vapnik-Chervonenkis capacity</h1>
                </header>
            
            <article>
                
<p> A mathematical formalization of the capacity of a classifier is provided by the <strong>Vapnik-Chervonenkis theory</strong>. To introduce the definition, it's first necessary to define the concept of <strong>shattering</strong>. If we have a class of sets <em>C</em> and a set <em>M</em>, we say that <em>C</em> shatters <em>M</em> if:</p>
<p class="mce-root CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/80c863ff-90ee-47a2-b994-702c455c4256.png" style="width:20.08em;height:1.50em;"/></p>
<p>In other words, given any subset of <em>M</em>, it can be obtained as the intersection of a particular instance of <em>C (c<sub>j</sub>)</em> and <em>M</em> itself. If we now consider a model as a parameterized function:</p>
<p class="mce-root CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/cca58a91-5886-45c6-8e00-c6851c414995.png" style="width:11.67em;height:1.42em;"/></p>
<p>We want to determine its capacity in relation to a finite dataset <em>X</em>:</p>
<p class="mce-root CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/043d5bff-1238-4688-bfe2-af3f015df786.png" style="width:20.83em;height:1.83em;"/></p>
<p>According to the Vapnik-Chervonenkis theory, we can say that the model <em>f</em> shatters <em>X</em> if there are no classification errors for every possible label assignment. Therefore, we can define the <strong>Vapnik-Chervonenkis-capacity</strong> or <strong>VC-capacity</strong> (sometimes called <strong>VC-dimension</strong>) as the maximum cardinality of a subset of <em>X</em> so that <em>f</em> can shatter it.</p>
<p>For example, if we consider a linear classifier in a bi-dimensional space, the VC-capacity is equal to 3, because it's always possible to label three samples so that <em>f</em> shatters them; however, it's impossible to do it in all situations where <em>N &gt; 3</em>. The XOR problem is an example that needs a VC-capacity higher than <em>3</em>. Let's explore the following plot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/7bae2238-7baf-40be-ba8d-bdd5bf6e5c78.png" style="width:25.67em;height:24.17em;"/></div>
<div class="mce-root CDPAlignCenter CDPAlign packt_figref">XOR problem with different separating curves</div>
<p>This particular label choice makes the set non-linearly separable. The only way to overcome this problem is to use higher-order functions (or non-linear ones). The curve lines (belonging to a classifier whose VC-capacity is greater than <em>3</em>) can separate both the upper-left and the lower-right regions from the remaining space, but no straight line can do the same (while it can always separate one point from the other three).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Bias of an estimator</h1>
                </header>
            
            <article>
                
<p class="mce-root">Let's now consider a parameterized model with a single vectorial parameter (this isn't a limitation, but only a didactic choice):</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/265f15b6-0886-46fa-a7a7-52bce47a74bf.png" style="width:3.67em;height:1.42em;"/></p>
<p class="mce-root">The goal of a learning process is to estimate the parameter <em>θ</em> so as, for example, to maximize the accuracy of a classification. We define the <strong>bias of an estimator</strong> (in relation to a parameter <em>θ</em>):</p>
<p class="mce-root CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/401cedb3-a8cc-4622-beaa-8cc42a42960c.png" style="width:26.17em;height:4.17em;"/></p>
<p>In other words, the bias is the difference between the expected value of the estimation and the real parameter value. Remember that the estimation is a function of <em>X</em>, and cannot be considered a constant in the sum.</p>
<p>An estimator is said to be <strong>unbiased </strong>if:</p>
<p class="mce-root CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/cd879fa7-6777-4f37-b6f8-8848fec1b9ea.png" style="width:13.50em;height:1.67em;"/></p>
<p>Moreover, the estimator is defined as <strong>consistent</strong> if the sequence of estimations converges (at least with probability 1) to the real value when <em>k → ∞</em>:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/6882f82d-093d-4424-9e3e-7f64a94caf69.png" style="width:25.42em;height:1.75em;"/></p>
<p>Given a dataset <em>X</em> whose samples are drawn from <em>p<sub>data</sub></em>, the accuracy of an estimator is inversely proportional to its bias. Low-bias (or unbiased) estimators are able to map the dataset <em>X</em> with high-precision levels, while high-bias estimators are very likely to have a capacity that isn't high enough for the problem to solve, and therefore their ability to detect the whole dynamic is poor. </p>
<p>Let's now compute the derivative of the bias with respect to the vector <em>θ</em> (it will be useful later):</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/73459af7-d774-4d7b-a8d3-0890d6b020b6.png" style="width:47.17em;height:7.75em;"/></p>
<p>Consider that the last equation, thanks to the linearity of <em>E[•]</em>, holds also if we add a term that doesn't depend on <em>x</em> to the estimation of <em>θ</em>. In fact, in line with the laws of probability, it's easy to verify that:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/463b0abc-e0c6-4f5f-9427-394e2ec5033a.png" style="width:31.00em;height:2.67em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Underfitting</h1>
                </header>
            
            <article>
                
<p>A model with a high bias is likely to underfit the training set. Let's consider the scenario shown in the following graph:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/08db0bc9-de16-4408-85f6-50eb3777211b.png" style="width:38.17em;height:23.00em;"/></div>
<div class="mce-root CDPAlignCenter CDPAlign packt_figref">Underfitted classifier: The curve cannot separate correctly the two classes</div>
<p>Even if the problem is very hard, we could try to adopt a linear model and, at the end of the training process, the slope and the intercept of the separating line are about -1 and 0 (as shown in the plot); however, if we measure the accuracy, we discover that it's close to 0! Independently from the number of iterations, this model will never be able to learn the association between <em>X</em> and <em>Y</em>. This condition is called <strong>underfitting</strong>, and its major indicator is a very low training accuracy. Even if some data preprocessing steps can improve the accuracy, when a model is underfitted, the only valid solution is to adopt a higher-capacity model.</p>
<p>In a machine learning task, our goal is to achieve the maximum accuracy, starting from the training set and then moving on to the validation set. More formally, we can say that we want to improve our models so to get as close as possible to <strong>Bayes accuracy</strong>. This is not a well-defined value, but a theoretical upper limit that is possible to achieve using an estimator. In the following diagram, we see a representation of this process:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/4b30abbf-a779-4669-8059-b85bd2c8cc22.png" style="width:40.08em;height:24.58em;"/></div>
<div class="mce-root CDPAlignCenter CDPAlign packt_figref">Accuracy level diagram</div>
<p>Bayes accuracy is often a purely theoretical limit and, for many tasks, it's almost impossible to achieve using even biological systems; however, advancements in the field of deep learning allow to create models that have a target accuracy slightly below the Bayes one. In general, there's no closed form for determining the Bayes accuracy, therefore human abilities are considered as a benchmark. In the previous classification example, a human being is immediately able to distinguish among different dot classes, but the problem can be very hard for a limited-capacity classifier. Some of the models we're going to discuss can solve this problem with a very high target accuracy, but at this point, we run another risk that can be understood after defining the concept of variance of an estimator.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Variance of an estimator</h1>
                </header>
            
            <article>
                
<p>At the beginning of this chapter, we have defined the data generating process <em>p<sub>data</sub></em>, and we have assumed that our dataset <em>X</em> has been drawn from this distribution; however, we don't want to learn existing relationships limited to <em>X</em>, but we expect our model to be able to generalize correctly to any other subset drawn from <em>p<sub>data</sub></em>. A good measure of this ability is provided by the <strong>variance of the estimator</strong>:</p>
<p class="mce-root CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/94edc141-6802-4678-85fc-f90776cce7e7.png" style="width:22.33em;height:2.00em;"/></p>
<p>The variance can be also defined as the square of the standard error (analogously to the standard deviation). A high variance implies dramatic changes in the accuracy when new subsets are selected, because the model has probably reached a very high training accuracy through an over-learning of a limited set of relationships, and it has almost completely lost its ability to generalize. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Overfitting</h1>
                </header>
            
            <article>
                
<p>If underfitting was the consequence of a low capacity and a high bias, <strong>overfitting</strong> is a phenomenon that a high variance can detect. In general, we can observe a very high training accuracy (even close to the Bayes level), but not a poor validation accuracy. This means that the capacity of the model is high enough or even excessive for the task (the higher the capacity, the higher the probability of large variances), and that the training set isn't a good representation of <em>p<sub>data</sub></em>. To understand the problem, consider the following classification scenarios:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/5fb37d6e-4e42-4234-9d3a-252c435db94b.png" style="width:38.08em;height:15.58em;"/></div>
<div class="mce-root CDPAlignCenter CDPAlign packt_figref">Acceptable fitting (left), overfitted classifier (right)</div>
<p class="mce-root CDPAlignLeft CDPAlign">The left plot has been obtained using logistic regression, while, for the right one, the algorithm is SVM with a sixth-degree polynomial kernel. If we consider the second model, the decision boundaries seem much more precise, with some samples just over them. Considering the shapes of the two subsets, it would be possible to say that a non-linear SVM can better capture the dynamics; however, if we sample another dataset from <em>p<sub>data</sub></em> and the diagonal <em>tail</em> becomes wider, logistic regression continues to classify the points correctly, while the SVM accuracy decreases dramatically. The second model is very likely to be overfitted, and some corrections are necessary. When the validation accuracy is much lower than the training one, a good strategy is to increase the number of training samples to consider the real <em>p<sub>data</sub></em>. In fact, it can happen that a training set is built starting from a hypothetical distribution that doesn't reflect the real one; or the number of samples used for the validation is too high, reducing the amount of information carried by the remaining samples. Cross-validation is a good way to assess the quality of datasets, but it can always happen that we find completely new subsets (for example, generated when the application is deployed in a production environment) that are misclassified, even if they were supposed to belong to <em>p<sub>data</sub></em>. If it's not possible to enlarge the training set, data augmentation could be a valid solution, because it allows creating artificial samples (for images, it's possible to mirror, rotate, or blur them) starting from the information stored in the known ones. Other strategies to prevent overfitting are based on a technique called <strong>regularization</strong>, which we're going to discuss in the last part of this chapter. For now, we can say that the effect of regularization is similar to a partial linearization, which implies a capacity reduction with a consequent variance decrease.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Cramér-Rao bound</h1>
                </header>
            
            <article>
                
<p>If it's theoretically possible to create an unbiased model (even asymptotically), this is not true for variance. To understand this concept, it's necessary to introduce an important definition: the <strong>Fisher information</strong>. If we have a parameterized model and a data-generating process <em>p<sub>data</sub></em>, we can define the likelihood function by considering the following parameters:</p>
<p class="mce-root CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/b00ac51d-ebc5-471b-a1b4-5fd56ccc391d.png" style="width:8.08em;height:1.33em;"/></p>
<p>This function allows measuring how well the model describes the original data generating process. The shape of the likelihood can vary substantially, from well-defined, peaked curves, to almost flat surfaces. Let's consider the following graph, showing two examples based on a single parameter:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/df9b41c2-7a3d-4f4a-812a-7caf3f276f38.png" style="width:46.08em;height:16.00em;"/></div>
<div class="mce-root CDPAlignCenter CDPAlign packt_figref">Very peaked likelihood (left), flatter likelihood (right)</div>
<p>We can immediately understand that, in the first case, the maximum likelihood can be easily reached by gradient ascent, because the surface is very peaked. In the second case, instead, the gradient magnitude is smaller, and it's rather easy to stop before reaching the actual maximum because of numerical imprecisions or tolerances. In worst cases, the surface can be almost flat in very large regions, with a corresponding gradient close to zero. Of course, we'd like to always work with very sharp and peaked likelihood functions, because they carry more information about their maximum. More formally, the Fisher information quantifies this value. For a single parameter, it is defined as follows:</p>
<p class="mce-root CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/6d13c559-8c9f-4b50-922f-8c930c542e4e.png" style="width:16.25em;height:3.75em;"/></p>
<p>The Fisher information is an unbounded non-negative number that is proportional to the amount of information carried by the log-likelihood; the use of logarithm has no impact on the gradient ascent, but it simplifies complex expressions by turning products into sums. This value can be interpreted as the <em>speed</em> of the gradient when the function is reaching the maximum; therefore, higher values imply better approximations, while a hypothetical value of zero means that the probability to determine the right parameter estimation is also null.</p>
<p>When working with a set of <em>K</em> parameters, the Fisher information becomes a positive semidefinite matrix:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/031c41a3-23a9-443d-92c3-00cf3942a56b.png" style="width:51.58em;height:7.58em;"/></p>
<p>This matrix is symmetric, and also has another important property: when a value is zero, it means that the corresponding couple of parameters are orthogonal for the purpose of the maximum likelihood estimation, and they can be considered separately. In many real cases, if a value is close to zero, it determines a very low correlation between parameters and, even if it's not mathematically rigorous, it's possible to decouple them anyway.</p>
<p>At this point, it's possible to introduce the <strong>Cramér-Rao bound</strong>, which states that for every unbiased estimator that adopts <em>x</em> (with probability distribution <em>p(x; θ)</em>) as a measure set, the variance of any estimator of <em>θ</em> is always lower-bounded according to the following inequality:</p>
<p class="mce-root CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/f4feb22e-34c0-4ef6-8387-0ce820e04e61.png" style="width:7.25em;height:2.58em;"/></p>
<p>In fact, considering initially a generic estimator and exploiting Cauchy-Schwarz inequality with the variance and the Fisher information (which are both expressed as expected values), we obtain:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/d41065f1-a330-4809-9a87-42a4f6dc3140.png" style="width:39.08em;height:3.58em;"/></p>
<p>Now, if we use the expression for derivatives of the bias with respect to <em>θ</em>, considering that the expected value of the estimation of <em>θ</em> doesn't depend on <em>x</em>, we can rewrite the right side of the inequality as:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/32bc0088-4bba-47f1-8330-2ba98612280d.png" style="width:28.50em;height:4.00em;"/></p>
<p>If the estimator is unbiased, the derivative on the right side is equal to zero, therefore, we get:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/6c3948c3-6c9e-4c21-87c3-ab9ed67f26bc.png" style="width:9.08em;height:1.67em;"/></p>
<p>In other words, we can try to reduce the variance, but it will be always lower-bounded by the inverse Fisher information. Therefore, given a dataset and a model, there's always a limit to the ability to generalize. In some cases, this measure is easy to determine; however, its real value is theoretical, because it provides the likelihood function with another fundamental property: it carries all the information needed to estimate the worst case for variance. This is not surprising: when we discussed the capacity of a model, we saw how different functions could drive to higher or lower accuracies. If the training accuracy is high enough, this means that the capacity is appropriate or even excessive for the problem; however, we haven't considered the role of the likelihood <em>p(X| θ)</em>.</p>
<p>High-capacity models, in particular, with small or low-informative datasets, can drive to flat likelihood surfaces with a higher probability than lower-capacity models. Therefore, the Fisher information tends to become smaller, because there are more and more parameter sets that yield similar probabilities, and this, at the end of the day, drives to higher variances and an increased risk of overfitting. To conclude this section, it's useful to consider a general empirical rule derived from the <strong>Occam's razor</strong> principle: whenever a simpler model can explain a phenomenon with enough accuracy, it doesn't make sense to increase its capacity. A simpler model is always preferable (when the performance is good and it represents accurately the specific problem), because it's normally faster both in the training and in the inference phases, and more efficient. When talking about deep neural networks, this principle can be applied in a more precise way, because it's easier to increase or decrease the number of layers and neurons until the desired accuracy has been achieved.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Loss and cost functions</h1>
                </header>
            
            <article>
                
<p>At the beginning of this chapter, we discussed the concept of generic target function so as to optimize in order to solve a machine learning problem. More formally, in a supervised scenario, where we have finite datasets <em>X</em> and <em>Y</em>:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/288f4481-7e25-4442-b623-076e744dd043.png" style="width:17.92em;height:1.50em;"/></p>
<p class="mce-root CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/51650bd3-6e1d-4955-b417-a9474554c3df.png" style="width:18.17em;height:1.50em;"/></p>
<p>We can define the generic <strong>loss function</strong> for a single sample as:</p>
<p class="mce-root CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/c6ed2c5c-3bba-46b1-959a-de58d115ce0f.png" style="width:19.67em;height:1.50em;"/></p>
<p><em>J</em> is a function of the whole parameter set, and must be proportional to the error between the true label and the predicted. Another important property is convexity. In many real cases, this is an almost impossible condition; however, it's always useful to look for convex loss functions, because they can be easily optimized through the gradient descent method. We're going to discuss this topic in <a href="cb8a2a42-13fc-40ed-b6f0-56e4843284d7.xhtml" target="_blank">Chapter 9</a>, <em>Neural Networks for Machine Learning</em>. However, for now, it's useful to consider a loss function as an intermediate between our training process and a pure mathematical optimization. The missing link is the complete data. As already discussed, <em>X</em> is drawn from <em>p<sub>data</sub></em>, so it should represent the true distribution. Therefore, when minimizing the loss function, we're considering a potential subset of points, and never the whole real dataset. In many cases, this isn't a limitation, because, if the bias is null and the variance is small enough, the resulting model will show a good generalization ability (high training and validation accuracy); however, considering the data generating process, it's useful to introduce another measure called <strong>expected risk</strong>:</p>
<p class="mce-root CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/c98b2f7f-894d-4bfe-9245-71acd5e0351f.png" style="width:22.92em;height:2.83em;"/></p>
<p>This value can be interpreted as an average of the loss function over all possible samples drawn from <em>p</em><sub><em>data</em>.</sub> Minimizing the expected risk implies the maximization of the global accuracy. When working with a finite number of training samples, instead, it's common to define a <strong>cost function </strong>(often called a loss function as well, and not to be confused with the log-likelihood):</p>
<p class="mce-root CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/f105b89b-e2d5-41c6-9f18-029d2ce04ab4.png" style="width:15.42em;height:3.75em;"/></p>
<p>This is the actual function that we're going to minimize and, divided by the number of samples (a factor that doesn't have any impact), it's also called <strong>empirical risk</strong>, because it's an approximation (based on real data) of the expected risk. In other words, we want to find a set of parameters so that:</p>
<p class="mce-root CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/66c92f36-b45f-4a28-a69c-f969de7bc3d5.png" style="width:12.67em;height:1.58em;"/></p>
<p>When the cost function has more than two parameters, it's very difficult and perhaps even impossible to understand its internal structure; however, we can analyze some potential conditions using a bidimensional diagram:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/88baf2eb-e5aa-4562-b4c1-786facba4717.png" style="width:33.67em;height:23.17em;"/></div>
<div class="mce-root CDPAlignCenter CDPAlign packt_figref"> Different kinds of points in a bidimensional scenario</div>
<p>The different situations we can observe are:</p>
<ul>
<li>The <strong>starting point</strong>, where the cost function is usually very high due to the error.</li>
<li><strong>Local minima</strong>, where the gradient is null (and the second derivative is positive). They are candidates for the optimal parameter set, but unfortunately, if the concavity isn't too deep, an inertial movement or some noise can easily move the point away.</li>
<li><strong>Ridges</strong> (or <strong>local maxima</strong>), where the gradient is null, and the second derivative is negative. They are unstable points, because a minimum perturbation allows escaping, reaching lower-cost areas.</li>
</ul>
<ul>
<li><strong>Plateaus</strong>, or the region where the surface is almost flat and the gradient is close to zero. The only way to escape a plateau is to keep a residual kinetic energy—we're going to discuss this concept when talking about neural optimization algorithms (<a href="cb8a2a42-13fc-40ed-b6f0-56e4843284d7.xhtml" target="_blank">Chapter 9</a>, <em>Neural Networks for Machine Learning</em><a href="cb8a2a42-13fc-40ed-b6f0-56e4843284d7.xhtml"/>).</li>
<li><strong>Global minimum</strong>, the point we want to reach to optimize the cost function.</li>
</ul>
<p>Even if local minima are likely when the number of parameters is small, they become very unlikely when the model has a large number of parameters. In fact, an <em>n</em>-dimensional point <em>θ<sup>*</sup></em> is a local minimum for a convex function (and here, we're assuming <em>L</em> to be convex) only if:</p>
<p class="mce-root CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/db82f2e0-e5fb-403d-9566-4e5a594a518e.png" style="width:14.33em;height:3.00em;"/></p>
<p>The second condition imposes a positive semi-definite Hessian matrix (equivalently, all principal minors <em>H<sub>n</sub></em> made with the first <em>n</em> rows and <em>n</em> columns must be non-negative), therefore all its<sub> </sub>eigenvalues <em><span>λ</span><sub>0</sub><span>, λ</span><sub>1</sub><span>, ..., </span><span>λ<sub>N</sub></span></em> must be non-negative. This probability decreases with the number of parameters (<em>H</em> is a <em>n×n</em> square matrix and has <em>n</em> eigenvalues), and becomes close to zero in deep learning models where the number of weights can be in the order of 10,000,000 (or even more). The reader interested in a complete mathematical proof can read <em>High Dimensional Spaces</em>, <em>Deep Learning and Adversarial Examples</em>,<em> </em><em>Dube S., arXiv:1801.00634 [cs.CV]</em>. As a consequence, a more common condition to consider is instead the presence of <strong>saddle points</strong>, where the eigenvalues have different signs and the orthogonal directional derivatives are null, even if the points are neither local maxima nor minima. Consider, for example, the following plot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/7fa93bda-0cb6-45ee-af55-2f70f817120b.png" style="width:39.00em;height:17.00em;"/></div>
<div class="mce-root CDPAlignCenter CDPAlign packt_figref"> Saddle point in a bidimensional scenario</div>
<p>The function is <em>y=x3</em> whose first and second derivatives are <em>y'=3x2</em> and <em>y''=6x</em>. Therefore, <em>y'(0)=y''(0)=0</em>. In this case (single-valued function), this point is also called a <strong>point of inflection</strong>, because at <em>x=0,</em> the function shows a change in the concavity. In three dimensions, it's easier to understand why a saddle point has been called in this way. Consider, for example, the following plot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/6c4185f6-5242-468e-901b-d2fde6dd3193.png" style="width:52.17em;height:32.75em;"/></div>
<div class="mce-root CDPAlignCenter CDPAlign packt_figref"> Saddle point in a three-dimensional scenario</div>
<p>The surface is very similar to a horse saddle, and if we project the point on an orthogonal plane, <em>XZ</em> is a minimum, while on another plane (<em>YZ</em>) it is a maximum. Saddle points are quite dangerous, because many simpler optimization algorithms can slow down and even stop, losing the ability to find the right direction. In <a href="cb8a2a42-13fc-40ed-b6f0-56e4843284d7.xhtml">Chapter 9</a>, <em>Neural Networks for Machine Learning</em>, we're going to discuss some methods that are able to mitigate this kind of problem, allowing deep models to converge.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Examples of cost functions</h1>
                </header>
            
            <article>
                
<p>In this section, we expose some common <strong>cost functions</strong> that are employed in both classification and regression tasks. Some of them will be extensively adopted in our examples in the next chapters, particularly when discussing training processes in shallow and deep neural networks.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Mean squared error</h1>
                </header>
            
            <article>
                
<p><strong>Mean squared error</strong> is one of the most common regression cost functions. Its generic expression is:</p>
<p class="mce-root CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/a427b719-280a-41a6-94b7-b83646e36208.png" style="width:20.00em;height:3.83em;"/></p>
<p>This function is differentiable at every point of its domain and it's convex, so it can be optimized using the <strong>stochastic gradient descent</strong> (<strong>SGD</strong>) algorithm; however, there's a drawback when employed in regressions where there are outliers. As its value is always quadratic when the distance between the prediction and the actual value (corresponding to an outlier) is large, the relative error is high, and this can lead to an unacceptable correction.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Huber cost function</h1>
                </header>
            
            <article>
                
<p>As explained, mean squared error isn't robust to outliers, because it's always quadratic independently of the distance between actual value and prediction. To overcome this problem, it's possible to employ the <strong>H</strong><strong>uber</strong> <strong>cost function</strong>, which is based on threshold <em>t<sub>H</sub></em>, so that for distances less than <em><span>t</span><sub>H</sub></em>, its behavior is quadratic, while for a distance greater than <em><span>t</span></em><sub><em>H</em>,</sub> it becomes linear, reducing the entity of the error and, therefore, the relative importance of the outliers.</p>
<p>The analytical expression is:</p>
<p class="mce-root CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/e437919e-1f6f-4eb2-9110-e896fe57eede.png" style="width:38.00em;height:3.83em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Hinge cost function</h1>
                </header>
            
            <article>
                
<p>This cost function is adopted by SVM, where the goal is to maximize the distance between the separation boundaries (where the support vector lies). It's analytic expression is:</p>
<p class="mce-root CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/68006894-0de8-4ef9-8ba5-ae93b4bc5123.png" style="width:22.17em;height:3.75em;"/></p>
<p>Contrary to the other examples, this cost function is not optimized using classic stochastic gradient descent methods, because it's not differentiable at all points where:</p>
<p class="mce-root CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/dee44504-4715-4432-9ec6-018f66643b6e.png" style="width:14.42em;height:1.58em;"/></p>
<p>For this reason, SVM algorithms are optimized using quadratic programming techniques.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Categorical cross-entropy</h1>
                </header>
            
            <article>
                
<p><strong>Categorical cross-entropy</strong> is the most diffused classification cost function, adopted by logistic regression and the majority of neural architectures. The generic analytical expression is:</p>
<p class="mce-root CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/dfd97220-2510-4838-b413-094a8458eca9.png" style="width:17.25em;height:3.67em;"/></p>
<p>This cost function is convex and can be easily optimized using stochastic gradient descent techniques; moreover, it has another important interpretation. If we are training a classifier, our goal is to create a model whose distribution is as similar as possible to <em>pdata</em>. This condition can be achieved by minimizing the Kullback-Leibler divergence between the two distributions:</p>
<p class="mce-root CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/90dd1a5a-55d3-4cdf-840c-1f69b68d7b12.png" style="width:30.42em;height:4.17em;"/></p>
<p>In the previous expression, <em>p<sub>M</sub></em> is the distribution generated by the model. Now, if we rewrite the divergence, we get:</p>
<p class="mce-root CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/ebe06332-3966-489c-a572-4974fd6c5b1b.png" style="width:50.42em;height:5.92em;"/></p>
<p>The first term is the entropy of the data-generating distribution, and it doesn't depend on the model parameters, while the second one is the cross-entropy. Therefore, if we minimize the cross-entropy, we also minimize the Kullback-Leibler divergence, forcing the model to reproduce a distribution that is very similar to <em>p<sub>data</sub></em>. This is a very elegant explanation as to why the cross-entropy cost function is an excellent choice for classification problems.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Regularization</h1>
                </header>
            
            <article>
                
<p>When a model is ill-conditioned or prone to overfitting, <strong>regularization</strong> offers some valid tools to mitigate the problems. From a mathematical viewpoint, a regularizer is a penalty added to the cost function, so to impose an extra-condition on the evolution of the parameters:</p>
<p class="mce-root CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/8e782293-ca76-4e45-881d-59c4358382fe.png" style="width:17.75em;height:1.58em;"/></p>
<p>The parameter <em>λ</em> controls the strength of the regularization, which is expressed through the function <em>g(θ)</em>. A fundamental condition on <em>g(θ)</em> is that it must be differentiable so that the new composite cost function can still be optimized using SGD algorithms. In general, any regular function can be employed; however, we normally need a function that can contrast the indefinite growth of the parameters.</p>
<p>To understand the principle, let's consider the following diagram:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/9bd85fcd-10ce-48c9-a538-70f3791a3f9c.png" style="width:43.33em;height:15.17em;"/></div>
<div class="mce-root CDPAlignCenter CDPAlign packt_figref">Interpolation with a linear curve (left) and a parabolic one (right)</div>
<p>In the first diagram, the model is linear and has two parameters, while in the second one, it is quadratic and has three parameters. We already know that the second option is more prone to overfitting, but if we apply a regularization term, it's possible to avoid the growth of a (first quadratic parameter), transforming the model into a linearized version. Of course, there's a difference between choosing a lower-capacity model and applying a regularization constraint. In fact, in the first case, we are renouncing the possibility offered by the extra capacity, running the risk of increasing the bias, while with regularization we keep the same model but optimize it so to reduce the variance. Let's now explore the most common regularization techniques.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Ridge</h1>
                </header>
            
            <article>
                
<p><strong>Ridge</strong> regularization (also known as <strong>Tikhonov regularization</strong>) is based on the squared L2-norm of the parameter vector:</p>
<p class="mce-root CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/521e6e3e-6215-4bd0-9bc8-f0f4fdf34fa6.png" style="width:18.92em;height:1.83em;"/></p>
<p>This penalty avoids an infinite growth of the parameters (for this reason, it's also known as <strong>weight shrinkage</strong>), and it's particularly useful when the model is ill-conditioned, or there is multicollinearity, due to the fact that the samples are completely independent (a relatively common condition).</p>
<p>In the following diagram, we see a schematic representation of the Ridge regularization in a bidimensional scenario:</p>
<div class="mce-root CDPAlignCenter CDPAlign packt_figref"><img style="font-size: 1em;width:52.75em;height:38.67em;" src="assets/75db56e9-e05e-4678-8e7c-5cceee9d68c3.png"/> </div>
<div class="mce-root CDPAlignCenter CDPAlign packt_figref">Ridge (L2) regularization</div>
<p>The zero-centered circle represents the Ridge boundary, while the shaded surface is the original cost function. Without regularization, the minimum (<strong>w<sub>1</sub></strong>, <strong>w<sub>2</sub></strong>) has a magnitude (for example, the distance from the origin) which is about double the one obtained by applying a Ridge constraint, confirming the expected shrinkage. When applied to regressions solved with the <strong>Ordinary Least Squares</strong> (<strong>OLS</strong>) algorithm, it's possible to prove that there always exists a Ridge coefficient, so that the weights are shrunk with respect the OLS ones. The same result, with some restrictions, can be extended to other cost functions. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Lasso</h1>
                </header>
            
            <article>
                
<p><strong>Lasso</strong> regularization is based on the <em>L1</em>-norm of the parameter vector:</p>
<p class="mce-root CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/6ad5e737-1b12-46f0-acd6-a5ac455964ba.png" style="width:16.67em;height:1.50em;"/></p>
<p>Contrary to Ridge, which shrinks all the weights, Lasso can shift the smallest one to zero, creating a sparse parameter vector. The mathematical proof is beyond the scope of this book; however, it's possible to understand it intuitively by considering the following diagram (bidimensional):</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/e8e2449c-e33a-4aae-b483-117c651dd76c.png" style="width:55.92em;height:40.25em;"/></div>
<div class="mce-root CDPAlignCenter CDPAlign packt_figref">Lasso (L1) regularization</div>
<p>The zero-centered square represents the Lasso boundaries. If we consider a generic line, the probability of being tangential to the square is higher at the corners, where at least one (exactly one in a bidimensional scenario) parameter is null. In general, if we have a vectorial convex function <em>f(x)</em> (we provide a definition of convexity in <a href="8d541a43-8790-4a91-a79b-e48496f75d90.xhtml" target="_blank">Chapter 5</a>, <em>EM Algorithm and Applications</em>), we can define:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/ba397d1e-6086-45de-9651-4358e965dec3.png" style="width:9.50em;height:1.58em;"/></p>
<p>As any <em>L<sub>p</sub></em>-norm is convex, as well as the sum of convex functions, <em>g(x)</em> is also convex. The regularization term is always non-negative, therefore the minimum corresponds to the norm of the null vector. When minimizing <em>g(x)</em>, we need to also consider the contribution of the gradient of the norm in the ball centered in the origin where, however, the partial derivatives don't exist. Increasing the value of <em>p</em>, the norm becomes smoothed around the origin, and the partial derivatives approach zero for <em>|x<sub>i</sub>| → 0</em>.</p>
<p>On the other side, with <em>p=1</em> (excluding the <em>L<sub>0</sub></em>-norm and all the norms with <em>p ∈ ]0, 1[</em> that allow an even stronger sparsity, but are non-convex), the partial derivatives are always +1 or -1, according to the sign of <em>x<sub>i</sub> (<span>x</span><sub>i</sub> ≠ 0)</em>. Therefore, it's <em>easier</em> for the <em>L<sub>1</sub></em>-norm to push the smallest components to zero, because the contribution to the minimization (for example, with a gradient descent) is independent of <em><span>x</span></em><sub><em>i</em>, </sub>while an <em>L<sub>2</sub></em>-norm<sub> </sub>decreases its <em>speed</em> when approaching the origin. This is a non-rigorous explanation of the sparsity achieved using the <em>L<sub>1</sub></em>-norm. In fact, we also need to consider the term <em>f(x)</em>, which bounds the value of the global minimum; however, it may help the reader to develop an intuitive understanding of the concept. It's possible to find further and mathematically rigorous details in <em>Optimization for Machine Learning, (e</em>dited by) <em>Sra S.</em>, <em>Nowozin S.</em>, <em>Wright S. J.</em>, <em>The MIT Press</em>.</p>
<p>Lasso regularization is particularly useful whenever a sparse representation of a dataset is needed. For example, we could be interested in finding the feature vectors corresponding to a group of images. As we expect to have many features but only a subset present in each image, applying the Lasso regularization allows forcing all the smallest coefficients to become null, suppressing the presence of the secondary features. Another potential application is latent semantic analysis, where our goal is to describe the documents belonging to a corpus in terms of a limited number of topics. All these methods can be summarized in a technique called <strong>sparse coding</strong>, where the objective is to reduce the dimensionality of a dataset (also in non-linear scenarios) by extracting the most representative atoms, using different approaches to achieve sparsity. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">ElasticNet</h1>
                </header>
            
            <article>
                
<p>In many real cases, it's useful to apply both Ridge and Lasso regularization in order to force weight shrinkage and a global sparsity. It is possible by employing the <strong>ElasticNet</strong> regularization, defined as:</p>
<p class="mce-root CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/2812dfb4-78aa-48ab-a9a5-684d1c674d40.png" style="width:25.83em;height:1.92em;"/></p>
<p>The strength of each regularization is controlled by the parameters <em>λ<sub>1</sub></em> and <em>λ<sub>2</sub></em>. ElasticNet can yield excellent results whenever it's necessary to mitigate overfitting effects while encouraging sparsity. We are going to apply all the regularization techniques when discussing some deep learning architectures.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Early stopping</h1>
                </header>
            
            <article>
                
<p>Even though it's a pure regularization technique, <strong>early stopping</strong> is often considered as a <em>last resort</em> when all other approaches to prevent overfitting and maximize validation accuracy fail. In many cases (above all, in deep learning scenarios), it's possible to observe a typical behavior of the training process considering both training and the validation cost functions:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/2df7b673-ba20-47dd-a49b-9c9ce0d9fc0d.png" style="width:40.83em;height:30.17em;"/> </div>
<div class="mce-root CDPAlignCenter CDPAlign packt_figref"> Example of early stopping before the beginning of ascending phase of U-curve</div>
<p>During the first epochs, both costs decrease, but it can happen that after a <em>threshold</em> epoch <em>e<sub>s</sub></em>, the validation cost starts increasing. If we continue with the training process, this results in overfitting the training set and increasing the variance. For this reason, when there are no other options, it's possible to prematurely stop the training process. In order to do so, it's necessary to store the last parameter vector before the beginning of a new iteration and, in the case of no improvements or the accuracy worsening, to stop the process and recover the last parameters. As explained, this procedure must never be considered as the best choice, because a better model or an improved dataset could yield higher performances. With early stopping, there's no way to verify alternatives, therefore it must be adopted only at the last stage of the process and never at the beginning. Many deep learning frameworks such as Keras include helpers to implement an early stopping callback; however, it's important to check whether the last parameter vector is the one stored before the last epoch or the one corresponding to <em>e<sub>s</sub></em>. In this case, it could be useful to repeat the training process, stopping it at the epoch previous to <em>e<sub>s</sub></em> (where the minimum validation cost has been achieved).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we discussed fundamental concepts shared by almost any machine learning model. In the first part, we have introduced the data generating process, as a generalization of a finite dataset. We explained which are the most common strategies to split a finite dataset into a training block and a validation set, and we introduced cross-validation, with some of the most important variants, as one of the best approaches to avoid the limitations of a static split.</p>
<p>In the second part, we discussed the main properties of an estimator: capacity, bias, and variance. We also introduced the <span>Vapnik-Chervonenkis theory, which is a mathematical formalization of the concept of representational capacity, and we analyzed the effects of high biases and high variances. In particular, we discussed effects called underfitting and overfitting, defining the relationship with high bias and high variance.</span></p>
<p>In the third part, we introduced the loss and cost functions, first as proxies of the expected risk, and then we detailed some common situations that can be experienced during an optimization problem. We also exposed some common cost functions, together with their main features. In the last part, we discussed regularization, explaining how it can mitigate the effects of overfitting.</p>
<p>In the next chapter, <a href="f6860c85-a228-4e63-96ac-22a0caf1a767.xhtml" target="_blank">Chapter 2</a>, <em>Introduction to Semi-Supervised Learning</em>, we're going to introduce semi-supervised learning, focusing our attention on the concepts of transductive and inductive learning.</p>


            </article>

            
        </section>
    </body></html>