<html><head></head><body>
		<div id="_idContainer102">
			<h1 id="_idParaDest-153"><em class="italic"><a id="_idTextAnchor160"/>Chapter 8</em>: Reinforcement Learning</h1>
			<p>The reinforcement learning paradigm is very different than standard machine learning and even the online machine learning methods that we have covered in earlier chapters. Although reinforcement learning will not always be a better choice than "regular" learning for many use cases, it is a powerful tool for tackling re-learning and the adaptation of models.</p>
			<p>In reinforcement learning, we give the model a lot of decisive power to do its re-learning and to update the rules of its decision-making process. Rather than letting the model make a prediction and hardcode the action to take for this prediction, the model will directly decide on the action to take.</p>
			<p>For automated machine learning pipelines in which actions are effectively automated, this can be a great choice. Of course, this must be complemented with different types of logging, monitoring, and more. For cases in which we need a prediction rather than an action, reinforcement learning will not be appropriate.</p>
			<p>Although very powerful in the right use case, reinforcement learning is currently not a standard choice with respect to regular machine learning. In the future, reinforcement learning may very well gain popularity for a larger number of use cases.</p>
			<p>In this chapter, you will first be thoroughly introduced to the different concepts behind reinforcement learning. You will then see an implementation of reinforcement learning in Python.</p>
			<p>This chapter covers the following topics:</p>
			<ul>
				<li>Defining reinforcement learning</li>
				<li>The main steps of reinforcement learning models</li>
				<li>Exploring Q-learning</li>
				<li>Deep Q-learning</li>
				<li>Using reinforcement learning for streaming data</li>
				<li>Use cases of reinforcement learning</li>
				<li>Implementing reinforcement learning in Python</li>
			</ul>
			<h1 id="_idParaDest-154"><a id="_idTextAnchor161"/>Technical requirements</h1>
			<p>You can find all the code for this book on GitHub at the following link: <a href="https://github.com/PacktPublishing/Machine-Learning-for-Streaming-Data-with-Python">https://github.com/PacktPublishing/Machine-Learning-for-Streaming-Data-with-Python</a>. If you are not yet familiar with Git and GitHub, the easiest way to download the notebooks and code samples is the following:</p>
			<ol>
				<li>Go to the link of the repository.</li>
				<li>Go to the green <strong class="bold">Code</strong> button.</li>
				<li>Select <strong class="bold">Download zip</strong>.</li>
			</ol>
			<p>When you download the ZIP file, you unzip it in your local environment, and you will be able to access the code through your preferred Python editor.</p>
			<h2 id="_idParaDest-155"><a id="_idTextAnchor162"/>Python environment</h2>
			<p>To follow along with this book, you can download the code in the repository and execute it using your preferred Python editor.</p>
			<p>If you are not yet familiar with Python environments, I would advise you to check out either Anaconda (<a href="https://www.anaconda.com/products/individual">https://www.anaconda.com/products/individual</a>), which comes with the Jupyter Notebook and JupyterLab, which are both great for executing notebooks. It also comes with Spyder and VSCode for editing scripts and programs.</p>
			<p>If you have difficulty installing Python or the associated programs on your machine, you can check out Google Colab (<a href="https://colab.research.google.com/">https://colab.research.google.com/</a>) or Kaggle Notebooks (<a href="https://www.kaggle.com/code">https://www.kaggle.com/code</a>), which both allow you to run Python code in online notebooks for free, without any setup.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The code in the book will generally use Colab and Kaggle notebooks with Python version 3.7.13 and you can set up your own environment to mimic this. </p>
			<h1 id="_idParaDest-156"><a id="_idTextAnchor163"/>Defining reinforcement learning</h1>
			<p>Reinforcement learning<a id="_idIndexMarker436"/> is a subdomain of machine learning that focuses on creating machine learning models that make decisions. Sometimes, the models are not referred to as models, but rather as intelligent agents.</p>
			<p>When looking from a distance, you could argue that reinforcement learning is very close to machine learning. We could say that both of them are methods inside artificial intelligence that try to deliver intelligent black boxes, which are able to learn specific tasks just like a human would – often better.</p>
			<p>If we look closer, however, we start to see important differences. In previous chapters, you have seen machine learning models such as anomaly detection, classification, and regression. All of them use a number of variables and are able to make real-time predictions on a target variable based on those. </p>
			<p>You have seen a number of metrics that allow us data scientists to decide whether a model is any good. The online models are also able to adapt to changing data by relearning and continuously taking into account their own error metrics.</p>
			<p>Reinforcement learning goes further than that. RL models not only make predictions but also take action. You could say that offline models do not take any autonomy in relearning from their mistakes, online models do take into account mistakes right away, and reinforcement learning models are designed to make mistakes and learn from them. </p>
			<p>Online models can adapt to their mistakes, just like reinforcement learning. However, when you build the first version of an online model, you do expect it to have acceptable performance in the beginning, and you would train it on some historical data. It can then adapt in the case of data drift or other changes.</p>
			<p>The reinforcement learning model, on the other hand, starts out totally naïve and unknowing. It will try out actions, make some mistakes, and then by pure hazard at some point, it will make some good decisions as well. At this point, the reinforcement model will receive rewards and start to remember those.</p>
			<h2 id="_idParaDest-157"><a id="_idTextAnchor164"/>Comparing online and offline reinforcement learning</h2>
			<p>Reinforcement learning<a id="_idIndexMarker437"/> is generally online learning: the intelligent agent<a id="_idIndexMarker438"/> learns through repeated <a id="_idIndexMarker439"/>action taking with rewards for good predictions. This can continue indefinitely, at least as long as feedback on the decision keeps getting fed into the model. </p>
			<p>However, reinforcement learning can also be offline. In this case, the model would learn for a given period of time, and then at some point, the feedback loop is cut off so that the model (the decision rules) stays the same after that point.</p>
			<p>In general, when reinforcement learning is used, it is because we are interested in continuous relearning. So, the online variant is the most common.</p>
			<h2 id="_idParaDest-158"><a id="_idTextAnchor165"/>A more detailed overview of feedback loops in reinforcement learning</h2>
			<p>Now, let's go more<a id="_idIndexMarker440"/> into the details of reinforcement<a id="_idIndexMarker441"/> learning. To start, it is important to understand how the feedback loop of a general reinforcement learning model works. The following schema shows the logic of a model learning through a feedback loop.</p>
			<div>
				<div id="_idContainer093" class="IMG---Figure">
					<img src="image/B18335_08_1.jpg" alt="Figure 8.1 – Feedback loops in RL&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.1 – Feedback loops in RL</p>
			<p>In this schema, you observe<a id="_idIndexMarker442"/> the following elements:</p>
			<ul>
				<li><strong class="bold">The RL agent</strong>: Our model that is continuously <a id="_idIndexMarker443"/>learning and making decisions.</li>
				<li><strong class="bold">The environment</strong>: A fixed environment in which the agent<a id="_idIndexMarker444"/> can make a specific set of decisions.</li>
				<li><strong class="bold">The action</strong>: Every time the agent<a id="_idIndexMarker445"/> makes a decision, this will alter the environment.</li>
				<li><strong class="bold">The reward</strong>: If the decision yields<a id="_idIndexMarker446"/> a good result, then a reward will be given to the agent.</li>
				<li><strong class="bold">The state</strong>: The information about the environment<a id="_idIndexMarker447"/> that the agent needs to make its decisions.</li>
			</ul>
			<p>As a simplified example, imagine that the agent is a human baby learning to walk. At each point in time, the baby is trying out stuff that could get them to walk. More specifically, they are activating several muscles in their body.</p>
			<p>While doing this, the baby is observing that they are or are not walking. Also, their parents cheer them on when they are getting closer to walking correctly. This is a reward being sent to the baby that indicates to them that they are learning in the right way.</p>
			<p>The baby will then again try to walk by using almost the same muscles, but with a little variation. If it's better, they'll see that as a positive thing and continue to move in that way.</p>
			<p>Let's now cover the remaining steps that are necessary for all of this to work.</p>
			<h1 id="_idParaDest-159"><a id="_idTextAnchor166"/>The main steps of a reinforcement learning model</h1>
			<p>The actions of the agent<a id="_idIndexMarker448"/> are the decisions that it can make. This is a limited set of decisions. As you will understand, the agent is just a piece of code, so all its decisions will need to be programmed controls of its own behavior.</p>
			<p>If we think of it as a computer<a id="_idIndexMarker449"/> game, then you understand that the actions that you as a player can execute are limited by the buttons that you can press on your game console. All of the combinations together still allow for a very wide range of options, but they are limited in some way.</p>
			<p>The same is true for our human baby learning to walk. They only have control over their own body, so they would not be able to execute any actions beyond this. This gives a huge number of things that can be done by humans, but still, it is a fixed set of actions.</p>
			<h2 id="_idParaDest-160"><a id="_idTextAnchor167"/>Making the decisions</h2>
			<p>Now, as your reinforcement <a id="_idIndexMarker450"/>agent is receiving information about its environment (the state), it will need to convert this information into a decision. This is the same idea as a machine learning model that needs to map independent variables into a target variable.</p>
			<p>This decision mapping is generally called the policy in the case of reinforcement learning. The policy will generally decide on the best action by estimating the expected rewards and then executing the action with the highest expected reward.</p>
			<h2 id="_idParaDest-161"><a id="_idTextAnchor168"/>Updating the decision rules</h2>
			<p>The last part of this big picture<a id="_idIndexMarker451"/> description of reinforcement learning is the update of the policy: basically, the learning itself. There are many models, and they all have their own specificities, but let's try to get a general idea anyway.</p>
			<p>At this point, you have seen that an agent takes an action from a set of fixed actions. The agent has estimated which is most likely to maximize rewards. After the execution of this task, the model will receive a certain reward. This will be used to alter the policy, in a way that depends on the exact method of reinforcement learning that you use.</p>
			<p>In the next section, you will see how this can be done in more detail by exploring the Q-learning algorithm.</p>
			<h1 id="_idParaDest-162"><a id="_idTextAnchor169"/>Exploring Q-learning</h1>
			<p>Although there are many<a id="_idIndexMarker452"/> variants of reinforcement learning, the previous explanation should have given you a good general overview of how most reinforcement models work. It is now time to move deeper into a specific model for reinforcement learning: Q-learning.</p>
			<p>Q-learning is a reinforcement learning algorithm that is, so-called, model free. Model-free reinforcement learning algorithms<a id="_idIndexMarker453"/> can be seen as pure trial-and-error algorithms: they have no prior notion of the environment, but merely just try out actions and learn whether their actions yield the correct outcome. </p>
			<p>Model-based algorithms, on the other hand, use a different theoretical approach. Rather than just learning the outcome based on the actions, they try to understand their environment through some form of a model. Once the agent learns how the environment works, it can take actions that will optimize the reward according to this knowledge.</p>
			<p>Although the model-based approach may seem more intuitively likely to perform, model-free approaches such as Q-learning are actually quite good.</p>
			<h2 id="_idParaDest-163"><a id="_idTextAnchor170"/>The goal of Q-learning</h2>
			<p>The goal of the Q-learning algorithm<a id="_idIndexMarker454"/> is to find a policy that maximizes the expected reward obtained from a number of successive steps starting at the current state. </p>
			<p>In regular language, this means that Q-learning looks at the current state (the variables of its environment) and then uses this information to take the best steps in the future. The model does not look at past happenings, only the future.</p>
			<p>The model uses the Q-value as a calculation for the quality of a state-action combination: that is, for each state, there is a list of potential actions. Each combination of a potential<a id="_idIndexMarker455"/> state and a potential action is called a state-action combination. The Q-value indicates the quality of this action when the state is the given one.</p>
			<p>At the beginning of the reinforcement learning process, the value of Q is initialized in some way (randomly or fixed) and then updates every time that a reward is received. The agent handles the model according to the Q-values, and when rewards (feedback on the actions) start to come in, those Q values change. The agent still continues to follow the Q-values, but as they update, the behavior of the agent changes.</p>
			<p>The core of this algorithm<a id="_idIndexMarker456"/> is the Bellman equation: an update rule for Q-values that uses a weighted average of older and new Q-values. Therefore, old information is forgotten at some point, when a lot of learning has happened. This avoids getting "stuck" in previous behaviors.</p>
			<p>The formula of the Bellman equation is the following:</p>
			<div>
				<div id="_idContainer094" class="IMG---Figure">
					<img src="image/Formula_08_001.jpg" alt=""/>
				</div>
			</div>
			<h2 id="_idParaDest-164"><a id="_idTextAnchor171"/>Parameters of the Q-learning algorithm</h2>
			<p>In this Bellman equation, there<a id="_idIndexMarker457"/> are a few important parameters that you can tune. Let's briefly cover those:</p>
			<ul>
				<li>The learning rate is a very commonly used hyperparameter in machine learning algorithms. It generally defines the step size of an optimizer in which large steps may make you move around faster in the optimization space, but too large steps may also cause a problem to go into narrow optimums.</li>
				<li>The discount factor is a concept that is very often used in finance and economics. In reinforcement learning, it indicates at which rate the model needs to prioritize short-term or long-term rewards.</li>
			</ul>
			<p>After this overview of Q-learning, the next section will introduce a more complex alternative version of this approach called Deep Q-learning.</p>
			<h1 id="_idParaDest-165"><a id="_idTextAnchor172"/>Deep Q-learning</h1>
			<p>Now that you have seen the basics of reinforcement<a id="_idIndexMarker458"/> learning and the most basic reinforcement learning model, Q-learning, it is time to move on to a more performant and more commonly used model called Deep Q-learning.</p>
			<p>Deep Q-learning is a variant of Q-learning in which the Q-values are not just a list of expected Q-values for each<a id="_idIndexMarker459"/> combination of state and actions, updated by the Bellman equation. Rather, in Deep Q-learning, this estimation is done using a (deep) neural network.</p>
			<p>If you are not familiar, neural networks are a class of machine learning models that are amongst the state of the art in terms of performance. Neural networks are largely used for many use cases in artificial intelligence, machine learning, and data science in general. Deep neural networks are the technology<a id="_idIndexMarker460"/> that allows many data science use cases such as <strong class="bold">Natural Language Processing</strong> (<strong class="bold">NLP</strong>), computer vision, and much more.</p>
			<p>The idea behind the neural network is to pass an input data point through a network of nodes, called neurons, that each do a very<a id="_idIndexMarker461"/> simple operation. The fact that there are many such simple operations being done, and weights applied in between, means that the neural network is a powerful learning algorithm for mapping input data into a target variable.</p>
			<p>The following example shows a standard depiction of a neural network. The models can be as simple or as complex as you want. You can go to huge numbers of hidden layers and add as many nodes per hidden layer as you want. Each arrow is a coefficient and needs to be estimated. So, it must be kept in mind that a large quantity of data will be necessary for estimating such models.</p>
			<p>The example schematic of a neural network is shown here:</p>
			<div>
				<div id="_idContainer095" class="IMG---Figure">
					<img src="image/B18335_08_2.jpg" alt="Figure 8.2 – Neural network architecture&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.2 – Neural network architecture</p>
			<p>For reinforcement learning, this has to be applied<a id="_idIndexMarker462"/> inside the Q-learning paradigm. In essence, the deep learning model is just a better way to estimate Q-values than the standard Q-learning approach (or at least that's what it aspires to be).</p>
			<p>You could see the analogy as follows. In standard Q-learning, there is a relatively simple storage and update mechanism for new rewards coming in and updating the policy. You could see it as depicted as a table, as follows:</p>
			<div>
				<div id="_idContainer096" class="IMG---Figure">
					<img src="image/B18335_08_3.jpg" alt="Figure 8.3 – Example table format&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.3 – Example table format</p>
			<p>In Deep Q-learning, the input and output processes are mostly the same, yet the state is transcribed as a number<a id="_idIndexMarker463"/> of variables that are input into a neural network. The neural network then outputs the estimated Q-values for each action.</p>
			<p>The following graph shows how the state is added as input to the neural network.</p>
			<div>
				<div id="_idContainer097" class="IMG---Figure">
					<img src="image/B18335_08_4.jpg" alt="Figure 8.4 – Adding the state as input to the neural network&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.4 – Adding the state as input to the neural network</p>
			<p>Now that you understand the theory behind reinforcement learning, the next section will be more applied as it presents<a id="_idIndexMarker464"/> a number of example use cases for reinforcement learning on streaming data.</p>
			<h1 id="_idParaDest-166"><a id="_idTextAnchor173"/>Using reinforcement learning for streaming data</h1>
			<p>As discussed throughout<a id="_idIndexMarker465"/> earlier chapters, the challenge of building models <a id="_idIndexMarker466"/>on streaming data is to find models that are able to learn incrementally and that are able to adapt in the case of model drift or data drift.</p>
			<p>Reinforcement learning is a potential candidate that could respond well to those two challenges. After all, reinforcement learning has a feedback loop that allows it to change policy when many mistakes are made. It is therefore able to adapt itself in the event of changes.</p>
			<p>Reinforcement learning can be seen as a subcase of online learning. At the same time, the second specificity of reinforcement learning is its focus on learning actions, whereas regular online models are focused on making accurate predictions.</p>
			<p>The split between the two fields is present in practice in the types of use cases and domains of application, but many streaming use cases have the potential to benefit from reinforcement learning and it is a great toolset to master.</p>
			<p>If you are looking for more depth and examples, you can look at the following insightful article: <a href="https://www.researchgate.net/publication/337581742_Machine_learning_for_streaming_data_state_of_the_art_challenges_and_opportunities">https://www.researchgate.net/publication/337581742_Machine_learning_for_streaming_data_state_of_the_art_challenges_and_opportunities</a>.</p>
			<p>In the next section, we will explore a few key use cases where reinforcement learning proves crucial.</p>
			<h1 id="_idParaDest-167"><a id="_idTextAnchor174"/>Use cases of reinforcement learning</h1>
			<p>The use cases of reinforcement learning <a id="_idIndexMarker467"/>are almost as numerous as online learning. It is a less often used technology when compared to standard offline and online models, but with the changes in the machine learning domain over the last years, it is still a great candidate that could become huge in the coming years.</p>
			<p>Let's look at some use cases to get a better feel of the types of use cases that can be suitable for reinforcement<a id="_idIndexMarker468"/> learning. Among the types of examples, there are some that are more traditional reinforcement learning use cases, and others that are more specific streaming data use cases.</p>
			<h2 id="_idParaDest-168"><a id="_idTextAnchor175"/>Use case one – trading system</h2>
			<p>As a first use case<a id="_idIndexMarker469"/> of reinforcement learning, let's talk about stock market trading. The stock market use case was already discussed in the forecasting use case of the regression chapter. Reinforcement learning is an alternative solution to it.</p>
			<p>In regression, online models are used to build forecasting tools. Using these forecasting tools, a stock trader could predict the price developments of specific stocks in the near future and use those predictions to decide on buying or selling the stocks.</p>
			<p>Using reinforcement learning, the use case would be developed slightly differently. The intelligent agent would learn how to make decisions rather than to predict prices. As an example, you could give the agent three actions: sell, buy, or hold (hold meaning do nothing/ignore).</p>
			<p>The agent would receive information about its environment, which could include past stock prices, macroeconomic information, and much more. This information would be used together with a policy and this policy decides when to buy, sell, or hold.</p>
			<p>By training this agent for a long period of time, and with a lot of data including all types of market scenarios, the agent could learn pretty well how to trade markets. You would then obtain a profitable "trading robot," making money without much intervention. If successful, this is clearly an advantage over regression models as they only predict price and do not take any action.</p>
			<p>For more information on this<a id="_idIndexMarker470"/> topic, you could start by checking out the following links:</p>
			<ul>
				<li><a href="https://arxiv.org/pdf/1911.10107.pdf">https://arxiv.org/pdf/1911.10107.pdf</a></li>
				<li><a href="http://cslt.riit.tsinghua.edu.cn/mediawiki/images/a/aa/07407387.pdf">http://cslt.riit.tsinghua.edu.cn/mediawiki/images/a/aa/07407387.pdf</a></li>
			</ul>
			<h2 id="_idParaDest-169"><a id="_idTextAnchor176"/>Use case two – social network ranking system</h2>
			<p>A second use case<a id="_idIndexMarker471"/> for reinforcement learning is the ranking of posts on social networks. The general idea of what happens behind this is a number of posts being created and the most relevant has to be shown to each specific user, based on their preference.</p>
			<p>There are many machine learning approaches that could be leveraged for this, and reinforcement learning is one of them. Basically, the model would end up making decisions on the posts to show to the user, so in this way, it is a real action that is taken. </p>
			<p>This action also generates feedback. If the user likes, comments, shares, clicks, pauses, or interacts in other ways with the post, the agent will be rewarded and learns that this type of post does interest the user.</p>
			<p>By trial and error, the agent can publish different types of posts to each user and learn which decisions are good and which are bad.</p>
			<p>Real-time response is very important<a id="_idIndexMarker472"/> here, as well as learning rapidly from mistakes. If a user receives a number of irrelevant posts, this would be detrimental to their user experience and the model should learn as soon as possible that its predictions are not correct. Online learning or reinforcement learning is therefore great for this use case.</p>
			<p>For more information<a id="_idIndexMarker473"/> about such use cases, you can find some materials here:</p>
			<ul>
				<li><a href="https://arxiv.org/abs/1601.00667">https://arxiv.org/abs/1601.00667</a></li>
				<li><a href="https://rbcdsai.iitm.ac.in/blogs/finding-influencers-in-social-networks-reinforcement-learning-shows-the-way/">https://rbcdsai.iitm.ac.in/blogs/finding-influencers-in-social-networks-reinforcement-learning-shows-the-way/</a></li>
			</ul>
			<h2 id="_idParaDest-170"><a id="_idTextAnchor177"/>Use case three – a self-driving car</h2>
			<p>Reinforcement learning<a id="_idIndexMarker474"/> has also been proposed for the use case of self-driving cars. As you probably know, self-driving cars have been increasingly gaining attention over the last few years. The goal is to make machine learning or artificial intelligence models that can replace the behavior of human drivers.</p>
			<p>It is easy to understand that the essential part of this model will be to take actions: accelerate, slow down, brake, turn, and so on. If a good enough reinforcement learning model could be built to obtain all those skills, it would be a great candidate for building self-driving cars.</p>
			<p>Self-driving cars need to respond to a large stream of data about the environment. For example, they need to detect cars, roads, road signs, and much more on a continuous video stream that is being filmed on multiple cameras, together with other sensors potentially. </p>
			<p>Real-time responses are key<a id="_idIndexMarker475"/> in this scenario. Retraining the model in real time might be more problematic, as you would want to make sure that the model is not applying a trial-and-error methodology while on the road.</p>
			<p>More information<a id="_idIndexMarker476"/> on this can be found at the following links:</p>
			<ul>
				<li><a href="https://arxiv.org/ftp/arxiv/papers/1901/1901.00569.pdf">https://arxiv.org/ftp/arxiv/papers/1901/1901.00569.pdf</a></li>
				<li><a href="https://www.ingentaconnect.com/contentone/ist/ei/2017/00002017/00000019/art00012?crawler=true&amp;mimetype=application/pdf">https://www.ingentaconnect.com/contentone/ist/ei/2017/00002017/00000019/art00012?crawler=true&amp;mimetype=application/pdf</a></li>
			</ul>
			<h2 id="_idParaDest-171"><a id="_idTextAnchor178"/>Use case four – chatbots</h2>
			<p>Another very different but<a id="_idIndexMarker477"/> also very advanced use case of machine learning is the development of chatbots. Intelligent chatbots are still rare, but we can expect to see chatbots become more intelligent in the near future.</p>
			<p>Chatbots<a id="_idIndexMarker478"/> need to be able to generate a response to a person while treating the information that was given to it by a user. The chatbot is therefore performing a sort of action: replying to the human.</p>
			<p>Reinforcement learning in combination with other techniques from the domain of natural language processing can be a good solution for such problems. By letting the chatbot talk with users, a reward can be given by the human user in the form of, for example, an evaluation of the usefulness of their interaction. This reward can then help the reinforcement learning agent adapt its policy and make replies more appropriate in future interactions.</p>
			<p>Chatbots need to be able to respond in real time, as no one wants to wait for an answer from a chatbot interaction. Learning can be done in an online or an offline fashion, but reinforcement learning is definitely one of the suitable alternatives.</p>
			<p>You can read more<a id="_idIndexMarker479"/> on this use case here:</p>
			<ul>
				<li><a href="https://arxiv.org/abs/1709.02349">https://arxiv.org/abs/1709.02349</a></li>
				<li><a href="https://arxiv.org/pdf/1908.10331.pdf">https://arxiv.org/pdf/1908.10331.pdf</a></li>
			</ul>
			<h2 id="_idParaDest-172"><a id="_idTextAnchor179"/>Use case five – learning games</h2>
			<p>As a final use case example<a id="_idIndexMarker480"/> for reinforcement learning, let's talk about the use case of learning games. It may be less valuable for business, but it is still an interesting use case of reinforcement learning.</p>
			<p>Over the past years, reinforcement learning agents have learned to play a number of games, including chess and Go. There is a clear set of moves that can be made at each step, and by playing many simulated (or real) games, the models can learn which policy (decision rules for the step to take) are the best.</p>
			<p>In the end, the agent has such a powerful policy that it can often beat the best human players in the world at such games.</p>
			<p>You can find more<a id="_idIndexMarker481"/> examples of this<a id="_idIndexMarker482"/> at the following links:</p>
			<ul>
				<li><a href="https://www.science.org/doi/10.1126/science.aar6404">https://www.science.org/doi/10.1126/science.aar6404</a></li>
				<li><a href="https://arxiv.org/pdf/1912.10944.pdf">https://arxiv.org/pdf/1912.10944.pdf</a></li>
			</ul>
			<p>Now that we have explored some of the use cases for reinforcement learning, let's implement it using Python, in the next section.</p>
			<h1 id="_idParaDest-173"><a id="_idTextAnchor180"/>Implementing reinforcement learning in Python</h1>
			<p>Let's now move on to an example<a id="_idIndexMarker483"/> in which streaming data<a id="_idIndexMarker484"/> is used for Q-Learning. The data that we will be using is simulated data of stock prices: </p>
			<ol>
				<li value="1">The data is generated in the following block of code.</li>
			</ol>
			<p>The list of values that is first generated is a list of 30,000 consecutive values that represent stock prices. The data generating process is the starting point of 0 and at every time step, there is a random value added to this. The random normal values are centered around 0, which indicates that prices would go up or down by a step size based on a standard deviation of 1.</p>
			<p>This process is often referred to as a random walk<a id="_idIndexMarker485"/> and it can go quite far up or down. After that, the values are standardized to be within a normal distribution again.</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Code Block 8-1</p>
			<p class="source-code">import numpy as np</p>
			<p class="source-code">import matplotlib.pyplot as plt</p>
			<p class="source-code">import random</p>
			<p class="source-code">starting = 0</p>
			<p class="source-code">values = [starting]</p>
			<p class="source-code">for i in range(30000):</p>
			<p class="source-code">    values.append(values[-1] + np.random.normal())</p>
			<p class="source-code">values = (values - np.mean(values)) / np.std(values)</p>
			<p class="source-code">plt.plot(values)</p>
			<p>The resulting<a id="_idIndexMarker486"/> plot can be seen in the following<a id="_idIndexMarker487"/>:</p>
			<div>
				<div id="_idContainer098" class="IMG---Figure">
					<img src="image/B18335_08_5.jpg" alt="Figure 8.5 – The resulting plot from the preceding code block &#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.5 – The resulting plot from the preceding code block </p>
			<ol>
				<li value="2">Now, for a reinforcement problem, it is necessary to have a finite number of states. Of course, if we consider<a id="_idIndexMarker488"/> stock prices, we could collect<a id="_idIndexMarker489"/> up to an infinite number of decimals. The data is rounded to 1 decimal to limit the number of possible state data points:</li>
			</ol>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Code Block 8-2</p>
			<p class="source-code">rounded_values = []</p>
			<p class="source-code">for value in values:</p>
			<p class="source-code">    rounded_values.append(round(value, 1))</p>
			<p class="source-code">plt.plot(rounded_values)</p>
			<p>The resulting graph is shown in the following figure:</p>
			<div>
				<div id="_idContainer099" class="IMG---Figure">
					<img src="image/B18335_08_6.jpg" alt="Figure 8.6 – The graph resulting from the preceding code block &#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.6 – The graph resulting from the preceding code block </p>
			<ol>
				<li value="3">We can now set the states' potential values<a id="_idIndexMarker490"/> to all of the values that have happened<a id="_idIndexMarker491"/> in the past. We can also initiate a policy.</li>
			</ol>
			<p>As seen in the theoretical part of this chapter, the policy represents the rules of the reinforcement learning agent. In some cases, there is a very specific ruleset, but in Q-learning, there is only a Q-value (quality) for each combination of state and action.</p>
			<p>In our example, let's consider a stock trading bot that can only do two things at a time<em class="italic"> t</em>. Either the trading bot buys at time <em class="italic">t</em> and sells at <em class="italic">t+1</em>, or it sells at time <em class="italic">t</em> and closes the sell position at time <em class="italic">t+1</em>. Without going into stock trading too much, the important things to understand about this are the following:</p>
			<ul>
				<li>When the agent buys, it should do so because it expects the stock market to go up.</li>
				<li>When the agent opens a sell order, it should do so because it expects the stock market to go down.</li>
			</ul>
			<p>As information, our stock trader will be very limited. The only data point in the state is the price at time t. The goal here is not to make a great model, but to show the principles of building a reinforcement learning agent on a stock trading example. In reality, you'd need much more information in the state to decide on your action:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Code Block 8-3</p>
			<p class="source-code">states = set(rounded_values)</p>
			<p class="source-code">import pandas as pd</p>
			<p class="source-code">policy = pd.DataFrame(0, index=states, columns=['buy', 'sell'])</p>
			<ol>
				<li value="4">The function defined hereafter is how to obtain an action (sell or buy) based on the Q-table. It is not entirely<a id="_idIndexMarker492"/> correct to refer to the Q table<a id="_idIndexMarker493"/> as the policy, but it does make it more understandable.</li>
			</ol>
			<p>The action chosen is that with the highest Q value for a given state (state is the current value of the stock):</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Code Block 8-4</p>
			<p class="source-code">def find_action(policy, current_value):</p>
			<p class="source-code">    </p>
			<p class="source-code">    if policy.loc[current_value,:].sum() == 0:</p>
			<p class="source-code">        return random.choice([ 'buy', 'sell'])</p>
			<p class="source-code">    return policy.columns[policy.loc[current_value,:].argmax()]</p>
			<ol>
				<li value="5">It is also necessary to define an update rule. In this example, the update rule is based on the Bellman equation that was explained earlier on. However, keep in mind that the agent is fairly simple, and the discounting part is not really relevant. Discounting is useful to make an agent prefer short-term gains over long-term gains. The current agent always makes its gains in one time step, so discounting is of no added value. In a real stock-trading bot, this would be very important: you wouldn't put your money on a stock that will double over 20 years if you could double it in 1 year instead:</li>
			</ol>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Code Block 8-5</p>
			<p class="source-code">def update_policy(reward, current_state_value, action):</p>
			<p class="source-code">    </p>
			<p class="source-code">    LEARNING_RATE = 0.1</p>
			<p class="source-code">    MAX_REWARD = 10</p>
			<p class="source-code">    DISCOUNT_FACTOR = 0.05</p>
			<p class="source-code">    </p>
			<p class="source-code">    return LEARNING_RATE * (reward + DISCOUNT_FACTOR * MAX_REWARD - policy.loc[current_state_value,action])</p>
			<ol>
				<li value="6">We now get to the execution<a id="_idIndexMarker494"/> of the model. We start by setting <strong class="source-inline">past_state</strong> to 0 and <strong class="source-inline">past_action</strong> to <strong class="source-inline">buy</strong>. The total<a id="_idIndexMarker495"/> reward is initialized at 0 and an accumulator list for rewards is instantiated.</li>
			</ol>
			<p>The code will then loop through the rounded values. This is a process that copies a data stream. If the data arrived one by one, the agent would be able to learn in exactly the same manner. The essence is an update of the Q table at every learning step.</p>
			<p>Within each iteration, the model will execute the best action, where the best is based on the Q values of the Q values table (policy). The model will also receive the reward from time step t-1, as this was defined as the only option for the stock trading bot. Those rewards will be used to update the Q table so that the next round can have updated information:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Code Block 8-6</p>
			<p class="source-code">past_state_value = 0</p>
			<p class="source-code">past_action = 'buy'</p>
			<p class="source-code">total_reward = 0.</p>
			<p class="source-code">rewards = []</p>
			<p class="source-code">for i, current_state_value in enumerate(rounded_values):</p>
			<p class="source-code">    </p>
			<p class="source-code">    # do the action</p>
			<p class="source-code">    action = find_action(policy, current_state_value)</p>
			<p class="source-code">    </p>
			<p class="source-code">    </p>
			<p class="source-code">    # also compute reward from previous action and update state</p>
			<p class="source-code">    if past_action == 'buy':</p>
			<p class="source-code">        reward = current_state_value - past_state_value</p>
			<p class="source-code">        </p>
			<p class="source-code">    if past_action == 'sell':</p>
			<p class="source-code">        reward = past_state_value - current_state_value</p>
			<p class="source-code">    </p>
			<p class="source-code">    total_reward = total_reward + float(reward)</p>
			<p class="source-code">    </p>
			<p class="source-code">    policy.loc[current_state_value, action] = policy.loc[current_state_value, action] + update_policy(reward, current_state_value,action)</p>
			<p class="source-code">    </p>
			<p class="source-code">    #print(policy)</p>
			<p class="source-code">    rewards.append(total_reward)</p>
			<p class="source-code">    </p>
			<p class="source-code">    past_action = action</p>
			<p class="source-code">    past_state_value = current_state_value</p>
			<ol>
				<li value="7">In the following plot, you see how<a id="_idIndexMarker496"/> the model is getting its rewards. In the beginning, total<a id="_idIndexMarker497"/> rewards are negative for a long time, and then they are positive at the end. Keep in mind that we are learning on input data that is hypothetical and that represents a random walk. If we wanted an actual intelligent stock trading bot, we'd need to give it much more and much better data:</li>
			</ol>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Code Block 8-7</p>
			<p class="source-code">plt.plot(rewards)</p>
			<p>The resulting graph is shown hereafter:</p>
			<div>
				<div id="_idContainer100" class="IMG---Figure">
					<img src="image/B18335_08_7.jpg" alt="Figure 8.7 – The graph resulting from the preceding code block &#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.7 – The graph resulting from the preceding code block </p>
			<ol>
				<li value="8">The following plot shows a heat map of the Q values against the policy. The values at the top of the table<a id="_idIndexMarker498"/> are the preferred action when stock<a id="_idIndexMarker499"/> prices are low, and the values at the bottom are preferred actions when stock prices are high. The color light yellow means high-quality actions, and the color black means low-quality actions:</li>
			</ol>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Code Block 8-8</p>
			<p class="source-code">import seaborn as sns</p>
			<p class="source-code">sns.heatmap(policy.sort_index())</p>
			<p>The resulting heatmap is shown here:</p>
			<div>
				<div id="_idContainer101" class="IMG---Figure">
					<img src="image/B18335_08_8.jpg" alt="Figure 8.8 – The heatmap resulting from the preceding code block &#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.8 – The heatmap resulting from the preceding code block </p>
			<p>It is interesting to see that the model seems to have started to learn a basic rule in stock trading: buy low, sell high. This can be seen by more yellow in selling at high prices and more yellow in buying at low prices. Apparently, this rule is even true on simulated random walk data.</p>
			<p>To learn more advanced rules, the agent would need to have more data in the state, and therefore the Q table<a id="_idIndexMarker500"/> would also become much heavier. An example<a id="_idIndexMarker501"/> of what you could add is a rolling history of prices so that the agent knows whether you are in an uptrend or a downtrend. You could also add macro-economic factors, sentiment estimations, or any other data.</p>
			<p>You could also make the action structure much more advanced. Rather than having only one-day sell or buy trades, it would be much more interesting to have a model that can buy or sell any equity in its portfolio at any time that the agent decides to.</p>
			<p>Of course, you would also need to provide enough data to allow the model to make estimations for all these scenarios. The more scenarios you take into account, the more time it will take the agent to learn how to behave correctly.</p>
			<h1 id="_idParaDest-174"><a id="_idTextAnchor181"/>Summary</h1>
			<p>In this chapter, you were first introduced to the underlying foundations of reinforcement learning. You saw that reinforcement learning models are focused on taking actions rather than on making predictions.</p>
			<p>You also saw two widely known algorithms for reinforcement learning. This started with Q-learning, which is the foundational algorithm of reinforcement learning, and its more powerful improvement, Deep Q-learning.</p>
			<p>Reinforcement learning is often used for more advanced use cases such as chatbots or self-driving cars, but can also be used for numerical data streams very well. Through a use case, you saw how to apply reinforcement learning to streaming data for finance.</p>
			<p>With this chapter, you have come to the end of discovering the most relevant machine learning models for online learning. In the coming chapters, you will discover a number of additional tools that you will need to take into account in online learning and that have no real counterpart in traditional ML. You will first have a deep dive into all types of data and model drift and then discover how to deal with models that go totally in the wrong direction through catastrophic forgetting.</p>
			<h1 id="_idParaDest-175"><a id="_idTextAnchor182"/>Further reading</h1>
			<ul>
				<li>Reinforcement learning applications: <a href="https://neptune.ai/blog/reinforcement-learning-applications">https://neptune.ai/blog/reinforcement-learning-applications</a></li>
				<li>Q-learning: <a href="https://en.wikipedia.org/wiki/Q-learning">https://en.wikipedia.org/wiki/Q-learning</a></li>
				<li>Deep Q-learning: <a href="https://en.wikipedia.org/wiki/Deep_reinforcement_learning">https://en.wikipedia.org/wiki/Deep_reinforcement_learning</a></li>
			</ul>
		</div>
	</body></html>