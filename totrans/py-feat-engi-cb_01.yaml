- en: <st c="0">1</st>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="2">Imputing Missing Data</st>
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="23">Missing data—meaning the absence</st> <st c="56">of values for certain
    observations—is an unavoidable problem in most data sources.</st> <st c="140">Some
    machine learning model implementations can handle missing data out of the box.</st>
    <st c="224">To train other models, we must remove observations with missing data
    or transform them into</st> <st c="316">permitted values.</st>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: <st c="333">The act of replacing missing data</st> <st c="367">with their statistical
    estimates is called</st> **<st c="411">imputation</st>**<st c="421">. The goa</st><st
    c="430">l of any imputation technique is to produce a complete dataset.</st> <st
    c="495">There are multiple imputation methods.</st> <st c="534">We select which
    one to use, depending on whether the data is missing at random, the proportion
    of missing values, and the machine learning model we intend to use.</st> <st c="697">In
    this chapter, we will discuss several</st> <st c="738">imputation methods.</st>
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: <st c="757">This chapter will cover the</st> <st c="786">following recipes:</st>
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: <st c="804">Removing observations with</st> <st c="832">missing data</st>
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="844">Performing mean or</st> <st c="864">median imputation</st>
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="881">Imputing</st> <st c="891">categorical variables</st>
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="912">Replacing missing values with an</st> <st c="946">arbitrary number</st>
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="962">Finding extreme values</st> <st c="986">for imputation</st>
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1000">Marking</st> <st c="1009">imputed values</st>
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1023">Implementing forward and</st> <st c="1049">backward fill</st>
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1062">Carrying</st> <st c="1072">out interpolation</st>
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1089">Performing multivariate imputation by</st> <st c="1128">chained
    equations</st>
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1145">Estimating missing data with</st> <st c="1175">nearest neighbo</st><st
    c="1190">r</st><st c="1192">s</st>
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1193">Technical requirements</st>
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="1215">In this chapter, we will use the Python libraries Matplotlib, pandas,
    NumPy, scikit-learn, and Feature-engine.</st> <st c="1327">If you need to install
    Python, the free Anaconda Python distribution (</st>[<st c="1397">https://www.anaconda.com/</st>](https://www.anaconda.com/)<st
    c="1423">) includes most numerical</st> <st c="1450">computing libraries.</st>
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '`<st c="1470">feature-engine</st>` <st c="1485">can be installed with</st>
    `<st c="1508">pip</st>` <st c="1511">as follows:</st>'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: <st c="1550">If you use Anaconda, you can install</st> `<st c="1588">feature-engine</st>`
    <st c="1602">with</st> `<st c="1608">conda</st>`<st c="1613">:</st>
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: <st c="1659">Note</st>
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1664">The recipes from this chapter were created using the latest versions
    of the Python libraries at the time of publishing.</st> <st c="1785">You can check
    the versions in the</st> `<st c="1819">requirements.txt</st>` <st c="1835">file
    in the accompanying GitHub repository,</st> <st c="1880">at</st> [<st c="1883">https://github.com/PacktPublishing/Python-Feature-engineering-Cookbook-Third-Edition/blob/main/requirements.txt</st>](https://github.com/PacktPublishing/Python-Feature-engineering-Cookbook-Third-Edition/blob/main/requirements.txt)<st
    c="1994">.</st>
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的食谱是在出版时使用的Python库的最新版本中创建的。<st c="1664">您可以在随附的GitHub仓库中的</st> `<st c="1819">requirements.txt</st>`
    <st c="1835">文件中检查版本，</st> <st c="1880">网址为</st> [<st c="1883">https://github.com/PacktPublishing/Python-Feature-engineering-Cookbook-Third-Edition/blob/main/requirements.txt</st>](https://github.com/PacktPublishing/Python-Feature-engineering-Cookbook-Third-Edition/blob/main/requirements.txt)<st
    c="1994">。</st>
- en: <st c="1995">We will use the</st> **<st c="2012">Credit Approval</st>** <st
    c="2027">dataset from the</st> *<st c="2045">UCI Machine Learning Repository</st>*
    <st c="2076">(</st>[<st c="2078">https://archive.ics.uci.edu/</st>](https://archive.ics.uci.edu/)<st
    c="2106">), licensed under the CC BY 4.0 creative commons attribution:</st> [<st
    c="2169">https://creativecommons.org/licenses/by/4.0/legalcode</st>](https://creativecommons.org/licenses/by/4.0/legalcode)<st
    c="2222">. You’ll find the dataset at this</st> <st c="2256">link:</st> [<st c="2262">http://archive.ics.uci.edu/dataset/27/credit+approval</st>](http://archive.ics.uci.edu/dataset/27/credit+approval)<st
    c="2315">.</st>
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用**<st c="2012">信用审批</st>** <st c="2027">数据集，该数据集来自*<st c="2045">UCI机器学习仓库</st>*
    <st c="2076">（</st>[<st c="2078">https://archive.ics.uci.edu/</st>](https://archive.ics.uci.edu/)<st
    c="2106">），许可协议为CC BY 4.0创意共享：</st> [<st c="2169">https://creativecommons.org/licenses/by/4.0/legalcode</st>](https://creativecommons.org/licenses/by/4.0/legalcode)<st
    c="2222">。您可以在以下链接找到数据集：</st> [<st c="2262">http://archive.ics.uci.edu/dataset/27/credit+approval</st>](http://archive.ics.uci.edu/dataset/27/credit+approval)<st
    c="2315">。</st>
- en: <st c="2316">I downloaded and modified the data as shown in this</st> <st c="2369">notebook:</st>
    [<st c="2379">https://github.com/PacktPublishing/Python-Feature-engineering-Cookbook-Third-Edition/blob/main/ch01-missing-data-imputation/credit-approval-dataset.ipynb</st>](https://github.com/PacktPublishing/Python-Feature-engineering-Cookbook-Third-Edition/blob/main/ch01-missing-data-imputation/credit-approval-dataset.ipynb)
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我已下载并修改了如下笔记本中的数据：<st c="2316">[此笔记本](https://github.com/PacktPublishing/Python-Feature-engineering-Cookbook-Third-Edition/blob/main/ch01-missing-data-imputation/credit-approval-dataset.ipynb)</st>。
- en: <st c="2532">We will also use the</st> **<st c="2554">air passenger</st>** <st
    c="2567">dataset located in Facebook’s Prophet GitHub repository (</st>[<st c="2625">https://github.com/facebook/prophet/blob/main/examples/example_air_passengers.csv</st>](https://github.com/facebook/prophet/blob/main/examples/example_air_passengers.csv)<st
    c="2707">), licensed under the MIT</st> <st c="2734">license:</st> [<st c="2743">https://github.com/facebook/prophet/blob/main/LICENSE</st>](https://github.com/facebook/prophet/blob/main/LICENSE)
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用位于Facebook的Prophet GitHub仓库中的**<st c="2554">航空乘客</st>** <st c="2567">数据集（</st>[<st
    c="2625">https://github.com/facebook/prophet/blob/main/examples/example_air_passengers.csv</st>](https://github.com/facebook/prophet/blob/main/examples/example_air_passengers.csv)<st
    c="2707">），许可协议为MIT：</st> [<st c="2743">https://github.com/facebook/prophet/blob/main/LICENSE</st>](https://github.com/facebook/prophet/blob/main/LICENSE)。
- en: <st c="2796">I modified the data as shown in this</st> <st c="2834">notebook:</st>
    [<st c="2844">https://github.com/PacktPublishing/Python-Feature-engineering-Cookbook-Third-Edition/blob/main/ch01-missing-data-imputation/air-passengers-dataset.ipynb</st>](https://github.com/PacktPublishing/Python-Feature-engineering-Cookbook-Third-Edition/blob/main/ch01-missing-data-imputation/air-passengers-dataset.ipynb)
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我已修改了如下笔记本中的数据：<st c="2796">[此笔记本](https://github.com/PacktPublishing/Python-Feature-engineering-Cookbook-Third-Edition/blob/main/ch01-missing-data-imputation/air-passengers-dataset.ipynb)</st>。
- en: <st c="2996">You’ll find a copy of the modified data sets in the accompanying
    GitHub</st> <st c="3069">repository:</st> [<st c="3081">https://github.com/PacktPublishing/Python-Feature-engineering-Cookbook-Third-Edition/blob/main/ch01-missing-data-imputatio</st><st
    c="3203">n</st><st c="3205">/</st>](https://github.com/PacktPublishing/Python-Feature-engineering-Cookbook-Third-Edition/blob/main/ch01-missing-data-imputation/)
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="2996">你可以在附带的GitHub存储库中找到修改后的数据集的副本：</st> [<st c="3081">https://github.com/PacktPublishing/Python-Feature-engineering-Cookbook-Third-Edition/blob/main/ch01-missing-data-imputation</st><st
    c="3203">/</st>](https://github.com/PacktPublishing/Python-Feature-engineering-Cookbook-Third-Edition/blob/main/ch01-missing-data-imputation/)
- en: <st c="3206">Removing observations with missing data</st>
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="3206">删除具有缺失数据的观察值</st>
- en: '**<st c="3245">Complete Case Analysis</st>** <st c="3268">(</st>**<st c="3270">CCA</st>**<st
    c="3273">), als</st><st c="3280">o called list-wis</st><st c="3298">e deletion
    of cases, consists</st> <st c="3328">of discarding</st> <st c="3342">observations</st>
    <st c="3355">with missing data.</st> <st c="3375">CCA can be applied to both categorical</st>
    <st c="3413">and numerical variables.</st> <st c="3439">With CCA, we pre</st><st
    c="3455">serve the distribution o</st><st c="3480">f the variables after the imputation,
    provided the data is missing at random and only in a small proportion of observations.</st>
    <st c="3606">However, if data is missing across many variables, CCA may lead to
    the removal of a large portion of</st> <st c="3707">the dataset.</st>'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**<st c="3245">完整案例分析</st>** <st c="3268">(</st>**<st c="3270">CCA</st>**<st
    c="3273">**)，也称为案例列表删除，包括丢弃具有缺失数据的观察值。</st> <st c="3328">CCA可以应用于分类</st> <st c="3375">和数值变量。</st>
    <st c="3439">使用CCA，我们可以在插补后保留变量的分布，前提是数据缺失是随机的，并且仅在少量观察值中。</st> <st c="3606">然而，如果数据在许多变量中缺失，CCA可能会导致大量数据集的删除。</st>'
- en: <st c="3719">Note</st>
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3719">注</st>
- en: <st c="3724">Use CCA only when a small number of observations are missing and
    you have good reasons to believe that they are not important to</st> <st c="3854">your
    m</st><st c="3860">odel.</st>
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3724">仅在少量观察值缺失且你有充分的理由相信它们对你的模型不重要时才使用CCA。</st>
- en: <st c="3866">How to do it...</st>
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="3866">如何操作...</st>
- en: <st c="3882">Let’s begin by making some imports and loading</st> <st c="3930">the
    dataset:</st>
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3882">让我们首先进行一些导入并加载数据集：</st> <st c="3930">：</st>
- en: <st c="3942">Let’s import</st> `<st c="3956">pandas</st>`<st c="3962">,</st>
    `<st c="3964">matplotlib</st>`<st c="3974">, and the train/test split function</st>
    <st c="4010">from scikit-learn:</st>
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="3942">让我们导入</st> `<st c="3956">pandas</st>`<st c="3962">，`<st c="3964">matplotlib</st>`<st
    c="3974">，以及来自scikit-learn的训练/测试分割函数</st> <st c="4010">：</st>
- en: '[PRE2]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: <st c="4133">Let’s load and display the dataset described in the</st> *<st c="4186">Technical</st>*
    *<st c="4196">requirements</st>* <st c="4208">section:</st>
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="4133">让我们加载并显示在*《技术要求》*部分中描述的数据集：</st>
- en: '[PRE3]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: <st c="4275">In the following image, we see the first 5 rows</st> <st c="4324">of
    data:</st>
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="4275">在以下图像中，我们看到了数据的前5行</st> <st c="4324">：</st>
- en: '![Figure 1.1 – First 5 rows of the dataset](img/B22396_01_01.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图1.1 – 数据集的前5行](img/B22396_01_01.jpg)'
- en: <st c="4633">Figure 1.1 – First 5 rows of the dataset</st>
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4633">图1.1 – 数据集的前5行</st>
- en: <st c="4673">Let’s proceed as we normally</st> <st c="4702">would if we were
    preparing</st> <st c="4729">the data to train machine learning models; by splitting
    the data into a training and a</st> <st c="4817">test set:</st>
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="4673">让我们像通常准备训练机器学习模型数据那样进行操作：</st> <st c="4702">：</st> <st c="4729">通过将数据分为训练集和测试集：</st>
- en: '[PRE4]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: <st c="4959">Let’s now make a bar plot with the proportion of missing data per
    variable in the training and</st> <st c="5055">te</st><st c="5057">st sets:</st>
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="4959">现在让我们绘制一个条形图，显示训练集和测试集中每个变量的缺失数据比例：</st> <st c="5055">：</st>
- en: '[PRE5]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: <st c="5395">The previous code block returns</st> <st c="5427">the following
    bar plots</st> <st c="5451">with the fraction of missing data per variable in
    the training (top) and test</st> <st c="5530">sets (b</st><st c="5537">ottom):</st>
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="5395">前面的代码块返回以下条形图</st> <st c="5427">，显示了训练集（顶部）和测试集（底部）中每个变量的缺失数据比例：</st>
- en: '![Figure 1.2 – Proportion of missing data per variable](img/B22396_01_02.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图1.2 – 每个变量的缺失数据比例](img/B22396_01_02.jpg)'
- en: <st c="5717">Figure 1.2 – Proportion of missing data per variable</st>
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5717">图1.2 – 每个变量的缺失数据比例</st>
- en: <st c="5769">Now</st><st c="5773">, we’ll remove obser</st><st c="5793">vations
    if they have missing values in</st> <st c="5833">any variable:</st>
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="5769">现在</st><st c="5773">，我们将删除任何变量中存在缺失值的观测值：</st>
- en: '[PRE6]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: <st c="5902">Note</st>
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5902">注意</st>
- en: <st c="5907">pandas’</st> `<st c="5916">dropna()</st>`<st c="5924">drops observations
    with any missing value by default.</st> <st c="5979">We can remove observations
    with missing data in a subset of variables like this:</st> `<st c="6060">data.dropna(subset=["A3",
    "A4"])</st>`<st c="6092">.</st>
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5907">pandas的</st> `<st c="5916">dropna()</st>`<st c="5924">默认删除任何缺失值的观测值。</st>
    <st c="5979">我们可以像这样删除变量子集中具有缺失数据的观测值：</st> `<st c="6060">data.dropna(subset=["A3",
    "A4"])</st>`<st c="6092">。</st>
- en: <st c="6093">Let’s print and compare the size of the original and complete</st>
    <st c="6156">case datasets:</st>
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="6093">让我们打印并比较原始和完整</st> <st c="6156">案例数据集的大小：</st>
- en: '[PRE7]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: <st c="6268">We removed more than 200 observations with missing data from the
    training set, as shown in the</st> <st c="6364">following output:</st>
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="6268">我们从训练集中删除了超过200个具有缺失数据的观测值，如下面的输出所示：</st>
- en: '[PRE8]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: <st c="6435">After removing</st> <st c="6450">observations from the training</st>
    <st c="6481">and test sets, we need to align the</st> <st c="6518">target variables:</st>
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="6435">从训练集和测试集中删除观测值后，我们需要对齐</st> <st c="6518">目标变量：</st>
- en: '[PRE9]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: <st c="6618">Now, the datasets and target variables contain the rows without</st>
    <st c="6683">missing data.</st>
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="6618">现在，数据集和目标变量包含没有</st> <st c="6683">缺失数据的行。</st>
- en: <st c="6696">To drop observations with missing data utilizing</st> `<st c="6746">feature-engine</st>`<st
    c="6760">, let’s import the</st> <st c="6779">required transformer:</st>
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="6696">要使用</st> `<st c="6746">feature-engine</st>`<st c="6760">删除具有缺失数据的观测值，让我们导入所需的变压器：</st>
- en: '[PRE10]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: <st c="6854">Let</st><st c="6858">’s set up the imputer to auto</st><st c="6888">matically
    find the variables with</st> <st c="6923">missing data:</st>
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="6854">让我们设置填充器以自动</st><st c="6858">找到具有</st> <st c="6888">缺失数据的变量：</st>
- en: '[PRE11]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: <st c="6993">Let’s fit the transformer so that it finds the variables with</st>
    <st c="7056">missing data:</st>
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="6993">让我们拟合变压器，以便它找到具有</st> <st c="7056">缺失数据的变量：</st>
- en: '[PRE12]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: <st c="7086">Let’s inspect the variables with NAN that the</st> <st c="7133">transformer
    found:</st>
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="7086">让我们检查变压器发现的具有NAN的变量：</st>
- en: '[PRE13]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: <st c="7166">The previous command returns the names of the variables with</st>
    <st c="7228">missing data:</st>
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="7166">之前的命令返回了具有</st> <st c="7228">缺失数据的变量名称：</st>
- en: '[PRE14]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: <st c="7310">Let’s remove the rows with missing data in the training and</st>
    <st c="7371">test sets:</st>
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="7310">让我们删除训练集和</st> <st c="7371">测试集中具有缺失数据的行：</st>
- en: '[PRE15]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: <st c="7449">Use</st> `<st c="7454">train_cca.isnull().sum()</st>` <st c="7478">to
    corroborate</st> <st c="7493">the absence of missing data in the complete</st>
    <st c="7537">case dataset.</st>
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="7449">使用</st> `<st c="7454">train_cca.isnull().sum()</st>` <st c="7478">来证实完整</st>
    <st c="7493">案例数据集中没有缺失数据。</st>
- en: '`<st c="7551">DropMissingData</st>` <st c="7567">can automatically adjust the
    target after removing missing data from the</st> <st c="7641">training set:</st>'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`<st c="7551">DropMissingData</st>` <st c="7567">可以在从训练集中删除缺失数据后自动调整目标：</st>'
- en: '[PRE16]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: <st c="7765">The previous code removed rows with</st> `<st c="7802">nan</st>`
    <st c="7805">from the training and test sets and then re-aligned the</st> <st
    c="7862">target variables.</st>
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7765">之前的代码从训练集和测试集中删除了包含</st> `<st c="7802">nan</st>` <st c="7805">的行，然后重新对齐了</st>
    <st c="7862">目标变量。</st>
- en: <st c="7879">Note</st>
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7879">注意</st>
- en: <st c="7884">To remove observations with missing data in a subset of variables,
    use</st> `<st c="7956">DropMissingData(variables=['A3', 'A4'])</st>`<st c="7995">.
    To remove rows with</st> `<st c="8017">nan</st>` <st c="8020">in at least 5% of
    the variables,</st> <st c="8054">use</st> `<st c="8058">DropMissingData(thres</st><st
    c="8079">hold=0.95)</st>`<st c="8090">.</st>
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7884">要从变量子集中删除具有缺失数据的观测值，请使用</st> `<st c="7956">DropMissingData(variables=['A3',
    'A4'])</st>`<st c="7995">。要删除至少5%的变量中包含</st> `<st c="8017">nan</st>` <st c="8020">的行，请使用</st>
    `<st c="8058">DropMissingData(threshold=0.95)</st>`<st c="8090">。</st>
- en: <st c="8091">How it works</st><st c="8104">...</st>
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="8091">工作原理</st><st c="8104">...</st>
- en: <st c="8107">In this recipe,</st> <st c="8123">we plotted</st> <st c="8134">the
    proportion of missing data</st> <st c="8165">in each variable and then removed
    all observations with</st> <st c="8222">missing values.</st>
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="8107">在这个菜谱中，</st> <st c="8123">我们绘制了每个变量中缺失数据的比例，然后删除了所有具有</st> <st
    c="8222">缺失值</st>的观测值。</st>
- en: <st c="8237">We used</st> `<st c="8246">pandas</st>` `<st c="8252">isnull()</st>`
    <st c="8261">and</st> `<st c="8266">mean()</st>` <st c="8272">methods to determine
    the proportion of missing observations in each variable.</st> <st c="8351">The</st>
    `<st c="8355">isnull()</st>` <st c="8363">method created a Boolean vector per
    variable with</st> `<st c="8414">True</st>` <st c="8418">and</st> `<st c="8423">False</st>`
    <st c="8428">values indicating whether a value was missing.</st> <st c="8476">The</st>
    `<st c="8480">mean()</st>` <st c="8486">method took the average of these values
    and returned the proportion of</st> <st c="8558">missing data.</st>
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="8237">我们使用了</st> `<st c="8246">pandas</st>` `<st c="8252">isnull()</st>`
    <st c="8261">和</st> `<st c="8266">mean()</st>` <st c="8272">方法来确定每个变量中缺失观测值的比例。</st>
    <st c="8351">`<st c="8355">isnull()</st>` <st c="8363">方法为每个变量创建了一个布尔向量，其中包含</st>
    `<st c="8414">True</st>` <st c="8418">和</st> `<st c="8423">False</st>` <st c="8428">值，表示值是否缺失。</st>
    <st c="8476">`<st c="8480">mean()</st>` <st c="8486">方法取这些值的平均值，并返回缺失数据的比例。</st>
- en: <st c="8571">We used</st> `<st c="8580">pandas</st>` `<st c="8586">plot.bar()</st>`
    <st c="8597">to create a bar plot of the fraction of missing data per variable.</st>
    <st c="8665">In</st> *<st c="8668">Figure 1</st>**<st c="8676">.2</st>*<st c="8678">,
    we saw the fraction of</st> `<st c="8703">nan</st>` <st c="8706">per variable
    in the training and</st> <st c="8740">test sets.</st>
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="8571">我们使用了</st> `<st c="8580">pandas</st>` `<st c="8586">plot.bar()</st>`
    <st c="8597">来创建每个变量的缺失数据分数的条形图。</st> <st c="8665">在</st> *<st c="8668">图 1</st>**<st
    c="8676">.2</st>*<st c="8678">中，我们看到了训练集和测试集中每个变量的</st> `<st c="8703">nan</st>`
    <st c="8706">分数。</st>
- en: <st c="8750">To remove observations with missing values in</st> *<st c="8797">any</st>*
    <st c="8800">variable, we used pandas’</st> `<st c="8827">dropna()</st>`<st c="8835">,
    thereby obtaining a complete</st> <st c="8866">case dataset.</st>
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="8750">为了删除任何变量中存在缺失值的观测值，我们使用了 pandas 的</st> `<st c="8827">dropna()</st>`<st
    c="8835">，从而获得一个完整的</st> <st c="8866">案例数据集。</st>
- en: <st c="8879">Finally, we removed missing data using Feature-engine’s</st> `<st
    c="8936">DropMissingData()</st>`<st c="8953">. This imputer automatically identified
    and stored the variables with missing data from the train set when we called the</st>
    `<st c="9074">fit()</st>` <st c="9079">method.</st> <st c="9088">With the</st>
    `<st c="9097">transform()</st>` <st c="9108">method, the imputer removed observations
    with</st> `<st c="9154">nan</st>` <st c="9158">in those variables.</st> <st c="9179">With</st>
    `<st c="9184">transform_x_y()</st>`<st c="9199">, the imputer removed rows with</st>
    `<st c="9231">nan</st>` <st c="9234">from the data sets and then realigned the</st>
    <st c="9277">target variable.</st>
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="8879">最后，我们使用 Feature-engine 的</st> `<st c="8936">DropMissingData()</st>`<st
    c="8953">删除缺失数据。此填充器在调用</st> `<st c="9074">fit()</st>` <st c="9079">方法时自动识别并存储了训练集中缺失数据的变量。</st>
    <st c="9088">使用</st> `<st c="9097">transform()</st>` <st c="9108">方法，填充器删除了那些变量中的</st>
    `<st c="9154">nan</st>` <st c="9158">观测值。</st> <st c="9179">使用</st> `<st c="9184">transform_x_y()</st>`<st
    c="9199">，填充器从数据集中删除了包含</st> `<st c="9231">nan</st>` <st c="9234">的行，然后重新对齐了</st>
    <st c="9277">目标变量。</st>
- en: <st c="9293">See also</st>
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="9293">另请参阅</st>
- en: <st c="9302">If you want to use</st> `<st c="9322">DropMissingData()</st>` <st
    c="9339">within a pipeline together with other Feature-engine or scikit-learn
    transformers, check</st> <st c="9428">out Feature-engine’s</st> `<st c="9450">Pipeline</st>`<st
    c="9458">:</st> [<st c="9461">https://Feature-engine.trainindata.com/en/latest/user_guide/pipeline/Pipeline.html</st>](https://Feature-engine.trainindata.com/en/latest/user_guide/pipeline/Pipeline.html)<st
    c="9543">. This pipeline can align the target with the training and test sets
    after</st> <st c="9618">removing rows.</st>
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="9302">如果您想在管道中使用</st> `<st c="9322">DropMissingData()</st>` <st c="9339">与其他
    Feature-engine 或 scikit-learn 转换器一起，请查看 Feature-engine 的</st> `<st c="9450">Pipeline</st>`<st
    c="9458">:</st> [<st c="9461">https://Feature-engine.trainindata.com/en/latest/user_guide/pipeline/Pipeline.html</st>](https://Feature-engine.trainindata.com/en/latest/user_guide/pipeline/Pipeline.html)<st
    c="9543">。此管道在删除行后可以将目标与训练集和测试集对齐。</st>
- en: <st c="9632">Performing mean or median impu</st><st c="9663">tation</st>
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="9632">执行均值或中位数填充</st><st c="9663"></st>
- en: <st c="9670">Mean or median imputation</st> <st c="9696">consists of replaci</st><st
    c="9716">ng missing data</st> <st c="9732">with the variable’s mean or median
    value.</st> <st c="9775">To avoid data leakage, we determine the mean or median
    using the train set, and then use these values to impute the train and test sets,
    and all</st> <st c="9920">future data.</st>
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="9670">均值或中位数插补</st> <st c="9696">包括用变量的均值或中位数值替换缺失数据。</st> <st c="9716">为了避免数据泄露，我们使用训练集来确定均值或中位数，然后使用这些值来插补训练集和测试集，以及所有</st>
    <st c="9920">未来的数据。</st>
- en: <st c="9932">Scikit-learn and Feature-engine learn the mean or median from the
    train set and store these parameters for future use out of</st> <st c="10058">the
    box.</st>
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="9932">Scikit-learn 和 Feature-engine 从训练集中学习均值或中位数，并将这些参数存储在</st> <st
    c="10058">箱外供将来使用。</st>
- en: <st c="10066">In this recipe, we will perform mean and median imputation using</st>
    `<st c="10132">pandas</st>`<st c="10138">,</st> `<st c="10140">scikit</st>`<st
    c="10146">-</st>`<st c="10148">learn</st>`<st c="10153">,</st> <st c="10155">and</st>
    `<st c="10159">feature-engine</st>`<st c="10173">.</st>
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10066">在这个菜谱中，我们将使用</st> `<st c="10132">pandas</st>`<st c="10138">，`<st
    c="10140">scikit</st>`<st c="10146">-</st>`<st c="10148">learn</st>`<st c="10153">，和</st>
    `<st c="10155">feature-engine</st>`<st c="10173">来执行均值和中位数插补。</st>
- en: <st c="10174">Note</st>
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10174">注意</st>
- en: <st c="10179">Use mean imputation if variables are normally distributed and
    median imputation otherwise.</st> <st c="10271">Mean and median imputation may
    distort the variable distribution if there is a high percentage</st> <st c="10366">of</st>
    <st c="10369">missing data.</st>
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10179">如果变量呈正态分布，则使用均值插补；否则使用中位数插补。</st> <st c="10271">如果缺失数据比例很高，均值和中位数插补可能会扭曲变量的分布。</st>
- en: <st c="10382">How t</st><st c="10388">o do it...</st>
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="10382">如何做...</st>
- en: <st c="10399">Let’s begin</st> <st c="10412">this reci</st><st c="10421">pe:</st>
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10399">让我们开始</st> <st c="10412">这个菜谱：</st>
- en: <st c="10425">First, we’ll import</st> `<st c="10446">pandas</st>` <st c="10452">and
    the required functions and classes from</st> `<st c="10496">scikit-learn</st>`
    <st c="10509">and</st> `<st c="10514">feature-engine</st>`<st c="10528">:</st>
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="10425">首先，我们将导入</st> `<st c="10446">pandas</st>` <st c="10452">以及从</st>
    `<st c="10496">scikit-learn</st>` <st c="10509">和</st> `<st c="10514">feature-engine</st>`<st
    c="10528">中所需的函数和类：</st>
- en: '[PRE17]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: <st c="10746">Let’s load the dataset that we prepared in the</st> *<st c="10794">Technical</st>*
    *<st c="10804">requirements</st>* <st c="10816">section:</st>
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="10746">让我们加载我们在</st> *<st c="10794">技术</st>* *<st c="10804">要求</st>*
    <st c="10816">部分中准备的数据集：</st>
- en: '[PRE18]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: <st c="10871">Let’s split the data into train and test sets with their</st>
    <st c="10929">respective targets:</st>
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="10871">让我们将数据分割成训练集和测试集及其</st> <st c="10929">相应的目标：</st>
- en: '[PRE19]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: <st c="11080">Let’s make a list with</st> <st c="11103">the numerical variables
    by excluding</st> <st c="11140">variables of</st> <st c="11154">type object:</st>
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="11080">让我们通过排除</st> <st c="11103">对象类型的变量来创建一个包含数值变量的列表：</st>
- en: '[PRE20]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: <st c="11235">If you execute</st> `<st c="11251">numeric_vars</st>`<st c="11263">,
    you will see the names of the numerical variables:</st> `<st c="11316">['A2',
    'A3', 'A8', 'A11', '</st>``<st c="11343">A14', 'A15']</st>`<st c="11356">.</st>
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="11235">如果您执行</st> `<st c="11251">numeric_vars</st>`<st c="11263">，您将看到数值变量的名称：</st>
    `<st c="11316">['A2', 'A3', 'A8', 'A11', '</st>``<st c="11343">A14', 'A15']</st>`<st
    c="11356">。</st>
- en: <st c="11357">Let’s capture the variables’ median values in</st> <st c="11404">a
    dictionary:</st>
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="11357">让我们将变量的中位数存储在</st> <st c="11404">一个字典中：</st>
- en: '[PRE21]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: <st c="11475">Tip</st>
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="11475">提示</st>
- en: <st c="11479">Note how we calculate the median using the train set.</st> <st
    c="11534">We will use these values to replace missing data in the train and test
    sets.</st> <st c="11611">To calculate the mean, use pandas</st> `<st c="11645">mean()</st>`
    <st c="11651">instead</st> <st c="11660">of</st> `<st c="11663">median()</st>`<st
    c="11671">.</st>
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="11479">注意我们如何使用训练集来计算中位数。</st> <st c="11534">我们将使用这些值来替换训练集和测试集中的缺失数据。</st>
    <st c="11611">要计算均值，请使用 pandas</st> `<st c="11645">mean()</st>` <st c="11651">而不是</st>
    `<st c="11663">median()</st>`<st c="11671">。</st>
- en: '<st c="11672">If you execute</st> `<st c="11688">median_values</st>`<st c="11701">,
    you will see a dictionary with the median value per variable:</st> `<st c="11765">{''A2'':
    28.835, ''A3'': 2.75, ''A8'': 1.0, ''A11'': 0.0, ''A14'': 160.0, ''</st>``<st
    c="11830">A15'': 6.0}.</st>`'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '<st c="11672">如果您执行</st> `<st c="11688">median_values</st>`<st c="11701">，您将看到一个包含每个变量的中位数的字典：</st>
    `<st c="11765">{''A2'': 28.835, ''A3'': 2.75, ''A8'': 1.0, ''A11'': 0.0, ''A14'':
    160.0, ''</st>``<st c="11830">A15'': 6.0}.</st>`'
- en: <st c="11842">Let’s replace missing data with</st> <st c="11875">the median:</st>
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: <st c="11980">If you execute</st> `<st c="11996">X_train_t[numeric_vars].isnull().sum()</st>`
    <st c="12034">after the imputation, the number of missing values in the numerical
    variables should</st> <st c="12120">be</st> `<st c="12123">0</st>`<st c="12124">.</st>
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="12125">Note</st>
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '`<st c="12130">pandas</st>` `<st c="12137">fillna()</st>` <st c="12146">returns
    a new dataset with imputed values by default.</st> <st c="12201">To replace missing
    data in the original DataFrame, set the</st> `<st c="12260">inplace</st>` <st
    c="12267">parameter to</st> `<st c="12281">True</st>`<st c="12285">:</st> `<st
    c="12288">X_train.fillna(value=median_values, inplace</st><st c="12331">=True)</st>`<st
    c="12338">.</st>'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: <st c="12339">Now, let’s impute missing valu</st><st c="12370">es with the median</st>
    <st c="12390">using</st> `<st c="12396">scikit-learn</st>`<st c="12408">.</st>
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: <st c="12409">Let’s set up the imputer</st> <st c="12434">to replace missing
    data with</st> <st c="12463">the median:</st>
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: <st c="12518">Note</st>
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: <st c="12523">To perform mean imputation, set</st> `<st c="12556">SimpleImputer()</st>`
    <st c="12571">as follows:</st> `<st c="12584">imputer =</st>` `<st c="12593">SimpleImputer(strategy
    = "</st>``<st c="12620">mean")</st>`<st c="12627">.</st>
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: <st c="12628">We restrict the imputation to the numerical variables by</st>
    <st c="12686">using</st> `<st c="12692">ColumnTransformer()</st>`<st c="12711">:</st>
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: <st c="12865">Note</st>
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: <st c="12870">Scikit-learn can return</st> `<st c="12895">numpy</st>` <st c="12900">arrays,</st>
    `<st c="12909">pandas</st>` <st c="12915">DataFrames, or</st> `<st c="12931">polar</st>`
    <st c="12936">frames, depending on how we set out the transform output.</st> <st
    c="12995">By default, it returns</st> `<st c="13018">numpy</st>` <st c="13023">arrays.</st>
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: <st c="13031">Let’s fit the imputer</st> <st c="13053">to the train set so that
    it learns the</st> <st c="13093">median</st> <st c="13099">values:</st>
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: <st c="13124">Let’s check out the learned</st> <st c="13153">median values:</st>
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: <st c="13211">The previous command returns the median values</st> <st c="13259">per
    variable:</st>
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: <st c="13313">Let’s replace missing values with</st> <st c="13348">the median:</st>
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: <st c="13425">Let’s display the resulting</st> <st c="13454">training set:</st>
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: <st c="13491">We see the resulting DataFrame in the</st> <st c="13530">following
    image:</st>
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 1.3 – Training set after the imputation. The imputed variables are
    marked by the imputer prefix; the untransformed variables show the prefix remainder](img/B22396_01_03.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
- en: <st c="14090">Figure 1.3 – Training set after the imputation.</st> <st c="14138">The
    imputed variables are marked by the imputer prefix; the untransformed variables
    show the prefix remainder</st>
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: <st c="14247">Finally, let’s perform median imputation</st> <st c="14289">using</st>
    `<st c="14295">feature-engine</st>`<st c="14309">.</st>
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们使用 `<st c="14295">feature-engine</st>`<st c="14309">.</st> 进行中位数插补。
- en: <st c="14310">Let’s set up the imputer</st> <st c="14335">to replace missing
    data in numerical variables</st> <st c="14382">with</st> <st c="14388">the median:</st>
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们设置插补器，以用中位数替换数值变量中的缺失数据：
- en: '[PRE30]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: <st c="14482">Note</st>
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: <st c="14487">To perform mean imputation, change</st> `<st c="14523">imputation_method</st>`
    <st c="14540">to</st> `<st c="14544">"mean"</st>`<st c="14550">. By default</st>
    `<st c="14563">MeanMedianImputer()</st>` <st c="14582">will impute all numerical
    variables in the DataFrame, ignoring categorical variables.</st> <st c="14669">Use
    the</st> `<st c="14677">variables</st>` <st c="14686">argument to restrict the
    imputation to a subset of</st> <st c="14738">numer</st><st c="14743">ical variables.</st>
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行均值插补，将 `<st c="14523">imputation_method</st>` <st c="14540">改为</st> `<st
    c="14544">"mean"</st>`<st c="14550">。默认情况下，`<st c="14563">MeanMedianImputer()</st>`
    <st c="14582">将插补 DataFrame 中的所有数值变量，忽略分类变量。</st> <st c="14669">使用</st> `<st c="14677">variables</st>`
    <st c="14686">参数将插补限制为数值变量的子集。</st>
- en: <st c="14759">Fit the imputer so th</st><st c="14781">at it learns the</st>
    <st c="14799">median values:</st>
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将插补器拟合，以便它学习中位数值：
- en: '[PRE31]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: <st c="14834">Inspect the</st> <st c="14847">learned medians:</st>
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查学习到的中位数：
- en: '[PRE32]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: <st c="14885">The previous command returns the median values in</st> <st c="14936">a
    dictionary:</st>
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前一个命令返回字典中的中位数值：
- en: '[PRE33]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: <st c="15025">Finally, let’s replace the missing values with</st> <st c="15073">the
    median:</st>
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们用中位数替换缺失值：
- en: '[PRE34]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: <st c="15156">Feature-engine’s</st> `<st c="15174">MeanMedianImputer()</st>`
    <st c="15193">returns a</st> `<st c="15204">DataFrame</st>`<st c="15213">. You
    can check that the imputed variables do not contain missing values</st> <st c="15286">using</st>
    `<st c="15292">X_train[numeric</st><st c="15307">_vars].isnull().mean()</st>`<st
    c="15330">.</st>
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="15156">Feature-engine</st>` 的 `<st c="15174">MeanMedianImputer()</st>`
    <st c="15193">返回一个 `<st c="15204">DataFrame</st>`<st c="15213">。您可以使用 `<st c="15292">X_train[numeric</st><st
    c="15307">_vars].isnull().mean()</st>`<st c="15330">` 检查插补变量是否不包含缺失值。</st>'
- en: <st c="15331">How it works...</st>
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作...
- en: <st c="15347">In this recipe, we replaced</st> <st c="15375">missing data with
    the variable’s median values</st> <st c="15422">using</st> `<st c="15429">pandas</st>`<st
    c="15435">,</st> `<st c="15437">scikit-learn</st>`<st c="15449">,</st> <st c="15451">and</st>
    `<st c="15455">feature-engine</st>`<st c="15469">.</st>
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们使用 `<st c="15429">pandas</st>`<st c="15435">`、`<st c="15437">scikit-learn</st>`<st
    c="15449">` 和 `<st c="15451">feature-engine</st>`<st c="15469">` 将缺失数据替换为变量的中位数值。
- en: <st c="15470">We divided the dataset into train and test sets using scikit-learn’s</st>
    `<st c="15540">train_test_split()</st>` <st c="15558">function.</st> <st c="15569">The
    function takes the predictor variables, the target, the fraction of observations
    to retain in the test set, and a</st> `<st c="15687">random_state</st>` <st c="15699">value
    for reproducibility, as arguments.</st> <st c="15741">It returned a train set
    with 70% of the original observations and a test set with 30% of the original
    observations.</st> <st c="15857">The 70:30 split was done</st> <st c="15882">at
    random.</st>
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 scikit-learn 的 `<st c="15540">train_test_split()</st>` <st c="15558">函数将数据集分为训练集和测试集。</st>
    <st c="15569">该函数接受预测变量、目标、测试集中要保留的观测值比例以及用于可重复性的 `<st c="15687">random_state</st>`
    <st c="15699">值` 作为参数。</st> <st c="15741">它返回一个包含原始观测值 70% 的训练集和一个包含原始观测值 30%
    的测试集。</st> <st c="15857">70:30 的分割是随机进行的。</st>
- en: <st c="15892">To impute missing data with pandas, in</st> *<st c="15932">step
    5</st>*<st c="15938">, we created a dictionary with the numerical variable names
    as keys and their medians as values.</st> <st c="16035">The median values were
    learned from the training set to avoid data leakage.</st> <st c="16111">To replace
    missing data, we applied</st> `<st c="16147">pandas</st>`<st c="16153">’</st>
    `<st c="16156">fillna()</st>` <st c="16164">to train and test sets, passing the
    dictionary with the median values per variable as</st> <st c="16251">a parameter.</st>
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`pandas`填充缺失数据，在第5步中，我们创建了一个字典，其中数值变量名称作为键，它们的平均值作为值。这些平均值是从训练集中学习的，以避免数据泄露。为了替换缺失数据，我们应用了`pandas`的`fillna()`到训练和测试集，传递包含每个变量的中值的字典作为参数。
- en: <st c="16263">To replace the missing values with the median using</st> `<st
    c="16316">scikit-learn</st>`<st c="16328">, we used</st> `<st c="16338">SimpleImputer()</st>`
    <st c="16353">with the</st> `<st c="16363">strategy</st>` <st c="16371">set to</st>
    `<st c="16379">"median"</st>`<st c="16387">. To restrict the imputation to numerical
    variables, we used</st> `<st c="16448">ColumnTransformer()</st>`<st c="16467">.
    With the</st> `<st c="16478">remainder</st>` <st c="16487">argument set to</st>
    `<st c="16504">passthrough</st>`<st c="16515">, we made</st> `<st c="16525">ColumnTransformer()</st>`
    <st c="16544">return</st> *<st c="16552">all the variables</st>* <st c="16569">seen
    in the training set in the transformed output; the imputed ones followed by those
    that were</st> <st c="16667">not transformed.</st>
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`scikit-learn`用中位数替换缺失值，我们使用了`SimpleImputer()`，其`strategy`设置为`"median"`。为了限制填充仅限于数值变量，我们使用了`ColumnTransformer()`。将`remainder`参数设置为`passthrough`，我们使`ColumnTransformer()`返回训练集中看到的*所有变量*在转换输出中；填充的变量随后是那些未转换的变量。
- en: <st c="16683">Note</st>
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '`<st c="16688">ColumnTransformer()</st>` <st c="16708">changes the names of
    the variables in the output.</st> <st c="16759">The transformed variables show
    the prefix</st> `<st c="16801">imputer</st>` <st c="16808">and the unchanged variables
    show the</st> <st c="16846">prefix</st> `<st c="16853">remainder</st>`<st c="16862">.</st>'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`ColumnTransformer()`会更改输出中变量的名称。转换后的变量显示前缀`imputer`，而未更改的变量显示前缀`remainder`。'
- en: <st c="16863">In</st> *<st c="16867">step 8</st>*<st c="16873">, we set the
    output of the column transformer to</st> `<st c="16922">pandas</st>` <st c="16928">to
    obtain a DataFrame as a result.</st> <st c="16964">By default,</st> `<st c="16976">ColumnTransformer()</st>`
    <st c="16995">returns</st> `<st c="17004">numpy</st>` <st c="17009">arrays.</st>
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在第8步中，我们将列转换器的输出设置为`pandas`以获得一个DataFrame作为结果。默认情况下，`ColumnTransformer()`返回`numpy`数组。
- en: <st c="17017">Note</st>
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: <st c="17022">From version 1.4.0,</st> `<st c="17043">scikit-learn</st>` <st
    c="17055">transformers can return</st> `<st c="17080">numpy</st>` <st c="17085">arrays,</st>
    `<st c="17094">pandas</st>` <st c="17100">DataFrames, or</st> `<st c="17116">polar</st>`
    <st c="17121">frames as a result of the</st> `<st c="17148">transform()</st>`
    <st c="17159">method.</st>
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本1.4.0开始，`scikit-learn`转换器可以返回`numpy`数组、`pandas` DataFrame或`polar` frames作为`transform()`方法的输出结果。
- en: <st c="17167">With</st> `<st c="17173">fit()</st>`<st c="17178">,</st> `<st
    c="17180">SimpleImputer()</st>` <st c="17195">learned the median of each numerical
    variable in the train set and stored them in its</st> `<st c="17282">statistics_</st>`
    <st c="17293">attribute.</st> <st c="17305">With</st> `<st c="17310">transform()</st>`<st
    c="17321">, it replaced the missing values with</st> <st c="17359">the medians.</st>
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`fit()`，`SimpleImputer()`学习训练集中每个数值变量的中位数并将它们存储在其`statistics_`属性中。使用`transform()`，它用中位数替换了缺失值。
- en: <st c="17371">To replace missing values with the median using Feature-engine,
    we used the</st> `<st c="17448">MeanMedianImputer()</st>` <st c="17467">with the</st>
    `<st c="17477">imputation_method</st>` <st c="17494">set to</st> `<st c="17502">median</st>`<st
    c="17508">. To restrict the imputation to a subset of variables, we passed the
    variable names in a list to the</st> `<st c="17609">variables</st>` <st c="17618">parameter.</st>
    <st c="17630">With</st> `<st c="17635">fit()</st>`<st c="17640">, the transformer
    learned and stored the median values per</st> <st c="17698">variable</st> <st
    c="17707">in a dictionary</st> <st c="17723">in its</st> `<st c="17731">imputer_dict_</st>`
    <st c="17744">attribute.</st> <st c="17756">With</st> `<st c="17761">transform()</st>`<st
    c="17772">, it replaced the missing values, re</st><st c="17808">turning a</st>
    <st c="17819">pandas DataFrame.</st>
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="17371">要使用 Feature-engine 将缺失值替换为中位数，我们使用了</st> `<st c="17448">MeanMedianImputer()</st>`
    <st c="17467">，并将</st> `<st c="17477">imputation_method</st>` <st c="17494">设置为</st>
    `<st c="17502">median</st>`<st c="17508">。要限制插补变量的子集，我们将变量名列表传递给</st> `<st c="17609">variables</st>`
    <st c="17618">参数。</st> <st c="17630">使用</st> `<st c="17635">fit()</st>`<st c="17640">，转换器学习并存储了每个</st>
    <st c="17698">变量</st> <st c="17707">的中位数值，存储在其</st> `<st c="17723">imputer_dict_</st>`
    <st c="17731">属性中的字典中。</st> <st c="17756">使用</st> `<st c="17761">transform()</st>`<st
    c="17772">，它替换了缺失值，返回一个</st> <st c="17819">pandas DataFrame。</st>
- en: <st c="17836">Imputing categorical variables</st>
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="17836">插补分类变量</st>
- en: <st c="17867">We typically impute categorical variables</st> <st c="17909">with
    the most frequent category, or with a specific string.</st> <st c="17970">To avoid
    data leakage, we find the frequent categories from the train set.</st> <st c="18045">Then,
    we use these values to impute the train, test, and future datasets.</st> `<st
    c="18119">scikit-learn</st>` <st c="18131">and</st> `<st c="18136">feature-engine</st>`
    <st c="18150">find and store the frequent categories for the imputation, out of</st>
    <st c="18217">the box.</st>
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="17867">我们通常用最频繁的类别或一个特定的字符串来插补分类变量。</st> <st c="17909">为了避免数据泄露，我们从训练集中找到频繁的类别。</st>
    <st c="17970">然后，我们使用这些值来插补训练、测试和未来的数据集。</st> `<st c="18119">scikit-learn</st>`
    <st c="18131">和</st> `<st c="18136">feature-engine</st>` <st c="18150">会自动找到并存储用于插补的频繁类别。</st>
- en: <st c="18225">In this recipe, we will replace missing data in categorical variables
    with the most frequent category,</st> <st c="18329">or with an</st> <st c="18340">arbitrary
    string.</st>
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="18225">在这个配方中，我们将用最频繁的类别</st> <st c="18329">或一个</st> <st c="18340">任意字符串</st>替换分类变量中的缺失数据。
- en: <st c="18357">How to do it...</st>
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="18357">如何做到这一点...</st>
- en: <st c="18373">To begin, let’s make a few imports and prepare</st> <st c="18421">the
    data:</st>
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="18373">首先，让我们进行一些导入并准备</st> <st c="18421">数据：</st>
- en: <st c="18430">Let’s import</st> `<st c="18444">pandas</st>` <st c="18450">and
    the required functions and classes from</st> `<st c="18495">scikit-learn</st>`
    <st c="18507">and</st> `<st c="18512">feature-engine</st>`<st c="18526">:</st>
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="18430">让我们导入</st> `<st c="18444">pandas</st>` <st c="18450">以及从</st>
    `<st c="18495">scikit-learn</st>` <st c="18507">和</st> `<st c="18512">feature-engine</st>`<st
    c="18526">中所需的函数和类：</st>
- en: '[PRE35]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: <st c="18745">Let’s load the dataset that we prepared in the</st> *<st c="18793">Technical</st>*
    *<st c="18803">requirements</st>* <st c="18815">section:</st>
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="18745">让我们加载我们在</st> *<st c="18793">技术</st>* *<st c="18803">要求</st>*
    <st c="18815">部分中准备的数据集：</st>
- en: '[PRE36]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: <st c="18871">Let’s split the data into train and test sets and their</st> <st
    c="18928">respective targets:</st>
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="18871">让我们将数据集分割成训练集和测试集及其</st> <st c="18928">相应的目标：</st>
- en: '[PRE37]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: <st c="19078">Let’s capture the categorical variables in</st> <st c="19122">a
    list:</st>
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="19078">让我们将分类变量</st> <st c="19122">存储在一个列表中：</st>
- en: '[PRE38]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: <st c="19202">Let’s store the variables’ most frequent categories in</st> <st
    c="19258">a dictionary:</st>
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="19202">让我们将变量的最频繁类别存储在一个</st> <st c="19258">字典中：</st>
- en: '[PRE39]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: <st c="19341">Let’s replace missing values</st> <st c="19370">with the</st>
    <st c="19380">frequent categories:</st>
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="19341">让我们用频繁的类别</st> <st c="19370">替换缺失值：</st>
- en: '[PRE40]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: <st c="19498">Note</st>
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="19498">注意</st>
- en: '`<st c="19503">fillna()</st>` <st c="19512">returns a new DataFrame with the
    imputed values by default.</st> <st c="19573">We can replace missing data in the
    original DataFrame by executing</st> `<st c="19640">X_train.fillna(value=frequent_valu</st><st
    c="19674">es, inplace=True)</st>`<st c="19692">.</st>'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="19503">fillna()</st>` <st c="19512">默认返回一个包含插补值的新的 DataFrame。</st>
    <st c="19573">我们可以通过执行</st> `<st c="19640">X_train.fillna(value=frequent_valu</st><st
    c="19674">es, inplace=True)</st>`<st c="19692">来替换原始 DataFrame 中的缺失数据。</st>'
- en: <st c="19693">To replace missing data with a specific string, let’s create an
    imputation dictionary with the categorical variable names as the keys and an arbitrary
    string as</st> <st c="19855">the values:</st>
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="19693">要用特定字符串替换缺失数据，请创建一个包含分类变量名称作为键和任意字符串作为</st> <st c="19855">值的插补字典：</st>
- en: '[PRE41]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: <st c="19929">Now, we can use this dictionary and the code in</st> *<st c="19978">step
    6</st>* <st c="19984">to replace</st> <st c="19996">missing data.</st>
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="19929">现在，我们可以使用这个字典和第</st> *<st c="19978">6</st> <st c="19984">步</st>
    <st c="19996">中的代码</st>来替换缺失数据。</st>
- en: <st c="20009">Note</st>
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="20009">注意</st>
- en: <st c="20014">With</st> `<st c="20020">pandas</st>` `<st c="20026">value_counts()</st>`
    <st c="20041">we can see the string added by the imputation.</st> <st c="20089">Try
    executing, for</st> <st c="20108">example,</st> `<st c="20117">X_train["A1"].value_counts()</st>`<st
    c="20145">.</st>
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="20014">使用</st> `<st c="20020">pandas</st>` `<st c="20026">value_counts()</st>`
    <st c="20041">我们可以看到插补添加的字符串。</st> <st c="20089">例如，尝试执行</st> <st c="20108">以下命令：</st>
    `<st c="20117">X_train["A1"].value_counts()</st>`<st c="20145">。</st>
- en: <st c="20146">Now, let’s impute missing values with the most frequent category</st>
    <st c="20212">using</st> `<st c="20218">scikit-learn</st>`<st c="20230">.</st>
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="20146">现在，让我们使用</st> `<st c="20218">scikit-learn</st>`<st c="20230">来用最频繁的类别插补缺失值：</st>
- en: <st c="20231">Let’s set up the imputer to find the most frequent category</st>
    <st c="20292">per variable:</st>
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="20231">让我们设置插补器以找到每个变量的最频繁类别：</st>
- en: '[PRE42]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: <st c="20355">Note</st>
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="20355">注意</st>
- en: '`<st c="20360">SimpleImputer()</st>` <st c="20376">will learn the mode for
    numerical and categorical variables alike.</st> <st c="20444">But in practice,
    mode imputation is done for categorical</st> <st c="20501">variables only.</st>'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="20360">SimpleImputer()</st>` <st c="20376">将为数值和分类变量学习众数。</st> <st
    c="20444">但在实践中，众数插补仅用于分类</st> <st c="20501">变量。</st>'
- en: <st c="20516">Let’s restrict the imputation</st> <st c="20547">to the</st> <st
    c="20554">categorical variables:</st>
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="20516">让我们将插补限制在</st> <st c="20547">分类变量</st> <st c="20554">：</st>
- en: '[PRE43]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: <st c="20698">Note</st>
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="20698">注意</st>
- en: <st c="20703">To impute missing data with a string instead of the most frequent
    category, set</st> `<st c="20784">SimpleImputer()</st>` <st c="20799">as follows:</st>
    `<st c="20812">imputer =</st>` `<st c="20822">SimpleImputer(strategy="constant",</st>
    <st c="20857">fill_value="missing")</st>`<st c="20878">.</st>
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="20703">要用字符串而不是最频繁的类别来插补缺失数据，请按以下方式设置</st> `<st c="20784">SimpleImputer()</st>`
    <st c="20799">：</st> `<st c="20812">imputer =</st>` `<st c="20822">SimpleImputer(strategy="constant",</st>
    <st c="20857">fill_value="missing")</st>`<st c="20878">.</st>
- en: <st c="20879">Fit the imputer to the train set so that it learns the most</st>
    <st c="20940">frequent values:</st>
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="20879">将插补器拟合到训练集，以便它学习最频繁的值：</st>
- en: '[PRE44]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: <st c="20972">Let’s take a look at the most frequent values learned by</st>
    <st c="21030">the imputer:</st>
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="20972">让我们看看插补器学到的最频繁值：</st> <st c="21030">：</st>
- en: '[PRE45]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: <st c="21085">The previous command returns the most frequent values</st> <st
    c="21140">per variable:</st>
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="21085">上一条命令返回每个变量的最频繁值</st> <st c="21140">：</st>
- en: '[PRE46]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: <st c="21220">Finally, let’s replace missing values with the</st> <st c="21268">frequent
    categories:</st>
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="21220">最后，让我们用频繁的类别替换缺失值：</st>
- en: '[PRE47]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: <st c="21354">Make sure to inspect the resulting DataFrames by</st> <st c="21404">executing</st>
    `<st c="21414">X_train_t.head()</st>`<st c="21430">.</st>
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="21354">确保通过</st> <st c="21404">执行</st> `<st c="21414">X_train_t.head()</st>`<st
    c="21430">.</st>来检查生成的 DataFrames。
- en: <st c="21431">Note</st>
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="21431">注意</st>
- en: <st c="21436">The</st> `<st c="21441">ColumnTransformer()</st>` <st c="21460">changes
    the names of the variables.</st> <st c="21497">The imputed variables show the
    prefix</st> `<st c="21535">imputer</st>` <st c="21542">and the untransformed variables
    the</st> <st c="21579">prefix</st> `<st c="21586">remainder</st>`<st c="21595">.</st>
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="21436">The</st> `<st c="21441">ColumnTransformer()</st>` <st c="21460">更改了变量的名称。</st>
    <st c="21497">被插补的变量显示前缀</st> `<st c="21535">imputer</st>` <st c="21542">，而未转换的变量显示前缀</st>
    `<st c="21579">remainder</st>`<st c="21595">。</st>
- en: <st c="21596">Finally, let’s impute missing value</st><st c="21632">s</st> <st
    c="21635">using</st> `<st c="21641">feature-engine</st>`<st c="21655">.</st>
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="21596">最后，让我们使用</st> `<st c="21641">feature-engine</st>`<st c="21655">来插补缺失值</st><st
    c="21632">s</st> <st c="21635">：</st>
- en: <st c="21656">Let’s set up the imputer</st> <st c="21681">to replace the missing
    data in categorical variables with their most</st> <st c="21751">frequent value:</st>
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="21656">让我们设置插补器</st> <st c="21681">以用最频繁的值替换分类变量中的缺失数据：</st>
- en: '[PRE48]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: <st c="21856">Note</st>
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="21856">注意</st>
- en: <st c="21861">With the</st> `<st c="21871">variables</st>` <st c="21880">parameter
    set to</st> `<st c="21898">None</st>`<st c="21902">,</st> `<st c="21904">CategoricalImputer()</st>`
    <st c="21924">will automatically impute all categorical variables found in the
    train set.</st> <st c="22001">Use this parameter to restrict the imputation to
    a subset of categorical variables, as shown in</st> *<st c="22097">step 13</st>*<st
    c="22104">.</st>
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `<st c="21871">variables</st>` <st c="21880">参数设置为 `<st c="21898">None</st>`<st
    c="21902">，`<st c="21904">CategoricalImputer()</st>` <st c="21924">将自动填充训练集中找到的所有分类变量。</st>
    <st c="22001">使用此参数将填充限制为分类变量的子集，如**步骤 13**<st c="22097">所示。</st>
- en: <st c="22105">Fit the imputer to the train set so that it learns the most</st>
    <st c="22166">frequent categories:</st>
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将填充器拟合到训练集，以便它学习最频繁的类别：
- en: '[PRE49]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: <st c="22207">Note</st>
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="22207">注意</st>
- en: <st c="22212">To impute categorical variables with a specific string, set</st>
    `<st c="22273">imputation_method</st>` <st c="22290">to</st> `<st c="22294">missing</st>`
    <st c="22301">and</st> `<st c="22306">fill_value</st>` <st c="22316">to the</st>
    <st c="22324">desired string.</st>
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用特定字符串填充分类变量，将 `<st c="22273">imputation_method</st>` 设置为 `<st c="22294">missing</st>`，并将
    `<st c="22306">fill_value</st>` 设置为所需的字符串。</st>
- en: <st c="22339">Let’s check out the</st> <st c="22360">learned categories:</st>
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们检查一下**学习到的类别**：
- en: '[PRE50]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: <st c="22401">We can see the dictionary</st> <st c="22427">with the most frequent
    values in the</st> <st c="22465">following output:</st>
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以在以下输出中看到包含最频繁值的字典：
- en: '[PRE51]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: <st c="22585">Finally, let’s replace the missing values with</st> <st c="22633">frequent
    categories:</st>
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们用频繁类别替换缺失值：
- en: '[PRE52]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: <st c="22729">If you want to impute numerical variables with a string or the
    most frequent value using</st> `<st c="22819">CategoricalImputer()</st>`<st c="22839">,
    set the</st> `<st c="22849">ignore_format</st>` <st c="22862">parameter</st> <st
    c="22873">to</st> `<st c="22876">True</st>`<st c="22880">.</st>
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你想要使用 `<st c="22819">CategoricalImputer()</st>`<st c="22839">》用字符串或最频繁的值填充数值变量，将
    `<st c="22849">ignore_format</st>` 参数设置为 `<st c="22876">True</st>`<st c="22880">。</st>
- en: '`<st c="22881">CategoricalImputer()</st>` <st c="22902">returns</st> <st c="22910">a
    pandas DataFrame as</st> <st c="22933">a result.</st>'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="22881">CategoricalImputer()</st>` <st c="22902">返回</st> <st c="22910">一个
    pandas DataFrame 作为</st> <st c="22933">结果。</st>'
- en: <st c="22942">How it works...</st>
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="22942">工作原理...</st>
- en: <st c="22958">In this recipe, we replaced missing values in categorical</st>
    <st c="23017">variables with the most frequent categories or an arbitrary string.</st>
    <st c="23085">We used</st> `<st c="23093">pandas</st>`<st c="23099">,</st> `<st
    c="23101">scikit-learn</st>`<st c="23113">,</st> <st c="23115">and</st> `<st c="23119">feature-engine</st>`<st
    c="23133">.</st>
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们使用最频繁的类别或任意字符串替换了分类变量中的缺失值。<st c="23085">我们使用了 `<st c="23093">pandas</st>`、`<st
    c="23099">scikit-learn</st>`、`<st c="23101">feature-engine</st>`。</st>
- en: <st c="23134">In</st> *<st c="23138">step 5</st>*<st c="23144">, we created
    a dictionary</st> <st c="23170">with the variable names as keys and the frequent
    categories as values.</st> <st c="23241">To capture the frequent categories, we
    used pandas</st> `<st c="23292">mode()</st>`<st c="23298">, and to return a dictionary,
    we used pandas</st> `<st c="23343">to_dict()</st>`<st c="23352">. To replace the
    missing data, we used</st> `<st c="23391">pandas</st>` `<st c="23397">fillna()</st>`<st
    c="23406">, passing the dictionary with the variables and their frequent categories
    as parameters.</st> <st c="23495">There can be more than one mode in a variable,
    that’s why we made sure to capture only one of those valu</st><st c="23599">es
    by</st> <st c="23606">using</st> `<st c="23612">.iloc[0]</st>`<st c="23620">.</st>
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在**步骤 5**中，我们使用变量名作为键，频繁类别作为值创建了一个字典。<st c="23170">为了捕获频繁类别，我们使用了 pandas 的 `<st
    c="23292">mode()</st>`，并且为了返回一个字典，我们使用了 pandas 的 `<st c="23343">to_dict()</st>`。为了替换缺失数据，我们使用了
    `<st c="23391">pandas</st>` 的 `<st c="23397">fillna()</st>`，传递包含变量及其频繁类别的字典作为参数。</st>
    <st c="23406">在一个变量中可能存在多个众数，这就是为什么我们确保通过使用 `<st c="23612">.iloc[0]</st>`<st c="23620">.</st>
    只捕获其中之一的原因。</st>
- en: <st c="23621">To replace the missing values using</st> `<st c="23658">scikit-learn</st>`<st
    c="23670">, we used</st> `<st c="23680">SimpleImputer()</st>` <st c="23695">with
    the</st> `<st c="23705">strategy</st>` <st c="23713">set to</st> `<st c="23721">most_frequent</st>`<st
    c="23734">. To restrict the imputation to categorical variables, we used</st>
    `<st c="23797">ColumnTransformer()</st>`<st c="23816">. With</st> `<st c="23823">remainder</st>`
    <st c="23832">set to</st> `<st c="23840">passthrough</st>`<st c="23851">, we made</st>
    `<st c="23861">ColumnTransformer()</st>` <st c="23880">return all the variables
    present in the training set as a result of the</st> `<st c="23953">transform()</st>`
    <st c="23964">method .</st>
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用`scikit-learn`替换缺失值，我们使用了`SimpleImputer()`，其`strategy`设置为`most_frequent`。为了将插补限制为分类变量，我们使用了`ColumnTransformer()`。将`remainder`设置为`passthrough`后，`ColumnTransformer()`将返回训练集中所有变量的结果，作为`transform()`方法的输出。
- en: <st c="23973">Note</st>
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '`<st c="23978">ColumnTransformer()</st>` <st c="23998">changes the names of
    the variables in the output.</st> <st c="24049">The transformed variables show
    the prefix</st> `<st c="24091">imputer</st>` <st c="24098">and the unchanged variables
    show the</st> <st c="24136">prefix</st> `<st c="24143">remainder</st>`<st c="24152">.</st>'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`ColumnTransformer()`更改输出中变量的名称。转换后的变量显示前缀`imputer`，而未更改的变量显示前缀`remainder`。'
- en: <st c="24153">With</st> `<st c="24159">fit()</st>`<st c="24164">,</st> `<st
    c="24166">SimpleImputer()</st>` <st c="24181">learned the variables’ most frequent
    categories and stored them in its</st> `<st c="24253">statistics_</st>` <st c="24264">attribute.</st>
    <st c="24276">With</st> `<st c="24281">transform()</st>`<st c="24292">, it replaced
    the missing data with the</st> <st c="24332">learned parameters.</st>
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`fit()`函数，`SimpleImputer()`学习变量最频繁的类别并将它们存储在其`statistics_`属性中。使用`transform()`函数，它用学习到的参数替换了缺失数据。
- en: '`<st c="24351">SimpleImputer()</st>` <st c="24367">and</st> `<st c="24372">ColumnTransformer()</st>`
    <st c="24391">return NumPy arrays by default.</st> <st c="24424">We can change
    this behavior with the</st> `<st c="24461">set_output()</st>` <st c="24473">parameter.</st>'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`SimpleImputer()`和`ColumnTransformer()`默认返回NumPy数组。我们可以通过`set_output()`参数更改此行为。'
- en: <st c="24484">To replace missing values with</st> `<st c="24516">feature-engine</st>`<st
    c="24530">, we used the</st> `<st c="24544">CategoricalImputer()</st>` <st c="24564">with</st>
    `<st c="24570">imputation_method</st>` <st c="24587">set to</st> `<st c="24595">frequent</st>`<st
    c="24603">. With</st> `<st c="24610">fit()</st>`<st c="24615">, the transformer
    learned and stored the most frequent categories in a dictionary in its</st> `<st
    c="24704">imputer_dict_</st>` <st c="24717">attribute.</st> <st c="24729">With</st>
    `<st c="24734">transform()</st>`<st c="24745">, it replaced the missing values
    with the</st> <st c="24787">learned parameters.</st>
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用`feature-engine`替换缺失值，我们使用了`CategoricalImputer()`，其`imputation_method`设置为`frequent`。使用`fit()`，转换器学习并存储了最频繁的类别在其`imputer_dict_`属性中的字典中。使用`transform()`，它用学习到的参数替换了缺失值。
- en: <st c="24806">Unlike</st> `<st c="24814">SimpleImputer()</st>`<st c="24829">,</st>
    `<st c="24831">CategoricalImputer()</st>` <st c="24851">will only impute categorical
    variables, unless specificall</st><st c="24910">y told not to do so by setting
    the</st> `<st c="24946">ignore_format</st>` <st c="24959">parameter to</st> `<st
    c="24973">True</st>`<st c="24977">. In addition, with</st> `<st c="24997">feature-engine</st>`
    <st c="25011">transformers we can restrict the transformations to a subset of
    variables through the transformer itself.</st> <st c="25118">For</st> `<st c="25122">scikit-learn</st>`
    <st c="25134">transformers, we need the additional</st> `<st c="25172">ColumnTransformer()</st>`
    <st c="25191">class to apply the transformat</st><st c="25222">ion</st> <st c="25226">to
    a subset of</st> <st c="25242">the variables.</st>
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: <st c="25256">Replacing missing values with an arbitrary number</st>
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="25306">We can replace missing data</st> <st c="25334">with an arbitrary
    value.</st> <st c="25360">Commonly</st> <st c="25368">used values are</st> `<st
    c="25385">999</st>`<st c="25388">,</st> `<st c="25390">9999</st>`<st c="25394">,
    or</st> `<st c="25399">-1</st>` <st c="25401">for positive distributions.</st>
    <st c="25430">This method is used for numerical variables.</st> <st c="25475">For
    categorical variables, the equivalent metho</st><st c="25522">d is to replace
    missing data with an arbitrary string, as described in the</st> *<st c="25598">Imputing
    categorical</st>* *<st c="25619">variables</st>* <st c="25628">recipe.</st>
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: <st c="25636">When replacing missing values with arbitrary numbers, we need
    to be careful not to select a value close to the mean, the median, or any other
    common value of</st> <st c="25795">the distribution.</st>
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: <st c="25812">Note</st>
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: <st c="25817">We’d use arbitrary number imputation when data is not missing
    at random, use non-linear models, or when the percentage of missing data is high.</st>
    <st c="25962">This imputation technique distorts the original</st> <st c="26010">variable
    distribution.</st>
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: <st c="26032">In this recipe, we will impute missing data with arbitrary numbers
    using</st> `<st c="26106">panda</st><st c="26111">s</st>`<st c="26113">,</st>
    `<st c="26115">scikit-learn</st>`<st c="26127">,</st> <st c="26129">and</st> `<st
    c="26133">feature-engine</st>`<st c="26147">.</st>
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: <st c="26148">How to do it...</st>
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="26164">Let’s begin by importing the necessary tools and loading</st>
    <st c="26222">the data:</st>
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: <st c="26231">Import</st> `<st c="26239">pandas</st>` <st c="26245">and the
    required functions</st> <st c="26273">and classes:</st>
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: <st c="26460">Let’s load the dataset described in the</st> *<st c="26501">Technical</st>*
    *<st c="26511">requirements</st>* <st c="26523">section:</st>
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: <st c="26578">Let’s separate</st> <st c="26593">the data into train and</st>
    <st c="26618">test</st> <st c="26622">sets:</st>
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: <st c="26761">We will select arbitrary values greater than the maximum value
    of</st> <st c="26828">the distribution.</st>
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="26761">我们将选择大于分布最大值的任意值。</st>
- en: <st c="26845">Let’s find the maximum value of four</st> <st c="26883">numerical
    variables:</st>
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="26845">让我们找到四个</st> <st c="26883">数值变量的最大值：</st>
- en: '[PRE56]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: <st c="26943">The previous</st> <st c="26956">command returns the</st> <st c="26977">following
    output:</st>
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="26943">之前的</st> <st c="26956">命令返回以下输出：</st>
- en: '[PRE57]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: <st c="27165">Let’s make a copy of the</st> <st c="27191">original DataFrames:</st>
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="27165">让我们复制原始的</st> <st c="27191">DataFrame：</st>
- en: '[PRE58]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: <st c="27263">Now, we replace the missing values</st> <st c="27299">with</st>
    `<st c="27304">99</st>`<st c="27306">:</st>
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="27263">现在，我们将缺失值替换为</st> `<st c="27299">99</st>`<st c="27306">：</st>
- en: '[PRE59]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: <st c="27482">Note</st>
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="27482">注意</st>
- en: '<st c="27487">To impute different variables with different values using</st>
    `<st c="27546">pandas</st>` `<st c="27552">fillna()</st>`<st c="27561">, use a
    dictionary like this:</st> `<st c="27591">imputation_dict = {"A2": -1, "A3": -</st><st
    c="27627">1, "A8": 999, "</st>``<st c="27643">A11": 9999}</st>`<st c="27655">.</st>'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '<st c="27487">要使用</st> `<st c="27546">pandas</st>` `<st c="27552">fillna()</st>`<st
    c="27561">函数填充不同变量不同的值，可以使用如下字典：</st> `<st c="27591">imputation_dict = {"A2":
    -1, "A3": -</st><st c="27627">1, "A8": 999, "</st>``<st c="27643">A11": 9999}</st>`<st
    c="27655">.</st>'
- en: <st c="27656">Now, we’ll impute missing</st> <st c="27682">values with an arbitrary
    number</st> <st c="27714">using</st> `<st c="27721">scikit-learn</st>`<st c="27733">.</st>
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="27656">现在，我们将使用</st> `<st c="27682">scikit-learn</st>`<st c="27714">来填充缺失值，使用任意数：</st>
- en: <st c="27734">Let’s set up</st> `<st c="27748">imputer</st>` <st c="27755">to
    replace missing values</st> <st c="27782">with</st> `<st c="27787">99</st>`<st
    c="27789">:</st>
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="27734">让我们设置</st> `<st c="27748">填充器</st>` <st c="27755">以替换缺失值为</st>
    `<st c="27782">99</st>`<st c="27787">：</st>
- en: '[PRE60]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: <st c="27851">Note</st>
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="27851">注意</st>
- en: <st c="27856">If your dataset contains categorical variables,</st> `<st c="27905">SimpleImputer()</st>`
    <st c="27920">will add</st> `<st c="27930">99</st>` <st c="27932">to those variables
    as well if any values</st> <st c="27974">are missing.</st>
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="27856">如果你的数据集包含分类变量，</st> `<st c="27905">SimpleImputer()</st>` <st c="27920">将在任何缺失值的情况下，也将</st>
    `<st c="27930">99</st>` <st c="27932">添加到这些变量中。</st>
- en: <st c="27986">Let’s fit</st> `<st c="27997">imputer</st>` <st c="28004">to a
    slice of the train set containing the variables</st> <st c="28058">to impute:</st>
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="27986">让我们将</st> `<st c="27997">填充器</st>` <st c="28004">拟合到包含要填充变量的训练集切片中</st>
    <st c="28058">：</st>
- en: '[PRE61]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: <st c="28128">Replace the missing values with</st> `<st c="28161">99</st>` <st
    c="28163">in the</st> <st c="28171">desired variables:</st>
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="28128">在所需变量中将缺失值替换为</st> `<st c="28161">99</st>` <st c="28163">：</st>
- en: '[PRE62]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: <st c="28289">Go ahead and check the lack of missing values by executing</st>
    `<st c="28349">X_test_t[["A2", "A3", "</st>``<st c="28372">A8", "A11"]].isnull().sum()</st>`<st
    c="28400">.</st>
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="28289">继续执行</st> `<st c="28349">X_test_t[["A2", "A3", "</st>``<st c="28372">A8",
    "A11"]].isnull().sum()</st>`<st c="28400">来检查缺失值的数量。</st>
- en: <st c="28401">To finish, let’s impute mis</st><st c="28429">sing values</st>
    <st c="28442">using</st> `<st c="28448">f</st><st c="28449">eature-engine</st>`<st
    c="28462">.</st>
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="28401">为了完成，让我们使用</st><st c="28429">填充缺失值</st> <st c="28442">功能</st>
    `<st c="28448">f</st><st c="28449">eature-engine</st>`<st c="28462">.</st>
- en: <st c="28463">Let’s set up the</st> `<st c="28481">imputer</st>` <st c="28488">to
    replace</st> <st c="28499">missing values</st> <st c="28514">with</st> `<st c="28520">99</st>`
    <st c="28522">in 4</st> <st c="28528">specific variables:</st>
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="28463">让我们设置</st> `<st c="28481">填充器</st>` <st c="28488">以替换</st> `<st
    c="28499">缺失值</st>` <st c="28514">为</st> `<st c="28520">99</st>` <st c="28522">在4</st>
    <st c="28528">个特定变量中：</st>
- en: '[PRE63]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '`<st c="28641">Note</st>`'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="28641">注意</st>`'
- en: '`<st c="28646">ArbitraryNumberImputer()</st>` <st c="28671">will automatically
    select all numerical variables in the train set for imputation if we set the</st>
    `<st c="28768">variables</st>` <st c="28777">parameter</st> <st c="28788">to</st>
    `<st c="28791">None</st>`<st c="28795">.</st>'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="28646">ArbitraryNumberImputer()</st>` <st c="28671">将自动选择训练集中的所有数值变量进行填充，如果我们设置</st>
    `<st c="28768">variables</st>` <st c="28777">参数</st> <st c="28788">为</st> `<st
    c="28791">None</st>`<st c="28795">。</st>'
- en: <st c="28796">Finally, let’s replace the missing values</st> <st c="28839">with</st>
    `<st c="28844">99</st>`<st c="28846">:</st>
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="28796">最后，让我们将缺失值替换为</st> `<st c="28839">99</st>`<st c="28846">：</st>
- en: '[PRE64]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: <st c="28924">Note</st>
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="28924">注意</st>
- en: '<st c="28929">To impute different variables with different numbers, set up</st>
    `<st c="28991">ArbitraryNumberImputer()</st>` <st c="29015">as follows:</st> `<st
    c="29028">ArbitraryNumberImputer(imputater_dict = {"A2": -1, "A3": -1, "A8": 999,
    "</st>``<st c="29101">A11": 9999})</st>`<st c="29114">.</st>'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '<st c="28929">为了使用不同的数字来填充不同的变量，请按照以下方式设置</st> `<st c="28991">ArbitraryNumberImputer()</st>`
    <st c="29015">：</st> `<st c="29028">ArbitraryNumberImputer(imputater_dict = {"A2":
    -1, "A3": -1, "A8": 999, "</st>``<st c="29101">A11": 9999})</st>`<st c="29114">。</st>'
- en: <st c="29115">We have now replaced missing data with arbitrary numbers us</st><st
    c="29175">ing three different</st> <st c="29196">open-source libraries.</st>
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="29115">我们现在已经使用三个不同的开源库将缺失数据替换为任意数字。</st>
- en: <st c="29218">How it works...</st>
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="29218">它是如何工作的...</st>
- en: <st c="29234">In this recipe, we replaced</st> <st c="29262">missing values
    in numerical variables</st> <st c="29300">with an arbitrary number using</st>
    `<st c="29332">pandas</st>`<st c="29338">,</st> `<st c="29340">sc</st><st c="29342">ikit-learn</st>`<st
    c="29353">,</st> <st c="29355">and</st> `<st c="29359">featur</st><st c="29365">e-engine</st>`<st
    c="29374">.</st>
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="29234">在这个配方中，我们使用</st> `<st c="29332">pandas</st>`<st c="29338">，</st>
    `<st c="29340">sc</st><st c="29342">ikit-learn</st>`<st c="29353">，和</st> `<st
    c="29355">featur</st><st c="29365">e-engine</st>`<st c="29374">替换了数值变量中的缺失值。</st>
- en: <st c="29375">To determine which arbitrary value to use, we inspected the maximum
    values of four numerical variables using pandas’</st> `<st c="29493">max()</st>`<st
    c="29498">. We chose</st> `<st c="29509">99</st>` <st c="29511">because it was
    greater than the maximum values of the selected variables.</st> <st c="29586">In</st>
    *<st c="29589">step 5</st>*<st c="29595">, we used</st> `<st c="29605">pandas</st>`
    `<st c="29611">fillna()</st>` <st c="29620">to replace the</st> <st c="29636">missing
    data.</st>
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="29375">为了确定使用哪个任意值，我们使用pandas的</st> `<st c="29493">max()</st>`<st c="29498">检查了四个数值变量的最大值。我们选择了</st>
    `<st c="29509">99</st>` <st c="29511">，因为它大于所选变量的最大值。</st> <st c="29586">在</st>
    *<st c="29589">步骤 5</st>*<st c="29595">中，我们使用了</st> `<st c="29605">pandas</st>`
    `<st c="29611">fillna()</st>` <st c="29620">来替换缺失数据。</st>
- en: <st c="29649">To replace missing values using</st> `<st c="29682">scikit-learn</st>`<st
    c="29694">, we utilized</st> `<st c="29708">SimpleImputer()</st>`<st c="29723">,
    with the</st> `<st c="29734">strategy</st>` <st c="29742">set to</st> `<st c="29750">constant</st>`<st
    c="29758">, and specified</st> `<st c="29774">99</st>` <st c="29776">in the</st>
    `<st c="29784">fill_value</st>` <st c="29794">argument.</st> <st c="29805">Next,
    we fitted the imputer to a slice of the train set with the numerical variables
    to impute.</st> <st c="29901">Finally, we replaced missing values</st> <st c="29937">using</st>
    `<st c="29943">transform()</st>`<st c="29954">.</st>
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="29649">要使用</st> `<st c="29682">scikit-learn</st>`<st c="29694">替换缺失值，我们使用了</st>
    `<st c="29708">SimpleImputer()</st>`<st c="29723">，将</st> `<st c="29734">策略</st>`
    <st c="29742">设置为</st> `<st c="29750">constant</st>`<st c="29758">，并在</st> `<st
    c="29784">fill_value</st>` <st c="29794">参数中指定了</st> `<st c="29774">99</st>` <st
    c="29776">。</st> <st c="29805">接下来，我们将填充器拟合到训练集中需要填充数值变量的一个子集。</st> <st c="29901">最后，我们使用</st>
    `<st c="29937">transform()</st>`<st c="29954">替换了缺失值。</st>
- en: <st c="29955">To replace missing values with</st> `<st c="29987">feature-engine</st>`
    <st c="30001">we used</st> `<st c="30010">ArbitraryValueImputer()</st>`<st c="30033">,
    specifying the value</st> `<st c="30056">99</st>` <st c="30058">and the variables
    to impute as parameters.</st> <st c="30102">Next, we applied the</st> `<st c="30123">fit_transform()</st>`
    <st c="30138">method to replace missing data in the train set and the</st> `<st
    c="30195">transform()</st>` <st c="30206">met</st><st c="30210">hod to replace
    missing data in the</st> <st c="30246">test set.</st>
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="29955">要使用</st> `<st c="29987">feature-engine</st>` <st c="30001">替换缺失值，我们使用了</st>
    `<st c="30010">ArbitraryValueImputer()</st>`<st c="30033">，指定了值</st> `<st c="30056">99</st>`
    <st c="30058">以及要填充的变量作为参数。</st> <st c="30102">接下来，我们将</st> `<st c="30123">fit_transform()</st>`
    <st c="30138">方法应用于替换训练集中的缺失数据，并使用</st> `<st c="30195">transform()</st>` <st c="30206">方法替换测试集中的缺失数据。</st>
- en: <st c="30255">Finding extreme values for imputation</st>
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="30255">为填充确定极端值</st>
- en: <st c="30293">Replacing missing values</st> <st c="30318">with a value at the
    end of the variable</st> <st c="30358">distribution (extreme values) is like replacing
    them with an arbitra</st><st c="30427">ry value, but instead of setting the arbitrary
    values manually, the values are automatically selected from the end of the</st>
    <st c="30550">variable distribution.</st>
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="30293">用变量分布末尾的值（极端值）替换缺失值，就像用任意值替换它们一样，但不是手动设置任意值，而是从变量分布的末尾自动选择这些值。</st>
- en: <st c="30572">We can replace missing data with a value that is greater or smaller
    than most values in the variable.</st> <st c="30675">To select a value that is
    greater, we can use the mean plus a factor of the standard deviation.</st> <st
    c="30771">Alternatively, we can set it to the 75th quantile + IQR × 1.5\.</st>
    **<st c="30834">IQR</st>** <st c="30837">stands for</st> **<st c="30849">inter-quartile
    range</st>** <st c="30869">and is the difference between</st> <st c="30899">the
    75th and 25th quantile.</st> <st c="30928">To replace missing data with values
    that are smaller than the remaining values, we can use the mean minus a factor
    of the standard deviation, or the 25th quantile – IQR ×</st> <st c="31099">1.5.</st>
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="30572">我们可以用比变量中大多数值大或小的值来替换缺失数据。</st> <st c="30675">为了选择一个比平均值大的值，我们可以使用平均值加上标准差的因子。</st>
    <st c="30771">或者，我们可以将其设置为75分位数 + 四分位数间距 × 1.5。</st> **<st c="30834">四分位数间距</st>**
    <st c="30837">代表</st> **<st c="30849">四分位数范围</st>** <st c="30869">，是第75分位数和第25分位数之间的差。</st>
    <st c="30928">为了用比剩余值小的值替换缺失数据，我们可以使用平均值减去标准差的因子，或者第25分位数 – 四分位数间距 ×</st> <st
    c="31099">1.5。</st>
- en: <st c="31103">Note</st>
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="31103">注意</st>
- en: <st c="31108">End-of-tail imputation may distort the distribution of the original
    variables, so it may not be suitable for</st> <st c="31218">linear models.</st>
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="31108">尾部插补可能会扭曲原始变量的分布，因此可能不适合</st> <st c="31218">线性模型。</st>
- en: <st c="31232">In this recipe, we will implement end-of-tail or extreme va</st><st
    c="31292">lue imputation using</st> `<st c="31314">pandas</st>` <st c="31320">and</st>
    `<st c="31325">feature-engine</st>`<st c="31339">.</st>
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="31232">在这个菜谱中，我们将使用</st> `<st c="31314">pandas</st>` <st c="31320">和</st>
    `<st c="31325">feature-engine</st>`<st c="31339">来实现尾部或极端值插补。</st>
- en: <st c="31340">How to do it...</st>
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="31340">如何做...</st>
- en: <st c="31356">To begin this</st> <st c="31370">recipe, let’s import the necessary
    tools</st> <st c="31411">and load</st> <st c="31421">the data:</st>
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="31356">为了开始这个</st> <st c="31370">菜谱，让我们导入必要的工具</st> <st c="31411">并加载</st>
    <st c="31421">数据：</st>
- en: <st c="31430">Let’s import</st> `<st c="31444">pandas</st>` <st c="31450">and
    the required function</st> <st c="31477">and class:</st>
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="31430">让我们导入</st> `<st c="31444">pandas</st>` <st c="31450">和所需的功能</st>
    <st c="31477">和类：</st>
- en: '[PRE65]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: <st c="31613">Let’s load the dataset we described in the</st> *<st c="31657">Technical</st>*
    *<st c="31667">requirements</st>* <st c="31679">section:</st>
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="31613">让我们加载我们在</st> *<st c="31657">技术</st>* *<st c="31667">要求</st>*
    <st c="31679">部分</st>中描述的数据集：</st>
- en: '[PRE66]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: <st c="31734">Let’s capture the numerical variables in a list, excluding</st>
    <st c="31794">the target:</st>
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="31734">让我们将数值变量捕获到一个列表中，排除</st> <st c="31794">目标：</st>
- en: '[PRE67]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: <st c="31908">Let’s split the data into train and test sets, keeping only the</st>
    <st c="31973">numerical variables:</st>
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="31908">让我们将数据分为训练集和测试集，只保留</st> <st c="31973">数值变量：</st>
- en: '[PRE68]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: <st c="32116">We’ll now determine</st> <st c="32137">the IQR:</st>
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="32116">我们现在将确定</st> <st c="32137">四分位数间距：</st>
- en: '[PRE69]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: <st c="32199">We can visualize</st> <st c="32216">the IQR values</st> <st c="32231">by
    executing</st> `<st c="32245">IQR</st>` <st c="32248">or</st> `<st c="32252">print(IQR)</st>`<st
    c="32262">:</st>
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="32199">我们可以通过执行</st> `<st c="32245">IQR</st>` <st c="32248">或</st> `<st
    c="32252">print(IQR)</st>`<st c="32262">来可视化</st> <st c="32231">四分位数间距值：</st>
- en: '[PRE70]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: <st c="32346">Let’s create a dictionary with the variable names and the</st>
    <st c="32405">imputation values:</st>
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="32346">让我们创建一个包含变量名称和</st> <st c="32405">插补值</st>的字典：
- en: '[PRE71]'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: <st c="32489">Note</st>
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="32489">注意</st>
- en: <st c="32494">If we use the inter-quartile range proximity rule, we determine
    the imputation values by adding 1.5 times the IQR to the 75th quantile.</st> <st
    c="32631">If variables are normally distributed, we can calculate the imputation
    values as the mean plus a factor of the standard deviation,</st> `<st c="32762">imputation_dict
    = (X_train.me</st><st c="32791">an() + 3 *</st>` `<st c="32803">X_train.std()).to_dict()</st>`<st
    c="32827">.</st>
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="32494">如果我们使用四分位数范围邻近规则，我们通过将1.5倍的四分位数范围（IQR）加到第75百分位数来确定插补值。</st> <st
    c="32631">如果变量呈正态分布，我们可以通过计算平均值加上标准差的因子来计算插补值，</st> `<st c="32762">imputation_dict
    = (X_train.mean() + 3 * X_train.std()).to_dict()</st>`<st c="32827">.</st>
- en: <st c="32828">Finally, let’s replace the</st> <st c="32856">missing data:</st>
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="32828">最后，让我们替换</st> <st c="32856">缺失的数据：</st>
- en: '[PRE72]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: <st c="32967">Note</st>
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="32967">注意</st>
- en: <st c="32972">We can also replace missing data with values at the left tail
    of the distribution using</st> `<st c="33061">value = X_train[var].quantile(0.25)
    - 1.5 * IQR</st>` <st c="33108">or</st> `<st c="33112">value = X_train[var].mean()
    – 3 *</st>` `<st c="33146">X_train[var].std()</st>`<st c="33164">.</st>
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="32972">我们还可以使用</st> `<st c="33061">value = X_train[var].quantile(0.25)
    - 1.5 * IQR</st>` <st c="33108">或</st> `<st c="33112">value = X_train[var].mean()
    – 3 * X_train[var].std()</st>`<st c="33146">来用分布左尾的值替换缺失数据</st> <st c="33164">.</st>
- en: <st c="33165">To finish, let’s impute</st> <st c="33189">missing values</st>
    <st c="33204">using</st> `<st c="33211">feature-engine</st>`<st c="33225">.</st>
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="33165">为了完成，让我们使用</st> <st c="33189">feature-engine</st> <st c="33204">来插补缺失值：</st>
- en: <st c="33226">Let’s set up</st> `<st c="33240">imputer</st>` <st c="33247">to
    estimate a value at the right of the distribution using the IQR</st> <st c="33315">proximity
    rule:</st>
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="33226">让我们设置</st> `<st c="33240">imputer</st>` <st c="33247">来使用IQR邻近规则估计分布右侧的值：</st>
- en: '[PRE73]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: <st c="33421">Note</st>
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="33421">注意</st>
- en: <st c="33426">To use the mean and standard deviation to calculate the replacement
    values, set</st> `<st c="33507">imputation_method="Gaussian"</st>`<st c="33535">.
    Use</st> `<st c="33541">left</st>` <st c="33545">or</st> `<st c="33549">right</st>`
    <st c="33554">in the</st> `<st c="33562">tail</st>` <st c="33566">argument to
    specify the side of the distribution to consider when finding values for</st>
    <st c="33652">the imputation.</st>
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="33426">要使用平均值和标准差来计算替换值，设置</st> `<st c="33507">imputation_method="Gaussian"</st>`<st
    c="33535">。使用</st> `<st c="33541">left</st>` <st c="33545">或</st> `<st c="33549">right</st>`
    <st c="33554">在</st> `<st c="33562">tail</st>` <st c="33566">参数中指定在寻找插补值时要考虑的分布的哪一侧。</st>
- en: <st c="33667">Let’s fit</st> `<st c="33678">EndTailImputer()</st>` <st c="33694">to
    the train set so that it learns the</st> <st c="33734">values for</st> <st c="33745">the
    imputation:</st>
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="33667">让我们将</st> `<st c="33678">EndTailImputer()</st>` <st c="33694">拟合到训练集，以便它学习插补的值：</st>
- en: '[PRE74]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: <st c="33781">Let’s inspect the</st> <st c="33800">learned values:</st>
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="33781">让我们检查</st> <st c="33800">学习到的值：</st>
- en: '[PRE75]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: <st c="33837">The previous command</st> <st c="33858">returns a dictionary with
    the values</st> <st c="33895">to use to impute</st> <st c="33913">each variable:</st>
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="33837">之前的命令</st> <st c="33858">返回一个包含用于插补</st> <st c="33895">每个变量的值</st>
    <st c="33913">的字典：</st>
- en: '[PRE76]'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: <st c="34022">Finally, let’s replace the</st> <st c="34050">missing values:</st>
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="34022">最后，让我们替换</st> <st c="34050">缺失的值：</st>
- en: '[PRE77]'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: <st c="34137">Remember that you can corroborate that the missing values were
    replaced by using</st> `<st c="34219">X_train[[</st><st c="34228">'A2','A3', 'A8',
    'A11', '</st>``<st c="34254">A14', 'A15']].isnull().mean()</st>`<st c="34284">.</st>
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="34137">记住，你可以使用</st> `<st c="34219">X_train[[</st><st c="34228">'A2','A3',
    'A8', 'A11', '</st>``<st c="34254">A14', 'A15']].isnull().mean()</st>`<st c="34284">.</st>
- en: <st c="34285">How it works...</st>
  id: totrans-323
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="34285">它是如何工作的...</st>
- en: <st c="34301">In this recipe, we replaced missing values in numerical variables
    with a number at the end</st> <st c="34393">of the distribution using</st> `<st
    c="34419">pandas</st>` <st c="34425">and</st> `<st c="34430">feature-engine</st>`<st
    c="34444">.</st>
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="34301">在这个菜谱中，我们使用`pandas`和`feature-engine`在数值变量的分布末端替换了缺失值</st> <st
    c="34393">。</st>
- en: <st c="34445">We determined the imputation values according to the formulas
    described in the introduction to this recipe.</st> <st c="34554">We used pandas</st>
    `<st c="34569">quantile()</st>` <st c="34579">to find specific quantile values,
    or</st> `<st c="34617">pandas</st>` `<st c="34623">mean()</st>` <st c="34630">and</st>
    `<st c="34635">std()</st>` <st c="34640">for the mean and standard deviation.</st>
    <st c="34678">With pandas</st> `<st c="34690">fillna()</st>` <st c="34698">we
    replaced the</st> <st c="34715">missing values.</st>
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="34445">我们根据本食谱引言中描述的公式确定了插补值。</st> <st c="34554">我们使用pandas</st> `<st
    c="34569">quantile()</st>` <st c="34579">来找到特定的分位数值，或者使用</st> `<st c="34617">pandas</st>`
    `<st c="34623">mean()</st>` <st c="34630">和</st> `<st c="34635">std()</st>` <st
    c="34640">来获取平均值和标准差。</st> <st c="34678">使用pandas</st> `<st c="34690">fillna()</st>`
    <st c="34698">我们替换了缺失值。</st>
- en: <st c="34730">To replace missing values with</st> `<st c="34762">EndTailImputer()</st>`
    <st c="34778">from</st> `<st c="34784">feature-engine</st>`<st c="34798">, we
    set</st> `<st c="34807">distribution</st>` <st c="34819">to</st> `<st c="34823">iqr</st>`
    <st c="34826">to calculate the values based on the IQR proximity rule.</st> <st
    c="34884">With</st> `<st c="34889">tail</st>` <st c="34893">set to</st> `<st c="34901">right</st>`
    <st c="34906">the transformer found the imputation values from the right of the
    distribution.</st> <st c="34987">With</st> `<st c="34992">fit()</st>`<st c="34997">,
    the imputer learned and stored the values for the imputation in a dictionary in
    the</st> `<st c="35083">imputer_dict_</st>` <st c="35096">attribute.</st> <st
    c="35108">With</st> `<st c="35113">transform()</st>`<st c="35124">, we replaced</st>
    <st c="35137">the missing</st> <st c="35149">values,</st> <st c="35158">returning
    DataFrames.</st>
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="34730">使用</st> `<st c="34762">EndTailImputer()</st>` <st c="34778">从</st>
    `<st c="34784">feature-engine</st>`<st c="34798">替换缺失值，我们将</st> `<st c="34807">distribution</st>`
    <st c="34819">设置为</st> `<st c="34823">iqr</st>` <st c="34826">以根据IQR邻近规则计算值。</st>
    <st c="34884">将</st> `<st c="34889">tail</st>` <st c="34893">设置为</st> `<st c="34901">right</st>`
    <st c="34906">后，转换器从分布的右侧找到了插补值。</st> <st c="34987">使用</st> `<st c="34992">fit()</st>`<st
    c="34997">，插补器学习并存储了在</st> `<st c="35083">imputer_dict_</st>` <st c="35096">属性中的插补值。</st>
    <st c="35108">使用</st> `<st c="35113">transform()</st>`<st c="35124">，我们替换了缺失的</st>
    <st c="35137">值，返回DataFrames。</st>
- en: <st c="35179">Marking imputed values</st>
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="35179">标记插补值</st>
- en: <st c="35202">In the previous recipes, we focused</st> <st c="35239">on replacing
    missing data with estimates of their values.</st> <st c="35297">In addition, we
    can add missing indicators to</st> *<st c="35343">mark</st>* <st c="35347">observations
    where values</st> <st c="35374">were missing.</st>
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="35202">在前面的食谱中，我们专注于使用它们值的估计来替换缺失数据。</st> <st c="35239">此外，我们还可以向*<st
    c="35343">标记</st>* <st c="35347">缺失值的观测值添加缺失指示符。</st>
- en: <st c="35387">A missing indicator is a binary var</st><st c="35423">iable that
    takes the value</st> `<st c="35451">1</st>` <st c="35452">or</st> `<st c="35456">True</st>`
    <st c="35460">to indicate whether a value was missing, and</st> `<st c="35506">0</st>`
    <st c="35507">or</st> `<st c="35511">False</st>` <st c="35516">otherwise.</st>
    <st c="35528">It is common practice to replace missing observations with the mean,
    median, or most frequent category while simultaneously marking those missing observations
    with missing indicators.</st> <st c="35712">In this recipe, we will learn how
    to add missing</st> <st c="35761">indicators using</st> `<st c="35778">pandas</st>`<st
    c="35784">,</st> `<st c="35786">scikit-learn</st>`<st c="35798">,</st> <st c="35800">and</st>
    `<st c="35804">feature-engine</st>`<st c="35818">.</st>
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="35387">缺失指示符是一个二元变量，它取值为</st> `<st c="35451">1</st>` <st c="35452">或</st>
    `<st c="35456">True</st>` <st c="35460">以指示值是否缺失，否则取值为</st> `<st c="35506">0</st>`
    <st c="35507">或</st> `<st c="35511">False</st>` <st c="35516">。</st> <st c="35528">在同时用缺失指示符标记缺失观测值的同时，用平均值、中位数或最频繁的类别替换缺失观测值是一种常见的做法。</st>
    <st c="35712">在本食谱中，我们将学习如何使用</st> `<st c="35778">pandas</st>`<st c="35784">、</st>
    `<st c="35786">scikit-learn</st>`<st c="35798">、</st> `<st c="35800">和</st> `<st
    c="35804">feature-engine</st>`<st c="35818">添加缺失指示符。</st>
- en: <st c="35819">How to do it...</st>
  id: totrans-330
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="35819">如何操作...</st>
- en: <st c="35835">Let’s begin by making some imports and loading</st> <st c="35883">the
    data:</st>
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="35835">让我们先进行一些导入并加载数据：</st>
- en: <st c="35892">Let’s import the required libraries, functions,</st> <st c="35941">and
    classes:</st>
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="35892">让我们导入所需的库、函数和类：</st>
- en: '[PRE78]'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: <st c="36270">Let’s load and split the dataset</st> <st c="36303">described
    in the</st> *<st c="36321">Technical</st>* *<st c="36331">requirements</st>* <st
    c="36343">section:</st>
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="36270">让我们加载并分割</st> <st c="36303">在</st> *<st c="36321">技术</st> * *<st
    c="36331">要求</st> * <st c="36343">部分中描述的</st> 数据集：</st>
- en: '[PRE79]'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: <st c="36529">Let’s capture the variable names in</st> <st c="36566">a list:</st>
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="36529">让我们将变量名捕获到一个</st> <st c="36566">列表中：</st>
- en: '[PRE80]'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: <st c="36627">Let’s create names for the missing indicators and store them in</st>
    <st c="36692">a list:</st>
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="36627">让我们为缺失指示器创建名称并将它们存储到一个</st> <st c="36692">列表中：</st>
- en: '[PRE81]'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: <st c="36746">If we execute</st> `<st c="36761">indicators</st>`<st c="36771">,
    we will see the names we will use for the new variables:</st> `<st c="36830">['A1_na',
    'A3_na', 'A4_na', 'A5_na', 'A6_na', '</st>``<st c="36877">A7_na', 'A8_na']</st>`<st
    c="36894">.</st>
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="36746">如果我们执行</st> `<st c="36761">indicators</st>`<st c="36771">，我们将看到我们将用于新变量的名称：</st>
    `<st c="36830">['A1_na', 'A3_na', 'A4_na', 'A5_na', 'A6_na', '</st>``<st c="36877">A7_na',
    'A8_na']</st>`<st c="36894">。</st>
- en: <st c="36895">Let’s make a copy of the</st> <st c="36921">original DataFrames:</st>
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="36895">让我们复制原始的</st> <st c="36921">DataFrame：</st>
- en: '[PRE82]'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: <st c="36994">Let’s add the</st> <st c="37009">missing indicators:</st>
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="36994">让我们添加</st> <st c="37009">缺失指示器：</st>
- en: '[PRE83]'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: <st c="37149">Note</st>
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="37149">注意</st>
- en: <st c="37154">If you want the indicators to have</st> `<st c="37190">True</st>`
    <st c="37194">and</st> `<st c="37199">False</st>` <st c="37204">as values instead
    of</st> `<st c="37226">0</st>` <st c="37227">and</st> `<st c="37232">1</st>`<st
    c="37233">, remove</st> `<st c="37242">astype(int)</st>` <st c="37253">in</st>
    *<st c="37257">step 6</st>*<st c="37263">.</st>
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="38283">如果您希望指示器具有</st> `<st c="37190">True</st>` <st c="37194">和</st>
    `<st c="37199">False</st>` <st c="37204">作为值，而不是</st> `<st c="37226">0</st>` <st
    c="37227">和</st> `<st c="37232">1</st>`<st c="37233">，请在</st> `<st c="37242">astype(int)</st>`
    <st c="37253">中移除</st> *<st c="37257">步骤 6</st>*<st c="37263">。</st>
- en: <st c="37264">Let’s inspect the</st> <st c="37283">resulting</st> <st c="37292">DataFrame:</st>
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="37264">让我们检查</st> <st c="37283">结果</st> <st c="37292">DataFrame：</st>
- en: '[PRE84]'
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: <st c="37320">We can see the newly added vari</st><st c="37352">ables at the
    right of the DataFrame in the</st> <st c="37396">following image:</st>
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="37320">我们可以在以下图像的DataFrame右侧看到新添加的变量：</st> <st c="37396">（图像）</st>
- en: '![Figure 1.4 – DataFrame with the missing indicators](img/B22396_01_04.jpg)'
  id: totrans-350
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.4 – 带有缺失指示器的 DataFrame](img/B22396_01_04.jpg)'
- en: <st c="37815">Figure 1.4 – DataFrame with the missing indicators</st>
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="37815">图 1.4 – 带有缺失指示器的 DataFrame</st>
- en: <st c="37865">Now, let’s add missing indicators using</st> <st c="37906">Feature-engine
    instead.</st>
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="37865">现在，让我们使用</st> <st c="37906">Feature-engine 添加缺失指示器。</st>
- en: <st c="37929">Set up the imputer to add binary indicators to every variable
    with</st> <st c="37997">missing data:</st>
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="37929">设置插补器，为每个具有</st> <st c="37997">缺失数据的变量添加二进制指示器：</st>
- en: '[PRE85]'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: <st c="38078">Fit the imputer to the train set so that it finds the variables
    with</st> <st c="38148">missing data:</st>
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="38078">将插补器拟合到训练集，以便它找到具有</st> <st c="38148">缺失数据的变量：</st>
- en: '[PRE86]'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: <st c="38182">Note</st>
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="38182">注意</st>
- en: <st c="38187">If we execute</st> `<st c="38202">imputer.variables_</st>`<st
    c="38220">, we will find the variables for which missing indicators will</st>
    <st c="38283">be added.</st>
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="38187">如果我们执行</st> `<st c="38202">imputer.variables_</st>`<st c="38220">，我们会找到将添加缺失指示器的变量。</st>
- en: <st c="38292">Finally, let’s add the</st> <st c="38316">missing indicators:</st>
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="38292">最后，让我们添加</st> <st c="38316">缺失指示器：</st>
- en: '[PRE87]'
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: <st c="38411">So far, we just added missing indicators.</st> <st c="38454">But
    we still have the missing data in our variables.</st> <st c="38507">We need to
    replace them with numbers.</st> <st c="38545">In the rest of this recipe, we will
    combine the use of missing indicators with mean and</st> <st c="38633">mode imputation.</st>
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="38411">到目前为止，我们只是添加了缺失指示器。</st> <st c="38454">但我们变量中仍然有缺失数据。</st> <st
    c="38507">我们需要用数字来替换它们。</st> <st c="38545">在本教程的剩余部分，我们将结合使用缺失指示器与均值和</st> <st
    c="38633">众数插补。</st>
- en: <st c="38649">Let’s create a pipeline</st> <st c="38673">to add missing indicators
    to categorical and numerical variables, then impute categorical variables with
    the most frequent category, and numerical variables with</st> <st c="38836">the
    mean:</st>
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="38649">让我们创建一个</st> <st c="38673">管道，将缺失指示器添加到分类和数值变量中，然后使用最频繁的类别对分类变量进行插补，使用均值对数值变量进行插补：</st>
- en: '[PRE88]'
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: <st c="39026">Note</st>
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="39026">注意</st>
- en: '`<st c="39031">feature-engine</st>` <st c="39046">imputers automatically identify
    numerical or categorical variables.</st> <st c="39115">So there is no need to
    slice the data or pass the variabl</st><st c="39172">e names as arguments to the
    transformers in</st> <st c="39217">this case.</st>'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="39031">feature-engine</st>` `<st c="39046">填充器会自动识别数值或类别变量。</st>` `<st
    c="39115">因此在这种情况下不需要切片数据或传递变量名作为参数到</st>` `<st c="39172">这个转换器的参数中。</st>`'
- en: <st c="39227">Let’s add the indicators and impute</st> <st c="39264">missing
    values:</st>
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`<st c="39227">让我们添加指示器并填充</st>` `<st c="39264">缺失值：</st>`'
- en: '[PRE89]'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: <st c="39353">Note</st>
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="39353">注意</st>`'
- en: <st c="39358">Use</st> `<st c="39363">X_train_t.isnull().sum()</st>` <st c="39387">to
    corroborate that there is no data missing.</st> <st c="39434">Execute</st> `<st
    c="39442">X_train_t.head()</st>` <st c="39458">to get a view of the</st> <st c="39480">resulting
    datafame.</st>
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `<st c="39358">Use</st>` `<st c="39363">X_train_t.isnull().sum()</st>` `<st
    c="39387">来验证没有数据缺失。</st>` `<st c="39434">执行</st>` `<st c="39442">X_train_t.head()</st>`
    `<st c="39458">以查看</st>` `<st c="39480">结果数据集。</st>`
- en: <st c="39499">Finally, let’s add missing indicators and simultaneously impute
    numerical and categorical variables with the mean and most frequent categories
    respectively,</st> <st c="39657">utilizing scikit-learn.</st>
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="39499">最后，让我们添加缺失指示器，并利用scikit-learn同时用均值和最频繁的类别分别填充数值和类别变量，</st>`
    `<st c="39657">实现填充：</st>`'
- en: <st c="39680">Let’s make a list with the names</st> <st c="39713">of the numerical
    and</st> <st c="39735">categorical variables:</st>
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`<st c="39680">让我们创建一个包含</st>` `<st c="39713">数值和</st>` `<st c="39735">类别变量</st>`
    `<st c="39735">名称的列表：</st>`'
- en: '[PRE90]'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: <st c="39885">Let’s set up a pipeline to perform mean and frequent category
    imputation while marking the</st> <st c="39977">missing data:</st>
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`<st c="39885">让我们设置一个管道来执行均值和频繁类别填充，同时标记</st>` `<st c="39977">缺失数据：</st>`'
- en: '[PRE91]'
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: <st c="40218">Now, let’s carry out</st> <st c="40240">the imputation:</st>
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`<st c="40218">现在，让我们执行</st>` `<st c="40240">填充：</st>`'
- en: '[PRE92]'
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: <st c="40329">Make sure to explore</st> `<st c="40350">X_train_t.head()</st>`
    <st c="40367">to get familiar with the</st> <st c="40393">pipeline’s output.</st>
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="40329">确保探索</st>` `<st c="40350">X_train_t.head()</st>` `<st c="40367">以熟悉</st>`
    `<st c="40393">管道的输出。</st>`'
- en: <st c="40411">How it works...</st>
  id: totrans-378
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`<st c="40411">它是如何工作的...</st>`'
- en: <st c="40427">To add missing</st> <st c="40442">indicators</st> <st c="40453">using
    pandas, we used</st> `<st c="40476">isna()</st>`<st c="40482">, which created
    a new vector assigning the value of</st> `<st c="40534">True</st>` <st c="40538">if
    there was a missing value or</st> `<st c="40571">False</st>` <st c="40576">otherwise.</st>
    <st c="40588">We used</st> `<st c="40596">astype(int)</st>` <st c="40607">to convert
    the Boolean vectors into binary vectors with values</st> `<st c="40671">1</st>`
    <st c="40672">and</st> `<st c="40676">0</st>`<st c="40677">.</st>
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="40427">要使用pandas添加缺失</st>` `<st c="40442">指示器</st>` `<st c="40453">，我们使用了</st>`
    `<st c="40476">isna()</st>` `<st c="40482">，它创建了一个新向量，如果存在缺失值则分配值为</st>` `<st
    c="40534">True</st>` `<st c="40538">，否则为</st>` `<st c="40571">False</st>` `<st
    c="40576">。</st>` `<st c="40588">我们使用了</st>` `<st c="40596">astype(int)</st>`
    `<st c="40607">将布尔向量转换为具有值</st>` `<st c="40671">1</st>` `<st c="40672">和</st>`
    `<st c="40676">0</st>` `<st c="40677">的二进制向量。</st>`'
- en: <st c="40678">To add a missing indicator with</st> `<st c="40711">feature-engine</st>`<st
    c="40725">, we used</st> `<st c="40735">AddMissingIndicator()</st>`<st c="40756">.
    With</st> `<st c="40763">fit()</st>` <st c="40768">the transformer found the variables
    with missing data.</st> <st c="40824">With</st> `<st c="40829">transform()</st>`
    <st c="40840">it appended the missing indicators to the right of the train and</st>
    <st c="40906">test sets.</st>
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="40678">要使用</st>` `<st c="40711">feature-engine</st>` `<st c="40725">添加缺失指示器，我们使用了</st>`
    `<st c="40735">AddMissingIndicator()</st>` `<st c="40756">。使用</st>` `<st c="40763">fit()</st>`
    `<st c="40768">转换器找到了具有缺失数据的变量。</st>` `<st c="40824">使用</st>` `<st c="40829">transform()</st>`
    `<st c="40840">它将缺失指示器添加到训练集和测试集的右侧。</st>`'
- en: <st c="40916">To sequentially add missing indicators and then replace the</st>
    `<st c="40977">nan</st>` <st c="40980">values with the most frequent category
    or the mean, we lined up Feature-engine’s</st> `<st c="41062">AddMissingIndicator()</st>`<st
    c="41083">,</st> `<st c="41085">CategoricalImputer()</st>`<st c="41105">, and</st>
    `<st c="41111">MeanMedianImputer()</st>` <st c="41130">within a</st> `<st c="41140">pipeline</st>`<st
    c="41148">. The</st> `<st c="41154">fit()</st>` <st c="41159">method from the</st>
    `<st c="41176">pipeline</st>` <st c="41184">made the transformers find the variables
    with</st> `<st c="41231">nan</st>` <st c="41234">and calculate the mean of the
    numerical variables and the mode of the categorical variables.</st> <st c="41328">The</st>
    `<st c="41332">transform()</st>` <st c="41343">method from the</st> `<st c="41360">pipeline</st>`
    <st c="41368">made the transformers add the missing indicators and then replace
    the missing values with</st> <st c="41459">their estimates.</st>
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="40916">为了依次添加缺失指标然后替换</st> `<st c="40977">nan</st>` <st c="40980">值，我们将
    Feature-engine 的</st> `<st c="41062">AddMissingIndicator()</st>`<st c="41083">,</st>
    `<st c="41085">CategoricalImputer()</st>`<st c="41105">, 和</st> `<st c="41111">MeanMedianImputer()</st>`
    <st c="41130">集成在一个</st> `<st c="41140">pipeline</st>`<st c="41148">中。`<st c="41154">fit()</st>`
    <st c="41159">方法从`<st c="41176">pipeline</st>` <st c="41184">中使转换器找到包含`<st c="41231">nan</st>`
    <st c="41234">的变量，并计算数值变量的平均值和分类变量的众数。</st> `<st c="41328">transform()</st>` <st
    c="41343">方法从`<st c="41360">pipeline</st>` <st c="41368">中使转换器添加缺失指标，然后用它们的估计值替换缺失值。</st>
- en: <st c="41475">Note</st>
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="41475">注意</st>
- en: <st c="41480">Feature-engine transformations return DataFrames respecting the
    original names and order of the variables.</st> <st c="41588">Scikit-learn’s</st>
    `<st c="41603">ColumnTransformer()</st>`<st c="41622">, on the other hand, changes
    the variable’s names and order in the</st> <st c="41689">resulting data.</st>
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="41480">Feature-engine 转换返回的 DataFrames 保留了变量的原始名称和顺序。</st> `<st c="41588">Scikit-learn
    的`<st c="41603">ColumnTransformer()</st>`<st c="41622">，另一方面，会改变结果数据中变量的名称和顺序。</st>
- en: <st c="41704">Finally, we added missing indicators and replaced missing data
    with the mean and most frequent category using</st> `<st c="41815">scikit-learn</st>`<st
    c="41827">. We lined up two instances of</st> `<st c="41858">SimpleImputer()</st>`<st
    c="41873">, the first to impute data with the mean and the second to impute data
    with the most frequent category.</st> <st c="41977">In both cases, we set the</st>
    `<st c="42003">add_indicator</st>` <st c="42016">parameter to</st> `<st c="42030">True</st>`
    <st c="42034">to add the missing indicators.</st> <st c="42066">We wrapped</st>
    `<st c="42077">SimpleImputer()</st>` <st c="42092">with</st> `<st c="42098">ColumnTransformer()</st>`
    <st c="42117">to specifically modify numerical or categorical variables.</st>
    <st c="42177">Then we used the</st> `<st c="42194">fit()</st>` <st c="42199">and</st>
    `<st c="42204">transform()</st>` <st c="42215">methods from the</st> `<st c="42233">pipeline</st>`
    <st c="42241">to train the transformers and then add the indicators and replace
    the</st> <st c="42312">missing data.</st>
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="41704">最后，我们使用`<st c="41815">scikit-learn</st>`<st c="41827">添加缺失指标并用平均值和最频繁的类别替换缺失数据。我们排列了两个`<st
    c="41858">SimpleImputer()</st>`<st c="41873">实例，第一个用平均值填充数据，第二个用最频繁的类别填充数据。</st>
    `<st c="41977">在两种情况下，我们将`<st c="42003">add_indicator</st>` <st c="42016">参数设置为`<st
    c="42030">True</st>` <st c="42034">以添加缺失指标。</st> `<st c="42066">我们将`<st c="42077">SimpleImputer()</st>`
    <st c="42092">包装在`<st c="42098">ColumnTransformer()</st>` <st c="42117">中，以专门修改数值或分类变量。</st>
    `<st c="42177">然后我们使用`<st c="42194">fit()</st>` <st c="42199">和`<st c="42204">transform()</st>`
    <st c="42215">方法从`<st c="42233">pipeline</st>` <st c="42241">中训练转换器，然后添加指标并替换缺失数据。</st>
- en: <st c="42325">When returning DataFrames,</st> `<st c="42353">ColumnTransformer()</st>`
    <st c="42372">changes the names of the variables and their order.</st> <st c="42425">Take
    a look at the result from</st> *<st c="42456">step 15</st>* <st c="42463">by executing</st>
    `<st c="42477">X_train_t.head()</st>`<st c="42493">. You’ll see that the name
    given to each step of the pipeline is added as a prefix to the variables to flag
    which variable was modified with each transformer.</st> <st c="42652">Then,</st>
    `<st c="42658">num_imputer__A2</st>` <st c="42673">was returned by the first step
    of the pipeline, while</st> `<st c="42728">cat_imputer__A12</st>` <st c="42744">was
    returned</st> <st c="42757">by the second step of</st> <st c="42780">the pipeline.</st>
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="42325">当返回 DataFrames 时，<st c="42353">ColumnTransformer()</st> <st c="42372">会更改变量的名称及其顺序。</st>
    <st c="42425">查看通过执行</st> *<st c="42456">步骤 15</st>* <st c="42463">的结果</st> `<st
    c="42477">X_train_t.head()</st>`<st c="42493">。你会看到每个步骤的名称被添加为变量的前缀，以标记每个变量被哪个转换器修改。</st>
    <st c="42652">然后，</st> `<st c="42658">num_imputer__A2</st>` <st c="42673">由管道的第一步返回，而</st>
    `<st c="42728">cat_imputer__A12</st>` <st c="42744">由管道的第二步返回</st> <st c="42757">。</st>
- en: <st c="42793">There’s more…</st>
  id: totrans-386
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="42793">还有更多...</st>
- en: <st c="42807">Scikit-learn has</st> <st c="42824">the</st> `<st c="42829">MissingIndicator()</st>`
    <st c="42847">transformer that just adds missing indicators.</st> <st c="42895">Check
    it out in the documentation:</st> [<st c="42930">https://scikit-learn.org/stable/modules/generated/sklearn.impute.MissingIndicator.html</st>](https://scikit-learn.org/stable/modules/generated/sklearn.impute.MissingIndicator.html)
    <st c="43016">and find an example in the accompanying GitHub repository</st> <st
    c="43075">at</st> [<st c="43078">https://github.com/PacktPublishing/Python-Feature-engineering-Cookbook-Third-Edition/blob/main/ch01</st><st
    c="43177">-missing-data-imputation/Recipe-06-Marking-imputed-values.ipynb</st>](https://github.com/PacktPublishing/Python-Feature-engineering-Cookbook-Third-Edition/blob/main/ch01-missing-data-imputation/Recipe-06-Marking-imputed-values.ipynb)<st
    c="43241">.</st>
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="42807">Scikit-learn 有</st> <st c="42824">一个</st> `<st c="42829">MissingIndicator()</st>`
    <st c="42847">转换器，它只是添加缺失指示器。</st> <st c="42895">在文档中查看它：</st> [<st c="42930">https://scikit-learn.org/stable/modules/generated/sklearn.impute.MissingIndicator.html</st>](https://scikit-learn.org/stable/modules/generated/sklearn.impute.MissingIndicator.html)
    <st c="43016">并在相关的 GitHub 仓库中找到一个示例</st> <st c="43075">在</st> [<st c="43078">https://github.com/PacktPublishing/Python-Feature-engineering-Cookbook-Third-Edition/blob/main/ch01</st><st
    c="43177">-missing-data-imputation/Recipe-06-Marking-imputed-values.ipynb</st>](https://github.com/PacktPublishing/Python-Feature-engineering-Cookbook-Third-Edition/blob/main/ch01-missing-data-imputation/Recipe-06-Marking-imputed-values.ipynb)<st
    c="43241">。</st>
- en: <st c="43242">Implementing forward and backward fill</st>
  id: totrans-388
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="43242">实现前向和后向填充</st>
- en: <st c="43281">Time series data also show missing values.</st> <st c="43325">To
    impute</st> <st c="43334">missing data in time series, we use specific methods.</st>
    <st c="43389">Forward fill imputation involves filling missing values in a dataset
    with the most recent non-missing value that precedes it in the data sequence.</st>
    <st c="43536">In other words, we carry forward the last seen value to the next
    valid value.</st> <st c="43614">Backward fill imputation involves filling missing
    values with the next non-missing value that follows it in the data sequence.</st>
    <st c="43741">In other words, we carry the last valid value backward to its preceding</st>
    <st c="43813">valid value.</st>
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="43281">时间序列数据也显示缺失值。</st> <st c="43325">为了在时间序列中插补缺失数据，我们使用特定的方法。</st>
    <st c="43389">前向填充插补涉及在数据序列中用最接近的前一个非缺失值填充数据集中的缺失值。</st> <st c="43536">换句话说，我们将最后一个观察到的值向前传递到下一个有效值。</st>
    <st c="43614">后向填充插补涉及用数据序列中跟随它的下一个非缺失值填充缺失值。</st> <st c="43741">换句话说，我们将最后一个有效值向后传递到其前面的</st>
    <st c="43813">有效值。</st>
- en: <st c="43825">In this recipe, we will replace missing data in a time series
    with forward and</st> <st c="43905">backward fills.</st>
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="43825">在这个菜谱中，我们将使用前向和后向填充替换时间序列中的缺失数据。</st>
- en: <st c="43920">How to do it...</st>
  id: totrans-391
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="43920">如何操作...</st>
- en: <st c="43936">Let’s begin by importing the required</st> <st c="43974">libraries
    and time</st> <st c="43994">series dataset:</st>
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="43936">让我们首先导入所需的</st> <st c="43974">库和时间</st> <st c="43994">序列数据集：</st>
- en: <st c="44009">Let’s import</st> `<st c="44023">pandas</st>` <st c="44029">and</st>
    `<st c="44034">matplotlib</st>`<st c="44044">:</st>
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="44009">让我们导入</st> `<st c="44023">pandas</st>` <st c="44029">和</st> `<st
    c="44034">matplotlib</st>`<st c="44044">:</st>
- en: '[PRE93]'
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: <st c="44098">Let’s load the air passengers dataset that we described in the</st>
    *<st c="44162">Technical requirements</st>* <st c="44184">section and display
    the first five rows of the</st> <st c="44232">time series:</st>
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="44098">让我们加载我们在</st> *<st c="44162">技术要求</st> <st c="44184">部分中描述的航空乘客数据集，并显示时序的前五行：</st>
- en: '[PRE94]'
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: <st c="44341">We see the time series in the</st> <st c="44372">following output:</st>
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="44341">我们在以下输出中看到时序数据：</st> <st c="44372">：</st>
- en: '[PRE95]'
  id: totrans-398
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: <st c="44478">Note</st>
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="44478">注意</st>
- en: <st c="44483">You can determine the percentage of missing data by</st> <st c="44536">executing</st>
    `<st c="44546">df.isnull().mean()</st>`<st c="44564">.</st>
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="44483">您可以通过执行</st> <st c="44536">df.isnull().mean()</st> <st c="44564">来</st>
    <st c="44536">确定缺失数据的百分比。</st>
- en: <st c="44565">Let’s plot the time series to spot any obvious</st> <st c="44613">data
    gaps:</st>
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="44565">让我们绘制时序图以查找任何明显</st> <st c="44613">的数据间隙：</st>
- en: '[PRE96]'
  id: totrans-402
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: <st c="44769">The previous code returns</st> <st c="44795">the following plot,
    where we see intervals of time where data</st> <st c="44858">is missing:</st>
  id: totrans-403
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="44769">前面的代码返回以下图表，其中我们看到了数据缺失的时间间隔：</st>
- en: '![Figure 1.5 – Time series data showing missing values](img/B22396_01_05.jpg)'
  id: totrans-404
  prefs: []
  type: TYPE_IMG
  zh: '![图1.5 – 显示缺失值的时序数据](img/B22396_01_05.jpg)'
- en: <st c="44967">Figure 1.5 – Time series data showing missing values</st>
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="44967">图1.5 – 显示缺失值的时序数据</st>
- en: <st c="45019">Let’s impute missing data by carrying the last observed value
    in any interval to the next</st> <st c="45110">valid value:</st>
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="45019">让我们通过将任何区间内最后观察到的值携带到下一个有效值来填充缺失数据：</st> <st c="45110">：</st>
- en: '[PRE97]'
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: <st c="45146">You can verify the absence of missing data by</st> <st c="45193">executing</st>
    `<st c="45203">df_imputed.isnull().sum()</st>`<st c="45228">.</st>
  id: totrans-408
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="45146">您可以通过执行</st> <st c="45193">df_imputed.isnull().sum()</st> <st
    c="45228">来验证缺失数据的缺失：</st>
- en: <st c="45229">Let’s now plot the complete dataset and overlay as a dotted line
    the values used for</st> <st c="45315">the imputation:</st>
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="45229">现在让我们绘制完整的数据集，并将用于</st> <st c="45315">插补的值叠加为虚线：</st>
- en: '[PRE98]'
  id: totrans-410
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: <st c="45560">The previous code returns the following plot, where we see the
    values used to replace</st> `<st c="45647">nan</st>` <st c="45650">as dotted lines</st>
    <st c="45666">overlaid in between the continuous time</st> <st c="45707">series
    lines:</st>
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="45560">前面的代码返回以下图表，其中我们看到了用于替换</st> `<st c="45647">nan</st>` <st c="45650">的值，并以虚线形式叠加在连续时间序列线之间</st>
    <st c="45707">：</st>
- en: '![Figure 1.6 – Time series data where missing values were replaced by the last
    seen observations (dotted line)](img/B22396_01_06.jpg)'
  id: totrans-412
  prefs: []
  type: TYPE_IMG
  zh: '![图1.6 – 使用最后观察到的值（虚线）替换缺失值的时序数据](img/B22396_01_06.jpg)'
- en: <st c="45819">Figure 1.6 – Time series data where missing values were replaced
    by the last seen observations (dotted line)</st>
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="45819">图1.6 – 使用最后观察到的值（虚线）替换缺失值的时序数据</st>
- en: <st c="45927">Alternatively, we can impute missing data using</st> <st c="45976">backward
    fill:</st>
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="45927">或者，我们可以使用</st> <st c="45976">后向填充</st>来填充缺失数据：
- en: '[PRE99]'
  id: totrans-415
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: <st c="46014">If we plot the imputed dataset and overlay the imputation values
    as we did in</st> *<st c="46093">step 5</st>*<st c="46099">, we’ll see the</st>
    <st c="46115">following plot:</st>
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="46014">如果我们绘制插补数据集，并将插补值叠加到我们</st> *<st c="46093">在第5步</st>* <st c="46099">所做的那样，我们将看到以下图表：</st>
- en: '![Figure 1.7 – Time series data where missing values were replaced by backward
    fill (dotted line)](img/B22396_01_07.jpg)'
  id: totrans-417
  prefs: []
  type: TYPE_IMG
  zh: '![图1.7 – 使用后向填充（虚线）替换缺失值的时序数据](img/B22396_01_07.jpg)'
- en: <st c="46225">Figure 1.7 – Time series data where missing values were replaced
    by backward fill (dotted line)</st>
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="46225">图1.7 – 使用后向填充（虚线）替换缺失值的时序数据</st>
- en: <st c="46320">Note</st>
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="46320">注意</st>
- en: <st c="46325">The heights of the values used in the imputation are different
    in</st> *<st c="46392">Figures 1.6 and 1.7</st>*<st c="46411">. In</st> *<st c="46416">Figure
    1</st>**<st c="46424">.6</st>*<st c="46426">, we carry the last value forward,
    hence the height is lower.</st> <st c="46488">In</st> *<st c="46491">Figure 1</st>**<st
    c="46499">.7</st>*<st c="46501">, we carry the next value backward, hence the
    height</st> <st c="46554">is higher.</st>
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="46325">用于插补的值的高度在</st> *<st c="46392">图1.6和1.7</st>* <st c="46411">中不同。在</st>
    *<st c="46416">图1</st>**<st c="46424">.6</st>* <st c="46426">中，我们向前携带最后一个值，因此高度较低。</st>
    <st c="46488">在</st> *<st c="46491">图1</st>**<st c="46499">.7</st>* <st c="46501">中，我们向后携带下一个值，因此高度</st>
    <st c="46554">较高。</st>
- en: <st c="46564">We’ve now obtained complete</st> <st c="46592">datasets that we
    can use for time series analysis</st> <st c="46643">and modeling.</st>
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="46564">我们现在已经获得了完整的</st> <st c="46592">数据集，我们可以使用它进行时间序列分析和建模。</st>
- en: <st c="46656">How it works...</st>
  id: totrans-422
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="46656">它是如何工作的...</st>
- en: '`<st c="46672">pandas</st>` `<st c="46679">ffill()</st>` <st c="46687">takes
    the last seen value in any temporal gap in a time series and propagates it forward
    to the next observed value.</st> <st c="46805">Hence, in</st> *<st c="46815">Figure
    1</st>**<st c="46823">.6</st>* <st c="46825">we see the dotted overlay corresponding
    to the imputation values at the height of the last</st> <st c="46917">seen observation.</st>'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="46672">pandas</st>` `<st c="46679">ffill()</st>` <st c="46687">在时间序列中的任何时间间隔中取最后一个观测到的值，并将其传播到下一个观测值。</st>
    <st c="46805">因此，在</st> *<st c="46815">图1</st>**<st c="46823">.6</st>* <st c="46825">中，我们看到对应于最后一个观测高度缺失值的高度虚线覆盖。</st>'
- en: '`<st c="46934">pandas</st>` `<st c="46941">bfill()</st>` <st c="46949">takes
    the next valid value in any temporal gap in a time series and propagates it backward
    to the previously observed value.</st> <st c="47075">Hence, in</st> *<st c="47085">Figure
    1</st>**<st c="47093">.7</st>* <st c="47095">we see the dotted overlay corresponding
    to the imputation values at the height of the next observation in</st> <st c="47202">the
    gap.</st>'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="46934">pandas</st>` `<st c="46941">bfill()</st>` <st c="46949">在时间序列中的任何时间间隔中取下一个有效值，并将其传播到之前观测到的值。</st>
    <st c="47075">因此，在</st> *<st c="47085">图1</st>**<st c="47093">.7</st>* <st c="47095">中，我们看到对应于下一个观测高度缺失值的高度虚线覆盖。</st>'
- en: <st c="47210">By default,</st> `<st c="47223">ffill()</st>` <st c="47230">and</st>
    `<st c="47235">bfill()</st>` <st c="47242">will impute all values between valid
    observations.</st> <st c="47294">We can restrict the imputation to a maximum number
    of data points in any interval by setting a limit, using the</st> `<st c="47406">limit</st>`
    <st c="47411">parameter in both methods.</st> <st c="47439">For example,</st>
    `<st c="47452">ffill(limit=10)</st>` <st c="47467">will only replace</st> <st
    c="47485">the first 10 data points in</st> <st c="47514">any gap.</st>
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="47210">默认情况下，</st> `<st c="47223">ffill()</st>` <st c="47230">和</st>
    `<st c="47235">bfill()</st>` <st c="47242">将插补所有有效观测值之间的值。</st> <st c="47294">我们可以通过设置限制，使用两种方法中的`<st
    c="47406">limit</st>` `<st c="47411">参数`来限制插补到任何间隔中的最大数据点数。</st> <st c="47439">例如，</st>
    `<st c="47452">ffill(limit=10)</st>` <st c="47467">将只替换任何间隔中的前10个数据点。</st>
- en: <st c="47522">Carrying out interpolation</st>
  id: totrans-426
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="47522">执行插值</st>
- en: <st c="47549">We can impute missing</st> <st c="47571">data in time series by
    using interpolation between two non-missing data points.</st> <st c="47652">Interpolation
    is the estimation of one or more values in a range by means of a function.</st>
    <st c="47741">In linear interpolation, we fit a linear function between the last
    observed value and the next valid point.</st> <st c="47849">In spline interpolation,
    we fit a low-degree polynomial between the last and next observed values.</st>
    <st c="47948">The idea of using interpolation is to obtain better estimates of
    the</st> <st c="48017">missing data.</st>
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="47549">我们可以通过在两个非缺失数据点之间进行插值来对时间序列中的缺失数据进行插补。</st> <st c="47571">插值是通过函数估计一个或多个值的方法。</st>
    <st c="47652">在线性插值中，我们在最后一个观测值和下一个有效点之间拟合一个线性函数。</st> <st c="47741">在样条插值中，我们在最后一个和下一个观测值之间拟合一个低阶多项式。</st>
    <st c="47849">使用插值的想法是获得对缺失数据的更好估计。</st> <st c="48017">的缺失数据。</st>
- en: <st c="48030">In this recipe, we’ll carry out linear and spline interpolation
    in a</st> <st c="48100">time series.</st>
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="48030">在这个菜谱中，我们将在一个时间序列中执行线性插值和样条插值。</st>
- en: <st c="48112">How to do it...</st>
  id: totrans-429
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="48112">如何做...</st>
- en: <st c="48128">Let’s begin by importing the required libraries and time</st>
    <st c="48186">series dataset.</st>
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="48128">让我们首先导入所需的库和时间序列数据集。</st> <st c="48186">系列数据集。</st>
- en: <st c="48201">Let’s import</st> `<st c="48215">pandas</st>` <st c="48221">and</st>
    `<st c="48226">matplotlib</st>`<st c="48236">:</st>
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="48201">让我们导入</st> `<st c="48215">pandas</st>` <st c="48221">和</st> `<st
    c="48226">matplotlib</st>`<st c="48236">:</st>
- en: '[PRE100]'
  id: totrans-432
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: <st c="48290">Let’s load the time series data described in the</st> *<st c="48340">Technical</st>*
    *<st c="48350">requirements</st>* <st c="48362">section:</st>
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="48290">让我们加载在*<st c="48340">技术</st>* *<st c="48350">要求</st>* <st c="48362">部分中描述的时间序列数据：</st>
- en: '[PRE101]'
  id: totrans-434
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: <st c="48451">Note</st>
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="48451">注意</st>
- en: <st c="48456">You can plot the time series to find data gaps as we did in</st>
    *<st c="48517">step 3</st>* <st c="48523">of the</st> *<st c="48531">Implementing
    forward and backward</st>* *<st c="48565">fill</st>* <st c="48569">recipe.</st>
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="48456">您可以通过绘制时间序列来查找数据缺口，就像我们在</st> *<st c="48517">步骤 3</st>* <st c="48523">中的
    *<st c="48531">实现向前和向后填充</st>* *<st c="48565">食谱</st>中所做的那样。</st>
- en: <st c="48577">Let’s impute the missing</st> <st c="48602">data by</st> <st c="48611">linear
    interpolation:</st>
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="48577">让我们通过</st> <st c="48602">线性插值来插补缺失数据：</st>
- en: '[PRE102]'
  id: totrans-438
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: <st c="48677">Note</st>
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="48677">注意</st>
- en: <st c="48682">If the time intervals between rows are not uniform then the</st>
    `<st c="48743">method</st>` <st c="48749">should be set to</st> `<st c="48767">time</st>`
    <st c="48771">to achieve a</st> <st c="48785">linear fit.</st>
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="48682">如果行之间的时间间隔不均匀，则应将</st> `<st c="48743">方法</st>` <st c="48749">设置为</st>
    `<st c="48767">时间</st>` <st c="48771">以实现线性拟合。</st>
- en: <st c="48796">You can verify the absence of missing data by</st> <st c="48843">executing</st>
    `<st c="48853">df_imputed.isnull().sum()</st>`<st c="48878">.</st>
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="48796">您可以通过</st> <st c="48843">执行</st> `<st c="48853">df_imputed.isnull().sum()</st>`<st
    c="48878">来验证缺失数据的缺失。</st>
- en: <st c="48879">Let’s now plot the complete dataset and overlay as a dotted line
    the values used for</st> <st c="48965">the imputation:</st>
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="48879">现在让我们绘制完整的数据集，并将用于</st> <st c="48965">插补的值以虚线形式叠加：</st>
- en: '[PRE103]'
  id: totrans-443
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: <st c="49210">The previous code returns the following plot, where we see the
    values used to replace</st> `<st c="49297">nan</st>` <st c="49300">as dotted lines
    in between the continuous line of the</st> <st c="49355">time series:</st>
  id: totrans-444
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="49210">前面的代码返回以下图表，其中我们看到了用于替换</st> `<st c="49297">nan</st>` <st c="49300">的值，并以虚线形式绘制在时间序列的连续线之间：</st>
- en: '![Figure 1.8 – Time series data where missing values were replaced by linear
    interpolation between the last and next valid data points (dotted line)](img/B22396_01_08.jpg)'
  id: totrans-445
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.8 – 时间序列数据，其中缺失值通过在最后和下一个有效数据点之间进行线性插值来替换（虚线）](img/B22396_01_08.jpg)'
- en: <st c="49462">Figure 1.8 – Time series data where missing values were replaced
    by linear interpolation between the last and next valid data points (dotted line)</st>
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="49462">图 1.8 – 时间序列数据，其中缺失值通过在最后和下一个有效数据点之间进行线性插值来替换（虚线）</st>
- en: <st c="49608">Alternatively, we can impute</st> <st c="49637">missing data by
    doing spline interpolation.</st> <st c="49682">We’ll use a polynomial of the</st>
    <st c="49712">second degree:</st>
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="49608">或者，我们可以通过进行样条插值来插补缺失数据。</st> <st c="49637">我们将使用二次多项式：</st>
- en: '[PRE104]'
  id: totrans-448
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: <st c="49780">If we plot the imputed dataset and overlay the imputation values
    as we did in</st> *<st c="49859">step 4</st>*<st c="49865">, we’ll see the</st>
    <st c="49881">following plot:</st>
  id: totrans-449
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="49780">如果我们绘制插补数据集，并将插补值叠加，就像我们在</st> *<st c="49859">步骤 4</st>*<st c="49865">中所做的那样，我们将看到以下图表：</st>
- en: '![Figure 1.9 – Time series data where missing values were replaced by fitting
    a second-degree polynomial between the last and next valid data points (dotted
    line)](img/B22396_01_09.jpg)'
  id: totrans-450
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.9 – 时间序列数据，其中缺失值通过在最后和下一个有效数据点之间拟合二次多项式来替换（虚线）](img/B22396_01_09.jpg)'
- en: <st c="49997">Figure 1.9 – Time series data where missing values were replaced
    by fitting a second-degree polynomial between the last and next valid data points
    (dotted line)</st>
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="49997">图 1.9 – 时间序列数据，其中缺失值通过在最后和下一个有效数据点之间拟合二次多项式来替换（虚线）</st>
- en: <st c="50157">Note</st>
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="50157">注意</st>
- en: <st c="50162">Change the degree of the polynomial used in the interpolation
    to see how the replacement</st> <st c="50252">values vary.</st>
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="50162">更改插值中使用的多项式的次数，以查看替换值如何变化。</st>
- en: <st c="50264">We’ve now obtained complete</st> <st c="50292">datasets that we
    can use for analysis</st> <st c="50331">and modeling.</st>
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="50264">我们现在已经获得了完整的</st> <st c="50292">数据集，我们可以用于分析和建模。</st>
- en: <st c="50344">How it works...</st>
  id: totrans-455
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="50344">它是如何工作的...</st>
- en: '`<st c="50360">pandas</st>` `<st c="50367">interpolate()</st>` <st c="50381">fills
    missing values in a range by using an interpolation method.</st> <st c="50448">When
    we set the</st> `<st c="50464">method</st>` <st c="50470">to</st> `<st c="50474">linear</st>`<st
    c="50480">,</st> `<st c="50482">interpolate()</st>` <st c="50495">treats all data
    points as equidistant and fits a line between the last and next valid points in
    an interval with</st> <st c="50609">missing data.</st>'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="50360">pandas</st>` `<st c="50367">interpolate()</st>` <st c="50381">通过使用插值方法填充范围内的缺失值。</st>
    <st c="50448">当我们设置</st> `<st c="50464">method</st>` <st c="50470">为</st> `<st
    c="50474">linear</st>`<st c="50480">时，</st> `<st c="50482">interpolate()</st>`
    <st c="50495">将所有数据点视为等距，并在存在缺失数据的区间内使用线性拟合连接最后和下一个有效点。</st> <st c="50609"></st>'
- en: <st c="50622">Note</st>
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="50622">注意</st>
- en: <st c="50627">If you want to perform linear interpolation, but your data points
    are not equally distanced, set</st> `<st c="50725">method</st>` <st c="50731">to</st>
    `<st c="50735">time</st>`<st c="50739">.</st>
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="50627">如果你想要执行线性插值，但你的数据点不是等距的，将</st> `<st c="50725">method</st>` <st
    c="50731">设置为</st> `<st c="50735">time</st>`<st c="50739">。</st>
- en: <st c="50740">We then performed spline interpolation with a second-degree polynomial
    by setting</st> `<st c="50823">method</st>` <st c="50829">to</st> `<st c="50833">spline</st>`
    <st c="50839">and</st> `<st c="50844">order</st>` <st c="50849">to</st> `<st c="50853">2</st>`<st
    c="50854">.</st>
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="50740">然后我们通过将</st> `<st c="50823">method</st>` <st c="50829">设置为</st>
    `<st c="50833">spline</st>` <st c="50839">和</st> `<st c="50844">order</st>` <st
    c="50849">设置为</st> `<st c="50853">2</st>`<st c="50854">来执行二次多项式样条插值。</st>
- en: '`<st c="50855">pandas</st>` `<st c="50862">interpolate()</st>` <st c="50876">uses</st>
    `<st c="50882">scipy.interpolate.interp1d</st>` <st c="50908">and</st> `<st c="50913">scipy.interpolate.UnivariateSpline</st>`
    <st c="50947">under the hood, and can therefore implement other interpolation</st>
    <st c="51011">methods.</st> <st c="51021">Check out pandas</st> <st c="51037">documentation
    for more details</st> <st c="51069">at</st> [<st c="51072">https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.interpolate.html</st>](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.interpolate.html)<st
    c="51164">.</st>'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="50855">pandas</st>` `<st c="50862">interpolate()</st>` <st c="50876">使用</st>
    `<st c="50882">scipy.interpolate.interp1d</st>` <st c="50908">和</st> `<st c="50913">scipy.interpolate.UnivariateSpline</st>`
    <st c="50947">在内部实现，因此可以实现其他插值</st> <st c="51011">方法。</st> <st c="51021">有关更多详细信息，请查看pandas</st>
    <st c="51037">文档</st> <st c="51069">，网址为</st> [<st c="51072">https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.interpolate.html</st>](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.interpolate.html)<st
    c="51164">。</st>'
- en: <st c="51165">See also</st>
  id: totrans-461
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="51165">另请参阅</st>
- en: <st c="51174">While interpolation aims to get better estimates of the missing
    data compared to forward and backward fill, these estimates may still not be accurate
    if the times series show strong trend and seasonality.</st> <st c="51380">To obtain
    better estimates of the missing data in these types of time series, check out
    time series decomposition</st> <st c="51493">followed by interpolation in the</st>
    *<st c="51527">Feature Engineering for Time Series Course</st>* <st c="51569">at</st>
    [<st c="51573">https://www.trainindata.com/p/feature-engineering-for-forecasting</st>](https://www.trainindata.com/p/feature-engineering-for-forecasting)<st
    c="51638">.</st>
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="51174">虽然插值旨在比前向填充和后向填充获得更好的缺失数据估计，但如果时间序列显示出强烈的趋势和季节性，这些估计可能仍然不准确。</st>
    <st c="51380">为了获得这些类型时间序列中缺失数据的更好估计，请查看在*《<st c="51527">时间序列特征工程课程</st>》* <st
    c="51569">中跟随时间序列分解后插值的</st> [<st c="51573">https://www.trainindata.com/p/feature-engineering-for-forecasting</st>](https://www.trainindata.com/p/feature-engineering-for-forecasting)<st
    c="51638">。</st>
- en: <st c="51639">Performing multivariate imputation by chained equations</st>
  id: totrans-463
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="51639">通过链式方程执行多元插补</st>
- en: <st c="51695">Multivariate imputat</st><st c="51716">ion</st> <st c="51720">methods,
    as opposed</st> <st c="51740">to univariate imputation, use multiple variables
    to estimate the missing values.</st> **<st c="51822">Multivariate Imputation by
    Chained Equations</st>** <st c="51866">(</st>**<st c="51868">MICE</st>**<st c="51872">)
    models each variable with missing</st> <st c="51908">values as a function of the
    remaining variables in the dataset.</st> <st c="51973">The output of that function
    is used to replace</st> <st c="52020">missing data.</st>
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="51695">多元插补方法，与单变量插补相反，使用多个变量来估计缺失值。</st> **<st c="51822">链式方程多元插补</st>**
    <st c="51866">(**<st c="51868">MICE</st>**) 将数据集中每个具有缺失值的变量建模为剩余变量的函数。</st> <st
    c="51973">该函数的输出用于替换缺失数据。</st>
- en: <st c="52033">MICE involves the</st> <st c="52052">following steps:</st>
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="52033">MICE包括以下步骤：</st>
- en: <st c="52068">First, it performs a simple univariate imputation to every variable
    with missing data.</st> <st c="52156">For example,</st> <st c="52169">median imputation.</st>
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="52068">首先，它对每个有缺失数据的变量执行简单的单变量插补。</st> <st c="52156">例如，</st> <st c="52169">中位数插补。</st>
- en: <st c="52187">Next, it selects one specific variable, say,</st> `<st c="52233">var_1</st>`<st
    c="52238">, and sets the missing values back</st> <st c="52273">to missing.</st>
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="52187">接下来，它选择一个特定的变量，比如，</st> `<st c="52233">var_1</st>`<st c="52238">，并将缺失值重新设置为缺失。</st>
- en: <st c="52284">It trains a model to predict</st> `<st c="52314">var_1</st>` <st
    c="52319">using the other variables as</st> <st c="52349">input features.</st>
  id: totrans-468
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="52284">它训练一个模型来预测</st> `<st c="52314">var_1</st>` <st c="52319">，使用其他变量作为</st>
    <st c="52349">输入特征。</st>
- en: <st c="52364">Finally, it replaces the missing values of</st> `<st c="52408">var_1</st>`
    <st c="52413">with the output of</st> <st c="52433">the model.</st>
  id: totrans-469
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="52364">最后，它用模型的输出替换</st> `<st c="52408">var_1</st>` <st c="52413">的缺失值。</st>
- en: <st c="52443">MICE repeats</st> *<st c="52457">steps 2</st>* <st c="52464">to</st>
    *<st c="52468">4</st>* <st c="52469">for each of the</st> <st c="52486">remaining
    variables.</st>
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="52443">MICE重复</st> *<st c="52457">步骤2</st>* <st c="52464">到</st> *<st
    c="52468">4</st>* <st c="52469">，对于剩余的每个变量。</st>
- en: <st c="52506">An imputation cycle</st> <st c="52526">concludes once all the
    variables</st> <st c="52559">have been modeled.</st> <st c="52579">MICE carries
    out multiple imputation cycles, typically 10\.</st> <st c="52638">That is, we
    repeat</st> *<st c="52657">steps 2</st>* <st c="52664">to</st> *<st c="52668">4</st>*
    <st c="52669">for each variable 10 times.</st> <st c="52698">The idea is th</st><st
    c="52712">at by the end of the cycles, we should have found the best possible
    estimates of the missing data for</st> <st c="52815">each variable.</st>
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="52506">一个插补周期</st> <st c="52526">一旦所有变量都被建模就结束。</st> <st c="52559">MICE执行多个插补周期，通常是10个。</st>
    <st c="52579">这意味着我们重复</st> *<st c="52657">步骤2</st>* <st c="52664">到</st> *<st
    c="52668">4</st>* <st c="52669">，对于每个变量重复10次。</st> <st c="52698">想法是，到周期结束时，我们应该找到了每个变量的缺失数据的最佳可能估计。</st>
- en: <st c="52829">Note</st>
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="52829">注意</st>
- en: <st c="52834">Multivariate imputation</st> <st c="52858">can be a useful alternative
    to univariate imputation in situations where we don’t want to distort the variable
    distributions.</st> <st c="52985">Multivariate imputation is also useful when
    we are interested in having good estimates o</st><st c="53073">f the</st> <st
    c="53080">missing data.</st>
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="52834">多元插补</st> <st c="52858">可以在我们不想扭曲变量分布的情况下，作为单变量插补的有用替代方案。</st>
    <st c="52985">当我们对获得缺失数据的良好估计感兴趣时，多元插补也非常有用。</st>
- en: <st c="53093">In th</st><st c="53099">is recipe, we will implement MICE</st>
    <st c="53134">using scikit-learn.</st>
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="53093">在这个配方中，我们将使用scikit-learn实现MICE。</st>
- en: <st c="53153">How to do it...</st>
  id: totrans-475
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="53153">如何做...</st>
- en: <st c="53169">To begin the recipe, let’s import the required libraries and load</st>
    <st c="53236">the data:</st>
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="53169">为了开始这个配方，让我们导入所需的库并加载数据：</st>
- en: <st c="53245">Let’s import the required Python libraries, classes,</st> <st
    c="53299">and functions:</st>
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="53245">让我们导入所需的Python库、类、</st> <st c="53299">和函数：</st>
- en: '[PRE105]'
  id: totrans-478
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: <st c="53590">Let’s load some numerical</st> <st c="53616">variables from the
    dataset</st> <st c="53643">described in the</st> *<st c="53661">Technical</st>*
    *<st c="53671">requirements</st>* <st c="53683">section:</st>
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="53590">让我们从描述在</st> *<st c="53661">技术</st> * *<st c="53671">要求</st> *
    <st c="53683">部分的</st>数据集中加载一些数值变量：</st>
- en: '[PRE106]'
  id: totrans-480
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: <st c="53821">Let’s divide the data into train and</st> <st c="53859">test sets:</st>
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="53821">让我们将数据分为训练集和</st> <st c="53859">测试集：</st>
- en: '[PRE107]'
  id: totrans-482
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: <st c="54001">Let’s create a MICE imputer using Bayes regression, specifying
    the number of iteration cycles and setting</st> `<st c="54108">random_state</st>`
    <st c="54120">for reproducibility:</st>
  id: totrans-483
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="54001">让我们使用贝叶斯回归创建一个MICE插补器，指定迭代周期数并设置</st> `<st c="54108">random_state</st>`
    <st c="54120">以实现可重复性：</st>
- en: '[PRE108]'
  id: totrans-484
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: <st c="54259">Note</st>
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="54259">注意</st>
- en: '`<st c="54264">IterativeImputer()</st>` <st c="54283">contains other useful
    arguments.</st> <st c="54317">For example, we can specify the first imputation
    strategy using the</st> `<st c="54385">initial_strategy</st>` <st c="54401">parameter.</st>
    <st c="54413">We can choose from the mean, median, mode, or arbitrary imputation.</st>
    <st c="54481">We can also specify how we want to cycle over the variables, either
    randomly or from the one with the fewest missing values to the one with</st> <st
    c="54621">the most.</st>'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="54264">IterativeImputer()</st>` <st c="54283">包含其他有用的参数。</st> <st c="54317">例如，我们可以使用</st>
    `<st c="54385">initial_strategy</st>` <st c="54401">参数指定第一个插补策略。</st> <st c="54413">我们可以从均值、中位数、众数或任意插补中进行选择。</st>
    <st c="54481">我们还可以指定我们想要如何遍历变量，是随机遍历还是从缺失值最少的变量遍历到缺失值最多的变量。</st>'
- en: <st c="54630">Let’s fit</st> `<st c="54641">IterativeImputer()</st>` <st c="54659">so
    that it trains</st> <st c="54677">the estimators</st> <st c="54692">to predict
    the missing values in</st> <st c="54726">each variable:</st>
  id: totrans-487
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="54630">让我们拟合</st> `<st c="54641">IterativeImputer()</st>` <st c="54659">，以便它训练</st>
    <st c="54677">估计器</st> <st c="54692">来预测每个变量中的缺失值：</st>
- en: '[PRE109]'
  id: totrans-488
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: <st c="54761">Note</st>
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="54761">注意</st>
- en: <st c="54766">We can use any regression model to estimate the missing data</st>
    <st c="54828">with</st> `<st c="54833">IterativeImputer()</st>`<st c="54851">.</st>
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="54766">我们可以使用任何回归模型来估计缺失数据</st> <st c="54828">，使用</st> `<st c="54833">IterativeImputer()</st>`<st
    c="54851">。</st>
- en: <st c="54852">Finally, let’s fill in the missing values in both the train and</st>
    <st c="54917">test sets:</st>
  id: totrans-491
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="54852">最后，让我们在训练集和</st> <st c="54917">测试集中填充缺失值：</st>
- en: '[PRE110]'
  id: totrans-492
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: <st c="55003">Note</st>
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="55003">注意</st>
- en: <st c="55008">To corroborate the lack of missing data, we can</st> <st c="55057">execute</st>
    `<st c="55065">X_train_t.isnull().sum()</st>`<st c="55089">.</st>
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="55008">为了证实缺失数据的缺乏，我们可以</st> <st c="55057">执行</st> `<st c="55065">X_train_t.isnull().sum()</st>`<st
    c="55089">。</st>
- en: <st c="55090">To wrap up the recipe, let’s impute the variables with a simple
    univariate imputation method and compare the effect on the</st> <st c="55214">variables’
    distribution.</st>
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="55090">为了总结这个方法，让我们使用简单的单变量插补方法来插补变量，并比较其对</st> <st c="55214">变量分布的影响。</st>
- en: <st c="55238">Let’s set up scikit-learn’s</st> `<st c="55267">SimpleImputer()</st>`
    <st c="55282">to perform mean imputation, and then transform</st> <st c="55330">the
    datasets:</st>
  id: totrans-496
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="55238">让我们设置scikit-learn的</st> `<st c="55267">SimpleImputer()</st>` <st
    c="55282">以执行均值插补，然后转换</st> <st c="55330">数据集：</st>
- en: '[PRE111]'
  id: totrans-497
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: <st c="55517">Let’s now make a histogram</st> <st c="55544">of the</st> `<st
    c="55552">A3</st>` <st c="55554">variable</st> <st c="55563">after MICE imputation,
    followed by a histogram of the same variable after</st> <st c="55638">mean imputation:</st>
  id: totrans-498
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="55517">现在让我们绘制</st> <st c="55544">变量</st> `<st c="55552">A3</st>` <st
    c="55554">在MICE插补后的直方图，然后是相同变量在</st> <st c="55638">均值插补后的直方图：</st>
- en: '[PRE112]'
  id: totrans-499
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: <st c="56070">In the following plot, we see that mean imputation distorts the
    variable distribution, with more observations toward the</st> <st c="56192">mean
    value:</st>
  id: totrans-500
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="56070">在下面的图中，我们可以看到均值插补扭曲了变量分布，更多的观测值趋向于</st> <st c="56192">平均值：</st>
- en: '![Figure 1.10 –  Histogram of variable A3 after mice imputation (top) or mean
    imputation (bottom), showing the distortion in the variable distribution caused
    by the latter](img/B22396_01_10.jpg)'
  id: totrans-501
  prefs: []
  type: TYPE_IMG
  zh: '![图1.10 – 变量A3在老鼠插补（顶部）或均值插补（底部）后的直方图，显示了后者导致的变量分布扭曲](img/B22396_01_10.jpg)'
- en: <st c="56285">Figure 1.10 – Histogram of variable A3 after mice imputation (top)
    or mean imputation (bottom), showing the distortion in the variable distribution
    caused by the latter</st>
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="56285">图1.10 – 变量A3在老鼠插补（顶部）或均值插补（底部）后的直方图，显示了后者导致的变量分布扭曲</st>
- en: <st c="56453">How it works...</st>
  id: totrans-503
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="56453">它是如何工作的...</st>
- en: <st c="56469">In this recipe, we performed</st> <st c="56498">multivariate imputation</st>
    <st c="56522">using</st> `<st c="56529">IterativeImputer()</st>` <st c="56547">from</st>
    `<st c="56553">scikit-learn</st>`<st c="56565">. When we fit the model,</st> `<st
    c="56590">IterativeImputer()</st>` <st c="56608">carried out the steps that we
    described in the introduction of the recipe.</st> <st c="56684">That is, it imputed
    all variables with the mean.</st> <st c="56733">Then it selected one variable
    and set its missing values back to missing.</st> <st c="56807">And finally, it
    fitted a Bayes regressor to estimate that variable based on the others.</st> <st
    c="56895">It repeated this procedure for each variable.</st> <st c="56941">That
    was one cycle of imputation.</st> <st c="56975">We set it to repeat this process
    10 times.</st> <st c="57018">By the end of this procedure,</st> `<st c="57048">IterativeImputer()</st>`
    <st c="57066">had one Bayes regressor trained to predict the values of each variable
    based on the other variables in the dataset.</st> <st c="57183">With</st> `<st
    c="57188">transform()</st>`<st c="57199">, it uses the predictions of these Bayes
    models to impute the</st> <st c="57261">missing d</st><st c="57270">ata.</st>
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们使用 `<st c="56529">IterativeImputer()</st>` 从 `<st c="56553">scikit-learn</st>`
    进行多元插补。当我们拟合模型时，`<st c="56590">IterativeImputer()</st>` 执行了我们在菜谱介绍中描述的步骤。也就是说，它使用均值对所有变量进行插补。然后它选择一个变量，将其缺失值重新设置为缺失。最后，它拟合一个贝叶斯回归器来根据其他变量估计该变量。它对每个变量重复此过程。这是插补的一个周期。我们将它设置为重复此过程10次。到这个过程的最后，`<st
    c="57048">IterativeImputer()</st>` 训练了一个贝叶斯回归器，用于根据数据集中的其他变量预测每个变量的值。使用 `<st c="57188">transform()</st>`，它使用这些贝叶斯模型的预测来插补缺失数据。
- en: '`<st c="57275">Iter</st><st c="57280">ativeImputer()</st>` <st c="57295">can
    only impute missing data in numerical variables based on numerical variables.</st>
    <st c="57378">If you want to use categorical variables as input, you need to encode
    them first.</st> <st c="57460">However, keep in mind</st> <st c="57481">that it
    will only carry</st> <st c="57506">out regression.</st> <st c="57522">Hence it
    is</st> <st c="57534">not suitable to estimate missing data in discrete or</st>
    <st c="57587">categorical variables.</st>'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="57275">Iter</st><st c="57280">ativeImputer()</st>` 只能基于数值变量对数值变量中的缺失数据进行插补。如果你想使用分类变量作为输入，你需要先对它们进行编码。然而，请注意，它只会执行回归。因此，它不适合估计离散或分类变量中的缺失数据。'
- en: <st c="57609">See also</st>
  id: totrans-506
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: <st c="57618">To learn more about MICE, take a look at the</st> <st c="57664">following
    resources:</st>
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于MICE的信息，请查看以下资源：
- en: <st c="57684">A multivariate technique for multiplying imputing missing values
    using a sequence of regression</st> <st c="57781">models:</st> [<st c="57789">https://www.researchgate.net/publication/244959137</st>](https://www.researchgate.net/publication/244959137_A_Multivariate_Technique_for_Multiply_Imputing_Missing_Values_Using_a_Sequence_of_Regression_Models)
  id: totrans-508
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用一系列回归模型进行多重插补缺失值的多元技术：[https://www.researchgate.net/publication/244959137](https://www.researchgate.net/publication/244959137_A_Multivariate_Technique_for_Multiply_Imputing_Missing_Values_Using_a_Sequence_of_Regression_Models)
- en: '*<st c="57839">Multiple Imputation by Chained Equations: W</st><st c="57883">hat
    is it and how does it</st>* *<st c="57910">work?</st>*<st c="57915">:</st> [<st
    c="57918">https://www.jstatsoft.org/article/download/v045i03/550</st>](https://www.jstatsoft.org/article/download/v045i03/550)'
  id: totrans-509
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*<st c="57839">链式方程多重插补：是什么以及它是如何工作的？*<st c="57915">：</st>[https://www.jstatsoft.org/article/download/v045i03/550](https://www.jstatsoft.org/article/download/v045i03/550)'
- en: <st c="57972">Estimating missing data with nearest neighbors</st>
  id: totrans-510
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用最近邻估计缺失数据
- en: <st c="58019">Imputation with</st> **<st c="58036">K-Nearest Neighbors</st>**
    <st c="58055">(</st>**<st c="58057">KNN</st>**<st c="58060">) involves estimating
    missing values</st> <st c="58097">in a dataset by considering</st> <st c="58125">the
    values of their nearest</st> <st c="58154">neighbors, where similarity between
    data points is determined based on a distance metric, such as the Euclidean distance.</st>
    <st c="58276">It assigns the missing value the average of the nearest neighbors’
    values, weighted by</st> <st c="58363">their distance.</st>
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="58019">使用</st> **<st c="58036">K-Nearest Neighbors</st>** <st c="58055">(</st>**<st
    c="58057">KNN</st>**<st c="58060">) 进行缺失值填充涉及通过考虑</st> <st c="58097">其最近邻的值来估计数据集中的缺失值，其中数据点之间的相似性基于距离度量，例如欧几里得距离。</st>
    <st c="58276">它将缺失值分配给最近邻值的平均值，并按</st> <st c="58363">它们的距离进行加权。</st>
- en: <st c="58378">Consider the following data set containing 4 variables (columns)
    and 11 observations (rows).</st> <st c="58472">We want to impute the dark value
    in the fifth row of the second variable.</st> <st c="58546">First, we find the
    row’s k-nearest neighbors, where</st> *<st c="58598">k=3</st>* <st c="58601">in
    our example, and they are highlighted by the rectangular boxes (middle panel).</st>
    <st c="58684">Next, we take the average value shown by the closest neighbors for</st>
    <st c="58751">variable 2.</st>
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="58378">考虑以下包含 4 个变量（列）和 11 个观测值（行）的数据集。</st> <st c="58472">我们想要填充第二个变量第五行的暗值。</st>
    <st c="58546">首先，我们找到该行的 k 个最近邻，其中</st> *<st c="58598">k=3</st>* <st c="58601">在我们的例子中，并且它们通过矩形框（中间面板）突出显示。</st>
    <st c="58684">接下来，我们取最接近的邻居显示的平均值，用于</st> <st c="58751">变量 2。</st>
- en: '![Figure 1.11 – Diagram showing a value to impute (dark box), the three closest
    rows to the value to impute (square boxes), and the values considered to take
    the average for the imputation](img/B22396_01_11.jpg)'
  id: totrans-513
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.11 – 显示要填充的值（深色框）、要填充的值的三条最近行（正方形框）以及用于填充的平均值考虑的值的图](img/B22396_01_11.jpg)'
- en: <st c="58870">Figure 1.11 – Diagram showing a value to impute (dark box), the
    three closest rows to the value to impute (square boxes), and the values considered
    to take the average for the imputation</st>
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="58870">图 1.11 – 显示要填充的值（深色框）、要填充的值的三条最近行（正方形框）以及用于填充的平均值考虑的值的图</st>
- en: <st c="59056">The value for the imputation</st> <st c="59085">is given by (value1
    × w1 + value2 × w2 + value3 × w3) / 3, where w1, w2, and w3 are proportional to
    the distance</st> <st c="59198">of the neighbo</st><st c="59213">r to the data</st>
    <st c="59228">to impute.</st>
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="59056">缺失值填充的值由 (value1 × w1 + value2 × w2 + value3 × w3) / 3 给出，其中 w1、w2
    和 w3 与数据到要填充的数据点的距离成比例</st> <st c="59198">的邻居距离</st><st c="59213">到要填充的数据</st>
    <st c="59228">点的距离</st>
- en: <st c="59238">In this recipe, we will perform KNN imputation</st> <st c="59286">using
    scikit-learn.</st>
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="59238">在这个菜谱中，我们将使用 scikit-learn 执行 KNN 缺失值填充</st> <st c="59286">。</st>
- en: <st c="59305">How to do it...</st>
  id: totrans-517
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="59305">如何做到这一点...</st>
- en: <st c="59321">To proceed with the recipe, let’s import the required libraries
    and prepare</st> <st c="59398">the data:</st>
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="59321">为了进行菜谱，让我们导入所需的库并准备</st> <st c="59398">数据：</st>
- en: <st c="59407">Let’s import the required libraries, classes,</st> <st c="59454">and
    functions:</st>
  id: totrans-519
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="59407">让我们导入所需的库、类、</st> <st c="59454">和函数：</st>
- en: '[PRE113]'
  id: totrans-520
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: <st c="59611">Let’s load the dataset described in the</st> *<st c="59652">Technical
    requirements</st>* <st c="59674">section (only some</st> <st c="59694">numerical
    variables):</st>
  id: totrans-521
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="59611">让我们加载在</st> *<st c="59652">技术要求</st>* <st c="59674">部分中描述的数据集（仅一些</st>
    <st c="59694">数值变量）：</st>
- en: '[PRE114]'
  id: totrans-522
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: <st c="59847">Let’s divide the data into train and</st> <st c="59885">test sets:</st>
  id: totrans-523
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="59847">让我们将数据分为训练集和</st> <st c="59885">测试集：</st>
- en: '[PRE115]'
  id: totrans-524
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: <st c="60026">Let’s set up the imputer</st> <st c="60051">to replace missing
    data</st> <st c="60075">with the weighted mean of its closest</st> <st c="60114">five
    neighbors:</st>
  id: totrans-525
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="60026">让我们设置缺失值填充器</st> <st c="60051">以用其最近五个邻居的加权平均值替换缺失数据</st> <st
    c="60075">：</st>
- en: '[PRE116]'
  id: totrans-526
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: <st c="60219">Note</st>
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="60219">注意</st>
- en: <st c="60224">The replacement values can be calculated as the uniform mean of
    the k-nearest neighbors, by setting</st> `<st c="60325">weights</st>` <st c="60332">to</st>
    `<st c="60336">uniform</st>` <st c="60343">or as the weighted average, as we do
    in the recipe.</st> <st c="60396">The weight is based on the distance of the neighbor
    to the observation to impute.</st> <st c="60478">The nearest neighbors carry</st>
    <st c="60506">more weight.</st>
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="60224">替换值可以计算为k近邻的均匀平均值，通过设置<st c="60325">权重</st> <st c="60332">为<st
    c="60336">均匀</st> <st c="60343">，或者像我们在食谱中做的那样，计算加权平均值。</st> <st c="60396">权重基于邻居到要插补的观测值的距离。</st>
    <st c="60478">最近邻的权重更大。</st>
- en: <st c="60518">Find the</st> <st c="60528">nearest neighbors:</st>
  id: totrans-529
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="60518">找到</st> <st c="60528">最近邻：</st>
- en: '[PRE117]'
  id: totrans-530
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: <st c="60567">Replace the missing values with the weighted mean of the values
    shown by</st> <st c="60641">the neighbors:</st>
  id: totrans-531
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="60567">用邻居显示的值的加权平均值替换缺失值：</st>
- en: '[PRE118]'
  id: totrans-532
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: <st c="60733">The result is a</st> <st c="60749">pandas DataFrame with the missing</st>
    <st c="60784">data replaced.</st>
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="60733">结果是包含缺失数据已被替换的<st c="60749">pandas DataFrame。</st>
- en: <st c="60798">How it works...</st>
  id: totrans-534
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="60798">它是如何工作的...</st>
- en: <st c="60814">In this recipe, we replaced</st> <st c="60842">missing data with
    the average</st> <st c="60872">value shown by each observation’s k-nearest neighbors.</st>
    <st c="60928">We set up</st> `<st c="60938">KNNImputer()</st>` <st c="60950">to
    find each observation’s five closest neighbors based on the Euclidean distance.</st>
    <st c="61034">The replacement values were estimated as the weighted average of
    the values shown by the five closest neighbors for the variable to impute.</st>
    <st c="61174">With</st> `<st c="61179">transform()</st>`<st c="61190">, the imputer
    calculated the replacement value and replaced the</st> <st c="61254">missing data.</st>
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们用每个观测值的k近邻的平均值替换了<st c="60814">缺失数据</st> <st c="60842">。<st c="60872"></st>
    <st c="60928">我们设置了</st> `<st c="60938">KNNImputer()</st>` <st c="60950">来根据欧几里得距离找到每个观测值的五个最近邻。</st>
    <st c="61034">替换值被估计为要插补变量的五个最近邻显示值的加权平均值。</st> <st c="61174">使用</st> `<st c="61179">transform()</st>`<st
    c="61190">，插补器计算了替换值并替换了</st> <st c="61254">缺失数据。</st>
