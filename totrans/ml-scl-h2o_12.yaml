- en: '*Chapter 9*: Production Scoring and the H2O MOJO'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第9章*：生产评分和H2O MOJO'
- en: We spent the entire previous section learning how to build world-class models
    against data at scale with H2O. In this chapter, we will learn how to deploy these
    models and make predictions from them. First, we will cover the background on
    putting models into production scoring systems. We will then learn how H2O makes
    this easy and flexible. At the center of this story is the H2O **MOJO** (short
    for **Model Object, Optimized**), a ready-to-deploy scoring artifact that you
    export from your model building environment. We will learn technically what a
    MOJO is and how to deploy it. We will then code a simple batch file scoring program
    and embed a MOJO in it. We will finish with some final notes on the MOJO. Altogether,
    in this chapter, you will develop the knowledge to deploy H2O models in diverse
    ways and so begin achieving value from live predictions.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前一节中学习了如何使用H2O在规模数据上构建世界级模型。在本章中，我们将学习如何部署这些模型并从中进行预测。首先，我们将介绍将模型投入生产评分系统的背景。然后，我们将学习H2O如何使这一过程变得简单和灵活。这个故事的核心是H2O
    **MOJO**（代表**Model Object, Optimized**），这是一个准备就绪的可部署评分工件，您可以从模型构建环境中导出它。我们将从技术上了解什么是MOJO以及如何部署它。然后我们将编写一个简单的批文件评分程序并在其中嵌入一个MOJO。最后，我们将对MOJO进行一些总结。总之，在本章中，您将获得部署H2O模型的不同方式的知识，并开始从实时预测中获得价值。
- en: 'These are the main topics we will cover in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们将在本章中涵盖的主要主题：
- en: Relating the model building context to the scoring context for H2O models
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将H2O模型的建模上下文与评分上下文相关联
- en: Recognizing the diversity of target production systems for H2O models
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认识到H2O模型的目标生产系统的多样性
- en: Examining the technical design of the H2O deployable artifact, the H2O MOJO
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查H2O可部署工件的技术设计，即H2O MOJO
- en: Writing your own H2O MOJO batch file scorer to show how to embed MOJOs in your
    own software
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写自己的H2O MOJO批文件评分器以展示如何在您的软件中嵌入MOJOs
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In this chapter, you will need a Java SE 8 or greater environment. A Java IDE
    such as Eclipse is optional but useful. You will get a MOJO, a dataset to score
    and the Java code for the batch file scorer program in the following GitHub repository:
    [https://github.com/PacktPublishing/Machine-Learning-at-Scale-with-H2O/tree/main/chapt9](https://github.com/PacktPublishing/Machine-Learning-at-Scale-with-H2O/tree/main/chapt9).
    These artifacts were generated from the model built in [*Chapter 8*](B16721_08_Final_SK_ePub.xhtml#_idTextAnchor137),
    *Putting It All Together*.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您需要一个Java SE 8或更高版本的环境。Java IDE，如Eclipse，是可选的但很有用。您将在以下GitHub仓库中获取一个MOJO、一个评分数据集以及批文件评分程序的Java代码：[https://github.com/PacktPublishing/Machine-Learning-at-Scale-with-H2O/tree/main/chapt9](https://github.com/PacktPublishing/Machine-Learning-at-Scale-with-H2O/tree/main/chapt9)。这些工件是从*第8章*中构建的模型生成的，*整合一切*。
- en: Note that we are done with model building at this point, so you do not need
    a model building environment pointing to a running H2O cluster.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，到目前为止我们已经完成了模型构建，因此您不需要一个指向运行中的H2O集群的模型构建环境。
- en: The model building and model scoring contexts
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型构建和模型评分上下文
- en: In *Section 2*, *Building State-of-the-Art Models on Large Data Volumes Using
    H2O*, we spent a great amount of focus on building world-class models at scale
    with H2O. Building highly accurate and trusted models against massive datasets
    can potentially generate millions of dollars for a business, save lives, and define
    new product areas, but only when the models are deployed to production systems
    where predictions are made and acted upon.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第2节*，*使用H2O在大数据量上构建世界级模型*中，我们投入了大量精力使用H2O在规模上构建世界级模型。针对大规模数据集构建高度准确和可信的模型可能为一家企业带来数百万美元的收入，挽救生命，并定义新产品领域，但这只有在模型部署到生产系统，在那里进行预测并采取行动的情况下才可能。
- en: This last step of deploying and predicting (or scoring) on a production system
    can often be time-consuming, problematic, and risky for reasons discussed shortly.
    H2O makes this transition from a built (trained) model to a deployed model easy.
    It also provides a wide range of flexibility in regard to where scoring is done
    (device, web application, database, microservice endpoint, or Kafka queue) and
    to the velocity of data (real-time, batch, and streaming). And, whatever the production
    context, the H2O deployed model scores lightning fast.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 最后这一步，在生产系统中部署和预测（或评分），通常可能耗时、有风险，原因将在下面简要讨论。H2O使从构建（训练）模型到部署模型这一过渡变得简单。它还提供了广泛的灵活性，关于评分的位置（设备、Web应用程序、数据库、微服务端点或Kafka队列）以及数据的速度（实时、批量、流式）。而且，无论生产环境如何，H2O部署的模型评分都非常快。
- en: At the center of this ease, flexibility, and low-latency production scoring
    is the H2O MOJO. An H2O MOJO is a ready-to-deploy scoring artifact that is generated
    by a simple export command at the end of your model-building code. H2O MOJOs are
    similar regardless of the model-building algorithm that generated them. As a result,
    all H2O models are deployed similarly. Before diving into the MOJO and learning
    how to deploy it, let's first take a look in general at the process of moving
    from model training to model scoring.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个易于、灵活和低延迟的生产评分的中心是H2O MOJO。H2O MOJO是一个准备就绪的评分工件，它是在模型构建代码的末尾通过简单的导出命令生成的。无论生成它们的模型构建算法是什么，H2O
    MOJO都是相似的。因此，所有H2O模型都是以相同的方式部署的。在深入探讨MOJO并学习如何部署它之前，让我们首先一般地看看从模型训练到模型评分的过程。
- en: Model training to production model scoring
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模型训练到生产模型评分
- en: We'll first take a general view of how models transition from model training
    to production scoring and then see how this is done with H2O.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将一般地了解模型如何从模型训练过渡到生产评分，然后看看H2O是如何做到这一点的。
- en: Generic training-to-scoring pipeline
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通用训练到评分流程
- en: 'A generic pipeline of a trained to a deployed model can be represented as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 训练到部署模型的通用流程可以表示如下：
- en: '![Figure 9.1 – Generalized pipeline from model training to scoring'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 9.1 – Generalized pipeline from model training to scoring'
- en: '](img/Figure_9.1_B16721.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_9.1_B16721.jpg]'
- en: Figure 9.1 – Generalized pipeline from model training to scoring
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 – 从模型训练到评分的通用流程
- en: Do note that this pipeline is more formally represented and elaborated by the
    practice called **Machine Learning Operations** (**MLOps**), which involves a
    larger area of concern, but for the focus of deploying a model to production,
    the representation here should work for us.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个流程更正式地由称为**机器学习操作**（**MLOps**）的实践来表示和阐述，它涉及更广泛的关注领域，但就部署模型到生产而言，这里的表示应该对我们适用。
- en: 'Each step is summarized as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 每个步骤总结如下：
- en: '`if-else` logic in software code. This is time-consuming because the logic
    of the trained model must be accurately communicated by the data scientist to
    the software developer, who must implement the logic correctly and then have it
    tested thoroughly to validate its accuracy. This is also error-prone and, therefore,
    risky, as well as time-consuming.'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 软件代码中的`if-else`逻辑。这是因为训练模型的逻辑必须由数据科学家准确传达给软件开发者，软件开发者必须正确实现逻辑，然后对其进行彻底测试以验证其准确性。这也很容易出错，因此具有风险，而且耗时。
- en: The best-case scenario is when a conversion tool translates the trained model
    into a deployable artifact. This can be either a format (for example, XML for
    PMML, PFA, or ONNX) that declares the logic for a production system that is ready
    to compute against the declarative constructs, or it can be a runnable software
    artifact (for example, a Python wheel or Java JAR file) that can be embedded into
    a software program or framework.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳情况是转换工具将训练模型转换为可部署的工件。这可以是一个格式（例如，用于PMML、PFA或ONNX的XML），它声明了准备就绪的生产系统的逻辑，该系统可以针对声明性结构进行计算，或者它可以是可运行的软件工件（例如，Python
    wheel或Java JAR文件），它可以嵌入到软件程序或框架中。
- en: '**Deployable model**: The converted model is deployed to a production system.
    This written code or converted artifact is integrated into a software application
    or framework that, at some point, inputs data into the scoring logic it holds
    and outputs the scoring result. For example, a customer''s data goes in and the
    probability of churn comes out.'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**可部署模型**：转换后的模型被部署到生产系统中。这段代码或转换后的工件被集成到软件应用程序或框架中，在某个时刻，将数据输入到它持有的评分逻辑中，并输出评分结果。例如，客户的数据输入，然后输出客户流失的概率。'
- en: Model deployment should be performed in TEST and **production** (**PROD**) environments,
    with deployment and promotion done through a formal governance process using a
    **continuous integration and continuous deployment** (**CI/CD**) pipeline, as
    with the deployment of software in general. Deployable artifacts that are recognizable
    and standardized across all models built (for example, among different ML algorithms)
    are easier to automate during deployment than those that are not.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 模型部署应在**测试**和**生产**（**PROD**）环境中进行，通过使用**持续集成和持续部署**（**CI/CD**）管道进行正式的治理流程，就像一般软件的部署一样。在所有构建的模型（例如，不同的机器学习算法之间）中可识别和标准化的可部署工件，在部署过程中比不可识别的工件更容易自动化。
- en: '**Production system**: Scoring live in production. Production scoring needs
    can be diverse. Scoring may be needed, for example, against entire database tables
    in one batch, against each live ATM transaction sent over the network, inside
    a web application for every web page click of a customer, or on streams of sensor
    data sent from edge devices. Scoring may be on a device or on a large server in
    the cloud. Typically, the faster the score, the better (demands of less than 50
    microseconds per score or faster are not uncommon), and the smaller the scorer
    size and resource consumption footprint, the closer to the edge it can be deployed.'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**生产系统**：在生产环境中进行评分。评分需求可能多种多样。例如，可能需要批量对整个数据库表进行评分，对通过网络发送的每个实时ATM交易进行评分，在Web应用程序中对每个客户的网页点击进行评分，或者对从边缘设备发送的传感器数据流进行评分。评分可以在设备上进行，也可以在云中的大型服务器上进行。通常，评分越快越好（每评分少于50微秒或更快的需求并不罕见），评分器的大小和资源消耗越小，它就可以部署得越接近边缘。'
- en: '**Predictions**: Scoring the output. Models output predictions during scoring.
    Note that predictions need a business context and action to achieve purpose or
    value. For example, customers who are predicted to churn are given phone calls
    or special offers to help ensure they remain customers. Often, scoring outputs
    require not just predictions, but also explanations in the form of reason codes
    for those predictions. How did the model weigh each input to the scorer when generating
    the prediction for a particular customer? In other words, which factors were most
    important in a specific prediction. These decision weights are represented as
    reason codes and they can help personalize a phone call or special offer in the
    churn case.'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**预测**：评分输出。模型在评分过程中输出预测结果。请注意，预测需要业务背景和行动来实现目的或价值。例如，预测会流失的客户会接到电话或特别优惠，以确保他们继续成为客户。通常，评分输出不仅需要预测，还需要以原因代码形式提供对这些预测的解释。模型在为特定客户生成预测时是如何权衡评分器输入的？换句话说，哪些因素在特定预测中最为重要。这些决策权重以原因代码的形式表示，并有助于在流失案例中个性化电话或特别优惠。'
- en: Let's see how the training-to-scoring pipeline is realized with H2O.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看H2O是如何实现训练到评分流程的。
- en: The H2O pipeline and its advantages
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: H2O流程及其优势
- en: 'Trained H2O models participate in a similar pipeline as discussed, but with
    important attributes that make them easy to deploy to a diverse target of software
    systems and are also very fast when they score there. The deployable artifact
    for H2O is called a MOJO and it bridges the gap between model training and model
    scoring, and so is the central character in the story. Attributes of the H2O pipeline
    are summarized as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 训练好的H2O模型参与与之前讨论的类似流程，但具有使它们易于部署到各种软件系统目标的重要属性，并且在评分时也非常快。H2O的可部署工件称为MOJO，它架起了模型训练和模型评分之间的桥梁，因此是故事中的核心角色。H2O流程的属性总结如下：
- en: '![Figure 9.2 – H2O''s model training-to-scoring pipeline'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.2 – H2O的模型训练到评分流程'
- en: '](img/Figure_9.2_B16721.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_9.2_B16721.jpg]'
- en: Figure 9.2 – H2O's model training-to-scoring pipeline
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 – H2O的模型训练到评分流程
- en: 'Let''s elaborate on H2O''s advantages of deploying models:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细说明H2O部署模型的优势：
- en: '**H2O trained model**: H2O MOJOs exported from the model-building IDE as ready
    to deploy. The data scientist converts the trained model into an exported and
    ready-to-deploy MOJO by writing a single line of code in the IDE.'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**H2O训练模型**：从模型构建IDE导出的H2O MOJOs，已准备好部署。数据科学家通过在IDE中编写一行代码，将训练好的模型转换为导出并准备就绪的MOJO。'
- en: '**H2O MOJO**: H2O MOJOs are standardized low-latency scoring artifacts and
    ready to deploy. The MOJO construct is standardized and shared by all model types
    and has its own runtime that embeds in any Java runtime. This means that all MOJOS
    (models) are identically embedded in any **Java virtual machine** (**JVM**) independent
    of the larger software and hardware context. MOJOs are also lightweight and can
    be deployed to nearly all infrastructure (except the smallest of edge devices).
    MOJOs are super fast at scoring and can handle any data velocity (real-time scoring,
    batch scoring, and streaming scoring).'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**H2O MOJO**: H2O MOJOs 是标准化的低延迟评分工件，并已准备好部署。MOJO 构造是标准化的，并由所有模型类型共享，并且拥有自己的运行时，该运行时嵌入在任何
    Java 运行时中。这意味着所有 MOJOS（模型）都相同地嵌入在任何 **Java 虚拟机**（**JVM**）中，独立于更大的软件和硬件环境。MOJOs
    轻量级，可以部署到几乎所有基础设施（除了最小的边缘设备）。MOJOs 在评分方面非常快，可以处理任何数据速度（实时评分、批量评分和流式评分）。'
- en: '**Production system**: H2O MOJOs flexibly deploy to a diversity of production
    systems. MOJOs deploy to a wide range of production systems. An overview of these
    systems and details of how MOJOS are deployed to them are given a bit later in
    this chapter.'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**生产系统**: H2O MOJOs 可以灵活地部署到各种生产系统中。MOJOs 可以部署到广泛的生产系统。这些系统的概述以及 MOJOS 如何部署到这些系统的详细信息将在本章稍后提供。'
- en: '**Predictions**: MOJOs can output a lot of information in their scoring. Inputs
    to MOJO return predictions in the form of class probabilities for classification,
    predicted numeric values for regression, and model-specific outcomes for unsupervised
    problems. Additionally, and optionally, MOJOs may return reason codes in the form
    of Shapley or K-LIME values, or other attributes such as leaf node assignments
    for a prediction.'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**预测**: MOJOs 在评分时可以输出大量信息。输入到 MOJO 的数据返回分类的概率预测、回归的预测数值以及无监督问题的模型特定结果。此外，可选地，MOJOs
    可以返回以 Shapley 或 K-LIME 值或其他属性（如预测的叶节点分配）形式的原因代码。'
- en: Let's focus more on H2O production scoring specifically in the next section.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将更专注于 H2O 的生产评分。
- en: H2O production scoring
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: H2O 生产评分
- en: Models achieve their business value when they are put into production to make
    predictions (or generate unsupervised results for an unsupervised class of problems).
    We discuss, in this section, a more detailed view of the H2O pipeline from model
    building to production scoring.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当模型投入生产以进行预测（或为无监督问题类生成无监督结果）时，它们实现了其商业价值。在本节中，我们讨论了从模型构建到生产评分的 H2O 管道的更详细视图。
- en: End-to-end production scoring pipeline with H2O
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 H2O 的端到端生产评分管道
- en: 'Take a look at the following diagram showing an end-to-end H2O pipeline from
    model training to model deployment and production scoring:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下图表，展示从模型训练到模型部署和生产的 H2O 端到端管道：
- en: '![Figure 9.3 – High-level view of full scoring pipeline with H2O'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.3 – 使用 H2O 的完整评分管道的高级视图](img/Figure_9.3_B16721.jpg)'
- en: '](img/Figure_9.3_B16721.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_9.3_B16721.jpg)'
- en: Figure 9.3 – High-level view of full scoring pipeline with H2O
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.3 – 使用 H2O 的完整评分管道的高级视图
- en: Typically, model building is considered a **development** (**DEV**) environment,
    and model scoring is a PROD environment with source data from each respective
    environment.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，模型构建被认为是 **开发**（**DEV**）环境，而模型评分是一个 PROD 环境，其源数据来自各自的环境。
- en: For DEV, we have treated feature engineering and model training (and many associated
    steps such as model explainability and evaluation) extensively in *Section 2*,
    *Building State-of-the-Art Models on Large Data Volumes Using H2O*. We also briefly
    discussed the exportable ready-to-deploy H2O MOJO scoring artifact and deploying
    it to PROD systems earlier in this chapter.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 对于开发（DEV），我们在 *第 2 部分*，*使用 H2O 在大型数据量上构建最先进的模型* 中广泛讨论了特征工程和模型训练（以及许多相关步骤，如模型可解释性和评估）。我们也在本章早期简要讨论了可导出并准备好部署的
    H2O MOJO 评分工件以及将其部署到 PROD 系统中。
- en: 'Let''s identify some key points to keep in mind during this pipeline:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们确定在管道中需要注意的一些关键点：
- en: '*You need feature engineering parity between DEV and PROD*: This means that
    any feature engineering done to create the training dataset must be matched by
    the scoring input in TEST/PROD. In other words, the features in the training dataset
    must be the same as those fed into the model scoring. If there were multiple steps
    of feature engineering (for example, **extract, transform, and load** (**ETL**)
    from a data source and feature engineering in H2O Sparkling Water) before constructing
    the training dataset in DEV, the input to scoring in TEST/PROD must have those
    same engineered features.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*您需要在开发和生产环境中保持特征工程的一致性*：这意味着为了创建训练数据集而进行的任何特征工程都必须在测试/生产中的评分输入中得到匹配。换句话说，训练数据集中的特征必须与输入到模型评分中的特征相同。如果在开发中在构建训练数据集之前有多个特征工程步骤（例如，从数据源中进行的**提取、转换和加载**（**ETL**）以及H2O
    Sparkling Water中的特征工程），则测试/生产中的评分输入必须具有相同的工程特征。'
- en: Having said that, depending on how the MOJO is deployed (H2O Scorer, third-party
    integration, or your own scorer), you likely will have to input to TEST/PROD only
    a subset of the features from those in the training dataset. This reflects the
    fact that the trained model typically selects only a subset of data features that
    contribute to the final model. This subsetting is not required, however; MOJOs
    can accept full or subsets of features (compared to the training dataset) depending
    on how you design it. This flexibility will become clearer later in the chapter
    when we take a closer look at deploying MOJOs.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，根据MOJO的部署方式（H2O Scorer、第三方集成或您自己的评分器），您可能只需要输入训练数据集中的一小部分特征到测试/生产中。这反映了训练模型通常只选择对最终模型有贡献的数据特征子集的事实。然而，这种子集化不是必需的；MOJO可以根据您的设计接受完整的特征集或特征子集（与训练数据集相比）。这种灵活性将在本章稍后当我们更仔细地查看部署MOJO时变得更加清晰。
- en: '*You may need a wrapper around your MOJO (but not with H2O Scorers and most
    third-party integrations)*: MOJOs are ready to deploy to a Java environment. This
    means the MOJO is ready to convert input data to a prediction output using the
    mathematical logic derived from model training and held in the MOJO, and that
    the MOJO itself does not need compiling or modification in any way. But, you must
    still make sure the input (for example, CSV, JSON, batch, and so on) feeds into
    the MOJO in a way that the MOJO can accept. On the other side, you may want to
    extract more from the MOJO scoring result than only predictions, and you will
    need to convert the MOJO output to a format expected downstream in the application.
    You do this by writing a simple Java wrapper class and using the MOJO API called
    `h2o-genmodel` API to interact with the MOJO. These wrapper classes are not complicated.
    We will learn more about wrapping MOJOs with an example later in this chapter.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*您可能需要在您的MOJO周围添加一个包装器（但不是与H2O Scorers和大多数第三方集成一起使用）*：MOJO已准备好部署到Java环境。这意味着MOJO可以准备好使用从模型训练中推导出的数学逻辑并将输入数据转换为预测输出，并且MOJO本身不需要以任何方式进行编译或修改。但是，您必须确保输入（例如，CSV、JSON、批处理等）以MOJO可以接受的方式输入。另一方面，您可能希望从MOJO评分结果中提取比仅预测更多的信息，并且您需要将MOJO输出转换为应用程序下游期望的格式。您可以通过编写一个简单的Java包装器类并使用名为`h2o-genmodel`的MOJO
    API与MOJO交互来完成此操作。这些包装器类并不复杂。我们将在本章稍后通过一个示例来学习如何包装MOJO。'
- en: Important Note
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 重要提示
- en: H2O Scorers and many third-party integrations for MOJOs do not require wrappers
    because they handle this internally. All you need is the exported MOJO in these
    cases. Additionally, many integrations occur by way of REST APIs to endpoints
    of MOJOs deployed on REST servers.
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: H2O Scorers和许多MOJO的第三方集成不需要包装器，因为它们内部处理这些操作。在这些情况下，您只需要导出的MOJO。此外，许多集成是通过REST
    API与部署在REST服务器上的MOJO端点进行的。
- en: '*You may want to return reason codes or other information with your predictions*:
    MOJOs return predictions for supervised models and model-specific output for unsupervised
    models (for example, an anomaly score is returned for a model trained with `H2OIsolationForestEstimator`.
    But, there is more to retrieve from the MOJO; you can also return reason codes
    as K-LIME or Shapley values, the decision path taken through tree-based models,
    or class labels for the prediction of classification problems. These additional
    outputs are implemented in wrapper code using the `h2o-genmodel` API for scorers
    you build. They may or may not be built into the functionality of H2O Scorers
    or out-of-the-box third-party integrations. You will need to check the specifications
    for these scorers.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*您可能希望与预测一起返回原因代码或其他信息*：MOJO为监督模型返回预测，为无监督模型返回模型特定的输出（例如，对于使用`H2OIsolationForestEstimator`训练的模型，返回异常分数）。但是，从MOJO中还可以检索更多内容；您还可以返回原因代码作为K-LIME或Shapley值，通过基于树的模型所采取的决策路径，或者分类问题的预测中的类别标签。这些额外的输出是通过使用`h2o-genmodel`
    API在构建评分器时实现的包装代码。这些可能或可能不会集成到H2O评分器的功能中，或者集成到现成的第三方集成中。您需要检查这些评分器的规范。'
- en: '*You need a formalized process to deploy and govern your model*: Putting models
    into production involves risks: generally, the risk of failure or delay from errors
    during deployment, and the risk to revenue or reputation from adverse consequences
    from model decisions by deployed models. We will look at this topic more closely
    in [*Chapter 14*](B16721_14_Final_SK_ePub.xhtml#_idTextAnchor256), *H2O at Scale
    in a Larger Platform Context*.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*您需要一个正式的过程来部署和治理您的模型*：将模型投入生产涉及风险：通常，部署过程中出现错误导致失败或延迟的风险，以及模型决策的不利后果对收入或声誉的风险。我们将在[*第14章*](B16721_14_Final_SK_ePub.xhtml#_idTextAnchor256)，*在大平台环境中的H2O扩展规模*中更详细地探讨这个主题。'
- en: '*You need MLOps to monitor your model*: Models in PROD typically need to be
    monitored to see whether values of input data are changing over time compared
    to those in the training data (this result is called data drift). In this case,
    the model may need to be retrained since the signal it was trained against has
    changed, possibly causing the predictive accuracy of the model to degrade. Bias,
    prediction distributions, and other aspects of scoring may also be monitored.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*您需要MLOps来监控您的模型*：PROD中的模型通常需要监控，以查看输入数据的值是否随时间变化，与训练数据中的值相比（这种结果称为数据漂移）。在这种情况下，模型可能需要重新训练，因为训练时对抗的信号已经改变，这可能导致模型的预测准确性下降。评分的偏差、预测分布和其他方面也可能被监控。'
- en: Model monitoring is outside the capability of MOJOs. MOJOs are concerned with
    single scores. Monitoring fundamentally tracks aggregate trends from MOJO inputs
    and outputs and is a separate area of technology and concern that will not be
    treated here. Do note, however, that H2O has an MLOps platform that performs model
    monitoring and governance. It is overviewed in *Chapter 16*, *The Machine Learning
    Life Cycle, AI Apps, and H2O AI Hybrid Cloud*.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 模型监控超出了MOJO的能力。MOJO关注的是单个评分。监控本质上跟踪MOJO输入和输出的聚合趋势，这是一个独立的技术和关注领域，这里不会涉及。但是请注意，H2O有一个执行模型监控和治理的MLOps平台。它在*第16章*，*机器学习生命周期、AI应用和H2O
    AI混合云*中概述。
- en: 'We have just overviewed the full pipeline from H2O model building to production
    scoring and identified key points regarding this pipeline. One part of this pipeline
    is quite variable depending on your needs: the target system on which to deploy
    your MOJO. Let''s explore this in greater detail.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚概述了从H2O模型构建到生产评分的完整流程，并确定了关于此流程的关键点。此流程的一部分根据您的需求有很大差异：部署您的MOJO的目标系统。让我们更详细地探讨这一点。
- en: Target production systems for H2O MOJOs
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: H2O MOJO的目标生产系统
- en: 'One large advantage of MOJOs is that they can be deployed to a wide range of
    production systems. Let''s dig deeper using the following diagram to summarize:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: MOJO的一个大优势是它们可以被部署到广泛的生产系统中。让我们使用以下图表来深入挖掘，以总结：
- en: '![Figure 9.4 – Taxonomy of production systems for MOJO scoring'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.4 – MOJO评分的生产系统分类'
- en: '](img/Figure_9.4_B16721.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.4_B16721.jpg)'
- en: Figure 9.4 – Taxonomy of production systems for MOJO scoring
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4 – MOJO评分的生产系统分类
- en: Business requirements mostly determine whether scoring needs to be real time,
    batch, or streaming and MOJOs can handle the full range of these data velocities.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 商业需求主要决定了评分是否需要实时、批量或流式处理，而MOJO可以处理这些数据速度的全范围。
- en: 'It is useful to articulate production target systems into the following three
    categories for MOJO deployments:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 对于MOJO部署，将生产目标系统划分为以下三个类别是有用的：
- en: '**H2O scoring system**: This represents the H2O scoring software that is available
    from H2O. These scorers include a REST server with MLOps and rich model monitoring
    and governance capabilities (and a lively roadmap that includes batch scoring,
    champion/challenger testing, A/B testing, and more), a database scorer for batch
    database table scoring that outputs to a table or file, a file batch scorer, and
    AMQ and Kafka Scorers for streaming events. H2O is actively adding more scorers,
    so visit their website to keep up to date. The MLOps scorer specifically is discussed
    in more detail in *Chapter 16*, *The Machine Learning Lifecycle, AI Apps, and
    H2O AI Hybrid Cloud*.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**H2O评分系统**：这代表了从H2O提供的H2O评分软件。这些评分器包括一个带有MLOps和丰富的模型监控和管理能力的REST服务器（以及包括批量评分、冠军/挑战者测试、A/B测试等在内的活跃路线图），一个用于批量数据库表评分的数据库评分器，它输出到表或文件，一个文件批量评分器，以及用于流式事件的AMQ和Kafka评分器。H2O正在积极添加更多评分器，请访问他们的网站以保持最新。MLOps评分器在*第16章*，*机器学习生命周期、AI应用和H2O
    AI混合云*中进行了更详细的讨论。'
- en: '**Third-party integrations**: Many third parties integrate out-of-the-box with
    MOJOs for scoring on their framework or software. Others require some glue to
    be built to create a custom integration.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第三方集成**：许多第三方将MOJOs直接集成到他们的框架或软件中进行评分。其他一些则需要构建一些粘合剂来创建自定义集成。'
- en: '**Your own DIY system**: You can embed MOJOs in your software or framework
    integrations that run a Java environment. Integrations will require a simple Java
    wrapper class to interface your application or framework to the MOJO data input
    and output capabilities (for example, your REST server will need to convert JSON
    to a MOJO data object). H2O makes this easy with its **MOJO API**. Wrapping with
    the MOJO API is discussed in greater detail with code examples later in the chapter.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**您自己的DIY系统**：您可以将MOJO嵌入到运行Java环境的软件或框架集成中。集成将需要一个简单的Java包装类来将您的应用程序或框架与MOJO的数据输入和输出能力接口（例如，您的REST服务器需要将JSON转换为MOJO数据对象）。H2O通过其**MOJO
    API**使这变得简单。本章后面将更详细地讨论使用MOJO API进行包装，并附有代码示例。'
- en: Note that this chapter provides an introduction to deploying MOJOs to target
    systems. The entire [*Chapter 10*](B16721_10_Final_SK_ePub.xhtml#_idTextAnchor178),
    *H2O Model Deployment Patterns,* will be devoted to walking through multiple examples
    of MOJO deployments to target systems.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，本章提供了将MOJO部署到目标系统的简介。整个[*第10章*](B16721_10_Final_SK_ePub.xhtml#_idTextAnchor178)，*H2O模型部署模式*，将致力于展示多个MOJO部署到目标系统的示例。
- en: 'Now that we understand the end-to-end H2O pipeline from model building to live
    scoring on diverse production systems, let''s take a closer look at its central
    player: the MOJO.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了从模型构建到在多样化的生产系统上实时评分的端到端H2O管道，让我们更深入地了解一下其核心角色：MOJO。
- en: H2O MOJO deep dive
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: H2O MOJO深度解析
- en: All MOJOs are fundamentally similar from a deployment and scoring standpoint.
    This is true regardless of the MOJO's origin from an upstream model-building standpoint,
    that is, regardless of which of H2O's wide diversity of model-building algorithms
    (for example, Generalized Linear Model, and XGBoost) and techniques (for example,
    Stacked Ensembles and AutoML) and training dataset sizes (from GBs to TBs) were
    used to build the final model.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 从部署和评分的角度来看，所有MOJOs在本质上都是相似的。这一点无论从上游模型构建的角度来看MOJO的来源如何，也就是说，无论使用了H2O广泛多样的模型构建算法（例如，广义线性模型和XGBoost）和技巧（例如，堆叠集成和AutoML），以及训练数据集的大小（从GB到TB），构建最终模型都是如此。
- en: Let's get to know the MOJO in greater detail.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地了解MOJO。
- en: What is a MOJO?
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是MOJO？
- en: 'A **MOJO** stands for Model Object, Optimized. It is exported from your model-building
    IDE by running the following line of code:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**MOJO**代表模型对象，优化。它是通过运行以下代码行从您的模型构建IDE导出的：'
- en: '[PRE0]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This downloads a uniquely-named `.zip` file onto the filesystem of your IDE,
    to the path you specified. This `.zip` file is the MOJO and this is what is deployed.
    You do not unzip it, but if you are curious, it contains a `model.ini` file that
    describes the MOJO as well as multiple `.bin` files, all of which are used by
    the **MOJO runtime**.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在您的IDE文件系统中下载一个具有唯一名称的`.zip`文件，到您指定的路径。这个`.zip`文件就是MOJO，这就是部署的内容。您不需要解压缩它，但如果您好奇，它包含一个`model.ini`文件，该文件描述了MOJO，以及多个`.bin`文件，所有这些文件都由**MOJO运行时**使用。
- en: What is a MOJO runtime? This is a Java `.jar` file called `h2o-genmodel.jar`
    and is a generic runtime for all H2O Core MOJOs. In other words, MOJOs are specific
    to the trained models they are derived from, and all MOJOs are loaded identically
    into the MOJO runtime. The MOJO runtime integrates with a Java runtime (in H2O
    software, third-party software, or your own software). The following diagram relates
    MOJOs to the MOJO runtime.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是MOJO运行时？这是一个名为`h2o-genmodel.jar`的Java `.jar`文件，是所有H2O Core MOJOs的通用运行时。换句话说，MOJO是特定于它们从中派生的训练模型的，所有MOJO都以相同的方式加载到MOJO运行时中。MOJO运行时与Java运行时（在H2O软件、第三方软件或你的软件中）集成。以下图表展示了MOJO与MOJO运行时的关系。
- en: '![Figure 9.5 – MOJOs and the MOJO runtime'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 9.5 – MOJOs and the MOJO runtime'
- en: '](img/Figure_9.5_B16721.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_9.5_B16721.jpg](img/Figure_9.5_B16721.jpg)'
- en: Figure 9.5 – MOJOs and the MOJO runtime
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5 – MOJOs和MOJO运行时
- en: As mentioned previously, MOJOs are deployed to a Java runtime, more formally
    known as a `h2o-genmodel.jar` as a dependent library to do so. The software loads
    the model-specific MOJO into the generic `h2o-genmodel.jar` runtime using the
    `h2o-genmodel` API. The actual scoring logic in the application code also uses
    `h2o-genmodel.jar` and its API to implement the scoring and extraction of results
    from the embedded MOJO.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，MOJO被部署到Java运行时，更正式地称为`h2o-genmodel.jar`，作为依赖库来执行。软件使用`h2o-genmodel` API将特定模型的MOJO加载到通用的`h2o-genmodel.jar`运行时中。应用程序代码中的实际评分逻辑也使用`h2o-genmodel.jar`及其API来实现评分和从嵌入的MOJO中提取结果。
- en: Let's dig down and elaborate in the next section.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一节深入探讨并详细阐述。
- en: Deploying a MOJO
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署MOJO
- en: You need only the MOJO if you deploy a MOJO to an H2O Scorer or to a third-party
    software that integrates MOJOs out-of-the-box. You do not need to consider the
    MOJO runtime and API in these cases. This is because these software systems have
    already implemented `h2o-genmodel.jar` (using the `h2o-genmodel` API) behind the
    scenes, in other words, in the H2O Scorer or third-party software that is deployed
    and operating.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将MOJO部署到H2O评分器或直接集成MOJO的第三方软件中，你只需要MOJO。在这些情况下，你不需要考虑MOJO运行时和API。这是因为这些软件系统已经在幕后实现了`h2o-genmodel.jar`（使用`h2o-genmodel`
    API），换句话说，在已部署和运行的H2O评分器或第三方软件中。
- en: In other cases, you need to write the code that embeds the MOJO and extracts
    its scoring results. This code, typically, is a single Java wrapper class that
    uses the `h2o-genmodel` API. We will visit this a bit later using a code example.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他情况下，你需要编写嵌入MOJO并提取其评分结果的代码。这种代码通常是使用`h2o-genmodel` API的单个Java包装类。我们将在稍后通过代码示例来探讨这一点。
- en: This distinction is important and deserves a larger callout.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这种区别很重要，值得特别强调。
- en: Key Distinction in MOJO Deployment
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: MOJO部署中的关键区别
- en: You need only the MOJO when deploying to H2O scoring software or third-party
    software that integrates MOJOs out of the box (configuration-based).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当部署到H2O评分软件或直接集成MOJO的第三方软件（基于配置）时，你只需要MOJO。
- en: You need to write a simple Java wrapper class using the `h2o-genmodel` API when
    integrating the MOJO into your own software or third-party software that does
    not integrate MOJO out of the box. This wrapper requires `h2o-genmodel.jar`, which
    is the library that the `h2o-genmodel` API represents.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当将MOJO集成到自己的软件或未直接集成MOJO的第三方软件中时，你需要编写一个简单的Java包装类，使用`h2o-genmodel` API。这个包装器需要`h2o-genmodel.jar`，这是`h2o-genmodel`
    API所代表的库。
- en: (If you are consuming MOJO predictions in third-party software or your own software
    from a REST server, you do not, of course, need the MOJO or the MOJO runtime.
    You simply need to conform to the REST endpoint API for the MOJO.)
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: （如果你在第三方软件或自己的软件中从REST服务器消费MOJO预测，你当然不需要MOJO或MOJO运行时。你只需要遵守MOJO的REST端点API。）
- en: Let's look at the case when you need to write a wrapper.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看你需要编写包装器的情况。
- en: Wrapping MOJOs using the H2O MOJO API
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用H2O MOJO API包装MOJO
- en: Let's first touch upon a few precursors before learning how to wrap MOJOs inside
    larger software programs.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习如何在大型软件程序中包装MOJO之前，让我们先简要介绍一些先决条件。
- en: Obtaining the MOJO runtime
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取MOJO运行时
- en: 'You can download `h2o-genmodel.jar` when you download your MOJO from the IDE
    after model building. This is simply a matter of adding a new argument to your
    download statement, as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在模型构建后从IDE下载MOJO时，你可以下载`h2o-genmodel.jar`。这仅仅是在你的下载语句中添加一个新参数的问题，如下所示：
- en: '[PRE1]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This method of obtaining `h2o-genmodel.jar` generally is not done in a governed
    production deployment. This is because `h2o-genmodel.jar` is generic to all MOJOs
    and is a concern of the software developer and not the data scientists.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Software developers can download the MOJO runtime from the Maven repository
    at [https://mvnrepository.com/artifact/ai.h2o/h2o-genmodel](https://mvnrepository.com/artifact/ai.h2o/h2o-genmodel).
    The `h2o-genmodel.jar` is backward-compatible; it should work for a MOJO generated
    from an H2O-3 (or Sparkling Water) version equal to or less than the `h2o-genmodel.jar`
    version.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: A Tip for Obtaining the MOJO Runtime (h2o-genmodel.jar)
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Data scientists do not have to download the MOJO runtime each time they download
    their MOJO from their model-building IDEs. This is because the MOJO runtime is
    generic to all MOJOs. A best practice is to let your developers (not the data
    scientists) concern themselves with obtaining and using the MOJO runtime for production
    deployments when needed. This can be done through the Maven repository referenced
    earlier.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: The h2o-genmodel API
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Javadocs for the `h2o-genmodel` API are located at [https://docs.h2o.ai/h2o/latest-stable/h2o-genmodel/javadoc/index.html](https://docs.h2o.ai/h2o/latest-stable/h2o-genmodel/javadoc/index.html).
    Note that this is for the latest H2O-3 (or Sparkling Water). To get a different
    version, go to [https://docs.h2o.ai/prior_h2o/index.html](https://docs.h2o.ai/prior_h2o/index.html).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: In summary, the `h2o-genmodel` API is used to build wrappers around the MOJO
    so your application can feed data into the MOJO, extract prediction and decision
    information from it, and convert these results to the code in your wrapper. The
    wrapper is typically part of your larger application and can be seen as the glue
    between your app and the MOJO.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Let's dive in.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: A generalized approach to wrapping your MOJO
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It will be useful before writing code to first look at the logical flow of
    application code for the MOJO wrapper you develop. This can be seen in the following
    diagram:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.6 – Logical view of wrapping a MOJO'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.6_B16721.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.6 – Logical view of wrapping a MOJO
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: 'The Java wrapper typically is its own class (or part of a class) and imports
    `h2o-genmodel.jar` and follows these general logical steps:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Load `yourMOJO.zip` into the MOJO runtime. Recall that `h2o-genmodel.jar` is
    the runtime that holds the generic logic to work on model-specific MOJOs. This
    runtime is now ready to operate on your specific model.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Feed data into the MOJO. To do so, convert the Java data structure of your input
    into a MOJO data structure using the `h2o-genmodel` code.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Score the MOJO. This is a single line of `h2o-genmodel` code.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extract the subset of information that you need from the MOJO scoring results.
    Recall that prediction results (or unsupervised results) represent aspects of
    the prediction (labels and predictions) as well as aspects of scoring decisions
    (reason codes, decision path to leaf node results, and other).
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从MOJO评分结果中提取所需的信息子集。回想一下，预测结果（或无监督结果）表示预测的各个方面（标签和预测）以及评分决策的各个方面（理由代码、决策路径到叶节点结果和其他）。
- en: Convert the extracted results into a data structure needed downstream by the
    application.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将提取的结果转换为应用程序下游所需的数据结构。
- en: Let's write a wrapper.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个包装器。
- en: Wrapping example – Build a batch file scorer in Java
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 包装示例 – 使用Java构建批量文件评分器
- en: The goal of the wrapper we are writing is to batch score new data from a file.
    The output of the scoring will be the input record, the prediction, and the reason
    codes all formatted as a line of CSV. The reason codes will be a single CSV field
    but the reason codes will be pipe-delimited.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写的包装器的目标是批量评分来自文件的新数据。评分的输出将是输入记录、预测和格式化为CSV行格式的理由代码。理由代码将是一个单独的CSV字段，但理由代码将以管道分隔。
- en: 'We will compile this wrapper class as a runnable program that accepts three
    input parameters:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编译这个包装器类为一个可运行的程序，该程序接受三个输入参数：
- en: 'Input param 1: `path/of/batch/file/to/score`'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入参数1：`path/of/batch/file/to/score`
- en: 'Input param 2: `path/to/yourMOJO.zip`'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入参数2：`path/to/yourMOJO.zip`
- en: 'Input param 3 (optional): The `—shap` flag to trigger the return of Shapley
    reason codes in addition to the scoring prediction for each row in the file'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入参数3（可选）：`—shap`标志以触发返回文件中每行的评分预测和Shapley理由代码
- en: Shapley Values Add Latency
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Shapley值增加延迟
- en: Keep in mind that returning Shapley values adds additional computation and,
    therefore, latency to each scoring. You might want to benchmark latencies with
    and without Shapley reason codes in your results to evaluate whether to include
    them in scoring or not if latency is critical.
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请记住，返回Shapley值会增加额外的计算，因此会增加每个评分的延迟。你可能想在结果中比较带有和不带有Shapley理由代码的延迟，以评估是否在评分中包含它们，如果延迟是关键的话。
- en: We will use the MOJO that you exported at the end of your model building exercise
    in [*Chapter 8*](B16721_08_Final_SK_ePub.xhtml#_idTextAnchor137), *Putting It
    All Together*.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用你在[*第8章*](B16721_08_Final_SK_ePub.xhtml#_idTextAnchor137)，“整合一切”的模型构建练习结束时导出的MOJO。
- en: The code
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代码
- en: Our batch file scorer program will involve a single Java class and will not
    include error handling and other production quality software design. Our purpose
    here is to show the fundamentals of integrating a MOJO into your software.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的批量文件评分程序将涉及一个Java类，并且不会包括错误处理和其他生产质量软件设计。我们在这里的目的只是展示将MOJO集成到你的软件中的基础知识。
- en: Note that the code samples below are elaborated step by step. To access the
    entire Java code from beginning to end, go to the GitHub repository at [https://github.com/PacktPublishing/Machine-Learning-at-Scale-with-H2O/tree/main/chapt9](https://github.com/PacktPublishing/Machine-Learning-at-Scale-with-H2O/tree/main/chapt9).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 注意以下代码示例是逐步详细阐述的。要访问从开始到结束的完整Java代码，请访问GitHub仓库[https://github.com/PacktPublishing/Machine-Learning-at-Scale-with-H2O/tree/main/chapt9](https://github.com/PacktPublishing/Machine-Learning-at-Scale-with-H2O/tree/main/chapt9)。
- en: 'Let''s get started:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧：
- en: '`BatchFileScorer`. Since this is also an executable program, we will create
    a `main` method to start the code execution. Note the `import` statements for
    the `h2o-genmodel` library packages:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`BatchFileScorer`。由于这也是一个可执行程序，我们将创建一个`main`方法来启动代码执行。注意`import`语句用于`h2o-genmodel`库包：'
- en: '[PRE3]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now, let's fill the `main` method with code, as shown in the following steps.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们按照以下步骤在`main`方法中填充代码。
- en: '**Retrieve the input parameters**: We retrieve the input parameters from the
    program''s arguments:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**检索输入参数**：我们从程序的参数中检索输入参数：'
- en: '[PRE4]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '**Load the MOJO and configure it to optionally return reason codes**: We load
    the MOJO into the MOJO runtime and configure it to return Shapley values:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**加载MOJO并配置它以可选地返回理由代码**：我们将MOJO加载到MOJO运行时中，并配置它返回Shapley值：'
- en: '[PRE5]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The MOJO is loaded only once here before all scoring later in the code.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: MOJO在这里只加载一次，然后在代码中稍后的所有评分之前。
- en: Important Design Point – Load Your MOJO Once
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 重要设计点 – 只加载一次MOJO
- en: Loading the MOJO can take a few seconds, but it only needs to be loaded into
    your program once.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 加载MOJO可能需要几秒钟，但只需要在你的程序中加载一次。
- en: Load the MOJO once in your wrapper class (for example, when it initializes)
    before making all scoring requests. You do not want your sub-hundred or sub-ten
    millisecond scores each preceded by multiple seconds of loading.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: 'Now to the magic: generating predictions.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '`import` statements shown in *step 1*:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: That is it! You have loaded the MOJO and configured the scoring, and scored
    each line of a file. To score, you have converted each record from its application
    representation (CSV string) to the `h2o-genmodel` representation (the `DataRow`
    object). You have written one line of code to score the record. And, you have
    retrieved the prediction and, optionally, Shapley reason codes from the scoring
    result. You then formatted this to a representation used by your application.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Drill-downs to the code
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's drill down into methods from the previous code.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Method drilldown – Converting your application data object to an h2o-genmodel
    data object
  id: totrans-151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Note that `RowData mojoRow` is where the program code is converted into the
    `h2o-genmodel` API data object. In the example here, it is done through the `convertInput(record)`
    method as shown:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We have simply split the input using a comma as a separator and assigned each
    value to the H2O `RowData` object, which essentially is a map of key-value pairs
    with the keys representing feature names (that is, column headings). There are
    alternatives to using `RowData`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Design Decision – Choices for converting Your Data Object to the MOJO API Data
    Object
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Using the `h2o-genmodel` API's `RowData` class, as we did here, is just one
    way to convert your application data object into an `h2o-genmodel` object to feed
    to the MOJO for scoring. Check the API for additional ways that may offer better
    code design for your implementation.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Method drilldown – The single line to score
  id: totrans-169
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Only a single line of code was needed to score the MOJO and retrieve results:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note that you may need a different class than `BinomialModelPrediction` depending
    on which type of model you build. Check the `h2o-genmodel` Javadocs for details
    on which Java class to use and what scoring information is returned.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Method drilldown – Collecting results and formatting as output
  id: totrans-173
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We ultimately constructed a string from the scoring results using the `formatOutput(record,
    p, doShapley)` method. Here is how that method was implemented:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The main point here is that the prediction results are held in the `h2o-genmodel`
    API's `BinomialModelPrediction p` object that was returned from scoring. We can
    retrieve a lot of information from this object. In our case, we retrieved the
    predicted class, identified by `p.label` , and its probability, `p.classProbabilities[0]`.
    Since this is a `BinomialModelPrediction`, the probability of the other class
    would be retrieved by `p.classProbabilities[1]`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: We then iterated through an array of the Shapley reason contribution names (`model.getContributionNames()[i]`)
    and values (`p.contributions[i]`). In our case, we are retrieving only reason
    codes with values over `0.01`. Alternatively, for example, we could have sorted
    the reasons by value and returned the top five. When returning all reasons, a
    bias is returned as the last in the array, and the sum of all features and the
    bias will equal the raw prediction of the model.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Altogether, we used a bunch of code to format all of this into a CSV string
    starting with the original record and then appending the predicted class and its
    probability, and then a bar-delimited list of reason codes.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Running the code
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To run the application, compile `BatchFileScorer.java` with `h2o-genmodel.jar`
    as an executable JAR file called `BatchFileScorer.jar`. Then, run the following
    command in the same directory as `BatchFileScorer.jar`:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: To retrieve Shapley reason codes, append `--shap` to the statement.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: Other things to know about MOJOs
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You are now ready to deploy MOJOs, with or without required wrappers, as articulated
    in the previous section. Let's round up our knowledge of MOJOs by addressing the
    following secondary topics.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting MOJO decision logic
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For tree-based models, you can use a utility built into `h2o-genmodel.jar` to
    generate a graphical representation of the tree logic in the MOJO. Here is how.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use the same MOJO we used in the previous coding example of building
    a wrapper class. On the command line where your `h2o-genmodel.jar` is located,
    run the following:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This will create a `.png` file that looks like this:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.7 – Output of the PrintMojo utility'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.7_B16721.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.7 – Output of the PrintMojo utility
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Note that if you omitted `--tree 0`, you would have generated a folder holding
    a forest of all trees. We have specified to return only the first one.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: You can also use `dot` for `--format`. This produces a format that can be consumed
    by the third-party **Graphviz** utility to make the graphical representation more
    prettified than that shown in *Figure 9.7*.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, if you wish to include this output for programmatic use, for
    `–format`, state `.json`, which outputs the file to JSON format.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: 'See the H2O documentation for more details and configuration alternatives:
    [https://docs.h2o.ai/h2o/latest-stable/h2o-docs/productionizing.html#viewing-a-mojo-model](https://docs.h2o.ai/h2o/latest-stable/h2o-docs/productionizing.html#viewing-a-mojo-model).'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: MOJO and POJO
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'OK, let''s say it: MOJOs are not the only H2O deployable artifact. Before MOJOs,
    there were only `h2o-genmodel` API to build wrapper classes, as we discussed before.
    They are also a bit different. Let''s compare, contrast, and conclude.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: MOJO and POJO similarities
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following are the similarities between MOJOs and POJOs:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: They are both exported from the IDE after your model is built (or from the H2O
    Flow UI).
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'They are both deployed in the same way: they both run in a JVM, there is the
    wrapper or no wrapper distinction depending on the target scoring system (H2O
    Scorers, third-party, or your own software program), and they both use the MOJO
    runtime (`h2o-genmodel.jar`) and the same API and Javadoc.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们的部署方式相同：它们都在JVM中运行，是否有封装器取决于目标评分系统（H2O评分器、第三方或您自己的软件程序），并且它们都使用MOJO运行时（`h2o-genmodel.jar`）以及相同的API和Javadoc。
- en: MOJO and POJO differences
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: MOJO和POJO的区别
- en: 'These are the differences between MOJOs and POJOs:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是MOJO和POJO之间的区别：
- en: A POJO is exported as a single `.java` file that needs to be compiled, whereas
    the MOJO exports as a single `.zip` file, as described earlier.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: POJO以单个`.java`文件的形式导出，需要编译，而MOJO以单个`.zip`文件的形式导出，如前所述。
- en: POJOs contain entire trees to navigate the model, whereas MOJOs contain tree
    metadata and use generic tree-walker code in `h2o-genmodel.zip` to navigate the
    model. The larger the tree structure, the larger the POJO.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: POJO包含用于导航模型的整个树，而MOJO包含树元数据，并使用`h2o-genmodel.zip`中的通用树遍历代码来导航模型。树结构越大，POJO就越大。
- en: POJOs are significantly larger than MOJOs (typically 20-25 times larger) and
    slower than MOJOs when scoring (2-3 times slower). In general, the larger the
    POJO, the slower it is compared to any MOJO built from the same model.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: POJO比MOJO大得多（通常是20-25倍）且在评分时比MOJO慢（慢2-3倍）。一般来说，POJO越大，与从同一模型构建的任何MOJO相比，它就越慢。
- en: Large POJOs may have trouble compiling. POJOs over 1 GB are not supported by
    H2O.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大型POJO可能难以编译。H2O不支持超过1 GB的POJO。
- en: When to use either a MOJO or POJO
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 何时使用MOJO或POJO
- en: You should view POJOs as deprecated but still supported (except > 1GB) and sometimes
    needed in edge cases. Know that MOJOs are not fully supported across all algorithms
    so, in these cases, you are forced to use POJOs. Therefore, use MOJOs when you
    can and resort to POJOs in infrequent cases when you cannot.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 您应将POJO视为已弃用但仍受支持（除> 1GB外），并且在某些边缘情况下有时需要。了解MOJO并非在所有算法中都完全受支持，因此在这些情况下，您被迫使用POJO。因此，在可能的情况下使用MOJO，在无法使用时才偶尔使用POJO。
- en: Deployment Decision – MOJO or POJO?
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 部署决策 - MOJO或POJO？
- en: See MOJOs as your go-to current technology and POJOs as similar to deploy but
    deprecated yet supported (except > 1 GB). MOJOs have advantages primarily in scoring
    speed and size footprint.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 将MOJO视为您当前的首选技术，将POJO视为类似部署但已弃用但仍受支持（除> 1 GB外）。MOJO的主要优势在于评分速度和大小占用。
- en: MOJOs are not supported for some algorithms. Check the H2O documentation for
    current support considerations for MOJOs and POJOs.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 一些算法不支持MOJO。请查阅H2O文档了解当前对MOJO和POJO的支持考虑因素。
- en: We are now ready to summarize.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备总结。
- en: Summary
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We began this chapter by taking a high-level view of the transition from model
    building to model deployment. We saw that this transition is bridged for H2O by
    the MOJO, a deployable representation of the trained model that is easy to generate
    from model building and easy to deploy for fast model scoring.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以从模型构建到模型部署的过渡的高级视角开始本章。我们了解到，H2O通过MOJO实现了这一过渡，MOJO是训练模型的可部署表示，易于从模型构建生成，也易于部署以实现快速模型评分。
- en: We then took a closer look at the range of target systems MOJOs can be deployed
    on, and saw that these must run in a Java runtime but, otherwise, are quite diverse.
    MOJOs can be scored on real-time, batch, and streaming systems, usefully categorized
    as H2O Scorers (scoring software provided and supported by H2O), third-party integrations
    (software provided and supported by companies other than H2O), and your software
    integrations (software that you build and maintain).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们更详细地研究了MOJO可以部署的目标系统范围，并看到这些系统必须在Java运行时中运行，但除此之外，它们相当多样化。MOJO可以在实时、批处理和流系统中进行评分，这些系统被有用地分类为H2O评分器（由H2O提供和支持的评分软件）、第三方集成（由H2O以外的公司提供和支持的软件）以及您的软件集成（您构建和维护的软件）。
- en: This categorization of target systems helps us determine whether you can deploy
    the exported MOJO directly, or whether you need to wrap it in a Java class using
    the `h2o-genmodel` API to embed it into the scoring software. H2O Scorers and
    some third-party scorers require only the exported MOJO and no wrapper to be implemented.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这种对目标系统的分类有助于我们确定您是否可以直接部署导出的MOJO，或者是否需要使用`h2o-genmodel` API将其封装在Java类中以便嵌入评分软件。H2O评分器和一些第三方评分器只需要导出的MOJO，无需实现封装器。
- en: We then took a detailed look at the MOJO and the MOJO runtime, and how these
    relate to deployments with and without the need for wrappers. We described the
    general structure of a MOJO wrapper and coded a wrapper to batch score records
    from a file. Our coding gave us a better understanding of the MOJO API that is
    used to interact with the MOJO in your application. This understanding included
    how to use the API to load the MOJO, structure data to a type that can be used
    by the MOJO, score with the MOJO, and retrieve predictions and reason codes from
    the scoring results.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后详细研究了 MOJO 及其运行时，以及这些如何与需要或不需包装器的部署相关联。我们描述了 MOJO 包装器的一般结构，并编写了一个包装器以批量从文件评分记录。我们的编码让我们对用于与应用程序中的
    MOJO 交互的 MOJO API 有更深入的理解。这种理解包括如何使用 API 加载 MOJO、将数据结构化为 MOJO 可以使用的类型、使用 MOJO
    进行评分，以及从评分结果中检索预测和原因代码。
- en: We then learned how to use a handy tool in the MOJO API to obtain a visual,
    JSON, or dot representation of the decision logic in the MOJO for your model.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后学习了如何使用 MOJO API 中的一个实用工具来获取模型中 MOJO 决策逻辑的视觉、JSON 或点表示。
- en: Finally, we introduced the predecessor of the MOJO, the POJO, and characterized
    it as similar to the MOJO in terms of deployment and use of the MOJO API but deprecated
    yet supported, and so to be used for a minority of cases when MOJOs cannot.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们介绍了 MOJO 的前身 POJO，并描述它类似于 MOJO 在部署和使用 MOJO API 方面，但已弃用但仍受支持，因此仅在 MOJO 无法使用的情况下使用少数情况。
- en: Now, we understand in great detail the MOJO and how it is flexibly deployed
    to a diversity of production scoring systems. Let's move to the next chapter where
    we will exhibit this flexibility and diversity by describing concrete MOJO deployments
    on a handful of these systems.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们详细了解了 MOJO 及其如何灵活地部署到各种生产评分系统中。让我们进入下一章，我们将通过描述这些系统中的具体 MOJO 部署来展示这种灵活性和多样性。
