- en: Part I. Module 1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Scala for Data Science**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Leverage the power of Scala with different tools to build scalable, robust
    data science applications*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Chapter 1. Scala and Data Science
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The second half of the 20^(th) century was the age of silicon. In fifty years,
    computing power went from extremely scarce to entirely mundane. The first half
    of the 21^(st) century is the age of the Internet. The last 20 years have seen
    the rise of giants such as Google, Twitter, and Facebook—giants that have forever
    changed the way we view knowledge.
  prefs: []
  type: TYPE_NORMAL
- en: The Internet is a vast nexus of information. Ninety percent of the data generated
    by humanity has been generated in the last 18 months. The programmers, statisticians,
    and scientists who can harness this glut of data to derive real understanding
    will have an ever greater influence on how businesses, governments, and charities
    make decisions.
  prefs: []
  type: TYPE_NORMAL
- en: This book strives to introduce some of the tools that you will need to synthesize
    the avalanche of data to produce true insight.
  prefs: []
  type: TYPE_NORMAL
- en: Data science
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Data science is the process of extracting useful information from data. As
    a discipline, it remains somewhat ill-defined, with nearly as many definitions
    as there are experts. Rather than add yet another definition, I will follow *Drew
    Conway''s* description ([http://drewconway.com/zia/2013/3/26/the-data-science-venn-diagram](http://drewconway.com/zia/2013/3/26/the-data-science-venn-diagram)).
    He describes data science as the culmination of three orthogonal sets of skills:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Data scientists must have *hacking skills*. Data is stored and transmitted
    through computers. Computers, programming languages, and libraries are the hammers
    and chisels of data scientists; they must wield them with confidence and accuracy
    to sculpt the data as they please. This is where Scala comes in: it''s a powerful
    tool to have in your programming toolkit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data scientists must have a sound understanding of *statistics and numerical
    algorithms*. Good data scientists will understand how machine learning algorithms
    function and how to interpret results. They will not be fooled by misleading metrics,
    deceptive statistics, or misinterpreted causal links.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A good data scientist must have a sound understanding of the *problem domain*.
    The data science process involves building and discovering knowledge about the
    problem domain in a scientifically rigorous manner. The data scientist must, therefore,
    ask the right questions, be aware of previous results, and understand how the
    data science effort fits in the wider business or research context.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Drew Conway summarizes this elegantly with a Venn diagram showing data science
    at the intersection of hacking skills, maths and statistics knowledge, and substantive
    expertise:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Data science](img/image01158.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: It is, of course, rare for people to be experts in more than one of these areas.
    Data scientists often work in cross-functional teams, with different members providing
    the expertise for different areas. To function effectively, every member of the
    team must nevertheless have a general working knowledge of all three areas.
  prefs: []
  type: TYPE_NORMAL
- en: 'To give a more concrete overview of the workflow in a data science project,
    let''s imagine that we are trying to write an application that analyzes the public
    perception of a political campaign. This is what the data science pipeline might
    look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Obtaining data**: This might involve extracting information from text files,
    polling a sensor network or querying a web API. We could, for instance, query
    the Twitter API to obtain lists of tweets with the relevant hashtags.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data ingestion**: Data often comes from many different sources and might
    be unstructured or semi-structured. Data ingestion involves moving data from the
    data source, processing it to extract structured information, and storing this
    information in a database. For tweets, for instance, we might extract the username,
    the names of other users mentioned in the tweet, the hashtags, text of the tweet,
    and whether the tweet contains certain keywords.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Exploring data**: We often have a clear idea of what information we want
    to extract from the data but very little idea how. For instance, let''s imagine
    that we have ingested thousands of tweets containing hashtags relevant to our
    political campaign. There is no clear path to go from our database of tweets to
    the end goal: insight into the overall public perception of our campaign. Data
    exploration involves mapping out how we are going to get there. This step will
    often uncover new questions or sources of data, which requires going back to the
    first step of the pipeline. For our tweet database, we might, for instance, decide
    that we need to have a human manually label a thousand or more tweets as expressing
    "positive" or "negative" sentiments toward the political campaign. We could then
    use these tweets as a training set to construct a model.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Feature building**: A machine learning algorithm is only as good as the features
    that enter it. A significant fraction of a data scientist''s time involves transforming
    and combining existing features to create new features more closely related to
    the problem that we are trying to solve. For instance, we might construct a new
    feature corresponding to the number of "positive" sounding words or pairs of words
    in a tweet.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Model construction and training**: Having built the features that enter the
    model, the data scientist can now train machine learning algorithms on their datasets.
    This will often involve trying different algorithms and optimizing model **hyperparameters**.
    We might, for instance, settle on using a random forest algorithm to decide whether
    a tweet is "positive" or "negative" about the campaign. Constructing the model
    involves choosing the right number of trees and how to calculate impurity measures.
    A sound understanding of statistics and the problem domain will help inform these
    decisions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Model extrapolation and prediction**: The data scientists can now use their
    new model to try and infer information about previously unseen data points. They
    might pass a new tweet through their model to ascertain whether it speaks positively
    or negatively of the political campaign.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Distillation of intelligence and insight from the model**: The data scientists
    combine the outcome of the data analysis process with knowledge of the business
    domain to inform business decisions. They might discover that specific messages
    resonate better with the target audience, or with specific segments of the target
    audience, leading to more accurate targeting. A key part of informing stakeholders
    involves data visualization and presentation: data scientists create graphs, visualizations,
    and reports to help make the insights derived clear and compelling.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is far from a linear pipeline. Often, insights gained at one stage will
    require the data scientists to backtrack to a previous stage of the pipeline.
    Indeed, the generation of business insights from raw data is normally an iterative
    process: the data scientists might do a rapid first pass to verify the premise
    of the problem and then gradually refine the approach by adding new data sources
    or new features or trying new machine learning algorithms.'
  prefs: []
  type: TYPE_NORMAL
- en: In this book, you will learn how to deal with each step of the pipeline in Scala,
    leveraging existing libraries to build robust applications.
  prefs: []
  type: TYPE_NORMAL
- en: Programming in data science
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This book is not a book about data science. It is a book about how to use Scala,
    a programming language, for data science. So, where does programming come in when
    processing data?
  prefs: []
  type: TYPE_NORMAL
- en: Computers are involved at every step of the data science pipeline, but not necessarily
    in the same manner. The style of programs that we build will be drastically different
    if we are just writing throwaway scripts to explore data or trying to build a
    scalable application that pushes data through a well-understood pipeline to continuously
    deliver business intelligence.
  prefs: []
  type: TYPE_NORMAL
- en: Let's imagine that we work for a company making games for mobile phones in which
    you can purchase in-game benefits. The majority of users never buy anything, but
    a small fraction is likely to spend a lot of money. We want to build a model that
    recognizes big spenders based on their play patterns.
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to explore data, find the right features, and build a model
    based on a subset of the data. In this exploration phase, we have a clear goal
    in mind but little idea of how to get there. We want a light, flexible language
    with strong libraries to get us a working model as soon as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have a working model, we need to deploy it on our gaming platform to
    analyze the usage patterns of all the current users. This is a very different
    problem: we have a relatively clear understanding of the goals of the program
    and of how to get there. The challenge comes in designing software that will scale
    out to handle all the users and be robust to future changes in usage patterns.'
  prefs: []
  type: TYPE_NORMAL
- en: In practice, the type of software that we write typically lies on a spectrum
    ranging from a single throwaway script to production-level code that must be proof
    against future expansion and load increases. Before writing any code, the data
    scientist must understand where their software lies on this spectrum. Let's call
    this the **permanence** **spectrum**.
  prefs: []
  type: TYPE_NORMAL
- en: Why Scala?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You want to write a program that handles data. Which language should you choose?
  prefs: []
  type: TYPE_NORMAL
- en: There are a few different options. You might choose a dynamic language such
    as Python or R or a more traditional object-oriented language such as Java. In
    this section, we will explore how Scala differs from these languages and when
    it might make sense to use it.
  prefs: []
  type: TYPE_NORMAL
- en: 'When choosing a language, the architect''s trade-off lies in a balance of provable
    correctness versus development speed. Which of these aspects you need to emphasize
    will depend on the application requirements and where on the permanence spectrum
    your program lies. Is this a short script that will be used by a few people who
    can easily fix any problems that arise? If so, you can probably permit a certain
    number of bugs in rarely used code paths: when a developer hits a snag, they can
    just fix the problem as it arises. By contrast, if you are developing a database
    engine that you plan on releasing to the wider world, you will, in all likelihood,
    favor correctness over rapid development. The SQLite database engine, for instance,
    is famous for its extensive test suite, with 800 times as much testing code as
    application code ([https://www.sqlite.org/testing.html](https://www.sqlite.org/testing.html)).'
  prefs: []
  type: TYPE_NORMAL
- en: What matters, when estimating the *correctness* of a program, is not the perceived
    absence of bugs, it is the degree to which you can prove that certain bugs are
    absent.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several ways of proving the absence of bugs before the code has even
    run:'
  prefs: []
  type: TYPE_NORMAL
- en: Static type checking occurs at compile time in statically typed languages, but
    this can also be used in strongly typed dynamic languages that support type annotations
    or type hints. Type checking helps verify that we are using functions and classes
    as intended.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static analyzers and linters that check for undefined variables or suspicious
    behavior (such as parts of the code that can never be reached).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Declaring some attributes as immutable or constant in compiled languages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit testing to demonstrate the absence of bugs along particular code paths.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are several more ways of checking for the absence of some bugs at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic type checking in both statically typed and dynamic languages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assertions verifying supposed program invariants or expected contracts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next sections, we will examine how Scala compares to other languages
    in data science.
  prefs: []
  type: TYPE_NORMAL
- en: Static typing and type inference
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Scala's static typing system is very versatile. A lot of information as to the
    program's behavior can be encoded in types, allowing the compiler to guarantee
    a certain level of correctness. This is particularly useful for code paths that
    are rarely used. A dynamic language cannot catch errors until a particular branch
    of execution runs, so a bug can persist for a long time until the program runs
    into it. In a statically typed language, any bug that can be caught by the compiler
    will be caught at compile time, before the program has even started running.
  prefs: []
  type: TYPE_NORMAL
- en: 'Statically typed object-oriented languages have often been criticized for being
    needlessly verbose. Consider the initialization of an instance of the `Example`
    class in Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We have to repeat the class name twice—once to define the compile-time type
    of the `myInstance` variable and once to construct the instance itself. This feels
    like unnecessary work: the compiler knows that the type of `myInstance` is `Example`
    (or a superclass of `Example`) as we are binding a value of the `Example` type.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Scala, like most functional languages, uses type inference to allow the compiler
    to infer the type of variables from the instances bound to them. We would write
    the equivalent line in Scala as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The Scala compiler infers that `myInstance` has the `Example` type at compile
    time. A lot of the time, it is enough to specify the types of the arguments and
    of the return value of a function. The compiler can then infer types for all the
    variables defined in the body of the function. Scala code is usually much more
    concise and readable than the equivalent Java code, without compromising any of
    the type safety.
  prefs: []
  type: TYPE_NORMAL
- en: Scala encourages immutability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Scala encourages the use of immutable objects. In Scala, it is very easy to
    define an attribute as immutable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The default collections are immutable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Having immutable objects removes a common source of bugs. Knowing that some
    objects cannot be changed once instantiated reduces the number of places bugs
    can creep in. Instead of considering the lifetime of the object, we can narrow
    in on the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Scala and functional programs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Scala encourages functional code. A lot of Scala code consists of using higher-order
    functions to transform collections. You, as a programmer, do not have to deal
    with the details of iterating over the collection. Let''s write an `occurrencesOf`
    function that returns the indices at which an element occurs in a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'How does this work? We first declare a new list, `collection.zipWithIndex`,
    whose elements are `(collection(0), 0)`, `(collection(1), 1)`, and so on: pairs
    of the collection''s elements and their indexes.'
  prefs: []
  type: TYPE_NORMAL
- en: We then tell Scala that we want to iterate over this collection, binding the
    `currentElem` variable to the current element and `index` to the index. We apply
    a filter on the iteration, selecting only those elements for which `currentElem
    == elem`. We then tell Scala to just return the `index` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'We did not need to deal with the details of the iteration process in Scala.
    The syntax is very declarative: we tell the compiler that we want the index of
    every element equal to `elem` in collection and let the compiler worry about how
    to iterate over collection.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the equivalent in Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In Java, you start by defining a (mutable) list in which to put occurrences
    as you find them. You then iterate over the collection by defining a counter,
    considering each element in turn and adding its index to the list of occurrences,
    if need be. There are many more moving parts that we need to get right for this
    method to work. These moving parts exist because we must tell Java how to iterate
    over the collection, and they represent a common source of bugs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, as a lot of code is taken up by the iteration mechanism, the line
    that defines the logic of the function is harder to find:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note that this is not meant as an attack on Java. In fact, Java 8 adds a slew
    of functional constructs, such as lambda expressions, the `Optional` type that
    mirrors Scala's `Option`, or stream processing. Rather, it is meant to demonstrate
    the benefit of functional approaches in minimizing the potential for errors and
    maximizing clarity.
  prefs: []
  type: TYPE_NORMAL
- en: Null pointer uncertainty
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We often need to represent the possible absence of a value. For instance, imagine
    that we are reading a list of usernames from a CSV file. The CSV file contains
    name and e-mail information. However, some users have declined to enter their
    e-mail into the system, so this information is absent. In Java, one would typically
    represent the e-mail as a string or an `Email` class and represent the absence
    of e-mail information for a particular user by setting that reference to `null`.
    Similarly, in Python, we might use `None` to demonstrate the absence of a value.
  prefs: []
  type: TYPE_NORMAL
- en: This approach is dangerous because we are not encoding the possible absence
    of e-mail information. In any nontrivial program, deciding whether an instance
    attribute can be `null` requires considering every occasion in which this instance
    is defined. This quickly becomes impractical, so programmers either assume that
    a variable is not null or code too defensively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Scala (following the lead of other functional languages) introduces the `Option[T]`
    type to represent an attribute that might be absent. We might then write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We have now encoded the possible absence of e-mail in the type information.
    It is obvious to any programmer using the `User` class that e-mail information
    is possibly absent. Even better, the compiler knows that the `email` field can
    be absent, forcing us to deal with the problem rather than recklessly ignoring
    it to have the application burn at runtime in a conflagration of null pointer
    exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: All this goes back to achieving a certain level of provable correctness. Never
    using `null`, we know that we will never run into null pointer exceptions. Achieving
    the same level of correctness in languages without `Option[T]` requires writing
    unit tests on the client code to verify that it behaves correctly when the e-mail
    attribute is null.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that it is possible to achieve this in Java using, for instance, Google''s
    Guava library ([https://code.google.com/p/guava-libraries/wiki/UsingAndAvoidingNullExplained](https://code.google.com/p/guava-libraries/wiki/UsingAndAvoidingNullExplained))
    or the `Optional` class in Java 8\. It is more a matter of convention: using `null`
    in Java to denote the absence of a value has long been the norm.'
  prefs: []
  type: TYPE_NORMAL
- en: Easier parallelism
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Writing programs that take advantage of parallel architectures is challenging.
    It is nevertheless necessary to tackle all but the simplest data science problems.
  prefs: []
  type: TYPE_NORMAL
- en: Parallel programming is difficult because we, as programmers, tend to think
    sequentially. Reasoning about the order in which different events can happen in
    a concurrent program is very challenging.
  prefs: []
  type: TYPE_NORMAL
- en: Scala provides several abstractions that greatly facilitate the writing of parallel
    code. These abstractions work by imposing constraints on the way parallelism is
    achieved. For instance, parallel collections force the user to phrase the computation
    as a sequence of operations (such as **map**, **reduce**, and **filter**) on collections.
    Actor systems require the developer to think in terms of actors that encapsulate
    the application state and communicate by passing messages.
  prefs: []
  type: TYPE_NORMAL
- en: It might seem paradoxical that restricting the programmer's freedom to write
    parallel code as they please avoids many of the problems associated with concurrency.
    However, limiting the number of ways in which a program behaves facilitates thinking
    about its behavior. For instance, if an actor is misbehaving, we know that the
    problem lies either in the code for this actor or in one of the messages that
    the actor receives.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example of the power afforded by having coherent, restrictive abstractions,
    let''s use parallel collections to solve a simple probability problem. We will
    calculate the probability of getting at least 60 heads out of 100 coin tosses.
    We can estimate this using Monte Carlo: we simulate 100 coin tosses by drawing
    100 random Boolean values and check whether the number of true values is at least
    60\. We repeat this until results have converged to the required accuracy, or
    we get bored of waiting.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run through this in a Scala console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `trial` function runs a single set of 100 throws, returning the number
    of heads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'To get our answer, we just need to repeat `trial` as many times as we can and
    aggregate the results. Repeating the same set of operations is ideally suited
    to parallel collections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The probability is thus approximately 2.5% to 3%. All we had to do to distribute
    the calculation over every CPU in our computer is use the `par` method to parallelize
    the range `(0 until nTrials)`. This demonstrates the benefits of having a coherent
    abstraction: parallel collections let us trivially parallelize any computation
    that can be phrased in terms of higher-order functions on collections.'
  prefs: []
  type: TYPE_NORMAL
- en: Clearly, not every problem is as easy to parallelize as a simple Monte Carlo
    problem. However, by offering a rich set of intuitive abstractions, Scala makes
    writing parallel applications manageable.
  prefs: []
  type: TYPE_NORMAL
- en: Interoperability with Java
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Scala runs on the Java virtual machine. The Scala compiler compiles programs
    to Java byte code. Thus, Scala developers have access to Java libraries natively.
    Given the phenomenal number of applications written in Java, both open source
    and as part of the legacy code in organizations, the interoperability of Scala
    and Java helps explain the rapid uptake of Scala.
  prefs: []
  type: TYPE_NORMAL
- en: 'Interoperability has not just been unidirectional: some Scala libraries, such
    as the Play framework, are becoming increasingly popular among Java developers.'
  prefs: []
  type: TYPE_NORMAL
- en: When not to use Scala
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous sections, we described how Scala's strong type system, preference
    for immutability, functional capabilities, and parallelism abstractions make it
    easy to write reliable programs and minimize the risk of unexpected behavior.
  prefs: []
  type: TYPE_NORMAL
- en: What reasons might you have to avoid Scala in your next project? One important
    reason is familiarity. Scala introduces many concepts such as implicits, type
    classes, and composition using traits that might not be familiar to programmers
    coming from the object-oriented world. Scala's type system is very expressive,
    but getting to know it well enough to use its full power takes time and requires
    adjusting to a new programming paradigm. Finally, dealing with immutable data
    structures can feel alien to programmers coming from Java or Python.
  prefs: []
  type: TYPE_NORMAL
- en: Nevertheless, these are all drawbacks that can be overcome with time. Scala
    does fall short of the other data science languages in library availability. The
    IPython Notebook, coupled with matplotlib, is an unparalleled resource for data
    exploration. There are ongoing efforts to provide similar functionality in Scala
    (Spark Notebooks or Apache Zeppelin, for instance), but there are no projects
    with the same level of maturity. The type system can also be a minor hindrance
    when one is exploring data or trying out different models.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, in this author's biased opinion, Scala excels for more *permanent* programs.
    If you are writing a throwaway script or exploring data, you might be better served
    with Python. If you are writing something that will need to be reused and requires
    a certain level of provable correctness, you will find Scala extremely powerful.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that the obligatory introduction is over, it is time to write some Scala
    code. In the next chapter, you will learn about leveraging Breeze for numerical
    computations with Scala. For our first foray into data science, we will use logistic
    regression to predict the gender of a person given their height and weight.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By far, the best book on Scala is *Programming in Scala* by *Martin Odersky*,
    *Lex Spoon*, and *Bill Venners*. Besides being authoritative (*Martin Odersky*
    is the driving force behind Scala), this book is also approachable and readable.
  prefs: []
  type: TYPE_NORMAL
- en: '*Scala Puzzlers* by *Andrew Phillips* and *Nermin Šerifović* provides a fun
    way to learn more advanced Scala.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Scala for Machine Learning* by *Patrick R. Nicholas* provides examples of
    how to write machine learning algorithms with Scala.'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 2. Manipulating Data with Breeze
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Data science is, by and large, concerned with the manipulation of structured
    data. A large fraction of structured datasets can be viewed as tabular data: each
    row represents a particular instance, and columns represent different attributes
    of that instance. The ubiquity of tabular representations explains the success
    of spreadsheet programs like Microsoft Excel, or of tools like SQL databases.'
  prefs: []
  type: TYPE_NORMAL
- en: To be useful to data scientists, a language must support the manipulation of
    columns or tables of data. Python does this through NumPy and pandas, for instance.
    Unfortunately, there is no single, coherent ecosystem for numerical computing
    in Scala that quite measures up to the SciPy ecosystem in Python.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will introduce Breeze, a library for fast linear algebra
    and manipulation of data arrays as well as many other features necessary for scientific
    computing and data science.
  prefs: []
  type: TYPE_NORMAL
- en: Code examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The easiest way to access the code examples in this book is to clone the GitHub
    repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The code samples for each chapter are in a single, standalone folder. You may
    also browse the code online on GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Breeze
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have downloaded the code examples for this book, the easiest way of using
    Breeze is to go into the `chap02` directory and type `sbt console` at the command
    line. This will open a Scala console in which you can import Breeze.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to build a standalone project, the most common way of installing
    Breeze (and, indeed, any Scala module) is through SBT. To fetch the dependencies
    required for this chapter, copy the following lines to a file called `build.sbt`,
    taking care to leave an empty line after `scalaVersion`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Open a Scala console in the same directory as your `build.sbt` file by typing
    `sbt console` in a terminal. You can check that Breeze is working correctly by
    importing Breeze from the Scala prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Getting help on Breeze
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter gives a reasonably detailed introduction to Breeze, but it does
    not aim to give a complete API reference.
  prefs: []
  type: TYPE_NORMAL
- en: To get a full list of Breeze's functionality, consult the Breeze Wiki page on
    GitHub at [https://github.com/scalanlp/breeze/wiki](https://github.com/scalanlp/breeze/wiki).
    This is very complete for some modules and less complete for others. The source
    code ([https://github.com/scalanlp/breeze/](https://github.com/scalanlp/breeze/))
    is detailed and gives a lot of information. To understand how a particular function
    is meant to be used, look at the unit tests for that function.
  prefs: []
  type: TYPE_NORMAL
- en: Basic Breeze data types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Breeze is an extensive library providing fast and easy manipulation of arrays
    of data, routines for optimization, interpolation, linear algebra, signal processing,
    and numerical integration.
  prefs: []
  type: TYPE_NORMAL
- en: The basic linear algebra operations underlying Breeze rely on the `netlib-java`
    library, which can use system-optimized **BLAS** and **LAPACK** libraries, if
    present. Thus, linear algebra operations in Breeze are often extremely fast. Breeze
    is still undergoing rapid development and can, therefore, be somewhat unstable.
  prefs: []
  type: TYPE_NORMAL
- en: Vectors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Breeze makes manipulating one- and two-dimensional data structures easy. To
    start, open a Scala console through SBT and import Breeze:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s dive straight in and define a vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We have just defined a three-element vector, `v`. Vectors are just one-dimensional
    arrays of data exposing methods tailored to numerical uses. They can be indexed
    like other Scala collections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'They support element-wise operations with a scalar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'They also support element-wise operations with another vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Breeze makes writing vector operations intuitive and considerably more readable
    than the native Scala equivalent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that Breeze will refuse (at compile time) to coerce operands to the correct
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'It will also refuse (at runtime) to add vectors together if they have different
    lengths:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Basic manipulation of vectors in Breeze will feel natural to anyone used to
    working with NumPy, MATLAB, or R.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we have only looked at *element-wise* operators. These are all prefixed
    with a colon. All the usual suspects are present: `:+`, `:*`, `:-`, `:/`, `:%`
    (remainder), and `:^` (power) as well as Boolean operators. To see the full list
    of operators, have a look at the API documentation for `DenseVector` or `DenseMatrix`
    ([https://github.com/scalanlp/breeze/wiki/Linear-Algebra-Cheat-Sheet](https://github.com/scalanlp/breeze/wiki/Linear-Algebra-Cheat-Sheet)).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides element-wise operations, Breeze vectors support the operations you
    might expect of mathematical vectors, such as the dot product:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Pitfalls of element-wise operators**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides the `:+` and `:-` operators for element-wise addition and subtraction
    that we have seen so far, we can also use the more traditional `+` and `-` operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'One must, however, be very careful with operator precedence rules when mixing
    `:+` or `:*` with `:+` operators. The `:+` and `:*` operators have very low operator
    precedence, so they will be evaluated last. This can lead to some counter-intuitive
    behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'By contrast, if we use `:+` instead of `+`, the mathematical precedence of
    operators is respected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In summary, one should avoid mixing the `:+` style operators with the `+` style
    operators as much as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Dense and sparse vectors and the vector trait
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All the vectors we have looked at thus far have been dense vectors. Breeze also
    supports sparse vectors. When dealing with arrays of numbers that are mostly zero,
    it may be more computationally efficient to use sparse vectors. The point at which
    a vector has enough zeros to warrant switching to a sparse representation depends
    strongly on the type of operations, so you should run your own benchmarks to determine
    which type to use. Nevertheless, a good heuristic is that, if your vector is about
    90% zero, you may benefit from using a sparse representation.
  prefs: []
  type: TYPE_NORMAL
- en: Sparse vectors are available in Breeze as the `SparseVector` and `HashVector`
    classes. Both these types support many of the same operations as `DenseVector`
    but use a different internal implementation. The `SparseVector` instances are
    very memory-efficient, but adding non-zero elements is slow. `HashVector` is more
    versatile, at the cost of an increase in memory footprint and computational time
    for iterating over non-zero elements. Unless you need to squeeze the last bits
    of memory out of your application, I recommend using `HashVector`. We will not
    discuss these further in this book, but the reader should find them straightforward
    to use if needed. `DenseVector`, `SparseVector`, and `HashVector` all implement
    the `Vector` trait, giving them a common interface.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Breeze remains very experimental and, as of this writing, somewhat unstable.
    I have found dealing with specific implementations of the `Vector` trait, such
    as `DenseVector` or `SparseVector`, to be more reliable than dealing with the
    `Vector` trait directly. In this chapter, we will explicitly type every vector
    as `DenseVector`.
  prefs: []
  type: TYPE_NORMAL
- en: Matrices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Breeze allows the construction and manipulation of two-dimensional arrays in
    a similar manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Building vectors and matrices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have seen how to explicitly build vectors and matrices by passing their
    values to the constructor (or rather, to the companion object''s `apply` method):
    `DenseVector(1.0, 2.0, 3.0)`. Breeze offers several other powerful ways of building
    vectors and matrices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The `linspace` method (available in the `breeze.linalg` package object) creates
    a `Double` vector of equally spaced values. For instance, to create a vector of
    10 values distributed uniformly between `0` and `1`, perform the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The `tabulate` method lets us construct vectors and matrices from functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The first argument to `DenseVector.tabulate` is the size of the vector, and
    the second is a function returning the value of the vector at a particular position.
    This is useful for creating ranges of data, among other things.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `rand` function lets us create random vectors and matrices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can construct vectors from Scala arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'To construct vectors from other Scala collections, you must use the *splat*
    operator, `:_ *`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Advanced indexing and slicing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have already seen how to select a particular element in a vector `v` by its
    index with, for instance, `v(2)`. Breeze also offers several powerful methods
    for selecting parts of a vector.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by creating a vector to play around with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Unlike native Scala collections, Breeze vectors support negative indexing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Breeze lets us slice the vector using a range:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Indexing by a range returns a *view* of the original vector: when running `val
    v2 = v(1 to 3)`, no data is copied. This means that slicing is extremely efficient.
    Taking a slice of a huge vector does not increase the memory footprint at all.
    It also means that one should be careful updating a slice, since it will also
    update the original vector. We will discuss mutating vectors and matrices in a
    subsequent section in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Breeze also lets us select an arbitrary set of elements from a vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a `SliceVector`, which behaves like a `DenseVector` (both implement
    the `Vector` interface), but does not actually have memory allocated for values:
    it just knows how to map from its indices to values in its parent vector. One
    should think of `vSlice` as a specific view of `v`. We can materialize the view
    (give it its own data rather than acting as a lens through which `v` is viewed)
    by converting it to `DenseVector`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that if an element of a slice is out of bounds, an exception will only
    be thrown when that element is accessed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, one can index vectors using Boolean arrays. Let''s start by defining
    an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, `v(mask)` results in a view containing the elements of `v` for which
    `mask` is `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'This can be used as a way of filtering certain elements in a vector. For instance,
    to select the elements of `v` which are less than `3.0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Matrices can be indexed in much the same way as vectors. Matrix indexing functions
    take two arguments—the first argument selects the row(s) and the second one slices
    the column(s):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also mix different slicing types for rows and columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Note how, in this case, Breeze returns a vector. In general, slicing returns
    the following objects:'
  prefs: []
  type: TYPE_NORMAL
- en: A scalar when single indices are passed as the row and column arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A vector when the row argument is a range and the column argument is a single
    index
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A vector transpose when the column argument is a range and the row argument
    is a single index
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A matrix otherwise
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The symbol `::` can be used to indicate *every element along a particular direction*.
    For instance, we can select the second column of `m`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Mutating vectors and matrices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Breeze vectors and matrices are mutable. Most of the slicing operations described
    above can also be used to set elements of a vector or matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'We are not limited to mutating single elements. In fact, all the indexing operations
    outlined above can be used to set the elements of vectors or matrices. When mutating
    slices of vectors or matrices, use the element-wise assignment operator, `:=`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The assignment operator, `:=`, works like other element-wise operators in Breeze.
    If the right-hand side is a scalar, it will automatically be broadcast to a vector
    of the given shape:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'All element-wise operators have an update counterpart. For instance, the `:+=`
    operator acts like the element-wise addition operator `:+`, but also updates its
    left-hand operand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Notice how the update operator updates the vector in place and returns it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have learnt how to slice vectors and matrices in Breeze to create new views
    of the original data. These views are not independent of the vector they were
    created from—updating the view will update the underlying vector and vice-versa.
    This is best illustrated with an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'This quickly becomes intuitive if we remember that, when we create a vector
    or matrix, we are creating a view of an underlying data array rather than creating
    the data itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Mutating vectors and matrices](img/image01159.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'A vector slice `v(0 to 6 by 2)` of the `v` vector is just a different view
    of the array underlying `v`. The view itself contains no data. It just contains
    pointers to the data in the original array. Internally, the view is just stored
    as a pointer to the underlying data and a recipe for iterating over that data:
    in the case of this slice, the recipe is just "start at the first element of the
    underlying data and go to the seventh element of the underlying data in steps
    of two".'
  prefs: []
  type: TYPE_NORMAL
- en: 'Breeze offers a `copy` function for when we want to create independent copies
    of data. In the previous example, we can construct a copy of `viewEvens` as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: We can now update `copyEvens` independently of `v`.
  prefs: []
  type: TYPE_NORMAL
- en: Matrix multiplication, transposition, and the orientation of vectors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have mostly looked at element-wise operations on vectors and matrices.
    Let's now look at matrix multiplication and related operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The matrix multiplication operator is `*`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Besides matrix-matrix multiplication, we can use the matrix multiplication
    operator between matrices and vectors. All vectors in Breeze are column vectors.
    This means that, when multiplying matrices and vectors together, a vector should
    be viewed as an (*n * 1*) matrix. Let''s walk through an example of matrix-vector
    multiplication. We want the following operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Matrix multiplication, transposition, and the orientation of vectors](img/image01160.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'By contrast, if we wanted:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Matrix multiplication, transposition, and the orientation of vectors](img/image01161.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We must convert `v` to a row vector. We can do this using the transpose operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Note that the type of `v.t` is `Transpose[DenseVector[_]]`. A `Transpose[DenseVector[_]]`
    behaves in much the same way as a `DenseVector` as far as element-wise operations
    are concerned, but it does not support mutation or slicing.
  prefs: []
  type: TYPE_NORMAL
- en: Data preprocessing and feature engineering
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have now discovered the basic components of Breeze. In the next few sections,
    we will apply them to real examples to understand how they fit together to form
    a robust base for data science.
  prefs: []
  type: TYPE_NORMAL
- en: An important part of data science involves preprocessing datasets to construct
    useful features. Let's walk through an example of this. To follow this example
    and access the data, you will need to download the code examples for the book
    ([www.github.com/pbugnion/s4ds](http://www.github.com/pbugnion/s4ds)).
  prefs: []
  type: TYPE_NORMAL
- en: 'You will find, in directory `chap02/data/` of the code attached to this book,
    a CSV file with true heights and weights as well as self-reported heights and
    weights for 181 men and women. The original dataset was collected as part of a
    study on body image. Refer to the following link for more information: [http://vincentarelbundock.github.io/Rdatasets/doc/car/Davis.html](http://vincentarelbundock.github.io/Rdatasets/doc/car/Davis.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a helper function in the package provided with the book to load the
    data into Breeze arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The `data` object contains five vectors, each 181 element long:'
  prefs: []
  type: TYPE_NORMAL
- en: '`data.genders`: A `Char` vector describing the gender of the participants'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`data.heights`: A `Double` vector of the true height of the participants'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`data.weights`: A `Double` vector of the true weight of the participants'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`data.reportedHeights`: A `Double` vector of the self-reported height of the
    participants'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`data.reportedWeights`: A `Double` vector of the self-reported weight of the
    participants'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s start by counting the number of men and women in the study. We will
    define an array that contains just `''M''` and do an element-wise comparison with
    `data.genders`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The `isMale` vector is the same length as `data.genders`. It is `true` where
    the participant is male, and `false` otherwise. We can use this Boolean array
    as a mask for the other arrays in the dataset (remember that `vector(mask)` selects
    the elements of `vector` where mask is `true`). Let''s get the height of the men
    in our dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'To count the number of men in our dataset, we can use the indicator function.
    This transforms a Boolean array into an array of doubles, mapping `false` to `0.0`
    and `true` to `1.0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s calculate the `mean` height of men and women in the experiment. We can
    calculate the mean of a vector using `mean(v)`, which we can access by importing
    `breeze.stats._`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'To calculate the `mean` height of the men, we can use our `isMale` array to
    slice `data.heights`; `data.heights(isMale)` is a view of the `data.heights` array
    with all the height values for the men:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'As a somewhat more involved example, let''s look at the discrepancy between
    real and reported weight for both men and women in this experiment. We can get
    an array of the percentage difference between the reported weight and the true
    weight:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Notice how Breeze's overloading of mathematical operators allows us to manipulate
    data arrays easily and elegantly.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now calculate the mean and standard deviation of this array for men:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also calculate the fraction of men who overestimated their height:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: There are thus ten men who believe they are taller than they actually are. The
    element-wise AND operator `:&` returns a vector that is true for all indices for
    which both its arguments are true. The vector `overReportMask :& isMale` is thus
    true for all participants that are male and over-reported their height.
  prefs: []
  type: TYPE_NORMAL
- en: Breeze – function optimization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Having studied feature engineering, let's now look at the other end of the data
    science pipeline. Typically, a machine learning algorithm defines a loss function
    that is a function of a set of parameters. The value of the loss function represents
    how well the model fits the data. The parameters are then optimized to minimize
    (or maximize) the loss function.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](part0117.xhtml#aid-3FIHQ2 "Chapter 12. Distributed Machine Learning
    with MLlib"), *Distributed Machine Learning with MLlib*, we will look at **MLlib**,
    a machine learning library that contains many well-known algorithms. Often, we
    don't need to worry about optimizing loss functions directly since we can rely
    on the machine learning algorithms provided by MLlib. It is nevertheless useful
    to have a basic knowledge of optimization.
  prefs: []
  type: TYPE_NORMAL
- en: 'Breeze has an `optimize` module that contains functions for finding a local
    minimum:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create a toy function that we want to optimize:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Breeze – function optimization](img/image01162.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can represent this function in Scala as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Most local optimizers also require the gradient of the function being optimized.
    The gradient is a vector of the same dimension as the arguments to the function.
    In our case, the gradient is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Breeze – function optimization](img/image01163.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can represent the gradient in Breeze with a function that takes a vector
    argument and returns a vector of the same length:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'For instance, at the point `(1, 1, 1)`, we have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s set up the optimization problem. Breeze''s optimization methods require
    that we pass in an implementation of the `DiffFunction` trait with a single method,
    `calculate`. This method must return a tuple of the function and its gradient:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'We are now ready to run the optimization. The optimize module provides a `minimize`
    function that does just what we want. We pass it `optTrait` and a starting point
    for the optimization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: The true minimum is at `(0.0, 0.0, 0.0)`. The optimizer therefore correctly
    finds the minimum.
  prefs: []
  type: TYPE_NORMAL
- en: The `minimize` function uses the **L-BFGS** method to run the optimization by
    default. It takes several additional arguments to control the optimization. We
    will explore these in the next sections.
  prefs: []
  type: TYPE_NORMAL
- en: Numerical derivatives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous example, we specified the gradient of `f` explicitly. While
    this is generally good practice, calculating the gradient of a function can often
    be tedious. Breeze provides a gradient approximation function using finite differences.
    Reusing the same objective function `def f(xs:DenseVector[Double]) = sum(xs :^
    2.0)` as in the previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The trait `approxOptTrait` has a `gradientAt` method that returns an approximation
    to the gradient at a point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Note that this can be quite inaccurate. The `ApproximateGradientFunction` constructor
    takes an `epsilon` optional argument that controls the size of the step taken
    when calculating the finite differences. Changing the value of `epsilon` can improve
    the accuracy of the finite difference algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ApproximateGradientFunction` instance implements the `DiffFunction` trait.
    It can therefore be passed to `minimize` directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: This, again, gives a result close to zero, but somewhat further away than when
    we specified the gradient explicitly. In general, it will be significantly more
    efficient and more accurate to calculate the gradient of a function analytically
    than to rely on Breeze's numerical gradient. It is probably best to only use the
    numerical gradient during data exploration or to check analytical gradients.
  prefs: []
  type: TYPE_NORMAL
- en: Regularization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `minimize` function takes many optional arguments relevant to machine learning
    algorithms. In particular, we can instruct the optimizer to use a regularization
    parameter when performing the optimization. Regularization introduces a penalty
    in the loss function to prevent the parameters from growing arbitrarily. This
    is useful to avoid overfitting. We will discuss regularization in greater detail
    in [Chapter 12](part0117.xhtml#aid-3FIHQ2 "Chapter 12. Distributed Machine Learning
    with MLlib"), *Distributed Machine Learning with MLlib*.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, to use `L2Regularization` with a hyperparameter of `0.5`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: The regularization makes no difference in this case, since the parameters are
    zero at the minimum.
  prefs: []
  type: TYPE_NORMAL
- en: To see a list of optional arguments that can be passed to `minimize`, consult
    the Breeze documentation online.
  prefs: []
  type: TYPE_NORMAL
- en: An example – logistic regression
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s now imagine we want to build a classifier that takes a person''s **height**
    and **weight** and assigns a probability to their being **Male** or **Female**.
    We will reuse the height and weight data introduced earlier in this chapter. Let''s
    start by plotting the dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: '![An example – logistic regression](img/image01164.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Height versus weight data for 181 men and women
  prefs: []
  type: TYPE_NORMAL
- en: There are many different algorithms for classification. A first glance at the
    data shows that we can, approximately, separate men from women by drawing a straight
    line across the plot. A linear method is therefore a reasonable initial attempt
    at classification. In this section, we will use logistic regression to build a
    classifier.
  prefs: []
  type: TYPE_NORMAL
- en: A detailed explanation of logistic regression is beyond the scope of this book.
    The reader unfamiliar with logistic regression is referred to *The Elements of
    Statistical Learning* by *Hastie*, *Tibshirani*, and *Friedman*. We will just
    give a brief summary here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Logistic regression estimates the probability of a given *height* and *weight*
    belonging to a *male* with the following sigmoid function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![An example – logistic regression](img/image01165.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, *f* is a linear function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![An example – logistic regression](img/image01166.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, ![An example – logistic regression](img/image01167.jpeg) is an array
    of parameters that we need to determine using the training set. If we consider
    the height and weight as a *features = (height, weight)* matrix, we can re-write
    the sigmoid kernel *f* as a matrix multiplication of the *features* matrix with
    the *params* vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '![An example – logistic regression](img/image01168.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'To simplify this expression further, it is common to add a dummy feature whose
    value is always *1* to the *features* matrix. We can then multiply *params(0)*
    by this feature, allowing us to write the entire sigmoid kernel *f* as a single
    matrix-vector multiplication:'
  prefs: []
  type: TYPE_NORMAL
- en: '![An example – logistic regression](img/image01169.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The feature matrix, *features*, is now a (*181 * 3*) matrix, where each row
    is *(1, height, weight)* for a particular participant.
  prefs: []
  type: TYPE_NORMAL
- en: 'To find the optimal values of the parameters, we can maximize the likelihood
    function, *L(params|features)*. The likelihood takes a given set of parameter
    values as input and returns the probability that these particular parameters gave
    rise to the training set. For a set of parameters and associated probability function
    *P(male|features[i]),* the likelihood is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![An example – logistic regression](img/image01170.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: If we magically know, ahead of time, the gender of everyone in the population,
    we can assign *P(male)=1* for the men and *P(male)=0* for the women. The likelihood
    function would then be **1**. Conversely, any uncertainty leads to a reduction
    in the likelihood function. If we choose a set of parameters that consistently
    lead to classification errors (low *P(male)* for men or high *P(male)* for women),
    the likelihood function drops to *0*.
  prefs: []
  type: TYPE_NORMAL
- en: The maximum likelihood corresponds to those values of the parameters most likely
    to describe the observed data. Thus, to find the parameters that best describe
    our training set, we just need to find parameters that maximize *L(params|features)*.
    However, maximizing the likelihood function itself is very rarely done, since
    it involves multiplying many small values together, which quickly leads to floating
    point underflow. It is best to maximize the log of the likelihood, which has the
    same maximum as the likelihood. Finally, since most optimization algorithms are
    geared to minimize a function rather than maximize it, we will minimize![An example
    – logistic regression](img/image01171.jpeg).
  prefs: []
  type: TYPE_NORMAL
- en: 'For logistic regression, this is equivalent to minimizing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![An example – logistic regression](img/image01172.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Here, the sum runs over all participants in the training data, ![An example
    – logistic regression](img/image01173.jpeg) is a vector ![An example – logistic
    regression](img/image01174.jpeg) of the *i*-th observation in the training set,
    and ![An example – logistic regression](img/image01175.jpeg) is *1* if the person
    is male, and *0* if the participant is female.
  prefs: []
  type: TYPE_NORMAL
- en: 'To minimize the *Cost* function, we must also know its gradient with respect
    to the parameters. This is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![An example – logistic regression](img/image01176.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We will start by rescaling the height and weight by their mean and standard
    deviation. While this is not strictly necessary for logistic regression, it is
    generally good practice. It facilitates the optimization and would become necessary
    if we wanted to use regularization methods or build superlinear features (features
    that allow the boundary separating men from women to be curved rather than a straight
    line).
  prefs: []
  type: TYPE_NORMAL
- en: 'For this example, we will move away from the Scala shell and write a standalone
    Scala script. Here''s the full code listing. Don''t worry if this looks daunting.
    We will break it up into manageable chunks in a minute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'That was a mouthful! Let''s take this one step at a time. After the obvious
    imports, we start with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'By extending the built-in `App` trait, we tell Scala to treat the entire object
    as a `main` function. This just cuts out `def main(args:Array[String])` boilerplate.
    We then load the data and rescale the height and weight to have a `mean` of zero
    and a standard deviation of one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: The `rescaledHeights` and `rescaledWeights` vectors will be the features of
    our model. We can now build the training set matrix for this model. This is a
    (*181 * 3*) matrix, for which the *i*-th row is `(1, height(i), weight(i))`, corresponding
    to the values of the height and weight for the *i*th participant. We start by
    transforming both `rescaledHeights` and `rescaledWeights` from vectors to (*181
    * 1*) matrices
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'We must also create a (*181 * 1*) matrix containing just *1* to act as the
    dummy feature. We can do this using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'We now need to combine our three (*181 * 1*) matrices together into a single
    feature matrix of shape (*181 * 3*). We can use the `horzcat` method to concatenate
    the three matrices together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'The final step in the data preprocessing stage is to create the target variable.
    We need to convert the `data.genders` vector to a vector of ones and zeros. We
    assign a value of one for men and zero for women. Thus, our classifier will predict
    the probability that any given person is male. We will use the `.values.map` method,
    a method equivalent to the `.map` method on Scala collections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we could also have used the indicator function which we discovered
    earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: This results in the allocation of a temporary array, `maleVector`, and might
    therefore increase the program's memory footprint if there were many participants
    in the experiment.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have a matrix representing the training set and a vector denoting the
    target variable. We can write the loss function that we want to minimize. As mentioned
    previously, we will minimize ![An example – logistic regression](img/image01177.jpeg).
    The loss function takes as input a set of values for the linear coefficients and
    returns a number indicating how well those values of the linear coefficients fit
    the training data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Note that we use `log1p(x)` to calculate *log(1+x)*. This is robust to underflow
    for small values of `x`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explore the cost function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the cost function is somewhat lower for slightly positive values
    of the height and weight parameters. This indicates that the likelihood function
    is larger for slightly positive values of the height and weight. This, in turn,
    implies (as we expect from the plot) that people who are taller and heavier than
    average are more likely to be male.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need a function that calculates the gradient of the loss function,
    since that will help with the optimization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Having defined the loss function and gradient, we are now in a position to
    set up the optimization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'All that is left now is to run the optimization. The cost function for logistic
    regression is convex (it has a single minimum), so the starting point for optimization
    is irrelevant in principle. In practice, it is common to start with a coefficient
    vector that is zero everywhere (equating to assigning a 0.5 probability of being
    male to every participant):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'This returns the vector of optimal parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: How can we interpret the values of the optimal parameters? The coefficients
    for the height and weight are both positive, indicating that people who are taller
    and heavier are more likely to be male.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also get the decision boundary (the line separating (height, weight)
    pairs more likely to belong to a woman from (height, weight) pairs more likely
    to belong to a man) directly from the coefficients. The decision boundary is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![An example – logistic regression](img/image01178.jpeg)![An example – logistic
    regression](img/image01179.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Height and weight data (shifted by the mean and rescaled by the standard deviation).
    The orange line is the logistic regression decision boundary. Logistic regression
    predicts that individuals above the boundary are male.
  prefs: []
  type: TYPE_NORMAL
- en: Towards re-usable code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we performed all of the computation in a single script.
    While this is fine for data exploration, it means that we cannot reuse the logistic
    regression code that we have built. In this section, we will start the construction
    of a machine learning library that you can reuse across different projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will factor the logistic regression algorithm out into its own class. We
    construct a `LogisticRegression` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: The class takes, as input, a matrix representing the training set and a vector
    denoting the target variable. Notice how we assign these to `vals`, meaning that
    they are set on class creation and will remain the same until the class is destroyed.
    Of course, the `DenseMatrix` and `DenseVector` objects are mutable, so the values
    that `training` and `target` point to might change. Since programming best practice
    dictates that mutable state makes reasoning about program behavior difficult,
    we will avoid taking advantage of this mutability.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add a method that calculates the cost function and its gradient:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'We are now all set up to run the optimization to calculate the coefficients
    that best reproduce the training set. In traditional object-oriented languages,
    we might define a `getOptimalCoefficients` method that returns a `DenseVector`
    of the coefficients. Scala, however, is more elegant. Since we have defined the
    `training` and `target` attributes as `vals`, there is only one possible set of
    values of the optimal coefficients. We could, therefore, define a `val optimalCoefficients
    = ???` class attribute that holds the optimal coefficients. The problem with this
    is that it forces all the computation to happen when the instance is constructed.
    This will be unexpected for the user and might be wasteful: if the user is only
    interested in accessing the cost function, for instance, the time spent minimizing
    it will be wasted. The solution is to use a `lazy val`. This value will only be
    evaluated when the client code requests it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'To help with the calculation of the coefficients, we will define a private
    helper method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: We have refactored the logistic regression into its own class, that we can reuse
    across different projects.
  prefs: []
  type: TYPE_NORMAL
- en: If we were planning on reusing the height-weight data, we could, similarly,
    refactor it into a class of its own that facilitates data loading, feature scaling,
    and any other functionality that we find ourselves reusing often.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatives to Breeze
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Breeze is the most feature-rich and approachable Scala framework for linear
    algebra and numeric computation. However, do not take my word for it: experiment
    with other libraries for tabular data. In particular, I recommend trying *Saddle*,
    which provides a `Frame` object similar to data frames in pandas or R. In the
    Java world, the *Apache Commons Maths library* provides a very rich toolkit for
    numerical computation. In [Chapter 10](part0097.xhtml#aid-2SG6I1 "Chapter 10. Distributed
    Batch Processing with Spark"), *Distributed Batch Processing with Spark*, [Chapter
    11](part0106.xhtml#aid-352RK2 "Chapter 11. Spark SQL and DataFrames"), *Spark
    SQL and DataFrames*, and [Chapter 12](part0117.xhtml#aid-3FIHQ2 "Chapter 12. Distributed
    Machine Learning with MLlib"), *Distributed Machine Learning with MLlib*, we will
    explore *Spark* and *MLlib*, which allow the user to run distributed machine learning
    algorithms.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This concludes our brief overview of Breeze. We have learned how to manipulate
    basic Breeze data types, how to use them for linear algebra, and how to perform
    convex optimization. We then used our knowledge to clean a real dataset and performed
    logistic regression on it.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss breeze-viz, a plotting library for Scala.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*The Elements of Statistical Learning*, by *Hastie*, *Tibshirani*, and *Friedman*,
    gives a lucid, practical description of the mathematical underpinnings of machine
    learning. Anyone aspiring to do more than mindlessly apply machine learning algorithms
    as black boxes ought to have a well-thumbed copy of this book.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Scala for Machine Learning*, by *Patrick R. Nicholas*, describes practical
    implementations of many useful machine learning algorithms in Scala.'
  prefs: []
  type: TYPE_NORMAL
- en: The Breeze documentation ([https://github.com/scalanlp/breeze/wiki/Quickstart](https://github.com/scalanlp/breeze/wiki/Quickstart)),
    API docs ([http://www.scalanlp.org/api/breeze/#package](http://www.scalanlp.org/api/breeze/#package)),
    and source code ([https://github.com/scalanlp/breeze](https://github.com/scalanlp/breeze))
    provide the most up-to-date sources of documentation on Breeze.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 3. Plotting with breeze-viz
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Data visualization is an integral part of data science. Visualization needs
    fall into two broad categories: during the development and validation of new models
    and, at the end of the pipeline, to distill meaning from the data and the models
    to provide insight to external stakeholders.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The two types of visualizations are quite different. At the data exploration
    and model development stage, the most important feature of a visualization library
    is its ease of use. It should take as few steps as possible to go from having
    data as arrays of numbers (or CSVs or in a database) to having data displayed
    on a screen. The lifetime of graphs is also quite short: once the data scientist
    has learned all he can from the graph or visualization, it is normally discarded.
    By contrast, when developing visualization widgets for external stakeholders,
    one is willing to tolerate increased development time for greater flexibility.
    The visualizations can have significant lifetime, especially if the underlying
    data changes over time.'
  prefs: []
  type: TYPE_NORMAL
- en: The tool of choice in Scala for the first type of visualization is breeze-viz.
    When developing visualizations for external stakeholders, web-based visualizations
    (such as D3) and Tableau tend to be favored.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will explore breeze-viz. In [Chapter 14](part0139.xhtml#aid-44HU61
    "Chapter 14. Visualization with D3 and the Play Framework"), *Visualization with
    D3 and the Play Framework*, we will learn how to build Scala backends for JavaScript
    visualizations.
  prefs: []
  type: TYPE_NORMAL
- en: Breeze-viz is (no points for guessing) Breeze's visualization library. It wraps
    **JFreeChart**, a very popular Java charting library. Breeze-viz is still very
    experimental. In particular, it is much less feature-rich than matplotlib in Python,
    or R or MATLAB. Nevertheless, breeze-viz allows access to the underlying JFreeChart
    objects so one can always fall back to editing these objects directly. The syntax
    for breeze-viz is inspired by MATLAB and matplotlib.
  prefs: []
  type: TYPE_NORMAL
- en: Diving into Breeze
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s get started. We will work in the Scala console, but a program similar
    to this example is available in `BreezeDemo.scala` in the examples corresponding
    to this chapter. Create a `build.sbt` file with the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Start an `sbt` console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s start by plotting a sigmoid curve, ![Diving into Breeze](img/image01180.jpeg).
    We will first generate the data using Breeze. Recall that the `linspace` method
    creates a vector of doubles, uniformly distributed between two values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have the data ready for plotting. The first step is to create a figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates an empty Java Swing window (which may appear on your taskbar or
    equivalent). A figure can contain one or more plots. Let''s add a plot to our
    figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'For now, let''s ignore the `0` passed as argument to `.subplot`. We can add
    data points to our `plot`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'The `plot` function takes two arguments, corresponding to the *x* and *y* values
    of the data series to be plotted. To view the changes, you need to refresh the
    figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'Look at the Swing window now. You should see a beautiful sigmoid, similar to
    the one below. Right-clicking on the window lets you interact with the plot and
    save the image as a PNG:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Diving into Breeze](img/image01181.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can also save the image programmatically as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: Breeze-viz currently only supports exporting to PNG.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing plots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We now have a curve on our chart. Let''s add a few more:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Looking at the figure now, you should see all three curves in different colors.
    Notice that we named the data series as we added them to the plot, using the `name=""`
    keyword argument. To view the names, we must set the `legend` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '![Customizing plots](img/image01182.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Our plot still leaves a lot to be desired. Let''s start by restricting the
    range of the *x* axis to remove the bands of white space on either side of the
    plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, notice how, while the *x* ticks are sensibly spaced, there are only two
    *y* ticks: at *0* and *1*. It would be useful to have ticks every *0.1* increment.
    Breeze does not provide a way to set this directly. Instead, it exposes the underlying
    JFreeChart Axis object belonging to the current plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Axis` object supports a `.setTickUnit` method that lets us set the tick
    spacing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: JFreeChart allows extensive customization of the `Axis` object. For a full list
    of methods available, consult the JFreeChart documentation ([http://www.jfree.org/jfreechart/api/javadoc/org/jfree/chart/axis/Axis.html](http://www.jfree.org/jfreechart/api/javadoc/org/jfree/chart/axis/Axis.html)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s also add a vertical line at *x=0* and a horizontal line at *f(x)=1*.
    We will need to access the underlying JFreeChart plot to add these lines. This
    is available (somewhat confusingly) as the `.plot` attribute in our Breeze `Plot`
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the `.addDomainMarker` and `.addRangeMarker` methods to add vertical
    and horizontal lines to JFreeChart `XYPlot` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s also add labels to the axes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have run all these commands, you should have a graph that looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Customizing plots](img/image01183.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We now know how to customize the basic building blocks of a graph. The next
    step is to learn how to change how curves are drawn.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing the line type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have just plotted lines using the default settings. Breeze lets us
    customize how lines are drawn, at least to some extent.
  prefs: []
  type: TYPE_NORMAL
- en: For this example, we will use the height-weight data discussed in [Chapter 2](part0018.xhtml#aid-H5A41
    "Chapter 2. Manipulating Data with Breeze"), *Manipulating Data with Breeze*.
    We will use the Scala shell here for demonstrative purposes, but you will find
    a program in `BreezeDemo.scala` that follows the example shell session.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code examples for this chapter come with a module for loading the data,
    `HWData.scala`, that loads the data from the CSVs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create a scatter plot of the heights against the weights:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'This produces a scatter-plot of the height-weight data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Customizing the line type](img/image01184.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Note that we passed a third argument to the `plot` method, `''+''`. This controls
    the plotting style. As of this writing, there are three available styles: `''-''`
    (the default), `''+''`, and `''.''`. Experiment with these to see what they do.
    Finally, we pass a `colorcode="black"` argument to control the color of the line.
    This is either a color name or an RGB triple, written as a string. Thus, to plot
    red points, we could have passed `colorcode="[255,0,0]"`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at the height-weight plot, there is clearly a trend between height
    and weight. Let''s try and fit a straight line through the data points. We will
    fit the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Customizing the line type](img/image01185.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Scientific literature suggests that it would be better to fit something more
    like ![Customizing the line type](img/image01186.jpeg). You should find it straightforward
    to fit a quadratic line to the data, should you wish to.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use Breeze''s least squares function to find the values of `a` and
    `b`. The `leastSquares` method expects an input matrix of features and a target
    vector, just like the `LogisticRegression` class that we defined in the previous
    chapter. Recall that in [Chapter 2](part0018.xhtml#aid-H5A41 "Chapter 2. Manipulating
    Data with Breeze"), *Manipulating Data with Breeze*, when we prepared the training
    set for logistic regression classification, we introduced a dummy feature that
    was one for every participant to provide the degree of freedom for the *y* intercept.
    We will use the same approach here. Our feature matrix, therefore, contains two
    columns—one that is `1` everywhere and one for the height:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'The `leastSquares` method returns an instance of `LeastSquareRegressionResult`,
    which contains a `coefficients` attribute containing the coefficients that best
    fit the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'The best-fit line is therefore:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Customizing the line type](img/image01187.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s extract the coefficients. An elegant way of doing this is to use Scala''s
    pattern matching capabilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: By writing `val Array(a, b) = ...`, we are telling Scala that the right-hand
    side of the expression is a two-element array and to bind the first element of
    that array to the value `a` and the second to the value `b`. See [Appendix](part0149.xhtml#aid-4E33Q2
    "Appendix A. Pattern Matching and Extractors"), *Pattern Matching and Extractors*,
    for a discussion of pattern matching.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now add the best-fit line to our graph. We start by generating evenly-spaced
    dummy height values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s also add the equation for the best-fit line to the graph as an annotation.
    We will first generate the label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'To add an annotation, we must access the underlying JFreeChart plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'The `XYTextAnnotation` constructor takes three parameters: the annotation string
    and a pair of (*x*, *y*) coordinates defining the centre of the annotation on
    the graph. The coordinates of the annotation are expressed in the coordinate system
    of the data. Thus, calling `new XYTextAnnotation(label, 175.0, 105.0)` generates
    an annotation whose centroid is at the point corresponding to a height of 175
    cm and weight of 105 kg:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Customizing the line type](img/image01188.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: More advanced scatter plots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Breeze-viz offers a `scatter` function that adds a significant degree of customization
    to scatter plots. In particular, we can use the size and color of the marker points
    to add additional dimensions of information to the plot.
  prefs: []
  type: TYPE_NORMAL
- en: The `scatter` function takes, as its first two arguments, collections of *x*
    and *y* points. The third argument is a function mapping an integer `i` to a `Double`
    indicating the size of the *ith* point. The size of the point is measured in units
    of the *x* axis. If you have the sizes as a Scala collection or a Breeze vector,
    you can use that collection's `apply` method as the function. Let's see how this
    works in practice.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with the previous examples, we will use the REPL, but you can find a sample
    program in `BreezeDemo.scala`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'Selecting custom colors works in a similar manner: we pass in a `colors` argument
    that maps an integer index to a `java.awt.Paint` object. Using these directly
    can be cumbersome, so Breeze provides some default palettes. For instance, the
    `GradientPaintScale` maps doubles in a given domain to a uniform color gradient.
    Let''s map doubles in the range `0.0` to `1.0` to the colors between red and green:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'Besides the `GradientPaintScale`, breeze-viz provides a `CategoricalPaintScale`
    class for categorical palettes. For an overview of the different palettes, consult
    the source file `PaintScale.scala` at `scala`: [https://github.com/scalanlp/breeze/blob/master/viz/src/main/scala/breeze/plot/PaintScale.scala](https://github.com/scalanlp/breeze/blob/master/viz/src/main/scala/breeze/plot/PaintScale.scala).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use our newfound knowledge to draw a multicolor scatter plot. We will
    assume the same initialization as the previous example. We will assign a random
    color to each point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '![More advanced scatter plots](img/image01189.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Multi-plot example – scatterplot matrix plots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will learn how to have several plots in the same figure.
  prefs: []
  type: TYPE_NORMAL
- en: 'The key new method that allows multiple plots in the same figure is `fig.subplot(nrows,
    ncols, plotIndex)`. This method, an overloaded version of the `fig.subplot` method
    we have been using up to now, both sets the number of rows and columns in the
    figure and returns a specific subplot. It takes three arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`nrows`: The number of rows of subplots in the figure'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ncols`: The number of columns of subplots in the figure'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`plotIndex`: The index of the plot to return'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Users familiar with MATLAB or matplotlib will note that the `.subplot` method
    is identical to the eponymous methods in these frameworks. This might seem a little
    complex, so let''s look at an example (you will find the code for this in `BreezeDemo.scala`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this example produces the following plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Multi-plot example – scatterplot matrix plots](img/image01190.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now that we have a basic grasp of how to add several subplots to the same figure,
    let's do something a little more interesting. We will write a class to draw scatterplot
    matrices. These are useful for exploring correlations between different features.
  prefs: []
  type: TYPE_NORMAL
- en: If you are not familiar with scatterplot matrices, have a look at the figure
    at the end of this section for an idea of what we are constructing. The idea is
    to build a square matrix of scatter plots for each pair of features. Element (*i*,
    *j*) in the matrix is a scatter plot of feature *i* against feature *j*. Since
    a scatter plot of a variable against itself is of limited use, one normally draws
    histograms of each feature along the diagonal. Finally, since a scatter plot of
    feature *i* against feature *j* contains the same information as a scatter plot
    of feature *j* against feature *i*, one normally only plots the upper triangle
    or the lower triangle of the matrix.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by writing functions for the individual plots. These will take
    a `Plot` object referencing the correct subplot and vectors of the data to plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: Notice the use of `hist(data)` to draw a histogram. The argument to `hist` must
    be a vector of data points. The `hist` method will bin these and represent them
    as a histogram.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the machinery for drawing individual plots, we just need to
    wire everything together. The tricky part is to know how to select the correct
    subplot for a given row and column position in the matrix. We can select a single
    plot by calling `fig.subplot(nrows, ncolumns, plotIndex)`, but translating from
    a (*row*, *column*) index pair to a single `plotIndex` is not obvious. The plots
    are numbered in increasing order, first from left to right, then from top to bottom:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s write a short function to select a plot at a (*row*, *column*) index
    pair:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'We are now in a position to draw the matrix plot itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s write an example for our class. We will use the height-weight data again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this through SBT produces the following plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Multi-plot example – scatterplot matrix plots](img/image01191.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Managing without documentation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Breeze-viz is unfortunately rather poorly documented. This can make the learning
    curve somewhat steep. Fortunately, it is still quite a small project: at the time
    of writing, there are just ten source files ([https://github.com/scalanlp/breeze/tree/master/viz/src/main/scala/breeze/plot](https://github.com/scalanlp/breeze/tree/master/viz/src/main/scala/breeze/plot)).
    A good way to understand exactly what breeze-viz does is to read the source code.
    For instance, to see what methods are available on a `Plot` object, read the source
    file `Plot.scala`. If you need functionality beyond that provided by Breeze, consult
    the documentation for JFreeChart to discover if you can implement what you need
    by accessing the underlying JFreeChart objects.'
  prefs: []
  type: TYPE_NORMAL
- en: Breeze-viz reference
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Writing a reference in a programming book is a dangerous exercise: you quickly
    become out of date. Nevertheless, given the paucity of documentation for breeze-viz,
    this section becomes more relevant – it is easier to compete against something
    that does not exist. Take this section with a pinch of salt, and if a command
    in this section does not work, head over to the source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Command | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `plt += plot(xs, ys)` | This plots a series of (`xs`, `ys`) values. The `xs`
    and `ys` values must be collection-like objects (Breeze vectors, Scala arrays,
    or lists, for instance). |'
  prefs: []
  type: TYPE_TB
- en: '| `plt += scatter(xs, ys, size)``plt += scatter(xs, ys, size, color)` | This
    plots a series of (`xs`, `ys`) values as a scatter plot. The `size` argument is
    an `(Int) => Double` function mapping the index of a point to its size (in the
    same units as the *x* axis). The `color` argument is an `(Int) => java.awt.Paint`
    function mapping from integers to colors. Read the *more advanced scatter plots*
    section for further details. |'
  prefs: []
  type: TYPE_TB
- en: '| `plt += hist(xs)``plt += hist(xs, bins=10)` | This bins `xs` and plots a
    histogram. The `bins` argument controls the number of bins. |'
  prefs: []
  type: TYPE_TB
- en: '| `plt += image(mat)` | This plots an image or matrix. The `mat` argument should
    be `Matrix[Double]`. Read the `package.scala` source file in `breeze.plot` for
    details ([https://github.com/scalanlp/breeze/blob/master/viz/src/main/scala/breeze/plot/package.scala](https://github.com/scalanlp/breeze/blob/master/viz/src/main/scala/breeze/plot/package.scala)).
    |'
  prefs: []
  type: TYPE_TB
- en: 'It is also useful to summarize the options available on a `plot` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Attribute | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `plt.xlabel = "x-label"``plt.ylabel = "y-label"` | This sets the axis label
    |'
  prefs: []
  type: TYPE_TB
- en: '| `plt.xlim = (0.0, 1.0)``plt.ylim = (0.0, 1.0)` | This sets the axis maximum
    and minimum value |'
  prefs: []
  type: TYPE_TB
- en: '| `plt.logScaleX = true``plt.logScaleY = true` | This switches the axis to
    a log scale |'
  prefs: []
  type: TYPE_TB
- en: '| `plt.title = "title"` | This sets the plot title |'
  prefs: []
  type: TYPE_TB
- en: Data visualization beyond breeze-viz
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Other tools for data visualization in Scala are emerging: Spark notebooks ([https://github.com/andypetrella/spark-notebook#description](https://github.com/andypetrella/spark-notebook#description))
    based on the IPython notebook and Apache Zeppelin ([https://zeppelin.incubator.apache.org](https://zeppelin.incubator.apache.org)).
    Both of these rely on Apache Spark, which we will explore later in this book.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to draw simple charts with breeze-viz. In the
    last chapter of this book, we will learn how to build interactive visualizations
    using JavaScript libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will learn about basic Scala concurrency constructs—specifically, parallel
    collections.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 4. Parallel Collections and Futures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data science often involves processing medium or large amounts of data. Since
    the previously exponential growth in the speed of individual CPUs has slowed down
    and the amount of data continues to increase, leveraging computers effectively
    must entail parallel computation.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will look at ways of parallelizing computation and data
    processing over a single computer. Virtually all new computers have more than
    one processing unit, and distributing a calculation over these cores can be an
    effective way of hastening medium-sized calculations.
  prefs: []
  type: TYPE_NORMAL
- en: Parallelizing calculations over a single chip is suitable for calculations involving
    gigabytes or a few terabytes of data. For larger data flows, we must resort to
    distributing the computation over several computers in parallel. We will discuss
    Apache Spark, a framework for parallel data processing in [Chapter 10](part0097.xhtml#aid-2SG6I1
    "Chapter 10. Distributed Batch Processing with Spark"), *Distributed Batch Processing
    with Spark*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this book, we will look at three common ways of leveraging parallel architectures
    in a single machine: parallel collections, futures, and actors. We will consider
    the first two in this chapter, and leave the study of actors to [Chapter 9](part0077.xhtml#aid-29DRA1
    "Chapter 9. Concurrency with Akka"), *Concurrency with Akka*.'
  prefs: []
  type: TYPE_NORMAL
- en: Parallel collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Parallel collections offer an extremely easy way to parallelize independent
    tasks. The reader, being familiar with Scala, will know that many tasks can be
    phrased as operations on collections, such as *map*, *reduce*, *filter*, or *groupBy*.
    Parallel collections are an implementation of Scala collections that parallelize
    these operations to run over several threads.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with an example. We want to calculate the frequency of occurrence
    of each letter in a sentence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s start by converting our sentence from a string to a vector of characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now convert `characters` to a *parallel* vector, a `ParVector`. To do
    this, we use the `par` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: '`ParVector` collections support the same operations as regular vectors, but
    their methods are executed in parallel over several threads.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by filtering out the spaces in `charactersPar`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: Notice how Scala hides the execution details. The `filter` operation was performed
    using multiple threads, and you barely even noticed! The interface and behavior
    of a parallel vector is identical to its serial counterpart, save for a few details
    that we will explore in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now use the `toLower` function to make the letters lowercase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'As before, the `map` method was applied in parallel. To find the frequency
    of occurrence of each letter, we use the `groupBy` method to group characters
    into vectors containing all the occurrences of that character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'Note how the `groupBy` method has created a `ParMap` instance, the parallel
    equivalent of an immutable map. To get the number of occurrences of each letter,
    we do a `mapValues` call on `intermediateMap`, replacing each vector by its length:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: Congratulations! We've written a multi-threaded algorithm for finding the frequency
    of occurrence of each letter in a few lines of code. You should find it straightforward
    to adapt this to find the frequency of occurrence of each word in a document,
    a common preprocessing problem for analyzing text data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parallel collections make it very easy to parallelize some operation pipelines:
    all we had to do was call `.par` on the `characters` vector. All subsequent operations
    were parallelized. This makes switching from a serial to a parallel implementation
    very easy.'
  prefs: []
  type: TYPE_NORMAL
- en: Limitations of parallel collections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Part of the power and the appeal of parallel collections is that they present
    the same interface as their serial counterparts: they have a `map` method, a `foreach`
    method, a `filter` method, and so on. By and large, these methods work in the
    same way on parallel collections as they do in serial. There are, however, some
    notable caveats. The most important one has to do with side effects. If an operation
    on a parallel collection has a side effect, this may result in a race condition:
    a situation in which the final result depends on the order in which the threads
    perform their operations.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Side effects in collections arise most commonly when we update a variable defined
    outside of the collection. To give a trivial example of unexpected behavior, let''s
    define a `count` variable and increment it a thousand times using a parallel range:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'What happened here? The function passed to `foreach` has a side effect: it
    increments `count`, a variable outside of the scope of the function. This is a
    problem because the `+=` operator is a sequence of two operations:'
  prefs: []
  type: TYPE_NORMAL
- en: Retrieve the value of `count` and add one to it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assign the result back to `count`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To understand why this causes unexpected behavior, let''s imagine that the
    `foreach` loop has been parallelized over two threads. **Thread A** might read
    the **count** variable when it is **832** and add one to it to give **833**. Before
    it has time to reassign **833** to **count**, **Thread B** reads **count**, still
    at **832**, and adds one to give **833**. **Thread A** then assigns **833** to
    **count**. **Thread B** then assigns **833** to **count**. We''ve run through
    two updates but only incremented the count by one. The problem arises because
    `+=` can be separated into two instructions: it is not *atomic*. This leaves room
    for threads to interleave their operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Limitations of parallel collections](img/image01192.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The anatomy of a race condition: both thread A and thread B are trying to update
    `count` concurrently, resulting in one of the updates being overwritten. The final
    value of `count` is 833 instead of 834.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To give a somewhat more realistic example of problems caused by non-atomicity,
    let''s look at a different method for counting the frequency of occurrence of
    each letter in our sentence. We define a mutable `Char -> Int` hash map outside
    of the loop. Each time we encounter a letter, we increment the corresponding integer
    in the map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: The discrepancy occurs because of the non-atomicity of the operations in the
    `foreach` loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, it is good practice to avoid side effects in higher-order functions
    on collections. They make the code harder to understand and preclude switching
    from serial to parallel collections. It is also good practice to avoid exposing
    mutable state: immutable objects can be shared freely between threads and cannot
    be affected by side effects.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another limitation of parallel collections occurs in reduction (or folding)
    operations. The function used to combine items together must be *associative*.
    For instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'The *minus* operator, `–`, is not associative. The order in which consecutive
    operations are applied matters: `(a – b) – c` is not the same as `a – (b – c)`.
    The function used to reduce a parallel collection must be associative because
    the order in which the reduction occurs is not tied to the order of the collection.'
  prefs: []
  type: TYPE_NORMAL
- en: Error handling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In single-threaded programs, exception handling is relatively straightforward:
    if an exception occurs, the function can either handle it or escalate it. This
    is not nearly as obvious when parallelism is introduced: a single thread might
    fail, but the others might return successfully.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Parallel collection methods will throw an exception if they fail on any element,
    just like their serial counterparts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: There are cases when this isn't the behavior that we want. For instance, we
    might be using a parallel collection to retrieve a large number of web pages in
    parallel. We might not mind if a few of the pages cannot be fetched.
  prefs: []
  type: TYPE_NORMAL
- en: 'Scala''s `Try` type was designed for sandboxing code that might throw exceptions.
    It is similar to `Option` in that it is a one-element container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: 'Unlike the `Option` type, which indicates whether an expression has a useful
    value, the `Try` type indicates whether an expression can be executed without
    throwing an exception. It takes on the following two values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Try { 2 + 2 } == Success(4)` if the expression in the `Try` statement is evaluated
    successfully'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Try { 2 / 0 } == Failure(java.lang.ArithmeticException: / by zero)` if the
    expression in the `Try` block results in an exception'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This will make more sense with an example. To see the `Try` type in action,
    we will try to fetch web pages in a fault tolerant manner. We will use the built-in
    `Source.fromURL` method which fetches a web page and opens an iterator of the
    page''s content. If it fails to fetch the web page, it throws an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of letting the expression propagate out and crash the rest of our code,
    we can wrap the call to `Source.fromURL` in `Try`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: 'To see the power of our `Try` statement, let''s now retrieve a list of URLs
    in parallel in a fault tolerant manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then use a `collect` statement to act on the pages we could fetch successfully.
    For instance, to get the number of characters on each page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: By making good use of Scala's built-in `Try` classes and parallel collections,
    we have built a fault tolerant, multithreaded URL retriever in a few lines of
    code. (Compare this to the myriad of Java/C++ books that prefix code examples
    with 'error handling is left out for clarity'.)
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**The Try type versus try/catch statements**'
  prefs: []
  type: TYPE_NORMAL
- en: Programmers with imperative or object-oriented backgrounds will be more familiar
    with try/catch blocks for handling exceptions. We could have accomplished similar
    functionality here by wrapping the code for fetching URLs in a try block, returning
    null if the call raises an exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, besides being more verbose, returning null is less satisfactory: we
    lose all information about the exception and null is less expressive than `Failure(exception)`.
    Furthermore, returning a `Try[T]` type forces the caller to consider the possibility
    that the function might fail, by encoding this possibility in the type of the
    return value. In contrast, just returning `T` and coding failure with a null value
    allows the caller to ignore failure, raising the possibility of a confusing `NullPointerException`
    being thrown at a completely different point in the program.'
  prefs: []
  type: TYPE_NORMAL
- en: In short, `Try[T]` is just another higher-order type, like `Option[T]` or `List[T]`.
    Treating the possibility of failure in the same way as the rest of the code adds
    coherence to the program and encourages programmers to tackle the possibility
    of exceptions explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the parallelism level
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far, we have considered parallel collections as black boxes: add `par` to
    a normal collection and all the operations are performed in parallel. Often, we
    will want more control over how the tasks are executed.'
  prefs: []
  type: TYPE_NORMAL
- en: Internally, parallel collections work by distributing an operation over multiple
    threads. Since the threads share memory, parallel collections do not need to copy
    any data. Changing the number of threads available to the parallel collection
    will change the number of CPUs that are used to perform the tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parallel collections have a `tasksupport` attribute that controls task execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: The task support object of a collection is an *execution context*, an abstraction
    capable of executing Scala expressions in a separate thread. By default, the execution
    context in Scala 2.11 is a *work-stealing thread pool*. When a parallel collection
    submits tasks, the context allocates these tasks to its threads. If a thread finds
    that it has finished its queued tasks, it will try and steal outstanding tasks
    from the other threads. The default execution context maintains a thread pool
    with number of threads equal to the number of CPUs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The number of threads over which the parallel collection distributes the work
    can be changed by changing the task support. For instance, to parallelize the
    operations performed by a range over four threads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: An example – cross-validation with parallel collections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's apply what you have learned so far to solve data science problems. There
    are many parts of a machine learning pipeline that can be parallelized trivially.
    One such part is cross-validation.
  prefs: []
  type: TYPE_NORMAL
- en: We will give a brief description of cross-validation here, but you can refer
    to *The Elements of Statistical Learning*, by *Hastie*, *Tibshirani*, and *Friedman*
    for a more in-depth discussion.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, a supervised machine learning problem involves training an algorithm
    over a training set. For instance, when we built a model to calculate the probability
    of a person being male based on their height and weight, the training set was
    the (height, weight) data for each participant, together with the male/female
    label for each row. Once the algorithm is trained on the training set, we can
    use it to classify new data. This process only really makes sense if the training
    set is representative of the new data that we are likely to encounter.
  prefs: []
  type: TYPE_NORMAL
- en: The training set has a finite number of entries. It will thus, inevitably, have
    idiosyncrasies that are not representative of the population at large, merely
    due to its finite nature. These idiosyncrasies will result in prediction errors
    when predicting whether a new person is male or female, over and above the prediction
    error of the algorithm on the training set itself. Cross-validation is a tool
    for estimating the error caused by the idiosyncrasies of the training set that
    do not reflect the population at large.
  prefs: []
  type: TYPE_NORMAL
- en: 'Cross-validation works by dividing the training set in two parts: a smaller,
    new training set and a cross-validation set. The algorithm is trained on the reduced
    training set. We then see how well the algorithm models the cross-validation set.
    Since we know the right answer for the cross-validation set, we can measure how
    well our algorithm is performing when shown new information. We repeat this procedure
    many times with different cross-validation sets.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several different types of cross-validation, which differ in how
    we choose the cross-validation set. In this chapter, we will look at repeated
    random subsampling: we select *k* rows at random from the training data to form
    the cross-validation set. We do this many times, calculating the cross-validation
    error for each subsample. Since each iteration is independent of the previous
    ones, we can parallelize this process trivially. It is therefore a good candidate
    for parallel collections. We will look at an alternative form of cross-validation,
    *k-fold cross-validation*, in [Chapter 12](part0117.xhtml#aid-3FIHQ2 "Chapter 12. Distributed
    Machine Learning with MLlib"), *Distributed Machine Learning with MLlib*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will build a class that performs cross-validation in parallel. I encourage
    you to write the code as you go, but you will find the source code corresponding
    to these examples on GitHub ([https://github.com/pbugnion/s4ds](https://github.com/pbugnion/s4ds)).We
    will use parallel collections to handle the parallelism and Breeze data types
    in the inner loop. The `build.sbt` file is identical to the one we used in [Chapter
    2](part0018.xhtml#aid-H5A41 "Chapter 2. Manipulating Data with Breeze") , *Manipulating
    Data with Breeze*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: 'We will build a `RandomSubsample` class. The class exposes a type alias, `CVFunction`,
    for a function that takes two lists of indices—the first corresponding to the
    reduced training set and the second to the validation set—and returns a `Double`
    corresponding to the cross-validation error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: 'The `RandomSubsample` class will expose a single method, `mapSamples`, which
    takes a `CVFunction`, repeatedly passes it different partitions of indices, and
    returns a vector of the errors. This is what the class looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at what happens in more detail, starting with the arguments passed
    to the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: We pass the total number of elements in the training set and the number of elements
    to leave out for cross-validation in the class constructor. Thus, passing 100
    to `nElems` and 20 to `nCrossValidation` implies that our training set will have
    80 random elements of the total data and that the test set will have 20 elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then construct a list of all integers between `0` and `nElems`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: For each iteration of the cross-validation, we will shuffle this list and take
    the first `nCrossValidation` elements to be the indices of rows in our test set
    and the remaining to be the indices of rows in our training set.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our class exposes a single method, `mapSamples`, that takes two curried arguments:
    `nShuffles`, the number of times to perform random subsampling, and `f`, a `CVFunction`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: 'With all this set up, the code for doing cross-validation is deceptively simple.
    We generate a parallel range from `0` to `nShuffles` and, for each item in the
    range, generate a new train-test split and calculate the cross-validation error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: The only tricky part of this function is splitting the shuffled index list into
    a list of indices for the training set and a list of indices for the test set.
    We use Breeze's `split` method. This takes a vector as its first argument and
    a list of split-points as its second, and returns a list of fragments of the original
    vector. We then use pattern matching to extract the individual parts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, `mapSamples` converts `cvResults` to a Breeze vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see this in action. We can test our class by running cross-validation
    on the logistic regression example developed in [Chapter 2](part0018.xhtml#aid-H5A41
    "Chapter 2. Manipulating Data with Breeze") , *Manipulating Data with Breeze*.
    In that chapter, we developed a `LogisticRegression` class that takes a training
    set (in the form of a `DenseMatrix`) and target (in the form of a `DenseVector`)
    at construction time. The class then calculates the parameters that best represent
    the training set. We will first add two methods to the `LogisticRegression` class
    to use the trained model to classify previously unseen examples:'
  prefs: []
  type: TYPE_NORMAL
- en: The `predictProbabilitiesMany` method uses the trained model to calculate the
    probability of having the target variable set to one. In the context of our example,
    this is the probability of being male, given a height and weight.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `classifyMany` method assigns classification labels (one or zero) to members
    of a test set. We will assign a one if `predictProbabilitiesMany` returns a value
    greater than `0.5`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With these two functions, our `LogisticRegression` class becomes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: We can now put together an example program for our `RandomSubsample` class.
    We will use the same height-weight data as in [Chapter 2](part0018.xhtml#aid-H5A41
    "Chapter 2. Manipulating Data with Breeze") , *Manipulating Data with Breeze*.
    The data preprocessing will be similar. The code examples for this chapter provide
    a helper module, `HWData`, to load the height-weight data into Breeze vectors.
    The data itself is in the `data/` directory of the code examples for this chapter
    (available on GitHub at [https://github.com/pbugnion/s4ds/tree/master/chap04](https://github.com/pbugnion/s4ds/tree/master/chap04)).
  prefs: []
  type: TYPE_NORMAL
- en: 'For each new subsample, we create a new `LogisticRegression` instance, train
    it on the subset of the training set to get the best coefficients for this train-test
    split, and use `classifyMany` to generate predictions on the cross-validation
    set in this split. We then calculate the classification error and report the average
    classification error over every train-test split:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: Running this program on the height-weight data gives a classification error
    of 10%.
  prefs: []
  type: TYPE_NORMAL
- en: We now have a fully working, parallelized cross-validation class. Scala's parallel
    range made it simple to repeatedly compute the same function in different threads.
  prefs: []
  type: TYPE_NORMAL
- en: Futures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Parallel collections offer a simple, yet powerful, framework for parallel operations.
    However, they are limited in one respect: the total amount of work must be known
    in advance, and each thread must perform the same function (possibly on different
    inputs).'
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that we want to write a program that fetches a web page (or queries
    a web API) every few seconds and extracts data for further processing from this
    web page. A typical example might involve querying a web API to maintain an up-to-date
    value of a particular stock price. Fetching data from an external web page takes
    a few hundred milliseconds, typically. If we perform this operation on the main
    thread, it will needlessly waste CPU cycles waiting for the web server to reply.
  prefs: []
  type: TYPE_NORMAL
- en: The solution is to wrap the code for fetching the web page in a *future*. A
    future is a one-element container containing the future result of a computation.
    When you create a future, the computation in it gets off-loaded to a different
    thread in order to avoid blocking the main thread. When the computation finishes,
    the result is written to the future and thus made accessible to the main thread.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, we will write a program that queries the "Markit on demand"
    API to fetch the price of a given stock. For instance, the URL for the current
    price of a Google share is [http://dev.markitondemand.com/MODApis/Api/v2/Quote?symbol=GOOG](http://dev.markitondemand.com/MODApis/Api/v2/Quote?symbol=GOOG).
    Go ahead and paste this in the address box of your web browser. You will see an
    XML string appear with, among other things, the current stock price. Let''s fetch
    this programmatically without resorting to a future first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice how it takes a little bit of time to query the API. Let''s now do the
    same, but using a future (don''t worry about the imports for now, we will discuss
    what they mean in more detail further on):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run this, you will notice that control returns to the shell instantly
    before the API has had a chance to respond. To make this evident, let''s simulate
    a slow connection by adding a call to `Thread.sleep`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run this, you do not have to wait for ten seconds for the next prompt
    to appear: you regain control of the shell straightaway. The bit of code in the
    future is executed asynchronously: its execution is independent of the main program
    flow.'
  prefs: []
  type: TYPE_NORMAL
- en: 'How do we retrieve the result of the computation? We note that `response` has
    type `Future[String]`. We can check whether the computation wrapped in the future
    has finished by querying the future''s `isCompleted` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: 'The future exposes a `value` attribute that contains the computation result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: The `value` attribute of a future has type `Option[Try[T]]`. We have already
    seen how to use the `Try` type to handle exceptions gracefully in the context
    of parallel collections. It is used in the same way here. A future's `value` attribute
    is `None` until the future is complete, then it is set to `Some(Success(value))`
    if the future ran successfully, or `Some(Failure(error))` if an exception was
    thrown.
  prefs: []
  type: TYPE_NORMAL
- en: 'Repeatedly calling `f.value` until the future completes works well in the shell,
    but it does not generalize to more complex programs. Instead, we want to tell
    the computer to do something once the future is complete: we want to bind a *callback*
    function to the future. We can do this by setting the future''s `onComplete` attribute.
    Let''s tell the future to print the API response when it completes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: The function passed to `onComplete` runs when the future is finished. It takes
    a single argument of type `Try[T]` containing the result of the future.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Failure is normal: how to build resilient applications**'
  prefs: []
  type: TYPE_NORMAL
- en: By wrapping the output of the code that it runs in a `Try` type, futures force
    the client code to consider the possibility that the code might fail. The client
    can isolate the effect of failure to avoid crashing the whole application. They
    might, for instance, log the exception. In the case of a web API query, they might
    add the offending URL to be queried again at a later date. In the case of a database
    failure, they might roll back the transaction.
  prefs: []
  type: TYPE_NORMAL
- en: By treating failure as a first-class citizen rather than through exceptional
    control flow bolted on at the end, we can build applications that are much more
    resilient.
  prefs: []
  type: TYPE_NORMAL
- en: Future composition – using a future's result
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, you learned about the `onComplete` method to bind a
    callback to a future. This is useful to cause a side effect to happen when the
    future is complete. It does not, however, let us transform the future's return
    value easily.
  prefs: []
  type: TYPE_NORMAL
- en: 'To carry on with our stocks example, let''s imagine that we want to convert
    the query response from a string to an XML object. Let''s start by including the
    `scala-xml` library as a dependency in `build.sbt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s restart the console and reimport the dependencies on `scala.concurrent._`,
    `scala.concurrent.ExecutionContext.Implicits.global`, and `scala.io._`. We also
    want to import the `XML` library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: 'We will use the same URL as in the previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://dev.markitondemand.com/MODApis/Api/v2/Quote?symbol=GOOG](http://dev.markitondemand.com/MODApis/Api/v2/Quote?symbol=GOOG)'
  prefs: []
  type: TYPE_NORMAL
- en: It is sometimes useful to think of a future as a collection that either contains
    one element if a calculation has been successful, or zero elements if it has failed.
    For instance, if the web API has been queried successfully, our future contains
    a string representation of the response. Like other container types in Scala,
    futures support a `map` method that applies a function to the element contained
    in the future, returning a new future, and does nothing if the calculation in
    the future failed. But what does this mean in the context of a computation that
    might not be finished yet? The map method gets applied as soon as the future is
    complete, like the `onComplete` method.
  prefs: []
  type: TYPE_NORMAL
- en: We can use the future's `map` method to apply a transformation to the result
    of the future asynchronously. Let's poll the "Markit on demand" API again. This
    time, instead of printing the result, we will parse it as XML.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: By registering subsequent maps on futures, we are providing a road map to the
    executor running the future for what to do.
  prefs: []
  type: TYPE_NORMAL
- en: 'If any of the steps fail, the failed `Try` instance containing the exception
    gets propagated instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: This behavior makes sense if you think of a failed future as an empty container.
    When applying a map to an empty list, it returns the same empty list. Similarly,
    when applying a map to an empty (failed) future, the empty future is returned.
  prefs: []
  type: TYPE_NORMAL
- en: Blocking until completion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The code for fetching stock prices works fine in the shell. However, if you
    paste it in a standalone program, you will notice that nothing gets printed and
    the program finishes straightaway. Let''s look at a trivial example of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: 'The program stops running as soon as the main thread has completed its tasks,
    which, in this example, just involves creating the futures. In particular, the
    line `"future completed"` is never printed. If we want the main thread to wait
    for a future to execute, we must explicitly tell it to block execution until the
    future has finished running. This is done using the `Await.ready` or `Await.result`
    methods. Both these methods block the execution of the main thread until the future
    completes. We could make the above program work as intended by adding this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: The `Await` methods take the future as their first argument and a `Duration`
    object as the second. If the future takes longer to complete than the specified
    duration, a `TimeoutException` is thrown. Pass `Duration.Inf` to set an infinite
    timeout.
  prefs: []
  type: TYPE_NORMAL
- en: The difference between `Await.ready` and `Await.result` is that the latter returns
    the value inside the future. In particular, if the future resulted in an exception,
    that exception will get thrown. In contrast, `Await.ready` returns the future
    itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, one should try to avoid blocking as much as possible: the whole
    point of futures is to run code in background threads in order to keep the main
    thread of execution responsive. However, a common, legitimate use case for blocking
    is at the end of a program. If we are running a large-scale integration process,
    we might dispatch several futures to query web APIs, read from text files, or
    insert data into a database. Embedding the code in futures is more scalable than
    performing these operations sequentially. However, as the majority of the intensive
    work is running in background threads, we are left with many outstanding futures
    when the main thread completes. It makes sense, at this stage, to block until
    all the futures have completed.'
  prefs: []
  type: TYPE_NORMAL
- en: Controlling parallel execution with execution contexts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we know how to define futures, let's look at controlling how they run.
    In particular, you might want to control the number of threads to use when running
    a large number of futures.
  prefs: []
  type: TYPE_NORMAL
- en: When a future is defined, it is passed an *execution context*, either directly
    or implicitly. An execution context is an object that exposes an `execute` method
    that takes a block of code and runs it, possibly asynchronously. By changing the
    execution context, we can change the "backend" that runs the futures. We have
    already seen how to use execution contexts to control the execution of parallel
    collections.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have just been using the default execution context by importing `scala.concurrent.ExecutionContext.Implicits.global`.
    This is a fork / join thread pool with as many threads as there are underlying
    CPUs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now define a new execution context that uses sixteen threads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: 'Having defined the execution context, we can pass it explicitly to futures
    as they are defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can define the execution context implicitly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: 'It is then passed as an implicit parameter to all new futures as they are constructed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: 'You can shut the execution context down to destroy the thread pool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: When an execution context receives a shutdown command, it will finish executing
    its current tasks but will refuse any new tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Futures example – stock price fetcher
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s bring some of the concepts that we covered in this section together
    to build a command-line application that prompts the user for the name of a stock
    and fetches the value of that stock. The catch is that, to keep the UI responsive,
    we will fetch the stock using a future:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: 'Try running the program and entering the code for some stocks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: Let's summarize how the code works. when you enter a stock, the main thread
    constructs a future that fetches the stock information from the API, converts
    it to XML, and extracts the price. We use `(r \ "LastPrice").text` to extract
    the text inside the `LastPrice` tag from the XML node `r`. We then convert the
    value to a big decimal. When the transformations are complete, the result is printed
    to screen by binding a callback through `onComplete`. Exception handling is handled
    naturally through our use of `.map` methods to handle transformations.
  prefs: []
  type: TYPE_NORMAL
- en: By wrapping the code for fetching a stock price in a future, we free up the
    main thread to just respond to the user. This means that the user interface does
    not get blocked if we have, for instance, a slow internet connection.
  prefs: []
  type: TYPE_NORMAL
- en: 'This example is somewhat artificial, but you could easily wrap much more complicated
    logic: stock prices could be written to a database and we could add additional
    commands to plot the stock price over time, for instance.'
  prefs: []
  type: TYPE_NORMAL
- en: We have only scratched the surface of what futures can offer in this section.
    We will revisit futures in more detail when we look at polling web APIs in [Chapter
    7](part0059.xhtml#aid-1O8H61 "Chapter 7. Web APIs"), *Web APIs* and [Chapter 9](part0077.xhtml#aid-29DRA1
    "Chapter 9. Concurrency with Akka"), *Concurrency with Akka*.
  prefs: []
  type: TYPE_NORMAL
- en: Futures are a key part of the data scientist's toolkit for building scalable
    systems. Moving expensive computation (either in terms of CPU time or wall time)
    to background threads improves scalability greatly. For this reason, futures are
    an important part of many Scala libraries such as **Akka** and the **Play** framework.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By providing high-level concurrency abstractions, Scala makes writing parallel
    code intuitive and straightforward. Parallel collections and futures form an invaluable
    part of a data scientist's toolbox, allowing them to parallelize their code with
    minimal effort. However, while these high-level abstractions obviate the need
    to deal directly with threads, an understanding of the internals of Scala's concurrency
    model is necessary to avoid race conditions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we will put concurrency on hold and study how to interact
    with SQL databases. However, this is only temporary: futures will play an important
    role in many of the remaining chapters in this book.'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Aleksandar Prokopec*, *Learning Concurrent Programming in Scala*. This is
    a detailed introduction to the basics of concurrent programming in Scala. In particular,
    it explores parallel collections and futures in much greater detail than this
    chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Daniel Westheide''s blog gives an excellent introduction to many Scala concepts,
    in particular:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Futures**: [http://danielwestheide.com/blog/2013/01/09/the-neophytes-guide-to-scala-part-8-welcome-to-the-future.html](http://danielwestheide.com/blog/2013/01/09/the-neophytes-guide-to-scala-part-8-welcome-to-the-future.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The Try** **type**: [http://danielwestheide.com/blog/2012/12/26/the-neophytes-guide-to-scala-part-6-error-handling-with-try.html](http://danielwestheide.com/blog/2012/12/26/the-neophytes-guide-to-scala-part-6-error-handling-with-try.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a discussion of cross-validation, see *The Elements of Statistical Learning*
    by *Hastie*, *Tibshirani*, and *Friedman*.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 5. Scala and SQL through JDBC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of data science's raison d'être is the difficulty of manipulating large
    datasets. Much of the data of interest to a company or research group cannot fit
    conveniently in a single computer's RAM. Storing the data in a way that is easy
    to query is therefore a complex problem.
  prefs: []
  type: TYPE_NORMAL
- en: Relational databases have been successful at solving the data storage problem.
    Originally proposed in 1970 ([http://www.seas.upenn.edu/~zives/03f/cis550/codd.pdf](http://www.seas.upenn.edu/~zives/03f/cis550/codd.pdf)),
    the overwhelming majority of databases in active use today are still relational.
    In that time, the price of RAM per megabyte has decreased by a factor of a hundred
    million. Similarly, hard drive capacity has increased from tens or hundreds of
    megabytes to terabytes. It is remarkable that, despite this exponential growth
    in data storage capacity, the relational model has remained dominant.
  prefs: []
  type: TYPE_NORMAL
- en: 'Virtually all relational databases are described and queried with variants
    of **SQL** (**Structured Query Language**). With the advent of distributed computing,
    the position of SQL databases as the de facto data storage standard is being challenged
    by other types of databases, commonly grouped under the umbrella term NoSQL. Many
    NoSQL databases are more partition-tolerant than SQL databases: they can be split
    into several parts residing on different computers. While this author expects
    that NoSQL databases will become increasingly popular, SQL databases are likely
    to remain prevalent as a data persistence mechanism; hence, a significant portion
    of this book is devoted to interacting with SQL from Scala.'
  prefs: []
  type: TYPE_NORMAL
- en: While SQL is standardized, most implementations do not follow the full standard.
    Additionally, most implementations provide extensions to the standard. This means
    that, while many of the concepts in this book will apply to all SQL backends,
    the exact syntax will need to be adjusted. We will consider only the MySQL implementation
    here.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to interact with SQL databases from Scala
    using JDBC, a bare bones Java API. In the next chapter, we will consider Slick,
    an **Object Relational** **Mapper** (**ORM**) that gives a more Scala-esque feel
    to interacting with SQL.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter is roughly composed of two sections: we will first discuss the
    basic functionality for connecting and interacting with SQL databases, and then
    discuss useful functional patterns that can be used to create an elegant, loosely
    coupled, and coherent data access layer.'
  prefs: []
  type: TYPE_NORMAL
- en: This chapter assumes that you have a basic working knowledge of SQL. If you
    do not, you would be better off first reading one of the reference books mentioned
    at the end of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with JDBC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JDBC is an API for connecting to SQL databases in Java. It remains the simplest
    way of connecting to SQL databases from Scala. Furthermore, the majority of higher-level
    abstractions for interacting with databases still use JDBC as a backend.
  prefs: []
  type: TYPE_NORMAL
- en: JDBC is not a library in itself. Rather, it exposes a set of interfaces to interact
    with databases. Relational database vendors then provide specific implementations
    of these interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by creating a `build.sbt` file. We will declare a dependency on
    the MySQL JDBC connector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: First steps with JDBC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by connecting to JDBC from the command line. To follow with the
    examples, you will need access to a running MySQL server. If you added the MySQL
    connector to the list of dependencies, open a Scala console by typing the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s import JDBC:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: 'We then need to tell JDBC to use a specific connector. This is normally done
    using reflection, loading the driver at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: This loads the appropriate driver into the namespace at runtime. If this seems
    somewhat magical to you, it's probably not worth worrying about exactly how this
    works. This is the only example of reflection that we will consider in this book,
    and it is not particularly idiomatic Scala.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to a database server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Having specified the SQL connector, we can now connect to a database. Let''s
    assume that we have a database called `test` on host `127.0.0.1`, listening on
    port `3306`. We create a connection as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: The first argument to `getConnection` is a URL-like string with `jdbc:mysql://host[:port]/database`.
    The second and third arguments are the username and password. Pass in an empty
    string if you can connect without a password.
  prefs: []
  type: TYPE_NORMAL
- en: Creating tables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have a database connection, let''s interact with the server. For
    these examples, you will find it useful to have a MySQL shell open (or a MySQL
    GUI such as **MySQLWorkbench**) as well as the Scala console. You can open a MySQL
    shell by typing the following command in a terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: 'As an example, we will create a small table to keep track of famous physicists.
    In a `mysql` shell, we would run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: 'To achieve the same with Scala, we send a JDBC statement to the connection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: Let's ignore the return value of `executeUpdate` for now.
  prefs: []
  type: TYPE_NORMAL
- en: Inserting data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have created a table, let''s insert some data into it. We can do
    this with a SQL `INSERT` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: In this case, `executeUpdate` returns `1`. When inserting rows, it returns the
    number of rows that were inserted. Similarly, if we had used a `SQL UPDATE` statement,
    this would return the number of rows that were updated. For statements that do
    not manipulate rows directly (such as the `CREATE TABLE` statement in the previous
    section), `executeUpdate` just returns `0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s just jump into a `mysql` shell to verify the insertion performed correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s quickly summarize what we have seen so far: to execute SQL statements
    that do not return results, use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: 'In the context of data science, we frequently need to insert or update many
    rows at a time. For instance, we might have a list of physicists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: 'We want to insert all of these into the database. While we could create a statement
    for each physicist and send it to the database, this is quite inefficient. A better
    solution is to create a *batch* of statements and send them to the database together.
    We start by creating a statement template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: 'This is identical to the previous `prepareStatement` calls, except that we
    replaced the physicist''s name with a `?` placeholder. We can set the placeholder
    value with the `statement.setString` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: 'This replaces the first placeholder in the statement with the string `Richard
    Feynman`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: Note that JDBC, somewhat counter-intuitively, counts the placeholder positions
    from 1 rather than 0.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have now created the first statement in the batch of updates. Run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: 'By running the preceding command, we initiate a batch insert: the statement
    is added to a temporary buffer that will be executed when we run the `executeBatch`
    method. Let''s add all the physicists in our list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now execute all the statements in the batch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: The return value of `executeBatch` is an array of the number of rows altered
    or inserted by each item in the batch.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we used `statement.setString` to fill in the template with a particular
    name. The `PreparedStatement` object has `setXXX` methods for all basic types.
    To get a complete list, read the `PreparedStatement` API documentation ([http://docs.oracle.com/javase/7/docs/api/java/sql/PreparedStatement.html](http://docs.oracle.com/javase/7/docs/api/java/sql/PreparedStatement.html)).
  prefs: []
  type: TYPE_NORMAL
- en: Reading data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we know how to insert data into a database, let''s look at the converse:
    reading data. We use SQL `SELECT` statements to query the database. Let''s do
    this in the MySQL shell first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: 'To extract this information in Scala, we define a `PreparedStatement`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: 'We execute this statement by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: This returns a JDBC `ResultSet` instance. The `ResultSet` is an abstraction
    representing a set of rows from the database. Note that we used `statement.executeQuery`
    rather than `statement.executeUpdate`. In general, one should execute statements
    that return data (in the form of `ResultSet`) with `executeQuery`. Statements
    that modify the database without returning data (insert, create, alter, or update
    statements, among others) are executed with `executeUpdate`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ResultSet` object behaves somewhat like an iterator. It exposes a `next`
    method that advances itself to the next record, returning `true` if there are
    records left in `ResultSet`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: 'When the `ResultSet` instance points to a record, we can extract fields in
    this record by passing in the field name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also extract fields using positional arguments. The fields are indexed
    from one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: 'When we are done with a particular record, we call the `next` method to advance
    the `ResultSet` to the next record:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: '![Reading data](img/image01193.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: A ResultSet object supports the getXXX(fieldName) methods to access the fields
    of a record and a `next` method to advance to the next record in the result set.
  prefs: []
  type: TYPE_NORMAL
- en: 'One can iterate over a result set using a `while` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A word of warning applies to reading fields that are nullable. While one might
    expect JDBC to return null when faced with a null SQL field, the return type depends
    on the `getXXX` command used. For instance, `getInt` and `getLong` will return
    `0` for any field that is null. Similarly, `getDouble` and `getFloat` return `0.0`.
    This can lead to some subtle bugs in code. In general, one should be careful with
    getters that return Java value types (`int`, `long`) rather than objects. To find
    out if a value is `null` in the database, query it first with `getInt` (or `getLong`
    or `getDouble`, as appropriate), then use the `wasNull` method that returns a
    Boolean if the last read value was null:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: This (surprising) behavior makes reading from `ResultSet` instances error-prone.
    One of the goals of the second part of this chapter is to give you the tools to
    build an abstraction layer on top of the `ResultSet` interface to avoid having
    to call methods such as `getInt` directly.
  prefs: []
  type: TYPE_NORMAL
- en: Reading values directly from `ResultSet` objects feels quite unnatural in Scala.
    We will look, further on in this chapter, at constructing a layer through which
    you can access the result set using type classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now know how to read and write to a database. Having finished with the database
    for now, we close the result sets, prepared statements, and connections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: While closing statements and connections is not important in the Scala shell
    (they will get closed when you exit), it is important when you run programs; otherwise,
    the objects will persist, leading to "out of memory exceptions". In the next sections,
    we will look at establishing connections and statements with the **loan pattern**,
    a design pattern that closes a resource automatically when we finish using it.
  prefs: []
  type: TYPE_NORMAL
- en: JDBC summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now have an overview of JDBC. The rest of this chapter will concentrate on
    writing abstractions that sit above JDBC, making database accesses feel more natural.
    Before we do this, let's summarize what we have seen so far.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have used three JDBC classes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Connection` class represents a connection to a specific SQL database.
    Instantiate a connection as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE198]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Our main use of `Connection` instances has been to generate `PreparedStatement`
    objects:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE199]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A `PreparedStatement` instance represents a SQL statement about to be sent
    to the database. It also represents the template for a SQL statement with placeholders
    for values yet to be filled in. The class exposes the following methods:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| `statement.executeUpdate` | This sends the statement to the database. Use
    this for SQL statements that modify the database and do not return any data, such
    as `INSERT`, `UPDATE`, `DELETE`, and `CREATE` statements. |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `val results = statement.executeQuery` | This sends the statement to the
    database. Use this for SQL statements that return data (predominantly, the `SELECT`
    statements). This returns a `ResultSet` instance. |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `statement.addBatch``statement.executeBatch` | The `addBatch` method adds
    the current statement to a batch of statements, and `executeBatch` sends the batch
    of statements to the database. |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `statement.setString(1, "Scala")``statement.setInt(1, 42)``statement.setBoolean(1,
    true)` | Fill in the placeholder values in the `PreparedStatement`. The first
    argument is the position in the statement (counting from 1). The second argument
    is the value.One common use case for these is in a batch update or insert: we
    might have a Scala list of objects that we want to insert into the database. We
    fill in the placeholders for each object in the list using the `.setXXX` methods,
    then add this statement to the batch using `.addBatch`. We can then send the entire
    batch to the database using `.executeBatch`. |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `statement.setNull(1, java.sql.Types.BOOLEAN)` | This sets a particular item
    in the statement to `NULL`. The second argument specifies the `NULL` type. If
    we are setting a cell in a Boolean column, for instance, this should be `Types.BOOLEAN`.
    A full list of types is given in the API documentation for the `java.sql.Types`
    package ([http://docs.oracle.com/javase/7/docs/api/java/sql/Types.html](http://docs.oracle.com/javase/7/docs/api/java/sql/Types.html)).
    |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: 'A `ResultSet` instance represents a set of rows returned by a `SELECT` or `SHOW`
    statement. `ResultSet` exposes methods to access fields in the current row:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| `rs.getString(i)``rs.getInt(i)` | These methods get the value of the `ith`
    field in the current row; `i` is measured from 1. |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `rs.getString("name")``rs.getInt("age")` | These methods get the value of
    a specific field, which is indexed by the column name. |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `rs.wasNull` | This returns whether the last column read was `NULL.` This
    is particularly important when reading Java value types, such as `getInt`, `getBoolean`,
    or `getDouble`, as these return a default value when reading a `NULL` value. |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: The `ResultSet` instance exposes the `.next` method to move to the next row;
    `.next` returns `true` until the `ResultSet` has advanced to just beyond the last
    row.
  prefs: []
  type: TYPE_NORMAL
- en: Functional wrappers for JDBC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now have a basic overview of the tools afforded by JDBC. All the objects
    that we have interacted with so far feel somewhat clunky and out of place in Scala.
    They do not encourage a functional style of programming.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, elegance is not necessarily a goal in itself (or, at least, you
    will probably struggle to convince your CEO that he should delay the launch of
    a product because the code lacks elegance). However, it is usually a symptom:
    either the code is not extensible or too tightly coupled, or it is easy to introduce
    bugs. The latter is particularly the case for JDBC. Forgot to check `wasNull`?
    That will come back to bite you. Forgot to close your connections? You''ll get
    an "out of memory exception" (hopefully not in production).'
  prefs: []
  type: TYPE_NORMAL
- en: In the next sections, we will look at patterns that we can use to wrap JDBC
    types in order to mitigate many of these risks. The patterns that we introduce
    here are used very commonly in Scala libraries and applications. Thus, besides
    writing robust classes to interact with JDBC, learning about these patterns will,
    I hope, give you greater understanding of Scala programming.
  prefs: []
  type: TYPE_NORMAL
- en: Safer JDBC connections with the loan pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have already seen how to connect to a JDBC database and send statements
    to the database for execution. This technique, however, is somewhat error prone:
    you have to remember to close statements; otherwise, you will quickly run out
    of memory. In more traditional imperative style, we write the following try-finally
    block around every connection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: 'Scala, with first-class functions, provides us with an alternative: the *loan
    pattern*. We write a function that is responsible for opening the connection,
    loaning it to the client code to do something interesting with it, and then closing
    it when the client code is done. Thus, the client code is not responsible for
    closing the connection any more.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a new `SqlUtils` object with a `usingConnection` method that
    leverages the loan pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see this function in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: Thus, the client doesn't have to remember to close the connection, and the resultant
    code (for the client) feels much more like Scala.
  prefs: []
  type: TYPE_NORMAL
- en: 'How does our `usingConnection` function work? The function definition is `def
    usingConnection( ... )(f : Connection => T ):T`. It takes, as its second set of
    arguments, a function that acts on a `Connection` object. The body of `usingConnection`
    creates the connection, then passes it to `f`, and finally closes the connection.
    This syntax is somewhat similar to code blocks in Ruby or the `with` statement
    in Python.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Be careful when mixing the loan pattern with lazy operations. This applies particularly
    to returning iterators, streams, and futures from `f`. As soon as the thread of
    execution leaves `f`, the connection will be closed. Any data structure that is
    not materialized at this point will not be able to carry on accessing the connection.
  prefs: []
  type: TYPE_NORMAL
- en: 'The loan pattern is, of course, not exclusive to database connections. It is
    useful whenever you have the following pattern, in pseudocode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: Enriching JDBC statements with the "pimp my library" pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous section, we saw how to create self-closing connections with
    the loan pattern. This allows us to open connections to the database without having
    to remember to close them. However, we still have to remember to close any `ResultSet`
    and `PreparedStatement` that we open:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: 'Having to open and close the statement is somewhat ugly and error prone. This
    is another natural use case for the loan pattern. Ideally, we would like to write
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: How can we define a `.withQuery` method on the `Connection` class? We do not
    control the `Connection` class definition as it is part of the JDBC API. We would
    like to be able to somehow reopen the `Connection` class definition to add the
    `withQuery` method.
  prefs: []
  type: TYPE_NORMAL
- en: Scala does not let us reopen classes to add new methods (a practice known as
    monkey-patching). We can still, however, enrich existing libraries with implicit
    conversions using the **pimp** **my library** pattern ([http://www.artima.com/weblogs/viewpost.jsp?thread=179766](http://www.artima.com/weblogs/viewpost.jsp?thread=179766)).
    We first define a `RichConnection` class that contains the `withQuery` method.
    This `RichConnection` class is created from an existing `Connection` instance.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: 'We could use this class by just wrapping every `Connection` instance in a `RichConnection`
    instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: 'This adds unnecessary boilerplate: we have to remember to convert every connection
    instance to `RichConnection` to use `withQuery`. Fortunately, Scala provides an
    easier way with implicit conversions: we tell Scala how to convert from `Connection`
    to `RichConnection` and vice versa, and tell it to perform this conversion automatically
    (implicitly), if necessary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: Now, whenever `pimpConnection` and `depimpConnection` are in the current scope,
    Scala will automatically use them to convert from `Connection` instances to `RichConnection`
    and back as needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now write the following (I have added type information for emphasis):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: This might look like magic, so let's step back and look at what happens when
    we call `withQuery` on a `Connection` instance. The Scala compiler will first
    look to see if the class definition of `Connection` defines a `withQuery` method.
    When it finds that it does not, it will look for implicit methods that convert
    a `Connection` instance to a class that defines `withQuery`. It will find that
    the `pimpConnection` method allows conversion from `Connection` to `RichConnection`,
    which defines `withQuery`. The Scala compiler automatically uses `pimpConnection`
    to transform the `Connection` instance to `RichConnection`.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we used the names `pimpConnection` and `depimpConnection` for the
    conversion functions, but they could have been anything. We never call these methods
    explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s summarize how to use the *pimp my library* pattern to add methods to
    an existing class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write a class that wraps the class you want to enrich: `class` `RichConnection(val
    underlying:Connection)`. Add all the methods that you wish the original class
    had.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write a method to convert from your original class to your enriched class as
    part of an object called (conventionally) `Implicits`. Make sure that you tell
    Scala to use this conversion automatically with the `implicit` keyword: `implicit
    def pimpConnection(conn:Connection):RichConnection`. You can also tell Scala to
    automatically convert back from the enriched class to the original class by adding
    the reverse conversion method.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Allow implicit conversions by importing the implicit conversion methods: `import
    Implicits._`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wrapping result sets in a stream
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The JDBC `ResultSet` object plays very badly with Scala collections. The only
    real way of doing anything useful with it is to loop through it directly with
    a `while` loop. For instance, to get a list of the names of physicists in our
    database, we could write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ResultSet` interface feels unnatural because it behaves very differently
    from Scala collections. In particular, it does not support the higher-order functions
    that we take for granted in Scala: no `map`, `filter`, `fold`, or `for` comprehensions.
    Thankfully, writing a *stream* that wraps `ResultSet` is quite straightforward.
    A Scala stream is a lazily evaluated list: it evaluates the next element in the
    collection when it is needed and forgets previous elements when they are no longer
    used.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can define a `stream` method that wraps `ResultSet` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: 'This might look quite confusing, so let''s take it slowly. We define a `stream`
    method that wraps `ResultSet`, returning a `Stream[ResultSet]`. When the client
    calls `stream` on an empty result set, this just returns an empty stream. When
    the client calls `stream` on a non-empty `ResultSet`, the `ResultSet` instance
    is advanced by one row, and the client gets back `results #:: stream(results)`.
    The `#::` operator on a stream is similar to the cons operator, `::`, on a list:
    it prepends `results` to an existing `Stream`. The critical difference is that,
    unlike a list, `stream(results)` does not get evaluated until necessary. This,
    therefore, avoids duplicating the entire `ResultSet` in memory.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use our brand new `stream` function to get the name of all the physicists
    in our database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: Streaming the results, rather than using the result set directly, lets us interact
    with the data much more naturally as we are now dealing with just a Scala collection.
  prefs: []
  type: TYPE_NORMAL
- en: When you use `stream` in a `withQuery` block (or, generally, in a block that
    automatically closes the result set), you must always materialize the stream within
    the function, hence the call to `toVector`. Otherwise, the stream will wait until
    its elements are needed to materialize them, and by then, the `ResultSet` instance
    will be closed.
  prefs: []
  type: TYPE_NORMAL
- en: Looser coupling with type classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have been reading and writing simple types to the database. Let''s
    imagine that we want to add a `gender` column to our database. We will store the
    gender as an enumeration in our physicists database. Our table is now as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: 'How can we represent genders in Scala? A good way of doing this is with an
    enumeration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: 'However, we now have a problem when deserializing objects from the database:
    JDBC has no built-in mechanism to convert from a SQL `ENUM` type to a Scala `Gender`
    type. We could achieve this by just converting manually every time we need to
    read gender information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: However, we would need to write this everywhere that we want to read the `gender`
    field. This goes against the DRY (don't repeat yourself) principle, leading to
    code that is difficult to maintain. If we decide to change the way gender is stored
    in the database, we would need to find every instance in the code where we read
    the `gender` field and change it.
  prefs: []
  type: TYPE_NORMAL
- en: 'A somewhat better solution would be to add a `getGender` method to the `ResultSet`
    class using the pimp my library idiom that we used extensively in this chapter.
    This solution is still not optimal. We are adding unnecessary specificity to `ResultSet`:
    it is now coupled to the structure of our databases.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We could create a subclass of `ResultSet` using inheritance, such as `PhysicistResultSet`,
    that can read the fields in a specific table. However, this approach is not composable:
    if we had another table that kept track of pets, with name, species, and gender
    fields, we would have to either reimplement the code for reading gender in a new
    `PetResultSet` or factor out a `GenderedResultSet` superclass. As the number of
    tables grows, the inheritance hierarchy would become unmanageable. A better approach
    would let us compose the functionality that we need. In particular, we want to
    decouple the process of extracting Scala objects from a result set from the code
    for iterating over a result set.'
  prefs: []
  type: TYPE_NORMAL
- en: Type classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Scala provides an elegant solution using *type classes*. Type classes are a
    very powerful arrow in the Scala architect's quiver. However, they can present
    a bit of a learning curve, especially as there is no direct equivalent in object-oriented
    programming.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of presenting an abstract explanation, I will dive into an example:
    I will describe how we can leverage type classes to convert fields in a `ResultSet`
    to Scala types. The aim is to define a `read[T](field)` method on `ResultSet`
    that knows exactly how to deserialize to objects of type `T`. This method will
    replace and extend the `getXXX` methods in `ResultSet`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: 'We start by defining an abstract `SqlReader[T]` trait that exposes a `read`
    method to read a specific field from a `ResultSet` and return an instance of type
    `T`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: 'We now need to provide a concrete implementation of `SqlReader[T]` for every
    `T` type that we want to read. Let''s provide concrete implementations for the
    `Gender` and `String` fields. We will place the implementation in a `SqlReader`
    companion object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: 'We could now use our `ReadableXXX` objects to read from a result set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: 'This is already somewhat better than using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: 'This is because the code to map from a `ResultSet` field to `Gender.Value`
    is centralized in a single place: `ReadableGender`. However, it would be great
    if we could tell Scala to use `ReadableGender` whenever it needs to read `Gender.Value`,
    and use `ReadableString` whenever it needs to read a String value. This is exactly
    what type classes do.'
  prefs: []
  type: TYPE_NORMAL
- en: Coding against type classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We defined a `Readable[T]` interface that abstracts how to read an object of
    type `T` from a field in a `ResultSet`. How do we tell Scala that it needs to
    use this `Readable` object to convert from the `ResultSet` fields to the appropriate
    Scala type?
  prefs: []
  type: TYPE_NORMAL
- en: 'The key is the `implicit` keyword that we used to prefix the `GenderReader`
    and `StringReader` object definitions. It lets us write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: 'By writing `implicitly[SqlReader[T]]`, we are telling the Scala compiler to
    find a class (or an object) that extends `SqlReader[T]` that is marked for implicit
    use. Try this out by pasting the following in the command line, for instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, using `implicitly[SqlReader[T]]` everywhere is not particularly
    elegant. Let''s use the pimp my library idiom to add a `read[T]` method to `ResultSet`.
    We first define a `RichResultSet` class that we can use to "pimp" the `ResultSet`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: 'The only unfamiliar part of this should be the `read[T : SqlReader]` generic
    definition. We are stating here that `read` will accept any `T` type, provided
    an instance of `SqlReader[T]` exists. This is called a *context bound.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'We must also add implicit methods to the `Implicits` object to convert from
    `ResultSet` to `RichResultSet`. You should be familiar with this now, so I will
    not bore you with the details. You can now call `results.read[T](fieldName)` for
    any `T` for which you have a `SqlReader[T]` implicit object defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s summarize the steps needed for type classes to work. We will do this
    in the context of deserializing from SQL, but you will be able to adapt these
    steps to solve other problems:'
  prefs: []
  type: TYPE_NORMAL
- en: Define an abstract generic trait that provides the interface for the type class,
    for example, `SqlReader[T]`. Any functionality that is independent of `T` can
    be added to this base trait.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create the companion object for the base trait and add implicit objects extending
    the trait for each `T`, for example,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE225]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Type classes are always used in generic methods. A method that relies on the
    existence of a type class for an argument must contain a context bound in the
    generic definition, for example, `def read[T : SqlReader](field:String):T`. To
    access the type class in this method, use the `implicitly` keyword: `implicitly[SqlReader[T]]`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When to use type classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Type classes are useful when you need a particular behavior for many different
    types, but exactly how this behavior is implemented varies between these types.
    For instance, we need to be able to read several different types from `ResultSet`,
    but exactly how each type is read differs between types: for strings, we must
    read from `ResultSet` using `getString`, whereas for integers, we must use `getInt`
    followed by `wasNull`.'
  prefs: []
  type: TYPE_NORMAL
- en: A good rule of thumb is when you start thinking "Oh, I could just write a generic
    method to do this. Ah, but wait, I will have to write the `Int` implementation
    as a specific edge case as it behaves differently. Oh, and the `Gender` implementation.
    I wonder if there's a better way?", then type classes might be useful.
  prefs: []
  type: TYPE_NORMAL
- en: Benefits of type classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Data scientists frequently have to deal with new input streams, changing requirements,
    and new data types. Having an object-relational mapping layer that is easy to
    extend or alter is therefore critical to responding to changes efficiently. Minimizing
    coupling between code entities and separation of concerns are the only ways to
    ensure that the code can be changed in response to new data.
  prefs: []
  type: TYPE_NORMAL
- en: 'With type classes, we maintain orthogonality between accessing records in the
    database (through the `ResultSet` class) and how individual fields are transformed
    to Scala objects: both can vary independently. The only coupling between these
    two concerns is through the `SqlReader[T]` interface.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that both concerns can evolve independently: to read a new data
    type, we just need to implement a `SqlReader[T]` object. Conversely, we can add
    functionality to `ResultSet` without needing to reimplement how fields are converted.
    For instance, we could add a `getColumn` method that returns a `Vector[T]` of
    all the values of a field in a `ResultSet` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: Note how we could do this without increasing the coupling to the way in which
    individual fields are read.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a data access layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's bring together everything that we have seen and build a *data-mapper*
    class for fetching `Physicist` objects from the database. These classes (also
    called *data access objects*) are useful to decouple the internal representation
    of an object from its representation in the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by defining the `Physicist` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: 'The data access object will expose a single method, `readAll`, that returns
    a `Vector[Physicist]` of all the physicists in our database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: 'The data access layer can be used by client code as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to interact with SQL databases using JDBC. We
    wrote a library to wrap native JDBC objects, aiming to give them a more functional
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn about Slick, a Scala library that provides
    functional wrappers to interact with relational databases.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The API documentation for JDBC is very complete: [http://docs.oracle.com/javase/7/docs/api/java/sql/package-summary.html](http://docs.oracle.com/javase/7/docs/api/java/sql/package-summary.html)'
  prefs: []
  type: TYPE_NORMAL
- en: The API documentation for the `ResultSet` interface ([http://docs.oracle.com/javase/7/docs/api/java/sql/ResultSet.html](http://docs.oracle.com/javase/7/docs/api/java/sql/ResultSet.html)),
    for the `PreparedStatement` class ([http://docs.oracle.com/javase/7/docs/api/java/sql/PreparedStatement.html](http://docs.oracle.com/javase/7/docs/api/java/sql/PreparedStatement.html))
    and the `Connection` class ([http://docs.oracle.com/javase/7/docs/api/java/sql/Connection.html](http://docs.oracle.com/javase/7/docs/api/java/sql/Connection.html))
    is particularly relevant.
  prefs: []
  type: TYPE_NORMAL
- en: The data mapper pattern is described extensively in Martin Fowler's *Patterns
    of Enterprise Application Architecture*. A brief description is also available
    on his website ([http://martinfowler.com/eaaCatalog/dataMapper.html](http://martinfowler.com/eaaCatalog/dataMapper.html)).
  prefs: []
  type: TYPE_NORMAL
- en: For an introduction to SQL, I suggest *Learning SQL* by *Alan Beaulieu* (*O'Reilly*).
  prefs: []
  type: TYPE_NORMAL
- en: For another discussion of type classes, read [http://danielwestheide.com/blog/2013/02/06/the-neophytes-guide-to-scala-part-12-type-classes.html](http://danielwestheide.com/blog/2013/02/06/the-neophytes-guide-to-scala-part-12-type-classes.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'This post describes how some common object-oriented design patterns can be
    reimplemented more elegantly in Scala using type classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://staticallytyped.wordpress.com/2013/03/24/gang-of-four-patterns-with-type-classes-and-implicits-in-scala-part-2/](https://staticallytyped.wordpress.com/2013/03/24/gang-of-four-patterns-with-type-classes-and-implicits-in-scala-part-2/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'This post by *Martin Odersky* details the *Pimp my Library* pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.artima.com/weblogs/viewpost.jsp?thread=179766](http://www.artima.com/weblogs/viewpost.jsp?thread=179766)'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 6. Slick – A Functional Interface for SQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 5](part0040.xhtml#aid-164MG1 "Chapter 5. Scala and SQL through JDBC"),
    *Scala and SQL through JDBC*, we investigated how to access SQL databases with
    JDBC. As interacting with JDBC feels somewhat unnatural, we extended JDBC using
    custom wrappers. The wrappers were developed to provide a functional interface
    to hide the imperative nature of JDBC.
  prefs: []
  type: TYPE_NORMAL
- en: With the difficulty of interacting directly with JDBC from Scala and the ubiquity
    of SQL databases, you would expect there to be existing Scala libraries that wrap
    JDBC. *Slick* is such a library.
  prefs: []
  type: TYPE_NORMAL
- en: Slick styles itself as a *functional-relational mapping* library, a play on
    the more traditional *object-relational mapping* name used to denote libraries
    that build objects from relational databases. It presents a functional interface
    to SQL databases, allowing the client to interact with them in a manner similar
    to native Scala collections.
  prefs: []
  type: TYPE_NORMAL
- en: FEC data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will use a somewhat more involved example dataset. The **Federal
    Electoral Commission of the United** **States** (**FEC**) records all donations
    to presidential candidates greater than $200\. These records are publicly available.
    We will look at the donations for the campaign leading up to the 2012 general
    elections that resulted in Barack Obama's re-election. The data includes donations
    to the two presidential candidates, Obama and Romney, and also to the other contenders
    in the Republican primaries (there were no Democrat primaries).
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will take the transaction data provided by the FEC, store
    it in a table, and learn how to query and analyze it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to acquire the data. If you have downloaded the code samples
    from the Packt website, you should already have two CSVs in the `data` directory
    of the code samples for this chapter. If not, you can download the files using
    the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: '`data.scala4datascience.com/fec/ohio.csv.gz` (or `ohio.csv.zip`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`data.scala4datascience.com/fec/us.csv.gz` (or `us.csv.zip`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Decompress the two files and place them in a directory called `data/` in the
    same location as the source code examples for this chapter. The data files correspond
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The `ohio.csv` file is a CSV of all the donations made by donors in Ohio.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `us.csv` file is a CSV of all the donations made by donors across the country.
    This is quite a large file, with six million rows.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The two CSV files contain identical columns. Use the Ohio dataset for more responsive
    behavior, or the nationwide data file if you want to wrestle with a larger dataset.
    The dataset is adapted from a list of contributions downloaded from [http://www.fec.gov/disclosurep/PDownload.do](http://www.fec.gov/disclosurep/PDownload.do).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by creating a Scala case class to represent a transaction. In
    the context of this chapter, a transaction is a single donation from an individual
    to a candidate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: 'The code repository for this chapter includes helper functions in an `FECData`
    singleton object to load the data from CSVs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling `FECData.loadOhio` or `FECData.loadAll` will create an `FECData` object
    with a single attribute, `transactions`, which is an iterator over all the donations
    coming from Ohio or the entire United States:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have some data to play with, let's try and put it in the database
    so that we can run some useful queries on it.
  prefs: []
  type: TYPE_NORMAL
- en: Importing Slick
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To add Slick to the list of dependencies, you will need to add `"com.typesafe.slick"
    %% "slick" % "2.1.0"` to the list of dependencies in your `build.sbt` file. You
    will also need to make sure that Slick has access to a JDBC driver. In this chapter,
    we will connect to a MySQL database, and must, therefore, add the MySQL connector
    `"mysql" % "mysql-connector-java" % "5.1.37"` to the list of dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Slick is imported by importing a specific database driver. As we are using
    MySQL, we must import the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: To connect to a different flavor of SQL database, import the relevant driver.
    The easiest way of seeing what drivers are available is to consult the API documentation
    for the `slick.driver` package, which is available at [http://slick.typesafe.com/doc/2.1.0/api/#scala.slick.driver.package](http://slick.typesafe.com/doc/2.1.0/api/#scala.slick.driver.package).
    All the common SQL flavors are supported (including **H2**, **PostgreSQL**, **MS
    SQL Server**, and **SQLite**).
  prefs: []
  type: TYPE_NORMAL
- en: Defining the schema
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s create a table to represent our transactions. We will use the following
    schema:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: Note that the donation amount is in *cents*. This allows us to use an integer
    field (rather than a fixed point decimal, or worse, a float).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You should never use a floating point format to represent money or, in fact,
    any discrete quantity because floats cannot represent most fractions exactly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: This seemingly nonsensical result occurs because there is no way to store 0.3
    exactly in doubles.
  prefs: []
  type: TYPE_NORMAL
- en: 'This post gives an extensive discussion of the limitations of the floating
    point format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html](http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html)'
  prefs: []
  type: TYPE_NORMAL
- en: 'To use Slick with tables in our database, we first need to tell Slick about
    the database schema. We do this by creating a class that extends the `Table` abstract
    class. The way in which a schema is defined is quite straightforward, so let''s
    dive straight into the code. We will store our schema in a `Tables` singleton.
    We define a `Transactions` class that provides the mapping to go from collections
    of `Transaction` instances to SQL tables structured like the `transactions` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: Let's go through this line by line. We first define a `Transactions` class,
    which must take a Slick `Tag` object as its first argument. The `Tag` object is
    used by Slick internally to construct SQL statements. The `Transactions` class
    extends a `Table` object, passing it the tag and name of the table in the database.
    We could, optionally, have added a database name by extending `Table[Transaction](tag,
    Some("fec"), "transactions")` rather than just `Table[Transaction](tag, "transactions")`.
    The `Table` type is parametrized by `Transaction`. This means that running `SELECT`
    statements on the database returns `Transaction` objects. Similarly, we will insert
    data into the database by passing a transaction or list of transactions to the
    relevant Slick methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the `Transactions` class definition in more detail. The body
    of the class starts by listing the database columns. For instance, the `id` column
    is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: We tell Slick that it should read the column called `id` and transform it to
    a Scala integer. Additionally, we tell Slick that this column is the primary key
    and that it is auto-incrementing. The Slick documentation contains a list of available
    options for `column`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `candidate` and `contributor` columns are straightforward: we tell Slick
    to read these as `String` from the database. The `contributor_state` column is
    a little more interesting. Besides specifying that it should be read from the
    database as a `String`, we also tell Slick that it should be stored in the database
    with type `VARCHAR(2)`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `contributor_occupation` column in our table can contain `NULL` values.
    When defining the schema, we pass the `Option[String]` type to the column method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: When reading from the database, a `NULL` field will get converted to `None`
    for columns specified as `Option[T]`. Conversely, if the field has a value, it
    will be returned as `Some(value)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last line of the class body is the most interesting part: it specifies
    how to transform the raw data read from the database into a `Transaction` object
    and how to convert a `Transaction` object to raw fields ready for insertion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: 'The first part is just a tuple of fields to be read from the database: `(id.?,
    candidate, contributor, contributorState, contributorOccupation, amount, date)`,
    with a small amount of metadata. The second part is a pair of functions that describe
    how to transform this tuple into a `Transaction` object and back. In this case,
    as `Transaction` is a case class, we can take advantage of the `Transaction.tupled`
    and `Transaction.unapply` methods automatically provided for case classes.'
  prefs: []
  type: TYPE_NORMAL
- en: Notice how we followed the `id` entry with `.?`. In our `Transaction` class,
    the donation `id` has the `Option[Int]` type, but the column in the database has
    the `INT` type with the additional `O.AutoInc` option. The `.?` suffix tells Slick
    to use the default value provided by the database (in this case, the database's
    auto-increment) if `id` is `None`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we define the value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the handle that we use to actually interact with the database. For
    instance, as we will see later, to get a list of donations to Barack Obama, we
    run the following query (don''t worry about the details of the query for now):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s summarize the parts of our `Transactions` mapper class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Transactions` class must extend the `Table` abstract class parametrized
    by the type that we want to return: `Table[Transaction]`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We define the columns to read from the database explicitly using `column`, for
    example, `def contributorState = column[String]("contributor_state", O.DBType("VARCHAR(2)"))`.
    The `[String]` type parameter defines the Scala type that this column gets read
    as. The first argument is the SQL column name. Consult the Slick documentation
    for a full list of additional arguments ([http://slick.typesafe.com/doc/2.1.0/schemas.html](http://slick.typesafe.com/doc/2.1.0/schemas.html)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We describe how to convert from a tuple of the column values to a Scala object
    and vice versa using `def * = (id.?, candidate, ...) <> (Transaction.tupled, Transaction.unapply)`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting to the database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, you have learned how to define `Table` classes that encode the transformation
    from rows in a SQL table to Scala case classes. To move beyond table definitions
    and start interacting with a database server, we must connect to a database. As
    in the previous chapter, we will assume that there is a MySQL server running on
    localhost on port `3306`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the console to demonstrate the functionality in this chapter, but
    you can find an equivalent sample program in `SlickDemo.scala`. Let''s open a
    Scala console and connect to the database running on port `3306`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: If you have read the previous chapter, you will recognize the first argument
    as a JDBC-style URL. The URL starts by defining a protocol, in this case, `jdbc:mysql`,
    followed by the IP address and port of the database server, followed by the database
    name (`test`, here).
  prefs: []
  type: TYPE_NORMAL
- en: The second argument to `forURL` is the class name of the JDBC driver. This driver
    is imported at runtime using reflection. Note that the driver specified here must
    match the Slick driver imported statically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having defined the database, we can now use it to create a connection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: 'Slick functions that require access to the database take a `Session` argument
    implicitly: if a `Session` instance marked as implicit is available in scope,
    they will use it. Thus, preceding `session` with the `implicit` keyword saves
    us having to pass `session` explicitly every time we run an operation on the database.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have read the previous chapter, you will recognize that Slick deals
    with the need to close connections with the *loan pattern*: a database connection
    is created in the form of a `session` object and passed temporarily to the client.
    When the client code returns, the session is closed, ensuring that all opened
    connections are closed. The client code is therefore spared the responsibility
    of closing the connection.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The loan pattern is very useful in production code, but it can be somewhat
    cumbersome in the shell. Slick lets us create a session explicitly as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: Creating tables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s use our new connection to create the transaction table in the database.
    We can access methods to create and drop tables using the `ddl` attribute on our
    `TableQuery[Transactions]` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: 'If you jump into a `mysql` shell, you will see that a `transactions` table
    has been created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: The `ddl` attribute also includes a `drop` method to drop the table. Incidentally,
    `ddl` stands for "data-definition language" and is commonly used to refer to the
    parts of SQL relevant to schema and constraint definitions.
  prefs: []
  type: TYPE_NORMAL
- en: Inserting data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Slick `TableQuery` instances let us interact with SQL tables with an interface
    similar to Scala collections.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a transaction first. We will pretend that a donation occurred
    on the 22nd of June, 2010\. Unfortunately, the code to create dates in Scala and
    pass these to JDBC is particularly clunky. We first create a `java.util.Date`
    instance, which we must then convert to a `java.sql.Date` to use in our newly
    created transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: 'Much of the interface provided by the `TableQuery` instance mirrors that of
    a mutable list. To insert a single row in the transaction table, we can use the
    `+=` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: Under the hood, this will create a JDBC prepared statement and run this statement's
    `executeUpdate` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are committing many rows at a time, you should use Slick''s bulk insert
    operator: `++=`. This takes a `List[Transaction]` as input and inserts all the
    transactions in a single batch by taking advantage of JDBC''s `addBatch` and `executeBatch`
    functionality.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s insert all the FEC transactions so that we have some data to play with
    when running queries in the next section. We can load an iterator of transactions
    for Ohio by calling the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also load the transactions for the whole of United States:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: 'To avoid materializing all the transactions in a single fell swoop—thus potentially
    exceeding our computer''s available memory—we will take batches of transactions
    from the iterator and insert them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: An iterator's `grouped` method splits the iterator into batches. It is useful
    to split a long collection or iterator into manageable batches that can be processed
    one after the other. This is important when integrating or processing large datasets.
  prefs: []
  type: TYPE_NORMAL
- en: 'All that we have to do now is iterate over our batches, inserting them into
    the database as we go:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE252]'
  prefs: []
  type: TYPE_PRE
- en: 'While this works, it is sometimes useful to see progress reports when doing
    long-running integration processes. As we have split the integration into batches,
    we know (to the nearest batch) how far into the integration we are. Let''s print
    the progress information at the beginning of every batch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE253]'
  prefs: []
  type: TYPE_PRE
- en: We use the `.zipWithIndex` method to transform our iterator over batches into
    an iterator of (*batch*, *current* *index*) pairs. In a full-scale application,
    the progress information would probably be written to a log file rather than to
    the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Slick's well-designed interface makes inserting data very intuitive, integrating
    well with native Scala types.
  prefs: []
  type: TYPE_NORMAL
- en: Querying data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, we used Slick to insert donation data into our database.
    Let's explore this data now.
  prefs: []
  type: TYPE_NORMAL
- en: 'When defining the `Transactions` class, we defined a `TableQuery` object, `transactions`,
    that acts as the handle for accessing the transaction table. It exposes an interface
    similar to Scala iterators. For instance, to see the first five elements in our
    database, we can call `take(5)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: 'Internally, Slick implements the `.take` method using a SQL `LIMIT`. We can,
    in fact, get the SQL statement using the `.selectStatement` method on the query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: 'Our Slick query is made up of the following two parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.take(n)`: This part is called the *invoker*. Invokers build up the SQL statement
    but do not actually fire it to the database. You can chain many invokers together
    to build complex SQL statements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.list`: This part sends the statement prepared by the invoker to the database
    and converts the result to Scala object. This takes a `session` argument, possibly
    implicitly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Invokers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Invokers** are the components of a Slick query that build up the SQL select
    statement. Slick exposes a variety of invokers that allow the construction of
    complex queries. Let''s look at some of these invokers here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `map` invoker is useful to select individual columns or apply operations
    to columns:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE256]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `filter` invoker is the equivalent of the `WHERE` statements in SQL. Note
    that Slick fields must be compared using `===`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE257]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Similarly, to filter out donations to Barack Obama, use the `=!=` operator:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE258]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `sortBy` invoker is the equivalent of the `ORDER BY` statement in SQL:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE259]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `leftJoin`, `rightJoin`, `innerJoin`, and `outerJoin` invokers are used
    for joining tables. As we do not cover interactions between multiple tables in
    this tutorial, we cannot demonstrate joins. See the Slick documentation ([http://slick.typesafe.com/doc/2.1.0/queries.html#joining-and-zipping](http://slick.typesafe.com/doc/2.1.0/queries.html#joining-and-zipping))
    for examples of these.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Aggregation invokers such as `length`, `min`, `max`, `sum`, and `avg` can be
    used for computing summary statistics. These must be executed using `.run`, rather
    than `.list`, as they return single numbers. For instance, to get the total donations
    to Barack Obama:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE260]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Operations on columns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous section, you learned about the different invokers and how they
    mapped to SQL statements. We brushed over the methods supported by columns themselves,
    however: we can compare for equality using `===`, but what other operations are
    supported by Slick columns?'
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of the SQL functions are supported. For instance, to get the total donations
    to candidates whose name starts with `"O"`, we could run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE261]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, to count donations that happened between January 1, 2011 and February
    1, 2011, we can use the `.between` method on the `date` column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE262]'
  prefs: []
  type: TYPE_PRE
- en: 'The equivalent of the SQL `IN (...)` operator that selects values in a specific
    set is `inSet`. For instance, to select all transactions to Barack Obama and Mitt
    Romney, we can use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE263]'
  prefs: []
  type: TYPE_PRE
- en: So, between them, Mitt Romney and Barack Obama received over 28 million dollars
    in registered donations.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also negate a Boolean column with the `!` operator. For instance, to
    calculate the total amount of donations received by all candidates apart from
    Barack Obama and Mitt Romney:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE264]'
  prefs: []
  type: TYPE_PRE
- en: Column operations are added by implicit conversion on the base `Column` instances.
    For a full list of methods available on String columns, consult the API documentation
    for the `StringColumnExtensionMethods` class ([http://slick.typesafe.com/doc/2.1.0/api/#scala.slick.lifted.StringColumnExtensionMethods](http://slick.typesafe.com/doc/2.1.0/api/#scala.slick.lifted.StringColumnExtensionMethods)).
    For the methods available on Boolean columns, consult the API documentation for
    the `BooleanColumnExtensionMethods` class ([http://slick.typesafe.com/doc/2.1.0/api/#scala.slick.lifted.BooleanColumnExtensionMethods](http://slick.typesafe.com/doc/2.1.0/api/#scala.slick.lifted.BooleanColumnExtensionMethods)).
    For the methods available on numeric columns, consult the API documentation for
    `NumericColumnExtensionMethods` ([http://slick.typesafe.com/doc/2.1.0/api/#scala.slick.lifted.NumericColumnExtensionMethods](http://slick.typesafe.com/doc/2.1.0/api/#scala.slick.lifted.NumericColumnExtensionMethods)).
  prefs: []
  type: TYPE_NORMAL
- en: Aggregations with "Group by"
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Slick also provides a `groupBy` method that behaves like the `groupBy` method
    of native Scala collections. Let''s get a list of candidates with all the donations
    for each candidate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE265]'
  prefs: []
  type: TYPE_PRE
- en: Let's break this down. The first statement, `transactions.groupBy { _.candidate
    }`, specifies the key by which to group. You can think of this as building an
    intermediate list of `(String, List[Transaction])` tuples mapping the group key
    to a list of all the table rows that satisfy this key. This behavior is identical
    to calling `groupBy` on a Scala collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'The call to `groupBy` must be followed by a `map` that aggregates the groups.
    The function passed to `map` must take the tuple `(String, List[Transaction])`
    pair created by the `groupBy` call as its sole argument. The `map` call is responsible
    for aggregating the `List[Transaction]` object. We choose to first pick out the
    `amount` field of each transaction, and then to run a sum over these. Finally,
    we call `.list` on the whole pipeline to actually run the query. This just returns
    a Scala list. Let''s convert the total donations from cents to dollars:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE266]'
  prefs: []
  type: TYPE_PRE
- en: Accessing database metadata
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Commonly, especially during development, you might start the script by dropping
    the table if it exists, then recreating it. We can find if a table is defined
    by accessing the database metadata through the `MTable` object. To get a list
    of tables with name matching a certain pattern, we can run `MTable.getTables(pattern)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE267]'
  prefs: []
  type: TYPE_PRE
- en: 'Thus, to drop the transactions table if it exists, we can run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE268]'
  prefs: []
  type: TYPE_PRE
- en: 'The `MTable` instance contains a lot of metadata about the table. Go ahead
    and recreate the `transactions` table if you dropped it in the previous example.
    Then, to find information about the table''s primary keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE269]'
  prefs: []
  type: TYPE_PRE
- en: For a full list of methods available on `MTable` instances, consult the Slick
    documentation ([http://slick.typesafe.com/doc/2.1.0/api/index.html#scala.slick.jdbc.meta.MTable](http://slick.typesafe.com/doc/2.1.0/api/index.html#scala.slick.jdbc.meta.MTable)).
  prefs: []
  type: TYPE_NORMAL
- en: Slick versus JDBC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter and the previous one introduced two different ways of interacting
    with SQL. In the previous chapter, we described how to use JDBC and build extensions
    on top of JDBC to make it more usable. In this chapter, we introduced Slick, a
    library that provides a functional interface on top of JDBC.
  prefs: []
  type: TYPE_NORMAL
- en: Which method should you choose? If you are starting a new project, you should
    consider using Slick. Even if you spend a considerable amount of time writing
    wrappers that sit on top of JDBC, it is unlikely that you will achieve the fluidity
    that Slick offers.
  prefs: []
  type: TYPE_NORMAL
- en: If you are working on an existing project that makes extensive use of JDBC,
    I hope that the previous chapter demonstrates that, with a little time and effort,
    you can write JDBC wrappers that reduce the impedance between the imperative style
    of JDBC and Scala's functional approach.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous two chapters, we looked extensively at how to query relational
    databases from Scala. In this chapter, you learned how to use Slick, a "functional-relational"
    mapper that allows interacting with SQL databases as one would with Scala collections.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn how to ingest data by querying web APIs.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To learn more about Slick, you can refer to the Slick documentation ([http://slick.typesafe.com/doc/2.1.0/](http://slick.typesafe.com/doc/2.1.0/))
    and its API documentation ([http://slick.typesafe.com/doc/2.1.0/api/#package](http://slick.typesafe.com/doc/2.1.0/api/#package)).
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 7. Web APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data scientists and data engineers get data from a variety of different sources.
    Often, data might come as CSV files or database dumps. Sometimes, we have to obtain
    the data through a web API.
  prefs: []
  type: TYPE_NORMAL
- en: 'An individual or organization sets up a web API to distribute data to programs
    over the Internet (or an internal network). Unlike websites, where the data is
    intended to be consumed by a web browser and shown to the user, the data provided
    by a web API is agnostic to the type of program querying it. Web servers serving
    HTML and web servers backing an API are queried in essentially the same way: through
    HTTP requests.'
  prefs: []
  type: TYPE_NORMAL
- en: We have already seen an example of a web API in [Chapter 4](part0036.xhtml#aid-12AK82
    "Chapter 4. Parallel Collections and Futures"), *Parallel Collections and Futures*,
    where we queried the "Markit on demand" API for current stock prices. In this
    chapter, we will explore how to interact with web APIs in more detail; specifically,
    how to convert the data returned by the API to Scala objects and how to add additional
    information to the request through HTTP headers (for authentication, for instance).
  prefs: []
  type: TYPE_NORMAL
- en: The "Markit on demand" API returned the data formatted as an XML object, but
    increasingly, new web APIs return data formatted as JSON. We will therefore focus
    on JSON in this chapter, but the concepts will port easily to XML.
  prefs: []
  type: TYPE_NORMAL
- en: JSON is a language for formatting structured data. Many readers will have come
    across JSON in the past, but if not, there is a brief introduction to the syntax
    and concepts later on in this chapter. You will find it quite straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will poll the GitHub API. GitHub has, over the last few
    years, become the de facto tool for collaborating on open source software. It
    provides a powerful, feature-rich API that gives programmatic access to nearly
    all the data available through the website.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get a taste of what we can do. Type `api.github.com/users/odersky` in
    your web browser address bar. This will return the data offered by the API on
    a particular user (Martin Odersky, in this case):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE270]'
  prefs: []
  type: TYPE_PRE
- en: The data is returned as a JSON object. This chapter is devoted to learning how
    to access and parse this data programmatically. In [Chapter 13](part0125.xhtml#aid-3N6MA1
    "Chapter 13. Web APIs with Play"), *Web APIs with Play*, you will learn how to
    build your own web API.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The GitHub API is extensive and very well-documented. We will explore some of
    the features of the API in this chapter. To see the full extent of the API, visit
    the documentation ([https://developer.github.com/v3/](https://developer.github.com/v3/)).
  prefs: []
  type: TYPE_NORMAL
- en: A whirlwind tour of JSON
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JSON is a format for transferring structured data. It is flexible, easy for
    computers to generate and parse, and relatively readable for humans. It has become
    very common as a means of persisting program data structures and transferring
    data between programs.
  prefs: []
  type: TYPE_NORMAL
- en: 'JSON has four basic types: **Numbers**, **Strings**, **Booleans**, and **null**,
    and two compound types: **Arrays** and **Objects**. Objects are unordered collections
    of key-value pairs, where the key is always a string and the value can be any
    simple or compound type. We have already seen a JSON object: the data returned
    by the API call `api.github.com/users/odersky`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Arrays are ordered lists of simple or compound types. For instance, type [api.github.com/users/odersky/repos](http://api.github.com/users/odersky/repos)
    in your browser to get an array of objects, each representing a GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE271]'
  prefs: []
  type: TYPE_PRE
- en: We can construct complex structures by nesting objects within other objects
    or arrays. Nevertheless, most web APIs return JSON structures with no more than
    one or two levels of nesting. If you are not familiar with JSON, I encourage you
    to explore the GitHub API through your web browser.
  prefs: []
  type: TYPE_NORMAL
- en: Querying web APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The easiest way of querying a web API from Scala is to use `Source.fromURL`.
    We have already used this in [Chapter 4](part0036.xhtml#aid-12AK82 "Chapter 4. Parallel
    Collections and Futures"), *Parallel Collections and Futures*, when we queried
    the "Markit on demand" API. `Source.fromURL` presents an interface similar to
    `Source.fromFile`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE272]'
  prefs: []
  type: TYPE_PRE
- en: '`Source.fromURL` returns an iterator over the characters of the response. We
    materialize the iterator into a string using its `.mkString` method. We now have
    the response as a Scala string. The next step is to parse the string with a JSON
    parser.'
  prefs: []
  type: TYPE_NORMAL
- en: JSON in Scala – an exercise in pattern matching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are several libraries for manipulating JSON in Scala. We prefer json4s,
    but if you are a die-hard fan of another JSON library, you should be able to readily
    adapt the examples in this chapter. Let''s create a `build.sbt` file with a dependency
    on `json4s`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE273]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then import `json4s` into an SBT console session with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE274]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s use `json4s` to parse the response to our GitHub API query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE275]'
  prefs: []
  type: TYPE_PRE
- en: The `parse` method takes a string (that contains well-formatted JSON) and converts
    it to a `JValue`, a supertype for all `json4s` objects. The runtime type of the
    response to this particular query is `JObject`, which is a `json4s` type representing
    a JSON object.
  prefs: []
  type: TYPE_NORMAL
- en: '`JObject` is a wrapper around a `List[JField]`, and `JField` represents an
    individual key-value pair in the object. We can use *extractors* to access this
    list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE276]'
  prefs: []
  type: TYPE_PRE
- en: 'What''s happened here? By writing `val JObject(fields) = ...`, we are telling
    Scala:'
  prefs: []
  type: TYPE_NORMAL
- en: The right-hand side has runtime type of `JObject`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go into the `JObject` instance and bind the list of fields to the constant `fields`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Readers familiar with Python might recognize the similarity with tuple unpacking,
    though Scala extractors are much more powerful and versatile. Extractors are used
    extensively to extract Scala types from `json4s` types.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Pattern matching using case classes**'
  prefs: []
  type: TYPE_NORMAL
- en: 'How exactly does the Scala compiler know what to do with an extractor such
    as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE277]'
  prefs: []
  type: TYPE_PRE
- en: '`JObject` is a case class with the following constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE278]'
  prefs: []
  type: TYPE_PRE
- en: Case classes all come with an extractor that reverses the constructor exactly.
    Thus, writing `val JObject(fields)` will bind `fields` to the `obj` attribute
    of the `JObject`. For further details on how extractors work, read [Appendix](part0149.xhtml#aid-4E33Q2
    "Appendix A. Pattern Matching and Extractors"), *Pattern Matching and Extractors*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have now extracted `fields`, a (plain old Scala) list of fields from the
    `JObject`. A `JField` is a key-value pair, with the key being a string and value
    being a subtype of `JValue`. Again, we can use extractors to extract the values
    in the field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE279]'
  prefs: []
  type: TYPE_PRE
- en: We matched the right-hand side against the pattern `JField(_, JString(_))`,
    binding the first element to `key` and the second to `value`. What happens if
    the right-hand side does not match the pattern?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE280]'
  prefs: []
  type: TYPE_PRE
- en: 'The code throws a `MatchError` at runtime. These examples demonstrate the power
    of nested pattern matching: in a single line, we managed to verify the type of
    `firstField`, that its value has type `JString`, and we have bound the key and
    value to the `key` and `value` variables, respectively. As another example, if
    we *know* that the first field is the login field, we can both verify this and
    extract the value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE281]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice how this style of programming is *declarative* rather than imperative:
    we declare that we want a `JField("login", JString(_))` variable on the right-hand
    side. We then let the language figure out how to check the variable types. Pattern
    matching is a recurring theme in functional languages.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use pattern matching in a for loop when looping over fields. When
    used in a for loop, a pattern match defines a *partial function*: only elements
    that match the pattern pass through the loop. This lets us filter the collection
    for elements that match a pattern and also apply a transformation to these elements.
    For instance, we can extract every string field in our `fields` list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE282]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use this to search for specific fields. For instance, to extract the
    `"followers"` field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE283]'
  prefs: []
  type: TYPE_PRE
- en: We first extracted all fields that matched the pattern `JField("follower", JInt(_))`,
    returning the integer inside the `JInt`. As the source collection, `fields`, is
    a list, this returns a list of integers. We then extract the first value from
    this list using `headOption`, which returns the head of the list if the list has
    at least one element, or `None` if the list is empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are not limited to extracting a single field at a time. For instance, to
    extract the `"id"` and `"login"` fields together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE284]'
  prefs: []
  type: TYPE_PRE
- en: Scala's pattern matching and extractors provide you with an extremely powerful
    way of traversing the `json4s` tree, extracting the fields that we need.
  prefs: []
  type: TYPE_NORMAL
- en: JSON4S types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have already discovered parts of `json4s`''s type hierarchy: strings are
    wrapped in `JString` objects, integers (or big integers) are wrapped in `JInt`,
    and so on. In this section, we will take a step back and formalize the type structure
    and what Scala types they extract to. These are the `json4s` runtime types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`val JString(s) // => extracts to a String`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`val JDouble(d) // => extracts to a Double`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`val JDecimal(d) // => extracts to a BigDecimal`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`val JInt(i) // => extracts to a BigInt`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`val JBool(b) // => extracts to a Boolean`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`val JObject(l) // => extracts to a List[JField]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`val JArray(l) // => extracts to a List[JValue]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`JNull // => represents a JSON null`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All these types are subclasses of `JValue`. The compile-time result of `parse`
    is `JValue`, which you normally need to cast to a concrete type using an extractor.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last type in the hierarchy is `JField`, which represents a key-value pair.
    `JField` is just a type alias for the `(String, JValue)` tuple. It is thus not
    a subtype of `JValue`. We can extract the key and value using the following extractor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE285]'
  prefs: []
  type: TYPE_PRE
- en: Extracting fields using XPath
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous sections, you learned how to traverse JSON objects using extractors.
    In this section, we will look at a different way of traversing JSON objects and
    extracting specific fields: the *XPath DSL* (domain-specific language). XPath
    is a query language for traversing tree-like structures. It was originally designed
    for addressing specific nodes in an XML document, but it works just as well with
    JSON. We have already seen an example of XPath syntax when we extracted the stock
    price from the XML document returned by the "Markit on demand" API in [Chapter
    4](part0036.xhtml#aid-12AK82 "Chapter 4. Parallel Collections and Futures"), *Parallel
    Collections and Futures*. We extracted the node with tag `"LastPrice"` using `r
    \ "LastPrice"`. The `\` operator was defined by the `scala.xml` package.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `json4s` package exposes a similar DSL to extract fields from `JObject`
    instances. For instance, we can extract the `"login"` field from the JSON object
    `jsonResponse`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE286]'
  prefs: []
  type: TYPE_PRE
- en: 'This returns a `JValue` that we can transform into a Scala string using an
    extractor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE287]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the similarity between the XPath DSL and traversing a filesystem: we
    can think of `JObject` instances as directories. Field names correspond to file
    names and the field value to the content of the file. This is more evident for
    nested structures. The `users` endpoint of the GitHub API does not have nested
    documents, so let''s try another endpoint. We will query the API for the repository
    corresponding to this book: "[https://api.github.com/repos/pbugnion/s4ds](https://api.github.com/repos/pbugnion/s4ds)".
    The response has the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE288]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s fetch this document and use the XPath syntax to extract the repository
    owner''s login name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE289]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, this is much like traversing a filesystem: `jsonResponse \ "owner"`
    returns a `JObject` corresponding to the `"owner"` object. This `JObject` can,
    in turn, be queried for the `"login"` field, returning the value `JString(pbugnion)`
    associated with this key.'
  prefs: []
  type: TYPE_NORMAL
- en: 'What if the API response is an array? The filesystem analogy breaks down somewhat.
    Let''s query the API endpoint listing Martin Odersky''s repositories: [https://api.github.com/users/odersky/repos](https://api.github.com/users/odersky/repos).
    The response is an array of JSON objects, each of which represents a repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE290]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s fetch this and parse it as JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE291]'
  prefs: []
  type: TYPE_PRE
- en: 'This returns a `JArray`. The XPath DSL works in the same way on a `JArray`
    as on a `JObject`, but now, instead of returning a single `JValue`, it returns
    an array of fields matching the path in every object in the array. Let''s get
    the size of all Martin Odersky''s repositories:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE292]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have a `JArray` of the values corresponding to the `"size"` field in
    every repository. We can iterate over this array with a `for` comprehension and
    use extractors to convert elements to Scala objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE293]'
  prefs: []
  type: TYPE_PRE
- en: Thus, combining extractors with the XPath DSL gives us powerful, complementary
    tools to extract information from JSON objects.
  prefs: []
  type: TYPE_NORMAL
- en: There is much more to the XPath syntax than we have space to cover here, including
    the ability to extract fields nested at any level of depth below the current root
    or fields that match a predicate or a certain type. We find that well-designed
    APIs obviate the need for many of these more powerful functions, but do consult
    the documentation (`json4s.org`) to get an overview of what you can do.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will look at extracting JSON directly into case classes.
  prefs: []
  type: TYPE_NORMAL
- en: Extraction using case classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous sections, we extracted specific fields from the JSON response
    using Scala extractors. We can do one better and extract full case classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'When moving beyond the REPL, programming best practice dictates that we move
    from `json4s` types to Scala objects as soon as possible rather than passing `json4s`
    types around the program. Converting from `json4s` types to Scala types (or case
    classes representing domain objects) is good practice because:'
  prefs: []
  type: TYPE_NORMAL
- en: It decouples the program from the structure of the data that we receive from
    the API, something we have little control over.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It improves type safety: a `JObject` is, as far as the compiler is concerned,
    always a `JObject`, whatever fields it contains. By contrast, the compiler will
    never mistake a `User` for a `Repository`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Json4s` lets us extract case classes directly from `JObject` instances, making
    writing the layer converting `JObject` instances to custom types easy.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s define a case class representing a GitHub user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE294]'
  prefs: []
  type: TYPE_PRE
- en: 'To extract a case class from a `JObject`, we must first define an implicit
    `Formats` value that defines how simple types should be serialized and deserialized.
    We will use the default `DefaultFormats` provided with `json4s`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE295]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now extract instances of `User`. Let''s do this for Martin Odersky:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE296]'
  prefs: []
  type: TYPE_PRE
- en: 'This works as long as the object is well-formatted. The `extract` method looks
    for fields in the `JObject` that match the attributes of `User`. In this case,
    `extract` will note that the `JObject` contains the `"login": "odersky"` field
    and that `JString("odersky")` can be converted to a Scala string, so it binds
    `"odersky"` to the `login` attribute in `User`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'What if the attribute names differ from the field names in the JSON object?
    We must first transform the object to have the correct fields. For instance, let''s
    rename the `login` attribute to `userName` in our `User` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE297]'
  prefs: []
  type: TYPE_PRE
- en: 'If we try to use `extract[User]` on `jsonResponse`, we will get a mapping error
    because the deserializer is missing a `login` field in the response. We can fix
    this using the `transformField` method on `jsonResponse` to rename the `login`
    field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE298]'
  prefs: []
  type: TYPE_PRE
- en: 'What about optional fields? Let''s assume that the JSON object returned by
    the GitHub API does not always contain the login field. We could symbolize this
    in our object model by giving the `login` parameter the type `Option[String]`
    rather than `String`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE299]'
  prefs: []
  type: TYPE_PRE
- en: 'This works just as you would expect. When the response contains a non-null
    `login` field, calling `extract[User]` will deserialize it to `Some(value)`, and
    when it''s missing or `JNull`, it will produce `None`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE300]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s wrap this up in a small program. The program will take a single command-line
    argument, the user''s login name, extract a `User` instance, and print it to screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE301]'
  prefs: []
  type: TYPE_PRE
- en: 'We can run this from an SBT console as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE302]'
  prefs: []
  type: TYPE_PRE
- en: Concurrency and exception handling with futures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While the program that we wrote in the previous section works, it is very brittle.
    It will crash if we enter a non-existent user name or the GitHub API changes or
    returns a badly-formatted response. We need to make it fault-tolerant.
  prefs: []
  type: TYPE_NORMAL
- en: What if we also wanted to fetch multiple users? The program, as written, is
    entirely single-threaded. The `fetchUserFromUrl` method fires a call to the API
    and blocks until the API sends data back. A better solution would be to fetch
    multiple users in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you learned in [Chapter 4](part0036.xhtml#aid-12AK82 "Chapter 4. Parallel
    Collections and Futures"), *Parallel Collections and Futures*, there are two straightforward
    ways to implement both fault tolerance and parallel execution: we can either put
    all the user names in a parallel collection and wrap the code for fetching and
    extracting the user in a `Try` block or we can wrap each query in a future.'
  prefs: []
  type: TYPE_NORMAL
- en: When querying web APIs, it is sometimes the case that a request can take abnormally
    long. To prevent this from blocking the other threads, it is preferable to rely
    on futures rather than parallel collections for concurrency, as we saw in the
    *Parallel collection or Future?* section at the end of [Chapter 4](part0036.xhtml#aid-12AK82
    "Chapter 4. Parallel Collections and Futures"), *Parallel Collections and Futures*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s rewrite the code from the previous section to handle fetching multiple
    users concurrently in a fault-tolerant manner. We will change the `fetchUserFromUrl`
    method to query the API asynchronously. This is not terribly different from [Chapter
    4](part0036.xhtml#aid-12AK82 "Chapter 4. Parallel Collections and Futures"), *Parallel
    Collections and Futures*, in which we queried the "Markit on demand" API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE303]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run the code through `sbt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE304]'
  prefs: []
  type: TYPE_PRE
- en: 'The code itself should be straightforward. All the concepts used here have
    been explored in this chapter or in [Chapter 4](part0036.xhtml#aid-12AK82 "Chapter 4. Parallel
    Collections and Futures"), *Parallel Collections and Futures*, apart from the
    last line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE305]'
  prefs: []
  type: TYPE_PRE
- en: This statement tells the program to wait until all futures in our list have
    been completed. `Await.ready(..., 1 minute)` takes a future as its first argument
    and blocks execution until this future returns. The second argument is a time-out
    on this future. The only catch is that we need to pass a single future to `Await`
    rather than a list of futures. We can use `Future.sequence` to merge a collection
    of futures into a single future. This future will be completed when all the futures
    in the sequence have completed.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication – adding HTTP headers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have been using the GitHub API without authentication. This limits
    us to sixty requests per hour. Now that we can query the API in parallel, we could
    exceed this limit in seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, GitHub is much more generous if you authenticate when you query
    the API. The limit increases to 5,000 requests per hour. You must have a GitHub
    user account to authenticate, so go ahead and create one now if you need to. After
    creating an account, navigate to [https://github.com/settings/tokens](https://github.com/settings/tokens)
    and click on the **Generate new token** button. Accept the default settings and
    enter a token description and a long hexadecimal number should appear on the screen.
    Copy the token for now.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP – a whirlwind overview
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before using our newly generated token, let's take a few minutes to review how
    HTTP works.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP is a protocol for transferring information between different computers.
    It is the protocol that we have been using throughout the chapter, though Scala
    hid the details from us in the call to `Source.fromURL`. It is also the protocol
    that you use when you point your web browser to a website, for instance.
  prefs: []
  type: TYPE_NORMAL
- en: In HTTP, a computer will typically make a *request* to a remote server, and
    the server will send back a *response*. Requests contain a *verb*, which defines
    the type of request, and a URL identifying a *resource*. For instance, when we
    typed [api.github.com/users/pbugnion](http://api.github.com/users/pbugnion) in
    our browsers, this was translated into a GET (the verb) request for the `users/pbugnion`
    resource. All the calls that we have made so far have been GET requests. You might
    use a different type of request, for instance, a POST request, to modify (rather
    than just view) some content on GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides the verb and resource, there are two more parts to an HTTP request:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The *headers* include metadata about the request, such as the expected format
    and character set of the response or the authentication credentials. Headers are
    just a list of key-value pairs. We will pass the OAuth token that we have just
    generated to the API using the `Authorization` header. This Wikipedia article
    lists commonly used header fields: [en.wikipedia.org/wiki/List_of_HTTP_header_fields](http://en.wikipedia.org/wiki/List_of_HTTP_header_fields).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The request body is not used in GET requests but becomes important for requests
    that modify the resource they query. For instance, if I wanted to create a new
    repository on GitHub programmatically, I would send a POST request to `/pbugnion/repos`.
    The POST body would then be a JSON object describing the new repository. We will
    not use the request body in this chapter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding headers to HTTP requests in Scala
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will pass the OAuth token as a header with our HTTP request. Unfortunately,
    the `Source.fromURL` method is not particularly suited to adding headers when
    creating a GET request. We will, instead, use a library, `scalaj-http`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add `scalaj-http` to the dependencies in our `build.sbt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE306]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now import `scalaj-http`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE307]'
  prefs: []
  type: TYPE_PRE
- en: 'We start by creating an `HttpRequest` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE308]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now add the authorization header to the request (add your own token
    string here):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE309]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `.header` method returns a new `HttpRequest` instance. It does not modify
    the request in place. Thus, just calling `request.header(...)` does not actually
    add the header to request itself, which can be a source of confusion.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s fire the request. We do this through the request''s `asString` method,
    which queries the API, fetches the response, and parses it as a Scala `String`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE310]'
  prefs: []
  type: TYPE_PRE
- en: 'The response is made up of three components:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The status code, which should be `200` for a successful request:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE311]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The response body, which is the part that we are interested in:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE312]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The response headers (metadata about the response):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE313]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To verify that the authorization was successful, query the `X-RateLimit-Limit`
    header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE314]'
  prefs: []
  type: TYPE_PRE
- en: This value is the maximum number of requests per hour that you can make to the
    GitHub API from a single IP address.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have some understanding of how to add authentication to GET requests,
    let''s modify our script for fetching users to use the OAuth token for authentication.
    We first need to import `scalaj-http`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE315]'
  prefs: []
  type: TYPE_PRE
- en: 'Injecting the value of the token into the code can be somewhat tricky. You
    might be tempted to hardcode it, but this prohibits you from sharing the code.
    A better solution is to use an *environment variable*. Environment variables are
    a set of variables present in your terminal session that are accessible to all
    processes running in that session. To get a list of the current environment variables,
    type the following on Linux or Mac OS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE316]'
  prefs: []
  type: TYPE_PRE
- en: 'On Windows, the equivalent command is `SET`. Let''s add the GitHub token to
    the environment. Use the following command on Mac OS or Linux:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE317]'
  prefs: []
  type: TYPE_PRE
- en: 'On Windows, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE318]'
  prefs: []
  type: TYPE_PRE
- en: If you were to reuse this environment variable across many projects, entering
    `export GHTOKEN=...` in the shell for every session gets old quite quickly. A
    more permanent solution is to add `export GHTOKEN="e83638…"` to your shell configuration
    file (your `.bashrc` file if you are using Bash). This is safe provided your `.bashrc`
    is readable by the user only. Any new shell session will have access to the `GHTOKEN`
    environment variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can access environment variables from a Scala program using `sys.env`, which
    returns a `Map[String, String]` of the variables. Let''s add a `lazy val token`
    to our class, containing the `token` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE319]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have the token, the only part of the code that must change, to
    add authentication, is the `fetchUserFromUrl` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE320]'
  prefs: []
  type: TYPE_PRE
- en: Additionally, we can, to gain clearer error messages, check that the response's
    status code is 200\. As this is straightforward, it is left as an exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you learned how to query the GitHub API, converting the response
    to Scala objects. Of course, merely printing results to screen is not terribly
    interesting. In the next chapter, we will look at the next step of the data ingestion
    process: storing data in a database. We will query the GitHub API and store the
    results in a MongoDB database.'
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 13](part0125.xhtml#aid-3N6MA1 "Chapter 13. Web APIs with Play"),
    *Web APIs with Play*, we will look at building our own simple web API.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The GitHub API, with its extensive documentation, is a good place to explore
    how a rich API is constructed. It has a **Getting Started** section that is worth
    reading:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://developer.github.com/guides/getting-started/](https://developer.github.com/guides/getting-started/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, this is not specific to Scala: it uses cURL to query the API.'
  prefs: []
  type: TYPE_NORMAL
- en: Read the documentation ([http://json4s.org](http://json4s.org)) and source code
    ([https://github.com/json4s/json4s](https://github.com/json4s/json4s)) for `json4s`
    for a complete reference. There are many parts of this package that we have not
    explored, in particular, how to build JSON from Scala.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 8. Scala and MongoDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 5](part0040.xhtml#aid-164MG1 "Chapter 5. Scala and SQL through JDBC"),
    *Scala and SQL through JDBC*, and [Chapter 6](part0051.xhtml#aid-1GKCM2 "Chapter 6. Slick
    – A Functional Interface for SQL"), *Slick – A Functional Interface for SQL*,
    you learned how to insert, transform, and read data in SQL databases. These databases
    remain (and are likely to remain) very popular in data science, but NoSQL databases
    are emerging as strong contenders.
  prefs: []
  type: TYPE_NORMAL
- en: 'The needs for data storage are growing rapidly. Companies are producing and
    storing more data points in the hope of acquiring better business intelligence.
    They are also building increasingly large teams of data scientists, who all need
    to access the data store. Maintaining constant access time as the data load increases
    requires taking advantage of parallel architectures: we need to distribute the
    database across several computers so that, as the load on the server increases,
    we can just add more machines to improve throughput.'
  prefs: []
  type: TYPE_NORMAL
- en: In MySQL databases, the data is naturally split across different tables. Complex
    queries necessitate joining across several tables. This makes partitioning the
    database across different computers difficult. NoSQL databases emerged to fill
    this gap.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn to interact with MongoDB, an open source database
    that offers high performance and can be distributed easily. MongoDB is one of
    the more popular NoSQL databases with a strong community. It offers a reasonable
    balance of speed and flexibility, making it a natural alternative to SQL for storing
    large datasets with uncertain query requirements, as might happen in data science.
    Many of the concepts and recipes in this chapter will apply to other NoSQL databases.
  prefs: []
  type: TYPE_NORMAL
- en: MongoDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'MongoDB is a *document-oriented* database. It contains collections of documents.
    Each document is a JSON-like object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE321]'
  prefs: []
  type: TYPE_PRE
- en: Just as in JSON, a document is a set of key-value pairs, where the values can
    be strings, numbers, Booleans, dates, arrays, or subdocuments. Documents are grouped
    in collections, and collections are grouped in databases.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might be thinking that this is not very different from SQL: a document
    is similar to a row and a collection corresponds to a table. There are two important
    differences:'
  prefs: []
  type: TYPE_NORMAL
- en: The values in documents can be simple values, arrays, subdocuments, or arrays
    of subdocuments. This lets us encode one-to-many and many-to-many relationships
    in a single collection. For instance, consider the wizard collection. In SQL,
    if we wanted to store pseudonyms for each wizard, we would have to use a separate
    `wizard2pseudonym` table with a row for each wizard-pseudonym pair. In MongoDB,
    we can just use an array. In practice, this means that we can normally use a single
    document to represent an entity (a customer, transaction, or wizard, for instance).
    In SQL, we would normally have to join across several tables to retrieve all the
    information on a specific entity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'MongoDB is *schemaless*. Documents in a collection can have varying sets of
    fields with different types for the same field across different documents. In
    practice, MongoDB collections have a loose schema enforced either client side
    or by convention: most documents will have a subset of the same fields, and fields
    will, in general, contain the same data type. Having a flexible schema makes adjusting
    the data structure easy as there is no need for time-consuming `ALTER` `TABLE`
    statements. The downside is that there is no easy way of enforcing our flexible
    schema on the database side.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Note the `_id` field: this is a unique key. MongoDB will generate one automatically
    if we insert a document without an `_id` field.'
  prefs: []
  type: TYPE_NORMAL
- en: This chapter gives recipes for interacting with a MongoDB database from Scala,
    including maintaining type safety and best practices. We will not cover advanced
    MongoDB functionality (such as aggregation or distributing the database). We will
    assume that you have MongoDB installed on your computer ([http://docs.mongodb.org/manual/installation/](http://docs.mongodb.org/manual/installation/)).
    It will also help to have a very basic knowledge of MongoDB (we discuss some references
    at the end of this chapter, but any basic tutorial available online will be sufficient
    for the needs of this chapter).
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to MongoDB with Casbah
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The official MongoDB driver for Scala is called **Casbah**. Rather than a fully-fledged
    driver, Casbah wraps the Java Mongo driver, providing a more functional interface.
    There are other MongoDB drivers for Scala, which we will discuss briefly at the
    end of this chapter. For now, we will stick to Casbah.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by adding Casbah to our `build.sbt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE322]'
  prefs: []
  type: TYPE_PRE
- en: 'Casbah also expects `slf4j` bindings (a Scala logging framework) to be available,
    so let''s also add `slf4j-nop`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE323]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now start an SBT console and import Casbah in the Scala shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE324]'
  prefs: []
  type: TYPE_PRE
- en: 'This connects to a MongoDB server on the default host (`localhost`) and default
    port (`27017`). To connect to a different server, pass the host and port as arguments
    to `MongoClient`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE325]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that creating a client is a lazy operation: it does not attempt to connect
    to the server until it needs to. This means that if you enter the wrong URL or
    password, you will not know about it until you try and access documents on the
    server.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have a connection to the server, accessing a database is as simple
    as using the client''s `apply` method. For instance, to access the `github` database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE326]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then access the `"users"` collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE327]'
  prefs: []
  type: TYPE_PRE
- en: Connecting with authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MongoDB supports several different authentication mechanisms. In this section,
    we will assume that your server is using the **SCRAM-SHA-1** mechanism, but you
    should find adapting the code to a different type of authentication straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: 'The easiest way of authenticating is to pass `username` and `password` in the
    URI when connecting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE328]'
  prefs: []
  type: TYPE_PRE
- en: 'In general, you will not want to put your password in plain text in the code.
    You can either prompt for a password on the command line or pass it through environment
    variables, as we did with the GitHub OAuth token in [Chapter 7](part0059.xhtml#aid-1O8H61
    "Chapter 7. Web APIs"), *Web APIs*. The following code snippet demonstrates how
    to pass credentials through the environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE329]'
  prefs: []
  type: TYPE_PRE
- en: 'You can run it through SBT as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE330]'
  prefs: []
  type: TYPE_PRE
- en: Inserting documents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s insert some documents into our newly created database. We want to store
    information about GitHub users, using the following document structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE331]'
  prefs: []
  type: TYPE_PRE
- en: 'Casbah provides a `DBObject` class to represent MongoDB documents (and subdocuments)
    in Scala. Let''s start by creating a `DBObject` instance for each repository subdocument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE332]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, a `DBObject` is just a list of key-value pairs, where the keys
    are strings. The values have compile-time type `AnyRef`, but Casbah will fail
    (at runtime) if you try to add a value that cannot be serialized.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also create `DBObject` instances from lists of key-value pairs directly.
    This is particularly useful when converting from a Scala map to a `DBObject`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE333]'
  prefs: []
  type: TYPE_PRE
- en: 'The `DBObject` class provides many of the same methods as a map. For instance,
    we can address individual fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE334]'
  prefs: []
  type: TYPE_PRE
- en: 'We can construct a new object by adding a field to an existing object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE335]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the return type: `mutable.Map[String,Any]`. Rather than implementing methods
    such as `+` directly, Casbah adds them to `DBObject` by providing an implicit
    conversion to and from `mutable.Map`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'New `DBObject` instances can also be created by concatenating two existing
    instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE336]'
  prefs: []
  type: TYPE_PRE
- en: '`DBObject` instances can then be inserted into a collection using the `+=`
    operator. Let''s insert our first document into the `user` collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE337]'
  prefs: []
  type: TYPE_PRE
- en: A database containing a single document is a bit boring, so let's add a few
    more documents queried directly from the GitHub API. You learned how to query
    the GitHub API in the previous chapter, so we won't dwell on how to do this here.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the code examples for this chapter, we have provided a class called `GitHubUserIterator`
    that queries the GitHub API (specifically the `/users` endpoint) for user documents,
    converts them to a case class, and offers them as an iterator. You will find the
    class in the code examples for this chapter (available on GitHub at [https://github.com/pbugnion/s4ds/tree/master/chap08](https://github.com/pbugnion/s4ds/tree/master/chap08))
    in the `GitHubUserIterator.scala` file. The easiest way to have access to the
    class is to open an SBT console in the directory of the code examples for this
    chapter. The API then fetches users in increasing order of their login ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE338]'
  prefs: []
  type: TYPE_PRE
- en: '`GitHubUserIterator` returns instances of the `User` case class, defined as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE339]'
  prefs: []
  type: TYPE_PRE
- en: Let's write a short program to fetch 500 users and insert them into the MongoDB
    database. We will need to authenticate with the GitHub API to retrieve these users.
    The constructor for `GitHubUserIterator` takes the GitHub OAuth token as an optional
    argument. We will inject the token through the environment, as we did in the previous
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We first give the entire code listing before breaking it down—if you are typing
    this out, you will need to copy `GitHubUserIterator.scala` from the code examples
    for this chapter to the directory in which you are running this to access the
    `GitHubUserIterator` class. The class relies on `scalaj-http` and `json4s`, so
    either copy the `build.sbt` file from the code examples or specify those packages
    as dependencies in your `build.sbt` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE340]'
  prefs: []
  type: TYPE_PRE
- en: 'Before diving into the details of how this program works, let''s run it through
    SBT. You will want to query the API with authentication to avoid hitting the rate
    limit. Recall that we need to set the `GHTOKEN` environment variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE341]'
  prefs: []
  type: TYPE_PRE
- en: 'The program will take about five minutes to run (depending on your Internet
    connection). To verify that the program works, we can query the number of documents
    in the `users` collection of the `github` database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE342]'
  prefs: []
  type: TYPE_PRE
- en: Let's break the code down. We first load the OAuth token to authenticate with
    the GithHub API. The token is stored as an environment variable, `GHTOKEN`. The
    `token` variable is a `lazy val`, so the token is loaded only when we formulate
    the first request to the API. We have already used this pattern in [Chapter 7](part0059.xhtml#aid-1O8H61
    "Chapter 7. Web APIs"), *Web APIs*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then define two methods to transform from classes in the domain model to
    `DBObject` instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE343]'
  prefs: []
  type: TYPE_PRE
- en: 'Armed with these two methods, we can add users to our MongoDB collection easily:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE344]'
  prefs: []
  type: TYPE_PRE
- en: 'We used currying to split the arguments of `insertUsers`. This lets us use
    `insertUsers` as a function factory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE345]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a new method, `inserter`, with signature `Iterable[User] => Unit`
    that inserts users into `coll`. To see how this might come in useful, let''s write
    a function to wrap the whole data ingestion process. This is how a first attempt
    at this function could look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE346]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice how `ingestUsers` takes a method that specifies how the list of users
    is inserted into the database as its second argument. This function encapsulates
    the entire code specific to insertion into a MongoDB collection. If we decide,
    at some later date, that we hate MongoDB and must insert the documents into a
    SQL database or write them to a flat file, all we need to do is pass a different
    `inserter` function to `ingestUsers`. The rest of the code remains the same. This
    demonstrates the increased flexibility afforded by using higher-order functions:
    we can easily build a framework and let the client code plug in the components
    that it needs.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ingestUsers` method, as defined previously, has one problem: if the `nusers`
    value is large, it will consume a lot of memory in constructing the entire list
    of users. A better solution would be to break it down into batches: we fetch a
    batch of users from the API, insert them into the database, and move on to the
    next batch. This allows us to control memory usage by changing the batch size.
    It is also more fault tolerant: if the program crashes, we can just restart from
    the last successfully inserted batch.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `.grouped` method, available on all iterables, is useful for batching.
    It returns an iterator over fragments of the original iterable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE347]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s rewrite our `ingestUsers` method to use batches. We will also add a
    progress report after each batch in order to give the user some feedback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE348]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at the highlighted line more closely. We start from the user iterator,
    `it`. We then take the first `nusers`. This returns an `Iterator[User]` that,
    instead of happily churning through every user in the GitHub database, will terminate
    after `nusers`. We then group this iterator into batches of 100 users. The `.grouped`
    method returns `Iterator[Iterator[User]]`. We then zip each batch with its index
    so that we know which batch we are currently processing (we use this in the `print`
    statement). The `.zipWithIndex` method returns `Iterator[(Iterator[User], Int)]`.
    We unpack this tuple in the loop using a case statement that binds `users` to
    `Iterator[User]` and `batchNumber` to the index. Let''s run this through SBT:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE349]'
  prefs: []
  type: TYPE_PRE
- en: Extracting objects from the database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We now have a database populated with a few users. Let''s query this database
    from the REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE350]'
  prefs: []
  type: TYPE_PRE
- en: 'The `findOne` method returns a single `DBObject` object wrapped in an option,
    unless the collection is empty, in which case it returns `None`. We must therefore
    use the `get` method to extract the object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE351]'
  prefs: []
  type: TYPE_PRE
- en: 'As you learned earlier in this chapter, `DBObject` is a map-like object with
    keys of type `String` and values of type `AnyRef`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE352]'
  prefs: []
  type: TYPE_PRE
- en: 'In general, we want to restore compile-time type information as early as possible
    when importing objects from the database: we do not want to pass `AnyRef`s around
    when we can be more specific. We can use the `getAs` method to extract a field
    and cast it to a specific type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE353]'
  prefs: []
  type: TYPE_PRE
- en: 'If the field is missing in the document or if the value cannot be cast, `getAs`
    will return `None`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE354]'
  prefs: []
  type: TYPE_PRE
- en: The astute reader may note that the interface provided by `getAs[T]` is similar
    to the `read[T]` method that we defined on a JDBC result set in [Chapter 5](part0040.xhtml#aid-164MG1
    "Chapter 5. Scala and SQL through JDBC"), *Scala and SQL through JDBC*.
  prefs: []
  type: TYPE_NORMAL
- en: 'If `getAs` fails (for instance, because the field is missing), we can use the
    `orElse` partial function to recover:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE355]'
  prefs: []
  type: TYPE_PRE
- en: 'The `getAsOrElse` method allows us to substitute a default value if the cast
    fails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE356]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we can also use `getAsOrElse` to throw an exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE357]'
  prefs: []
  type: TYPE_PRE
- en: 'Arrays embedded in documents can be cast to `List[T]` objects, where `T` is
    the type of elements in the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE358]'
  prefs: []
  type: TYPE_PRE
- en: 'Retrieving a single document at a time is not very useful. To retrieve all
    the documents in a collection, use the `.find` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE359]'
  prefs: []
  type: TYPE_PRE
- en: 'This returns an iterator of `DBObject`s. To actually fetch the documents from
    the database, you need to materialize the iterator by transforming it into a collection,
    using, for instance, `.toList`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE360]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s bring all of this together. We will write a toy program that prints
    the average number of repositories per user in our collection. The code works
    by fetching every document in the collection, extracting the number of repositories
    from each document, and then averaging over these:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE361]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run this through SBT:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE362]'
  prefs: []
  type: TYPE_PRE
- en: The code starts with the `extractNumber` function, which extracts the number
    of repositories from each `DBObject`. The return value is `None` if the document
    does not contain the `repos` field.
  prefs: []
  type: TYPE_NORMAL
- en: The main body of the code starts by creating an iterator over `DBObject`s in
    the collection. This iterator is then mapped through the `extractNumber` function,
    which transforms it into an iterator of `Option[Int]`. We then run `.collect`
    on this iterator to collect all the values that are not `None`, converting from
    `Option[Int]` to `Int` in the process. Only then do we materialize the iterator
    to a list using `.toList`. The resulting list, `wellFormattedNumbers`, has the
    `List[Int]` type. We then just take the mean of this list and print it to screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that, besides the `extractNumber` function, none of this program deals
    with Casbah-specific types: the iterator returned by `.find()` is just a Scala
    iterator. This makes Casbah straightforward to use: the only data type that you
    need to familiarize yourself with is `DBObject` (compare this with JDBC''s `ResultSet`,
    which we had to explicitly wrap in a stream, for instance).'
  prefs: []
  type: TYPE_NORMAL
- en: Complex queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now know how to convert `DBObject` instances to custom Scala classes. In
    this section, you will learn how to construct queries that only return a subset
    of the documents in the collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous section, you learned to retrieve all the documents in a collection
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE363]'
  prefs: []
  type: TYPE_PRE
- en: The `collection.find()` method returns an iterator over all the documents in
    the collection. By calling `.toList` on this iterator, we materialize it to a
    list.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can customize which documents are returned by passing a query document to
    the `.find` method. For instance, we can retrieve documents for a specific login
    name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE364]'
  prefs: []
  type: TYPE_PRE
- en: 'MongoDB queries are expressed as `DBObject` instances. Keys in the `DBObject`
    correspond to fields in the collection''s documents, and the values are expressions
    controlling the allowed values of this field. Thus, `DBObject("login" -> "mojombo")`
    will select all the documents for which the `login` field is `mojombo`. Using
    a `DBObject` instance to represent a query might seem a little obscure, but it
    will quickly make sense if you read the MongoDB documentation ([https://docs.mongodb.org/manual/core/crud-introduction/](https://docs.mongodb.org/manual/core/crud-introduction/)):
    queries are themselves just JSON objects in MongoDB. Thus, the fact that the query
    in Casbah is represented as a `DBObject` is consistent with other MongoDB client
    implementations. It also allows someone familiar with MongoDB to start writing
    Casbah queries in no time.'
  prefs: []
  type: TYPE_NORMAL
- en: 'MongoDB supports more complex queries. For instance, to query everyone with
    `"github_id"` between `20` and `30`, we can write the following query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE365]'
  prefs: []
  type: TYPE_PRE
- en: We limit the range of values that `github_id` can take with `DBObject("$gte"
    -> 20, "$lt" -> 30)`. The `"$gte"` string indicates that `github_id` must be greater
    or equal to `20`. Similarly, `"$lt"` denotes the *less than* operator. To get
    a full list of operators that you can use when querying, consult the MongoDB reference
    documentation ([http://docs.mongodb.org/manual/reference/operator/query/](http://docs.mongodb.org/manual/reference/operator/query/)).
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we have only looked at queries on top-level fields. Casbah also lets
    us query fields in subdocuments and arrays using the *dot* notation. In the context
    of array values, this will return all the documents for which at least one value
    in the array matches the query. For instance, to retrieve all users who have a
    repository whose main language is Scala:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE366]'
  prefs: []
  type: TYPE_PRE
- en: Casbah query DSL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using `DBObject` instances to express queries can be very verbose and somewhat
    difficult to read. Casbah provides a DSL to express queries much more succinctly.
    For instance, to get all the documents with the `github_id` field between `20`
    and `30`, we would write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE367]'
  prefs: []
  type: TYPE_PRE
- en: The operators provided by the DSL will automatically construct `DBObject` instances.
    Using the DSL operators as much as possible generally leads to much more readable
    and maintainable code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Going into the full details of the query DSL is beyond the scope of this chapter.
    You should find it quite easy to use. For a full list of the operators supported
    by the DSL, refer to the Casbah documentation at [http://mongodb.github.io/casbah/3.0/reference/query_dsl/](http://mongodb.github.io/casbah/3.0/reference/query_dsl/).
    We summarize the most important operators here:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Operators | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `"login" $eq "mojombo"` | This selects documents whose `login` field is exactly
    `mojombo` |'
  prefs: []
  type: TYPE_TB
- en: '| `"login" $ne "mojombo"` | This selects documents whose `login` field is not
    `mojombo` |'
  prefs: []
  type: TYPE_TB
- en: '| `"github_id" $gt 1 $lt 20` | This selects documents with `github_id` greater
    than `1` and less than `20` |'
  prefs: []
  type: TYPE_TB
- en: '| `"github_id" $gte 1 $lte 20` | This selects documents with `github_id` greater
    than or equal to `1` and less than or equal to `20` |'
  prefs: []
  type: TYPE_TB
- en: '| `"login" $in ("mojombo", "defunkt")` | The `login` field is either `mojombo`
    or `defunkt` |'
  prefs: []
  type: TYPE_TB
- en: '| `"login" $nin ("mojombo", "defunkt")` | The `login` field is not `mojombo`
    or `defunkt` |'
  prefs: []
  type: TYPE_TB
- en: '| `"login" $regex "^moj.*"` | The `login` field matches the particular regular
    expression |'
  prefs: []
  type: TYPE_TB
- en: '| `"login" $exists true` | The `login` field exists |'
  prefs: []
  type: TYPE_TB
- en: '| `$or("login" $eq "mojombo", "github_id" $gte 22)` | Either the `login` field
    is `mojombo` or the `github_id` field is greater or equal to `22` |'
  prefs: []
  type: TYPE_TB
- en: '| `$and("login" $eq "mojombo", "github_id" $gte 22)` | The `login` field is
    `mojombo` and the `github_id` field is greater or equal to `22` |'
  prefs: []
  type: TYPE_TB
- en: 'We can also use the *dot* notation to query arrays and subdocuments. For instance,
    the following query will count all the users who have a repository in Scala:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE368]'
  prefs: []
  type: TYPE_PRE
- en: Custom type serialization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have only tried to serialize and deserialize simple types. What
    if we wanted to decode the language field in the repository array to an enumeration
    rather than a string? We might, for instance, define the following enumeration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE369]'
  prefs: []
  type: TYPE_PRE
- en: 'Casbah lets us define custom serializers tied to a specific Scala type: we
    can inform Casbah that whenever it encounters an instance of the `Language.Value`
    type in a `DBObject`, the instance should be passed through a custom transformer
    that will convert it to, for instance, a string, before writing it to the database.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To define a custom serializer, we need to define a class that extends the `Transformer`
    trait. This trait exposes a single method, `transform(o:AnyRef):AnyRef`. Let''s
    define a `LanguageTransformer` trait that transforms from `Language.Value` to
    `String`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE370]'
  prefs: []
  type: TYPE_PRE
- en: 'We now need to register the trait to be used whenever an instance of type `Language.Value`
    needs to be decoded. We can do this using the `addEncodingHook` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE371]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now construct `DBObject` instances containing values of the `Language`
    enumeration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE372]'
  prefs: []
  type: TYPE_PRE
- en: 'What about the reverse? How do we tell Casbah to read the `"language"` field
    as `Language.Value`? This is not possible with custom deserializers: `"Scala"`
    is now stored as a string in the database. Thus, when it comes to deserialization,
    `"Scala"` is no different from, say, `"mojombo"`. We thus lose type information
    when `"Scala"` is serialized.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, while custom encoding hooks are useful for serialization, they are much
    less useful when deserializing. A cleaner, more consistent alternative to customize
    both serialization and deserialization is to use *type classes*. We have already
    covered how to use these extensively in [Chapter 5](part0040.xhtml#aid-164MG1
    "Chapter 5. Scala and SQL through JDBC"), *Scala and SQL through JDBC*, in the
    context of serializing to and from SQL. The procedure here would be very similar:'
  prefs: []
  type: TYPE_NORMAL
- en: Define a `MongoReader[T]` type class with a `read(v:Any)`:`T` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define concrete implementations of `MongoReader` in the `MongoReader` companion
    object for all types of interest, such as `String`, `Language.Value`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enrich `DBObject` with a `read[T:MongoReader]` method using the *pimp my library*
    pattern.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For instance, the implementation of `MongoReader` for `Language.Value` would
    be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE373]'
  prefs: []
  type: TYPE_PRE
- en: We could then do the same with a `MongoWriter` type class. Using type classes
    is an idiomatic and extensible approach to custom serialization and deserialization.
  prefs: []
  type: TYPE_NORMAL
- en: We provide a complete example of type classes in the code examples associated
    with this chapter (in the `typeclass` directory).
  prefs: []
  type: TYPE_NORMAL
- en: Beyond Casbah
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have only considered Casbah in this chapter. There are, however, other drivers
    for MongoDB.
  prefs: []
  type: TYPE_NORMAL
- en: '*ReactiveMongo* is a driver that focusses on asynchronous read and writes to
    and from the database. All queries return a future, forcing asynchronous behavior.
    This fits in well with data streams or web applications.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Salat* sits at a higher level than Casbah and aims to provide easy serialization
    and deserialization of case classes.'
  prefs: []
  type: TYPE_NORMAL
- en: A full list of drivers is available at [https://docs.mongodb.org/ecosystem/drivers/scala/](https://docs.mongodb.org/ecosystem/drivers/scala/).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to interact with a MongoDB database. By weaving
    the constructs learned in the previous chapter—pulling information from a web
    API—with those learned in this chapter, we can now build a concurrent, reactive
    program for data ingestion.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn to build distributed, concurrent structures
    with greater flexibility using Akka actors.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*MongoDB: The Definitive Guide*, by *Kristina Chodorow*, is a good introduction
    to MongoDB. It does not cover interacting with MongoDB in Scala at all, but Casbah
    is intuitive enough for anyone familiar with MongoDB.'
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, the MongoDB documentation ([https://docs.mongodb.org/manual/](https://docs.mongodb.org/manual/))
    provides an in-depth discussion of MongoDB.
  prefs: []
  type: TYPE_NORMAL
- en: Casbah itself is well-documented ([http://mongodb.github.io/casbah/3.0/](http://mongodb.github.io/casbah/3.0/)).
    There is a *Getting Started* guide that is somewhat similar to this chapter and
    a complete reference guide that will fill in the gaps left by this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'This gist, [https://gist.github.com/switzer/4218526](https://gist.github.com/switzer/4218526),
    implements type classes to serialize and deserialize objects in the domain model
    to `DBObject`s. The premise is a little different from the suggested usage of
    type classes in this chapter: we are converting from Scala types to `AnyRef` to
    be used as values in `DBObject`. However, the two approaches are complementary:
    one could imagine a set of type classes to convert from `User` or `Repo` to `DBObject`
    and another to convert from `Language.Value` to `AnyRef`.'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 9. Concurrency with Akka
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Much of this book focusses on taking advantage of multicore and distributed
    architectures. In [Chapter 4](part0036.xhtml#aid-12AK82 "Chapter 4. Parallel Collections
    and Futures"), *Parallel Collections and Futures*, you learned how to use parallel
    collections to distribute batch processing problems over several threads and how
    to perform asynchronous computations using futures. In [Chapter 7](part0059.xhtml#aid-1O8H61
    "Chapter 7. Web APIs"), *Web APIs*, we applied this knowledge to query the GitHub
    API with several concurrent threads.
  prefs: []
  type: TYPE_NORMAL
- en: Concurrency abstractions such as futures and parallel collections simplify the
    enormous complexity of concurrent programming by limiting what you can do. Parallel
    collections, for instance, force you to phrase your parallelization problem as
    a sequence of pure functions on collections.
  prefs: []
  type: TYPE_NORMAL
- en: Actors offer a different way of thinking about concurrency. Actors are very
    good at encapsulating *state*. Managing state shared between different threads
    of execution is probably the most challenging part of developing concurrent applications,
    and, as we will discover in this chapter, actors make it manageable.
  prefs: []
  type: TYPE_NORMAL
- en: GitHub follower graph
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous two chapters, we explored the GitHub API, learning how to query
    the API and parse the results using *json-4s*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s imagine that we want to extract the GitHub follower graph: we want a
    program that will start from a particular user, extract this user followers, and
    then extract their followers until we tell it to stop. The catch is that we don''t
    know ahead of time what URLs we need to fetch: when we download the login names
    of a particular user''s followers, we need to verify whether we have fetched these
    users previously. If not, we add them to a queue of users whose followers we need
    to fetch. Algorithm aficionados might recognize this as *breadth-first search*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s outline how we might write this in a single-threaded way. The central
    components are a set of visited users and queue of future users to visit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE374]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `fetchFollowersForUser` method has signature `String => Iterable[String]`
    and is responsible for taking a login name, transforming it into a URL in the
    GitHub API, querying the API, and extracting a list of followers from the response.
    We will not implement it here, but you can find a complete example in the `chap09/single_threaded`
    directory of the code examples for this book ([https://github.com/pbugnion/s4ds](https://github.com/pbugnion/s4ds)).
    You should have all the tools to implement this yourself if you have read [Chapter
    7](part0059.xhtml#aid-1O8H61 "Chapter 7. Web APIs"), *Web APIs*.
  prefs: []
  type: TYPE_NORMAL
- en: While this works, it will be painfully slow. The bottleneck is clearly the `fetchFollowersForUser`
    method, in particular, the part that queries the GitHub API. This program does
    not lend itself to the concurrency constructs that we have seen earlier in the
    book because we need to protect the state of the program, embodied by the user
    queue and set of fetched users, from race conditions. Note that it is not just
    a matter of making the queue and set thread-safe. We must also keep the two synchronized.
  prefs: []
  type: TYPE_NORMAL
- en: '*Actors* offer an elegant abstraction to encapsulate state. They are lightweight
    objects that each perform a single task (possibly repeatedly) and communicate
    with each other by passing messages. The internal state of an actor can only be
    changed from within the actor itself. Importantly, actors only process messages
    one at a time, effectively preventing race conditions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'By hiding program state inside actors, we can reason about the program more
    effectively: if a bug is introduced that makes this state inconsistent, the culprit
    will be localized entirely in that actor.'
  prefs: []
  type: TYPE_NORMAL
- en: Actors as people
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, you learned that an actor encapsulates state, interacting
    with the outside world through messages. Actors make concurrent programming more
    intuitive because they behave a little bit like an ideal workforce.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s think of an actor system representing a start-up with five people. There''s
    Chris, the CEO, and Mark, who''s in charge of marketing. Then there''s Sally,
    who heads the engineering team. Sally has two minions, Bob and Kevin. As every
    good organization needs an organizational chart, refer to the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Actors as people](img/image01194.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Let's say that Chris receives an order. He will look at the order, decide whether
    it is something that he can process himself, and if not, he will forward it to
    Mark or Sally. Let's assume that the order asks for a small program so Bob forwards
    the order to Sally. Sally is very busy working on a backlog of orders so she cannot
    process the order message straightaway, and it will just sit in her mailbox for
    a short while. When she finally gets round to processing the order, she might
    decide to split the order into several parts, some of which she will give to Kevin
    and some to Bob.
  prefs: []
  type: TYPE_NORMAL
- en: As Bob and Kevin complete items, they will send messages back to Sally to inform
    her. When every part of the order is fulfilled, Sally will aggregate the parts
    together and message either the customer directly or Chris with the results.
  prefs: []
  type: TYPE_NORMAL
- en: 'The task of keeping track of which jobs must be fulfilled to complete the order
    rests with Sally. When she receives messages from Bob and Kevin, she must update
    her list of tasks in progress and check whether every task related to this order
    is complete. This sort of coordination would be more challenging with traditional
    *synchronize* blocks: every access to the list of tasks in progress and to the
    list of completed tasks would need to be synchronized. By embedding this logic
    in Sally, who can only process a single message at a time, we can be sure that
    there will not be race conditions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our start-up works well because each person is responsible for doing a single
    thing: Chris either delegates to Mark or Sally, Sally breaks up orders into several
    parts and assigns them to Bob and Kevin, and Bob and Kevin fulfill each part.
    You might think "hold on, all the logic is embedded in Bob and Kevin, the employees
    at the bottom of the ladder who do all the actual work". Actors, unlike employees,
    are cheap, so if the logic embedded in an actor gets too complicated, it is easy
    to introduce additional layers of delegation until tasks get simple enough.'
  prefs: []
  type: TYPE_NORMAL
- en: The employees in our start-up refuse to multitask. When they get a piece of
    work, they process it completely and then move on to the next task. This means
    that they cannot get muddled by the complexities of multitasking. Actors, by processing
    a single message at a time, greatly reduce the scope for introducing concurrency
    errors such as race conditions.
  prefs: []
  type: TYPE_NORMAL
- en: More importantly, by offering an abstraction that programmers can intuitively
    understand—that of human workers—Akka makes reasoning about concurrency easier.
  prefs: []
  type: TYPE_NORMAL
- en: Hello world with Akka
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s install Akka. We add it as a dependency to our `build.sbt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE375]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now import Akka as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE376]'
  prefs: []
  type: TYPE_PRE
- en: 'For our first foray into the world of actors, we will build an actor that echoes
    every message it receives. The code examples for this section are in a directory
    called `chap09/hello_akka` in the sample code provided with this book ([https://github.com/pbugnion/s4ds](https://github.com/pbugnion/s4ds)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE377]'
  prefs: []
  type: TYPE_PRE
- en: Let's pick this example apart, starting with the constructor. Our actor class
    must extend `Actor`. We also add `ActorLogging`, a utility trait that adds the
    `log` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: The `Echo` actor exposes a single method, `receive`. This is the actor's only
    way of communicating with the external world. To be useful, all actors must expose
    a `receive` method. The `receive` method is a partial function, typically implemented
    with multiple `case` statements. When an actor starts processing a message, it
    will match it against every `case` statement until it finds one that matches.
    It will then execute the corresponding block.
  prefs: []
  type: TYPE_NORMAL
- en: Our echo actor accepts a single type of message, a plain string. When this message
    gets processed, the actor waits for half a second and then echoes the message
    to the log file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s instantiate a couple of Echo actors and send them messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE378]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this gives us the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE379]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the `echo1` and `echo2` actors are clearly acting concurrently: `hello
    echo1` and `hello echo2` are logged at the same time. The second message, passed
    to `echo1`, gets processed after the actor has finished processing `hello echo1`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few different things to note:'
  prefs: []
  type: TYPE_NORMAL
- en: To start instantiating actors, we must first create an actor system. There is
    typically a single actor system per application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The way in which we instantiate actors looks a little strange. Instead of calling
    the constructor, we create an actor properties object, `Props[T]`. We then ask
    the actor system to create an actor with these properties. In fact, we never instantiate
    actors with `new`: they are either created by calling the `actorOf` method in
    the actor system or a similar method from within another actor (more on this later).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We never call an actor's methods from outside that actor. The only way to interact
    with the actor is to send messages to it. We do this using the *tell* operator,
    `!`. There is thus no way to mess with an actor's internals from outside that
    actor (or at least, Akka makes it difficult to mess with an actor's internals).
  prefs: []
  type: TYPE_NORMAL
- en: Case classes as messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In our "hello world" example, we constructed an actor that is expected to receive
    a string as message. Any object can be passed as a message, provided it is immutable.
    It is very common to use case classes to represent messages. This is better than
    using strings because of the additional type safety: the compiler will catch a
    typo in a case class but not in a string.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s rewrite our `EchoActor` to accept instances of case classes as messages.
    We will make it accept two different messages: `EchoMessage(message)` and `EchoHello`,
    which just echoes a default message. The examples for this section and the next
    are in the `chap09/hello_akka_case_classes` directory in the sample code provided
    with this book ([https://github.com/pbugnion/s4ds](https://github.com/pbugnion/s4ds)).'
  prefs: []
  type: TYPE_NORMAL
- en: 'A common Akka pattern is to define the messages that an actor can receive in
    the actor''s companion object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE380]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s change the actor definition to accept these messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE381]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now send `EchoHello` and `EchoMessage` to our actors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE382]'
  prefs: []
  type: TYPE_PRE
- en: Actor construction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Actor construction is a common source of difficulty for people new to Akka.
    Unlike (most) ordinary objects, you never instantiate actors explicitly. You would
    never write, for instance, `val echo = new EchoActor`. In fact, if you try this,
    Akka raises an exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating actors in Akka is a two-step process: you first create a `Props` object,
    which encapsulates the properties needed to construct an actor. The way to construct
    a `Props` object differs depending on whether the actor takes constructor arguments.
    If the constructor takes no arguments, we simply pass the actor class as a type
    parameter to `Props`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE383]'
  prefs: []
  type: TYPE_PRE
- en: 'If we have an actor whose constructor does take arguments, we must pass these
    as additional arguments when defining the `Props` object. Let''s consider the
    following actor, for instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE384]'
  prefs: []
  type: TYPE_PRE
- en: 'We pass the constructor arguments to the `Props` object as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE385]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Props` instance just embodies the configuration for creating an actor.
    It does not actually create anything. To create an actor, we pass the `Props`
    instance to the `system.actorOf` method, defined on the `ActorSystem` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE386]'
  prefs: []
  type: TYPE_PRE
- en: 'The `name` parameter is optional but is useful for logging and error messages.
    The value returned by `.actorOf` is not the actor itself: it is a *reference*
    to the actor (it helps to think of it as an address that the actor lives at) and
    has the `ActorRef` type. `ActorRef` is immutable, but it can be serialized and
    duplicated without affecting the underlying actor.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is another way to create actors besides calling `actorOf` on the actor
    system: each actor exposes a `context.actorOf` method that takes a `Props` instance
    as its argument. The context is only accessible from within the actor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE387]'
  prefs: []
  type: TYPE_PRE
- en: 'The difference between an actor created from the actor system and an actor
    created from another actor''s context lies in the actor hierarchy: each actor
    has a parent. Any actor created within another actor''s context will have that
    actor as its parent. An actor created by the actor system has a predefined actor,
    called the *user guardian*, as its parent. We will understand the importance of
    the actor hierarchy when we study the actor lifecycle at the end of this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A very common idiom is to define a `props` method in an actor''s companion
    object that acts as a factory method for `Props` instances for that actor. Let''s
    amend the `EchoActor` companion object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE388]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then instantiate the actor as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE389]'
  prefs: []
  type: TYPE_PRE
- en: Anatomy of an actor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before diving into a full-blown application, let''s look at the different components
    of the actor framework and how they fit together:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Mailbox**: A mailbox is basically a queue. Each actor has its own mailbox.
    When you send a message to an actor, the message lands in its mailbox and does
    nothing until the actor takes it off the queue and passes it through its `receive`
    method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Messages**: Messages make synchronization between actors possible. A message
    can have any type with the sole requirement that it should be immutable. In general,
    it is better to use case classes or case objects to gain the compiler''s help
    in checking message types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Actor reference**: When we create an actor using `val echo1 = system.actorOf(Props[EchoActor])`,
    `echo1` has type `ActorRef`. An `ActorRef` is a proxy for an actor and is what
    the rest of the world interacts with: when you send a message, you send it to
    the `ActorRef`, not to the actor directly. In fact, you can never obtain a handle
    to an actor directly in Akka. An actor can obtain an `ActorRef` for itself using
    the `.self` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Actor context**: Each actor has a `context` attribute through which you can
    access methods to create or access other actors and find information about the
    outside world. We have already seen how to create new actors with `context.actorOf(props)`.
    We can also obtain a reference to an actor''s parent through `context.parent`.
    An actor can also stop another actor with `context.stop(actorRef)`, where `actorRef`
    is a reference to the actor that we want to stop.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dispatcher**: The dispatcher is the machine that actually executes the code
    in an actor. The default dispatcher uses a fork/join thread pool. Akka lets us
    use different dispatchers for different actors. Tweaking the dispatcher can be
    useful to optimize the performance and give priority to certain actors. The dispatcher
    that an actor runs on is accessible through `context.dispatcher`. Dispatchers
    implement the `ExecutionContext` interface so they can be used to run futures.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Follower network crawler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The end game for this chapter is to build a crawler to explore GitHub's follower
    graph. We have already outlined how we can do this in a single-threaded manner
    earlier in this chapter. Let's design an actor system to do this concurrently.
  prefs: []
  type: TYPE_NORMAL
- en: The moving parts in the code are the data structures managing which users have
    been fetched or are being fetched. These need to be encapsulated in an actor to
    avoid race conditions arising from multiple actors trying to change them concurrently.
    We will therefore create a *fetcher manager* actor whose job is to keep track
    of which users have been fetched and which users we are going to fetch next.
  prefs: []
  type: TYPE_NORMAL
- en: The part of the code that is likely to be a bottleneck is querying the GitHub
    API. We therefore want to be able to scale the number of workers doing this concurrently.
    We will create a pool of *fetchers*, actors responsible for querying the API for
    the followers of a particular user. Finally, we will create an actor whose responsibility
    is to interpret the API's response. This actor will forward its interpretation
    of the response to another actor who will extract the followers and give them
    to the fetcher manager.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what the architecture of the program will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Follower network crawler](img/image01195.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Actor system for our GitHub API crawler
  prefs: []
  type: TYPE_NORMAL
- en: 'Each actor in our program performs a single task: fetchers just query the GitHub
    API and the queue manager just distributes work to the fetchers. Akka best practice
    dictates giving actors as narrow an area of responsibility as possible. This enables
    better granularity when scaling out (for instance, by adding more fetcher actors,
    we just parallelize the bottleneck) and better resilience: if an actor fails,
    it will only affect his area of responsibility. We will explore actor failure
    later on in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will build the app in several steps, exploring the Akka toolkit as we write
    the program. Let''s start with the `build.sbt` file. Besides Akka, we will mark
    `scalaj-http` and `json4s` as dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE390]'
  prefs: []
  type: TYPE_PRE
- en: Fetcher actors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The workhorse of our application is the fetcher, the actor responsible for fetching
    the follower details from GitHub. In the first instance, our actor will accept
    a single message, `Fetch(user)`. It will fetch the followers corresponding to
    `user` and log the response to screen. We will use the recipes developed in [Chapter
    7](part0059.xhtml#aid-1O8H61 "Chapter 7. Web APIs"), *Web APIs*, to query the
    GitHub API with an OAuth token. We will inject the token through the actor constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the companion object. This will contain the definition of
    the `Fetch(user)` message and two factory methods to create the `Props` instances.
    You can find the code examples for this section in the `chap09/fetchers_alone`
    directory in the sample code provided with this book ([https://github.com/pbugnion/s4ds](https://github.com/pbugnion/s4ds)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE391]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now define the fetcher itself. We will wrap the call to the GitHub API
    in a future. This avoids a single slow request blocking the actor. When our actor
    receives a `Fetch` request, it wraps this request into a future, sends it off,
    and can then process the next message. Let''s go ahead and implement our actor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE392]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s instantiate an actor system and four fetchers to check whether our actor
    is working as expected. We will read the GitHub token from the environment, as
    described in [Chapter 7](part0059.xhtml#aid-1O8H61 "Chapter 7. Web APIs"), *Web
    APIs*, then create four actors and ask each one to fetch the followers of a particular
    GitHub user. We wait five seconds for the requests to get completed, and then
    shut the system down:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE393]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run the code through SBT:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE394]'
  prefs: []
  type: TYPE_PRE
- en: Notice how we explicitly need to shut the actor system down using `system.shutdown`.
    The program hangs until the system is shut down. However, shutting down the system
    will stop all the actors, so we need to make sure that they have finished working.
    We do this by inserting a call to `Thread.sleep`.
  prefs: []
  type: TYPE_NORMAL
- en: Using `Thread.sleep` to wait until the API calls have finished to shut down
    the actor system is a little crude. A better approach could be to let the actors
    signal back to the system that they have completed their task. We will see examples
    of this pattern later when we implement the *fetcher manager* actor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Akka includes a feature-rich *scheduler* to schedule events. We can use the
    scheduler to replace the call to `Thread.sleep` by scheduling a system shutdown
    five seconds in the future. This is preferable as the scheduler does not block
    the calling thread, unlike `Thread.sleep`. To use the scheduler, we need to import
    a global execution context and the duration module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE395]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then schedule a system shutdown by replacing our call to `Thread.sleep`
    with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE396]'
  prefs: []
  type: TYPE_PRE
- en: Besides `scheduleOnce`, the scheduler also exposes a `schedule` method that
    lets you schedule events to happen regularly (every two seconds, for instance).
    This is useful for heartbeat checks or monitoring systems. For more information,
    read the API documentation on the scheduler available at [http://doc.akka.io/docs/akka/snapshot/scala/scheduler.html](http://doc.akka.io/docs/akka/snapshot/scala/scheduler.html).
  prefs: []
  type: TYPE_NORMAL
- en: Note that we are actually cheating a little bit here by not fetching every follower.
    The response to the follower's query is actually paginated, so we would need to
    fetch several pages to fetch all the followers. Adding logic to the actor to do
    this is not terribly complicated. We will ignore this for now and assume that
    users are capped at 100 followers each.
  prefs: []
  type: TYPE_NORMAL
- en: Routing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous example, we created four fetchers and dispatched messages to
    them, one after the other. We have a pool of identical actors among which we distribute
    tasks. Manually routing the messages to the right actor to maximize the utilization
    of our pool is painful and error-prone. Fortunately, Akka provides us with several
    routing strategies that we can use to distribute work among our pool of actors.
    Let's rewrite the previous example with automatic routing. You can find the code
    examples for this section in the `chap09/fetchers_routing` directory in the sample
    code provided with this book ([https://github.com/pbugnion/s4ds](https://github.com/pbugnion/s4ds)).
    We will reuse the same definition of `Fetchers` and its companion object as we
    did in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by importing the routing package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE397]'
  prefs: []
  type: TYPE_PRE
- en: 'A *router* is an actor that forwards the messages that it receives to its children.
    The easiest way to define a pool of actors is to tell Akka to create a router
    and pass it a `Props` object for its children. The router will then manage the
    creation of the workers directly. In our example (we will only comment on the
    parts that differ from the previous example in the text, but you can find the
    full code in the `fetchers_routing` directory with the examples for this chapter),
    we replace the custom `Fetcher` creation code with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE398]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then send the fetch messages directly to the router. The router will
    route the messages to the children in a round-robin manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE399]'
  prefs: []
  type: TYPE_PRE
- en: We used a round-robin router in this example. Akka offers many different types
    of routers, including routers with dynamic pool size, to cater to different types
    of load balancing. Head over to the Akka documentation for a list of all the available
    routers, at [http://doc.akka.io/docs/akka/snapshot/scala/routing.html](http://doc.akka.io/docs/akka/snapshot/scala/routing.html).
  prefs: []
  type: TYPE_NORMAL
- en: Message passing between actors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Merely logging the API response is not very useful. To traverse the follower
    graph, we must perform the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Check the return code of the response to make sure that the GitHub API was happy
    with our request
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parse the response as JSON
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extract the login names of the followers and, if we have not fetched them already,
    push them into the queue
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You learned how to do all these things in [Chapter 7](part0059.xhtml#aid-1O8H61
    "Chapter 7. Web APIs"), *Web APIs*, but not in the context of actors.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could just add the additional processing steps to the `receive` method of
    our `Fetcher` actor: we could add further transformations to the API response
    by future composition. However, having actors do several different things, and
    possibly failing in several different ways, is an anti-pattern: when we learn
    about managing the actor life cycle, we will see that it becomes much more difficult
    to reason about our actor systems if the actors contain several bits of logic.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will therefore use a pipeline of three different actors:'
  prefs: []
  type: TYPE_NORMAL
- en: The fetchers, which we have already encountered, are responsible just for fetching
    a URL from GitHub. They will fail if the URL is badly formatted or they cannot
    access the GitHub API.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The response interpreter is responsible for taking the response from the GitHub
    API and parsing it to JSON. If it fails at any step, it will just log the error
    (in a real application, we might take different corrective actions depending on
    the type of failure). If it manages to extract JSON successfully, it will pass
    the JSON array to the follower extractor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The follower extractor will extract the followers from the JSON array and pass
    them on to the queue of users whose followers we need to fetch.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have already built the fetchers, though we will need to modify them to forward
    the API response to the response interpreter rather than just logging it.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the code examples for this section in the `chap09/all_workers`
    directory in the sample code provided with this book ([https://github.com/pbugnion/s4ds](https://github.com/pbugnion/s4ds)).The
    first step is to modify the fetchers so that, instead of logging the response,
    they forward the response to the response interpreter. To be able to forward the
    response to the response interpreter, the fetchers will need a reference to this
    actor. We will just pass the reference to the response interpreter through the
    fetcher constructor, which is now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE400]'
  prefs: []
  type: TYPE_PRE
- en: 'We must also modify the `Props` factory method in the companion object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE401]'
  prefs: []
  type: TYPE_PRE
- en: 'We must also modify the `receive` method to forward the HTTP response to the
    interpreter rather than just logging it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE402]'
  prefs: []
  type: TYPE_PRE
- en: The *response interpreter* takes the response, decides if it is valid, parses
    it to JSON, and forwards it to a follower extractor. The response interpreter
    will need a reference to the follower extractor, which we will pass in the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by defining the `ResponseInterpreter` companion. It will just
    contain the definition of the messages that the response interpreter can receive
    and a factory to create a `Props` object to help with instantiation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE403]'
  prefs: []
  type: TYPE_PRE
- en: 'The body of `ResponseInterpreter` should feel familiar: when the actor receives
    a message giving it a response to interpret, it parses it to JSON using the techniques
    that you learned in [Chapter 7](part0059.xhtml#aid-1O8H61 "Chapter 7. Web APIs"),
    *Web APIs*. If we parse the response successfully, we forward the parsed JSON
    to the follower extractor. If we fail to parse the response (possibly because
    it was badly formatted), we just log the error. We could recover from this in
    other ways, for instance, by re-adding this login to the queue manager to be fetched
    again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE404]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have two-thirds of our worker actors. The last link is the follower
    extractor. This actor''s job is simple: it takes the `JArray` passed to it by
    the response interpreter and converts it to a list of followers. For now, we will
    just log this list, but when we build our fetcher manager, the follower extractor
    will send messages asking the manager to add the followers to its queue of logins
    to fetch.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As before, the companion just defines the messages that this actor can receive
    and a Props factory method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE405]'
  prefs: []
  type: TYPE_PRE
- en: 'The `FollowerExtractor` class receives `Extract` messages containing a `JArray`
    of information representing a follower. It extracts the `login` field and logs
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE406]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s write a new `main` method to exercise all our actors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE407]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run this through SBT:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE408]'
  prefs: []
  type: TYPE_PRE
- en: Queue control and the pull pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have now defined the three worker actors in our crawler application. The
    next step is to define the manager. The *fetcher manager* is responsible for keeping
    a queue of logins to fetch as well as a set of login names that we have already
    seen in order to avoid fetching the same logins more than once.
  prefs: []
  type: TYPE_NORMAL
- en: 'A first attempt might involve building an actor that keeps a set of users that
    we have already seen and just dispatches it to a round-robin router for fetchers
    when it is given a new user to fetch. The problem with this approach is that the
    number of messages in the fetchers'' mailboxes would accumulate quickly: for each
    API query, we are likely to get tens of followers, each of which is likely to
    make it back to a fetcher''s inbox. This gives us very little control over the
    amount of work piling up.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first problem that this is likely to cause involves the GitHub API rate
    limit: even with authentication, we are limited to 5,000 requests per hour. It
    would be useful to stop queries as soon as we hit this threshold. We cannot be
    responsive if each fetcher has a backlog of hundreds of users that they need to
    fetch.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A better alternative is to use a *pull* system: the fetchers request work from
    a central queue when they find themselves idle. Pull systems are common in Akka
    when we have a producer that produces work faster than consumers can process it
    (refer to [http://www.michaelpollmeier.com/akka-work-pulling-pattern/](http://www.michaelpollmeier.com/akka-work-pulling-pattern/)).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Conversations between the manager and fetchers will proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: If the manager goes from a state of having no work to having work, it sends
    a `WorkAvailable` message to all the fetchers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whenever a fetcher receives a `WorkAvailable` message or when it completes an
    item of work, it sends a `GiveMeWork` message to the queue manager.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the queue manager receives a `GiveMeWork` message, it ignores the request
    if no work is available or it is throttled. If it has work, it sends a `Fetch(user)`
    message to the actor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s start by modifying our fetcher. You can find the code examples for this
    section in the `chap09/ghub_crawler` directory in the sample code provided with
    this book ([https://github.com/pbugnion/s4ds](https://github.com/pbugnion/s4ds)).
    We will pass a reference to the fetcher manager through the constructor. We need
    to change the companion object to add the `WorkAvailable` message and the `props`
    factory to include the reference to the manager:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE409]'
  prefs: []
  type: TYPE_PRE
- en: We also need to change the `receive` method so that it queries the `FetcherManager`
    asking for more work once it's done processing a request or when it receives a
    `WorkAvailable` message.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the final version of the fetchers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE410]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have a working definition of the fetchers, let's build the `FetcherManager`.
    This is the most complex actor that we have built so far, and, before we dive
    into building it, we need to learn a bit more about the components of the Akka
    toolkit.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the sender of a message
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When our fetcher manager receives a `GiveMeWork` request, we will need to send
    work back to the correct fetcher. We can access the actor who sent a message using
    the `sender` method, which is a method of `Actor` that returns the `ActorRef`
    corresponding to the actor who sent the message currently being processed. The
    `case` statement corresponding to `GiveMeWork` in the fetcher manager is therefore:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE411]'
  prefs: []
  type: TYPE_PRE
- en: 'As `sender` is a *method*, its return value will change for every new incoming
    message. It should therefore only be used synchronously with the `receive` method.
    In particular, using it in a future is dangerous:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE412]'
  prefs: []
  type: TYPE_PRE
- en: The problem is that when the future is completed 20 seconds after the message
    is processed, the actor will, in all likelihood, be processing a different message
    so the return value of `sender` will have changed. We will thus send the `Complete`
    message to a completely different actor.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you need to reply to a message outside of the `receive` method, such as
    when a future completes, you should bind the value of the current sender to a
    variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE413]'
  prefs: []
  type: TYPE_PRE
- en: Stateful actors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The behavior of the fetcher manager depends on whether it has work to give
    out to the fetchers:'
  prefs: []
  type: TYPE_NORMAL
- en: If it has work to give, it needs to respond to `GiveMeWork` messages with a
    `Fetcher.Fetch` message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If it does not have work, it must ignore the `GiveMeWork` messages and, if work
    gets added, it must send a `WorkAvailable` message to the fetchers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Encoding the notion of state is straightforward in Akka. We specify different
    `receive` methods and switch from one to the other depending on the state. We
    will define the following `receive` methods for our fetcher manager, corresponding
    to each of the states:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE414]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we must define the return type of the receive methods as `Receive`.
    To switch the actor from one method to the other, we can use `context.become(methodName)`.
    Thus, for instance, when the last login name is popped off the queue, we can transition
    to using the `receiveWhileEmpty` method with `context.become(receiveWhileEmpty)`.
    We set the initial state by assigning `receiveWhileEmpty` to the `receive` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE415]'
  prefs: []
  type: TYPE_PRE
- en: Follower network crawler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are now ready to code up the remaining pieces of our network crawler. The
    largest missing piece is the fetcher manager. Let''s start with the companion
    object. As with the worker actors, this just contains the definitions of the messages
    that the actor can receive and a factory to create the `Props` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE416]'
  prefs: []
  type: TYPE_PRE
- en: 'The manager can receive two messages: `AddToQueue`, which tells it to add a
    username to the queue of users whose followers need to be fetched, and `GiveMeWork`,
    emitted by the fetchers when they are unemployed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The manager will be responsible for launching the fetchers, response interpreter,
    and follower extractor, as well as maintaining an internal queue of usernames
    and a set of usernames that we have seen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE417]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have a fetcher manager. The rest of the code can remain the same, apart
    from the follower extractor. Instead of logging followers names, it must send
    `AddToQueue` messages to the manager. We will pass a reference to the manager
    at construction time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE418]'
  prefs: []
  type: TYPE_PRE
- en: 'The `main` method running all this is remarkably simple as all the code to
    instantiate actors has been moved to the `FetcherManager`. We just need to instantiate
    the manager and give it the first node in the network, and it will do the rest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE419]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice how we do not attempt to shut down the actor system anymore. We will
    just let it run, crawling the network, until we stop it or hit the authentication
    limit. Let''s run this through SBT:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE420]'
  prefs: []
  type: TYPE_PRE
- en: Our program does not actually do anything useful with the followers that it
    retrieves besides logging them. We could replace the `log.info` call to, for instance,
    store the nodes in a database or draw the graph to screen.
  prefs: []
  type: TYPE_NORMAL
- en: Fault tolerance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Real programs fail, and they fail in unpredictable ways. Akka, and the Scala
    community in general, favors planning explicitly for failure rather than trying
    to write infallible applications. A *fault tolerant* system is a system that can
    continue to operate when one or more of its components fails. The failure of an
    individual subsystem does not necessarily mean the failure of the application.
    How does this apply to Akka?
  prefs: []
  type: TYPE_NORMAL
- en: 'The actor model provides a natural unit to encapsulate failure: the actor.
    When an actor throws an exception while processing a message, the default behavior
    is for the actor to restart, but the exception does not leak out and affect the
    rest of the system. For instance, let''s introduce an arbitrary failure in the
    response interpreter. We will modify the `receive` method to throw an exception
    when it is asked to interpret the response for `misto`, one of Martin Odersky''s
    followers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE421]'
  prefs: []
  type: TYPE_PRE
- en: 'If you rerun the code through SBT, you will notice that an error gets logged.
    The program does not crash, however. It just continues as normal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE422]'
  prefs: []
  type: TYPE_PRE
- en: 'None of the followers of `misto` will get added to the queue: he never made
    it past the `ResponseInterpreter` stage. Let''s step through what happens when
    the exception gets thrown:'
  prefs: []
  type: TYPE_NORMAL
- en: The interpreter is sent the `InterpretResponse("misto", ...)` message. This
    causes it to throw an exception and it dies. None of the other actors are affected
    by the exception.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A fresh instance of the response interpreter is created with the same Props
    instance as the recently deceased actor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the response interpreter has finished initializing, it gets bound to the
    same `ActorRef` as the deceased actor. This means that, as far as the rest of
    the system is concerned, nothing has changed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The mailbox is tied to `ActorRef` rather than the actor, so the new response
    interpreter will have the same mailbox as its predecessor, without the offending
    message.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thus, if, for whatever reason, our crawler crashes when fetching or parsing
    the response for a user, the application will be minimally affected—we will just
    not fetch this user's followers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Any internal state that an actor carries is lost when it restarts. Thus, if,
    for instance, the fetcher manager died, we would lose the current value of the
    queue and visited users. The risks associated with losing the internal state can
    be mitigated by the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Adopting a different strategy for failure: we can, for instance, carry on processing
    messages without restarting the actor in the event of failure. Of course, this
    is of little use if the actor died because its internal state is inconsistent.
    In the next section, we will discuss how to change the failure recovery strategy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Backing up the internal state by writing it to disk periodically and loading
    from the backup on restart.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Protecting actors that carry critical state by ensuring that all "risky" operations
    are delegated to other actors. In our crawler example, all the interactions with
    external services, such as querying the GitHub API and parsing the response, happen
    with actors that carry no internal state. As we saw in the previous example, if
    one of these actors dies, the application is minimally affected. By contrast,
    the precious fetcher manager is only allowed to interact with sanitized inputs.
    This is called the *error kernel* pattern: code likely to cause errors is delegated
    to kamikaze actors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom supervisor strategies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The default strategy of restarting an actor on failure is not always what we
    want. In particular, for actors that carry a lot of data, we might want to resume
    processing after an exception rather than restarting the actor. Akka lets us customize
    this behavior by setting a *supervisor strategy* in the actor's supervisor.
  prefs: []
  type: TYPE_NORMAL
- en: Recall that all actors have parents, including the top-level actors, who are
    children of a special actor called the *user guardian*. By default, an actor's
    supervisor is his parent, and it is the supervisor who decides what happens to
    the actor on failure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, to change how an actor reacts to failure, you must set its parent''s
    supervisor strategy. You do this by setting the `supervisorStrategy` attribute.
    The default strategy is equivalent to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE423]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two components to a supervisor strategy:'
  prefs: []
  type: TYPE_NORMAL
- en: '`OneForOneStrategy` determines that the strategy applies only to the actor
    that failed. By contrast, we can use `AllForOneStrategy`, which applies the same
    strategy to all the supervisees. If a single child fails, all the children will
    be restarted (or stopped or resumed).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A partial function mapping `Throwables` to a `Directive`, which is an instruction
    on what to do in response to a failure. The default strategy, for instance, maps
    `ActorInitializationException` (which happens if the constructor fails) to the
    `Stop` directive and (almost all) other exceptions to `Restart`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are four directives:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Restart`: This destroys the faulty actor and restarts it, binding the newborn
    actor to the old `ActorRef`. This clears the internal state of the actor, which
    may be a good thing (the actor might have failed because of some internal inconsistency).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Resume`: The actor just moves on to processing the next message in its inbox.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Stop`: The actor stops and is not restarted. This is useful in throwaway actors
    that you use to complete a single operation: if this operation fails, the actor
    is not needed any more.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Escalate`: The supervisor itself rethrows the exception, hoping that its supervisor
    will know what to do with it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A supervisor does not have access to which of its children failed. Thus, if
    an actor has children that might require different recovery strategies, it is
    best to create a set of intermediate supervisor actors to supervise the different
    groups of children.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example of setting the supervisor strategy, let''s tweak the `FetcherManager`
    supervisor strategy to adopt an all-for-one strategy and stop its children when
    one of them fails. We start with the relevant imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE424]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we just need to set the `supervisorStrategy` attribute in the `FetcherManager`
    definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE425]'
  prefs: []
  type: TYPE_PRE
- en: If you run this through SBT, you will notice that when the code comes across
    the custom exception thrown by the response interpreter, the system halts. This
    is because all the actors apart from the fetcher manager are now defunct.
  prefs: []
  type: TYPE_NORMAL
- en: Life-cycle hooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Akka lets us specify code that runs in response to specific events in an actor''s
    life, through *life-cycle hooks*. Akka defines the following hooks:'
  prefs: []
  type: TYPE_NORMAL
- en: '`preStart()`: This runs after the actor''s constructor has finished but before
    it starts processing messages. This is useful to run initialization code that
    depends on the actor being fully constructed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`postStop()`: This runs when the actor dies after it has stopped processing
    messages. This is useful to run cleanup code before terminating the actor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`preRestart(reason: Throwable, message: Option[Any])`: This is called just
    after an actor receives an order to restart. The `preRestart` method has access
    to the exception that was thrown and to the offending message, allowing for corrective
    action. The default behavior of `preRestart` is to stop each child and then call
    `postStop`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`postRestart(reason:Throwable)`: This is called after an actor has restarted.
    The default behavior is to call `preStart()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s use system hooks to persist the state of `FetcherManager` between runs
    of the programs. You can find the code examples for this section in the `chap09/ghub_crawler_fault_tolerant`
    directory in the sample code provided with this book ([https://github.com/pbugnion/s4ds](https://github.com/pbugnion/s4ds)).
    This will make the fetcher manager fault-tolerant. We will use `postStop` to write
    the current queue and set of visited users to text files and `preStart` to read
    these text files from the disk. Let''s start by importing the libraries necessary
    to read and write files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE426]'
  prefs: []
  type: TYPE_PRE
- en: 'We will store the names of the two text files in which we persist the state
    in the `FetcherManager` companion object (a better approach would be to store
    them in a configuration file):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE427]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `preStart` method, we load both the set of fetched users and the backlog
    of users to fetch from the text files, and in the `postStop` method, we overwrite
    these files with the new values of these data structures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE428]'
  prefs: []
  type: TYPE_PRE
- en: Now that we save the state of the crawler when it shuts down, we can put a better
    termination condition for the program than simply interrupting the program once
    we get bored. In production, we might halt the crawler when we have enough names
    in a database, for instance. In this example, we will simply let the crawler run
    for 30 seconds and then shut it down.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s modify the `main` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE429]'
  prefs: []
  type: TYPE_PRE
- en: After 30 seconds, we just call `system.shutdown`, which stops all the actors
    recursively. This will stop the fetcher manager, calling the `postStop` life cycle
    hook. After one run of the program, I have 2,164 names in the `fetched-users.txt`
    file. Running it again increases this number to 3,728 users.
  prefs: []
  type: TYPE_NORMAL
- en: We could improve fault tolerance further by making the fetcher manager dump
    the data structures at regular intervals while the code runs. As writing to the
    disk (or to a database) carries a certain element of risk (What if the database
    server goes down or the disk is full?) it would be better to delegate writing
    the data structures to a custom actor rather than endangering the manager.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our crawler has one minor problem: when the fetcher manager stops, it stops
    the fetcher actors, response interpreter, and follower extractor. However, none
    of the users currently going through these actors are stored. This also results
    in a small number of undelivered messages at the end of the code: if the response
    interpreter stops before a fetcher, the fetcher will try to deliver to a non-existent
    actor. This only accounts for a small number of users. To recover these login
    names, we can create a reaper actor whose job is to coordinate the killing of
    all the worker actors in the correct order and harvest their internal state. This
    pattern is documented in a blog post by *Derek Wyatt* ([http://letitcrash.com/post/30165507578/shutdown-patterns-in-akka-2](http://letitcrash.com/post/30165507578/shutdown-patterns-in-akka-2)).'
  prefs: []
  type: TYPE_NORMAL
- en: What we have not talked about
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Akka is a very rich ecosystem, far too rich to do it justice in a single chapter.
    There are some important parts of the toolkit that you will need, but we have
    not covered them here. We will give brief descriptions, but you can refer to the
    Akka documentation for more details:'
  prefs: []
  type: TYPE_NORMAL
- en: The ask operator, `?`, offers an alternative to the tell operator, `!`, that
    we have used to send messages to actors. Unlike "tell", which just fires a message
    to an actor, the ask operator expects a response. This is useful when we need
    to ask actors questions rather than just telling them what to do. The ask pattern
    is documented at [http://doc.akka.io/docs/akka/snapshot/scala/actors.html#Ask__Send-And-Receive-Future](http://doc.akka.io/docs/akka/snapshot/scala/actors.html#Ask__Send-And-Receive-Future).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deathwatch allows actors to watch another actor and receive a message when it
    dies. This is useful for actors that might depend on another actor but not be
    its direct supervisor. This is documented at [http://doc.akka.io/docs/akka/snapshot/scala/actors.html#Lifecycle_Monitoring_aka_DeathWatch](http://doc.akka.io/docs/akka/snapshot/scala/actors.html#Lifecycle_Monitoring_aka_DeathWatch).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our crawler, we passed references to actors explicitly through the constructor.
    We can also look up actors using the actor hierarchy with a syntax reminiscent
    of files in a filesystem at [http://doc.akka.io/docs/akka/snapshot/scala/actors.html#Identifying_Actors_via_Actor_Selection](http://doc.akka.io/docs/akka/snapshot/scala/actors.html#Identifying_Actors_via_Actor_Selection).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We briefly explored how to implement stateful actors with different receive
    methods and using `context.become` to switch between them. Akka offers a more
    powerful alternative, based on finite state machines, to encode a more complex
    set of states and transitions: [http://doc.akka.io/docs/akka/snapshot/scala/fsm.html](http://doc.akka.io/docs/akka/snapshot/scala/fsm.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We have not discussed distributing actor systems across several nodes in this
    chapter. The message passing architecture works well with distributed setups:
    [http://doc.akka.io/docs/akka/2.4.0/common/cluster.html](http://doc.akka.io/docs/akka/2.4.0/common/cluster.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to weave actors together to tackle a difficult
    concurrent problem. More importantly, we saw how Akka's actor framework encourages
    us to think about concurrent problems in terms of many separate chunks of encapsulated
    mutable data, synchronized through message passing. Akka makes concurrent programming
    easier to reason about and more fun.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Derek Wyatt''s* book, *Akka Concurrency*, is a fantastic introduction to Akka.
    It should definitely be the first stop for anyone wanting to do serious Akka programming.'
  prefs: []
  type: TYPE_NORMAL
- en: The **LET IT CRASH** blog ([http://letitcrash.com](http://letitcrash.com)) is
    the official Akka blog, and contains many examples of idioms and patterns to solve
    common issues.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 10. Distributed Batch Processing with Spark
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 4](part0036.xhtml#aid-12AK82 "Chapter 4. Parallel Collections and
    Futures"), *Parallel Collections and Futures*, we discovered how to use parallel
    collections for "embarrassingly" parallel problems: problems that can be broken
    down into a series of tasks that require no (or very little) communication between
    the tasks.'
  prefs: []
  type: TYPE_NORMAL
- en: Apache Spark provides behavior similar to Scala parallel collections (and much
    more), but, instead of distributing tasks across different CPUs on the same computer,
    it allows the tasks to be distributed across a computer cluster. This provides
    arbitrary horizontal scalability, since we can simply add more computers to the
    cluster.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will learn the basics of Apache Spark and use it to explore
    a set of emails, extracting features with the view of building a spam filter.
    We will explore several ways of actually building a spam filter in [Chapter 12](part0117.xhtml#aid-3FIHQ2
    "Chapter 12. Distributed Machine Learning with MLlib"), *Distributed Machine Learning
    with MLlib*.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Spark
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous chapters, we included dependencies by specifying them in a `build.sbt`
    file, and relying on SBT to fetch them from the Maven Central repositories. For
    Apache Spark, downloading the source code or pre-built binaries explicitly is
    more common, since Spark ships with many command line scripts that greatly facilitate
    launching jobs and interacting with a cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Head over to [http://spark.apache.org/downloads.html](http://spark.apache.org/downloads.html)
    and download Spark 1.5.2, choosing the "pre-built for Hadoop 2.6 or later" package.
    You can also build Spark from source if you need customizations, but we will stick
    to the pre-built version since it requires no configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Clicking **Download** will download a tarball, which you can unpack with the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE430]'
  prefs: []
  type: TYPE_PRE
- en: This will create a `spark-1.5.2-bin-hadoop2.6` directory. To verify that Spark
    works correctly, navigate to `spark-1.5.2-bin-hadoop2.6/bin` and launch the Spark
    shell using `./spark-shell`. This is just a Scala shell with the Spark libraries
    loaded.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may want to add the `bin/` directory to your system path. This will let
    you call the scripts in that directory from anywhere on your system, without having
    to reference the full path. On Linux or Mac OS, you can add variables to the system
    path by entering the following line in your shell configuration file (`.bash_profile`
    on Mac OS, and `.bashrc` or `.bash_profile` on Linux):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE431]'
  prefs: []
  type: TYPE_PRE
- en: 'The changes will take effect in new shell sessions. On Windows (if you use
    PowerShell), you need to enter this line in the `profile.ps1` file in the `WindowsPowerShell`
    folder in `Documents`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE432]'
  prefs: []
  type: TYPE_PRE
- en: If this worked correctly, you should be able to open a Spark shell in any directory
    on your system by just typing `spark-shell` in a terminal.
  prefs: []
  type: TYPE_NORMAL
- en: Acquiring the example data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will explore the Ling-Spam email dataset (The original dataset
    is described at [http://csmining.org/index.php/ling-spam-datasets.html](http://csmining.org/index.php/ling-spam-datasets.html)).
    Download the dataset from [http://data.scala4datascience.com/ling-spam.tar.gz](http://data.scala4datascience.com/ling-spam.tar.gz)
    (or [ling-spam.zip](http://ling-spam.zip), depending on your preferred mode of
    compression), and unpack the contents to the directory containing the code examples
    for this chapter. The archive contains two directories, `spam/` and `ham/`, containing
    the spam and legitimate emails, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Resilient distributed datasets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spark expresses all computations as a sequence of transformations and actions
    on distributed collections, called **Resilient Distributed Datasets** (**RDD**).
    Let''s explore how RDDs work with the Spark shell. Navigate to the examples directory
    and open a Spark shell as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE433]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s start by loading an email in an RDD:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE434]'
  prefs: []
  type: TYPE_PRE
- en: '`email` is an RDD, with each element corresponding to a line in the input file.
    Notice how we created the RDD by calling the `textFile` method on an object called
    `sc`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE435]'
  prefs: []
  type: TYPE_PRE
- en: '`sc` is a `SparkContext` instance, an object representing the entry point to
    the Spark cluster (for now, just our local machine). When we start a Spark shell,
    a context is created and bound to the variable `sc` automatically.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s split the email into words using `flatMap`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE436]'
  prefs: []
  type: TYPE_PRE
- en: 'This will feel natural if you are familiar with collections in Scala: the `email`
    RDD behaves just like a list of strings. Here, we split using the regular expression
    `\s`, denoting white space characters. Instead of using `flatMap` explicitly,
    we can also manipulate RDDs using Scala''s syntactic sugar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE437]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s inspect the results. We can use `.take(n)` to extract the first *n*
    elements of an RDD:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE438]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use `.count` to get the number of elements in an RDD:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE439]'
  prefs: []
  type: TYPE_PRE
- en: 'RDDs support many of the operations supported by collections. Let''s use `filter`
    to remove punctuation from our email. We will remove all words that contain any
    non-alphanumeric character. We can do this by filtering out elements that match
    this *regular expression* anywhere in the word: `[^a-zA-Z0-9]`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE440]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we created an RDD from a text file. We can also create RDDs
    from Scala iterables using the `sc.parallelize` method available on a Spark context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE441]'
  prefs: []
  type: TYPE_PRE
- en: 'This is useful for debugging and for trialling behavior in the shell. The counterpart
    to parallelize is the `.collect` method, which converts an RDD to a Scala array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE442]'
  prefs: []
  type: TYPE_PRE
- en: The `.collect` method requires the entire RDD to fit in memory on the master
    node. It is thus either used for debugging with a reduced dataset, or at the end
    of a pipeline that trims down a dataset.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, RDDs offer an API much like Scala iterables. The critical difference
    is that RDDs are *distributed* and *resilient*. Let's explore what this means
    in practice.
  prefs: []
  type: TYPE_NORMAL
- en: RDDs are immutable
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You cannot change an RDD once it is created. All operations on RDDs either create
    new RDDs or other Scala objects.
  prefs: []
  type: TYPE_NORMAL
- en: RDDs are lazy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you execute operations like map and filter on a Scala collection in the
    interactive shell, the REPL prints the values of the new collection to screen.
    The same isn''t true of Spark RDDs. This is because operations on RDDs are lazy:
    they are only evaluated when needed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, when we write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE443]'
  prefs: []
  type: TYPE_PRE
- en: 'We are creating an RDD, `words` that knows how to build itself from its parent
    RDD, `email`, which, in turn, knows that it needs to read a text file and split
    it into lines. However, none of the commands actually happen until we force the
    evaluation of the RDDs by calling an *action* to return a Scala object. This is
    most evident if we try to read from a non-existent text file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE444]'
  prefs: []
  type: TYPE_PRE
- en: 'We can create the RDD without a hitch. We can even define further transformations
    on the RDD. The program crashes only when these transformations are finally evaluated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE445]'
  prefs: []
  type: TYPE_PRE
- en: The action `.count` is expected to return the number of elements in our RDD
    as an integer. Spark has no choice but to evaluate `inp`, which results in an
    exception.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, it is probably more appropriate to think of an RDD as a pipeline of operations,
    rather than a more traditional collection.
  prefs: []
  type: TYPE_NORMAL
- en: RDDs know their lineage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: RDDs can only be constructed from stable storage (for instance, by loading data
    from a file that is present on every node in the Spark cluster), or through a
    set of transformations based on other RDDs. Since RDDs are lazy, they need to
    know how to build themselves when needed. They do this by knowing who their parent
    RDD is, and what operation they need to apply to the parent. This is a well-defined
    process since the parent RDD is immutable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `toDebugString` method provides a diagram of how an RDD is constructed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE446]'
  prefs: []
  type: TYPE_PRE
- en: RDDs are resilient
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you run an application on a single computer, you generally don''t need to
    worry about hardware failure in your application: if the computer fails, your
    application is doomed anyway.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Distributed architectures should, by contrast, be fault-tolerant: the failure
    of a single machine should not crash the entire application. Spark RDDs are built
    with fault tolerance in mind. Let''s imagine that one of the worker nodes fails,
    causing the destruction of some of the data associated with an RDD. Since the
    Spark RDD knows how to build itself from its parent, there is no permanent data
    loss: the elements that were lost can just be re-computed when needed on another
    computer.'
  prefs: []
  type: TYPE_NORMAL
- en: RDDs are distributed
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you construct an RDD, for instance from a text file, Spark will split the
    RDD into a number of partitions. Each partition will be entirely localized on
    a single machine (though there is, in general, more than one partition per machine).
  prefs: []
  type: TYPE_NORMAL
- en: 'Many transformations on RDDs can be executed on each partition independently.
    For instance, when performing a `.map` operation, a given element in the output
    RDD depends on a single element in the parent: data does not need to be moved
    between partitions. The same is true of `.flatMap` and `.filter` operations. This
    means that the partition in the RDD produced by one of these operations depends
    on a single partition in the parent RDD.'
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, a `.distinct` transformation, which removes all duplicate
    elements from an RDD, requires the data in a given partition to be compared to
    the data in every other partition. This requires *shuffling* the data across the
    nodes. Shuffling, especially for large datasets, is an expensive operation and
    should be avoided if possible.
  prefs: []
  type: TYPE_NORMAL
- en: Transformations and actions on RDDs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The set of operations supported by an RDD can be split into two categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Transformations** create a new RDD from the current one. Transformations
    are lazy: they are not evaluated immediately.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Actions** force the evaluation of an RDD, and normally return a Scala object,
    rather than an RDD, or have some form of side-effect. Actions are evaluated immediately,
    triggering the execution of all the transformations that make up this RDD.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the tables below, we give some examples of useful transformations and actions.
    For a full, up-to-date list, consult the Spark documentation ([http://spark.apache.org/docs/latest/programming-guide.html#rdd-operations](http://spark.apache.org/docs/latest/programming-guide.html#rdd-operations)).
  prefs: []
  type: TYPE_NORMAL
- en: 'For the examples in these tables, we assume that you have created an RDD with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE447]'
  prefs: []
  type: TYPE_PRE
- en: 'The following table lists common transformations on an RDD. Recall that transformations
    always generate a new RDD, and that they are lazy operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Transformation | Notes | **Example (assuming** `rdd` **is** `{ "quick", "brown",
    "quick", "dog" }`) |'
  prefs: []
  type: TYPE_TB
- en: '| `rdd.map(func)` |   | `rdd.map { _.size } // => { 5, 5, 5, 3 }` |'
  prefs: []
  type: TYPE_TB
- en: '| `rdd.filter(pred)` |   | `rdd.filter { _.length < 4 } // => { "dog" }` |'
  prefs: []
  type: TYPE_TB
- en: '| `rdd.flatMap(func)` |   | `rdd.flatMap { _.toCharArray } // => { ''q'', ''u'',
    ''i'', ''c'', ''k'', ''b'', ''r'', ''o'' … }` |'
  prefs: []
  type: TYPE_TB
- en: '| `rdd.distinct()` | Remove duplicate elements in RDD. | `rdd.distinct // =>
    { "dog", "brown", "quick" }` |'
  prefs: []
  type: TYPE_TB
- en: '| `rdd.pipe(command, [envVars])` | Pipe through an external program. RDD elements
    are written, line-by-line, to the process''s `stdin`. The output is read from
    `stdout`. | `rdd.pipe("tr a-z A-Z") // => { "QUICK", "BROWN", "QUICK", "DOG" }`
    |'
  prefs: []
  type: TYPE_TB
- en: The following table describes common actions on RDDs. Recall that actions always
    generate a Scala type or cause a side-effect, rather than creating a new RDD.
    Actions force the evaluation of the RDD, triggering the execution of the transformations
    underpinning the RDD.
  prefs: []
  type: TYPE_NORMAL
- en: '| Action | Nodes | **Example (assuming** `rdd` **is** `{ "quick", "brown",
    "quick", "dog" }`) |'
  prefs: []
  type: TYPE_TB
- en: '| `rdd.first` | First element in the RDD. | `rdd.first // => quick` |'
  prefs: []
  type: TYPE_TB
- en: '| `rdd.collect` | Transform the RDD to an array (the array must be able to
    fit in memory on the master node). | `rdd.collect // => Array[String]("quick",
    "brown", "quick", "dog")` |'
  prefs: []
  type: TYPE_TB
- en: '| `rdd.count` | Number of elements in the RDD. | `rdd.count // => 4` |'
  prefs: []
  type: TYPE_TB
- en: '| `rdd.countByValue` | Map of element to the number of times this element occurs.
    The map must fit on the master node. | `rdd.countByValue // => Map(quick -> 2,
    brown -> 1, dog -> 1)` |'
  prefs: []
  type: TYPE_TB
- en: '| `rdd.take(n)` | Return an array of the first *n* elements in the RDD. | `rdd.take(2)
    // => Array(quick, brown)` |'
  prefs: []
  type: TYPE_TB
- en: '| `rdd.takeOrdered(n:Int)(implicit ordering: Ordering[T])` | Top *n* elements
    in the RDD according to the element''s default ordering, or the ordering passed
    as second argument. See the Scala docs for `Ordering` for how to define custom
    comparison functions ([http://www.scala-lang.org/api/current/index.html#scala.math.Ordering](http://www.scala-lang.org/api/current/index.html#scala.math.Ordering)).
    | `rdd.takeOrdered(2) // => Array(brown, dog)``rdd.takeOrdered(2) (Ordering.by
    { _.size }) // => Array[String] = Array(dog, quick)` |'
  prefs: []
  type: TYPE_TB
- en: '| `rdd.reduce(func)` | Reduce the RDD according to the specified function.
    Uses the first element in the RDD as the base. `func` should be commutative and
    associative. | `rdd.map { _.size }.reduce { _ + _ } // => 18` |'
  prefs: []
  type: TYPE_TB
- en: '| `rdd.aggregate(zeroValue)(seqOp, combOp)` | Reduction for cases where the
    reduction function returns a value of type different to the RDD''s type. In this
    case, we need to provide a function for reducing within a single partition (`seqOp`)
    and a function for combining the value of two partitions (`combOp`). | `rdd.aggregate(0)
    ( _ + _.size, _ + _ ) // => 18` |'
  prefs: []
  type: TYPE_TB
- en: Persisting RDDs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have learned that RDDs only retain the sequence of operations needed to
    construct the elements, rather than the values themselves. This, of course, drastically
    reduces memory usage since we do not need to keep intermediate versions of our
    RDDs in memory. For instance, let''s assume we want to trawl through transaction
    logs to identify all the transactions that occurred on a particular account:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE448]'
  prefs: []
  type: TYPE_PRE
- en: The set of all transactions will be large, while the set of transactions on
    the account of interest will be much smaller. Spark's policy of remembering *how*
    to construct a dataset, rather than the dataset itself, means that we never have
    all the lines of our input file in memory at any one time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two situations in which we may want to avoid re-computing the elements
    of an RDD every time we use it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For interactive use: we might have detected fraudulent behavior on account
    "123456", and we want to investigate how this might have arisen. We will probably
    want to perform many different exploratory calculations on this RDD, without having
    to re-read the entire log file every time. It therefore makes sense to persist
    `interestingTransactions`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When an algorithm re-uses an intermediate result, or a dataset. A canonical
    example is logistic regression. In logistic regression, we normally use an iterative
    algorithm to find the 'optimal' coefficients that minimize the loss function.
    At every step in our iterative algorithm, we must calculate the loss function
    and its gradient from the training set. We should avoid re-computing the training
    set (or re-loading it from an input file) if at all possible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spark provides a `.persist` method on RDDs to achieve this. By calling `.persist`
    on an RDD, we tell Spark to keep the dataset in memory next time it is computed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE449]'
  prefs: []
  type: TYPE_PRE
- en: 'Spark supports different levels of persistence, which you can tune by passing
    arguments to `.persist`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE450]'
  prefs: []
  type: TYPE_PRE
- en: 'Spark provides several persistence levels, including:'
  prefs: []
  type: TYPE_NORMAL
- en: '`MEMORY_ONLY`: the default storage level. The RDD is stored in RAM. If the
    RDD is too big to fit in memory, parts of it will not persist, and will need to
    be re-computed on the fly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MEMORY_AND_DISK`: As much of the RDD is stored in memory as possible. If the
    RDD is too big, it will spill over to disk. This is only worthwhile if the RDD
    is expensive to compute. Otherwise, re-computing it may be faster than reading
    from the disk.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you persist several RDDs and run out of memory, Spark will clear the least
    recently used out of memory (either discarding them or saving them to disk, depending
    on the chosen persistence level). RDDs also expose an `unpersist` method to explicitly
    tell Spark than an RDD is not needed any more.
  prefs: []
  type: TYPE_NORMAL
- en: Persisting RDDs can have a drastic impact on performance. What and how to persist
    therefore becomes very important when tuning a Spark application. Finding the
    best persistence level generally requires some tinkering, benchmarking and experimentation.
    The Spark documentation provides guidelines on when to use which persistence level
    ([http://spark.apache.org/docs/latest/programming-guide.html#rdd-persistence](http://spark.apache.org/docs/latest/programming-guide.html#rdd-persistence)),
    as well as general tips on tuning memory usage ([http://spark.apache.org/docs/latest/tuning.html](http://spark.apache.org/docs/latest/tuning.html)).
  prefs: []
  type: TYPE_NORMAL
- en: Importantly, the `persist` method does not force the evaluation of the RDD.
    It just notifies the Spark engine that, next time the values in this RDD are computed,
    they should be saved rather than discarded.
  prefs: []
  type: TYPE_NORMAL
- en: Key-value RDDs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far, we have only considered RDDs of Scala value types. RDDs of more complex
    data types support additional operations. Spark adds many operations for *key-value
    RDDs*: RDDs whose type parameter is a tuple `(K, V)`, for any type `K` and `V`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go back to our sample email:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE451]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s persist the `words` RDD in memory to avoid having to re-read the `email`
    file from disk repeatedly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE452]'
  prefs: []
  type: TYPE_PRE
- en: 'To access key-value operations, we just need to apply a transformation to our
    RDD that creates key-value pairs. Let''s use the words as keys. For now, we will
    just use 1 for every value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE453]'
  prefs: []
  type: TYPE_PRE
- en: 'Key-value RDDs support several operations besides the core RDD operations.
    These are added through an implicit conversion, using the "pimp my library" pattern
    that we explored in [Chapter 5](part0040.xhtml#aid-164MG1 "Chapter 5. Scala and
    SQL through JDBC"), *Scala and SQL through JDBC*. These additional transformations
    fall into two broad categories: *by-key* transformations and *joins* between RDDs.'
  prefs: []
  type: TYPE_NORMAL
- en: 'By-key transformations are operations that aggregate the values corresponding
    to the same key. For instance, we can count the number of times each word appears
    in our email using `reduceByKey`. This method takes all the values that belong
    to the same key and combines them using a user-supplied function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE454]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that `reduceByKey` requires (in general) shuffling the RDD, since not
    every occurrence of a given key will be in the same partition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE455]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that key-value RDDs are not like Scala Maps: the same key can occur multiple
    times, and they do not support *O(1)* lookup. A key-value RDD can be transformed
    to a Scala map using the `.collectAsMap` action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE456]'
  prefs: []
  type: TYPE_PRE
- en: This requires pulling the entire RDD onto the main Spark node. You therefore
    need to have enough memory on the main node to house the map. This is often the
    last stage in a pipeline that filters a large RDD to just the information that
    we need.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many by-key operations, which we describe in the table below. For
    the examples in the table, we assume that `rdd` is created as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE457]'
  prefs: []
  type: TYPE_PRE
- en: '| Transformation | Notes | **Example (assumes** `rdd` **is** `{ quick -> 5,
    brown -> 5, quick -> 5, dog -> 3 }`) |'
  prefs: []
  type: TYPE_TB
- en: '| `rdd.mapValues` | Apply an operation to the values. | `rdd.mapValues { _
    * 2 } // => { quick -> 10, brown -> 10, quick -> 10, dog ->6 }` |'
  prefs: []
  type: TYPE_TB
- en: '| `rdd.groupByKey` | Return a key-value RDD in which values corresponding to
    the same key are grouped into iterables. | `rdd.groupByKey // => { quick -> Iterable(5,
    5), brown -> Iterable(5), dog -> Iterable(3) }` |'
  prefs: []
  type: TYPE_TB
- en: '| `rdd.reduceByKey(func)` | Return a key-value RDD in which values corresponding
    to the same key are combined using a user-supplied function. | `rdd.reduceByKey
    { _ + _ } // => { quick -> 10, brown -> 5, dog -> 3 }` |'
  prefs: []
  type: TYPE_TB
- en: '| `rdd.keys` | Return an RDD of the keys. | `rdd.keys // => { quick, brown,
    quick, dog }` |'
  prefs: []
  type: TYPE_TB
- en: '| `rdd.values` | Return an RDD of the values. | `rdd.values // => { 5, 5, 5,
    3 }` |'
  prefs: []
  type: TYPE_TB
- en: 'The second category of operations on key-value RDDs involves joining different
    RDDs together by key. This is somewhat similar to SQL joins, where the keys are
    the column being joined on. Let''s load a spam email and apply the same transformations
    we applied to our ham email:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE458]'
  prefs: []
  type: TYPE_PRE
- en: 'Both `spamWordCounts` and `wordCounts` are key-value RDDs for which the keys
    correspond to unique words in the message, and the values are the number of times
    that word occurs. There will be some overlap in keys between `spamWordCounts`
    and `wordCounts`, since the emails will share many of the same words. Let''s do
    an *inner join* between those two RDDs to get the words that occur in both emails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE459]'
  prefs: []
  type: TYPE_PRE
- en: The values in the RDD resulting from an inner join will be pairs. The first
    element in the pair is the value for that key in the first RDD, and the second
    element is the value for that key in the second RDD. Thus, the word *call* occurs
    three times in the legitimate email and once in the spam email.
  prefs: []
  type: TYPE_NORMAL
- en: 'Spark supports all four join types. For instance, let''s perform a left join:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE460]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the second element in our pair has type `Option[Int]`, to accommodate
    keys absent in `spamWordCounts`. The word *paper*, for instance, occurs twice
    in the legitimate email and never in the spam email. In this case, it is more
    useful to have zeros to indicate absence, rather than `None`. Replacing `None`
    with a default value is simple with `getOrElse`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE461]'
  prefs: []
  type: TYPE_PRE
- en: 'The table below lists the most common joins on key-value RDDs:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Transformation** | **Result (assuming** `rdd1` is `{ quick -> 1, brown
    -> 2, quick -> 3, dog -> 4 }` **and** `rdd2` **is** `{ quick -> 78, brown -> 79,
    fox -> 80 }`) |'
  prefs: []
  type: TYPE_TB
- en: '| `rdd1.join(rdd2)` | `{ quick -> (1, 78), quick -> (3, 78), brown -> (2, 79)
    }` |'
  prefs: []
  type: TYPE_TB
- en: '| `rdd1.leftOuterJoin(rdd2)` | `{ dog -> (4, None), quick -> (1, Some(78)),
    quick -> (3, Some(78)), brown -> (2, Some(79)) }` |'
  prefs: []
  type: TYPE_TB
- en: '| `rdd1.rightOuterJoin(rdd2)` | `{ quick -> (Some(1), 78), quick -> (Some(3),
    78), brown -> (Some(2), 79), fox -> (None, 80) }` |'
  prefs: []
  type: TYPE_TB
- en: '| `rdd1.fullOuterJoin(rdd2)` | `{ dog -> (Some(4), None), quick -> (Some(1),
    Some(78)), quick -> (Some(3), Some(78)), brown -> (Some(2), Some(79)), fox ->
    (None, Some(80)) }` |'
  prefs: []
  type: TYPE_TB
- en: For a complete list of transformations, consult the API documentation for `PairRDDFunctions`,
    [http://spark.apache.org/docs/latest/api/scala/index.html#org.apache.spark.rdd.PairRDDFunctions](http://spark.apache.org/docs/latest/api/scala/index.html#org.apache.spark.rdd.PairRDDFunctions).
  prefs: []
  type: TYPE_NORMAL
- en: Double RDDs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous section, we saw that Spark adds functionality to key-value
    RDDs through an implicit conversion. Similarly, Spark adds statistics functionality
    to RDDs of doubles. Let''s extract the word frequencies for the ham message, and
    convert the values from integers to doubles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE462]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then get summary statistics using the `.stats` action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE463]'
  prefs: []
  type: TYPE_PRE
- en: 'Thus, the most common word appears 72 times. We can also use the `.histogram`
    action to get an idea of the distribution of values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE464]'
  prefs: []
  type: TYPE_PRE
- en: 'The `.histogram` method returns a pair of arrays. The first array indicates
    the bounds of the histogram bins, and the second is the count of elements in that
    bin. Thus, there are `391` words that appear less than `15.2` times. The distribution
    of words is very skewed, such that a histogram with regular-sized bin is not really
    appropriate. We can, instead, pass in custom bins by passing an array of bin edges
    to the `histogram` method. For instance, we might distribute the bins logarithmically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE465]'
  prefs: []
  type: TYPE_PRE
- en: Building and running standalone programs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have interacted exclusively with Spark through the Spark shell. In
    the section that follows, we will build a standalone application and launch a
    Spark program either locally or on an EC2 cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Running Spark applications locally
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first step is to write the `build.sbt` file, as you would if you were running
    a standard Scala script. The Spark binary that we downloaded needs to be run against
    Scala 2.10 (You need to compile Spark from source to run against Scala 2.11\.
    This is not difficult to do, just follow the instructions on [http://spark.apache.org/docs/latest/building-spark.html#building-for-scala-211](http://spark.apache.org/docs/latest/building-spark.html#building-for-scala-211)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE466]'
  prefs: []
  type: TYPE_PRE
- en: We then run `sbt package` to compile and build a jar of our program. The jar
    will be built in `target/scala-2.10/`, and called `spam_mi_2.10-0.1-SNAPSHOT.jar`.
    You can try this with the example code provided for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then run the jar locally using the `spark-submit` shell script, available
    in the `bin/` folder in the Spark installation directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE467]'
  prefs: []
  type: TYPE_PRE
- en: The resources allocated to Spark can be controlled by passing arguments to `spark-submit`.
    Use `spark-submit --help` to see the full list of arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the Spark programs has dependencies (for instance, on other Maven packages),
    it is easiest to bundle them into the application jar using the *SBT* *assembly*
    plugin. Let''s imagine that our application depends on breeze-viz. The `build.sbt`
    file now looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE468]'
  prefs: []
  type: TYPE_PRE
- en: 'SBT assembly is an SBT plugin that builds *fat* jars: jars that contain not
    only the program itself, but all the dependencies for the program.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that we marked Spark as "provided" in the list of dependencies, which
    means that Spark itself will not be included in the jar (it is provided by the
    Spark environment anyway). To include the SBT assembly plugin, create a file called
    `assembly.sbt` in the `project/` directory, with the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE469]'
  prefs: []
  type: TYPE_PRE
- en: You will need to re-start SBT for the changes to take effect. You can then create
    the assembly jar using the `assembly` command in SBT. This will create a jar called
    `spam_mi-assembly-0.1-SNAPSHOT.jar` in the `target/scala-2.10` directory. You
    can run this jar using `spark-submit`.
  prefs: []
  type: TYPE_NORMAL
- en: Reducing logging output and Spark configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Spark is, by default, very verbose. The default log-level is set to `INFO`.
    To avoid missing important messages, it is useful to change the log settings to
    `WARN`. To change the default log level system-wide, go into the `conf` directory
    in the directory in which you installed Spark. You should find a file called `log4j.properties.template`.
    Rename this file to `log4j.properties` and look for the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE470]'
  prefs: []
  type: TYPE_PRE
- en: 'Change this line to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE471]'
  prefs: []
  type: TYPE_PRE
- en: There are several other configuration files in that directory that you can use
    to alter Spark's default behavior. For a full list of configuration options, head
    over to [http://spark.apache.org/docs/latest/configuration.html](http://spark.apache.org/docs/latest/configuration.html).
  prefs: []
  type: TYPE_NORMAL
- en: Running Spark applications on EC2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Running Spark locally is useful for testing, but the whole point of using a
    distributed framework is to run programs harnessing the power of several different
    computers. We can set Spark up on any set of computers that can communicate with
    each other using HTTP. In general, we also need to set up a distributed file system
    like HDFS, so that we can share input files across the cluster. For the purpose
    of this example, we will set Spark up on an Amazon EC2 cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'Spark comes with a shell script, `ec2/spark-ec2`, for setting up an EC2 cluster
    and installing Spark. It will also install HDFS. You will need an account with
    Amazon Web Services (AWS) to follow these examples ([https://aws.amazon.com](https://aws.amazon.com)).
    You will need the AWS access key and secret key, which you can access through
    the **Account** / **Security Credentials** / **Access Credentials** menu in the
    AWS web console. You need to make these available to the `spark-ec2` script through
    environment variables. Inject them into your current session as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE472]'
  prefs: []
  type: TYPE_PRE
- en: You can also write these lines into the configuration script for your shell
    (your `.bashrc` file, or equivalent), to avoid having to re-enter them every time
    you run the `setup-ec2` script. We discussed environment variables in [Chapter
    6](part0051.xhtml#aid-1GKCM2 "Chapter 6. Slick – A Functional Interface for SQL"),
    *Slick – A Functional Interface for SQL*.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will also need to create a key pair by clicking on **Key Pairs** in the
    EC2 web console, creating a new key pair and downloading the certificate file.
    I will assume you named the key pair `test_ec2` and the certificate file `test_ec2.pem`.
    Make sure that the key pair is created in the *N*. Virginia region (by choosing
    the correct region in the upper right corner of the EC2 Management console), to
    avoid having to specify the region explicitly in the rest of this chapter. You
    will need to set access permissions on the certificate file to user-readable only:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE473]'
  prefs: []
  type: TYPE_PRE
- en: 'We are now ready to launch the cluster. Navigate to the `ec2` directory and
    run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE474]'
  prefs: []
  type: TYPE_PRE
- en: This will create a cluster called `test_cluster` with a master and two slaves.
    The number of slaves is set through the `-s` command line argument. The cluster
    will take a while to start up, but you can verify that the instances are launching
    correctly by looking at the **Instances** window in the EC2 Management Console.
  prefs: []
  type: TYPE_NORMAL
- en: The setup script supports many options for customizing the type of instances,
    the number of hard drives and so on. You can explore these options by passing
    the `--help` command line option to `spark-ec2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The life cycle of the cluster can be controlled by passing different commands
    to the `spark-ec2` script, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE475]'
  prefs: []
  type: TYPE_PRE
- en: For more detail on using Spark on EC2, consult the official documentation at
    [http://spark.apache.org/docs/latest/ec2-scripts.html#running-applications](http://spark.apache.org/docs/latest/ec2-scripts.html#running-applications).
  prefs: []
  type: TYPE_NORMAL
- en: Spam filtering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s put all we''ve learned to good use and do some data exploration for
    our spam filter. We will use the Ling-Spam email dataset: [http://csmining.org/index.php/ling-spam-datasets.html](http://csmining.org/index.php/ling-spam-datasets.html).
    The dataset contains 2412 ham emails and 481 spam emails, all of which were received
    by a mailing list on linguistics. We will extract the words that are most informative
    of whether an email is spam or ham.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first steps in any natural language processing workflow are to remove stop
    words and lemmatization. Removing stop words involves filtering very common words
    such as *the*, *this* and so on. Lemmatization involves replacing different forms
    of the same word with a canonical form: both *colors* and *color* would be mapped
    to *color*, and *organize*, *organizing* and *organizes* would be mapped to *organize*.
    Removing stop words and lemmatization is very challenging, and beyond the scope
    of this book (if you do need to remove stop words and lemmatize a dataset, your
    go-to tool should be the Stanford NLP toolkit: [http://nlp.stanford.edu/software/corenlp.shtml](http://nlp.stanford.edu/software/corenlp.shtml)).
    Fortunately, the Ling-Spam e-mail dataset has been cleaned and lemmatized already
    (which is why the text in the emails looks strange).'
  prefs: []
  type: TYPE_NORMAL
- en: 'When we do build the spam filter, we will use the presence of a particular
    word in an email as the feature for our model. We will use a *bag-of-words* approach:
    we consider which words appear in an email, but not the word order.'
  prefs: []
  type: TYPE_NORMAL
- en: Intuitively, some words will be more important than others when deciding whether
    an email is spam. For instance, an email that contains *language* is likely to
    be ham, since the mailing list was for linguistics discussions, and *language*
    is a word unlikely to be used by spammers. Conversely, words which are common
    to both message types, for instance *hello*, are unlikely to be much use.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way of quantifying the importance of a word in determining whether a message
    is spam is through the **Mutual Information** (**MI**). The mutual information
    is the gain in information about whether a message is ham or spam if we know that
    it contains a particular word. For instance, the presence of *language* in a particular
    email is very informative as to whether that email is spam or ham. Similarly,
    the presence of the word *dollar* is informative since it appears often in spam
    messages and only infrequently in ham messages. By contrast, the presence of the
    word *morning* is uninformative, since it is approximately equally common in both
    spam and ham messages. The formula for the mutual information between the presence
    of a particular word in an email, and whether that email is spam or ham is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Spam filtering](img/image01196.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: where ![Spam filtering](img/image01197.jpeg) is the joint probability of an
    email containing a particular word and being of that class (either ham or spam),
    ![Spam filtering](img/image01198.jpeg) is the probability that a particular word
    is present in an email, and ![Spam filtering](img/image01199.jpeg) is the probability
    that any email is of that class. The MI is commonly used in decision trees.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The derivation of the expression for the mutual information is beyond the scope
    of this book. The interested reader is directed to *David MacKay's* excellent
    *Information Theory, Inference, and Learning Algorithms*, especially the chapter
    *Dependent Random Variables*.
  prefs: []
  type: TYPE_NORMAL
- en: A key component of our MI calculation is evaluating the probability that a word
    occurs in spam or ham messages. The best approximation to this probability, given
    our data set, is the fraction of messages a word appears in. Thus, for instance,
    if *language* appears in 40% of messages, we will assume that the probability
    ![Spam filtering](img/image01200.jpeg) of language being present in any message
    is 0.4\. Similarly, if 40% of the messages are ham, and *language* appears in
    50% of those, we will assume that the probability of language being present in
    an email, and that email being ham is ![Spam filtering](img/image01201.jpeg).
  prefs: []
  type: TYPE_NORMAL
- en: Let's write a `wordFractionInFiles` function to calculate the fraction of messages
    in which each word appears, for all the words in a given corpus. Our function
    will take, as argument, a path with a shell wildcard identifying a set of files,
    such as `ham/*`, and it will return a key-value RDD, where the keys are words
    and the values are the probability that that word occurs in any of those files.
    We will put the function in an object called `MutualInformation`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We first give the entire code listing for this function. Don''t worry if this
    doesn''t all make sense straight-away: we explain the tricky parts in more detail
    just after the code. You may find it useful to type some of these commands in
    the shell, replacing `fileGlob` with, for instance `"ham/*"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE476]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s play with this function in the Spark shell. To be able to access this
    function from the shell, we need to create a jar with the `MutualInformation`
    object. Write a `build.sbt` file similar to the one presented in the previous
    section and package the code into a jar using `sbt package`. Then, open a Spark
    shell with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE477]'
  prefs: []
  type: TYPE_PRE
- en: 'This will open a Spark shell with our newly created jar on the classpath. Let''s
    run our `wordFractionInFiles` method on the `ham` emails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE478]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s get a snapshot of the `fractions` RDD:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE479]'
  prefs: []
  type: TYPE_PRE
- en: 'It would be nice to see the words that come up most often in ham messages.
    We can use the `.takeOrdered` action to take the top values of an RDD, with a
    custom ordering. `.takeOrdered` expects, as its second argument, an instance of
    the type class `Ordering[T]`, where `T` is the type parameter of our RDD: `(String,
    Double)` in this case. `Ordering[T]` is a trait with a single `compare(a:T, b:T)`
    method describing how to compare `a` and `b`. The easiest way of creating an `Ordering[T]`
    is through the companion object''s `by` method, which defines a key by which to
    compare the elements of our RDD.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to order the elements in our key-value RDD by the value and, since
    we want the most common words, rather than the least, we need to reverse that
    ordering:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE480]'
  prefs: []
  type: TYPE_PRE
- en: Unsurprisingly, `language` is present in 67% of ham emails, `university` in
    60% of ham emails and so on. A similar investigation on spam messages reveals
    that the exclamation mark character *!* is present in 83% of spam emails, *our*
    is present in 61% and *free* in 57%.
  prefs: []
  type: TYPE_NORMAL
- en: We are now in a position to start writing the body of our application to calculate
    the mutual information between each word and whether a message is spam or ham.
    We will put the body of the code in the `MutualInformation` object, which already
    contains the `wordFractionInFiles` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to create a Spark context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE481]'
  prefs: []
  type: TYPE_PRE
- en: Note that we did not need to do this when we were using the Spark shell because
    the shell comes with a pre-built context bound to the variable `sc`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now calculate the conditional probabilities of a message containing
    a particular word given that it is *spam*, ![Spam filtering](img/image01202.jpeg).
    This is just the fraction of messages containing that word in the *spam* corpus.
    This, in turn, lets us infer the joint probability of a message containing a certain
    word and being *spam* ![Spam filtering](img/image01203.jpeg). We will do this
    for all four combinations of classes: whether any given word is present or absent
    in a message, and whether that message is spam or ham:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE482]'
  prefs: []
  type: TYPE_PRE
- en: 'We will re-use these RDDs in several places in the calculation, so let''s tell
    Spark to keep them in memory to avoid having to re-calculate them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE483]'
  prefs: []
  type: TYPE_PRE
- en: We now need to calculate the probabilities of words being present, ![Spam filtering](img/image01198.jpeg).
    This is just the sum of `pPresentAndSpam` and `pPresentAndHam`, for each word.
    The tricky part is that not all words are present in both the ham and spam messages.
    We must therefore do a full outer join of those RDDs. This will give an RDD mapping
    each word to a pair of `Option[Double]` values. For words absent in either the
    ham or spam messages, we must use a default value. A sensible default is ![Spam
    filtering](img/image01204.jpeg) for spam messages (a more rigorous approach would
    be to use *additive smoothing*). This implies that the word would appear once
    if the corpus was twice as large.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE484]'
  prefs: []
  type: TYPE_PRE
- en: Note that we could also have chosen 0 as the default value. This complicates
    the information gain calculation somewhat, since we cannot just take the log of
    a zero value, and it seems unlikely that a particular word has exactly zero probability
    of occurring in an email.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now construct an RDD mapping words to ![Spam filtering](img/image01198.jpeg),
    the probability that a word exists in either a spam or a ham message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE485]'
  prefs: []
  type: TYPE_PRE
- en: We now have all the RDDs that we need to calculate the mutual information between
    the presence of a word in a message and whether it is ham or spam. We need to
    bring them all together using the equation for the mutual information outlined
    earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start by defining a helper method that, given an RDD of joint probabilities
    *P(X, Y)* and marginal probabilities *P(X)* and *P(Y)*, calculates ![Spam filtering](img/image01205.jpeg).
    Here, *P(X)* could, for instance, be the probability of a word being present in
    a message ![Spam filtering](img/image01198.jpeg) and *P(Y)* would be the probability
    that that message is *spam*, ![Spam filtering](img/image01206.jpeg):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE486]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use our function to calculate the four terms in the mutual information
    sum:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE487]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we just need to sum those four terms together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE488]'
  prefs: []
  type: TYPE_PRE
- en: 'The RDD `mutualInformation` is a key-value RDD mapping each word to a measure
    of how informative the presence of that word is in discerning whether a message
    is spam or ham. Let''s print out the twenty words that are most informative of
    whether a message is ham or spam:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE489]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run this using `spark-submit`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE490]'
  prefs: []
  type: TYPE_PRE
- en: Thus, we find that the presence of words like `language` or `free` or `!` carry
    the most information, because they are almost exclusively present in either just
    spam messages or just ham messages. A very simple classification algorithm could
    just take the top 10 (by mutual information) spam words, and the top 10 ham words
    and see whether a message contains more spam words or ham words. We will explore
    machine learning algorithms for classification in more depth in [Chapter 12](part0117.xhtml#aid-3FIHQ2
    "Chapter 12. Distributed Machine Learning with MLlib"), *Distributed Machine Learning
    with MLlib*.
  prefs: []
  type: TYPE_NORMAL
- en: Lifting the hood
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last section of this chapter, we will discuss, very briefly, how Spark
    works internally. For a more detailed discussion, see the *References* section
    at the end of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: When you open a Spark context, either explicitly or by launching the Spark shell,
    Spark starts a web UI with details of how the current task and past tasks have
    executed. Let's see this in action for the example mutual information program
    we wrote in the last section. To prevent the context from shutting down when the
    program completes, you can insert a call to `readLine` as the last line of the
    `main` method (after the call to `takeOrdered`). This expects input from the user,
    and will therefore pause program execution until you press *enter*.
  prefs: []
  type: TYPE_NORMAL
- en: To access the UI, point your browser to `127.0.0.1:4040`. If you have other
    instances of the Spark shell running, the port may be `4041`, or `4042` and so
    on.
  prefs: []
  type: TYPE_NORMAL
- en: '![Lifting the hood](img/image01207.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The first page of the UI tells us that our application contains three *jobs*.
    A job occurs as the result of an action. There are, indeed, three actions in our
    application: the first two are called within the `wordFractionInFiles` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE491]'
  prefs: []
  type: TYPE_PRE
- en: The last job results from the call to `takeOrdered`, which forces the execution
    of the entire pipeline of RDD transformations that calculate the mutual information.
  prefs: []
  type: TYPE_NORMAL
- en: 'The web UI lets us delve deeper into each job. Click on the `takeOrdered` job
    in the job table. You will get taken to a page that describes the job in more
    detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Lifting the hood](img/image01208.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Of particular interest is the **DAG visualization** entry. This is a graph of
    the execution plan to fulfill the action, and provides a glimpse of the inner
    workings of Spark.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you define a job by calling an action on an RDD, Spark looks at the RDD''s
    lineage and constructs a graph mapping the dependencies: each RDD in the lineage
    is represented by a node, with directed edges going from this RDD''s parent to
    itself. This type of graph is called a **directed** **acyclic graph** (**DAG**),
    and is a data structure useful for dependency resolution. Let''s explore the DAG
    for the `takeOrdered` job in our program using the web UI. The graph is quite
    complex, and it is therefore easy to get lost, so here is a simplified reproduction
    that only lists the RDDs bound to variable names in the program.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Lifting the hood](img/image01209.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, at the bottom of the graph, we have the `mutualInformation`
    RDD. This is the RDD that we need to construct for our action. This RDD depends
    on the intermediate elements in the sum, `igFragment1`, `igFragment2`, and so
    on. We can work our way back through the list of dependencies until we reach the
    other end of the graph: RDDs that do not depend on other RDDs, only on external
    sources.'
  prefs: []
  type: TYPE_NORMAL
- en: Once the graph is built, the Spark engines formulates a plan to execute the
    job. The plan starts with the RDDs that only have external dependencies (such
    as RDDs built by loading files from disk or fetching from a database) or RDDs
    that already have cached data. Each arrow along the graph is translated to a set
    of *tasks*, with each task applying a transformation to a partition of the data.
  prefs: []
  type: TYPE_NORMAL
- en: Tasks are grouped into *stages*. A stage consists of a set of tasks that can
    all be performed without needing an intermediate shuffle.
  prefs: []
  type: TYPE_NORMAL
- en: Data shuffling and partitions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To understand data shuffling in Spark, we first need to understand how data
    is partitioned in RDDs. When we create an RDD by, for instance, loading a file
    from HDFS, or reading a file in local storage, Spark has no control over what
    bits of data are distributed in which partitions. This becomes a problem for key-value
    RDDs: these often require knowing where occurrences of a particular key are, for
    instance to perform a join. If the key can occur anywhere in the RDD, we have
    to look through every partition to find the key.'
  prefs: []
  type: TYPE_NORMAL
- en: To prevent this, Spark allows the definition of a *partitioner* on key-value
    RDDs. A partitioner is an attribute of the RDD that determines which partition
    a particular key lands in. When an RDD has a partitioner set, the location of
    a key is entirely determined by the partitioner, and not by the RDD's history,
    or the number of keys. Two different RDDs with the same partitioner will map the
    same key to the same partition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Partitions impact performance through their effect on transformations. There
    are two types of transformations on key-value RDDs:'
  prefs: []
  type: TYPE_NORMAL
- en: Narrow transformations, like `mapValues`. In narrow transformations, the data
    to compute a partition in the child RDD resides on a single partition in the parent.
    The data processing for a narrow transformation can therefore be performed entirely
    locally, without needing to communicate data between nodes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Wide transformations, like `reduceByKey`. In wide transformations, the data
    to compute any single partition can reside on all the partitions in the parent.
    The RDD resulting from a wide transformation will, in general, have a partitioner
    set. For instance, the output of a `reduceByKey` transformation are hash-partitioned
    by default: the partition that a particular key ends up in is determined by `hash(key)
    % numPartitions`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thus, in our mutual information example, the RDDs `pPresentAndSpam` and `pPresentAndHam`
    will have the same partition structure since they both have the default hash partitioner.
    All descendent RDDs retain the same keys, all the way down to `mutualInformation`.
    The word `language`, for instance, will be in the same partition for each RDD.
  prefs: []
  type: TYPE_NORMAL
- en: 'Why does all this matter? If an RDD has a partitioner set, this partitioner
    is retained through all subsequent narrow transformations originating from this
    RDD. Let''s go back to our mutual information example. The RDDs `pPresentGivenHam`
    and `pPresentGivenSpam` both originate from `reduceByKey` operations, and they
    both have string keys. They will therefore both have the same hash-partitioner
    (unless we explicitly set a different partitioner). This partitioner is retained
    as we construct `pPresentAndSpam` and `pPresentAndHam`. When we construct `pPresent`,
    we perform a full outer join of `pPresentAndSpam` and `pPresentAndHam`. Since
    both these RDDs have the same partitioner, the child RDD `pPresent` has narrow
    dependencies: we can just join the first partition of `pPresentAndSpam` with the
    first partition of `pPresentAndHam`, the second partition of `pPresentAndSpam`
    with the second partition of `pPresentAndHam` and so on, since any string key
    will be hashed to the same partition in both RDDs. By contrast, without partitioner,
    we would have to join the data in each partition of `pPresentAndSpam` with every
    partition of `pPresentAndSpam`. This would require sending data across the network
    to all the nodes holding `pPresentAndSpam`, a time-consuming exercise.'
  prefs: []
  type: TYPE_NORMAL
- en: This process of having to send the data to construct a child RDD across the
    network, as a result of wide dependencies, is called *shuffling*. Much of the
    art of optimizing a Spark program involves reducing shuffling and, when shuffling
    is necessary, reducing the amount of shuffling.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored the basics of Spark and learned how to construct
    and manipulate RDDs. In the next chapter, we will learn about Spark SQL and DataFrames,
    a set of implicit conversions that allow us to manipulate RDDs in a manner similar
    to pandas DataFrames, and how to interact with different data sources using Spark.
  prefs: []
  type: TYPE_NORMAL
- en: Reference
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Learning Spark*, by *Holden Karau*, *Andy Konwinski*, *Patrick Wendell*, and
    *Matei Zaharia*, *O''Reilly*, provides a much more complete introduction to Spark
    that this chapter can provide. I thoroughly recommend it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are interested in learning more about information theory, I recommend
    *David MacKay's* book *Information Theory, Inference, and Learning Algorithms*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Information Retrieval*, by *Manning*, *Raghavan*, and *Schütze*, describes
    how to analyze textual data (including lemmatization and stemming). An online'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On the Ling-Spam dataset, and how to analyze it: [http://www.aueb.gr/users/ion/docs/ir_memory_based_antispam_filtering.pdf](http://www.aueb.gr/users/ion/docs/ir_memory_based_antispam_filtering.pdf).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This blog post delves into the Spark Web UI in more detail. [https://databricks.com/blog/2015/06/22/understanding-your-spark-application-through-visualization.html](https://databricks.com/blog/2015/06/22/understanding-your-spark-application-through-visualization.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This blog post, by *Sandy Ryza*, is the first in a two-part series discussing
    Spark internals, and how to leverage them to improve performance: [http://blog.cloudera.com/blog/2015/03/how-to-tune-your-apache-spark-jobs-part-1/](http://blog.cloudera.com/blog/2015/03/how-to-tune-your-apache-spark-jobs-part-1/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chapter 11. Spark SQL and DataFrames
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned how to build a simple distributed application
    using Spark. The data that we used took the form of a set of e-mails stored as
    text files.
  prefs: []
  type: TYPE_NORMAL
- en: 'We learned that Spark was built around the concept of **resilient distributed
    datasets** (**RDDs**). We explored several types of RDDs: simple RDDs of strings,
    key-value RDDs, and RDDs of doubles. In the case of key-value RDDs and RDDs of
    doubles, Spark added functionality beyond that of the simple RDDs through implicit
    conversions. There is one important type of RDD that we have not explored yet:
    **DataFrames** (previously called **SchemaRDD**). DataFrames allow the manipulation
    of objects significantly more complex than those we have explored to date.'
  prefs: []
  type: TYPE_NORMAL
- en: A DataFrame is a distributed tabular data structure, and is therefore very useful
    for representing and manipulating structured data. In this chapter, we will first
    investigate DataFrames through the Spark shell, and then use the Ling-spam e-mail
    dataset, presented in the previous chapter, to see how DataFrames can be integrated
    in a machine learning pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: DataFrames – a whirlwind introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by opening a Spark shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE492]'
  prefs: []
  type: TYPE_PRE
- en: Let's imagine that we are interested in running analytics on a set of patients
    to estimate their overall health level. We have measured, for each patient, their
    height, weight, age, and whether they smoke.
  prefs: []
  type: TYPE_NORMAL
- en: 'We might represent the readings for each patient as a case class (you might
    wish to write some of this in a text editor and paste it into the Scala shell
    using `:paste`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE493]'
  prefs: []
  type: TYPE_PRE
- en: 'We would, typically, have many thousands of patients, possibly stored in a
    database or a CSV file. We will worry about how to interact with external sources
    later in this chapter. For now, let''s just hard-code a few readings directly
    in the shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE494]'
  prefs: []
  type: TYPE_PRE
- en: 'We can convert `readings` to an RDD by using `sc.parallelize`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE495]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the type parameter of our RDD is `PatientReadings`. Let''s convert
    the RDD to a DataFrame using the `.toDF` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE496]'
  prefs: []
  type: TYPE_PRE
- en: 'We have created a DataFrame where each row corresponds to the readings for
    a specific patient, and the columns correspond to the different features:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE497]'
  prefs: []
  type: TYPE_PRE
- en: The easiest way to create a DataFrame is to use the `toDF` method on an RDD.
    We can convert any `RDD[T]`, where `T` is a case class or a tuple, to a DataFrame.
    Spark will map each attribute of the case class to a column of the appropriate
    type in the DataFrame. It uses reflection to discover the names and types of the
    attributes. There are several other ways of constructing DataFrames, both from
    RDDs and from external sources, which we will explore later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'DataFrames support many operations for manipulating the rows and columns. For
    instance, let''s add a column for the **Body Mass Index** (**BMI**). The BMI is
    a common way of aggregating *height* and *weight* to decide if someone is overweight
    or underweight. The formula for the BMI is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![DataFrames – a whirlwind introduction](img/image01210.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s start by creating a column of the height in meters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE498]'
  prefs: []
  type: TYPE_PRE
- en: '`heightM` has data type `Column`, representing a column of data in a DataFrame.
    Columns support many arithmetic and comparison operators that apply element-wise
    across the column (similarly to Breeze vectors encountered in [Chapter 2](part0018.xhtml#aid-H5A41
    "Chapter 2. Manipulating Data with Breeze"), *Manipulating Data with Breeze*).
    Operations on columns are lazy: the `heightM` column is not actually computed
    when defined. Let''s now define a BMI column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE499]'
  prefs: []
  type: TYPE_PRE
- en: 'It would be useful to add the `bmi` column to our readings DataFrame. Since
    DataFrames, like RDDs, are immutable, we must define a new DataFrame that is identical
    to `readingsDF`, but with an additional column for the BMI. We can do this using
    the `withColumn` method, which takes, as its arguments, the name of the new column
    and a `Column` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE500]'
  prefs: []
  type: TYPE_PRE
- en: 'All the operations we have seen so far are *transformations*: they define a
    pipeline of operations that create new DataFrames. These transformations are executed
    when we call an **action**, such as `show`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE501]'
  prefs: []
  type: TYPE_PRE
- en: 'Besides creating additional columns, DataFrames also support filtering rows
    that satisfy a certain predicate. For instance, we can select all smokers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE502]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, to select everyone who weighs more than 70 kgs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE503]'
  prefs: []
  type: TYPE_PRE
- en: 'It can become cumbersome to keep repeating the DataFrame name in an expression.
    Spark defines the operator `$` to refer to a column in the current DataFrame.
    Thus, the `filter` expression above could have been written more succinctly using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE504]'
  prefs: []
  type: TYPE_PRE
- en: 'The `.filter` method is overloaded. It accepts either a column of Boolean values,
    as above, or a string identifying a Boolean column in the current DataFrame. Thus,
    to filter our `readingsWithBmiDF` DataFrame to sub-select smokers, we could also
    have used the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE505]'
  prefs: []
  type: TYPE_PRE
- en: 'When comparing for equality, you must compare columns with the special *triple-equals*
    operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE506]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, you must use `!==` to select rows that are not equal to a value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE507]'
  prefs: []
  type: TYPE_PRE
- en: Aggregation operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have seen how to apply an operation to every row in a DataFrame to create
    a new column, and we have seen how to use filters to build new DataFrames with
    a sub-set of rows from the original DataFrame. The last set of operations on DataFrames
    is grouping operations, equivalent to the `GROUP BY` statement in SQL. Let''s
    calculate the average BMI for smokers and non-smokers. We must first tell Spark
    to group the DataFrame by a column (the `isSmoker` column, in this case), and
    then apply an aggregation operation (averaging, in this case) to reduce each group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE508]'
  prefs: []
  type: TYPE_PRE
- en: 'This has created a new DataFrame with two columns: the grouping column and
    the column over which we aggregated. Let''s show this DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE509]'
  prefs: []
  type: TYPE_PRE
- en: 'Besides averaging, there are several operators for performing the aggregation
    across each group. We outline some of the more important ones in the table below,
    but, for a full list, consult the *Aggregate functions* section of [http://spark.apache.org/docs/latest/api/scala/index.html#org.apache.spark.sql.functions$](http://spark.apache.org/docs/latest/api/scala/index.html#org.apache.spark.sql.functions%24):'
  prefs: []
  type: TYPE_NORMAL
- en: '| Operator | Notes |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `avg(column)` | Group averages of the values in the specified column. |'
  prefs: []
  type: TYPE_TB
- en: '| `count(column)` | Number of elements in each group in the specified column.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `countDistinct(column, ... )` | Number of distinct elements in each group.
    This can also accept multiple columns to return the count of unique elements across
    several columns. |'
  prefs: []
  type: TYPE_TB
- en: '| `first(column), last(column)` | First/last element in each group |'
  prefs: []
  type: TYPE_TB
- en: '| `max(column), min(column)` | Largest/smallest element in each group |'
  prefs: []
  type: TYPE_TB
- en: '| `sum(column)` | Sum of the values in each group |'
  prefs: []
  type: TYPE_TB
- en: 'Each aggregation operator takes either the name of a column, as a string, or
    an expression of type `Column`. The latter allows aggregation of compound expressions.
    If we wanted the average height, in meters, of the smokers and non-smokers in
    our sample, we could use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE510]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use compound expressions to define the column on which to group.
    For instance, to count the number of patients in each `age` group, increasing
    by decade, we can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE511]'
  prefs: []
  type: TYPE_PRE
- en: We have used the short-hand `"*"` to indicate a count over every column.
  prefs: []
  type: TYPE_NORMAL
- en: Joining DataFrames together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have only considered operations on a single DataFrame. Spark also
    offers SQL-like joins to combine DataFrames. Let''s assume that we have another
    DataFrame mapping the patient id to a (systolic) blood pressure measurement. We
    will assume we have the data as a list of pairs mapping patient IDs to blood pressures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE512]'
  prefs: []
  type: TYPE_PRE
- en: 'We can construct a DataFrame from this RDD of tuples. However, unlike when
    constructing DataFrames from RDDs of case classes, Spark cannot infer column names.
    We must therefore pass these explicitly to `.toDF`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE513]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s join `bloodPressureDF` with `readingsDF`, using the patient ID as the
    join key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE514]'
  prefs: []
  type: TYPE_PRE
- en: 'This performs an *inner join*: only patient IDs present in both DataFrames
    are included in the result. The type of join can be passed as an extra argument
    to `join`. For instance, we can perform a *left join*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE515]'
  prefs: []
  type: TYPE_PRE
- en: Possible join types are `inner`, `outer`, `leftouter`, `rightouter`, or `leftsemi`.
    These should all be familiar, apart from `leftsemi`, which corresponds to a *left
    semi join*.This is the same as an inner join, but only the columns on the left-hand
    side are retained after the join. It is thus a way to filter a DataFrame for rows
    which are present in another DataFrame.
  prefs: []
  type: TYPE_NORMAL
- en: Custom functions on DataFrames
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have only used built-in functions to operate on DataFrame columns.
    While these are often sufficient, we sometimes need greater flexibility. Spark
    lets us apply custom transformations to every row through **user-defined functions**
    (**UDFs**). Let''s assume that we want to use the equation that we derived in
    [Chapter 2](part0018.xhtml#aid-H5A41 "Chapter 2. Manipulating Data with Breeze"),
    *Manipulating Data with Breeze*, for the probability of a person being male, given
    their height and weight. We calculated that the decision boundary was given by:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Custom functions on DataFrames](img/image01211.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Any person with *f > 0* is more likely to be male than female, given their
    height and weight and the training set used for [Chapter 2](part0018.xhtml#aid-H5A41
    "Chapter 2. Manipulating Data with Breeze"), *Manipulating Data with Breeze* (which
    was based on students, so is unlikely to be representative of the population as
    a whole). To convert from a height in centimeters to the normalized height, *rescaledHeight*,
    we can use this formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Custom functions on DataFrames](img/image01212.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Similarly, to convert a weight (in kilograms) to the normalized weight, *rescaledWeight*,
    we can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Custom functions on DataFrames](img/image01213.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The average and standard deviation of the *height* and *weight* are calculated
    from the training set. Let''s write a Scala function that returns whether a person
    is more likely to be male, given their height and weight:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE516]'
  prefs: []
  type: TYPE_PRE
- en: 'To use this function on Spark DataFrames, we need to register it as a **user-defined
    function** (**UDF**). This transforms our function, which accepts integer arguments,
    into one that accepts column arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE517]'
  prefs: []
  type: TYPE_PRE
- en: To register a UDF, we must have access to a `sqlContext` instance. The SQL context
    provides the entry point for DataFrame operations. The Spark shell creates a SQL
    context at startup, bound to the variable `sqlContext`, and destroys it when the
    shell session is closed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first argument passed to the `register` function is the name of the UDF
    (we will use the UDF name later when we write SQL statements on the DataFrame,
    but you can ignore it for now). We can then use the UDF just like the built-in
    transformations included in Spark:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE518]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, Spark applies the function underlying the UDF to every row
    in the DataFrame. We are not limited to using UDFs to create new columns. We can
    also use them in `filter` expressions. For instance, to select rows likely to
    correspond to women:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE519]'
  prefs: []
  type: TYPE_PRE
- en: Using UDFs lets us define arbitrary Scala functions to transform rows, giving
    tremendous additional power for data manipulation.
  prefs: []
  type: TYPE_NORMAL
- en: DataFrame immutability and persistence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: DataFrames, like RDDs, are immutable. When you define a transformation on a
    DataFrame, this always creates a new DataFrame. The original DataFrame cannot
    be modified in place (this is notably different to pandas DataFrames, for instance).
  prefs: []
  type: TYPE_NORMAL
- en: 'Operations on DataFrames can be grouped into two: *transformations*, which
    result in the creation of a new DataFrame, and *actions*, which usually return
    a Scala type or have a side-effect. Methods like `filter` or `withColumn` are
    transformations, while methods like `show` or `head` are actions.'
  prefs: []
  type: TYPE_NORMAL
- en: Transformations are lazy, much like transformations on RDDs. When you generate
    a new DataFrame by transforming an existing DataFrame, this results in the elaboration
    of an execution plan for creating the new DataFrame, but the data itself is not
    transformed immediately. You can access the execution plan with the `queryExecution`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you call an action on a DataFrame, Spark processes the action as if it
    were a regular RDD: it implicitly builds a direct acyclic graph to resolve dependencies,
    processing the transformations needed to build the DataFrame on which the action
    was called.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Much like RDDs, we can persist DataFrames in memory or on disk:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE520]'
  prefs: []
  type: TYPE_PRE
- en: 'This works in the same way as persisting RDDs: next time the RDD is calculated,
    it will be kept in memory (provided there is enough space), rather than discarded.
    The level of persistence can also be set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE521]'
  prefs: []
  type: TYPE_PRE
- en: SQL statements on DataFrames
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By now, you will have noticed that many operations on DataFrames are inspired
    by SQL operations. Additionally, Spark allows us to register DataFrames as tables
    and query them with SQL statements directly. We can therefore build a temporary
    database as part of the program flow.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s register `readingsDF` as a temporary table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE522]'
  prefs: []
  type: TYPE_PRE
- en: This registers a temporary table that can be used in SQL queries. Registering
    a temporary table relies on the presence of a SQL context. The temporary tables
    are destroyed when the SQL context is destroyed (when we close the shell, for
    instance).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explore what we can do with our temporary tables and the SQL context.
    We can first get a list of all the tables currently registered with the context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE523]'
  prefs: []
  type: TYPE_PRE
- en: 'This returns a DataFrame. In general, all operations on a SQL context that
    return data return DataFrames:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE524]'
  prefs: []
  type: TYPE_PRE
- en: 'We can query this table by passing SQL statements to the SQL context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE525]'
  prefs: []
  type: TYPE_PRE
- en: 'Any UDFs registered with the `sqlContext` are available through the name given
    to them when they were registered. We can therefore use them in SQL queries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE526]'
  prefs: []
  type: TYPE_PRE
- en: You might wonder why one would want to register DataFrames as temporary tables
    and run SQL queries on those tables, when the same functionality is available
    directly on DataFrames. The main reason is for interacting with external tools.
    Spark can run a SQL engine that exposes a JDBC interface, meaning that programs
    that know how to interact with a SQL database will be able to make use of the
    temporary tables.
  prefs: []
  type: TYPE_NORMAL
- en: We don't have the space to cover how to set up a distributed SQL engine in this
    book, but you can find details in the Spark documentation ([http://spark.apache.org/docs/latest/sql-programming-guide.html#distributed-sql-engine](http://spark.apache.org/docs/latest/sql-programming-guide.html#distributed-sql-engine)).
  prefs: []
  type: TYPE_NORMAL
- en: Complex data types – arrays, maps, and structs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, all the elements in our DataFrames were simple types. DataFrames support
    three additional collection types: arrays, maps, and structs.'
  prefs: []
  type: TYPE_NORMAL
- en: Structs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first compound type that we will look at is the **struct**. A struct is
    similar to a case class: it stores a set of key-value pairs, with a fixed set
    of keys. If we convert an RDD of a case class containing nested case classes to
    a DataFrame, Spark will convert the nested objects to a struct.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s imagine that we want to serialize Lords of the Ring characters. We might
    use the following object model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE527]'
  prefs: []
  type: TYPE_PRE
- en: 'We want to create a DataFrame of `LotrCharacter` instances. Let''s create some
    dummy data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE528]'
  prefs: []
  type: TYPE_PRE
- en: 'The `weapon` attribute in the case class was converted to a struct column in
    the DataFrame. To extract sub-fields from a struct, we can pass the field name
    to the column''s `.apply` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE529]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use this derived column just as we would any other column. For instance,
    let''s filter our DataFrame to only contain characters who wield a sword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE530]'
  prefs: []
  type: TYPE_PRE
- en: Arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s return to the earlier example, and assume that, besides height, weight,
    and age measurements, we also have phone numbers for our patients. Each patient
    might have zero, one, or more phone numbers. We will define a new case class and
    new dummy data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE531]'
  prefs: []
  type: TYPE_PRE
- en: 'The `List[String]` array in our case class gets translated to an `array<string>`
    data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE532]'
  prefs: []
  type: TYPE_PRE
- en: 'As with structs, we can construct a column for a specific index the array.
    For instance, we can select the first element in each array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE533]'
  prefs: []
  type: TYPE_PRE
- en: Maps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last compound data type is the map. Maps are similar to structs inasmuch
    as they store key-value pairs, but the set of keys is not fixed when the DataFrame
    is created. They can thus store arbitrary key-value pairs.
  prefs: []
  type: TYPE_NORMAL
- en: Scala maps will be converted to DataFrame maps when the DataFrame is constructed.
    They can then be queried in a manner similar to structs.
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with data sources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A major challenge in data science or engineering is dealing with the wealth
    of input and output formats for persisting data. We might receive or send data
    as CSV files, JSON files, or through a SQL database, to name a few.
  prefs: []
  type: TYPE_NORMAL
- en: Spark provides a unified API for serializing and de-serializing DataFrames to
    and from different data sources.
  prefs: []
  type: TYPE_NORMAL
- en: JSON files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Spark supports loading data from JSON files, provided that each line in the
    JSON file corresponds to a single JSON object. Each object will be mapped to a
    DataFrame row. JSON arrays are mapped to arrays, and embedded objects are mapped
    to structs.
  prefs: []
  type: TYPE_NORMAL
- en: This section would be a little dry without some data, so let's generate some
    from the GitHub API. Unfortunately, the GitHub API does not return JSON formatted
    as a single object per line. The code repository for this chapter contains a script,
    `FetchData.scala` which will download and format JSON entries for Martin Odersky's
    repositories, saving the objects to a file named `odersky_repos.json` (go ahead
    and change the GitHub user in `FetchData.scala` if you want). You can also download
    a pre-constructed data file from [data.scala4datascience.com/odersky_repos.json](http://data.scala4datascience.com/odersky_repos.json).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s dive into the Spark shell and load this data into a DataFrame. Reading
    from a JSON file is as simple as passing the file name to the `sqlContext.read.json`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE534]'
  prefs: []
  type: TYPE_PRE
- en: 'Reading from a JSON file loads data as a DataFrame. Spark automatically infers
    the schema from the JSON documents. There are many columns in our DataFrame. Let''s
    sub-select a few to get a more manageable DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE535]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s save the DataFrame back to JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE536]'
  prefs: []
  type: TYPE_PRE
- en: If you look at the files present in the directory in which you are running the
    Spark shell, you will notice a `repos_short.json` directory. Inside it, you will
    see files named `part-000000`, `part-000001`, and so on. When serializing JSON,
    each partition of the DataFrame is serialized independently. If you are running
    this on several machines, you will find parts of the serialized output on each
    computer.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may, optionally, pass a `mode` argument to control how Spark deals with
    the case of an existing `repos_short.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE537]'
  prefs: []
  type: TYPE_PRE
- en: Available save modes are `ErrorIfExists`, `Append` (only available for Parquet
    files), `Overwrite`, and `Ignore` (do not save if the file exists already).
  prefs: []
  type: TYPE_NORMAL
- en: Parquet files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Apache Parquet is a popular file format well-suited for storing tabular data.
    It is often used for serialization in the Hadoop ecosystem, since it allows for
    efficient extraction of specific columns and rows without having to read the entire
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Serialization and deserialization of Parquet files is identical to JSON, with
    the substitution of `json` with `parquet`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE538]'
  prefs: []
  type: TYPE_PRE
- en: In general, Parquet will be more space-efficient than JSON for storing large
    collections of objects. Parquet is also much more efficient at retrieving specific
    columns or rows, if the partition can be inferred from the row. Parquet is thus
    advantageous over JSON unless you need the output to be human-readable, or de-serializable
    by an external program.
  prefs: []
  type: TYPE_NORMAL
- en: Standalone programs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have been using Spark SQL and DataFrames through the Spark shell.
    To use it in standalone programs, you will need to create it explicitly, from
    a Spark context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE539]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, importing the `implicits` object nested in `sqlContext` allows
    the conversions of RDDs to DataFrames:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE540]'
  prefs: []
  type: TYPE_PRE
- en: We will use DataFrames extensively in the next chapter to manipulate data to
    get it ready for use with MLlib.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored Spark SQL and DataFrames. DataFrames add a rich
    layer of abstraction on top of Spark's core engine, greatly facilitating the manipulation
    of tabular data. Additionally, the source API allows the serialization and de-serialization
    of DataFrames from a rich variety of data files.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will build on our knowledge of Spark and DataFrames
    to build a spam filter using MLlib.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'DataFrames are a relatively recent addition to Spark. There is thus still a
    dearth of literature and documentation. The first port of call should be the Scala
    docs, available at: [http://spark.apache.org/docs/latest/api/scala/index.html#org.apache.spark.sql.DataFrame](http://spark.apache.org/docs/latest/api/scala/index.html#org.apache.spark.sql.DataFrame).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Scaladocs for operations available on the DataFrame `Column` type can be
    found at: [http://spark.apache.org/docs/latest/api/scala/#org.apache.spark.sql.Column](http://spark.apache.org/docs/latest/api/scala/#org.apache.spark.sql.Column).'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is also extensive documentation on the Parquet file format: [https://parquet.apache.org](https://parquet.apache.org).'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 12. Distributed Machine Learning with MLlib
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Machine learning describes the construction of algorithms that make predictions
    from data. It is a core component of most data science pipelines, and is often
    seen to be the component adding the most value: the accuracy of the machine learning
    algorithm determines the success of the data science endeavor. It is also, arguably,
    the section of the data science pipeline that requires the most knowledge from
    fields beyond software engineering: a machine learning expert will be familiar,
    not just with algorithms, but also with statistics and with the business domain.'
  prefs: []
  type: TYPE_NORMAL
- en: Choosing and tuning a machine learning algorithm to solve a particular problem
    involves significant exploratory analysis to try and determine which features
    are relevant, how features are correlated, whether there are outliers in the dataset,
    and so on. Designing suitable machine learning pipelines is difficult. Add on
    an additional layer of complexity resulting from the size of datasets and the
    need for scalability, and you have a real challenge.
  prefs: []
  type: TYPE_NORMAL
- en: '**MLlib** helps mitigate this difficulty. MLlib is a component of Spark that
    provides machine learning algorithms on top of the core Spark libraries. It offers
    a set of learning algorithms that parallelize well over distributed datasets.'
  prefs: []
  type: TYPE_NORMAL
- en: 'MLlib has evolved into two separate layers. MLlib itself contains the core
    algorithms, and **ml**, also called the *pipeline API*, defines an API for gluing
    algorithms together and provides a higher level of abstraction. The two libraries
    differ in the data types on which they operate: the original MLlib predates the
    introduction of DataFrames, and acts mainly on RDDs of feature vectors. The pipeline
    API operates on DataFrames.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will study the newer pipeline API, diving into MLlib only
    when the functionality is missing from the pipeline API.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter does not try to teach the machine learning fundamentals behind
    the algorithms that we present. We assume that the reader has a good enough grasp
    of machine learning tools and techniques to understand, at least superficially,
    what the algorithms presented here do, and we defer to better authors for in-depth
    explanations of the mechanics of statistical learning (we present several references
    at the end of the chapter).
  prefs: []
  type: TYPE_NORMAL
- en: MLlib is a rich library that is evolving rapidly. This chapter does not aim
    to give a complete overview of the library. We will work through the construction
    of a machine learning pipeline to train a spam filter, learning about the parts
    of MLlib that we need along the way. Having read this chapter, you will have an
    understanding of how the different parts of the library fit together, and can
    use the online documentation, or a more specialized book (see references at the
    end of this chapter) to learn about the parts of MLlib not covered here.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing MLlib – Spam classification
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's introduce MLlib with a concrete example. We will look at spam classification
    using the Ling-Spam dataset that we used in the [Chapter 10](part0097.xhtml#aid-2SG6I1
    "Chapter 10. Distributed Batch Processing with Spark"), *Distributed Batch Processing
    with Spark*. We will create a spam filter that uses logistic regression to estimate
    the probability that a given message is spam.
  prefs: []
  type: TYPE_NORMAL
- en: We will run through examples using the Spark shell, but you will find an analogous
    program in `LogisticRegressionDemo.scala` among the examples for this chapter.
    If you have not installed Spark, refer to [Chapter 10](part0097.xhtml#aid-2SG6I1
    "Chapter 10. Distributed Batch Processing with Spark"), *Distributed Batch Processing
    with Spark*, for installation instructions.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by loading the e-mails in the Ling-Spam dataset. If you have not
    done this for [Chapter 10](part0097.xhtml#aid-2SG6I1 "Chapter 10. Distributed
    Batch Processing with Spark"), *Distributed Batch Processing with Spark*, download
    the data from [data.scala4datascience.com/ling-spam.tar.gz](http://data.scala4datascience.com/ling-spam.tar.gz)
    or [data.scala4datascience.com/ling-spam.zip](http://data.scala4datascience.com/ling-spam.zip),
    depending on whether you want a `tar.gz` file or a `zip` file, and unpack the
    archive. This will create a `spam` directory and a `ham` directory containing
    spam and ham messages, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use the `wholeTextFiles` method to load spam and ham e-mails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE541]'
  prefs: []
  type: TYPE_PRE
- en: 'The `wholeTextFiles` method creates a key-value RDD where the keys are the
    file names and the values are the contents of the files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE542]'
  prefs: []
  type: TYPE_PRE
- en: 'The algorithms in the pipeline API work on DataFrames. We must therefore convert
    our key-value RDDs to DataFrames. We define a new case class, `LabelledDocument`,
    which contains a message text and a category label identifying whether a message
    is `spam` or `ham`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE543]'
  prefs: []
  type: TYPE_PRE
- en: 'To create models, we will need all the documents in a single DataFrame. Let''s
    therefore take the union of our two `LabelledDocument` RDDs, and transform that
    to a DataFrame. The `union` method concatenates RDDs together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE544]'
  prefs: []
  type: TYPE_PRE
- en: Let's do some basic checks to verify that we have loaded all the documents.
    We start by persisting the DataFrame in memory to avoid having to re-create it
    from the raw text files.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE545]'
  prefs: []
  type: TYPE_PRE
- en: Let's now split the DataFrame into a training set and a test set. We will use
    the test set to validate the model that we build. For now, we will just use a
    single split, training the model on 70% of the data and testing it on the remaining
    30%. In the next section, we will look at cross-validation, which provides more
    rigorous way to check the accuracy of our models.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can achieve this 70-30 split using the DataFrame''s `.randomSplit` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE546]'
  prefs: []
  type: TYPE_PRE
- en: 'The `.randomSplit` method takes an array of weights and returns an array of
    DataFrames, of approximately the size specified by the weights. For instance,
    we passed weights `0.7` and `0.3`, indicating that any given row has a 70% chance
    of ending up in `trainDF`, and a 30% chance of ending up in `testDF`. Note that
    this means the split DataFrames are not of fixed size: `trainDF` is approximately,
    but not exactly, 70% the size of `documentsDF`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE547]'
  prefs: []
  type: TYPE_PRE
- en: If you need a fixed size sample, use the DataFrame's `.sample` method to obtain
    `trainDF` and filter `documentDF` for rows not in `trainDF`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are now in a position to start using MLlib. Our attempt at classification
    will involve performing logistic regression on *term-frequency vectors*: we will
    count how often each word appears in each message, and use the frequency of occurrence
    as a feature. Before jumping into the code, let''s take a step back and discuss
    the structure of machine learning pipelines.'
  prefs: []
  type: TYPE_NORMAL
- en: Pipeline components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Pipelines consist of a set of components joined together such that the DataFrame
    produced by one component is used as input for the next component. The components
    available are split into two classes: *transformers* and *estimators*.'
  prefs: []
  type: TYPE_NORMAL
- en: Transformers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Transformers** transform one DataFrame into another, normally by appending
    one or more columns.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step in our spam classification algorithm is to split each message
    into an array of words. This is called **tokenization**. We can use the `Tokenizer`
    transformer, provided by MLlib:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE548]'
  prefs: []
  type: TYPE_PRE
- en: 'The behavior of transformers can be customized through getters and setters.
    The easiest way of obtaining a list of the parameters available is to call the
    `.explainParams` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE549]'
  prefs: []
  type: TYPE_PRE
- en: 'We see that the behavior of a `Tokenizer` instance can be customized using
    two parameters: `inputCol` and `outputCol`, describing the header of the column
    containing the input (the string to be tokenized) and the output (the array of
    words), respectively. We can set these parameters using the `setInputCol` and
    `setOutputCol` methods.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We set `inputCol` to `"text"`, since that is what the column is called in our
    training and test DataFrames. We will set `outputCol` to `"words"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE550]'
  prefs: []
  type: TYPE_PRE
- en: In due course, we will integrate `tokenizer` into a pipeline, but, for now,
    let's just use it to transform the training DataFrame, to verify that it works
    correctly.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE551]'
  prefs: []
  type: TYPE_PRE
- en: The `tokenizer` transformer produces a new DataFrame with an additional column,
    `words`, containing an array of the words in the `text` column.
  prefs: []
  type: TYPE_NORMAL
- en: Clearly, we can use our `tokenizer` to transform any DataFrame with the correct
    schema. We could, for instance, use it on the test set. Much of machine learning
    involves calling the same (or a very similar) pipeline on different data sets.
    By providing the pipeline abstraction, MLlib facilitates reasoning about complex
    machine learning algorithms consisting of many cleaning, transformation, and modeling
    components.
  prefs: []
  type: TYPE_NORMAL
- en: The next step in our pipeline is to calculate the frequency of occurrence of
    each word in each message. We will eventually use these frequencies as features
    in our algorithm. We will use the `HashingTF` transformer to transform from arrays
    of words to word frequency vectors for each message.
  prefs: []
  type: TYPE_NORMAL
- en: The `HashingTF` transformer constructs a sparse vector of word frequencies from
    input iterables. Each element in the word array gets transformed to a hash code.
    This hash code is truncated to a value between *0* and a large number *n*, the
    total number of elements in the output vector. The term frequency vector is just
    the number of occurrences of the truncated hash.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run through an example manually to understand how this works. We will
    calculate the term frequency vector for `Array("the", "dog", "jumped", "over",
    "the")`. Let''s set *n*, the number of elements in the sparse output vector, to
    16 for this example. The first step is to calculate the hash code for each element
    in our array. We can use the built-in `##` method, which calculates a hash code
    for any object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE552]'
  prefs: []
  type: TYPE_PRE
- en: 'To transform the hash codes into valid vector indices, we take the modulo of
    each hash by the size of the vector (`16`, in this case):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE553]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then create a mapping from indices to the number of times that index
    appears:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE554]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can convert this map to a sparse vector, where the value at each
    element in the vector is the frequency with which this particular index occurs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE555]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the `.toString` output for a sparse vector consists of three elements:
    the total size of the vector, followed by two lists: the first is a series of
    indices, and the second is a series of values at those indices.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using a sparse vector provides a compact and efficient way of representing
    the frequency of occurrence of words in the message, and is exactly how `HashingTF`
    works under the hood. The disadvantage is that the mapping from words to indices
    is not necessarily unique: truncating hash codes by the length of the vector will
    map different strings to the same index. This is known as a *collision*. The solution
    is to make *n* large enough that the frequency of collisions is minimized.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`HashingTF` is similar to building a hash table (for example, a Scala map)
    whose keys are words and whose values are the number of times that word occurs
    in the message, with one important difference: it does not attempt to deal with
    hash collisions. Thus, if two words map to the same hash, they will have the wrong
    frequency. There are two advantages to using this algorithm over just constructing
    a hash table:'
  prefs: []
  type: TYPE_NORMAL
- en: We do not have to maintain a list of distinct words in memory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each e-mail can be transformed to a vector independently of all others: we
    do not have to reduce over different partitions to get the set of keys in the
    map. This greatly eases applying this algorithm to each e-mail in a distributed
    manner, since we can apply the `HashingTF` transformation on each partition independently.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The main disadvantage is that we must use machine learning algorithms that can
    take advantage of the sparse representation efficiently. This is the case with
    logistic regression, which we will use here.
  prefs: []
  type: TYPE_NORMAL
- en: As you might expect, the `HashingTF` transformer takes, as parameters, the input
    and output columns. It also takes a parameter defining the number of distinct
    hash buckets in the vector. Increasing the number of buckets decreases the number
    of collisions. In practice, a value between ![Transformers](img/image01214.jpeg)
    and ![Transformers](img/image01215.jpeg) is recommended.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE556]'
  prefs: []
  type: TYPE_PRE
- en: 'Each element in the `features` column is a sparse vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE557]'
  prefs: []
  type: TYPE_PRE
- en: 'We can thus interpret our vector as: the word that hashes to element `33` occurs
    three times, the word that hashes to element `36` occurs four times etc.'
  prefs: []
  type: TYPE_NORMAL
- en: Estimators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We now have the features ready for logistic regression. The last step prior
    to running logistic regression is to create the target variable. We will transform
    the `category` column in our DataFrame to a binary 0/1 target column. Spark provides
    a `StringIndexer` class that replaces a set of strings in a column with doubles.
    A `StringIndexer` is not a transformer: it must first be ''fitted'' to a set of
    categories to calculate the mapping from string to numeric value. This introduces
    the second class of components in the pipeline API: *estimators*.'
  prefs: []
  type: TYPE_NORMAL
- en: Unlike a transformer, which works "out of the box", an estimator must be fitted
    to a DataFrame. For our string indexer, the fitting process involves obtaining
    the list of unique strings (`"spam"` and `"ham"`) and mapping each of these to
    a double. The fitting process outputs a transformer which can be used on subsequent
    DataFrames.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE558]'
  prefs: []
  type: TYPE_PRE
- en: 'The transformer produced by the fitting process has a `labels` attribute describing
    the mapping it applies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE559]'
  prefs: []
  type: TYPE_PRE
- en: 'Each label will get mapped to its index in the array: thus, our transformer
    maps `ham` to `0` and `spam` to `1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE560]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have the feature vectors and classification labels in the correct format
    for logistic regression. The component for performing logistic regression is an
    estimator: it is fitted to a training DataFrame to create a trained model. The
    model can then be used to transform test DataFrames.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE561]'
  prefs: []
  type: TYPE_PRE
- en: 'The `LogisticRegression` estimator expects the feature column to be named `"features"`
    and the label column (the target) to be named `"label"`, by default. There is
    no need to set these explicitly, since they match the column names set by `hashingTF`
    and `indexer`. There are several parameters that can be set to control how logistic
    regression works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE562]'
  prefs: []
  type: TYPE_PRE
- en: 'For now, we just set the `maxIter` parameter. We will look at the effect of
    other parameters, such as regularization, later on. Let''s now fit the classifier
    to `labelledDF`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE563]'
  prefs: []
  type: TYPE_PRE
- en: 'This produces a transformer that we can use on a DataFrame with a `features`
    column. The transformer appends a `prediction` column and a `probability` column.
    We can, for instance use `trainedClassifier` to transform `labelledDF`, the training
    set itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE564]'
  prefs: []
  type: TYPE_PRE
- en: 'A quick way of checking the performance of our model is to just count the number
    of misclassified messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE565]'
  prefs: []
  type: TYPE_PRE
- en: In this case, logistic regression managed to correctly classify every message
    but one in the training set. This is perhaps unsurprising, given the large number
    of features and the relatively clear demarcation between the words used in spam
    and legitimate e-mails.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, the real test of a model is not how well it performs on the training
    set, but how well it performs on a test set. To test this, we could just push
    the test DataFrame through the same stages that we used to train the model, replacing
    estimators with the fitted transformer that they produced. MLlib provides the
    *pipeline* abstraction to facilitate this: we wrap an ordered list of transformers
    and estimators in a pipeline. This pipeline is then fitted to a DataFrame corresponding
    to the training set. The fitting produces a `PipelineModel` instance, equivalent
    to the pipeline but with estimators replaced by transformers, as shown in this
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Estimators](img/image01216.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s construct the pipeline for our logistic regression spam filter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE566]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the pipeline is defined, we fit it to the DataFrame holding the training
    set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE567]'
  prefs: []
  type: TYPE_PRE
- en: 'When fitting a pipeline to a DataFrame, estimators and transformers are treated
    differently:'
  prefs: []
  type: TYPE_NORMAL
- en: Transformers are applied to the DataFrame and copied, as is, into the pipeline
    model.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Estimators are fitted to the DataFrame, producing a transformer. The transformer
    is then applied to the DataFrame, and appended to the pipeline model.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can now apply the pipeline model to the test set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE568]'
  prefs: []
  type: TYPE_PRE
- en: 'This has added a `prediction` column to the DataFrame with the predictions
    of our logistic regression model. To measure the performance of our algorithm,
    we calculate the classification error on the test set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE569]'
  prefs: []
  type: TYPE_PRE
- en: Thus, our naive logistic regression algorithm, with no model selection, or regularization,
    mis-classifies 2.3% of e-mails. You may, of course, get slightly different results,
    since the train-test split was random.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s save the training and test DataFrames, with predictions, as `parquet`
    files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE570]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In spam classification, a false positive is considerably worse than a false
    negative: it is much worse to classify a legitimate message as spam, than it is
    to let a spam message through. To account for this, we could increase the threshold
    for classification: only messages that score, for instance, 0.7 or above would
    get classified as spam. This raises the obvious question of choosing the right
    threshold. One way to do this would be to investigate the false positive rate
    incurred in the test set for different thresholds, and choosing the lowest threshold
    to give us an acceptable false positive rate. A good way of visualizing this is
    to use ROC curves, which we will investigate in the next section.'
  prefs: []
  type: TYPE_NORMAL
- en: Evaluation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unfortunately, the functionality for evaluating model quality in the pipeline
    API remains limited, as of version 1.5.2\. Logistic regression does output a summary
    containing several evaluation metrics (available through the `summary` attribute
    on the trained model), but these are calculated on the training set. In general,
    we want to evaluate the performance of the model both on the training set and
    on a separate test set. We will therefore dive down to the underlying MLlib layer
    to access evaluation metrics.
  prefs: []
  type: TYPE_NORMAL
- en: MLlib provides a module, `org.apache.spark.mllib.evaluation`, with a set of
    classes for assessing the quality of a model. We will use the `BinaryClassificationMetrics`
    class here, since spam classification is a binary classification problem. Other
    evaluation classes provide metrics for multi-class models, regression models and
    ranking models.
  prefs: []
  type: TYPE_NORMAL
- en: 'As in the previous section, we will illustrate the concepts in the shell, but
    you will find analogous code in the `ROC.scala` script in the code examples for
    this chapter. We will use *breeze-viz* to plot curves, so, when starting the shell,
    we must ensure that the relevant libraries are on the classpath. We will use SBT
    assembly, as described in [Chapter 10](part0097.xhtml#aid-2SG6I1 "Chapter 10. Distributed
    Batch Processing with Spark"), *Distributed Batch Processing with Spark* (specifically,
    the *Building and running standalone programs* section), to create a JAR with
    the required dependencies. We will then pass this JAR to the Spark shell, allowing
    us to import breeze-viz. Let''s write a `build.sbt` file that declares a dependency
    on breeze-viz:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE571]'
  prefs: []
  type: TYPE_PRE
- en: 'Package the dependencies into a jar with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE572]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create a jar called `spam_filter-assembly-0.1-SNAPSHOT.jar` in the
    `target/scala-2.10`/ directory. To include this jar in the Spark shell, re-start
    the shell with the `--jars` command line argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE573]'
  prefs: []
  type: TYPE_PRE
- en: 'To verify that the packaging worked correctly, try to import `breeze.plot`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE574]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s load the test set, with predictions, which we created in the previous
    section and saved as a `parquet` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE575]'
  prefs: []
  type: TYPE_PRE
- en: 'The `BinaryClassificationMetrics` object expects an `RDD[(Double, Double)]`
    object of pairs of scores (the probability assigned by the classifier that a particular
    e-mail is spam) and labels (whether an e-mail is actually spam). We can extract
    this RDD from our DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE576]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now construct the `BinaryClassificationMetrics` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE577]'
  prefs: []
  type: TYPE_PRE
- en: The `BinaryClassificationMetrics` objects contain many useful metrics for evaluating
    the performance of a classification model. We will look at the **receiver operating**
    **characteristic** (**ROC**) curve.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**ROC Curves**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine gradually decreasing, from 1.0, the probability threshold at which
    we assume a particular e-mail is spam. Clearly, when the threshold is set to 1.0,
    no e-mails will get classified as spam. This means that there will be no **false
    positives** (ham messages which we incorrectly classify as spam), but it also
    means that there will be no **true positives** (spam messages that we correctly
    identify as spam): all spam e-mails will be incorrectly identified as ham.'
  prefs: []
  type: TYPE_NORMAL
- en: As we gradually lower the probability threshold at which we assume a particular
    e-mail is spam, our spam filter will, hopefully, start identifying a large fraction
    of e-mails as spam. The vast majority of these will, if our algorithm is well-designed,
    be real spam. Thus, our rate of true positives increases. As we gradually lower
    the threshold, we start classifying messages about which we are less sure of as
    spam. This will increase the number of messages correctly identified as spam,
    but it will also increase the number of false positives.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ROC curve plots, for each threshold value, the fraction of true positives
    against the fraction of false positives. In the best case, the curve is always
    1: this happens when all spam messages are given a score of 1.0, and all ham messages
    are given a score of 0.0\. By contrast, the worst case happens when the curve
    is a diagonal *P(true positive) = P(false positive)*, which occurs when our algorithm
    does no better than random. In general, ROC curves fall somewhere in between,
    forming a convex shell above the diagonal. The deeper this shell, the better our
    algorithm.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Evaluation](img/image01217.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '(left) ROC curve for a model performing much better than random: the curve
    reaches very high true positive rates for a low false positive rate.'
  prefs: []
  type: TYPE_NORMAL
- en: (middle) ROC curve for a model performing significantly better than random.
  prefs: []
  type: TYPE_NORMAL
- en: '(right) ROC curve for a model performing only marginally better than random:
    the true positive rate is only marginally larger than the rate of false positives,
    for any given threshold, meaning that nearly half the examples are misclassified.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can calculate an array of points on the ROC curve using the `.roc` method
    on our `BinaryClassificationMetrics` instance. This returns an `RDD[(Double, Double)]`
    of (*false positive*, *true positive*) fractions for each threshold value. We
    can collect this as an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE578]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, an array of numbers is not very enlightening, so let''s plot the
    ROC curve with breeze-viz. We start by transforming our array of pairs into two
    arrays, one of false positives and one of true positives:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE579]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s plot these two arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE580]'
  prefs: []
  type: TYPE_PRE
- en: 'The ROC curve hits *1.0* for a small value of x: that is, we retrieve all true
    positives at the cost of relatively few false positives. To visualize the curve
    more accurately, it is instructive to limit the range on the *x*-axis from *0*
    to *0.1*.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE581]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to tell breeze-viz to use appropriate tick spacing, which requires
    going down to the JFreeChart layer underlying breeze-viz:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE582]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now save the graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE583]'
  prefs: []
  type: TYPE_PRE
- en: 'This produces the following graph, stored in `roc.png`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Evaluation](img/image01218.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: ROC curve for spam classification with logistic regression. Note that we have
    limited the false positive axis at 0.1
  prefs: []
  type: TYPE_NORMAL
- en: By looking at the graph, we see that we can filter out 85% of spam without a
    single **false positive**. Of course, we would need a larger test set to really
    validate this assumption.
  prefs: []
  type: TYPE_NORMAL
- en: 'A graph is useful to really understand the behavior of a model. Sometimes,
    however, we just want to have a single measure of the quality of a model. The
    area under the ROC curve can be a good such metric:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE584]'
  prefs: []
  type: TYPE_PRE
- en: 'This can be interpreted as follows: given any two messages randomly drawn from
    the test set, one of which is ham, and one of which is spam, there is a 99.8%
    probability that the model assigned a greater likelihood of spam to the spam message
    than to the ham message.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Other useful measures of model quality are the precision and recall for particular
    thresholds, or the F1 score. All of these are provided by the `BinaryClassificationMetrics`
    instance. The API documentation lists the methods available: [https://spark.apache.org/docs/latest/api/scala/index.html#org.apache.spark.mllib.evaluation.BinaryClassificationMetrics](https://spark.apache.org/docs/latest/api/scala/index.html#org.apache.spark.mllib.evaluation.BinaryClassificationMetrics).'
  prefs: []
  type: TYPE_NORMAL
- en: Regularization in logistic regression
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the dangers of machine learning is over-fitting: the algorithm captures
    not only the signal in the training set, but also the statistical noise that results
    from the finite size of the training set.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A way to mitigate over-fitting in logistic regression is to use regularization:
    we impose a penalty for large values of the parameters when optimizing. We can
    do this by adding a penalty to the cost function that is proportional to the magnitude
    of the parameters. Formally, we re-write the logistic regression cost function
    (described in [Chapter 2](part0018.xhtml#aid-H5A41 "Chapter 2. Manipulating Data
    with Breeze"), *Manipulating Data with Breeze*) as:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Regularization in logistic regression](img/image01219.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'where ![Regularization in logistic regression](img/image01220.jpeg) is the
    normal logistic regression cost function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Regularization in logistic regression](img/image01221.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, *params* is the vector of parameters, ![Regularization in logistic regression](img/image01222.jpeg)
    is the vector of features for the *i^(th)* training example, and ![Regularization
    in logistic regression](img/image01223.jpeg) is *1* if the *i* *th* training example
    is spam, and *0* otherwise. This is identical to the logistic regression cost-function
    introduced in [Chapter 2](part0018.xhtml#aid-H5A41 "Chapter 2. Manipulating Data
    with Breeze"), *Manipulating data with Breeze*, apart from the addition of the
    regularization term ![Regularization in logistic regression](img/image01224.jpeg),
    the ![Regularization in logistic regression](img/image01225.jpeg) norm of the
    parameter vector. The most common value of *n* is 2, in which case ![Regularization
    in logistic regression](img/image01226.jpeg) is just the magnitude of the parameter
    vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Regularization in logistic regression](img/image01227.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The additional regularization term drives the algorithm to reduce the magnitude
    of the parameter vector. When using regularization, features must all have comparable
    magnitude. This is commonly achieved by normalizing the features. The logistic
    regression estimator provided by MLlib normalizes all features by default. This
    can be turned off with the `setStandardization` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Spark has two hyperparameters that can be tweaked to control regularization:'
  prefs: []
  type: TYPE_NORMAL
- en: The type of regularization, set with the `elasticNetParam` parameter. A value
    of 0 indicates ![Regularization in logistic regression](img/image01228.jpeg) regularization.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The degree of regularization (![Regularization in logistic regression](img/image01229.jpeg)
    in the cost function), set with the `regParam` parameter. A high value of the
    regularization parameter indicates a strong regularization. In general, the greater
    the danger of over-fitting, the larger the regularization parameter ought to be.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s create a new logistic regression instance that uses regularization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE585]'
  prefs: []
  type: TYPE_PRE
- en: To choose the appropriate value of ![Regularization in logistic regression](img/image01229.jpeg),
    we fit the pipeline to the training set and calculate the classification error
    on the test set for several values of ![Regularization in logistic regression](img/image01229.jpeg).
    Further on in the chapter, we will learn about cross-validation in MLlib, which
    provides a much more rigorous way of choosing hyper-parameters.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE586]'
  prefs: []
  type: TYPE_PRE
- en: For our example, we see that any attempt to add L[2] regularization leads to
    a decrease in classification accuracy.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-validation and model selection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous example, we validated our approach by withholding 30% of the
    data when training, and testing on this subset. This approach is not particularly
    rigorous: the exact result changes depending on the random train-test split. Furthermore,
    if we wanted to test several different hyperparameters (or different models) to
    choose the best one, we would, unwittingly, choose the model that best reflects
    the specific rows in our test set, rather than the population as a whole.'
  prefs: []
  type: TYPE_NORMAL
- en: This can be overcome with *cross-validation*. We have already encountered cross-validation
    in [Chapter 4](part0036.xhtml#aid-12AK82 "Chapter 4. Parallel Collections and
    Futures"), *Parallel Collections and Futures*. In that chapter, we used random
    subsample cross-validation, where we created the train-test split randomly.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will use **k-fold cross-validation**: we split the training
    set into *k* parts (where, typically, *k* is *10* or *3*) and use *k-1* parts
    as the training set and the last as the test set. The train/test cycle is repeated
    *k* times, keeping a different part as test set each time.'
  prefs: []
  type: TYPE_NORMAL
- en: Cross-validation is commonly used to choose the best set of hyperparameters
    for a model. To illustrate choosing suitable hyperparameters, we will go back
    to our regularized logistic regression example. Instead of intuiting the hyper-parameters
    ourselves, we will choose the hyper-parameters that give us the best cross-validation
    score.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will explore setting both the regularization type (through `elasticNetParam`)
    and the degree of regularization (through `regParam`). A crude, but effective
    way to find good values of the parameters is to perform a grid search: we calculate
    the cross-validation score for every pair of values of the regularization parameters
    of interest.'
  prefs: []
  type: TYPE_NORMAL
- en: We can build a grid of parameters using MLlib's `ParamGridBuilder`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE587]'
  prefs: []
  type: TYPE_PRE
- en: 'To add hyper-parameters over which to optimize to the grid, we use the `addGrid`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE588]'
  prefs: []
  type: TYPE_PRE
- en: 'Once all the dimensions are added, we can just call the `build` method on the
    builder to build the grid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE589]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the grid is just a one-dimensional array of sets of parameters
    to pass to the logistic regression model prior to fitting.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step in setting up the cross-validation pipeline is to define a metric
    for comparing model performance. Earlier in the chapter, we saw how to use `BinaryClassificationMetrics`
    to estimate the quality of a model. Unfortunately, the `BinaryClassificationMetrics`
    class is part of the core MLLib API, rather than the new pipeline API, and is
    thus not (easily) compatible. The pipeline API offers a `BinaryClassificationEvaluator`
    class instead. This class works directly on DataFrames, and thus fits perfectly
    into the pipeline API flow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE590]'
  prefs: []
  type: TYPE_PRE
- en: 'From the parameter list, we see that the `BinaryClassificationEvaluator` class
    supports two metrics: the area under the ROC curve, and the area under the precision-recall
    curve. It expects, as input, a DataFrame containing a `label` column (the model
    truth) and a `rawPrediction` column (the column containing the probability that
    an e-mail is spam or ham).'
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have all the parameters we need to run cross-validation. We first build
    the pipeline, and then pass the pipeline, the evaluator and the array of parameters
    over which to run the cross-validation to an instance of `CrossValidator`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE591]'
  prefs: []
  type: TYPE_PRE
- en: 'We will now fit `crossval` to `trainDF`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE592]'
  prefs: []
  type: TYPE_PRE
- en: 'This step can take a fairly long time (over an hour on a single machine). This
    creates a transformer, `cvModel`, corresponding to the logistic regression object
    with the parameters that best represent `trainDF`. We can use it to predict the
    classification error on the test DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE593]'
  prefs: []
  type: TYPE_PRE
- en: 'Cross-validation has therefore resulted in a model that performs identically
    to the original, naive logistic regression model with no hyper-parameters. `cvModel`
    also contains a list of the evaluation score for each set of parameter in the
    parameter grid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE594]'
  prefs: []
  type: TYPE_PRE
- en: 'The easiest way to relate this to the hyper-parameters is to zip it with `cvModel.getEstimatorParamMaps`.
    This gives us a list of (*hyperparameter values*, *cross-validation score*) pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE595]'
  prefs: []
  type: TYPE_PRE
- en: The best set of hyper-parameters correspond to L[2] regularization with a regularization
    parameter of `1E-10`, though this only corresponds to a tiny improvement in AUC.
  prefs: []
  type: TYPE_NORMAL
- en: 'This completes our spam filter example. We have successfully trained a spam
    filter for this particular Ling-Spam dataset. To obtain better results, one could
    experiment with better feature extraction: we could remove stop words or use TF-IDF
    vectors, rather than just term frequency vectors as features, and we could add
    additional features like the length of messages, or even *n-grams*. We could also
    experiment with non-linear algorithms, such as random forest. All of these steps
    would be straightforward to add to the pipeline.'
  prefs: []
  type: TYPE_NORMAL
- en: Beyond logistic regression
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have concentrated on logistic regression in this chapter, but MLlib offers
    many alternative algorithms that will capture non-linearity in the data more effectively.
    The consistency of the pipeline API makes it easy to try out different algorithms
    and see how they perform. The pipeline API offers decision trees, random forest
    and gradient boosted trees for classification, as well as a simple feed-forward
    neural network, which is still experimental. It offers lasso and ridge regression
    and decision trees for regression, as well as PCA for dimensionality reduction.
  prefs: []
  type: TYPE_NORMAL
- en: The lower level MLlib API also offers principal component analysis for dimensionality
    reduction, several clustering methods including *k*-means and latent Dirichlet
    allocation and recommender systems using alternating least squares.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MLlib tackles the challenge of devising scalable machine learning algorithms
    head-on. In this chapter, we used it to train a simple scalable spam filter. MLlib
    is a vast, rapidly evolving library. The best way to learn more about what it
    can offer is to try and port code that you might have written using another library
    (such as scikit-learn).
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at how to build web APIs and interactive visualizations
    to share our results with the rest of the world.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The best reference is the online documentation, including:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The pipeline API: [http://spark.apache.org/docs/latest/ml-features.html](http://spark.apache.org/docs/latest/ml-features.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A full list of transformers: [http://spark.apache.org/docs/latest/mllib-guide.html#sparkml-high-level-apis-for-ml-pipelines](http://spark.apache.org/docs/latest/mllib-guide.html#sparkml-high-level-apis-for-ml-pipelines)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Advanced Analytics with Spark*, by *Sandy Ryza*, *Uri Laserson*, *Sean Owen*
    and *Josh Wills* provides a detailed and up-to-date introduction to machine learning
    with Spark.'
  prefs: []
  type: TYPE_NORMAL
- en: There are several books that introduce machine learning in more detail than
    we can here. We have mentioned *The Elements of Statistical Learning*, by *Friedman*,
    *Tibshirani* and *Hastie* several times in this book. It is one of the most complete
    introductions to the mathematical underpinnings of machine learning currently
    available.
  prefs: []
  type: TYPE_NORMAL
- en: Andrew Ng's Machine Learning course on [https://www.coursera.org/](https://www.coursera.org/)
    provides a good introduction to machine learning. It uses Octave/MATLAB as the
    programming language, but should be straightforward to adapt to Breeze and Scala.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 13. Web APIs with Play
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the first 12 chapters of this book, we introduced basic tools and libraries
    for anyone wanting to build data science applications: we learned how to interact
    with SQL and MongoDB databases, how to build fast batch processing applications
    using Spark, how to apply state-of-the-art machine learning algorithms using MLlib,
    and how to build modular concurrent applications in Akka.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the last chapters of this book, we will branch out to look at a web framework:
    *Play*. You might wonder why a web framework would feature in a data science book;
    surely such topics are best left to software engineers or web developers. Data
    scientists, however, rarely exist in a vacuum. They often need to communicate
    results or insights to stakeholders. As compelling as an ROC curve may be to someone
    well versed in statistics, it may not carry as much weight with less technical
    people. Indeed, it can be much easier to sell insights when they are accompanied
    by an engaging visualization.'
  prefs: []
  type: TYPE_NORMAL
- en: Many modern interactive data visualization applications are web applications
    running in a web browser. Often, these involve **D3.js**, a JavaScript library
    for building data-driven web pages. In this chapter and the next, we will look
    at integrating D3 with Scala.
  prefs: []
  type: TYPE_NORMAL
- en: 'Writing a web application is a complex endeavor. We will split this task over
    this chapter and the next. In this chapter, we will learn how to write a REST
    API that we can use as backend for our application, or query in its own right.
    In the next chapter, we will look at integrating front-end code with Play to query
    the API exposed by the backend and display it using D3\. We assume at least a
    basic familiarity with HTTP in this chapter: you should have read [Chapter 7](part0059.xhtml#aid-1O8H61
    "Chapter 7. Web APIs"), *Web APIs*, at least.'
  prefs: []
  type: TYPE_NORMAL
- en: Many data scientists or aspiring data scientists are unlikely to be familiar
    with the inner workings of web technologies. Learning how to build complex websites
    or web APIs can be daunting. This chapter therefore starts with a general discussion
    of dynamic websites and the architecture of web applications. If you are already
    familiar with server-side programming and with web frameworks, you can easily
    skip over the first few sections.
  prefs: []
  type: TYPE_NORMAL
- en: Client-server applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A website works through the interaction between two computers: the client and
    the server. If you enter the URL [www.github.com/pbugnion/s4ds/graphs](http://www.github.com/pbugnion/s4ds/graphs)
    in a web browser, your browser queries one of the GitHub servers. The server will
    look though its database for information concerning the repository that you are
    interested in. It will serve this information as HTML, CSS, and JavaScript to
    your computer. Your browser is then responsible for interpreting this response
    in the correct way.'
  prefs: []
  type: TYPE_NORMAL
- en: If you look at the URL in question, you will notice that there are several graphs
    on that page. Unplug your internet connection and you can still interact with
    the graphs. All the information necessary for interacting with the graphs was
    transferred, as JavaScript, when you loaded that webpage. When you play with the
    graphs, the CPU cycles necessary to make those changes happen are spent on *your*
    computer, not a GitHub server. The code is executed *client-side*. Conversely,
    when you request information about a new repository, that request is handled by
    a GitHub server. It is said to be handled *server-side*.
  prefs: []
  type: TYPE_NORMAL
- en: 'A web framework like Play can be used on the server. For client-side code,
    we can only use a language that the client browser will understand: HTML for the
    layout, CSS for the styling and JavaScript, or languages that can compile to JavaScript,
    for the logic.'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to web frameworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section is a brief introduction to how modern web applications are designed.
    Go ahead and skip it if you already feel comfortable writing backend code.
  prefs: []
  type: TYPE_NORMAL
- en: Loosely, a web framework is a set of tools and code libraries for building web
    applications. To understand what a web framework provides, let's take a step back
    and think about what you would need to do if you did not have one.
  prefs: []
  type: TYPE_NORMAL
- en: 'You want to write a program that listens on port 80 and sends HTML (or JSON
    or XML) back to clients that request it. This is simple if you are serving the
    same file back to every client: just load the HTML from file when you start the
    server, and send it to clients who request it.'
  prefs: []
  type: TYPE_NORMAL
- en: So far, so good. But what if you now want to customize the HTML based on the
    client request? You might choose to respond differently based on part of the URL
    that the client put in his browser, or based on specific elements in the HTTP
    request. For instance, the product page on [amazon.com](http://amazon.com) is
    different to the payment page. You need to write code to parse the URL and the
    request, and then route the request to the relevant handler.
  prefs: []
  type: TYPE_NORMAL
- en: You might now want to customize the HTML returned dynamically, based on specific
    elements of the request. The page for every product on [amazon.com](http://amazon.com)
    follows the same outline, but specific elements are different. It would be wasteful
    to store the entire HTML content for every product. A better way is to store the
    details for each product in a database and inject them into an HTML template when
    a client requests information on that product. You can do this with a *template
    processor*. Of course, writing a good template processor is difficult.
  prefs: []
  type: TYPE_NORMAL
- en: You might deploy your web framework and realize that it cannot handle the traffic
    directed to it. You decide that handlers responding to client requests should
    run asynchronously. You now have to deal with concurrency.
  prefs: []
  type: TYPE_NORMAL
- en: A web framework essentially provides the wires to bind everything together.
    Besides bundling an HTTP server, most frameworks will have a router that automatically
    routes a request, based on the URL, to the correct handler. In most cases, the
    handler will run asynchronously, giving you much better scalability. Many frameworks
    have a template processor that lets you write HTML (or sometimes JSON or XML)
    templates intuitively. Some web frameworks also provide functionality for accessing
    a database, for parsing JSON or XML, for formulating HTTP requests and for localization
    and internationalization.
  prefs: []
  type: TYPE_NORMAL
- en: Model-View-Controller architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Many web frameworks impose program architectures: it is difficult to provide
    wires to bind disparate components together without making some assumptions about
    what those components are. The **Model-View-Controller** (**MVC**) architecture
    is particularly popular on the Web, and it is the architecture the Play framework
    assumes. Let''s look at each component in turn:'
  prefs: []
  type: TYPE_NORMAL
- en: The model is the data underlying the application. For example, I expect the
    application underlying GitHub has models for users, repositories, organizations,
    pull requests and so on. In the Play framework, a model is often an instance of
    a case class. The core responsibility of the model is to remember the current
    state of the application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Views are representations of a model or a set of models on the screen.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The controller handles client interactions, possibly changing the model. For
    instance, if you *star* a project on GitHub, the controller will update the relevant
    models. Controllers normally carry very little application state: remembering
    things is the job of the models.![Model-View-Controller architecture](img/image01230.jpeg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'MVC architecture: the state of the application is provided by the model. The
    view provides a visual representation of the model to the user, and the controller
    handles logic: what to do when the user presses a button or submits a form.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The MVC framework works well because it decouples the user interface from the
    underlying data and structures the flow of actions: a controller can update the
    model state or the view, a model can send signals to the view to tell it to update,
    and the view merely displays that information. The model carries no information
    related to the user interface. This separation of concerns results in an easier
    mental model of information flow, better encapsulation and greater testability.'
  prefs: []
  type: TYPE_NORMAL
- en: Single page applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The client-server duality adds a degree of complication to the elegant MVC architecture.
    Where should the model reside? What about the controller? Traditionally, the model
    and the controller ran almost entirely on the server, which just pushed the relevant
    HTML view to the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'The growth in client-side JavaScript frameworks, such AngularJS, has resulted
    in a gradual shift to putting more code in the client. Both the controller and
    a temporary version of the model typically run client-side. The server just functions
    as a web API: if, for instance, the user updates the model, the controller will
    send an HTTP request to the server informing it of the change.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It then makes sense to think of the program running server-side and the one
    running client-side as two separate applications: the server persists data in
    databases, for instance, and provides a programmatic interface to this data, usually
    as a web service returning JSON or XML data. The client-side program maintains
    its own model and controller, and polls the server whenever it needs a new model,
    or whenever it needs to inform the server that the persistent view of the model
    should be changed.'
  prefs: []
  type: TYPE_NORMAL
- en: Taken to the extreme, this results in **Single-Page Applications**. In a single-page
    application, the first time the client requests a page from the server, he receives
    the HTML and the JavaScript necessary to build the framework for the entire application.
    If the client needs further data from the server, he will poll the server's API.
    This data is returned as JSON or XML.
  prefs: []
  type: TYPE_NORMAL
- en: 'This might seem a little complicated in the abstract, so let''s think how the
    Amazon website might be structured as a single-page application. We will just
    concern ourselves with the products page here, since that''s complicated enough.
    Let''s imagine that you are on the home page, and you hit a link for a particular
    product. The application running on your computer knows how to display products,
    for instance through an HTML template. The JavaScript also has a prototype for
    the model, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE596]'
  prefs: []
  type: TYPE_PRE
- en: 'What it''s currently missing is knowledge of what data to put in those fields
    for the product you have just selected: there is no way that information could
    have been sent to your computer when the website loaded, since there was no way
    to know what product you might click on (and sending information about every product
    would be prohibitively costly). So the Amazon client sends a request to the server
    for information on that product. The Amazon server replies with a JSON object
    (or maybe XML). The client then updates its model with that information. When
    the update is complete, an event is fired to update the view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Single page applications](img/image01231.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Client-server communications in a single-page application: when the client
    first accesses the website, it receives HTML, CSS and JavaScript files that contain
    the entire logic for the application. From then on, the client only uses the server
    as an API when it requests additional data. The application running in the user''s
    web browser and the one running on the server are nearly independent. The only
    coupling is through the structure of the API exposed by the server.'
  prefs: []
  type: TYPE_NORMAL
- en: Building an application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter and the next, we will build a single-page application that
    relies on an API written in Play. We will build a webpage that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building an application](img/image01232.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The user enters the name of someone on GitHub and can view a list of their repositories
    and a chart summarizing what language they use. You can find the application deployed
    at `app.scala4datascience.com`. Go ahead and give it a whirl.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get a glimpse of the innards, type `app.scala4datascience.com/api/repos/odersky`.
    This returns a JSON object like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE597]'
  prefs: []
  type: TYPE_PRE
- en: We will build the API in this chapter, and write the front-end code in the next
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The Play framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Play framework is a web framework built on top of Akka. It has a proven
    track record in industry, and is thus a reliable choice for building scalable
    web applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Play is an *opinionated* web framework: it expects you to follow the MVC architecture,
    and it has a strong opinion about the tools you should be using. It comes bundled
    with its own JSON and XML parsers, with its own tools for accessing external APIs,
    and with recommendations for how to access databases.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Web applications are much more complex than the command line scripts we have
    been developing in this book, because there are many more components: the backend
    code, routing information, HTML templates, JavaScript files, images, and so on.
    The Play framework makes strong assumptions about the directory structure for
    your project. Building that structure from scratch is both mind-numbingly boring
    and easy to get wrong. Fortunately, we can use **Typesafe activators** to bootstrap
    the project (you can also download the code from the Git repository in [https://github.com/pbugnion/s4ds](https://github.com/pbugnion/s4ds)
    but I encourage you to start the project from a basic activator structure and
    code along instead, using the finished version as an example).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Typesafe activator is a custom version of SBT that includes templates to get
    Scala programmers up and running quickly. To install activator, you can either
    download a JAR from [https://www.typesafe.com/activator/download](https://www.typesafe.com/activator/download),
    or, on Mac OS, via homebrew:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE598]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then launch the activator console from the terminal. If you downloaded
    activator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE599]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, if you installed via Homebrew:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE600]'
  prefs: []
  type: TYPE_PRE
- en: This starts a new project in the current directory. It starts by asking what
    template you want to start with. Choose `play-scala`. It then asks for a name
    for your application. I chose `ghub-display`, but go ahead and be creative!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explore the newly created project structure (I have only retained the
    most important files):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE601]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run the app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE602]'
  prefs: []
  type: TYPE_PRE
- en: Head over to your browser and navigate to the URL `127.0.0.1:9000/`. The page
    may take a few seconds to load. Once it is loaded, you should see a default page
    that says **Your application is ready**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we modify anything, let''s walk through how this happens. When you ask
    your browser to take you to `127.0.0.1:9000/`, your browser sends an HTTP request
    to the server listening at that address (in this case, the Netty server bundled
    with Play). The request is a GET request for the route `/`. The Play framework
    looks in `conf/routes` to see if it has a route satisfying `/`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE603]'
  prefs: []
  type: TYPE_PRE
- en: 'We see that the `conf/routes` file does contain the route `/` for GET requests.
    The second part of that line, `controllers.Application.index`, is the name of
    a Scala function to handle that route (more on that in a moment). Let''s experiment.
    Change the route end-point to `/hello`. Refresh your browser without changing
    the URL. This will trigger recompilation of the application. You should now see
    an error page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Play framework](img/image01233.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The error page tells you that the app does not have an action for the route
    `/` any more. If you navigate to `127.0.0.1:9000/hello`, you should see the landing
    page again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides learning a little of how routing works, we have also learned two things
    about developing Play applications:'
  prefs: []
  type: TYPE_NORMAL
- en: In development mode, code gets recompiled when you refresh your browser and
    there have been code changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compilation and runtime errors get propagated to the web page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's change the route back to `/`. There is a lot more to say on routing, but
    it can wait till we start building our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `conf/routes` file tells the Play framework to use the method `controllers.Application.index`
    to handle requests to `/`. Let''s look at the `Application.scala` file in `app/controllers`,
    where the `index` method is defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE604]'
  prefs: []
  type: TYPE_PRE
- en: 'We see that `controllers.Application.index` refers to the method `index` in
    the class `Application`. This method has return type `Action`. An `Action` is
    just a function that maps HTTP requests to responses. Before explaining this in
    more detail, let''s change the action to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE605]'
  prefs: []
  type: TYPE_PRE
- en: Refresh your browser and you should see the landing page replaced with `"hello
    world"`. By having our action return `Ok("hello, world")`, we are asking Play
    to return an HTTP response with status code 200 (indicating that the request was
    successful) and the body `"hello world"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go back to the original content of `index`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE606]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that this calls the method `views.html.index`. This might appear
    strange, because there is no `views` package anywhere. However, if you look at
    the `app/views` directory, you will notice two files: `index.scala.html` and `main.scala.html`.
    These are templates, which, at compile time, get transformed into Scala functions.
    Let''s have a look at `main.scala.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE607]'
  prefs: []
  type: TYPE_PRE
- en: 'At compile time, this template is compiled to a function `main(title:String)(content:Html)`
    in the package `views.html`. Notice that the function package and name comes from
    the template file name, and the function arguments come from the first line of
    the template. The template contains embedded `@title` and `@content` values, which
    get filled in by the arguments to the function. Let''s experiment with this in
    a Scala console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE608]'
  prefs: []
  type: TYPE_PRE
- en: We can call `views.html.main`, just like we would call a normal Scala function.
    The arguments we pass in get embedded in the correct place, as defined by the
    template in `views/main.scala.html`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This concludes our introductory tour of Play. Let''s briefly go over what we
    have learnt: when a request reaches the Play server, the server reads the URL
    and the HTTP verb and checks that these exist in its `conf/routes` file. It will
    then pass the request to the `Action` defined by the controller for that route.
    This `Action` returns an HTTP response that gets fed back to the browser. In constructing
    the response, the `Action` may make use of a template, which, as far as it is
    concerned is just a function `(arguments list) => String` or `(arguments list)
    => HTML`.'
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic routing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Routing, as we saw, is the mapping of HTTP requests to Scala handlers. Routes
    are stored in `conf/routes`. A route is defined by an HTTP verb, followed by the
    end-point, followed by a Scala function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE609]'
  prefs: []
  type: TYPE_PRE
- en: 'We learnt to add new routes by just adding lines to the `routes` file. We are
    not limited to static routes, however. The Play framework lets us include wild
    cards in routes. The value of the wild card can be passed as an argument to the
    controller. To see how this works, let''s create a controller that takes the name
    of a person as argument. In the `Application` object in `app.controllers`, add:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE610]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now define a route handled by this controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE611]'
  prefs: []
  type: TYPE_PRE
- en: If you now point your browser to `127.0.0.1:9000/hello/Jim`, you will see **hello,
    Jim** appear on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Any string between `:` and the following `/` is treated as a wild card: it
    will match any combination of characters. The value of the wild card can be passed
    to the controller. Note that the wild card can appear anywhere in the URL, and
    there can be more than one wild card. The following are all valid route definitions,
    for instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE612]'
  prefs: []
  type: TYPE_PRE
- en: 'There are many other options for selecting routes and passing arguments to
    the controller. Consult the documentation for the Play framework for a full discussion
    on the routing possibilities: [https://www.playframework.com/documentation/2.4.x/ScalaRouting](https://www.playframework.com/documentation/2.4.x/ScalaRouting).'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**URL design**'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is generally considered best practice to leave the URL as simple as possible.
    The URL should reflect the hierarchical structure of the information of the website,
    rather than the underlying implementation. GitHub is a very good example of this:
    its URLs make intuitive sense. For instance, the URL for the repository for this
    book is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/pbugnion/s4ds](https://github.com/pbugnion/s4ds)'
  prefs: []
  type: TYPE_NORMAL
- en: To access the issues page for that repository, add `/issues` to the route. To
    access the first issue, add `/1` to that route. These are called **semantic URLs**
    ([https://en.wikipedia.org/wiki/Semantic_URL](https://en.wikipedia.org/wiki/Semantic_URL)).
  prefs: []
  type: TYPE_NORMAL
- en: Actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have talked about routes, and how to pass parameters to controllers. Let's
    now talk about what we can do with the controller.
  prefs: []
  type: TYPE_NORMAL
- en: The method defined in the route must return a `play.api.mvc.Action` instance.
    The `Action` type is a thin wrapper around the type `Request[A] => Result`, where
    `Request[A]` identifies an HTTP request and `Result` is an HTTP response.
  prefs: []
  type: TYPE_NORMAL
- en: Composing the response
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An HTTP response, as we saw in [Chapter 7](part0059.xhtml#aid-1O8H61 "Chapter 7. Web
    APIs"), *Web APIs*, is composed of:'
  prefs: []
  type: TYPE_NORMAL
- en: the status code (such as 200 for a successful response, or 404 for a missing
    page)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the response headers, a key-value list indicating metadata related to the response
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The response body. This can be HTML for web pages, or JSON, XML or plain text
    (or many other formats). This is generally the bit that we are really interested
    in.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Play framework defines a `play.api.mvc.Result` object that symbolizes a
    response. The object contains a `header` attribute with the status code and the
    headers, and a `body` attribute containing the body.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest way to generate a `Result` is to use one of the factory methods
    in `play.api.mvc.Results`. We have already seen the `Ok` method, which generates
    a response with status code 200:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE613]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a step back and open a Scala console so we can understand how this
    works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE614]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see how the `Results.Ok(...)` creates a `Result` object with status
    `200` and (in this case), a single header denoting the content type. The body
    is a bit more complicated: it is an enumerator that can be pushed onto the output
    stream when needed. The enumerator contains the argument passed to `Ok`: `"hello,
    world"`, in this case.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many factory methods in `Results` for returning different status
    codes. Some of the more relevant ones are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Action { Results.NotFound }`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Action { Results.BadRequest("bad request") }`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Action { Results.InternalServerError("error") }`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Action { Results.Forbidden }`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Action { Results.Redirect("/home") }`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a full list of `Result` factories, consult the API documentation for Results
    ([https://www.playframework.com/documentation/2.4.x/api/scala/index.html#play.api.mvc.Results](https://www.playframework.com/documentation/2.4.x/api/scala/index.html#play.api.mvc.Results)).
  prefs: []
  type: TYPE_NORMAL
- en: 'We have, so far, been limiting ourselves to passing strings as the content
    of the `Ok` result: `Ok("hello, world")`. We are not, however, limited to passing
    strings. We can pass a JSON object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE615]'
  prefs: []
  type: TYPE_PRE
- en: 'We will cover interacting with JSON in more detail when we start building the
    API. We can also pass HTML as the content. This is most commonly the case when
    returning a view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE616]'
  prefs: []
  type: TYPE_PRE
- en: Note how the `Content-Type` header is set based on the type of content passed
    to `Ok`. The `Ok` factory uses the `Writeable` type class to convert its argument
    to the body of the response. Thus, any content type for which a `Writeable` type
    class exists can be used as argument to `Ok`. If you are unfamiliar with type
    classes, you might want to read the *Looser coupling with type classes* section
    in [Chapter 5](part0040.xhtml#aid-164MG1 "Chapter 5. Scala and SQL through JDBC"),
    *Scala and SQL through JDBC*.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding and parsing the request
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We now know how to formulate (basic) responses. The other half of the equation
    is the HTTP request. Recall that an `Action` is just a function mapping `Request
    => Result`. We can access the request using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE617]'
  prefs: []
  type: TYPE_PRE
- en: 'One of the reasons for needing a reference to the request is to access parameters
    in the query string. Let''s modify the `Hello, <name>` example that we wrote earlier
    to, optionally, include a title in the query string. Thus, a URL could be formatted
    as `/hello/Jim?title=Dr`. The `request` instance exposes the `getQueryString`
    method for accessing specific keys in the query string. This method returns `Some[String]`
    if the key is present in the query, or `None` otherwise. We can re-write our `hello`
    controller as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE618]'
  prefs: []
  type: TYPE_PRE
- en: Try this out by accessing the URL `127.0.0.1:9000/hello/Odersky?title=Dr` in
    your browser. The browser should display `Hello, Dr Odersky`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have, so far, been concentrating on GET requests. These do not have a body.
    Other types of HTTP request, most commonly POST requests, do contain a body. Play
    lets the user pass *body parsers* when defining the action. The request body will
    be passed through the body parser, which will convert it from a byte stream to
    a Scala type. As a very simple example, let''s define a new route that accepts
    POST requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE619]'
  prefs: []
  type: TYPE_PRE
- en: 'We will apply the predefined `parse.text` body parser to the incoming request
    body. This converts the body of the request to a string. The `helloPost` controller
    looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE620]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You cannot test POST requests easily in the browser. You can use cURL instead.
    cURL is a command line utility for dispatching HTTP requests. It is installed
    by default on Mac OS and should be available via the package manager on Linux
    distributions. The following will send a POST request with `"I think that Scala
    is great"` in the body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE621]'
  prefs: []
  type: TYPE_PRE
- en: 'This prints the following line to the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Hello. You told me: I think that Scala is great`'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several types of built-in body parsers:'
  prefs: []
  type: TYPE_NORMAL
- en: '`parse.file(new File("filename.txt"))` will save the body to a file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`parse.json` will parse the body as JSON (we will learn more about interacting
    with JSON in the next section).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`parse.xml` will parse the body as XML.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`parse.urlFormEncoded` will parse the body as returned by submitting an HTML
    form. The `request.body` attribute is a Scala map from `String` to `Seq[String]`,
    mapping each form element to its value(s).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For a full list of body parsers, the best source is the Scala API documentation
    for `play.api.mvc.BodyParsers.parse` available at: [https://www.playframework.com/documentation/2.5.x/api/scala/index.html#play.api.mvc.BodyParsers$parse$](https://www.playframework.com/documentation/2.5.x/api/scala/index.html#play.api.mvc.BodyParsers%24parse%24).'
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with JSON
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JSON, as we discovered in previous chapters, is becoming the de-facto language
    for communicating structured data over HTTP. If you develop a web application
    or a web API, it is likely that you will have to consume or emit JSON, or both.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 7](part0059.xhtml#aid-1O8H61 "Chapter 7. Web APIs"), *Web APIs*,
    we learned how to parse JSON through `json4s`. The Play framework includes its
    own JSON parser and emitter. Fortunately, it behaves in much the same way as `json4s`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's imagine that we are building an API that summarizes information about
    GitHub repositories. Our API will emit a JSON array listing a user's repositories
    when queried about a specific user (much like the GitHub API, but with just a
    subset of fields).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by defining a model for the repository. In Play applications,
    models are normally stored in the folder `app/models`, in the `models` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE622]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add a route to our application that serves arrays of repos for a particular
    user. In `conf/routes`, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE623]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now implement the framework for the controller. We will create a new
    controller for our API, imaginatively called `Api`. For now, we will just have
    the controller return dummy data. This is what the code looks like (we will explain
    the details shortly):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE624]'
  prefs: []
  type: TYPE_PRE
- en: 'If you point your web browser to `127.0.0.1:9000/api/repos/odersky`, you should
    now see the following JSON object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE625]'
  prefs: []
  type: TYPE_PRE
- en: The only tricky part of this code is the conversion from `Repo` to JSON. We
    call `Json.toJson` on `data`, an instance of type `List[Repo]`. The `toJson` method
    relies on the existence of a type class `Writes[T]` for the type `T` passed to
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Play framework makes extensive use of type classes to define how to convert
    models to specific formats. Recall that we learnt how to write type classes in
    the context of SQL and MongoDB. The Play framework''s expectations are very similar:
    for the `Json.toJson` method to work on an instance of type `Repo`, there must
    be a `Writes[Repo]` implementation available that specifies how to transform `Repo`
    objects to JSON.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Play framework, the `Writes[T]` type class defines a single method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE626]'
  prefs: []
  type: TYPE_PRE
- en: '`Writes` methods for built-in simple types and for collections are already
    built into the Play framework, so we do not need to worry about defining `Writes[Boolean]`,
    for instance.'
  prefs: []
  type: TYPE_NORMAL
- en: The `Writes[Repo]` instance is commonly defined either directly in the controller,
    if it is just used for that controller, or in the `Repo` companion object, where
    it can be used across several controllers. For simplicity, we just embedded it
    in the controller.
  prefs: []
  type: TYPE_NORMAL
- en: Note how type-classes allow for separation of concerns. The model just defines
    the `Repo` type, without attaching any behavior. The `Writes[Repo]` type class
    just knows how to convert from a `Repo` instance to JSON, but knows nothing of
    the context in which it is used. Finally, the controller just knows how to create
    a JSON HTTP response.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations, you have just defined a web API that returns JSON! In the next
    section, we will learn how to fetch data from the GitHub web API to avoid constantly
    returning the same array.
  prefs: []
  type: TYPE_NORMAL
- en: Querying external APIs and consuming JSON
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have learnt how to provide the user with a dummy JSON array of repositories
    in response to a request to `/api/repos/:username`. In this section, we will replace
    the dummy data with the user's actual repositories, dowloaded from GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 7](part0059.xhtml#aid-1O8H61 "Chapter 7. Web APIs"), *Web APIs*,
    we learned how to query the GitHub API using Scala's `Source.fromURL` method and
    `scalaj-http`. It should come as no surprise that the Play framework implements
    its own library for interacting with external web services.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s edit the `Api` controller to fetch information about a user''s repositories
    from GitHub, rather than using dummy data. When called with a username as argument,
    the controller will:'
  prefs: []
  type: TYPE_NORMAL
- en: Send a GET request to the GitHub API for that user's repositories.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Interpret the response, converting the body from a JSON object to a `List[Repo]`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Convert from the `List[Repo]` to a JSON array, forming the response.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We start by giving the full code listing before explaining the thornier parts
    in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE627]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have written all this, point your browser to, for instance, `127.0.0.1:9000/api/repos/odersky`
    to see the list of repositories owned by Martin Odersky:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE628]'
  prefs: []
  type: TYPE_PRE
- en: This code sample is a lot to take in, so let's break it down.
  prefs: []
  type: TYPE_NORMAL
- en: Calling external web services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first step in querying external APIs is to import the `WS` object, which
    defines factory methods for creating HTTP requests. These factory methods rely
    on a reference to an implicit Play application in the namespace. The easiest way
    to ensure this is the case is to import `play.api.Play.current`, a reference to
    the current application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s ignore the `readsRepoFromGithub` type class for now and jump straight
    to the controller body. The URL that we want to hit with a GET request is `"https://api.github.com/users/$username/repos"`,
    with the appropriate value for `$username`. We create a GET request with `WS.url(url).get()`.
    We can also add headers to an existing request. For instance, to specify the content
    type, we could have written:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE629]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use headers to pass a GitHub OAuth token using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE630]'
  prefs: []
  type: TYPE_PRE
- en: To formulate a POST request, rather than a GET request, replace the final `.get()`
    with `.post(data)`. Here, `data` can be JSON, XML or a string.
  prefs: []
  type: TYPE_NORMAL
- en: Adding `.get` or `.post` fires the request, returning a `Future[WSResponse]`.
    You should, by now, be familiar with futures. By writing `response.map { r =>
    ... }`, we specify a transformation to be executed on the future result, when
    it returns. The transformation verifies the response's status, returning `NotFound`
    if the status code of the response is anything but 200.
  prefs: []
  type: TYPE_NORMAL
- en: Parsing JSON
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If the status code is 200, the callback parses the response body to JSON and
    converts the parsed JSON to a `List[Repo]` instance. We already know how to convert
    from a `Repo` object to JSON using the `Writes[Repo]` type class. The converse,
    going from JSON to a `Repo` object, is a little more challenging, because we have
    to account for incorrectly formatted JSON. To this effect, the Play framework
    provides the `.validate[T]` method on JSON objects. This method tries to convert
    the JSON to an instance of type `T`, returning `JsSuccess` if the JSON is well-formatted,
    or `JsError` otherwise (similar to Scala''s `Try` object). The `.validate` method
    relies on the existence of a type class `Reads[Repo]`. Let''s experiment with
    a Scala console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE631]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `Json.parse` converts a string to an instance of `JsValue`, the super-type
    for JSON instances. We can access specific fields in `parsedJson` using XPath-like
    syntax (if you are not familiar with XPath-like syntax, you might want to read
    [Chapter 6](part0051.xhtml#aid-1GKCM2 "Chapter 6. Slick – A Functional Interface
    for SQL"), *Slick – A Functional Interface for SQL*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE632]'
  prefs: []
  type: TYPE_PRE
- en: 'XPath-like lookups return an instance with type `JsLookupResult`. This takes
    two values: either `JsDefined`, if the path is valid, or `JsUndefined` if it is
    not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE633]'
  prefs: []
  type: TYPE_PRE
- en: 'To go from a `JsLookupResult` instance to a String in a type-safe way, we can
    use the `.validate[String]` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE634]'
  prefs: []
  type: TYPE_PRE
- en: 'The `.validate[T]` method returns either `JsSuccess` if the `JsDefined` instance
    could be successfully cast to `T`, or `JsError` otherwise. To illustrate the latter,
    let''s try validating this as an `Int`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE635]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling `.validate` on an instance of type `JsUndefined` also returns in a
    `JsError`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE636]'
  prefs: []
  type: TYPE_PRE
- en: 'To convert from an instance of `JsResult[T]` to an instance of type `T`, we
    can use pattern matching:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE637]'
  prefs: []
  type: TYPE_PRE
- en: We can now use `.validate` to cast JSON to simple types in a type-safe manner.
    But, in the code example, we used `.validate[Repo]`. This works provided a `Reads[Repo]`
    type class is implicitly available in the namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most common way of defining `Reads[T]` type classes is through a DSL provided
    in `import play.api.libs.functional.syntax._`. The DSL works by chaining operations
    returning either `JsSuccess` or `JsError` together. Discussing exactly how this
    DSL works is outside the scope of this chapter (see, for instance, the Play framework
    documentation page on JSON combinators: [https://www.playframework.com/documentation/2.4.x/ScalaJsonCombinators](https://www.playframework.com/documentation/2.4.x/ScalaJsonCombinators)).
    We will stick to discussing the syntax.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE638]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Reads` type class is defined in two stages. The first chains together
    `read[T]` methods with `and`, combining successes and errors. The second uses
    the apply method of the companion object of a case class (or `Tuple` instance)
    to construct the object, provided the first stage completed successfully. Now
    that we have defined the type class, we can call `validate[Repo]` on a `JsValue`
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE639]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then use pattern matching to extract the `Repo` object from the `JsSuccess`
    instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE640]'
  prefs: []
  type: TYPE_PRE
- en: We have, so far, only talked about validating single repos. The Play framework
    defines type classes for collection types, so, provided `Reads[Repo]` is defined,
    `Reads[List[Repo]]` will also be defined.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand how to extract Scala objects from JSON, let's get back
    to the code. If we manage to successfully convert the repositories to a `List[Repo]`,
    we emit it again as JSON. Of course, converting from GitHub's JSON representation
    of a repository to a Scala object, and from that Scala object directly to our
    JSON representation of the object, might seem convoluted. However, if this were
    a real application, we would have additional logic. We could, for instance, store
    repos in a cache, and try and fetch from that cache instead of querying the GitHub
    API. Converting from JSON to Scala objects as early as possible decouples the
    code that we write from the way GitHub returns repositories.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous actions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last bit of the code sample that is new is the call to `Action.async`, rather
    than just `Action`. Recall that an `Action` instance is a thin wrapper around
    a `Request => Result` method. Our code, however, returns a `Future[Result]`, rather
    than a `Result`. When that is the case, use the `Action.async` to construct the
    action, rather than `Action` directly. Using `Action.async` tells the Play framework
    that the code creating the `Action` is asynchronous.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating APIs with Play: a summary'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the last section, we deployed an API that responds to GET requests. Since
    this is a lot to take in, let''s summarize how to go about API creation:'
  prefs: []
  type: TYPE_NORMAL
- en: Define appropriate routes in `/conf/routes`, using wildcards in the URL as needed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create Scala case classes in `/app/models` to represent the models used by the
    API.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create `Write[T]` methods to write models to JSON or XML so that they can be
    returned by the API.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bind the routes to controllers. If the controllers need to do more than a trivial
    amount a work, wrap the work in a future to avoid blocking the server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There are many more useful components of the Play framework that you are likely
    to need, such as, for instance, how to use Slick to access SQL databases. We do
    not, unfortunately, have time to cover these in this introduction. The Play framework
    has extensive, well-written documentation that will fill the gaping holes in this
    tutorial.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rest APIs: best practice'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As the Internet matures, REST (representational state transfer) APIs are emerging
    as the most reliable design pattern for web APIs. An API is described as *RESTful*
    if it follows these guiding principles:'
  prefs: []
  type: TYPE_NORMAL
- en: The API is designed as a set of resources. For instance, the GitHub API provides
    information about users, repositories, followers, etc. Each user, or repository,
    is a specific resource. Each resource can be addressed through a different HTTP
    end-point.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The URLs should be simple and should identify the resource clearly. For instance,
    `api.github.com/users/odersky` is simple and tells us clearly that we should expect
    information about the user Martin Odersky.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is no *world resource* that contains all the information about the system.
    Instead, top-level resources contain links to more specialized resources. For
    instance, the user resource in the GitHub API contains links to that user's repositories
    and that user's followers, rather than having all that information embedded in
    the user resource directly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The API should be discoverable. The response to a request for a specific resource
    should contain URLs for related resources. When you query the user resource on
    GitHub, the response contains the URL for accessing that user's followers, repositories
    etc. The client should use the URLs provided by the API, rather than attempting
    to construct them client-side. This makes the client less brittle to changes in
    the API.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There should be as little state maintained on the server as possible. For instance,
    when querying the GitHub API, we must pass the authentication token with every
    request, rather than expecting our authentication status to be *remembered* on
    the server. Having each interaction be independent of the history provides much
    better scalability: if any interaction can be handled by any server, load balancing
    is much easier.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we introduced the Play framework as a tool for building web
    APIs. We built an API that returns a JSON array of a user's GitHub repositories.
    In the next chapter, we will build on this API and construct a single-page application
    to represent this data graphically.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This Wikipedia page gives information on semantic URLs: [https://en.wikipedia.org/wiki/Semantic_URL](https://en.wikipedia.org/wiki/Semantic_URL)
    and [http://apiux.com/2013/04/03/url-design-restful-web-services/](http://apiux.com/2013/04/03/url-design-restful-web-services/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a much more in depth discussion of the Play framework, I suggest *Play Framework
    Essentials* by *Julien Richard-Foy*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*REST in Practice: Hypermedia and Systems Architecture*, by *Jim Webber*, *Savas
    Parastatidis* and *Ian Robinson* describes how to architect REST APIs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chapter 14. Visualization with D3 and the Play Framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned about the Play framework, a web framework
    for Scala. We built an API that returns a JSON array describing a user's GitHub
    repositories.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will construct a fully-fledged web application that displays
    a table and a chart describing a user's repositories. We will learn to integrate
    **D3.js**, a JavaScript library for building data-driven web pages, with the Play
    framework. This will set you on the path to building compelling interactive visualizations
    that showcase results obtained with machine learning.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter assumes that you are familiar with HTML, CSS, and JavaScript. We
    present references at the end of the chapter. You should also have read the previous
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: GitHub user data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will build a single-page application that uses, as its backend, the API
    developed in the previous chapter. The application contains a form where the user
    enters the login name for a GitHub account. The application queries the API to
    get a list of repositories for that user and displays them on the screen as both
    a table and a pie chart summarizing programming language use for that user:'
  prefs: []
  type: TYPE_NORMAL
- en: '![GitHub user data](img/image01234.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: To see a live version of the application, head over to [http://app.scala4datascience.com](http://app.scala4datascience.com).
  prefs: []
  type: TYPE_NORMAL
- en: Do I need a backend?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we learned about the client-server model that underpins
    how the internet works: when you enter a website URL in your browser, the server
    serves HTML, CSS, and JavaScript to your browser, which then renders it in the
    appropriate manner.'
  prefs: []
  type: TYPE_NORMAL
- en: What does this all mean for you? Arguably the second question that you should
    be asking yourself when building a web application is whether you need to do any
    server-side processing (right after "is this really going to be worth the effort?").
    Could you just create an HTML web-page with some JavaScript?
  prefs: []
  type: TYPE_NORMAL
- en: 'You can get away without a backend if the data needed to build the whole application
    is small enough: typically a few megabytes. If your application is larger, you
    will need a backend to transfer just the data the client currently needs. Surprisingly,
    you can often build visualizations without a backend: while data science is accustomed
    to dealing with terabytes of data, the goal of the data science process is often
    condensing these huge data sets to a few meaningful numbers.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Having a backend also lets you include logic invisible to the client. If you
    need to validate a password, you clearly cannot send the code to do that to the
    client computer: it needs to happen out of sight, on the server.'
  prefs: []
  type: TYPE_NORMAL
- en: If your application is small enough and you do not need to do any server-side
    processing, stop reading this chapter, brush up on your JavaScript if you have
    to, and forget about Scala for now. Not having to worry about building a backend
    will make your life easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Clearly, however, we do not have that freedom for the application that we want
    to build: the user could enter the name of anyone on GitHub. Finding information
    about that user requires a backend with access to tremendous storage and querying
    capacity (which we simulate by just forwarding the request to the GitHub API and
    re-interpreting the response).'
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript dependencies through web-jars
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the challenges of developing web applications is that we are writing
    two quasi-separate programs: the server-side program and the client-side program.
    These generally require different technologies. In particular, for any but the
    most trivial application, we must keep track of JavaScript libraries, and integrate
    processing the JavaScript code (for instance, for minification) in the build process.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Play framework manages JavaScript dependencies through *web-jars*. These
    are just JavaScript libraries packaged as jars. They are deployed on Maven Central,
    which means that we can just add them as dependencies to our `build.sbt` file.
    For this application, we will need the following JavaScript libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: Require.js, a library for writing modular JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JQuery
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bootstrap
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Underscore.js, a library that adds many functional constructs and client-side
    templating.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: D3, the graph plotting library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NVD3, a graph library built on top of D3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you are planning on coding up the examples provided in this chapter, the
    easiest will be for you to start from the code for the previous chapter (You can
    download the code for [Chapter 13](part0125.xhtml#aid-3N6MA1 "Chapter 13. Web
    APIs with Play"), *Web APIs with Play*, from GitHub: [https://github.com/pbugnion/s4ds/tree/master/chap13](https://github.com/pbugnion/s4ds/tree/master/chap13)).
    We will assume this as a starting point here onwards.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s include the dependencies on the web-jars in the `build.sbt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE641]'
  prefs: []
  type: TYPE_PRE
- en: Fetch the modules by running `activator` `update`. Once you have done this,
    you will notice the JavaScript libraries in `target/web/public/main/lib`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Towards a web application: HTML templates'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we briefly saw how to construct HTML templates by interleaving
    Scala snippets in an HTML file. We saw that templates are compiled to Scala functions,
    and we learned how to call these functions from the controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In single-page applications, the majority of the logic governing what is actually
    displayed in the browser resides in the client-side JavaScript, not in the server.
    The pages served by the server contain the bare-bones HTML framework.
  prefs: []
  type: TYPE_NORMAL
- en: Let's create the HTML layout for our application. We will save this in `views/index.scala.html`.
    The template will just contain the layout for the application, but will not contain
    any information about any user's repositories. To fetch that information, the
    application will have to query the API developed in the previous chapter. The
    template does not take any parameters, since all the dynamic HTML generation will
    happen client-side.
  prefs: []
  type: TYPE_NORMAL
- en: We use the Bootstrap grid layout to control the HTML layout. If you are not
    familiar with Bootstrap layouts, consult the documentation at [http://getbootstrap.com/css/#grid-example-basic](http://getbootstrap.com/css/#grid-example-basic).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE642]'
  prefs: []
  type: TYPE_PRE
- en: In the HTML head, we link the CSS stylesheets that we need for the application.
    Instead of specifying the path explicitly, we use the `@routes.Assets.versioned(...)`
    function. This resolves to a URI corresponding to the location where the assets
    are stored post-compilation. The argument passed to the function should be the
    path from `target/web/public/main` to the asset you need.
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to serve the compiled version of this view when the user accesses the
    route `/` on our server. We therefore need to add this route to `conf/routes`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE643]'
  prefs: []
  type: TYPE_PRE
- en: 'The route is served by the `index` function in the `Application` controller.
    All this controller needs to do is serve the `index` view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE644]'
  prefs: []
  type: TYPE_PRE
- en: Start the Play framework by running `activator run` in the root directory of
    the application and point your web browser to `127.0.0.1:9000/`. You should see
    the framework for our web application. Of course, the application does not do
    anything yet, since we have not written any of the JavaScript logic yet.
  prefs: []
  type: TYPE_NORMAL
- en: '![Towards a web application: HTML templates](img/image01235.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Modular JavaScript through RequireJS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The simplest way of injecting JavaScript libraries into the namespace is to
    add them to the HTML framework via `<script>...</script>` tags in the HTML header.
    For instance, to add JQuery, we would add the following line to the head of the
    document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE645]'
  prefs: []
  type: TYPE_PRE
- en: While this works, it does not scale well to large applications, since every
    library gets imported into the global namespace. Modern client-side JavaScript
    frameworks such as AngularJS provide an alternative way of defining and loading
    modules that preserve encapsulation.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use RequireJS. In a nutshell, RequireJS lets us encapsulate JavaScript
    modules through functions. For instance, if we wanted to write a module `example`
    that contains a function for hiding a `div`, we would define the module as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE646]'
  prefs: []
  type: TYPE_PRE
- en: 'We encapsulate our module as a callback in a function called `define`. The
    `define` function takes two arguments: a list of dependencies, and a function
    definition. The `define` function binds the dependencies to the arguments list
    of the callback: in this case, functions in JQuery will be bound to `$` and functions
    in Underscore will be bound to `_`. This creates a module which exposes whatever
    the callback function returns. In this case, we export the `hide` function, binding
    it to the name `"hide"`. Our example module thus exposes the `hide` function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To load this module, we pass it as a dependency to the module in which we want
    to use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE647]'
  prefs: []
  type: TYPE_PRE
- en: Notice how the functions in `example` are encapsulated, rather than existing
    in the global namespace. We call them through `example.<function-name>`. Furthermore,
    any functions or variables defined internally to the `example` module remain private.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, we want JavaScript code to exist outside of modules. This is often
    the case for the script that bootstraps the application. For these, replace `define`
    with `require`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE648]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have an overview of RequireJS, how do we use it in the Play framework?
    The first step is to add the dependency on the RequireJS web jar, which we have
    done. The Play framework also adds a RequireJS SBT plugin ([https://github.com/sbt/sbt-rjs](https://github.com/sbt/sbt-rjs)),
    which should be installed by default if you used the `play-scala` activator. If
    this is missing, it can be added with the following line in `plugins.sbt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE649]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to add the plugin to the list of stages. This allows the plugin
    to manipulate the JavaScript assets when packaging the application as a jar. Add
    the following line to `build.sbt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE650]'
  prefs: []
  type: TYPE_PRE
- en: You will need to restart the activator for the changes to take effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are now ready to use RequireJS in our application. We can use it by adding
    the following line in the head section of our view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE651]'
  prefs: []
  type: TYPE_PRE
- en: 'When the view is compiled, this is resolved to tags like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE652]'
  prefs: []
  type: TYPE_PRE
- en: The argument passed to `data-main` is the entry point for our application. When
    RequireJS loads, it will execute `main.js`. That script must therefore bootstrap
    our application. In particular, it should contain a configuration object for RequireJS,
    to make it aware of where all the libraries are.
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrapping the applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we linked `require.js` to our application, we told it to use `main.js`
    as our entry point. To test that this works, let''s start by entering a dummy
    `main.js`. JavaScript files in Play applications go in `/public/javascripts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE653]'
  prefs: []
  type: TYPE_PRE
- en: To verify that this worked, head to `127.0.0.1:9000` and open the browser console.
    You should see `"hello, JavaScript"` in the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now write a more useful `main.js`. We will start by configuring RequireJS,
    giving it the location of modules we will use in our application. Unfortunately,
    NVD3, the graph library that we use, does not play very well with RequireJS so
    we have to use an ugly hack to make it work. This complicates our `main.js` file
    somewhat:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE654]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have the configuration in place, we can dig into the JavaScript
    part of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Client-side program architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The basic idea is simple: the user searches for the name of someone on GitHub
    in the input box. When he enters a name, we fire a request to the API designed
    earlier in this chapter. When the response from the API returns, the program binds
    that response to a model and emits an event notifying that the model has been
    changed. The views listen for this event and refresh from the model in response.'
  prefs: []
  type: TYPE_NORMAL
- en: Designing the model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's start by defining the client-side model. The model holds information regarding
    the repos of the user currently displayed. It gets filled in after the first search.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE655]'
  prefs: []
  type: TYPE_PRE
- en: 'To see a populated value of the model, head to the complete application example
    on `app.scala4datascience.com`, open a JavaScript console in your browser, search
    for a user (for example, `odersky`) in the application and type the following
    in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE656]'
  prefs: []
  type: TYPE_PRE
- en: These import the `"model"` module, bind it to the variable `model`, and then
    print information to the console.
  prefs: []
  type: TYPE_NORMAL
- en: The event bus
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need a mechanism for informing the views when the model is updated, since
    the views need to refresh from the new model. This is commonly handled through
    *events* in web applications. JQuery lets us bind callbacks to specific events.
    The callback is executed when that event occurs.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, to bind a callback to the event `"custom-event"`, enter the following
    in a JavaScript console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE657]'
  prefs: []
  type: TYPE_PRE
- en: 'We can fire the event using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE658]'
  prefs: []
  type: TYPE_PRE
- en: 'Events in JQuery require an *event* bus, a DOM element on which the event is
    registered. In this case, we used the `window` DOM element as our event bus, but
    any JQuery element would have served. Centralizing event definitions to a single
    module is helpful. We will, therefore, create an `events` module containing two
    functions: `trigger`, which triggers an event (specified by a string) and `on`,
    which binds a callback to a specific event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE659]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now emit and receive events using the `events` module. You can test
    this out in a JavaScript console on the live version of the application (at `app.scala4datascience.com`).
    Let''s start by registering a listener:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE660]'
  prefs: []
  type: TYPE_PRE
- en: 'If we now trigger the event `"hello_event"`, the listener prints `"Received
    event"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE661]'
  prefs: []
  type: TYPE_PRE
- en: Using events allows us to decouple the controller from the views. The controller
    does not need to know anything about the views, and vice-versa. The controller
    just needs to emit a `"model_updated"` event when the model is updated, and the
    views need to refresh from the model when they receive that event.
  prefs: []
  type: TYPE_NORMAL
- en: AJAX calls through JQuery
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can now write the controller for our application. When the user enters a
    name in the text input, we query the API, update the model and trigger a `model_updated`
    event.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use JQuery''s `$.getJSON` function to query our API. This function takes
    a URL as its first argument, and a callback as its second argument. The API call
    is asynchronous: `$.getJSON` returns immediately after execution. All request
    processing must, therefore, be done in the callback. The callback is called if
    the request is successful, but we can define additional handlers that are always
    called, or called on failure. Let''s try this out in the browser console (either
    your own, if you are running the API developed in the previous chapter, or on
    `app.scala4datascience.com`). Recall that the API is listening to the end-point
    `/api/repos/:user`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE662]'
  prefs: []
  type: TYPE_PRE
- en: '`getJSON` returns immediately. A few tenths of a second later, the API responds,
    at which point the response gets fed through the callback.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The callback only gets executed on success. It takes, as its argument, the
    JSON object returned by the API. To bind a callback that is executed when the
    API request fails, call the `.fail` method on the return value of `getJSON`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE663]'
  prefs: []
  type: TYPE_PRE
- en: We can also use the `.always` method on the return value of `getJSON` to specify
    a callback that is executed, whether the API query was successful or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we know how to use `$.getJSON` to query our API, we can write the
    controller. The controller listens for changes to the `#user-selection` input
    field. When a change occurs, it fires an AJAX request to the API for information
    on that user. It binds a callback which updates the model when the API replies
    with a list of repositories. We will define a `controller` module that exports
    a single function, `initialize`, that creates the event listeners:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE664]'
  prefs: []
  type: TYPE_PRE
- en: 'Our controller module just exposes the `initialize` method. Once the initialization
    is performed, the controller interacts with the rest of the application through
    event listeners. We will call the controller''s `initialize` method in `main.js`.
    Currently, the last lines of that file are just an empty `require` block. Let''s
    import our controller and initialize it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE665]'
  prefs: []
  type: TYPE_PRE
- en: 'To test that this works, we can bind a dummy listener to the `"model_updated"`
    event. For instance, we could log the current model to the browser JavaScript
    console with the following snippet (which you can write directly in the JavaScript
    console):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE666]'
  prefs: []
  type: TYPE_PRE
- en: If you then search for a user, the model will be printed to the console. We
    now have the controller in place. The last step is writing the views.
  prefs: []
  type: TYPE_NORMAL
- en: Response views
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If the request fails, we just display **Not found** in the response div. This
    part is the easiest to code up, so let''s do that first. We define an `initialize`
    method that generates the view. The view then listens for the `"model_updated"`
    event, which is fired by the controller after it updates the model. Once the initialization
    is complete, the only way to interact with the response view is through `"model_updated"`
    events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE667]'
  prefs: []
  type: TYPE_PRE
- en: 'To bootstrap the view, we must call the initialize function from `main.js`.
    Just add a dependency on `responseView` in the require block, and call `responseView.initialize()`.
    With these modifications, the final `require` block in `main.js` is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE668]'
  prefs: []
  type: TYPE_PRE
- en: You can check that this all works by entering junk in the user input to deliberately
    cause the API request to fail.
  prefs: []
  type: TYPE_NORMAL
- en: When the user enters a valid GitHub login name and the API returns a list of
    repos, we must display those on the screen. We display a table and a pie chart
    that aggregates the repository sizes by language. We will define the pie chart
    and the table in two separate modules, called `repoGraph.js` and `repoTable.js`.
    Let's assume those exist for now and that they expose a `build` method that accepts
    a `model` and the name of a `div` in which to appear.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s update the code for `responseView` to accommodate the user entering
    a valid GitHub user name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE669]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s walk through what happens in the event of a successful API call. We
    inject the following bit of HTML in the `#response` div:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE670]'
  prefs: []
  type: TYPE_PRE
- en: This adds two HTML divs, one for the table of repositories, and the other for
    the graph. We use Bootstrap classes to split the response div vertically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now turn our attention to the table view, which needs to expose a single
    `build` method, as described in the previous section. We will just display the
    repositories in an HTML table. We will use *Underscore templates* to build the
    table dynamically. Underscore templates work much like string interpolation in
    Scala: we define a template with placeholders. Let''s try this in a browser console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE671]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a `myTemplate` function which accepts an object with attributes
    `title` and `name`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE672]'
  prefs: []
  type: TYPE_PRE
- en: 'Underscore templates thus provide a convenient mechanism for formatting an
    object as a string. We will create a template for each row in our table, and pass
    the model for each repository to the template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE673]'
  prefs: []
  type: TYPE_PRE
- en: Drawing plots with NVD3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: D3 is a library that offers low-level components for building interactive visualizations
    in JavaScript. By offering the low-level components, it gives a huge degree of
    flexibility to the developer. The learning curve can, however, be quite steep.
    In this example, we will use NVD3, a library which provides pre-made graphs for
    D3\. This can greatly speed up initial development. We will place the code in
    the file `repoGraph.js` and expose a single method, `build`, which takes, as arguments,
    a model and a div and draws a pie chart in that div. The pie chart will aggregate
    language use across all the user's repositories.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for generating a pie chart is nearly identical to the example given
    in the NVD3 documentation, available at [http://nvd3.org/examples/pie.html](http://nvd3.org/examples/pie.html).
    The data passed to the graph must be available as an array of objects. Each object
    must contain a `label` field and a `size` field. The `label` field identifies
    the language, and the `size` field is the total size of all the repositories for
    that user written in that language. The following would be a valid data array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE674]'
  prefs: []
  type: TYPE_PRE
- en: 'To get the data in this format, we must aggregate sizes across the repositories
    written in a particular language in our model. We write the `generateDataFromModel`
    function to transform the `repos` array in the model to an array suitable for
    NVD3\. The crux of the aggregation is performed by a call to Underscore''s `groupBy`
    method, to group repositories by language. This method works exactly like Scala''s
    `groupBy` method. With this in mind, the `generateDataFromModel` function is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE675]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now build the pie chart, using NVD3''s `addGraph` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE676]'
  prefs: []
  type: TYPE_PRE
- en: This was the last component of our application. Point your browser to `127.0.0.1:9000`
    and you should see the application running.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! We have built a fully-functioning single-page web application.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to write a fully-featured web application with
    the Play framework. Congratulations on making it this far. Building web applications
    are likely to push many data scientists beyond their comfort zone, but knowing
    enough about the web to build basic applications will allow you to share your
    results in a compelling, engaging manner, as well as facilitate communications
    with software engineers and web developers.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our whistle stop tour of Scala libraries. Over the course of
    this book, we have learned how to tackle linear algebra and optimization problems
    efficiently using Breeze, how to insert and query data in SQL databases in a functional
    manner, and both how to interact with web APIs and how to create them. We have
    reviewed some of tools available to the data scientist for writing concurrent
    or parallel applications, from parallel collections and futures to Spark via Akka.
    We have seen how pervasive these constructs are in Scala libraries, from futures
    in the Play framework to Akka as the backbone of Spark. If you have read this
    far, pat yourself on the back.
  prefs: []
  type: TYPE_NORMAL
- en: This books gives you the briefest of introduction to the libraries it covers,
    hopefully just enough to give you a taste of what each tool is good for, what
    you could accomplish with it, and how it fits in the wider Scala ecosystem. If
    you decide to use any of these in your data science pipeline, you will need to
    read the documentation in more detail, or a more complete reference book. The
    references listed at the end of each chapter should provide a good starting point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Both Scala and data science are evolving rapidly. Do not stay wedded to a particular
    toolkit or concept. Remain on top of current developments and, above all, remain
    pragmatic: find the right tool for the right job. Scala and the libraries discussed
    here will often be that tool, but not always: sometimes, a shell command or a
    short Python script will be more effective. Remember also that programming skills
    are but one aspect of the data scientist''s body of knowledge. Even if you want
    to specialize in the engineering side of data science, learn about the problem
    domain and the mathematical underpinnings of machine learning.'
  prefs: []
  type: TYPE_NORMAL
- en: Most importantly, if you have taken the time to read this book, it is likely
    that you view programming and data science as more than a day job. Coding in Scala
    can be satisfying and rewarding, so have fun and be awesome!
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are thousands of HTML and CSS tutorials dotted around the web. A simple
    Google search will give you a much better idea of the resources available than
    any list of references I can provide.
  prefs: []
  type: TYPE_NORMAL
- en: 'Mike Bostock''s website has a wealth of beautiful D3 visualizations: [http://bost.ocks.org/mike/.](http://bost.ocks.org/mike/.)
    To understand a bit more about D3, I recommend *Scott Murray''s Interactive Data
    Visualization for the Web*.'
  prefs: []
  type: TYPE_NORMAL
- en: You may also wish to consult the references given in the previous chapter for
    reference books on the Play framework and designing REST APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Appendix A. Pattern Matching and Extractors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pattern matching is a powerful tool for control flow in Scala. It is often underused
    and under-estimated by people coming to Scala from imperative languages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with a few examples of pattern matching before diving into the
    theory. We start by defining a tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE677]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use pattern matching to extract the elements of this tuple and bind
    them to variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE678]'
  prefs: []
  type: TYPE_PRE
- en: 'We just extracted the two elements of the `names` tuple, binding them to the
    variables `firstName` and `lastName`. Notice how the left-hand side defines a
    pattern that the right-hand side must match: we are declaring that the variable
    `names` must be a two-element tuple. To make the pattern more specific, we could
    also have specified the expected types of the elements in the tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE679]'
  prefs: []
  type: TYPE_PRE
- en: What happens if the pattern on the left-hand side does not match the right-hand
    side?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE680]'
  prefs: []
  type: TYPE_PRE
- en: This results in a compile error. Other types of pattern matching failures result
    in runtime errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pattern matching is very expressive. To achieve the same behavior without pattern
    matching, you would have to do the following explicitly:'
  prefs: []
  type: TYPE_NORMAL
- en: Verify that the variable `names` is a two-element tuple
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extract the first element and bind it to `firstName`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extract the second element and bind it to `lastName`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we expect certain elements in the tuple to have specific values, we can
    verify this as part of the pattern match. For instance, we can verify that the
    first element of the `names` tuple matches `"Pascal"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE681]'
  prefs: []
  type: TYPE_PRE
- en: 'Besides tuples, we can also match on Scala collections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE682]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the similarity between this pattern matching and array construction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE683]'
  prefs: []
  type: TYPE_PRE
- en: Syntactically, Scala expresses pattern matching as the reverse process to instance
    construction. We can think of pattern matching as the deconstruction of an object,
    binding the object's constituent parts to variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'When matching against collections, one is sometimes only interested in matching
    the first element, or the first few elements, and discarding the rest of the collection,
    whatever its length. The operator `_*` will match against any number of elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE684]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, the part of the pattern matched by the `_*` operator is not bound
    to a variable. We can capture it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE685]'
  prefs: []
  type: TYPE_PRE
- en: 'Besides tuples and collections, we can also match against case classes. Let''s
    start by defining a case representing a name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE686]'
  prefs: []
  type: TYPE_PRE
- en: 'We can match against instances of `Name` in much the same way we matched against
    tuples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE687]'
  prefs: []
  type: TYPE_PRE
- en: 'All these patterns can also be used in `match` statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE688]'
  prefs: []
  type: TYPE_PRE
- en: Pattern matching in for comprehensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Pattern matching is useful in *for* comprehensions for extracting items from
    a collection that match a specific pattern. Let''s build a collection of `Name`
    instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE689]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use pattern matching to extract the internals of the class in a for-comprehension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE690]'
  prefs: []
  type: TYPE_PRE
- en: So far, nothing terribly ground-breaking. But what if we wanted to extract the
    surname of everyone whose first name is `"Martin"`?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE691]'
  prefs: []
  type: TYPE_PRE
- en: Writing `Name("Martin", last) <- names` extracts the elements of names that
    match the pattern. You might think that this is a contrived example, and it is,
    but the examples in [Chapter 7](part0059.xhtml#aid-1O8H61 "Chapter 7. Web APIs"),
    *Web APIs* demonstrate the usefulness and versatility of this language pattern,
    for instance, for extracting specific fields from JSON objects.
  prefs: []
  type: TYPE_NORMAL
- en: Pattern matching internals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you define a case class, as we saw with `Name`, you get pattern matching
    against the constructor *for free*. You should be using case classes to represent
    your data as much as possible, thus reducing the need to implement your own pattern
    matching. It is nevertheless useful to understand how pattern matching works.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you create a case class, Scala automatically builds a companion object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE692]'
  prefs: []
  type: TYPE_PRE
- en: The method used (internally) for pattern matching is `unapply`. This method
    takes, as argument, an object and returns `Option[T],` where `T` is a tuple of
    the values of the case class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE693]'
  prefs: []
  type: TYPE_PRE
- en: 'The `unapply` method is an *extractor*. It plays the opposite role of the constructor:
    it takes an object and extracts the list of parameters needed to construct that
    object. When you write `val Name(firstName, lastName)`, or when you use `Name`
    as a case in a match statement, Scala calls `Name.unapply` on what you are matching
    against. A value of `Some[(String, String)]` implies a pattern match, while a
    value of `None` implies that the pattern fails.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To write custom extractors, you just need an object with an `unapply` method.
    While `unapply` normally resides in the companion object of a class that you are
    deconstructing, this need not be the case. In fact, it does not need to correspond
    to an existing class at all. For instance, let''s define a `NonZeroDouble` extractor
    that matches any non-zero double:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE694]'
  prefs: []
  type: TYPE_PRE
- en: We defined an extractor for `NonZeroDouble`, despite the absence of a corresponding
    `NonZeroDouble` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'This `NonZeroDouble` extractor would be useful in a match object. For instance,
    let''s define a `safeDivision` function that returns a default value when the
    denominator is zero:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE695]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a trivial example because the `NonZeroDouble.unapply` method is so
    simple, but you can hopefully see the usefulness and expressiveness, if we were
    to define a more complex test. Defining custom extractors lets you define powerful
    control flow constructs to leverage `match` statements. More importantly, they
    enable the client using the extractors to think about control flow declaratively:
    the client can declare that they need a `NonZeroDouble`, rather than instructing
    the compiler to check whether the value is zero.'
  prefs: []
  type: TYPE_NORMAL
- en: Extracting sequences
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The previous section explains extraction from case classes, and how to write
    custom extractors, but it does not explain how extraction works on sequences:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE696]'
  prefs: []
  type: TYPE_PRE
- en: 'Rather than relying on an `unapply` method, sequences rely on an `unapplySeq`
    method defined in the companion object. This is expected to return an `Option[Seq[A]]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE697]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s write an example. We will write an extractor for Breeze vectors (which
    do not currently support pattern matching). To avoid clashing with the `DenseVector`
    companion object, we will write our `unapplySeq` in a separate object, called
    `DV`. All our `unapplySeq` method needs to do is convert its argument to a Scala
    `Vector` instance. To avoid muddying the concepts with generics, we will write
    this implementation for `[Double]` vectors only:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE698]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s try our new extractor implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE699]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Pattern matching is a powerful tool for control flow. It encourages the programmer
    to think declaratively: declare that you expect a variable to match a certain
    pattern, rather than explicitly tell the computer how to check that it matches
    this pattern. This can save many lines of code and enhance clarity.'
  prefs: []
  type: TYPE_NORMAL
- en: Reference
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For an overview of pattern matching in Scala, there is no better reference
    than *Programming in Scala*, by *Martin Odersky*, *Bill Venners*, and *Lex Spoon*.
    An online version of the first edition is available at: [https://www.artima.com/pins1ed/case-classes-and-pattern-matching.html](https://www.artima.com/pins1ed/case-classes-and-pattern-matching.html).'
  prefs: []
  type: TYPE_NORMAL
- en: '*Daniel Westheide''s* blog covers slightly more advanced Scala constructs,
    and is a very useful read: [http://danielwestheide.com/blog/2012/11/21/the-neophytes-guide-to-scala-part-1-extractors.html](http://danielwestheide.com/blog/2012/11/21/the-neophytes-guide-to-scala-part-1-extractors.html).'
  prefs: []
  type: TYPE_NORMAL
