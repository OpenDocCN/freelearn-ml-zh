- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Finding Patterns – Market Basket Analysis Using Association Rules
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 寻找模式 - 使用关联规则进行篮子分析
- en: Think back to your last impulse purchase. Maybe in the grocery store checkout
    lane, you bought a pack of chewing gum or a candy bar. Perhaps on a late-night
    trip for diapers and formula, you picked up a caffeinated beverage or a six-pack
    of beer. You might have even bought this book on a bookseller’s recommendation.
    These impulse buys are no coincidence, as retailers use sophisticated data analysis
    techniques to identify useful patterns for marketing promotions and driving upselling
    via product placement.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 想想你上一次的冲动购买。也许在杂货店的结账通道，你买了一包口香糖或一块巧克力棒。也许在深夜为尿布和配方奶粉的购物之旅中，你买了一瓶含咖啡因的饮料或一箱啤酒。你甚至可能是在书店推荐下买了这本书。这些冲动购买并非巧合，因为零售商使用复杂的数据分析技术来识别用于营销促销和通过产品定位推动交叉销售的有用模式。
- en: In years past, such recommendations were based on the subjective intuition of
    marketing professionals and inventory managers. Now, barcode scanners, inventory
    databases, and online shopping carts all generate transactional data that machine
    learning can use to learn purchasing patterns. The practice is commonly known
    as market basket analysis because it has been so frequently applied to supermarket
    data.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，这样的推荐基于市场营销专业人士和库存管理人员的直观直觉。现在，条形码扫描仪、库存数据库和在线购物车都生成交易数据，机器学习可以使用这些数据来学习购买模式。这种做法通常被称为篮子分析，因为它已经被频繁应用于超市数据。
- en: 'Although the technique originated with shopping data, it is also useful in
    other contexts. By the time you finish this chapter, you will know how to apply
    market basket analysis techniques to your own tasks, whatever they may be. Generally,
    the work involves:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这项技术起源于购物数据，但它也适用于其他环境。在你完成这一章的时候，你将知道如何将篮子分析技术应用于你自己的任务，无论它们是什么。通常，这项工作涉及：
- en: Understanding the peculiarities of transactional data
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解交易数据的特殊性
- en: Using simple performance measures to find associations in large databases
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用简单的性能指标在大数据库中寻找关联
- en: Knowing how to identify useful and actionable patterns
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 知道如何识别有用和可操作的规律
- en: Because market basket analysis is able to discover nuggets of insight in many
    types of large datasets, as we apply the technique, you are likely to identify
    applications to your work even if you have no affiliation with the retail sector.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 由于篮子分析能够发现许多类型的大型数据集中的洞察力，当我们应用这项技术时，你可能会发现你的工作中也有应用，即使你没有与零售行业有联系。
- en: Understanding association rules
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解关联规则
- en: 'The building blocks of a market basket analysis are the items that may appear
    in any given transaction. Groups of one or more items are surrounded by brackets
    to indicate that they form a set, or more specifically, an **itemset** that appears
    in the data with some regularity. Transactions are specified in terms of itemsets,
    such as the following transaction that might be found in a typical grocery store:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 篮子分析的基础是可能出现在任何给定交易中的项目。一组或多个项目被括号包围，以表示它们形成一个集合，或者更具体地说，是一个在数据中出现频率较高的**项目集**。交易是以项目集来指定的，如下面在典型杂货店可能找到的交易：
- en: '`{bread, peanut butter, jelly}`'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`{面包, 花生酱, 果酱}`'
- en: 'The result of a market basket analysis is a collection of **association rules**
    that specify patterns found in the relationships among items in the itemsets.
    Association rules are always composed from subsets of itemsets and are denoted
    by relating one itemset on the **left-hand side** (**LHS**) of the rule to another
    itemset on the **right-hand side** (**RHS**) of the rule. The LHS is the condition
    that needs to be met in order to trigger the rule, and the RHS is the expected
    result of meeting that condition. A rule identified from the preceding example
    transaction might be expressed in the form:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 篮子分析的结果是一系列**关联规则**，这些规则指定了在项目集项目之间的关系中发现的模式。关联规则总是由项目集的子集组成，并通过将规则的一侧的**左侧（LHS**）与另一侧的**右侧（RHS**）关联来表示。LHS
    是触发规则需要满足的条件，而 RHS 是满足该条件后的预期结果。从前面的示例交易中识别出的规则可能以以下形式表示：
- en: '`{peanut butter, jelly} → {bread}`'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`{花生酱, 果酱} → {面包}`'
- en: In plain language, this association rule states that if peanut butter and jelly
    are purchased together, then bread is also likely to be purchased. In other words,
    “peanut butter and jelly imply bread.”
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 用简单的话来说，这个关联规则表明，如果花生酱和果酱一起购买，那么面包也很可能被购买。换句话说，“花生酱和果酱意味着面包。”
- en: Developed in the context of retail transaction databases, association rules
    are not used for prediction, but rather for unsupervised knowledge discovery in
    large databases. This is unlike the classification and numeric prediction algorithms
    presented in previous chapters. Even so, you will find that the result of association
    rule learning is closely related to and shares many features with the result of
    classification rule learning as presented in *Chapter 5*, *Divide and Conquer
    – Classification Using Decision Trees and Rules*.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在零售交易数据库的背景下开发，关联规则不用于预测，而是用于在大数据库中进行无监督的知识发现。这与前几章中介绍的分类和数值预测算法不同。即便如此，你会发现关联规则学习的结果与第5章中介绍的分类规则学习的结果密切相关，并共享许多特征，即*“分而治之
    – 使用决策树和规则进行分类”*。
- en: Because association rule learners are unsupervised, there is no need for the
    algorithm to be trained and the data does not need to be labeled ahead of time.
    The program is simply unleashed on a dataset in the hope that interesting associations
    are found. The downside, of course, is that there isn’t an easy way to objectively
    measure the performance of a rule learner, aside from evaluating it for qualitative
    usefulness—typically, an eyeball test of some sort.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 由于关联规则学习器是无监督的，因此不需要对算法进行训练，数据也不需要在事先进行标记。程序只是简单地应用于数据集，希望找到有趣的相关性。当然，缺点是没有简单的方法可以客观地衡量规则学习器的性能，除了评估其定性有用性——通常，是一种某种形式的目视检查。
- en: 'Although association rules are most often used for market basket analysis,
    they are helpful for finding patterns in many different types of data. Other potential
    applications include:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管关联规则最常用于篮子分析，但它们对于在许多不同类型的数据中寻找模式很有帮助。其他潜在的应用包括：
- en: Searching for interesting and frequently occurring patterns of DNA and protein
    sequences in cancer data
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在癌症数据中寻找有趣的DNA和蛋白质序列模式
- en: Finding patterns of purchases or medical claims that occur in combination with
    fraudulent credit card or insurance use
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寻找与欺诈性信用卡或保险使用相结合的购买或医疗索赔模式
- en: Identifying combinations of behavior that precede customers dropping their cellular
    phone service or upgrading their cable television package
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别出导致客户放弃手机服务或升级有线电视套餐的行为组合
- en: Association rule analysis is used to search for interesting connections among
    a very large number of elements. Human beings are capable of such insight quite
    intuitively, but it often takes expert-level knowledge or a great deal of experience
    to do what a rule learning algorithm can do in minutes or even seconds. Additionally,
    some datasets are simply too large and complex for a human being to find the needle
    in the haystack.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 关联规则分析用于在大量元素中寻找有趣的相关性。人类能够相当直观地做到这一点，但通常需要专家级知识或大量的经验才能在几分钟或几秒钟内完成规则学习算法所能做到的事情。此外，有些数据集太大、太复杂，以至于人类难以在“大海捞针”中找到所需的信息。
- en: The Apriori algorithm for association rule learning
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关联规则学习的Apriori算法
- en: Just as large transactional datasets create challenges for humans, these datasets
    also present challenges for machines. Transactional datasets can be large in both
    the number of transactions as well as the number of items or features that are
    recorded. The fundamental problem of searching for interesting itemsets is that
    the number of potential itemsets grows exponentially with the number of items.
    Given *k* items that can appear or not appear in a set, there are *2*^k possible
    itemsets that could be potential rules. A retailer that sells only 100 different
    items could have on the order of *2^100 = 1.27e+30* itemsets that an algorithm
    must evaluate—a seemingly impossible task.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 正如大型交易数据集给人类带来挑战一样，这些数据集也给机器带来了挑战。交易数据集在交易数量以及记录的项目或特征数量上都可以很大。搜索有趣的项目集的基本问题在于，潜在的项目集数量随着项目数量的指数增长。给定可以出现在集合中或不出现在集合中的*k*个项目，有*2*^k种可能的项目集，这些项目集可能是潜在的规则。一个只销售100种不同商品的零售商可能需要评估大约*2^100
    = 1.27e+30*个项目集——这看起来是一项看似不可能的任务。
- en: Rather than evaluating each of these itemsets one by one, a smarter rule learning
    algorithm takes advantage of the fact that many of the potential combinations
    of items are rarely, if ever, found in practice. For instance, even if a store
    sells both automotive items and food products, a set of *{motor oil, bananas}*
    is likely to be extraordinarily uncommon. By ignoring these rare (and perhaps
    less important) combinations, it is possible to limit the scope of the search
    for rules to a more manageable size.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是逐个评估这些项集，一个更智能的规则学习算法利用了这样一个事实：在实际情况中，许多潜在的项目组合很少甚至从未被发现。例如，即使一家商店同时销售汽车用品和食品产品，集合*{机油，香蕉}*可能非常罕见。通过忽略这些罕见（也许不那么重要）的组合，可以将搜索规则的范围限制在更易于管理的规模。
- en: Much work has been done to identify heuristic algorithms for reducing the number
    of itemsets to search. Perhaps the most widely-known approach for efficiently
    searching large databases for rules is known as **Apriori**. Introduced in 1994
    by Rakesh Agrawal and Ramakrishnan Srikant, the Apriori algorithm has since become
    somewhat synonymous with association rule learning, despite the invention of newer
    and faster algorithms. The name is derived from the fact that the algorithm utilizes
    a simple prior (that is, *a priori*) belief about the properties of frequent itemsets.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 已做了大量工作来识别用于减少搜索项集数量的启发式算法。也许最广为人知的用于高效搜索大型数据库规则的算法被称为**Apriori**。该算法由Rakesh
    Agrawal和Ramakrishnan Srikant于1994年提出，尽管后来发明了更新、更快的算法，但Apriori算法仍然与关联规则学习有些同义。该名称来源于算法利用关于频繁项集属性的一种简单先验（即*先验*）信念。
- en: 'Before we discuss that in more depth, it’s worth noting that this algorithm,
    like all learning algorithms, is not without its strengths and weaknesses. Some
    of these are listed as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们更深入地讨论这一点之前，值得注意的是，这个算法，像所有学习算法一样，并非没有其优点和缺点。以下列出了一些：
- en: '| **Strengths** | **Weaknesses** |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| **优点** | **缺点** |'
- en: '|'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Capable of working with large amounts of transactional data
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够处理大量交易数据
- en: Results in rules that are easy to understand
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成易于理解的规则
- en: Useful for data mining and discovering unexpected knowledge in databases
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适用于数据挖掘和发现数据库中的意外知识
- en: '|'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Not very helpful for relatively small datasets
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于相对较小的数据集不太有帮助
- en: Takes effort to separate true insight from common sense
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要努力区分真正的洞察力和常识
- en: Easy to draw spurious conclusions from random patterns
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容易从随机模式中得出错误的结论
- en: '|'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'As noted earlier, the Apriori algorithm employs a simple *a priori* belief
    as a guideline for reducing the association rule search space: all subsets of
    a frequent itemset must also be frequent. This heuristic is known as the **Apriori
    property**. Using this astute observation, it is possible to dramatically limit
    the number of rules to search. For example, the set *{motor oil, bananas}* can
    only be frequent if both *{motor oil}* and *{bananas}* occur frequently as well.
    Consequently, if either *{motor oil}* or *{bananas}* are infrequent, then any
    set containing these items can be excluded from the search.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Apriori算法采用一种简单的*先验*信念作为减少关联规则搜索空间的指导原则：频繁项集的所有子集也必须是频繁的。这种启发式方法被称为**Apriori属性**。利用这一精明的观察，可以显著减少需要搜索的规则数量。例如，集合*{机油，香蕉}*只有在*{机油}*和*{香蕉}*都频繁出现的情况下才能是频繁的。因此，如果*{机油}*或*{香蕉}*不频繁，那么包含这些项目的任何集合都可以从搜索中排除。
- en: For additional details on the Apriori algorithm, refer to *Fast Algorithms for
    Mining Association Rules, Agrawal, R., Srikant, R., Proceedings of the 20th International
    Conference on Very Large Databases, 1994, pp. 487-499*.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Apriori算法的更多详细信息，请参阅*Agrawal, R., Srikant, R.，《快速挖掘关联规则算法》，第20届国际非常大型数据库会议论文集，1994年，第487-499页*。
- en: 'To see how this principle can be applied in a more realistic setting, let’s
    consider a simple transaction database. The following table shows five completed
    transactions at an imaginary hospital’s gift shop:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到这一原则如何在更现实的设置中应用，让我们考虑一个简单的交易数据库。以下表格显示了在一个虚构医院礼品店中完成的五个交易：
- en: '![](img/B17290_08_01.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17290_08_01.png)'
- en: 'Figure 8.1: Itemsets representing five transactions in a hypothetical hospital’s
    gift shop'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1：表示假设医院礼品店中五个交易的项集
- en: By looking at the sets of purchases, one can infer that there are a couple of
    typical buying patterns. A person visiting a sick friend or family member tends
    to buy a get-well card and flowers, while visitors of new mothers tend to buy
    plush toy bears and balloons. Such patterns are notable because they appear frequently
    enough to catch our interest; we simply apply a bit of logic and subject matter
    experience to explain the rule.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 通过观察购买集合，我们可以推断出存在几种典型的购买模式。一个人去看望生病的亲朋好友时，往往会购买一张祝福卡和鲜花，而看望新妈妈的访客则倾向于购买毛绒玩具熊和气球。这些模式值得关注，因为它们出现的频率足够高，足以引起我们的兴趣；我们只需运用一点逻辑和专业知识来解释这些规则。
- en: In a similar fashion, the Apriori algorithm uses statistical measures of an
    itemset’s “interestingness” to locate association rules in much larger transaction
    databases. In the sections that follow, we will discover how Apriori computes
    such measures of interest, and how they are combined with the Apriori property
    to reduce the number of rules to be learned.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，Apriori算法使用项集“有趣性”的统计指标在更大的交易数据库中定位关联规则。在接下来的章节中，我们将发现Apriori如何计算这些兴趣度量，以及它们如何与Apriori属性结合以减少要学习的规则数量。
- en: Measuring rule interest – support and confidence
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测量规则兴趣——支持度和置信度
- en: 'Whether or not an association rule is deemed interesting is determined by two
    statistical measures: support and confidence. By providing minimum thresholds
    for each of these metrics and applying the Apriori principle, it is easy to drastically
    limit the number of rules reported. If this limit is too strict, it may cause
    only the most obvious or common-sense rules to be identified. For this reason,
    it is important to carefully understand the types of rules that are excluded under
    these criteria so that the right balance can be obtained.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 一个关联规则是否被认为是有趣的，由两个统计指标决定：支持度和置信度。通过为这些指标提供最小阈值并应用Apriori原则，可以很容易地大幅减少报告的规则数量。如果这个限制过于严格，可能会导致只有最明显或常识性的规则被识别。因此，了解在这些标准下被排除的规则类型非常重要，以便获得正确的平衡。
- en: 'The **support** of an itemset or rule measures how frequently it occurs in
    the data. For instance, the itemset *{get well card, flowers}* has the support
    of *3 / 5 = 0.6* in the hospital gift shop data. Similarly, the support for *{get
    well card} ![](img/B17290_08_004.png) {flowers}* is also *0.6*. Support can be
    calculated for any itemset or even a single item; for instance, the support for
    *{candy bar}* is *2/5 = 0.4*, since candy bars appear in 40 percent of purchases.
    A function defining support for itemset *X* could be defined as:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 项集或规则的**支持度**衡量它在数据中出现的频率。例如，项集*{祝福卡，鲜花}*在医院的礼品店数据中的支持度为*3/5 = 0.6*。同样，项集*{祝福卡}
    ![](img/B17290_08_004.png) {鲜花}*的支持度也是*0.6*。支持度可以计算任何项集或单个项；例如，项集*{巧克力棒}*的支持度为*2/5
    = 0.4*，因为巧克力棒出现在40%的购买中。可以定义一个函数来定义项集*X*的支持度：
- en: '![](img/B17290_08_001.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17290_08_001.png)'
- en: Here, *N* is the number of transactions in the database, and *count(X)* is the
    number of transactions containing itemset *X*.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，*N*是数据库中的交易数量，而*count(X)*是包含项集*X*的交易数量。
- en: 'A rule’s **confidence** is a measurement of its predictive power or accuracy.
    It is defined as the support of the itemset containing both *X* and *Y* divided
    by the support of the itemset containing only *X*:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 规则的**置信度**是对其预测能力或准确性的衡量。它定义为包含*X*和*Y*的项集的支持度除以只包含*X*的项集的支持度：
- en: '![](img/B17290_08_002.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17290_08_002.png)'
- en: Essentially, the confidence tells us the proportion of transactions where the
    presence of item or itemset *X* results in the presence of item or itemset *Y*.
    Keep in mind that the confidence that *X* leads to *Y* is not the same as the
    confidence that *Y* leads to *X*.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 实质上，置信度告诉我们交易中存在项或项集*X*导致存在项或项集*Y*的比例。记住，*X*导致*Y*的置信度与*Y*导致*X*的置信度不同。
- en: For example, the confidence of *{flowers} ![](img/B17290_08_004.png) {get-well
    card}* is *0.6 / 0.8 = 0.75*. In comparison, the confidence of *{get-well card}
    ![](img/B17290_08_004.png) {flowers}* is *0.6 / 0.6 = 1.0*. This means that a
    purchase of flowers also includes the purchase of a get-well card 75 percent of
    the time, while a purchase of a get-well card also includes flowers 100 percent
    of the time. This information could be quite useful to the gift shop management.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，*{flowers} ![](img/B17290_08_004.png) {get-well card}*的置信度为*0.6 / 0.8 = 0.75*。相比之下，*{get-well
    card} ![](img/B17290_08_004.png) {flowers}*的置信度为*0.6 / 0.6 = 1.0*。这意味着购买鲜花75%的时间也包括购买祝福卡，而购买祝福卡100%的时间也包括鲜花。这些信息对礼品店的管理可能非常有用。
- en: You may have noticed similarities between support, confidence, and the Bayesian
    probability rules covered in *Chapter 4*, *Probabilistic Learning – Classification
    Using Naive Bayes*. In fact, *support(A, B)* is the same as *P(A ![](img/B17290_08_005.png)
    B)* and *confidence(A* *![](img/B17290_08_004.png)* *B)* is the same as *P(B |
    A)*. It is just the context that differs.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到了支持度、置信度和在第4章“概率学习 - 使用朴素贝叶斯进行分类”中介绍的贝叶斯概率规则之间的相似性。事实上，*support(A, B)*与*P(A
    ![](img/B17290_08_005.png) B)*相同，而*confidence(A* *![](img/B17290_08_004.png)*
    *B)*与*P(B | A)*相同。只是上下文不同。
- en: Rules like *{get-well card} ![](img/B17290_08_004.png) {flowers}* are known
    as **strong rules** because they have both high support and confidence. One way
    to find more strong rules would be to examine every possible combination of items
    in the gift shop, measure the support and confidence, and report back only those
    rules that meet certain levels of interest. However, as noted before, this strategy
    is generally not feasible for anything but the smallest of datasets.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于*{get-well card} ![](img/B17290_08_004.png) {flowers}*的规则被称为**强规则**，因为它们既有高的支持度又有高的置信度。找到更多强规则的一种方法就是检查礼品店中所有可能的商品组合，测量支持度和置信度，并仅报告那些达到一定兴趣水平的规则。然而，正如之前所述，这种策略通常只适用于数据集非常小的情况。
- en: In the next section, you will see how the Apriori algorithm uses minimum levels
    of support and confidence with the Apriori principle to find strong rules quickly
    by reducing the number of rules to a more manageable level.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，您将看到Apriori算法如何使用Apriori原则和最小支持度、置信度水平，通过减少规则数量到更易管理的水平来快速找到强规则。
- en: Building a set of rules with the Apriori principle
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Apriori原则构建一组规则
- en: Recall that the Apriori principle states that all subsets of a frequent itemset
    must also be frequent. In other words, if *{A, B}* is frequent, then *{A}* and
    *{B}* must both be frequent. Recall also that, by definition, the support metric
    indicates how frequently an itemset appears in the data. Therefore, if we know
    that *{A}* does not meet a desired support threshold, there is no reason to consider
    *{A, B}* or any other itemset containing *{A}*; these cannot possibly be frequent.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，Apriori原则指出，频繁项集的所有子集也必须是频繁的。换句话说，如果*{A, B}*是频繁的，那么*{A}*和*{B}*都必须是频繁的。还要记住，根据定义，支持度指标表示项集在数据中出现的频率。因此，如果我们知道*{A}*没有达到期望的支持度阈值，就没有理由考虑*{A,
    B}*或任何包含*{A}*的其他项集；这些不可能频繁出现。
- en: 'The Apriori algorithm uses this logic to exclude potential association rules
    prior to evaluating them. The process of creating rules then occurs in two phases:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Apriori算法使用这种逻辑在评估之前排除潜在的关联规则。创建规则的过程分为两个阶段：
- en: Identifying all the itemsets that meet a minimum support threshold
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 识别所有满足最小支持度阈值的项集
- en: Creating rules from these itemsets using those meeting a minimum confidence
    threshold
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用满足最小置信度阈值的项集创建规则
- en: The first phase occurs in multiple iterations. Each successive iteration involves
    evaluating the support of a set of increasingly large itemsets. For instance,
    iteration one involves evaluating the set of 1-item itemsets (1-itemsets), iteration
    two evaluates the 2-itemsets, and so on. The result of each iteration *i* is a
    set of all the *i*-itemsets that meet the minimum support threshold.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 第一阶段发生在多次迭代中。每一次连续的迭代都涉及评估一组越来越大项集的支持度。例如，第一次迭代涉及评估1项项集（1项集），第二次迭代评估2项集，依此类推。每一次迭代*i*的结果是所有满足最小支持度阈值的*i*项集的集合。
- en: All the itemsets from iteration *i* are combined to generate candidate itemsets
    for evaluation in iteration *i + 1*. But the Apriori principle can eliminate some
    of them even before the next round begins. If *{A}*, *{B}*, and *{C}* are frequent
    in iteration one, while *{D}* is not frequent, then iteration two will consider
    only *{A, B}*, *{A, C}*, and *{B, C}*. Thus, the algorithm needs to evaluate only
    three itemsets rather than the six 2-item itemsets that would have needed to be
    evaluated if the sets containing *D* had not been eliminated *a priori*.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 所有来自迭代 *i* 的项集都被组合起来，以生成在迭代 *i + 1* 中评估的候选项集。但Apriori原则可以在下一轮开始之前消除其中的一些。如果在一轮迭代中
    *{A}*, *{B}*, 和 *{C}* 是频繁的，而 *{D}* 不是频繁的，那么第二轮迭代将只考虑 *{A, B}*, *{A, C}*, 和 *{B,
    C}*。因此，算法只需要评估三个项集，而不是如果包含 *D* 的集合没有被提前消除，将需要评估的六个2项项集。
- en: Continuing this thought, suppose during iteration two it is discovered that
    *{A, B}* and *{B, C}* are frequent, but *{A, C}* is not. Although iteration three
    would normally begin by evaluating the support for the 3-item itemset *{A, B,
    C}*, this step is not necessary. Why not? The Apriori principle states that *{A,
    B, C}* cannot possibly be frequent, since the subset *{A, C}* is not. Therefore,
    having generated no new itemsets in iteration three, the algorithm may stop.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 继续这个想法，假设在第二次迭代中发现 *{A, B}* 和 *{B, C}* 是频繁的，但 *{A, C}* 不是。尽管第三次迭代通常从评估3项项集 *{A,
    B, C}* 的支持度开始，但这一步不是必要的。为什么不是？Apriori原则指出，由于子集 *{A, C}* 不是频繁的，因此 *{A, B, C}* 不可能是频繁的。因此，在第三次迭代中没有生成新的项集，算法可能停止。
- en: '![](img/B17290_08_02.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17290_08_02.png)'
- en: 'Figure 8.2: In this example, the Apriori algorithm only evaluated 7 of the
    15 potential itemsets that can occur in transactional data for four items (the
    0-item itemset is not shown)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2：在这个例子中，Apriori算法只评估了15个潜在项集（对于四个项目，0项项集未显示）中的7个，这些项集可能出现在事务数据中
- en: At this point, the second phase of the Apriori algorithm may begin. Given the
    set of frequent itemsets, association rules are generated from all possible subsets.
    For instance, *{A, B}* would result in candidate rules for *{A} ![](img/B17290_08_004.png)
    {B}* and *{B} ![](img/B17290_08_004.png) {A}*. These are evaluated against a minimum
    confidence threshold, and any rule that does not meet the desired confidence level
    is eliminated.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，Apriori算法的第二阶段可能开始。给定频繁项集的集合，从所有可能的子集中生成关联规则。例如，*{A, B}* 将导致为 *{A} ![](img/B17290_08_004.png)
    {B}* 和 *{B} ![](img/B17290_08_004.png) {A}* 生成候选规则。这些规则将根据最小置信度阈值进行评估，任何不符合所需置信度水平的规则都将被淘汰。
- en: Example – identifying frequently purchased groceries with association rules
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例 - 使用关联规则识别经常购买的杂货
- en: As noted in this chapter’s introduction, market basket analysis is used behind
    the scenes for the recommendation systems used in many brick-and-mortar and online
    retailers. The learned association rules indicate the items that are often purchased
    together. Knowledge of these patterns provides insight into new ways a grocery
    chain might optimize the inventory, advertise promotions, or organize the physical
    layout of the store. For instance, if shoppers frequently purchase coffee or orange
    juice with a breakfast pastry, it may be possible to increase profit by relocating
    pastries closer to coffee and juice.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章引言所述，市场篮子分析在许多实体店和在线零售商使用的推荐系统背后被使用。学习到的关联规则表明了经常一起购买的商品。了解这些模式可以为杂货连锁店优化库存、宣传促销或组织商店的物理布局提供新的见解。例如，如果购物者经常在早餐糕点时购买咖啡或橙汁，那么通过将糕点移至咖啡和果汁附近，可能有可能增加利润。
- en: Similarly, online retailers can use the information for dynamic recommendation
    engines that suggest items related to those you’ve already viewed or to follow
    up after a website visit or online purchase with an email that suggests add-on
    items in a practice called **active after-marketing**.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在线零售商可以使用这些信息为动态推荐引擎提供支持，这些引擎建议与您已经查看的商品相关的商品，或者在网站访问或在线购买后通过电子邮件建议附加商品，这种做法被称为**主动营销**。
- en: In this tutorial, we will perform a market basket analysis of transactional
    data from a grocery store. In doing so, we will see how the Apriori algorithm
    is able to efficiently evaluate a potentially massive set of association rules.
    The same techniques could also be applied to many other business tasks, from movie
    recommendations to dating sites to finding dangerous interactions among medications.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将对一家杂货店的交易数据进行市场篮子分析。这样做，我们将看到Apriori算法如何高效地评估潜在的庞大关联规则集。同样的技术也可以应用于许多其他商业任务，从电影推荐到交友网站，再到寻找药物之间的危险相互作用。
- en: Step 1 – collecting data
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第1步 – 收集数据
- en: Our market basket analysis will utilize purchase data from one month of operation
    at a real-world grocery store. The data contains 9,835 transactions, or about
    327 transactions per day (roughly 30 transactions per hour in a 12-hour business
    day), suggesting that the retailer is not particularly large, nor is it particularly
    small.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的市场篮子分析将利用一家真实杂货店一个月运营的购买数据。数据包含9,835笔交易，或大约每天327笔交易（在12小时营业日中，每小时大约30笔交易），这表明零售商既不是特别大，也不是特别小。
- en: The dataset used here was adapted from the `Groceries` dataset in the `arules`
    R package. For more information, see *Implications of Probabilistic Data Modeling
    for Mining Association Rules, Hahsler, M., Hornik, K., Reutterer, T., 2005*. In
    *From Data and Information Analysis to Knowledge Engineering, Gaul, W., Vichi,
    M., Weihs, C., Studies in Classification, Data Analysis, and Knowledge Organization,
    2006, pp. 598–605*.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用的数据集是从`arules` R包中的`Groceries`数据集改编的。更多信息，请参阅*概率数据建模对挖掘关联规则的影响，Hahsler,
    M.，Hornik, K.，Reutterer, T.，2005*。在*从数据和信息分析到知识工程，Gaul, W.，Vichi, M.，Weihs, C.，分类、数据分析和知识组织研究，2006，第598-605页*。
- en: A typical grocery store offers a huge variety of items. There might be five
    brands of milk, a dozen types of laundry detergent, and three brands of coffee.
    Given the moderate size of the retailer in this example, we will assume that it
    is not terribly concerned with finding rules that apply only to a specific brand
    of milk or detergent, and thus all brand names are removed from the purchases.
    This reduces the number of grocery items to a more manageable 169 types, using
    broad categories such as chicken, frozen meals, margarine, and soda.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的杂货店提供大量商品。可能有五种牛奶品牌，一打洗衣剂类型，以及三种咖啡品牌。鉴于本例中零售商的适度规模，我们假设它并不特别关注仅适用于特定品牌牛奶或洗衣剂的规则，因此所有品牌名称都从购买中去除。这减少了杂货商品的种类，使其更易于管理，共有169种类型，使用广泛的类别，如鸡肉、冷冻食品、人造黄油和汽水。
- en: If you hope to identify highly specific association rules—such as whether customers
    prefer grape or strawberry jelly with their peanut butter— you will need a tremendous
    amount of transactional data. Large chain retailers use databases of many millions
    of transactions in order to find associations among particular brands, colors,
    or flavors of items.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望识别高度具体的关联规则——例如，客户是否更喜欢葡萄或草莓果酱与花生酱搭配——你需要大量的交易数据。大型连锁零售商使用数百万笔交易的数据库，以找到特定品牌、颜色或口味之间的关联。
- en: Do you have any guesses about which types of items might be purchased together?
    Will wine and cheese be a common pairing? Bread and butter? Tea and honey? Let’s
    dig into this data and see if these guesses can be confirmed.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你对哪些类型的商品可能一起购买有什么猜测吗？葡萄酒和奶酪会是常见的搭配吗？面包和黄油？茶和蜂蜜？让我们深入挖掘这些数据，看看这些猜测是否可以得到证实。
- en: Step 2 – exploring and preparing the data
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第2步 – 探索和准备数据
- en: Transactional data is stored in a slightly different format than we have used
    previously. Most of our prior analyses utilized data in a matrix format where
    rows indicated example instances and columns indicated features. As described
    in *Chapter 1*, *Introducing Machine Learning*, in matrix format, all examples
    must have exactly the same set of features.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 事务数据存储的格式与我们之前使用的略有不同。我们之前的大多数分析都使用了矩阵格式，其中行表示示例实例，列表示特征。如*第一章*，*介绍机器学习*中所述，在矩阵格式中，所有示例必须具有完全相同的特征集。
- en: In comparison, transactional data is more freeform. As usual, each row in the
    data specifies a single example—in this case, a transaction. However, rather than
    having a set number of features, each record comprises a comma-separated list
    of any number of items, from one to many. In essence, the features may differ
    from example to example.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，交易数据更为自由形式。通常，数据中的每一行指定一个单独的例子——在本例中，是一个交易。然而，与具有固定数量的特征不同，每条记录包含一个由逗号分隔的项目列表，数量从一到多个。本质上，特征可能因例子而异。
- en: To follow along with this analysis, download the `groceries.csv` file from the
    Packt Publishing GitHub repository for this chapter and save it in your R working
    directory.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随这个分析，请从本章的 Packt Publishing GitHub 仓库下载 `groceries.csv` 文件，并将其保存在您的 R 工作目录中。
- en: 'The first five rows of the raw `groceries.csv` file are as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 原始 `groceries.csv` 文件的头五行如下：
- en: '[PRE0]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'These lines indicate five separate grocery store transactions. The first transaction
    included four items: `citrus fruit`, `semi-finished bread`, `margarine`, and `ready
    soups`. In comparison, the third transaction included only one item: `whole milk`.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这些行表示五个不同的杂货店交易。第一个交易包含四个项目：`柑橘水果`、`半成品面包`、`黄油`和`即食汤品`。相比之下，第三个交易只包含一个项目：`全脂牛奶`。
- en: 'Suppose we tried to load the data using the `read.csv()` function as we did
    in prior analyses. R would happily comply and read the data into a data frame
    in matrix format as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们尝试使用与先前分析中相同的 `read.csv()` 函数加载数据。R 会欣然同意，并将数据以矩阵格式读入数据框，如下所示：
- en: '![Table  Description automatically generated](img/B17290_08_03.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![表格描述自动生成](img/B17290_08_03.png)'
- en: 'Figure 8.3: Reading transactional data into R as a data frame will cause problems
    later on'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.3：将交易数据作为数据框读入 R 将会在以后造成问题
- en: 'You will notice that R created four columns to store the items in the transactional
    data: `V1`, `V2`, `V3`, and `V4`. Although this may seem reasonable, if we use
    the data in this form, we will encounter problems later. R chose to create four
    variables because the first line had exactly four comma-separated values. However,
    we know that grocery purchases can contain more than four items; in the four-column
    design, such transactions will be broken across multiple rows in the matrix. We
    could try to remedy this by putting the transaction with the largest number of
    items at the top of the file, but this ignores another more problematic issue.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到 R 创建了四个列来存储交易数据中的项目：`V1`、`V2`、`V3` 和 `V4`。虽然这看起来似乎是合理的，但如果我们以这种形式使用数据，我们以后会遇到问题。R
    选择创建四个变量，因为第一行恰好有四个由逗号分隔的值。然而，我们知道杂货购买可能包含超过四个项目；在四列设计中，这样的交易将在矩阵的多个行中拆分。我们可以尝试通过将项目数量最多的交易放在文件顶部来纠正这个问题，但这忽略了另一个更成问题的问题。
- en: By structuring the data this way, R has constructed a set of features that record
    not just the items in the transactions but also the order they appear. If we imagine
    our learning algorithm as an attempt to find a relationship among `V1`, `V2`,
    `V3`, and `V4`, then the `whole milk` item in `V1` might be treated differently
    than the `whole milk` item appearing in `V2`. Instead, we need a dataset that
    does not treat a transaction as a set of positions to be filled (or not filled)
    with specific items, but rather as a market basket that either contains or does
    not contain each item.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式结构化数据，R 构建了一套特征，不仅记录了交易中的项目，还记录了它们出现的顺序。如果我们把我们的学习算法想象成试图在 `V1`、`V2`、`V3`
    和 `V4` 之间找到关系，那么 `V1` 中的 `whole milk` 项目可能与 `V2` 中出现的 `whole milk` 项目被不同对待。相反，我们需要一个数据集，它不将交易视为需要（或不需）用特定项目填充（或不填充）的位置集合，而将其视为一个包含或不包含每个项目的市场篮子。
- en: Data preparation – creating a sparse matrix for transaction data
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据准备 – 为交易数据创建稀疏矩阵
- en: The solution to this problem utilizes a data structure called a sparse matrix.
    You may recall that we used a sparse matrix to process text data in *Chapter 4*,
    *Probabilistic Learning – Classification Using Naive Bayes*. Just as with the
    preceding dataset, each row in the sparse matrix indicates a transaction. However,
    the sparse matrix has a column (that is, a feature) for every item that could
    possibly appear in someone’s shopping bag. Since there are 169 different items
    in our grocery store data, our sparse matrix will contain 169 columns.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的解决方案使用了一种称为稀疏矩阵的数据结构。你可能记得我们在*第4章*，*概率学习 - 使用朴素贝叶斯进行分类*中使用了稀疏矩阵来处理文本数据。就像先前的数据集一样，稀疏矩阵中的每一行都表示一个事务。然而，稀疏矩阵为可能出现在某人购物袋中的每个商品都有一个列（即特征）。由于我们的杂货店数据中有169种不同的商品，我们的稀疏矩阵将包含169列。
- en: Why not just store this as a data frame as we did in most of our prior analyses?
    The reason is that as additional transactions and items are added, a conventional
    data structure quickly becomes too large to fit in the available memory. Even
    with the relatively small transactional dataset used here, the matrix contains
    nearly 1.7 million cells, most of which contain zeros (hence the name “sparse”
    matrix—there are very few non-zero values).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么不就像我们之前的大多数分析那样将其存储为数据框呢？原因是随着更多的事务和商品的添加，传统的数据结构很快就会变得太大，无法适应可用的内存。即使使用这里相对较小的交易数据集，矩阵也包含近170万个单元格，其中大多数包含零（因此得名“稀疏”矩阵——非零值非常少）。
- en: Since there is no benefit to storing all these zeros, a sparse matrix does not
    actually store the full matrix in memory; it only stores the cells that are occupied
    by an item. This allows the structure to be more memory efficient than an equivalently
    sized matrix or data frame.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 由于存储所有这些零没有好处，稀疏矩阵实际上并不在内存中存储完整的矩阵；它只存储被商品占用的单元格。这使得结构比同等大小的矩阵或数据框更节省内存。
- en: In order to create the sparse matrix data structure from transactional data,
    we can use the functionality provided by the `arules` (association rules) package.
    Install and load the package using the `install.packages("arules")` and `library(arules)`
    commands.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从事务数据中创建稀疏矩阵数据结构，我们可以使用`arules`（关联规则）包提供的功能。使用`install.packages("arules")`和`library(arules)`命令安装并加载该包。
- en: For more information on the `arules` package, refer to *arules - A Computational
    Environment for Mining Association Rules and Frequent Item Sets, Hahsler, M.,
    Gruen, B., Hornik, K., Journal of Statistical Software, 2005, Vol. 14*.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`arules`包的更多信息，请参阅*arules - A Computational Environment for Mining Association
    Rules and Frequent Item Sets, Hahsler, M., Gruen, B., Hornik, K., Journal of Statistical
    Software, 2005, Vol. 14*。
- en: 'Because we’re loading transactional data, we cannot simply use the `read.csv()`
    function used previously. Instead, `arules` provides a `read.transactions()` function
    that is similar to `read.csv()` with the exception that it results in a sparse
    matrix suitable for transactional data. The parameter `sep = ","` specifies that
    items in the input file are separated by a comma. To read the `groceries.csv`
    data into a sparse matrix named `groceries`, type the following line:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在加载事务数据，我们不能简单地使用之前使用的`read.csv()`函数。相反，`arules`提供了一个`read.transactions()`函数，它类似于`read.csv()`，但区别在于它生成一个适合事务数据的稀疏矩阵。参数`sep
    = ","`指定输入文件中的项由逗号分隔。要将`groceries.csv`数据读取到名为`groceries`的稀疏矩阵中，请输入以下行：
- en: '[PRE1]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To see some basic information about the `groceries` matrix we just created,
    use the `summary()` function on the object:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看我们刚刚创建的`groceries`矩阵的一些基本信息，请在对象上使用`summary()`函数：
- en: '[PRE2]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The first block of information in the output provides a summary of the sparse
    matrix we created. The output `9835 rows` refers to the number of transactions,
    and `169 columns` indicates each of the 169 different items that might appear
    in someone’s grocery basket. Each cell in the matrix is a `1` if the item was
    purchased for the corresponding transaction, or `0` otherwise.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的第一块信息提供了我们创建的稀疏矩阵的摘要。输出`9835 rows`指的是事务数量，`169 columns`表示可能出现在某人购物篮中的169种不同商品。矩阵中的每个单元格如果是为相应事务购买的商品，则为`1`，否则为`0`。
- en: The density value of `0.02609146` (2.6 percent) refers to the proportion of
    non-zero matrix cells. Since there are *9,835 * 169 = 1,662,115* positions in
    the matrix, we can calculate that a total of *1,662,115 * 0.02609146 = 43,367*
    items were purchased during the store’s 30 days of operation (ignoring the fact
    that duplicates of the same items might have been purchased). With an additional
    step, we can determine that the average transaction contained *43,367 / 9,835
    = 4.409* distinct grocery items. Of course, if we look a little further down the
    output, we’ll see that the mean number of items per transaction has already been
    provided.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 密度值 `0.02609146`（2.6%）指的是非零矩阵单元格的比例。由于矩阵中有 *9,835 * 169 = 1,662,115* 个位置，我们可以计算出在商店运营的30天内总共购买了
    *1,662,115 * 0.02609146 = 43,367* 件商品（不考虑可能购买相同商品的重复）。通过额外的步骤，我们可以确定平均交易包含 *43,367
    / 9,835 = 4.409* 种不同的杂货商品。当然，如果我们进一步查看输出，我们会看到每笔交易的商品数量的平均值已经提供。
- en: The next block of `summary()` output lists the items that were most commonly
    found in the transactional data. Since *2,513 / 9,835 = 0.2555*, we can determine
    that `whole milk` appeared in 25.6 percent of transactions.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个 `summary()` 输出块列出了在交易数据中最常出现的商品。由于 *2,513 / 9,835 = 0.2555*，我们可以确定`全脂牛奶`出现在25.6%的交易中。
- en: '`Other vegetables`, `rolls/buns`, `soda`, and `yogurt` round out the list of
    other common items, as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`其他蔬菜`、`面包卷/面包`、`汽水`和`酸奶`构成了其他常见商品的列表，如下所示：'
- en: '[PRE4]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We are also presented with a set of statistics about the size of the transactions.
    A total of 2,159 transactions contained only a single item, while one transaction
    had 32 items. The first quartile and median purchase size are two and three items
    respectively, implying that 25 percent of the transactions contained two or fewer
    items and about half contained three items or fewer. The mean of 4.409 items per
    transaction matches the value we calculated by hand:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还提供了一组关于交易大小的统计数据。共有2,159笔交易只包含一个商品，而有一笔交易包含32个商品。第一四分位数和中位数购买量分别是两个和三个商品，这意味着25%的交易包含两个或更少的商品，大约一半的交易包含三个或更少的商品。每笔交易4.409个商品的均值与我们手工计算出的值相匹配：
- en: '[PRE5]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Finally, the bottom of the output includes additional information about any
    metadata that may be associated with the item matrix, such as item hierarchies
    or labels. We have not used these advanced features, but the output still indicates
    that the data has labels. The `read.transactions()` function added these automatically
    upon load using the item names in the original CSV file, and the first three labels
    (in alphabetical order) are shown:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，输出底部包括与商品矩阵可能关联的任何元数据的附加信息，例如商品层次结构或标签。我们没有使用这些高级功能，但输出仍然表明数据有标签。`read.transactions()`
    函数在加载时自动使用原始CSV文件中的商品名称添加了这些标签，前三个标签（按字母顺序排列）如下所示：
- en: '[PRE6]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Note that the `arules` package represents items internally using numeric item
    ID numbers with no connection to the item in the real world. By default, most
    `arules` functions will decode these numbers using the item labels. However, to
    illustrate the numeric IDs, we can examine the first two transactions without
    decoding using the so-called “long” format. In long-format transactional data,
    each row is a single item from a single transaction rather than each row representing
    a single transaction with multiple items. For instance, because the first and
    second transactions had four and three items, respectively, the long format represents
    these transactions in seven rows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`arules` 包内部使用没有与真实世界中的商品关联的数字项ID来表示商品。默认情况下，大多数 `arules` 函数将使用商品标签解码这些数字。然而，为了说明数字ID，我们可以使用所谓的“长”格式来检查前两个交易，而不进行解码。在长格式交易数据中，每一行代表单个交易中的一个单独商品，而不是每一行代表一个包含多个商品的单独交易。例如，因为第一个和第二个交易分别有四个和三个商品，所以长格式用七行来表示这些交易：
- en: '[PRE7]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this representation of the transactional data, the column named `TID` refers
    to the transaction ID—that is, the first or second market basket—and the column
    named `item` refers to the internal ID number assigned to the item. As the first
    transaction contained *{citrus fruit, margarine, ready soups, and semi-finished
    bread}*, we can assume that the item ID of 30 refers to *citrus fruit* and 89
    refers to *margarine*.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种交易数据的表示中，名为 `TID` 的列指的是交易ID——即第一个或第二个购物篮，而名为 `item` 的列指的是分配给商品的内部ID号。由于第一个交易包含
    *{柑橘类水果、黄油、即食汤和半成品面包}*，我们可以假设商品ID 30指的是 *柑橘类水果*，而89指的是 *黄油*。
- en: 'The `arules` package, of course, includes features for examining transaction
    data in more intuitive formats. To look at the contents of the sparse matrix,
    use the `inspect()` function in combination with R’s vector operators. The first
    five transactions can be viewed as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，`arules`包包括用于以更直观的格式检查交易数据的特性。要查看稀疏矩阵的内容，请使用`inspect()`函数与R的向量运算符结合。以下是如何查看前五笔交易的示例：
- en: '[PRE9]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: When formatted using the `inspect()` function, the data does not look very different
    from what we had seen in the original CSV file.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`inspect()`函数格式化时，数据看起来与我们之前在原始CSV文件中看到的数据没有太大区别。
- en: 'Because the `groceries` object is stored as a sparse item matrix, the `[row,
    column]` notation can be used to examine desired items as well as desired transactions.
    Using this with the `itemFrequency()` function allows us to see the proportion
    of all transactions that contain the specified item. For instance, to view the
    support level for the first three items across all rows in the grocery data, use
    the following command:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`groceries`对象存储为稀疏项矩阵，可以使用`[行，列]`表示法来检查所需的项以及所需的交易。使用此功能与`itemFrequency()`函数结合，我们可以看到包含指定项的所有交易的比例。例如，要查看所有行中前三个项的支持水平，请使用以下命令：
- en: '[PRE11]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Notice that the items in the sparse matrix are arranged in columns in alphabetical
    order. Abrasive cleaners and artificial sweeteners are found in about 0.3 percent
    of the transactions, while baby cosmetics are found in about 0.06 percent of the
    transactions.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到稀疏矩阵中的项按字母顺序排列在列中。磨料清洁剂和人造甜味剂在约0.3%的交易中找到，而婴儿化妆品在约0.06%的交易中找到。
- en: Visualizing item support – item frequency plots
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可视化项支持 - 项频率图
- en: To present these statistics visually, use the `itemFrequencyPlot()` function.
    This creates a bar chart depicting the proportion of transactions containing specified
    items. Since transactional data contains a very large number of items, you will
    often need to limit those appearing in the plot in order to produce a legible
    chart.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 要将这些统计数据可视化，请使用`itemFrequencyPlot()`函数。这会创建一个条形图，表示包含指定项的交易比例。由于交易数据包含大量项，你通常需要限制图表中出现的项，以便生成可读的图表。
- en: 'If you would like to display items that appear in a minimum proportion of transactions,
    use `itemFrequencyPlot()` with the `support` parameter:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望显示出现在交易中比例最小的项，请使用带有`support`参数的`itemFrequencyPlot()`函数：
- en: '[PRE13]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As shown in the following plot, this results in a histogram showing the eight
    items in the `groceries` data with at least 10 percent support:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下图表所示，这会产生一个直方图，显示了`groceries`数据中至少有10%支持的八个项：
- en: '![Chart, bar chart  Description automatically generated](img/B17290_08_04.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图表，条形图  自动生成的描述](img/B17290_08_04.png)'
- en: 'Figure 8.4: Support levels for all grocery items in at least 10 percent of
    transactions'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4：至少在10%的交易中所有杂货项的支持水平
- en: 'If you would rather limit the plot to a specific number of items, use the function
    with the `topN` parameter:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望将图表限制在特定数量的项上，请使用带有`topN`参数的函数：
- en: '[PRE14]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The histogram is then sorted by decreasing support, as shown in the following
    diagram for the top 20 items in the `groceries` data:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 然后直方图按支持度递减排序，如下图中`groceries`数据的前20项所示：
- en: '![A picture containing chart  Description automatically generated](img/B17290_08_05.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![包含图表的图片  自动生成的描述](img/B17290_08_05.png)'
- en: 'Figure 8.5: Support levels for the top 20 grocery items'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5：前20个杂货项的支持水平
- en: Visualizing the transaction data – plotting the sparse matrix
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可视化交易数据 - 绘制稀疏矩阵
- en: 'In addition to looking at specific items, it’s also possible to obtain a bird’s-eye
    view of the entire sparse matrix using the `image()` function. Of course, because
    the matrix itself is very large, it is usually best to request a subset of the
    entire matrix. The command to display the sparse matrix for the first five transactions
    is as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 除了查看特定项之外，还可以使用`image()`函数从整体上获得稀疏矩阵的鸟瞰图。当然，由于矩阵本身非常大，通常最好请求整个矩阵的一个子集。显示前五笔交易的稀疏矩阵的命令如下：
- en: '[PRE15]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The resulting diagram depicts a matrix with 5 rows and 169 columns, indicating
    the 5 transactions and 169 possible items we requested. Cells in the matrix are
    filled with black for transactions (rows) where the item (column) was purchased.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的图表显示了一个5行169列的矩阵，表示我们请求的5笔交易和169个可能的项。矩阵中的单元格在交易（行）中购买项（列）时填充为黑色。
- en: '![A picture containing chart  Description automatically generated](img/B17290_08_06.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![包含图表的图片  自动生成的描述](img/B17290_08_06.png)'
- en: 'Figure 8.6: A visualization of the sparse matrix for the first five transactions'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6：前五笔交易的稀疏矩阵可视化
- en: Although *Figure 8.6* is small and may be slightly hard to read, you can see
    that the first, fourth, and fifth transactions contained four items each, since
    their rows have four cells filled in. On the right side of the diagram, you can
    also see that rows three and five, and rows two and four, share an item in common.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然图8.6很小，可能稍微难以阅读，但您可以看到第一、第四和第五笔交易各包含四个项目，因为它们的行有四个单元格被填充。在图表的右侧，您还可以看到第三行和第五行，以及第二行和第四行共享一个共同的项目。
- en: This visualization can be a useful tool for exploring transactional data. For
    one, it may help with the identification of potential data issues. Columns that
    are filled all the way down could indicate items that are purchased in every transaction—a
    problem that could arise, perhaps, if a retailer’s name or identification number
    was inadvertently included in the transaction dataset.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这种可视化可以是一个有用的工具来探索交易数据。首先，它可能有助于识别潜在的数据问题。完全填满的列可能表明在每次交易中都购买的项目——这可能是由于零售商的名称或识别号码意外包含在交易数据集中而引起的问题。
- en: Additionally, patterns in the diagram may help reveal interesting segments of
    transactions and items, particularly if the data is sorted in interesting ways.
    For example, if the transactions are sorted by date, patterns in the black dots
    could reveal seasonal effects in the number or types of items purchased. Perhaps
    around Christmas or Hanukkah, toys are more common; around Halloween, perhaps
    candies become popular. This type of visualization could be especially powerful
    if the items were also sorted into categories. In most cases, however, the plot
    will look fairly random, like static on a television screen.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，图中的模式可能有助于揭示有趣的交易和项目段，尤其是如果数据以有趣的方式排序。例如，如果交易按日期排序，黑色点的模式可能揭示购买数量或类型的季节性影响。也许在圣诞节或光明节期间，玩具更为常见；在万圣节期间，糖果可能变得流行。如果项目也被分类排序，这种类型的可视化可能特别强大。然而，在大多数情况下，图表看起来相当随机，就像电视屏幕上的静电一样。
- en: 'Keep in mind that this visualization will not be as useful for extremely large
    transaction databases because the cells will be too small to discern. Still, by
    combining it with the `sample()` function, you can view the sparse matrix for
    a randomly sampled set of transactions. The command to create a random selection
    of 100 transactions is as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这种可视化对于非常大的交易数据库可能不太有用，因为单元格太小，无法辨别。不过，通过结合`sample()`函数，您可以查看随机采样交易集的稀疏矩阵。创建100笔随机交易的选择命令如下：
- en: '[PRE16]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This creates a matrix diagram with 100 rows and 169 columns:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了一个100行169列的矩阵图：
- en: '![Chart, scatter chart  Description automatically generated](img/B17290_08_07.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图表，散点图  自动生成的描述](img/B17290_08_07.png)'
- en: 'Figure 8.7: A visualization of the sparse matrix for 100 randomly selected
    transactions'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7：100笔随机选择交易的稀疏矩阵可视化
- en: A few columns seem fairly heavily populated, indicating some very popular items
    at the store. However, the distribution of dots seems fairly random overall. Given
    nothing else of note, let’s continue with our analysis.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 几列似乎相当密集，表明商店中一些非常受欢迎的商品。然而，点的分布总体上似乎相当随机。如果没有其他值得注意的事项，让我们继续我们的分析。
- en: Step 3 – training a model on the data
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第3步 – 在数据上训练模型
- en: With data preparation complete, we can now work at finding associations among
    shopping cart items. We will use an implementation of the Apriori algorithm in
    the `arules` package we’ve been using for exploring and preparing the `groceries`
    data. You’ll need to install and load this package if you have not done so already.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 数据准备完成后，我们现在可以着手寻找购物车项目之间的关联。我们将使用我们一直在使用的`arules`包中的Apriori算法实现来探索和准备`groceries`数据。如果您还没有安装和加载此包，您需要这样做。
- en: 'The following table shows the syntax for creating sets of rules with the `apriori()`
    function:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 下表显示了使用`apriori()`函数创建规则集的语法：
- en: '![Text  Description automatically generated](img/B17290_08_08.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![文本  自动生成的描述](img/B17290_08_08.png)'
- en: 'Figure 8.8: Apriori association rule learning syntax'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.8：Apriori关联规则学习语法
- en: Although running the `apriori()` function is straightforward, there can sometimes
    be a fair amount of trial and error needed to find the `support` and `confidence`
    parameters that produce a reasonable number of association rules. If you set these
    levels too high, then you might find no rules, or might find rules that are too
    generic to be very useful. On the other hand, a threshold too low might result
    in an unwieldy number of rules. Worse, the operation might take a very long time
    or run out of memory during the learning phase.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然运行`apriori()`函数很简单，但有时为了找到产生合理数量关联规则的`支持`和`置信度`参数，可能需要进行相当多的试错。如果你将这些级别设置得太高，那么你可能会找不到任何规则，或者可能会找到过于通用的规则，不太有用。另一方面，如果阈值设置得太低，可能会导致规则数量过多。更糟糕的是，操作可能会花费很长时间，或者在学习阶段耗尽内存。
- en: 'On the `groceries` data, using the default settings of `support = 0.1` and
    `confidence = 0.8` leads to a disappointing outcome. Although the full output
    has been omitted for brevity, the end result is a set of zero rules:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在`groceries`数据上，使用默认的`support = 0.1`和`confidence = 0.8`设置导致令人失望的结果。虽然为了简洁省略了完整的输出，但最终结果是零规则集：
- en: '[PRE17]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Obviously, we need to widen the search a bit.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们需要稍微扩大搜索范围。
- en: If you think about it, this outcome should not have been terribly surprising.
    Because `support = 0.1` by default, in order to generate a rule, an item must
    have appeared in at least *0.1 * 9,385 = 938.5* transactions. Since only eight
    items appeared this frequently in our data, it’s no wonder we didn’t find any
    rules.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细想想，这个结果不应该令人特别惊讶。因为默认的`support = 0.1`，为了生成一个规则，一个商品必须至少出现在*0.1 * 9,385
    = 938.5*次交易中。由于在我们的数据中只有八个商品这么频繁地出现，难怪我们没有找到任何规则。
- en: One way to approach the problem of setting a minimum support is to think about
    the smallest number of transactions needed before a stakeholder would consider
    a pattern interesting. For instance, one could argue that if an item is purchased
    twice a day (about 60 times in a month of data) then it may be important. From
    there, it is possible to calculate the support level needed to find only rules
    matching at least that many transactions. Since 60 out of 9,835 equals approximately
    0.006, we’ll try setting the support there first.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 解决设置最小支持度问题的一种方法是想一下在利益相关者认为一个模式有趣之前需要的最小交易数量。例如，可以争论如果一项商品每天被购买两次（在一个月的数据中大约是60次），那么它可能很重要。从那里，可以计算出找到至少那么多交易的规则所需的支持水平。由于60除以9,835大约等于0.006，我们将首先尝试将支持度设置为那里。
- en: Setting the minimum confidence involves a delicate balance. On the one hand,
    if the confidence is too low, then we might be overwhelmed with many unreliable
    rules—such as dozens of rules indicating items purchased together frequently by
    chance alone, like bread and batteries. How would we know where to target our
    advertising budget then? On the other hand, if we set the confidence too high,
    then we will be limited to rules that are obvious or inevitable—like the fact
    that a smoke detector is always purchased in combination with batteries. In this
    case, moving the smoke detectors closer to the batteries is unlikely to generate
    additional revenue, since the two items were already almost always purchased together.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 设置最低置信度需要微妙的平衡。一方面，如果置信度太低，我们可能会被许多不可靠的规则淹没——例如，几十条规则表明面包和电池等商品偶然经常一起购买。那么我们如何知道在哪里投放我们的广告预算呢？另一方面，如果我们设置置信度太高，那么我们将局限于明显或不可避免的规则——比如烟雾探测器总是与电池一起购买的事实。在这种情况下，将烟雾探测器移近电池不太可能产生额外的收入，因为这两个商品几乎总是一起购买。
- en: The appropriate minimum confidence level depends a great deal on the goals of
    your analysis. If you start with a conservative value, you can always reduce it
    to broaden the search if you aren’t finding actionable intelligence.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 适当的最低置信度水平在很大程度上取决于你分析的目标。如果你从一个保守的值开始，如果你没有找到可操作的信息，你可以总是将其降低以扩大搜索范围。
- en: We’ll start with a confidence threshold of 0.25, which means that in order to
    be included in the results, the rule must be correct at least 25 percent of the
    time. This will eliminate the most unreliable rules while allowing some room for
    us to modify behavior with targeted promotions.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个置信度阈值为0.25开始，这意味着为了被包含在结果中，规则至少必须有25%的时间是正确的。这将消除最不可靠的规则，同时为我们留出一些空间，通过有针对性的促销来修改行为。
- en: Now we’re ready to generate some rules. In addition to the minimum `support`
    and `confidence` parameters, it is helpful to set `minlen = 2` to eliminate rules
    that contain fewer than two items. This prevents uninteresting rules from being
    created simply because the item is purchased frequently, for instance, `{} =>
    whole milk`. This rule meets the minimum support and confidence because whole
    milk is purchased in over 25 percent of transactions, but it isn’t a very actionable
    insight.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备生成一些规则。除了最小`支持`和`置信度`参数外，设置`minlen = 2`以消除包含少于两个项目的规则是有帮助的。这可以防止仅因为项目经常被购买而创建无趣的规则，例如，`{}
    => whole milk`。此规则满足最小支持和置信度，因为全脂牛奶在超过25%的交易中被购买，但这并不是一个非常有用的洞察。
- en: 'The full command for finding a set of association rules using the Apriori algorithm
    is as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Apriori算法查找关联规则的全命令如下：
- en: '[PRE19]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The first few lines of output describe the parameter settings we specified,
    as well as several others that remained set to their defaults; for definitions
    of these, use the `?APparameter` help command. The second set of lines shows behind-the-scenes
    algorithmic control parameters that may be helpful for much larger datasets, as
    they control computing tradeoffs like optimizing for speed or memory use. For
    information on these parameters, use the `?APcontrol` help command:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的前几行描述了我们指定的参数设置，以及一些保持默认设置的参数；有关这些参数的定义，请使用`?APparameter`帮助命令。第二组行显示了幕后算法控制参数，这些参数对于处理更大的数据集可能很有帮助，因为它们控制着计算权衡，如优化速度或内存使用。有关这些参数的信息，请使用`?APcontrol`帮助命令：
- en: '[PRE20]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Next, the output includes information about the steps in the Apriori algorithm
    execution:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，输出包括关于Apriori算法执行步骤的信息：
- en: '[PRE21]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Given the small size of the transactional dataset, most of the rows show steps
    that took virtually no time to run—denoted as `[0.00s]` in the output here, but
    your output may vary slightly depending on computer capability.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 由于事务数据集规模较小，大多数行显示的步骤几乎不需要时间运行——在此输出中用`[0.00s]`表示，但你的输出可能因计算机性能而略有不同。
- en: The `Absolute minimum support count` refers to the smallest count of transactions
    that would meet the support threshold of 0.006 we specified. Since *0.006 * 9,835
    = 59.01*, the algorithm requires items to appear in a minimum of 59 transactions.
    The `checking subsets of size 1 2 3 4` output suggests that the algorithm tested
    *i*-itemsets of 1, 2, 3, and 4 items before stopping the iteration process and
    writing the final set of 463 rules.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`绝对最小支持计数`指的是满足我们指定的支持阈值0.006所需的最小交易计数。由于`0.006 * 9,835 = 59.01`，算法要求项目至少出现在59个交易中。`检查大小为1
    2 3 4的子集`输出表明算法在停止迭代过程并写入最终的463条规则之前测试了1、2、3和4个项目的-i项集。'
- en: 'The end result of the `apriori()` function is a rules object, which we can
    peek into by typing its name:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`apriori()`函数的最终结果是规则对象，我们可以通过输入其名称来查看：'
- en: '[PRE22]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Our `groceryrules` object contains quite a large set of association rules! To
    determine whether any of them are useful, we’ll have to dig deeper.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`groceryrules`对象包含大量关联规则！为了确定其中是否有任何有用的规则，我们还需要深入研究。
- en: Step 4 – evaluating model performance
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 步骤4 – 评估模型性能
- en: 'To obtain a high-level overview of the association rules, we can use `summary()`
    as follows. The rule length distribution tells us how many rules have each count
    of items. In our rule set, 150 rules have only two items, while 297 have three,
    and 16 have four. The summary statistics associated with this distribution are
    also provided in the first few lines of output:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得关联规则的高级概述，我们可以使用`summary()`如下。规则长度分布告诉我们有多少规则具有每个项目计数。在我们的规则集中，150条规则只有两个项目，而297条规则有三个，16条规则有四个。与此分布相关的摘要统计信息也提供在输出的前几行：
- en: '[PRE24]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As noted in the previous output, the size of the rule is calculated as the total
    of both the left-hand side (`lhs`) and right-hand side (`rhs`) of the rule. This
    means that a rule like `{bread} => {butter}` is two items and `{peanut butter,
    jelly} => {bread}` is three.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个输出所示，规则的尺寸是规则左侧（`lhs`）和右侧（`rhs`）的总和。这意味着像`{bread} => {butter}`这样的规则包含两个项目，而`{peanut
    butter, jelly} => {bread}`则包含三个。
- en: 'Next, we see the summary statistics of the rule quality measures, including
    `support` and `confidence`, as well as `coverage`, `lift`, and `count`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们看到规则质量度量指标的摘要统计信息，包括`支持`和`置信度`，以及`覆盖率`、`提升度`和`计数`：
- en: '[PRE26]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `support` and `confidence` measures should not be very surprising, since
    we used these as selection criteria for the rules. We might be alarmed if most
    or all of the rules had `support` and `confidence` very near the minimum thresholds,
    as this would mean that we may have set the bar too high. This is not the case
    here, as there are many rules with much higher values of each.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`支持`和`置信度`度量不应该非常令人惊讶，因为我们已经将这些作为规则选择标准。如果我们发现大多数或所有规则的支持和置信度都非常接近最小阈值，我们可能会感到惊讶，因为这意味着我们可能把门槛设得太高。但这里并非如此，因为有许多规则的支持值和置信度都远高于这个值。'
- en: The `count` and `coverage` measures are closely related to `support` and `confidence`.
    As defined here, **count** is simply the numerator of the support metric or the
    number (rather than proportion) of transactions that contained the item. Because
    the absolute minimum support count was 59, it is unsurprising that the minimum
    observed count of 60 is close to the parameter setting. The maximum count of 736
    suggests that an item appeared in 736 out of 9,835 transactions; this relates
    to the maximum observed support as *736 / 9,835 = 0.074835*.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`计数`和`覆盖度`度量与`支持度`和`置信度`密切相关。在这里定义的**计数**是支持度度量的分子，或者是包含该商品的交易数量（而不是比例）。由于绝对最小支持度计数为59，因此观察到的最小计数为60，这与参数设置非常接近并不令人惊讶。最大计数为736表明，该商品出现在9,835笔交易中的736笔；这与观察到的最大支持度相关，即*736
    / 9,835 = 0.074835*。'
- en: 'The **coverage** of an association rule is simply the support of the left-hand
    side of the rule, but it has a useful real-world interpretation: it can be understood
    as the chance that a rule applies to any given transaction in the dataset, selected
    at random. Thus, the minimum `coverage` of 0.009964 suggests that the least applicable
    rule covers only about one percent of transactions; the maximum `coverage` of
    0.255516 suggests that at least one rule covers more than 25 percent of transactions.
    Surely, this rule involves `whole milk`, as it is the only item that appears in
    so many transactions.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 关联规则的**覆盖度**简单地是规则左侧的支持度，但它有一个有用的现实世界解释：它可以理解为规则在数据集中随机选择的任何给定交易中应用的概率。因此，最小的`覆盖度`为0.009964表明，最不适用规则的覆盖范围仅占交易的大约1%；最大的`覆盖度`为0.255516表明，至少有一个规则覆盖了超过25%的交易。当然，这个规则涉及到`全脂牛奶`，因为它是唯一出现在如此多交易中的商品。
- en: 'The final column is a metric we have not considered yet. The **lift** of a
    rule measures how much more likely one item or itemset is to be purchased relative
    to its typical rate of purchase, given that you know another item or itemset has
    been purchased. This is defined by the following equation:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一列是我们尚未考虑的度量。规则的**提升度**衡量的是，在已知另一个商品或商品集已被购买的情况下，一个商品或商品集相对于其典型购买率的购买可能性。这由以下方程定义：
- en: '![](img/B17290_08_003.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17290_08_003.png)'
- en: Unlike confidence, where the item order matters, *lift(X* *![](img/B17290_08_004.png)*
    *Y)* is the same as *lift(Y* *![](img/B17290_08_004.png)* *X)*.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 与置信度不同，其中项目顺序很重要，*提升(X* *![](img/B17290_08_004.png)* *Y)*与*提升(Y* *![](img/B17290_08_004.png)*
    *X)*相同。
- en: For example, suppose at a grocery store, most people purchase milk and bread.
    By chance alone, we would expect to find many transactions with both milk and
    bread. However, if *lift(milk* *![](img/B17290_08_004.png)* *bread)* is greater
    than 1, this implies that the two items are found together more often than expected
    by chance alone. In other words, someone who purchases one of the items is more
    likely to purchase the other. A large lift value is therefore a strong indicator
    that a rule is important and reflects a true connection between the items, and
    that the rule will be useful for business purposes. Keep in mind, however, that
    this is only the case for sufficiently large transactional datasets; lift values
    can be exaggerated for items with low support.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设在一家杂货店，大多数人会购买牛奶和面包。仅凭运气，我们预计会发现许多同时购买牛奶和面包的交易。然而，如果*提升(milk* *![](img/B17290_08_004.png)*
    *bread)*大于1，这表明这两个商品比仅凭运气更频繁地一起出现。换句话说，购买其中一个商品的人更有可能购买另一个商品。因此，一个大的提升值是规则重要的强烈指标，反映了商品之间的真实联系，并且该规则对商业用途是有用的。然而，请注意，这仅适用于足够大的交易数据集；对于支持度低的商品，提升值可能会被夸大。
- en: A pair of authors from the `apriori` package have proposed new metrics called
    **hyper-lift** and **hyper-confidence** to address the shortcomings of these measures
    for data with rare items. For more information, see *M. Hahsler and K. Hornik,
    New Probabilistic Interest Measures for Association Rules (2018).* [https://arxiv.org/pdf/0803.0966.pdf](https://arxiv.org/pdf/0803.0966.pdf).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`apriori`包的一对作者提出了新的度量标准，称为**超提升**和**超置信度**，以解决这些度量标准在稀疏数据中的不足。更多信息，请参阅*M.
    Hahsler和K. Hornik，关联规则的新概率兴趣度量（2018）.* [https://arxiv.org/pdf/0803.0966.pdf](https://arxiv.org/pdf/0803.0966.pdf)。'
- en: 'In the final section of the `summary()` output, we receive mining information,
    telling us about how the rules were chosen. Here, we see that the `groceries`
    data, which contained 9,835 transactions, was used to construct rules with a minimum
    support of 0.006 and minimum confidence of 0.25:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在`summary()`输出的最后部分，我们收到挖掘信息，告诉我们规则是如何被选择的。在这里，我们看到`groceries`数据，其中包含9,835笔交易，被用来构建最小支持度为0.006和最小置信度为0.25的规则：
- en: '[PRE27]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We can take a look at specific rules using the `inspect()` function. For instance,
    the first three rules in the `groceryrules` object can be viewed as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`inspect()`函数查看具体的规则。例如，`groceryrules`对象中的前三条规则可以如下查看：
- en: '[PRE28]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The first rule can be read in plain language as “if a customer buys potted plants,
    they will also buy whole milk.” With a support of about 0.007 and a confidence
    of 0.400, we can determine that this rule covers about 0.7 percent of transactions
    and is correct in 40 percent of purchases involving potted plants. The lift value
    tells us how much more likely a customer is to buy whole milk relative to the
    average customer, given that they bought a potted plant. Since we know that about
    25.6 percent of customers bought whole milk (`support`), while 40 percent of customers
    buying a potted plant bought whole milk (`confidence`), we can compute the lift
    as *0.40 / 0.256 = 1.56*, which matches the value shown.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条规则可以用普通语言读作：“如果一个顾客购买了盆栽植物，他们也会购买全脂牛奶。”支持度约为0.007，置信度为0.400，我们可以确定这条规则覆盖了大约0.7%的交易，并且在涉及盆栽植物的40%的购买中是正确的。提升值告诉我们，在顾客购买了盆栽植物的情况下，他们购买全脂牛奶的可能性相对于平均顾客要高多少。由于我们知道大约25.6%的顾客购买了全脂牛奶（`support`），而40%购买盆栽植物的顾客购买了全脂牛奶（`confidence`），我们可以计算出提升值为*0.40
    / 0.256 = 1.56*，这与显示的值相匹配。
- en: Note that the column labeled `support` indicates the support for the rule, not
    the support for the `lhs` or `rhs` alone. The column labeled `coverage` is the
    support for the left-hand side.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，标有`support`的列表示规则的支撑度，而不是`lhs`或`rhs`单独的支撑度。标有`coverage`的列是左侧的支撑度。
- en: Although the confidence and lift are high, does *{potted plants} ![](img/B17290_08_004.png)
    {whole milk}* seem like a very useful rule? Probably not, as there doesn’t seem
    to be a logical reason why someone would be more likely to buy milk with a potted
    plant. Yet our data suggests otherwise. How can we make sense of this fact?
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管置信度和提升度都很高，但*{盆栽植物} ![](img/B17290_08_004.png) {全脂牛奶}*看起来像一条非常有用的规则吗？可能不是，因为没有明显的逻辑原因说明为什么有人会更有可能和盆栽植物一起购买牛奶。然而，我们的数据表明情况并非如此。我们如何理解这一事实？
- en: 'A common approach is to take the association rules and divide them into the
    following three categories:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 一种常见的方法是将关联规则分为以下三个类别：
- en: Actionable
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可执行
- en: Trivial
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 琐碎
- en: Inexplicable
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无法解释
- en: Obviously, the goal of a market basket analysis is to find **actionable** rules
    that provide a clear and interesting insight. Some rules are clear and others
    are interesting; it is less common to find a combination of both of these factors.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，市场篮子分析的目标是找到**可执行**的规则，这些规则提供了清晰且有趣的见解。有些规则是清晰的，有些是有趣的；同时具备这两个因素的规则较为罕见。
- en: So-called **trivial** rules include any rules that are so obvious that they
    are not worth mentioning—they are clear, but not interesting. Suppose you are
    a marketing consultant being paid large sums of money to identify new opportunities
    for cross-promoting items. If you report the finding that *{diapers} ![](img/B17290_08_004.png)
    {formula}*, you probably won’t be invited back for another consulting job.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 所说的**琐碎**规则包括任何如此明显以至于不值得提及的规则——它们是清晰的，但并不有趣。假设你是一名营销顾问，被支付大笔金钱来识别跨推广商品的新机会。如果你报告的发现是*{纸尿布}
    ![](img/B17290_08_004.png) {配方}*，你可能不会被邀请回来进行另一项咨询工作。
- en: Trivial rules can also sneak in disguised as more interesting results. For instance,
    say you found an association between a particular brand of children’s cereal and
    a popular animated movie. This finding is not very insightful if the movie’s main
    character is on the front of the cereal box.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的规则也可能伪装成更有趣的结果。例如，如果你发现某种儿童谷物品牌与一部流行的动画片之间存在关联。如果这部电影的主要角色出现在谷物盒的正面，这个发现就不是很具有洞察力。
- en: Rules are **inexplicable** if the connection between the items is so unclear
    that figuring out how to use the information is impossible or nearly impossible.
    The rule may simply be a random pattern in the data, for instance, a rule stating
    that *{pickles} ![](img/B17290_08_004.png) {chocolate ice cream}* may be due to
    a single customer whose pregnant wife had regular cravings for strange combinations
    of foods.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果项目之间的联系如此不清楚，以至于无法或几乎无法弄清楚如何使用这些信息，则规则是**无法解释的**。该规则可能仅仅是数据中的随机模式，例如，一条声称*{腌黄瓜}*与*{巧克力冰淇淋}*之间有关系的规则可能仅是由于一位孕妇妻子对奇怪食物组合有定期渴望的单一客户。
- en: The best rules are the hidden gems—the undiscovered insights that only seem
    obvious once discovered. Given enough time, one could evaluate each and every
    rule to find the gems. However, the data scientists working on the analysis may
    not be the best judge of whether a rule is actionable, trivial, or inexplicable.
    Consequently, better rules are likely to arise via collaboration with the domain
    experts responsible for managing the retail chain, who can help interpret the
    findings. In the next section, we’ll facilitate such sharing by employing methods
    for sorting and exporting the learned rules so that the most interesting results
    float to the top.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的规则是隐藏的宝石——一旦被发现，似乎就显而易见的未发现见解。如果时间足够，可以评估每一条规则以找到这些宝石。然而，从事分析的数据科学家可能不是判断规则是否具有可操作性、平凡或无法解释的最佳评判者。因此，更好的规则很可能是通过与负责管理零售连锁店的领域专家合作而产生的，他们可以帮助解释这些发现。在下一节中，我们将通过采用排序和导出学习规则的方法来促进这种共享，以便最有趣的结果浮出水面。
- en: Step 5 – improving model performance
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第5步 – 提高模型性能
- en: Subject matter experts may be able to identify useful rules very quickly, but
    it would be a poor use of their time to ask them to evaluate hundreds or thousands
    of rules. Therefore, it’s useful to be able to sort the rules according to different
    criteria and get them out of R in a form that can be shared with marketing teams
    and examined in more depth. In this way, we can improve the performance of our
    rules by making the results more actionable.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 主题专家可能能够非常快速地识别出有用的规则，但要求他们评估数百或数千条规则则是对他们时间的低效利用。因此，能够根据不同的标准对规则进行排序，并以可以与营销团队共享并深入审查的形式从R中提取它们，是非常有用的。这样，我们可以通过使结果更具可操作性来提高我们规则的表现力。
- en: If you are running into memory limitations or if Apriori is taking too long
    to run, it may also be possible to improve the computational performance of the
    association rule mining process itself by using a more recent algorithm.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遇到内存限制问题，或者Apriori运行时间过长，也可以通过使用更近期的算法来提高关联规则挖掘过程的计算性能。
- en: Sorting the set of association rules
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对关联规则集进行排序
- en: Depending upon the objectives of the market basket analysis, the most useful
    rules might be those with the highest support, confidence, or lift. The `arules`
    package works with the R `sort()` function to allow reordering of the list of
    rules so that those with the highest or lowest values of the quality measure come
    first.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 根据市场篮子分析的目标，最有用的规则可能是那些具有最高支持度、置信度或提升度的规则。`arules`包与R的`sort()`函数一起工作，允许重新排序规则列表，使得具有最高或最低质量度量值的规则排在最前面。
- en: 'To reorder the `groceryrules` object, we can `sort()` while specifying a value
    of `"support"`, `"confidence"`, or `"lift"` to the `by` parameter. By combining
    the sort with vector operators, we can obtain a specific number of interesting
    rules. For instance, the best five rules according to the `lift` statistic can
    be examined using the following command:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 为了重新排序`groceryrules`对象，我们可以使用`sort()`函数，同时指定`by`参数的值为`"support"`、`"confidence"`或`"lift"`。通过将排序与向量运算符结合使用，我们可以获得特定数量的有趣规则。例如，可以使用以下命令检查根据`lift`统计量得出的最佳五条规则：
- en: '[PRE30]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The output is as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE31]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: These rules appear to be more interesting than the ones we looked at previously.
    The first rule, with a `lift` of about 3.96, implies that people who buy herbs
    are nearly four times more likely to buy root vegetables than the typical customer—
    perhaps for a stew of some sort. Rule two is also interesting. Whipped cream is
    over three times more likely to be found in a shopping cart with berries versus
    other carts, suggesting perhaps a dessert pairing.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: By default, the sort order is decreasing, meaning the largest values come first.
    To reverse this order, add an additional parameter, `decreasing = FALSE`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Taking subsets of association rules
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Suppose that, given the preceding rule, the marketing team is excited about
    the possibility of creating an advertisement to promote berries, which are now
    in season. Before finalizing the campaign, however, they ask you to investigate
    whether berries are often purchased with other items. To answer this question,
    we’ll need to find all the rules that include berries in some form.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: 'The `subset()` function provides a method for searching for subsets of transactions,
    items, or rules. To use it to find any rules with berries appearing in the rule,
    use the following command. This will store the rules in a new object named `berryrules`:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We can then inspect the rules as we had done with the larger set:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The result is the following set of rules:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: There are four rules involving berries, two of which seem to be interesting
    enough to be called actionable. In addition to whipped cream, berries are also
    purchased frequently with yogurt—a pairing that could serve well for breakfast
    or lunch, as well as dessert.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: 'The `subset()` function is very powerful. The criteria for choosing the subset
    can be defined with several keywords and operators:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: The keyword `items`, explained previously, matches an item appearing anywhere
    in the rule. To limit the subset to where the match occurs only on the left-hand
    side or right-hand side, use `lhs` or `rhs` instead.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The operator `%in%` means that at least one of the items must be found in the
    list you defined. If you wanted any rules matching either `berries` or `yogurt`,
    you could write `items %in% c("berries", "yogurt")`.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Additional operators are available for partial matching (`%pin%`) and complete
    matching (`%ain%`). Partial matching allows you to find both citrus fruit and
    tropical fruit using one search: `items %pin% "fruit"`. Complete matching requires
    that all listed items are present. For instance, `items %ain% c("berries", "yogurt")`
    finds only rules with both `berries` and `yogurt`.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Subsets can also be limited by `support`, `confidence`, or `lift`. For instance,
    `confidence > 0.50` would limit the rules to those with confidence greater than
    50 percent.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Matching criteria can be combined with standard R logical operators such as
    AND (`&`), OR (`|`), and NOT (`!`).
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using these options, you can limit the selection of rules to be as specific
    or general as you would like.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Saving association rules to a file or data frame
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To share the results of your market basket analysis, you can save the rules
    to a CSV file with the `write()` function. This will produce a CSV file that can
    be used in most spreadsheet programs, including Microsoft Excel:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Sometimes it is also convenient to convert the rules into an R data frame.
    This can be accomplished using the `as()` function, as follows:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This creates a data frame with the rules in character format, and numeric vectors
    for support, confidence, coverage, lift, and count:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Saving the rules to a data frame may be useful if you want to perform additional
    processing on the rules or need to export them to another database.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: Using the Eclat algorithm for greater efficiency
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Eclat algorithm**, which is named for its use of “equivalence class itemset
    clustering and bottom-up lattice traversal” methods, is a slightly more modern
    and substantially faster association rule learning algorithm. While the implementation
    details are outside the scope of this book, it can be understood as a close relative
    of Apriori; it too assumes all subsets of frequent itemsets are also frequent.
    However, Eclat is able to search even fewer subsets by utilizing clever tricks
    that provide shortcuts to identify the potentially maximal frequent itemsets and
    search only these itemsets’ subsets. Where Apriori is a form of a breadth-first
    algorithm because it searches wide before it searches deep, Eclat is considered
    a depth-first algorithm in that it dives to the final endpoint and searches only
    as wide as needed. For some use cases, this can lead to a performance gain of
    an order of magnitude and less memory consumed.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: For more information on Eclat, refer to *New Algorithms for Fast Discovery of
    Association Rules, Zaki, M. J., Parthasarathy, S., Ogihara, M., Li, W., KDD-97
    Proceedings, 1997*.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: A key tradeoff with Eclat’s fast searching is that it skips the phase in Apriori
    in which confidence is calculated. It assumes that once the itemsets with high
    support are obtained, the most useful associations can be identified later—whether
    manually via a subjective eyeball test, or via another round of processing to
    compute metrics like confidence and lift. This being said, the `arules` package
    makes it just as easy to apply Eclat as Apriori, despite the additional step in
    the process.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: 'We begin with the `eclat()` function and setting the `support` parameter to
    0.006 as before; however, note that the confidence is not set at this stage:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Some of the output is omitted here, but the last few lines are similar to what
    we obtained from the `apriori()` function, with the key exception that 747 itemsets
    were written rather than 463 rules:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The resulting Eclat itemset object can be used with the `inspect()` function
    as we did with the Apriori rules object. The following command shows the first
    five itemsets:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'To produce rules from the itemsets, use the `ruleInduction()` function with
    the desired `confidence` parameter value as follows:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 要从项集中生成规则，请使用 `ruleInduction()` 函数，并设置所需的 `confidence` 参数值，如下所示：
- en: '[PRE43]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'With `support` and `confidence` set to the earlier values of 0.006 and 0.25,
    respectively, it is no surprise that the Eclat algorithm produced the same set
    of 463 rules as Apriori:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `support` 和 `confidence` 设置为之前的值 0.006 和 0.25，Eclat 算法产生了与 Apriori 相同的 463
    条规则，这并不令人惊讶：
- en: '[PRE44]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The resulting rules object can be inspected just as before:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 结果的规则对象可以像之前一样进行检查：
- en: '[PRE46]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Given the ease of use with either method, if you have a very large transactional
    dataset, it may be worth testing Eclat and Apriori on smaller random samples of
    transactions to see if one outperforms the other.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 由于两种方法都易于使用，如果你有一个非常大的交易数据集，那么在较小的随机交易样本上测试 Eclat 和 Apriori 算法可能值得，以查看哪一个表现更好。
- en: Summary
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Association rules are used to find insight into the massive transaction databases
    of large retailers. As an unsupervised learning process, association rule learners
    are capable of extracting knowledge from large databases without any prior knowledge
    of what patterns to seek. The catch is that it takes some effort to reduce the
    wealth of information into a smaller and more manageable set of results. The Apriori
    algorithm, which we studied in this chapter, does so by setting minimum thresholds
    of interestingness and reporting only the associations meeting these criteria.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 关联规则用于发现大型零售商的大量交易数据库中的洞察。作为一个无监督学习过程，关联规则学习器能够从大型数据库中提取知识，而无需任何关于要寻找的模式的先验知识。难点在于需要付出一些努力，将丰富的信息减少到更小、更易于管理的结果集。我们在本章研究的
    Apriori 算法通过设置最小有趣性阈值，并仅报告满足这些标准的关联来实现这一点。
- en: We put the Apriori algorithm to work while performing a market basket analysis
    for a month’s worth of transactions at a modestly sized supermarket. Even in this
    small example, a wealth of associations was identified. Among these, we noted
    several patterns that may be useful for future marketing campaigns. The same methods
    we applied are used at much larger retailers on databases many times this size,
    and can also be applied to projects outside of a retail setting.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在为一家规模适中的超市进行一个月的交易市场篮子分析时使用了 Apriori 算法。即使在这样一个小例子中，也发现了大量的关联。在这些关联中，我们注意到了一些可能对未来的营销活动有用的模式。我们应用的方法在规模大得多的零售商处使用，其数据库规模是这个大小的多倍，也可以应用于零售环境之外的项目。
- en: In the next chapter, we will examine another unsupervised learning algorithm.
    Just like association rules, it is intended to find patterns within data. But
    unlike association rules that seek groups of related items or features, the methods
    in the next chapter are concerned with finding connections and relationships among
    the examples.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将检查另一个无监督学习算法。就像关联规则一样，它的目的是在数据中找到模式。但与寻求相关项目或特征的关联规则不同，下一章中的方法关注于在示例之间找到联系和关系。
- en: Join our book’s Discord space
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们书籍的 Discord 空间
- en: 'Join our Discord community to meet like-minded people and learn alongside more
    than 4000 people at:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社区，与志同道合的人见面，并在以下地方与超过 4000 人一起学习：
- en: '[https://packt.link/r](https://packt.link/r)'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/r](https://packt.link/r)'
- en: '![](img/r.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![](img/r.jpg)'
