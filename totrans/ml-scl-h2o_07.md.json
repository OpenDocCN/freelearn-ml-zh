["```py\ntrain, valid, test = loans.split_frame(\n```", "```py\n    seed = 25,\n```", "```py\n    ratios = [0.6, 0.2],\n```", "```py\n    destination_frames = [\"train\", \"valid\", \"test\"]\n```", "```py\n) \n```", "```py\ntrain_cv, test_cv = loans.split_frame(\n```", "```py\n    seed = 25,\n```", "```py\n    ratios = [0.8],\n```", "```py\n    destination_frames = [\"train_cv\", \"test_cv\"]\n```", "```py\n) \n```", "```py\nresponse = \"bad_loan\"\n```", "```py\nomit = [\"issue_d\", response]\n```", "```py\npredictors = list(set(loans.columns) - set(omit)) \n```", "```py\nfrom h2o.estimators.gbm import H2OGradientBoostingEstimator\n```", "```py\ngbm = H2OGradientBoostingEstimator(seed = 25)\n```", "```py\ngbm.train(x = predictors,\n```", "```py\n          y = response,\n```", "```py\n          training_frame = train,\n```", "```py\n          validation_frame = valid,\n```", "```py\n          model_id = \"gbm_baseline\")\n```", "```py\n%matplotlib inline\n```", "```py\ngbm.model_performance(train).plot()\n```", "```py\ngbm.model_performance(valid).plot()\n```", "```py\ngbm.model_performance(test).plot()\n```", "```py\nprint(gbm.model_performance(train).auc(),\n```", "```py\n      gbm.model_performance(valid).auc(),\n```", "```py\n      gbm.model_performance(test).auc())\n```", "```py\ngbm.auc(train = True, valid = True)\n```", "```py\ngbm.varimp_plot(20)\n```", "```py\nfrom h2o.estimators import H2OXGBoostEstimator\n```", "```py\nxgb = H2OXGBoostEstimator(nfolds = 5, seed = 25)\n```", "```py\nxgb.train(x = predictors,\n```", "```py\n          y = response,\n```", "```py\n          training_frame = train_cv,\n```", "```py\n          model_id = \"xgb\")\n```", "```py\nxgb.auc(train = True, xval = True)\n```", "```py\nxgb.model_performance(test_cv).auc()\n```", "```py\nperf = xgb.auc(train = True, xval = True)\n```", "```py\nperf[\"test\"] = xgb.model_performance(test_cv).auc()\n```", "```py\nperf\n```", "```py\nxgb.varimp_plot(20)\n```", "```py\n    from h2o.grid.grid_search import H2OGridSearch\n    hyperparams = {\n        \"max_depth\": list(range(2, 14, 2)) \n    }\n    ```", "```py\n    gbm_grid = H2OGradientBoostingEstimator(\n        ntrees = 10000,\n        stopping_metric = \"AUC\",\n        stopping_rounds = 5,\n        stopping_tolerance = 1e-4,\n        learn_rate = 0.05,\n        learn_rate_annealing = 0.99,\n        sample_rate = 0.8,\n        col_sample_rate = 0.8,\n        score_tree_interval = 10,\n        seed = 25\n    )\n    ```", "```py\n    grid = H2OGridSearch(\n        gbm_grid,\n        hyperparams,\n        grid_id = \"gbm_depth_grid\",\n        search_criteria = {\"strategy\": \"Cartesian\"}\n    )\n    ```", "```py\n    grid.train(x = predictors,\n               y = response,\n               training_frame = train,\n               validation_frame = valid)\n    ```", "```py\n    sorted_grid = grid.get_grid(\n        sort_by = \"auc\", decreasing = True)\n    print(sorted_grid)\n    ```", "```py\nhyperparams_tune = {\n```", "```py\n    \"max_depth\" : list(range(2, 6, 1)),\n```", "```py\n    \"sample_rate\" : [x/100\\. for x in range(20,101)],\n```", "```py\n    \"col_sample_rate\" : [x/100\\. for x in range(20,101)],\n```", "```py\n    \"min_split_improvement\": [0, 1e-8, 1e-6, 1e-4]\n```", "```py\n}\n```", "```py\nsearch_criteria_tune = {\n```", "```py\n    \"strategy\" : \"RandomDiscrete\",\n```", "```py\n    \"max_runtime_secs\" : 300,\n```", "```py\n    \"max_models\" : 10, \n```", "```py\n    \"stopping_rounds\" : 5,\n```", "```py\n    \"stopping_metric\" : \"AUC\",\n```", "```py\n    \"stopping_tolerance\" : 1e-3\n```", "```py\n}\n```", "```py\ngbm_final_grid = H2OGradientBoostingEstimator(\n```", "```py\n    ntrees = 10000,\n```", "```py\n    learn_rate = 0.05,\n```", "```py\n    learn_rate_annealing = 0.99,\n```", "```py\n    score_tree_interval = 10,\n```", "```py\n    seed = 12345\n```", "```py\n)\n```", "```py\nfinal_grid = H2OGridSearch(\n```", "```py\n    gbm_final_grid,\n```", "```py\n    hyper_params = hyperparams_tune,\n```", "```py\n    grid_id = \"gbm_final_grid\",\n```", "```py\n    search_criteria = search_criteria_tune)\n```", "```py\nfinal_grid.train(\n```", "```py\n    x = predictors,\n```", "```py\n    y = response,\n```", "```py\n    max_runtime_secs = 180,\n```", "```py\n    training_frame = train,\n```", "```py\n    validation_frame = valid\n```", "```py\n)\n```", "```py\ngrid = final_grid.get_grid(sort_by = \"auc\", \n```", "```py\n                           decreasing = True)\n```", "```py\ngrid\n```", "```py\nbest_gbm = grid.models[0]\n```", "```py\nperf = best_gbm.auc(train = True, valid = True)\n```", "```py\nperf[\"test\"] = best_gbm.model_performance(test).auc()\n```", "```py\nperf\n```", "```py\nfrom h2o.automl import H2OAutoML\n```", "```py\naml = H2OAutoML(max_models = 10,\n```", "```py\n                max_runtime_secs_per_model = 60,\n```", "```py\n                exclude_algos = [\"DeepLearning\"],\n```", "```py\n                seed = 25)\n```", "```py\naml.train(x = predictors, \n```", "```py\n          y = response, \n```", "```py\n          training_frame = train_cv)\n```", "```py\nprint(aml.leaderboard)\n```", "```py\nbest = aml.leader\n```", "```py\nperf = best.auc(train = True, xval = True)\n```", "```py\nperf[\"test\"] = best.model_performance(test_cv).auc()\n```", "```py\nperf\n```", "```py\nselect = h2o.get_model(aml.leaderboard[2, \"model_id\"])\n```", "```py\nperf = select.auc(train = True, xval = True)\n```", "```py\nperf[\"test\"] = select.model_performance(test_cv).auc()\n```", "```py\nperf\n```", "```py\nimport numpy as npdef sorted_table(colname, data = train_cv):\n```", "```py\n    tbl = data[colname].table().as_data_frame()\n```", "```py\n    tbl[\"Percent\"] = np.round((100 * tbl[\"Count\"]/data.nrows), 2)\n```", "```py\n    tbl = tbl.sort_values(by = \"Count\", ascending = 0)\n```", "```py\n    tbl = tbl.reset_index(drop = True)\n```", "```py\n    return(tbl) \n```", "```py\nsorted_table(\"purpose\")\n```", "```py\nsorted_table(\"addr_state\")\n```", "```py\n    from h2o.estimators import H2OTargetEncoderEstimator\n    encoded_columns = [\"purpose\", \"addr_state\"]\n    ```", "```py\n    train_cv[\"fold\"] = train_cv.kfold_column(\n        n_folds=5, seed=25)\n    ```", "```py\n    te = H2OTargetEncoderEstimator(\n        data_leakage_handling = \"k_fold\",\n        fold_column = \"fold\",\n        noise = 0.05,\n        blending = True,\n        inflection_point = 10,\n        smoothing = 20\n    )\n    ```", "```py\nte.train = (x = encoded_columns, y = response,\n    training_frame = train_cv)\n```", "```py\n    train_te = te.transform(frame = train_cv)\n    test_te = te.transform(frame = test_cv, noise = 0.0)\n    ```", "```py\n    train_te[\"purpose_te\"].hist()\n    ```", "```py\ntrain_te[\"addr_state_te\"].hist()\n```", "```py\n    predictors.extend([\"addr_state_te\", \"purpose_te\"])\n    ```", "```py\n    drop = [\"addr_state\", \"purpose\"]\n    predictors = [x for x in predictors if x not in drop]\n    ```", "```py\n    transformed = predictors.copy()\n    ```", "```py\n    train = train_te\n    test = test_te\n    ```", "```py\n    check = H2OAutoML(max_models = 10,\n                      max_runtime_secs_per_model = 60,\n                      exclude_algos = [\"DeepLearning\"],\n                      seed = 25)\n    check.train(x = transformed, \n                y = response, \n                training_frame = train)\n    check.leaderboard\n    ```", "```py\n    check_gbm = h2o.get_model(check.leaderboard[2, \"model_id\"])\n    check_gbm.varimp_plot(15)\n    ```", "```py\ncheck_xgb = h2o.get_model(check.leaderboard[5, \"model_id\"])\n```", "```py\ncheck_xgb.varimp_plot(15)\n```"]