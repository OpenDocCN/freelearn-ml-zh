["```py\nimport time \ndef sleep_func():\n    print('Sleeping for a 1 second')\n    time.sleep(1)\n    print('Done.')\nif __name__ == '__main__':\n    time_start = time.time()\n    # Run the function 5 times\n    sleep_func()\n    sleep_func()\n    sleep_func()\n    sleep_func()\n    sleep_func()\n    time_stop = time.time()\n    print(f'Took {round(time_stop - time_start, 2)} seconds to execute!')\n```", "```py\nSleeping for a 1 second\nDone.\nSleeping for a 1 second\nDone.\nSleeping for a 1 second\nDone.\nSleeping for a 1 second\nDone.\nSleeping for a 1 second\nDone.\nTook 5.02 seconds to execute!\n```", "```py\nimport time \ndef sleep_func():\n    print('Sleeping for a 1 second')\n    time.sleep(1)\n    print('Done.')\nif __name__ == '__main__':\n    time_start = time.time()\n    # Run the function 5 times in loop\n    for _ in range(5):\n        sleep_func()\n    time_stop = time.time()\n    print(f'Took {round(time_stop - time_start, 2)} seconds to execute!')\n```", "```py\nSleeping for a 1 second\nDone.\nSleeping for a 1 second\nDone.\nSleeping for a 1 second\nDone.\nSleeping for a 1 second\nDone.\nSleeping for a 1 second\nDone.\nTook 5.01 seconds to execute!\n```", "```py\nimport time \nfrom multiprocessing import Process\ndef sleep_func():\n    print('Sleeping for a 1 second')\n    time.sleep(1)\n    print('Done.')\nif __name__ == '__main__':\n    time_start = time.time()\n    process_1 = Process(target=sleep_func)\n    process_2 = Process(target=sleep_func)\n    process_3 = Process(target=sleep_func)\n    process_1.start()\n    process_2.start()\n    process_3.start()\n    process_1.join()\n    process_2.join()\n    process_3.join()\n    time_stop = time.time()\n    print(f'Took {round(time_stop - time_start, 2)} seconds to  execute!')\n```", "```py\nSleeping for a 1 second\nSleeping for a 1 second\nSleeping for a 1 second\nDone.\nDone.\nDone.\nTook 1.07 seconds to execute!\n```", "```py\nimport time \nimport concurrent.futures\ndef sleep_func():\n    print('Sleeping for a 1 second')\n    time.sleep(1)\n    return 'Done.'\nif __name__ == '__main__':\n    time_start = time.time()\n    with concurrent.futures.ProcessPoolExecutor() as ppe:\n        out = []\n        for _ in range(5):\n            out.append(ppe.submit(sleep_func))\n        for curr in concurrent.futures.as_completed(out):\n            print(curr.result())\n    time_stop = time.time()\n    print(f'Took {round(time_stop - time_start, 2)} seconds to execute!')\n```", "```py\nSleeping for a 1 second\nSleeping for a 1 second\nSleeping for a 1 second\nSleeping for a 1 second\nSleeping for a 1 second\nDone.\nDone.\nDone.\nDone.\nDone.\nTook 1.17 seconds to execute!\n```", "```py\nimport time \nimport concurrent.futures\ndef sleep_func(how_long: int):\n    print(f'Sleeping for a {how_long} seconds')\n    time.sleep(how_long)\n    return f'Finished sleeping for {how_long} seconds.'\nif __name__ == '__main__':\n    time_start = time.time()\n    sleep_seconds = [1, 2, 3, 1, 2, 3]\n    with concurrent.futures.ProcessPoolExecutor() as ppe:\n        out = []\n        for sleep_second in sleep_seconds:\n            out.append(ppe.submit(sleep_func, sleep_second))\n        for curr in concurrent.futures.as_completed(out):\n            print(curr.result())\n    time_stop = time.time()\n    print(f'Took {round(time_stop - time_start, 2)} seconds to execute!')\n```", "```py\nSleeping for 1 seconds\nSleeping for 2 seconds\nSleeping for 3 seconds\nSleeping for 1 seconds\nSleeping for 2 seconds\nSleeping for 3 seconds\nFinished sleeping for 1 seconds.\nFinished sleeping for 1 seconds.\nFinished sleeping for 2 seconds.\nFinished sleeping for 2 seconds.\nFinished sleeping for 3 seconds.\nFinished sleeping for 3 seconds.\nTook 3.24 seconds to execute!\n```", "```py\npipenv install \"dask[complete]\"\n```", "```py\n%%time\nimport numpy as np\nnp_ones = np.ones((1000, 1000, 1000))\n```", "```py\nCPU times: user 1.86 s, sys: 2.21 s, total: 4.07 s\nWall time: 4.35 s\n```", "```py\n%%time\nimport dask.array as da\nda_ones = da.ones((1000, 1000, 1000))\n```", "```py\nCPU times: user 677 µs, sys: 12 µs, total: 689 µs\nWall time: 696 µs \n```", "```py\nimport pandas as pd\nfrom datetime import datetime\nfor year in np.arange(2010, 2020):\n    dates = pd.date_range(\n        start=datetime(year=year, month=1, day=1),\n        end=datetime(year=year, month=12, day=31),\n        freq='S'\n    )\n    df = pd.DataFrame()\n    df['Date'] = dates\n    for i in range(5):\n        df[f'X{i}'] = np.random.randint(low=0, high=100, size=len(df))\n\n    df.to_csv(f'data/{year}.csv', index=False)\n!ls data/\n```", "```py\n2010.csv 2012.csv 2014.csv 2016.csv 2018.csv\n2011.csv 2013.csv 2015.csv 2017.csv 2019.csv\n```", "```py\n%%time\ndf = pd.read_csv('data/2010.csv', parse_dates=['Date'])\navg = df.groupby(by=df['Date'].dt.month).sum()\n```", "```py\nCPU times: user 26.5 s, sys: 9.7 s, total: 36.2 s\nWall time: 42 s\n```", "```py\n%%time\nimport glob\nall_files = glob.glob('data/*.csv')\ndfs = []\nfor fname in all_files:\n    dfs.append(pd.read_csv(fname, parse_dates=['Date']))\n\ndf = pd.concat(dfs, axis=0)\nagg = df.groupby(by=df['Date'].dt.year).sum()\n```", "```py\n%%time\nimport dask.dataframe as dd\ndf = dd.read_csv('data/*.csv', parse_dates=['Date'])\nagg = df.groupby(by=df['Date'].dt.year).sum().compute()\n```", "```py\nCPU times: user 5min 3s, sys: 1min 11s, total: 6min 15s\nWall time: 3min 41s\n```", "```py\nimport time\nimport dask\nimport math\nfrom dask import delayed, compute\n```", "```py\n%%time\ndef cube(number: int) -> int:\n    print(f'cube({number}) called!')\n    time.sleep(1)\n    return number ** 3\ndef multiply(items: list) -> int:\n    print(f'multiply([{items}]) called!')\n    return math.prod(items)\nnumbers = [1, 2, 3, 4, 5]\ngraph = multiply([cube(num) for num in numbers])\nprint(f'Total = {graph}')\n```", "```py\ncube(1) called!\ncube(2) called!\ncube(3) called!\ncube(4) called!\ncube(5) called!\nmultiply([[1, 8, 27, 64, 125]]) called!\nTotal = 1728000\nCPU times: user 8.04 ms, sys: 4 ms, total: 12 ms\nWall time: 5.02 s\n```", "```py\n%%time\n@delayed\ndef cube(number: int) -> int:\n    print(f'cube({number}) called!')\n    time.sleep(1)\n    return number ** 3\n@delayed\ndef multiply(items: list) -> int:\n    print(f'multiply([{items}]) called!')\n    return math.prod(items)\nnumbers = [1, 2, 3, 4, 5]\ngraph = multiply([cube(num) for num in numbers])\nprint(f'Total = {graph.compute()}')\n```", "```py\ncube(3) called!cube(2) called!cube(4) called!\ncube(1) called!\ncube(5) called!\nmultiply([[1, 8, 27, 64, 125]]) called!\nTotal = 1728000\nCPU times: user 6.37 ms, sys: 5.4 ms, total: 11.8 ms\nWall time: 1.01 s\n```", "```py\ngraph.visualize()\n```", "```py\npipenv install dask-ml\n```", "```py\n    import tpot\n    from tpot import TPOTClassifier\n    from sklearn.datasets import load_digits\n    from sklearn.model_selection import train_test_split\n    from dask.distributed import Client\n    import warnings\n    warnings.filterwarnings('ignore')\n    ```", "```py\n    client = Client()\n    client\n    ```", "```py\n    digits = load_digits()\n    X_train, X_test, y_train, y_test = train_test_split(\n        digits.data,\n        digits.target,\n        test_size=0.5,\n    )\n    X_train.shape, X_test.shape\n    ```", "```py\n    estimator = TPOTClassifier(\n        n_jobs=-1,\n        random_state=42,\n        use_dask=True,\n        verbosity=2,\n        max_time_mins=10\n    )\n    ```", "```py\n    estimator.fit(X_train, y_train)\n    ```"]