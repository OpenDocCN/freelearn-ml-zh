["```py\ndef intersection(hist0, hist1):\n    assert len(hist0) == len(hist1),\n            'Histogram lengths are mismatched'\n    result = 0\n    for i in range(len(hist0)):\n        result += min(hist0[i], hist1[i])\n    return result \n```", "```py\nmin(50%, 100%) + min(50%, 0%) = 50% = 0.5\n```", "```py\n#!/usr/bin/env python\n\nimport numpy # Hint to PyInstaller\nimport cv2\nimport scipy.io\nimport scipy.sparse\n```", "```py\nclass HistogramClassifier(object):\n\n    def __init__(self):\n\n        self.verbose = False\n        self.minimumSimilarityForPositiveLabel = 0.075\n\n        self._channels = range(3)\n        self._histSize = [256] * 3\n        self._ranges = [0, 255] * 3\n        self._references = {}\n```", "```py\n    def _createNormalizedHist(self, image, sparse):\n        # Create the histogram.\n        hist = cv2.calcHist([image], self._channels, None,\n                            self._histSize, self._ranges)\n        # Normalize the histogram.\n        hist[:] = hist * (1.0 / numpy.sum(hist))\n        # Convert the histogram to one column for efficient storage.\n        hist = hist.reshape(16777216, 1)  # 16777216 == pow(2, 24)\n        if sparse:\n            # Convert the histogram to a sparse matrix.\n            hist = scipy.sparse.csc_matrix(hist)\n        return hist\n```", "```py\n    def addReference(self, image, label):\n        hist = self._createNormalizedHist(image, True)\n        if label not in self._references:\n            self._references[label] = [hist]\n        else:\n            self._references[label] += [hist]\n```", "```py\n    def addReferenceFromFile(self, path, label):\n        image = cv2.imread(path, cv2.IMREAD_COLOR)\n        self.addReference(image, label)\n```", "```py\n    def classify(self, queryImage, queryImageName=None):\n        queryHist = self._createNormalizedHist(queryImage, False)\n        bestLabel = 'Unknown'\n        bestSimilarity = self.minimumSimilarityForPositiveLabel\n        if self.verbose:\n            print('================================================')\n            if queryImageName is not None:\n                print('Query image:')\n                print(' %s' % queryImageName)\n            print('Mean similarity to reference images by label:')\n        for label, referenceHists in self._references.items():\n            similarity = 0.0\n            for referenceHist in referenceHists:\n                similarity += cv2.compareHist(\n                        referenceHist.todense(), queryHist,\n                        cv2.HISTCMP_INTERSECT)\n            similarity /= len(referenceHists)\n            if self.verbose:\n                print(' %8f %s' % (similarity, label))\n            if similarity > bestSimilarity:\n                bestLabel = label\n                bestSimilarity = similarity\n        if self.verbose:\n            print('================================================')\n        return bestLabel\n```", "```py\n    def classifyFromFile(self, path, queryImageName=None):\n        if queryImageName is None:\n            queryImageName = path\n        queryImage = cv2.imread(path, cv2.IMREAD_COLOR)\n        return self.classify(queryImage, queryImageName)\n```", "```py\n    def serialize(self, path, compressed=False):\n        file = open(path, 'wb')\n        scipy.io.savemat(\n            file, self._references, do_compression=compressed)\n```", "```py\n    def deserialize(self, path):\n        file = open(path, 'rb')\n        self._references = scipy.io.loadmat(file)\n        for key in list(self._references.keys()):\n            value = self._references[key]\n            if not isinstance(value, numpy.ndarray):\n                # This entry is serialization metadata so delete it.\n                del self._references[key]\n                continue\n            # The serializer wraps the data in an extra array.\n            # Unwrap the data.\n            self._references[key] = value[0]\n```", "```py\ndef main():\n    classifier = HistogramClassifier()\n    classifier.verbose = True\n\n    # 'Stalinist, interior' reference images\n    classifier.addReferenceFromFile(\n            'images/communal_apartments_01.jpg',\n            'Stalinist, interior')\n    # ...\n    # Other reference images are omitted for brevity.\n    # See the GitHub repository for the full implementation.\n    # ...\n\n    classifier.serialize('classifier.mat')\n    classifier.deserialize('classifier.mat')\n    classifier.classifyFromFile('images/dubai_damac_heights.jpg')\n    classifier.classifyFromFile('images/communal_apartments_01.jpg')\n\nif __name__ == '__main__':\n    main()\n```", "```py\n#!/usr/bin/env python\n\nimport numpy # Hint to PyInstaller\nimport cv2\nimport requests\nimport sys\n```", "```py\n# Spoof a browser's User-Agent string.\n# Otherwise, some sites will reject us as a bot.\nHEADERS = {\n    'User-Agent': 'Mozilla/5.0 ' \\\n                  '(Macintosh; Intel Mac OS X 10.9; rv:25.0) ' \\\n                  'Gecko/20100101 Firefox/25.0'\n}\n```", "```py\ndef validateResponse(response):\n    statusCode = response.status_code\n    if statusCode == 200:\n        return True\n    url = response.request.url\n    sys.stderr.write(\n            'Received unexpected status code (%d) when requesting %s\\n' % \\\n            (statusCode, url))\n    return False\n```", "```py\ndef cvImageFromUrl(url):\n    response = requests.get(url, headers=HEADERS)\n    if not validateResponse(response):\n        return None\n    imageData = numpy.fromstring(response.content, numpy.uint8)\n    image = cv2.imdecode(imageData, cv2.IMREAD_COLOR)\n    if image is None:\n        sys.stderr.write(\n                'Failed to decode image from content of %s\\n' % url)\n    return image\n```", "```py\ndef main():\n    image = cvImageFromUrl('http://nummist.com/images/ceiling.gaze.jpg')\n    if image is not None:\n        cv2.imwrite('image.png', image)\n\nif __name__ == '__main__':\n    main()\n```", "```py\n$ pip install --user py-ms-cognitive\n```", "```py\n#!/usr/bin/env python\n\nfrom py_ms_cognitive import PyMsCognitiveImageSearch\nPyMsCognitiveImageSearch.SEARCH_IMAGE_BASE = \\\n        'https://api.cognitive.microsoft.com/bing/v7.0/images/search'\n\nimport numpy # Hint to PyInstaller\nimport cv2\nimport os\nimport pprint\nimport sys\n\nimport RequestsUtils\n```", "```py\nclass ImageSearchSession(object):\n\n    def __init__(self):\n        self.verbose = False\n\n        self._query = ''\n        self._results = []\n        self._offset = 0\n        self._numResultsRequested = 0\n        self._numResultsReceived = 0\n        self._numResultsAvailable = 0\n```", "```py\n    @property\n    def query(self):\n        return self._query\n\n    @property\n    def offset(self):\n        return self._offset\n\n    @property\n    def numResultsRequested(self):\n        return self._numResultsRequested\n\n    @property\n    def numResultsReceived(self):\n        return self._numResultsReceived\n\n    @property\n    def numResultsAvailable(self):\n        return self._numResultsAvailable\n```", "```py\n    def searchPrev(self):\n        if self._offset == 0:\n            return\n        offset = max(0, self._offset - self._numResultsRequested)\n        self.search(self._query, self._numResultsRequested, offset)\n\n    def searchNext(self):\n        if self._offset + self._numResultsRequested >= \\\n                self._numResultsAvailable:\n            return\n        offset = self._offset + self._numResultsRequested\n        self.search(self._query, self._numResultsRequested, offset)\n```", "```py\n    def search(self, query, numResultsRequested=50, offset=0):\n        if 'BING_SEARCH_KEY' in os.environ:\n            bingKey = os.environ['BING_SEARCH_KEY']\n        else:\n            sys.stderr.write(\n                    'Environment variable BING_SEARCH_KEY is undefined. '\n                    'Please define it, equal to your Bing Search API '\n                    'key.\\n')\n            return\n\n        self._query = query\n        self._numResultsRequested = numResultsRequested\n        self._offset = offset\n```", "```py\n        params = {'color':'ColorOnly', 'imageType':'Photo'}\n```", "```py\n        searchService = PyMsCognitiveImageSearch(\n                bingKey, query, custom_params=params)\n        searchService.current_offset = offset\n\n        try:\n            self._results = searchService.search(numResultsRequested,\n                                                 'json')\n        except Exception as e:\n            sys.stderr.write(\n                    'Error when requesting Bing image search for '\n                    '\"%s\":\\n' % query)\n            sys.stderr.write('%s\\n' % str(e))\n            self._offset = 0\n            self._numResultsReceived = 0\n            return\n```", "```py\n        json = searchService.most_recent_json\n        self._numResultsReceived = len(self._results)\n        if self._numResultsRequested < self._numResultsReceived:\n            # py_ms_cognitive modified the request to get more results.\n            self._numResultsRequested = self._numResultsReceived\n        self._numResultsAvailable = int(json[u'totalEstimatedMatches'])\n```", "```py\n        if self.verbose:\n            print('Received results of Bing image search for ' \n                  '\"%s\":' % query)\n            pprint.pprint(json)\n```", "```py\n    def getCvImageAndUrl(self, index, useThumbnail = False):\n        if index >= self._numResultsReceived:\n            return None, None\n        result = self._results[index]\n        if useThumbnail:\n            url = result.thumbnail_url\n        else:\n            url = result.content_url\n        return RequestsUtils.cvImageFromUrl(url), url\n```", "```py\ndef main():\n    session = ImageSearchSession()\n    session.verbose = True\n    session.search('luxury condo sales')\n    image, url = session.getCvImageAndUrl(0)\n    cv2.imwrite('image.png', image)\n\nif __name__ == '__main__':\n    main()\n```", "```py\nimport numpy # Hint to PyInstaller\nimport cv2\n```", "```py\ndef cvResizeAspectFill(src, maxSize,\n                       upInterpolation=cv2.INTER_LANCZOS4,\n                       downInterpolation=cv2.INTER_AREA):\n    h, w = src.shape[:2]\n    if w > h:\n        if w > maxSize:\n            interpolation=downInterpolation\n        else:\n            interpolation=upInterpolation\n        h = int(maxSize * h / float(w))\n        w = maxSize\n    else:\n        if h > maxSize:\n            interpolation=downInterpolation\n        else:\n            interpolation=upInterpolation\n        w = int(maxSize * w / float(h))\n        h = maxSize\n    dst = cv2.resize(src, (w, h), interpolation=interpolation)\n    return dst\n```", "```py\nimport numpy # Hint to PyInstaller\nimport cv2\nimport wx\n```", "```py\nWX_MAJOR_VERSION = int(wx.__version__.split('.')[0])\n```", "```py\ndef wxBitmapFromCvImage(image):\n    image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n    h, w = image.shape[:2]\n    # The following conversion fails on Raspberry Pi.\n    if WX_MAJOR_VERSION < 4:\n        bitmap = wx.BitmapFromBuffer(w, h, image)\n    else:\n        bitmap = wx.Bitmap.FromBuffer(w, h, image)\n    return bitmap\n```", "```py\nimport os\nimport sys\n```", "```py\ndef resourcePath(relativePath):\n    basePath = getattr(sys, '_MEIPASS', os.path.abspath('.'))\n    return os.path.join(basePath, relativePath)\n```", "```py\n#!/usr/bin/env python\n\nimport numpy # Hint to PyInstaller\nimport cv2\nimport os\nimport threading\nimport wx\n\nfrom HistogramClassifier import HistogramClassifier\nfrom ImageSearchSession import ImageSearchSession\nimport PyInstallerUtils\nimport ResizeUtils\nimport WxUtils\n```", "```py\nclass Luxocator(wx.Frame):\n\n    def __init__(self, classifierPath, maxImageSize=768,\n                 verboseSearchSession=False,\n                 verboseClassifier=False):\n\n        style = wx.CLOSE_BOX | wx.MINIMIZE_BOX | wx.CAPTION | \\\n            wx.SYSTEM_MENU | wx.CLIP_CHILDREN\n        wx.Frame.__init__(self, None, title='Luxocator', style=style)\n        self.SetBackgroundColour(wx.Colour(232, 232, 232))\n\n        self._maxImageSize = maxImageSize\n        border = 12\n        defaultQuery = 'luxury condo sales'\n\n        self._index = 0\n        self._session = ImageSearchSession()\n        self._session.verbose = verboseSearchSession\n        self._session.search(defaultQuery)\n\n        self._classifier = HistogramClassifier()\n        self._classifier.verbose = verboseClassifier\n        self._classifier.deserialize(classifierPath)\n\n        self.Bind(wx.EVT_CLOSE, self._onCloseWindow)\n\n        quitCommandID = wx.NewId()\n        self.Bind(wx.EVT_MENU, self._onQuitCommand,\n                  id=quitCommandID)\n        acceleratorTable = wx.AcceleratorTable([\n            (wx.ACCEL_NORMAL, wx.WXK_ESCAPE, quitCommandID)\n        ])\n        self.SetAcceleratorTable(acceleratorTable)\n```", "```py\n        self._searchCtrl = wx.SearchCtrl(\n                self, size=(self._maxImageSize / 3, -1),\n                style=wx.TE_PROCESS_ENTER)\n        self._searchCtrl.SetValue(defaultQuery)\n        self._searchCtrl.Bind(wx.EVT_TEXT_ENTER,\n                              self._onSearchEntered)\n        self._searchCtrl.Bind(wx.EVT_SEARCHCTRL_SEARCH_BTN,\n                              self._onSearchEntered)\n        self._searchCtrl.Bind(wx.EVT_SEARCHCTRL_CANCEL_BTN,\n                              self._onSearchCanceled)\n```", "```py\n        self._labelStaticText = wx.StaticText(self)\n\n        self._prevButton = wx.Button(self, label='Prev')\n        self._prevButton.Bind(wx.EVT_BUTTON,\n                              self._onPrevButtonClicked)\n\n        self._nextButton = wx.Button(self, label='Next')\n        self._nextButton.Bind(wx.EVT_BUTTON,\n                              self._onNextButtonClicked)\n\n        self._staticBitmap = wx.StaticBitmap(self)\n```", "```py\n        controlsSizer = wx.BoxSizer(wx.HORIZONTAL)\n        controlsSizer.Add(self._searchCtrl, 0,\n                          wx.ALIGN_CENTER_VERTICAL | wx.RIGHT,\n                          border)\n        controlsSizer.Add((0, 0), 1) # Spacer\n        controlsSizer.Add(\n                self._labelStaticText, 0, wx.ALIGN_CENTER_VERTICAL)\n        controlsSizer.Add((0, 0), 1) # Spacer\n        controlsSizer.Add(\n                self._prevButton, 0,\n                wx.ALIGN_CENTER_VERTICAL | wx.LEFT | wx.RIGHT,\n                border)\n        controlsSizer.Add(\n                self._nextButton, 0, wx.ALIGN_CENTER_VERTICAL)\n```", "```py\n        self._rootSizer = wx.BoxSizer(wx.VERTICAL)\n        self._rootSizer.Add(self._staticBitmap, 0,\n                            wx.TOP | wx.LEFT | wx.RIGHT, border)\n        self._rootSizer.Add(controlsSizer, 0, wx.EXPAND | wx.ALL,\n                            border)\n\n        self.SetSizerAndFit(self._rootSizer)\n\n        self._updateImageAndControls()\n```", "```py\n    @property\n    def verboseSearchSession(self):\n        return self._session.verbose\n\n    @verboseSearchSession.setter\n    def verboseSearchSession(self, value):\n        self._session.verbose = value\n\n    @property\n    def verboseClassifier(self):\n        return self._classifier.verbose\n\n    @verboseClassifier.setter\n    def verboseClassifier(self, value):\n        self._classifier.verbose = value\n```", "```py\n    def _onCloseWindow(self, event):\n        self.Destroy()\n```", "```py\n    def _onQuitCommand(self, event):\n        self.Close()\n```", "```py\n    def _onSearchEntered(self, event):\n        query = event.GetString()\n        if len(query) < 1:\n            return\n        self._session.search(query)\n        self._index = 0\n        self._updateImageAndControls()\n```", "```py\n    def _onSearchCanceled(self, event):\n        self._searchCtrl.Clear()\n```", "```py\n    def _onNextButtonClicked(self, event):\n        self._index += 1\n        if self._index >= self._session.offset + \\\n                self._session.numResultsReceived - 1:\n            self._session.searchNext()\n        self._updateImageAndControls()\n\n    def _onPrevButtonClicked(self, event):\n        self._index -= 1\n        if self._index < self._session.offset:\n            self._session.searchPrev()\n        self._updateImageAndControls()\n```", "```py\n    def _disableControls(self):\n        self._searchCtrl.Disable()\n        self._prevButton.Disable()\n        self._nextButton.Disable()\n```", "```py\n    def _enableControls(self):\n        self._searchCtrl.Enable()\n        if self._index > 0:\n            self._prevButton.Enable()\n        if self._index < self._session.numResultsAvailable - 1:\n            self._nextButton.Enable()\n```", "```py\n    def _updateImageAndControls(self):\n        # Disable the controls.\n        self._disableControls()\n        # Show the busy cursor.\n        wx.BeginBusyCursor()\n        # Get the image in a background thread.\n        threading.Thread(\n                target=self._updateImageAndControlsAsync).start()\n```", "```py\n    def _updateImageAndControlsAsync(self):\n        if self._session.numResultsRequested == 0:\n            image = None\n            label = 'Search had no results'\n        else:\n            # Get the current image.\n            image, url = self._session.getCvImageAndUrl(\n                self._index % self._session.numResultsRequested)\n            if image is None:\n                # Provide an error message.\n                label = 'Failed to decode image'\n            else:\n                # Classify the image.\n                label = self._classifier.classify(image, url)\n                # Resize the image while maintaining its aspect ratio.\n                image = ResizeUtils.cvResizeAspectFill(\n                    image, self._maxImageSize)\n        # Update the GUI on the main thread.\n        wx.CallAfter(self._updateImageAndControlsResync, image,\n                     label)\n```", "```py\n    def _updateImageAndControlsResync(self, image, label):\n        # Hide the busy cursor.\n        wx.EndBusyCursor()\n        if image is None:\n            # Provide a black bitmap.\n            bitmap = wx.Bitmap(self._maxImageSize,\n                               self._maxImageSize / 2)\n        else:\n            # Convert the image to bitmap format.\n            bitmap = WxUtils.wxBitmapFromCvImage(image)\n        # Show the bitmap.\n        self._staticBitmap.SetBitmap(bitmap)\n        # Show the label.\n        self._labelStaticText.SetLabel(label)\n        # Resize the sizer and frame.\n        self._rootSizer.Fit(self)\n        # Re-enable the controls.\n        self._enableControls()\n        # Refresh.\n        self.Refresh()\n```", "```py\ndef main():\n    os.environ['REQUESTS_CA_BUNDLE'] = \\\n            PyInstallerUtils.resourcePath('cacert.pem')\n    app = wx.App()\n    luxocator = Luxocator(\n            PyInstallerUtils.resourcePath('classifier.mat'),\n            verboseSearchSession=False, verboseClassifier=False)\n    luxocator.Show()\n    app.MainLoop()\n\nif __name__ == '__main__':\n    main()\n```", "```py\nrequests.exceptions.SSLError: [Errno 1] _ssl.c:510: error:14077410:SSL routines:SSL23_GET_SERVER_HELLO:sslv3 alert handshake failure\n```", "```py\n$ sudo apt-get install python-dev libssl-dev libffi-dev\n$ pip install --user pyopenssl==0.13.1 pyasn1 ndg-httpsclient\n```", "```py\na = Analysis(['Luxocator.py'],\n             pathex=['.'],\n             hiddenimports=[],\n             hookspath=None,\n             runtime_hooks=None)\n\n# Include SSL certificates for the sake of the 'requests' module.\na.datas.append(('cacert.pem', 'cacert.pem', 'DATA'))\n\n# Include our app's classifier data.\na.datas.append(('classifier.mat', 'classifier.mat', 'DATA'))\n\npyz = PYZ(a.pure)\n\nexe = EXE(pyz,\n          a.scripts,\n          a.binaries,\n          a.zipfiles,\n          a.datas,\n          name='Luxocator',\n          icon='win\\icon-windowed.ico',\n          debug=False,\n          strip=None,\n          upx=True,\n          console=False)\n\napp = BUNDLE(exe,\n             name='Luxocator.app',\n             icon=None)\n```", "```py\nset PYINSTALLER=pyinstaller\n\nREM Remove any previous build of the app.\nrmdir build /s /q\nrmdir dist /s /q\n\nREM Train the classifier.\npython HistogramClassifier.py\n\nREM Build the app.\n\"%PYINSTALLER%\" --onefile --windowed Luxocator.spec\n\nREM Make the app an executable.\nrename dist\\Luxocator Luxocator.exe\n```", "```py\n#!/usr/bin/env sh\n\n# Search for common names of PyInstaller in $PATH.\nif [ -x \"$(command -v \"pyinstaller\")\" ]; then\n    PYINSTALLER=pyinstaller\nelif [ -x \"$(command -v \"pyinstaller-3.6\")\" ]; then\n    PYINSTALLER=pyinstaller-3.6\nelif [ -x \"$(command -v \"pyinstaller-3.5\")\" ]; then\n    PYINSTALLER=pyinstaller-3.5\nelif [ -x \"$(command -v \"pyinstaller-3.4\")\" ]; then\n    PYINSTALLER=pyinstaller-3.4\nelif [ -x \"$(command -v \"pyinstaller-2.7\")\" ]; then\n    PYINSTALLER=pyinstaller-2.7\nelse\n    echo \"Failed to find PyInstaller in \\$PATH\"\n    exit 1\nfi\necho \"Found PyInstaller in \\$PATH with name \\\"$PYINSTALLER\\\"\"\n\n# Remove any previous build of the app.\nrm -rf build\nrm -rf dist\n\n# Train the classifier.\npython HistogramClassifier.py\n\n# Build the app.\n\"$PYINSTALLER\" --onefile --windowed Luxocator.spec\n\n# Determine the platform.\nplatform=`uname -s`\n\nif [ \"$platform\" = 'Darwin' ]; then\n    # We are on Mac.\n    # Copy custom metadata and resources into the app bundle.\n    cp -r mac/Contents dist/Luxocator.app\nfi\n```"]