<html><head></head><body>
<div id="_idContainer174">
<h1 class="chapter-number" id="_idParaDest-209"><a id="_idTextAnchor210"/><span class="koboSpan" id="kobo.1.1">10</span></h1>
<h1 id="_idParaDest-210"><a id="_idTextAnchor211"/><span class="koboSpan" id="kobo.2.1">Using the PID Algorithm to Follow Walls</span></h1>
<p><span class="koboSpan" id="kobo.3.1">We built a robot with multiple sensors and used distance sensors in </span><a href="B18001_08.xhtml#_idTextAnchor166"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.4.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.5.1">, </span><em class="italic"><span class="koboSpan" id="kobo.6.1">Sensing Distances to Detect Objects with Pico</span></em><span class="koboSpan" id="kobo.7.1">. </span><span class="koboSpan" id="kobo.7.2">We can use smarter algorithms with these sensors to make </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">smoother behaviors.</span></span></p>
<p><span class="koboSpan" id="kobo.9.1">In this chapter, we will investigate the PID algorithm, building its stages into something that will follow objects, then turning that into something that will follow a wall. </span><span class="koboSpan" id="kobo.9.2">We will use our new ability to graph over Bluetooth to tune the settings and get a smooth result. </span></p>
<p><span class="koboSpan" id="kobo.10.1">In this chapter, we will cover the following </span><span class="No-Break"><span class="koboSpan" id="kobo.11.1">main topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.12.1">Introducing the </span><span class="No-Break"><span class="koboSpan" id="kobo.13.1">PID algorithm</span></span></li>
<li><span class="koboSpan" id="kobo.14.1">Using a PID to follow </span><span class="No-Break"><span class="koboSpan" id="kobo.15.1">a wall</span></span></li>
<li><span class="koboSpan" id="kobo.16.1">PID tuning – using graphs to tune </span><span class="No-Break"><span class="koboSpan" id="kobo.17.1">the PID</span></span></li>
</ul>
<h1 id="_idParaDest-211"><a id="_idTextAnchor212"/><span class="koboSpan" id="kobo.18.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.19.1">You will need the following items for </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">this chapter:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.21.1">The robot and code from </span><a href="B18001_09.xhtml#_idTextAnchor189"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.22.1">Chapter 9</span></em></span></a><span class="koboSpan" id="kobo.23.1">, </span><em class="italic"><span class="koboSpan" id="kobo.24.1">Teleoperating Raspberry Pi Pico Robot with </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.25.1">Bluetooth LE</span></em></span></li>
<li><span class="koboSpan" id="kobo.26.1">An open space with room to move, and objects suitable </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">for following</span></span></li>
<li><span class="koboSpan" id="kobo.28.1">An Android/iOS device with the </span><span class="No-Break"><span class="koboSpan" id="kobo.29.1">Bluefruit app</span></span></li>
<li><span class="koboSpan" id="kobo.30.1">A hand screwdriver with a 2 </span><span class="No-Break"><span class="koboSpan" id="kobo.31.1">mm bit</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.32.1">Digital calipers</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.33.1">A pencil</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.34.1">You can find the code for this chapter </span><span class="No-Break"><span class="koboSpan" id="kobo.35.1">at </span></span><a href="https://github.com/PacktPublishing/Robotics-at-Home-with-Raspberry-Pi-Pico/tree/main/ch-10"><span class="No-Break"><span class="koboSpan" id="kobo.36.1">https://github.com/PacktPublishing/Robotics-at-Home-with-Raspberry-Pi-Pico/tree/main/ch-10</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.37.1">.</span></span></p>
<h1 id="_idParaDest-212"><a id="_idTextAnchor213"/><span class="koboSpan" id="kobo.38.1">Introducing the PID algorithm</span></h1>
<p><span class="koboSpan" id="kobo.39.1">In this section, we will introduce the different</span><a id="_idIndexMarker562"/><span class="koboSpan" id="kobo.40.1"> parts of the PID algorithm while building on what you have </span><span class="No-Break"><span class="koboSpan" id="kobo.41.1">already seen.</span></span></p>
<h2 id="_idParaDest-213"><a id="_idTextAnchor214"/><span class="koboSpan" id="kobo.42.1">Control and feedback</span></h2>
<p><span class="koboSpan" id="kobo.43.1">Controlling robot </span><a id="_idIndexMarker563"/><span class="koboSpan" id="kobo.44.1">systems generally depends on feedback loops like the </span><span class="No-Break"><span class="koboSpan" id="kobo.45.1">following one:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer156">
<span class="koboSpan" id="kobo.46.1"><img alt="Figure 10.1 – Control and feedback loop " src="image/Figure_10.01_B18001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.47.1">Figure 10.1 – Control and feedback loop</span></p>
<p><span class="koboSpan" id="kobo.48.1">The preceding figure shows data from the sensors going into a control algorithm. </span><span class="koboSpan" id="kobo.48.2">The algorithm controls the motor as its output. </span><span class="koboSpan" id="kobo.48.3">The motor will cause the robot to move. </span><span class="koboSpan" id="kobo.48.4">This movement leads to a feedback loop as the sensor reading changes and goes through the cycle again. </span><span class="koboSpan" id="kobo.48.5">This concept is known </span><a id="_idIndexMarker564"/><span class="koboSpan" id="kobo.49.1">as </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.50.1">closed-loop control</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.51.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.52.1">This closed-loop lets the robot interact with the real world, adjusting its behavior to produce the </span><span class="No-Break"><span class="koboSpan" id="kobo.53.1">desired result.</span></span></p>
<p><span class="koboSpan" id="kobo.54.1">We built a simple system like this for our distance sensors. </span><span class="koboSpan" id="kobo.54.2">We’ll look more closely at that </span><span class="No-Break"><span class="koboSpan" id="kobo.55.1">system next.</span></span></p>
<h2 id="_idParaDest-214"><a id="_idTextAnchor215"/><span class="koboSpan" id="kobo.56.1">Bang-bang control</span></h2>
<p><span class="koboSpan" id="kobo.57.1">In the examples </span><a id="_idIndexMarker565"/><span class="koboSpan" id="kobo.58.1">provided in </span><a href="B18001_08.xhtml#_idTextAnchor166"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.59.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.60.1">, </span><em class="italic"><span class="koboSpan" id="kobo.61.1">Sensing Distances to Detect Objects with Pico</span></em><span class="koboSpan" id="kobo.62.1">, the system compared the distance sensors on our robot against a threshold. </span><span class="koboSpan" id="kobo.62.2">For example, look at the </span><span class="No-Break"><span class="koboSpan" id="kobo.63.1">following diagram:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer157">
<span class="koboSpan" id="kobo.64.1"><img alt="Figure 10.2 – Bang-bang motor control " src="image/Figure_10.02_B18001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.65.1">Figure 10.2 – Bang-bang motor control</span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.66.1">Figure 10</span></em></span><em class="italic"><span class="koboSpan" id="kobo.67.1">.2</span></em><span class="koboSpan" id="kobo.68.1"> summarizes </span><strong class="bold"><span class="koboSpan" id="kobo.69.1">bang-bang control</span></strong><span class="koboSpan" id="kobo.70.1">. </span><span class="koboSpan" id="kobo.70.2">This control system has two modes. </span><span class="koboSpan" id="kobo.70.3">If</span><a id="_idIndexMarker566"/><span class="koboSpan" id="kobo.71.1"> the actual measurement is above the expected value and too far away, it will drive forward; otherwise, it assumes that it is below the value and too close and will drive backward. </span><span class="koboSpan" id="kobo.71.2">It will always drive in one of the directions and at a fixed motor power. </span><span class="koboSpan" id="kobo.71.3">Controlling </span><a id="_idIndexMarker567"/><span class="koboSpan" id="kobo.72.1">with only a fixed power is known as </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.73.1">constant correction</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.74.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.75.1">This method is simple and suitable in some situations, but occasionally, something smoother is needed. </span><span class="koboSpan" id="kobo.75.2">What if we wanted the robot’s motor power to change depending on how far away it is from the object? </span><span class="koboSpan" id="kobo.75.3">We’ll need to calculate an error value, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.76.1">following diagram:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer158">
<span class="koboSpan" id="kobo.77.1"><img alt="Figure 10.3 – Calculating an error value " src="image/Figure_10.03_B18001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.78.1">Figure 10.3 – Calculating an error value</span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.79.1">Figure 10</span></em></span><em class="italic"><span class="koboSpan" id="kobo.80.1">.3</span></em><span class="koboSpan" id="kobo.81.1"> shows how we calculate the error value. </span><span class="koboSpan" id="kobo.81.2">By subtracting the actual value from the expected, we will get the error. </span><span class="koboSpan" id="kobo.81.3">This error will change in magnitude, depending on how different things are, and change in direction, depending on which side of the expected measurement the actual </span><span class="No-Break"><span class="koboSpan" id="kobo.82.1">measurement falls.</span></span></p>
<p><span class="koboSpan" id="kobo.83.1">If we multiply this </span><a id="_idIndexMarker568"/><span class="koboSpan" id="kobo.84.1">error by some value, this could be turned into a motor speed, such that a higher magnitude error will lead to a larger motor movement. </span><span class="koboSpan" id="kobo.84.2">This process will form the feedback control loop </span><span class="No-Break"><span class="koboSpan" id="kobo.85.1">shown here:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer159">
<span class="koboSpan" id="kobo.86.1"><img alt="Figure 10.4 – A proportional feedback loop " src="image/Figure_10.04_B18001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.87.1">Figure 10.4 – A proportional feedback loop</span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.88.1">Figure 10</span></em></span><em class="italic"><span class="koboSpan" id="kobo.89.1">.4</span></em><span class="koboSpan" id="kobo.90.1"> builds upon </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.91.1">Figure 10</span></em></span><em class="italic"><span class="koboSpan" id="kobo.92.1">.1</span></em><span class="koboSpan" id="kobo.93.1">, feeding an error value through a multiplier (or gain) to calculate the motor speed, which moves the robot. </span><span class="koboSpan" id="kobo.93.2">Robot movement feedback changes the sensor reading. </span><span class="koboSpan" id="kobo.93.3">With the right gain value, this robot will slow down as it approaches </span><span class="No-Break"><span class="koboSpan" id="kobo.94.1">the object.</span></span></p>
<p><span class="koboSpan" id="kobo.95.1">Multiplying the error value to control the output like this is known </span><a id="_idIndexMarker569"/><span class="koboSpan" id="kobo.96.1">as </span><strong class="bold"><span class="koboSpan" id="kobo.97.1">proportional control</span></strong><span class="koboSpan" id="kobo.98.1">, which is one part of the system we are building. </span><span class="koboSpan" id="kobo.98.2">The amount by which we multiply </span><a id="_idIndexMarker570"/><span class="koboSpan" id="kobo.99.1">the </span><a id="_idIndexMarker571"/><span class="koboSpan" id="kobo.100.1">error is known as the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.101.1">proportional gain</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.102.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.103.1">At this point, I think we are ready to write the code </span><span class="No-Break"><span class="koboSpan" id="kobo.104.1">for this.</span></span></p>
<h2 id="_idParaDest-215"><a id="_idTextAnchor216"/><span class="koboSpan" id="kobo.105.1">Distance sensing with proportional control</span></h2>
<p><span class="koboSpan" id="kobo.106.1">In this section, we’ll write code</span><a id="_idIndexMarker572"/><span class="koboSpan" id="kobo.107.1"> to approach an object and maintain the expected distance from the object. </span><span class="koboSpan" id="kobo.107.2">Create a folder on the host named </span><strong class="source-inline"><span class="koboSpan" id="kobo.108.1">proportional-distance-control</span></strong><span class="koboSpan" id="kobo.109.1">. </span><span class="koboSpan" id="kobo.109.2">We’ll copy the content of this folder into the top directory on the Pico. </span><span class="koboSpan" id="kobo.109.3">We can also copy the robot and </span><strong class="source-inline"><span class="koboSpan" id="kobo.110.1">pio_encoder</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.111.1">files there.</span></span></p>
<p><span class="koboSpan" id="kobo.112.1">Add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.113.1">code.py</span></strong><span class="koboSpan" id="kobo.114.1"> file, starting with imports and enabling </span><span class="No-Break"><span class="koboSpan" id="kobo.115.1">the UART:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.116.1">
import time
import board
import busio
import robot
uart = busio.UART(board.GP12, board.GP13, baudrate=9600)</span></pre>
<p><span class="koboSpan" id="kobo.117.1">Now, we can add our proportional controller as </span><span class="No-Break"><span class="koboSpan" id="kobo.118.1">a class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.119.1">
class PController:
    def __init__(self, kp):
        self.kp = kp
   def calculate(self, error):
        return self.kp * error</span></pre>
<p><span class="koboSpan" id="kobo.120.1">This code lets us make proportional controller (</span><strong class="source-inline"><span class="koboSpan" id="kobo.121.1">PController</span></strong><span class="koboSpan" id="kobo.122.1">) objects with a proportional gain, </span><strong class="source-inline"><span class="koboSpan" id="kobo.123.1">kp</span></strong><span class="koboSpan" id="kobo.124.1">. </span><span class="koboSpan" id="kobo.124.2">We can call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.125.1">calculate</span></strong><span class="koboSpan" id="kobo.126.1"> method with an error value to get the </span><span class="No-Break"><span class="koboSpan" id="kobo.127.1">control value.</span></span></p>
<p><span class="koboSpan" id="kobo.128.1">Let’s set up </span><span class="No-Break"><span class="koboSpan" id="kobo.129.1">a sensor:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.130.1">
robot.right_distance.distance_mode = 1
robot.right_distance.start_ranging()
distance_set_point = 10
distance_controller = PController(-0.1)</span></pre>
<p><span class="koboSpan" id="kobo.131.1">We make a set point of 10 cm for our expected distance. </span><span class="koboSpan" id="kobo.131.2">Then, we have our </span><strong class="source-inline"><span class="koboSpan" id="kobo.132.1">distance_controller</span></strong><span class="koboSpan" id="kobo.133.1">, which is using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.134.1">PController</span></strong><span class="koboSpan" id="kobo.135.1"> object. </span></p>
<p><span class="koboSpan" id="kobo.136.1">When our robot is further away, we need to drive forward, so we need to use a negative proportional gain. </span><span class="koboSpan" id="kobo.136.2">The motor speeds are between -1 and 1, so -0.1 will reduce the distance by a tenth and </span><span class="No-Break"><span class="koboSpan" id="kobo.137.1">negate it.</span></span></p>
<p><span class="koboSpan" id="kobo.138.1">The main </span><a id="_idIndexMarker573"/><span class="koboSpan" id="kobo.139.1">loop will only check the </span><strong class="source-inline"><span class="koboSpan" id="kobo.140.1">PController</span></strong><span class="koboSpan" id="kobo.141.1"> when there’s a new </span><span class="No-Break"><span class="koboSpan" id="kobo.142.1">distance reading:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.143.1">
while True:
  if robot.right_distance.data_ready:
    distance = robot.right_distance.distance</span></pre>
<p><span class="koboSpan" id="kobo.144.1">We can use this with the set point to calculate the error and feed it into the </span><span class="No-Break"><span class="koboSpan" id="kobo.145.1">proportional controller:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.146.1">
    error = distance_set_point – distance
    speed = distance_controller.calculate(error)
    uart.write(f"{error},{speed}\n".encode())</span></pre>
<p><span class="koboSpan" id="kobo.147.1">While we’re here, we can send the numbers to the UART (so that we can plot them). </span><span class="koboSpan" id="kobo.147.2">We have a speed from the error. </span><span class="koboSpan" id="kobo.147.3">Now, we can send this speed to </span><span class="No-Break"><span class="koboSpan" id="kobo.148.1">both motors:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.149.1">
    robot.set_left(speed)
    robot.set_right(speed)</span></pre>
<p><span class="koboSpan" id="kobo.150.1">Finally, we must reset the sensor for another reading and delay it </span><span class="No-Break"><span class="koboSpan" id="kobo.151.1">a little:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.152.1">
    robot.right_distance.clear_interrupt()
    time.sleep(0.05)</span></pre>
<p><span class="koboSpan" id="kobo.153.1">Send this code to the robot. </span><span class="koboSpan" id="kobo.153.2">If you place an object in front of the robot, it will find and hold a position about 10 cm from the object. </span><span class="koboSpan" id="kobo.153.3">You should also be able to plot the output. </span></p>
<p><span class="koboSpan" id="kobo.154.1">The motors here may be beeping a lot; this is not good for them and will make them hot. </span><span class="koboSpan" id="kobo.154.2">We can use code to establish a </span><strong class="bold"><span class="koboSpan" id="kobo.155.1">dead zone</span></strong><span class="koboSpan" id="kobo.156.1">, where </span><a id="_idIndexMarker574"/><span class="koboSpan" id="kobo.157.1">we expect the control output to be too small for the motors to respond and turn them </span><span class="No-Break"><span class="koboSpan" id="kobo.158.1">off instead.</span></span></p>
<p><span class="koboSpan" id="kobo.159.1">Add the following code after the speed calculation to stop </span><span class="No-Break"><span class="koboSpan" id="kobo.160.1">the beeping:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.161.1">
    if abs(speed) &lt; 0.3:
      speed = 0</span></pre>
<p><span class="koboSpan" id="kobo.162.1">This code uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.163.1">abs</span></strong><span class="koboSpan" id="kobo.164.1"> to get the magnitude of the speed only. </span><span class="koboSpan" id="kobo.164.2">If the magnitude is below 0.3, it</span><a id="_idIndexMarker575"/><span class="koboSpan" id="kobo.165.1"> sends a </span><strong class="source-inline"><span class="koboSpan" id="kobo.166.1">0</span></strong><span class="koboSpan" id="kobo.167.1"> instead. </span><span class="koboSpan" id="kobo.167.2">I found </span><strong class="source-inline"><span class="koboSpan" id="kobo.168.1">0.3</span></strong><span class="koboSpan" id="kobo.169.1"> experimentally, but this may be different on </span><span class="No-Break"><span class="koboSpan" id="kobo.170.1">your robot.</span></span></p>
<p><span class="koboSpan" id="kobo.171.1">Before continuing, you should test this on the robot and check the next section if this behavior did not try to find the distance to </span><span class="No-Break"><span class="koboSpan" id="kobo.172.1">the object.</span></span></p>
<h2 id="_idParaDest-216"><a id="_idTextAnchor217"/><span class="koboSpan" id="kobo.173.1">Troubleshooting</span></h2>
<p><span class="koboSpan" id="kobo.174.1">The following are some </span><a id="_idIndexMarker576"/><span class="koboSpan" id="kobo.175.1">solutions to try if you aren’t getting the follow behavior </span><span class="No-Break"><span class="koboSpan" id="kobo.176.1">to work:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.177.1">First, check the distance sensor functionality using the </span><a href="B18001_08.xhtml#_idTextAnchor166"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.178.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.179.1"> code. </span><span class="koboSpan" id="kobo.179.2">Then, verify the sensor and </span><span class="No-Break"><span class="koboSpan" id="kobo.180.1">motor connections.</span></span></li>
<li><span class="koboSpan" id="kobo.181.1">If the robot is driving the wrong way, reverse the </span><span class="No-Break"><span class="koboSpan" id="kobo.182.1">proportional constant.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.183.1">There is a problem where this robot may get close to the right place but leave a gap for small distances. </span><span class="koboSpan" id="kobo.183.2">As a result, it might not generate a speed large enough to move the motors. </span><span class="koboSpan" id="kobo.183.3">In the next section, we’ll </span><span class="No-Break"><span class="koboSpan" id="kobo.184.1">see why.</span></span></p>
<h2 id="_idParaDest-217"><a id="_idTextAnchor218"/><span class="koboSpan" id="kobo.185.1">Using the integral to handle small distances</span></h2>
<p><span class="koboSpan" id="kobo.186.1">The </span><a id="_idIndexMarker577"/><span class="koboSpan" id="kobo.187.1">following graph shows a small error remaining </span><span class="No-Break"><span class="koboSpan" id="kobo.188.1">after activity:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer160">
<span class="koboSpan" id="kobo.189.1"><img alt="Figure 10.5 – Small remaining error " src="image/Figure_10.05_B18001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.190.1">Figure 10.5 – Small remaining error</span></p>
<p><span class="koboSpan" id="kobo.191.1">The preceding figure shows a graph of the error and motor output versus time. </span><span class="koboSpan" id="kobo.191.2">The error line varies by up to 10 units. </span><span class="koboSpan" id="kobo.191.3">The motor graph is more flat. </span><span class="koboSpan" id="kobo.191.4">This line is between 0 and 1 and in the opposite direction, as expected from the proportional experiment. </span><span class="koboSpan" id="kobo.191.5">The graph is divided into two portions. </span><span class="koboSpan" id="kobo.191.6">Portion A shows the robot moving as we move an object closer and further away, with the motor responding. </span><span class="koboSpan" id="kobo.191.7">In portion B, we gradually move the object, creating a small error of -1. </span><span class="koboSpan" id="kobo.191.8">This small error results in a speed of 0.1, which is insufficient to move. </span></p>
<p><span class="koboSpan" id="kobo.192.1">What we </span><a id="_idIndexMarker578"/><span class="koboSpan" id="kobo.193.1">have is a </span><strong class="bold"><span class="koboSpan" id="kobo.194.1">steady-state error</span></strong><span class="koboSpan" id="kobo.195.1">. </span><span class="koboSpan" id="kobo.195.2">The </span><a id="_idIndexMarker579"/><span class="koboSpan" id="kobo.196.1">system has not converged on the set point and will not act further to reduce </span><span class="No-Break"><span class="koboSpan" id="kobo.197.1">the error.</span></span></p>
<p><span class="koboSpan" id="kobo.198.1">This situation is where the integral element is useful. </span><span class="koboSpan" id="kobo.198.2">The </span><strong class="bold"><span class="koboSpan" id="kobo.199.1">integral</span></strong><span class="koboSpan" id="kobo.200.1"> is </span><a id="_idIndexMarker580"/><span class="koboSpan" id="kobo.201.1">equivalent to an area under a graph. </span><span class="koboSpan" id="kobo.201.2">Look at the following graph for </span><span class="No-Break"><span class="koboSpan" id="kobo.202.1">an example:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer161">
<span class="koboSpan" id="kobo.203.1"><img alt="Figure 10.6 – Plotting the integral " src="image/Figure_10.06_B18001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.204.1">Figure 10.6 – Plotting the integral</span></p>
<p><span class="koboSpan" id="kobo.205.1">This</span><a id="_idIndexMarker581"/><span class="koboSpan" id="kobo.206.1"> graph has two elements. </span><span class="koboSpan" id="kobo.206.2">The bars represent the error value from the previous graph, approximated as discrete time steps. </span><span class="koboSpan" id="kobo.206.3">Then, there’s the thick line over this, which represents the integral. </span><span class="koboSpan" id="kobo.206.4">While the graph varies, the integral varies perhaps a little later. </span><span class="koboSpan" id="kobo.206.5">However, when it reaches a steady state, the graph starts to pull </span><span class="No-Break"><span class="koboSpan" id="kobo.207.1">downwards continuously.</span></span></p>
<p><span class="koboSpan" id="kobo.208.1">If we take this and multiply it by another small constant, we can cause the motors to move a little to iron out a steady-state error. </span><span class="koboSpan" id="kobo.208.2">We call this</span><a id="_idIndexMarker582"/><span class="koboSpan" id="kobo.209.1"> the </span><strong class="bold"><span class="koboSpan" id="kobo.210.1">integral gain</span></strong><span class="koboSpan" id="kobo.211.1">, or </span><strong class="source-inline"><span class="koboSpan" id="kobo.212.1">ki</span></strong><span class="koboSpan" id="kobo.213.1">. </span><span class="koboSpan" id="kobo.213.2">The following diagram shows the control system with the </span><span class="No-Break"><span class="koboSpan" id="kobo.214.1">integral term:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer162">
<span class="koboSpan" id="kobo.215.1"><img alt="Figure 10.7 – The feedback loop with the integral " src="image/Figure_10.07_B18001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.216.1">Figure 10.7 – The feedback loop with the integral</span></p>
<p><span class="koboSpan" id="kobo.217.1">The </span><a id="_idIndexMarker583"/><span class="koboSpan" id="kobo.218.1">preceding diagram shows the feedback loop control system with the integral added – this box shows </span><em class="italic"><span class="koboSpan" id="kobo.219.1">I * ki</span></em><span class="koboSpan" id="kobo.220.1">, the integral multiplied by an integral gain. </span><span class="koboSpan" id="kobo.220.2">It feeds into the motor speed, which is added to the proportional output. </span><span class="koboSpan" id="kobo.220.3">The integral is given the same error term as the </span><span class="No-Break"><span class="koboSpan" id="kobo.221.1">proportional element.</span></span></p>
<p><span class="koboSpan" id="kobo.222.1">The integral will store the area of the error graph seen until this point. </span><span class="koboSpan" id="kobo.222.2">This would be the area under a graph. </span><span class="koboSpan" id="kobo.222.3">How do we calculate the area? </span><span class="koboSpan" id="kobo.222.4">We can take each error and multiply it by the time interval during which it was produced. </span><span class="koboSpan" id="kobo.222.5">Adding this to a running total represents a good approximation of </span><span class="No-Break"><span class="koboSpan" id="kobo.223.1">the area.</span></span></p>
<p><span class="koboSpan" id="kobo.224.1">The following code extends the </span><span class="No-Break"><span class="koboSpan" id="kobo.225.1">previous example.</span></span></p>
<p><span class="koboSpan" id="kobo.226.1">Let’s update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.227.1">PController</span></strong><span class="koboSpan" id="kobo.228.1"> code so that it’s a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.229.1">PIController</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.230.1"> class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.231.1">
class </span><strong class="bold"><span class="koboSpan" id="kobo.232.1">PIC</span></strong><span class="koboSpan" id="kobo.233.1">ontroller:
    def __init__(self, kp</span><strong class="bold"><span class="koboSpan" id="kobo.234.1">, ki</span></strong><span class="koboSpan" id="kobo.235.1">):
        self.kp = kp
</span><strong class="bold"><span class="koboSpan" id="kobo.236.1">        self.ki = ki</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.237.1">        self.integral = 0</span></strong></pre>
<p><span class="koboSpan" id="kobo.238.1">In the preceding code, we added </span><strong class="source-inline"><span class="koboSpan" id="kobo.239.1">ki</span></strong><span class="koboSpan" id="kobo.240.1"> as an integral gain to scale our integral. </span><span class="koboSpan" id="kobo.240.2">We also store an integral total, starting </span><span class="No-Break"><span class="koboSpan" id="kobo.241.1">at </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.242.1">0</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.243.1">.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.244.1">Important Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.245.1">Prefixing gain constants like these with </span><em class="italic"><span class="koboSpan" id="kobo.246.1">k</span></em><span class="koboSpan" id="kobo.247.1"> is due to them being treated as </span><em class="italic"><span class="koboSpan" id="kobo.248.1">constants</span></em><span class="koboSpan" id="kobo.249.1"> by the PID algorithm, but the outer code can tune these. </span><span class="koboSpan" id="kobo.249.2">So, mathematically, this is a constant, but not a constant in </span><span class="No-Break"><span class="koboSpan" id="kobo.250.1">the code.</span></span></p>
<p><span class="koboSpan" id="kobo.251.1">Then, we must change the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.252.1">calculate</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.253.1"> method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.254.1">
    def calculate(self, error</span><strong class="bold"><span class="koboSpan" id="kobo.255.1">, dt</span></strong><span class="koboSpan" id="kobo.256.1">):
</span><strong class="bold"><span class="koboSpan" id="kobo.257.1">        self.integral += error * dt</span></strong><span class="koboSpan" id="kobo.258.1">
        return self.kp * error</span><strong class="bold"><span class="koboSpan" id="kobo.259.1"> + self.ki * self.integral</span></strong></pre>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.260.1">calculate</span></strong><span class="koboSpan" id="kobo.261.1"> now adds the error to the integral, which means the integral will continue moving in the error direction. </span><span class="koboSpan" id="kobo.261.2">However, we will multiply this by the elapsed time (or delta time, </span><strong class="source-inline"><span class="koboSpan" id="kobo.262.1">dt</span></strong><span class="koboSpan" id="kobo.263.1">), so that a longer interval between measurements will result in a larger area. </span><span class="koboSpan" id="kobo.263.2">The last line multiplies the current integral by the </span><span class="No-Break"><span class="koboSpan" id="kobo.264.1">integral gain.</span></span></p>
<p><span class="koboSpan" id="kobo.265.1">We’ll need to set the integral constant when we create </span><span class="No-Break"><span class="koboSpan" id="kobo.266.1">the controller:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.267.1">
distance_controller = P</span><strong class="bold"><span class="koboSpan" id="kobo.268.1">I</span></strong><span class="koboSpan" id="kobo.269.1">Controller(-0.19</span><strong class="bold"><span class="koboSpan" id="kobo.270.1">, -0.005</span></strong><span class="koboSpan" id="kobo.271.1">) </span></pre>
<p><span class="koboSpan" id="kobo.272.1">The </span><a id="_idIndexMarker584"/><span class="koboSpan" id="kobo.273.1">values of </span><strong class="source-inline"><span class="koboSpan" id="kobo.274.1">–0.19</span></strong><span class="koboSpan" id="kobo.275.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.276.1">–0.005</span></strong><span class="koboSpan" id="kobo.277.1"> work for my robot. </span><span class="koboSpan" id="kobo.277.2">We will learn how to tune these later in the chapter. </span><span class="koboSpan" id="kobo.277.3">The integral constant should be negative in this case and small. </span><span class="koboSpan" id="kobo.277.4">Larger values will cause overshoots, and the system will go back and </span><span class="No-Break"><span class="koboSpan" id="kobo.278.1">forth (oscillate).</span></span></p>
<p><span class="koboSpan" id="kobo.279.1">We can now alter the </span><span class="No-Break"><span class="koboSpan" id="kobo.280.1">main loop:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.281.1">prev_time = time.monotonic()</span></strong><span class="koboSpan" id="kobo.282.1">
while True:
  if robot.right_distance.data_ready:
    distance = robot.right_distance.distance
    error = distance_set_point – distance
</span><strong class="bold"><span class="koboSpan" id="kobo.283.1">    current_time = time.monotonic()</span></strong><span class="koboSpan" id="kobo.284.1">
    speed = distance_controller.calculate(error</span><strong class="bold"><span class="koboSpan" id="kobo.285.1">, current_time - prev_time</span></strong><span class="koboSpan" id="kobo.286.1">)
</span><strong class="bold"><span class="koboSpan" id="kobo.287.1">    prev_time = current_time</span></strong><span class="koboSpan" id="kobo.288.1">
    if abs(speed) &lt; 0.3:
      speed = 0
    uart.write(f"{error},{speed},"
      f"{distance_controller.integral}\n".encode())
    robot.set_left(speed)
    robot.set_right(speed)
    robot.right_distance.clear_interrupt()
    time.sleep(0.05)</span></pre>
<p><span class="koboSpan" id="kobo.289.1">The </span><a id="_idIndexMarker585"/><span class="koboSpan" id="kobo.290.1">highlighted changes start with the time delta calculations. </span><span class="koboSpan" id="kobo.290.2">We keep a previous time (</span><strong class="source-inline"><span class="koboSpan" id="kobo.291.1">prev_time</span></strong><span class="koboSpan" id="kobo.292.1">) so that we can subtract this from </span><strong class="source-inline"><span class="koboSpan" id="kobo.293.1">current_time</span></strong><span class="koboSpan" id="kobo.294.1"> later and feed this time difference into the controller with the error. </span><span class="koboSpan" id="kobo.294.2">Next, we store </span><strong class="source-inline"><span class="koboSpan" id="kobo.295.1">current_time</span></strong><span class="koboSpan" id="kobo.296.1"> in </span><strong class="source-inline"><span class="koboSpan" id="kobo.297.1">prev_time</span></strong><span class="koboSpan" id="kobo.298.1"> so that we are ready for the next loop. </span><span class="koboSpan" id="kobo.298.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.299.1">time.monotonic</span></strong><span class="koboSpan" id="kobo.300.1"> function provides a time in seconds with fractions, guaranteeing that subsequent calls cannot return a </span><span class="No-Break"><span class="koboSpan" id="kobo.301.1">lower value.</span></span></p>
<p><span class="koboSpan" id="kobo.302.1">We also send the current integral value to the UART to plot it. </span><span class="koboSpan" id="kobo.302.2">Send this code to </span><span class="No-Break"><span class="koboSpan" id="kobo.303.1">the robot:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer163">
<span class="koboSpan" id="kobo.304.1"><img alt="Figure 10.8 – Oscillation versus smaller integral " src="image/Figure_10.08_B18001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.305.1">Figure 10.8 – Oscillation versus smaller integral</span></p>
<p><span class="koboSpan" id="kobo.306.1">In </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.307.1">Figure 10</span></em></span><em class="italic"><span class="koboSpan" id="kobo.308.1">.8 (a)</span></em><span class="koboSpan" id="kobo.309.1"> the screenshot shows an error with a large integral gain. </span><span class="koboSpan" id="kobo.309.2">This rise makes the motors move and carry on while the system overshoots, until the integral flips the other way - this causes oscillation. </span><span class="koboSpan" id="kobo.309.3">In </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.310.1">Figure 10</span></em></span><em class="italic"><span class="koboSpan" id="kobo.311.1">.8 (b)</span></em><span class="koboSpan" id="kobo.312.1"> the integral gain is much lower, so the integral must reach a higher value before it creates a change. </span><span class="koboSpan" id="kobo.312.2">The motors respond to the proportional change first, but the integral makes a slight adjustment later. </span><span class="koboSpan" id="kobo.312.3">This setting may still oscillate a tiny amount, but the oscillations will be slow </span><span class="No-Break"><span class="koboSpan" id="kobo.313.1">and subtle.</span></span></p>
<p><span class="koboSpan" id="kobo.314.1">Note that when the robot corrects the steady state and the error reaches zero, this doesn’t reduce </span><span class="No-Break"><span class="koboSpan" id="kobo.315.1">the integral.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.316.1">Important Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.317.1">Stop the code (or robot) if the wheels/motors are not moving the robot forward, and restart the code when the wheels are in contact with the floor or motors are turned on (they are on battery power only). </span><span class="koboSpan" id="kobo.317.2">Otherwise, the system can build up a large integral and will ram the next object placed in front of it. </span><span class="koboSpan" id="kobo.317.3">This problem is known as </span><strong class="bold"><span class="koboSpan" id="kobo.318.1">integral wind-up</span></strong><span class="koboSpan" id="kobo.319.1"> and</span><a id="_idIndexMarker586"/><span class="koboSpan" id="kobo.320.1"> can be a big problem if you do not account </span><span class="No-Break"><span class="koboSpan" id="kobo.321.1">for it.</span></span></p>
<p><span class="koboSpan" id="kobo.322.1">Some </span><a id="_idIndexMarker587"/><span class="koboSpan" id="kobo.323.1">overshoot here is inevitable, but the system is reacting to steady-state errors. </span><span class="koboSpan" id="kobo.323.2">This PI controller will work, but if you move the target object quickly, you may still be able to induce oscillation. </span><span class="koboSpan" id="kobo.323.3">How can we dampen that? </span><span class="koboSpan" id="kobo.323.4">We’ll see how in the </span><span class="No-Break"><span class="koboSpan" id="kobo.324.1">next section.</span></span></p>
<h2 id="_idParaDest-218"><a id="_idTextAnchor219"/><span class="koboSpan" id="kobo.325.1">Dealing with oscillations using the derivative</span></h2>
<p><span class="koboSpan" id="kobo.326.1">Oscillations </span><a id="_idIndexMarker588"/><span class="koboSpan" id="kobo.327.1">are made due to sudden state changes, creating a large reacting output, which can cause a large change of state in the opposite direction. </span><span class="koboSpan" id="kobo.327.2">This may repeat on either side of the set point. </span><span class="koboSpan" id="kobo.327.3">The state change is equivalent to a slope on a graph at </span><span class="No-Break"><span class="koboSpan" id="kobo.328.1">any point.</span></span></p>
<p><span class="koboSpan" id="kobo.329.1">The following graph shows a varying value, with the slopes marked at a </span><span class="No-Break"><span class="koboSpan" id="kobo.330.1">few points:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer164">
<span class="koboSpan" id="kobo.331.1"><img alt="Figure 10.9 – Slopes on a graph " src="image/Figure_10.09_B18001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.332.1">Figure 10.9 – Slopes on a graph</span></p>
<p><span class="koboSpan" id="kobo.333.1">The preceding graph shows an error PID response settling. </span><span class="koboSpan" id="kobo.333.2">Along the graph are dots, with dashed lines showing the slope. </span><span class="koboSpan" id="kobo.333.3">The derivative represents this slope at </span><span class="No-Break"><span class="koboSpan" id="kobo.334.1">any point.</span></span></p>
<p><span class="koboSpan" id="kobo.335.1">The essential factor is that when there is a steep change in the error, there is a steeper slope. </span><span class="koboSpan" id="kobo.335.2">This slope value is</span><a id="_idIndexMarker589"/><span class="koboSpan" id="kobo.336.1"> the </span><strong class="bold"><span class="koboSpan" id="kobo.337.1">derivative</span></strong><span class="koboSpan" id="kobo.338.1">. </span><span class="koboSpan" id="kobo.338.2">It represents the rate of change in our system. </span><span class="koboSpan" id="kobo.338.3">Using this value with a gain can reduce overshoot, dampening the system. </span><span class="koboSpan" id="kobo.338.4">So, we could add this along with the PI components and dampen the movement </span><span class="No-Break"><span class="koboSpan" id="kobo.339.1">a little.</span></span></p>
<p><span class="koboSpan" id="kobo.340.1">However, before we do that, there </span><a id="_idIndexMarker590"/><span class="koboSpan" id="kobo.341.1">is another issue: the output from the distance sensors is a little noisy. </span><span class="koboSpan" id="kobo.341.2">The following zoomed-in view shows noise on the sensor when the robot is not moving: </span></p>
<div>
<div class="IMG---Figure" id="_idContainer165">
<span class="koboSpan" id="kobo.342.1"><img alt="Figure 10.10 – Noise from the sensor " src="image/Figure_10.10_B18001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.343.1">Figure 10.10 – Noise from the sensor</span></p>
<p><span class="koboSpan" id="kobo.344.1">The preceding </span><a id="_idIndexMarker591"/><span class="koboSpan" id="kobo.345.1">screenshot is enlarged to show the sensor data noise. </span><span class="koboSpan" id="kobo.345.2">One of the lines is frequently going above or below the line. </span><span class="koboSpan" id="kobo.345.3">This noise is slight but makes many fast changes in </span><span class="No-Break"><span class="koboSpan" id="kobo.346.1">the slope.</span></span></p>
<p><span class="koboSpan" id="kobo.347.1">Using the derivative directly with this noise may cause our robot to produce large movements. </span><span class="koboSpan" id="kobo.347.2">To reduce this, we will use a </span><strong class="bold"><span class="koboSpan" id="kobo.348.1">low pass filter</span></strong><span class="koboSpan" id="kobo.349.1"> in front of the integral. </span><span class="koboSpan" id="kobo.349.2">This only allows sustained error movements in, filtering out the constant jiggle </span><span class="No-Break"><span class="koboSpan" id="kobo.350.1">of noise.</span></span></p>
<p><span class="koboSpan" id="kobo.351.1">Let’s see this as a feedback </span><span class="No-Break"><span class="koboSpan" id="kobo.352.1">control diagram:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer166">
<span class="koboSpan" id="kobo.353.1"><img alt="Figure 10.11 – Feedback flow for the PID controller " src="image/Figure_10.11_B18001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.354.1">Figure 10.11 – Feedback flow for the PID controller</span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.355.1">Figure 10</span></em></span><em class="italic"><span class="koboSpan" id="kobo.356.1">.11</span></em><span class="koboSpan" id="kobo.357.1"> extends </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.358.1">Figure 10</span></em></span><em class="italic"><span class="koboSpan" id="kobo.359.1">.7</span></em><span class="koboSpan" id="kobo.360.1"> by adding two additional blocks. </span><span class="koboSpan" id="kobo.360.2">First, the error splits through a block labeled LPF – this is a low pass filter, with a stylized frequency graph showing how this tails off for higher frequencies. </span><span class="koboSpan" id="kobo.360.3">The LPF block feeds into the next block – the derivative multiplied by a </span><strong class="source-inline"><span class="koboSpan" id="kobo.361.1">kd</span></strong><span class="koboSpan" id="kobo.362.1"> derivative gain. </span><span class="koboSpan" id="kobo.362.2">This block has a stylized graph showing the slope lines. </span><span class="koboSpan" id="kobo.362.3">The derivative output is then added to the other PI outputs to make the motor </span><span class="No-Break"><span class="koboSpan" id="kobo.363.1">speed signal.</span></span></p>
<p><span class="koboSpan" id="kobo.364.1">Now that we have seen how this operates, let’s modify the code, starting with the </span><span class="No-Break"><span class="koboSpan" id="kobo.365.1">PID class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.366.1">
class PI</span><strong class="bold"><span class="koboSpan" id="kobo.367.1">D</span></strong><span class="koboSpan" id="kobo.368.1">Controller:
    def __init__(self, kp, ki, </span><strong class="bold"><span class="koboSpan" id="kobo.369.1">kd, d_filter_gain=0.1</span></strong><span class="koboSpan" id="kobo.370.1">):
        self.kp = kp
        self.ki = ki
        </span><strong class="bold"><span class="koboSpan" id="kobo.371.1">self.kd = kd</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.372.1">        self.d_filter_gain = d_filter_gain</span></strong><span class="koboSpan" id="kobo.373.1">
        self.integral = 0
</span><strong class="bold"><span class="koboSpan" id="kobo.374.1">        self.error_prev = 0</span></strong></pre>
<p><span class="koboSpan" id="kobo.375.1">Here, we add two additional construction parameters to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.376.1">PIDController</span></strong><span class="koboSpan" id="kobo.377.1"> class – a derivative gain, </span><strong class="source-inline"><span class="koboSpan" id="kobo.378.1">kd</span></strong><span class="koboSpan" id="kobo.379.1">, and a derivative filter gain. </span><span class="koboSpan" id="kobo.379.2">We also store a previous error to calculate the difference from the current error. </span><span class="koboSpan" id="kobo.379.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.380.1">calculate</span></strong><span class="koboSpan" id="kobo.381.1"> function </span><span class="No-Break"><span class="koboSpan" id="kobo.382.1">also changes:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.383.1">
    def calculate(self, error, dt):
        self.integral += error * dt
</span><strong class="bold"><span class="koboSpan" id="kobo.384.1">        difference = (error - self.error_prev) * self.d_filter_gain</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.385.1">        self.error_prev += difference</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.386.1">        self.derivative = difference / dt</span></strong><span class="koboSpan" id="kobo.387.1">
        return self.kp * error + self.ki * self.integral</span><strong class="bold"><span class="koboSpan" id="kobo.388.1"> + self.kd * self.derivative</span></strong></pre>
<p><span class="koboSpan" id="kobo.389.1">We need the </span><a id="_idIndexMarker592"/><span class="koboSpan" id="kobo.390.1">difference between the current error and the previous error. </span><span class="koboSpan" id="kobo.390.2">We multiply this difference by the filter gain, and add this onto the previous error. </span><span class="koboSpan" id="kobo.390.3">This means that the error changes by a smoothed out amount and sets us up for the next calculation. </span></p>
<p><span class="koboSpan" id="kobo.391.1">The next line divides this difference by the change in time, to get the rate of change. </span><span class="koboSpan" id="kobo.391.2">We store this in </span><strong class="source-inline"><span class="koboSpan" id="kobo.392.1">self.derivative</span></strong><span class="koboSpan" id="kobo.393.1"> so that we can graph this term later. </span><span class="koboSpan" id="kobo.393.2">Finally, we multiply </span><strong class="source-inline"><span class="koboSpan" id="kobo.394.1">self.derivative</span></strong><span class="koboSpan" id="kobo.395.1"> by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.396.1">d</span></strong><span class="koboSpan" id="kobo.397.1"> gain (</span><strong class="source-inline"><span class="koboSpan" id="kobo.398.1">kd</span></strong><span class="koboSpan" id="kobo.399.1">) and add this to </span><span class="No-Break"><span class="koboSpan" id="kobo.400.1">the calculations.</span></span></p>
<p><span class="koboSpan" id="kobo.401.1">The PID controller </span><a id="_idIndexMarker593"/><span class="koboSpan" id="kobo.402.1">is now complete. </span><span class="koboSpan" id="kobo.402.2">We can make this reusable by moving the </span><strong class="source-inline"><span class="koboSpan" id="kobo.403.1">PIDController</span></strong><span class="koboSpan" id="kobo.404.1"> class into a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.405.1">pid_controller.py</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.406.1"> file.</span></span></p>
<p><span class="koboSpan" id="kobo.407.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.408.1">code.py</span></strong><span class="koboSpan" id="kobo.409.1"> file can use </span><strong class="source-inline"><span class="koboSpan" id="kobo.410.1">pid_controller</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.411.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.412.1">
import time
import board
import busio
import robot
</span><strong class="bold"><span class="koboSpan" id="kobo.413.1">from pid_controller import PIDController</span></strong><span class="koboSpan" id="kobo.414.1">
uart = busio.UART(board.GP12, board.GP13, baudrate=9600)
robot.right_distance.distance_mode = 1
robot.right_distance.start_ranging()
distance_set_point = 10
distance_controller = </span><strong class="bold"><span class="koboSpan" id="kobo.415.1">PIDController(-0.19, -0.008, -0.2)</span></strong><span class="koboSpan" id="kobo.416.1">
prev_time = time.monotonic()
while True:
  if robot.right_distance.data_ready:
    distance = robot.right_distance.distance
    error = distance_set_point – distance
    current_time = time.monotonic()
    speed = distance_controller.calculate(error, current_time - prev_time)
    prev_time = current_time
    if abs(speed) &lt; 0.35:
      speed = 0
    uart.write(f"{error},{speed}, {distance_controller.integral}</span><strong class="bold"><span class="koboSpan" id="kobo.417.1">, {distance_controller.derivative}</span></strong><span class="koboSpan" id="kobo.418.1">\n".encode())
    robot.set_left(speed)
    robot.set_right(speed)
    robot.right_distance.clear_interrupt()
    time.sleep(0.05)</span></pre>
<p><span class="koboSpan" id="kobo.419.1">The highlighted parts of the code show how this changed from the previous </span><strong class="source-inline"><span class="koboSpan" id="kobo.420.1">code.py</span></strong><span class="koboSpan" id="kobo.421.1"> example. </span><span class="koboSpan" id="kobo.421.2">First, we imported the </span><strong class="source-inline"><span class="koboSpan" id="kobo.422.1">PIDController</span></strong><span class="koboSpan" id="kobo.423.1"> class. </span><span class="koboSpan" id="kobo.423.2">Then, we swapped our use of </span><strong class="source-inline"><span class="koboSpan" id="kobo.424.1">PIController</span></strong><span class="koboSpan" id="kobo.425.1"> for </span><strong class="source-inline"><span class="koboSpan" id="kobo.426.1">PIDController</span></strong><span class="koboSpan" id="kobo.427.1">. </span><span class="koboSpan" id="kobo.427.2">PID tuning parameters are tuned as we expand on this code. </span><span class="koboSpan" id="kobo.427.3">Adding additional terms, such as the derivative, will make tuning the </span><span class="No-Break"><span class="koboSpan" id="kobo.428.1">others necessary.</span></span></p>
<p><span class="koboSpan" id="kobo.429.1">We send the</span><a id="_idIndexMarker594"/><span class="koboSpan" id="kobo.430.1"> error and time difference into the controller calculation to get the speed, then send the derivative to the UART to see what our robot is doing and tune </span><span class="No-Break"><span class="koboSpan" id="kobo.431.1">the parameters.</span></span></p>
<p><span class="koboSpan" id="kobo.432.1">With that, we’ve built a PID controller and used it to keep a certain amount of distance from an object. </span><span class="koboSpan" id="kobo.432.2">We’ll make this into a more dynamic example in the </span><span class="No-Break"><span class="koboSpan" id="kobo.433.1">next section.</span></span></p>
<h1 id="_idParaDest-219"><a id="_idTextAnchor220"/><span class="koboSpan" id="kobo.434.1">Using PID to follow a wall</span></h1>
<p><span class="koboSpan" id="kobo.435.1">Driving along </span><a id="_idIndexMarker595"/><span class="koboSpan" id="kobo.436.1">a wall using the PID algorithm requires a little more coordination. </span><span class="koboSpan" id="kobo.436.2">Let’s visualize the problem with </span><span class="No-Break"><span class="koboSpan" id="kobo.437.1">a diagram:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer167">
<span class="koboSpan" id="kobo.438.1"><img alt="Figure 10.12 – The robot following a wall " src="image/Figure_10.12_B18001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.439.1">Figure 10.12 – The robot following a wall</span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.440.1">Figure 10</span></em></span><em class="italic"><span class="koboSpan" id="kobo.441.1">.12</span></em><span class="koboSpan" id="kobo.442.1"> shows how</span><a id="_idIndexMarker596"/><span class="koboSpan" id="kobo.443.1"> our robot will follow a wall. </span><span class="koboSpan" id="kobo.443.2">First, the robot drives forward in the direction shown by the solid line with an arrow. </span><span class="koboSpan" id="kobo.443.3">We have turned the sensor out so that it can detect the wall in its cone (these distance sensors cover around 20 degrees). </span><span class="koboSpan" id="kobo.443.4">Based on the return of a close object (shown as a dashed line), the robot will adjust its heading to try and keep a constant distance. </span><span class="koboSpan" id="kobo.443.5">When the robot faces the wall, it will curve outward, and it may overshoot, but also, there is a step change in the wall, so the robot will adjust its path and </span><span class="No-Break"><span class="koboSpan" id="kobo.444.1">straighten up.</span></span></p>
<p><span class="koboSpan" id="kobo.445.1">We have a few issues. </span><span class="koboSpan" id="kobo.445.2">First, we have put the motors a little forward, and turning the sensor with the current placement would have the wheel in the path of the sensor, so we’ll need to move them back. </span><span class="koboSpan" id="kobo.445.3">Then, we’ll need to make that 90-degree sensor turn. </span><span class="koboSpan" id="kobo.445.4">After, we’ll need to use the PID to determine how much to change the robot’s heading, a deflection, as the robot </span><span class="No-Break"><span class="koboSpan" id="kobo.446.1">drives forward.</span></span></p>
<p><span class="koboSpan" id="kobo.447.1">Let’s start by making some changes to move </span><span class="No-Break"><span class="koboSpan" id="kobo.448.1">the sensor.</span></span></p>
<h2 id="_idParaDest-220"><a id="_idTextAnchor221"/><span class="koboSpan" id="kobo.449.1">Changing the sensor’s placement</span></h2>
<p><span class="koboSpan" id="kobo.450.1">We will need to make</span><a id="_idIndexMarker597"/><span class="koboSpan" id="kobo.451.1"> some changes to our CAD sketches, then use a drawing to drill some holes. </span><span class="koboSpan" id="kobo.451.2">Note that with the front of the robot facing down in the CAD sketches, the left-hand side of the CAD sketch is for the robot’s </span><span class="No-Break"><span class="koboSpan" id="kobo.452.1">right-hand side.</span></span></p>
<p><span class="koboSpan" id="kobo.453.1">The following FreeCAD screenshots show how to make the </span><span class="No-Break"><span class="koboSpan" id="kobo.454.1">CAD changes:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer168">
<span class="koboSpan" id="kobo.455.1"><img alt="Figure 10.13 – FreeCAD sketches for turning the sensor sideways " src="image/Figure_10.13_B18001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.456.1">Figure 10.13 – FreeCAD sketches for turning the sensor sideways</span></p>
<p><span class="koboSpan" id="kobo.457.1">The left-hand screenshot of </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.458.1">Figure 10</span></em></span><em class="italic"><span class="koboSpan" id="kobo.459.1">.13</span></em><span class="koboSpan" id="kobo.460.1"> shows how we move the motor back in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.461.1">UpperParts</span></strong><span class="koboSpan" id="kobo.462.1"> sketch. </span><span class="koboSpan" id="kobo.462.2">First, delete the horizontal constraint between the bottom corner of the motor (shown on the left) and the breadboard. </span><span class="koboSpan" id="kobo.462.3">Then, add an 18 mm vertical dimension between the same two points. </span><span class="koboSpan" id="kobo.462.4">Moving the motor back 18 mm gives ample space for the sensor, but it will also mean we can reuse one of the existing holes since the distance between them is 18 mm. </span><span class="koboSpan" id="kobo.462.5">In addition, the two motors have symmetry constraints so that they will move together. </span><span class="koboSpan" id="kobo.462.6">Now, you can close </span><span class="No-Break"><span class="koboSpan" id="kobo.463.1">this sketch.</span></span></p>
<p><span class="koboSpan" id="kobo.464.1">The right-hand side of </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.465.1">Figure 10</span></em></span><em class="italic"><span class="koboSpan" id="kobo.466.1">.13</span></em><span class="koboSpan" id="kobo.467.1"> is a screenshot of the sketch for an additional front sensor hole at 90 degrees. </span><span class="koboSpan" id="kobo.467.2">Import the existing distance sensor holes as external geometry. </span><span class="koboSpan" id="kobo.467.3">Then, use construction lines to constrain the distance between this hole and the top outer hole so that it is equal to the distance between the initial distance sensor holes. </span><span class="koboSpan" id="kobo.467.4">Add an equals constraint on the circles and a perpendicular constraint between the lines. </span><span class="koboSpan" id="kobo.467.5">You can make a similar circle on the other side, although we will only use one sensor for </span><span class="No-Break"><span class="koboSpan" id="kobo.468.1">this demonstration.</span></span></p>
<p><span class="koboSpan" id="kobo.469.1">The following figure shows the CAD drawing and parts fitted in new positions on </span><span class="No-Break"><span class="koboSpan" id="kobo.470.1">the robot:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer169">
<span class="koboSpan" id="kobo.471.1"><img alt="Figure 10.14 – The drawing and result of this robot change " src="image/Figure_10.14_B18001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.472.1">Figure 10.14 – The drawing and result of this robot change</span></p>
<p><span class="koboSpan" id="kobo.473.1">The left-hand side of the preceding figure shows the drawing. </span><span class="koboSpan" id="kobo.473.2">I’ve marked the new holes, using the existing ones as a reference. </span><span class="koboSpan" id="kobo.473.3">You will need to detach the motors and sensors to do this – unbolt them but leave the wiring connected and put them carefully to one side while doing this. </span><span class="koboSpan" id="kobo.473.4">After removing the motors, attach one side of the motor bracket and use the hole on the other side of the bracket to mark the </span><span class="No-Break"><span class="koboSpan" id="kobo.474.1">new hole.</span></span></p>
<p><span class="koboSpan" id="kobo.475.1">With the distance sensor, remove the inner bolt, then turn it to face out 90 degrees. </span><span class="koboSpan" id="kobo.475.2">You can then use the inner bolt hole to mark where </span><span class="No-Break"><span class="koboSpan" id="kobo.476.1">to drill.</span></span></p>
<p><span class="koboSpan" id="kobo.477.1">The right-hand</span><a id="_idIndexMarker598"/><span class="koboSpan" id="kobo.478.1"> side of the preceding figure shows the motor and sensor moved into position. </span><span class="koboSpan" id="kobo.478.2">Ensure that the connections are still correct. </span></p>
<p><span class="koboSpan" id="kobo.479.1">This robot is ready for us to write wall-following code on it. </span><span class="koboSpan" id="kobo.479.2">Let’s </span><span class="No-Break"><span class="koboSpan" id="kobo.480.1">see how.</span></span></p>
<h2 id="_idParaDest-221"><a id="_idTextAnchor222"/><span class="koboSpan" id="kobo.481.1">Wall-following code</span></h2>
<p><span class="koboSpan" id="kobo.482.1">Wall </span><a id="_idIndexMarker599"/><span class="koboSpan" id="kobo.483.1">following is an extension of the code </span><a id="_idIndexMarker600"/><span class="koboSpan" id="kobo.484.1">we’ve already been working on, with a few key differences. </span><span class="koboSpan" id="kobo.484.2">First, our robot will drive at a constant speed, but depending on the sensor feedback, it will steer closer to/farther from the wall. </span><span class="koboSpan" id="kobo.484.3">It can do this by adding a PID output to the speed of one side and subtracting it </span><span class="No-Break"><span class="koboSpan" id="kobo.485.1">from another.</span></span></p>
<p><span class="koboSpan" id="kobo.486.1">Start by taking a copy of the previous code example. </span><span class="koboSpan" id="kobo.486.2">We’ll make changes to </span><strong class="source-inline"><span class="koboSpan" id="kobo.487.1">code.py</span></strong><span class="koboSpan" id="kobo.488.1">. </span><span class="koboSpan" id="kobo.488.2">The imports and setup stay </span><span class="No-Break"><span class="koboSpan" id="kobo.489.1">the same:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.490.1">
import time
import board
import busio
import robot
from pid_controller import PIDController
uart = busio.UART(board.GP12, board.GP13, baudrate=9600)
robot.right_distance.distance_mode = 1
robot.right_distance.start_ranging()</span></pre>
<p><span class="koboSpan" id="kobo.491.1">However, along with the other settings, we must add a base speed for the robot to drive. </span><span class="koboSpan" id="kobo.491.2">The distance set point should also be </span><span class="No-Break"><span class="koboSpan" id="kobo.492.1">further out:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.493.1">speed = 0.7</span></strong><span class="koboSpan" id="kobo.494.1">
distance_set_point = 15
distance_controller = PIDController(0.05, 0.0, 0.0)</span></pre>
<p><span class="koboSpan" id="kobo.495.1">We have set up the PID here so that you can tweak </span><span class="No-Break"><span class="koboSpan" id="kobo.496.1">its settings.</span></span></p>
<p><span class="koboSpan" id="kobo.497.1">The main loop gets the sensor data and error in the </span><span class="No-Break"><span class="koboSpan" id="kobo.498.1">same way:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.499.1">
prev_time = time.monotonic()
while True:
  if robot.right_distance.data_ready:
    distance = robot.right_distance.distance
    error = distance_set_point - distance</span></pre>
<p><span class="koboSpan" id="kobo.500.1">When we calculate the PID, we now store it in </span><strong class="source-inline"><span class="koboSpan" id="kobo.501.1">deflection</span></strong><span class="koboSpan" id="kobo.502.1">, describing how fast we </span><span class="No-Break"><span class="koboSpan" id="kobo.503.1">will turn:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.504.1">
    current_time = time.monotonic()
    </span><strong class="bold"><span class="koboSpan" id="kobo.505.1">deflection</span></strong><span class="koboSpan" id="kobo.506.1"> = distance_controller.calculate(error, current_time - prev_time)
    prev_time = current_time</span></pre>
<p><span class="koboSpan" id="kobo.507.1">We write this to the UART so that we can plot and </span><span class="No-Break"><span class="koboSpan" id="kobo.508.1">debug it:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.509.1">
    uart.write(f"{error},{</span><strong class="bold"><span class="koboSpan" id="kobo.510.1">deflection</span></strong><span class="koboSpan" id="kobo.511.1">}\n".encode())</span></pre>
<p><span class="koboSpan" id="kobo.512.1">The code uses this deflection by adding it to the right motor speed and subtracting it from the left. </span><span class="koboSpan" id="kobo.512.2">This deflection should pull us toward the set point, a distance from the wall, while </span><span class="No-Break"><span class="koboSpan" id="kobo.513.1">driving forward:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.514.1">
    robot.set_left(speed</span><strong class="bold"><span class="koboSpan" id="kobo.515.1"> - deflection</span></strong><span class="koboSpan" id="kobo.516.1">)
    robot.set_right(speed</span><strong class="bold"><span class="koboSpan" id="kobo.517.1"> + deflection</span></strong><span class="koboSpan" id="kobo.518.1">)</span></pre>
<p><span class="koboSpan" id="kobo.519.1">Finish by resetting the sensor and sleeping a bit </span><span class="No-Break"><span class="koboSpan" id="kobo.520.1">before looping:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.521.1">
    robot.right_distance.clear_interrupt()
    time.sleep(0.05)</span></pre>
<p><span class="koboSpan" id="kobo.522.1">You can send this to the robot and start it near a wall, and it may try to follow it. </span><span class="koboSpan" id="kobo.522.2">I’ve found a few boxes in the middle of the room good as it can drive around them; however, it will likely struggle with anything concave. </span></p>
<p><span class="koboSpan" id="kobo.523.1">The result of this may be unstable, so we’ll need to tune this PID. </span><span class="koboSpan" id="kobo.523.2">However, even if unstable, it </span><a id="_idIndexMarker601"/><span class="koboSpan" id="kobo.524.1">should try to follow the wall, even if </span><span class="No-Break"><span class="koboSpan" id="kobo.525.1">it collides.</span></span></p>
<h2 id="_idParaDest-222"><a id="_idTextAnchor223"/><span class="koboSpan" id="kobo.526.1">Troubleshooting</span></h2>
<p><span class="koboSpan" id="kobo.527.1">Try these steps if the</span><a id="_idIndexMarker602"/><span class="koboSpan" id="kobo.528.1"> robot isn’t following </span><span class="No-Break"><span class="koboSpan" id="kobo.529.1">or starting:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.530.1">First, check the distance sensor wiring; now that you’ve moved it, the wires may have been dislodged. </span><a href="B18001_08.xhtml#_idTextAnchor166"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.531.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.532.1">, </span><em class="italic"><span class="koboSpan" id="kobo.533.1">Sensing Distances to Detect Objects with Pico</span></em><span class="koboSpan" id="kobo.534.1">, contains guides on sensor wiring if you need to </span><span class="No-Break"><span class="koboSpan" id="kobo.535.1">check this.</span></span></li>
<li><span class="koboSpan" id="kobo.536.1">Ensure you have a fresh set of batteries – this won’t work well on </span><span class="No-Break"><span class="koboSpan" id="kobo.537.1">low batteries.</span></span></li>
<li><span class="koboSpan" id="kobo.538.1">If the robot is spinning, put it closer to the wall, and if it is reacting too hard, bring down the </span><a id="_idIndexMarker603"/><span class="koboSpan" id="kobo.539.1">P value. </span><span class="koboSpan" id="kobo.539.2">We’ll tune this </span><span class="No-Break"><span class="koboSpan" id="kobo.540.1">more shortly.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.541.1">You should now have a robot that is kind of following the wall but may be quite unstable or crashing somewhat. </span><span class="koboSpan" id="kobo.541.2">To make this work well, we’ll need to tune </span><span class="No-Break"><span class="koboSpan" id="kobo.542.1">the PID.</span></span></p>
<h1 id="_idParaDest-223"><a id="_idTextAnchor224"/><span class="koboSpan" id="kobo.543.1">PID tuning – using graphs to tune the PID</span></h1>
<p><span class="koboSpan" id="kobo.544.1">The PID algorithm is </span><a id="_idIndexMarker604"/><span class="koboSpan" id="kobo.545.1">great for responding to sensor input, adjusting for constant errors, and dampening out overcompensation with the derivative. </span><span class="koboSpan" id="kobo.545.2">The only problem is that getting these three values right is tricky. </span><span class="koboSpan" id="kobo.545.3">How you tune a PID depends on the system. </span><span class="koboSpan" id="kobo.545.4">In our case, for wall following, much of this will be on how the robot feels in the situation. </span><span class="koboSpan" id="kobo.545.5">This method works for small robots, but there are formal methods that require a mathematical model of </span><span class="No-Break"><span class="koboSpan" id="kobo.546.1">the system.</span></span></p>
<p><span class="koboSpan" id="kobo.547.1">Depending on the situation, we may only use one constant, but for this, we’ll try to use all three. </span><span class="koboSpan" id="kobo.547.2">It’s also a good practice to change only one gain constant at </span><span class="No-Break"><span class="koboSpan" id="kobo.548.1">a time.</span></span></p>
<p><span class="koboSpan" id="kobo.549.1">We already have graphing for our system on the phone. </span><span class="koboSpan" id="kobo.549.2">While we are starting, we’ll only show the error and response; we can add other components as needed. </span><span class="koboSpan" id="kobo.549.3">The derivative and integral components can dwarf the proportional component, and the Bluefruit app does not allow plots with different scales on the </span><span class="No-Break"><span class="koboSpan" id="kobo.550.1">same graph.</span></span></p>
<p><span class="koboSpan" id="kobo.551.1">We are also going to add some controls other than graphing. </span><span class="koboSpan" id="kobo.551.2">Otherwise, you’ll be plugging the robot in to reprogram a lot! </span><span class="koboSpan" id="kobo.551.3">So, let’s start with some </span><span class="No-Break"><span class="koboSpan" id="kobo.552.1">basic controls.</span></span></p>
<h2 id="_idParaDest-224"><a id="_idTextAnchor225"/><span class="koboSpan" id="kobo.553.1">Controlling motor speed</span></h2>
<p><span class="koboSpan" id="kobo.554.1">First, we’ll need the</span><a id="_idIndexMarker605"/><span class="koboSpan" id="kobo.555.1"> ability to start and stop our motors. </span><span class="koboSpan" id="kobo.555.2">Currently, our system starts with motors live and running. </span><span class="koboSpan" id="kobo.555.3">Turning the motors off or slowing things down will make tuning far </span><span class="No-Break"><span class="koboSpan" id="kobo.556.1">less frustrating.</span></span></p>
<p><span class="koboSpan" id="kobo.557.1">The motor speeds are down to the PWM system. </span><span class="koboSpan" id="kobo.557.2">The current PWM settings on our robot have a frequency of 500 Hz. </span><span class="koboSpan" id="kobo.557.3">This is a little high for DC motors, which means they can stall (stop) at low speeds. </span><span class="koboSpan" id="kobo.557.4">So, we’ll reduce the motor PWM frequency. </span><span class="koboSpan" id="kobo.557.5">In </span><strong class="source-inline"><span class="koboSpan" id="kobo.558.1">robot.py</span></strong><span class="koboSpan" id="kobo.559.1">, make the highlighted changes on the </span><span class="No-Break"><span class="koboSpan" id="kobo.560.1">matching lines:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.561.1">
motor_A1 = pwmio.PWMOut(board.GP17</span><strong class="bold"><span class="koboSpan" id="kobo.562.1">, frequency=100</span></strong><span class="koboSpan" id="kobo.563.1">)
motor_A2 = pwmio.PWMOut(board.GP16</span><strong class="bold"><span class="koboSpan" id="kobo.564.1">, frequency=100</span></strong><span class="koboSpan" id="kobo.565.1">)
motor_B1 = pwmio.PWMOut(board.GP18</span><strong class="bold"><span class="koboSpan" id="kobo.566.1">, frequency=100</span></strong><span class="koboSpan" id="kobo.567.1">)
motor_B2 = pwmio.PWMOut(board.GP19</span><strong class="bold"><span class="koboSpan" id="kobo.568.1">, frequency=100</span></strong><span class="koboSpan" id="kobo.569.1">)</span></pre>
<p><span class="koboSpan" id="kobo.570.1">In </span><strong class="source-inline"><span class="koboSpan" id="kobo.571.1">code.py</span></strong><span class="koboSpan" id="kobo.572.1">, we </span><a id="_idIndexMarker606"/><span class="koboSpan" id="kobo.573.1">will modify our system to allow motors to be </span><span class="No-Break"><span class="koboSpan" id="kobo.574.1">turned off:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.575.1">
prev_time = time.monotonic()
</span><strong class="bold"><span class="koboSpan" id="kobo.576.1">motors_active = False</span></strong><span class="koboSpan" id="kobo.577.1">
while True:
  if robot.right_distance.data_ready:
    distance = robot.right_distance.distance
    error = distance_set_point - distance
    current_time = time.monotonic()
    deflection = distance_controller.calculate(error, current_time - prev_time)
    prev_time = current_time
    uart.write(f"{error},{deflection}\n".encode())
</span><strong class="bold"><span class="koboSpan" id="kobo.578.1">    if motors_active:</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.579.1">      robot.set_left(speed - deflection)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.580.1">      robot.set_right(speed + deflection)</span></strong><span class="koboSpan" id="kobo.581.1">
    robot.right_distance.clear_interrupt()
    time.sleep(0.05)</span></pre>
<p><span class="koboSpan" id="kobo.582.1">Then, we’ll want to add </span><span class="No-Break"><span class="koboSpan" id="kobo.583.1">UART control:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.584.1">  if uart.in_waiting:</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.585.1">    command = uart.readline().decode().strip()</span></strong> </pre>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.586.1">if</span></strong><span class="koboSpan" id="kobo.587.1"> checks for waiting commands; if we have one, we read in a line of input and decode it. </span><strong class="source-inline"><span class="koboSpan" id="kobo.588.1">strip</span></strong><span class="koboSpan" id="kobo.589.1"> removes the line </span><span class="No-Break"><span class="koboSpan" id="kobo.590.1">end character.</span></span></p>
<p><span class="koboSpan" id="kobo.591.1">Now, we can start checking </span><span class="No-Break"><span class="koboSpan" id="kobo.592.1">for commands:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.593.1">
    if command.startswith("M"):
      speed = float(command[1:])</span></pre>
<p><span class="koboSpan" id="kobo.594.1">This code</span><a id="_idIndexMarker607"/><span class="koboSpan" id="kobo.595.1"> means we can send the robot an instruction such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.596.1">M0.7</span></strong><span class="koboSpan" id="kobo.597.1"> via the Bluefruit UART app, and the straight motor speed will </span><span class="No-Break"><span class="koboSpan" id="kobo.598.1">be 0.7.</span></span></p>
<p><span class="koboSpan" id="kobo.599.1">We also want to be able to activate/deactivate </span><span class="No-Break"><span class="koboSpan" id="kobo.600.1">the motors:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.601.1">
    elif command == "G":
      motors_active = not motors_active
      robot.set_left(0)
      robot.set_right(0)
      distance_controller.integral = 0</span></pre>
<p><span class="koboSpan" id="kobo.602.1">We can stop or start the motors by sending the </span><strong class="source-inline"><span class="koboSpan" id="kobo.603.1">G</span></strong><span class="koboSpan" id="kobo.604.1"> instruction to the robot. </span><span class="koboSpan" id="kobo.604.2">This handler toggles the </span><strong class="source-inline"><span class="koboSpan" id="kobo.605.1">motors_active</span></strong><span class="koboSpan" id="kobo.606.1"> variable. </span><span class="koboSpan" id="kobo.606.2">It will always stop the motors. </span><span class="koboSpan" id="kobo.606.3">The next loop cycle will turn them on only if it’s active, ensuring they stop. </span></p>
<p><span class="koboSpan" id="kobo.607.1">Finally this resets the integral to avoid integral wind up while the motors are not running. </span><span class="koboSpan" id="kobo.607.2">Having the integral running while the robot cannot act to counter it is known as </span><strong class="bold"><span class="koboSpan" id="kobo.608.1">integral wind-up</span></strong><span class="koboSpan" id="kobo.609.1"> and can </span><a id="_idIndexMarker608"/><span class="koboSpan" id="kobo.610.1">cause </span><span class="No-Break"><span class="koboSpan" id="kobo.611.1">big problems.</span></span></p>
<p><span class="koboSpan" id="kobo.612.1">We can test this with the existing proportional and send it to the robot. </span><span class="koboSpan" id="kobo.612.2">You should be able to test the instructions from the UART panel in the </span><span class="No-Break"><span class="koboSpan" id="kobo.613.1">Bluefruit app:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.614.1">G</span></strong><span class="koboSpan" id="kobo.615.1"> -&gt; Enable/disable robot motors: </span><span class="No-Break"><span class="koboSpan" id="kobo.616.1">think Go/Stop.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.617.1">M&lt;speed&gt;</span></strong><span class="koboSpan" id="kobo.618.1"> -&gt; Set the motor speed: this should be between 0.3 and 1.0. </span><span class="koboSpan" id="kobo.618.2">It will likely not move </span><a id="_idIndexMarker609"/><span class="koboSpan" id="kobo.619.1">under 0.3. </span><span class="koboSpan" id="kobo.619.2">This will behave incorrectly at negative speeds, and the motor code truncates values </span><span class="No-Break"><span class="koboSpan" id="kobo.620.1">above 1.0.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.621.1">Now that you have control of the robot, let’s figure out how to tweak the </span><span class="No-Break"><span class="koboSpan" id="kobo.622.1">proportional component.</span></span></p>
<h2 id="_idParaDest-225"><a id="_idTextAnchor226"/><span class="koboSpan" id="kobo.623.1">The proportional component</span></h2>
<p><span class="koboSpan" id="kobo.624.1">The </span><a id="_idIndexMarker610"/><span class="koboSpan" id="kobo.625.1">proportional gain constant, </span><strong class="source-inline"><span class="koboSpan" id="kobo.626.1">pk</span></strong><span class="koboSpan" id="kobo.627.1">, is the starting point and is usually dominant in a system. </span><span class="koboSpan" id="kobo.627.2">Multiplying the error by </span><strong class="source-inline"><span class="koboSpan" id="kobo.628.1">pk</span></strong><span class="koboSpan" id="kobo.629.1"> will create the most immediate reaction to </span><span class="No-Break"><span class="koboSpan" id="kobo.630.1">a sensor.</span></span></p>
<p><span class="koboSpan" id="kobo.631.1">We can start by adding code to change the </span><span class="No-Break"><span class="koboSpan" id="kobo.632.1">proportional constant:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.633.1">
    elif command.startswith("P"):
      distance_controller.kp = float(command[1:])</span></pre>
<p><span class="koboSpan" id="kobo.634.1">This code checks for the input, </span><strong class="source-inline"><span class="koboSpan" id="kobo.635.1">P&lt;proportional gain&gt;</span></strong><span class="koboSpan" id="kobo.636.1">, and uses it in the same way as the motor speed. </span><span class="koboSpan" id="kobo.636.2">When you type a value, the proportional constant is updated. </span><span class="koboSpan" id="kobo.636.3">So, let’s review the state of the robot by adding an instruction to </span><span class="No-Break"><span class="koboSpan" id="kobo.637.1">inspect these:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.638.1">
    elif command.startswith("?"):
      uart.write(f"P{distance_controller.kp:.3f}\n".encode())
      uart.write(f"I{distance_controller.ki:.3f}\n".encode())
      uart.write(f"D{distance_controller.kd:.3f}\n".encode())
      uart.write(f"M{speed:.1f}\n".encode())
      time.sleep(3)</span></pre>
<p><span class="koboSpan" id="kobo.639.1">This handler for </span><strong class="source-inline"><span class="koboSpan" id="kobo.640.1">?</span></strong><span class="koboSpan" id="kobo.641.1"> will print the PID constants and speed settings. </span><span class="koboSpan" id="kobo.641.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.642.1">.3f</span></strong><span class="koboSpan" id="kobo.643.1"> annotation encodes the value as a number with 3 decimal places. </span><span class="koboSpan" id="kobo.643.2">Because the robot usually outputs the graph values via UART, we pause for 3 seconds here. </span><span class="koboSpan" id="kobo.643.3">Do not use this command with the </span><span class="No-Break"><span class="koboSpan" id="kobo.644.1">motors active.</span></span></p>
<p><span class="koboSpan" id="kobo.645.1">When we send this to the robot, we have two additional </span><span class="No-Break"><span class="koboSpan" id="kobo.646.1">control abilities:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.647.1">P0.045</span></strong><span class="koboSpan" id="kobo.648.1"> -&gt; Set the proportional gain value </span><span class="No-Break"><span class="koboSpan" id="kobo.649.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.650.1">0.045</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.651.1">.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.652.1">?</span></strong><span class="koboSpan" id="kobo.653.1"> -&gt; Print the </span><span class="No-Break"><span class="koboSpan" id="kobo.654.1">current state:</span></span></li>
</ul>
<pre class="console"><span class="koboSpan" id="kobo.655.1">
P0.045
I0.000
D0.000
M0.7</span></pre>
<p><span class="koboSpan" id="kobo.656.1">Send this to the robot. </span><span class="koboSpan" id="kobo.656.2">Before we engage the motors (</span><strong class="source-inline"><span class="koboSpan" id="kobo.657.1">G</span></strong><span class="koboSpan" id="kobo.658.1">), let’s consider a good proportional value. </span><span class="koboSpan" id="kobo.658.2">For this example, we expect an error between 5 and -5, giving us a range of 10 cm. </span><span class="koboSpan" id="kobo.658.3">Corners will go beyond this and set the turning at full (saturation, maximum value). </span><span class="koboSpan" id="kobo.658.4">With a speed of 0.7, to turn back, we would need an output of -1.4. </span><span class="koboSpan" id="kobo.658.5">We can divide 1.4 by 10, giving us a starting guess of 0.14. </span><span class="koboSpan" id="kobo.658.6">Send </span><strong class="source-inline"><span class="koboSpan" id="kobo.659.1">P0.14</span></strong><span class="koboSpan" id="kobo.660.1"> to set this and </span><strong class="source-inline"><span class="koboSpan" id="kobo.661.1">G</span></strong><span class="koboSpan" id="kobo.662.1"> to start the </span><span class="No-Break"><span class="koboSpan" id="kobo.663.1">robot moving.</span></span></p>
<p><span class="koboSpan" id="kobo.664.1">This setting is responding but has some oscillation. </span><span class="koboSpan" id="kobo.664.2">Use </span><strong class="source-inline"><span class="koboSpan" id="kobo.665.1">G</span></strong><span class="koboSpan" id="kobo.666.1"> to stop it. </span><span class="koboSpan" id="kobo.666.2">We will use trial and error here by</span><a id="_idIndexMarker611"/><span class="koboSpan" id="kobo.667.1"> halving the P value and trying again. </span><span class="koboSpan" id="kobo.667.2">We can test this and use </span><span class="No-Break"><span class="koboSpan" id="kobo.668.1">two rules:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.669.1">If the robot is oscillating too much, divide the value </span><span class="No-Break"><span class="koboSpan" id="kobo.670.1">by 2.</span></span></li>
<li><span class="koboSpan" id="kobo.671.1">If the robot responds too slowly, multiply by 1.5 (the value between here and the previous one </span><span class="No-Break"><span class="koboSpan" id="kobo.672.1">is high).</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.673.1">This method lets us home in on a value. </span><span class="koboSpan" id="kobo.673.2">When you find values that you like, you can put them back into </span><strong class="source-inline"><span class="koboSpan" id="kobo.674.1">code.py</span></strong><span class="koboSpan" id="kobo.675.1"> to keep for later. </span><span class="koboSpan" id="kobo.675.2">Use </span><strong class="source-inline"><span class="koboSpan" id="kobo.676.1">?</span></strong><span class="koboSpan" id="kobo.677.1"> to see the last </span><strong class="source-inline"><span class="koboSpan" id="kobo.678.1">P</span></strong><span class="koboSpan" id="kobo.679.1"> setting </span><span class="No-Break"><span class="koboSpan" id="kobo.680.1">you had.</span></span></p>
<p><span class="koboSpan" id="kobo.681.1">The following screenshot shows how this looks on the </span><span class="No-Break"><span class="koboSpan" id="kobo.682.1">graph output:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer170">
<span class="koboSpan" id="kobo.683.1"><img alt="Figure 10.15 – Proportional response " src="image/Figure_10.15_B18001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.684.1">Figure 10.15 – Proportional response</span></p>
<p><span class="koboSpan" id="kobo.685.1">The</span><a id="_idIndexMarker612"/><span class="koboSpan" id="kobo.686.1"> preceding phone screenshot shows a graph with only a proportional response. </span><span class="koboSpan" id="kobo.686.2">The X axis specifies the time in seconds. </span><span class="koboSpan" id="kobo.686.3">The Y axis is the distance in cm for the error, but more arbitrary for the output value. </span><span class="koboSpan" id="kobo.686.4">The error has a higher range in tens of cms. </span><span class="koboSpan" id="kobo.686.5">The robot is driving around some obstacles. </span><span class="koboSpan" id="kobo.686.6">The huge swings are when it reaches a corner and drives around it. </span><span class="koboSpan" id="kobo.686.7">The blue line shows the PID output and the deflection. </span><span class="koboSpan" id="kobo.686.8">The deflection scale is usually below 1, but the large swings will take it above that. </span><span class="koboSpan" id="kobo.686.9">Motor speeds are clamped between -1.0 and 1.0, so those large corners will saturate the motors, making the robot turn on </span><span class="No-Break"><span class="koboSpan" id="kobo.687.1">the spot.</span></span></p>
<p><span class="koboSpan" id="kobo.688.1">In summary, a high proportional gain will make a system respond quickly, but it will overshoot and may even start to oscillate. </span><span class="koboSpan" id="kobo.688.2">Too low, and it will not respond </span><span class="No-Break"><span class="koboSpan" id="kobo.689.1">fast enough.</span></span></p>
<p><span class="koboSpan" id="kobo.690.1">A </span><a id="_idIndexMarker613"/><span class="koboSpan" id="kobo.691.1">proportional-only system can oversteer when there are larger changes. </span><span class="koboSpan" id="kobo.691.2">We want to damp this out. </span><span class="koboSpan" id="kobo.691.3">We’ll adjust the </span><em class="italic"><span class="koboSpan" id="kobo.692.1">D</span></em><span class="koboSpan" id="kobo.693.1"> component to deal </span><span class="No-Break"><span class="koboSpan" id="kobo.694.1">with this.</span></span></p>
<h2 id="_idParaDest-226"><a id="_idTextAnchor227"/><span class="koboSpan" id="kobo.695.1">Adjusting the derivative gain</span></h2>
<p><span class="koboSpan" id="kobo.696.1">The </span><a id="_idIndexMarker614"/><span class="koboSpan" id="kobo.697.1">derivative component allows the robot to deal with large changes in the error and react by either damping or pulling harder if there’s a sudden change, such as oversteering, running out of wall (a corner), or finding a step change in the wall. </span></p>
<p><span class="koboSpan" id="kobo.698.1">Let’s modify our code to make it easier to work with the derivative. </span><span class="koboSpan" id="kobo.698.2">In </span><strong class="source-inline"><span class="koboSpan" id="kobo.699.1">code.py</span></strong><span class="koboSpan" id="kobo.700.1">, add </span><strong class="source-inline"><span class="koboSpan" id="kobo.701.1">,{distance_controller.derivative}</span></strong><span class="koboSpan" id="kobo.702.1"> to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.703.1">uart.write</span></strong><span class="koboSpan" id="kobo.704.1"> line after we calculate </span><span class="No-Break"><span class="koboSpan" id="kobo.705.1">the deflection:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.706.1">
    deflection = distance_controller.calculate(error, current_time - prev_time)
    prev_time = current_time
    uart.write(f"{error},{deflection}</span><strong class="bold"><span class="koboSpan" id="kobo.707.1">,"</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.708.1">      f"{distance_controller.derivative}</span></strong><span class="koboSpan" id="kobo.709.1">\n".encode())</span></pre>
<p><span class="koboSpan" id="kobo.710.1">We also need to control the derivative. </span><span class="koboSpan" id="kobo.710.2">Add the following after the </span><strong class="source-inline"><span class="koboSpan" id="kobo.711.1">P</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.712.1">command handler:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.713.1">
    elif command.startswith("D"):
      distance_controller.kd = float(command[1:])</span></pre>
<p><span class="koboSpan" id="kobo.714.1">As you can see, this sets a simple pattern, the same </span><span class="No-Break"><span class="koboSpan" id="kobo.715.1">as </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.716.1">P</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.717.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.718.1">Now, we can start this with half the P value, </span><strong class="source-inline"><span class="koboSpan" id="kobo.719.1">D0.035</span></strong><span class="koboSpan" id="kobo.720.1">, which results in fewer collisions with occasional</span><a id="_idIndexMarker615"/><span class="koboSpan" id="kobo.721.1"> bouncing. </span><span class="koboSpan" id="kobo.721.2">The following screenshot shows the robot going </span><span class="No-Break"><span class="koboSpan" id="kobo.722.1">around boxes:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer171">
<span class="koboSpan" id="kobo.723.1"><img alt="Figure 10.16 – Initial derivative graph " src="image/Figure_10.16_B18001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.724.1">Figure 10.16 – Initial derivative graph</span></p>
<p><span class="koboSpan" id="kobo.725.1">The</span><a id="_idIndexMarker616"/><span class="koboSpan" id="kobo.726.1"> preceding graph shows the derivative in orange, overlaid on the error in red, and the output in blue. </span><span class="koboSpan" id="kobo.726.2">Note that the derivative spikes are very large but can sometimes be the opposite sign of the error allowing it to dampen changes. </span><span class="koboSpan" id="kobo.726.3">The largest spikes are still walls. </span><span class="koboSpan" id="kobo.726.4">Between 10 and 15 seconds, the derivative dampens the </span><span class="No-Break"><span class="koboSpan" id="kobo.727.1">proportional output.</span></span></p>
<p><span class="koboSpan" id="kobo.728.1">A sudden distance increase, such as the end of a wall, can cause strong oscillation, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.729.1">following graph:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer172">
<span class="koboSpan" id="kobo.730.1"><img alt="Figure 10.17 – Strong derivative oscillations " src="image/Figure_10.17_B18001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.731.1">Figure 10.17 – Strong derivative oscillations</span></p>
<p><span class="koboSpan" id="kobo.732.1">In the </span><a id="_idIndexMarker617"/><span class="koboSpan" id="kobo.733.1">preceding screenshot, at around 42 seconds, the robot encounters a concave step. </span><span class="koboSpan" id="kobo.733.2">That step caused the derivative to overshoot, pushing the robot right out. </span><span class="koboSpan" id="kobo.733.3">However, this put the sensor past the obstacle and detected a long-range distance, going rapidly from too close to too far. </span><span class="koboSpan" id="kobo.733.4">The derivative swings strongly back the other way – time to stop </span><span class="No-Break"><span class="koboSpan" id="kobo.734.1">with </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.735.1">G</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.736.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.737.1">We can roughly half the value again to </span><strong class="source-inline"><span class="koboSpan" id="kobo.738.1">0.017</span></strong><span class="koboSpan" id="kobo.739.1"> for another attempt, but it will still have the same issue. </span><span class="koboSpan" id="kobo.739.2">We need to be more aggressive with reducing </span><strong class="source-inline"><span class="koboSpan" id="kobo.740.1">D</span></strong><span class="koboSpan" id="kobo.741.1"> than we were with </span><strong class="source-inline"><span class="koboSpan" id="kobo.742.1">P</span></strong><span class="koboSpan" id="kobo.743.1">. </span><span class="koboSpan" id="kobo.743.2">We can divide </span><a id="_idIndexMarker618"/><span class="koboSpan" id="kobo.744.1">the proportional constant by 10 (</span><strong class="source-inline"><span class="koboSpan" id="kobo.745.1">0.0035</span></strong><span class="koboSpan" id="kobo.746.1">) for a more stable robot. </span><span class="koboSpan" id="kobo.746.2">The resulting plot looks </span><span class="No-Break"><span class="koboSpan" id="kobo.747.1">as follows:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer173">
<span class="koboSpan" id="kobo.748.1"><img alt="Figure 10.18 – The tuned derivative graph " src="image/Figure_10.18_B18001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.749.1">Figure 10.18 – The tuned derivative graph</span></p>
<p><span class="koboSpan" id="kobo.750.1">The preceding</span><a id="_idIndexMarker619"/><span class="koboSpan" id="kobo.751.1"> screenshot shows a graph with the same properties as </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.752.1">Figure 10</span></em></span><em class="italic"><span class="koboSpan" id="kobo.753.1">.17</span></em><span class="koboSpan" id="kobo.754.1"> but using a </span><strong class="source-inline"><span class="koboSpan" id="kobo.755.1">0.0035 </span></strong><span class="koboSpan" id="kobo.756.1">setting. </span><span class="koboSpan" id="kobo.756.2">While the corners still show up as large spikes, the blue output graph is now calmer, with the derivative dampening the </span><a id="_idIndexMarker620"/><span class="koboSpan" id="kobo.757.1">output. </span><span class="koboSpan" id="kobo.757.2">The robot will now be driving quite smoothly. </span></p>
<p><span class="koboSpan" id="kobo.758.1">We may need a slightly different scenario to tune </span><span class="No-Break"><span class="koboSpan" id="kobo.759.1">the integral.</span></span></p>
<h2 id="_idParaDest-227"><a id="_idTextAnchor228"/><span class="koboSpan" id="kobo.760.1">Tuning the integral</span></h2>
<p><span class="koboSpan" id="kobo.761.1">In an environment</span><a id="_idIndexMarker621"/><span class="koboSpan" id="kobo.762.1"> with many step changes, such as driving around boxes in a room, the integral will not play as much of a part. </span><span class="koboSpan" id="kobo.762.2">Not every problem requires all three parts of the PID, and in this case, the integral may not be particularly suitable. </span><span class="koboSpan" id="kobo.762.3">Let’s set this nice and slow and find a long straight wall. </span><span class="koboSpan" id="kobo.762.4">I had to use a garden path for this (and change some values </span><span class="No-Break"><span class="koboSpan" id="kobo.763.1">to suit).</span></span></p>
<p><span class="koboSpan" id="kobo.764.1">Let’s add the integral control and output to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.765.1">code.py</span></strong><span class="koboSpan" id="kobo.766.1"> file first. </span><span class="koboSpan" id="kobo.766.2">The output is swapping </span><strong class="source-inline"><span class="koboSpan" id="kobo.767.1">{distance_controller.derivative}</span></strong><span class="koboSpan" id="kobo.768.1"> for </span><strong class="source-inline"><span class="koboSpan" id="kobo.769.1">{distance_controller.integral}</span></strong><span class="koboSpan" id="kobo.770.1"> in the </span><span class="No-Break"><span class="koboSpan" id="kobo.771.1">output line.</span></span></p>
<p><span class="koboSpan" id="kobo.772.1">We can also add this to the </span><span class="No-Break"><span class="koboSpan" id="kobo.773.1">control handling:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.774.1">
    elif command.startswith("I"):
      distance_controller.ki = float(command[1:])</span></pre>
<p><span class="koboSpan" id="kobo.775.1">This will accept a command such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.776.1">I0.001</span></strong><span class="koboSpan" id="kobo.777.1"> to set the integral. </span><span class="koboSpan" id="kobo.777.2">This is also a good starting value. </span><span class="koboSpan" id="kobo.777.3">We now have a comprehensive control system. </span></p>
<p><span class="koboSpan" id="kobo.778.1">Send </span><strong class="source-inline"><span class="koboSpan" id="kobo.779.1">M0.35</span></strong><span class="koboSpan" id="kobo.780.1"> to reduce the speed. </span><span class="koboSpan" id="kobo.780.2">We can send half the </span><strong class="source-inline"><span class="koboSpan" id="kobo.781.1">P</span></strong><span class="koboSpan" id="kobo.782.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.783.1">D</span></strong><span class="koboSpan" id="kobo.784.1"> values to match, using </span><strong class="source-inline"><span class="koboSpan" id="kobo.785.1">?</span></strong><span class="koboSpan" id="kobo.786.1"> to see what they were. </span><span class="koboSpan" id="kobo.786.2">Send </span><strong class="source-inline"><span class="koboSpan" id="kobo.787.1">I0.001</span></strong><span class="koboSpan" id="kobo.788.1"> and then </span><strong class="source-inline"><span class="koboSpan" id="kobo.789.1">G</span></strong><span class="koboSpan" id="kobo.790.1"> to start the robot against a long </span><span class="No-Break"><span class="koboSpan" id="kobo.791.1">straight wall.</span></span></p>
<p><span class="koboSpan" id="kobo.792.1">You should see some large adjustments as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.793.1">P</span></strong><span class="koboSpan" id="kobo.794.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.795.1">D</span></strong><span class="koboSpan" id="kobo.796.1"> terms settle; then, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.797.1">I</span></strong><span class="koboSpan" id="kobo.798.1"> term will settle more slowly. </span><span class="koboSpan" id="kobo.798.2">Observe the graph while driving. </span></p>
<p><span class="koboSpan" id="kobo.799.1">For this term, the strategy I use is settling on a small value and slowly incrementing it if the reaction to a constant error is too slow. </span><span class="koboSpan" id="kobo.799.2">Like the other terms, making this too high will lead to instability. </span><span class="koboSpan" id="kobo.799.3">If the starting point of </span><strong class="source-inline"><span class="koboSpan" id="kobo.800.1">0.001</span></strong><span class="koboSpan" id="kobo.801.1"> pushes the system into instability, divide it by 10 and slowly </span><span class="No-Break"><span class="koboSpan" id="kobo.802.1">increment that.</span></span></p>
<p><span class="koboSpan" id="kobo.803.1">You now have a</span><a id="_idIndexMarker622"/><span class="koboSpan" id="kobo.804.1"> strategy to tune PID values on a robot, along with a control system to </span><span class="No-Break"><span class="koboSpan" id="kobo.805.1">do so.</span></span></p>
<h2 id="_idParaDest-228"><a id="_idTextAnchor229"/><span class="koboSpan" id="kobo.806.1">Closing notes on tuning</span></h2>
<p><span class="koboSpan" id="kobo.807.1">Tuning a</span><a id="_idIndexMarker623"/><span class="koboSpan" id="kobo.808.1"> PID will take time. </span><span class="koboSpan" id="kobo.808.2">Algorithms such as Ziegler-Nichols</span><a id="_idIndexMarker624"/><span class="koboSpan" id="kobo.809.1"> can be used to solve this with mathematical modeling and will work in </span><span class="No-Break"><span class="koboSpan" id="kobo.810.1">some situations.</span></span></p>
<p><span class="koboSpan" id="kobo.811.1">Another thing to note is that changes in the system response, such as its turning circle, will alter things. </span><span class="koboSpan" id="kobo.811.2">For example, driving a robot on a carpet causes drag on the wheels, making turning slower. </span><span class="koboSpan" id="kobo.811.3">If a PID was tuned to work well on carpet, putting the same robot on wooden flooring may cause it to oversteer as its steering effort results in larger changes. </span><span class="koboSpan" id="kobo.811.4">Tune a PID for a particular behavior to the environment where you expect it to </span><span class="No-Break"><span class="koboSpan" id="kobo.812.1">be operating.</span></span></p>
<h1 id="_idParaDest-229"><a id="_idTextAnchor230"/><span class="koboSpan" id="kobo.813.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.814.1">The PID controller is a great way to build robot behavior that adjusts to sensor input. </span><span class="koboSpan" id="kobo.814.2">In this chapter, you learned what a PID controller and its components are, including where a low-pass filter makes it </span><span class="No-Break"><span class="koboSpan" id="kobo.815.1">behave better.</span></span></p>
<p><span class="koboSpan" id="kobo.816.1">The PID controller allows for dynamic responses but requires a lot of tuning to get it right. </span><span class="koboSpan" id="kobo.816.2">You’ve seen how to add a wireless control method, which is essential for tuning a PID. </span><span class="koboSpan" id="kobo.816.3">You’ve also observed the graphs of PID systems, understanding how they relate to their operations </span><span class="No-Break"><span class="koboSpan" id="kobo.817.1">and tuning.</span></span></p>
<p><span class="koboSpan" id="kobo.818.1">In the next chapter, we will be taking our PID controller and using it with encoders to drive in </span><span class="No-Break"><span class="koboSpan" id="kobo.819.1">straight lines.</span></span></p>
<h1 id="_idParaDest-230"><a id="_idTextAnchor231"/><span class="koboSpan" id="kobo.820.1">Exercises</span></h1>
<p><span class="koboSpan" id="kobo.821.1">These exercises will deepen your understanding of the topics discussed in this chapter and make the robot </span><span class="No-Break"><span class="koboSpan" id="kobo.822.1">code better:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.823.1">Enhance the settings code so that the set point can be adjusted in the same way. </span><strong class="source-inline"><span class="koboSpan" id="kobo.824.1">S&lt;set point&gt;</span></strong><span class="koboSpan" id="kobo.825.1"> is probably a </span><span class="No-Break"><span class="koboSpan" id="kobo.826.1">good idea.</span></span></li>
<li><span class="koboSpan" id="kobo.827.1">Modify the command handlers for setting PID values to stop the motors and reset the integral when these </span><span class="No-Break"><span class="koboSpan" id="kobo.828.1">values change.</span></span></li>
<li><span class="koboSpan" id="kobo.829.1">Try adapting the control code back to the distance control app used earlier in </span><span class="No-Break"><span class="koboSpan" id="kobo.830.1">this chapter.</span></span></li>
<li><span class="koboSpan" id="kobo.831.1">Try the robot wall-follow when driving on a completely different surface and adjust the PID values to get a smooth </span><span class="No-Break"><span class="koboSpan" id="kobo.832.1">wall following.</span></span></li>
</ul>
<h1 id="_idParaDest-231"><a id="_idTextAnchor232"/><span class="koboSpan" id="kobo.833.1">Further reading</span></h1>
<p><span class="koboSpan" id="kobo.834.1">These study aids will let you read on and dive deeper into the PID algorithm and </span><span class="No-Break"><span class="koboSpan" id="kobo.835.1">its quirks:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.836.1">Christopher Lam on YouTube has an excellent control theory video course: </span><a href="https://www.youtube.com/playlist?list=PLxdnSsBqCrrF9KOQRB9ByfB0EUMwnLO9o"><span class="koboSpan" id="kobo.837.1">https://www.youtube.com/playlist?list=PLxdnSsBqCrrF9KOQRB9ByfB0EUMwnLO9o</span></a><span class="koboSpan" id="kobo.838.1">. </span><span class="koboSpan" id="kobo.838.2">This uses MATLAB and goes into detail about control systems such as PID, tuning them, problems with them, modeling them, and analyzing them. </span><span class="koboSpan" id="kobo.838.3">There are at least 30 hours of content that takes a very </span><span class="No-Break"><span class="koboSpan" id="kobo.839.1">mathematical approach.</span></span></li>
<li><span class="koboSpan" id="kobo.840.1">For a deeper dive into PID control systems, consider </span><em class="italic"><span class="koboSpan" id="kobo.841.1">PID-based Practical Digital Control with Raspberry Pi and Arduino Uno</span></em><span class="koboSpan" id="kobo.842.1"> from Elektor Electronics. </span><span class="koboSpan" id="kobo.842.2">This book discusses control theory, transform functions, and PID tuning, while providing code and </span><span class="No-Break"><span class="koboSpan" id="kobo.843.1">practical examples.</span></span></li>
<li><em class="italic"><span class="koboSpan" id="kobo.844.1">PID Control Fundamentals</span></em><span class="koboSpan" id="kobo.845.1">, by Jens Graf, published via CreateSpace, is a comprehensive look at PID control systems. </span><span class="koboSpan" id="kobo.845.2">This provides more detail on each of the components and building PI, PD, and full PID algorithm </span><span class="No-Break"><span class="koboSpan" id="kobo.846.1">control systems.</span></span></li>
</ul>
</div>
</body></html>