- en: Miscellaneous Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter will cover a few miscellaneous design patterns that are quite
    useful in building larger applications. These patterns provide additional tools
    that we can leverage apart of the major patterns that we have seen so far from
    previous chapters. In a nutshell, we will explore three patterns, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The singleton type dispatch pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The stubbing/mocking pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The functional pipes pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The singleton type dispatch pattern leverages Julia's multiple dispatch feature,
    which allows you to add new functionalities without having to modify existing
    code.
  prefs: []
  type: TYPE_NORMAL
- en: The stubbing/mocking pattern can be utilized to test software components in
    isolation. It's also possible to test external dependencies without actually using
    them. It makes automated testing a lot easier.
  prefs: []
  type: TYPE_NORMAL
- en: The functional pipes pattern makes use of the pipe operator to represent a linear
    flow of execution. It is a way of programming that is adopted in many data processing
    pipelines. Some people find this concept of linear execution more intuitive. We
    will explore some examples about they may well with this pattern.
  prefs: []
  type: TYPE_NORMAL
- en: '*Let''s get started!*'
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The sample source code for this chapter is located at [https://github.com/PacktPublishing/Hands-on-Design-Patterns-and-Best-Practices-with-Julia/tree/master/Chapter09](https://github.com/PacktPublishing/Hands-on-Design-Patterns-and-Best-Practices-with-Julia/tree/master/Chapter09).
  prefs: []
  type: TYPE_NORMAL
- en: The code in this chapter has been tested in a Julia 1.3.0 environment.
  prefs: []
  type: TYPE_NORMAL
- en: Singleton type dispatch pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Julia supports dynamic dispatch, which is a specific feature of its multiple
    dispatch system. Dynamic dispatch allows the program to dispatch to the proper
    function based on the type of the function arguments at runtime. If you are familiar
    with polymorphism in terms of object-oriented programming languages, then this
    concept is similar. In this section, we will explain what singleton types are
    and how they can be used to implement dynamic dispatch.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin, let''s consider a desktop application use case where the system responds
    to user click events. Here is what the **graphical user interface** (**GUI**)
    may look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/976936e4-7904-447f-ab73-2015b753ec97.png)'
  prefs: []
  type: TYPE_IMG
- en: We will try to implement the processing function with simple logic first and
    then see how it can be improved using the singleton type dispatch pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Developing a command processor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our first attempt to implement a command process that may look similar to the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `process_command` function simply takes the command as a string. Then, depending
    on the value of the string, it will call the respective function. The `args` argument
    may be passed by the GUI code for additional information; for example, the path
    of the file that is being opened or closed.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is nothing wrong with this code from a logical perspective, but it can
    be improved, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The code contains a list of if-then-else statements. In this example, we only
    have to support four functions. In practice, we will probably have to handle many
    more functions. Having such a large if-then-else block makes the code very ugly
    and hard to maintain.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whenever we need to add a new command, we have to modify this function to include
    a new condition.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fortunately, we can make it better using singleton types and dynamic dispatch.
    We'll go over that next.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding singleton types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A singleton type is just a data type that is designed to have a single instance.
    In Julia, it can be implemented easily by defining a type without any field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To create a single instance of such a data type, we can use the following default
    constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Unlike in some object-oriented programming languages, this constructor returns
    exactly the same instance, even if you call it multiple times. In other words,
    it is already a singleton. We can prove this like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/95b2889b-a5f9-4df4-9277-c1b672422565.png)'
  prefs: []
  type: TYPE_IMG
- en: After creating two instances of `OpenCommand`, we compare them using the `===`
    operator, which tells us that these two instances are indeed referring to the
    same object. Hence, we have achieved the creation of a singleton.
  prefs: []
  type: TYPE_NORMAL
- en: Moving on, we can take the same approach and create a singleton types for each
    command, that is, `CloseCommand`, `ExitCommand`, `HelpCommand`, and so on. Furthermore,
    we can also create a new abstract type called `AbstractCommand`, which can serve
    as the supertype for all these command types.
  prefs: []
  type: TYPE_NORMAL
- en: It seems exhaustively verbose that we have to create a new type for each command.
    A better way to handle this situation is to use parametric types. Since it's a
    fairly common use case, Julia predefines a type called `Val`. Let's take a look
    at it.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Val parametric data type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Val` is a parametric data type that is defined in the Julia Base package.
    Its purpose is to provide us with an easy way to dispatch using singleton types.
    The `Val` type is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'How do we create a singleton object? We can use the `Val` constructor and pass
    it any value. For example, we can create a singleton type that embeds a value
    of 1, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d03674fd-7f84-4a68-bef0-c3bdc0a4dde2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s confirm the data type of such an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/617825ba-704a-48c4-924b-19f835d9721d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, we can see that `Val(1)` and `Val(2)` have their own types – `Val{1}`
    and `Val{2}`, respectively. Interestingly, the value being passed to the constructor
    ends up in the type signature. Again, we can prove that these are indeed singletons
    by calling the `Val` constructor twice and comparing their identities:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/66e95cb6-912d-47c4-805a-8373b30d7256.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, the `Val` constructor function can also accept a symbol as
    an argument. Note that `Val` can only accept data that is a bit type because it
    goes to the type signature. Most use cases involve the `Val` type with integers
    and symbols in the type parameter. If we try to create new `Val` objects with
    non-bits type, then we get an error, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8efc1c0a-2188-4587-b5da-627cd0d6cc4c.png)'
  prefs: []
  type: TYPE_IMG
- en: You may be wondering why we go through so much to talk about singleton types.
    This is because singleton types can be used for dynamic dispatch. Now that we
    know how to create singletons, let's learn how to utilize them for dispatch.
  prefs: []
  type: TYPE_NORMAL
- en: Using singleton types with dynamic dispatch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Julia, function calls are dispatched according to the type of the arguments
    when the function is called. For a quick introduction to this mechanism, please
    refer to [Chapter 3](6c453014-3590-4a63-9d39-9bdd735185d5.xhtml), *Designing Functions
    and Interfaces.*
  prefs: []
  type: TYPE_NORMAL
- en: Let's recall the use case that we presented earlier in this chapter about a
    command processor function. With a naive implementation, we have a large if-then-else
    block that dispatch to different functions according to the command string. Let's
    try to implement the same feature using singleton types.
  prefs: []
  type: TYPE_NORMAL
- en: 'For each command, we can define a function that takes a singleton type. For
    example, the signatures of the functions for the `Open` and `Close` events are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We didn''t have to specify any name for the first argument because we don''t
    need to use it. However, we do specify the type of the first argument to be `Val{:open}` or
    `Val{:close}`. Given such a function signature, we can handle the `Open` event
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5b252b1-cce3-4177-b36e-c070da2415ad.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Basically, we create a singleton and pass it to the function. Because the type
    signature matches, Julia will dispatch to the function we just defined in the
    preceding screenshot. Now, assuming that we have defined all other functions,
    we can write the code for the main dispatcher as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we simply convert the command into a symbol and then create a singleton
    type object by passing it to the `Val` constructor. At runtime, the proper `process_command`
    functions will be dispatched accordingly. Let''s quickly test that out:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/84106eb5-0204-449a-838d-5ff6158c230b.png)'
  prefs: []
  type: TYPE_IMG
- en: '*Fabulous!* Now, let''s pause for a moment and think about what we have just
    achieved. In particular, we can make two observations:'
  prefs: []
  type: TYPE_NORMAL
- en: The main dispatcher function in the preceding screenshot no longer has an if-then-else
    block. It just utilizes dynamic dispatch to figure out which underlying function
    to call.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whenever we need to add a new command, we can just define a new `process_command`
    function with a new `Val` singleton. There is no change to the main dispatcher
    function anymore.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It is possible to create your own parametric type rather than using the standard
    `Val` type. This can be achieved quite simply, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor function takes a string and creates a `Command` singleton object
    with a `Symbol` type parameter that is converted from the string. Having such
    a singleton type, we can define our dispatcher function and corresponding actions
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This style of code is fairly idiomatic in Julia programming – there is no conditional
    branch anymore since it is replaced by function dispatch. In addition, you also
    extend the functionality of a system by defining new functions, without the need
    to modify any existing code. This is a fairly useful characteristic when we need
    to extend functions from a third-party library.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will do some experiments and measure the performance of dynamic dispatch.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the performance benefits of dispatch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using a singleton type is nice because we can avoid writing conditional branches.
    Another side benefit is that performance can be greatly improved. An interesting
    example can be found in the `ntuple` function from Julia's Base package.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ntuple` function is used to create a tuple of N elements by applying a
    function over the sequence of 1 to N. For example, we can create a tuple of even
    numbers as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/edba9bf7-adba-4e1c-8afe-decf81c3ecdd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The first argument is an anonymous function that doubles the value. Since we
    specified 10 in the second argument, it mapped over the range of 1 to 10 and gave
    us 2, 4, 6, ... 20\. If we take a peek into the source code, we will find this
    interesting definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'While the code is indented quite nicely, we can clearly see that it supports
    up to 10 elements by hard coding the short-circuit branches with the `?` and `:` ternary
    operators. If it''s more than 10, then it calls another function to create the
    tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This `_ntuple` function is expected to perform poorly because it creates an
    array using comprehension and then the result is splatted into a new tuple. You
    may be very surprised by the performance benchmarking result when we compare the
    case of creating a 10-element tuple versus an 11-element tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d37679bc-bcb4-4bf7-9af2-e0fb7c398352.png)'
  prefs: []
  type: TYPE_IMG
- en: The `ntuple` function is designed to perform optimally when the number of elements
    is small, that is, for 10 or fewer elements. It would be possible to change the
    `ntuple` function to hardcode more, but it would be too tedious to write the code,
    and the resulting code would be extremely ugly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perhaps a little more surprisingly, Julia actually comes with another variation
    of the same function while using the `Val` singleton type, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0a146254-a816-4277-9f65-161d4f3b2dee.png)'
  prefs: []
  type: TYPE_IMG
- en: 'There is literally no difference between 10 and 11 elements. In fact, even
    with 100 elements, the performance is quite reasonable (17 nanoseconds) compared
    to the non-`Val` version (820 nanoseconds). Let''s take a look at how it is implemented.
    The following has been taken from the Julia source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding code, we can see that there are a few functions being defined
    for tuples that have fewer than four elements. After that, the function uses a
    meta-programming technique to generate code on the fly. In this case, it uses
    a special construct that allows the compiler to choose between code generation
    and its generic implementation, which is represented in if-blocks and else-blocks
    in the code. Looking at how the `@generated`, `@nexprs`, and `@ncalls` macros
    work is out of the scope of this section, but you are encouraged to find out more
    from the Julia reference manual.
  prefs: []
  type: TYPE_NORMAL
- en: According to our preceding performance test, calling `ntuple` with `Val(100)` was
    quite fast, so it appears that the compiler has chosen the code generation path.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, we have learned how to use parametric types to create new singletons
    and create functions that are dispatched by these singleton types. We can apply
    this pattern whenever we need to handle such conditional branches.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will learn how to develop automated testing code effectively using
    stubs and mocks.
  prefs: []
  type: TYPE_NORMAL
- en: Stubbing/Mocking pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Julia comes with excellent tools for building automated unit tests. When the
    programmer follows good design patterns and best practices, the software is likely
    going to be composed of many small functions that can be tested individually.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, certain test cases are more difficult to handle. They usually
    involve testing components that have specific dependencies that are awkward to
    be included in automated tests. Common issues include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Performance**: The dependency may be a time-consuming process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cost**: The dependency may incur a financial cost every time it is invoked.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Randomness**: The dependency may produce a different result every time it
    is invoked.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stubbing/Mocking is a common strategy to address these issues. In this section,
    we will look into how to apply stubs and mocks while testing Julia code.
  prefs: []
  type: TYPE_NORMAL
- en: What are testing doubles?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we get into the specifics about stubbing/mocking, it would be helpful
    to go over some industry-standard terminology. First of all, there is the concept
    of *testing doubles*. Interestingly, the term comes from a movie-making technique
    that's related to how stunts are filmed. When performing dangerous acts, a stuntman
    or stuntwoman replaces the actor or actress to perform the job. From a viewer's
    perspective, it would look like the original actor or actress was performing.
    Testing doubles are the same in the sense that a fake component is used in place
    of the real thing during testing.
  prefs: []
  type: TYPE_NORMAL
- en: There are multiple types of testing doubles, but the most useful ones are *stubs*
    and *mocks*, which we will focus on in this section. In object-oriented programming,
    these concepts are expressed in terms of classes and objects. In Julia, we will
    leverage the same terminology for functions. One benefit of working with functions
    is that we can focus all of our effort on testing a single thing.
  prefs: []
  type: TYPE_NORMAL
- en: 'A **stub** is a fake function that imitates the real function, also known as
    the *collaborator function*. Depending on what is required from the testing objectives,
    they can be as dumb as returning the same result all the time, or they can be
    a little smarter and return different values, depending on the input arguments.
    Regardless of how smart they are, return values are almost always hardcoded for
    consistency reasons. During testing, stubs replace the collaborator function when
    the **function under test** (**FUT**) is being exercised. When the FUT finishes
    its execution, we can determine the correctness of the returned value. This is
    called *state verification*. The interaction between these functions can be depicted
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/83731e39-751b-414f-a05c-d6d91115f015.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A **mock** is also a fake function that imitates the collaborator function.
    The difference between mocks and stubs is that a mock focuses on behavior verification.
    Rather than just examining the state of the FUT, mocks keep track of all the calls
    being made. It can be used to verify behavior, such as how many times the mock
    is expected to be called, the types and values of the arguments that the mock
    expected to be passed, and so on. This is called *behavior verification*. At the
    end of their execution, we can perform both state verification and behavior verification. This
    is depicted as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f0022792-8675-41c0-a4da-970a06c2352f.png)'
  prefs: []
  type: TYPE_IMG
- en: In the upcoming sections, we will focus on how to apply stubs and mocks in testing.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the credit approval use case
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we''ll introduce a sample use case related to credit approval.
    Suppose that you are developing a system that has the ability to open a new credit
    card account for a customer upon a successful background check. You may create
    a Julia module that has the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s implement each of the functions. We''ll start with the `check_background`
    function, which just logs the event and returns true, meaning that the background
    check is successful. Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `create_account` function is similar to this. In this case, the expected
    behavior is to return an account number, that is, an integer value that refers
    to the account that has just been created. For this example, we just return a
    hardcoded value of 1, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `notify_customer` function is supposed to send an email to the customer.
    For testing purposes, we will just log the event; nothing needs to be returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the `open_account` function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This is the FUT in our example. The logic involves checking the background for
    a customer and creating an account and notifying downstream about the new account
    if the background check is successful.
  prefs: []
  type: TYPE_NORMAL
- en: Let's think about how to test the `open_account` function. The obvious thing
    that needs our attention is the background check code. More specifically, we expect
    two possible execution paths – when the background check is successful and when
    the background check fails. If we need to cover both cases, then we need to be
    able to simulate the different return values of the `check_background` function.
    We will do that next with a stub.
  prefs: []
  type: TYPE_NORMAL
- en: Performing state verification using stubs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our goal is to test the `open_account` function with two scenarios, where the
    `check_background` function returns either true or false. When a background check
    is successful, we expect `open_account` to return `:success`. Otherwise, it should
    return `:failure`.
  prefs: []
  type: TYPE_NORMAL
- en: Using our terminology, `open_account` is the function under test, while `check_background`
    is the collaborator function. It is a bit unfortunate that we can't really control
    how the collaborator function behaves. In practice, this function may even reach
    out to a background check service, the working of which we have little influence
    on. As a matter of fact, we would not want to call the remote service every single
    time that we test our software.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have copied from the original `CreditApproval` module to a new module
    called `CreditApprovalStub`, we can move on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we are smart programmers, we can just create a stub that replaces the
    collaborator function. As functions are first-class in Julia, we can refactor
    the `open_account` function so that it can take any background check function
    from a keyword argument, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The new `checker` keyword argument takes a function that is used to perform
    a background check for a customer. We have set the default value to the original
    `check_background` function, so it should behave the same as before. Now, the
    function is more testable.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our test suite, we can now exercise both execution paths, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have created two stubs for background checks: `check_background_success`
    and `check_background_failure`. They return true and false to simulate a successful
    and failed background check, respectively. Then, when we need to test the `open_account`
    function, we can just pass these stub functions via the `checker` keyword argument.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run the test now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3167bd6e-aff8-4ad0-8535-7952bbd8e10f.png)'
  prefs: []
  type: TYPE_IMG
- en: At this point, we have only enabled the `check_background` function for stubbing
    in the `open_account` function. What if we want to do the same for the `create_account`
    and `notify_downstream` functions? It would be just as easy if we created two
    more keyword arguments and called it done. This isn't a bad option. However, you
    may not be very satisfied with the fact that we need to keep changing the code
    to make new tests. Furthermore, these keyword arguments were added merely for
    the sake of testing, rather than being a part of the call interface.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will explore the use of the Mocking package, which is
    an excellent tool for applying stubs and mocks without messing too much with the
    source code.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing stubs with the Mocking package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A good alternative to implementing stubs is the Mocking package. This package
    is fairly straightforward to use. We will quickly go over how to use Mocking to
    apply the same stubs that we applied earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to follow this exercise, you can copy the code from the original `CreditApproval`
    module to a new module called `CreditApprovalMockingStub`. Now, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, make sure that the Mocking package is installed. Then, modify the function
    under test, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `@mock` macro creates an injection point where a stub can be applied, replacing
    the existing call to the collaborator function, that is, `check_background`. Under
    normal execution conditions, the `@mock` macro simply calls the collaborator function.
  prefs: []
  type: TYPE_NORMAL
- en: 'During testing, however, a stub can be applied. To achieve such behavior, we
    need to activate mocking at the top of the test script, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we can define stub functions using the `@patch` macro:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `@patch` macro can be placed right in front of a function definition. The
    function name must match the original collaborator function name. Likewise, the
    function arguments should match as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `@patch` macro returns an anonymous function that can be applied to the
    call site in the FUT. To apply a patch, we use the `apply` function, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `apply` function takes the stub and applies it to everywhere that the collaborator
    function is called, as identified by the `@mock` macro in the function under test.
    Let''s run the test from the REPL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f6b663ef-9c64-4867-aaf4-f0506f33e17f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s make sure that the stubs are not applied under normal execution
    conditions. From the REPL, we can call the function directly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f8d540fc-ed9d-44e7-bf76-e8fa5ca204e4.png)'
  prefs: []
  type: TYPE_IMG
- en: '*Fabulous!*From the preceding output, we can see that the original collaborator
    function, `check_background`, was called.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will expand on the same idea and apply multiple stubs to the same function.
  prefs: []
  type: TYPE_NORMAL
- en: Applying multiple stubs to the same function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our example, the `open_account` function calls several dependent functions.
    It performs background checks for a customer, creates the account, and notifies
    downstream systems. Practically speaking, we may want to create stubs for all
    of them. How do we apply multiple stubs? The Mocking package supports this feature.
  prefs: []
  type: TYPE_NORMAL
- en: 'As usual, we would need to decorate the `open_account` function with a `@mock`
    macro for every function that we want to apply to our stubs. The following code
    shows this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we''re all set to create more stubs. For demonstration purpose, we will
    define another stub for the `create_account` function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'As part of its design, this stub function must return an account number. Therefore,
    we are just returning a fake value of 314\. To test the scenario where both `check_background_success_patch`
    and `create_account_patch` are applied, we can pass them as an array to the `apply`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Note that we have not provided any stub for the `notify_downstream` function.
    When a stub is not provided, the original collaborator function is used. Hence,
    we have all the flexibility we want in applying stub functions in our test suite.
    In the `open_account` function, since we have placed `@mock` in three different
    injection points, we can technically test eight different scenarios, for which
    each stub is enabled or disabled.
  prefs: []
  type: TYPE_NORMAL
- en: The complexity of tests for the FUT increases exponentially by the number of
    branches and functions that are used inside the function. This is also one of
    the reasons why we want to write small functions. Due to this, it is a good idea
    to break down large functions into smaller ones so that they can be tested independently.
  prefs: []
  type: TYPE_NORMAL
- en: Using stubs, we can easily verify the expected return value for a function.
    A different approach is mocking, which shifts the focus to verifying the behavior
    of the FUT and its collaboration functions. We will look into that next.
  prefs: []
  type: TYPE_NORMAL
- en: Performing behavior verification using mocks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Mocks are different from stubs – rather than just testing the return value
    of a function, we focus on testing expectations from the collaborator functions''
    perspective. What kind of activities does a collaborator function expect? Here
    are some examples for our use case:'
  prefs: []
  type: TYPE_NORMAL
- en: From the `check_background` function's perspective, was it called only once
    for each `open_account` call?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From the `create_account` function's perspective, was it called when a background
    check was successful?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From the `create_account` function's perspective, was it not called when the
    background check failed?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From the `notify_account` function's perspective, was it called with an account
    number that is greater than 0?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The process to set up a mock-enabled test involves four main steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Set up the mock functions that will be used during the test.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Establish the expectations for the collaborator functions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the tests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verify the expectations that we set earlier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let''s try to develop our own mock test. Here, we will exercise the success
    path for opening a new account. In this case, we can expect the `check_background`,
    `create_account`, and `notify_downstream` functions to be called exactly once.
    Also, we can expect that the account number being passed to the `notify_downstream`
    function should be a number greater than 1\. Keeping this information in mind,
    we will create a let-block with bound variables to track everything that we want
    to test against our expectations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The first three variables will be used to track the number of calls to the
    three mocks that we are about to create. Also, the last variable will be used
    to record whether the `notify_downstream` function received a proper account number
    during the test. Within this let-block, we will implement the four steps we outlined
    previously. Let''s define the mock functions first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we just increment the `check_background_call_count` counter within the
    mock function so that we can keep track of how many times the mock function is
    called. Similarly, we can define the `create_account_patch` mock function in the
    same way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The last mock function, `notify_downstream_patch`, covers two expectations.
    Not only does it keep track of the number of calls, but it also verifies that
    the account number being passed is proper and, if so, updates the Boolean flag.
    The following code shows this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The second step is to establish our expectation formally. This can be defined
    as a simple function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The `verify` function includes a set of expectations, formally defined as regular
    Julia tests. Now, we are ready to exercise our test by applying all three mock
    functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, as the very last step, we will test against our expectation. It is
    simply a call to the `verify` function that we defined earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we are ready to run the mock test. The respective results are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cf26ccee-e303-4386-88c2-d76e934bee99.png)'
  prefs: []
  type: TYPE_IMG
- en: The result statistics show five test cases in total and all of them passed.
    Four out of the five tests came from the `verify` function for behavior verification,
    while one came from the state verification for the return value of the `open_account`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, mocks are quite different from stub because they are used to
    perform both behavior and state verifications.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will look into a pattern that's related to how data pipelines can be
    built more intuitively.
  prefs: []
  type: TYPE_NORMAL
- en: Functional pipes pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, when building an application, we face a large problem that requires
    complex calculations and data transformation. Using structured programming techniques,
    we can often break down the large problem into medium-sized problems and then
    break these down further into small-sized problems. When a problem is small enough,
    we can write functions to tackle each problem individually.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, these functions do not work in isolation – it is more likely that
    the results of one function will feed into another function. In this section,
    we will explore the functional pipes pattern, which allows data to be passed seamlessly
    through a data pipeline. This is not uncommon in functional programming languages
    but is seen less in Julia. Nevertheless, we will take a look and see how it can
    be done.
  prefs: []
  type: TYPE_NORMAL
- en: First, we will go over a sample use case related to downloading recent Hacker
    News stories for analysis. Then, we will progressively refactor the code into
    using the functional pipes pattern. Let's go!
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the Hacker News analysis use case
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Hacker News is a popular online forum that's used by software developers. The
    topics on this forum are usually related to technology, but not always. The stories
    are ranked according to the number of votes by users, respective timeliness, and
    other factors. Every story has a score associated with it.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will develop a program that retrieves the top stories from
    Hacker News and calculates an average score of those stories. More information
    about the Hacker News API can be found in the following GitHub repository: [https://github.com/HackerNews/API](https://github.com/HackerNews/API).
    Here, you can quickly go over the process of retrieving stories and details about
    each story.
  prefs: []
  type: TYPE_NORMAL
- en: Fetching top story IDs on Hacker News
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we will create a module called `HackerNewsAnalysis`. The very first
    function is going to retrieve the top stories from Hacker News. The code for this
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'How does it work? Let''s try it out:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/11d3946d-238d-48c9-8b75-665dafb60b92.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s take several steps and dissect the logic in this function. The top stories
    can be retrieved from a fixed URL. Here, we have used the HTTP package for fetching
    data from web services. The `HTTP.request` function call, if successful, returns
    an `HTTP.Message.Response` object. It is easy to verify from the REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b969a9a6-2a41-4438-a89d-f56e27943147.png)'
  prefs: []
  type: TYPE_IMG
- en: 'So, how do we get the content from the `Response` object? It is available from
    the `body` field. As it turns out, the `body` field is just a byte array. To understand
    what the data means, we can convert it into a `String`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/df1b8b94-11b8-47e7-8cba-c22c6f14acbe.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Judging from the output, we can see that it is in JSON format. We can also
    verify the same by visiting the web URL from a browser. From the API documentation,
    we know that the numbers represent story IDs from Hacker News. To parse the data
    into usable Julia data types, we can leverage the `JSON3` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d256434e-2e77-4bad-ad88-f14c3eb11456.png)'
  prefs: []
  type: TYPE_IMG
- en: The `JSON3.Array` object is a lazy version of an array. By design, JSON3 does
    not extract the value until you ask for it. We can use it as if it were a regular
    Julia array. For more information, you are encouraged to visit JSON3's documentation
    on GitHub: [https://github.com/quinnj/JSON3.jl/blob/master/README.md](https://github.com/quinnj/JSON3.jl/blob/master/README.md).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have an array of story IDs, we will develop the function for retrieving
    detailed information about a Hacker News story.
  prefs: []
  type: TYPE_NORMAL
- en: Fetching details about a story
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Given a story ID, we can retrieve information about the story using the `item`
    endpoint of the Hacker News API. Before we write the function, let''s define a
    type to store the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The fields of a `Story` are designed according to the JSON schema documented
    on the Hacker News API website. Sometimes, a field may be unavailable for certain
    story types, in which case we will leave them as `nothing` in the object. These
    optional fields include `descendants`, `kids`, and `url`. Lastly, every story
    comes with a unique identifier `id`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need a constructor to create `Story` objects. Because JSON3 returns a dictionary-like
    object, we can just extract individual fields and pass them to the constructor.
    The constructor''s function can be defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Generally, we can extract the field from a `Dict` object using the index operator
    (square brackets). However, we need to handle the fact that some fields may be
    unavailable in the object. To avoid an unexpected `KeyError`, we can define a
    closure function called `value` for extracting a field or returning `nothing`
    when the key is not found in the object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at the function for retrieving the details of a single
    story:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, we retrieve the data using `HTTP.request`. After we receive the response,
    we can parse the data using JSON3 and construct a `Story` object accordingly.
    Here''s how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4e8dfc3f-df1d-4b92-be7b-43656a6713d3.png)'
  prefs: []
  type: TYPE_IMG
- en: Next, we will go over the main program for calculating the average score for
    the top N stories from Hacker News.
  prefs: []
  type: TYPE_NORMAL
- en: Calculating the average score for the top N stories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have the ability to find the top stories and retrieve details about
    each story, we can create a new function to calculate an average score from the
    top N stories.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `average_score` function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'There are three parts to this function:'
  prefs: []
  type: TYPE_NORMAL
- en: The first part finds the story IDs for top stories using the `fetch_top_stories`
    function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, it retrieves details of the first `n` stories using the `fetch_story`
    function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, it calculates the average score from just those stories. Then, the
    average score is returned to the caller.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In order to get the top `n` story IDs, we have chosen to use the index operator
    with the range `1:min(n,end)`. The `min` function is used to handle the case when
    `n` is greater than the size of the array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run the function and see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/58abdc3a-b34c-4f72-a864-1e982c6181cd.png)'
  prefs: []
  type: TYPE_IMG
- en: From the result, we can see that the top `n` stories from Hacker News have an
    average score of 125.4\. Note that you may get a different result since this number
    changes in real time as Hacker News users vote on their favorite stories.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the use case has been established, we will leap forward and experiment
    with a different way of writing the same program. We call this style of programming
    *functional pipes*.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding functional pipes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Julia, there is a pipe operator that can be used to pass data from one function
    to another. The concept is very simple. First, let's take a look at some examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous section, we developed a `fetch_top_stories` function that''s
    used to retrieve the current top stories from Hacker News. The return value is
    a `JSON3.Array` object that looks like an array of integers. Let''s say we want
    to find the first story ID from the array. To do this, we can create a pipe operation,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/229a17c3-b359-4565-8ac5-a52df569fcea.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The pipe operator `|>` is actually defined as a regular function in Julia,
    just like how `+` is defined as a function. Note that the preceding code is syntactically
    equivalent to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a552b267-2943-49a1-b204-cde7e323d37f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In addition, we can use multiple pipe operators in an expression. For example,
    we can retrieve the details of the first story by appending the `fetch_story`
    function at the end of the pipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a132a714-c648-4b1d-b6ee-276278dab5d3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Because the data naturally flows from left to right, this is called a functional
    pipe pattern. This can be seen in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/27f8a457-078e-41db-9389-2e0797fd83a6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Note that every function that follows the piping operator must accept a single
    argument. In the preceding example, we can see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The `first` function takes an array and returns the first element.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `fetch_story` function takes an integer of the story ID and returns a `Story`
    object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is a very important point, so let me say this once again – *a functional
    pipe only feeds data to single-argument functions*.
  prefs: []
  type: TYPE_NORMAL
- en: We will learn about how to deal with this constraint later. For now, we will
    talk about a similar pattern where the syntax is written in reverse compared to
    functional pipes. This concept is called composability, and is a design technique
    that leads to highly reusable code.
  prefs: []
  type: TYPE_NORMAL
- en: Designing composable functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, you may hear other Julia programmers talk about composability. What
    does that mean?
  prefs: []
  type: TYPE_NORMAL
- en: Composability is used to describe how easily functions can be assembled in different
    ways to achieve different results. Let's look at an analogy. I would say that
    Lego has a highly composable design. This is because almost every piece of Lego
    can be combined with any other piece of Lego, even if they have different shapes.
    For that reason, any kid can use Lego to build almost anything imaginable.
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to system design, we can also keep composability in mind. If we
    could build our functions so that they can be composed easily, then we would have
    the flexibility to build many different things as well. In Julia, we can compose
    functions quite easily.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use the same example from the previous section. We will create a new
    function called `top_story_id` that retrieves the first story ID from Hacker News:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/71baa434-d1e6-41b1-a26c-b6d9e27af910.png)'
  prefs: []
  type: TYPE_IMG
- en: 'From the preceding code, we can see that the `top_story_id` function is defined
    as an anonymous function. The Unicode circle symbol (`∘`, input as `\circ`) is
    the compose operator in Julia. Unlike the pipe operator, we read the order of
    composed functions from right to left. In this case, we apply the `fetch_top_stories` function
    first and then apply the `first` function. Intuitively, we can use the `top_story_id`
    function as usual:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9779ab10-0cc4-453a-a454-f61e49b7b1bf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can also compose multiple functions. To get the top story details, we can
    compose a new function called `top_story`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/939b8ad1-ba1b-44b2-9bd4-162a7f7d8342.png)'
  prefs: []
  type: TYPE_IMG
- en: '*This is great!* We have taken three random Lego blocks and built a new thing
    out of them. The `top_story` function is a new thing that is composed of three
    smaller blocks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ee9e6815-8318-412d-818f-e2d3ef5a1fe5.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's go one step further and create a new function to retrieve the title of
    the top story. Now, we run into a little trouble. No function that returns the
    story title from a `Story` object has been defined. However, we can solve this
    problem by utilizing the Accessors Pattern, which we described in [Chapter 8](6b565339-641f-444c-ad42-f8ff7998001b.xhtml),
    *Robustness Patterns*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s define an accessor for the title field and then compose a new `top_story_title`
    function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6f93e148-a75d-446a-9543-3d52cb7e52fa.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This new function works beautifully, as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6045db13-c177-4561-a5ad-d1ea102a83d9.png)'
  prefs: []
  type: TYPE_IMG
- en: The compose operator allows us to create a new function that is composed of
    several other functions. It is slightly more convenient than the pipe operator
    in the sense that the composed function doesn't need to be executed right away.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to functional pipes, the compose operator also expects single-argument
    functions. Having said that, it is also the reason why single-argument functions
    are more composable.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will go back and revisit the Hacker News `average_score` function and
    see how we can refactor the code into the functional pipe style.
  prefs: []
  type: TYPE_NORMAL
- en: Developing a functional pipe for the average score function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, let''s recap on how the `average_score` function was written:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Although the code looks quite decent and simple to understand, let me point
    out some potential issues:'
  prefs: []
  type: TYPE_NORMAL
- en: The top stories are retrieved via array comprehension syntax. The logic is a
    little busy and we won't be able to test this part of the code independently from
    the `average_score` function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `println` function is used for logging, but we seem to be replicating the
    code to display the current timestamp.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, we will refactor the code. The logic is largely linear, which makes it
    a good candidate for functional pipes. Conceptually, this is what we think about
    the computation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c8f6a9fa-b301-47d9-b72e-17ba0d97f58b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It would be nice to design a function that works like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This is our second version of the same function, so we have named it `average_score2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, we just ignore the logging aspect to keep it simple. We will come
    back to this later. Since we have already defined the `fetch_top_stories` function,
    we just have to develop the other three functions, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'From the preceding code, we can see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The `take` function takes an integer, `n`, and returns an anonymous function
    that returns the first `n` elements from an array.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `min` function is used to ensure that it will take no more than the actual
    size of the array.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `fetch_story_details` function takes an array of story IDs and broadcasts
    the `fetch_story` function over them using the dot notation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `calculate_average_score` function takes an array of `Story` objects and
    calculates the mean of the scores.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a quick reminder, all of these functions accept a single argument as input
    so that they can participate in the functional pipe operation.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's get back to logging. Logging plays a funny role in functional pipes.
    It is designed to produce side effects and do not affect the result of computation.
    It is *slippery* in the sense that it just returns the same data that it received
    from its input. Since the standard `println` function returns nothing, we cannot
    use it directly in a piping operation. Instead, we must create a logging function
    that is smart enough to print what we want and yet returns the same data that
    it was passed.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, we want to be able to format the output using the data that passes
    through the system. For that reason, we can utilize the `Formatting` package.
    It contains a flexible and efficient formatting facility. Let''s build our own
    logging function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The `logx` function takes a format string and a possible transformer function, `f`.
    It returns an anonymous function that passes the transformed value to the `printfmln`
    function. It also automatically prefixes the log with the current timestamp. Most
    importantly, this anonymous function returns the original value of the argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how this logging function works, we can play with a few examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/badbdf09-9008-486e-9c28-5178db123ad0.png)'
  prefs: []
  type: TYPE_IMG
- en: In the first example shown in the preceding screenshot, the `logx` function
    was called with just a format string, so the input coming via the pipe will be
    used as-is in the log. The second example passes the `length` function as the
    second argument of `logx`. The `length` function is then used to transform the
    input value for logging purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Putting this all together, we can introduce logging to our functional pipe
    in our new `average_score3` function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Occasionally, functional pipes can make the code easier to understand. Because
    conditional statements are not allowed in a piping operation, the logic is always
    linear.
  prefs: []
  type: TYPE_NORMAL
- en: You may be wondering how to handle conditional logic in functional pipe design.
    We'll learn about this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing conditional logic in functional pipes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since the logical flow is quite linear, how do we deal with conditional logic?
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we want to determine the hotness of top stories by checking the average
    score against a threshold. If the average score is higher than 100, then it would
    be considered high; otherwise, it would be considered low. So, literally, we need
    an if-statement that determines what to execute next.
  prefs: []
  type: TYPE_NORMAL
- en: We can use dynamic dispatch to solve this problem. We are going to build this
    function from the bottom-up, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `hotness` function, which determines the hotness of the Hacker News
    site by score. It returns an instance of the `Val{:high}` or `Val{:low}` parametric
    type. The built-in `Val` data type is a convenient way to create new parametric
    types that can be used for dispatch purposes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Create two `celebrate` functions with respect to the `Val` parametric types.
    They simply use the `logx` function to print some text. We call it with the value
    of `v` so that the hotness argument is passed downstream if we ever want to do
    more work after celebration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Build the `check_hotness` function, which uses a functional pipe pattern. It
    uses the `average_score3` function to calculate the average score. Then, it uses
    the `hotness` function to determine how to change the execution path. Finally,
    it calls the `celebrate` function via the multiple dispatch mechanism:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s test this out:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/374a2225-7a96-4ded-8ff8-1cb54906358f.png)'
  prefs: []
  type: TYPE_IMG
- en: This simple example demonstrates how conditional logic can be implemented in
    functional pipe design. Of course, in reality, we would have more complex logic
    than just printing something to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'An important observation is that functional pipes only handle linear execution.
    Hence, whenever the execution splits conditionally, we would form a new pipe for
    each possible path. The following diagram depicts how an execution path may be
    designed with functional pipes. Each split of execution is enabled by dispatching
    over the type of a single argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eea27711-3695-463d-8b04-e66e43f2f0e4.png)'
  prefs: []
  type: TYPE_IMG
- en: Functional pipes look fairly simple and straightforward from a conceptual point
    of view. However, they are sometimes criticized for having to pass intermediate
    data between each component in the pipe, causing unnecessary memory allocation
    and slowness. In the next section, we will go over how to use broadcasting to
    overcome this issue.
  prefs: []
  type: TYPE_NORMAL
- en: Broadcasting along functional pipes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a data processing pipeline, we may encounter a situation where the functions
    can be fused together into a single loop. This is called *broadcasting *and it
    can be conveniently enabled by using the dot notation. Using broadcasting may
    make a huge performance difference for data-intensive applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following scenario, where two vectorized functions have already
    been defined, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The `add1v` function takes a vector and increments all the elements by 1\.
    Likewise, the `mul2v` function takes a vector and multiplies every element by
    2\. Now, we can combine the functions to create a new one that takes a vector
    and sends it down the pipe to `add1v` and subsequently `mul2v`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'However, the `add1mul2v` function is not optimal from a performance perspective.
    The reason for this is that each operation must be fully completed and then passed
    to the next function. The intermediate result, while only needed temporarily,
    must be allocated in memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5a64914-0132-490a-bd82-f55aae4c0fcc.png)'
  prefs: []
  type: TYPE_IMG
- en: As depicted in the preceding diagram, besides the input vector and the output
    vector, an intermediate vector must be allocated to hold the results from the
    `add1v` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to avoid the allocation of the intermediate results, we can utilize
    broadcasting. Let''s create another set of functions that operate on individual
    elements rather than arrays, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Our original problem still requires taking a vector, adding 1, and multiplying
    by 2 for every element. So, we can define such a function using the dot notation,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The dot character right before the pipe operator indicates that the elements
    in `xs` will be broadcast to the `add1` and `mul2` functions, fusing the whole
    operation into a single loop. The data flow now looks more like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/170e5aeb-9ac8-430c-ba2a-accbeb830d8a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, the intermediate result becomes a single integer, eliminating the need
    for the temporary array. To appreciate the performance improvement we get from
    broadcasting, we can run a performance benchmark for the two functions, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/35b7e0a6-5e15-468b-a5f4-e2ff5a4f4a42.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the broadcasting version ran twice as fast as the vectorized
    version in this scenario.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will review some considerations about using functional
    pipes.
  prefs: []
  type: TYPE_NORMAL
- en: Considerations about using functional pipes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before you get too excited about functional pipes, let's make sure that we understand
    the pros and cons of using functional pipes.
  prefs: []
  type: TYPE_NORMAL
- en: From a readability perspective, functional pipes can possibly make the code
    easier to read and easier to follow. This is because the logic has to be linear.
    On the contrary, some people may find it less intuitive and harder to read because
    the direction of computation is reversed as compared to nested function calls.
  prefs: []
  type: TYPE_NORMAL
- en: 'Functional pipes require single-argument functions, for which they can be easily
    composed with other functions. When it comes to functions that require multiple
    arguments, the general solution is to create *curried functions* – higher-order
    functions that fix an argument. Previously, we defined a `take` function that
    takes the first few elements from a collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The `take` function is a curried function made out of the `getindex` function
    (with a convenient syntax of using square brackets). The `getindex` function takes
    two arguments: a collection and a range. Because the number of arguments has been
    reduced to 1, it can now participate in the functional pipe.'
  prefs: []
  type: TYPE_NORMAL
- en: On the flip side, we cannot utilize multiple dispatch for single-argument functions.
    This could be a huge disadvantage when you are handling logic that requires consideration
    of multiple arguments.
  prefs: []
  type: TYPE_NORMAL
- en: While functions can only accept single arguments, it is possible to work around
    the issue by using tuples. Tuples have a composite type signature that can be
    used for dispatch. However, it's not recommended because it is quite awkward to
    define functions that take a single tuple argument rather than multiple arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Nevertheless, functional pipes can be a useful pattern under certain circumstances.
    Any data-processing task that fits into a linear process style could be a good
    fit.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about several patterns that can be quite useful
    in application design.
  prefs: []
  type: TYPE_NORMAL
- en: We started with the singleton type dispatch pattern. Using a command processor
    example, we successfully refactored the code from using if-then-else conditional
    statements to utilizing dynamic dispatch. We learned how to create new singleton
    types using the standard `Val` type or rolling our own parametric type.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we switched gears and discussed how to implement automated testing effectively
    using the stubbing/mocking pattern. We took a simple use case of a credit approval
    process and experimented with a simple way to inject stubs using keyword arguments.
    We weren't very satisfied with the need to change the API for testing, so we leaned
    on the Mocking package for a more seamless approach. We then learned how to replace
    function calls with stubs and mocks in our test suite and how they work differently.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we learned about the functional pipes pattern and how it can make the
    code easier to read and follow. We learned about composability and how the compose
    operator works similarly to the pipe operator. We went over how to develop efficient
    code using functional pipes and broadcasting. Finally, we discussed the pros and
    cons of using functional pipes and other related considerations.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will turn around and look at some anti-patterns of Julia
    programming.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What predefined data type can be used to conveniently create new singleton types?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the benefits of using singleton type dispatch?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why do we want to create stubs?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between mocking and stubbing?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does composability mean?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the primary constraint of using functional pipes?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How are functional pipes useful?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
