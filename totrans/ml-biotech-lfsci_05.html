<html><head></head><body>
		<div id="_idContainer082">
			<h1 id="_idParaDest-65"><a id="_idTextAnchor066"/><span class="koboSpan" id="kobo.1.1">Chapter 4: Visualizing Data with Python</span></h1>
			<p><span class="koboSpan" id="kobo.2.1">Regardless of the field of work you operate in, the career path you've chosen, or the specific project you are working on, the ability to effectively communicate information to others will always be useful. </span><span class="koboSpan" id="kobo.2.2">In fact, exactly one hundred years ago, in 1921, Frederick R. </span><span class="koboSpan" id="kobo.2.3">Barnard first said something which has become a phrase you have probably heard countless times: </span><em class="italic"><span class="koboSpan" id="kobo.3.1">A picture is worth a thousand words</span></em><span class="koboSpan" id="kobo.4.1">.</span></p>
			<p><span class="koboSpan" id="kobo.5.1">With the many new technologies that have emerged in the realm of machine learning in recent years, the amount of data being structured, processed, and analyzed has grown exponentially. </span><span class="koboSpan" id="kobo.5.2">The ability to take data in its raw form and translate it to a meaningful and communicative diagram is one of the most sought-after skill sets in the industry today. </span><span class="koboSpan" id="kobo.5.3">Most decisions made in large companies and corporations are generally data-driven, and the best way to start a conversation about an area you care about is to create a meaningful visualization about it. </span><span class="koboSpan" id="kobo.5.4">Consider the following:</span></p>
			<ul>
				<li><span class="koboSpan" id="kobo.6.1">The human brain is able to process visualizations 60,000 times faster than text.</span></li>
				<li><span class="koboSpan" id="kobo.7.1">Nearly 90% of all information processed by the human brain is done visually.</span></li>
				<li><span class="koboSpan" id="kobo.8.1">Visualizations are 30 times more likely to be read than even simple text.</span></li>
			</ul>
			<p><span class="koboSpan" id="kobo.9.1">Visualizations are not always about driving a conversation or convincing an opposing party to agree on something – they are often used as a means to investigate and explore data for the purposes of uncovering hidden insights. </span><span class="koboSpan" id="kobo.9.2">In almost every machine learning project you undertake, a significant amount of effort will be devoted to exploring data to uncover its hidden </span><strong class="bold"><span class="koboSpan" id="kobo.10.1">features</span></strong><span class="koboSpan" id="kobo.11.1"> through a process known as </span><strong class="bold"><span class="koboSpan" id="kobo.12.1">Exploratory Data Analysis</span></strong><span class="koboSpan" id="kobo.13.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.14.1">EDA</span></strong><span class="koboSpan" id="kobo.15.1">). </span><span class="koboSpan" id="kobo.15.2">EDA is normally done prior to any type of machine learning project in order to better understand the data, its features, and its limits. </span><span class="koboSpan" id="kobo.15.3">One of the best ways to explore data in this fashion is in a visual form, allowing you to uncover much more than the numerical values alone.</span></p>
			<p><span class="koboSpan" id="kobo.16.1">Over the course of the following chapter, we will look over some useful steps to follow to develop a robust visual for a given dataset. </span><span class="koboSpan" id="kobo.16.2">We will also explore some of the most common visualization libraries used in the </span><strong class="bold"><span class="koboSpan" id="kobo.17.1">Python</span></strong><span class="koboSpan" id="kobo.18.1"> community today. </span><span class="koboSpan" id="kobo.18.2">Finally, we will explore several datasets and learn how to develop some of the most common visualizations for them.</span></p>
			<p><span class="koboSpan" id="kobo.19.1">Within this chapter, we will cover the following main topics:</span></p>
			<ul>
				<li><span class="koboSpan" id="kobo.20.1">Exploring the six steps of data visualization</span></li>
				<li><span class="koboSpan" id="kobo.21.1">Commonly used visualization libraries </span></li>
				<li><span class="koboSpan" id="kobo.22.1">Tutorial – visualizing data in Python</span></li>
			</ul>
			<h1 id="_idParaDest-66"><a id="_idTextAnchor067"/><span class="koboSpan" id="kobo.23.1">Technical requirements</span></h1>
			<p><span class="koboSpan" id="kobo.24.1">In this chapter, we will apply our understanding of Python and </span><strong class="bold"><span class="koboSpan" id="kobo.25.1">Structured Query Language</span></strong><span class="koboSpan" id="kobo.26.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.27.1">SQL</span></strong><span class="koboSpan" id="kobo.28.1">) to retrieve data and design meaningful visualizations through a number of popular Python libraries. </span><span class="koboSpan" id="kobo.28.2">These libraries can be installed using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.29.1">pip</span></strong><span class="koboSpan" id="kobo.30.1"> installer demonstrated in </span><a href="B17761_02_Final_JM_ePub.xhtml#_idTextAnchor023"><em class="italic"><span class="koboSpan" id="kobo.31.1">Chapter 2</span></em></a><span class="koboSpan" id="kobo.32.1">, </span><em class="italic"><span class="koboSpan" id="kobo.33.1">Introducing Python and the Command Line</span></em><span class="koboSpan" id="kobo.34.1">. </span><span class="koboSpan" id="kobo.34.2">Recall that the process of installing a library is done via the command line:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.35.1">$ pip install library-name</span></p>
			<p><span class="koboSpan" id="kobo.36.1">So, now that we are set up, let's begin!</span></p>
			<h1 id="_idParaDest-67"><a id="_idTextAnchor068"/><span class="koboSpan" id="kobo.37.1">Exploring the six steps of data visualization</span></h1>
			<p><span class="koboSpan" id="kobo.38.1">When it </span><a id="_idIndexMarker218"/><span class="koboSpan" id="kobo.39.1">comes to effectively communicating key trends in your data, the method in which it is presented will always be important. </span><span class="koboSpan" id="kobo.39.2">When presenting any type of data to an audience, there are two main considerations: first, selecting the correct segment of data for the argument; second, selecting the most effective visualization for the argument. </span><span class="koboSpan" id="kobo.39.3">When working on a new visualization, there are six steps you can follow to help guide you:</span></p>
			<ol>
				<li><strong class="bold"><span class="koboSpan" id="kobo.40.1">Acquire</span></strong><span class="koboSpan" id="kobo.41.1">: Obtain the data from its source.</span></li>
				<li><strong class="bold"><span class="koboSpan" id="kobo.42.1">Understand</span></strong><span class="koboSpan" id="kobo.43.1">: Learn about the data and understand its categories and features.</span></li>
				<li><strong class="bold"><span class="koboSpan" id="kobo.44.1">Filter</span></strong><span class="koboSpan" id="kobo.45.1">: Clean the data and remove missing values, </span><strong class="source-inline"><span class="koboSpan" id="kobo.46.1">NaN</span></strong><span class="koboSpan" id="kobo.47.1"> values, and corrupt entries.</span></li>
				<li><strong class="bold"><span class="koboSpan" id="kobo.48.1">Mine</span></strong><span class="koboSpan" id="kobo.49.1">: Identify patterns or engineer new features.</span></li>
				<li><strong class="bold"><span class="koboSpan" id="kobo.50.1">Condense</span></strong><span class="koboSpan" id="kobo.51.1">: Isolate the most useful features.</span></li>
				<li><strong class="bold"><span class="koboSpan" id="kobo.52.1">Represent</span></strong><span class="koboSpan" id="kobo.53.1">: Select a representation for these features.</span></li>
			</ol>
			<p><span class="koboSpan" id="kobo.54.1">Let's look at each step in detail.</span></p>
			<p><span class="koboSpan" id="kobo.55.1">The first step is to </span><em class="italic"><span class="koboSpan" id="kobo.56.1">acquire</span></em><span class="koboSpan" id="kobo.57.1"> your data from its source. </span><span class="koboSpan" id="kobo.57.2">This source may be a simple CSV file, a relational database, or </span><a id="_idIndexMarker219"/><span class="koboSpan" id="kobo.58.1">even a </span><strong class="bold"><span class="koboSpan" id="kobo.59.1">NoSQL</span></strong><span class="koboSpan" id="kobo.60.1"> database.</span></p>
			<p><span class="koboSpan" id="kobo.61.1">Second, it is important to </span><em class="italic"><span class="koboSpan" id="kobo.62.1">understand</span></em><span class="koboSpan" id="kobo.63.1"> the context of the data as well as its content. </span><span class="koboSpan" id="kobo.63.2">As a data scientist, your</span><a id="_idIndexMarker220"/><span class="koboSpan" id="kobo.64.1"> objective is to place yourself in the shoes of your stakeholders and understand their data as best you can. </span><span class="koboSpan" id="kobo.64.2">Often, a simple</span><a id="_idIndexMarker221"/><span class="koboSpan" id="kobo.65.1"> conversation with a </span><strong class="bold"><span class="koboSpan" id="kobo.66.1">Subject Matter Expert</span></strong><span class="koboSpan" id="kobo.67.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.68.1">SME</span></strong><span class="koboSpan" id="kobo.69.1">) can save you hours by highlighting facts about the data that you otherwise would not have known.</span></p>
			<p><span class="koboSpan" id="kobo.70.1">Third, </span><em class="italic"><span class="koboSpan" id="kobo.71.1">filtering</span></em><span class="koboSpan" id="kobo.72.1"> your data will always be crucial. </span><span class="koboSpan" id="kobo.72.2">Most real-world applications of data science rarely involve ready-to-use datasets. </span><span class="koboSpan" id="kobo.72.3">Often, data in its raw form will be the main data source, and it is up to data scientists and developers to ensure that any missing values and corrupt entries are taken care of. </span><span class="koboSpan" id="kobo.72.4">Data scientists often refer to this step as </span><strong class="bold"><span class="koboSpan" id="kobo.73.1">preprocessing</span></strong><span class="koboSpan" id="kobo.74.1">, and </span><a id="_idIndexMarker222"/><span class="koboSpan" id="kobo.75.1">we will explore this in more detail in </span><a href="B17761_05_Final_JM_ePub.xhtml#_idTextAnchor082"><em class="italic"><span class="koboSpan" id="kobo.76.1">Chapter 5</span></em></a><span class="koboSpan" id="kobo.77.1">, </span><em class="italic"><span class="koboSpan" id="kobo.78.1">Understanding Machine Learning</span></em><span class="koboSpan" id="kobo.79.1">.</span></p>
			<p><span class="koboSpan" id="kobo.80.1">With the data preprocessed, our next objective is to </span><em class="italic"><span class="koboSpan" id="kobo.81.1">mine</span></em><span class="koboSpan" id="kobo.82.1"> the data in an attempt to identify patterns or engineer new features. </span><span class="koboSpan" id="kobo.82.2">In simple datasets, values can often be quickly visualized as either increasing or decreasing, allowing us to easily understand the trend. </span><span class="koboSpan" id="kobo.82.3">In multidimensional datasets, these trends are often more difficult to uncover. </span><span class="koboSpan" id="kobo.82.4">For example, a time-series graph may show you an increasing </span><em class="italic"><span class="koboSpan" id="kobo.83.1">trend</span></em><span class="koboSpan" id="kobo.84.1">, however, the first derivative of this graph may expose </span><em class="italic"><span class="koboSpan" id="kobo.85.1">trends</span></em><span class="koboSpan" id="kobo.86.1"> relating to </span><em class="italic"><span class="koboSpan" id="kobo.87.1">seasonality</span></em><span class="koboSpan" id="kobo.88.1">.</span></p>
			<p><span class="koboSpan" id="kobo.89.1">Once a trend of interest is identified, the data representing that trend is often </span><em class="italic"><span class="koboSpan" id="kobo.90.1">isolated</span></em><span class="koboSpan" id="kobo.91.1"> from the rest of the data. </span><span class="koboSpan" id="kobo.91.2">And finally, this trend is </span><em class="italic"><span class="koboSpan" id="kobo.92.1">represented</span></em><span class="koboSpan" id="kobo.93.1"> using a visualization that complements it. </span></p>
			<p><span class="koboSpan" id="kobo.94.1">It is important to understand that these steps are by no means hard rules, but they should be thought of as useful guidelines to assist you in generating effective visualizations. </span><span class="koboSpan" id="kobo.94.2">Not every visualization will require every step! </span><span class="koboSpan" id="kobo.94.3">In fact, some visualizations may require other steps, perhaps sometimes in a different order. </span><span class="koboSpan" id="kobo.94.4">We will go through a number of these steps to generate some visualizations later in the </span><em class="italic"><span class="koboSpan" id="kobo.95.1">Tutorial – Visualizing data in Python</span></em><span class="koboSpan" id="kobo.96.1"> section within this chapter. </span><span class="koboSpan" id="kobo.96.2">When we do, try to recall these steps and see if you can identify them.</span></p>
			<p><span class="koboSpan" id="kobo.97.1">Before we </span><a id="_idIndexMarker223"/><span class="koboSpan" id="kobo.98.1">begin generating some interesting visuals, let's talk about some of the libraries we will need.</span></p>
			<h1 id="_idParaDest-68"><a id="_idTextAnchor069"/><span class="koboSpan" id="kobo.99.1">Commonly used visualization libraries</span></h1>
			<p><span class="koboSpan" id="kobo.100.1">There are </span><a id="_idIndexMarker224"/><span class="koboSpan" id="kobo.101.1">countless </span><strong class="bold"><span class="koboSpan" id="kobo.102.1">visualization libraries</span></strong><span class="koboSpan" id="kobo.103.1"> available in Python, and more are being published every day. </span><span class="koboSpan" id="kobo.103.2">Visualization libraries can be divided</span><a id="_idIndexMarker225"/><span class="koboSpan" id="kobo.104.1"> into </span><a id="_idIndexMarker226"/><span class="koboSpan" id="kobo.105.1">two </span><a id="_idIndexMarker227"/><span class="koboSpan" id="kobo.106.1">main</span><a id="_idIndexMarker228"/><span class="koboSpan" id="kobo.107.1"> categories: </span><strong class="bold"><span class="koboSpan" id="kobo.108.1">static visualization</span></strong><span class="koboSpan" id="kobo.109.1"> libraries and </span><strong class="bold"><span class="koboSpan" id="kobo.110.1">interactive visualization</span></strong><span class="koboSpan" id="kobo.111.1"> libraries. </span><span class="koboSpan" id="kobo.111.2">Static visualizations are images consisting of plotted values that cannot be clicked by the user. </span><span class="koboSpan" id="kobo.111.3">On the other hand, interactive visualizations are not just images but representations that can be clicked on, reshaped, moved around, and scaled in a particular direction. </span><span class="koboSpan" id="kobo.111.4">Static visualizations are often destined for email communications, printed publications, or slide decks, as they are visualizations that you do not intend others to change. </span><span class="koboSpan" id="kobo.111.5">However, interactive visualizations are generally destined for dashboards </span><a id="_idIndexMarker229"/><span class="koboSpan" id="kobo.112.1">and </span><a id="_idIndexMarker230"/><span class="koboSpan" id="kobo.113.1">websites (such as </span><strong class="bold"><span class="koboSpan" id="kobo.114.1">AWS</span></strong><span class="koboSpan" id="kobo.115.1"> or </span><strong class="bold"><span class="koboSpan" id="kobo.116.1">Heroku</span></strong><span class="koboSpan" id="kobo.117.1">) in anticipation of users interacting with them and exploring the data as permitted. </span></p>
			<p><span class="koboSpan" id="kobo.118.1">The following open source libraries are currently some of the most popular in the industry. </span><span class="koboSpan" id="kobo.118.2">Each of them has its own advantages and disadvantages, which are detailed in the following table:</span></p>
			<div>
				<div id="_idContainer053" class="IMG---Figure">
					<span class="koboSpan" id="kobo.119.1"><img src="image/B17761_04_001.jpg" alt="Figure 4.1 – A list of the most common visualization libraries in Python "/></span>
				</div>
			</div>
			<p class="figure-caption"><span class="koboSpan" id="kobo.120.1">Figure 4.1 – A list of the most common visualization libraries in Python</span></p>
			<p><span class="koboSpan" id="kobo.121.1">Now that we</span><a id="_idIndexMarker231"/><span class="koboSpan" id="kobo.122.1"> know about visualization libraries, let's move on to the next section!</span></p>
			<h1 id="_idParaDest-69"><a id="_idTextAnchor070"/><span class="koboSpan" id="kobo.123.1">Tutorial – visualizing data in Python</span></h1>
			<p><span class="koboSpan" id="kobo.124.1">Over the</span><a id="_idIndexMarker232"/><span class="koboSpan" id="kobo.125.1"> course </span><a id="_idIndexMarker233"/><span class="koboSpan" id="kobo.126.1">of this tutorial, we will be retrieving a few different datasets from a range of sources and exploring them through various kinds of visualizations. </span><span class="koboSpan" id="kobo.126.2">To create these visuals, we will implement many of the visualization steps in conjunction with some of the open source visualization libraries. </span><span class="koboSpan" id="kobo.126.3">Let's get started!</span></p>
			<h2 id="_idParaDest-70"><a id="_idTextAnchor071"/><span class="koboSpan" id="kobo.127.1">Getting data</span></h2>
			<p><span class="koboSpan" id="kobo.128.1">Recall</span><a id="_idIndexMarker234"/><span class="koboSpan" id="kobo.129.1"> that, in </span><a href="B17761_03_Final_JM_ePub.xhtml#_idTextAnchor050"><em class="italic"><span class="koboSpan" id="kobo.130.1">Chapter 3</span></em></a><span class="koboSpan" id="kobo.131.1">, </span><em class="italic"><span class="koboSpan" id="kobo.132.1">Getting Started with SQL and Relational Databases</span></em><span class="koboSpan" id="kobo.133.1">, we used AWS to create and deploy a database to the cloud, allowing us to query data</span><a id="_idIndexMarker235"/><span class="koboSpan" id="kobo.134.1"> using </span><strong class="bold"><span class="koboSpan" id="kobo.135.1">MySQL Workbench</span></strong><span class="koboSpan" id="kobo.136.1">. </span><span class="koboSpan" id="kobo.136.2">This same database can also be queried directly from Python using a library known as </span><strong class="source-inline"><span class="koboSpan" id="kobo.137.1">sqlalchemy</span></strong><span class="koboSpan" id="kobo.138.1">: </span></p>
			<ol>
				<li value="1"><span class="koboSpan" id="kobo.139.1">Let's</span><a id="_idIndexMarker236"/><span class="koboSpan" id="kobo.140.1"> query that dataset directly from </span><strong class="bold"><span class="koboSpan" id="kobo.141.1">Amazon</span></strong> <strong class="bold"><span class="koboSpan" id="kobo.142.1">Relational Database Service</span></strong><span class="koboSpan" id="kobo.143.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.144.1">RDS</span></strong><span class="koboSpan" id="kobo.145.1">). </span><span class="koboSpan" id="kobo.145.2">To do so, we will need the </span><strong class="source-inline"><span class="koboSpan" id="kobo.146.1">endpoint</span></strong><span class="koboSpan" id="kobo.147.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.148.1">username</span></strong><span class="koboSpan" id="kobo.149.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.150.1">password</span></strong><span class="koboSpan" id="kobo.151.1"> values generated in the previous chapter. </span><span class="koboSpan" id="kobo.151.2">Go ahead and list these as variables in Python:</span><p class="source-code"><span class="koboSpan" id="kobo.152.1">ENDPOINT=" yourEndPointHere&gt;"</span></p><p class="source-code"><span class="koboSpan" id="kobo.153.1">PORT="3306"</span></p><p class="source-code"><span class="koboSpan" id="kobo.154.1">USR="admin"</span></p><p class="source-code"><span class="koboSpan" id="kobo.155.1">DBNAME="toxicity_db_tutorial"</span></p><p class="source-code"><span class="koboSpan" id="kobo.156.1">PASSWORD = "&lt;YourPasswordHere&gt;"</span></p></li>
				<li><span class="koboSpan" id="kobo.157.1">With the variables populated with your respective parameters, we can now query this data using </span><strong class="source-inline"><span class="koboSpan" id="kobo.158.1">sqlalchemy</span></strong><span class="koboSpan" id="kobo.159.1">. </span><span class="koboSpan" id="kobo.159.2">Since we are interested in the dataset as a whole, we </span><a id="_idIndexMarker237"/><span class="koboSpan" id="kobo.160.1">can simply run a </span><strong class="source-inline"><span class="koboSpan" id="kobo.161.1">SELECT * FROM dataset_toxicity_sd</span></strong><span class="koboSpan" id="kobo.162.1"> command:</span><p class="source-code"><span class="koboSpan" id="kobo.163.1">from sqlalchemy import create_engine</span></p><p class="source-code"><span class="koboSpan" id="kobo.164.1">import pandas as pd</span></p><p class="source-code"><span class="koboSpan" id="kobo.165.1">db_connection_str =</span></p><p class="source-code"><span class="koboSpan" id="kobo.166.1">'mysql+pymysql://{USR}:{PASSWORD}@{ENDPOINT}:{PORT}/{DBNAME}'.format(USR=USR, PASSWORD=PASSWORD, ENDPOINT=ENDPOINT, PORT=PORT, DBNAME=DBNAME)</span></p><p class="source-code"><span class="koboSpan" id="kobo.167.1">db_connection = create_engine(db_connection_str)</span></p><p class="source-code"><span class="koboSpan" id="kobo.168.1">df = pd.read_sql('SELECT * FROM dataset_toxicity_sd',</span></p><p class="source-code"><span class="koboSpan" id="kobo.169.1">con=db_connection)</span></p><p><span class="koboSpan" id="kobo.170.1">Alternatively, you can simply import the same dataset as a CSV file using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.171.1">read_csv()</span></strong><span class="koboSpan" id="kobo.172.1"> function:</span></p><p class="source-code"><span class="koboSpan" id="kobo.173.1">df = pd.read_csv("../../datasets/dataset_toxicity_sd.csv")</span></p></li>
				<li><span class="koboSpan" id="kobo.174.1">We can take a quick look at the dataset to understand its content using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.175.1">head()</span></strong><span class="koboSpan" id="kobo.176.1"> function. </span><span class="koboSpan" id="kobo.176.2">Recall that we can choose to reduce the columns by specifying the names of the ones we are interested in by using double square brackets (</span><strong class="source-inline"><span class="koboSpan" id="kobo.177.1">[[]]</span></strong><span class="koboSpan" id="kobo.178.1">):</span><p class="source-code"><span class="koboSpan" id="kobo.179.1">df[["ID", "smiles", "toxic"]].head() </span></p><p><span class="koboSpan" id="kobo.180.1">This gives us the following output:</span></p><div id="_idContainer054" class="IMG---Figure"><span class="koboSpan" id="kobo.181.1"><img src="image/B17761_04_002.jpg" alt="Figure 4.2 – A DataFrame representation of selected columns from the toxicity dataset "/></span></div><p class="figure-caption"> </p><p class="figure-caption"><span class="koboSpan" id="kobo.182.1">Figure 4.2 – A DataFrame representation of selected columns from the toxicity dataset</span></p><p><span class="koboSpan" id="kobo.183.1">If you </span><a id="_idIndexMarker238"/><span class="koboSpan" id="kobo.184.1">recall, there are quite a few columns within this dataset, ranging from general data such as the primary key (</span><strong class="source-inline"><span class="koboSpan" id="kobo.185.1">ID</span></strong><span class="koboSpan" id="kobo.186.1">) to the structure (</span><strong class="source-inline"><span class="koboSpan" id="kobo.187.1">smiles</span></strong><span class="koboSpan" id="kobo.188.1">) and the toxicity (</span><strong class="source-inline"><span class="koboSpan" id="kobo.189.1">toxic</span></strong><span class="koboSpan" id="kobo.190.1">). </span><span class="koboSpan" id="kobo.190.2">In addition, there are many features that describe and represent the dataset, ranging from the total polar surface area (</span><strong class="source-inline"><span class="koboSpan" id="kobo.191.1">TPSA</span></strong><span class="koboSpan" id="kobo.192.1">) all the way to lipophilicity (</span><strong class="source-inline"><span class="koboSpan" id="kobo.193.1">LogP</span></strong><span class="koboSpan" id="kobo.194.1">). </span></p></li>
				<li><span class="koboSpan" id="kobo.195.1">We can also get a sense of some of the general statistics behind this dataset – such as the maximum, minimum, and averages relating to each column – by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.196.1">describe()</span></strong><span class="koboSpan" id="kobo.197.1"> function in </span><strong class="source-inline"><span class="koboSpan" id="kobo.198.1">pandas</span></strong><span class="koboSpan" id="kobo.199.1">:</span><p class="source-code"><span class="koboSpan" id="kobo.200.1">df[["toxic", "TPSA", "MolWt", "LogP"]].describe()</span></p><p><span class="koboSpan" id="kobo.201.1">This results in the following table:</span></p><p class="figure-caption"> </p><div id="_idContainer055" class="IMG---Figure"><span class="koboSpan" id="kobo.202.1"><img src="image/B17761_04_003.jpg" alt="Figure 4.3 – Some general statistics of selected columns from the toxicity dataset "/></span></div><p class="figure-caption"><span class="koboSpan" id="kobo.203.1">Figure 4.3 – Some general statistics of selected columns from the toxicity dataset</span></p><p><span class="koboSpan" id="kobo.204.1">Immediately, we </span><a id="_idIndexMarker239"/><span class="koboSpan" id="kobo.205.1">notice that the </span><strong class="bold"><span class="koboSpan" id="kobo.206.1">means</span></strong><span class="koboSpan" id="kobo.207.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.208.1">standard deviations</span></strong><span class="koboSpan" id="kobo.209.1"> of each of the columns are drastically different from each other. </span><span class="koboSpan" id="kobo.209.2">We also notice that the minimum and maximum values are also quite different, in the sense that many of the columns are </span><em class="italic"><span class="koboSpan" id="kobo.210.1">integers</span></em><span class="koboSpan" id="kobo.211.1"> (whole numbers), whereas others are </span><em class="italic"><span class="koboSpan" id="kobo.212.1">floats</span></em><span class="koboSpan" id="kobo.213.1"> (decimals). </span><span class="koboSpan" id="kobo.213.2">We can also see that many of the minimums have values of zero, with two columns (</span><strong class="source-inline"><span class="koboSpan" id="kobo.214.1">FormalCharge</span></strong><span class="koboSpan" id="kobo.215.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.216.1">LogP</span></strong><span class="koboSpan" id="kobo.217.1">) having negative values. </span><span class="koboSpan" id="kobo.217.2">So, this real-world dataset is quite diverse and spread out. </span></p></li>
				<li><span class="koboSpan" id="kobo.218.1">Before we can explore the dataset further, we will need to ensure that there are no missing values. </span><span class="koboSpan" id="kobo.218.2">To do this, we can run a quick check using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.219.1">isna()</span></strong><span class="koboSpan" id="kobo.220.1"> function provided by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.221.1">pandas</span></strong><span class="koboSpan" id="kobo.222.1"> library. </span><span class="koboSpan" id="kobo.222.2">We can chain this with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.223.1">sum()</span></strong><span class="koboSpan" id="kobo.224.1"> function to get a sum of all of the missing values for each column:</span><p class="source-code"><span class="koboSpan" id="kobo.225.1">df.isna().sum()</span></p><p><span class="koboSpan" id="kobo.226.1">The result is shown in </span><em class="italic"><span class="koboSpan" id="kobo.227.1">Figure 4.4</span></em><span class="koboSpan" id="kobo.228.1">:</span></p></li>
			</ol>
			<div>
				<div id="_idContainer056" class="IMG---Figure">
					<span class="koboSpan" id="kobo.229.1"><img src="image/B17761_04_004.jpg" alt="Figure 4.4 – The list of missing values within the DataFrame "/></span>
				</div>
			</div>
			<p class="figure-caption"><span class="koboSpan" id="kobo.230.1">Figure 4.4 – The list of missing values within the DataFrame</span></p>
			<p><span class="koboSpan" id="kobo.231.1">Thankfully, there are no missing values from this particular dataset, so we are free to move forward with creating a few plots and visuals. </span></p>
			<p class="callout-heading"><span class="koboSpan" id="kobo.232.1">Important note</span></p>
			<p class="callout"><strong class="bold"><span class="koboSpan" id="kobo.233.1">Missing values</span></strong><span class="koboSpan" id="kobo.234.1">: Please </span><a id="_idIndexMarker240"/><span class="koboSpan" id="kobo.235.1">note that missing values can be addressed in a number of different ways. </span><span class="koboSpan" id="kobo.235.2">One option is to exclude a row with missing values from the dataset completely by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.236.1">dropna()</span></strong><span class="koboSpan" id="kobo.237.1"> function. </span><span class="koboSpan" id="kobo.237.2">Another option is to replace any missing value with a </span><a id="_idIndexMarker241"/><span class="koboSpan" id="kobo.238.1">common value using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.239.1">fillna()</span></strong><span class="koboSpan" id="kobo.240.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.241.1">replace()</span></strong><span class="koboSpan" id="kobo.242.1"> functions. </span><span class="koboSpan" id="kobo.242.2">Finally, you can also replace missing values with the mean of all the other values using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.243.1">mean()</span></strong><span class="koboSpan" id="kobo.244.1"> function. </span><span class="koboSpan" id="kobo.244.2">The method you select will be highly dependent on the identity and meaning of the column. </span></p>
			<h2 id="_idParaDest-71"><a id="_idTextAnchor072"/><span class="koboSpan" id="kobo.245.1">Summarizing data with bar plots</span></h2>
			<p><strong class="bold"><span class="koboSpan" id="kobo.246.1">Bar plots</span></strong><span class="koboSpan" id="kobo.247.1"> or </span><strong class="bold"><span class="koboSpan" id="kobo.248.1">bar charts</span></strong><span class="koboSpan" id="kobo.249.1"> are </span><a id="_idIndexMarker242"/><span class="koboSpan" id="kobo.250.1">often used</span><a id="_idIndexMarker243"/><span class="koboSpan" id="kobo.251.1"> to describe </span><em class="italic"><span class="koboSpan" id="kobo.252.1">categorical data</span></em><span class="koboSpan" id="kobo.253.1"> in which the lengths or heights of the bars are proportional to the values of the categories they represent. </span><span class="koboSpan" id="kobo.253.2">Bar plots provide a visual estimate of the central tendency of a dataset with the uncertainty of the estimate represented by error bars.</span></p>
			<p><span class="koboSpan" id="kobo.254.1">So, let's create our first bar plot. </span><span class="koboSpan" id="kobo.254.2">We will be using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.255.1">seaborn</span></strong><span class="koboSpan" id="kobo.256.1"> library for this particular task. </span><span class="koboSpan" id="kobo.256.2">There are a number of different ways to style your graphs. </span><span class="koboSpan" id="kobo.256.3">For the purposes of this tutorial, we will use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.257.1">darkgrid</span></strong><span class="koboSpan" id="kobo.258.1"> style from </span><strong class="source-inline"><span class="koboSpan" id="kobo.259.1">seaborn</span></strong><span class="koboSpan" id="kobo.260.1">. </span></p>
			<p><span class="koboSpan" id="kobo.261.1">Let's plot the </span><strong class="source-inline"><span class="koboSpan" id="kobo.262.1">TPSA</span></strong><span class="koboSpan" id="kobo.263.1"> feature relative to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.264.1">FormalCharge</span></strong><span class="koboSpan" id="kobo.265.1"> feature to get a sense of the relationship between them:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.266.1">import pandas as pd</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.267.1">import seaborn as sns</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.268.1">plt.figure(figsize=(10,5))</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.269.1">sns.barplot(x="FormalCharge", y="TPSA", data=df);</span></p>
			<p><span class="koboSpan" id="kobo.270.1">Our initial</span><a id="_idIndexMarker244"/><span class="koboSpan" id="kobo.271.1"> results </span><a id="_idIndexMarker245"/><span class="koboSpan" id="kobo.272.1">are shown in </span><em class="italic"><span class="koboSpan" id="kobo.273.1">Figure 4.5</span></em><span class="koboSpan" id="kobo.274.1">:</span></p>
			<div>
				<div id="_idContainer057" class="IMG---Figure">
					<span class="koboSpan" id="kobo.275.1"><img src="image/B17761_04_005.png.jpg" alt="Figure 4.5 – A bar plot of the TPSA and FormalCharge features "/></span>
				</div>
			</div>
			<p class="figure-caption"><span class="koboSpan" id="kobo.276.1">Figure 4.5 – A bar plot of the TPSA and FormalCharge features</span></p>
			<p><span class="koboSpan" id="kobo.277.1">Immediately, we can see an interesting relationship between the two, in the sense that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.278.1">TPSA</span></strong><span class="koboSpan" id="kobo.279.1"> feature tends to increase when the absolute value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.280.1">FormalCharge</span></strong><span class="koboSpan" id="kobo.281.1"> is further away from zero. </span><span class="koboSpan" id="kobo.281.2">If you are following along with the provided </span><strong class="bold"><span class="koboSpan" id="kobo.282.1">Jupyter notebooks</span></strong><span class="koboSpan" id="kobo.283.1">, feel free to explore a few other relationships within this dataset. </span><span class="koboSpan" id="kobo.283.2">Now, let's try exploring the number of hydrogen donors (</span><strong class="source-inline"><span class="koboSpan" id="kobo.284.1">HDonors</span></strong><span class="koboSpan" id="kobo.285.1">) instead of </span><strong class="source-inline"><span class="koboSpan" id="kobo.286.1">TPSA</span></strong><span class="koboSpan" id="kobo.287.1">:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.288.1">sns.barplot(x="FormalCharge", y="HDonors", data=df)</span></p>
			<p><span class="koboSpan" id="kobo.289.1">We can see the subsequent output in </span><em class="italic"><span class="koboSpan" id="kobo.290.1">Figure 4.6</span></em><span class="koboSpan" id="kobo.291.1">:</span></p>
			<div>
				<div id="_idContainer058" class="IMG---Figure">
					<span class="koboSpan" id="kobo.292.1"><img src="image/B17761_04_006.png.jpg" alt="Figure 4.6 – A bar plot of the HDonors and FormalCharge features "/></span>
				</div>
			</div>
			<p class="figure-caption"><span class="koboSpan" id="kobo.293.1">Figure 4.6 – A bar plot of the HDonors and FormalCharge features</span></p>
			<p><span class="koboSpan" id="kobo.294.1">Taking a</span><a id="_idIndexMarker246"/><span class="koboSpan" id="kobo.295.1"> look </span><a id="_idIndexMarker247"/><span class="koboSpan" id="kobo.296.1">at the plot, we do not see as strong a relationship between the two variables. </span><span class="koboSpan" id="kobo.296.2">The highest and lowest formal charges do in fact show higher hydrogen donors. </span><span class="koboSpan" id="kobo.296.3">Let's compare this to </span><strong class="source-inline"><span class="koboSpan" id="kobo.297.1">HAcceptors</span></strong><span class="koboSpan" id="kobo.298.1"> – a similar feature in this dataset. </span><span class="koboSpan" id="kobo.298.2">We could either plot this feature individually, as we did with the hydrogen donors, or we could combine them both into one diagram. </span><span class="koboSpan" id="kobo.298.3">We can do this by </span><em class="italic"><span class="koboSpan" id="kobo.299.1">isolating</span></em><span class="koboSpan" id="kobo.300.1"> the features of interest (do you remember the name of this step?) and then </span><em class="italic"><span class="koboSpan" id="kobo.301.1">reshaping</span></em><span class="koboSpan" id="kobo.302.1"> the dataset. </span><span class="koboSpan" id="kobo.302.2">DataFrames within Python are often </span><strong class="bold"><span class="koboSpan" id="kobo.303.1">reshaped</span></strong><span class="koboSpan" id="kobo.304.1"> using four common functions:</span></p>
			<div>
				<div id="_idContainer059" class="IMG---Figure">
					<span class="koboSpan" id="kobo.305.1"><img src="image/B17761_04_007.jpg" alt="Figure 4.7 – Four of the most common DataFrame reshaping functions "/></span>
				</div>
			</div>
			<p class="figure-caption"><span class="koboSpan" id="kobo.306.1">Figure 4.7 – Four of the most common DataFrame reshaping functions</span></p>
			<p><span class="koboSpan" id="kobo.307.1">Each of these functions serves to reshape the data in a specific way. </span><span class="koboSpan" id="kobo.307.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.308.1">pivot()</span></strong><span class="koboSpan" id="kobo.309.1"> function is often used to reshape a DataFrame organized by its index. </span><span class="koboSpan" id="kobo.309.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.310.1">stack()</span></strong><span class="koboSpan" id="kobo.311.1"> function is often used with multi-index DataFrames – this allows you to </span><em class="italic"><span class="koboSpan" id="kobo.312.1">stack</span></em><span class="koboSpan" id="kobo.313.1"> your data, making the table </span><em class="italic"><span class="koboSpan" id="kobo.314.1">long and narrow</span></em><span class="koboSpan" id="kobo.315.1"> instead of </span><em class="italic"><span class="koboSpan" id="kobo.316.1">wide and short</span></em><span class="koboSpan" id="kobo.317.1">. </span><span class="koboSpan" id="kobo.317.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.318.1">melt()</span></strong><span class="koboSpan" id="kobo.319.1"> function is similar to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.320.1">stack()</span></strong><span class="koboSpan" id="kobo.321.1"> function in the sense that it also </span><em class="italic"><span class="koboSpan" id="kobo.322.1">stacks</span></em><span class="koboSpan" id="kobo.323.1"> your data, but the difference between them is that </span><strong class="source-inline"><span class="koboSpan" id="kobo.324.1">stack()</span></strong><span class="koboSpan" id="kobo.325.1"> will insert the compressed columns into the inner index, whereas </span><strong class="source-inline"><span class="koboSpan" id="kobo.326.1">melt()</span></strong><span class="koboSpan" id="kobo.327.1"> will create a new column called </span><strong class="source-inline"><span class="koboSpan" id="kobo.328.1">Variable</span></strong><span class="koboSpan" id="kobo.329.1">. </span><span class="koboSpan" id="kobo.329.2">Finally, </span><strong class="source-inline"><span class="koboSpan" id="kobo.330.1">unstack()</span></strong><span class="koboSpan" id="kobo.331.1"> is simply the opposite of </span><strong class="source-inline"><span class="koboSpan" id="kobo.332.1">stack()</span></strong><span class="koboSpan" id="kobo.333.1">, in the sense that data is converted from </span><em class="italic"><span class="koboSpan" id="kobo.334.1">long</span></em><span class="koboSpan" id="kobo.335.1"> to </span><em class="italic"><span class="koboSpan" id="kobo.336.1">wide</span></em><span class="koboSpan" id="kobo.337.1">. </span></p>
			<p><span class="koboSpan" id="kobo.338.1">For the purposes of comparing the hydrogen donors and acceptors, we will be using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.339.1">melt()</span></strong><span class="koboSpan" id="kobo.340.1"> function, which you can see in </span><em class="italic"><span class="koboSpan" id="kobo.341.1">Figure 4.8</span></em><span class="koboSpan" id="kobo.342.1">. </span><span class="koboSpan" id="kobo.342.2">Note that two new columns are created in</span><a id="_idIndexMarker248"/><span class="koboSpan" id="kobo.343.1"> the </span><a id="_idIndexMarker249"/><span class="koboSpan" id="kobo.344.1">process: </span><strong class="source-inline"><span class="koboSpan" id="kobo.345.1">Variable</span></strong><span class="koboSpan" id="kobo.346.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.347.1">Value</span></strong><span class="koboSpan" id="kobo.348.1">:</span></p>
			<div>
				<div id="_idContainer060" class="IMG---Figure">
					<span class="koboSpan" id="kobo.349.1"><img src="image/B17761_04_008.jpg" alt="Figure 4.8 – A graphical representation of the melt() function "/></span>
				</div>
			</div>
			<p class="figure-caption"><span class="koboSpan" id="kobo.350.1">Figure 4.8 – A graphical representation of the melt() function</span></p>
			<p><span class="koboSpan" id="kobo.351.1">First, we create a variable called </span><strong class="source-inline"><span class="koboSpan" id="kobo.352.1">df_iso</span></strong><span class="koboSpan" id="kobo.353.1"> to represent the isolated DataFrame, and then we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.354.1">melt()</span></strong><span class="koboSpan" id="kobo.355.1"> function to </span><em class="italic"><span class="koboSpan" id="kobo.356.1">melt</span></em><span class="koboSpan" id="kobo.357.1"> its data and assign it to a new variable called </span><strong class="source-inline"><span class="koboSpan" id="kobo.358.1">df_melt</span></strong><span class="koboSpan" id="kobo.359.1">. </span><span class="koboSpan" id="kobo.359.2">We can also print the shape of the data to prove to ourselves that the columns </span><em class="italic"><span class="koboSpan" id="kobo.360.1">stack</span></em><span class="koboSpan" id="kobo.361.1"> correctly if they exactly </span><em class="italic"><span class="koboSpan" id="kobo.362.1">double</span></em><span class="koboSpan" id="kobo.363.1"> in length. </span><span class="koboSpan" id="kobo.363.2">Recall that you can also check the data using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.364.1">head()</span></strong><span class="koboSpan" id="kobo.365.1"> function:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.366.1">df_iso = df[["FormalCharge", "HDonors", "HAcceptors"]]</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.367.1">print(df_iso.shape)</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.368.1">    (1460, 3)</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.369.1">df_melted = pd.melt(df_iso, id_vars=["FormalCharge"],</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.370.1">                    value_vars=["HDonors", "HAcceptors"])</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.371.1">print(df_melted.shape)</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.372.1">    (2920, 3)</span></p>
			<p><span class="koboSpan" id="kobo.373.1">Finally, with the data ordered correctly, we can go ahead and plot this data, specifying the x-axis as </span><strong class="source-inline"><span class="koboSpan" id="kobo.374.1">FormalCharge</span></strong><span class="koboSpan" id="kobo.375.1">, and the y-axis as </span><strong class="source-inline"><span class="koboSpan" id="kobo.376.1">value</span></strong><span class="koboSpan" id="kobo.377.1">:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.378.1">sns.barplot(data=df_melted, x='FormalCharge', y='value', </span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.379.1">            hue='variable')</span></p>
			<p><span class="koboSpan" id="kobo.380.1">Upon executing this line of code, we will get the following figure:</span></p>
			<div>
				<div id="_idContainer061" class="IMG---Figure">
					<span class="koboSpan" id="kobo.381.1"><img src="image/B17761_04_009.png.jpg" alt="Figure 4.9 – A bar plot of two features relative to FormalCharge "/></span>
				</div>
			</div>
			<p class="figure-caption"><span class="koboSpan" id="kobo.382.1">Figure 4.9 – A bar plot of two features relative to FormalCharge</span></p>
			<p><span class="koboSpan" id="kobo.383.1">As you begin to explore the many functions and classes within the </span><strong class="source-inline"><span class="koboSpan" id="kobo.384.1">seaborn</span></strong><span class="koboSpan" id="kobo.385.1"> library, referring </span><a id="_idIndexMarker250"/><span class="koboSpan" id="kobo.386.1">to the documentation as you write your </span><a id="_idIndexMarker251"/><span class="koboSpan" id="kobo.387.1">code can help you to debug errors and also uncover new functionality that you may not have known about. </span><span class="koboSpan" id="kobo.387.2">You can view the Seaborn documentation at </span><a href="https://seaborn.pydata.org/api.html"><span class="koboSpan" id="kobo.388.1">https://seaborn.pydata.org/api.html</span></a><span class="koboSpan" id="kobo.389.1">.</span></p>
			<h2 id="_idParaDest-72"><a id="_idTextAnchor073"/><span class="koboSpan" id="kobo.390.1">Working with distributions and histograms</span></h2>
			<p><strong class="bold"><span class="koboSpan" id="kobo.391.1">Histograms</span></strong><span class="koboSpan" id="kobo.392.1"> are</span><a id="_idIndexMarker252"/><span class="koboSpan" id="kobo.393.1"> plots </span><a id="_idIndexMarker253"/><span class="koboSpan" id="kobo.394.1">that </span><a id="_idIndexMarker254"/><span class="koboSpan" id="kobo.395.1">visually portray a summary or approximation of the distribution of a </span><em class="italic"><span class="koboSpan" id="kobo.396.1">numerical dataset</span></em><span class="koboSpan" id="kobo.397.1">. </span><span class="koboSpan" id="kobo.397.2">In order to construct a histogram, </span><strong class="bold"><span class="koboSpan" id="kobo.398.1">bins</span></strong><span class="koboSpan" id="kobo.399.1"> must be established, representing a range of values by which the full range is divided. </span><span class="koboSpan" id="kobo.399.2">For example, take the molecular weights of the items in a dataset; we can plot a histogram of the weights in bins of </span><strong class="source-inline"><span class="koboSpan" id="kobo.400.1">40</span></strong><span class="koboSpan" id="kobo.401.1">:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.402.1">plt.figure(figsize=(10,5))</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.403.1">plt.title("Histogram of Molecular Weight (g/mol)", fontsize=20)</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.404.1">plt.xlabel("Molecular Weight (g/mol)", fontsize=15)</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.405.1">plt.ylabel("Frequency", fontsize=15)</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.406.1">df["MolWt"].hist(figsize=(10, 5), </span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.407.1">                          bins=40, </span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.408.1">                          xlabelsize=10, </span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.409.1">                          ylabelsize=10, </span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.410.1">                          color = "royalblue")</span></p>
			<p><span class="koboSpan" id="kobo.411.1">We</span><a id="_idIndexMarker255"/><span class="koboSpan" id="kobo.412.1"> can </span><a id="_idIndexMarker256"/><span class="koboSpan" id="kobo.413.1">see the output </span><a id="_idIndexMarker257"/><span class="koboSpan" id="kobo.414.1">of this code in </span><em class="italic"><span class="koboSpan" id="kobo.415.1">Figure 4.10</span></em><span class="koboSpan" id="kobo.416.1">:</span></p>
			<div>
				<div id="_idContainer062" class="IMG---Figure">
					<span class="koboSpan" id="kobo.417.1"><img src="image/B17761_04_010.png.jpg" alt="Figure 4.10 – A histogram of molecular weight with a bin size of 40 "/></span>
				</div>
			</div>
			<p class="figure-caption"><span class="koboSpan" id="kobo.418.1">Figure 4.10 – A histogram of molecular weight with a bin size of 40</span></p>
			<p><span class="koboSpan" id="kobo.419.1">As you explore more visualization methods in Python, you will notice that most libraries offer a number of quick functions that have already been developed and optimized to perform a specific task. </span><span class="koboSpan" id="kobo.419.2">We could go through the same process of reshaping our data for each feature and iterate through them to plot a histogram for each of the features, or we could simply use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.420.1">hist()</span></strong><span class="koboSpan" id="kobo.421.1"> function for them collectively:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.422.1">dftmp = df[["MolWt", "NHOH", "HAcceptors", "Heteroatoms", </span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.423.1">                     "LogP", "TPSA"]]</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.424.1">dftmp.hist(figsize=(30, 10), bins=40, xlabelsize=10,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.425.1">                    ylabelsize=10, color = "royalblue")</span></p>
			<p><span class="koboSpan" id="kobo.426.1">The </span><a id="_idIndexMarker258"/><span class="koboSpan" id="kobo.427.1">subsequent output </span><a id="_idIndexMarker259"/><span class="koboSpan" id="kobo.428.1">can </span><a id="_idIndexMarker260"/><span class="koboSpan" id="kobo.429.1">be seen in </span><em class="italic"><span class="koboSpan" id="kobo.430.1">Figure 4.11</span></em><span class="koboSpan" id="kobo.431.1">:</span></p>
			<div>
				<div id="_idContainer063" class="IMG---Figure">
					<span class="koboSpan" id="kobo.432.1"><img src="image/B17761_04_011.png.jpg" alt="Figure 4.11 – A series of histograms for various features automated using the hist() function "/></span>
				</div>
			</div>
			<p class="figure-caption"><span class="koboSpan" id="kobo.433.1">Figure 4.11 – A series of histograms for various features automated using the hist() function</span></p>
			<p><span class="koboSpan" id="kobo.434.1">Histograms can also be overlayed in order to showcase two features on the same plot. </span><span class="koboSpan" id="kobo.434.2">When doing this, we would need to give the plots a degree of transparency by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.435.1">alpha</span></strong><span class="koboSpan" id="kobo.436.1"> parameter:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.437.1">dftmp = df[["MolWt","TPSA"]]</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.438.1">x1 = dftmp.MolWt.values</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.439.1">x2 = dftmp.TPSA.values</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.440.1">kwargs = dict(histtype='stepfilled', alpha=0.3, </span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.441.1">              density=True, bins=100, ec="k")</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.442.1">plt.figure(figsize=(10,5))</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.443.1">plt.title("Histogram of Molecular Weight (g/mol)", </span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.444.1">           fontsize=20)</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.445.1">plt.xlabel("Molecular Weight (g/mol)", fontsize=15)</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.446.1">plt.ylabel("Frequency", fontsize=15)</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.447.1">plt.xlim([-100, 1000])</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.448.1">plt.ylim([0, 0.01])</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.449.1">plt.hist(x1, **kwargs)</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.450.1">plt.hist(x2, **kwargs)</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.451.1">plt.legend(dftmp.columns)</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.452.1">plt.show()</span></p>
			<p><span class="koboSpan" id="kobo.453.1">We </span><a id="_idIndexMarker261"/><span class="koboSpan" id="kobo.454.1">can </span><a id="_idIndexMarker262"/><span class="koboSpan" id="kobo.455.1">see the output</span><a id="_idIndexMarker263"/><span class="koboSpan" id="kobo.456.1"> of the preceding command in </span><em class="italic"><span class="koboSpan" id="kobo.457.1">Figure 4.12</span></em><span class="koboSpan" id="kobo.458.1">:</span></p>
			<div>
				<div id="_idContainer064" class="IMG---Figure">
					<span class="koboSpan" id="kobo.459.1"><img src="image/B17761_04_012.png.jpg" alt="Figure 4.12 – An overlay of two histograms where their opacity was reduced "/></span>
				</div>
			</div>
			<p class="figure-caption"><span class="koboSpan" id="kobo.460.1">Figure 4.12 – An overlay of two histograms where their opacity was reduced</span></p>
			<p><span class="koboSpan" id="kobo.461.1">Histograms are wonderful ways to summarize and visualize data in large quantities, especially when the functionality is as easy as using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.462.1">hist()</span></strong><span class="koboSpan" id="kobo.463.1"> function. </span><span class="koboSpan" id="kobo.463.2">You will find that most </span><a id="_idIndexMarker264"/><span class="koboSpan" id="kobo.464.1">libraries – such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.465.1">pandas</span></strong><span class="koboSpan" id="kobo.466.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.467.1">numpy</span></strong><span class="koboSpan" id="kobo.468.1"> – have numerous functions </span><a id="_idIndexMarker265"/><span class="koboSpan" id="kobo.469.1">with similar </span><a id="_idIndexMarker266"/><span class="koboSpan" id="kobo.470.1">functionality.</span></p>
			<h2 id="_idParaDest-73"><a id="_idTextAnchor074"/><span class="koboSpan" id="kobo.471.1">Visualizing features with scatter plots</span></h2>
			<p><strong class="bold"><span class="koboSpan" id="kobo.472.1">Scatter plots</span></strong><span class="koboSpan" id="kobo.473.1"> are </span><a id="_idIndexMarker267"/><span class="koboSpan" id="kobo.474.1">representations</span><a id="_idIndexMarker268"/><span class="koboSpan" id="kobo.475.1"> based on </span><em class="italic"><span class="koboSpan" id="kobo.476.1">Cartesian coordinates</span></em><span class="koboSpan" id="kobo.477.1"> that allow for visualizations to be created in both two- and three-dimensional spaces. </span><span class="koboSpan" id="kobo.477.2">Scatter plots consist of an x-axis and a y-axis and are normally accompanied by an additional feature that allows for separation within the data. </span><span class="koboSpan" id="kobo.477.3">Scatter plots are best used when accompanied by a third feature that can be represented either by color or shape, depending on the data type available. </span><span class="koboSpan" id="kobo.477.4">Let's look at a simple example: </span></p>
			<ol>
				<li value="1"><span class="koboSpan" id="kobo.478.1">We'll take a look at an example of a simple scatter plot showing </span><strong class="source-inline"><span class="koboSpan" id="kobo.479.1">TPSA</span></strong><span class="koboSpan" id="kobo.480.1"> relative to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.481.1">HeavyAtoms</span></strong><span class="koboSpan" id="kobo.482.1"> feature:</span><p class="source-code"><span class="koboSpan" id="kobo.483.1">plt.figure(figsize=(10,5))</span></p><p class="source-code"><span class="koboSpan" id="kobo.484.1">plt.title("Scatterplot of Heavy Atoms and TPSA", fontsize=20)</span></p><p class="source-code"><span class="koboSpan" id="kobo.485.1">plt.ylabel("Heavy Atoms", fontsize=15)</span></p><p class="source-code"><span class="koboSpan" id="kobo.486.1">plt.xlabel("TPSA", fontsize=15)</span></p><p class="source-code"><span class="koboSpan" id="kobo.487.1">sns.scatterplot(x="TPSA", y="HeavyAtoms", data=df)</span></p><p><span class="koboSpan" id="kobo.488.1">The output for the preceding code can be seen in </span><em class="italic"><span class="koboSpan" id="kobo.489.1">Figure 4.13</span></em><span class="koboSpan" id="kobo.490.1">:</span></p><div id="_idContainer065" class="IMG---Figure"><span class="koboSpan" id="kobo.491.1"><img src="image/B17761_04_013.png.jpg" alt="Figure 4.13 – A scatter plot of the TPSA and HeavyAtoms features "/></span></div><p class="figure-caption"><span class="koboSpan" id="kobo.492.1">Figure 4.13 – A scatter plot of the TPSA and HeavyAtoms features</span></p><p><span class="koboSpan" id="kobo.493.1">Immediately, we notice that there is some dependency between the two features, as shown by the slight positive correlation. </span></p></li>
				<li><span class="koboSpan" id="kobo.494.1">We </span><a id="_idIndexMarker269"/><span class="koboSpan" id="kobo.495.1">can take a look at a third </span><a id="_idIndexMarker270"/><span class="koboSpan" id="kobo.496.1">feature, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.497.1">MolWt</span></strong><span class="koboSpan" id="kobo.498.1">, by changing the color and size using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.499.1">hue</span></strong><span class="koboSpan" id="kobo.500.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.501.1">size</span></strong><span class="koboSpan" id="kobo.502.1"> arguments, respectively. </span><span class="koboSpan" id="kobo.502.2">This gives us the ability to plot three or four features on the same graph, giving us an excellent interpretation of the dataset. </span><span class="koboSpan" id="kobo.502.3">We can see some trending among </span><strong class="source-inline"><span class="koboSpan" id="kobo.503.1">TPSA</span></strong><span class="koboSpan" id="kobo.504.1"> relative to </span><strong class="source-inline"><span class="koboSpan" id="kobo.505.1">HeavyAtoms</span></strong><span class="koboSpan" id="kobo.506.1">, and increasing </span><strong class="source-inline"><span class="koboSpan" id="kobo.507.1">MolWt</span></strong><span class="koboSpan" id="kobo.508.1">:</span><p class="source-code"><span class="koboSpan" id="kobo.509.1">plt.figure(figsize=(10,5))</span></p><p class="source-code"><span class="koboSpan" id="kobo.510.1">plt.title("Scatterplot of Heavy Atoms and TPSA", fontsize=20)</span></p><p class="source-code"><span class="koboSpan" id="kobo.511.1">plt.ylabel("Heavy Atoms", fontsize=15)</span></p><p class="source-code"><span class="koboSpan" id="kobo.512.1">plt.xlabel("Molecular Weight (g/mol)", fontsize=15)</span></p><p class="source-code"><span class="koboSpan" id="kobo.513.1">sns.scatterplot(x="TPSA",y="HeavyAtoms", </span></p><p class="source-code"><span class="koboSpan" id="kobo.514.1">size="MolWt", hue="MolWt", data=df)</span></p><p><span class="koboSpan" id="kobo.515.1">The output of the preceding code can be seen in </span><em class="italic"><span class="koboSpan" id="kobo.516.1">Figure 4.14</span></em><span class="koboSpan" id="kobo.517.1">:</span></p><div id="_idContainer066" class="IMG---Figure"><span class="koboSpan" id="kobo.518.1"><img src="image/B17761_04_014.png.jpg" alt="Figure 4.14 – A scatter plot of two features, with a third represented by size and color "/></span></div><p class="figure-caption"><span class="koboSpan" id="kobo.519.1">Figure 4.14 – A scatter plot of two features, with a third represented by size and color</span></p></li>
				<li><span class="koboSpan" id="kobo.520.1">As an </span><a id="_idIndexMarker271"/><span class="koboSpan" id="kobo.521.1">alternative to 2D scatter</span><a id="_idIndexMarker272"/><span class="koboSpan" id="kobo.522.1"> plots, we can use 3D scatter plots to introduce another feature in the form of a new dimension. </span><span class="koboSpan" id="kobo.522.2">We can take advantage of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.523.1">Plotly</span></strong><span class="koboSpan" id="kobo.524.1"> library to implement some 3D functionality. </span><span class="koboSpan" id="kobo.524.2">To do this, we can define a </span><strong class="source-inline"><span class="koboSpan" id="kobo.525.1">fig</span></strong><span class="koboSpan" id="kobo.526.1"> object using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.527.1">scatter_3d</span></strong><span class="koboSpan" id="kobo.528.1"> function, and subsequently, we define the source of our data and the axes of interest:</span><p class="source-code"><span class="koboSpan" id="kobo.529.1">import plotly.express as px</span></p><p class="source-code"><span class="koboSpan" id="kobo.530.1">fig = px.scatter_3d(df, x='TPSA', y='LogP', z='HeavyAtoms',</span></p><p class="source-code"><span class="koboSpan" id="kobo.531.1">                     color='toxic', opacity=0.7)</span></p><p class="source-code"><span class="koboSpan" id="kobo.532.1">fig.update_traces(marker=dict(size=4))</span></p><p class="source-code"><span class="koboSpan" id="kobo.533.1">fig.show()</span></p><p><span class="koboSpan" id="kobo.534.1">The output of this code will result in </span><em class="italic"><span class="koboSpan" id="kobo.535.1">Figure 4.15</span></em><span class="koboSpan" id="kobo.536.1">:</span></p><div id="_idContainer067" class="IMG---Figure"><span class="koboSpan" id="kobo.537.1"><img src="image/B17761_04_015.jpg" alt="Figure 4.15 – A 3D scatter plot of three features, colored by toxicity "/></span></div><p class="figure-caption"><span class="koboSpan" id="kobo.538.1">Figure 4.15 – A 3D scatter plot of three features, colored by toxicity</span></p></li>
				<li><span class="koboSpan" id="kobo.539.1">Instead</span><a id="_idIndexMarker273"/><span class="koboSpan" id="kobo.540.1"> of adding more </span><a id="_idIndexMarker274"/><span class="koboSpan" id="kobo.541.1">features, we can add some more elements to the scatter plot to help interpret the two features on the x and y coordinates. </span><span class="koboSpan" id="kobo.541.2">We noticed earlier that there was a slight correlation within the dataset that seems ripe for exploration. </span><span class="koboSpan" id="kobo.541.3">It would be interesting to see if this correlation holds true for both toxic and non-toxic compounds. </span><span class="koboSpan" id="kobo.541.4">We can get a sense of the correlation using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.542.1">lmplot()</span></strong><span class="koboSpan" id="kobo.543.1"> function, which allows us to graphically represent the correlation as a </span><em class="italic"><span class="koboSpan" id="kobo.544.1">linear regression</span></em><span class="koboSpan" id="kobo.545.1"> within the scatter plot:</span><p class="source-code"><span class="koboSpan" id="kobo.546.1">sns.lmplot(x="HAcceptors", y="TPSA", hue="toxic", </span></p><p class="source-code"><span class="koboSpan" id="kobo.547.1">         data=df, markers=["o", "x"], height = 5, </span></p><p class="source-code"><span class="koboSpan" id="kobo.548.1">         aspect = 1.7, palette="muted");</span></p><p class="source-code"><span class="koboSpan" id="kobo.549.1">plt.xlim([0, 16])</span></p><p class="source-code"><span class="koboSpan" id="kobo.550.1">plt.ylim([0, 400])</span></p><p><span class="koboSpan" id="kobo.551.1">The subsequent output can be seen in </span><em class="italic"><span class="koboSpan" id="kobo.552.1">Figure 4.16</span></em><span class="koboSpan" id="kobo.553.1">:</span></p></li>
			</ol>
			<div>
				<div id="_idContainer068" class="IMG---Figure">
					<span class="koboSpan" id="kobo.554.1"><img src="image/B17761_04_016.png.jpg" alt="Figure 4.16 – A scatter plot of two features and their associated correlations "/></span>
				</div>
			</div>
			<p class="figure-caption"><span class="koboSpan" id="kobo.555.1">Figure 4.16 – A scatter plot of two features and their associated correlations</span></p>
			<p><span class="koboSpan" id="kobo.556.1">Scatter plots are great ways to portray data relationships and begin to understand any dependencies or correlations they may have. </span><span class="koboSpan" id="kobo.556.2">Plotting regressions or lines of best fit can give</span><a id="_idIndexMarker275"/><span class="koboSpan" id="kobo.557.1"> you some insight into any possible</span><a id="_idIndexMarker276"/><span class="koboSpan" id="kobo.558.1"> relationships. </span><span class="koboSpan" id="kobo.558.2">We will explore this in greater detail in the following section.</span></p>
			<h2 id="_idParaDest-74"><a id="_idTextAnchor075"/><span class="koboSpan" id="kobo.559.1">Identifying correlations with heat maps</span></h2>
			<p><span class="koboSpan" id="kobo.560.1">Now </span><a id="_idIndexMarker277"/><span class="koboSpan" id="kobo.561.1">that we have established </span><a id="_idIndexMarker278"/><span class="koboSpan" id="kobo.562.1">a correlation between two molecular features within our dataset, let's investigate to see if there are any others. </span><span class="koboSpan" id="kobo.562.2">We can easily go through each set of features, plot them, and look at their respective regressions to determine whether or not a correlation may exist. </span><span class="koboSpan" id="kobo.562.3">In Python, automating whenever possible is advised, and luckily for us, this task has already been automated! </span><span class="koboSpan" id="kobo.562.4">So, let's take a look: </span></p>
			<ol>
				<li value="1"><span class="koboSpan" id="kobo.563.1">Using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.564.1">pairplot()</span></strong><span class="koboSpan" id="kobo.565.1"> function will take your dataset as input and return a figure of all the scatter plots for all of the features within your dataset. </span><span class="koboSpan" id="kobo.565.2">To fit the figure within the confines of this page, only the most interesting features were selected. </span><span class="koboSpan" id="kobo.565.3">However, I challenge you to run the code in the provided Jupyter notebook to see if there are any other interesting trends:</span><p class="source-code"><span class="koboSpan" id="kobo.566.1">featOfInterest = ["TPSA", "MolWt", "HAcceptors",</span></p><p class="source-code"><span class="koboSpan" id="kobo.567.1">       "HDonors", "toxic", "LogP"]</span></p><p class="source-code"><span class="koboSpan" id="kobo.568.1">sns.pairplot(df[featOfInterest], hue = "toxic", markers="o")</span></p><p><span class="koboSpan" id="kobo.569.1">The</span><a id="_idIndexMarker279"/><span class="koboSpan" id="kobo.570.1"> results are presented </span><a id="_idIndexMarker280"/><span class="koboSpan" id="kobo.571.1">in the form of numerous smaller graphs, as shown in </span><em class="italic"><span class="koboSpan" id="kobo.572.1">Figure 4.17</span></em><span class="koboSpan" id="kobo.573.1">:</span></p><div id="_idContainer069" class="IMG---Figure"><span class="koboSpan" id="kobo.574.1"><img src="image/B17761_04_017.jpg" alt="Figure 4.17 – A pairplot() graphic of the toxicity dataset for selected features "/></span></div><p class="figure-caption"><span class="koboSpan" id="kobo.575.1">Figure 4.17 – A pairplot() graphic of the toxicity dataset for selected features</span></p></li>
				<li><span class="koboSpan" id="kobo.576.1">Alternatively, we</span><a id="_idIndexMarker281"/><span class="koboSpan" id="kobo.577.1"> can capture the </span><em class="italic"><span class="koboSpan" id="kobo.578.1">Pearson correlation</span></em><span class="koboSpan" id="kobo.579.1"> for each of the feature pairs using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.580.1">corr()</span></strong><span class="koboSpan" id="kobo.581.1"> function in conjunction with the DataFrame itself:</span><p class="source-code"><span class="koboSpan" id="kobo.582.1">df[["TPSA", "MolWt", "HeavyAtoms", "NHOH", "HAcceptors", </span></p><p class="source-code"><span class="koboSpan" id="kobo.583.1">          "HDonors", "AromaticRings", "LogP", "AromaticN"]].corr()</span></p><p><span class="koboSpan" id="kobo.584.1">We can </span><a id="_idIndexMarker282"/><span class="koboSpan" id="kobo.585.1">review these correlations </span><a id="_idIndexMarker283"/><span class="koboSpan" id="kobo.586.1">as a DataFrame in </span><em class="italic"><span class="koboSpan" id="kobo.587.1">Figure 4.18</span></em><span class="koboSpan" id="kobo.588.1">:</span></p><div id="_idContainer070" class="IMG---Figure"><span class="koboSpan" id="kobo.589.1"><img src="image/B17761_04_018.jpg" alt="Figure 4.18 – A DataFrame showing the correlations between selected features "/></span></div><p class="figure-caption"><span class="koboSpan" id="kobo.590.1">Figure 4.18 – A DataFrame showing the correlations between selected features</span></p></li>
				<li><span class="koboSpan" id="kobo.591.1">For a more visually appealing result, we can </span><em class="italic"><span class="koboSpan" id="kobo.592.1">wrap</span></em><span class="koboSpan" id="kobo.593.1"> our data within a </span><strong class="source-inline"><span class="koboSpan" id="kobo.594.1">heatmap()</span></strong><span class="koboSpan" id="kobo.595.1"> function and apply a color map to show dark colors for strong correlations and light colors for weaker ones:</span><p class="source-code"><span class="koboSpan" id="kobo.596.1">sns.heatmap(df[["TPSA", "MolWt", "HeavyAtoms", "NHOH", </span></p><p class="source-code"><span class="koboSpan" id="kobo.597.1">              "HAcceptors", "HDonors", "AromaticRings", </span></p><p class="source-code"><span class="koboSpan" id="kobo.598.1">              "LogP", "AromaticN"]].corr(), </span></p><p class="source-code"><span class="koboSpan" id="kobo.599.1">              annot = True,  cmap="YlGnBu")</span></p><p><span class="koboSpan" id="kobo.600.1">Some of the code we have written so far has become a little complicated as we begin to </span><em class="italic"><span class="koboSpan" id="kobo.601.1">chain</span></em><span class="koboSpan" id="kobo.602.1"> multiple functions together. </span><span class="koboSpan" id="kobo.602.2">To provide some clarity of the syntax and structure, let's take a closer look at the following function. </span><span class="koboSpan" id="kobo.602.3">We begin by calling the main </span><strong class="source-inline"><span class="koboSpan" id="kobo.603.1">heatmap</span></strong><span class="koboSpan" id="kobo.604.1"> class within the </span><strong class="source-inline"><span class="koboSpan" id="kobo.605.1">seaborn</span></strong><span class="koboSpan" id="kobo.606.1"> library (recall that we give this the alias </span><strong class="source-inline"><span class="koboSpan" id="kobo.607.1">sns</span></strong><span class="koboSpan" id="kobo.608.1">). </span><span class="koboSpan" id="kobo.608.2">We then add our dataset, containing the sliced set of the features of interest. </span><span class="koboSpan" id="kobo.608.3">We then apply the correlation function to get the respective </span><a id="_idIndexMarker284"/><span class="koboSpan" id="kobo.609.1">correlations, and </span><a id="_idIndexMarker285"/><span class="koboSpan" id="kobo.610.1">finally add some additional arguments to style and color the plot:</span></p></li>
			</ol>
			<p class="figure-caption"> </p>
			<div>
				<div id="_idContainer071" class="IMG---Figure">
					<span class="koboSpan" id="kobo.611.1"><img src="image/B17761_04_019.jpg" alt="Figure 4.19 – A heat map showing the correlation between selected features "/></span>
				</div>
			</div>
			<p class="figure-caption"><span class="koboSpan" id="kobo.612.1">Figure 4.19 – A heat map showing the correlation between selected features</span></p>
			<p><span class="koboSpan" id="kobo.613.1">Identifying correlations within datasets will always be useful, regardless of whether you are analyzing data or preparing a predictive model. </span><span class="koboSpan" id="kobo.613.2">You will find that </span><strong class="source-inline"><span class="koboSpan" id="kobo.614.1">corr()</span></strong><span class="koboSpan" id="kobo.615.1"> and many of its </span><a id="_idIndexMarker286"/><span class="koboSpan" id="kobo.616.1">derivatives are commonly </span><a id="_idIndexMarker287"/><span class="koboSpan" id="kobo.617.1">used in the machine learning space.</span></p>
			<h2 id="_idParaDest-75"><a id="_idTextAnchor076"/><span class="koboSpan" id="kobo.618.1">Displaying sequential and time-series plots</span></h2>
			<p><span class="koboSpan" id="kobo.619.1">The</span><a id="_idIndexMarker288"/><span class="koboSpan" id="kobo.620.1"> datasets </span><a id="_idIndexMarker289"/><span class="koboSpan" id="kobo.621.1">and</span><a id="_idIndexMarker290"/><span class="koboSpan" id="kobo.622.1"> features we have explored so far have all been</span><a id="_idIndexMarker291"/><span class="koboSpan" id="kobo.623.1"> provided in a </span><em class="italic"><span class="koboSpan" id="kobo.624.1">structured</span></em><span class="koboSpan" id="kobo.625.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.626.1">tabular</span></em><span class="koboSpan" id="kobo.627.1"> form, existing as rows and columns within DataFrames. </span><span class="koboSpan" id="kobo.627.2">These rows are fully independent of each other. </span><span class="koboSpan" id="kobo.627.3">This is not always the case in all datasets, and </span><em class="italic"><span class="koboSpan" id="kobo.628.1">dependence</span></em><span class="koboSpan" id="kobo.629.1"> (especially </span><em class="italic"><span class="koboSpan" id="kobo.630.1">time-based dependence</span></em><span class="koboSpan" id="kobo.631.1">) is sometimes a factor we need to consider. </span><span class="koboSpan" id="kobo.631.2">For</span><a id="_idIndexMarker292"/><span class="koboSpan" id="kobo.632.1"> example, take a </span><strong class="bold"><span class="koboSpan" id="kobo.633.1">Fast All</span></strong><span class="koboSpan" id="kobo.634.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.635.1">FASTA</span></strong><span class="koboSpan" id="kobo.636.1">) sequence – that is, a text-based format often used in the realm of bioinformatics for representing nucleotide or amino acid sequences via letter codes. </span><span class="koboSpan" id="kobo.636.2">In molecular biology and genetics, a parameter known as </span><strong class="bold"><span class="koboSpan" id="kobo.637.1">Guanine-Cytosine</span></strong><span class="koboSpan" id="kobo.638.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.639.1">GC</span></strong><span class="koboSpan" id="kobo.640.1">) </span><strong class="bold"><span class="koboSpan" id="kobo.641.1">content</span></strong><span class="koboSpan" id="kobo.642.1"> is a </span><a id="_idIndexMarker293"/><span class="koboSpan" id="kobo.643.1">metric used to determine the percent of nitrogenous bases within DNA or RNA molecules. </span><span class="koboSpan" id="kobo.643.2">Let's explore plotting this sequential data using a FASTA file for COVID-19 data: </span></p>
			<ol>
				<li value="1"><span class="koboSpan" id="kobo.644.1">We will begin the process by importing the dataset using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.645.1">wget</span></strong><span class="koboSpan" id="kobo.646.1"> library:</span><p class="source-code"><span class="koboSpan" id="kobo.647.1">import wget</span></p><p class="source-code"><span class="koboSpan" id="kobo.648.1">url_covid = "https://ftp.expasy.org/databases/uniprot/pre_release/covid-19.fasta"</span></p><p class="source-code"><span class="koboSpan" id="kobo.649.1">filename = wget.download(url_covid, out="../../datasets")</span></p></li>
				<li><span class="koboSpan" id="kobo.650.1">Next, we can calculate the GC content using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.651.1">Biopython</span></strong><span class="koboSpan" id="kobo.652.1"> (also called </span><strong class="source-inline"><span class="koboSpan" id="kobo.653.1">Bio</span></strong><span class="koboSpan" id="kobo.654.1">) library – one of the most commonly utilized Python libraries in the computational molecular biology space. </span><span class="koboSpan" id="kobo.654.2">The documentation and tutorials for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.655.1">Biopython</span></strong><span class="koboSpan" id="kobo.656.1"> library can be found at </span><a href="http://biopython.org/DIST/docs/tutorial/Tutorial.html"><span class="koboSpan" id="kobo.657.1">http://biopython.org/DIST/docs/tutorial/Tutorial.html</span></a><span class="koboSpan" id="kobo.658.1">.</span></li>
				<li><span class="koboSpan" id="kobo.659.1">We will then parse the file using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.660.1">SeqIO</span></strong><span class="koboSpan" id="kobo.661.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.662.1">GC</span></strong><span class="koboSpan" id="kobo.663.1"> classes and write the results to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.664.1">gc_values_covid</span></strong><span class="koboSpan" id="kobo.665.1"> variable:</span><p class="source-code"><span class="koboSpan" id="kobo.666.1">from Bio import SeqIO</span></p><p class="source-code"><span class="koboSpan" id="kobo.667.1">from Bio.SeqUtils import GC</span></p><p class="source-code"><span class="koboSpan" id="kobo.668.1">gc_values_covid = sorted(GC(rec.seq) for rec in </span></p><p class="source-code"><span class="koboSpan" id="kobo.669.1">    SeqIO.parse("../../datasets/covid-19.fasta", "fasta"))</span></p><p><span class="koboSpan" id="kobo.670.1">Please note that the path to the file in the preceding code may change depending on which directory the file was saved in.</span></p></li>
				<li><span class="koboSpan" id="kobo.671.1">Finally, we</span><a id="_idIndexMarker294"/><span class="koboSpan" id="kobo.672.1"> can</span><a id="_idIndexMarker295"/><span class="koboSpan" id="kobo.673.1"> go </span><a id="_idIndexMarker296"/><span class="koboSpan" id="kobo.674.1">ahead and plot the results</span><a id="_idIndexMarker297"/><span class="koboSpan" id="kobo.675.1"> using either </span><strong class="source-inline"><span class="koboSpan" id="kobo.676.1">pylab</span></strong><span class="koboSpan" id="kobo.677.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.678.1">matplotlib</span></strong><span class="koboSpan" id="kobo.679.1">:</span><p class="source-code"><span class="koboSpan" id="kobo.680.1">import pylab</span></p><p class="source-code"><span class="koboSpan" id="kobo.681.1">plt.figure(figsize=(10,5))</span></p><p class="source-code"><span class="koboSpan" id="kobo.682.1">plt.title("COVID-19 FASTA Sequence GC%", fontsize=20)</span></p><p class="source-code"><span class="koboSpan" id="kobo.683.1">plt.ylabel("GC Content %", fontsize=15)</span></p><p class="source-code"><span class="koboSpan" id="kobo.684.1">plt.xlabel("Genes", fontsize=15)</span></p><p class="source-code"><span class="koboSpan" id="kobo.685.1">pylab.plot(gc_values_covid)</span></p><p class="source-code"><span class="koboSpan" id="kobo.686.1">pylab.show()</span></p><p><span class="koboSpan" id="kobo.687.1">The subsequent output can be seen in </span><em class="italic"><span class="koboSpan" id="kobo.688.1">Figure 4.20</span></em><span class="koboSpan" id="kobo.689.1">:</span></p></li>
			</ol>
			<div>
				<div id="_idContainer072" class="IMG---Figure">
					<span class="koboSpan" id="kobo.690.1"><img src="image/B17761_04_020.png.jpg" alt="Figure 4.20 – A plot showing the GC content of the COVID-19 sequence "/></span>
				</div>
			</div>
			<p class="figure-caption"><span class="koboSpan" id="kobo.691.1">Figure 4.20 – A plot showing the GC content of the COVID-19 sequence</span></p>
			<p><span class="koboSpan" id="kobo.692.1">While there are many non-time-based sequential datasets such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.693.1">text</span></strong><span class="koboSpan" id="kobo.694.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.695.1">images</span></strong><span class="koboSpan" id="kobo.696.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.697.1">audio</span></strong><span class="koboSpan" id="kobo.698.1">, there are also time-based datasets such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.699.1">stock prices</span></strong><span class="koboSpan" id="kobo.700.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.701.1">manufacturing processes</span></strong><span class="koboSpan" id="kobo.702.1">. </span><span class="koboSpan" id="kobo.702.2">Within the laboratory space, there are many pieces of</span><a id="_idIndexMarker298"/><span class="koboSpan" id="kobo.703.1"> equipment</span><a id="_idIndexMarker299"/><span class="koboSpan" id="kobo.704.1"> that </span><a id="_idIndexMarker300"/><span class="koboSpan" id="kobo.705.1">also utilize time series-based </span><a id="_idIndexMarker301"/><span class="koboSpan" id="kobo.706.1">approaches, such as those relating to chromatography. </span><span class="koboSpan" id="kobo.706.2">For </span><a id="_idIndexMarker302"/><span class="koboSpan" id="kobo.707.1">example, take </span><strong class="bold"><span class="koboSpan" id="kobo.708.1">Size-Exclusion Chromatography</span></strong><span class="koboSpan" id="kobo.709.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.710.1">SEC</span></strong><span class="koboSpan" id="kobo.711.1">), in which molecules are separated by their sizes. </span><span class="koboSpan" id="kobo.711.2">This property is known as </span><em class="italic"><span class="koboSpan" id="kobo.712.1">molecular weight</span></em><span class="koboSpan" id="kobo.713.1">. </span><span class="koboSpan" id="kobo.713.2">Most predictive maintenance models tend to monitor temperature and pressure to detect anomalies and alert users. </span><span class="koboSpan" id="kobo.713.3">Let's go ahead and pull in the following </span><strong class="source-inline"><span class="koboSpan" id="kobo.714.1">time-series</span></strong><span class="koboSpan" id="kobo.715.1"> dataset and overlay </span><strong class="source-inline"><span class="koboSpan" id="kobo.716.1">Temperature</span></strong><span class="koboSpan" id="kobo.717.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.718.1">Pressure</span></strong><span class="koboSpan" id="kobo.719.1"> together over time:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.720.1">dfts = pd.read_csv("../../datasets/dataset_pressure_ts.csv")</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.721.1">plt.title("Timeseries of an LCMS Chromatogram (Pressure &amp; </span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.722.1">     Temperature)", fontsize=20)</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.723.1">plt.ylabel("Pressure (Bar)", fontsize=15)</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.724.1">plt.xlabel("Run Time (min)", fontsize=15)</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.725.1">ax1 = sns.lineplot(x="Run Time", y="Pressure",</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.726.1">                      data=dfts, color = "royalblue", </span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.727.1">                      label = "Pressure (Bar)");</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.728.1">ax2 = sns.lineplot(x="Run Time", y="Temperature",</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.729.1">                      data=dfts, color = "orange", </span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.730.1">                      label = "Pressure (Bar)");</span></p>
			<p><span class="koboSpan" id="kobo.731.1">The output of this code can be seen in </span><em class="italic"><span class="koboSpan" id="kobo.732.1">Figure 4.21</span></em><span class="koboSpan" id="kobo.733.1">:</span></p>
			<div>
				<div id="_idContainer073" class="IMG---Figure">
					<span class="koboSpan" id="kobo.734.1"><img src="image/B17761_04_021.png.jpg" alt="Figure 4.21 – A time-series plot showing the temperature and pressure of a failed LCMS run "/></span>
				</div>
			</div>
			<p class="figure-caption"><span class="koboSpan" id="kobo.735.1">Figure 4.21 – A time-series plot showing the temperature and pressure of a failed LCMS run</span></p>
			<p><span class="koboSpan" id="kobo.736.1">We </span><a id="_idIndexMarker303"/><span class="koboSpan" id="kobo.737.1">notice</span><a id="_idIndexMarker304"/><span class="koboSpan" id="kobo.738.1"> that </span><a id="_idIndexMarker305"/><span class="koboSpan" id="kobo.739.1">within</span><a id="_idIndexMarker306"/><span class="koboSpan" id="kobo.740.1"> the first 5 minutes of this graph, the temperature and pressure parameters are increasing quite quickly. </span><span class="koboSpan" id="kobo.740.2">A dip of some sort occurs within the 6.5-minute range, and the system keeps increasing for a moment, then both parameters begin to plummet downward and level out at their respective ranges. </span><span class="koboSpan" id="kobo.740.3">This is an example of an instrument failure, and it is a situation that a finely tuned machine learning model would be able to detect relative to its successful counterpart. </span><span class="koboSpan" id="kobo.740.4">We will explore the development of this anomaly detection model in greater detail in </span><a href="B17761_07_Final_JM_ePub.xhtml#_idTextAnchor101"><em class="italic"><span class="koboSpan" id="kobo.741.1">Chapter 7</span></em></a><span class="koboSpan" id="kobo.742.1">, </span><em class="italic"><span class="koboSpan" id="kobo.743.1">Supervised Machine Learning</span></em><span class="koboSpan" id="kobo.744.1">.</span></p>
			<h2 id="_idParaDest-76"><a id="_idTextAnchor077"/><span class="koboSpan" id="kobo.745.1">Emphasizing flows with Sankey diagrams</span></h2>
			<p><span class="koboSpan" id="kobo.746.1">A popular</span><a id="_idIndexMarker307"/><span class="koboSpan" id="kobo.747.1"> form of visualization</span><a id="_idIndexMarker308"/><span class="koboSpan" id="kobo.748.1"> in data science is the </span><strong class="bold"><span class="koboSpan" id="kobo.749.1">Sankey diagram</span></strong><span class="koboSpan" id="kobo.750.1"> – made famous by Minard's classic depiction of Napoleon's army during the invasion of Russia. </span><span class="koboSpan" id="kobo.750.2">The main purpose of a Sankey diagram is to visualize a magnitude in terms of its proportional width on a flow diagram: </span></p>
			<div>
				<div id="_idContainer074" class="IMG---Figure">
					<span class="koboSpan" id="kobo.751.1"><img src="image/B17761_04_022.jpg" alt="Figure 4.22 – A Sankey diagram by Charles Joseph Minard depicting Napoleon's march to Russia "/></span>
				</div>
			</div>
			<p class="figure-caption"><span class="koboSpan" id="kobo.752.1">Figure 4.22 – A Sankey diagram by Charles Joseph Minard depicting Napoleon's march to Russia</span></p>
			<p><span class="koboSpan" id="kobo.753.1">Sankey diagrams are often used to depict many applications across various sectors. </span><span class="koboSpan" id="kobo.753.2">Biotechnology and health sector applications of Sankey diagrams include the following:</span></p>
			<ul>
				<li><span class="koboSpan" id="kobo.754.1">Depictions of drug candidates during clinical trials</span></li>
				<li><span class="koboSpan" id="kobo.755.1">Process flow diagrams for synthetic molecules</span></li>
				<li><span class="koboSpan" id="kobo.756.1">Process flow diagrams for microbial fermentation</span></li>
				<li><span class="koboSpan" id="kobo.757.1">Project flow diagrams and success rates</span></li>
				<li><span class="koboSpan" id="kobo.758.1">Financial diagrams depicting costs within an organization</span></li>
			</ul>
			<p><span class="koboSpan" id="kobo.759.1">Let's visualize a simple example of a company's drug candidate pipeline. </span><span class="koboSpan" id="kobo.759.2">We'll take the total number of candidates, their classification by phase, and finally, their designation by modality as small or large molecules. </span><span class="koboSpan" id="kobo.759.3">We can take advantage of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.760.1">Plotly</span></strong><span class="koboSpan" id="kobo.761.1"> library to assist us with this:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.762.1">import plotly.graph_objects as go</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.763.1">fig = go.Figure(data=[go.Sankey(node = dict(pad = 50, </span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.764.1">      thickness = 10,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.765.1">                 line = dict(color = "black", width = 0.5),</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.766.1">                 label = ["Drug Candidates", "Phase 1", "Phase 2",</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.767.1">                 "Phase 3", "Small Molecules", "Large Molecules"],</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.768.1">                 color = "blue"),</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.769.1">                 link = dict(</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.770.1">                 source = [0,  0, 0, 1,  2, 3, 1, 2, 3],</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.771.1">                 target = [1,  2, 3, 4,  4, 4, 5, 5, 5],</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.772.1">                 value = [15, 4, 2, 13, 3, 1, 2, 1, 1]</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.773.1">  ))]) </span></p>
			<p><span class="koboSpan" id="kobo.774.1">This </span><a id="_idIndexMarker309"/><span class="koboSpan" id="kobo.775.1">segment </span><a id="_idIndexMarker310"/><span class="koboSpan" id="kobo.776.1">of code is quite long and complex – let's try to break this down. </span><span class="koboSpan" id="kobo.776.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.777.1">figure</span></strong><span class="koboSpan" id="kobo.778.1"> object consists of several arguments we need to take into account. </span><span class="koboSpan" id="kobo.778.2">The first is </span><strong class="source-inline"><span class="koboSpan" id="kobo.779.1">pad</span></strong><span class="koboSpan" id="kobo.780.1">, which describes the spacing between the </span><em class="italic"><span class="koboSpan" id="kobo.781.1">nodes</span></em><span class="koboSpan" id="kobo.782.1"> of the visualization. </span><span class="koboSpan" id="kobo.782.2">The second describes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.783.1">thickness</span></strong><span class="koboSpan" id="kobo.784.1"> value of the node's bars. </span><span class="koboSpan" id="kobo.784.2">The third sets the </span><strong class="source-inline"><span class="koboSpan" id="kobo.785.1">color</span></strong><span class="koboSpan" id="kobo.786.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.787.1">width</span></strong><span class="koboSpan" id="kobo.788.1"> values of the lines. </span><span class="koboSpan" id="kobo.788.2">The fourth contains the </span><strong class="source-inline"><span class="koboSpan" id="kobo.789.1">label</span></strong><span class="koboSpan" id="kobo.790.1"> names of the nodes. </span><span class="koboSpan" id="kobo.790.2">And finally, we arrive at the data, which has been structured in a slightly different way to how we are accustomed. </span><span class="koboSpan" id="kobo.790.3">In this case, the dataset is divided into a </span><strong class="source-inline"><span class="koboSpan" id="kobo.791.1">source</span></strong><span class="koboSpan" id="kobo.792.1"> array (or origin), the </span><strong class="source-inline"><span class="koboSpan" id="kobo.793.1">target</span></strong><span class="koboSpan" id="kobo.794.1"> array, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.795.1">value</span></strong><span class="koboSpan" id="kobo.796.1"> array associated with it. </span><span class="koboSpan" id="kobo.796.2">Starting on the left-hand side, we see that the first value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.797.1">source</span></strong><span class="koboSpan" id="kobo.798.1"> is node </span><strong class="source-inline"><span class="koboSpan" id="kobo.799.1">0</span></strong><span class="koboSpan" id="kobo.800.1">, which goes to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.801.1">target</span></strong><span class="koboSpan" id="kobo.802.1"> of node </span><strong class="source-inline"><span class="koboSpan" id="kobo.803.1">1</span></strong><span class="koboSpan" id="kobo.804.1">, with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.805.1">value</span></strong><span class="koboSpan" id="kobo.806.1"> of </span><strong class="source-inline"><span class="koboSpan" id="kobo.807.1">15</span></strong><span class="koboSpan" id="kobo.808.1">. </span><span class="koboSpan" id="kobo.808.2">Reading the process in this fashion makes the flow of the data a little clearer to the user or developer. </span><span class="koboSpan" id="kobo.808.3">Finally, we can go ahead and plot the image using </span><strong class="source-inline"><span class="koboSpan" id="kobo.809.1">show()</span></strong><span class="koboSpan" id="kobo.810.1">:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.811.1">fig.update_layout(title_text="Drug Candidates within a Company Pipeline", font_size=10)</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.812.1">fig.show()</span></p>
			<p><span class="koboSpan" id="kobo.813.1">The following diagram displays the output of the preceding code:</span></p>
			<div>
				<div id="_idContainer075" class="IMG---Figure">
					<span class="koboSpan" id="kobo.814.1"><img src="image/B17761_04_023.jpg" alt="Figure 4.23 – A Sankey diagram representing a company's pipeline "/></span>
				</div>
			</div>
			<p class="figure-caption"><span class="koboSpan" id="kobo.815.1">Figure 4.23 – A Sankey diagram representing a company's pipeline</span></p>
			<p><span class="koboSpan" id="kobo.816.1">Sankey diagrams are a great way to show the flow or transfer of information over time or by category. </span><span class="koboSpan" id="kobo.816.2">In the preceding example, we looked at its application in terms of small and large</span><a id="_idIndexMarker311"/><span class="koboSpan" id="kobo.817.1"> molecules within a </span><a id="_idIndexMarker312"/><span class="koboSpan" id="kobo.818.1">pipeline. </span><span class="koboSpan" id="kobo.818.2">Let's now take a look at how we can visualize these molecules. </span></p>
			<h2 id="_idParaDest-77"><a id="_idTextAnchor078"/><span class="koboSpan" id="kobo.819.1">Visualizing small molecules</span></h2>
			<p><span class="koboSpan" id="kobo.820.1">When </span><a id="_idIndexMarker313"/><span class="koboSpan" id="kobo.821.1">it </span><a id="_idIndexMarker314"/><span class="koboSpan" id="kobo.822.1">comes to small molecules, there are a number of ways we can visualize them using various software platforms and online services. </span><span class="koboSpan" id="kobo.822.2">Luckily, there exists an excellent library commonly utilized for </span><strong class="bold"><span class="koboSpan" id="kobo.823.1">cheminformatics</span></strong><span class="koboSpan" id="kobo.824.1"> applications </span><a id="_idIndexMarker315"/><span class="koboSpan" id="kobo.825.1">known as the </span><strong class="bold"><span class="koboSpan" id="kobo.826.1">Research and Development Kit</span></strong><span class="koboSpan" id="kobo.827.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.828.1">RDKit</span></strong><span class="koboSpan" id="kobo.829.1">) that </span><a id="_idIndexMarker316"/><span class="koboSpan" id="kobo.830.1">allows for the depiction of small molecules using the </span><strong class="bold"><span class="koboSpan" id="kobo.831.1">SMILES</span></strong><span class="koboSpan" id="kobo.832.1"> format. </span><span class="koboSpan" id="kobo.832.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.833.1">rdkit</span></strong><span class="koboSpan" id="kobo.834.1"> library can be installed using </span><strong class="source-inline"><span class="koboSpan" id="kobo.835.1">pip</span></strong><span class="koboSpan" id="kobo.836.1">:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.837.1">import pandas as pd</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.838.1">import rdkit</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.839.1">from rdkit import Chem</span></p>
			<p><span class="koboSpan" id="kobo.840.1">We can parse the DataFrame we imported earlier in this tutorial and extract a sample </span><strong class="source-inline"><span class="koboSpan" id="kobo.841.1">smiles</span></strong><span class="koboSpan" id="kobo.842.1"> string via indexing. </span><span class="koboSpan" id="kobo.842.2">We can then create a molecule object using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.843.1">MolFromSmiles()</span></strong><span class="koboSpan" id="kobo.844.1"> function within the </span><strong class="source-inline"><span class="koboSpan" id="kobo.845.1">Chem</span></strong><span class="koboSpan" id="kobo.846.1"> class of </span><strong class="source-inline"><span class="koboSpan" id="kobo.847.1">rdkit</span></strong><span class="koboSpan" id="kobo.848.1"> using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.849.1">smiles</span></strong><span class="koboSpan" id="kobo.850.1"> string as the single argument: </span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.851.1">df = pd.read_csv("../../datasets/dataset_toxicity_sd.csv")</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.852.1">m = Chem.MolFromSmiles(df["smiles"][5])</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.853.1">m</span></p>
			<p><span class="koboSpan" id="kobo.854.1">The</span><a id="_idIndexMarker317"/><span class="koboSpan" id="kobo.855.1"> output</span><a id="_idIndexMarker318"/><span class="koboSpan" id="kobo.856.1"> of this variable can be seen in </span><em class="italic"><span class="koboSpan" id="kobo.857.1">Figure 4.24</span></em><span class="koboSpan" id="kobo.858.1">:</span></p>
			<div>
				<div id="_idContainer076" class="IMG---Figure">
					<span class="koboSpan" id="kobo.859.1"><img src="image/B17761_04_024.jpg" alt="Figure 4.24 – A representation of a small molecule "/></span>
				</div>
			</div>
			<p class="figure-caption"><span class="koboSpan" id="kobo.860.1">Figure 4.24 – A representation of a small molecule</span></p>
			<p><span class="koboSpan" id="kobo.861.1">We can check the structure of another molecule by looking at a different index value:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.862.1">m = Chem.MolFromSmiles(df["smiles"][20])</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.863.1">m</span></p>
			<p><span class="koboSpan" id="kobo.864.1">This time, our output is as follows:</span></p>
			<div>
				<div id="_idContainer077" class="IMG---Figure">
					<span class="koboSpan" id="kobo.865.1"><img src="image/B17761_04_025.jpg" alt="Figure 4.25 – A representation of a small molecule "/></span>
				</div>
			</div>
			<p class="figure-caption"><span class="koboSpan" id="kobo.866.1">Figure 4.25 – A representation of a small molecule</span></p>
			<p><span class="koboSpan" id="kobo.867.1">In addition to rendering print-ready depictions of small molecules, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.868.1">rdkit</span></strong><span class="koboSpan" id="kobo.869.1"> library also supports a wide variety of functions related to the analysis, prediction, and calculation of small molecule properties. </span><span class="koboSpan" id="kobo.869.2">In addition, the library also supports the use of charge calculations, as well as similarity maps:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.870.1">from rdkit.Chem import AllChem</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.871.1">from rdkit.Chem.Draw import SimilarityMaps</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.872.1">AllChem.ComputeGasteigerCharges(m)</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.873.1">contribs = [m.GetAtomWithIdx(i).GetDoubleProp('_GasteigerCharge') for i in range(m.GetNumAtoms())]</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.874.1">fig = SimilarityMaps.GetSimilarityMapFromWeights(m, </span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.875.1">             contribs, contourLines=10, )</span></p>
			<p><span class="koboSpan" id="kobo.876.1">The output of </span><a id="_idIndexMarker319"/><span class="koboSpan" id="kobo.877.1">the preceding code can be seen in </span><em class="italic"><span class="koboSpan" id="kobo.878.1">Figure 4.26</span></em><span class="koboSpan" id="kobo.879.1">:</span></p>
			<p class="figure-caption"> </p>
			<div>
				<div id="_idContainer078" class="IMG---Figure">
					<span class="koboSpan" id="kobo.880.1"><img src="image/B17761_04_026.jpg" alt="Figure 4.26 – A representation of a small molecule's charge "/></span>
				</div>
			</div>
			<p class="figure-caption"><span class="koboSpan" id="kobo.881.1">Figure 4.26 – A representation of a small molecule's charge</span></p>
			<p><span class="koboSpan" id="kobo.882.1">Now that we </span><a id="_idIndexMarker320"/><span class="koboSpan" id="kobo.883.1">have gained an idea of how we can </span><a id="_idIndexMarker321"/><span class="koboSpan" id="kobo.884.1">use RDKit to represent small molecules, let's look at an application of this for large molecules instead.</span></p>
			<h2 id="_idParaDest-78"><a id="_idTextAnchor079"/><span class="koboSpan" id="kobo.885.1">Visualizing large molecules</span></h2>
			<p><span class="koboSpan" id="kobo.886.1">There are </span><a id="_idIndexMarker322"/><span class="koboSpan" id="kobo.887.1">a number of Python libraries</span><a id="_idIndexMarker323"/><span class="koboSpan" id="kobo.888.1"> designed for the visualization, simulation, and analysis of large molecules for the purposes of research and development. </span><span class="koboSpan" id="kobo.888.2">Currently, one of the most common libraries is </span><strong class="source-inline"><span class="koboSpan" id="kobo.889.1">py3Dmol</span></strong><span class="koboSpan" id="kobo.890.1">. </span><span class="koboSpan" id="kobo.890.2">Exclusively used for the purposes of 3D visualization within a Jupyter Notebook setting, this library allows for the creation of publication-ready visuals of 3D proteins. </span><span class="koboSpan" id="kobo.890.3">The library can be easily downloaded using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.891.1">pip</span></strong><span class="koboSpan" id="kobo.892.1"> framework.</span></p>
			<p><span class="koboSpan" id="kobo.893.1">At the time of writing, the world is still in the midst of dealing with the COVID-19 virus that originated in Wuhan, China and spread throughout the world. </span><span class="koboSpan" id="kobo.893.2">On July 8, 2020, a 1.7 Å resolution </span><a id="_idIndexMarker324"/><span class="koboSpan" id="kobo.894.1">structure of the </span><em class="italic"><span class="koboSpan" id="kobo.895.1">SARS-CoV-2 3CL</span></em><span class="koboSpan" id="kobo.896.1"> protease was released in the </span><strong class="bold"><span class="koboSpan" id="kobo.897.1">RCSB Protein Data Bank</span></strong><span class="koboSpan" id="kobo.898.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.899.1">RCSB PDB</span></strong><span class="koboSpan" id="kobo.900.1">) at </span><strong class="source-inline"><span class="koboSpan" id="kobo.901.1">pdb = 6XMK</span></strong><span class="koboSpan" id="kobo.902.1">. </span><span class="koboSpan" id="kobo.902.2">Let's go ahead and use this protein as an example in the following visualizations:</span></p>
			<ol>
				<li value="1"><span class="koboSpan" id="kobo.903.1">We can begin the development of this visual using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.904.1">py3dmol</span></strong><span class="koboSpan" id="kobo.905.1"> library and querying</span><a id="_idIndexMarker325"/><span class="koboSpan" id="kobo.906.1"> the protein structure directly within the following function:</span><p class="source-code"><span class="koboSpan" id="kobo.907.1">import py3Dmol</span></p><p class="source-code"><span class="koboSpan" id="kobo.908.1">largeMol = py3Dmol.view(query='pdb:6xmk', </span></p><p class="source-code"><span class="koboSpan" id="kobo.909.1">                           width=600,</span></p><p class="source-code"><span class="koboSpan" id="kobo.910.1">                           height=600)</span></p></li>
				<li><span class="koboSpan" id="kobo.911.1">With the library imported, a new variable object called </span><strong class="source-inline"><span class="koboSpan" id="kobo.912.1">lm</span></strong><span class="koboSpan" id="kobo.913.1"> can be specified using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.914.1">view</span></strong><span class="koboSpan" id="kobo.915.1"> class in </span><strong class="source-inline"><span class="koboSpan" id="kobo.916.1">py3Dmol</span></strong><span class="koboSpan" id="kobo.917.1">. </span><span class="koboSpan" id="kobo.917.2">This function takes three main arguments. </span><span class="koboSpan" id="kobo.917.3">The first is the identity of the protein of interest, namely </span><strong class="source-inline"><span class="koboSpan" id="kobo.918.1">6xmk</span></strong><span class="koboSpan" id="kobo.919.1">. </span><span class="koboSpan" id="kobo.919.2">The second and third arguments are the width and height of the display window, respectively. </span><span class="koboSpan" id="kobo.919.3">For more information about PDB files, visit the </span><strong class="bold"><span class="koboSpan" id="kobo.920.1">RCSB PDB</span></strong><span class="koboSpan" id="kobo.921.1"> at www.rcsb.org. </span><span class="koboSpan" id="kobo.921.2">Let's start by viewing this protein as a basic molecular stick structure by passing a </span><strong class="source-inline"><span class="koboSpan" id="kobo.922.1">stick</span></strong><span class="koboSpan" id="kobo.923.1"> argument:</span><p class="source-code"><span class="koboSpan" id="kobo.924.1"> largeMol.setStyle({'stick':{'color':'spectrum'}})</span></p><p class="source-code"><span class="koboSpan" id="kobo.925.1"> largeMol</span></p><p><span class="koboSpan" id="kobo.926.1">Upon executing this line of code, we get the following image of the molecule:</span></p><div id="_idContainer079" class="IMG---Figure"><span class="koboSpan" id="kobo.927.1"><img src="image/B17761_04_027.jpg" alt="Figure 4.27 – A representation of a large molecule or protein in ball-stick form "/></span></div><p class="figure-caption"><span class="koboSpan" id="kobo.928.1">Figure 4.27 – A representation of a large molecule or protein in ball-stick form</span></p></li>
				<li><span class="koboSpan" id="kobo.929.1">Notice </span><a id="_idIndexMarker326"/><span class="koboSpan" id="kobo.930.1">that we added a </span><strong class="source-inline"><span class="koboSpan" id="kobo.931.1">stick</span></strong><span class="koboSpan" id="kobo.932.1"> argument </span><a id="_idIndexMarker327"/><span class="koboSpan" id="kobo.933.1">that displayed the last structure. </span><span class="koboSpan" id="kobo.933.2">We can change this argument to </span><strong class="source-inline"><span class="koboSpan" id="kobo.934.1">cartoon</span></strong><span class="koboSpan" id="kobo.935.1"> to see a cartoon representation of this protein based on its </span><em class="italic"><span class="koboSpan" id="kobo.936.1">secondary structure</span></em><span class="koboSpan" id="kobo.937.1">:</span><p class="source-code"><span class="koboSpan" id="kobo.938.1">largeMol.setStyle({'cartoon':{'color':'spectrum'}})</span></p><p class="source-code"><span class="koboSpan" id="kobo.939.1">largeMol</span></p><p><span class="koboSpan" id="kobo.940.1"> When executing this line of code, we get the following image of the molecule:</span></p><div id="_idContainer080" class="IMG---Figure"><span class="koboSpan" id="kobo.941.1"><img src="image/B17761_04_028.jpg" alt="Figure 4.28 – A representation of a large molecule or protein's secondary structure "/></span></div><p class="figure-caption"><span class="koboSpan" id="kobo.942.1">Figure 4.28 – A representation of a large molecule or protein's secondary structure</span></p></li>
				<li><span class="koboSpan" id="kobo.943.1">There are</span><a id="_idIndexMarker328"/><span class="koboSpan" id="kobo.944.1"> a number of other changes and </span><a id="_idIndexMarker329"/><span class="koboSpan" id="kobo.945.1">arguments that can be added to custom fit this visualization to a user's particular aims. </span><span class="koboSpan" id="kobo.945.2">One of these changes is the addition of a </span><strong class="bold"><span class="koboSpan" id="kobo.946.1">Van der Waals surface</span></strong><span class="koboSpan" id="kobo.947.1">, which allows for the illustration of the area through which a molecular interaction might occur. </span><span class="koboSpan" id="kobo.947.2">We will add this surface to only one of the two chains on this protein:</span><p class="source-code"><span class="koboSpan" id="kobo.948.1">lm = py3Dmol.view(query='pdb:6xmk')</span></p><p class="source-code"><span class="koboSpan" id="kobo.949.1">chA = {'chain':'A'}</span></p><p class="source-code"><span class="koboSpan" id="kobo.950.1">chB = {'chain':'B'}</span></p><p class="source-code"><span class="koboSpan" id="kobo.951.1">lm.setStyle(chA,{'cartoon': {'color':'spectrum'}}) </span></p><p class="source-code"><span class="koboSpan" id="kobo.952.1">lm.addSurface(py3Dmol.VDW, {'opacity':0.7, 'color':'white'}, chA)</span></p><p class="source-code"><span class="koboSpan" id="kobo.953.1">lm.setStyle(chB,{'cartoon': {'color':'spectrum'}})</span></p><p class="source-code"><span class="koboSpan" id="kobo.954.1">lm.show()</span></p><p><span class="koboSpan" id="kobo.955.1">We can see the output of this code in </span><em class="italic"><span class="koboSpan" id="kobo.956.1">Figure 4.29</span></em><span class="koboSpan" id="kobo.957.1">:</span></p></li>
			</ol>
			<div>
				<div id="_idContainer081" class="IMG---Figure">
					<span class="koboSpan" id="kobo.958.1"><img src="image/B17761_04_029.jpg" alt="Figure 4.29 – A representation of a large molecule or protein's secondary structure with a Van der Waals surface on one of the chains"/></span>
				</div>
			</div>
			<p class="figure-caption"><span class="koboSpan" id="kobo.959.1">Figure 4.29 – A representation of a large molecule or protein's secondary structure with a Van der Waals surface on one of the chains</span></p>
			<p><span class="koboSpan" id="kobo.960.1">The study of large molecules, or </span><strong class="bold"><span class="koboSpan" id="kobo.961.1">biologics</span></strong><span class="koboSpan" id="kobo.962.1">, have shown tremendous growth in the biotechnology sector in recent years. </span><span class="koboSpan" id="kobo.962.2">Within this chapter, we briefly introduced one of the many methods </span><a id="_idIndexMarker330"/><span class="koboSpan" id="kobo.963.1">used to visualize these complex </span><a id="_idIndexMarker331"/><span class="koboSpan" id="kobo.964.1">molecules – an important first step for any bioinformatics project. </span></p>
			<h1 id="_idParaDest-79"><a id="_idTextAnchor080"/><span class="koboSpan" id="kobo.965.1">Summary</span></h1>
			<p><span class="koboSpan" id="kobo.966.1">Visualizations can be useful, powerful, and convincing tools to help illustrate points and drive conversations in specific directions. </span><span class="koboSpan" id="kobo.966.2">To create a proper visualization, there are certain steps and techniques that need to be taken to ensure your diagram is correct and effective.</span></p>
			<p><span class="koboSpan" id="kobo.967.1">Within this chapter, we explored the six main steps to follow when creating a proper visualization. </span><span class="koboSpan" id="kobo.967.2">We also explored many different methods and libraries within the scope of Python to help you create and style visuals for your specific aims. </span><span class="koboSpan" id="kobo.967.3">We explored some of the more basic visuals, such as bar plots, histograms, and scatter plots to analyze a few features at a time. </span><span class="koboSpan" id="kobo.967.4">We also explored more complex visualizations such as pair plots, heat maps, Sankey diagrams, and molecular representations, with which we can explore many more features.</span></p>
			<p><span class="koboSpan" id="kobo.968.1">We also touched on the concept of </span><em class="italic"><span class="koboSpan" id="kobo.969.1">correlation</span></em><span class="koboSpan" id="kobo.970.1"> and how certain features can have relationships with others – a concept we will cover in greater detail as we turn our attention to </span><strong class="bold"><span class="koboSpan" id="kobo.971.1">machine learning</span></strong><span class="koboSpan" id="kobo.972.1"> in the next chapter.</span></p>
		</div>
	</body></html>