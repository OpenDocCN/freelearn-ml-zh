["```py\ndef onehot2value(l, allowZeros=False):    for i, x in enumerate(l):\n        if x == 1:\n            return i\n    if allowZeros:\n        return len(l)\n    else:\n        raise Exception(\"No non-zero value found\")\n```", "```py\nfrom scipy import sparsedef tweets2sparse(train, wthreshold=1):\n    rows = []\n    data = []\n    columns = []\n    for i, tweet in enumerate(train.tweets):\n        t = sum(train.idf[token] for token in tweet.tokens)\n        for token in tweet.tokens:\n            if train.df[token] > wthreshold:\n                rows.append(i)\n                columns.append(train.index[token])\n                if useDF:\n                    s = train.idf[token]/t\n                else:\n                    s = 1\n                data.append(s)\n    return sparse.csc_matrix((data, (rows, columns)),\n                             (len(train.tweets[:N]),\n                              len(train.index)))\n```", "```py\nclass SKLEARNCLASSIFIER(classifiers.BASECLASSIFIER):    def readTrainingData(self, train, N=sys.maxsize,\n                         useDF=False):\n        if isinstance(train, str):\n            train = tweets.makeDATASET(train)\n        self.train = train\n        self.matrix = tweets.tweets2sparse(self.train, N=N,\n                                           useDF=useDF)\n        # Convert the one-hot representation of the Gold\n        # Standard for each tweet to a class identifier\n        emotions = self.train.emotions\n        self.values = [tweets.onehot2value(tweet.GS,\n                                           emotions)\n                       for tweet in train.tweets[:N]]\n```", "```py\n    def applyToTweet(self, tweet, resultAsOneHot):        p = self.clsf.predict(tweets.tweet2sparse(tweet,\n                                                  self))[0]\n        if resultAsOneHot:\n            k = [0 for i in self.train.emotions]+[0]\n            k[p] = 1\n            return k\n        else:\n            return p\n```", "```py\nclass NBCLASSIFIER(sklearnclassifier.SKLEARNCLASSIFIER):    def __init__(self, train, N=sys.maxsize, args={}):\n        # Convert the training data to sklearn format\n        self.readTrainingData(train, N=N, args=args)\n        # Make a naive bayes classifier\n        self.clsf = naive_bayes.MultinomialNB()\n        # Train it on the dataset\n        self.clsf.fit(self.matrix, self.values)\n```", "```py\nclass NBCLASSIFIER1(NBCLASSIFIER):    def applyToTweet(self, tweet, resultAsOneHot=True):\n        tweet = tweets.tweet2sparse(tweet, self)\n        # use predict_log_proba\n        p = self.clsf.predict_log_proba(tweet)[0]\n        # compare to previously defined threshold\n        threshold = numpy.log(self.threshold)\n        return [1 if i > threshold else 0 for i in p]\n```", "```py\nclass NBCLASSIFIER2(NBCLASSIFIER):    def applyToTweet(self, tweet, resultAsOneHot=True):\n        tweet = tweets.tweet2sparse(tweet, self)\n        p = self.clsf.predict_log_proba(tweet)[0]\n        # pick the second highest score in p\n        threshold = list(reversed(sorted(list(p))))[2]\n        return [1 if i > threshold else 0 for i in p]\n```"]