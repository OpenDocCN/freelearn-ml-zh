<html><head></head><body>
<div class="Basic-Text-Frame" id="_idContainer158">
<h1 class="chapterNumber"><span class="koboSpan" id="kobo.1.1">6</span></h1>
<h1 class="chapterTitle" id="_idParaDest-75"><span class="koboSpan" id="kobo.2.1">Can You Predict Bee Subspecies?</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.3.1">In this chapter, we will learn how to work with image data and start building models to classify images. </span><span class="koboSpan" id="kobo.3.2">Computer vision’s part in data science and data analysis has grown in an exponential way over the years. </span><span class="koboSpan" id="kobo.3.3">Some of the most high-profile (with a large number of upvotes and forks, e.g., copying and editing) notebooks on Kaggle are not </span><strong class="keyWord"><span class="koboSpan" id="kobo.4.1">Exploratory Data Analysis</span></strong><span class="koboSpan" id="kobo.5.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.6.1">EDA</span></strong><span class="koboSpan" id="kobo.7.1">) notebooks</span><a id="_idIndexMarker248"/><span class="koboSpan" id="kobo.8.1"> or just EDAs but, instead, notebooks to build models.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.9.1">In this chapter, we will demonstrate how to use your in-depth data analysis to prepare to build a model, and we will also give you some insights into the process of iteratively refining a model. </span><span class="koboSpan" id="kobo.9.2">It will be not for a competition but, instead, for an image dataset. </span><span class="koboSpan" id="kobo.9.3">The dataset is the </span><em class="italic"><span class="koboSpan" id="kobo.10.1">BeeImage Dataset: Annotated Honey Bee Images</span></em><span class="koboSpan" id="kobo.11.1"> (see </span><em class="italic"><span class="koboSpan" id="kobo.12.1">Reference 1</span></em><span class="koboSpan" id="kobo.13.1">). </span><span class="koboSpan" id="kobo.13.2">In the previous chapter, we also started to use Plotly as a visualization library. </span><span class="koboSpan" id="kobo.13.3">In this chapter, we will continue to use Plotly for visualization of the dataset features. </span><span class="koboSpan" id="kobo.13.4">We grouped a few useful functions for visualization with Plotly in a utility script, </span><code class="inlineCode"><span class="koboSpan" id="kobo.14.1">plotly-utils</span></code><span class="koboSpan" id="kobo.15.1"> (see </span><em class="italic"><span class="koboSpan" id="kobo.16.1">Reference 2</span></em><span class="koboSpan" id="kobo.17.1">). </span><span class="koboSpan" id="kobo.17.2">The notebook associated with this chapter is </span><em class="italic"><span class="koboSpan" id="kobo.18.1">Honeybee Subspecies Classification </span></em><span class="koboSpan" id="kobo.19.1">(see </span><em class="italic"><span class="koboSpan" id="kobo.20.1">Reference 3</span></em><span class="koboSpan" id="kobo.21.1">).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.22.1">This chapter will cover the following topics:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.23.1">A comprehensive data exploration of the </span><em class="italic"><span class="koboSpan" id="kobo.24.1">BeeImage Dataset: Annotated Honey Bee Images</span></em><span class="koboSpan" id="kobo.25.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.26.1">Preparation of a model baseline followed by step-by-step model refinement, analyzing the effect of the changes performed on the evolution of train and validation metrics, and taking new actions to further improve the model.</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-76"><span class="koboSpan" id="kobo.27.1">Data exploration</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.28.1">The </span><em class="italic"><span class="koboSpan" id="kobo.29.1">BeeImage Dataset: Annotated Honey Bee Images</span></em><span class="koboSpan" id="kobo.30.1"> contains </span><a id="_idIndexMarker249"/><span class="koboSpan" id="kobo.31.1">one </span><strong class="keyWord"><span class="koboSpan" id="kobo.32.1">comma-delimited format</span></strong><span class="koboSpan" id="kobo.33.1"> (.</span><strong class="keyWord"><span class="koboSpan" id="kobo.34.1">csv</span></strong><span class="koboSpan" id="kobo.35.1">) file, </span><code class="inlineCode"><span class="koboSpan" id="kobo.36.1">bee_data.csv</span></code><span class="koboSpan" id="kobo.37.1">, with 5172 rows</span><a id="_idIndexMarker250"/><span class="koboSpan" id="kobo.38.1"> and 9 columns, along with a folder with 5172 images:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.39.1"><img alt="A screenshot of a computer  Description automatically generated with low confidence" src="../Images/B20963_06_01.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.40.1">Figure 6.1: Sample of the bee_data.csv data file</span></p>
<p class="normal"><span class="koboSpan" id="kobo.41.1">As you can see, the preceding dataframe contains the following columns:</span></p>
<ul>
<li class="bulletList"><strong class="screenText"><span class="koboSpan" id="kobo.42.1">file</span></strong><span class="koboSpan" id="kobo.43.1">: the image filename</span></li>
<li class="bulletList"><strong class="screenText"><span class="koboSpan" id="kobo.44.1">date</span></strong><span class="koboSpan" id="kobo.45.1">: the date when the picture was taken</span></li>
<li class="bulletList"><strong class="screenText"><span class="koboSpan" id="kobo.46.1">time</span></strong><span class="koboSpan" id="kobo.47.1">: the time when the picture was taken</span></li>
<li class="bulletList"><strong class="screenText"><span class="koboSpan" id="kobo.48.1">location</span></strong><span class="koboSpan" id="kobo.49.1">: the US location, with city, state, and country names</span></li>
<li class="bulletList"><strong class="screenText"><span class="koboSpan" id="kobo.50.1">zip code</span></strong><span class="koboSpan" id="kobo.51.1">: the ZIP code associated with the location</span></li>
<li class="bulletList"><strong class="screenText"><span class="koboSpan" id="kobo.52.1">subspecies</span></strong><span class="koboSpan" id="kobo.53.1">: the subspecies to whom the bee in the current image belongs</span></li>
<li class="bulletList"><strong class="screenText"><span class="koboSpan" id="kobo.54.1">health</span></strong><span class="koboSpan" id="kobo.55.1">: the health state of the bee in the current image</span></li>
<li class="bulletList"><strong class="screenText"><span class="koboSpan" id="kobo.56.1">pollen_carrying</span></strong><span class="koboSpan" id="kobo.57.1">: indicates whether the picture shows the bee with pollen attached to its legs or not</span></li>
<li class="bulletList"><strong class="screenText"><span class="koboSpan" id="kobo.58.1">caste</span></strong><span class="koboSpan" id="kobo.59.1">: the bee’s caste</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.60.1">We will start the data exploration journey with a few quality checks, focusing on the </span><code class="inlineCode"><span class="koboSpan" id="kobo.61.1">bee_data.csv</span></code><span class="koboSpan" id="kobo.62.1"> file, followed by the images. </span><span class="koboSpan" id="kobo.62.2">For the data quality checks, we will use one of the utility scripts previously introduced in </span><em class="italic"><span class="koboSpan" id="kobo.63.1">Chapter 4</span></em><span class="koboSpan" id="kobo.64.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.65.1">data_quality_stats</span></code><span class="koboSpan" id="kobo.66.1">.</span></p>
<h2 class="heading-2" id="_idParaDest-77"><span class="koboSpan" id="kobo.67.1">Data quality checks</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.68.1">The dataset does</span><a id="_idIndexMarker251"/><span class="koboSpan" id="kobo.69.1"> not have any missing values, as you can see in the following figure. </span><span class="koboSpan" id="kobo.69.2">All the features are of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.70.1">string</span></code><span class="koboSpan" id="kobo.71.1"> type.</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.72.1"><img alt="A screenshot of a computer  Description automatically generated with low confidence" src="../Images/B20963_06_02.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.73.1">Figure 6.2: Missing values in the bee_data.csv file. </span><span class="koboSpan" id="kobo.73.2">The result was obtained using the data_quality_stats functions</span></p>
<p class="normal"><span class="koboSpan" id="kobo.74.1">In </span><em class="italic"><span class="koboSpan" id="kobo.75.1">Figure 6.3</span></em><span class="koboSpan" id="kobo.76.1">, we show the unique values of the dataset features. </span><span class="koboSpan" id="kobo.76.2">The data was collected:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.77.1">at 6 different dates and 35 different times</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.78.1">in 8 locations with 7 different ZIP codes</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.79.1">In the data, there are seven subspecies represented with six different health problems.</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.80.1"><img alt="A picture containing text, screenshot, font, line  Description automatically generated" src="../Images/B20963_06_03.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.81.1">Figure 6.3: Unique values in the bee_data.csv file. </span><span class="koboSpan" id="kobo.81.2">The result was obtained using the data_quality_stats functions</span></p>
<p class="normal"><span class="koboSpan" id="kobo.82.1">From the data shown in </span><em class="italic"><span class="koboSpan" id="kobo.83.1">Figure 6.4</span></em><span class="koboSpan" id="kobo.84.1">, 21% of the images are from one single date (out of 16 different dates). </span><span class="koboSpan" id="kobo.84.2">There </span><a id="_idIndexMarker252"/><span class="koboSpan" id="kobo.85.1">was a time when 11% of images were collected. </span><span class="koboSpan" id="kobo.85.2">There is one single location (Saratoga, California, with the ZIP code 95070) where 2000 (or 39% of the) images were collected. </span><span class="koboSpan" id="kobo.85.3">Italian honeybee is the most frequent species. </span><span class="koboSpan" id="kobo.85.4">65% of the images represent healthy bees. </span><span class="koboSpan" id="kobo.85.5">Almost all the images show bees that do not carry pollen, and all are from the worker caste.</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.86.1"><img alt="A picture containing text, font, number, line  Description automatically generated" src="../Images/B20963_06_04.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.87.1">Figure 6.4: The most frequent values in the bee_data.csv file. </span><span class="koboSpan" id="kobo.87.2">The result was obtained using data_quality_stats functions</span></p>
<p class="normal"><span class="koboSpan" id="kobo.88.1">Next, we will review the image data in parallel with the features in </span><code class="inlineCode"><span class="koboSpan" id="kobo.89.1">bee_data.csv</span></code><span class="koboSpan" id="kobo.90.1">. </span><span class="koboSpan" id="kobo.90.2">We will also introduce functions to read and visualize the images.</span></p>
<h2 class="heading-2" id="_idParaDest-78"><span class="koboSpan" id="kobo.91.1">Exploring image data</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.92.1">First, we check that</span><a id="_idIndexMarker253"/><span class="koboSpan" id="kobo.93.1"> all the image names present in the dataset are also present in the folder with images:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.94.1">file_names = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.95.1">list</span></span><span class="koboSpan" id="kobo.96.1">(honey_bee_df[</span><span class="hljs-string"><span class="koboSpan" id="kobo.97.1">'file'</span></span><span class="koboSpan" id="kobo.98.1">])
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.99.1">print</span></span><span class="koboSpan" id="kobo.100.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.101.1">"Matching image names: {}"</span></span><span class="koboSpan" id="kobo.102.1">.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.103.1">format</span></span><span class="koboSpan" id="kobo.104.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.105.1">len</span></span><span class="koboSpan" id="kobo.106.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.107.1">set</span></span><span class="koboSpan" id="kobo.108.1">(file_names).intersection(image_files))))
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.109.1">The result is that all the images indexed in the .</span><code class="inlineCode"><span class="koboSpan" id="kobo.110.1">csv</span></code><span class="koboSpan" id="kobo.111.1"> file are present in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.112.1">images</span></code><span class="koboSpan" id="kobo.113.1"> folder. </span><span class="koboSpan" id="kobo.113.2">Next, we check the image sizes. </span><span class="koboSpan" id="kobo.113.3">For this, we can use the following code to read images:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.114.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.115.1">read_image_sizes</span></span><span class="koboSpan" id="kobo.116.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.117.1">file_name</span></span><span class="koboSpan" id="kobo.118.1">):
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.119.1">"""</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.120.1">    Read images size using skimage.io</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.121.1">    Args:</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.122.1">        file_name: the name of the image file</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.123.1">    Returns:</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.124.1">        A list with images shape</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.125.1">    """</span></span><span class="koboSpan" id="kobo.126.1">
    image = skimage.io.imread(config[</span><span class="hljs-string"><span class="koboSpan" id="kobo.127.1">'image_path'</span></span><span class="koboSpan" id="kobo.128.1">] + file_name)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.129.1">return</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.130.1">list</span></span><span class="koboSpan" id="kobo.131.1">(image.shape)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.132.1">Alternatively, we can use the following code to read images based on the OpenCSV (</span><code class="inlineCode"><span class="koboSpan" id="kobo.133.1">cv2</span></code><span class="koboSpan" id="kobo.134.1">) library:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.135.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.136.1">read_image_sizes_cv</span></span><span class="koboSpan" id="kobo.137.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.138.1">file_name</span></span><span class="koboSpan" id="kobo.139.1">):
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.140.1">"""</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.141.1">    Read images size using OpenCV</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.142.1">    Args:</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.143.1">        file_name: the name of the image file</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.144.1">    Returns:</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.145.1">        A list with images shape</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.146.1">    """</span></span><span class="koboSpan" id="kobo.147.1">
    image = cv2.imread(config[</span><span class="hljs-string"><span class="koboSpan" id="kobo.148.1">'image_path'</span></span><span class="koboSpan" id="kobo.149.1">] + file_name)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.150.1">return</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.151.1">list</span></span><span class="koboSpan" id="kobo.152.1">(image.shape)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.153.1">We now compare the speed of the preceding two methods using a subsample of all the images. </span><span class="koboSpan" id="kobo.153.2">The following code snippet measures the execution time to read the images, using the method based on </span><code class="inlineCode"><span class="koboSpan" id="kobo.154.1">skimage.io</span></code><span class="koboSpan" id="kobo.155.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.156.1">%timeit m = np.stack(subset.apply(read_image_sizes))
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.157.1">The code below is used to measure the execution time to read the images, using the method based on opencv:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.158.1">%timeit m = np.stack(subset.apply(read_image_sizes_cv))
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.159.1">The comparison shows that the execution was faster using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.160.1">opencv</span></code><span class="koboSpan" id="kobo.161.1">-based method:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.162.1">With </span><code class="inlineCode"><span class="koboSpan" id="kobo.163.1">skimage.io</span></code><span class="koboSpan" id="kobo.164.1">:</span></li>
</ul>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.165.1">129 ms ± 4.12 ms per loop (mean ± std. </span><span class="koboSpan" id="kobo.165.2">dev. </span><span class="koboSpan" id="kobo.165.3">of 7 runs, 1 loop each)</span></code></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.166.1">With </span><code class="inlineCode"><span class="koboSpan" id="kobo.167.1">opencv</span></code><span class="koboSpan" id="kobo.168.1">:</span></li>
</ul>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.169.1">127 ms ± 6.79 ms per loop (mean ± std. </span><span class="koboSpan" id="kobo.169.2">dev. </span><span class="koboSpan" id="kobo.169.3">of 7 runs, 10 loops each)</span></code></p>
<p class="normal"><span class="koboSpan" id="kobo.170.1">Then, we apply the fastest approach to extract the shape of each image (the width, height, and depth, or </span><a id="_idIndexMarker254"/><span class="koboSpan" id="kobo.171.1">the number of color dimensions) and add it to the dataset for each image:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.172.1">t_start = time.time()
m = np.stack(honey_bee_df[</span><span class="hljs-string"><span class="koboSpan" id="kobo.173.1">'file'</span></span><span class="koboSpan" id="kobo.174.1">].apply(read_image_sizes_cv))
df = pd.DataFrame(m,columns=[</span><span class="hljs-string"><span class="koboSpan" id="kobo.175.1">'w'</span></span><span class="koboSpan" id="kobo.176.1">,</span><span class="hljs-string"><span class="koboSpan" id="kobo.177.1">'h'</span></span><span class="koboSpan" id="kobo.178.1">,</span><span class="hljs-string"><span class="koboSpan" id="kobo.179.1">'c'</span></span><span class="koboSpan" id="kobo.180.1">])
honey_bee_df = pd.concat([honey_bee_df,df],axis=</span><span class="hljs-number"><span class="koboSpan" id="kobo.181.1">1</span></span><span class="koboSpan" id="kobo.182.1">, sort=</span><span class="hljs-literal"><span class="koboSpan" id="kobo.183.1">False</span></span><span class="koboSpan" id="kobo.184.1">)
t_end = time.time()
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.185.1">print</span></span><span class="koboSpan" id="kobo.186.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.187.1">f"Total processing time (using OpenCV): </span></span><span class="hljs-subst"><span class="koboSpan" id="kobo.188.1">{</span></span><span class="hljs-built_in"><span class="koboSpan" id="kobo.189.1">round</span></span><span class="hljs-subst"><span class="koboSpan" id="kobo.190.1">(t_end-t_start, </span></span><span class="hljs-number"><span class="koboSpan" id="kobo.191.1">2</span></span><span class="hljs-subst"><span class="koboSpan" id="kobo.192.1">)}</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.193.1"> sec."</span></span><span class="koboSpan" id="kobo.194.1">)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.195.1">The output of executing the preceding code is:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.196.1">Total processing time (using OpenCV): 34.38 sec.
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.197.1">We can check the image size distribution using the following code snippet. </span><span class="koboSpan" id="kobo.197.2">Notice that we use Plotly to create this visualization. </span><span class="koboSpan" id="kobo.197.3">We create two traces of the type </span><code class="inlineCode"><span class="koboSpan" id="kobo.198.1">boxplot</span></code><span class="koboSpan" id="kobo.199.1">. </span><span class="koboSpan" id="kobo.199.2">In the first, we show the image width distribution, and in the second, the image height distribution. </span><span class="koboSpan" id="kobo.199.3">The boxplot shows the minimum, first quartile, median, third quartile, and maximum values in the distribution of the value we plot. </span><span class="koboSpan" id="kobo.199.4">We also show the outliers’ values as points on each of the traces:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.200.1">traceW = go.Box(
    x = honey_bee_df[</span><span class="hljs-string"><span class="koboSpan" id="kobo.201.1">'w'</span></span><span class="koboSpan" id="kobo.202.1">],
    name=</span><span class="hljs-string"><span class="koboSpan" id="kobo.203.1">"Width"</span></span><span class="koboSpan" id="kobo.204.1">,
     marker=</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.205.1">dict</span></span><span class="koboSpan" id="kobo.206.1">(
                color=</span><span class="hljs-string"><span class="koboSpan" id="kobo.207.1">'rgba(238,23,11,0.5)'</span></span><span class="koboSpan" id="kobo.208.1">,
                line=</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.209.1">dict</span></span><span class="koboSpan" id="kobo.210.1">(
                    color=</span><span class="hljs-string"><span class="koboSpan" id="kobo.211.1">'red'</span></span><span class="koboSpan" id="kobo.212.1">,
                    width=</span><span class="hljs-number"><span class="koboSpan" id="kobo.213.1">1.2</span></span><span class="koboSpan" id="kobo.214.1">),
            ),
    orientation=</span><span class="hljs-string"><span class="koboSpan" id="kobo.215.1">'h'</span></span><span class="koboSpan" id="kobo.216.1">)
traceH = go.Box(
    x = honey_bee_df[</span><span class="hljs-string"><span class="koboSpan" id="kobo.217.1">'h'</span></span><span class="koboSpan" id="kobo.218.1">],
    name=</span><span class="hljs-string"><span class="koboSpan" id="kobo.219.1">"Height"</span></span><span class="koboSpan" id="kobo.220.1">,
    marker=</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.221.1">dict</span></span><span class="koboSpan" id="kobo.222.1">(
                color=</span><span class="hljs-string"><span class="koboSpan" id="kobo.223.1">'rgba(11,23,245,0.5)'</span></span><span class="koboSpan" id="kobo.224.1">,
                line=</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.225.1">dict</span></span><span class="koboSpan" id="kobo.226.1">(
                    color=</span><span class="hljs-string"><span class="koboSpan" id="kobo.227.1">'blue'</span></span><span class="koboSpan" id="kobo.228.1">,
                    width=</span><span class="hljs-number"><span class="koboSpan" id="kobo.229.1">1.2</span></span><span class="koboSpan" id="kobo.230.1">),
            ),
    orientation=</span><span class="hljs-string"><span class="koboSpan" id="kobo.231.1">'h'</span></span><span class="koboSpan" id="kobo.232.1">)
data = [traceW, traceH]
layout = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.233.1">dict</span></span><span class="koboSpan" id="kobo.234.1">(title = </span><span class="hljs-string"><span class="koboSpan" id="kobo.235.1">'Width &amp; Heights of images'</span></span><span class="koboSpan" id="kobo.236.1">,
          xaxis = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.237.1">dict</span></span><span class="koboSpan" id="kobo.238.1">(title = </span><span class="hljs-string"><span class="koboSpan" id="kobo.239.1">'Size'</span></span><span class="koboSpan" id="kobo.240.1">, showticklabels=</span><span class="hljs-literal"><span class="koboSpan" id="kobo.241.1">True</span></span><span class="koboSpan" id="kobo.242.1">), 
          yaxis = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.243.1">dict</span></span><span class="koboSpan" id="kobo.244.1">(title = </span><span class="hljs-string"><span class="koboSpan" id="kobo.245.1">'Image dimmension'</span></span><span class="koboSpan" id="kobo.246.1">),
          hovermode = </span><span class="hljs-string"><span class="koboSpan" id="kobo.247.1">'closest'</span></span><span class="koboSpan" id="kobo.248.1">,
         )
fig = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.249.1">dict</span></span><span class="koboSpan" id="kobo.250.1">(data=data, layout=layout)
iplot(fig, filename=</span><span class="hljs-string"><span class="koboSpan" id="kobo.251.1">'width-height'</span></span><span class="koboSpan" id="kobo.252.1">)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.253.1">The result is</span><a id="_idIndexMarker255"/><span class="koboSpan" id="kobo.254.1"> plotted in </span><em class="italic"><span class="koboSpan" id="kobo.255.1">Figure 6.5</span></em><span class="koboSpan" id="kobo.256.1">. </span><span class="koboSpan" id="kobo.256.2">Median values for width and height are 61 and 62, respectively. </span><span class="koboSpan" id="kobo.256.3">There are many outliers for both width (the maximum value being 520) and height (the maximum value is 392).</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.257.1"><img alt="" role="presentation" src="../Images/B20963_06_05.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.258.1">Figure 6.5: Width and height distribution of images</span></p>
<p class="normal"><span class="koboSpan" id="kobo.259.1">In our analysis, we include all the features in the dataset, not only the ones related to images. </span><span class="koboSpan" id="kobo.259.2">We want to</span><a id="_idIndexMarker256"/><span class="koboSpan" id="kobo.260.1"> understand, before we start building a baseline for the prediction model, all aspects related to </span><em class="italic"><span class="koboSpan" id="kobo.261.1">The BeeImage Dataset: Annotated Honey Bee Images</span></em><span class="koboSpan" id="kobo.262.1">.</span></p>
<h2 class="heading-2" id="_idParaDest-79"><span class="koboSpan" id="kobo.263.1">Locations</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.264.1">By grouping the data</span><a id="_idIndexMarker257"/><span class="koboSpan" id="kobo.265.1"> in our dataset by locations where the pictures were shot and ZIP code, we can observe that there is one location with the same ZIP code and similar name:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.266.1"><img alt="" role="presentation" src="../Images/B20963_06_06.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.267.1">Figure 6.6: Locations and ZIP codes where the pictures with bees were taken</span></p>
<p class="normal"><span class="koboSpan" id="kobo.268.1">We can observe that Athens, Georgia, USA appears with two slightly different names. </span><span class="koboSpan" id="kobo.268.2">We just merge them using the following lines of code:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.269.1">honey_bee_df = honey_bee_df.replace({</span><span class="hljs-string"><span class="koboSpan" id="kobo.270.1">'location'</span></span><span class="koboSpan" id="kobo.271.1">:</span><span class="hljs-string"><span class="koboSpan" id="kobo.272.1">'Athens, Georgia, USA'</span></span><span class="koboSpan" id="kobo.273.1">}, </span><span class="hljs-string"><span class="koboSpan" id="kobo.274.1">'Athens, GA, USA'</span></span><span class="koboSpan" id="kobo.275.1">)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.276.1">Now, let’s visualize, using one of the functions in the Plotly utility script module, the distribution of the resulting location data:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.277.1">tmp = honey_bee_df.groupby([</span><span class="hljs-string"><span class="koboSpan" id="kobo.278.1">'zip code'</span></span><span class="koboSpan" id="kobo.279.1">])[</span><span class="hljs-string"><span class="koboSpan" id="kobo.280.1">'location'</span></span><span class="koboSpan" id="kobo.281.1">].value_counts()
df = pd.DataFrame(data={</span><span class="hljs-string"><span class="koboSpan" id="kobo.282.1">'Images'</span></span><span class="koboSpan" id="kobo.283.1">: tmp.values}, index=tmp.index).reset_index()
df[</span><span class="hljs-string"><span class="koboSpan" id="kobo.284.1">'code'</span></span><span class="koboSpan" id="kobo.285.1">] = df[</span><span class="hljs-string"><span class="koboSpan" id="kobo.286.1">'location'</span></span><span class="koboSpan" id="kobo.287.1">].</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.288.1">map</span></span><span class="koboSpan" id="kobo.289.1">(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.290.1">lambda</span></span><span class="koboSpan" id="kobo.291.1"> x: x.split(</span><span class="hljs-string"><span class="koboSpan" id="kobo.292.1">','</span></span><span class="koboSpan" id="kobo.293.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.294.1">2</span></span><span class="koboSpan" id="kobo.295.1">)[</span><span class="hljs-number"><span class="koboSpan" id="kobo.296.1">1</span></span><span class="koboSpan" id="kobo.297.1">])
plotly_barplot(df, </span><span class="hljs-string"><span class="koboSpan" id="kobo.298.1">'location'</span></span><span class="koboSpan" id="kobo.299.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.300.1">'Images'</span></span><span class="koboSpan" id="kobo.301.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.302.1">'Tomato'</span></span><span class="koboSpan" id="kobo.303.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.304.1">'Locations'</span></span><span class="koboSpan" id="kobo.305.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.306.1">'Number of images'</span></span><span class="koboSpan" id="kobo.307.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.308.1">'</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.309.1">Number of bees images per location'</span></span><span class="koboSpan" id="kobo.310.1">)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.311.1">The code for the function </span><code class="inlineCode"><span class="koboSpan" id="kobo.312.1">plotly_barplot</span></code><span class="koboSpan" id="kobo.313.1"> is given here:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.314.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.315.1">plotly_barplot</span></span><span class="koboSpan" id="kobo.316.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.317.1">df, x_feature, y_feature, col, x_label, y_label, title</span></span><span class="koboSpan" id="kobo.318.1">):
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.319.1">"""</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.320.1">    Plot a barplot with number of y for category x</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.321.1">    Args:</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.322.1">        df: dataframe</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.323.1">        x_feature: x feature</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.324.1">        y_feature: y feature</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.325.1">        col: color for markers</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.326.1">        x_label: x label</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.327.1">        y_label: y label</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.328.1">        title: title</span></span>
<span class="hljs-string"> </span>
<span class="hljs-string"><span class="koboSpan" id="kobo.329.1">    Returns:</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.330.1">        None</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.331.1">    """</span></span><span class="koboSpan" id="kobo.332.1">
    trace = go.Bar(
            x = df[x_feature],
            y = df[y_feature],
            marker=</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.333.1">dict</span></span><span class="koboSpan" id="kobo.334.1">(color=col),
            </span><span class="hljs-comment"><span class="koboSpan" id="kobo.335.1">#text=df['location']</span></span><span class="koboSpan" id="kobo.336.1">
        )
    data = [trace]
    layout = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.337.1">dict</span></span><span class="koboSpan" id="kobo.338.1">(title = title,
              xaxis = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.339.1">dict</span></span><span class="koboSpan" id="kobo.340.1">(title = x_label, showticklabels=</span><span class="hljs-literal"><span class="koboSpan" id="kobo.341.1">True</span></span><span class="koboSpan" id="kobo.342.1">, tickangle=</span><span class="hljs-number"><span class="koboSpan" id="kobo.343.1">15</span></span><span class="koboSpan" id="kobo.344.1">), 
              yaxis = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.345.1">dict</span></span><span class="koboSpan" id="kobo.346.1">(title = y_label),
              hovermode = </span><span class="hljs-string"><span class="koboSpan" id="kobo.347.1">'closest'</span></span><span class="koboSpan" id="kobo.348.1">
             )
    fig = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.349.1">dict</span></span><span class="koboSpan" id="kobo.350.1">(data = data, layout = layout)
    iplot(fig, filename=</span><span class="hljs-string"><span class="koboSpan" id="kobo.351.1">f'images-</span></span><span class="hljs-subst"><span class="koboSpan" id="kobo.352.1">{x_feature}</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.353.1">-</span></span><span class="hljs-subst"><span class="koboSpan" id="kobo.354.1">{y_feature}</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.355.1">'</span></span><span class="koboSpan" id="kobo.356.1">)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.357.1">In </span><em class="italic"><span class="koboSpan" id="kobo.358.1">Figure 6.7</span></em><span class="koboSpan" id="kobo.359.1">, we show </span><a id="_idIndexMarker258"/><span class="koboSpan" id="kobo.360.1">the distribution of the locations where the bee images were taken. </span><span class="koboSpan" id="kobo.360.2">Most of the images are from Saratoga, CA (2000 images), followed by Athens, GA, and Des Moines, IA.</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.361.1"><img alt="" role="presentation" src="../Images/B20963_06_07.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.362.1">Figure 6.7: Location distribution</span></p>
<p class="normal"><span class="koboSpan" id="kobo.363.1">We also build a function for the visualization of subsets of images, based on a selected criterion. </span><span class="koboSpan" id="kobo.363.2">The following code is to select images based on location and display a subset of them (five images </span><a id="_idIndexMarker259"/><span class="koboSpan" id="kobo.364.1">in a row, from the same location):</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.365.1">#list of locations</span></span><span class="koboSpan" id="kobo.366.1">
locations = (honey_bee_df.groupby([</span><span class="hljs-string"><span class="koboSpan" id="kobo.367.1">'location'</span></span><span class="koboSpan" id="kobo.368.1">])[</span><span class="hljs-string"><span class="koboSpan" id="kobo.369.1">'location'</span></span><span class="koboSpan" id="kobo.370.1">].nunique()).index
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.371.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.372.1">draw_category_images</span></span><span class="koboSpan" id="kobo.373.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.374.1">var,cols=</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.375.1">5</span></span><span class="koboSpan" id="kobo.376.1">):
    categories = (honey_bee_df.groupby([var])[var].nunique()).index
    f, ax = plt.subplots(nrows=</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.377.1">len</span></span><span class="koboSpan" id="kobo.378.1">(categories),ncols=cols, figsize=(</span><span class="hljs-number"><span class="koboSpan" id="kobo.379.1">2</span></span><span class="koboSpan" id="kobo.380.1">*cols,</span><span class="hljs-number"><span class="koboSpan" id="kobo.381.1">2</span></span><span class="koboSpan" id="kobo.382.1">*</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.383.1">len</span></span><span class="koboSpan" id="kobo.384.1">(categories)))
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.385.1"># draw a number of images for each location</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.386.1">for</span></span><span class="koboSpan" id="kobo.387.1"> i, cat </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.388.1">in</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.389.1">enumerate</span></span><span class="koboSpan" id="kobo.390.1">(categories):
        sample = honey_bee_df[honey_bee_df[var]==cat].sample(cols)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.391.1">for</span></span><span class="koboSpan" id="kobo.392.1"> j </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.393.1">in</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.394.1">range</span></span><span class="koboSpan" id="kobo.395.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.396.1">0</span></span><span class="koboSpan" id="kobo.397.1">,cols):
            file=config[</span><span class="hljs-string"><span class="koboSpan" id="kobo.398.1">'image_path'</span></span><span class="koboSpan" id="kobo.399.1">] + sample.iloc[j][</span><span class="hljs-string"><span class="koboSpan" id="kobo.400.1">'file'</span></span><span class="koboSpan" id="kobo.401.1">]
            im=imageio.imread(file)
            ax[i, j].imshow(im, resample=</span><span class="hljs-literal"><span class="koboSpan" id="kobo.402.1">True</span></span><span class="koboSpan" id="kobo.403.1">)
            ax[i, j].set_title(cat, fontsize=</span><span class="hljs-number"><span class="koboSpan" id="kobo.404.1">9</span></span><span class="koboSpan" id="kobo.405.1">)  
    plt.tight_layout()
    plt.show()
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.406.1">In </span><em class="italic"><span class="koboSpan" id="kobo.407.1">Figure 6.8</span></em><span class="koboSpan" id="kobo.408.1">, a fraction of this selection is shown (just for the first two locations). </span><span class="koboSpan" id="kobo.408.2">The full image can be seen in the associated notebook:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.409.1"><img alt="" role="presentation" src="../Images/B20963_06_08.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.410.1">Figure 6.8: Bee images from two locations (a selection from the full picture, obtained with the preceding code)</span></p>
<h2 class="heading-2" id="_idParaDest-80"><span class="koboSpan" id="kobo.411.1">Date and time</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.412.1">Let’s continue with</span><a id="_idIndexMarker260"/><span class="koboSpan" id="kobo.413.1"> the detailed analysis of the features in our dataset. </span><span class="koboSpan" id="kobo.413.2">We start now to analyze the </span><code class="inlineCode"><span class="koboSpan" id="kobo.414.1">date</span></code><span class="koboSpan" id="kobo.415.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.416.1">time</span></code><span class="koboSpan" id="kobo.417.1"> data. </span><span class="koboSpan" id="kobo.417.2">We will convert the </span><code class="inlineCode"><span class="koboSpan" id="kobo.418.1">date</span></code><span class="koboSpan" id="kobo.419.1"> to </span><code class="inlineCode"><span class="koboSpan" id="kobo.420.1">datetime</span></code><span class="koboSpan" id="kobo.421.1"> and extract the year, month, and day. </span><span class="koboSpan" id="kobo.421.2">We also convert </span><code class="inlineCode"><span class="koboSpan" id="kobo.422.1">time</span></code><span class="koboSpan" id="kobo.423.1"> and extract the hour and minute:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.424.1">honey_bee_df[</span><span class="hljs-string"><span class="koboSpan" id="kobo.425.1">'date_time'</span></span><span class="koboSpan" id="kobo.426.1">] = pd.to_datetime(honey_bee_df[</span><span class="hljs-string"><span class="koboSpan" id="kobo.427.1">'date'</span></span><span class="koboSpan" id="kobo.428.1">] + </span><span class="hljs-string"><span class="koboSpan" id="kobo.429.1">' '</span></span><span class="koboSpan" id="kobo.430.1"> + honey_bee_df[</span><span class="hljs-string"><span class="koboSpan" id="kobo.431.1">'time'</span></span><span class="koboSpan" id="kobo.432.1">])
honey_bee_df[</span><span class="hljs-string"><span class="koboSpan" id="kobo.433.1">"year"</span></span><span class="koboSpan" id="kobo.434.1">] = honey_bee_df[</span><span class="hljs-string"><span class="koboSpan" id="kobo.435.1">'date_time'</span></span><span class="koboSpan" id="kobo.436.1">].dt.year
honey_bee_df[</span><span class="hljs-string"><span class="koboSpan" id="kobo.437.1">"month"</span></span><span class="koboSpan" id="kobo.438.1">] = honey_bee_df[</span><span class="hljs-string"><span class="koboSpan" id="kobo.439.1">'date_time'</span></span><span class="koboSpan" id="kobo.440.1">].dt.month
honey_bee_df[</span><span class="hljs-string"><span class="koboSpan" id="kobo.441.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.442.1">day"</span></span><span class="koboSpan" id="kobo.443.1">] = honey_bee_df[</span><span class="hljs-string"><span class="koboSpan" id="kobo.444.1">'date_time'</span></span><span class="koboSpan" id="kobo.445.1">].dt.day
honey_bee_df[</span><span class="hljs-string"><span class="koboSpan" id="kobo.446.1">"hour"</span></span><span class="koboSpan" id="kobo.447.1">] = honey_bee_df[</span><span class="hljs-string"><span class="koboSpan" id="kobo.448.1">'date_time'</span></span><span class="koboSpan" id="kobo.449.1">].dt.hour
honey_bee_df[</span><span class="hljs-string"><span class="koboSpan" id="kobo.450.1">"minute"</span></span><span class="koboSpan" id="kobo.451.1">] = honey_bee_df[</span><span class="hljs-string"><span class="koboSpan" id="kobo.452.1">'date_time'</span></span><span class="koboSpan" id="kobo.453.1">].dt.minute
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.454.1">A visualization of the number of bee images per date and approximative hour and location is shown in </span><em class="italic"><span class="koboSpan" id="kobo.455.1">Figure 6.9</span></em><span class="koboSpan" id="kobo.456.1">. </span><span class="koboSpan" id="kobo.456.2">The code for this visualization starts by grouping the data by </span><code class="inlineCode"><span class="koboSpan" id="kobo.457.1">date_time</span></code><span class="koboSpan" id="kobo.458.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.459.1">hour</span></code><span class="koboSpan" id="kobo.460.1"> and calculating the number of images collected on each date and the time of day:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.461.1">tmp = honey_bee_df.groupby([</span><span class="hljs-string"><span class="koboSpan" id="kobo.462.1">'</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.463.1">date_time'</span></span><span class="koboSpan" id="kobo.464.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.465.1">'hour'</span></span><span class="koboSpan" id="kobo.466.1">])[</span><span class="hljs-string"><span class="koboSpan" id="kobo.467.1">'location'</span></span><span class="koboSpan" id="kobo.468.1">].value_counts()
df = pd.DataFrame(data={</span><span class="hljs-string"><span class="koboSpan" id="kobo.469.1">'Images'</span></span><span class="koboSpan" id="kobo.470.1">: tmp.values}, index=tmp.index).reset_index()
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.471.1">Then, we build the text displayed when we hover over one point displayed in the graph. </span><span class="koboSpan" id="kobo.471.2">This text will include the hour, location, and the number of images. </span><span class="koboSpan" id="kobo.471.3">We then add the hover texts as a new column in the new dataset:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.472.1">hover_text = []
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.473.1">for</span></span><span class="koboSpan" id="kobo.474.1"> index, row </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.475.1">in</span></span><span class="koboSpan" id="kobo.476.1"> df.iterrows():
    hover_text.append((</span><span class="hljs-string"><span class="koboSpan" id="kobo.477.1">'Date/time: {}&lt;br&gt;'</span></span><span class="koboSpan" id="kobo.478.1">+
                      </span><span class="hljs-string"><span class="koboSpan" id="kobo.479.1">'Hour: {}&lt;br&gt;'</span></span><span class="koboSpan" id="kobo.480.1">+
                      </span><span class="hljs-string"><span class="koboSpan" id="kobo.481.1">'Location: {}&lt;br&gt;'</span></span><span class="koboSpan" id="kobo.482.1">+
                      </span><span class="hljs-string"><span class="koboSpan" id="kobo.483.1">'</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.484.1">Images: {}'</span></span><span class="koboSpan" id="kobo.485.1">).</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.486.1">format</span></span><span class="koboSpan" id="kobo.487.1">(row[</span><span class="hljs-string"><span class="koboSpan" id="kobo.488.1">'date_time'</span></span><span class="koboSpan" id="kobo.489.1">],
                                            row[</span><span class="hljs-string"><span class="koboSpan" id="kobo.490.1">'hour'</span></span><span class="koboSpan" id="kobo.491.1">],
                                            row[</span><span class="hljs-string"><span class="koboSpan" id="kobo.492.1">'location'</span></span><span class="koboSpan" id="kobo.493.1">],
                                            row[</span><span class="hljs-string"><span class="koboSpan" id="kobo.494.1">'Images'</span></span><span class="koboSpan" id="kobo.495.1">]))
df[</span><span class="hljs-string"><span class="koboSpan" id="kobo.496.1">'hover_text'</span></span><span class="koboSpan" id="kobo.497.1">] = hover_text
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.498.1">Then, we represent, for each location, a scatter plot with the time and hour when pictures were</span><a id="_idIndexMarker261"/><span class="koboSpan" id="kobo.499.1"> collected. </span><span class="koboSpan" id="kobo.499.2">Each point’s size is proportional to the number of images taken in that location, at a certain time of day, and on a certain date:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.500.1">locations = (honey_bee_df.groupby([</span><span class="hljs-string"><span class="koboSpan" id="kobo.501.1">'location'</span></span><span class="koboSpan" id="kobo.502.1">])[</span><span class="hljs-string"><span class="koboSpan" id="kobo.503.1">'location'</span></span><span class="koboSpan" id="kobo.504.1">].nunique()).index
data = []
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.505.1">for</span></span><span class="koboSpan" id="kobo.506.1"> location </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.507.1">in</span></span><span class="koboSpan" id="kobo.508.1"> locations:
    dfL = df[df[</span><span class="hljs-string"><span class="koboSpan" id="kobo.509.1">'location'</span></span><span class="koboSpan" id="kobo.510.1">]==location]
    trace = go.Scatter(
        x = dfL[</span><span class="hljs-string"><span class="koboSpan" id="kobo.511.1">'date_time'</span></span><span class="koboSpan" id="kobo.512.1">],y = dfL[</span><span class="hljs-string"><span class="koboSpan" id="kobo.513.1">'hour'</span></span><span class="koboSpan" id="kobo.514.1">],
        name=location,
        marker=</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.515.1">dict</span></span><span class="koboSpan" id="kobo.516.1">(
            symbol=</span><span class="hljs-string"><span class="koboSpan" id="kobo.517.1">'circle'</span></span><span class="koboSpan" id="kobo.518.1">,
            sizemode=</span><span class="hljs-string"><span class="koboSpan" id="kobo.519.1">'area'</span></span><span class="koboSpan" id="kobo.520.1">,
            sizeref=</span><span class="hljs-number"><span class="koboSpan" id="kobo.521.1">0.2</span></span><span class="koboSpan" id="kobo.522.1">,
            size=dfL[</span><span class="hljs-string"><span class="koboSpan" id="kobo.523.1">'Images'</span></span><span class="koboSpan" id="kobo.524.1">],
            line=</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.525.1">dict</span></span><span class="koboSpan" id="kobo.526.1">(
                width=</span><span class="hljs-number"><span class="koboSpan" id="kobo.527.1">2</span></span><span class="koboSpan" id="kobo.528.1">
            ),),
        mode = </span><span class="hljs-string"><span class="koboSpan" id="kobo.529.1">"markers"</span></span><span class="koboSpan" id="kobo.530.1">,
        text=dfL[</span><span class="hljs-string"><span class="koboSpan" id="kobo.531.1">'hover_text'</span></span><span class="koboSpan" id="kobo.532.1">],
    )
    data.append(trace)
    
layout = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.533.1">dict</span></span><span class="koboSpan" id="kobo.534.1">(title = </span><span class="hljs-string"><span class="koboSpan" id="kobo.535.1">'Number of bees images per date, approx. </span><span class="koboSpan" id="kobo.535.2">hour and location'</span></span><span class="koboSpan" id="kobo.536.1">,
          xaxis = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.537.1">dict</span></span><span class="koboSpan" id="kobo.538.1">(title = </span><span class="hljs-string"><span class="koboSpan" id="kobo.539.1">'Date'</span></span><span class="koboSpan" id="kobo.540.1">, showticklabels=</span><span class="hljs-literal"><span class="koboSpan" id="kobo.541.1">True</span></span><span class="koboSpan" id="kobo.542.1">), 
          yaxis = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.543.1">dict</span></span><span class="koboSpan" id="kobo.544.1">(title = </span><span class="hljs-string"><span class="koboSpan" id="kobo.545.1">'</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.546.1">Hour'</span></span><span class="koboSpan" id="kobo.547.1">),
          hovermode = </span><span class="hljs-string"><span class="koboSpan" id="kobo.548.1">'closest'</span></span><span class="koboSpan" id="kobo.549.1">
         )
fig = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.550.1">dict</span></span><span class="koboSpan" id="kobo.551.1">(data = data, layout = layout)
iplot(fig, filename=</span><span class="hljs-string"><span class="koboSpan" id="kobo.552.1">'images-date_time'</span></span><span class="koboSpan" id="kobo.553.1">)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.554.1">In the next image, </span><em class="italic"><span class="koboSpan" id="kobo.555.1">Figure 6.9</span></em><span class="koboSpan" id="kobo.556.1">, we see the result of running the aforementioned code. </span><span class="koboSpan" id="kobo.556.2">Most pictures were</span><a id="_idIndexMarker262"/><span class="koboSpan" id="kobo.557.1"> taken around August. </span><span class="koboSpan" id="kobo.557.2">Most of the pictures were also taken in the afternoon hours.</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.558.1"><img alt="" role="presentation" src="../Images/B20963_06_09.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.559.1">Figure 6.9: Number of bee images per date and the approximate hour and location</span></p>
<h2 class="heading-2" id="_idParaDest-81"><span class="koboSpan" id="kobo.560.1">Subspecies</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.561.1">We use the </span><a id="_idIndexMarker263"/><span class="koboSpan" id="kobo.562.1">same </span><code class="inlineCode"><span class="koboSpan" id="kobo.563.1">plotly_barplot</span></code><span class="koboSpan" id="kobo.564.1"> function to visualize the distribution of subspecies. </span><span class="koboSpan" id="kobo.564.2">Most of the bees are Italian honey bees, followed by Russian honey bees and Carniolan honey bees (see </span><em class="italic"><span class="koboSpan" id="kobo.565.1">Figure 6.10</span></em><span class="koboSpan" id="kobo.566.1">). </span><span class="koboSpan" id="kobo.566.2">Some of the 428 images are not classified (with a label value of </span><strong class="screenText"><span class="koboSpan" id="kobo.567.1">-1</span></strong><span class="koboSpan" id="kobo.568.1">). </span><span class="koboSpan" id="kobo.568.2">We will keep the images not classified as one subspecies category.</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.569.1"><img alt="A picture containing text, screenshot, diagram, line  Description automatically generated" src="../Images/B20963_06_10.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.570.1">Figure 6.10: Number of bee images per date and the approximate hour and location</span></p>
<p class="normal"><span class="koboSpan" id="kobo.571.1">In </span><em class="italic"><span class="koboSpan" id="kobo.572.1">Figure 6.11</span></em><span class="koboSpan" id="kobo.573.1">, we </span><a id="_idIndexMarker264"/><span class="koboSpan" id="kobo.574.1">show a selection of images, with samples for just a few of the subspecies:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.575.1"><img alt="A collage of images of a bee  Description automatically generated" src="../Images/B20963_06_11.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.576.1">Figure 6.11: Samples of bee images from a few subspecies</span></p>
<p class="normal"><span class="koboSpan" id="kobo.577.1">Now, let’s represent the number of images per subspecies and location, as well as the number of images per subspecies and hour (see </span><em class="italic"><span class="koboSpan" id="kobo.578.1">Figure 6.12</span></em><span class="koboSpan" id="kobo.579.1">). </span><span class="koboSpan" id="kobo.579.2">The largest number of images were collected from Saratoga, CA, and all were Italian honey bees (1972 images). </span><span class="koboSpan" id="kobo.579.3">The largest number </span><a id="_idIndexMarker265"/><span class="koboSpan" id="kobo.580.1">of images were collected at hour 13, and all were of Italian honey bees (909 images).</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.581.1"><img alt="" role="presentation" src="../Images/B20963_06_12.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.582.1">Figure 6.12: Number of images per subspecies and location (upper) and the number of images per subspecies and hour (lower)</span></p>
<p class="normal"><span class="koboSpan" id="kobo.583.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.584.1">Subspecies</span></code><span class="koboSpan" id="kobo.585.1"> images </span><a id="_idIndexMarker266"/><span class="koboSpan" id="kobo.586.1">have a large variety of weights and heights. </span><em class="italic"><span class="koboSpan" id="kobo.587.1">Figure 6.13</span></em><span class="koboSpan" id="kobo.588.1"> shows this distribution, using a boxplot, for the weight and the height.</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.589.1"><img alt="" role="presentation" src="../Images/B20963_06_13.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.590.1">Figure 6.13: Image size distribution per each subspecies – width (upper) and height (lower)</span></p>
<p class="normal"><strong class="screenText"><span class="koboSpan" id="kobo.591.1">VSH Italian honey bee</span></strong><span class="koboSpan" id="kobo.592.1"> has the largest average and also the largest variance for both width and height. </span><strong class="screenText"><span class="koboSpan" id="kobo.593.1">Western honey bee</span></strong><span class="koboSpan" id="kobo.594.1">, </span><strong class="screenText"><span class="koboSpan" id="kobo.595.1">Carniolan honey be</span></strong><em class="italic"><span class="koboSpan" id="kobo.596.1">e</span></em><span class="koboSpan" id="kobo.597.1">, and </span><strong class="screenText"><span class="koboSpan" id="kobo.598.1">Mixed local stock 2</span></strong><span class="koboSpan" id="kobo.599.1"> have the most compact distribution of weight and height (and lower variance). </span><span class="koboSpan" id="kobo.599.2">The </span><em class="italic"><span class="koboSpan" id="kobo.600.1">Italian honey bee</span></em><span class="koboSpan" id="kobo.601.1">, the most numerous subspecies, shows both a small median and a large variance, with a lot of outliers. </span><span class="koboSpan" id="kobo.601.2">In the next figure, we show the weight and the height distribution</span><a id="_idIndexMarker267"/><span class="koboSpan" id="kobo.602.1"> combined on the same scatter plot:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.603.1"><img alt="" role="presentation" src="../Images/B20963_06_14.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.604.1">Figure 6.14: Image size distribution per each subspecies – scatter plot</span></p>
<p class="normal"><span class="koboSpan" id="kobo.605.1">The preceding figure shows this distribution, using a scatter plot, for the weight and the height. </span><span class="koboSpan" id="kobo.605.2">The code for this visualization is shown in the following. </span><span class="koboSpan" id="kobo.605.3">First, we start by defining a function to draw a scatter plot, with the image width on the </span><code class="inlineCode"><span class="koboSpan" id="kobo.606.1">x</span></code><span class="koboSpan" id="kobo.607.1"> scale and the image height on the </span><code class="inlineCode"><span class="koboSpan" id="kobo.608.1">y</span></code><span class="koboSpan" id="kobo.609.1"> scale:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.610.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.611.1">draw_trace_scatter</span></span><span class="koboSpan" id="kobo.612.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.613.1">dataset, subspecies</span></span><span class="koboSpan" id="kobo.614.1">):
    dfS = dataset[dataset[</span><span class="hljs-string"><span class="koboSpan" id="kobo.615.1">'subspecies'</span></span><span class="koboSpan" id="kobo.616.1">]==subspecies];
    trace = go.Scatter(
        x = dfS[</span><span class="hljs-string"><span class="koboSpan" id="kobo.617.1">'w'</span></span><span class="koboSpan" id="kobo.618.1">],y = dfS[</span><span class="hljs-string"><span class="koboSpan" id="kobo.619.1">'h'</span></span><span class="koboSpan" id="kobo.620.1">],
        name=subspecies,
        mode = </span><span class="hljs-string"><span class="koboSpan" id="kobo.621.1">"markers"</span></span><span class="koboSpan" id="kobo.622.1">,
        marker = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.623.1">dict</span></span><span class="koboSpan" id="kobo.624.1">(opacity=</span><span class="hljs-number"><span class="koboSpan" id="kobo.625.1">0.8</span></span><span class="koboSpan" id="kobo.626.1">),
        text=dfS[</span><span class="hljs-string"><span class="koboSpan" id="kobo.627.1">'subspecies'</span></span><span class="koboSpan" id="kobo.628.1">], 
    )
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.629.1">return</span></span><span class="koboSpan" id="kobo.630.1"> trace
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.631.1">We now use the function defined above to draw the scatter plot for each subspecies. </span><span class="koboSpan" id="kobo.631.2">Each function call will</span><a id="_idIndexMarker268"/><span class="koboSpan" id="kobo.632.1"> create a trace, and we add the traces to the Plotly plot:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.633.1">subspecies = (honey_bee_df.groupby([</span><span class="hljs-string"><span class="koboSpan" id="kobo.634.1">'subspecies'</span></span><span class="koboSpan" id="kobo.635.1">])[</span><span class="hljs-string"><span class="koboSpan" id="kobo.636.1">'subspecies'</span></span><span class="koboSpan" id="kobo.637.1">].nunique()).index
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.638.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.639.1">draw_group</span></span><span class="koboSpan" id="kobo.640.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.641.1">dataset, title,height=</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.642.1">600</span></span><span class="koboSpan" id="kobo.643.1">):
    data = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.644.1">list</span></span><span class="koboSpan" id="kobo.645.1">()
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.646.1">for</span></span><span class="koboSpan" id="kobo.647.1"> subs </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.648.1">in</span></span><span class="koboSpan" id="kobo.649.1"> subspecies:
        data.append(draw_trace_scatter(dataset, subs))
        
    layout = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.650.1">dict</span></span><span class="koboSpan" id="kobo.651.1">(title = title,
              xaxis = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.652.1">dict</span></span><span class="koboSpan" id="kobo.653.1">(title = </span><span class="hljs-string"><span class="koboSpan" id="kobo.654.1">'Width'</span></span><span class="koboSpan" id="kobo.655.1">,showticklabels=</span><span class="hljs-literal"><span class="koboSpan" id="kobo.656.1">True</span></span><span class="koboSpan" id="kobo.657.1">),
              yaxis = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.658.1">dict</span></span><span class="koboSpan" id="kobo.659.1">(title = </span><span class="hljs-string"><span class="koboSpan" id="kobo.660.1">'Height'</span></span><span class="koboSpan" id="kobo.661.1">, showticklabels=</span><span class="hljs-literal"><span class="koboSpan" id="kobo.662.1">True</span></span><span class="koboSpan" id="kobo.663.1">, tickfont=</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.664.1">dict</span></span><span class="koboSpan" id="kobo.665.1">(
                family=</span><span class="hljs-string"><span class="koboSpan" id="kobo.666.1">'Old Standard TT, serif'</span></span><span class="koboSpan" id="kobo.667.1">,
                size=</span><span class="hljs-number"><span class="koboSpan" id="kobo.668.1">8</span></span><span class="koboSpan" id="kobo.669.1">,
                color=</span><span class="hljs-string"><span class="koboSpan" id="kobo.670.1">'black'</span></span><span class="koboSpan" id="kobo.671.1">),), 
              hovermode = </span><span class="hljs-string"><span class="koboSpan" id="kobo.672.1">'</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.673.1">closest'</span></span><span class="koboSpan" id="kobo.674.1">,
              showlegend=</span><span class="hljs-literal"><span class="koboSpan" id="kobo.675.1">True</span></span><span class="koboSpan" id="kobo.676.1">,
                  width=</span><span class="hljs-number"><span class="koboSpan" id="kobo.677.1">800</span></span><span class="koboSpan" id="kobo.678.1">,
                  height=height,
             )
    fig = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.679.1">dict</span></span><span class="koboSpan" id="kobo.680.1">(data=data, layout=layout)
    iplot(fig, filename=</span><span class="hljs-string"><span class="koboSpan" id="kobo.681.1">'subspecies-image'</span></span><span class="koboSpan" id="kobo.682.1">)
draw_group(honey_bee_df,  </span><span class="hljs-string"><span class="koboSpan" id="kobo.683.1">"Width and height of images per subspecies"</span></span><span class="koboSpan" id="kobo.684.1">)
</span></code></pre>
<h2 class="heading-2" id="_idParaDest-82"><span class="koboSpan" id="kobo.685.1">Health</span></h2>
<p class="normal"><em class="italic"><span class="koboSpan" id="kobo.686.1">Figure 6.15</span></em><span class="koboSpan" id="kobo.687.1"> shows the </span><a id="_idIndexMarker269"/><span class="koboSpan" id="kobo.688.1">distribution of images with various health problems. </span><span class="koboSpan" id="kobo.688.2">The majority of images are for </span><strong class="screenText"><span class="koboSpan" id="kobo.689.1">healthy</span></strong><span class="koboSpan" id="kobo.690.1"> bees (3384), followed by </span><strong class="screenText"><span class="koboSpan" id="kobo.691.1">few varrao, hive beetles</span></strong><span class="koboSpan" id="kobo.692.1"> (579), </span><strong class="screenText"><span class="koboSpan" id="kobo.693.1">Varroa, Small Hive Beetles</span></strong><span class="koboSpan" id="kobo.694.1"> (472), and </span><strong class="screenText"><span class="koboSpan" id="kobo.695.1">ant problems</span></strong><span class="koboSpan" id="kobo.696.1"> (457):</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.697.1"><img alt="A picture containing text, screenshot, diagram, line  Description automatically generated" src="../Images/B20963_06_15.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.698.1">Figure 6.15: Number of images with different health problems</span></p>
<p class="normal"><span class="koboSpan" id="kobo.699.1">If we analyze the</span><a id="_idIndexMarker270"/><span class="koboSpan" id="kobo.700.1"> number of images per subspecies and health (see </span><em class="italic"><span class="koboSpan" id="kobo.701.1">Figure 6.16</span></em><span class="koboSpan" id="kobo.702.1">), we can observe that only a reduced number of combinations of health and subspecies values are present. </span><span class="koboSpan" id="kobo.702.2">Most images are </span><strong class="screenText"><span class="koboSpan" id="kobo.703.1">healthy</span></strong> <strong class="screenText"><span class="koboSpan" id="kobo.704.1">Italian honey bee</span></strong><span class="koboSpan" id="kobo.705.1"> (1972), followed by </span><strong class="screenText"><span class="koboSpan" id="kobo.706.1">few varroa, hive beetles</span></strong><span class="koboSpan" id="kobo.707.1">, then </span><strong class="screenText"><span class="koboSpan" id="kobo.708.1">Italian honey bee</span></strong><span class="koboSpan" id="kobo.709.1"> (579), and lastly, </span><strong class="screenText"><span class="koboSpan" id="kobo.710.1">healthy</span></strong> <strong class="screenText"><span class="koboSpan" id="kobo.711.1">Russian honey bee</span></strong><span class="koboSpan" id="kobo.712.1"> (527). </span><span class="koboSpan" id="kobo.712.2">The unknown subspecies are either </span><strong class="screenText"><span class="koboSpan" id="kobo.713.1">healthy</span></strong><span class="koboSpan" id="kobo.714.1"> (177) or </span><strong class="screenText"><span class="koboSpan" id="kobo.715.1">hive being robbed</span></strong><span class="koboSpan" id="kobo.716.1"> (251).</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.717.1"><img alt="A screenshot of a computer screen  Description automatically generated with low confidence" src="../Images/B20963_06_16.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.718.1">Figure 6.16: Number of images per subspecies and bees with different health problems</span></p>
<p class="normal"><span class="koboSpan" id="kobo.719.1">In </span><em class="italic"><span class="koboSpan" id="kobo.720.1">Figure 6.17</span></em><span class="koboSpan" id="kobo.721.1">, we</span><a id="_idIndexMarker271"/><span class="koboSpan" id="kobo.722.1"> plot the number of images per location, subspecies, and health problems:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.723.1"><img alt="A screenshot of a graph  Description automatically generated with low confidence" src="../Images/B20963_06_17.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.724.1">Figure 6.17: Number of images per location, subspecies, and health problems</span></p>
<h2 class="heading-2" id="_idParaDest-83"><span class="koboSpan" id="kobo.725.1">Others</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.726.1">There is a small </span><a id="_idIndexMarker272"/><span class="koboSpan" id="kobo.727.1">number of images with bees carrying pollen. </span><em class="italic"><span class="koboSpan" id="kobo.728.1">Figure 6.18</span></em><span class="koboSpan" id="kobo.729.1"> shows a few images of bees carrying pollen and some not carrying pollen. </span><span class="koboSpan" id="kobo.729.2">All the bees are from only one caste: the worker caste.</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.730.1"><img alt="A picture containing collage, screenshot, text  Description automatically generated" src="../Images/B20963_06_18.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.731.1">Figure 6.18: Selection of images with bees carrying pollen and not carrying pollen</span></p>
<h2 class="heading-2" id="_idParaDest-84"><span class="koboSpan" id="kobo.732.1">Conclusion</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.733.1">We use a Sankey</span><a id="_idIndexMarker273"/><span class="koboSpan" id="kobo.734.1"> diagram, drawn with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.735.1">plotly_sankey</span></code><span class="koboSpan" id="kobo.736.1"> script from the </span><code class="inlineCode"><span class="koboSpan" id="kobo.737.1">plotly_utils</span></code><span class="koboSpan" id="kobo.738.1"> utility script module, to draw the summary graph in </span><em class="italic"><span class="koboSpan" id="kobo.739.1">Figure 6.19</span></em><span class="koboSpan" id="kobo.740.1">. </span><span class="koboSpan" id="kobo.740.2">A Sankey diagram is used mainly to visualize processes or flows, for example, the production of energy, with its sources and consumers, in an economy. </span><span class="koboSpan" id="kobo.740.3">I use it here with another purpose, to summarize the distribution of data with multiple features. </span><span class="koboSpan" id="kobo.740.4">It shows on the same plot the distribution of images per date, time, location, ZIP code, subspecies, and health. </span><span class="koboSpan" id="kobo.740.5">The adaptation code for the Sankey diagram is not given here for limited space reasons (refer </span><em class="italic"><span class="koboSpan" id="kobo.741.1">Reference 2</span></em><span class="koboSpan" id="kobo.742.1"> for the code samples associated with the chapter); we just include the code to adapt the honey bee data for the use of this function:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.743.1">tmp = honey_bee_df.groupby([</span><span class="hljs-string"><span class="koboSpan" id="kobo.744.1">'</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.745.1">location'</span></span><span class="koboSpan" id="kobo.746.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.747.1">'zip code'</span></span><span class="koboSpan" id="kobo.748.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.749.1">'date'</span></span><span class="koboSpan" id="kobo.750.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.751.1">'time'</span></span><span class="koboSpan" id="kobo.752.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.753.1">'health'</span></span><span class="koboSpan" id="kobo.754.1">])[</span><span class="hljs-string"><span class="koboSpan" id="kobo.755.1">'subspecies'</span></span><span class="koboSpan" id="kobo.756.1">].value_counts()
df = pd.DataFrame(data={</span><span class="hljs-string"><span class="koboSpan" id="kobo.757.1">'Images'</span></span><span class="koboSpan" id="kobo.758.1">: tmp.values}, index=tmp.index).reset_index()
fig = plotly_sankey(df,cat_cols=[</span><span class="hljs-string"><span class="koboSpan" id="kobo.759.1">'date'</span></span><span class="koboSpan" id="kobo.760.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.761.1">'time'</span></span><span class="koboSpan" id="kobo.762.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.763.1">'location'</span></span><span class="koboSpan" id="kobo.764.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.765.1">'</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.766.1">zip code'</span></span><span class="koboSpan" id="kobo.767.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.768.1">'subspecies'</span></span><span class="koboSpan" id="kobo.769.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.770.1">'health'</span></span><span class="koboSpan" id="kobo.771.1">],value_cols=</span><span class="hljs-string"><span class="koboSpan" id="kobo.772.1">'Images'</span></span><span class="koboSpan" id="kobo.773.1">,
                    title=</span><span class="hljs-string"><span class="koboSpan" id="kobo.774.1">'Honeybee Images: date | time | location | zip code | subspecies | health'</span></span><span class="koboSpan" id="kobo.775.1">, 
                 color_palette=[ </span><span class="hljs-string"><span class="koboSpan" id="kobo.776.1">"darkgreen"</span></span><span class="koboSpan" id="kobo.777.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.778.1">"lightgreen"</span></span><span class="koboSpan" id="kobo.779.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.780.1">"green"</span></span><span class="koboSpan" id="kobo.781.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.782.1">"gold"</span></span><span class="koboSpan" id="kobo.783.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.784.1">"black"</span></span><span class="koboSpan" id="kobo.785.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.786.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.787.1">yellow"</span></span><span class="koboSpan" id="kobo.788.1">],
           height=</span><span class="hljs-number"><span class="koboSpan" id="kobo.789.1">800</span></span><span class="koboSpan" id="kobo.790.1">)
iplot(fig, filename=</span><span class="hljs-string"><span class="koboSpan" id="kobo.791.1">'Honeybee Images'</span></span><span class="koboSpan" id="kobo.792.1">)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.793.1">The visualization in </span><em class="italic"><span class="koboSpan" id="kobo.794.1">Figure 6.19</span></em><span class="koboSpan" id="kobo.795.1">, a funnel-like graph, allows us to capture in one single graph the relationship between multiple features:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.796.1"><img alt="A screenshot of a computer  Description automatically generated with low confidence" src="../Images/B20963_06_19.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.797.1">Figure 6.19: Summary of images</span></p>
<p class="normal"><span class="koboSpan" id="kobo.798.1">Until now, we </span><a id="_idIndexMarker274"/><span class="koboSpan" id="kobo.799.1">analyzed the distribution of features in the dataset. </span><span class="koboSpan" id="kobo.799.2">Now, we have a better understanding of the data in the dataset. </span><span class="koboSpan" id="kobo.799.3">In the following section of this chapter, we will start preparation to build a machine learning model to classify images on subspecies, which is the second and more important objective of this chapter.</span></p>
<h1 class="heading-1" id="_idParaDest-85"><span class="koboSpan" id="kobo.800.1">Subspecies classification</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.801.1">The objective of</span><a id="_idIndexMarker275"/><span class="koboSpan" id="kobo.802.1"> this section will be to use the images investigated until now to build a machine learning model that will correctly predict the subspecies. </span><span class="koboSpan" id="kobo.802.2">Since we have one dataset only, we will start by splitting the data into three subsets: for train, validation, and test data. </span><span class="koboSpan" id="kobo.802.3">We will use train and validation during the training process: the train data to feed the model and the validation data to verify how well the model predicts the class (i.e., the subspecies) with the new data. </span><span class="koboSpan" id="kobo.802.4">Then, the model trained and </span><a id="_idIndexMarker276"/><span class="koboSpan" id="kobo.803.1">validated will be used to predict the class in the test set, which was not used either in train or validation.</span></p>
<h2 class="heading-2" id="_idParaDest-86"><span class="koboSpan" id="kobo.804.1">Splitting the data</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.805.1">First, we split the data into </span><code class="inlineCode"><span class="koboSpan" id="kobo.806.1">train</span></code><span class="koboSpan" id="kobo.807.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.808.1">test</span></code><span class="koboSpan" id="kobo.809.1">, using an 80%–20% split. </span><span class="koboSpan" id="kobo.809.2">Then, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.810.1">train</span></code><span class="koboSpan" id="kobo.811.1"> data is split again, in to train and validation, using the same 80%–20% split. </span><span class="koboSpan" id="kobo.811.2">The splits are performed using </span><code class="inlineCode"><span class="koboSpan" id="kobo.812.1">stratify</span></code><span class="koboSpan" id="kobo.813.1"> with </span><code class="inlineCode"><span class="koboSpan" id="kobo.814.1">subspecies</span></code><span class="koboSpan" id="kobo.815.1"> as a parameter, ensuring balanced subsets that respect the overall distribution of classes in the subsampled sets of train, validation, and test. </span><span class="koboSpan" id="kobo.815.2">The percent values for train/validation/test splits are chosen arbitrarily here and are not the result of a study or optimization. </span><span class="koboSpan" id="kobo.815.3">In your experiments, you can work with different values for train/validation/test subsets, and you can also choose to not use </span><code class="inlineCode"><span class="koboSpan" id="kobo.816.1">stratify</span></code><span class="koboSpan" id="kobo.817.1">: </span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.818.1">train_df, test_df = train_test_split(honey_bee_df, test_size=config[</span><span class="hljs-string"><span class="koboSpan" id="kobo.819.1">'test_size'</span></span><span class="koboSpan" id="kobo.820.1">], random_state=config[</span><span class="hljs-string"><span class="koboSpan" id="kobo.821.1">'random_state'</span></span><span class="koboSpan" id="kobo.822.1">], 
             stratify=honey_bee_df[</span><span class="hljs-string"><span class="koboSpan" id="kobo.823.1">'subspecies'</span></span><span class="koboSpan" id="kobo.824.1">])
train_df, val_df = train_test_split(train_df, test_size=config[</span><span class="hljs-string"><span class="koboSpan" id="kobo.825.1">'val_size'</span></span><span class="koboSpan" id="kobo.826.1">], random_state=config[</span><span class="hljs-string"><span class="koboSpan" id="kobo.827.1">'random_state'</span></span><span class="koboSpan" id="kobo.828.1">], 
             stratify=train_df[</span><span class="hljs-string"><span class="koboSpan" id="kobo.829.1">'subspecies'</span></span><span class="koboSpan" id="kobo.830.1">])
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.831.1">Ultimately, we will have three subsets, as follows:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.832.1">Train set rows: 3309</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.833.1">Validation set rows: 828</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.834.1">Test set rows: 1035</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.835.1">We will split the images into subsets, corresponding to the image names’ subsets. </span><span class="koboSpan" id="kobo.835.2">We create functions to read images and rescale them all to the same dimension, as specified in the configuration structure we defined, using </span><code class="inlineCode"><span class="koboSpan" id="kobo.836.1">skimage.io</span></code><span class="koboSpan" id="kobo.837.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.838.1">opencv</span></code><span class="koboSpan" id="kobo.839.1">. </span><span class="koboSpan" id="kobo.839.2">We decided to rescale all images to 100 x 100 pixels. </span><span class="koboSpan" id="kobo.839.3">Our decision was based on the analysis of the images’ size distribution. </span><span class="koboSpan" id="kobo.839.4">You can choose to modify the code in the notebook given at </span><em class="italic"><span class="koboSpan" id="kobo.840.1">Reference 3 </span></em><span class="koboSpan" id="kobo.841.1">and experiment with different image sizes.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.842.1">The following code reads an image (using </span><code class="inlineCode"><span class="koboSpan" id="kobo.843.1">skimage.io</span></code><span class="koboSpan" id="kobo.844.1">) and resizes it according to the size set in the configuration. </span><span class="koboSpan" id="kobo.844.2">You can change the configuration and resize the image, using different values for the image height and width:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.845.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.846.1">read_image</span></span><span class="koboSpan" id="kobo.847.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.848.1">file_name</span></span><span class="koboSpan" id="kobo.849.1">):
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.850.1">"""</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.851.1">    Read and resize the image to image_width x image_height</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.852.1">    Args:</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.853.1">        file_name: file name for current image</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.854.1">    Returns:</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.855.1">        resized image</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.856.1">    """</span></span><span class="koboSpan" id="kobo.857.1">
    image = skimage.io.imread(config[</span><span class="hljs-string"><span class="koboSpan" id="kobo.858.1">'image_path'</span></span><span class="koboSpan" id="kobo.859.1">] + file_name)
    image = skimage.transform.resize(image, (config[</span><span class="hljs-string"><span class="koboSpan" id="kobo.860.1">'image_width'</span></span><span class="koboSpan" id="kobo.861.1">], config[</span><span class="hljs-string"><span class="koboSpan" id="kobo.862.1">'</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.863.1">image_height'</span></span><span class="koboSpan" id="kobo.864.1">]), mode=</span><span class="hljs-string"><span class="koboSpan" id="kobo.865.1">'reflect'</span></span><span class="koboSpan" id="kobo.866.1">)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.867.1">return</span></span><span class="koboSpan" id="kobo.868.1"> image[:,:,:config[</span><span class="hljs-string"><span class="koboSpan" id="kobo.869.1">'image_channels'</span></span><span class="koboSpan" id="kobo.870.1">]]
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.871.1">The code below reads and resizes an image using opencv. </span><span class="koboSpan" id="kobo.871.2">The function differs from the previous one shown above just by the method to read the image file:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.872.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.873.1">read_image_cv</span></span><span class="koboSpan" id="kobo.874.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.875.1">file_name</span></span><span class="koboSpan" id="kobo.876.1">):
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.877.1">"""</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.878.1">    Read and resize the image to image_width x image_height</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.879.1">    Args:</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.880.1">        file_name: file name for current image</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.881.1">    Returns:</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.882.1">        resized image</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.883.1">    """</span></span><span class="koboSpan" id="kobo.884.1">
    image = cv2.imread(config[</span><span class="hljs-string"><span class="koboSpan" id="kobo.885.1">'image_path'</span></span><span class="koboSpan" id="kobo.886.1">] + file_name)
    image = cv2.resize(image, (config[</span><span class="hljs-string"><span class="koboSpan" id="kobo.887.1">'image_width'</span></span><span class="koboSpan" id="kobo.888.1">], config[</span><span class="hljs-string"><span class="koboSpan" id="kobo.889.1">'image_height'</span></span><span class="koboSpan" id="kobo.890.1">]))
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.891.1">return</span></span><span class="koboSpan" id="kobo.892.1"> image[:,:,:config[</span><span class="hljs-string"><span class="koboSpan" id="kobo.893.1">'image_channels'</span></span><span class="koboSpan" id="kobo.894.1">]]
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.895.1">We then apply one of </span><a id="_idIndexMarker277"/><span class="koboSpan" id="kobo.896.1">these functions to all dataset files to read and rescale the images in the dataset.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.897.1">We also create dummy variables corresponding to the categorical target variables. </span><span class="koboSpan" id="kobo.897.2">We prefer to use this approach because we will prepare a model for multiclass classification that outputs probabilities per class:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.898.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.899.1">categories_encoder</span></span><span class="koboSpan" id="kobo.900.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.901.1">dataset, var=</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.902.1">'subspecies'</span></span><span class="koboSpan" id="kobo.903.1">):
    X = np.stack(dataset[</span><span class="hljs-string"><span class="koboSpan" id="kobo.904.1">'file'</span></span><span class="koboSpan" id="kobo.905.1">].apply(read_image))
    y = pd.get_dummies(dataset[var], drop_first=</span><span class="hljs-literal"><span class="koboSpan" id="kobo.906.1">False</span></span><span class="koboSpan" id="kobo.907.1">)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.908.1">return</span></span><span class="koboSpan" id="kobo.909.1"> X, y
s_time = time.time()
X_train, y_train = categories_encoder(train_df)
X_val, y_val = categories_encoder(val_df)
X_test, y_test = categories_encoder(test_df)
e_time = time.time()
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.910.1">print</span></span><span class="koboSpan" id="kobo.911.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.912.1">f"Total time: </span></span><span class="hljs-subst"><span class="koboSpan" id="kobo.913.1">{</span></span><span class="hljs-built_in"><span class="koboSpan" id="kobo.914.1">round</span></span><span class="hljs-subst"><span class="koboSpan" id="kobo.915.1">(e_time-s_time, </span></span><span class="hljs-number"><span class="koboSpan" id="kobo.916.1">2</span></span><span class="hljs-subst"><span class="koboSpan" id="kobo.917.1">)}</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.918.1"> sec."</span></span><span class="koboSpan" id="kobo.919.1">)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.920.1">With that, we’ve shown how to read and rescale our images. </span><span class="koboSpan" id="kobo.920.2">Next, we will see how we can multiply our images</span><a id="_idIndexMarker278"/><span class="koboSpan" id="kobo.921.1"> to have more data in the train set so that we present to the model a larger variety of data.</span></p>
<h2 class="heading-2" id="_idParaDest-87"><span class="koboSpan" id="kobo.922.1">Data augmentation</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.923.1">We will use a deep </span><a id="_idIndexMarker279"/><span class="koboSpan" id="kobo.924.1">learning model to classify the subspecies in our images. </span><span class="koboSpan" id="kobo.924.2">Typically, deep learning models perform better when trained with a larger amount of data. </span><span class="koboSpan" id="kobo.924.3">Using data augmentation, we also create a larger variety in the data, which is also beneficial for the model quality. </span><span class="koboSpan" id="kobo.924.4">Our model will improve its generalization if we expose it to more diverse data during training.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.925.1">We define a component for data augmentation, based on </span><code class="inlineCode"><span class="koboSpan" id="kobo.926.1">ImageDataGenerator</span></code><span class="koboSpan" id="kobo.927.1"> from </span><code class="inlineCode"><span class="koboSpan" id="kobo.928.1">keras.preprocessing.image</span></code><span class="koboSpan" id="kobo.929.1">. </span><span class="koboSpan" id="kobo.929.2">In this notebook, we will use Keras to build various components of the model. </span><span class="koboSpan" id="kobo.929.3">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.930.1">ImageDataGenerator</span></code><span class="koboSpan" id="kobo.931.1"> component is initialized with various parameters to create random variations of the training dataset, by applying:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.932.1">a rotation (in a range of 0 to 180 degrees) of the original images</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.933.1">a zoom (10%)</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.934.1">a shift in horizontal and vertical directions (10%)</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.935.1">a horizontal and vertical shift (10%)</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.936.1">These variations can be controlled separately. </span><span class="koboSpan" id="kobo.936.2">Not all use cases will allow, or benefit from applying, all the transformations listed above (think about, for example, images with buildings or other landmarks, for which rotations do not make too much sense). </span><span class="koboSpan" id="kobo.936.3">The following code can be used in our case to initialize and fit the image generator:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.937.1">image_generator = ImageDataGenerator(
        featurewise_center=</span><span class="hljs-literal"><span class="koboSpan" id="kobo.938.1">False</span></span><span class="koboSpan" id="kobo.939.1">,
        samplewise_center=</span><span class="hljs-literal"><span class="koboSpan" id="kobo.940.1">False</span></span><span class="koboSpan" id="kobo.941.1">,
        featurewise_std_normalization=</span><span class="hljs-literal"><span class="koboSpan" id="kobo.942.1">False</span></span><span class="koboSpan" id="kobo.943.1">,
        samplewise_std_normalization=</span><span class="hljs-literal"><span class="koboSpan" id="kobo.944.1">False</span></span><span class="koboSpan" id="kobo.945.1">,
        zca_whitening=</span><span class="hljs-literal"><span class="koboSpan" id="kobo.946.1">False</span></span><span class="koboSpan" id="kobo.947.1">,
        rotation_range=</span><span class="hljs-number"><span class="koboSpan" id="kobo.948.1">180</span></span><span class="koboSpan" id="kobo.949.1">,
        zoom_range = </span><span class="hljs-number"><span class="koboSpan" id="kobo.950.1">0.1</span></span><span class="koboSpan" id="kobo.951.1">, 
        width_shift_range=</span><span class="hljs-number"><span class="koboSpan" id="kobo.952.1">0.1</span></span><span class="koboSpan" id="kobo.953.1">,
        height_shift_range=</span><span class="hljs-number"><span class="koboSpan" id="kobo.954.1">0.1</span></span><span class="koboSpan" id="kobo.955.1">, 
        horizontal_flip=</span><span class="hljs-literal"><span class="koboSpan" id="kobo.956.1">True</span></span><span class="koboSpan" id="kobo.957.1">,
        vertical_flip=</span><span class="hljs-literal"><span class="koboSpan" id="kobo.958.1">True</span></span><span class="koboSpan" id="kobo.959.1">)
image_generator.fit(X_train)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.960.1">We then move on</span><a id="_idIndexMarker280"/><span class="koboSpan" id="kobo.961.1"> to building and training a baseline model.</span></p>
<h2 class="heading-2" id="_idParaDest-88"><span class="koboSpan" id="kobo.962.1">Building a baseline model</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.963.1">It is almost always recommended to start your work with a simple model and then conduct an </span><a id="_idIndexMarker281"/><span class="koboSpan" id="kobo.964.1">error analysis. </span><span class="koboSpan" id="kobo.964.2">Based on the error analysis, you will have to further refine your model. </span><span class="koboSpan" id="kobo.964.3">If, for example, you observe that you obtained, with your baseline model, a large error for training, you need to start by improving the training. </span><span class="koboSpan" id="kobo.964.4">You can do this by perhaps adding more data, improving your data labeling, or creating better features. </span><span class="koboSpan" id="kobo.964.5">If your training error is small but you have instead a high validation error, it means that your model probably overfits on the training data. </span><span class="koboSpan" id="kobo.964.6">In such a case, you need to try to improve your model generalization. </span><span class="koboSpan" id="kobo.964.7">You can try various techniques to improve your model generalization. </span><span class="koboSpan" id="kobo.964.8">See more about this kind of analysis in </span><em class="italic"><span class="koboSpan" id="kobo.965.1">Reference 4</span></em><span class="koboSpan" id="kobo.966.1"> at the end of this chapter.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.967.1">We will use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.968.1">Keras</span></code><span class="koboSpan" id="kobo.969.1"> library to define our models. </span><span class="koboSpan" id="kobo.969.2">Keras (see </span><em class="italic"><span class="koboSpan" id="kobo.970.1">Reference 5</span></em><span class="koboSpan" id="kobo.971.1">) is a wrapper over the TensorFlow machine learning platform (see </span><em class="italic"><span class="koboSpan" id="kobo.972.1">Reference 6</span></em><span class="koboSpan" id="kobo.973.1">). </span><span class="koboSpan" id="kobo.973.2">It allows you to create powerful deep learning models by defining a sequential structure with specialized layers. </span><span class="koboSpan" id="kobo.973.3">We will add the following layers to our model:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.974.1">One </span><code class="inlineCode"><span class="koboSpan" id="kobo.975.1">Conv2D</span></code><span class="koboSpan" id="kobo.976.1"> layer, with 16 filters of dimension 3</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.977.1">One </span><code class="inlineCode"><span class="koboSpan" id="kobo.978.1">MaxPooling2D</span></code><span class="koboSpan" id="kobo.979.1"> layer, with reduction factor 2</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.980.1">One convolutional layer, with 16 filters of dimension 3</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.981.1">A </span><code class="inlineCode"><span class="koboSpan" id="kobo.982.1">Flatten</span></code><span class="koboSpan" id="kobo.983.1"> layer</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.984.1">A Dense layer, with the dimension the number of classes of the subspecies target feature</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.985.1">The preceding architecture is a very simple example of a </span><strong class="keyWord"><span class="koboSpan" id="kobo.986.1">convolutional neural network</span></strong><span class="koboSpan" id="kobo.987.1">. </span><span class="koboSpan" id="kobo.987.2">The</span><a id="_idIndexMarker282"/><span class="koboSpan" id="kobo.988.1"> role of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.989.1">convolutional2d</span></code><span class="koboSpan" id="kobo.990.1"> layer is to apply sliding convolutional filters to a 2D input. </span><span class="koboSpan" id="kobo.990.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.991.1">maxpool2d</span></code><span class="koboSpan" id="kobo.992.1"> layer will down-sample the input along its spatial dimension (width and height) by taking the maximum value over an input window (see </span><em class="italic"><span class="koboSpan" id="kobo.993.1">Reference 5</span></em><span class="koboSpan" id="kobo.994.1"> for more details).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.995.1">The code to build the described architecture will be:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.996.1">model1=Sequential()
model1.add(Conv2D(config[</span><span class="hljs-string"><span class="koboSpan" id="kobo.997.1">'conv_2d_dim_1'</span></span><span class="koboSpan" id="kobo.998.1">], 
                  kernel_size=config[</span><span class="hljs-string"><span class="koboSpan" id="kobo.999.1">'</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1000.1">kernel_size'</span></span><span class="koboSpan" id="kobo.1001.1">], 
                  input_shape=(config[</span><span class="hljs-string"><span class="koboSpan" id="kobo.1002.1">'image_width'</span></span><span class="koboSpan" id="kobo.1003.1">], config[</span><span class="hljs-string"><span class="koboSpan" id="kobo.1004.1">'image_height'</span></span><span class="koboSpan" id="kobo.1005.1">],config[</span><span class="hljs-string"><span class="koboSpan" id="kobo.1006.1">'image_channels'</span></span><span class="koboSpan" id="kobo.1007.1">]), 
                  activation=</span><span class="hljs-string"><span class="koboSpan" id="kobo.1008.1">'relu'</span></span><span class="koboSpan" id="kobo.1009.1">, padding=</span><span class="hljs-string"><span class="koboSpan" id="kobo.1010.1">'same'</span></span><span class="koboSpan" id="kobo.1011.1">))
model1.add(MaxPool2D(config[</span><span class="hljs-string"><span class="koboSpan" id="kobo.1012.1">'max_pool_dim'</span></span><span class="koboSpan" id="kobo.1013.1">]))
model1.add(Conv2D(config[</span><span class="hljs-string"><span class="koboSpan" id="kobo.1014.1">'conv_2d_dim_2'</span></span><span class="koboSpan" id="kobo.1015.1">],  kernel_size=config[</span><span class="hljs-string"><span class="koboSpan" id="kobo.1016.1">'kernel_size'</span></span><span class="koboSpan" id="kobo.1017.1">],
                  activation=</span><span class="hljs-string"><span class="koboSpan" id="kobo.1018.1">'relu'</span></span><span class="koboSpan" id="kobo.1019.1">, padding=</span><span class="hljs-string"><span class="koboSpan" id="kobo.1020.1">'</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1021.1">same'</span></span><span class="koboSpan" id="kobo.1022.1">))
model1.add(Flatten())
model1.add(Dense(y_train.columns.size, activation=</span><span class="hljs-string"><span class="koboSpan" id="kobo.1023.1">'softmax'</span></span><span class="koboSpan" id="kobo.1024.1">))
model1.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1025.1">compile</span></span><span class="koboSpan" id="kobo.1026.1">(optimizer=</span><span class="hljs-string"><span class="koboSpan" id="kobo.1027.1">'adam'</span></span><span class="koboSpan" id="kobo.1028.1">, loss=</span><span class="hljs-string"><span class="koboSpan" id="kobo.1029.1">'categorical_crossentropy'</span></span><span class="koboSpan" id="kobo.1030.1">, metrics=[</span><span class="hljs-string"><span class="koboSpan" id="kobo.1031.1">'accuracy'</span></span><span class="koboSpan" id="kobo.1032.1">])
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1033.1">In </span><em class="italic"><span class="koboSpan" id="kobo.1034.1">Figure 6.20</span></em><span class="koboSpan" id="kobo.1035.1">, we show</span><a id="_idIndexMarker283"/><span class="koboSpan" id="kobo.1036.1"> the summary information of the model. </span><span class="koboSpan" id="kobo.1036.2">As you can see, the total number of trainable parameters is 282,775:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.1037.1"><img alt="A screenshot of a computer program  Description automatically generated with medium confidence" src="../Images/B20963_06_20.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.1038.1">Figure 6.20: Summary of the baseline model</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1039.1">For the baseline, we start with a small model and train for a reduced number of epochs. </span><span class="koboSpan" id="kobo.1039.2">The size of the input images is 100 x 100 x 3 (as we explained previously). </span><span class="koboSpan" id="kobo.1039.3">We will train this model for five epochs. </span><span class="koboSpan" id="kobo.1039.4">The batch size is set to 32. </span><span class="koboSpan" id="kobo.1039.5">The code to run the training is shown here:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1040.1">train_model1  = model1.fit_generator(image_generator.flow(X_train, y_train, batch_size=config[</span><span class="hljs-string"><span class="koboSpan" id="kobo.1041.1">'batch_size'</span></span><span class="koboSpan" id="kobo.1042.1">]),
                        epochs=config[</span><span class="hljs-string"><span class="koboSpan" id="kobo.1043.1">'no_epochs_1'</span></span><span class="koboSpan" id="kobo.1044.1">],
                        validation_data=[X_val, y_val],
                        steps_per_epoch=</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1045.1">len</span></span><span class="koboSpan" id="kobo.1046.1">(X_train)/config[</span><span class="hljs-string"><span class="koboSpan" id="kobo.1047.1">'batch_size'</span></span><span class="koboSpan" id="kobo.1048.1">])
</span></code></pre>
<p class="normal"><em class="italic"><span class="koboSpan" id="kobo.1049.1">Figure 6.21</span></em><span class="koboSpan" id="kobo.1050.1"> shows the training log for the baseline model. </span><span class="koboSpan" id="kobo.1050.2">We are not saving the best model version during </span><a id="_idIndexMarker284"/><span class="koboSpan" id="kobo.1051.1">training; the model weights at the last step will be used for the test.</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.1052.1"><img alt="A picture containing text, screenshot, font, number  Description automatically generated" src="../Images/B20963_06_21.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.1053.1">Figure 6.21: The training log for the baseline model. </span><span class="koboSpan" id="kobo.1053.2">The training loss and accuracy and validation loss and accuracy for each step are shown</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1054.1">The training loss and accuracy are updated after each batch, and the validation loss and accuracy are calculated at the end of each epoch. </span><span class="koboSpan" id="kobo.1054.2">Next, with the model trained and validated, we will evaluate the test set loss and accuracy:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1055.1">score = model1.evaluate(X_test, y_test, verbose=</span><span class="hljs-number"><span class="koboSpan" id="kobo.1056.1">0</span></span><span class="koboSpan" id="kobo.1057.1">)
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1058.1">print</span></span><span class="koboSpan" id="kobo.1059.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1060.1">'Test loss:'</span></span><span class="koboSpan" id="kobo.1061.1">, score[</span><span class="hljs-number"><span class="koboSpan" id="kobo.1062.1">0</span></span><span class="koboSpan" id="kobo.1063.1">])
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1064.1">print</span></span><span class="koboSpan" id="kobo.1065.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1066.1">'Test accuracy:'</span></span><span class="koboSpan" id="kobo.1067.1">, score[</span><span class="hljs-number"><span class="koboSpan" id="kobo.1068.1">1</span></span><span class="koboSpan" id="kobo.1069.1">])
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1070.1">In </span><em class="italic"><span class="koboSpan" id="kobo.1071.1">Figure 6.22</span></em><span class="koboSpan" id="kobo.1072.1">, we show the training and validation loss and the training and validation accuracy:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.1073.1"><img alt="A graph of a graph of a graph of a graph of a graph of a graph of a graph of a graph of a graph of a graph of a graph of a graph of a graph of  Description automatically generated with low confidence" src="../Images/B20963_06_22.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.1074.1">Figure 6.22: Baseline model – the training and validation accuracy (left) and the training and validation loss (right)</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1075.1">The results obtained are as follows:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1076.1">Test loss: </span><strong class="screenText"><span class="koboSpan" id="kobo.1077.1">0.42</span></strong></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1078.1">Test accuracy: </span><strong class="screenText"><span class="koboSpan" id="kobo.1079.1">0.82</span></strong></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.1080.1">The test loss refers </span><a id="_idIndexMarker285"/><span class="koboSpan" id="kobo.1081.1">to the loss function, a mathematical function that measures the difference between the predicted values and the true values. </span><span class="koboSpan" id="kobo.1081.2">By measuring this value during training, for both the train and validation sets, we can monitor how the model learns and improves its predictions.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1082.1">Using a metrics classification report (</span><code class="inlineCode"><span class="koboSpan" id="kobo.1083.1">metrics.classification_report</span></code><span class="koboSpan" id="kobo.1084.1">) from </span><code class="inlineCode"><span class="koboSpan" id="kobo.1085.1">sklearn</span></code><span class="koboSpan" id="kobo.1086.1">, we calculate the precision, recall, f1-score, and accuracy per each class in train data. </span><span class="koboSpan" id="kobo.1086.2">The code for that is given here:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1087.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1088.1">test_accuracy_report</span></span><span class="koboSpan" id="kobo.1089.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.1090.1">model</span></span><span class="koboSpan" id="kobo.1091.1">):
    predicted = model.predict(X_test)
    test_predicted = np.argmax(predicted, axis=</span><span class="hljs-number"><span class="koboSpan" id="kobo.1092.1">1</span></span><span class="koboSpan" id="kobo.1093.1">)
    test_truth = np.argmax(y_test.values, axis=</span><span class="hljs-number"><span class="koboSpan" id="kobo.1094.1">1</span></span><span class="koboSpan" id="kobo.1095.1">)
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1096.1">print</span></span><span class="koboSpan" id="kobo.1097.1">(metrics.classification_report(test_truth, test_predicted, target_names=y_test.columns)) 
    test_res = model.evaluate(X_test, y_test.values, verbose=</span><span class="hljs-number"><span class="koboSpan" id="kobo.1098.1">0</span></span><span class="koboSpan" id="kobo.1099.1">)
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1100.1">print</span></span><span class="koboSpan" id="kobo.1101.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1102.1">'Loss function: %s, accuracy:'</span></span><span class="koboSpan" id="kobo.1103.1"> % test_res[</span><span class="hljs-number"><span class="koboSpan" id="kobo.1104.1">0</span></span><span class="koboSpan" id="kobo.1105.1">], test_res[</span><span class="hljs-number"><span class="koboSpan" id="kobo.1106.1">1</span></span><span class="koboSpan" id="kobo.1107.1">])
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1108.1">In </span><em class="italic"><span class="koboSpan" id="kobo.1109.1">Figure 6.23</span></em><span class="koboSpan" id="kobo.1110.1">, we show this classification report for the test set, where we applied the baseline model fit with train data. </span><span class="koboSpan" id="kobo.1110.2">The macro average of the precision, recall, and f1-score are </span><strong class="screenText"><span class="koboSpan" id="kobo.1111.1">0.78</span></strong><span class="koboSpan" id="kobo.1112.1">, </span><strong class="screenText"><span class="koboSpan" id="kobo.1113.1">0.72</span></strong><span class="koboSpan" id="kobo.1114.1">, and </span><strong class="screenText"><span class="koboSpan" id="kobo.1115.1">0.74</span></strong><span class="koboSpan" id="kobo.1116.1">, respectively (the support data is </span><strong class="screenText"><span class="koboSpan" id="kobo.1117.1">1035</span></strong><span class="koboSpan" id="kobo.1118.1">). </span><span class="koboSpan" id="kobo.1118.2">The weighted average precision, recall, and f1-score are </span><strong class="screenText"><span class="koboSpan" id="kobo.1119.1">0.82</span></strong><span class="koboSpan" id="kobo.1120.1">, </span><strong class="screenText"><span class="koboSpan" id="kobo.1121.1">0.83</span></strong><span class="koboSpan" id="kobo.1122.1">, and </span><strong class="screenText"><span class="koboSpan" id="kobo.1123.1">0.82</span></strong><span class="koboSpan" id="kobo.1124.1">, respectively.</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.1125.1"><img alt="A screenshot of a computer  Description automatically generated with low confidence" src="../Images/B20963_06_23.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.1126.1">Figure 6.23: Classification report for test data using the baseline model</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1127.1">These weighted average scores are higher because unlike the simple averages of all class scores, these are weighted averages, so the higher scores associated with better-represented</span><a id="_idIndexMarker286"/><span class="koboSpan" id="kobo.1128.1"> classes will have a higher contribution to the overall average. </span><span class="koboSpan" id="kobo.1128.2">The worst scores for precision/class are for </span><strong class="screenText"><span class="koboSpan" id="kobo.1129.1">1 Mixed local stock 2</span></strong><span class="koboSpan" id="kobo.1130.1"> (0.52) and </span><strong class="screenText"><span class="koboSpan" id="kobo.1131.1">VSH Italian honey bee</span></strong><span class="koboSpan" id="kobo.1132.1"> (0.68). </span><span class="koboSpan" id="kobo.1132.2">The worst overall score is for </span><strong class="screenText"><span class="koboSpan" id="kobo.1133.1">VSH Italian honey bee, </span></strong><span class="koboSpan" id="kobo.1134.1">where the recall is 0.33.</span></p>
<h2 class="heading-2" id="_idParaDest-89"><span class="koboSpan" id="kobo.1135.1">Iteratively refining the model</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1136.1">If we go back now to the</span><a id="_idIndexMarker287"/><span class="koboSpan" id="kobo.1137.1"> training and validation errors, we can see that validation and training accuracies are around 0.81 and 0.82.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1138.1">We will continue to train the model, and to avoid overfitting, we will also introduce two </span><code class="inlineCode"><span class="koboSpan" id="kobo.1139.1">Dropout</span></code><span class="koboSpan" id="kobo.1140.1"> layers, each with a coefficient of 0.4. </span><span class="koboSpan" id="kobo.1140.2">A </span><code class="inlineCode"><span class="koboSpan" id="kobo.1141.1">Dropout</span></code><span class="koboSpan" id="kobo.1142.1"> layer is used as a regularization method in neural networks. </span><span class="koboSpan" id="kobo.1142.2">Its purpose is to prevent overfitting and improve generalization of the model. </span><span class="koboSpan" id="kobo.1142.3">The coefficient given as a parameter is the percentage of inputs randomly selected during training to be set to zero at each training epoch. </span><span class="koboSpan" id="kobo.1142.4">The structure of the model is described in </span><em class="italic"><span class="koboSpan" id="kobo.1143.1">Figure 6.24</span></em><span class="koboSpan" id="kobo.1144.1">. </span><span class="koboSpan" id="kobo.1144.2">The number of trainable parameters will remain the same.</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.1145.1"><img alt="A screenshot of a computer  Description automatically generated with medium confidence" src="../Images/B20963_06_24.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.1146.1">Figure 6.24: Refined model summary. </span><span class="koboSpan" id="kobo.1146.2">Two Dropout layers were added</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1147.1">We also extend the </span><a id="_idIndexMarker288"/><span class="koboSpan" id="kobo.1148.1">number of epochs to 10. </span><span class="koboSpan" id="kobo.1148.2">Let’s see the results in </span><em class="italic"><span class="koboSpan" id="kobo.1149.1">Figure 6.25</span></em><span class="koboSpan" id="kobo.1150.1">, where we show the training and validation accuracy and the training and validation loss.</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.1151.1"><img alt="A graph of a graph of a graph of a graph of a graph of a graph of a graph of a graph of a graph of a graph of a graph of a graph of a graph of  Description automatically generated with low confidence" src="../Images/B20963_06_25.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.1152.1">Figure 6.25: Refined model (version 2) – the training and validation accuracy (left) and the training and validation loss (right)</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1153.1">The final training loss is 0.32, and the final training accuracy is 0.87. </span><span class="koboSpan" id="kobo.1153.2">The final validation loss is 0.28, and the final validation accuracy is 0.88. </span><span class="koboSpan" id="kobo.1153.3">These are improved results. </span><span class="koboSpan" id="kobo.1153.4">Of course, training accuracy</span><a id="_idIndexMarker289"/><span class="koboSpan" id="kobo.1154.1"> is mainly improved due to the fact that we trained for more epochs.</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.1155.1"><img alt="A screenshot of a computer screen  Description automatically generated with low confidence" src="../Images/B20963_06_26.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.1156.1">Figure 6.26: Classification report for test data using the second refined model (the training epochs increased to 10 and Dropout layers added)</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1157.1">As per validation accuracy, the result is due to both more training epochs as well as adding </span><code class="inlineCode"><span class="koboSpan" id="kobo.1158.1">Dropout</span></code><span class="koboSpan" id="kobo.1159.1"> layers, which kept overfitting under control. </span><span class="koboSpan" id="kobo.1159.2">Let’s now check the test loss and accuracy as well as look at the entire classification report for test data.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1160.1">Both macro averaged and weighted averaged metrics improved for precision, recall, and f1-score. </span><span class="koboSpan" id="kobo.1160.2">Also, we can see much-improved precision, recall, and f1-scores for the classes with small scores obtained with the baseline. </span><strong class="screenText"><span class="koboSpan" id="kobo.1161.1">1 Mixed local stock 2</span></strong><span class="koboSpan" id="kobo.1162.1"> had 0.52 precision, and now, precision is 0.63. </span><span class="koboSpan" id="kobo.1162.2">As for </span><strong class="screenText"><span class="koboSpan" id="kobo.1163.1">VSH Italian honey bee</span></strong><span class="koboSpan" id="kobo.1164.1">, precision was 0.68 and is now 0.97. </span><span class="koboSpan" id="kobo.1164.2">We see a degradation of the precision of </span><strong class="screenText"><span class="koboSpan" id="kobo.1165.1">Western honey bee</span></strong><span class="koboSpan" id="kobo.1166.1">, but the support for this minority class is only 7, so this result is expected.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1167.1">We continue to refine our model to improve the validation and test metrics – in other words, to improve the model performance. </span><span class="koboSpan" id="kobo.1167.2">In the next iteration, we will increase the number of training epochs to 50. </span><span class="koboSpan" id="kobo.1167.3">Also, we will add three callback functions, as follows:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1168.1">A learning rate scheduler, to implement a nonlinear function for variation of the learning rate. </span><span class="koboSpan" id="kobo.1168.2">By changing the learning rate at each epoch, we can improve the training process. </span><span class="koboSpan" id="kobo.1168.3">The function we introduce to control the learning rate will gradually decrease the learning function value.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1169.1">An early stopper to stop training epochs, based on the loss function evolution (if loss does not improve for a certain number of epochs) and a patience factor (the number of epochs, after which, if we don’t see any improvement of the monitored function, we stop training).</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1170.1">A check pointer to save the best-performing models every time we obtain the best accuracy. </span><span class="koboSpan" id="kobo.1170.2">This will allow us to use not the model parameters at the last training epoch but, instead, the best-performing model of all the epochs.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.1171.1">The code for the three</span><a id="_idIndexMarker290"/><span class="koboSpan" id="kobo.1172.1"> callback functions is given below:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1173.1">annealer3 = LearningRateScheduler(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1174.1">lambda</span></span><span class="koboSpan" id="kobo.1175.1"> x: </span><span class="hljs-number"><span class="koboSpan" id="kobo.1176.1">1e-3</span></span><span class="koboSpan" id="kobo.1177.1"> * </span><span class="hljs-number"><span class="koboSpan" id="kobo.1178.1">0.995</span></span><span class="koboSpan" id="kobo.1179.1"> ** (x+config[</span><span class="hljs-string"><span class="koboSpan" id="kobo.1180.1">'no_epochs_3'</span></span><span class="koboSpan" id="kobo.1181.1">]))
earlystopper3 = EarlyStopping(monitor=</span><span class="hljs-string"><span class="koboSpan" id="kobo.1182.1">'loss'</span></span><span class="koboSpan" id="kobo.1183.1">, patience=config[</span><span class="hljs-string"><span class="koboSpan" id="kobo.1184.1">'</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1185.1">patience'</span></span><span class="koboSpan" id="kobo.1186.1">], verbose=config[</span><span class="hljs-string"><span class="koboSpan" id="kobo.1187.1">'verbose'</span></span><span class="koboSpan" id="kobo.1188.1">])
checkpointer3 = ModelCheckpoint(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1189.1">'best_model_3.h5'</span></span><span class="koboSpan" id="kobo.1190.1">,
                                monitor=</span><span class="hljs-string"><span class="koboSpan" id="kobo.1191.1">'val_accuracy'</span></span><span class="koboSpan" id="kobo.1192.1">,
                                verbose=config[</span><span class="hljs-string"><span class="koboSpan" id="kobo.1193.1">'verbose'</span></span><span class="koboSpan" id="kobo.1194.1">],
                                save_best_only=</span><span class="hljs-literal"><span class="koboSpan" id="kobo.1195.1">True</span></span><span class="koboSpan" id="kobo.1196.1">,
                                save_weights_only=</span><span class="hljs-literal"><span class="koboSpan" id="kobo.1197.1">True</span></span><span class="koboSpan" id="kobo.1198.1">)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1199.1">The code to fit the model is also given below:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1200.1">train_model3  = model3.fit_generator(image_generator.flow(X_train, y_train, batch_size=config[</span><span class="hljs-string"><span class="koboSpan" id="kobo.1201.1">'batch_size'</span></span><span class="koboSpan" id="kobo.1202.1">]),
                        epochs=config[</span><span class="hljs-string"><span class="koboSpan" id="kobo.1203.1">'no_epochs_3'</span></span><span class="koboSpan" id="kobo.1204.1">],
                        validation_data=[X_val, y_val],
                        steps_per_epoch=</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1205.1">len</span></span><span class="koboSpan" id="kobo.1206.1">(X_train)/config[</span><span class="hljs-string"><span class="koboSpan" id="kobo.1207.1">'batch_size'</span></span><span class="koboSpan" id="kobo.1208.1">],
                        callbacks=[earlystopper3, checkpointer3, annealer3])
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1209.1">The training can take as many as the maximum number of epochs assigned or, if the early stopping criteria are met (i.e., no loss function improvement after a number of epochs equal to the patience factor), it might end earlier. </span><span class="koboSpan" id="kobo.1209.2">Either way, the model for which the best validation accuracy was achieved is saved and will be used for testing.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1210.1">In </span><em class="italic"><span class="koboSpan" id="kobo.1211.1">Figure 6.27</span></em><span class="koboSpan" id="kobo.1212.1">, we show the evolution of the training and validation accuracy and the training and validation loss for this further refined model. </span><span class="koboSpan" id="kobo.1212.2">The final training loss obtained is 0.18, and the final training accuracy is 0.93. </span><span class="koboSpan" id="kobo.1212.3">For validation, the last validation loss is 0.21, and the last validation accuracy is 0.91. </span><span class="koboSpan" id="kobo.1212.4">The learning rate at the final epoch is 6.08e-4. </span><span class="koboSpan" id="kobo.1212.5">The best </span><a id="_idIndexMarker291"/><span class="koboSpan" id="kobo.1213.1">validation accuracy obtained was for epoch 46, 0.92.</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.1214.1"><img alt="A picture containing text, screenshot, plot, diagram  Description automatically generated" src="../Images/B20963_06_27.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.1215.1">Figure 6.27: Refined model (version 3, with a learning rate scheduler, early stop, and checkpoint) – the training and validation accuracy (left) and the training and validation loss (right)</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1216.1">We use the model checkpoint saved (for epoch 46) to predict for the test data. </span><span class="koboSpan" id="kobo.1216.2">In </span><em class="italic"><span class="koboSpan" id="kobo.1217.1">Figure 6.28</span></em><span class="koboSpan" id="kobo.1218.1">, we show the classification report for the third model.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1219.1">Macro average metrics are further improved to the precision, recall, and f1-score values of 0.88, 0.90, and 0.89, respectively. </span><span class="koboSpan" id="kobo.1219.2">The weighted average values for precision, recall, and f1-score are also improved to 0.91, 0.90, and 0.90, respectively.</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.1220.1"><img alt="A screenshot of a computer screen  Description automatically generated with low confidence" src="../Images/B20963_06_28.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.1221.1">Figure 6.28: Classification report for test data using the third refined model (the training epochs increased to 50 and a learning rate scheduler, early stopper, and model checkpoint added)</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1222.1">Here, we will stop the process of iteratively improving the model. </span><span class="koboSpan" id="kobo.1222.2">You can continue to refine it. </span><span class="koboSpan" id="kobo.1222.3">You can try to add more convolutional and maxpool layers, using a different number of kernels and values of stride to work with different hyperparameters, including a different batch size or learning rate scheduler. </span><span class="koboSpan" id="kobo.1222.4">Also, you can change the optimization scheme. </span><span class="koboSpan" id="kobo.1222.5">Another way to change the model is to control, through data augmentation, the balance of the class images (currently, the bee images are unbalanced with respect to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1223.1">subspecies</span></code><span class="koboSpan" id="kobo.1224.1"> class).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1225.1">You can also experiment with various data augmentation parameters and try to use a different data augmentation solution. </span><span class="koboSpan" id="kobo.1225.2">See </span><em class="italic"><span class="koboSpan" id="kobo.1226.1">Reference 5</span></em><span class="koboSpan" id="kobo.1227.1"> for one example of an image data augmentation library</span><a id="_idIndexMarker292"/><span class="koboSpan" id="kobo.1228.1"> that is very much used currently, </span><strong class="keyWord"><span class="koboSpan" id="kobo.1229.1">Albumentations</span></strong><span class="koboSpan" id="kobo.1230.1">, created by a group of data scientists, researchers, and computer vision engineers, including the famous Kaggle Grandmaster Vladimir Iglovikov.</span></p>
<h1 class="heading-1" id="_idParaDest-90"><span class="koboSpan" id="kobo.1231.1">Summary</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1232.1">In this chapter, we started by introducing a new dataset, with metadata about images collected at different dates and in different locations, including various bee subspecies that have various diseases. </span><span class="koboSpan" id="kobo.1232.2">We also introduced a few functions to read, rescale, and extract features from images, based on </span><code class="inlineCode"><span class="koboSpan" id="kobo.1233.1">skimage.io</span></code><span class="koboSpan" id="kobo.1234.1"> and opencv (</span><code class="inlineCode"><span class="koboSpan" id="kobo.1235.1">cv2</span></code><span class="koboSpan" id="kobo.1236.1">). </span></p>
<p class="normal"><span class="koboSpan" id="kobo.1237.1">We used a newly created utility script to visualize tabular data, based on Plotly, and created insightful visualizations by leveraging the flexibility of Plotly to create customized graphics. </span><span class="koboSpan" id="kobo.1237.2">We also created visualization functions for images.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1238.1">After the detailed EDA, we moved on to building a predictive model for bee subspecies. </span><span class="koboSpan" id="kobo.1238.2">Here, we introduced a method for data augmentation to multiply the initial available training data, by creating variations (rotations, zoom, shift, and mirroring) from the original image sets. </span><span class="koboSpan" id="kobo.1238.3">We split the data into train, validation, and test subsets, using </span><code class="inlineCode"><span class="koboSpan" id="kobo.1239.1">stratify</span></code><span class="koboSpan" id="kobo.1240.1"> to account for the class imbalance when randomly sampling the three subsets. </span><span class="koboSpan" id="kobo.1240.2">We started by training and validating a baseline model, and then, after performing error analysis, we gradually improved the initial model, by adding more steps, introducing </span><code class="inlineCode"><span class="koboSpan" id="kobo.1241.1">Dropout</span></code><span class="koboSpan" id="kobo.1242.1"> layers, and then using several callbacks: the learning rate scheduler, early stopper, and model checkpoints. </span><span class="koboSpan" id="kobo.1242.2">We analyzed the iterative improvement for the training, validation, and test errors, looking not only at the training and validation loss and accuracy but also at the classification report for test data.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1243.1">In the following chapter, we will introduce techniques and tools for text data analysis, showing you how to prepare your data to create baseline models using text data.</span></p>
<h1 class="heading-1" id="_idParaDest-91"><span class="koboSpan" id="kobo.1244.1">References</span></h1>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.1245.1">The BeeImage Dataset: Annotated Honey Bee Images: </span><a href="https://www.kaggle.com/datasets/jenny18/honey-bee-annotated-images"><span class="url"><span class="koboSpan" id="kobo.1246.1">https://www.kaggle.com/datasets/jenny18/honey-bee-annotated-images</span></span></a></li>
<li class="numberedList"><code class="inlineCode"><span class="koboSpan" id="kobo.1247.1">plotly-script</span></code><span class="koboSpan" id="kobo.1248.1"> and Kaggle Utility Script: </span><a href="https://github.com/PacktPublishing/Developing-Kaggle-Notebooks/blob/develop/Chapter-06/plotly-utils.ipynb"><span class="url"><span class="koboSpan" id="kobo.1249.1">https://github.com/PacktPublishing/Developing-Kaggle-Notebooks/blob/develop/Chapter-06/plotly-utils.ipynb</span></span></a></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1250.1">Honeybee Subspecies Classification, Kaggle Notebook: </span><a href="https://github.com/PacktPublishing/Developing-Kaggle-Notebooks/blob/develop/Chapter-06/honeybee-subspecies-classification.ipynb"><span class="url"><span class="koboSpan" id="kobo.1251.1">https://github.com/PacktPublishing/Developing-Kaggle-Notebooks/blob/develop/Chapter-06/honeybee-subspecies-classification.ipynb</span></span></a></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1252.1">Andrew Ng, Machine Learning Yearning: </span><a href="https://info.deeplearning.ai/machine-learning-yearning-book"><span class="url"><span class="koboSpan" id="kobo.1253.1">https://info.deeplearning.ai/machine-learning-yearning-book</span></span></a></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1254.1">Keras: </span><a href="https://keras.io/"><span class="url"><span class="koboSpan" id="kobo.1255.1">https://keras.io/</span></span></a></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1256.1">TensorFlow: </span><a href="https://www.tensorflow.org/"><span class="url"><span class="koboSpan" id="kobo.1257.1">https://www.tensorflow.org/</span></span></a></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1258.1">Using Albumentations with Tensorflow: </span><a href="https://github.com/albumentations-team/albumentations_examples/blob/master/notebooks/tensorflow-example.ipynb"><span class="url"><span class="koboSpan" id="kobo.1259.1">https://github.com/albumentations-team/albumentations_examples/blob/master/notebooks/tensorflow-example.ipynb</span></span></a></li>
</ol>
<h1 class="heading-1"><span class="koboSpan" id="kobo.1260.1">Join our book’s Discord space</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1261.1">Join our Discord community to meet like-minded people and learn alongside more than 5000 members at:</span></p>
<p class="normal"><a href="https://packt.link/kaggle"><span class="url"><span class="koboSpan" id="kobo.1262.1">https://packt.link/kaggle</span></span></a></p>
<p class="normal"><span class="koboSpan" id="kobo.1263.1"><img alt="" role="presentation" src="../Images/QR_Code9220780366773140.png"/></span></p>
</div>
</body></html>