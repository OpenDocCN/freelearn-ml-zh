<html><head></head><body>
<div id="_idContainer154">
<h1 class="chapter-number" id="_idParaDest-188"><a id="_idTextAnchor189"/><span class="koboSpan" id="kobo.1.1">9</span></h1>
<h1 id="_idParaDest-189"><a id="_idTextAnchor190"/><span class="koboSpan" id="kobo.2.1">Teleoperating a Raspberry Pi Pico Robot with Bluetooth LE</span></h1>
<p><span class="koboSpan" id="kobo.3.1">We intend for the robot we are building to be mobile. </span><span class="koboSpan" id="kobo.3.2">We already have the robot driving on the floor and able to sense and respond to its surroundings. </span><span class="koboSpan" id="kobo.3.3">However, we either rely on it blindly or are tethered to it with a laptop. </span><span class="koboSpan" id="kobo.3.4">Neither is quite what we want. </span><span class="koboSpan" id="kobo.3.5">What if we could get feedback while it’s untethered and roaming </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">the floor?</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">In this chapter, we’ll see how Bluetooth </span><strong class="bold"><span class="koboSpan" id="kobo.6.1">Low Energy</span></strong><span class="koboSpan" id="kobo.7.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.8.1">LE</span></strong><span class="koboSpan" id="kobo.9.1">) is well suited to this task, allowing us to get </span><a id="_idIndexMarker515"/><span class="koboSpan" id="kobo.10.1">data from the robot, use an app to graph data, and even remotely control our robot from </span><span class="No-Break"><span class="koboSpan" id="kobo.11.1">our smartphone!</span></span></p>
<p><span class="koboSpan" id="kobo.12.1">In this chapter, we will cover the following </span><span class="No-Break"><span class="koboSpan" id="kobo.13.1">main topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.14.1">Wireless robot </span><span class="No-Break"><span class="koboSpan" id="kobo.15.1">connection options</span></span></li>
<li><span class="koboSpan" id="kobo.16.1">Connecting Bluetooth LE to Raspberry </span><span class="No-Break"><span class="koboSpan" id="kobo.17.1">Pi Pico</span></span></li>
<li><span class="koboSpan" id="kobo.18.1">Making a Bluetooth LE sensor feed on Raspberry </span><span class="No-Break"><span class="koboSpan" id="kobo.19.1">Pi Pico</span></span></li>
<li><span class="koboSpan" id="kobo.20.1">Teleoperating the robot with </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">Bluetooth LE</span></span></li>
</ul>
<h1 id="_idParaDest-190"><a id="_idTextAnchor191"/><span class="koboSpan" id="kobo.22.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.23.1">This chapter requires </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.25.1">The robot from </span><a href="B18001_08.xhtml#_idTextAnchor166"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.26.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.27.1">, </span><em class="italic"><span class="koboSpan" id="kobo.28.1">Sensing Distances to Detect Objects </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.29.1">with Pico</span></em></span></li>
<li><span class="koboSpan" id="kobo.30.1">An Adafruit Bluefruit LE UART </span><span class="No-Break"><span class="koboSpan" id="kobo.31.1">Friend ADA2479</span></span></li>
<li><span class="koboSpan" id="kobo.32.1">1 x eight-way single-row 2.54-mm header (included with </span><span class="No-Break"><span class="koboSpan" id="kobo.33.1">the module)</span></span></li>
<li><span class="koboSpan" id="kobo.34.1">5 x male-to-female jump wires with a 2.54-mm </span><span class="No-Break"><span class="koboSpan" id="kobo.35.1">DuPont connector</span></span></li>
<li><span class="koboSpan" id="kobo.36.1">Access to an Android or </span><span class="No-Break"><span class="koboSpan" id="kobo.37.1">iOS smartphone</span></span></li>
<li><span class="koboSpan" id="kobo.38.1">Velcro hook and </span><span class="No-Break"><span class="koboSpan" id="kobo.39.1">loop dots</span></span></li>
<li><span class="koboSpan" id="kobo.40.1">The code from </span><span class="No-Break"><span class="koboSpan" id="kobo.41.1">previous chapters</span></span></li>
<li><span class="koboSpan" id="kobo.42.1">A Raspberry Pi Pico code editor such as Mu </span><span class="No-Break"><span class="koboSpan" id="kobo.43.1">or Thonny</span></span></li>
<li><span class="koboSpan" id="kobo.44.1">A USB </span><span class="No-Break"><span class="koboSpan" id="kobo.45.1">micro cable</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.46.1">You can find the code for this chapter </span><span class="No-Break"><span class="koboSpan" id="kobo.47.1">at </span></span><a href="https://github.com/PacktPublishing/Robotics-at-Home-with-Raspberry-Pi-Pico/tree/main/ch-09"><span class="No-Break"><span class="koboSpan" id="kobo.48.1">https://github.com/PacktPublishing/Robotics-at-Home-with-Raspberry-Pi-Pico/tree/main/ch-09</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.49.1">.</span></span></p>
<h1 id="_idParaDest-191"><a id="_idTextAnchor192"/><span class="koboSpan" id="kobo.50.1">Wireless robot connection options</span></h1>
<p><span class="koboSpan" id="kobo.51.1">So far, we’ve </span><a id="_idIndexMarker516"/><span class="koboSpan" id="kobo.52.1">been working with the robot tethered to our computer. </span><span class="koboSpan" id="kobo.52.2">We send code to it and use the REPL tools to see what it is doing or printing out. </span><span class="koboSpan" id="kobo.52.3">While the REPL tools can be convenient, having a wire between the computer and the robot is not so convenient and limits how far the robot can drive or has you running behind it with the laptop. </span><span class="koboSpan" id="kobo.52.4">The following diagram shows how we could </span><span class="No-Break"><span class="koboSpan" id="kobo.53.1">do things:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer141">
<span class="koboSpan" id="kobo.54.1"><img alt="Figure 9.1 – Robot connections " src="image/Figure_9.01_B18001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.55.1">Figure 9.1 – Robot connections</span></p>
<p><span class="koboSpan" id="kobo.56.1">The top part of the diagram shows things tethered with a wire. </span><span class="koboSpan" id="kobo.56.2">But the bottom part shows that </span><a id="_idIndexMarker517"/><span class="koboSpan" id="kobo.57.1">the computer and the robot are not physically wired together. </span><span class="koboSpan" id="kobo.57.2">Instead, they are using wireless to send data to </span><span class="No-Break"><span class="koboSpan" id="kobo.58.1">each other.</span></span></p>
<p><span class="koboSpan" id="kobo.59.1">Once we are wireless, we can also consider a smartphone coming in as an alternative item. </span><span class="koboSpan" id="kobo.59.2">We can use a wireless medium to send data from the robot’s sensors or code to see what is going on and monitor it. </span><span class="koboSpan" id="kobo.59.3">We can also send control signals to take control and drive </span><span class="No-Break"><span class="koboSpan" id="kobo.60.1">our robot.</span></span></p>
<p><span class="koboSpan" id="kobo.61.1">There are several different wireless protocols we can use. </span><span class="koboSpan" id="kobo.61.2">All require our robot to have a </span><strong class="bold"><span class="koboSpan" id="kobo.62.1">transceiver</span></strong><span class="koboSpan" id="kobo.63.1"> – transmitter </span><a id="_idIndexMarker518"/><span class="koboSpan" id="kobo.64.1">and receiver – </span><span class="No-Break"><span class="koboSpan" id="kobo.65.1">board.</span></span></p>
<p><span class="koboSpan" id="kobo.66.1">While some robot controllers, such as Raspberry Pi 4, have onboard transceivers, Raspberry Pi Pico does not. </span><span class="koboSpan" id="kobo.66.2">Therefore, we will need to add a breakout. </span><span class="koboSpan" id="kobo.66.3">In addition, they come with </span><a id="_idIndexMarker519"/><span class="koboSpan" id="kobo.67.1">different protocols and different implementations of </span><span class="No-Break"><span class="koboSpan" id="kobo.68.1">those protocols.</span></span></p>
<p><span class="koboSpan" id="kobo.69.1">Which transceiver boards might we choose and why? </span><span class="koboSpan" id="kobo.69.2">The following table shows </span><span class="No-Break"><span class="koboSpan" id="kobo.70.1">the comparison:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer142">
<span class="koboSpan" id="kobo.71.1"><img alt="Table 9.1 – Transceiver modules for Pico " src="image/Table_9.01_B18001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.72.1">Table 9.1 – Transceiver modules for Pico</span></p>
<p><span class="koboSpan" id="kobo.73.1">In the preceding table, I’ve picked boards that come with onboard software stacks, reducing the amount of code we need. </span><span class="koboSpan" id="kobo.73.2">We are less concerned with speed as we don’t intend to send camera data; however, latency is important as we want our robot to respond quickly to commands and send up-to-date </span><span class="No-Break"><span class="koboSpan" id="kobo.74.1">sensor data.</span></span></p>
<p><span class="koboSpan" id="kobo.75.1">Support is important – we want to choose modules with good support from their vendors and </span><a id="_idIndexMarker520"/><span class="koboSpan" id="kobo.76.1">the community. </span><span class="koboSpan" id="kobo.76.2">For example, Adafruit has excellent support and documentation for their modules, with online communities on Discord and other forums and all their code available on GitHub, which gives their modules a lot of credibility over cheaper and less </span><span class="No-Break"><span class="koboSpan" id="kobo.77.1">well-supported options.</span></span></p>
<p><span class="koboSpan" id="kobo.78.1">An honorable mention must go to Raspberry Pi Pico W – a Pico with an onboard Wi-Fi chip. </span><span class="koboSpan" id="kobo.78.2">This has excellent support from the Raspberry Pi community. </span><span class="koboSpan" id="kobo.78.3">It has the added complexity of requiring you to serve up a graphing web frontend, however it may make a very </span><span class="No-Break"><span class="koboSpan" id="kobo.79.1">good alternative.</span></span></p>
<p><span class="koboSpan" id="kobo.80.1">The HM-10 modules are widely available and may even be super cheap, but their unusual protocols mean connecting with them needs </span><span class="No-Break"><span class="koboSpan" id="kobo.81.1">more code.</span></span></p>
<p><span class="koboSpan" id="kobo.82.1">The choice with the most going for it here is the Adafruit Bluefruit LE board. </span><span class="koboSpan" id="kobo.82.2">It has low current </span><a id="_idIndexMarker521"/><span class="koboSpan" id="kobo.83.1">usage and is small. </span><span class="koboSpan" id="kobo.83.2">There is a </span><strong class="bold"><span class="koboSpan" id="kobo.84.1">Serial Peripheral Interface</span></strong><span class="koboSpan" id="kobo.85.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.86.1">SPI</span></strong><span class="koboSpan" id="kobo.87.1">) and a </span><strong class="bold"><span class="koboSpan" id="kobo.88.1">Universal Asynchronous Receiver/Transmitter</span></strong><span class="koboSpan" id="kobo.89.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.90.1">UART</span></strong><span class="koboSpan" id="kobo.91.1">; defined </span><a id="_idIndexMarker522"/><span class="koboSpan" id="kobo.92.1">in more detail as follows) version of this board. </span><strong class="bold"><span class="koboSpan" id="kobo.93.1">Bluetooth LE</span></strong><span class="koboSpan" id="kobo.94.1"> is a low-energy </span><a id="_idIndexMarker523"/><span class="koboSpan" id="kobo.95.1">variant of Bluetooth, ideal for short-range communications between devices such as a robot and a controller. </span><span class="koboSpan" id="kobo.95.2">It has a range of up to 100 m. </span><span class="koboSpan" id="kobo.95.3">Bluetooth LE has two-thirds of the data rate compared to regular Bluetooth but consumes half the current when active. </span><span class="koboSpan" id="kobo.95.4">Smart software profiles allow it to frequently use low-power modes, and rapidly wake up </span><span class="No-Break"><span class="koboSpan" id="kobo.96.1">when needed.</span></span></p>
<p><span class="koboSpan" id="kobo.97.1">UART doesn’t need much configuration and only uses two wires (as opposed to the three or more wires SPI or I2C uses). </span><span class="koboSpan" id="kobo.97.2">There is no clock line (just an agreement on speeds) and no address, just one-to-one device communication. </span><span class="koboSpan" id="kobo.97.3">We have already been using a USB-based UART to communicate with Raspberry </span><span class="No-Break"><span class="koboSpan" id="kobo.98.1">Pi Pico.</span></span></p>
<p><span class="koboSpan" id="kobo.99.1">We will use the Adafruit Bluefruit LE UART Friend board for simplicity in </span><span class="No-Break"><span class="koboSpan" id="kobo.100.1">our project.</span></span></p>
<p><span class="koboSpan" id="kobo.101.1">It is widely available through Adafruit directly or through distributors such as Pimoroni and </span><span class="No-Break"><span class="koboSpan" id="kobo.102.1">Mouser Electronics.</span></span></p>
<p><span class="koboSpan" id="kobo.103.1">Adafruit Bluefruit is an ecosystem of Bluetooth LE-based development boards, so there’s lots </span><a id="_idIndexMarker524"/><span class="koboSpan" id="kobo.104.1">of compatible code. </span><span class="koboSpan" id="kobo.104.2">In addition, it works with computers and phones that have built-in Bluetooth LE transceivers, and Adafruit makes apps for both computers and phones to communicate with them. </span><span class="koboSpan" id="kobo.104.3">These apps will save us time, as other solutions require you to build </span><span class="No-Break"><span class="koboSpan" id="kobo.105.1">your apps.</span></span></p>
<p><span class="koboSpan" id="kobo.106.1">We now know which module we will use. </span><span class="koboSpan" id="kobo.106.2">So we can make use of it, let’s take the Bluefruit LE UART board and connect it to </span><span class="No-Break"><span class="koboSpan" id="kobo.107.1">our robot!</span></span></p>
<h1 id="_idParaDest-192"><a id="_idTextAnchor193"/><span class="koboSpan" id="kobo.108.1">Connecting Bluetooth LE to Raspberry Pi Pico</span></h1>
<p><span class="koboSpan" id="kobo.109.1">The Bluefruit LE UART Friend is relatively simple to wire in. </span><span class="koboSpan" id="kobo.109.2">First, the module will need headers </span><a id="_idIndexMarker525"/><span class="koboSpan" id="kobo.110.1">soldered onto it, and then we can </span><a id="_idIndexMarker526"/><span class="koboSpan" id="kobo.111.1">look at how to attach it to the robot physically and how to wire it. </span><span class="koboSpan" id="kobo.111.2">We will then connect to it from our robot and </span><span class="No-Break"><span class="koboSpan" id="kobo.112.1">a smartphone.</span></span></p>
<p><span class="koboSpan" id="kobo.113.1">Adding Bluetooth LE will result in our robot having a block diagram </span><span class="No-Break"><span class="koboSpan" id="kobo.114.1">as follows:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer143">
<span class="koboSpan" id="kobo.115.1"><img alt="Figure 9.2 – Robot block diagram with Bluetooth " src="image/Figure_9.02_B18001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.116.1">Figure 9.2 – Robot block diagram with Bluetooth</span></p>
<p><span class="koboSpan" id="kobo.117.1">The </span><a id="_idIndexMarker527"/><span class="koboSpan" id="kobo.118.1">preceding diagram shows the robot blocks with the additional Adafruit Bluefruit LE UART Friend (marked as a Bluefruit module) connected via UART to Raspberry </span><span class="No-Break"><span class="koboSpan" id="kobo.119.1">Pi Pico.</span></span></p>
<p><span class="koboSpan" id="kobo.120.1">Solder a set of male headers onto the board using the same techniques used for the modules in </span><a href="B18001_08.xhtml#_idTextAnchor166"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.121.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.122.1">, </span><em class="italic"><span class="koboSpan" id="kobo.123.1">Sensing Distances to Detect Objects </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.124.1">with Pico</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.125.1">.</span></span></p>
<h2 id="_idParaDest-193"><a id="_idTextAnchor194"/><span class="koboSpan" id="kobo.126.1">Attaching the Bluetooth module to the robot</span></h2>
<p><span class="koboSpan" id="kobo.127.1">We want to place the module above devices that are most likely to restrict and interfere with the Bluetooth. </span><span class="koboSpan" id="kobo.127.2">We created a breakout shelf in </span><a href="B18001_07.xhtml#_idTextAnchor139"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.128.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.129.1">, </span><em class="italic"><span class="koboSpan" id="kobo.130.1">Planning and Shopping for More Devices</span></em><span class="koboSpan" id="kobo.131.1">, for </span><span class="No-Break"><span class="koboSpan" id="kobo.132.1">this purpose.</span></span></p>
<p><span class="koboSpan" id="kobo.133.1">The following photo shows how the headers should </span><span class="No-Break"><span class="koboSpan" id="kobo.134.1">be attached:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer144">
<span class="koboSpan" id="kobo.135.1"><img alt="Figure 9.3 – Adafruit Bluetooth LE UART Friend with headers " src="image/Figure_9.03_B18001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.136.1">Figure 9.3 – Adafruit Bluetooth LE UART Friend with headers</span></p>
<p><span class="koboSpan" id="kobo.137.1">The previous figure shows the device with the headers. </span><span class="koboSpan" id="kobo.137.2">They should be soldered so they are standing above the pin names, facing the same way as the switch. </span><span class="koboSpan" id="kobo.137.3">The switch should be in </span><span class="No-Break"><span class="koboSpan" id="kobo.138.1">UART mode.</span></span></p>
<p><span class="koboSpan" id="kobo.139.1">We want the attachment to be good enough not to slide around or stick out awkwardly due to cable tension. </span><span class="koboSpan" id="kobo.139.2">You could make a more permanent connection by drilling the appropriate holes in the shelf, but a convenient way for quick prototype platforms is to use Velcro (hook and loop) dots. </span><span class="koboSpan" id="kobo.139.3">Look at the </span><span class="No-Break"><span class="koboSpan" id="kobo.140.1">following photo:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer145">
<span class="koboSpan" id="kobo.141.1"><img alt="Figure 9.4 – Bluefruit module Velcro connection " src="image/Figure_9.04_B18001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.142.1">Figure 9.4 – Bluefruit module Velcro connection</span></p>
<p><span class="koboSpan" id="kobo.143.1">The previous photo shows the Bluetooth breakout module with a Velcro dot ready to attach to the Velcro dot already attached to the </span><span class="No-Break"><span class="koboSpan" id="kobo.144.1">robot’s shelf.</span></span></p>
<p><span class="koboSpan" id="kobo.145.1">The Velcro gives us a convenient way to attach/detach the module without it </span><span class="No-Break"><span class="koboSpan" id="kobo.146.1">sliding off.</span></span></p>
<p><span class="koboSpan" id="kobo.147.1">Next, we need to wire the Bluetooth breakout into Raspberry </span><span class="No-Break"><span class="koboSpan" id="kobo.148.1">Pi Pico.</span></span></p>
<h2 id="_idParaDest-194"><a id="_idTextAnchor195"/><span class="koboSpan" id="kobo.149.1">Wiring the Bluetooth breakout to Raspberry Pi Pico</span></h2>
<p><span class="koboSpan" id="kobo.150.1">Wiring the Adafruit Bluefruit LE UART Friend module requires only five wires. </span><span class="koboSpan" id="kobo.150.2">The following photo shows the connections you </span><span class="No-Break"><span class="koboSpan" id="kobo.151.1">will need:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer146">
<span class="koboSpan" id="kobo.152.1"><img alt="Figure 9.5 – Connecting the Bluefruit LE module to Pico " src="image/Figure_9.05_B18001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.153.1">Figure 9.5 – Connecting the Bluefruit LE module to Pico</span></p>
<p><span class="koboSpan" id="kobo.154.1">The preceding </span><a id="_idIndexMarker528"/><span class="koboSpan" id="kobo.155.1">diagram shows, as a schematic, the connection between the Bluefruit module and Raspberry </span><span class="No-Break"><span class="koboSpan" id="kobo.156.1">Pi Pico.</span></span></p>
<p><span class="koboSpan" id="kobo.157.1">First, connect the module to power and ground, with the VIN going to 3.3V power. </span><span class="koboSpan" id="kobo.157.2">Next, the CTS pin needs to be connected to ground to send and receive data via UART. </span><span class="koboSpan" id="kobo.157.3">The next figure shows how the TX and RX </span><span class="No-Break"><span class="koboSpan" id="kobo.158.1">pins interact:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer147">
<span class="koboSpan" id="kobo.159.1"><img alt="Figure 9.6 – Transmit and receive pins " src="image/Figure_9.06_B18001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.160.1">Figure 9.6 – Transmit and receive pins</span></p>
<p><span class="koboSpan" id="kobo.161.1">Pay close attention to the transmit and receive pins (shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.162.1">Figure 9</span></em></span><em class="italic"><span class="koboSpan" id="kobo.163.1">.5</span></em><span class="koboSpan" id="kobo.164.1">) on the UART. </span><span class="koboSpan" id="kobo.164.2">TX (transmit) on one device always goes to RX (receive) on the other. </span><span class="koboSpan" id="kobo.164.3">The most common wiring failure is to confuse </span><span class="No-Break"><span class="koboSpan" id="kobo.165.1">these pins.</span></span></p>
<p><span class="koboSpan" id="kobo.166.1">Connect </span><a id="_idIndexMarker529"/><span class="koboSpan" id="kobo.167.1">the RXI (receive input) pin on the Bluefruit to PIN12, the TX (transmit) pin 12 on Pico, and TXD (transmit data) from Bluefruit to the RX pin 13 </span><span class="No-Break"><span class="koboSpan" id="kobo.168.1">on Pico.</span></span></p>
<p><span class="koboSpan" id="kobo.169.1">You should have now made five connections. </span><span class="koboSpan" id="kobo.169.2">The Bluetooth LE device is ready to turn on. </span><span class="koboSpan" id="kobo.169.3">Let’s try some code to connect to it </span><span class="No-Break"><span class="koboSpan" id="kobo.170.1">over UART.</span></span></p>
<h2 id="_idParaDest-195"><a id="_idTextAnchor196"/><span class="koboSpan" id="kobo.171.1">Connecting to the Bluefruit LE device with UART</span></h2>
<p><span class="koboSpan" id="kobo.172.1">Now we have the board connected and a smartphone ready to talk to it, how can we get our </span><a id="_idIndexMarker530"/><span class="koboSpan" id="kobo.173.1">Raspberry Pi Pico to communicate? </span><span class="koboSpan" id="kobo.173.2">Let’s start by making a Hello </span><span class="No-Break"><span class="koboSpan" id="kobo.174.1">Bluetooth app.</span></span></p>
<p><span class="koboSpan" id="kobo.175.1">Create a folder named </span><strong class="source-inline"><span class="koboSpan" id="kobo.176.1">bluetooth-hello-world</span></strong><span class="koboSpan" id="kobo.177.1">. </span><span class="koboSpan" id="kobo.177.2">In a slight departure from our previous examples, we can name the main file </span><strong class="source-inline"><span class="koboSpan" id="kobo.178.1">code.py</span></strong><span class="koboSpan" id="kobo.179.1">, and we only need to drag and drop the content of our example folders onto the </span><span class="No-Break"><span class="koboSpan" id="kobo.180.1">CircuitPy volume.</span></span></p>
<p><span class="koboSpan" id="kobo.181.1">We start </span><strong class="source-inline"><span class="koboSpan" id="kobo.182.1">bluetooth-hello-world/code.py</span></strong><span class="koboSpan" id="kobo.183.1"> with imports for the board, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.184.1">busio</span></strong><span class="koboSpan" id="kobo.185.1">, which has code for the </span><span class="No-Break"><span class="koboSpan" id="kobo.186.1">UART bus:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.187.1">
import board
import busio</span></pre>
<p><span class="koboSpan" id="kobo.188.1">We then use the IO pins from </span><strong class="source-inline"><span class="koboSpan" id="kobo.189.1">board</span></strong><span class="koboSpan" id="kobo.190.1"> to create a </span><span class="No-Break"><span class="koboSpan" id="kobo.191.1">UART object:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.192.1">
uart = busio.UART(board.GP12, board.GP13, baudrate=9600)</span></pre>
<p><span class="koboSpan" id="kobo.193.1">Note that we could have multiple UARTs on different pin combinations for other sensors and devices. </span><span class="koboSpan" id="kobo.193.2">We have specified the </span><strong class="bold"><span class="koboSpan" id="kobo.194.1">baud rate</span></strong><span class="koboSpan" id="kobo.195.1">, the rate at which the signal changes per second. </span><strong class="source-inline"><span class="koboSpan" id="kobo.196.1">9600</span></strong><span class="koboSpan" id="kobo.197.1"> is the default for this device, as specified in </span><span class="No-Break"><span class="koboSpan" id="kobo.198.1">its datasheet.</span></span></p>
<p><span class="koboSpan" id="kobo.199.1">We can use this in a loop to check for any input – this is how we know something </span><span class="No-Break"><span class="koboSpan" id="kobo.200.1">is connected:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.201.1">
while True:
    if uart.read(32) is not None:
        uart.write("Hello, Bluetooth World!\n".encode())</span></pre>
<p><span class="koboSpan" id="kobo.202.1">In every loop, we try reading up to 32 bytes. </span><span class="koboSpan" id="kobo.202.2">If we get anything (it’s not showing </span><strong class="source-inline"><span class="koboSpan" id="kobo.203.1">None</span></strong><span class="koboSpan" id="kobo.204.1">), then we </span><a id="_idIndexMarker531"/><span class="koboSpan" id="kobo.205.1">respond with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.206.1">hello</span></strong><span class="koboSpan" id="kobo.207.1"> message. </span><span class="koboSpan" id="kobo.207.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.208.1">uart.write</span></strong><span class="koboSpan" id="kobo.209.1"> method sends bytes, not strings, so we must encode the string to send it. </span><span class="koboSpan" id="kobo.209.2">Also, note the </span><strong class="source-inline"><span class="koboSpan" id="kobo.210.1">\n</span></strong><span class="koboSpan" id="kobo.211.1"> character at the end – this is a new line in </span><span class="No-Break"><span class="koboSpan" id="kobo.212.1">the output.</span></span></p>
<p><span class="koboSpan" id="kobo.213.1">Copy this over to Pico, and it will now be running, waiting for something to connect. </span><span class="koboSpan" id="kobo.213.2">So, let’s connect something to our Pico via </span><span class="No-Break"><span class="koboSpan" id="kobo.214.1">Bluetooth LE!</span></span></p>
<h2 id="_idParaDest-196"><a id="_idTextAnchor197"/><span class="koboSpan" id="kobo.215.1">Connecting a smartphone</span></h2>
<p><span class="koboSpan" id="kobo.216.1">A smartphone makes a great client to connect to the robot and see what is going on. </span><span class="koboSpan" id="kobo.216.2">You can </span><a id="_idIndexMarker532"/><span class="koboSpan" id="kobo.217.1">use an Android/iOS smartphone to connect to the Bluefruit by finding the Bluefruit LE Connect app on the app store appropriate to </span><span class="No-Break"><span class="koboSpan" id="kobo.218.1">that phone.</span></span></p>
<p><span class="koboSpan" id="kobo.219.1">This app is free. </span><span class="koboSpan" id="kobo.219.2">Alternatives are available at </span><a href="https://learn.adafruit.com/introducing-the-adafruit-bluefruit-le-uart-friend/software-resources"><span class="koboSpan" id="kobo.220.1">https://learn.adafruit.com/introducing-the-adafruit-bluefruit-le-uart-friend/software-resources</span></a><span class="koboSpan" id="kobo.221.1">, including desktop apps with </span><span class="No-Break"><span class="koboSpan" id="kobo.222.1">similar functionality.</span></span></p>
<p><span class="koboSpan" id="kobo.223.1">Load the Bluefruit LE Connect app. </span><span class="koboSpan" id="kobo.223.2">The following screenshots show what </span><span class="No-Break"><span class="koboSpan" id="kobo.224.1">you’ll see:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer148">
<span class="koboSpan" id="kobo.225.1"><img alt=" Figure 9.7 – Connecting to Bluetooth LE UART devices " src="image/Figure_9.07_B18001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.226.1"> Figure 9.7 – Connecting to Bluetooth LE UART devices</span></p>
<p><span class="koboSpan" id="kobo.227.1">In the preceding screenshots, the panel on the left shows the app. </span><span class="koboSpan" id="kobo.227.2">With your robot powered </span><a id="_idIndexMarker533"/><span class="koboSpan" id="kobo.228.1">on and the Adafruit Bluefruit LE connected, you should see the device in the list on the app. </span><span class="koboSpan" id="kobo.228.2">There may be many Bluetooth devices; you can turn on the </span><strong class="bold"><span class="koboSpan" id="kobo.229.1">Must have UART Service</span></strong><span class="koboSpan" id="kobo.230.1"> toggle to filter these. </span><span class="koboSpan" id="kobo.230.2">You can then click the </span><strong class="bold"><span class="koboSpan" id="kobo.231.1">Connect</span></strong><span class="koboSpan" id="kobo.232.1"> button to connect to </span><span class="No-Break"><span class="koboSpan" id="kobo.233.1">the device.</span></span></p>
<p><span class="koboSpan" id="kobo.234.1">When doing so, you should see a solid blue light on the Bluefruit board on the robot. </span><span class="koboSpan" id="kobo.234.2">You will also see the screen on the right. </span><span class="koboSpan" id="kobo.234.3">Bluefruit LE Connect may ask you to perform an update on the Bluetooth device; if so, please follow the onscreen instructions and accept this before proceeding. </span><span class="koboSpan" id="kobo.234.4">This may take a </span><span class="No-Break"><span class="koboSpan" id="kobo.235.1">short while.</span></span></p>
<p><span class="koboSpan" id="kobo.236.1">Click the </span><strong class="bold"><span class="koboSpan" id="kobo.237.1">UART</span></strong><span class="koboSpan" id="kobo.238.1"> button in the menu to send and receive data. </span><span class="koboSpan" id="kobo.238.2">You should see screens like those shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.239.1">following screenshot:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer149">
<span class="koboSpan" id="kobo.240.1"><img alt="Figure 9.8 – Interacting over Bluetooth UART " src="image/Figure_9.08_B18001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.241.1">Figure 9.8 – Interacting over Bluetooth UART</span></p>
<p><span class="koboSpan" id="kobo.242.1">The UART </span><a id="_idIndexMarker534"/><span class="koboSpan" id="kobo.243.1">screen, shown in the preceding screenshot, lets you interact with and see output from the module. </span><span class="koboSpan" id="kobo.243.2">The left panel shows me typing </span><strong class="source-inline"><span class="koboSpan" id="kobo.244.1">hello</span></strong><span class="koboSpan" id="kobo.245.1">. </span><span class="koboSpan" id="kobo.245.2">Try this yourself and hit the </span><strong class="bold"><span class="koboSpan" id="kobo.246.1">Send</span></strong><span class="koboSpan" id="kobo.247.1"> button to send data to the module – our code will respond when you send something </span><span class="No-Break"><span class="koboSpan" id="kobo.248.1">to it.</span></span></p>
<p><span class="koboSpan" id="kobo.249.1">The right panel shows the robot responding with the message. </span><span class="koboSpan" id="kobo.249.2">It may take around a second to respond here. </span><span class="koboSpan" id="kobo.249.3">It may send the message twice if you send more than </span><span class="No-Break"><span class="koboSpan" id="kobo.250.1">32 characters.</span></span></p>
<p><span class="koboSpan" id="kobo.251.1">You should </span><a id="_idIndexMarker535"/><span class="koboSpan" id="kobo.252.1">now be in contact with the module. </span><span class="koboSpan" id="kobo.252.2">If not, try the following </span><span class="No-Break"><span class="koboSpan" id="kobo.253.1">troubleshooting steps.</span></span></p>
<h2 id="_idParaDest-197"><a id="_idTextAnchor198"/><span class="koboSpan" id="kobo.254.1">Troubleshooting the Bluefruit module</span></h2>
<p><span class="koboSpan" id="kobo.255.1">The </span><a id="_idIndexMarker536"/><span class="koboSpan" id="kobo.256.1">following should get you up </span><span class="No-Break"><span class="koboSpan" id="kobo.257.1">and running:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.258.1">When it is powered up, there should be a red light on the Bluefruit module. </span><span class="koboSpan" id="kobo.258.2">If not, disconnect the power immediately and verify the power (3.3V) and </span><span class="No-Break"><span class="koboSpan" id="kobo.259.1">ground wiring.</span></span></li>
<li><span class="koboSpan" id="kobo.260.1">You should see a solid blue light when you connect to the Bluefruit device from the smartphone. </span><span class="koboSpan" id="kobo.260.2">If not, verify that you have connected to the </span><span class="No-Break"><span class="koboSpan" id="kobo.261.1">correct device.</span></span></li>
<li><span class="koboSpan" id="kobo.262.1">If you cannot see the </span><strong class="source-inline"><span class="koboSpan" id="kobo.263.1">Hello, Bluetooth World!</span></strong><span class="koboSpan" id="kobo.264.1"> message, please verify that the TX and RX wiring is correct; reversing them is a common issue with </span><span class="No-Break"><span class="koboSpan" id="kobo.265.1">the wiring.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.266.1">You should now have this module connected and able to send data from the robot to a listening device. </span><span class="koboSpan" id="kobo.266.2">Let’s make use of this to send </span><span class="No-Break"><span class="koboSpan" id="kobo.267.1">sensor data.</span></span></p>
<h1 id="_idParaDest-198"><a id="_idTextAnchor199"/><span class="koboSpan" id="kobo.268.1">Getting sensor data over Bluetooth LE on Raspberry Pi Pico</span></h1>
<p><span class="koboSpan" id="kobo.269.1">So </span><a id="_idIndexMarker537"/><span class="koboSpan" id="kobo.270.1">far, you’ve tested </span><a id="_idIndexMarker538"/><span class="koboSpan" id="kobo.271.1">the sensor-based examples, seeing </span><a id="_idIndexMarker539"/><span class="koboSpan" id="kobo.272.1">their output in the console by connecting your laptop to it. </span><span class="koboSpan" id="kobo.272.2">However, building on our </span><strong class="source-inline"><span class="koboSpan" id="kobo.273.1">hello world</span></strong><span class="koboSpan" id="kobo.274.1"> example and the distance sensing in </span><a href="B18001_08.xhtml#_idTextAnchor166"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.275.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.276.1">, </span><em class="italic"><span class="koboSpan" id="kobo.277.1">Sensing Distances to Detect Objects with Pico</span></em><span class="koboSpan" id="kobo.278.1">, we can not only see the sensor output over UART as text but also plot in in a graph. </span><span class="koboSpan" id="kobo.278.2">So, let’s get </span><span class="No-Break"><span class="koboSpan" id="kobo.279.1">into it.</span></span></p>
<p><span class="koboSpan" id="kobo.280.1">We’ll put this code in a folder named </span><strong class="source-inline"><span class="koboSpan" id="kobo.281.1">bluetooth-distance-sensors</span></strong><span class="koboSpan" id="kobo.282.1">. </span><span class="koboSpan" id="kobo.282.2">Copy in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.283.1">robot.py</span></strong><span class="koboSpan" id="kobo.284.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.285.1">pio_encoder.py</span></strong><span class="koboSpan" id="kobo.286.1"> files. </span><span class="koboSpan" id="kobo.286.2">We will add </span><strong class="source-inline"><span class="koboSpan" id="kobo.287.1">code.py</span></strong><span class="koboSpan" id="kobo.288.1">. </span><span class="koboSpan" id="kobo.288.2">Let’s start with the imports, combining the sensors and </span><span class="No-Break"><span class="koboSpan" id="kobo.289.1">bus setup:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.290.1">
import board
import time
import busio
import robot
uart = busio.UART(board.GP12, board.GP13, baudrate=9600)</span></pre>
<p><span class="koboSpan" id="kobo.291.1">With </span><a id="_idIndexMarker540"/><span class="koboSpan" id="kobo.292.1">the UART now </span><a id="_idIndexMarker541"/><span class="koboSpan" id="kobo.293.1">prepared, we can </span><a id="_idIndexMarker542"/><span class="koboSpan" id="kobo.294.1">prepare </span><span class="No-Break"><span class="koboSpan" id="kobo.295.1">the sensors:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.296.1">
robot.left_distance.distance_mode = 1
robot.left_distance.start_ranging()
robot.right_distance.distance_mode = 1
robot.right_distance.start_ranging()</span></pre>
<p><span class="koboSpan" id="kobo.297.1">We’ve set both sensors ranging and in the correct mode. </span><span class="koboSpan" id="kobo.297.2">We can now start a loop and fetch the </span><span class="No-Break"><span class="koboSpan" id="kobo.298.1">sensor data:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.299.1">
while True:
    if robot.left_distance.data_ready and robot.right_distance.data_ready:
        sensor1 = robot.left_distance.distance
        sensor2 = robot.right_distance.distance</span></pre>
<p><span class="koboSpan" id="kobo.300.1">We wait until the data is ready before fetching the distance, and we store the distance from both sensors. </span><span class="koboSpan" id="kobo.300.2">We can now send the data to </span><span class="No-Break"><span class="koboSpan" id="kobo.301.1">the UART:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.302.1">
        uart.write(f"{sensor1},{sensor2}\n".encode())</span></pre>
<p><span class="koboSpan" id="kobo.303.1">We use an f-string to format the data from both sensors into one line, separated by a comma. </span><span class="koboSpan" id="kobo.303.2">We must also include the end-of-line, </span><strong class="source-inline"><span class="koboSpan" id="kobo.304.1">\n</span></strong><span class="koboSpan" id="kobo.305.1">, character again and encode it </span><span class="No-Break"><span class="koboSpan" id="kobo.306.1">into bytes.</span></span></p>
<p><span class="koboSpan" id="kobo.307.1">We </span><a id="_idIndexMarker543"/><span class="koboSpan" id="kobo.308.1">must then ensure </span><a id="_idIndexMarker544"/><span class="koboSpan" id="kobo.309.1">the sensors on the </span><a id="_idIndexMarker545"/><span class="koboSpan" id="kobo.310.1">robot are ready to take </span><span class="No-Break"><span class="koboSpan" id="kobo.311.1">another reading:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.312.1">
        robot.left_distance.clear_interrupt()
        robot.right_distance.clear_interrupt()</span></pre>
<p><span class="koboSpan" id="kobo.313.1">We can wait for a little time before trying again. </span><span class="koboSpan" id="kobo.313.2">Add the following code outside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.314.1">if</span></strong><span class="koboSpan" id="kobo.315.1"> block but inside the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.316.1">while</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.317.1"> loop:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.318.1">
    time.sleep(0.05)</span></pre>
<p><span class="koboSpan" id="kobo.319.1">This sleep completes the code for this example. </span><span class="koboSpan" id="kobo.319.2">As an overview, this loop will read the sensors, send data when it has a reading, and then send this over the UART, and it will sleep for a little time and </span><span class="No-Break"><span class="koboSpan" id="kobo.320.1">go again.</span></span></p>
<p><span class="koboSpan" id="kobo.321.1">If you copy this code to the robot and connect the phone with the </span><strong class="bold"><span class="koboSpan" id="kobo.322.1">UART</span></strong><span class="koboSpan" id="kobo.323.1"> menu option, you will be able to see the two numbers vary as you move things in front of the sensors. </span><span class="koboSpan" id="kobo.323.2">The following screenshot shows </span><span class="No-Break"><span class="koboSpan" id="kobo.324.1">an example:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer150">
<span class="koboSpan" id="kobo.325.1"><img alt="Figure 9.9 – The sensor output as text " src="image/Figure_9.09_B18001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.326.1">Figure 9.9 – The sensor output as text</span></p>
<p><span class="koboSpan" id="kobo.327.1">The </span><a id="_idIndexMarker546"/><span class="koboSpan" id="kobo.328.1">previous screenshot </span><a id="_idIndexMarker547"/><span class="koboSpan" id="kobo.329.1">shows how </span><a id="_idIndexMarker548"/><span class="koboSpan" id="kobo.330.1">the data is output as plain text numbers. </span><span class="koboSpan" id="kobo.330.2">You can disconnect the computer and put the robot on independent battery power, and you should still be able to connect to it and see the </span><span class="No-Break"><span class="koboSpan" id="kobo.331.1">sensor readings.</span></span></p>
<p><span class="koboSpan" id="kobo.332.1">This data feed is great as we have a remote view of the robot. </span><span class="koboSpan" id="kobo.332.2">However, we can now go one better and graph </span><span class="No-Break"><span class="koboSpan" id="kobo.333.1">this data.</span></span></p>
<h2 id="_idParaDest-199"><a id="_idTextAnchor200"/><span class="koboSpan" id="kobo.334.1">Graphing the data</span></h2>
<p><span class="koboSpan" id="kobo.335.1">The phone </span><a id="_idIndexMarker549"/><span class="koboSpan" id="kobo.336.1">app has the built-in ability to graph data in comma-separated format. </span><span class="koboSpan" id="kobo.336.2">We can use this for the output of numeric data to quickly visualize what is </span><span class="No-Break"><span class="koboSpan" id="kobo.337.1">going on.</span></span></p>
<p><span class="koboSpan" id="kobo.338.1">From the UART screen, click on the back button to go back to the options menu for this connection. </span><span class="koboSpan" id="kobo.338.2">Then, click the </span><strong class="bold"><span class="koboSpan" id="kobo.339.1">Plotter</span></strong><span class="koboSpan" id="kobo.340.1"> button to access the </span><span class="No-Break"><span class="koboSpan" id="kobo.341.1">plot mode.</span></span></p>
<p><span class="koboSpan" id="kobo.342.1">The following screenshots show how to </span><span class="No-Break"><span class="koboSpan" id="kobo.343.1">do that:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer151">
<span class="koboSpan" id="kobo.344.1"><img alt=" Figure 9.10 – Enabling graphing " src="image/Figure_9.10_B18001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.345.1"> Figure 9.10 – Enabling graphing</span></p>
<p><span class="koboSpan" id="kobo.346.1">The preceding </span><a id="_idIndexMarker550"/><span class="koboSpan" id="kobo.347.1">screenshots show how to access the graph functionality and an example sensor </span><span class="No-Break"><span class="koboSpan" id="kobo.348.1">data graph.</span></span></p>
<p><span class="koboSpan" id="kobo.349.1">The app will use any comma-separated numeric data, and I’ve tested it with six columns of data so far. </span><span class="koboSpan" id="kobo.349.2">If the output seems patchy, please ensure you allow the app to make an over-the-air update of the Bluetooth device, as this significantly improves </span><span class="No-Break"><span class="koboSpan" id="kobo.350.1">the throughput.</span></span></p>
<p><span class="koboSpan" id="kobo.351.1">We’ve seen how to get robot sensor data and use it to plot what is going on with the sensors. </span><span class="koboSpan" id="kobo.351.2">However, we might also want to use our Bluetooth services to take control of the robot. </span><span class="koboSpan" id="kobo.351.3">Let’s see how in the </span><span class="No-Break"><span class="koboSpan" id="kobo.352.1">next section.</span></span></p>
<h1 id="_idParaDest-200"><a id="_idTextAnchor201"/><span class="koboSpan" id="kobo.353.1">Controlling the robot with Bluetooth LE</span></h1>
<p><span class="koboSpan" id="kobo.354.1">Bluetooth LE </span><a id="_idIndexMarker551"/><span class="koboSpan" id="kobo.355.1">is a two-way medium. </span><span class="koboSpan" id="kobo.355.2">In this section, we’ll </span><a id="_idIndexMarker552"/><span class="koboSpan" id="kobo.356.1">see how to receive data from the UART and, better yet, how to decode that data into control signals. </span><span class="koboSpan" id="kobo.356.2">By the end of this section, you’ll be able to drive your robot with </span><span class="No-Break"><span class="koboSpan" id="kobo.357.1">a smartphone!</span></span></p>
<h2 id="_idParaDest-201"><a id="_idTextAnchor202"/><span class="koboSpan" id="kobo.358.1">Printing what we got</span></h2>
<p><span class="koboSpan" id="kobo.359.1">Before </span><a id="_idIndexMarker553"/><span class="koboSpan" id="kobo.360.1">we try to decode control packets, let’s just make a simple app to echo whatever shows on the Bluefruit UART out onto the Raspberry Pi </span><span class="No-Break"><span class="koboSpan" id="kobo.361.1">Pico console.</span></span></p>
<p><span class="koboSpan" id="kobo.362.1">Put the following code in </span><strong class="source-inline"><span class="koboSpan" id="kobo.363.1">bluetooth-print-incoming/code.py</span></strong><span class="koboSpan" id="kobo.364.1">. </span><span class="koboSpan" id="kobo.364.2">We start by importing and setting up the </span><span class="No-Break"><span class="koboSpan" id="kobo.365.1">UART port:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.366.1">
import board
import busio
uart = busio.UART(board.GP12,board.GP13,baudrate=9600, timeout=0.01)
print("Waiting for bytes on UART...")</span></pre>
<p><span class="koboSpan" id="kobo.367.1">The one difference here is that I’ve added a short timeout. </span><span class="koboSpan" id="kobo.367.2">Without the short timeout, the port will wait a full second for the number of bytes read. </span><span class="koboSpan" id="kobo.367.3">You might have noticed with the Hello world example that it took a second before you got the output, and this will be why. </span><span class="koboSpan" id="kobo.367.4">We want to get control data as soon as possible. </span><span class="koboSpan" id="kobo.367.5">There’s also a </span><strong class="source-inline"><span class="koboSpan" id="kobo.368.1">print</span></strong><span class="koboSpan" id="kobo.369.1"> statement, so we know </span><span class="No-Break"><span class="koboSpan" id="kobo.370.1">it’s ready.</span></span></p>
<p><span class="koboSpan" id="kobo.371.1">Now we have the </span><span class="No-Break"><span class="koboSpan" id="kobo.372.1">main loop:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.373.1">
while True:
    if uart.in_waiting:
        print(uart.read(32))</span></pre>
<p><span class="koboSpan" id="kobo.374.1">This loop reads data from the port. </span><span class="koboSpan" id="kobo.374.2">First, it checks whether there is data waiting, then tries to read up to 32 bytes and immediately prints what we got, then </span><span class="No-Break"><span class="koboSpan" id="kobo.375.1">tries again.</span></span></p>
<p><span class="koboSpan" id="kobo.376.1">If you go back to the </span><strong class="bold"><span class="koboSpan" id="kobo.377.1">UART</span></strong><span class="koboSpan" id="kobo.378.1"> menu option in the phone app, you will be able to type messages on the phone and see them appear in the </span><span class="No-Break"><span class="koboSpan" id="kobo.379.1">Pico console:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer152">
<span class="koboSpan" id="kobo.380.1"><img alt="Figure 9.11 – Echoing incoming Bluetooth UART messages on the Pico console " src="image/Figure_9.11_B18001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.381.1">Figure 9.11 – Echoing incoming Bluetooth UART messages on the Pico console</span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.382.1">Figure 9</span></em></span><em class="italic"><span class="koboSpan" id="kobo.383.1">.11</span></em><span class="koboSpan" id="kobo.384.1"> shows a screenshot of the phone on the left, ready to send a message. </span><span class="koboSpan" id="kobo.384.2">The screenshot </span><a id="_idIndexMarker554"/><span class="koboSpan" id="kobo.385.1">on the right shows the message appearing in the Raspberry Pi Pico console. </span><span class="koboSpan" id="kobo.385.2">Notice the </span><strong class="source-inline"><span class="koboSpan" id="kobo.386.1">b</span></strong><span class="koboSpan" id="kobo.387.1"> prefix. </span><span class="koboSpan" id="kobo.387.2">This prefix means it’s a raw byte message. </span><span class="koboSpan" id="kobo.387.3">We will be able to extract our button data </span><span class="No-Break"><span class="koboSpan" id="kobo.388.1">from this.</span></span></p>
<p><span class="koboSpan" id="kobo.389.1">In the next section, let’s see how the smartphone app can use this </span><span class="No-Break"><span class="koboSpan" id="kobo.390.1">for control.</span></span></p>
<h2 id="_idParaDest-202"><a id="_idTextAnchor203"/><span class="koboSpan" id="kobo.391.1">Button control mode</span></h2>
<p><span class="koboSpan" id="kobo.392.1">On the </span><a id="_idIndexMarker555"/><span class="koboSpan" id="kobo.393.1">phone app, there were several different menu modes for interacting with the robot. </span><span class="koboSpan" id="kobo.393.2">One of these is </span><strong class="bold"><span class="koboSpan" id="kobo.394.1">Controller</span></strong><span class="koboSpan" id="kobo.395.1"> mode. </span><span class="koboSpan" id="kobo.395.2">The following screenshots show how </span><span class="No-Break"><span class="koboSpan" id="kobo.396.1">this looks:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer153">
<span class="koboSpan" id="kobo.397.1"><img alt="Figure 9.12 – Bluefruit app Controller mode " src="image/Figure_9.12_B18001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.398.1">Figure 9.12 – Bluefruit app Controller mode</span></p>
<p><span class="koboSpan" id="kobo.399.1">The screenshots show the controller mode. </span><span class="koboSpan" id="kobo.399.2">The leftmost screenshot shows the initial </span><strong class="bold"><span class="koboSpan" id="kobo.400.1">Controller</span></strong><span class="koboSpan" id="kobo.401.1"> app screen; from this, we pick </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.402.1">Control Pad</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.403.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.404.1">The screenshot </span><a id="_idIndexMarker556"/><span class="koboSpan" id="kobo.405.1">in the middle shows the control pad. </span><span class="koboSpan" id="kobo.405.2">In this screenshot, on the left is a directional pad, and on the right is a set of numeric buttons. </span><span class="koboSpan" id="kobo.405.3">We can send both signals to </span><span class="No-Break"><span class="koboSpan" id="kobo.406.1">the robot.</span></span></p>
<p><span class="koboSpan" id="kobo.407.1">The third, rightmost screenshot shows how the control signals look when printed. </span><span class="koboSpan" id="kobo.407.2">This output looks like some strange text, but that is because it is data encoded into a data </span><strong class="bold"><span class="koboSpan" id="kobo.408.1">packet</span></strong><span class="koboSpan" id="kobo.409.1">. </span><span class="koboSpan" id="kobo.409.2">A packet is </span><a id="_idIndexMarker557"/><span class="koboSpan" id="kobo.410.1">a chunk of data on </span><span class="No-Break"><span class="koboSpan" id="kobo.411.1">a bus.</span></span></p>
<p><span class="koboSpan" id="kobo.412.1">These control signal packets encode the button that changed and whether it was pressed or released. </span><span class="koboSpan" id="kobo.412.2">Try pressing a button now with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.413.1">print-incoming</span></strong><span class="koboSpan" id="kobo.414.1"> app, and you will see a set of control codes. </span><span class="koboSpan" id="kobo.414.2">They aren’t particularly human-readable, so we’ll need to </span><span class="No-Break"><span class="koboSpan" id="kobo.415.1">decode them.</span></span></p>
<p><span class="koboSpan" id="kobo.416.1">Let’s make some code to detect and decode button </span><span class="No-Break"><span class="koboSpan" id="kobo.417.1">control packets.</span></span></p>
<h2 id="_idParaDest-203"><a id="_idTextAnchor204"/><span class="koboSpan" id="kobo.418.1">Decoding button control packets to drive the robot</span></h2>
<p><span class="koboSpan" id="kobo.419.1">Adafruit </span><a id="_idIndexMarker558"/><span class="koboSpan" id="kobo.420.1">has a library for specifically handling and decoding these packets. </span><span class="koboSpan" id="kobo.420.2">Copy the </span><strong class="source-inline"><span class="koboSpan" id="kobo.421.1">adafruit_bluefruit_connect</span></strong><span class="koboSpan" id="kobo.422.1"> folder from the CircuitPython bundle into your Pico </span><span class="No-Break"><span class="koboSpan" id="kobo.423.1">at </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.424.1">CIRCUITY/lib</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.425.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.426.1">We can import this into our code and use it to drive the robot. </span><span class="koboSpan" id="kobo.426.2">Create a folder called </span><strong class="source-inline"><span class="koboSpan" id="kobo.427.1">bluetooth-teleoperation</span></strong><span class="koboSpan" id="kobo.428.1"> on your computer. </span><span class="koboSpan" id="kobo.428.2">Copy the most recent </span><strong class="source-inline"><span class="koboSpan" id="kobo.429.1">robot.py</span></strong><span class="koboSpan" id="kobo.430.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.431.1">pio_encoder.py</span></strong><span class="koboSpan" id="kobo.432.1"> files into this. </span><span class="koboSpan" id="kobo.432.2">We’ll start a </span><strong class="source-inline"><span class="koboSpan" id="kobo.433.1">code.py</span></strong><span class="koboSpan" id="kobo.434.1"> file with </span><span class="No-Break"><span class="koboSpan" id="kobo.435.1">the imports:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.436.1">
import board
import time
import busiofrom adafruit_bluefruit_connect.button_packet
import ButtonPacket
import robot
uart = busio.UART(board.GP12,board.GP13,baudrate=9600, timeout=0.01)</span></pre>
<p><span class="koboSpan" id="kobo.437.1">The imports are mostly familiar, but we’ve added the button packet type so we can decode control pad buttons. </span><span class="koboSpan" id="kobo.437.2">We also set up the UART to </span><span class="No-Break"><span class="koboSpan" id="kobo.438.1">receive data.</span></span></p>
<p><span class="koboSpan" id="kobo.439.1">The keys send a keypress and key release. </span><span class="koboSpan" id="kobo.439.2">What we don’t want is for the robot to receive nothing from the phone and keep driving, so we will have a stop time. </span><span class="koboSpan" id="kobo.439.3">We are also going to set an overall </span><span class="No-Break"><span class="koboSpan" id="kobo.440.1">driving speed:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.441.1">
stop_at = 0
speed = 0.8</span></pre>
<p><span class="koboSpan" id="kobo.442.1">We can now get into the app’s main loop. </span><span class="koboSpan" id="kobo.442.2">The first thing we’ll do is check for waiting data, and if there is some, decode it as </span><span class="No-Break"><span class="koboSpan" id="kobo.443.1">button presses:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.444.1">
while True:
  if uart.in_waiting:
    packet = ButtonPacket.from_stream(uart)</span></pre>
<p><span class="koboSpan" id="kobo.445.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.446.1">from_stream</span></strong><span class="koboSpan" id="kobo.447.1"> function will decode a button packet directly from the UART. </span><span class="koboSpan" id="kobo.447.2">It frees us from considering the byte size of that packet by trying to read the right number </span><span class="No-Break"><span class="koboSpan" id="kobo.448.1">of bytes.</span></span></p>
<p><span class="koboSpan" id="kobo.449.1">If we have a packet, we can check whether the button was pressed or released and ensure we stop the robot if it </span><span class="No-Break"><span class="koboSpan" id="kobo.450.1">is released:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.451.1">
    if packet:
      if not packet.pressed:
          robot.stop()
      elif packet.button == ButtonPacket.UP:
        robot.set_left(speed)
        robot.set_right(speed)
      elif packet.button == ButtonPacket.DOWN:
        robot.set_left(-speed)
        robot.set_right(-speed)
      elif packet.button == ButtonPacket.LEFT:
        robot.set_left(-speed)
        robot.set_right(speed)
      elif packet.button == ButtonPacket.RIGHT:
        robot.set_left(speed)
        robot.set_right(-speed)</span></pre>
<p><span class="koboSpan" id="kobo.452.1">The preceding </span><a id="_idIndexMarker559"/><span class="koboSpan" id="kobo.453.1">code first checks whether you’ve pressed the button. </span><span class="koboSpan" id="kobo.453.2">We then started matching the button code with different buttons and changing motor speeds to drive or turn depending on which </span><span class="No-Break"><span class="koboSpan" id="kobo.454.1">you pressed.</span></span></p>
<p><span class="koboSpan" id="kobo.455.1">Next, we need to consider timeouts. </span><span class="koboSpan" id="kobo.455.2">If we have pressed a button, we should reset the timeout, and in the outer loop, we should check </span><span class="No-Break"><span class="koboSpan" id="kobo.456.1">the timeout:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.457.1">
      stop_at = time.time() + 3
  if time.time() &gt; stop_at:
    robot.stop()</span></pre>
<p><span class="koboSpan" id="kobo.458.1">At the end of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.459.1">if</span></strong><span class="koboSpan" id="kobo.460.1"> packet block, we add 3 seconds to the current time; this will be when we time out. </span><span class="koboSpan" id="kobo.460.2">Then, at the bottom of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.461.1">while</span></strong><span class="koboSpan" id="kobo.462.1"> loop, if we’ve passed the </span><strong class="source-inline"><span class="koboSpan" id="kobo.463.1">stop_at</span></strong><span class="koboSpan" id="kobo.464.1"> time, we stop </span><span class="No-Break"><span class="koboSpan" id="kobo.465.1">the robot.</span></span></p>
<p><span class="koboSpan" id="kobo.466.1">Copy this over to CircuitPython on Pico, and you will now be able to use the buttons to drive the robot. </span><span class="koboSpan" id="kobo.466.2">You can disconnect it from the computer, turn on battery power, and </span><span class="No-Break"><span class="koboSpan" id="kobo.467.1">drive it.</span></span></p>
<p><span class="koboSpan" id="kobo.468.1">You can </span><a id="_idIndexMarker560"/><span class="koboSpan" id="kobo.469.1">now use control pad buttons to drive the robot. </span><span class="koboSpan" id="kobo.469.2">Press and hold a button and it will drive for up to 3 seconds without a further keypress; you’ll need to press multiple times to drive further. </span><span class="koboSpan" id="kobo.469.3">This 3-second timeout is a compromise between ensuring it doesn’t run away and making it fun </span><span class="No-Break"><span class="koboSpan" id="kobo.470.1">to drive.</span></span></p>
<h2 id="_idParaDest-204"><a id="_idTextAnchor205"/><span class="koboSpan" id="kobo.471.1">Troubleshooting</span></h2>
<p><span class="koboSpan" id="kobo.472.1">If the </span><a id="_idIndexMarker561"/><span class="koboSpan" id="kobo.473.1">robot is not responding and you have been through the previous examples, try this </span><span class="No-Break"><span class="koboSpan" id="kobo.474.1">troubleshooting method.</span></span></p>
<p><span class="koboSpan" id="kobo.475.1">In code like this, adding </span><strong class="source-inline"><span class="koboSpan" id="kobo.476.1">print</span></strong><span class="koboSpan" id="kobo.477.1"> statements will help. </span><span class="koboSpan" id="kobo.477.2">When you have the robot connected to the computer, you can just use </span><strong class="source-inline"><span class="koboSpan" id="kobo.478.1">print</span></strong><span class="koboSpan" id="kobo.479.1">. </span><span class="koboSpan" id="kobo.479.2">Otherwise, use </span><strong class="source-inline"><span class="koboSpan" id="kobo.480.1">uart.write(message.encode())</span></strong><span class="koboSpan" id="kobo.481.1">. </span><span class="koboSpan" id="kobo.481.2">Try adding these before the </span><strong class="source-inline"><span class="koboSpan" id="kobo.482.1">while</span></strong><span class="koboSpan" id="kobo.483.1"> loop starts and in places where the code </span><span class="No-Break"><span class="koboSpan" id="kobo.484.1">handles buttons.</span></span></p>
<p><span class="koboSpan" id="kobo.485.1">By printing before the </span><strong class="source-inline"><span class="koboSpan" id="kobo.486.1">while</span></strong><span class="koboSpan" id="kobo.487.1"> loop, we know our code started (if not, we can connect it to the computer to look for error messages). </span><span class="koboSpan" id="kobo.487.2">Likewise, we can tell that button signals are being decoded by printing when it </span><span class="No-Break"><span class="koboSpan" id="kobo.488.1">handles buttons.</span></span></p>
<p><span class="koboSpan" id="kobo.489.1">Printing like this lets us narrow down where the problem is. </span><span class="koboSpan" id="kobo.489.2">By checking the lines around any output we fail to see, we can see what might be incorrect or whether there is wiring </span><span class="No-Break"><span class="koboSpan" id="kobo.490.1">to verify.</span></span></p>
<p><span class="koboSpan" id="kobo.491.1">You should now have a </span><span class="No-Break"><span class="koboSpan" id="kobo.492.1">remote-controllable robot!</span></span></p>
<h1 id="_idParaDest-205"><a id="_idTextAnchor206"/><span class="koboSpan" id="kobo.493.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.494.1">In this chapter, we have seen how to hook a Bluefruit LE transceiver to our robot and then use it to send and receive data. </span><span class="koboSpan" id="kobo.494.2">We’ve seen the robot data go to a smartphone and data go from a smartphone back to Pico on </span><span class="No-Break"><span class="koboSpan" id="kobo.495.1">the robot.</span></span></p>
<p><span class="koboSpan" id="kobo.496.1">We then took this up a level and sent formatted data to plot sensor information on the phone, allowing us to remotely visualize the </span><span class="No-Break"><span class="koboSpan" id="kobo.497.1">robot’s state.</span></span></p>
<p><span class="koboSpan" id="kobo.498.1">Finally, we used the smartphone app to control and drive the robot. </span><span class="koboSpan" id="kobo.498.2">In the next chapter, we will look at the PID algorithm, a neat way to tie sensor data and outputs together in a feedback loop, and we’ll use our new remote data plotting ability to </span><span class="No-Break"><span class="koboSpan" id="kobo.499.1">tune it!</span></span></p>
<h1 id="_idParaDest-206"><a id="_idTextAnchor207"/><span class="koboSpan" id="kobo.500.1">Exercises</span></h1>
<p><span class="koboSpan" id="kobo.501.1">These exercises let you extend the functionality of your robot code and deepen your understanding of </span><span class="No-Break"><span class="koboSpan" id="kobo.502.1">the topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.503.1">In the Bluetooth control app, there are four numeric buttons. </span><span class="koboSpan" id="kobo.503.2">Could you extend the control program to use these to control the </span><span class="No-Break"><span class="koboSpan" id="kobo.504.1">robot’s speed?</span></span></li>
<li><span class="koboSpan" id="kobo.505.1">The Bluetooth control pad app also has a little window to show messages. </span><span class="koboSpan" id="kobo.505.2">Try sending messages back from the robot code to the app to show in </span><span class="No-Break"><span class="koboSpan" id="kobo.506.1">this window.</span></span></li>
<li><span class="koboSpan" id="kobo.507.1">Could you use the plotting code with the encoder counts and plot these? </span><span class="koboSpan" id="kobo.507.2">Perhaps divide their total counts by elapsed time in the code, or reset the encoder counts and reread them to plot a rate </span><span class="No-Break"><span class="koboSpan" id="kobo.508.1">per second.</span></span></li>
</ul>
<h1 id="_idParaDest-207"><a id="_idTextAnchor208"/><span class="koboSpan" id="kobo.509.1">Further reading</span></h1>
<ul>
<li><span class="koboSpan" id="kobo.510.1">Adafruit’s great support for the Bluefruit UART LE Friend includes a product page with dimensions – </span><a href="https://www.adafruit.com/product/2479"><span class="koboSpan" id="kobo.511.1">https://www.adafruit.com/product/2479</span></a><span class="koboSpan" id="kobo.512.1">. </span><span class="koboSpan" id="kobo.512.2">In addition, they have content on the Adafruit learn website at </span><a href="https://learn.adafruit.com/introducing-the-adafruit-bluefruit-le-uart-friend/"><span class="koboSpan" id="kobo.513.1">https://learn.adafruit.com/introducing-the-adafruit-bluefruit-le-uart-friend/</span></a><span class="koboSpan" id="kobo.514.1">, including material on more ways to connect and use the device, complete datasheets and specifications, along with </span><span class="No-Break"><span class="koboSpan" id="kobo.515.1">additional software.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.516.1">Adafruit also has a </span><strong class="source-inline"><span class="koboSpan" id="kobo.517.1">#help-with-radio</span></strong><span class="koboSpan" id="kobo.518.1"> channel on their Discord with a community that specifically helps with problems, questions, and ideas about their </span><span class="No-Break"><span class="koboSpan" id="kobo.519.1">transceiver modules.</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.520.1">For further information on Bluetooth LE, check out </span><em class="italic"><span class="koboSpan" id="kobo.521.1">Building Bluetooth Low Energy Systems</span></em><span class="koboSpan" id="kobo.522.1"> by Muhammad Usama bin Aftab. </span><span class="koboSpan" id="kobo.522.2">This book has a detailed dive into wireless network communication systems suitable for use in </span><strong class="bold"><span class="koboSpan" id="kobo.523.1">Internet of Things</span></strong><span class="koboSpan" id="kobo.524.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.525.1">IoT</span></strong><span class="koboSpan" id="kobo.526.1">). </span><span class="koboSpan" id="kobo.526.2">IoT concepts translate well </span><span class="No-Break"><span class="koboSpan" id="kobo.527.1">into robotics.</span></span></li>
</ul>
</div>


<div class="Content" id="_idContainer155">
<h1 id="_idParaDest-208"><a id="_idTextAnchor209"/><span class="koboSpan" id="kobo.1.1">Part 3: Adding More Robotic Behaviors to Raspberry Pi Pico</span></h1>
<p><span class="koboSpan" id="kobo.2.1">Now that we’ve seen some sensors, we can add more interesting robot behaviors. </span><span class="koboSpan" id="kobo.2.2">We will learn robot algorithms to make more use of the distance sensors and encoders. </span><span class="koboSpan" id="kobo.2.3">Then we introduce the Inertial Measurement unit. </span><span class="koboSpan" id="kobo.2.4">Finally, we will look at how to use the sensors to locate a robot in a known space.</span></p>
<p><span class="koboSpan" id="kobo.3.1">This part contains the following chapters:</span></p>
<ul>
<li><a href="B18001_10.xhtml#_idTextAnchor210"><em class="italic"><span class="koboSpan" id="kobo.4.1">Chapter 10</span></em></a><span class="koboSpan" id="kobo.5.1">, </span><em class="italic"><span class="koboSpan" id="kobo.6.1">Using the PID Algorithm to Follow Walls</span></em></li>
<li><a href="B18001_11.xhtml#_idTextAnchor233"><em class="italic"><span class="koboSpan" id="kobo.7.1">Chapter 11</span></em></a><span class="koboSpan" id="kobo.8.1">, </span><em class="italic"><span class="koboSpan" id="kobo.9.1">Controlling Motion with Encoders on Raspberry Pi Pico</span></em></li>
<li><a href="B18001_12.xhtml#_idTextAnchor252"><em class="italic"><span class="koboSpan" id="kobo.10.1">Chapter 12</span></em></a><span class="koboSpan" id="kobo.11.1">, </span><em class="italic"><span class="koboSpan" id="kobo.12.1">Detecting Orientation with an IMU on Raspberry Pi Pico</span></em></li>
<li><a href="B18001_13.xhtml#_idTextAnchor274"><em class="italic"><span class="koboSpan" id="kobo.13.1">Chapter 13</span></em></a><span class="koboSpan" id="kobo.14.1">, </span><em class="italic"><span class="koboSpan" id="kobo.15.1">Determining Position using Monte Carlo Localization</span></em></li>
<li><a href="B18001_14.xhtml#_idTextAnchor302"><em class="italic"><span class="koboSpan" id="kobo.16.1">Chapter 14</span></em></a><span class="koboSpan" id="kobo.17.1">, </span><em class="italic"><span class="koboSpan" id="kobo.18.1">Continuing Your Journey – Your Next Robot</span></em></li>
</ul>
</div>
</body></html>