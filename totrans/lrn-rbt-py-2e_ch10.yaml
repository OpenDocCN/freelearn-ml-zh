- en: Assessments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Chapter 1, Getting Started with the Robot Operating System
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are the three main features of ROS:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Message passing interface to communicate with different programs
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Off-the-shelf robotics algorithm to make the robot prototyping faster
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Software tools to visualize robot data and debugging
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The different levels of concepts in ROS are the ROS Filesystem level, ROS Computation
    Graph Level, and ROS Community Level.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Catkin build system is built using CMake and Python scripts. This tool helps
    us build the ROS packages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The ROS topic is a named bus in which one node can communicate to another node.
    The kind of message type used in the topics are ROS messages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The different concepts of the ROS computation graph are ROS Nodes, ROS Topics,
    ROS Messages, ROS Master, ROS Services, and
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: ROS Bags.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The ROS Master act as a mediator program to connect two ROS nodes to start communicating
    with each other.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The important features of Gazebo are:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Dynamic simulation: It includes physics engine like ODE, Bullet, Simbody and
    Dart'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Advanced 3D graphics: It uses OGRE framework to create high-quality lighting,
    shadows, and textures'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Plugin support: This will allow developers to add new robot, sensors, and environmental
    control'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'TCP/IP Transport: Controlling Gazebo using socket-based message passing interface'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Chapter 2, Understanding the Basics of Differential Robots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Holonomic robots can freely move in any direction and the controllable degrees
    of freedom is equal to the total degrees of freedom. Omni wheel-based robots are
    an example of holonomic robots. Nonholonomic robots have constraints on its motion,
    so controllable degrees of freedom will not be equal to the total degrees of freedom.
    Differential driver configuration is an example of nonholonomic configuration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Robot kinematics deals with the motion of the robot without considering the
    mass and inertia, whereas robot dynamics is the relationship between mass and
    inertia properties, motion, and associated torques.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: ICC stands for Instantaneous Center of Curvature, which is an imaginary point
    on the robot wheel axis around which the robot is rotated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is the process of finding the robot's current position from the wheel velocity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finding the wheel velocity to reach a goal position.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 3, Modeling the Differential Drive Robot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Robot modeling is the process of creating the 2D and 3D representation of robot
    having all the parameters of the robot, which includes kinematic and dynamic parameters
    of the robot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The 2D model mainly includes the exact dimension of robot parts, which helps
    us compute the kinematics of the robot as well as helps  manufacture robot parts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The 3D model of the robot is an exact replica of robot hardware having all parameters
    of the physical robot designed using a CAD software. This is used for creating
    robot simulation and 3D printing parts of the robot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating a 3D model using Python scripting is much easier and accurate than
    manual modeling if you know the Blender scripting APIs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: URDF is the 3D robot model representation of robot in ROS. It is having kinematic
    and dynamic parameters of the robot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 4, Simulating a Differential Drive Robot Using ROS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sensor modeling in Gazebo can be done using Gazebo plugins. The sensor model
    can be written using C++, which can be plugged in to the Gazebo simulator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: ROS is interfaced to Gazebo using Gazebo ROS plugin. When we load this plugin
    into Gazebo, we can able to control Gazebo through ROS interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The important tags are `<inertia>`, `<collision>`, and `<gazebo>`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Gmapping package in ROS is an implementation of Fast SLAM algorithm, which
    can be used in robot to map the environment and localizing on it. Using Gmapping
    in ROS is a straightforward process, including the gmapping node with necessary
    parameters and topics such as odometry and laser scan.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Move_base` node has a provision to handle various navigation subsystem
    in a robot. It is having a provision to handle global and local planner, also
    the map of the robot. Once the node receives the goal position, which feed to
    the navigation subsystem in order to reach to that goal position.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: AMCL stands for Adaptive Monte Carlo Localization, which is an algorithm to
    localize a robot on a given map. There is a ROS package in ROS for deploying AMCL
    in our robot. We can launch the amcl node with proper input and necessary parameters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 5, Designing ChefBot Hardware and Circuits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is the process for finding proper robot hardware components for the robot
    that is meeting the robot desired specification. It also involves circuit designing
    and computing the current flow of each components in order to ensure the stability
    of the robot components.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It’s a switching circuit to control the direction and speed of an electric motor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The main components are wheel encoder to compute wheel velocity and laser range
    finder or depth sensor to detect the obstacle around the robot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need to check whether it meets the specification of the robot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Mapping, obstacle detection, object detection, and tracking.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 6, Interfacing Actuators and Sensors to the Robot Controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Switching circuit in order to control the speed of motors in a robot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A sensor that can detect the speed and direction of wheel rotation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the 4X encoding scheme, we are extracting the maximum transition between
    the encoder pulses in order to get more counts from a single rotation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using encoder count and distance per count, we can easily compute the displacement
    of the wheel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is a smart actuator having a motor and a microcontroller that can be directly
    interfaced to a PC and used to customize different settings of the actuator. It
    can be connected as daisy chain manner, which is appropriate for robotic arm.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is the sensor for finding range and has one transmitter and one receiver.
    The transmitter transmits ultrasonic sound, and the receiver receives it. The
    delay between these process is used for distance measurement.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Range = high level time of echo pin output * velocity (340 M/S) / 2.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It is sending IR pulses and receive by an IR receiver. According to the distance,
    the voltage in the IR receiver changes, and we can compute the distance using
    the following equation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Range = (6787 / (Volt - 3)) – 4
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 7, Interfacing Vision Sensors with ROS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of the 3D depth sensors have additional vision sensors to detect the depth.
    It may be using IR projection method or using stereo vision.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The message passing interface, tools to visualize and debug robots, off-the-shelf
    robot algorithms.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: OpenCV is mainly having computer vision algorithm, OpenNI is having algorithm
    implementation for implementing NI applications, and PCL is having algorithm to
    process point cloud data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It stands for Simultaneous Localization and Mapping. It is an algorithm commonly
    used to map the robot environment and localize on it at the same time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is an algorithm to map the robot environment in 3D.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 8, Building ChefBot Hardware and Integration of Software
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is a mediator program between robot low-level controller and high-level controller
    such as PC. It converts the low-level data into ROS equivalent data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: PID is a control loop feedback mechanism to reach a robot goal position by taking
    feedback of robot position.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using encoder data, we can compute the distance traversed by the robot using
    robot kinematic equations. Those values are odometry data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is mainly using for mapping the environment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is mainly using for localizing the robot in a static map.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 9, Designing a GUI for a Robot Using Qt and Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Qt and GTK.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Both bindings are almost the same, only difference is in the name. The PyQt
    license is GPL and PySide comes with LGPL. Also, PySide is having much documentation
    about its APIs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can use Py UI compiler named pyuic.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Qt slots are functions in a program that can be triggered by Qt signal. For
    example, clicked is a signal that can invoke a function named `hello()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rqt is one of the useful GUI tool in ROS. We can create rqt plugins and can
    insert in the rqt gui. There are existing plugins to do visualization, debugging,
    and so on in rqt.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
