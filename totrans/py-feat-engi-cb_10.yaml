- en: <st c="0">10</st>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="0">10</st>
- en: <st c="3">Creating Features from a Time Series with tsfresh</st>
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="3">使用tsfresh从时间序列创建特征</st>
- en: <st c="53">Throughout this book, we’ve discussed feature engineering methods
    and tools tailored for tabular and relational datasets.</st> <st c="176">In this
    chapter, we will shift our focus to time-series data.</st> <st c="238">A time
    series is a sequence of observations taken sequentially over time.</st> <st c="312">Examples
    include energy generation and demand, temperature, air pollutant concentration,
    stock prices, and sales revenue.</st> <st c="434">Each of these examples represents
    a variable and their values change</st> <st c="503">over time.</st>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="53">在这本书的整个过程中，我们讨论了针对表格和关系数据集定制的特征工程方法和工具。</st> <st c="176">在本章中，我们将把我们的重点转向时间序列数据。</st>
    <st c="238">时间序列是在时间上按顺序进行观察的一系列数据。</st> <st c="312">例如，包括能源生产和需求、温度、空气污染物浓度、股价和销售收入。</st>
    <st c="434">这些例子代表了一个变量，并且它们的值随时间变化。</st> <st c="503">。
- en: <st c="513">The widespread availability of affordable sensors capable of measuring
    motion, movement, humidity, glucose, and other parameters has significantly increased
    the amount of temporally annotated data.</st> <st c="712">These time series can
    be utilized in various classification tasks.</st> <st c="779">For instance, by
    analyzing the electricity usage pattern of a household at a given time interval,
    we can infer whether a particular appliance was being used.</st> <st c="937">Similarly,
    the signal of an ultrasound sensor can help determine the probability of a (gas)
    pipeline failure, and the characteristics of a sound wavelength can help predict
    whether a listener will like a song.</st> <st c="1147">Time-series data is also
    valuable for regression tasks.</st> <st c="1203">For example, signals from machinery
    sensors can be used to predict the remaining useful life of</st> <st c="1299">the
    device.</st>
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="513">可负担的传感器的大量可用性，能够测量运动、湿度、葡萄糖和其他参数，显著增加了时间标注数据的数量。</st> <st c="712">这些时间序列可以用于各种分类任务。</st>
    <st c="779">例如，通过分析在特定时间间隔内家庭的电力使用模式，我们可以推断出是否使用了特定的电器。</st> <st c="937">同样，超声波传感器的信号可以帮助确定（气体）管道故障的概率，而声音波长的特征可以帮助预测听众是否会喜欢一首歌。</st>
    <st c="1147">时间序列数据对于回归任务也非常有价值。</st> <st c="1203">例如，机械设备传感器的信号可以用来预测设备的剩余使用寿命。</st>
    <st c="1299">。
- en: <st c="1310">To use time series with traditional supervised machine learning
    models, such as linear and logistic regression, or decision-tree-based algorithms,
    we need to map each time series into a well-defined feature vector that captures
    its characteristics.</st> <st c="1560">Time-series patterns, including trends,
    seasonality, and periodicity, among other things, can be captured by a combination
    of simple and complex mathematical operations.</st> <st c="1730">Simple calculations
    include, for instance, taking the mean and the standard deviation of the time
    series.</st> <st c="1836">More complex methods include determining correlation
    or entropy, for example.</st> <st c="1914">In addition, we can apply non-linear
    time-series analysis functions to decompose the time-series signal, for example,
    Fourier or wavelet transformations, and use the parameters of these functions
    as features of the</st> <st c="2129">supervised models.</st>
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1310">为了使用时间序列与传统的监督机器学习模型，如线性回归、逻辑回归或基于决策树的算法，我们需要将每个时间序列映射到一个定义良好的特征向量，以捕捉其特征。</st>
    <st c="1560">时间序列模式，包括趋势、季节性和周期性等，可以通过简单和复杂的数学运算的组合来捕捉。</st> <st c="1730">简单的计算包括，例如，计算时间序列的平均值和标准差。</st>
    <st c="1836">更复杂的方法包括确定相关性或熵，例如。</st> <st c="1914">此外，我们可以应用非线性时间序列分析函数来分解时间序列信号，例如傅里叶变换或小波变换，并使用这些函数的参数作为监督模型的特征。</st>
    <st c="2129">。
- en: <st c="2147">Creating features from time series can be very time-consuming;
    we need to apply various signal processing and time-series analysis algorithms
    to identify and extract meaningful features.</st> <st c="2335">The</st> `<st c="2339">tsfresh</st>`
    <st c="2346">Python package, which stands for</st> `<st c="2597">tsfresh</st>`
    <st c="2604">includes a feature selection algorithm that identifies the most predictive
    features for a given time series.</st> <st c="2714">By automating the application
    of complex time-series methods,</st> `<st c="2776">tsfresh</st>` <st c="2783">bridges
    the gap between signal-processing experts and machine learning practitioners,
    making it easier to extract valuable features from</st> <st c="2921">time-series
    data.</st>
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 从时间序列创建特征可能非常耗时；我们需要应用各种信号处理和时间序列分析算法来识别和提取有意义的特征。</st> `<st c="2339">tsfresh</st>`
    <st c="2346">Python包，代表</st> `<st c="2597">tsfresh</st>` <st c="2604">包括一个特征选择算法，该算法可以识别给定时间序列的最具预测性的特征。</st>
    `<st c="2714">通过自动化应用复杂的时间序列方法，</st> `<st c="2776">tsfresh</st>` <st c="2783">弥合了信号处理专家和机器学习实践者之间的差距，使得从时间序列数据中提取有价值的特征变得更加容易。</st>
- en: <st c="2938">In this chapter, we will learn how to automatically create hundreds
    of features from time-series data by utilizing</st> `<st c="3054">tsfresh</st>`<st
    c="3061">. Following that, we will discuss how to fine-tune this feature creation
    process by selecting the most relevant features, extracting different features
    from different time series, and integrating the feature creation process into
    a scikit-learn pipeline to classify</st> <st c="3327">time-series data.</st>
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何通过利用<st c="3054">tsfresh</st>自动从时间序列数据中创建数百个特征。随后，我们将讨论如何通过选择最相关的特征、从不同的时间序列中提取不同的特征以及将特征创建过程集成到scikit-learn管道中来对<st
    c="3327">时间序列数据</st>进行分类。
- en: <st c="3344">In this chapter, we will go through the</st> <st c="3385">following
    recipes:</st>
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：<st c="3385">以下内容：</st>
- en: <st c="3403">Extracting hundreds of features automatically from a</st> <st c="3457">time
    series</st>
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从<st c="3457">时间序列</st>自动提取数百个特征
- en: <st c="3468">Automatically creating and selecting predictive features from</st>
    <st c="3531">time-series data</st>
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从<st c="3531">时间序列数据</st>自动创建和选择预测特征
- en: <st c="3547">Extracting different features from different</st> <st c="3593">time
    series</st>
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从不同的<st c="3593">时间序列</st>中提取不同的特征
- en: <st c="3604">Creating a subset of features identified through</st> <st c="3654">feature
    selection</st>
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过<st c="3604">特征选择</st>创建特征子集
- en: <st c="3671">Embedding feature creation into a</st> <st c="3706">scikit-learn
    pipeline</st>
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将特征创建嵌入到<st c="3706">scikit-learn管道</st>
- en: <st c="3727">Technical requirements</st>
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="3727">技术要求</st>
- en: <st c="3750">In this chapter, we will use the open source</st> `<st c="3796">tsfresh</st>`
    <st c="3803">Python library.</st> <st c="3820">You can install</st> `<st c="3836">tsfresh</st>`
    <st c="3843">with</st> `<st c="3849">pip</st>` <st c="3852">by executing</st>
    `<st c="3866">pip</st>` `<st c="3870">install tsfresh</st>`<st c="3885">.</st>
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用开源的<st c="3796">tsfresh</st> <st c="3803">Python库。</st> <st c="3820">您可以通过执行</st>
    <st c="3836">tsfresh</st> <st c="3843">安装</st> <st c="3849">pip</st> <st c="3852">来安装<st
    c="3836">tsfresh</st>：</st> <st c="3866">pip</st> <st c="3870">install tsfresh</st><st
    c="3885">。
- en: <st c="3886">Note</st>
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3886">注意</st>
- en: <st c="3891">If you have an old Microsoft operating system, you may need to
    update the Microsoft C++ build tools to proceed with the</st> `<st c="4012">tsfresh</st>`
    <st c="4019">package’s installation.</st> <st c="4044">Follow the steps in this
    thread to do</st> <st c="4082">so:</st> [<st c="4086">https://stackoverflow.com/questions/64261546/how-to-solve-error-microsoft-visual-c-14-0-or-greater-is-required-when-inst</st>](https://stackoverflow.com/questions/64261546/how-to-solve-error-microsoft-visual-c-14-0-or-greater-is-required-when-inst)<st
    c="4206">.</st>
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是旧版的Microsoft操作系统，您可能需要更新Microsoft C++构建工具才能继续安装<st c="4012">tsfresh</st>
    <st c="4019">包。</st> <st c="4044">请按照此线程中的步骤操作：</st> [<st c="4086">https://stackoverflow.com/questions/64261546/how-to-solve-error-microsoft-visual-c-14-0-or-greater-is-required-when-inst</st>](https://stackoverflow.com/questions/64261546/how-to-solve-error-microsoft-visual-c-14-0-or-greater-is-required-when-inst)<st
    c="4206">。</st>
- en: <st c="4207">We will work</st> <st c="4220">with the</st> **<st c="4230">Occupancy
    Detection</st>** <st c="4249">dataset from the UCI Machine Learning Repository,
    available at</st> [<st c="4313">http://archive.ics.uci.edu/ml/datasets/Occupancy+Detection</st>](http://archive.ics.uci.edu/ml/datasets/Occupancy+Detection)
    <st c="4371">and licensed under a Creative Commons Attribution 4.0 International
    (CC BY 4.0) license:</st> [<st c="4461">https://creativecommons.org/licenses/by/4.0/legalcode</st>](https://creativecommons.org/licenses/by/4.0/legalcode)<st
    c="4514">. The corresponding citation for this data is</st> <st c="4560">as follows:</st>
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用来自UCI机器学习仓库的**<st c="4230">占用检测</st>**数据集，该数据集可在[<st c="4313">http://archive.ics.uci.edu/ml/datasets/Occupancy+Detection</st>](http://archive.ics.uci.edu/ml/datasets/Occupancy+Detection)找到，并受Creative
    Commons Attribution 4.0 International (CC BY 4.0)许可协议的许可：[<st c="4461">https://creativecommons.org/licenses/by/4.0/legalcode</st>](https://creativecommons.org/licenses/by/4.0/legalcode)。该数据的相应引用如下：
- en: <st c="4571">Candanedo, Luis.</st> <st c="4589">(2016).</st> <st c="4597">Occupancy
    Detection.</st> <st c="4618">UCI Machine Learning</st> <st c="4639">Repository.</st>
    [<st c="4651">https://doi.org/10.24432/C5X01N</st>](https://doi.org/10.24432/C5X01N)<st
    c="4682">.</st>
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Candanedo, Luis. <st c="4589">(2016). <st c="4597">占用检测.</st> <st c="4618">UCI机器学习</st>
    <st c="4639">仓库.</st> [<st c="4651">https://doi.org/10.24432/C5X01N</st>](https://doi.org/10.24432/C5X01N)<st
    c="4682">.</st>
- en: <st c="4683">I downloaded and modified the data as shown in this</st> <st c="4736">notebook:</st>
    [<st c="4746">https://github.com/PacktPublishing/Python-Feature-engineering-Cookbook-Third-Edition/blob/main/ch10-tsfresh/prepare-occupancy-dataset.ipynb</st>](https://github.com/PacktPublishing/Python-Feature-engineering-Cookbook-Third-Edition/blob/main/ch10-tsfresh/prepare-occupancy-dataset.ipynb)
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我下载并修改了如本笔记本所示的数据：[<st c="4746">https://github.com/PacktPublishing/Python-Feature-engineering-Cookbook-Third-Edition/blob/main/ch10-tsfresh/prepare-occupancy-dataset.ipynb</st>](https://github.com/PacktPublishing/Python-Feature-engineering-Cookbook-Third-Edition/blob/main/ch10-tsfresh/prepare-occupancy-dataset.ipynb)
- en: <st c="4885">For a copy of the modified dataset and a target variable, check
    out the files called</st> `<st c="4971">occupancy.csv</st>` <st c="4984">and</st>
    `<st c="4989">occupancy_target.csv</st>`<st c="5009">, available at the following</st>
    <st c="5038">link:</st> [<st c="5044">https://github.com/PacktPublishing/Python-Feature-engineering-Cookbook-Third-Edition/blob/main/ch10-tsfresh</st>](https://github.com/PacktPublishing/Python-Feature-engineering-Cookbook-Third-Edition/blob/main/ch10-tsfresh)
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 若要获取修改后的数据集和目标变量，请查看以下链接中的文件`<st c="4971">occupancy.csv</st>` <st c="4984">和</st>
    `<st c="4989">occupancy_target.csv</st>`<st c="5009">，可在以下链接找到：<st c="5038">[https://github.com/PacktPublishing/Python-Feature-engineering-Cookbook-Third-Edition/blob/main/ch10-tsfresh](https://github.com/PacktPublishing/Python-Feature-engineering-Cookbook-Third-Edition/blob/main/ch10-tsfresh)</st>
- en: <st c="5151">The Occupancy Detection dataset contains time-series data taken
    over 135 hours at one-minute intervals.</st> <st c="5256">The variables measure
    the temperature, humidity,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>C</mml:mi><mml:mi>O</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:math>](img/38.png)
    <st c="5305"><st c="5309">level, and light consumption in an office.</st> <st
    c="5352">Camera footage was used to determine whether someone was in the office.</st>
    <st c="5424">The target variable shows whether the office was occupied at any
    one hour.</st> <st c="5499">If the target takes the value</st> `<st c="5529">1</st>`<st
    c="5530">, it means that the office was occupied during that hour; otherwise,
    it takes the</st> <st c="5612">value</st> `<st c="5618">0</st>`<st c="5619">.</st></st>
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 占用检测数据集包含在135小时内每分钟间隔采集的时间序列数据。<st c="5256">变量测量办公室的温度、湿度、</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>C</mml:mi><mml:mi>O</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:math>](img/38.png)
    <st c="5305"><st c="5309">水平，以及照明消耗。</st> <st c="5352">使用摄像头录像来确定是否有人在办公室。</st>
    <st c="5424">目标变量显示办公室是否在任何一小时被占用。</st> <st c="5499">如果目标变量取值为</st> `<st c="5529">1</st>`<st
    c="5530">，则表示该小时办公室被占用；否则，它取值为</st> `<st c="5612">0</st>`<st c="5618">。</st>
- en: <st c="5620">The dataset with the time series and that with the target variable
    have different numbers of rows.</st> <st c="5720">The time-series dataset contains
    135 hours of records at one-minute intervals – that is, 8,100 rows.</st> <st c="5821">The
    target has only 135 rows, with a label indicating whether the office was occupied
    at each of the</st> <st c="5922">135 hours.</st>
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5620">包含时间序列和目标变量的数据集行数不同。</st> <st c="5720">时间序列数据集包含以一分钟间隔记录的135小时记录，即8,100行。</st>
    <st c="5821">目标变量只有135行，每行都有一个标签，表示在135小时中的每个小时办公室是否被占用。</st>
- en: <st c="5932">Note</st>
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5932">注意</st>
- en: <st c="5937">Check out the notebook in this book’s GitHub repository for plots
    of the different time series to become familiar with the</st> <st c="6061">dataset:</st>
    [<st c="6070">https://github.com/PacktPublishing/Python-Feature-Engineering-Cookbook-Third-Edition/blob/main/ch10-tsfresh/prepare-occupancy-dataset.ipynb</st>](https://github.com/PacktPublishing/Python-Feature-Engineering-Cookbook-Third-Edition/blob/main/ch10-tsfresh/prepare-occupancy-dataset.ipynb)
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5937">查看本书GitHub仓库中的笔记本，以熟悉不同时间序列的绘图：</st> <st c="6061">数据集：</st> [<st
    c="6070">https://github.com/PacktPublishing/Python-Feature-Engineering-Cookbook-Third-Edition/blob/main/ch10-tsfresh/prepare-occupancy-dataset.ipynb</st>](https://github.com/PacktPublishing/Python-Feature-Engineering-Cookbook-Third-Edition/blob/main/ch10-tsfresh/prepare-occupancy-dataset.ipynb)
- en: <st c="6209">Extracting hundreds of features automatically from a time series</st>
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="6209">从时间序列自动提取数百个特征</st>
- en: <st c="6274">Time series</st> <st c="6287">a</st><st c="6288">re data points
    indexed in time</st> <st c="6319">order.</st> <st c="6326">Analyzing time-series
    sequences allows us to make various predictions.</st> <st c="6397">For example,
    sensor data can be used to predict pipeline failures, sound data can help identify
    music genres, health history or personal measurements such as glucose levels can
    indicate whether a person is sick, and, as we will show in this recipe, patterns
    of light usage, humidity, and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>C</mml:mi><mml:mi>O</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:math>](img/39.png)
    <st c="6685"><st c="6689">levels can determine whether an office</st> <st c="6728">is
    occupied.</st></st>
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="6274">时间序列</st> <st c="6287">是</st><st c="6288">按时间顺序索引的数据点</st> <st
    c="6319">。</st> <st c="6326">分析时间序列序列使我们能够做出各种预测。</st> <st c="6397">例如，传感器数据可以用来预测管道故障，声音数据可以帮助识别音乐类型，健康历史或个人测量，如血糖水平，可以表明一个人是否生病，正如我们将在这个菜谱中展示的，光照模式、湿度和</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>C</mml:mi><mml:mi>O</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:math>](img/39.png)
    <st c="6685"><st c="6689">水平可以确定办公室</st> <st c="6728">是否被占用。</st></st>
- en: <st c="6740">To tra</st><st c="6747">in regression and classification models
    using traditional machine learning algorithms, such as linear regression or random
    forests, we require a dataset of size</st> *<st c="6909">M x N</st>*<st c="6914">,
    where M is the number of rows and N is the number of features or columns.</st>
    <st c="6990">However, with time-series data, what we have is a collection of</st>
    *<st c="7054">M</st>* <st c="7055">time series, and each time series has multiple
    rows indexed chronologically.</st> <st c="7133">To use time series in supervised
    learning models, each time series needs to be mapped into a well-defined feature
    vector,</st> *<st c="7255">N</st>*<st c="7256">, as shown in the</st> <st c="7274">following
    diagram</st><st c="7291">:</st>
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="6740">为了训练回归和分类模型，使用传统的机器学习算法，如线性回归或随机森林，我们需要一个大小为</st> *<st c="6909">M
    x N</st>*<st c="6914">的数据集，其中M是行数，N是特征数或列数。</st> <st c="6990">然而，对于时间序列数据，我们拥有的是一系列</st>
    *<st c="7054">M</st>* <st c="7055">时间序列，每个时间序列都有多个按时间顺序索引的行。</st> <st c="7133">要在监督学习模型中使用时间序列，每个时间序列都需要映射到一个定义良好的特征向量，</st>
    *<st c="7255">N</st>*<st c="7256">，如图所示</st> <st c="7274">以下</st><st c="7291">：</st>
- en: '![Figure 10.1 – Diagram showing the process of feature creation from a time
    series for classification or regression](img/B22396_10_01.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图10.1 – 显示从时间序列创建特征过程（用于分类或回归）的图表](img/B22396_10_01.jpg)'
- en: <st c="7294">Figure 10.1 – Diagram showing the process of feature creation from
    a time series for classification or regression</st>
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7294">图10.1 – 显示从时间序列创建特征过程（用于分类或回归）的图表</st>
- en: <st c="7407">The</st><st c="7411">se feature vectors, which are represented
    as</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math>](img/40.png)<st
    c="7457"><st c="7458">,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:math>](img/41.png)<st
    c="7460"><st c="7461">, and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:msub></mml:math>](img/42.png)
    <st c="7467"><st c="7468">in</st> *<st c="7472">Figure 10</st>**<st c="7481">.1</st>*<st
    c="7483">, should capture the characteristics of the time series.</st> <st c="7540">For
    example,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math>](img/43.png)<st
    c="7553"><st c="7554">could be the mean value of the time series and</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:math>](img/44.png)<st
    c="7601"><st c="7602">its variance.</st> <st c="7616">We can crea</st><st c="7627">te
    many features to characterize the time series concerning the distribution of data
    points, correlation properties, stationarity, or entropy, among others.</st> <st
    c="7785">Therefore, the feature vector, N, can be constructed by applying a series</st>
    <st c="7859">of</st> **<st c="7862">characterization methods</st>** <st c="7886">t</st><st
    c="7888">hat take a time series as input and return one or more scalars as output.</st>
    <st c="7962">The mean, or the sum, takes the time-series sequence as input and
    returns a single scalar as output, with the mean value of the time series or the
    sum of its values.</st> <st c="8128">We can also fit a linear trend to the time-series
    sequence, which will return two scalars – one with the slope and one with</st>
    <st c="8252">the intercep</st><st c="8264">t.</st></st></st></st></st></st>
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7407">这些</st><st c="7411">特征向量，表示为</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math>](img/40.png)<st
    c="7457"><st c="7458">,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:math>](img/41.png)<st
    c="7460"><st c="7461">, 和</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:msub></mml:math>](img/42.png)
    <st c="7467"><st c="7468">在</st> *<st c="7472">图10.1</st>**<st c="7481">.1</st>*<st
    c="7483">中，应该能够捕捉时间序列的特征。</st> <st c="7540">例如，</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math>](img/43.png)<st
    c="7553"><st c="7554">可能是时间序列的均值，</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:math>](img/44.png)<st
    c="7601"><st c="7602">及其方差。</st> <st c="7616">我们可以创建许多特征来描述时间序列，包括数据点的分布、相关性、平稳性或熵等。</st>
    <st c="7785">因此，特征向量N可以通过应用一系列</st> <st c="7859">**<st c="7862">特征化方法</st>**</st>
    <st c="7886">t</st><st c="7888">hat</st> <st c="7890">取时间序列作为输入并返回一个或多个标量作为输出。</st>
    <st c="7962">均值或总和将时间序列序列作为输入，并返回一个标量作为输出，该标量是时间序列的均值或其值的总和。</st> <st c="8128">我们还可以将线性趋势拟合到时间序列序列中，这将返回两个标量——一个表示斜率，另一个表示</st>
    <st c="8252">截距。</st>
- en: '`<st c="8267">tsfresh</st>` <st c="8275">applies 63 characterization methods
    to a time series, each of which returns one or more scalars, therefore resulting
    in more than 750 features for any given time series.</st> <st c="8446">In this
    recipe, we will use</st> `<st c="8474">tsfresh</st>` <st c="8481">to transform
    time-series data into an M x N feature</st> <st c="8534">table, which</st> <st
    c="8547">we will then use to predict</st> <st c="8575">office occupa</st><st c="8588">ncy.</st>'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="8267">tsfresh</st>` <st c="8275">对时间序列应用63种特征化方法，每种方法返回一个或多个标量，因此对于任何给定的时间序列，都会产生超过750个特征。</st>
    <st c="8446">在这个菜谱中，我们将使用</st> `<st c="8474">tsfresh</st>` <st c="8481">将时间序列数据转换为M
    x N特征</st> <st c="8534">表，然后</st> <st c="8547">我们将使用它来预测</st> <st c="8575">办公室占用</st><st
    c="8588">情况。</st>'
- en: <st c="8593">Getting ready</st>
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="8593">准备就绪</st>
- en: <st c="8607">In this recipe, we wil</st><st c="8630">l use the Occupancy Detection
    dataset described in the</st> *<st c="8686">Technical requirements</st>* <st c="8708">section.</st>
    <st c="8718">This dataset contains measurements of temperature, humidity,</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>C</mml:mi><mml:mi>O</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:math>](img/45.png)
    <st c="8779"><st c="8782">level, and light consumption in an office taken at one-minute
    intervals.</st> <st c="8855">There are 135 hours of measurements, and each hour
    is flagged with a unique identifier.</st> <st c="8943">There is also a dataset
    with a target variable that indicates in which of these 135 hours the office was
    occupied.</st> <st c="9058">Let’s load the data and make some plot</st><st c="9096">s
    to understand</st> <st c="9113">its patterns:</st></st>
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="8607">在这个菜谱中，我们将使用</st><st c="8630">在*《技术要求》</st>* <st c="8686">部分中描述的</st>
    <st c="8708">占用检测数据集。</st> <st c="8718">该数据集包含在办公室内每分钟间隔测量的温度、湿度、</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>C</mml:mi><mml:mi>O</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:math>](img/45.png)
    <st c="8779"><st c="8782">级别和照明消耗。</st> <st c="8855">有135小时的测量数据，每小时都有一个唯一的标识符。</st>
    <st c="8943">还有一个包含目标变量的数据集，该变量指示在135小时中的哪个小时办公室被占用。</st> <st c="9058">让我们加载数据并绘制一些图表来理解</st><st
    c="9096">其模式：</st>
- en: <st c="9126">Let’s load</st> `<st c="9138">pandas</st>` <st c="9144">and</st>
    `<st c="9149">matplotlib</st>`<st c="9159">:</st>
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="9126">让我们</st> `<st c="9138">pandas</st>` <st c="9144">和</st> `<st c="9149">matplotlib</st>`<st
    c="9159">:</st>
- en: '[PRE0]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: <st c="9213">Load the dataset and display the first</st> <st c="9253">five rows:</st>
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="9213">加载数据集并显示前五行：</st> <st c="9253">:</st>
- en: '[PRE1]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: <st c="9328">In the following figure, we can see the dataset containing a unique
    identifier, followed by the date and time of the measurements and values for five
    time series capturing temperature, humidity, lights, and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>C</mml:mi><mml:mi>O</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:math>](img/39.png)
    <st c="9536"><st c="9540">levels in</st> <st c="9550">the offi</st><st c="9558">ce:</st></st>
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="9328">在下面的图中，我们可以看到包含唯一标识符的数据集，随后是测量日期和时间以及五个时间序列的值，这些时间序列捕捉了温度、湿度、照明和</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>C</mml:mi><mml:mi>O</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:math>](img/39.png)
    <st c="9536"><st c="9540">办公室的</st> <st c="9550">级别：</st>
- en: '![Figure 10.2 – DataFrame with the time-series data](img/B22396_10_02.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图10.2 – 包含时间序列数据的DataFrame](img/B22396_10_02.jpg)'
- en: <st c="9934">Figure 10.2 – DataFrame with the time-series data</st>
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="9934">图10.2 – 包含时间序列数据的DataFrame</st>
- en: <st c="9983">Let’s creat</st><st c="9995">e a</st> <st c="10000">function to</st>
    <st c="10011">plot the time series from</st> *<st c="10038">step 2</st>* <st c="10044">at
    a given hour (the</st> `<st c="10066">id</st>` <st c="10068">column is a unique
    identifier for each of the 135 hours</st> <st c="10125">of records):</st>
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="9983">让我们</st><st c="9995">创建</st> <st c="10000">一个函数来</st> <st c="10011">绘制从</st>
    *<st c="10038">步骤2</st>* <st c="10044">在给定小时的时间序列（记录的135小时中的每一小时都有一个唯一的标识符`<st
    c="10066">id</st>` <st c="10068">列）：</st>
- en: '[PRE2]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: <st c="10587">Let’s</st> <st c="10593">plot the time series corresponding to
    an hour when the office was</st> <st c="10660">not occupied:</st>
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="10587">让我们</st> <st c="10593">绘制办公室未被占用的小时对应的时间序列：</st>
- en: '[PRE3]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: <st c="10692">In the following figure, we can see the time-series values during
    the second hour of</st> <st c="10778">records, when the office</st> <st c="10802">was</st>
    <st c="10807">empty:</st>
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="10692">在下面的图中，我们可以看到记录的第二个小时的时间序列值，当时办公室</st> <st c="10778">是空的：</st>
- en: "![Figure 10.3 – Time-series values during the second hour of data collection\
    \ when the office was empt\uFEFFy](img/B22396_10_03.jpg)"
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图10.3 – 数据收集的第二个小时的时间序列值，当时办公室是空的](img/B22396_10_03.jpg)'
- en: <st c="11177">Figure 10.3 – Time-series values during the second hour of data
    collection when the office was empt</st><st c="11276">y</st>
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="11177">图10.3 – 数据收集的第二个小时的时间序列值，当时办公室是空的</st><st c="11276">的</st>
- en: <st c="11278">Note that the lights were off, and that</st> <st c="11318">is
    why we see the flat line at 0 in the plot of</st> `<st c="11366">light</st>` <st
    c="11371">consumption in the</st> <st c="11391">top-right corner.</st>
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="11278">注意灯光是关闭的，这就是为什么我们在右上角的光消耗图中看到0处的水平线。</st>
- en: <st c="11408">Now, let’s plot the time-series data corresponding to an hour
    when the office</st> <st c="11487">was occupied:</st>
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="11408">现在，让我们绘制出办公室被占用的小时对应的时间序列数据：</st>
- en: '[PRE4]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: <st c="11520">In the following figure, we can see the time-series values during
    the fifteenth hour of records, when the office</st> <st c="11634">was occu</st><st
    c="11642">pied:</st>
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="11520">在下面的图中，我们可以看到记录的第十五个小时的时间序列值，当时办公室</st> <st c="11634">被占用：</st>
- en: '![Figure 10.4 – Time-series values during the fifteenth hour of data collection,
    when the office was occupied](img/B22396_10_04.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图10.4 – 数据收集的第十五个小时的时间序列值，当时办公室被占用](img/B22396_10_04.jpg)'
- en: <st c="12022">Figure 10.4 – Time-series values during the fifteenth hour of
    data collection, when the office was occupied</st>
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12022">图10.4 – 数据收集的第十五个小时的时间序列值，当时办公室被占用</st>
- en: <st c="12129">Notice that the lights were on this time (</st><st c="12172">top-right
    panel).</st>
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这次灯光是亮着的（</st><st c="12172">右上角面板）。</st>
- en: <st c="12190">In this recipe, we will extract features from each of these one-hour
    windows of time-series data, capturing</st> <st c="12298">various aspects of their</st>
    <st c="12324">character</st><st c="12333">istics.</st> <st c="12342">From each
    of these 60-minute time-series segments, we will automatically generate more than
    750 features using</st> `<st c="12453">tsfresh</st>`<st c="12460">, ensuring a
    comprehensive representation of the</st> <st c="12509">data’s prop</st><st c="12520">erties.</st>
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12190">在这个菜谱中，我们将从这些时间序列数据的每一小时窗口中提取特征，捕捉</st> <st c="12298">它们的</st>
    <st c="12324">特征</st><st c="12333">的各个方面。</st> <st c="12342">从这些60分钟的时间序列段中，我们将使用</st>
    `<st c="12453">tsfresh</st>`<st c="12460">自动生成超过750个特征，确保对</st> <st c="12509">数据属性</st><st
    c="12520">的全面表示。</st>
- en: <st c="12528">How to do it...</st>
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="12528">如何做到...</st>
- en: <st c="12544">We will begin by automatically creating hundreds of features from
    one time series,</st> `<st c="12628">lights</st>`<st c="12634">, and then use
    those features to predict whether the office was occupied at any</st> <st c="12714">given
    hour:</st>
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12544">我们将从一条时间序列</st> `<st c="12628">灯光</st>`<st c="12634">中自动创建数百个特征，然后使用这些特征来预测办公室是否在任何</st>
    <st c="12714">给定的小时被占用：</st>
- en: <st c="12725">Let’s import the required Python libraries</st> <st c="12769">and
    functions:</st>
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="12725">让我们导入所需的Python库</st> <st c="12769">和函数：</st>
- en: '[PRE5]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: <st c="13056">Load the dataset described in the</st> *<st c="13091">Technical</st>*
    *<st c="13101">requirements</st>* <st c="13113">section:</st>
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="13056">加载在</st> *<st c="13091">技术</st>* *<st c="13101">要求</st>* <st c="13113">部分中描述的</st>数据集：</st>
- en: '[PRE6]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: <st c="13177">L</st><st c="13179">oad the target variable into a</st> `<st c="13210">pandas</st>`
    <st c="13216">Series:</st>
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="13177">L</st><st c="13179">将目标变量加载到一个</st> `<st c="13210">pandas</st>`
    <st c="13216">序列中：</st>
- en: '[PRE7]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: <st c="13293">Let’s create hundreds of features automatically for each hour
    of light records using</st> `<st c="13379">tsfresh</st>`<st c="13386">. To create
    features from the</st> `<st c="13416">light</st>` <st c="13421">variable, we pass
    the DataFrame containing this variable and the unique identifier for each time
    series to the</st> `<st c="13533">extract_features</st>` <st c="13549">function</st>
    <st c="13559">from</st> `<st c="13564">tsfresh</st>`<st c="13571">:</st>
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="13293">让我们使用</st> `<st c="13379">tsfresh</st>`<st c="13386">自动为每小时的灯光记录创建数百个特征。要从</st>
    `<st c="13416">light</st>` <st c="13421">变量中创建特征，我们将包含此变量和每个时间序列的唯一标识符的DataFrame传递给</st>
    `<st c="13533">extract_features</st>` <st c="13549">函数</st> <st c="13559">来自</st>
    `<st c="13564">tsfresh</st>`<st c="13571">：</st>
- en: '[PRE8]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: <st c="13638">If we execute</st> `<st c="13653">features.shape</st>`<st c="13667">,
    we’ll obtain</st> `<st c="13682">(135, 789)</st>` <st c="13692">corresponding
    to the size</st> <st c="13719">of</st> <st c="13722">the resulting DataFrame,
    where each row represents an hour of records and each column one of the features
    created by</st> `<st c="13839">tsfresh</st>`<st c="13846">. There are 789 features
    that characterize light consumption at any given hour.</st> <st c="13926">Go ahead
    and execute</st> `<st c="13947">features.head()</st>` <st c="13962">to get a view
    of the resulting DataFrame.</st> <st c="14005">For space reasons, we can’t display
    the entire DataFrame in the book.</st> <st c="14075">So, instead, we will explore
    some of</st> <st c="14112">the features.</st>
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="13638">如果我们执行</st> `<st c="13653">features.shape</st>`<st c="13667">，我们将获得</st>
    `<st c="13682">(135, 789)</st>` <st c="13692">，这对应于结果DataFrame的大小</st> <st c="13719">，其中每一行代表一个小时的记录，每一列代表由</st>
    `<st c="13839">tsfresh</st>`<st c="13846">创建的一个特征。有789个特征可以描述任何给定小时的光消耗。</st>
    <st c="13926">继续执行</st> `<st c="13947">features.head()</st>` <st c="13962">以查看结果DataFrame。</st>
    <st c="14005">由于篇幅原因，我们无法在书中显示整个DataFrame。</st> <st c="14075">因此，我们将探索一些</st>
    <st c="14112">特征。</st>
- en: <st c="14125">Let’s capture the names of five of the created features in</st>
    <st c="14185">an array:</st>
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="14125">让我们将创建的五个特征名称存储在</st> <st c="14185">一个数组中：</st>
- en: '[PRE9]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: <st c="14226">If we execute</st> `<st c="14241">feats</st>`<st c="14246">, we’ll
    see the names of five features corresponding to the mean, length, standard deviation,
    coefficient of variation, and variance of the light consumption</st> <st c="14404">per
    hour:</st>
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="14226">如果我们执行</st> `<st c="14241">feats</st>`<st c="14246">，我们将看到与平均数、长度、标准差、变异系数和光消耗的方差相对应的五个特征名称</st>
    <st c="14404">每小时：</st>
- en: '[PRE10]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: <st c="14549">Now, let’s display the values of the features from</st> *<st c="14601">step
    5</st>* <st c="14607">for the first</st> <st c="14622">five hours:</st>
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="14549">现在，让我们显示从</st> *<st c="14601">步骤5</st>* <st c="14607">开始的第一个</st>
    <st c="14622">五个小时</st>的特征值：</st>
- en: '[PRE11]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: <st c="14656">In the following DataFrame, we see the features extracted from
    the time series for the first</st> <st c="14749">five hours of</st> <st c="14764">light</st>
    <st c="14770">co</st><st c="14772">nsumption:</st>
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="14656">在以下DataFrame中，我们看到从</st> <st c="14749">前五个小时的</st> <st c="14764">光</st>
    <st c="14770">合</st><st c="14772">消耗</st> <st c="14778">的时间序列中提取的特征：</st>
- en: '![Figure 10.5 – Features created for each hour of light consumption](img/B22396_10_05.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图10.5 – 为每小时的光消耗创建的特征](img/B22396_10_05.jpg)'
- en: <st c="15066">Figure 10.5 – Features created for each hour of light consumption</st>
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15066">图10.5 – 为每小时的光消耗创建的特征</st>
- en: <st c="15131">Looking at the mean value of light consumption in</st> *<st c="15182">Figure
    10</st>**<st c="15191">.4</st>*<st c="15193">, we can see that the lights were
    on during the first hour, and then</st> <st c="15262">off in the following four
    hours.</st> <st c="15295">The length of the time series is 60 because we have
    60 minutes of records</st> <st c="15369">per hour.</st>
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15131">查看图10**<st c="15182">.4</st>**中的光消耗平均值，我们可以看到前一个小时灯光是开启的，然后在接下来的四个小时里关闭了。</st>
    <st c="15262">时间序列的长度是60，因为我们每小时有60分钟的记录。</st>
- en: <st c="15378">Note</st>
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15378">注意</st>
- en: '`<st c="15383">tsfresh</st>` <st c="15391">applies 63 feature creation methods
    to a time series.</st> <st c="15446">Based on the characteristics of the time
    series, such as its length or its variability, some of the methods will return
    missing values or infinite values.</st> <st c="15601">For example, in</st> *<st
    c="15617">Figure 10</st>**<st c="15626">.4</st>*<st c="15628">, w</st><st c="15631">e
    see that the variation coefficient could not be calculated for those hours where
    the light consumption is constant.</st> <st c="15750">And the variance is also</st>
    `<st c="15775">0</st>` <st c="15776">in those cases.</st> <st c="15793">In fact,
    for our dataset, many of the resulting features contain only</st> `<st c="15863">NaN</st>`
    <st c="15866">values, or are constant, like the length, and are therefore not
    useful for training machine</st> <st c="15959">learning models.</st>'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="15383">tsfresh</st>` <st c="15391">对时间序列应用63种特征创建方法。</st> <st c="15446">根据时间序列的特征，如其长度或其变异性，某些方法可能会返回缺失值或无穷大值。</st>
    <st c="15601">例如，在</st> *<st c="15617">图10</st>**<st c="15626">.4</st>*<st c="15628">中，我们可以看到在光照消耗恒定的那些小时，无法计算变异系数。</st>
    <st c="15750">并且在这些情况下，方差也是</st> `<st c="15775">0</st>` <st c="15776">。</st> <st
    c="15793">实际上，对于我们的数据集，许多生成的特征只包含</st> `<st c="15863">NaN</st>` <st c="15866">值，或者像长度一样是恒定的，因此对于训练机器</st>
    <st c="15959">学习模型来说没有用。</st>'
- en: '`<st c="15975">tsfresh</st>` <st c="15983">includes an imputation function
    to impute features that contain</st> `<st c="16048">NaN</st>` <st c="16051">values.</st>
    <st c="16060">Let’s go ahead and impute</st> <st c="16086">our features:</st>'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`<st c="15975">tsfresh</st>` <st c="15983">包含一个用于填充包含</st> `<st c="16048">NaN</st>`
    <st c="16051">值的特征的填充函数。</st> <st c="16060">让我们继续填充</st> <st c="16086">我们的特征：</st>'
- en: '[PRE12]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: <st c="16116">The</st> `<st c="16121">impute</st>` <st c="16127">function from</st>
    `<st c="16142">tsfresh</st>` <st c="16149">replaces</st> `<st c="16159">NaN</st>`<st
    c="16162">,</st> `<st c="16164">-Inf</st>`<st c="16168">, and</st> `<st c="16174">Inf</st>`
    <st c="16177">values with the variable’s median, minimum, or maximum</st> <st
    c="16233">values, respectively.</st>
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="16116">The</st> `<st c="16121">impute</st>` <st c="16127">函数来自</st> `<st
    c="16142">tsfresh</st>` <st c="16149">，它将</st> `<st c="16159">NaN</st>`<st c="16162">、`<st
    c="16164">-Inf</st>`<st c="16168">和</st> `<st c="16174">Inf</st>` <st c="16177">值分别替换为变量的中位数、最小值或最大值。</st>
- en: <st c="16254">Let’s use these features to train a logistic regression model
    and predict whether the office</st> <st c="16348">was occupied.</st>
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="16254">让我们使用这些特征来训练一个逻辑回归模型，并预测办公室</st> <st c="16348">是否被占用。</st>
- en: <st c="16361">Let’s begin</st> <st c="16373">by separating the</st> <st c="16391">dataset
    into training and</st> <st c="16418">test sets:</st>
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="16361">让我们开始</st> <st c="16373">将</st> <st c="16391">数据集</st> <st c="16418">分为训练集和</st>
    <st c="16435">测试集：</st>
- en: '[PRE13]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: <st c="16528">Now, let’s set up and train a logistic regression model, and then
    evaluate</st> <st c="16604">its performance:</st>
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="16528">现在，让我们设置并训练一个逻辑回归模型，然后评估</st> <st c="16604">其性能：</st>
- en: '[PRE14]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: <st c="16755">In t</st><st c="16760">he following output, we see the values
    of evaluation metrics that are commonly used for classification analysis, which
    suggests that the created features ar</st><st c="16917">e useful for predicting</st>
    <st c="16942">office occupancy:</st>
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="16755">在以下输出中，我们看到用于分类分析的常用评估指标的值，这表明创建的特征对于预测</st> <st c="16942">办公室占用情况是有用的：</st>
- en: '[PRE15]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: <st c="17108">Note</st>
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="17108">注意</st>
- en: <st c="17113">To keep the recipe simple, I have not optimized the model hyperparameters
    or tuned the probability threshold – things that we normally do to ensure our
    models</st> <st c="17273">are accurate.</st>
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="17113">为了保持方法简单，我没有优化模型超参数或调整概率阈值——这些是我们通常为了确保模型</st> <st c="17273">准确度所做的事情。</st>
- en: <st c="17286">To finish</st> <st c="17297">off, let’s</st> <st c="17308">extract
    features from every time series, that is,</st> `<st c="17358">light</st>`<st c="17363">,</st>
    `<st c="17365">temperature</st>`<st c="17376">,</st> `<st c="17378">humidity</st>`<st
    c="17386">, and</st> `<st c="17392">co2</st>`<st c="17395">, and this time, we
    will impute the features right after</st> <st c="17452">the extraction:</st>
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="17286">最后，让我们</st> <st c="17297">提取每个时间序列的特征，即</st> `<st c="17358">光照</st>`<st
    c="17363">、`<st c="17365">温度</st>`<st c="17376">、`<st c="17378">湿度</st>`<st c="17386">和</st>
    `<st c="17392">二氧化碳</st>`<st c="17395">，这次，我们将在提取后立即填充特征：</st>
- en: '[PRE16]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: <st c="17561">Note</st>
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="17561">注意</st>
- en: <st c="17566">In</st> *<st c="17570">step 10</st>*<st c="17577">, we indicated
    that we want to sort our time series based on the timestamp containing the time
    and date of the measurement, by passing the</st> `<st c="17716">date</st>` <st
    c="17720">variable to the</st> `<st c="17737">column_sort</st>` <st c="17748">parameter.</st>
    <st c="17760">This is useful when our time series are not equidistant or not ordered
    chronologically.</st> <st c="17848">If we leave this parameter set to</st> `<st
    c="17882">None</st>`<st c="17886">,</st> `<st c="17888">tsfresh</st>` <st c="17895">assumes
    that the time series are ordered</st> <st c="17937">and eq</st><st c="17943">uidistant.</st>
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="17566">在</st> *<st c="17570">步骤 10</st>*<st c="17577">中，我们指出我们想要根据包含测量时间和日期的时间戳对时间序列进行排序，通过将</st>
    `<st c="17716">date</st>` <st c="17720">变量传递给</st> `<st c="17737">column_sort</st>`
    <st c="17748">参数。</st> <st c="17760">这在我们的时间序列不是等距或不是按时间顺序排列时很有用。</st> <st c="17848">如果我们将此参数设置为</st>
    `<st c="17882">None</st>`<st c="17886">，</st> `<st c="17888">tsfresh</st>` <st
    c="17895">将假设时间序列是有序的且等距的。</st>
- en: <st c="17954">The output of</st> *<st c="17969">step 10</st>* <st c="17976">consists
    of a DataFrame with 135 rows, containing 3,945 features (execute</st> `<st c="18051">features.shape</st>`
    <st c="18065">to check that out) that characterize the five original time series
    – temperature, light, humidity and its ratio, and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>C</mml:mi><mml:mi>O</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:math>](img/47.png)
    <st c="18183"><st c="18187">in the office.</st> <st c="18202">These</st> <st c="18207">features
    were imputed in</st> *<st c="18233">step 10</st>*<st c="18240">, so you can go
    ahead and use this DataFrame to train another logistic</st> <st c="18311">regression</st>
    <st c="18321">model to predict</st> <st c="18339">o</st><st c="18340">ffice occupancy.</st></st>
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="17954">*<st c="17969">步骤 10</st>* <st c="17976">的输出是一个包含 135 行的 DataFrame，包含
    3,945 个特征（执行</st> `<st c="18051">features.shape</st>` <st c="18065">以检查这一点），这些特征描述了五个原始时间序列——温度、光照、湿度及其比率，以及</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>C</mml:mi><mml:mi>O</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:math>](img/47.png)
    <st c="18183"><st c="18187">办公室。</st> <st c="18202">这些</st> <st c="18207">特征在</st>
    *<st c="18233">步骤 10</st>*<st c="18240">中被插补，因此您可以继续使用此 DataFrame 来训练另一个逻辑</st>
    <st c="18311">回归</st> <st c="18321">模型以预测</st> <st c="18339">办公室</st><st c="18340">的占用情况。</st>
- en: <st c="18356">How it works...</st>
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="18356">它是如何工作的...</st>
- en: <st c="18372">In this recipe, we used</st> `<st c="18397">tsfresh</st>` <st
    c="18404">to automatically create hundreds of features from five time series,
    and then used those features to train a logistic regression model to predict whether
    the office</st> <st c="18569">was occupied.</st>
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="18372">在这个菜谱中，我们使用了</st> `<st c="18397">tsfresh</st>` <st c="18404">来自动从五个时间序列中创建数百个特征，然后使用这些特征来训练一个逻辑回归模型以预测办公室</st>
    <st c="18569">是否被占用。</st>
- en: <st c="18582">Note</st>
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="18582">注意</st>
- en: <st c="18587">To create features with</st> `<st c="18612">tsfresh</st>`<st c="18619">,
    the time-series interval from which we want to extract features must be marked</st>
    <st c="18700">with a</st> `<st c="18755">id</st>` <st c="18757">variable.</st>
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="18587">要使用</st> `<st c="18612">tsfresh</st>`<st c="18619">创建特征，我们想要从中提取特征的时序间隔必须用一个</st>
    `<st c="18700">id</st>` <st c="18755">变量</st c="18757">标记。</st>
- en: <st c="18767">To create features from time series, we used the</st> `<st c="18817">extract_features</st>`
    <st c="18833">function from</st> `<st c="18848">tsfresh</st>`<st c="18855">. This
    function takes the DataFrame containing the time series and the unique identifier
    as input and returns a DataFrame containing the extracted features</st> <st c="19011">as
    output.</st>
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="18767">为了从时间序列创建特征，我们使用了</st> `<st c="18817">extract_features</st>` <st
    c="18833">函数，该函数来自</st> `<st c="18848">tsfresh</st>`<st c="18855">。此函数接受包含时间序列和唯一标识符的
    DataFrame 作为输入，并返回一个包含提取特征的 DataFrame 作为输出。</st> <st c="19011">（执行</st> `<st c="18051">features.shape</st>`
    <st c="18065">以检查这一点）。</st>
- en: '`<st c="19021">extract_features</st>` <st c="19038">has three key parameters:</st>
    `<st c="19065">column_id</st>`<st c="19074">,</st> `<st c="19076">column_sort</st>`<st
    c="19087">, and</st> `<st c="19093">impute_function</st>`<st c="19108">.</st>
    `<st c="19110">column_id</st>` <st c="19119">receives the name of the column with
    the unique identifier for each sequence that’ll be used to extract features.</st>
    `<st c="19234">column_sort</st>` <st c="19245">is used to reorder the time series
    before extracting features.</st> <st c="19309">When</st> `<st c="19314">column_sort</st>`
    <st c="19325">is left to</st> `<st c="19337">None</st>`<st c="19341">,</st> `<st
    c="19343">tsfresh</st>` <st c="19350">assumes that the data is ordered chronologically
    and that the timestamps are equidistant.</st> <st c="19441">In</st> *<st c="19444">step
    10</st>*<st c="19451">, we passed the</st> `<st c="19467">date</st>` <st c="19471">variable
    as the sorting variable, which informs</st> `<st c="19520">tsfresh</st>` <st c="19527">how
    to sort the data before extracting</st> <st c="19567">the features.</st>'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`<extract_features>`有三个关键参数：`column_id`、`column_sort`和`impute_function`。`column_id`接收用于提取特征时每个序列的唯一标识符的列名。`column_sort`用于在提取特征之前重新排序时间序列。当`column_sort`被设置为`None`时，`tsfresh`假设数据是按时间顺序排列的，并且时间戳是等距的。在*步骤10*中，我们传递了`date`变量作为排序变量，这通知`tsfresh`在提取特征之前如何排序数据。'
- en: <st c="19580">Note</st>
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: <st c="19585">In our dataset, leaving</st> `<st c="19610">column_sort</st>`
    <st c="19621">set to</st> `<st c="19629">None</st>` <st c="19633">or passing the</st>
    `<st c="19649">date</st>` <st c="19653">variable made no difference, because our
    time series were already ordered chronologically and the timestamps were equidistant.</st>
    <st c="19781">If this is not the case in your time series, use this parameter
    to create</st> <st c="19855">features correctly.</st>
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的数据集中，将`column_sort`设置为`None`或传递`date`变量没有区别，因为我们的时间序列已经是按时间顺序排列的，并且时间戳是等距的。如果您的时序不是这种情况，请使用此参数正确创建特征。
- en: <st c="19874">Finally,</st> `<st c="19884">extract_features</st>` <st c="19900">also
    accepts the</st> `<st c="19918">impute</st>` <st c="19924">function through the</st>
    `<st c="19946">impute_function</st>` <st c="19961">parameter, to</st> <st c="19975">automatically</st>
    <st c="19990">remove infinite and</st> `<st c="20010">NaN</st>` <st c="20013">values
    from the created features.</st> <st c="20048">Will discuss additional parameters
    of</st> `<st c="20086">extract_features</st>` <st c="20102">in the</st> <st c="20110">coming
    recipes.</st>
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**最后**，`extract_features`也接受通过`impute_function`参数的`impute`函数，以自动从创建的特征中移除无限和`NaN`值。将在后续菜谱中讨论`extract_features`的附加参数。'
- en: <st c="20125">Note</st>
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: <st c="20130">For more details</st> <st c="20148">about the</st> `<st c="20158">extract_features</st>`
    <st c="20174">function,</st> <st c="20185">visit</st> [<st c="20191">https://tsfresh.readthedocs.io/en/latest/api/tsfresh.feature_extraction.html#module-tsfresh.feature_extraction.extraction</st>](https://tsfresh.readthedocs.io/en/latest/api/tsfresh.feature_extraction.html#module-tsfresh.feature_extraction.extraction)<st
    c="20312">.</st>
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '[更多关于`extract_features`函数的细节](https://tsfresh.readthedocs.io/en/latest/api/tsfresh.feature_extraction.html#module-tsfresh.feature_extraction.extraction)。'
- en: <st c="20313">The</st> `<st c="20318">im</st><st c="20320">pute</st>` <st c="20325">function,
    which can be used independently, as we did in</st> *<st c="20382">step 7</st>*<st
    c="20388">, or within the</st> `<st c="20404">extract_features</st>` <st c="20420">function,
    as we did in</st> *<st c="20444">step 10</st>*<st c="20451">, replaced</st> `<st
    c="20462">NAN</st>`<st c="20465">,</st> `<st c="20467">-Inf</st>`<st c="20471">,
    and</st> `<st c="20477">Inf</st>` <st c="20480">values</st> <st c="20487">with
    the variable’s median, minimum, or maximum values, respectively.</st> <st c="20558">If
    the feature contains only</st> `<st c="20587">NaN</st>` <st c="20590">values,
    they are replaced by zeroes.</st> <st c="20628">The imputation occurs in place
    – that is, in the same DataFrame that is</st> <st c="20700">being imputed.</st>
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: <st c="20714">The</st> `<st c="20719">extract_features</st>` <st c="20735">function
    returns a DataFrame containing as many rows as unique identifiers in the data.</st>
    <st c="20824">In our case, it returned a DataFrame with 135 rows.</st> <st c="20876">The
    columns of the resulting DataFrame correspond to the 789 values that were returned
    by 63 characterization methods applied to each of the 135 60-minute</st> <st c="21031">time
    series.</st>
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: <st c="21043">In</st> *<st c="21047">step 5</st>*<st c="21053">, we explored
    some of the resulting features, which captured the time series mean, variance,
    and coefficient of variation, as well as their length.</st> <st c="21201">Let’s
    explore a few more of the</st> <st c="21233">resulting features.</st>
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: <st c="21252">Some of the created variables are self-explanatory.</st> <st c="21305">For
    example, the</st> `<st c="21322">'light__skewness'</st>` <st c="21339">and</st>
    `<st c="21344">'light__kurtosis'</st>` <st c="21361">variables contain the skewness
    and kurtosis coefficients, which characterize the data distribution.</st> <st
    c="21462">The</st> `<st c="21466">'light__has_duplicate_max'</st>`<st c="21492">,</st>
    `<st c="21494">'light__has_duplicate_min'</st>`<st c="21520">, and</st> `<st c="21526">'light__has_duplicate'</st>`
    <st c="21548">variables indicate whether the time series has duplicated values
    or duplicated minimum or maximum values within the time interval.</st> <st c="21680">The</st>
    `<st c="21684">'light__quantile__q_0.1'</st>`<st c="21708">,</st> `<st c="21710">'light__quantile__q_0.2'</st>`<st
    c="21734">, and</st> `<st c="21740">'light__quantile__q_0.3'</st>` <st c="21764">variables
    display the different quantile values of the time series.</st> <st c="21833">Finally,
    the</st> `<st c="21846">'light__autocorrelation__lag_0'</st>`<st c="21877">,</st>
    `<st c="21879">'light__autocorrelation__lag_1'</st>`<st c="21910">, and</st> `<st
    c="21916">'light__autocorrelation__lag_2'</st>` <st c="21947">variables show the
    autocorrelation of the time series with its past values, lagged by 0, 1, or 2
    steps – information that is generally useful</st> <st c="22090">i</st><st c="22091">n
    forecasting.</st>
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="21252">其中一些创建的变量是自解释的。</st><st c="21305">例如，</st><st c="21322">'light__skewness'</st><st
    c="21339">和</st><st c="21344">'light__kurtosis'</st><st c="21361">变量包含偏度和峰度系数，这些系数表征了数据分布。</st><st
    c="21462">`<st c="21466">'light__has_duplicate_max'</st>`<st c="21492">，`<st c="21494">'light__has_duplicate_min'</st>`<st
    c="21520">，以及</st><st c="21526">'light__has_duplicate'</st>`<st c="21548">变量指示时间序列在时间间隔内是否有重复值或重复的最小值或最大值。</st><st
    c="21680">`<st c="21684">'light__quantile__q_0.1'</st>`<st c="21708">，`<st c="21710">'light__quantile__q_0.2'</st>`<st
    c="21734">，以及</st><st c="21740">'light__quantile__q_0.3'</st>`<st c="21764">变量显示了时间序列的不同分位数。</st><st
    c="21833">最后，</st><st c="21846">'light__autocorrelation__lag_0'</st>`<st c="21877">，`<st
    c="21879">'light__autocorrelation__lag_1'</st>`<st c="21910">，以及</st><st c="21916">'light__autocorrelation__lag_2'</st>`<st
    c="21947">变量显示了时间序列与其过去值的自相关，滞后0，1或2步——这些信息通常在预测中很有用。</st><st c="22090">i</st><st
    c="22091">n</st><st c="22092">预测。</st>
- en: <st c="22105">Other characterization methods return fe</st><st c="22146">atures
    obtained from signal processing</st> <st c="22185">algorithms, such</st> <st c="22203">as</st>
    <st c="22206">the continuous wavelet transform for the Ricker wavelet, which returns
    the</st> `<st c="22281">'light__cwt_coefficients__coeff_0__w_2__widths_(2, 5,
    10, 20)'</st>`<st c="22343">,</st> `<st c="22345">'light__cwt_coefficients__coeff_0__w_5__widths_(2,
    5, 10, 20)'</st>`<st c="22407">,</st> `<st c="22409">'light__cwt_coefficients__coeff_0__w_10__widths_(2,
    5, 10, 20)'</st>`<st c="22472">, and</st> `<st c="22478">'light__cwt_coefficients__coeff_0__w_20__widths_(2,
    5, 10, 20)'</st>` <st c="22541">features,</st> <st c="22552">among others.</st>
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="22105">其他特征描述方法返回来自信号处理算法的特征</st><st c="22146">，例如</st><st c="22185">对于Ricker小波，它返回</st><st
    c="22203">以下</st><st c="22206">特征</st>，即`<st c="22281">'light__cwt_coefficients__coeff_0__w_2__widths_(2,
    5, 10, 20)'</st>`<st c="22343">，`<st c="22345">'light__cwt_coefficients__coeff_0__w_5__widths_(2,
    5, 10, 20)'</st>`<st c="22407">，`<st c="22409">'light__cwt_coefficients__coeff_0__w_10__widths_(2,
    5, 10, 20)'</st>`<st c="22472">，以及</st><st c="22478">'light__cwt_coefficients__coeff_0__w_20__widths_(2,
    5, 10, 20)'</st>`<st c="22541">等。</st><st c="22552">其中一些。</st>
- en: <st c="22565">Note</st>
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="22565">注意</st>
- en: <st c="22570">We can’t discuss each of these feature characterization methods
    or their outputs in detail in this book because there are too many.</st> <st c="22703">You
    can find more details about the transformations</st> <st c="22755">supported by</st>
    `<st c="22768">tsfresh</st>` <st c="22775">and their formulation</st> <st c="22798">at</st>
    [<st c="22801">https://tsfresh.readthedocs.io/en/latest/api/tsfresh.feature_extraction.html</st>](https://tsfresh.readthedocs.io/en/latest/api/tsfresh.feature_extraction.html)<st
    c="22877">.</st>
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="22570">由于方法众多，本书无法详细讨论每种特征描述方法及其输出。</st><st c="22703">您可以在[<st c="22801">https://tsfresh.readthedocs.io/en/latest/api/tsfresh.feature_extraction.html</st>](https://tsfresh.readthedocs.io/en/latest/api/tsfresh.feature_extraction.html)找到有关`<st
    c="22768">tsfresh</st>`支持的转换及其公式的更多详细信息。</st><st c="22877">。</st>
- en: <st c="22878">Some of the features that are automatically created by</st> `<st
    c="22934">tsfresh</st>` <st c="22941">may not make sense or even be possible to
    calculate for some time series because they require a certain length or data variability,
    or the time series must meet certain distribution assumptions.</st> <st c="23137">Therefore,
    the suitability of the features will depend on the nature of the</st> <st c="23213">time
    series.</st>
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="22878">由</st> `<st c="22934">tsfresh</st>` <st c="22941">自动创建的一些特征可能对某些时间序列没有意义，甚至无法计算，因为它们需要一定的长度或数据变化性，或者时间序列必须满足某些分布假设。</st>
    <st c="23137">因此，特征的可适用性将取决于时间序列的性质。</st>
- en: <st c="23225">Note</st>
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23225">注意</st>
- en: <st c="23230">You can decide which features to extract from your time series
    based on domain knowledge, or by creating all possible features and then applying
    feature selection algorithms or following up with data analysis.</st> <st c="23441">In
    fact, from our dataset, many of the resulting features were either constant or
    contained only missing data.</st> <st c="23552">Hence, we can reduce the feature
    space to informative features by taking those fe</st><st c="23633">atures out
    of</st> <st c="23648">the data.</st>
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23230">您可以根据领域知识决定从您的时序数据中提取哪些特征，或者通过创建所有可能的特征，然后应用特征选择算法或进行数据分析。</st>
    <st c="23441">实际上，从我们的数据集中，许多生成的特征要么是恒定的，要么只包含缺失数据。</st> <st c="23552">因此，我们可以通过从数据中去除这些特征来减少特征空间到信息特征。</st>
- en: <st c="23657">See also</st>
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="23657">另请参阅</st>
- en: <st c="23666">For more</st> <st c="23675">details about</st> `<st c="23690">tsfresh</st>`<st
    c="23697">, check</st> <st c="23705">out the article Christ M., Braun N., , Neuffer
    J., and Kempa-Liehr A., (2018).</st> *<st c="23784">Time Series FeatuRe Extraction
    on basis of Scalable Hypothesis tests (tsfresh – A Python package).</st> <st c="23883">Neurocomputing
    307 (2018).</st> <st c="23910">Pages</st>* *<st c="23916">72-77.</st>* [<st c="23922">https://dl.acm.org/doi/10.1</st><st
    c="23950">016/j.neucom.2018.03.067</st>](https://dl.acm.org/doi/10.1016/j.neucom.2018.03.067)<st
    c="23975">.</st>
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23666">有关</st> <st c="23675">`<st c="23690">tsfresh</st>`</st> <st c="23697">的更多</st>
    <st c="23705">详细信息，请参阅文章 Christ M.，Braun N.，，Neuffer J.，和 Kempa-Liehr A. (2018)。</st>
    *<st c="23784">基于可扩展假设检验的时间序列特征提取 (tsfresh – 一个Python包)。</st> <st c="23883">神经计算
    307 (2018)。</st> <st c="23910">第</st>* *<st c="23916">72-77页。</st>* [<st c="23922">https://dl.acm.org/doi/10.1</st><st
    c="23950">016/j.neucom.2018.03.067</st>](https://dl.acm.org/doi/10.1016/j.neucom.2018.03.067)<st
    c="23975">。</st>
- en: <st c="23976">Automatically creating and selecting predictive features fr</st><st
    c="24036">om time-series data</st>
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="23976">自动从时间序列数据中创建和选择预测特征</st>
- en: <st c="24056">In the previous</st> <st c="24073">recipe, we</st> <st c="24084">automatically
    extracted several hundred features from time-series variables using</st> `<st
    c="24166">tsfresh</st>`<st c="24173">. If we have more than one time-series variable,
    we can easily end up with a dataset containing thousands of features.</st> <st
    c="24292">In addition, many of the resulting features had only missing data or
    were constant and were therefore not useful for training mach</st><st c="24422">ine</st>
    <st c="24427">learning models.</st>
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个<st c="24056">菜谱</st> <st c="24073">中，我们</st> <st c="24084">使用</st> `<st
    c="24166">tsfresh</st>`<st c="24173">自动从时间序列变量中提取了数百个特征。如果我们有多个时间序列变量，我们很容易得到一个包含数千个特征的数据库。</st>
    <st c="24292">此外，许多生成的特征只有缺失数据或恒定值，因此对训练机器学习模型没有用。</st><st c="24422">学习</st> <st
    c="24427">模型。</st>
- en: <st c="24443">When we create classiﬁcation and regression models to solve real-life
    problems, we often want our models to take a small number of relevant features
    as input to produce interpretable machine learning outputs.</st> <st c="24653">Simpler
    models have many advantages.</st> <st c="24690">First, their output is easier
    to interpret.</st> <st c="24734">Second, simpler models are cheaper to store and
    faster to train.</st> <st c="24799">They also return th</st><st c="24818">eir</st>
    <st c="24823">outputs faster.</st>
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="24443">当我们创建分类和回归模型来解决现实生活中的问题时，我们通常希望我们的模型只输入少量相关特征以产生可解释的机器学习输出。</st>
    <st c="24653">简单的模型有很多优点。</st> <st c="24690">首先，它们的输出更容易解释。</st> <st c="24734">其次，简单的模型存储成本低，训练速度快。</st>
    <st c="24799">它们也能更快地返回输出。</st>
- en: '`<st c="24838">tsfresh</st>` <st c="24846">includes a highly parallelizable
    feature selection algorithm based on non-parametric statistical hypothesis tests,
    which can be executed at the back of the feature creation procedure to quickly
    remove irrelevant features.</st> <st c="25069">The feature selection procedure
    utilizes different tests for</st> <st c="25129">different features.</st>'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="24838">tsfresh</st>` 包含一个基于非参数统计假设检验的高度可并行化的特征选择算法，该算法可以在特征创建过程之后执行，以快速去除不相关的特征。特征选择过程利用不同的测试针对不同的特征。'
- en: '`<st c="25149">tsfresh</st>` <st c="25157">uses the following tests to</st>
    <st c="25186">select features:</st>'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="25149">tsfresh</st>` 使用以下测试来 `<st c="25186">选择特征</st>`：'
- en: <st c="25202">Fisher’s exact test of independence, if both the feature and the
    target</st> <st c="25275">are binary</st>
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果特征和目标 `<st c="25275">都是二进制</st>` 的 `<st c="25202">费舍尔精确检验独立性</st>`，
- en: <st c="25285">Kolmogorov-Smirnov test, if either the feature or the target</st>
    <st c="25347">is binary</st>
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果特征或目标 `<st c="25347">是二进制</st>` 的 `<st c="25285">科尔莫哥洛夫-斯米尔诺夫检验</st>`，
- en: <st c="25356">Kendall rank test, if neither the feature nor the target</st>
    <st c="25414">is binary</st>
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果特征或目标 `<st c="25414">都不是二进制</st>` 的 `<st c="25356">肯德尔秩次检验</st>`，
- en: <st c="25423">The advantage of these tests is that they are non-parametric,
    and thus make no assumptions on the underlying distribution of the variables</st>
    <st c="25563">being tested.</st>
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测试的优势在于它们是非参数的，因此不对被测试变量的潜在分布做出假设。
- en: <st c="25576">The result of these tests is a vector of p-values that measures
    the significance of the association between each feature and the target.</st>
    <st c="25714">These p-values are then evaluated based on</st> <st c="25756">the</st>
    <st c="25761">Benjamini-Yekutieli procedure to decide which features</st> <st
    c="25816">to keep.</st>
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测试的结果是一个衡量每个特征与目标之间关联显著性的 p 值向量。然后根据 `<st c="25756">本雅明-叶库蒂埃</st>` 程序对这些 p
    值进行评估，以决定保留哪些特征。
- en: <st c="25824">Note</st>
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="25824">注意</st>`'
- en: <st c="25829">For more details abo</st><st c="25850">ut</st> `<st c="25854">tsfresh</st>`<st
    c="25861">’s featu</st><st c="25870">re selection procedure, check out the article
    Christ, Kempa-Liehr, and Feindt,</st> *<st c="25950">Distributed and parallel
    time series feature extraction for industrial big data applications</st>*<st c="26042">.
    Asian Machine Learning Conference (ACML) 2016, Workshop on Learning on Big Data
    (WLBD), Hamilton (New Zealand),</st> <st c="26156">arXiv,</st> [<st c="26163">https://arxiv.org/abs/1610.07717v1</st>](https://arxiv.org/abs/1610.07717v1)<st
    c="26197">.</st>
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `<st c="25854">tsfresh</st>` 的特征选择过程的更多详细信息，请参阅 Christ, Kempa-Liehr, 和 Feindt
    的文章，*<st c="25950">分布式和并行时间序列特征提取用于工业大数据应用</st>*。亚洲机器学习会议 (ACML) 2016，大数据学习研讨会
    (WLBD)，汉密尔顿（新西兰），arXiv，[<st c="26163">https://arxiv.org/abs/1610.07717v1</st>](https://arxiv.org/abs/1610.07717v1)。
- en: <st c="26198">In this recipe, we will automatically create hundreds of features
    from various time series, and then select the most relevant f</st><st c="26326">eatures
    by</st> <st c="26338">utilizing</st> `<st c="26348">tsfresh</st>`<st c="26355">.</st>
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将自动从各种时间序列中创建数百个特征，然后通过使用 `<st c="26348">tsfresh</st>` 来选择最相关的特征。
- en: <st c="26356">How</st> <st c="26360">to do it...</st>
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`<st c="26356">如何做到...</st>`'
- en: <st c="26372">We will begin by automatically creating and selecting features
    from one time series,</st> `<st c="26458">lights</st>`<st c="26464">, and then
    we will automate the procedure for multiple</st> <st c="26519">time series:</st>
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先自动从单个时间序列 `<st c="26458">lights</st>` 中创建和选择特征，然后我们将自动化针对多个 `<st c="26519">时间序列</st>`
    的过程：
- en: <st c="26531">Let’s import the required Python libraries</st> <st c="26575">and
    functions:</st>
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们导入所需的 Python 库和函数：
- en: '[PRE17]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: <st c="26907">Load the</st> <st c="26916">dataset</st> <st c="26925">and the
    target variable described in the</st> *<st c="26966">Technical</st>* *<st c="26976">requirements</st>*
    <st c="26988">section:</st>
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载在 *<st c="26966">技术</st>* *<st c="26976">要求</st>* 部分中描述的 `<st c="26925">数据集</st>`
    和目标变量：
- en: '[PRE18]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: <st c="27122">Let’s create hundreds of features automatically for each hour
    of</st> `<st c="27188">light</st>` <st c="27193">use records and impute the</st>
    <st c="27221">resulting features:</st>
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们为每个小时的**使用记录**自动创建数百个特征，并填补结果特征：
- en: '[PRE19]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: <st c="27331">The output of the previous step is a DataFrame with 135 rows and
    789 columns, corresponding to the features created from each hour of</st> <st
    c="27466">light consumption.</st>
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上一步的输出是一个包含 135 行和 789 列的 DataFrame，对应于从每个小时的**能耗**中创建的特征。
- en: <st c="27484">Note</st>
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: <st c="27489">For more details about</st> *<st c="27513">step 3</st>*<st c="27519">,
    or the Occupancy Detection dataset, check out the</st> *<st c="27571">Extracting
    hundreds of features automatically from a time</st>* *<st c="27629">seri</st><st
    c="27633">es</st>* <st c="27636">recipe.</st>
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 关于**步骤 3**或占用检测数据集的更多详细信息，请查看**从时间序列中自动提取数百个特征**的食谱。
- en: <st c="27644">Now, let’s select the features based on the non-parametric tests
    that we mentioned in the introduction of</st> <st c="27751">this recipe:</st>
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们根据我们在本食谱介绍中提到的非参数测试来选择特征：
- en: '[PRE20]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: <st c="27803">If we execute</st> `<st c="27818">len(features)</st>`<st c="27831">,
    we’ll see the value</st> `<st c="27853">135</st>`<st c="27856">, which means that
    from the 789 features created in</st> *<st c="27908">step 3</st>*<st c="27914">,
    only 135 are statistically significant.</st> <st c="27956">Go ahead and execute</st>
    `<st c="27977">features.head()</st>` <st c="27992">to display the first five rows
    of the</st> <st c="28031">resulting DataFrame.</st>
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们执行 `<st c="27818">len(features)</st>`<st c="27831">，我们将看到值 `<st c="27853">135</st>`<st
    c="27856">，这意味着从**步骤 3**中创建的 789 个特征中，只有 135 个具有统计学意义。继续执行 `<st c="27977">features.head()</st>`<st
    c="27992">以显示结果 DataFrame 的前五行。
- en: <st c="28051">For space reasons, we will only display the first</st> <st c="28102">five
    features:</st>
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于空间原因，我们只将显示前**五**个特征：
- en: '[PRE21]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: <st c="28169">In</st> <st c="28172">the</st> <st c="28176">following DataFrame,
    we see the values of the first five features for the first</st> <st c="28257">five
    hours of</st> <st c="28271">light consumption:</st>
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在以下 DataFrame 中，我们可以看到前五个小时的**能耗**的前五个特征的值：
- en: '![Figure 10.6 – DataFrame with five of the selected features created from each
    hour of light consumption](img/B22396_10_06.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.6 – 从每个小时的能耗中创建的五个选定特征的 DataFrame](img/B22396_10_06.jpg)'
- en: <st c="28549">Figure 10.6 – DataFrame with five of the selected features created
    from each hour of light consumption</st>
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.6 – 从每个小时的能耗中创建的五个选定特征的 DataFrame
- en: <st c="28651">Check the discussion in the</st> *<st c="28680">How it works…</st>*
    <st c="28693">section for a more detailed analysis of the DataFrame resulting
    from</st> *<st c="28763">step 4</st>*<st c="28769">.</st>
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在**如何工作…**部分查看讨论，以获取关于**步骤 4**产生的 DataFrame 的更详细分析。
- en: <st c="28770">Now, we will use the features from</st> *<st c="28806">step 4</st>*
    <st c="28812">to train a logistic regression model and predict whether the office
    was occupied.</st> <st c="28895">Let’s begin by separating the dataset into training
    and</st> <st c="28951">test sets:</st>
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将使用**步骤 4**中的特征来训练一个逻辑回归模型，并预测办公室是否被占用。首先，我们将数据集分为训练集和测试集：
- en: '[PRE22]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: <st c="29061">Let’s set</st> <st c="29072">up</st> <st c="29074">and train a
    logistic regression model and then evaluate</st> <st c="29131">its performance:</st>
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们设置并训练一个逻辑回归模型，然后评估其性能：
- en: '[PRE23]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: <st c="29298">In the following output, we see the values of commonly used evaluation
    metrics for classification analysis.</st> <st c="29407">These suggest that the
    selected features are useful for predicting</st> <st c="29474">office occupancy:</st>
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在以下输出中，我们可以看到用于分类分析的常用评估指标值。这些指标表明，所选特征对预测办公室占用情况很有用：
- en: '[PRE24]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: features = extract_relevant_features(
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: features = extract_relevant_features(
- en: X,
  id: totrans-159
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: X,
- en: y,
  id: totrans-160
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: y,
- en: column_id="id",
  id: totrans-161
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: column_id="id",
- en: column_sort="date",
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: column_sort="date",
- en: )
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: )
- en: '[PRE25]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '**<st c="30226">Note</st>'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: <st c="30231">The parameters of</st> `<st c="30250">extract_relevant_features</st>`
    <st c="30275">are very similar to those of</st> `<st c="30305">extract_features</st>`<st
    c="30321">. Note, however, that the former will automatically perform imputation
    to be able to proceed with the feature selection.</st> <st c="30442">We discussed
    the parameters of</st> `<st c="30473">extract_features</st>` <st c="30489">in
    the</st> *<st c="30497">Extracting hundreds of features automatically from time</st>*
    *<st c="30553">series</st>* <st c="30559">recipe.</st>
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="30231">`extract_relevant_features` 的参数与 `extract_features` 的参数非常相似。</st>
    <st c="30250">然而，请注意，前者将自动执行插补以能够进行特征选择。</st> <st c="30442">我们在 *<st c="30473">从时间序列中自动提取数百个特征</st>
    *<st c="30489">食谱</st> 中讨论了 `extract_features` 的参数。</st>
- en: <st c="30567">The output of</st> *<st c="30582">step 8</st>* <st c="30588">consists
    of a DataFrame with 135 rows and 968 features, from the original 3,945 that are
    returned by default by</st> `<st c="30701">tsfresh</st>` <st c="30708">(you can
    check that out by executing</st> `<st c="30746">features.shape</st>`<st c="30760">).</st>
    <st c="30764">Go ahead and use this DataFrame to train another logistic regressio</st><st
    c="30831">n model to predict</st> <st c="30851">office occupancy</st><st c="30867">.</st>
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="30567">步骤 8 的</st> *<st c="30582">输出</st>* <st c="30588">由一个包含 135 行和
    968 个特征的 DataFrame 组成，这些特征是从默认返回的 3,945 个原始特征中提取的，由 <st c="30701">tsfresh</st>
    <st c="30708">返回（你可以通过执行 <st c="30746">features.shape</st> <st c="30760">来检查这一点）。</st>
    <st c="30764">继续使用这个 DataFrame 来训练另一个逻辑回归模型以预测办公室占用率。</st><st c="30831">。</st>
    <st c="30851">。</st> <st c="30867">。</st>
- en: <st c="30868">How it works...</st>
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="30868">它是如何工作的...</st>
- en: <st c="30884">In this</st> <st c="30892">recipe, we</st> <st c="30904">created
    hundreds of features from a time series and then selected the most relevant features
    based on non-parametric statistical tests.</st> <st c="31040">The feature creation
    and selection procedures were carried out automatically</st> <st c="31117">by</st>
    `<st c="31120">tsfresh</st>`<st c="31127">.</st>
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="30884">在这个</st> <st c="30892">食谱</st> 中，我们 <st c="30904">从时间序列中创建了数百个特征，然后根据非参数统计测试选择了最相关的特征。</st>
    <st c="31040">特征创建和选择过程是通过 <st c="31117">tsfresh</st> <st c="31127">自动执行的。</st>
- en: <st c="31128">To create the features, we used</st> `<st c="31161">tsfresh</st>`<st
    c="31168">’s</st> `<st c="31172">extract_features</st>` <st c="31188">function,
    which we described in detail in the</st> *<st c="31235">Extracting hundreds of
    features automatical</st><st c="31278">ly from a time</st>* *<st c="31294">series</st>*
    <st c="31300">recipe.</st>
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="31128">为了创建特征，我们使用了 <st c="31161">tsfresh</st> 的 <st c="31168">extract_features</st>
    <st c="31188">函数，我们在 *<st c="31235">从时间序列中自动提取数百个特征</st> *<st c="31278">食谱</st>
    中对其进行了详细描述。</st>
- en: <st c="31308">To select features, we used the</st> `<st c="31341">select_features</st>`
    <st c="31356">function, also from</st> `<st c="31377">tsfresh</st>`<st c="31384">.
    This function applies different statistical tests, depending on the nature of
    the feature and the target.</st> <st c="31492">Briefly, if the feature and target
    are binary, it tests their relationship with Fisher’s exact test.</st> <st c="31593">If
    either the feature or the target is binary, and the other variable is continuous,
    it tests their relationship by using the Kolmogorov-Smirnov test.</st> <st c="31744">If
    neither the features nor the target is binary, it uses the Kendall</st> <st c="31814">rank
    test.</st>
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="31308">为了选择特征，我们使用了来自 <st c="31377">tsfresh</st> 的 <st c="31341">select_features</st>
    <st c="31356">函数。这个函数根据特征的性质和目标应用不同的统计测试。</st> <st c="31492">简而言之，如果特征和目标是二元的，它通过费舍尔精确测试测试它们之间的关系。</st>
    <st c="31593">如果特征或目标是二元的，而另一个变量是连续的，它通过使用柯尔莫哥洛夫-斯米尔诺夫测试来测试它们之间的关系。</st> <st c="31744">如果特征和目标都不是二元的，它使用肯德尔秩测试。</st>
- en: <st c="31824">The result of these tests is a vector with one p-value per feature.</st>
    <st c="31893">Next,</st> `<st c="31899">tsfresh</st>` <st c="31906">applies the
    Benjamini-Yekutieli procedure, which aims to reduce the false discovery rate,
    to select which features to keep based on the p-values.</st> <st c="32053">This
    feature selection procedure has some advantages, the main one being that statistical
    tests are fast to compute, and therefore the selection algorithm is scalable and
    can be parallelized.</st> <st c="32245">Another advantage is that the tests are
    non-parametric and hence suitable for linear and</st> <st c="32334">non-linear
    models.</st>
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="31824">这些测试的结果是一个向量，每个特征都有一个p值。</st> <st c="31893">接下来，</st> `<st c="31899">tsfresh</st>`
    <st c="31906">应用Benjamini-Yekutieli程序，旨在降低错误发现率，根据p值选择要保留的特征。</st> <st c="32053">这种特征选择程序有一些优点，主要优点是统计测试计算速度快，因此选择算法可扩展且可并行化。</st>
    <st c="32245">另一个优点是测试是非参数的，因此适用于线性和非线性模型。</st>
- en: <st c="32352">However, feature selection methods that evaluate each feature
    individually are unable to remove redundant features.</st> <st c="32469">In fact,
    many of the features automatically created by</st> `<st c="32524">tsfresh</st>`
    <st c="32531">will be highly correlated, like those capturing the different quantiles
    of light consumption.</st> <st c="32626">Hence, they will show similar p-values
    and be retained.</st> <st c="32682">But in practice, we only need one or a few
    of them to capture the information of the time series.</st> <st c="32780">I’d
    recommend following up the</st> `<st c="32811">tsfresh</st>` <st c="32818">selection
    procedure with alternative feature selection methods that are able to pick up</st>
    <st c="32907">feature interactions.</st>
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，评估每个特征单独的特征选择方法无法去除冗余特征。<st c="32469">事实上，许多由</st> `<st c="32524">tsfresh</st>`
    <st c="32531">自动创建的特征将高度相关，例如那些捕捉到不同消费分位数的光照。</st> <st c="32626">因此，它们将显示相似的p值并被保留。</st>
    <st c="32682">但在实践中，我们只需要一个或少数几个来捕捉时间序列的信息。</st> <st c="32780">我建议使用能够识别</st>
    `<st c="32811">tsfresh</st>` <st c="32818">选择程序中特征交互的替代特征选择方法。</st>
- en: <st c="32928">Finally, in</st> *<st c="32941">step 8</st>*<st c="32947">, we
    combined the feature creation step (</st>*<st c="32988">step 3</st>*<st c="32995">)
    with the feature selection step (</st>*<st c="33031">step 4</st>*<st c="33038">)
    by using the</st> `<st c="33054">extract_relevant_features</st>` <st c="33079">function.</st>
    `<st c="33090">extract_relevant_features</st>` <st c="33115">applies the</st>
    `<st c="33128">extract_features</st>` <st c="33144">function to create the features
    from each time series and imputes them.</st> <st c="33217">Next, it applies the</st>
    `<st c="33238">select_features</st>` <st c="33253">function to return a DataFrame
    containing one row per unique identifier, and the features that were selected
    for each time series.</st> <st c="33385">Note that different features can</st>
    <st c="33417">be</st> <st c="33421">selected for different</st> <st c="33444">time
    series.</st>
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="32928">最后，在</st> *<st c="32941">步骤8</st>*<st c="32947">中，我们通过使用</st>
    `<st c="33054">extract_relevant_features</st>` <st c="33079">函数将特征创建步骤（</st>*<st
    c="32988">步骤3</st>*<st c="32995">）与特征选择步骤（</st>*<st c="33031">步骤4</st>*<st c="33038">）结合起来。</st>
    `<st c="33090">extract_relevant_features</st>` <st c="33115">将</st> `<st c="33128">extract_features</st>`
    <st c="33144">函数应用于从每个时间序列中创建特征并进行插补。</st> <st c="33217">接下来，它应用</st> `<st c="33238">select_features</st>`
    <st c="33253">函数以返回一个DataFrame，其中每行都有一个唯一的标识符，以及为每个时间序列选择的特征。</st> <st c="33385">请注意，不同的特征可以为不同的</st>
    <st c="33417">时间序列</st> <st c="33421">选择。</st>
- en: <st c="33456">See also</st>
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="33456">另请参阅</st>
- en: <st c="33465">The selection algorithm from</st> `<st c="33495">tsfresh</st>`
    <st c="33502">offers a quick method to remove irrelevant features.</st> <st c="33556">However,
    it does not find the best feature subset for the classification or regression
    task.</st> <st c="33649">Other feature selection methods can be applied at the
    back of</st> `<st c="33711">tsfresh</st>`<st c="33718">’s algorithm to reduce
    the feature</st> <st c="33754">space further.</st>
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="33465">`<st c="33495">tsfresh</st>` <st c="33502">的选择算法提供了一个快速的方法来去除无关特征。</st>
    <st c="33556">然而，它并不能找到分类或回归任务的最佳特征子集。</st> <st c="33649">可以在</st> `<st c="33711">tsfresh</st>`<st
    c="33718">算法之后应用其他特征选择方法来进一步减少特征</st> <st c="33754">空间。</st>
- en: <st c="33768">For more details on feature selection algorithms, check out the
    book</st> *<st c="33838">Feature Selection in Machine Learning with Python</st>*
    <st c="33887">by Soledad Galli on</st> <st c="33908">Leanpub:</st> [<st c="33917">https://leanpub.com</st><st
    c="33936">/feature-selection-in-machine-learning/</st>](https://leanpub.com/feature-selection-in-machine-learning/)<st
    c="33976">.</st>
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="33768">有关特征选择算法的更多详细信息，请参阅Soledad Galli所著的书籍</st> *<st c="33838">《Python机器学习中的特征选择》*
    <st c="33887">在Leanpub上的内容：</st> [<st c="33917">https://leanpub.com</st><st c="33936">/feature-selection-in-machine-learning/</st>](https://leanpub.com/feature-selection-in-machine-learning/)<st
    c="33976">。</st>
- en: <st c="33977">Extracting diffe</st><st c="33994">rent features from different
    time series</st>
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="33977">从不同的时间序列中提取不同的特征</st>
- en: '`<st c="34035">tsfresh</st>` <st c="34043">extracts</st> <st c="34053">many
    features based on the time-series characteristics and distribution, such as their
    correlation properties, stationarity, and entropy.</st> <st c="34191">It also
    applies non-linear time-series analysis functions, which decompose the time-series
    signal through, for example, Fourier or wavelet transformations.</st> <st c="34347">Depending
    on the nature of the time series, some of these transformations make more sense
    than others.</st> <st c="34450">For example, wavelength decomposition methods
    can make sense for time series resulting from signals or sensors but are not always
    useful for time series representing sales or</st> <st c="34625">stock prices.</st>'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="34035">tsfresh</st>` <st c="34043">基于时间序列的特征和分布提取许多特征，例如它们的关联属性、平稳性和熵。</st>
    <st c="34191">它还应用非线性时间序列分析函数，例如通过傅里叶或小波变换分解时间序列信号。</st> <st c="34347">根据时间序列的性质，这些变换中的一些比其他的有意义。</st>
    <st c="34450">例如，波长分解方法对于由信号或传感器产生的时间序列是有意义的，但并不总是对表示销售或</st> <st c="34625">股价的时间序列有用。</st>'
- en: <st c="34638">In this recipe, we will discuss how to optimize the feature extracti</st><st
    c="34707">on procedure to extract specific features from each time series, and
    then use th</st><st c="34788">ese features to predict</st> <st c="34813">office
    occupancy.</st>
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="34638">在这个菜谱中，我们将讨论如何优化特征提取过程以从每个时间序列中提取特定特征，然后使用这些特征来预测</st> <st c="34813">办公室占用率。</st>
- en: <st c="34830">How to do it...</st>
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="34830">如何做到这一点...</st>
- en: '`<st c="34846">tsfresh</st>` <st c="34854">accesses the methods that will be
    used to create features through a dictionary that contains the method names as
    keys and, if they need a parameter, it has the parameter as a value.</st> `<st
    c="35037">tsfresh</st>` <st c="35044">includes some predefined dictionaries as
    well.</st> <st c="35092">We’ll explore these predefined dictionaries first, which
    can be accessed through the</st> `<st c="35177">settings</st>` <st c="35185">module:</st>'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="34846">tsfresh</st>` <st c="34854">通过包含方法名称作为键的字典访问将用于创建特征的**方法**，如果它们需要一个参数，它将参数作为值。</st>
    `<st c="35037">tsfresh</st>` <st c="35044">还包括一些预定义的字典。</st> <st c="35092">我们将首先探索这些预定义的字典，这些字典可以通过</st>
    `<st c="35177">settings</st>` <st c="35185">模块</st>访问：</st>'
- en: <st c="35193">Let’s import the required Python libraries and functions and the</st>
    `<st c="35259">settings</st>` <st c="35267">module:</st>
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="35193">让我们导入所需的Python库、函数和</st> `<st c="35259">settings</st>` <st c="35267">模块：</st>
- en: '[PRE26]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: <st c="35559">Load the dataset and the target variable described in the</st>
    *<st c="35618">Technical</st>* *<st c="35628">requirements</st>* <st c="35640">section:</st>
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="35559">加载文档中描述的**数据集和目标变量**：</st>
- en: '[PRE27]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '`<st c="35773">tsfresh</st>` <st c="35781">includes</st> <st c="35791">three
    main dictionaries that control the feature creation output:</st> `<st c="35857">settings.ComprehensiveFCParameters</st>`<st
    c="35891">,</st> `<st c="35893">settings.EfficientFCParameters</st>`<st c="35923">,
    and</st> `<st c="35929">settings.MinimalFCParameters</st>`<st c="35957">. Here,
    we’ll explore the dictionary that returns the fewest features.</st> <st c="36028">You
    can repeat the steps to explore the</st> <st c="36068">additional dictionaries.</st>'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`<st c="35773">tsfresh</st>` <st c="35781">包括</st> <st c="35791">三个主要字典，这些字典控制特征创建输出：</st>
    `<st c="35857">settings.ComprehensiveFCParameters</st>`<st c="35891">,</st> `<st
    c="35893">settings.EfficientFCParameters</st>`<st c="35923">, 和</st> `<st c="35929">settings.MinimalFCParameters</st>`<st
    c="35957">。在这里，我们将探索返回特征最少的字典。</st> <st c="36028">您可以重复这些步骤来探索</st> <st c="36068">其他字典。</st>'
- en: <st c="36092">Display the feature creation methods that will be applied when
    using the dictionary that returns the</st> <st c="36194">fewest features:</st>
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="36092">显示在使用返回最少特征的字典时将应用的特征创建方法：</st> <st c="36194">最少特征：</st>
- en: '[PRE28]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: <st c="36277">In the output of</st> *<st c="36295">step 3</st>*<st c="36301">,
    we see a dictionary with the feature extraction method names as keys, and the
    parameters used by those methods, if any,</st> <st c="36423">as values:</st>
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="36277">在输出中的 *<st c="36295">步骤 3</st>*<st c="36301">，我们看到一个以特征提取方法名称为键，如果有的话，使用这些方法的参数，作为值的字典：</st>
    <st c="36423">作为值：</st>
- en: '[PRE29]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: <st c="36643">Note</st>
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="36643">注意</st>
- en: <st c="36648">Go ahead and explore the other two predefined dictionaries,</st>
    `<st c="36709">settings.ComprehensiveFCParameters</st>` <st c="36743">and</st>
    `<st c="36748">settings.EfficientFCParameters</st>`<st c="36778">, by ad</st><st
    c="36785">apting the code from</st> *<st c="36807">step 3</st>*<st c="36813">.</st>
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="36648">继续探索其他两个预定义的字典，</st> `<st c="36709">settings.ComprehensiveFCParameters</st>`
    <st c="36743">和</st> `<st c="36748">settings.EfficientFCParameters</st>`<st c="36778">，通过调整来自</st>
    *<st c="36807">步骤 3</st>*<st c="36813">的代码。</st>
- en: <st c="36814">Now, let’s use the dictionary from</st> *<st c="36850">step 3</st>*
    <st c="36856">to extract only those features from the</st> `<st c="36897">light</st>`
    <st c="36902">time</st> <st c="36907">series and then display the shape of the</st>
    <st c="36949">resulting DataFrame:</st>
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="36814">现在，让我们使用来自 *<st c="36850">步骤 3</st>* <st c="36856">的字典来提取仅从</st>
    `<st c="36897">灯光</st>` <st c="36902">时间</st> <st c="36907">序列中提取的特征，然后显示结果 DataFrame
    的形状：</st>
- en: '[PRE30]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: <st c="37087">The output of</st> *<st c="37102">step 4</st>* <st c="37108">is</st>
    `<st c="37112">(135, 10)</st>`<st c="37121">, which means that only 10 features
    were created for each of th</st><st c="37184">e 135 hours of light</st> <st c="37206">consumption
    data.</st>
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="37087">*<st c="37102">步骤 4</st>* <st c="37108">的输出是 `<st c="37112">(135,
    10)</st>`<st c="37121">，这意味着为 135 个小时的灯光消耗数据中的每一个都创建了 10 个特征。</st>
- en: <st c="37223">Let’s display the</st> <st c="37242">resulting DataFrame:</st>
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="37223">让我们显示</st> <st c="37242">结果 DataFrame：</st>
- en: '[PRE31]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: <st c="37278">We see the values of the resulting features for the first five
    hours of lig</st><st c="37354">ht consumption in the</st> <st c="37377">following
    DataFrame:</st>
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="37278">我们在以下 DataFrame 中看到前五个小时灯光消耗的结果特征值：</st> <st c="37354">在以下 DataFrame
    中：</st>
- en: "![Figure 10.7 – DataFrame with the features created \uFEFFfor each hour of\
    \ light consumption](img/B22396_10_07.jpg)"
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.7 – 每小时灯光消耗创建的特征 DataFrame](img/B22396_10_07.jpg)'
- en: <st c="37945">Figure 10.7 – DataFrame with the features created</st> <st c="37995">for
    each hour of light consumption</st>
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="37945">图 10.7 – 每小时灯光消耗创建的特征 DataFrame</st>
- en: <st c="38029">Now, we will use these features to train a logistic regression
    model to predict whether</st> <st c="38118">the office</st> <st c="38129">was
    occupied.</st>
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="38029">现在，我们将使用这些特征来训练一个逻辑回归模型，以预测办公室</st> <st c="38118">是否被占用。</st>
- en: <st c="38142">Let’s begin by separating the dataset into training and</st> <st
    c="38199">test sets:</st>
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="38142">让我们首先将数据集分为训练集和</st> <st c="38199">测试集：</st>
- en: '[PRE32]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: <st c="38309">Now, let’s set up and train a logistic regression model, and then
    evaluate</st> <st c="38385">its performance:</st>
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="38309">现在，让我们设置并训练一个逻辑回归模型，然后评估</st> <st c="38385">其性能：</st>
- en: '[PRE33]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: <st c="38538">In the following output, we see the evaluation metrics that are
    commonly used for classification analysis.</st> <st c="38646">These suggest that
    the selected features are useful for predicting</st> <st c="38713">office occupancy:</st>
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="38538">在以下输出中，我们看到用于分类分析的常用评估指标。</st> <st c="38646">这些指标表明所选特征对预测办公室占用是有用的：</st>
- en: '[PRE34]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '**<st c="38879">Note</st>'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '**<st c="38879">注意</st>'
- en: <st c="38884">Because light consumption is a very good indicator of office occupancy,
    with very simple features, we can obtain a predictive logistic</st> <st c="39020">regression
    model.</st>
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="38884">由于灯光消耗是办公室占用非常好的指标，具有非常简单的特征，我们可以获得一个预测逻辑</st> <st c="39020">回归模型。</st>
- en: <st c="39037">Now, let’s</st> <st c="39049">learn how to specify the creation
    of different features for different</st> <st c="39119">time series.</st>
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="39037">现在，让我们</st> <st c="39049">学习如何为不同的时间序列指定不同特征的创建。</st> <st c="39119">时间序列。</st>
- en: <st c="39131">Let’s create a dictionary with the names of the methods that we
    want to use to create features from the</st> `<st c="39236">light</st>` <st c="39241">time
    series.</st> <st c="39255">We enter the method’s names as keys, and if the methods
    take a parameter, we pass it as an additional dictionary to the corresponding
    key; otherwise, we pass</st> `<st c="39413">None</st>` <st c="39417">as</st> <st
    c="39421">the values:</st>
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="39131">让我们创建一个字典，包含我们想要从</st> `<st c="39236">光</st>` <st c="39241">时间序列</st>
    <st c="39255">中创建特征的方法的名称。</st> <st c="39255">我们将方法的名称作为键，如果方法需要参数，我们将其作为附加字典传递给相应的键；否则，我们传递</st>
    `<st c="39413">None</st>` <st c="39417">作为</st> <st c="39421">值：</st>
- en: '[PRE35]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: <st c="39552">Now, let’s create a dictionary with the features that we want
    to create from the</st> `<st c="39634">co2</st>` <st c="39637">time series:</st>
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="39552">现在，让我们创建一个字典，包含我们想要从</st> `<st c="39634">co2</st>` <st c="39637">时间序列</st>
    <st c="39634">中创建的特征：</st>
- en: '[PRE36]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: <st c="39729">Let’s</st> <st c="39735">combine these dictionaries into a</st>
    <st c="39770">new dictionary:</st>
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="39729">让我们</st> <st c="39735">将这些字典合并成一个</st> <st c="39770">新的字典：</st>
- en: '[PRE37]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: <st c="39851">Finally, let’s use the dictionary from</st> *<st c="39891">step
    10</st>* <st c="39898">to create the features from both</st> <st c="39932">time
    series:</st>
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="39851">最后，让我们使用*<st c="39891">步骤10</st>* <st c="39898">中的字典来创建两个时间序列的特征：</st>
- en: '[PRE38]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: <st c="40063">The output of</st> *<st c="40078">step 11</st>* <st c="40085">consists
    of a DataFrame with 135 rows and 8 features.</st> <st c="40140">If we execute</st>
    `<st c="40154">features.columns</st>`<st c="40170">, we will see the names of
    the</st> <st c="40201">created features:</st>
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="40063">*<st c="40078">步骤11</st>* <st c="40085">的输出由一个包含135行和8个特征的DataFrame组成。</st>
    <st c="40140">如果我们执行</st> `<st c="40154">features.columns</st>`<st c="40170">，我们将看到创建的特征的名称：</st>
- en: '[PRE39]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: <st c="40439">N</st><st c="40441">ote that in the output from</st> *<st c="40469">step
    11</st>*<st c="40476">, different variables have been create</st><st c="40514">d
    from each of the</st> `<st c="40534">light</st>` <st c="40539">and</st> `<st c="40544">co2</st>`
    <st c="40547">time series.</st>
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="40439">注意在</st> *<st c="40469">步骤11</st>*<st c="40476">的输出中，已经从每个</st>
    `<st c="40534">光</st>` <st c="40539">和</st> `<st c="40544">co2</st>` <st c="40547">时间序列</st>
    <st c="40534">中创建了不同的变量。</st>
- en: <st c="40560">How it works...</st>
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="40560">它是如何工作的...</st>
- en: <st c="40576">In this</st> <st c="40585">recipe, we extracted specific features
    from our time-series data.</st> <st c="40651">First, we created features based
    on a predefined dictionary that comes with</st> `<st c="40727">tsfresh</st>`<st
    c="40734">. Next, we created our own dictionary, specifying the creation of different
    features for different</st> <st c="40833">time series.</st>
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="40576">在这个</st> <st c="40585">菜谱中，我们从我们的时间序列数据中提取了特定的特征。</st> <st c="40651">首先，我们根据`<st
    c="40727">tsfresh</st>`<st c="40734">附带的一个预定义字典创建了特征。接下来，我们创建了自己的字典，指定为不同的</st>
    <st c="40833">时间序列</st> <st c="40833">创建不同的特征。</st>
- en: <st c="40845">The</st> `<st c="40850">tsfresh</st>` <st c="40857">package comes
    with some predefined dictionaries that can be accessed through the</st> `<st c="40939">settings</st>`
    <st c="40947">module.</st> <st c="40956">The</st> `<st c="40960">MinimalFCParameters</st>`
    <st c="40979">dictionary is used to create 10 simple features based on basic statistical
    parameters of the time-series distribution, such as the mean, median, standard
    deviation, variance, sum of its values, count (or length), and minimum and maximum
    values.</st> <st c="41225">In</st> *<st c="41228">step 3</st>*<st c="41234">,
    we displayed the dictionary, with the method names as keys, and, as these methods
    do not require additional parameters, each key had</st> `<st c="41369">None</st>`
    <st c="41373">as</st> <st c="41377">the value.</st>
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="40845">`<st c="40850">tsfresh</st>` <st c="40857">包附带一些预定义的字典，可以通过</st>
    `<st c="40939">settings</st>` <st c="40947">模块</st> <st c="40956">访问。</st> `<st
    c="40960">MinimalFCParameters</st>` <st c="40979">字典用于根据时间序列分布的基本统计参数（如平均值、中位数、标准差、方差、值的总和、计数（或长度）以及最小值和最大值）创建10个简单特征。</st>
    <st c="41225">在</st> *<st c="41228">步骤3</st>*<st c="41234">中，我们展示了该字典，方法名称作为键，由于这些方法不需要额外的参数，每个键都有</st>
    `<st c="41369">None</st>` <st c="41373">作为值。</st>
- en: '`<st c="41387">tsfresh</st>` <st c="41395">has two additional predefined dictionaries.</st>
    `<st c="41440">EfficientFCParameters</st>` <st c="41461">is used to apply methods
    that are fast to compute, whereas</st> `<st c="41521">ComprehensiveFCParameters</st>`
    <st c="41546">returns all possible features and is the one used by default by
    the</st> `<st c="41615">extract_</st><st c="41623">features</st>` <st c="41632">function.</st>'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="41387">tsfresh</st>` <st c="41395">有两个额外的预定义字典。</st> `<st c="41440">EfficientFCParameters</st>`
    <st c="41461">用于应用计算快速的算法，而</st> `<st c="41521">ComprehensiveFCParameters</st>`
    <st c="41546">返回所有可能的特征，并且是`extract_</st><st c="41615">features</st>` <st c="41632">函数默认使用的。</st>'
- en: <st c="41642">Note</st>
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="41642">注意</st>
- en: <st c="41647">For more details about the predefined dictionaries, check out</st>
    `<st c="41710">tsfresh</st>`<st c="41717">’s</st> <st c="41721">documentation:</st>
    [<st c="41736">https://tsfresh.readthedocs.io/en/latest</st><st c="41776">/text/feature_extraction_setti</st><st
    c="41807">ngs.html</st>](https://tsfresh.readthedocs.io/en/latest/text/feature_extraction_settings.html)
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="41647">有关预定义字典的更多详细信息，请查看`<st c="41710">tsfresh</st>`<st c="41717">的</st>
    <st c="41721">文档：</st> [<st c="41736">https://tsfresh.readthedocs.io/en/latest</st><st
    c="41776">/text/feature_extraction_setti</st><st c="41807">ngs.html</st>](https://tsfresh.readthedocs.io/en/latest/text/feature_extraction_settings.html)
- en: <st c="41816">By using these predefined dictionaries in the</st> `<st c="41863">default_fc_parameters</st>`
    <st c="41884">parameter of</st> `<st c="41898">tsfresh</st>`<st c="41905">’s</st>
    `<st c="41909">extract_features</st>` <st c="41925">function, we can create specific
    features from one or more time series, as we did in</st> *<st c="42011">step 4</st>*<st
    c="42017">. Note that</st> `<st c="42029">default_fc_parameters</st>` <st c="42050">instructs</st>
    `<st c="42061">extract_features</st>` <st c="42077">to create the same features
    from</st> *<st c="42111">all</st>* <st c="42114">the time series.</st> <st c="42132">What
    if we want to extract different features from different</st> <st c="42193">time
    series?</st>
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="41816">通过在`<st c="41863">default_fc_parameters</st>` <st c="41884">参数中使用这些预定义字典，我们可以从一条或多条时间序列中创建特定的特征，就像我们在</st>
    *<st c="42011">步骤 4</st>*<st c="42017">中做的那样。请注意，</st> `<st c="42029">default_fc_parameters</st>`
    <st c="42050">指示</st> `<st c="42061">extract_features</st>` <st c="42077">从</st>
    *<st c="42111">所有</st>* <st c="42114">时间序列中创建相同的特征。</st> <st c="42132">如果我们想从不同的时间序列中提取不同的特征怎么办呢？</st>
- en: <st c="42205">To create different features for different time series, we can
    use the</st> `<st c="42277">kind_to_fc_parameters</st>` <st c="42298">parameter
    of</st> `<st c="42312">tsfresh</st>`<st c="42319">’s</st> `<st c="42323">extract_features</st>`
    <st c="42339">function.</st> <st c="42350">This parameter takes a dictionary of
    dictionaries, specifying the methods to apply to each</st> <st c="42441">time
    series.</st>
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="42205">为了为不同的时间序列创建不同的特征，我们可以使用`<st c="42277">kind_to_fc_parameters</st>`
    <st c="42298">参数，这是`<st c="42312">tsfresh</st>`<st c="42319">的</st> `<st c="42323">extract_features</st>`
    <st c="42339">函数的。</st> <st c="42350">此参数接受一个字典的字典，指定应用于每个</st> <st c="42441">时间序列的算法。</st>
- en: <st c="42453">In</st> *<st c="42457">step 8</st>*<st c="42463">, we created
    a dictionary to specify the creation of specific features from the</st> `<st c="42543">light</st>`
    <st c="42548">time series.</st> <st c="42562">Note that the</st> `<st c="42576">"sum_values"</st>`
    <st c="42588">and</st> `<st c="42593">"mean"</st>` <st c="42599">methods take</st>
    `<st c="42613">None</st>` <st c="42617">as values, but the</st> `<st c="42637">quantile</st>`
    <st c="42645">method needs additional parameters corresponding to the quantiles
    that should be returned from the time series.</st> <st c="42758">In</st> *<st
    c="42761">step 9</st>*<st c="42767">, we created a dictionary to specify the creation
    of features from the</st> `<st c="42838">co2</st>` <st c="42841">time series.</st>
    <st c="42855">In</st> *<st c="42858">step 10</st>*<st c="42865">, we combined
    both dictionaries into one that takes the name of the time series as the key and
    the feature creation dictionaries as values.</st> <st c="43005">Then, we passed
    this dictionary to the</st> `<st c="43044">kind_to_fc_parameters</st>` <st c="43065">parameter
    of</st> `<st c="43079">tsfresh</st>`<st c="43086">’s</st> `<st c="43090">extract_features</st>`
    <st c="43106">function.</st> <st c="43117">This way of specifying features is
    suitable if we use domain knowledge to create the features, or if we only create
    a small number</st> <st c="43248">of features.</st>
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第8步*中，我们创建了一个字典来指定从`<st c="42543">light</st>`时间序列创建特定特征。请注意，`<st c="42576">"sum_values"</st>`和`<st
    c="42593">"mean"</st>`方法将`<st c="42613">None</st>`作为值，但`<st c="42637">quantile</st>`方法需要额外的参数，这些参数对应于应从时间序列返回的分位数。在*第9步*中，我们创建了一个字典来指定从`<st
    c="42838">co2</st>`时间序列创建特征。在*第10步*中，我们将这两个字典合并为一个，以时间序列的名称作为键，特征创建字典作为值。然后，我们将这个字典传递给`<st
    c="43079">tsfresh</st>`的`<st c="43090">extract_features</st>`函数的`<st c="43044">kind_to_fc_parameters</st>`参数。如果我们使用领域知识来创建特征，或者只创建少量特征，这种方式指定特征是合适的。
- en: <st c="43260">Do we need to type each method by hand into a dictionary if we
    want to create multiple features for various</st> <st c="43368">time series?</st>
    <st c="43382">Not really.</st> <st c="43394">In the following recipe, we will
    learn how to specify which features</st> <st c="43462">to create based on features
    selected</st> <st c="43500">by Lasso.</st>
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要为各种时间序列创建多个特征，是否需要手动将每个方法键入字典中？实际上并不需要。在下面的配方中，我们将学习如何根据Lasso选择的特征指定要创建哪些特征。
- en: <st c="43509">Creating a subset of features identified through feature selection</st>
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过特征选择创建特征子集
- en: <st c="43576">In the</st> *<st c="43584">Automatically creating and selecting
    predictive features from time-series data</st>* <st c="43662">recipe, we</st>
    <st c="43673">learned</st> <st c="43682">how to select relevant features using</st>
    `<st c="43720">tsfresh</st>`<st c="43727">. We also discussed the limitations
    of</st> `<st c="43766">tsfresh</st>`<st c="43773">’s selection procedures and
    suggested following up with alternative feature selection methods to identify
    predictive featu</st><st c="43896">res while</st> <st c="43907">avoiding redundancy.</st>
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在《*自动从时间序列数据中创建和选择预测特征*》的配方中，我们学习了如何使用`<st c="43720">tsfresh</st>`来选择相关特征。我们还讨论了`<st
    c="43766">tsfresh</st>`选择程序的局限性，并建议采用替代特征选择方法来识别预测特征，同时避免冗余。
- en: <st c="43927">In this recipe, we will create and select features using</st>
    `<st c="43985">tsfresh</st>`<st c="43992">. Following that, we will reduce the
    feature space further by utilizing Lasso regularization.</st> <st c="44086">Then,
    we will learn how to create a dictionary from the selected feature names to trigger
    the creatio</st><st c="44187">n of those features</st> *<st c="44208">only</st>*
    <st c="44212">from future</st> <st c="44225">time series.</st>
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将使用`<st c="43985">tsfresh</st>`创建和选择特征。之后，我们将通过利用Lasso正则化进一步减少特征空间。然后，我们将学习如何从选定的特征名称创建字典，以触发仅从未来的时间序列创建这些特征。
- en: <st c="44237">How to do it...</st>
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '...如何做到这一点...'
- en: <st c="44253">Let’s begin by importing the necessary libraries and getting the</st>
    <st c="44319">dataset ready:</st>
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="44253">让我们首先导入必要的库并准备</st> <st c="44319">数据集：</st>
- en: <st c="44333">Let’s import</st> <st c="44347">the</st> <st c="44350">required
    libraries</st> <st c="44370">and functions:</st>
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="44333">让我们导入</st> <st c="44347">所需的库和函数：</st>
- en: '[PRE40]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: <st c="44627">Load the Occupancy Detection dataset described in the</st> *<st
    c="44682">Technical</st>* *<st c="44692">requirements</st>* <st c="44704">section:</st>
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="44627">加载在</st> *<st c="44682">技术</st>* *<st c="44692">要求</st>* <st c="44704">部分中描述的</st>
    <st c="44627">占用检测数据集：</st>
- en: '[PRE41]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: <st c="44838">Create and select features from our five time series and then
    display the shape of the</st> <st c="44926">resulting DataFrame:</st>
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="44838">从我们的五个时间序列创建并选择特征，然后显示结果的 DataFrame 的形状：</st>
- en: '[PRE42]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: <st c="45043">The output of</st> *<st c="45058">step 3</st>* <st c="45064">is</st>
    `<st c="45068">(135, 968)</st>`<st c="45078">, indicating that 968 features were
    returned from the five original time series, for each hour</st> <st c="45173">of
    records.</st>
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="45043">步骤 3</st> *<st c="45058">的输出是</st> `<st c="45068">(135, 968)</st>`<st
    c="45078">，表示从五个原始时间序列中返回了 968 个特征，对于每小时的记录。</st>
- en: <st c="45184">Note</st>
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="45184">注意</st>
- en: <st c="45189">We discussed the function from</st> *<st c="45221">step 3</st>*
    <st c="45227">in the</st> *<st c="45235">Automatically creating and selecting
    pred</st><st c="45276">ictive features from time-series</st>* *<st c="45310">data</st>*
    <st c="45314">recipe.</st>
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="45189">我们在</st> *<st c="45221">步骤 3</st>* <st c="45227">的 *<st c="45235">自动从时间序列数据创建和选择预测特征</st><st
    c="45276">食谱</st> *<st c="45310">中讨论了该函数。</st>
- en: <st c="45322">Let’s reduce</st> <st c="45336">the</st> <st c="45340">feature
    space further by selecting features with</st> <st c="45389">Lasso regularization.</st>
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="45322">让我们通过选择具有 Lasso 正则化的特征进一步减少特征空间。</st>
- en: <st c="45410">Set up logistic regression with Lasso regularization, which is
    the</st> `<st c="45478">"l1"</st>` <st c="45482">penalty.</st> <st c="45492">I
    also set some additional</st> <st c="45519">parameters arbitrarily:</st>
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="45410">设置具有 Lasso 正则化的逻辑回归，这是</st> `<st c="45478">"l1"</st>` <st c="45482">惩罚。</st>
    <st c="45492">我还任意设置了</st> <st c="45519">一些额外的参数：</st>
- en: '[PRE43]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: <st c="45644">Let’s set up a transformer to retain those features whose logistic
    regression coefficients are different</st> <st c="45750">from 0:</st>
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="45644">让我们设置一个转换器来保留那些逻辑回归系数</st> <st c="45750">与 0</st> <st c="45754">不同的特征：</st>
- en: '[PRE44]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: <st c="45789">Train the logistic regression model and select</st> <st c="45837">the
    features:</st>
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="45789">训练逻辑回归模型并选择</st> <st c="45837">特征：</st>
- en: '[PRE45]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: <st c="45876">Now, capture the selected features in</st> <st c="45915">a variable:</st>
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="45876">现在，将所选特征存储在</st> <st c="45915">一个变量中：</st>
- en: '[PRE46]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: <st c="45970">If we</st> <st c="45976">execute</st> `<st c="45985">features</st>`<st
    c="45993">, we’ll</st> <st c="46001">see the names of the</st> <st c="46022">selected
    features:</st>
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="45970">如果我们</st> <st c="45976">执行</st> `<st c="45985">特征</st>`<st c="45993">，我们将</st>
    <st c="46001">看到所选特征的</st> <st c="46022">名称：</st>
- en: '[PRE47]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: <st c="46596">To extract just the features from</st> *<st c="46631">step 6</st>*
    <st c="46637">from the time series, we need to capture the feature creation method
    name and corresponding parameters in a dictionary.</st> <st c="46758">We can do
    this automatically from the feature names</st> <st c="46810">with</st> `<st c="46815">tsfresh</st>`<st
    c="46822">:</st>
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="46596">要从时间序列中提取仅来自</st> *<st c="46631">步骤 6</st>* <st c="46637">的特征，我们需要在字典中捕获特征创建方法名称和相应的参数。</st>
    <st c="46758">我们可以通过使用</st> `<st c="46815">tsfresh</st>`<st c="46822">从特征名称</st>
    <st c="46810">自动完成此操作：</st>
- en: '[PRE48]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: <st c="46907">If we execute</st> `<st c="46922">kind_to_fc_parameters</st>`<st
    c="46943">, we’ll see the dictionary that was created from the</st> <st c="46996">names
    of the features from</st> *<st c="47023">step 6</st>*<st c="47029">:</st>
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="46907">如果我们执行</st> `<st c="46922">kind_to_fc_parameters</st>`<st c="46943">，我们将看到从</st>
    <st c="46996">步骤 6</st> <st c="47023">的特征名称</st> *<st c="47029">创建的字典：</st>
- en: '[PRE49]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: <st c="47457">Now, we can use</st> <st c="47473">the dictionary from</st> *<st
    c="47494">step 8</st>* <st c="47500">together with the</st> `<st c="47519">extract_features</st>`
    <st c="47535">function to create only those features from</st> <st c="47580">our
    dataset:</st>
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="47457">现在，我们可以使用</st> <st c="47473">来自</st> *<st c="47494">步骤 8</st>*
    <st c="47500">的字典以及</st> `<st c="47519">extract_features</st>` <st c="47535">函数来仅从</st>
    <st c="47580">我们的数据集中创建那些特征：</st>
- en: '[PRE50]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: <st c="47707">The new DataFrame, which can be displayed by executing</st> `<st
    c="47763">features.head()</st>`<st c="47778">, only contains the 12 features that
    were selected by Las</st><st c="47835">so.</st> <st c="47840">Go ahead and corroborate
    the re</st><st c="47871">sult on</st> <st c="47880">your computer.</st>
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="47707">新的DataFrame可以通过执行</st> `<st c="47763">features.head()</st>`<st
    c="47778">来显示</st><st c="47835">，它只包含由Las</st><st c="47835">选择的12个特征。</st> <st
    c="47840">请在您的计算机上进一步验证结果。</st>
- en: <st c="47894">How it works...</st>
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="47894">它是如何工作的...</st>
- en: <st c="47910">In this recipe, we</st> <st c="47930">created 968 features</st>
    <st c="47951">from 5 time series.</st> <st c="47971">Next, we reduced the feature
    space to 12 features by using Lasso regularization.</st> <st c="48052">Finally,
    we captured the specifications of the selected features in a dictionary so that,
    looking forward, we only created those features from our</st> <st c="48199">time
    series.</st>
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="47910">在这个食谱中，我们</st> <st c="47930">从5个时间序列中创建了968个特征</st> <st c="47951">。</st>
    <st c="47971">接下来，我们使用Lasso正则化将特征空间减少到12个特征。</st> <st c="48052">最后，我们将所选特征的规格捕获到一个字典中，以便在未来的操作中，我们只从我们的</st>
    <st c="48199">时间序列中创建这些特征。</st>
- en: <st c="48211">To automatically create and select features with</st> `<st c="48261">tsfresh</st>`<st
    c="48268">, we used the</st> `<st c="48282">extract_relevant_features</st>` <st
    c="48307">function, which we described in detail in the</st> *<st c="48354">Automatically
    creating and selecting predictive features from time-series</st>* *<st c="48428">data</st>*
    <st c="48432">recipe.</st>
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="48211">要使用</st> `<st c="48261">tsfresh</st>`<st c="48268">自动创建和选择特征，我们使用了</st>
    `<st c="48282">extract_relevant_features</st>` <st c="48307">函数，我们在</st> *<st
    c="48354">从时间序列数据自动创建和选择预测特征</st> * *<st c="48428">食谱</st> * <st c="48432">中详细描述了它。</st>
- en: <st c="48440">Lasso regularization has the intrinsic ability to reduce some
    of the coefficients of the logistic regression model to 0\.</st> <st c="48562">The
    contribution of the features whose coefficient is 0 to the prediction of office
    occupancy is null and can therefore be removed.</st> <st c="48694">The</st> `<st
    c="48698">SelectFromModel()</st>` <st c="48715">class can identify and remove
    those features.</st> <st c="48762">We set up an instance of</st> `<st c="48787">SelectFromModel()</st>`
    <st c="48804">with a logistic regression model that used Lasso regularization
    to find the model coefficients.</st> <st c="48901">With</st> `<st c="48906">fit()</st>`<st
    c="48911">,</st> `<st c="48913">SelectFromModel()</st>` <st c="48930">trained
    the logistic regression model using the 968 features created from our time series
    and identified those whose coefficients were different from 0\.</st> <st c="49084">Then,
    with the</st> `<st c="49099">get_feature_names_out()</st>` <st c="49122">method,
    we captured the names of the selected features in a</st> <st c="49183">new variable.</st>
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="48440">Lasso正则化具有将逻辑回归模型的一些系数降低到0的内禀能力。</st> <st c="48562">系数为0的特征对办公室占用预测的贡献为零，因此可以将其移除。</st>
    <st c="48694">使用</st> `<st c="48698">SelectFromModel()</st>` <st c="48715">类可以识别并移除这些特征。</st>
    <st c="48762">我们设置了一个使用Lasso正则化的逻辑回归模型的</st> `<st c="48787">SelectFromModel()</st>`
    <st c="48804">实例来找到模型系数。</st> <st c="48901">通过</st> `<st c="48906">fit()</st>`<st
    c="48911">，</st> `<st c="48913">SelectFromModel()</st>` <st c="48930">使用我们从时间序列创建的968个特征训练了逻辑回归模型，并识别了那些系数与0不同的特征。</st>
    <st c="49084">然后，使用</st> `<st c="49099">get_feature_names_out()</st>` <st c="49122">方法，我们将所选特征的名称捕获到一个</st>
    <st c="49183">新变量中。</st>
- en: <st c="49196">To create only the 12 features selected by Lasso regularization,
    we created a dictionary from the variable names by using the</st> `<st c="49323">from_columns()</st>`
    <st c="49337">function from</st> `<st c="49352">tsfresh</st>`<st c="49359">. This
    function returned a dictionary with the variables from which features were selected
    as keys.</st> <st c="49459">The values were additional dictionaries, containing
    the methods used to create features as keys, and the parameters used, if any,
    as values.</st> <st c="49600">To create the new features, we used this</st> <st
    c="49641">dictionary</st> <st c="49652">together with the</st> `<st c="49670">extract_features</st>`
    <st c="49686">function.</st>
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="49196">为了仅创建由Lasso正则化选择的12个特征，我们使用来自</st> `<st c="49323">from_columns()</st>`
    <st c="49337">函数的</st> `<st c="49352">tsfresh</st>`<st c="49359">来创建一个字典。此函数返回一个字典，其变量是作为键从其中选择特征的。</st>
    <st c="49459">值是包含用于创建特征的键的额外字典，以及如果有的话，作为值的参数。</st> <st c="49600">为了创建新特征，我们使用这个</st>
    <st c="49641">字典</st> <st c="49652">以及</st> `<st c="49670">extract_features</st>`
    <st c="49686">函数。</st>
- en: <st c="49696">Note</st>
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="49696">注意</st>
- en: <st c="49701">In</st> *<st c="49705">step 9</st>*<st c="49711">, we passed the
    entire dataset</st> <st c="49742">to the</st> `<st c="49749">extract_features</st>`
    <st c="49765">function.</st> <st c="49776">The resulting features only contained
    features extracted from three of the</st> <st c="49851">five time series.</st>
    <st c="49869">The additional two time series</st> <st c="49900">were ignored.</st>
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="49701">在*<st c="49705">步骤9</st>*<st c="49711">中，我们将整个数据集</st> <st c="49742">传递给</st>
    `<st c="49749">extract_features</st>` <st c="49765">函数。</st> <st c="49776">生成的特征只包含从五个时间序列中的三个提取的特征。</st>
    <st c="49851">另外两个时间序列</st> <st c="49900">被忽略。</st>
- en: <st c="49913">Embe</st><st c="49918">dding feature creation into a scikit-learn
    pipeline</st>
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="49913">将特征创建集成到scikit-learn管道中</st>
- en: <st c="49970">Throughout this</st> <st c="49986">chapter, we’ve discussed how
    to automatical</st><st c="50030">ly create and select features from time-series
    data by utilizing</st> `<st c="50096">tsfresh</st>`<st c="50103">. Then, we used
    these features to train a classification model to predict whether an office was
    occupied at any</st> <st c="50215">given hour.</st>
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="49970">在本章中，我们讨论了如何通过利用</st> `<st c="50096">tsfresh</st>`<st c="50103">自动创建和选择时间序列数据中的特征。然后，我们使用这些特征来训练一个分类模型，以预测在任何给定的小时内办公室是否被占用。</st>
- en: '`<st c="50226">tsfresh</st>` <st c="50234">includes</st> *<st c="50244">wrapper</st>*
    <st c="50251">classes around its main functions,</st> `<st c="50287">extract_features</st>`
    <st c="50303">and</st> `<st c="50308">extract_relevant_features</st>`<st c="50333">,
    to make the creation and selection of features compatible with the</st> <st c="50402">scikit-learn
    pipeline.</st>'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="50226">tsfresh</st>` <st c="50234">包括围绕其主函数的包装类，</st> `<st c="50244">wrapper</st>`
    <st c="50251">，`<st c="50287">extract_features</st>` <st c="50303">和</st> `<st
    c="50308">extract_relevant_features</st>`<st c="50333">，以便使特征创建和选择与</st> `<st
    c="50402">scikit-learn管道</st>`兼容。'
- en: <st c="50424">In this recipe, we will set up a scikit-learn pipeline that extracts
    features from time series using</st> `<st c="50526">tsfresh</st>` <st c="50533">and
    then trains a logistic re</st><st c="50563">gression model with those features
    to predict</st> <st c="50610">office occupancy.</st>
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="50424">在这个菜谱中，我们将设置一个scikit-learn管道，使用</st> `<st c="50526">tsfresh</st>`
    <st c="50533">从时间序列中提取特征，然后用这些特征训练一个逻辑回归模型来预测</st> <st c="50610">办公室的占用情况。</st>
- en: <st c="50627">How to do it...</st>
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="50627">如何操作...</st>
- en: <st c="50643">Let’s begin by importing the necessary libraries and getting the</st>
    <st c="50709">dataset ready:</st>
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="50643">让我们首先导入必要的库并准备好数据集：</st>
- en: <st c="50723">Let’s import the required libraries</st> <st c="50760">and functions:</st>
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="50723">让我们导入所需的库</st> <st c="50760">和函数：</st>
- en: '[PRE51]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: <st c="51048">Load the Occupancy Detection dataset described in the</st> *<st
    c="51103">Technical</st>* *<st c="51113">requirements</st>* <st c="51125">section:</st>
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="51048">加载在*<st c="51103">技术</st>* *<st c="51113">要求</st>* <st c="51125">部分中描述的占用检测数据集：</st>
- en: '[PRE52]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: <st c="51259">Create an empty DataFrame that contains the index of the</st>
    <st c="51317">target variable:</st>
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="51259">创建一个空的DataFrame，其中包含目标变量的索引：</st>
- en: '[PRE53]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: <st c="51367">Now, let’s split</st> <st c="51384">the DataFrame from</st> *<st
    c="51404">step 3</st>* <st c="51410">and the target from</st> *<st c="51431">step
    2</st>* <st c="51437">into training and</st> <st c="51456">test sets:</st>
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="51367">现在，让我们将</st> <st c="51384">从*<st c="51404">步骤3</st>* <st c="51410">和目标从*<st
    c="51431">步骤2</st>* <st c="51437">分成训练集和</st> <st c="51456">测试集：</st>
- en: '[PRE54]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: <st c="51543">Note</st>
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="51543">注意</st>
- en: '`<st c="51548">X_train</st>` <st c="51556">and</st> `<st c="51561">X_test</st>`
    <st c="51567">will be used as containers to store the features created by</st>
    `<st c="51628">tsfresh</st>`<st c="51635">. They are needed for the functionality
    of</st> `<st c="51678">RelevantFe</st><st c="51688">atureAugmenter()</st>` <st
    c="51705">that we will discuss in the</st> <st c="51734">coming steps.</st>'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="51548">X_train</st>` <st c="51556">和</st> `<st c="51561">X_test</st>`
    <st c="51567">将用作容器来存储由</st> `<st c="51628">tsfresh</st>` <st c="51635">创建的特征。它们对于</st>
    `<st c="51678">RelevantFe</st><st c="51688">atureAugmenter()</st>` <st c="51705">的功能是必需的，我们将在接下来的步骤中讨论。</st>'
- en: <st c="51747">Let’s create a dictionary specifying the features to extract from
    each time series (I defined the following</st> <st c="51856">features arbitrarily):</st>
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="51747">让我们创建一个字典，指定从每个时间序列中提取的特征（我任意定义了以下</st> <st c="51856">特征</st>）：
- en: '[PRE55]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: <st c="52750">We discussed the parameters of this dictionary in the</st> *<st
    c="52805">Extrac</st><st c="52811">ting different features from different ti</st><st
    c="52853">me</st>* *<st c="52857">series</st>* <st c="52863">recipe.</st>
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们在*《从不同时间序列中提取不同特征的方法》*中讨论了该字典的参数。
- en: <st c="52871">Let’s set</st> <st c="52882">up</st> `<st c="52885">RelevantFeatureAugmenter()</st>`<st
    c="52911">, which is a wrapper around the</st> `<st c="52943">extract_relevant_features</st>`
    <st c="52968">function, to create the features specified in</st> *<st c="53015">step
    5</st>*<st c="53021">:</st>
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们设置`<st c="52885">RelevantFeatureAugmenter()</st>`，它是对`<st c="52943">extract_relevant_features</st>`函数的包装，以创建在*第5步*中指定的特征：
- en: '[PRE56]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: <st c="53144">Note</st>
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: <st c="53149">To create all possible features, use the</st> `<st c="53191">FeatureAugmenter()</st>`
    <st c="53209">class instead in</st> *<st c="53227">step 6</st>*<st c="53233">.</st>
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建所有可能的特征，请在*第6步*中使用`<st c="53191">FeatureAugmenter()</st>`类。
- en: <st c="53234">Let’s combine the feature creation instance from</st> *<st c="53284">step
    6</st>* <st c="53290">with a logistic regression model in a</st> <st c="53329">scikit-learn
    pipeline:</st>
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将*第6步*中的特征创建实例与一个逻辑回归模型结合到一个scikit-learn流水线中：
- en: '[PRE57]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: <st c="53462">Now, let’s</st> <st c="53473">tell</st> `<st c="53479">RelevantFeatureAugmenter()</st>`
    <st c="53505">which dataset it needs to use to create</st> <st c="53546">the feat</st><st
    c="53554">ures:</st>
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们告诉`<st c="53479">RelevantFeatureAugmenter()</st>`它需要使用哪个数据集来创建特征：
- en: '[PRE58]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: <st c="53611">Let’s fit the pipeline, which will trigger the feature creation
    process, followed by the training of the logistic</st> <st c="53726">regression
    model:</st>
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们拟合流水线，这将触发特征创建过程，然后是逻辑回归模型的训练：
- en: '[PRE59]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: <st c="53770">Now, let’s obtain predictions using the time series in the test
    set and evaluate the model’s performance through a</st> <st c="53886">classification
    report:</st>
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们使用测试集中的时间序列来获取预测，并通过以下分类报告来评估模型的性能：
- en: '[PRE60]'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: <st c="53968">We can see the</st> <st c="53984">output of</st> *<st c="53994">step</st>*
    *<st c="53999">10</st>* <st c="54001">here:</st>
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以看到*第10步*的输出如下：
- en: '[PRE61]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '**<st c="54156">The values of the classification report suggest that the extracted
    features are suitabl</st><st c="54244">e for predicting whether the office is
    occupied at any</st> <st c="54300">given hour.</st>'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '**分类报告的值表明，提取的特征适合预测在任何给定小时办公室是否被占用**。'
- en: <st c="54311">How it works...</st>
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: <st c="54327">In this recipe, we combined creating features from a time series
    with</st> `<st c="54398">tsfresh</st>` <st c="54405">with training a machine learning
    algorith</st><st c="54447">m from the scikit-learn library in</st> <st c="54483">a
    pip</st><st c="54488">eline.</st>
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们将从时间序列中创建特征与`<st c="54398">tsfresh</st>`结合，并在一条流水线上训练来自scikit-learn库的机器学习算法。
- en: <st c="54495">The</st> `<st c="54500">tsfresh</st>` <st c="54507">library includes
    two wrapper classes around its main functions to make the feature creation process
    compatible with the scikit-learn pipeline.</st> <st c="54651">In this recipe,
    we used the</st> `<st c="54679">RelevantFeatureAugmenter()</st>` <st c="54705">class,
    which wraps the</st> `<st c="54729">extract_relevant_features</st>` <st c="54754">function
    to create and then select features from a</st> <st c="54806">time series.</st>
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="54500">tsfresh</st>`库包括两个包装类，围绕其主函数，以使特征创建过程与scikit-learn流水线兼容。在这个方法中，我们使用了`<st
    c="54679">RelevantFeatureAugmenter()</st>`类，它包装了`<st c="54729">extract_relevant_features</st>`函数，用于从时间序列中创建和选择特征。'
- en: '`<st c="54818">RelevantFeatureAugmenter()</st>` <st c="54845">works as follows;
    with</st> `<st c="54869">fit()</st>`<st c="54874">, it creates and selects features
    by using</st> `<st c="54917">extract_relevant_features</st>`<st c="54942">. The
    names of the selected features are then stored internally in the transformer.</st>
    <st c="55026">With</st> `<st c="55031">transform()</st>`<st c="55042">,</st> `<st
    c="55044">RelevantFeatureAugmenter()</st>` <st c="55070">creates the selected
    features from the</st> <st c="55110">time series.</st>'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="54818">RelevantFeatureAugmenter()</st>` <st c="54845">的工作原理如下；使用</st>
    `<st c="54869">fit()</st>`<st c="54874">，它通过使用</st> `<st c="54917">extract_relevant_features</st>`<st
    c="54942">来创建和选择特征。所选特征的名称随后存储在transformer内部。</st> <st c="55026">使用</st> `<st
    c="55031">transform()</st>`<st c="55042">，</st> `<st c="55044">RelevantFeatureAugmenter()</st>`
    <st c="55070">从时间序列中创建所选特征。</st>'
- en: <st c="55122">We overrode the default</st> <st c="55147">functionality of</st>
    `<st c="55164">RelevantFeatureAugmenter()</st>` <st c="55190">by passing a dictionary
    with the features we wanted to create to its</st> `<st c="55260">kind_to_fc_parameters</st>`
    <st c="55281">parameter.</st> <st c="55293">Therefore, with</st> `<st c="55309">transform()</st>`<st
    c="55320">,</st> `<st c="55322">RelevantFeatureAugmenter()</st>` <st c="55348">created
    the indicated features from the</st> <st c="55389">time series.</st>
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="55122">我们通过传递一个包含我们想要创建的特征的字典到其</st> `<st c="55164">RelevantFeatureAugmenter()</st>`
    <st c="55190">的</st> `<st c="55260">kind_to_fc_parameters</st>` <st c="55281">参数中，覆盖了</st>
    `<st c="55164">RelevantFeatureAugmenter()</st>` <st c="55190">的默认</st> `<st c="55147">功能</st>`。</st>
    <st c="55293">因此，使用</st> `<st c="55309">transform()</st>`<st c="55320">，</st>
    `<st c="55322">RelevantFeatureAugmenter()</st>` <st c="55348">从时间序列中创建了指定的特征。</st>'
- en: <st c="55401">To create all features from the time series,</st> `<st c="55447">tsfresh</st>`
    <st c="55454">includes the</st> `<st c="55468">FeatureAugmenter()</st>` <st c="55486">class,
    which has the same functionality as</st> `<st c="55530">RelevantFeatureAugmenter()</st>`<st
    c="55556">, but without the feature</st> <st c="55582">selection step.</st>
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="55401">为了从时间序列创建所有特征，</st> `<st c="55447">tsfresh</st>` <st c="55454">包含了</st>
    `<st c="55468">FeatureAugmenter()</st>` <st c="55486">类，它具有与</st> `<st c="55530">RelevantFeatureAugmenter()</st>`<st
    c="55556">相同的函数，但没有特征</st> `<st c="55582">选择步骤</st>`。'
- en: <st c="55597">Both</st> `<st c="55603">RelevantFeatureAugmenter()</st>` <st
    c="55629">and</st> `<st c="55634">FeatureAugmenter()</st>` <st c="55652">need
    two DataFrames to work.</st> <st c="55682">The first DataFrame contains the time-series
    data and the unique identifiers (we loaded this DataFrame in</st> *<st c="55788">step
    2</st>*<st c="55794">).</st> <st c="55798">The second DataFrame should be empty
    and contain the unique identifiers</st> *<st c="55870">in its index</st>* <st
    c="55882">(we created this DataFrame in</st> *<st c="55913">step 3</st>*<st c="55919">).</st>
    <st c="55923">The features are extracted from the first DataFrame with the time
    series (when applying</st> `<st c="56011">transform()</st>`<st c="56022">) and
    subsequently added to the second DataFrame, which is then used to train the logistic
    regression or obtain</st> <st c="56135">its predictions.</st>
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="55597">RelevantFeatureAugmenter()</st>` <st c="55603">和</st> `<st c="55629">FeatureAugmenter()</st>`
    <st c="55634">都需要两个DataFrame来工作。</st> <st c="55682">第一个DataFrame包含时间序列数据和唯一标识符（我们在</st>
    *<st c="55788">步骤 2</st>*<st c="55794">中加载了这个DataFrame）。</st> <st c="55798">第二个DataFrame应该是空的，并包含唯一标识符</st>
    *<st c="55870">在其索引中</st>* <st c="55882">（我们在</st> *<st c="55913">步骤 3</st>*<st
    c="55919">中创建了此DataFrame）。</st> <st c="55923">特征是从包含时间序列的第一个DataFrame中提取的（在应用</st>
    `<st c="56011">transform()</st>`<st c="56022">时）并随后添加到第二个DataFrame中，然后用于训练逻辑回归或获取</st>
    `<st c="56135">其预测</st>`。'
- en: <st c="56151">Note</st>
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="56151">注意</st>`'
- en: <st c="56156">The index of the empty DataFrame is used by</st> `<st c="56201">RelevantFeatureAugmenter()</st>`
    <st c="56227">and</st> `<st c="56232">FeatureAugmenter()</st>` <st c="56250">to
    identify the time series from which to extract the features.</st> <st c="56315">Hence,
    when applying</st> `<st c="56336">fit()</st>` <st c="56341">while passing</st>
    `<st c="56356">X_train</st>`<st c="56363">, features were extracted from time
    series whose</st> `<st c="56412">id</st>` <st c="56414">value was in the training
    set.</st> <st c="56446">After that, the model was evaluated by observing predictions
    made using the test set, which triggered the creation of features from time series
    whose</st> `<st c="56596">id</st>` <st c="56598">value was</st> <st c="56609">in</st>
    `<st c="56612">X_test</st>`<st c="56618">.</st>
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 空 DataFrame 的索引被 `<st c="56201">RelevantFeatureAugmenter()</st>` 和 `<st c="56232">FeatureAugmenter()</st>`
    用于识别从中提取特征的时间序列。因此，当传递 `<st c="56356">X_train</st>`<st c="56363"> 并应用 `<st c="56336">fit()</st>`
    时，从其 `<st c="56412">id</st>` <st c="56414">值在训练集中的时间序列中提取了特征。之后，通过观察使用测试集做出的预测来评估模型，这触发了从其
    `<st c="56596">id</st>` <st c="56598">值在 `<st c="56612">X_test</st>`<st c="56618">》中的时间序列中创建特征的过程。
- en: <st c="56619">When we used</st> `<st c="56633">fit()</st>` <st c="56638">on
    the pipeline, we created features from our raw time series and trained a logistic
    regression model with the resulting features.</st> <st c="56770">With the</st>
    `<st c="56779">predict()</st>` <st c="56788">method, we created features from
    the test set and obtained</st> <st c="56848">the predictions of the</st> <st c="56870">logistic
    regression based on</st> <st c="56900">those features.</st>
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在管道上使用 `<st c="56633">fit()`</st>` 时，我们从原始时间序列中创建了特征，并使用这些特征训练了一个逻辑回归模型。使用
    `<st c="56779">predict()`</st>` 方法，我们从测试集中创建了特征，并基于这些特征获得了逻辑回归的预测结果。
- en: <st c="56915">See also</st>
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见：
- en: <st c="56924">For more details about the classes</st> <st c="56960">and procedures
    used in this recipe, visit the</st> <st c="57006">following links:</st>
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 关于本食谱中使用的课程和程序的更多详细信息，请访问以下链接：<st c="56924">[链接](https://example.org) <st c="56960">[链接](https://example.org)
    <st c="57006">[链接](https://example.org)。
- en: <st c="57022">The</st> `<st c="57027">tsfresh</st>` <st c="57034">documentation:</st>
    [<st c="57050">https://tsfresh.readthedocs.io/en/latest/api/tsfresh.transformers.html#tsfresh.transformers.relevant_feature_augmenter.RelevantFeatureAugmenter</st>](https://tsfresh.readthedocs.io/en/latest/api/tsfresh.transformers.html#tsfresh.transformers.relevant_feature_augmenter.RelevantFeatureAugmenter)
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="57027">tsfresh</st>` 文档：[文档](https://tsfresh.readthedocs.io/en/latest/api/tsfresh.transformers.html#tsfresh.transformers.relevant_feature_augmenter.RelevantFeatureAugmenter)。'
- en: <st c="57193">A Jupyter notebook with a</st> <st c="57220">demo:</st> [<st c="57226">https://github.com/blue-yonder/tsfresh/blob/main/notebooks/02%20sklearn%20Pipeline.ipynb</st>](https://github.com/blue-yonder/tsfresh/blob/main/notebooks/02%20sklearn%20Pipeline.ipynb)******
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包含演示的 Jupyter 笔记本：[演示](https://github.com/blue-yonder/tsfresh/blob/main/notebooks/02%20sklearn%20Pipeline.ipynb)。
