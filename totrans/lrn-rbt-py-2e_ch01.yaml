- en: Getting Started with Robot Operating System
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main aim of this book is to teach you how to build an autonomous mobile
    robot from scratch. The robot will be programmed using ROS and its operations
    will be simulated using a simulator called Gazebo. You will also see the robot's
    mechanical design, circuit design, embedded programming, and high-level software
    programming using ROS in the upcoming chapters.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will start with the basics of ROS, how to install it, how
    to write a basic application using ROS and Python, and the basics of Gazebo. This
    chapter will be the foundation of your autonomous robotics project. If you are
    already aware of the basics of ROS, and already have it installed on your system,
    you may skip this chapter. However, you can still go through this chapter later
    to refresh your memory as to the basics of ROS.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to ROS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing ROS Kinetic on Ubuntu 16.04.3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing, installing, and testing Gazebo
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start programming robots using Python and Robot Operating System (ROS).
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get the complete code that is mentioned in this chapter, you can clone the
    following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/qboticslabs/learning_robotics_2nd_ed](https://github.com/qboticslabs/learning_robotics_2nd_ed)'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to ROS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**ROS** is a software framework used for creating robotic applications. The
    main aim of the ROS framework is to provide the capabilities that you can use
    to create powerful robotics applications that can be reused for other robots.
    ROS has a collection of software tools, libraries, and collection of packages
    that makes robot software development easy.'
  prefs: []
  type: TYPE_NORMAL
- en: 'ROS is a complete open source project licensed under the BSD ([https://opensource.org/licenses/BSD-3-Clause](https://opensource.org/licenses/BSD-3-Clause))
    license. We can use it for research and commercial applications. Even though ROS
    stands for Robot Operating System, it is not a real operating system. Rather,
    it is a meta-operating system, which provides the features of a real operating
    system. Here are the major features that ROS provides:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Message passing interface**: This is the core feature of ROS, and it enables
    interprocess communication. Using this message-passing capability, the ROS program
    can communicate with its linked systems and exchange data. We will learn more
    technical terms concerning the exchange of data between ROS programs/nodes in
    the coming sections and chapters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hardware abstraction**: ROS has a degree of abstraction that enables developers
    to create robot-agnostic applications. These kinds of application can be used
    with any robot; the developers need only worry about the underlying robot hardware.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Package management**: The ROS nodes are organized in packages called ROS
    packages. ROS packages consist of source codes, configuration files, build files,
    and so on. We create the package, build the package, and install the package.
    There is a build system in ROS that helps to build these packages. The package
    management in ROS makes ROS development more systematic and organized.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Third-party library integration:** The ROS framework is integrated with many
    third-party libraries, such as Open-CV, PCL, OpenNI, and so on. This helps developers
    to create all kinds of application in ROS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Low-level device control**: When we work with robots, we may need to work
    with low-level devices, such as those that control I/O pins, sending data through
    serial ports, and so on. This can also be done using ROS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Distributed computing**: The amount of computation required to process the
    data from robot sensors is very high. Using ROS, we can easily distribute the
    computation to a cluster of computing nodes. This distributes the computing power
    and allows you to process the data faster than you could using a single computer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code reuse**: The main goal of ROS is code reuse. Code reuse enables the
    growth of a good research and development community around the world. ROS executables
    are called nodes. These executables can be grouped into a single entity called
    a ROS package. A group of packages is called a meta package, and both packages
    and meta packages can be shared and distributed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Language independence**: The ROS framework can be programmed using popular
    languages (such as Python, C++, and Lisp). The nodes can be written in any language
    and can communicate through ROS without any issues.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Easy testing**: ROS has a built-in unit/integration test framework called
    rostest to test ROS packages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scaling**: ROS can be scaled to perform complex computation in robots.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Free and open source**: The source code of ROS is open and it''s absolutely
    free to use. The core part of ROS is licensed under a BSD license, and it can
    be reused in commercial and closed source products.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ROS is a combination of plumbing (message passing), tools, capabilities, and
    ecosystem. There are powerful tools in ROS to debug and visualize the robot data.
    There are inbuilt robot capabilities in ROS, such as robot navigation, localization,
    mapping, manipulation, and so on. They help to create powerful robotics applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image shows the ROS equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3a99e07a-d3a9-4346-b54e-a3c6395c6165.png)'
  prefs: []
  type: TYPE_IMG
- en: The ROS equation
  prefs: []
  type: TYPE_NORMAL
- en: Refer to [http://wiki.ros.org/ROS/Introduction](http://wiki.ros.org/ROS/Introduction)
    for more information on ROS.
  prefs: []
  type: TYPE_NORMAL
- en: ROS concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are three main organizational levels in ROS:'
  prefs: []
  type: TYPE_NORMAL
- en: The ROS filesystem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ROS computation graph
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ROS community
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ROS filesystem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The ROS filesystem mainly covers how ROS files are organized on the disk. The
    following are the main terms that we have to understand when working with the
    ROS filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Packages**: ROS packages are the individual unit of the ROS software framework.
    A ROS package may contain source code, third-party libraries, configuration files,
    and so on. ROS packages can be reused and shared.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Package manifests**: The manifests (`package.xml`) file will have all the
    details of the packages, including the name, description, license, and, more importantly,
    the dependencies of the package.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Message (msg) types**: Message descriptions are stored in the `msg` folder
    in a package. ROS messages are data structures for sending data through ROS''s
    message-passing system. Message definitions are stored in a file with the `.msg`
    extension.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Service (srv) types**: Service descriptions are stored in the `srv` folder
    with the `.srv` extension. The `srv` file defines the request and response data
    structure for the service in ROS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ROS Computation Graph
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The ROS Computation Graph is the peer-to-peer network of ROS systems that processes
    data. The basic features of ROS Computation Graph are nodes, ROS Master, the parameter
    server, messages, and services:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Nodes**: The ROS node is a process that uses ROS functionalities to process
    the data. A node basically computes. For example, a node can process the laser
    scanner data to check whether there is any collision. A ROS node is written with
    the help of an ROS client library (such as `roscpp` and `rospy`*),* *which will
    be discussed in the upcoming section*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ROS Master**: The ROS nodes can connect to each other using a program called
    ROS Master. This provides the name, registration, and lookup to the rest of the
    computation graph. Without starting the master, the nodes will not find each other
    and send messages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Parameter server**: The ROS parameters are static values that are stored
    in a global location called the parameter server. From the parameter server, all
    the nodes can access these values. We can even set the scope of the parameter
    server as private or public so that it can access one node or access all nodes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ROS topics**: The ROS nodes communicate with each other using a named bus
    called ROS topic. The data flows through the topic in the form of messages. The
    sending of messages over a topic is called publishing, and receiving the data
    through a topic is called subscribing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Messages**: A ROS message is a data type that can consist of primitive data
    types, such as integers, floating points, and Booleans. The ROS messages flow
    through the ROS topic. A topic can only send/receive one type of message at a
    time. We can create our own message definition and send it through the topics.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Services**: We have seen that the publish/subscribe model using ROS topics
    is a very easy way of communicating. This communication method is a one-to-many
    mode of communication, meaning that a topic can be subscribed to by any number
    of nodes. In some cases, we may also require a request/reply kind of interaction,
    which is usually used in distributed systems. This kind of interaction can be
    done using ROS services. The ROS services work in a similar way to ROS topics
    in that they have a message type definition. Using that message definition, we
    can send the service request to another node that provides the service. The result
    of the service will be sent as a reply. The node has to wait until the result
    is received from the other node.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bags**: These are formats in which to save and play back the ROS topics.
    ROS bags are an important tool to log the sensor data and the processed data.
    These bags can be used later for testing our algorithm offline.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram shows how topics and services work between the nodes
    and the Master:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d964ad3e-9445-41b6-823b-610fa20927aa.png)'
  prefs: []
  type: TYPE_IMG
- en: Communication between the ROS nodes and the ROS Master
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding diagram, you can see two ROS nodes with the ROS Master in between
    them. One thing we have to remember is, before starting any nodes in ROS, you
    should start the ROS Master. The ROS Master acts like a mediator between nodes
    for exchanging information about other ROS nodes in order to establish communication.
    Say that Node 1 wants to publish a topic called `/xyz` with message type `abc`.
    It will first approach the ROS Master, and says `I am going to publish a topic
    called /xyz with message type abc and share its details`. When another node, say
    Node 2, wants to subscribe to the same topic of `/xyz` with the message type of
    `abc`, the Master will share the information about Node 1 and allocate a port
    to start communication between these two nodes directly without communicating
    with the ROS Master.
  prefs: []
  type: TYPE_NORMAL
- en: The ROS services works in the same way. The ROS Master is a kind of DNS server,
    which can share the node details when the second node requests a topic or service
    from the first node. The communication protocol ROS uses is TCPROS ([http://wiki.ros.org/ROS/TCPROS](http://wiki.ros.org/ROS/TCPROS)),
    which basically uses TCP/IP sockets for the communication.
  prefs: []
  type: TYPE_NORMAL
- en: The ROS community level
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The ROS community consists of ROS developers and researchers who can create
    and maintain packages and exchange new information related to existing packages,
    newly released packages, and other news related to the ROS framework. The ROS
    community provides the following services:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Distributions**: A ROS distribution has a set of packages that come with
    a specific version. The distribution that we are using in this book is ROS Kinetic.
    There are other versions available, such as ROS Lunar and Indigo, which has a
    specific version that we can install. It is easier to maintain the packages in
    each distribution. In most cases, the packages inside a distribution will be relatively
    stable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Repositories**: The online repositories are the locations where we keep our
    packages. Normally, developers keep a set of similar packages called meta packages
    in a repository. We can also keep an individual package in a single repository.
    We can simply clone these repositories and build or reuse the packages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The ROS wiki**: The ROS wiki is the place where almost all the documentation
    of ROS is available. You can learn about ROS, from its most basic concepts to
    the most advanced programming, using the ROS wiki ([http://wiki.ros.org](http://wiki.ros.org)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mailing lists**: If you want to get updates regarding ROS, you can subscribe
    to the ROS mailing list ([http://lists.ros.org/mailman/listinfo/ros-users](http://lists.ros.org/mailman/listinfo/ros-users)).
    You can also get the latest ROS news from ROS Discourse ([https://discourse.ros.org](https://discourse.ros.org)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ROS answers**: This is very similar to the Stack Overflow website. You can
    ask questions related to ROS in this portal, and you might get support from developers
    across the world ([https://answers.ros.org/questions/](https://answers.ros.org/questions/)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many other features available in ROS; you can refer to the ROS official
    website at www.ros.org for more information. For now, we will move on to the installation
    procedure of ROS.
  prefs: []
  type: TYPE_NORMAL
- en: Installing ROS on Ubuntu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As per our previous discussion, we know that ROS is a metaoperating system
    that is installed on a host system. ROS is completely supported on Ubuntu /Linux
    and in the experimental stages on Windows and OS X. Some of the latest ROS distributions
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Distribution | Release date |'
  prefs: []
  type: TYPE_TB
- en: '| ROS Melodic Morenia | May 23 2018 |'
  prefs: []
  type: TYPE_TB
- en: '| ROS Lunar Loggerhead | May 23 2017 |'
  prefs: []
  type: TYPE_TB
- en: '| ROS Kinetic Kame | May 23 2016 |'
  prefs: []
  type: TYPE_TB
- en: '| ROS Indigo Igloo | July 22 2014 |'
  prefs: []
  type: TYPE_TB
- en: We will now look at the installation procedure of the stable, long-term support
    (LTS) distribution of ROS called Kinetic on Ubuntu 16.04.3 LTS. ROS Kinetic Kame
    will be primarily targeted at Ubuntu 16.04 LTS. You can also find instructions
    to set up ROS in the latest LTS Melodic Morenia on Ubuntu 18.04 LTS after looking
    at the following instructions. If you are a Windows or OS X user, you can install
    Ubuntu in a VirtualBox application before installing ROS on it. The link to download
    VirtualBox is [https://www.virtualbox.org/wiki/Downloads](https://www.virtualbox.org/wiki/Downloads).
  prefs: []
  type: TYPE_NORMAL
- en: You can find the complete instructions for doing this at [http://wiki.ros.org/kinetic/Installation/Ubuntu](http://wiki.ros.org/kinetic/Installation/Ubuntu).
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Configure your Ubuntu repositories to allow restricted, universe, and multiverse
    downloadable files. We can configure it using Ubuntu''s Software & Update tool.
    We can get this tool by simply searching on the Ubuntu Unity search menu and ticking
    the shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/384d0cc9-fbb5-4f3d-aa60-58b4e9017233.png)'
  prefs: []
  type: TYPE_IMG
- en: Ubuntu's Software & Update tool
  prefs: []
  type: TYPE_NORMAL
- en: 'Set up your system to accept ROS packages from `packages.ros.org`. ROS Kinetic
    is supported only on Ubuntu 15.10 and 16.04\. The following command will store
    `packages.ros.org` in Ubuntu''s `apt` repository list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to add apt-keys. An `apt-key` is used to manage the list of keys
    used by apt to authenticate the packages. Packages that have been authenticated
    using these keys will be considered trusted. The following command will add apt-keys
    for the ROS packages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'After adding the apt-keys, we have to update the Ubuntu package list. The following
    command will add and update the ROS packages, along with the Ubuntu packages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'After updating the ROS packages, we can install the packages. The following
    command will install all the necessary packages, tools, and libraries of ROS:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We may need to install additional packages even after the desktop full installation.
    Each additional installation will be mentioned in the appropriate section. The
    desktop full install will take some time. After the installation of ROS, you will
    almost be done. The next step is to initialize `rosdep`, which enables you to
    easily install the system dependencies for ROS source packages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'To access ROS''s tools and commands on the current bash shell, we can add ROS
    environmental variables to the `.bashrc` file. This will execute at the beginning
    of each bash session. The following is a command to add the ROS variable to `.bashrc`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command will execute the `.bashrc` script on the current shell
    to generate the change in the current shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'A useful tool to install the dependency of a package is `rosinstall`. This
    tool has to be installed separately. It enables you to easily download many source
    trees for the ROS package with one command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The installation of the latest LTS Melodic is similar to the preceding instructions.
    You can install Melodic along with Ubuntu 18.04 LTS. You can find the complete
    instructions at [http://wiki.ros.org/melodic/Installation/Ubuntu](http://wiki.ros.org/melodic/Installation/Ubuntu).
  prefs: []
  type: TYPE_NORMAL
- en: After the installation of ROS, we will discuss how to create a sample package
    in ROS. Before creating the package, we have to create a ROS workspace. The packages
    are created in the ROS workspace. We will use the catkin build system, which is
    a set of tools that is used to build packages in ROS. The catkin build system
    generates an executable or shared library from the source code. ROS Kinetic uses
    the catkin build system to build packages. Let's look at what catkin is.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing catkin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Catkin** is the official build system of ROS. Before catkin, ROS used the
    **rosbuild** system to build packages. Its replacement is catkin on the latest
    ROS version. Catkin combines CMake macros and Python scripts to provide the same
    normal workflow that CMake produces. Catkin provides better distribution of packages,
    better cross-compilation, and better portability than the rosbuild system. For
    more information, refer to wiki.ros.org/catkin.'
  prefs: []
  type: TYPE_NORMAL
- en: Catkin workspace is a folder where you can modify, build, and install catkin
    packages.
  prefs: []
  type: TYPE_NORMAL
- en: Let's check how to create an ROS catkin workspace.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command will create a parent directory called `catkin_ws` and
    a subfolder called `src`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Switch directory to the `src` folder using the following command. We will create
    our packages in the `src` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Initialize the catkin workspace using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'After you initialize the catkin workspace, you can simply build the package
    (even if there is no source file) using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `catkin_make` command is used to build packages inside the `src` directory.
    After building the packages, we will see a `build` and `devel` folder in `catkin_ws`
    The executables are stored in the `build` folder. In the `devel` folder, there
    are shell script files to add the workspace on the ROS environment.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a ROS package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will look at how to create a sample package that contains
    two Python nodes. One of the nodes is used to publish a Hello World string message
    on a topic called `/hello_pub` and the other node will subscribe to this topic.
  prefs: []
  type: TYPE_NORMAL
- en: A catkin ROS package can be created using the `catkin_create_pkg` command in
    ROS.
  prefs: []
  type: TYPE_NORMAL
- en: 'The package is created inside the `src` folder that we created during the creation
    of the workspace. Before creating the packages, switch to the `src` folder using
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command will create a `hello_world` package with `std_msgs` dependencies,
    which contain standard message definitions. The `rospy` is the Python client library
    for ROS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the message we get upon a successful creation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: After the successful creation of the `hello_world` package, we need to add two
    Python nodes or scripts to demonstrate the subscribing and publishing of topics.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create a folder named `scripts` in the `hello_world` package using the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Switch to the `scripts` folder and create a script named `hello_world_publisher.py`
    and another script called `hello_world_subscriber.py` to publish and subscribe
    to the hello world message. The following section covers the code and function
    of these scripts or nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: Hello_world_publisher.py
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `hello_world_publisher.py` node basically publishes a greeting message called
    hello world to a topic called `/hello_pub`. The greeting message is published
    to the topic at a rate of 10 Hz.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a diagram that shows how the interaction between the two ROS nodes
    works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9a59240f-72a5-4062-94e5-bee52f248330.png)'
  prefs: []
  type: TYPE_IMG
- en: Communication between the publisher and subscriber node
  prefs: []
  type: TYPE_NORMAL
- en: The full code of this book is available at [https://github.com/qboticslabs/learning_robotics_2nd_ed](https://github.com/qboticslabs/learning_robotics_2nd_ed).
  prefs: []
  type: TYPE_NORMAL
- en: 'The step-by-step explanation of how this code works is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We need to import `rospy` if we are writing a ROS Python node. It contains Python
    APIs to interact with ROS topics, services, and so on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To send the hello world message, we have to import a `String` message data
    type from the `std_msgs` package. The `std_msgs` package has the message definition
    for standard data types. We can import using the following lines of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The following line of code creates a publisher object to a topic called `hello_pub`.
    The message type is `String` and the `queue_size` value is `10`. If the subscriber
    is not fast enough to receive the data, we can use the `queue_size` option to
    buffer it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The following line of code initializes a ROS node. It will also assign a name
    to the node. If two nodes are running with the same node name, one will shut down.
    If we want to run both, use anonymous`=True` flag as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The following line creates a rate object called `r`. Using a `sleep()` method
    in the `Rate` object, we can update the loop at the desired rate. Here, we are
    giving the rate the value of `10`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The following loop will check whether `rospy` constructs the `rospy.is_shutdown()`
    flag. Then, it executes the loop. If we click on *Ctrl* + *C*, this loop will
    exit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside the loop, a hello world message is printed on the Terminal and published
    on the `hello_pub` topic with a rate of 10 Hz:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code has Python _`_main__` check and calls the `talker()` function.
    The code will keep on executing the talker(), and when Ctrl + C is pressed the
    node will get shut down:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: After publishing the topic, we will see how to subscribe to it. The following
    section covers the code needed to subscribe to the `hello_pub` topic.
  prefs: []
  type: TYPE_NORMAL
- en: Hello_world_subscriber.py
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The subscriber code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code is a callback function that is executed when a message reaches
    the `hello_pub` topic. The `data` variable contains the message from the topic,
    and it will print using `rospy.loginfo()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The following steps will start the node with a `hello_world_subscriber` name
    and start subscribing to the `/hello_pub` topic:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The data type of the message is `String`, and when a message arrives on this
    topic, a method called callback will be called:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code will keep your node from exiting until the node is shut
    down:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the main section of the Python code. The main section will
    call the `listener()` method, which will subscribe to the `/hello_pub` topic:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'After saving two Python nodes, you need to change the permission to executable
    using the `chmod` commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'After changing the file permission, build the package using the `catkin_make`
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command adds the current ROS workspace path in all terminals
    so that we can access the ROS packages inside this workspace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output of the subscriber and publisher nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f021e994-89e3-4c64-a21f-9ad70db20cd1.png)'
  prefs: []
  type: TYPE_IMG
- en: Output of the hello world node
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to run `roscore` before starting the nodes. The `roscore` command
    or ROS master is needed to communicate between nodes. So, the first command is
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'After executing `roscore`, run each node using the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following command will run the publisher:'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command will run the subscriber node. This node subscribes to
    the `hello_pub` topic, as shown in the following code:'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We have covered some of the basics of ROS. Now, we will see what Gazebo is and
    how we can work with Gazebo using ROS.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Gazebo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Gazebo** is a free and open source robot simulator in which we can test our
    own algorithms, design robots, and test robots in different simulated environments.
    Gazebo can accurately and efficiently simulate complex robots in indoor and outdoor
    environments. Gazebo is built with a physics engine with which we can create high-quality
    graphics and rendering.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The features of Gazebo are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Dynamic simulation**: Gazebo can simulate the dynamics of a robot using physics
    engines such as **Open Dynamics Engine** (**ODE**). ([http://opende.sourceforge.net/](http://opende.sourceforge.net/)),
    Bullet ([http://bulletphysics.org/wordpress/](http://bulletphysics.org/wordpress/)),
    Simbody ([https://simtk.org/home/simbody/](https://simtk.org/home/simbody/)),
    and DART ([http://dartsim.github.io/](http://dartsim.github.io/)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Advanced 3D graphics**: Gazebo provides high-quality rendering, lighting,
    shadows, and texturing using the OGRE framework ([http://www.ogre3d.org/](http://www.ogre3d.org/)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sensor support**: Gazebo supports a wide range of sensors, including laser
    range finders, Kinect-style sensors, 2D/3D cameras, and so on. We can also use
    it to simulate noise to test audio sensors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Plugins**: We can develop custom plugins for the robot, sensors, and environmental
    controls. Plugins can access Gazebo''s API.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Robot models**: Gazebo provides models for popular robots, such as PR2, Pioneer
    2 DX, iRobot Create, and TurtleBot. We can also build custom models of robots.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**TCP/IP transport**: We can run simulations on a remote machine and a Gazebo
    interface through a socket-based message-passing service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cloud simulation**: We can run simulations on the cloud server using the
    CloudSim framework ([http://cloudsim.io/](http://cloudsim.io/)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Command-line tools**: Extensive command-line tools are used to check and
    log simulations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing Gazebo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Gazebo can be installed as a standalone application or an integrated application
    along with ROS. In this chapter, we will use Gazebo along with ROS to simulation
    a robot's behavior and to test our written code using the ROS framework.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to try the latest Gazebo simulator yourself, you can follow the
    steps given at [http://gazebosim.org/download](http://gazebosim.org/download.).[](http://gazebosim.org/download.)
  prefs: []
  type: TYPE_NORMAL
- en: To work with Gazebo and ROS, we don't need to install them separately because
    Gazebo comes with the ROS desktop full installation.
  prefs: []
  type: TYPE_NORMAL
- en: The ROS package that integrates Gazebo with ROS is called `gazebo_ros_pkgs`.
    There are wrappers around the standalone Gazebo. This package provides the necessary
    interface to simulate a robot in Gazebo using ROS message services.
  prefs: []
  type: TYPE_NORMAL
- en: 'The complete `gazebo_ros_pkgs` can be installed in ROS Indigo using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Testing Gazebo with the ROS interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Assuming that the ROS environment is properly set up, we can start `roscore`
    before starting Gazebo using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command will run Gazebo using ROS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Gazebo runs two executables-the Gazebo server and the Gazebo client. The Gazebo
    server will execute the simulation process and the Gazebo client can be the Gazebo
    GUI. Using the previous command, the Gazebo client and server will run in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Gazebo GUI is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b6dfeeb9-3bbb-4f5c-9d3d-698aa123cb3e.png)'
  prefs: []
  type: TYPE_IMG
- en: The Gazebo simulator
  prefs: []
  type: TYPE_NORMAL
- en: 'After starting Gazebo, the following topics will be generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We can run the server and client separately using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the Gazebo server using the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the Gazebo client using the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter was an introduction to Robot Operating System. The main goal of
    this chapter was to give you an overview of ROS, its features, how to install
    it, the basic concepts of ROS, and how to program it using Python. Along with
    this, we have looked at a robotics simulator called Gazebo, which can work with
    ROS. We have seen how to install and run Gazebo. In the next chapter, we will
    look at the basic concepts of differential drive robots.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are the important features of ROS?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the different levels of concepts in ROS?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is ROS catkin build system?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are ROS topics and messages?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the different concepts of the ROS Computation Graph?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the main function of the ROS Master?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the important features of Gazebo?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
