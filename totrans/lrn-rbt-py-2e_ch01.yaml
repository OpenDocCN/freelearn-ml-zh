- en: Getting Started with Robot Operating System
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用机器人操作系统
- en: The main aim of this book is to teach you how to build an autonomous mobile
    robot from scratch. The robot will be programmed using ROS and its operations
    will be simulated using a simulator called Gazebo. You will also see the robot's
    mechanical design, circuit design, embedded programming, and high-level software
    programming using ROS in the upcoming chapters.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的主要目标是教会您如何从头开始构建一个自主移动机器人。机器人将使用 ROS 编程，其操作将通过一个名为 Gazebo 的模拟器进行模拟。在接下来的章节中，您还将看到机器人的机械设计、电路设计、嵌入式编程以及使用
    ROS 的高级软件编程。
- en: In this chapter, we will start with the basics of ROS, how to install it, how
    to write a basic application using ROS and Python, and the basics of Gazebo. This
    chapter will be the foundation of your autonomous robotics project. If you are
    already aware of the basics of ROS, and already have it installed on your system,
    you may skip this chapter. However, you can still go through this chapter later
    to refresh your memory as to the basics of ROS.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将从 ROS 的基础知识开始，包括如何安装它、如何使用 ROS 和 Python 编写基本的应用程序，以及 Gazebo 的基础知识。本章将是您自主机器人项目的基础。如果您已经熟悉
    ROS 的基础知识，并且已经在系统上安装了它，您可以跳过本章。然而，您仍然可以稍后阅读本章，以刷新您对 ROS 基础知识的记忆。
- en: 'This chapter will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Introduction to ROS
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ROS 简介
- en: Installing ROS Kinetic on Ubuntu 16.04.3
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Ubuntu 16.04.3 上安装 ROS Kinetic
- en: Introducing, installing, and testing Gazebo
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍、安装和测试 Gazebo
- en: Let's start programming robots using Python and Robot Operating System (ROS).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始使用 Python 和机器人操作系统 (ROS) 编程机器人。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To get the complete code that is mentioned in this chapter, you can clone the
    following link:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取本章中提到的完整代码，您可以克隆以下链接：
- en: '[https://github.com/qboticslabs/learning_robotics_2nd_ed](https://github.com/qboticslabs/learning_robotics_2nd_ed)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/qboticslabs/learning_robotics_2nd_ed](https://github.com/qboticslabs/learning_robotics_2nd_ed)'
- en: Introduction to ROS
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ROS 简介
- en: '**ROS** is a software framework used for creating robotic applications. The
    main aim of the ROS framework is to provide the capabilities that you can use
    to create powerful robotics applications that can be reused for other robots.
    ROS has a collection of software tools, libraries, and collection of packages
    that makes robot software development easy.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**ROS** 是一个用于创建机器人应用的软件框架。ROS 框架的主要目标是提供您可以使用的能力，以创建可重用于其他机器人的强大机器人应用。ROS 拥有一系列软件工具、库和软件包集合，使得机器人软件开发变得简单。'
- en: 'ROS is a complete open source project licensed under the BSD ([https://opensource.org/licenses/BSD-3-Clause](https://opensource.org/licenses/BSD-3-Clause))
    license. We can use it for research and commercial applications. Even though ROS
    stands for Robot Operating System, it is not a real operating system. Rather,
    it is a meta-operating system, which provides the features of a real operating
    system. Here are the major features that ROS provides:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: ROS 是一个完全开源的项目，许可协议为 BSD ([https://opensource.org/licenses/BSD-3-Clause](https://opensource.org/licenses/BSD-3-Clause))
    许可证。我们可以将其用于研究和商业应用。尽管 ROS 代表机器人操作系统，但它不是一个真正的操作系统。相反，它是一个元操作系统，提供了真实操作系统的功能。以下是
    ROS 提供的主要功能：
- en: '**Message passing interface**: This is the core feature of ROS, and it enables
    interprocess communication. Using this message-passing capability, the ROS program
    can communicate with its linked systems and exchange data. We will learn more
    technical terms concerning the exchange of data between ROS programs/nodes in
    the coming sections and chapters.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消息传递接口**：这是 ROS 的核心功能，它实现了进程间通信。利用这种消息传递能力，ROS 程序可以与其链接的系统进行通信并交换数据。在接下来的部分和章节中，我们将学习更多关于
    ROS 程序/节点之间数据交换的技术术语。'
- en: '**Hardware abstraction**: ROS has a degree of abstraction that enables developers
    to create robot-agnostic applications. These kinds of application can be used
    with any robot; the developers need only worry about the underlying robot hardware.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**硬件抽象**：ROS 具有一定的抽象程度，使开发者能够创建与机器人无关的应用程序。这类应用程序可以与任何机器人一起使用；开发者只需关注底层机器人硬件即可。'
- en: '**Package management**: The ROS nodes are organized in packages called ROS
    packages. ROS packages consist of source codes, configuration files, build files,
    and so on. We create the package, build the package, and install the package.
    There is a build system in ROS that helps to build these packages. The package
    management in ROS makes ROS development more systematic and organized.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**包管理**：ROS 节点组织在称为 ROS 包的包中。ROS 包由源代码、配置文件、构建文件等组成。我们创建包，构建包，并安装包。ROS 中有一个构建系统，有助于构建这些包。ROS
    的包管理使得 ROS 开发更加系统化和有序。'
- en: '**Third-party library integration:** The ROS framework is integrated with many
    third-party libraries, such as Open-CV, PCL, OpenNI, and so on. This helps developers
    to create all kinds of application in ROS.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第三方库集成**：ROS 框架集成了许多第三方库，例如 Open-CV、PCL、OpenNI 等。这有助于开发者在 ROS 中创建各种应用。'
- en: '**Low-level device control**: When we work with robots, we may need to work
    with low-level devices, such as those that control I/O pins, sending data through
    serial ports, and so on. This can also be done using ROS.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**低级设备控制**：当我们与机器人一起工作时，我们可能需要与低级设备一起工作，例如控制 I/O 引脚、通过串行端口发送数据等。这也可以使用 ROS
    完成。'
- en: '**Distributed computing**: The amount of computation required to process the
    data from robot sensors is very high. Using ROS, we can easily distribute the
    computation to a cluster of computing nodes. This distributes the computing power
    and allows you to process the data faster than you could using a single computer.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分布式计算**：处理机器人传感器数据所需的数据量非常高。使用 ROS，我们可以轻松地将计算分布到计算节点集群中。这分散了计算能力，并允许您比使用单个计算机更快地处理数据。'
- en: '**Code reuse**: The main goal of ROS is code reuse. Code reuse enables the
    growth of a good research and development community around the world. ROS executables
    are called nodes. These executables can be grouped into a single entity called
    a ROS package. A group of packages is called a meta package, and both packages
    and meta packages can be shared and distributed.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码重用**：ROS 的主要目标是代码重用。代码重用使得全球范围内围绕良好的研发社区得以增长。ROS 可执行文件称为节点。这些可执行文件可以组合成一个称为
    ROS 包的单个实体。一组包称为元包，包和元包都可以共享和分发。'
- en: '**Language independence**: The ROS framework can be programmed using popular
    languages (such as Python, C++, and Lisp). The nodes can be written in any language
    and can communicate through ROS without any issues.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**语言无关性**：ROS 框架可以使用流行的语言（如 Python、C++ 和 Lisp）进行编程。节点可以用任何语言编写，并且可以通过 ROS 无任何问题地进行通信。'
- en: '**Easy testing**: ROS has a built-in unit/integration test framework called
    rostest to test ROS packages.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易于测试**：ROS 有一个内置的单元/集成测试框架，称为 rostest，用于测试 ROS 包。'
- en: '**Scaling**: ROS can be scaled to perform complex computation in robots.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**：ROS 可以扩展以在机器人中执行复杂的计算。'
- en: '**Free and open source**: The source code of ROS is open and it''s absolutely
    free to use. The core part of ROS is licensed under a BSD license, and it can
    be reused in commercial and closed source products.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**免费和开源**：ROS 的源代码是开放的，并且完全免费使用。ROS 的核心部分采用 BSD 许可证，可以在商业和封闭源产品中重用。'
- en: ROS is a combination of plumbing (message passing), tools, capabilities, and
    ecosystem. There are powerful tools in ROS to debug and visualize the robot data.
    There are inbuilt robot capabilities in ROS, such as robot navigation, localization,
    mapping, manipulation, and so on. They help to create powerful robotics applications.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: ROS 是管道（消息传递）、工具、能力和生态系统的结合。ROS 中有许多强大的工具用于调试和可视化机器人数据。ROS 内置了机器人能力，如机器人导航、定位、建图、操作等。它们有助于创建强大的机器人应用。
- en: 'The following image shows the ROS equation:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像显示了 ROS 公式：
- en: '![](img/3a99e07a-d3a9-4346-b54e-a3c6395c6165.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3a99e07a-d3a9-4346-b54e-a3c6395c6165.png)'
- en: The ROS equation
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: ROS 公式
- en: Refer to [http://wiki.ros.org/ROS/Introduction](http://wiki.ros.org/ROS/Introduction)
    for more information on ROS.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅 [http://wiki.ros.org/ROS/Introduction](http://wiki.ros.org/ROS/Introduction)
    了解 ROS 的更多信息。
- en: ROS concepts
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ROS 概念
- en: 'There are three main organizational levels in ROS:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: ROS 中有三个主要组织级别：
- en: The ROS filesystem
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ROS 文件系统
- en: The ROS computation graph
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ROS 计算图
- en: The ROS community
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ROS 社区
- en: The ROS filesystem
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ROS 文件系统
- en: 'The ROS filesystem mainly covers how ROS files are organized on the disk. The
    following are the main terms that we have to understand when working with the
    ROS filesystem:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: ROS 文件系统主要涵盖 ROS 文件在磁盘上的组织方式。以下是我们与 ROS 文件系统工作时必须理解的主要术语：
- en: '**Packages**: ROS packages are the individual unit of the ROS software framework.
    A ROS package may contain source code, third-party libraries, configuration files,
    and so on. ROS packages can be reused and shared.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**包**：ROS包是ROS软件框架的独立单元。一个ROS包可能包含源代码、第三方库、配置文件等。ROS包可以重用和共享。'
- en: '**Package manifests**: The manifests (`package.xml`) file will have all the
    details of the packages, including the name, description, license, and, more importantly,
    the dependencies of the package.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**包清单**：清单文件（`package.xml`）将包含所有包的详细信息，包括名称、描述、许可协议，更重要的是，包的依赖关系。'
- en: '**Message (msg) types**: Message descriptions are stored in the `msg` folder
    in a package. ROS messages are data structures for sending data through ROS''s
    message-passing system. Message definitions are stored in a file with the `.msg`
    extension.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消息（msg）类型**：消息描述存储在包中的`msg`文件夹中。ROS消息是通过ROS的消息传递系统发送数据的结构。消息定义存储在具有`.msg`扩展名的文件中。'
- en: '**Service (srv) types**: Service descriptions are stored in the `srv` folder
    with the `.srv` extension. The `srv` file defines the request and response data
    structure for the service in ROS.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务（srv）类型**：服务描述存储在具有`.srv`扩展名的`srv`文件夹中。`srv`文件定义了ROS中服务的请求和响应数据结构。'
- en: The ROS Computation Graph
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ROS计算图
- en: 'The ROS Computation Graph is the peer-to-peer network of ROS systems that processes
    data. The basic features of ROS Computation Graph are nodes, ROS Master, the parameter
    server, messages, and services:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: ROS计算图是ROS系统处理数据的对等网络。ROS计算图的基本特性包括节点、ROS Master、参数服务器、消息和服务：
- en: '**Nodes**: The ROS node is a process that uses ROS functionalities to process
    the data. A node basically computes. For example, a node can process the laser
    scanner data to check whether there is any collision. A ROS node is written with
    the help of an ROS client library (such as `roscpp` and `rospy`*),* *which will
    be discussed in the upcoming section*.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**节点**：ROS节点是使用ROS功能处理数据的进程。节点基本上是进行计算。例如，一个节点可以处理激光扫描数据以检查是否存在碰撞。ROS节点是用ROS客户端库（如`roscpp`和`rospy`*）编写的，*这些将在下一节中讨论*。'
- en: '**ROS Master**: The ROS nodes can connect to each other using a program called
    ROS Master. This provides the name, registration, and lookup to the rest of the
    computation graph. Without starting the master, the nodes will not find each other
    and send messages.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ROS Master**：ROS节点可以使用名为ROS Master的程序相互连接。这为计算图的其余部分提供了名称、注册和查找功能。如果没有启动主服务器，节点将无法找到彼此并发送消息。'
- en: '**Parameter server**: The ROS parameters are static values that are stored
    in a global location called the parameter server. From the parameter server, all
    the nodes can access these values. We can even set the scope of the parameter
    server as private or public so that it can access one node or access all nodes.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**参数服务器**：ROS参数是存储在称为参数服务器的全局位置中的静态值。从参数服务器，所有节点都可以访问这些值。我们甚至可以将参数服务器的范围设置为私有或公共，以便它可以访问一个节点或访问所有节点。'
- en: '**ROS topics**: The ROS nodes communicate with each other using a named bus
    called ROS topic. The data flows through the topic in the form of messages. The
    sending of messages over a topic is called publishing, and receiving the data
    through a topic is called subscribing.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ROS主题**：ROS节点使用名为ROS主题的命名总线进行通信。数据以消息的形式通过主题流动。在主题上发送消息称为发布，通过主题接收数据称为订阅。'
- en: '**Messages**: A ROS message is a data type that can consist of primitive data
    types, such as integers, floating points, and Booleans. The ROS messages flow
    through the ROS topic. A topic can only send/receive one type of message at a
    time. We can create our own message definition and send it through the topics.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消息**：ROS消息是一种可以由原始数据类型（如整数、浮点数和布尔值）组成的数据类型。ROS消息通过ROS主题流动。一个主题一次只能发送/接收一种类型的消息。我们可以创建自己的消息定义并通过主题发送。'
- en: '**Services**: We have seen that the publish/subscribe model using ROS topics
    is a very easy way of communicating. This communication method is a one-to-many
    mode of communication, meaning that a topic can be subscribed to by any number
    of nodes. In some cases, we may also require a request/reply kind of interaction,
    which is usually used in distributed systems. This kind of interaction can be
    done using ROS services. The ROS services work in a similar way to ROS topics
    in that they have a message type definition. Using that message definition, we
    can send the service request to another node that provides the service. The result
    of the service will be sent as a reply. The node has to wait until the result
    is received from the other node.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务**: 我们已经看到，使用ROS主题的发布/订阅模型是一种非常容易的通信方式。这种通信方法是一种一对多的通信模式，意味着任何数量的节点都可以订阅一个主题。在某些情况下，我们可能还需要请求/回复类型的交互，这种交互通常用于分布式系统中。这种交互可以使用ROS服务来完成。ROS服务的工作方式与ROS主题类似，因为它们都有一个消息类型定义。使用该消息定义，我们可以将服务请求发送到提供服务的另一个节点。服务的结果将以回复的形式发送。节点必须等待从另一个节点接收到结果。'
- en: '**Bags**: These are formats in which to save and play back the ROS topics.
    ROS bags are an important tool to log the sensor data and the processed data.
    These bags can be used later for testing our algorithm offline.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据包**: 这些是保存和回放ROS主题的格式。ROS数据包是记录传感器数据和处理数据的重要工具。这些数据包可以用于稍后离线测试我们的算法。'
- en: 'The following diagram shows how topics and services work between the nodes
    and the Master:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图显示了节点和Master之间主题和服务的工作方式：
- en: '![](img/d964ad3e-9445-41b6-823b-610fa20927aa.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d964ad3e-9445-41b6-823b-610fa20927aa.png)'
- en: Communication between the ROS nodes and the ROS Master
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: ROS节点与ROS Master之间的通信
- en: In the preceding diagram, you can see two ROS nodes with the ROS Master in between
    them. One thing we have to remember is, before starting any nodes in ROS, you
    should start the ROS Master. The ROS Master acts like a mediator between nodes
    for exchanging information about other ROS nodes in order to establish communication.
    Say that Node 1 wants to publish a topic called `/xyz` with message type `abc`.
    It will first approach the ROS Master, and says `I am going to publish a topic
    called /xyz with message type abc and share its details`. When another node, say
    Node 2, wants to subscribe to the same topic of `/xyz` with the message type of
    `abc`, the Master will share the information about Node 1 and allocate a port
    to start communication between these two nodes directly without communicating
    with the ROS Master.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，你可以看到两个ROS节点，它们之间有ROS Master。我们必须记住的一件事是，在ROS中启动任何节点之前，你应该先启动ROS Master。ROS
    Master充当节点之间的调解人，以交换有关其他ROS节点信息，以便建立通信。比如说，节点1想要发布一个名为`/xyz`的主题，消息类型为`abc`。它首先会接近ROS
    Master，并说：“我将发布一个名为/xyz的主题，消息类型为abc，并分享其详细信息。”当另一个节点，比如说节点2，想要订阅与`/xyz`相同的主题，消息类型为`abc`时，Master将共享关于节点1的信息，并分配一个端口以直接在这两个节点之间启动通信，而不与ROS
    Master通信。
- en: The ROS services works in the same way. The ROS Master is a kind of DNS server,
    which can share the node details when the second node requests a topic or service
    from the first node. The communication protocol ROS uses is TCPROS ([http://wiki.ros.org/ROS/TCPROS](http://wiki.ros.org/ROS/TCPROS)),
    which basically uses TCP/IP sockets for the communication.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: ROS服务的工作方式相同。ROS Master类似于DNS服务器，当第二个节点从第一个节点请求主题或服务时，它可以共享节点详细信息。ROS使用的通信协议是TCPROS
    ([http://wiki.ros.org/ROS/TCPROS](http://wiki.ros.org/ROS/TCPROS))，它基本上使用TCP/IP套接字进行通信。
- en: The ROS community level
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ROS社区级别
- en: 'The ROS community consists of ROS developers and researchers who can create
    and maintain packages and exchange new information related to existing packages,
    newly released packages, and other news related to the ROS framework. The ROS
    community provides the following services:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: ROS社区由ROS开发者和研究人员组成，他们可以创建和维护软件包，并交换与现有软件包、新发布的软件包以及其他与ROS框架相关的新闻信息。ROS社区提供以下服务：
- en: '**Distributions**: A ROS distribution has a set of packages that come with
    a specific version. The distribution that we are using in this book is ROS Kinetic.
    There are other versions available, such as ROS Lunar and Indigo, which has a
    specific version that we can install. It is easier to maintain the packages in
    each distribution. In most cases, the packages inside a distribution will be relatively
    stable.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发行版**：ROS发行版包含一系列带有特定版本的软件包。本书中使用的发行版是ROS Kinetic。还有其他版本可供选择，例如ROS Lunar和Indigo，它们都有特定的版本可以安装。维护每个发行版中的软件包更容易。在大多数情况下，发行版内部的软件包将相对稳定。'
- en: '**Repositories**: The online repositories are the locations where we keep our
    packages. Normally, developers keep a set of similar packages called meta packages
    in a repository. We can also keep an individual package in a single repository.
    We can simply clone these repositories and build or reuse the packages.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**仓库**：在线仓库是我们存放软件包的位置。通常，开发者在一个仓库中保持一组称为元软件包的类似软件包。我们也可以在单个仓库中保留单个软件包。我们可以简单地克隆这些仓库并构建或重用软件包。'
- en: '**The ROS wiki**: The ROS wiki is the place where almost all the documentation
    of ROS is available. You can learn about ROS, from its most basic concepts to
    the most advanced programming, using the ROS wiki ([http://wiki.ros.org](http://wiki.ros.org)).'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ROS wiki**：ROS wiki是几乎所有ROS文档都可以找到的地方。你可以通过ROS wiki学习ROS，从其最基本的概念到最先进的编程，([http://wiki.ros.org](http://wiki.ros.org))。'
- en: '**Mailing lists**: If you want to get updates regarding ROS, you can subscribe
    to the ROS mailing list ([http://lists.ros.org/mailman/listinfo/ros-users](http://lists.ros.org/mailman/listinfo/ros-users)).
    You can also get the latest ROS news from ROS Discourse ([https://discourse.ros.org](https://discourse.ros.org)).'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**邮件列表**：如果你想获取有关ROS的更新，你可以订阅ROS邮件列表([http://lists.ros.org/mailman/listinfo/ros-users](http://lists.ros.org/mailman/listinfo/ros-users))。你还可以从ROS
    Discourse([https://discourse.ros.org](https://discourse.ros.org))获取最新的ROS新闻。'
- en: '**ROS answers**: This is very similar to the Stack Overflow website. You can
    ask questions related to ROS in this portal, and you might get support from developers
    across the world ([https://answers.ros.org/questions/](https://answers.ros.org/questions/)).'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ROS问答**：这与Stack Overflow网站非常相似。你可以在该门户中提出与ROS相关的问题，并可能从世界各地的开发者那里获得支持([https://answers.ros.org/questions/](https://answers.ros.org/questions/))。'
- en: There are many other features available in ROS; you can refer to the ROS official
    website at www.ros.org for more information. For now, we will move on to the installation
    procedure of ROS.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: ROS中还有许多其他功能；你可以通过访问ROS官方网站www.ros.org获取更多信息。现在，我们将继续进行ROS的安装过程。
- en: Installing ROS on Ubuntu
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Ubuntu上安装ROS
- en: 'As per our previous discussion, we know that ROS is a metaoperating system
    that is installed on a host system. ROS is completely supported on Ubuntu /Linux
    and in the experimental stages on Windows and OS X. Some of the latest ROS distributions
    are as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们之前的讨论，我们知道ROS是一个安装在宿主系统上的元操作系统。ROS在Ubuntu/Linux上完全受支持，在Windows和OS X上处于实验阶段。以下是一些最新的ROS发行版：
- en: '| Distribution | Release date |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| 发行版 | 发布日期 |'
- en: '| ROS Melodic Morenia | May 23 2018 |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| ROS Melodic Morenia | 2018年5月23日 |'
- en: '| ROS Lunar Loggerhead | May 23 2017 |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| ROS Lunar Loggerhead | 2017年5月23日 |'
- en: '| ROS Kinetic Kame | May 23 2016 |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| ROS Kinetic Kame | 2016年5月23日 |'
- en: '| ROS Indigo Igloo | July 22 2014 |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| ROS Indigo Igloo | 2014年7月22日 |'
- en: We will now look at the installation procedure of the stable, long-term support
    (LTS) distribution of ROS called Kinetic on Ubuntu 16.04.3 LTS. ROS Kinetic Kame
    will be primarily targeted at Ubuntu 16.04 LTS. You can also find instructions
    to set up ROS in the latest LTS Melodic Morenia on Ubuntu 18.04 LTS after looking
    at the following instructions. If you are a Windows or OS X user, you can install
    Ubuntu in a VirtualBox application before installing ROS on it. The link to download
    VirtualBox is [https://www.virtualbox.org/wiki/Downloads](https://www.virtualbox.org/wiki/Downloads).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将查看在Ubuntu 16.04.3 LTS上安装ROS的稳定、长期支持(LTS)发行版，称为Kinetic的安装过程。ROS Kinetic
    Kame将主要针对Ubuntu 16.04 LTS。在查看以下说明后，你还可以找到在最新的LTS Melodic Morenia上设置ROS的说明。如果你是Windows或OS
    X用户，在安装ROS之前，你可以在VirtualBox应用程序中安装Ubuntu。下载VirtualBox的链接是[https://www.virtualbox.org/wiki/Downloads](https://www.virtualbox.org/wiki/Downloads)。
- en: You can find the complete instructions for doing this at [http://wiki.ros.org/kinetic/Installation/Ubuntu](http://wiki.ros.org/kinetic/Installation/Ubuntu).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[http://wiki.ros.org/kinetic/Installation/Ubuntu](http://wiki.ros.org/kinetic/Installation/Ubuntu)找到完成此操作的完整说明。
- en: 'The steps are as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤如下：
- en: 'Configure your Ubuntu repositories to allow restricted, universe, and multiverse
    downloadable files. We can configure it using Ubuntu''s Software & Update tool.
    We can get this tool by simply searching on the Ubuntu Unity search menu and ticking
    the shown in the following screenshot:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置您的Ubuntu仓库以允许下载受限制的、宇宙的和多宇宙的可下载文件。我们可以使用Ubuntu的软件和更新工具来配置它。我们可以在Ubuntu Unity搜索菜单中简单搜索并勾选以下截图所示：
- en: '![](img/384d0cc9-fbb5-4f3d-aa60-58b4e9017233.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/384d0cc9-fbb5-4f3d-aa60-58b4e9017233.png)'
- en: Ubuntu's Software & Update tool
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Ubuntu的软件和更新工具
- en: 'Set up your system to accept ROS packages from `packages.ros.org`. ROS Kinetic
    is supported only on Ubuntu 15.10 and 16.04\. The following command will store
    `packages.ros.org` in Ubuntu''s `apt` repository list:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置您的系统以接受来自`packages.ros.org`的ROS包。ROS Kinetic仅支持Ubuntu 15.10和16.04。以下命令将`packages.ros.org`存储在Ubuntu的`apt`仓库列表中：
- en: '[PRE0]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, we have to add apt-keys. An `apt-key` is used to manage the list of keys
    used by apt to authenticate the packages. Packages that have been authenticated
    using these keys will be considered trusted. The following command will add apt-keys
    for the ROS packages:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们必须添加apt-keys。`apt-key`用于管理apt用于验证包的密钥列表。使用这些密钥验证过的包将被视为可信的。以下命令将为ROS包添加apt-keys：
- en: '[PRE1]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'After adding the apt-keys, we have to update the Ubuntu package list. The following
    command will add and update the ROS packages, along with the Ubuntu packages:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在添加apt-keys之后，我们必须更新Ubuntu包列表。以下命令将添加和更新ROS包，以及Ubuntu包：
- en: '[PRE2]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'After updating the ROS packages, we can install the packages. The following
    command will install all the necessary packages, tools, and libraries of ROS:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在更新ROS包之后，我们可以安装包。以下命令将安装所有必要的ROS包、工具和库：
- en: '[PRE3]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We may need to install additional packages even after the desktop full installation.
    Each additional installation will be mentioned in the appropriate section. The
    desktop full install will take some time. After the installation of ROS, you will
    almost be done. The next step is to initialize `rosdep`, which enables you to
    easily install the system dependencies for ROS source packages:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 即使在桌面完全安装之后，我们可能还需要安装额外的包。每个额外的安装将在适当的部分中提及。桌面完全安装将花费一些时间。在安装ROS之后，您几乎就完成了。下一步是初始化`rosdep`，这将使您能够轻松安装ROS源包的系统依赖项：
- en: '[PRE4]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To access ROS''s tools and commands on the current bash shell, we can add ROS
    environmental variables to the `.bashrc` file. This will execute at the beginning
    of each bash session. The following is a command to add the ROS variable to `.bashrc`:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在当前的bash shell中访问ROS的工具和命令，我们可以将ROS环境变量添加到`.bashrc`文件中。这将在每个bash会话开始时执行。以下是将ROS变量添加到`.bashrc`的命令：
- en: '[PRE5]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The following command will execute the `.bashrc` script on the current shell
    to generate the change in the current shell:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令将在当前shell中执行`.bashrc`脚本，以生成当前shell中的更改：
- en: '[PRE6]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'A useful tool to install the dependency of a package is `rosinstall`. This
    tool has to be installed separately. It enables you to easily download many source
    trees for the ROS package with one command:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装包依赖项的有用工具是`rosinstall`。这个工具需要单独安装。它使您能够通过一条命令轻松下载许多ROS包的源树：
- en: '[PRE7]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The installation of the latest LTS Melodic is similar to the preceding instructions.
    You can install Melodic along with Ubuntu 18.04 LTS. You can find the complete
    instructions at [http://wiki.ros.org/melodic/Installation/Ubuntu](http://wiki.ros.org/melodic/Installation/Ubuntu).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 最新LTS Melodic的安装与前面的说明类似。您可以将Melodic与Ubuntu 18.04 LTS一起安装。您可以在[http://wiki.ros.org/melodic/Installation/Ubuntu](http://wiki.ros.org/melodic/Installation/Ubuntu)找到完整的说明。
- en: After the installation of ROS, we will discuss how to create a sample package
    in ROS. Before creating the package, we have to create a ROS workspace. The packages
    are created in the ROS workspace. We will use the catkin build system, which is
    a set of tools that is used to build packages in ROS. The catkin build system
    generates an executable or shared library from the source code. ROS Kinetic uses
    the catkin build system to build packages. Let's look at what catkin is.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装ROS之后，我们将讨论如何在ROS中创建一个示例包。在创建包之前，我们必须创建一个ROS工作空间。包是在ROS工作空间中创建的。我们将使用catkin构建系统，这是一个用于在ROS中构建包的工具集。catkin构建系统从源代码生成可执行文件或共享库。ROS
    Kinetic使用catkin构建系统来构建包。让我们看看catkin是什么。
- en: Introducing catkin
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍catkin
- en: '**Catkin** is the official build system of ROS. Before catkin, ROS used the
    **rosbuild** system to build packages. Its replacement is catkin on the latest
    ROS version. Catkin combines CMake macros and Python scripts to provide the same
    normal workflow that CMake produces. Catkin provides better distribution of packages,
    better cross-compilation, and better portability than the rosbuild system. For
    more information, refer to wiki.ros.org/catkin.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**Catkin**是ROS的官方构建系统。在catkin之前，ROS使用**rosbuild**系统来构建包。在最新版本的ROS中，它的替代者是catkin。Catkin结合了CMake宏和Python脚本，以提供与CMake产生的相同的标准工作流程。Catkin比rosbuild系统提供了更好的包分发、更好的交叉编译和更好的可移植性。有关更多信息，请参阅wiki.ros.org/catkin。'
- en: Catkin workspace is a folder where you can modify, build, and install catkin
    packages.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Catkin工作空间是一个文件夹，你可以在这里修改、构建和安装catkin包。
- en: Let's check how to create an ROS catkin workspace.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何创建一个ROS catkin工作空间。
- en: 'The following command will create a parent directory called `catkin_ws` and
    a subfolder called `src`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令将创建一个名为`catkin_ws`的父目录和一个名为`src`的子目录：
- en: '[PRE8]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Switch directory to the `src` folder using the following command. We will create
    our packages in the `src` folder:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令切换目录到`src`文件夹。我们将在`src`文件夹中创建我们的包：
- en: '[PRE9]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Initialize the catkin workspace using the following command:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令初始化catkin工作空间：
- en: '[PRE10]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'After you initialize the catkin workspace, you can simply build the package
    (even if there is no source file) using the following command:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化catkin工作空间后，你可以简单地使用以下命令构建包（即使没有源文件）：
- en: '[PRE11]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `catkin_make` command is used to build packages inside the `src` directory.
    After building the packages, we will see a `build` and `devel` folder in `catkin_ws`
    The executables are stored in the `build` folder. In the `devel` folder, there
    are shell script files to add the workspace on the ROS environment.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`catkin_make`命令用于构建`src`目录内的包。构建包后，我们将在`catkin_ws`中看到`build`和`devel`文件夹。可执行文件存储在`build`文件夹中。在`devel`文件夹中，有shell脚本文件用于在ROS环境中添加工作空间。'
- en: Creating a ROS package
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建ROS包
- en: In this section, we will look at how to create a sample package that contains
    two Python nodes. One of the nodes is used to publish a Hello World string message
    on a topic called `/hello_pub` and the other node will subscribe to this topic.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨如何创建一个包含两个Python节点的示例包。其中一个节点用于在名为`/hello_pub`的主题上发布一个Hello World字符串消息，另一个节点将订阅此主题。
- en: A catkin ROS package can be created using the `catkin_create_pkg` command in
    ROS.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用ROS中的`catkin_create_pkg`命令创建catkin ROS包。
- en: 'The package is created inside the `src` folder that we created during the creation
    of the workspace. Before creating the packages, switch to the `src` folder using
    the following command:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 包是在我们创建工作空间时创建的`src`文件夹内创建的。在创建包之前，使用以下命令切换到`src`文件夹：
- en: '[PRE12]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following command will create a `hello_world` package with `std_msgs` dependencies,
    which contain standard message definitions. The `rospy` is the Python client library
    for ROS:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令将创建一个包含`std_msgs`依赖项的`hello_world`包，其中包含标准消息定义。`rospy`是ROS的Python客户端库：
- en: '[PRE13]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This is the message we get upon a successful creation:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这是成功创建后我们得到的消息：
- en: '[PRE14]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: After the successful creation of the `hello_world` package, we need to add two
    Python nodes or scripts to demonstrate the subscribing and publishing of topics.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功创建`hello_world`包之后，我们需要添加两个Python节点或脚本以演示主题的订阅和发布。
- en: 'First, create a folder named `scripts` in the `hello_world` package using the
    following command:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用以下命令在`hello_world`包中创建一个名为`scripts`的文件夹：
- en: '[PRE15]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Switch to the `scripts` folder and create a script named `hello_world_publisher.py`
    and another script called `hello_world_subscriber.py` to publish and subscribe
    to the hello world message. The following section covers the code and function
    of these scripts or nodes:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 切换到`scripts`文件夹，创建一个名为`hello_world_publisher.py`的脚本和另一个名为`hello_world_subscriber.py`的脚本，用于发布和订阅hello
    world消息。以下部分将涵盖这些脚本或节点的代码和功能：
- en: Hello_world_publisher.py
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Hello_world_publisher.py
- en: The `hello_world_publisher.py` node basically publishes a greeting message called
    hello world to a topic called `/hello_pub`. The greeting message is published
    to the topic at a rate of 10 Hz.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`hello_world_publisher.py`节点基本上将一个名为hello world的问候消息发布到名为`/hello_pub`的主题。问候消息以10
    Hz的速率发布到主题。'
- en: 'Here is a diagram that shows how the interaction between the two ROS nodes
    works:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个图表，展示了两个ROS节点之间的交互方式：
- en: '![](img/9a59240f-72a5-4062-94e5-bee52f248330.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9a59240f-72a5-4062-94e5-bee52f248330.png)'
- en: Communication between the publisher and subscriber node
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 发布者和订阅者节点之间的通信
- en: The full code of this book is available at [https://github.com/qboticslabs/learning_robotics_2nd_ed](https://github.com/qboticslabs/learning_robotics_2nd_ed).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 本书完整代码可在 [https://github.com/qboticslabs/learning_robotics_2nd_ed](https://github.com/qboticslabs/learning_robotics_2nd_ed)
    获取。
- en: 'The step-by-step explanation of how this code works is as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对此代码如何工作的逐步解释：
- en: We need to import `rospy` if we are writing a ROS Python node. It contains Python
    APIs to interact with ROS topics, services, and so on.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们正在编写 ROS Python 节点，则需要导入 `rospy`。它包含用于与 ROS 主题、服务等交互的 Python API。
- en: 'To send the hello world message, we have to import a `String` message data
    type from the `std_msgs` package. The `std_msgs` package has the message definition
    for standard data types. We can import using the following lines of code:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要发送“Hello World”消息，我们必须从 `std_msgs` 包中导入 `String` 消息数据类型。`std_msgs` 包包含标准数据类型的消息定义。我们可以使用以下代码行导入：
- en: '[PRE16]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The following line of code creates a publisher object to a topic called `hello_pub`.
    The message type is `String` and the `queue_size` value is `10`. If the subscriber
    is not fast enough to receive the data, we can use the `queue_size` option to
    buffer it:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码行创建了一个名为 `hello_pub` 的主题的发布者对象。消息类型是 `String`，`queue_size` 的值是 `10`。如果订阅者接收数据不够快，我们可以使用
    `queue_size` 选项来缓冲它：
- en: '[PRE17]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The following line of code initializes a ROS node. It will also assign a name
    to the node. If two nodes are running with the same node name, one will shut down.
    If we want to run both, use anonymous`=True` flag as shown in the following code:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码行初始化一个 ROS 节点。它还将为节点分配一个名称。如果有两个节点以相同的节点名运行，其中一个将关闭。如果我们想同时运行它们，可以使用以下代码中的匿名
    `=True` 标志：
- en: '[PRE18]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The following line creates a rate object called `r`. Using a `sleep()` method
    in the `Rate` object, we can update the loop at the desired rate. Here, we are
    giving the rate the value of `10`:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下行创建了一个名为 `r` 的速率对象。使用 `Rate` 对象中的 `sleep()` 方法，我们可以以期望的速率更新循环。这里，我们给速率赋值为
    `10`：
- en: '[PRE19]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The following loop will check whether `rospy` constructs the `rospy.is_shutdown()`
    flag. Then, it executes the loop. If we click on *Ctrl* + *C*, this loop will
    exit.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下循环将检查 `rospy` 是否构建了 `rospy.is_shutdown()` 标志。然后执行循环。如果我们点击 *Ctrl* + *C*，此循环将退出。
- en: 'Inside the loop, a hello world message is printed on the Terminal and published
    on the `hello_pub` topic with a rate of 10 Hz:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环内部，以 10 Hz 的速率在终端打印并发布“Hello World”消息到 `hello_pub` 主题：
- en: '[PRE20]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The following code has Python _`_main__` check and calls the `talker()` function.
    The code will keep on executing the talker(), and when Ctrl + C is pressed the
    node will get shut down:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码具有 Python `_` `main__` 检查并调用 `talker()` 函数。代码将持续执行 `talker()`，当按下 Ctrl +
    C 时，节点将关闭：
- en: '[PRE21]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: After publishing the topic, we will see how to subscribe to it. The following
    section covers the code needed to subscribe to the `hello_pub` topic.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在发布主题后，我们将了解如何订阅它。以下部分涵盖了订阅 `hello_pub` 主题所需的代码。
- en: Hello_world_subscriber.py
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Hello_world_subscriber.py
- en: 'The subscriber code is as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 订阅者代码如下：
- en: '[PRE22]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The following code is a callback function that is executed when a message reaches
    the `hello_pub` topic. The `data` variable contains the message from the topic,
    and it will print using `rospy.loginfo()`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个回调函数，当消息到达 `hello_pub` 主题时执行。`data` 变量包含来自主题的消息，它将使用 `rospy.loginfo()`
    打印：
- en: '[PRE23]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The following steps will start the node with a `hello_world_subscriber` name
    and start subscribing to the `/hello_pub` topic:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将以 `hello_world_subscriber` 名称启动节点并开始订阅 `/hello_pub` 主题：
- en: 'The data type of the message is `String`, and when a message arrives on this
    topic, a method called callback will be called:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 消息的数据类型是 `String`，当消息到达此主题时，将调用名为 callback 的方法：
- en: '[PRE24]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The following code will keep your node from exiting until the node is shut
    down:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码将防止节点退出，直到节点被关闭：
- en: '[PRE25]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The following is the main section of the Python code. The main section will
    call the `listener()` method, which will subscribe to the `/hello_pub` topic:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下为 Python 代码的主要部分。主部分将调用 `listener()` 方法，该方法将订阅 `/hello_pub` 主题：
- en: '[PRE26]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'After saving two Python nodes, you need to change the permission to executable
    using the `chmod` commands:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在保存两个 Python 节点后，您需要使用 `chmod` 命令更改权限为可执行：
- en: '[PRE27]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'After changing the file permission, build the package using the `catkin_make`
    command:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在更改文件权限后，使用 `catkin_make` 命令构建包：
- en: '[PRE28]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The following command adds the current ROS workspace path in all terminals
    so that we can access the ROS packages inside this workspace:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下命令将当前 ROS 工作空间路径添加到所有终端中，以便我们可以访问此工作空间内的 ROS 软件包：
- en: '[PRE29]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The following is the output of the subscriber and publisher nodes:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为订阅者和发布者节点的输出：
- en: '![](img/f021e994-89e3-4c64-a21f-9ad70db20cd1.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f021e994-89e3-4c64-a21f-9ad70db20cd1.png)'
- en: Output of the hello world node
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Hello World 节点的输出
- en: 'First, we need to run `roscore` before starting the nodes. The `roscore` command
    or ROS master is needed to communicate between nodes. So, the first command is
    as follows:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在启动节点之前，我们需要运行 `roscore`。`roscore` 命令或 ROS 主节点用于节点之间的通信。因此，第一个命令如下：
- en: '[PRE30]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'After executing `roscore`, run each node using the following commands:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行 `roscore` 后，使用以下命令运行每个节点：
- en: 'The following command will run the publisher:'
  id: totrans-166
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下命令将运行发布者：
- en: '[PRE31]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The following command will run the subscriber node. This node subscribes to
    the `hello_pub` topic, as shown in the following code:'
  id: totrans-168
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下命令将运行订阅者节点。此节点订阅 `hello_pub` 主题，如下面的代码所示：
- en: '[PRE32]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We have covered some of the basics of ROS. Now, we will see what Gazebo is and
    how we can work with Gazebo using ROS.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经涵盖了 ROS 的一些基础知识。现在，我们将了解 Gazebo 是什么以及我们如何使用 ROS 与 Gazebo 合作。
- en: Introducing Gazebo
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 Gazebo
- en: '**Gazebo** is a free and open source robot simulator in which we can test our
    own algorithms, design robots, and test robots in different simulated environments.
    Gazebo can accurately and efficiently simulate complex robots in indoor and outdoor
    environments. Gazebo is built with a physics engine with which we can create high-quality
    graphics and rendering.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**Gazebo** 是一个免费的开源机器人模拟器，在其中我们可以测试自己的算法、设计机器人以及在不同的模拟环境中测试机器人。Gazebo 可以在室内和室外环境中准确高效地模拟复杂的机器人。Gazebo
    使用物理引擎构建，我们可以用它创建高质量的图形和渲染。'
- en: 'The features of Gazebo are as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Gazebo 的功能如下：
- en: '**Dynamic simulation**: Gazebo can simulate the dynamics of a robot using physics
    engines such as **Open Dynamics Engine** (**ODE**). ([http://opende.sourceforge.net/](http://opende.sourceforge.net/)),
    Bullet ([http://bulletphysics.org/wordpress/](http://bulletphysics.org/wordpress/)),
    Simbody ([https://simtk.org/home/simbody/](https://simtk.org/home/simbody/)),
    and DART ([http://dartsim.github.io/](http://dartsim.github.io/)).'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态模拟**：Gazebo 可以使用物理引擎（如 **Open Dynamics Engine** （**ODE**））模拟机器人的动力学。([http://opende.sourceforge.net/](http://opende.sourceforge.net/))，Bullet
    ([http://bulletphysics.org/wordpress/](http://bulletphysics.org/wordpress/))，Simbody
    ([https://simtk.org/home/simbody/](https://simtk.org/home/simbody/))，和 DART ([http://dartsim.github.io/](http://dartsim.github.io/)))。'
- en: '**Advanced 3D graphics**: Gazebo provides high-quality rendering, lighting,
    shadows, and texturing using the OGRE framework ([http://www.ogre3d.org/](http://www.ogre3d.org/)).'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高级 3D 图形**：Gazebo 使用 OGRE 框架提供高质量的渲染、照明、阴影和纹理（[http://www.ogre3d.org/](http://www.ogre3d.org/)）。'
- en: '**Sensor support**: Gazebo supports a wide range of sensors, including laser
    range finders, Kinect-style sensors, 2D/3D cameras, and so on. We can also use
    it to simulate noise to test audio sensors.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**传感器支持**：Gazebo 支持广泛的传感器，包括激光测距仪、Kinect 风格的传感器、2D/3D 摄像头等。我们还可以用它来模拟噪声以测试音频传感器。'
- en: '**Plugins**: We can develop custom plugins for the robot, sensors, and environmental
    controls. Plugins can access Gazebo''s API.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**插件**：我们可以为机器人、传感器和环境控制开发自定义插件。插件可以访问 Gazebo 的 API。'
- en: '**Robot models**: Gazebo provides models for popular robots, such as PR2, Pioneer
    2 DX, iRobot Create, and TurtleBot. We can also build custom models of robots.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**机器人模型**：Gazebo 为流行的机器人提供模型，例如 PR2、Pioneer 2 DX、iRobot Create 和 TurtleBot。我们还可以构建机器人的自定义模型。'
- en: '**TCP/IP transport**: We can run simulations on a remote machine and a Gazebo
    interface through a socket-based message-passing service.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TCP/IP 传输**：我们可以通过基于套接字的消息传递服务在远程机器和 Gazebo 界面运行模拟。'
- en: '**Cloud simulation**: We can run simulations on the cloud server using the
    CloudSim framework ([http://cloudsim.io/](http://cloudsim.io/)).'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**云模拟**：我们可以使用 CloudSim 框架在云服务器上运行模拟（[http://cloudsim.io/](http://cloudsim.io/)）。'
- en: '**Command-line tools**: Extensive command-line tools are used to check and
    log simulations.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命令行工具**：广泛使用的命令行工具用于检查和记录模拟。'
- en: Installing Gazebo
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Gazebo
- en: Gazebo can be installed as a standalone application or an integrated application
    along with ROS. In this chapter, we will use Gazebo along with ROS to simulation
    a robot's behavior and to test our written code using the ROS framework.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Gazebo 可以作为独立应用程序或与 ROS 集成应用程序安装。在本章中，我们将使用 Gazebo 与 ROS 一起模拟机器人的行为，并使用 ROS
    框架测试我们编写的代码。
- en: If you want to try the latest Gazebo simulator yourself, you can follow the
    steps given at [http://gazebosim.org/download](http://gazebosim.org/download.).[](http://gazebosim.org/download.)
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想亲自尝试最新的 Gazebo 模拟器，可以按照[http://gazebosim.org/download](http://gazebosim.org/download)提供的步骤进行。
- en: To work with Gazebo and ROS, we don't need to install them separately because
    Gazebo comes with the ROS desktop full installation.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 要与 Gazebo 和 ROS 一起工作，我们不需要分别安装它们，因为 Gazebo 随 ROS 桌面完整安装提供。
- en: The ROS package that integrates Gazebo with ROS is called `gazebo_ros_pkgs`.
    There are wrappers around the standalone Gazebo. This package provides the necessary
    interface to simulate a robot in Gazebo using ROS message services.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Gazebo 与 ROS 集成的 ROS 软件包称为 `gazebo_ros_pkgs`。该软件包围绕独立的 Gazebo 提供了包装器。此软件包提供了使用
    ROS 消息服务在 Gazebo 中模拟机器人的必要接口。
- en: 'The complete `gazebo_ros_pkgs` can be installed in ROS Indigo using the following
    command:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下命令在 ROS Indigo 中安装完整的 `gazebo_ros_pkgs`：
- en: '[PRE33]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Testing Gazebo with the ROS interface
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 ROS 接口测试 Gazebo
- en: 'Assuming that the ROS environment is properly set up, we can start `roscore`
    before starting Gazebo using the following command:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 ROS 环境已正确设置，我们可以在启动 Gazebo 之前使用以下命令启动 `roscore`：
- en: '[PRE34]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The following command will run Gazebo using ROS:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令将使用 ROS 运行 Gazebo：
- en: '[PRE35]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Gazebo runs two executables-the Gazebo server and the Gazebo client. The Gazebo
    server will execute the simulation process and the Gazebo client can be the Gazebo
    GUI. Using the previous command, the Gazebo client and server will run in parallel.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Gazebo 运行两个可执行文件——Gazebo 服务器和 Gazebo 客户端。Gazebo 服务器将执行仿真过程，而 Gazebo 客户端可以是 Gazebo
    GUI。使用前面的命令，Gazebo 客户端和服务器将并行运行。
- en: 'The Gazebo GUI is shown in the following screenshot:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了 Gazebo GUI：
- en: '![](img/b6dfeeb9-3bbb-4f5c-9d3d-698aa123cb3e.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b6dfeeb9-3bbb-4f5c-9d3d-698aa123cb3e.png)'
- en: The Gazebo simulator
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Gazebo 模拟器
- en: 'After starting Gazebo, the following topics will be generated:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 启动 Gazebo 后，将生成以下主题：
- en: '[PRE36]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We can run the server and client separately using the following commands:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令分别运行服务器和客户端：
- en: 'Run the Gazebo server using the following command:'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用以下命令运行 Gazebo 服务器：
- en: '[PRE37]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Run the Gazebo client using the following command:'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用以下命令运行 Gazebo 客户端：
- en: '[PRE38]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Summary
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter was an introduction to Robot Operating System. The main goal of
    this chapter was to give you an overview of ROS, its features, how to install
    it, the basic concepts of ROS, and how to program it using Python. Along with
    this, we have looked at a robotics simulator called Gazebo, which can work with
    ROS. We have seen how to install and run Gazebo. In the next chapter, we will
    look at the basic concepts of differential drive robots.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是关于机器人操作系统的介绍。本章的主要目标是向您概述 ROS，其功能，如何安装它，ROS 的基本概念，以及如何使用 Python 编程。此外，我们还探讨了可以与
    ROS 一起工作的机器人模拟器 Gazebo，我们看到了如何安装和运行 Gazebo。在下一章中，我们将探讨差速驱动机器人的基本概念。
- en: Questions
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What are the important features of ROS?
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ROS 的重要特性有哪些？
- en: What are the different levels of concepts in ROS?
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ROS 中概念的不同级别是什么？
- en: What is ROS catkin build system?
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ROS catkin 构建系统是什么？
- en: What are ROS topics and messages?
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ROS 主题和消息是什么？
- en: What are the different concepts of the ROS Computation Graph?
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ROS 计算图的不同概念是什么？
- en: What is the main function of the ROS Master?
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ROS Master 的主要功能是什么？
- en: What are the important features of Gazebo?
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Gazebo 的重要特性有哪些？
