<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;An Introduction to the Basics of OpenCV"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. An Introduction to the Basics of OpenCV</h1></div></div></div><p>After covering the installation of OpenCV on different operating systems in <a class="link" href="ch01.html" title="Chapter 1. Getting Started with OpenCV">Chapter 1</a>, <span class="emphasis"><em>Getting Started with OpenCV</em></span>, we are going to introduce the basics of OpenCV development in this chapter.</p><p>In this chapter, you will learn how to create your project using CMake.</p><p>We will also introduce the image basic data structures, matrices, and other structures that are required in our projects.</p><p>We will learn how to save our variables and data in files using the XML/YAML persistence OpenCV functions.</p><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Configuring projects with CMake</li><li class="listitem" style="list-style-type: disc">Reading/writing images from/to disk</li><li class="listitem" style="list-style-type: disc">Reading videos and accessing camera devices</li><li class="listitem" style="list-style-type: disc">The main image structures (matrices)</li><li class="listitem" style="list-style-type: disc">Other important and basic structures (vectors, scalars, and so on)</li><li class="listitem" style="list-style-type: disc">An introduction to basic matrix operations</li><li class="listitem" style="list-style-type: disc">File storage operations with the XML/YAML persistence OpenCV API</li></ul></div><div class="section" title="Basic CMake configuration files"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec13"/>Basic CMake configuration files</h1></div></div></div><p>To configure <a id="id49" class="indexterm"/>and check all the required dependencies of our project, we are going to use CMake; but it is not mandatory, so we can configure our project in any other tool or IDE such as Makefiles or Visual Studio. However, CMake is the most portable way to configure multiplatform C++ projects.</p><p>CMake uses configuration files called <code class="literal">CMakeLists.txt</code>, where the compilation and dependency processes are defined. For a basic project, based on an executable build from one source code file, a two-line <code class="literal">CMakeLists.txt</code> file is all that is needed. The file looks like this:</p><div class="informalexample"><pre class="programlisting">cmake_minimum_required (VERSION 2.6)
project (CMakeTest)
add_executable(${PROJECT_NAME} main.cpp)</pre></div><p>The first line defines the minimum version of CMake required. This line is mandatory in our <code class="literal">CMakeLists.txt</code> file and allows you to use the <code class="literal">cmake</code> functionality defined from a given version defined in the second line; it defines the project name. This name is saved in a variable called <code class="literal">PROJECT_NAME</code>.</p><p>The last line creates <a id="id50" class="indexterm"/>an executable command (<code class="literal">add_executable()</code>) in the <code class="literal">main.cpp</code> file, gives it the same name as our project (<code class="literal">${PROJECT_NAME}</code>), and compiles our source code into an executable called <code class="literal">CMakeTest</code>, which we set as the project name.</p><p>The <code class="literal">${}</code> expression allows access to any variable defined in our environment. Then, we can use the <code class="literal">${PROJECT_NAME}</code> variable as an executable output name.</p></div></div>
<div class="section" title="Creating a library"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec14"/>Creating a library</h1></div></div></div><p>CMake allows<a id="id51" class="indexterm"/> you to create libraries, which are indeed used by the OpenCV build system. Factorizing the shared code among multiple applications is a common and useful practice in software development. In big applications or when the common code is shared in multiple applications, this practice is very useful.</p><p>In this case, we do not create a binary executable; instead, we create a compiled file that includes all the functions, classes, and so on, developed. We can then share this library file with the other applications without sharing our source code.</p><p>CMake includes the <code class="literal">add_library</code> function for this purpose:</p><div class="informalexample"><pre class="programlisting"># Create our hello library
add_library(Hello hello.cpp hello.h)

# Create our application that uses our new library
add_executable(executable main.cpp)

# Link our executable with the new library
target_link_libraries( executable Hello )</pre></div><p>The lines starting with <code class="literal">#</code> add comments and are ignored by CMake.</p><p>The <code class="literal">add_library(Hello hello.cpp hello.h)</code> command defines our new library called, where <code class="literal">Hello</code> is the library name and <code class="literal">hello.cpp</code>, <code class="literal">hello.h</code> are the source files. We add the header file to allow IDEs such as Visual Studio to link to the header files.</p><p>This line will generate <a id="id52" class="indexterm"/>a shared file (So for OS X and Unix or <code class="literal">.dll</code> for Windows) or a static library (A for OS X and Unix or <code class="literal">.dll</code> for Windows), depending on our operating system or if it is a dynamic or static library.</p><p>
<code class="literal">target_link_libraries( executable Hello)</code> is the function that links our executable to the desired library; in our case, it's the <code class="literal">Hello</code> library.</p></div>
<div class="section" title="Managing dependencies"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec15"/>Managing dependencies</h1></div></div></div><p>CMake has<a id="id53" class="indexterm"/> the ability to search our dependencies and external libraries, giving us the facility to build complex projects depending on external components in our projects and by adding some requirements.</p><p>In this book, the most important dependency is, of course, OpenCV, and we will add it to all our projects:</p><div class="informalexample"><pre class="programlisting">cmake_minimum_required (VERSION 2.6)
cmake_policy(SET CMP0012 NEW)
PROJECT(Chapter2)
# Requires OpenCV
FIND_PACKAGE( OpenCV 3.0.0 REQUIRED )
# Show a message with the opencv version detected
MESSAGE("OpenCV version : ${OpenCV_VERSION}")
include_directories(${OpenCV_INCLUDE_DIRS})
link_directories(${OpenCV_LIB_DIR})
# Create a variable called SRC
SET(SRC main.cpp )
# Create our executable
ADD_EXECUTABLE( ${PROJECT_NAME} ${SRC} )
# Link our library
TARGET_LINK_LIBRARIES( ${PROJECT_NAME} ${OpenCV_LIBS} )</pre></div><p>Now, let's understand the working of the script:</p><div class="informalexample"><pre class="programlisting">cmake_minimum_required (VERSION 2.6)
cmake_policy(SET CMP0012 NEW)
PROJECT(Chapter2)</pre></div><p>The first line defines the minimum CMake version; the second line tells CMake to use the new behavior of CMake so that it can correctly recognize numbers and Booleans constants without dereferencing variables with such names. This policy was introduced in CMake 2.8.0, and CMake warns when the policy is not set to version 3.0.2. Finally, the last line defines the project title:</p><div class="informalexample"><pre class="programlisting"># Requires OpenCV
FIND_PACKAGE( OpenCV 3.0.0 REQUIRED )
# Show a message with the opencv version detected
MESSAGE("OpenCV version : ${OpenCV_VERSION}")
include_directories(${OpenCV_INCLUDE_DIRS})
link_directories(${OpenCV_LIB_DIR})</pre></div><p>This is where <a id="id54" class="indexterm"/>we search for our OpenCV dependency. <code class="literal">FIND_PACKAGE</code> is the function that allows us to find our dependencies and the minimum version required if this dependency is required or optional. In this sample script, we look for OpenCV in version 3.0.0 or greater and it is a required package.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note04"/>Note</h3><p>The <code class="literal">FIND_PACKAGE</code> command includes all OpenCV submodules, but you can specify the submodules that you want to include in the project by making your application smaller and faster. For example, if we are going to work only with the basic OpenCV types and core functionalities, we can use the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>FIND_PACKAGE(OpenCV 3.0.0 REQUIRED core)</strong></span>
</pre></div></div></div><p>If CMake does not find it, it returns an error and does not prevent us from compiling our application.</p><p>The MESSAGE function shows a message on the terminal or CMake GUI. In our case, we will show the OpenCV version, as follows:</p><div class="informalexample"><pre class="programlisting">OpenCV version : 3.0.0</pre></div><p>
<code class="literal">${OpenCV_VERSION}</code> is a variable where CMake stores the OpenCV package version.</p><p>The <code class="literal">include_directories()</code> and <code class="literal">link_directories()</code> add the header and the directory of the specified library to our environment. OpenCV's CMake module saves this data in the <code class="literal">${OpenCV_INCLUDE_DIRS}</code> and <code class="literal">${OpenCV_LIB_DIR}</code> variables. These lines are not required in all platforms, such as Linux, because these paths are normally in the environment, but it's recommended that you have more than one OpenCV version to choose from the correct link and include directories:</p><div class="informalexample"><pre class="programlisting"># Create a variable called SRC
SET(SRC main.cpp )
# Create our executable
ADD_EXECUTABLE( ${PROJECT_NAME} ${SRC} )
# Link our library
TARGET_LINK_LIBRARIES( ${PROJECT_NAME} ${OpenCV_LIBS} )</pre></div><p>This last line <a id="id55" class="indexterm"/>creates the executable and links it to the OpenCV library, as we saw in the previous section, <span class="emphasis"><em>Creating a library</em></span>.</p><p>There is a new function in this piece of code called <code class="literal">SET</code>. This function creates a new variable and adds any value that we need to it. In our case, we set the SRC variable to the <code class="literal">main.cpp</code> value. However, we can add more and more values to the same variable, as shown in this script:</p><div class="informalexample"><pre class="programlisting">SET(SRC main.cpp
        utils.cpp
        color.cpp
)</pre></div></div>
<div class="section" title="Making the script more complex"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec16"/>Making the script more complex</h1></div></div></div><p>In this section, we <a id="id56" class="indexterm"/>will show you a more complex script that includes subfolders, libraries, and executables, all in only two files and a few lines, as shown in this script.</p><p>It's not mandatory to create multiple <code class="literal">CMakeLists.txt</code> files because we can specify everything in the main <code class="literal">CMakeLists.txt</code> file. It is more common to use different <code class="literal">CMakeLists.txt</code> files for each project subfolder, making it more flexible and portable.</p><p>This example has a code structure folder that contains one folder for the <code class="literal">utils</code> library and the other for the <code class="literal">root</code> folder, which contains the main executable:</p><div class="informalexample"><pre class="programlisting">CMakeLists.txt
main.cpp
utils/
  CMakeLists.txt
  computeTime.cpp
  computeTime.h
  logger.cpp
  logger.h
  plotting.cpp
  plotting.h</pre></div><p>Then, we need to define two <code class="literal">CMakeLists.txt</code> files: one in the <code class="literal">root</code> folder and the other in the <code class="literal">utils</code> folder. The <code class="literal">CMakeLists.txt</code> root folder file has the following contents:</p><div class="informalexample"><pre class="programlisting">cmake_minimum_required (VERSION 2.6)
project (Chapter2)

# Opencv Package required
FIND_PACKAGE( OpenCV  3.0.0 REQUIRED )

#Add opencv header files to project
include_directories( ${OpenCV_INCLUDE_DIR} )
link_directories(${OpenCV_LIB_DIR})

add_subdirectory(utils)

# Add optional log with a precompiler definition
option(WITH_LOG "Build with output logs and images in tmp" OFF)
if(WITH_LOG)
  add_definitions(-DLOG)
endif(WITH_LOG)

# generate our new executable
add_executable( ${PROJECT_NAME} main.cpp )
# link the project with his dependencies
target_link_libraries( ${PROJECT_NAME} ${OpenCV_LIBS} Utils)</pre></div><p>Almost all the lines <a id="id57" class="indexterm"/>are described in the previous sections except for some functions that we will explain in later sections.</p><p>The <code class="literal">add_subdirectory()</code> tells CMake to analyze the <code class="literal">CMakeLists.txt</code> of a desired subfolder.</p><p>Before we continue with an explanation of the main <code class="literal">CMakeLists.txt</code> file, we will explain the <code class="literal">utils CMakeLists.txt</code> file.</p><p>In the <code class="literal">CMakeLists.txt</code> file in the <code class="literal">utils</code> folder, we will write a new library to include it in our main project folder:</p><div class="informalexample"><pre class="programlisting"># Add new variable for src utils lib
SET(UTILS_LIB_SRC
  computeTime.cpp 
  logger.cpp 
  plotting.cpp
)
# create our new utils lib
add_library(Utils ${UTILS_LIB_SRC} )
# make sure the compiler can find include files for our library
target_include_directories(Utils PUBLIC ${CMAKE_CURRENT_SOURCE_DIR})</pre></div><p>This <a id="id58" class="indexterm"/>CMake script file defines an <code class="literal">UTILS_LIB_SRC</code> variable where we add all the source files included in our library, generate the library with the <code class="literal">add_library</code> function, and use the <code class="literal">target_include_directories</code> function to allow our main project to detect all header files.</p><p>Leaving out the <code class="literal">utils</code> subfolder and continuing with the root <code class="literal">cmake</code> script, the Option function creates a new variable—in our case, <code class="literal">WITH_LOG</code>, with a small description attached. This variable can be changed via the <code class="literal">ccmake</code> command line or CMake GUI interface, where the description and a checkbox appears that allow users to enable or disable this option.</p><p>This function is very useful and allows the user to decide about compile-time features such as enabling or disabling logs, compiling with Java or Python support as with OpenCV, and so on.</p><p>In our case, we use this option to enable a logger in our application. To enable the logger, we use a precompiler definition in our code:</p><div class="informalexample"><pre class="programlisting">#ifdef LOG
logi("Number of iteration %d", i);
#endif</pre></div><p>To tell our compiler that we require the <code class="literal">LOG</code> compile time definition, we use the <code class="literal">add_definitions(-DLOG)</code> function in our <code class="literal">CMakeLists.txt</code>. To allow the user to decide whether they want to enable it or not, we only have to verify whether the <code class="literal">WITH_LOG</code> CMake variable is checked or not with a simple condition:</p><div class="informalexample"><pre class="programlisting">if(WITH_LOG)
  add_definitions(-DLOG)
endif(WITH_LOG)</pre></div><p>Now, we are ready to create our CMake script files to be compiled in any operating system our Computer Vision projects. Then, we will continue with the OpenCV basics before we start with a sample project.</p></div>
<div class="section" title="Images and matrices"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec17"/>Images and matrices</h1></div></div></div><p>The most important structure in<a id="id59" class="indexterm"/> a Computer Vision is without any doubt the images. The image in Computer Vision is a representation of the physical world captured with a digital device. This picture is only a sequence of numbers stored in a matrix format, as<a id="id60" class="indexterm"/> shown in the following image. Each number is a measurement of the light intensity for the considered wavelength (for example, red, green, or blue in color images) or for a wavelength range (for panchromatic devices). Each point in an image is called a pixel (for a picture element), and each pixel can store one or more values depending on whether it is a gray, black, or white image (called a binary image as well) that stores only one value, such as 0 or 1, a gray-scale-level image that can store only one value, or a color image that can store three values. These values are usually integer numbers between 0 and 255, but you can use the other range. For example, 0 to 1 in a floating point numbers such as <a id="id61" class="indexterm"/>
<span class="strong"><strong>HDRI</strong></span> (<span class="strong"><strong>High Dynamic Range Imaging</strong></span>) or thermal images.</p><div class="mediaobject"><img src="graphics/B04283_02_01.jpg" alt="Images and matrices"/></div><p>The image is stored in a matrix format, where each pixel has a position in it and can be referenced by the number of the column and row. OpenCV uses the <code class="literal">Mat</code> class for this purpose. In the case of a grayscale image, a single matrix is used, as shown in the following figure:</p><div class="mediaobject"><img src="graphics/B04283_02_02.jpg" alt="Images and matrices"/></div><p>In the case <a id="id62" class="indexterm"/>of a color <a id="id63" class="indexterm"/>image, as shown in the following image, we use a matrix of size width x height x number of colors:</p><div class="mediaobject"><img src="graphics/B04283_02_03.jpg" alt="Images and matrices"/></div><p>The <code class="literal">Mat</code> class<a id="id64" class="indexterm"/> is <a id="id65" class="indexterm"/>not only used to store images, but also to store different types of arbitrarily sized matrices. You can use is it as an algebraic matrix and perform operations with it. In the next section, we are going to describe the most important matrix operations such as add, matrix multiplication, create a diagonal matrix, and so on.</p><p>However, before that, it's important to know how the matrix is stored internally in the computer memory because it is always better to have efficient access to the memory slots instead of access to each pixel with the OpenCV functions.</p><p>In memory, the matrix is saved as an array or sequence of values ordered by columns and rows. The following table shows the sequence of pixels in the BGR image format:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th colspan="9" style="text-align: center" valign="bottom">
<p>Row 0</p>
</th><th colspan="9" style="text-align: center" valign="bottom">
<p>Row 1</p>
</th><th colspan="9" style="text-align: center" valign="bottom">
<p>Row 2</p>
</th></tr></thead><tbody><tr><td colspan="3" style="text-align: center" valign="top">
<p>Col 0</p>
</td><td colspan="3" style="text-align: center" valign="top">
<p>Col 1</p>
</td><td colspan="3" style="text-align: center" valign="top">
<p>Col 2</p>
</td><td colspan="3" style="text-align: center" valign="top">
<p>Col 0</p>
</td><td colspan="3" style="text-align: center" valign="top">
<p>Col 1</p>
</td><td colspan="3" style="text-align: center" valign="top">
<p>Col 2</p>
</td><td colspan="3" style="text-align: center" valign="top">
<p>Col 0</p>
</td><td colspan="3" style="text-align: center" valign="top">
<p>Col 1</p>
</td><td colspan="3" style="text-align: center" valign="top">
<p>Col 2</p>
</td></tr><tr><td colspan="3" style="text-align: center" valign="top">
<p>Pixel 1</p>
</td><td colspan="3" style="text-align: center" valign="top">
<p>Pixel 2</p>
</td><td colspan="3" style="text-align: center" valign="top">
<p>Pixel 3</p>
</td><td colspan="3" style="text-align: center" valign="top">
<p>Pixel 4</p>
</td><td colspan="3" style="text-align: center" valign="top">
<p>Pixel 5</p>
</td><td colspan="3" style="text-align: center" valign="top">
<p>Pixel 6</p>
</td><td colspan="3" style="text-align: center" valign="top">
<p>Pixel 7</p>
</td><td colspan="3" style="text-align: center" valign="top">
<p>Pixel 8</p>
</td><td colspan="3" style="text-align: center" valign="top">
<p>Pixel 9</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>B</p>
</td><td style="text-align: left" valign="top">
<p>G</p>
</td><td style="text-align: left" valign="top">
<p>R</p>
</td><td style="text-align: left" valign="top">
<p>B</p>
</td><td style="text-align: left" valign="top">
<p>G</p>
</td><td style="text-align: left" valign="top">
<p>R</p>
</td><td style="text-align: left" valign="top">
<p>B</p>
</td><td style="text-align: left" valign="top">
<p>G</p>
</td><td style="text-align: left" valign="top">
<p>R</p>
</td><td style="text-align: left" valign="top">
<p>B</p>
</td><td style="text-align: left" valign="top">
<p>G</p>
</td><td style="text-align: left" valign="top">
<p>R</p>
</td><td style="text-align: left" valign="top">
<p>B</p>
</td><td style="text-align: left" valign="top">
<p>G</p>
</td><td style="text-align: left" valign="top">
<p>R</p>
</td><td style="text-align: left" valign="top">
<p>B</p>
</td><td style="text-align: left" valign="top">
<p>G</p>
</td><td style="text-align: left" valign="top">
<p>R</p>
</td><td style="text-align: left" valign="top">
<p>B</p>
</td><td style="text-align: left" valign="top">
<p>G</p>
</td><td style="text-align: left" valign="top">
<p>R</p>
</td><td style="text-align: left" valign="top">
<p>B</p>
</td><td style="text-align: left" valign="top">
<p>G</p>
</td><td style="text-align: left" valign="top">
<p>R</p>
</td><td style="text-align: left" valign="top">
<p>B</p>
</td><td style="text-align: left" valign="top">
<p>G</p>
</td><td style="text-align: left" valign="top">
<p>R</p>
</td></tr></tbody></table></div><p>With this order, we <a id="id66" class="indexterm"/>can access any pixel, as shown in the following<a id="id67" class="indexterm"/> formula:</p><div class="informalexample"><pre class="programlisting">Value= Row_i*num_cols*num_channels + Col_i + channel_i</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note05"/>Note</h3><p>OpenCV functions are quite optimized for random access, but sometimes direct access to the memory (working with pointer arithmetic) is more efficient—for example, when we have access to all the pixels in a loop.</p></div></div></div>
<div class="section" title="Reading/writing images"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec18"/>Reading/writing images</h1></div></div></div><p>After the<a id="id68" class="indexterm"/> introduction of this matrix, we are going to start with the basics of the OpenCV code. Firstly, we need to learn how to read and write images:</p><div class="informalexample"><pre class="programlisting">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;
using namespace std;

// OpenCV includes
#include "opencv2/core.hpp"
#include "opencv2/highgui.hpp"
using namespace cv;

int main( int argc, const char** argv )
{
  // Read images
  Mat color= imread("../lena.jpg");
  Mat gray= imread("../lena.jpg", 0);
  
  // Write images
  imwrite("lenaGray.jpg", gray);
  
  // Get same pixel with opencv function
  int myRow=color.cols-1;
  int myCol=color.rows-1;
  Vec3b pixel= color.at&lt;Vec3b&gt;(myRow, myCol);
  cout &lt;&lt; "Pixel value (B,G,R): (" &lt;&lt; (int)pixel[0] &lt;&lt; "," &lt;&lt; (int)pixel[1] &lt;&lt; "," &lt;&lt; (int)pixel[2] &lt;&lt; ")" &lt;&lt; endl;
  
  // show images
  imshow("Lena BGR", color);
  imshow("Lena Gray", gray);
  // wait for any key press
  waitKey(0);
  return 0;
}</pre></div><p>Let's try to understand this code:</p><div class="informalexample"><pre class="programlisting">// OpenCV includes
#include "opencv2/core.hpp"
#include "opencv2/highgui.hpp"
using namespace cv;</pre></div><p>First, we <a id="id69" class="indexterm"/>have to include the declarations of the functions that we need in our sample. These functions come from core (basic image data handling) and high-gui (the cross-platform I/O functions provided by OpenCV are <code class="literal">core</code> and <code class="literal">highui</code>. The first includes the basic classes, such as matrices, and the second includes the functions to read, write, and show images with graphical interfaces).</p><div class="informalexample"><pre class="programlisting">// Read images
Mat color= imread("../lena.jpg");
Mat gray= imread("../lena.jpg", 0);</pre></div><p>The <span class="strong"><strong>imread</strong></span> is the main function used to read images. This function opens an image and stores the image in a matrix format. The <code class="literal">imread</code> function<a id="id70" class="indexterm"/> accepts two parameters: the first parameter is a string that contains the image's path, and the second parameter is optional and, by default, loads the image as a color image. The second parameter allows the following options:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">CV_LOAD_IMAGE_ANYDEPTH</code>: If set to this constant, returns a 16-bit/32-bit image when the input has the corresponding depth; otherwise, the <code class="literal">imread</code> function converts it to an 8-bit image</li><li class="listitem" style="list-style-type: disc"><code class="literal">CV_LOAD_IMAGE_COLOR</code>: If set to this constant, always converts the image to color</li><li class="listitem" style="list-style-type: disc"><code class="literal">CV_LOAD_IMAGE_GRAYSCALE</code>: If set to this constant, always converts the image to grayscale</li></ul></div><p>To save images, we can use the <code class="literal">imwrite</code> function, <a id="id71" class="indexterm"/>which stores a matrix image in our computer:</p><div class="informalexample"><pre class="programlisting">// Write images
imwrite("lenaGray.jpg", gray);</pre></div><p>The first <a id="id72" class="indexterm"/>parameter is the path where we want to save the image with the extension format that we desire. The second parameter is the matrix image that we want to save. In our code sample, we create and store a gray version of the image and then save it as a jpg file the gray image that we loaded and store in <code class="literal">gray</code> variable:</p><div class="informalexample"><pre class="programlisting">// Get same pixel with opencv function
int myRow=color.cols-1;
int myCol=color.rows-1;</pre></div><p>Using the <code class="literal">.cols</code> and <code class="literal">.rows</code> attributes of a matrix, we can access the number of columns and rows of an image—or in other words, the width and height:</p><div class="informalexample"><pre class="programlisting">Vec3b pixel= color.at&lt;Vec3b&gt;(myRow, myCol);
cout &lt;&lt; "Pixel value (B,G,R): (" &lt;&lt; (int)pixel[0] &lt;&lt; "," &lt;&lt; (int)pixel[1] &lt;&lt; "," &lt;&lt; (int)pixel[2] &lt;&lt; ")" &lt;&lt; endl;</pre></div><p>To access one pixel of an image, we use the <code class="literal">cv::Mat::at&lt;typename t&gt;(row,col)</code> template function from the <code class="literal">Mat</code> OpenCV class. The template parameter is the desired return type. A <code class="literal">typename</code> in an 8-bit color image is a <code class="literal">Vec3b</code> class that stores three unsigned char data (Vec=vector, 3=number of components, and b = 1 byte). In the case of the gray image, we can directly use the unsigned char or any other number format used in the image, such as <code class="literal">uchar pixel= color.at&lt;uchar&gt;(myRow, myCol)</code>:</p><div class="informalexample"><pre class="programlisting">// show images
imshow("Lena BGR", color);
imshow("Lena Gray", gray);
// wait for any key press
waitKey(0);</pre></div><p>Finally, to show the images, we can use the <code class="literal">imshow</code> function that creates a window with a title as the first parameter and the image matrix as the second parameter.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note06"/>Note</h3><p>If we want to stop our application by waiting for the user to press a key, we can use the OpenCV <code class="literal">waitKey</code> function with a parameter set to the number of milliseconds we want to wait. If we set the parameter to <code class="literal">0</code>, then the function will wait forever.</p></div></div><p>The result of this code is shown in the following picture; the left-hand image is a color image and right-hand image is a gray scale:</p><div class="mediaobject"><img src="graphics/B04283_02_04.jpg" alt="Reading/writing images"/></div><p>Finally, as an<a id="id73" class="indexterm"/> example for the following samples, we are going to create the <code class="literal">CMakeLists.txt</code> to allow you to compile our project and also see how to compile it.</p><p>The following code describes the <code class="literal">CMakeLists.txt</code> file:</p><div class="informalexample"><pre class="programlisting">cmake_minimum_required (VERSION 2.6)
cmake_policy(SET CMP0012 NEW)
PROJECT(project)

# Requires OpenCV
FIND_PACKAGE( OpenCV 3.0.0 REQUIRED )
MESSAGE("OpenCV version : ${OpenCV_VERSION}")

include_directories(${OpenCV_INCLUDE_DIRS})
link_directories(${OpenCV_LIB_DIR})
ADD_EXECUTABLE( sample main.cpp )
TARGET_LINK_LIBRARIES( sample ${OpenCV_LIBS} )</pre></div><p>To compile<a id="id74" class="indexterm"/> our code, using the <code class="literal">CMakeLists.txt</code> file we have to perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a <code class="literal">build</code> folder.</li><li class="listitem">Inside the <code class="literal">build</code> folder, execute <code class="literal">cmake</code> or open the <code class="literal">CMake gui</code> app in Windows, choose the source folder and build folder, and click on the Configure and Generate buttons.</li><li class="listitem">After step 2, if we are in Linux or OS, generate a <code class="literal">makefile</code>; then we have to compile the project using the make command. If we are in Windows, we have to open the project with the editor that we selected in step 2 and compile it.</li><li class="listitem">After step 3, we have an executable called <code class="literal">app</code>.</li></ol></div></div>
<div class="section" title="Reading videos and cameras"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec19"/>Reading videos and cameras</h1></div></div></div><p>This<a id="id75" class="indexterm"/> section <a id="id76" class="indexterm"/>introduces you to reading a video and camera with this simple example:</p><div class="informalexample"><pre class="programlisting">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;
using namespace std;

// OpenCV includes
#include "opencv2/core.hpp"
#include "opencv2/highgui.hpp"
using namespace cv;

// OpenCV command line parser functions
// Keys accecpted by command line parser
const char* keys =
{
    "{help h usage ? | | print this message}"
    "{@video | | Video file, if not defined try to use webcamera}"
};

int main( int argc, const char** argv )
{
    CommandLineParser parser(argc, argv, keys);
    parser.about("Chapter 2. v1.0.0");
    //If requires help show
    if (parser.has("help"))
    {
      parser.printMessage();
      return 0;
    }
    String videoFile= parser.get&lt;String&gt;(0);
    
    // Check if params are correctly parsed in his variables
    if (!parser.check())
    {
        parser.printErrors();
        return 0;
    }

    VideoCapture cap; // open the default camera
    if(videoFile != "")
        cap.open(videoFile);
    else
        cap.open(0);
    if(!cap.isOpened())  // check if we succeeded
        return -1;

    namedWindow("Video",1);
    for(;;)
    {
        Mat frame;
        cap &gt;&gt; frame; // get a new frame from camera
        imshow("Video", frame);
        if(waitKey(30) &gt;= 0) break;
    }
    // Release the camera or video cap
    cap.release();
    
    return 0;
}</pre></div><p>Before we <a id="id77" class="indexterm"/>explain how to read video or camera inputs, we need to introduce a <a id="id78" class="indexterm"/>useful new class that will help us manage the input command line parameters; this new class was introduced in OpenCV version 3.0 and is called the <code class="literal">CommandLineParser</code> class:</p><div class="informalexample"><pre class="programlisting">// OpenCV command line parser functions
// Keys accepted by command line parser
const char* keys =
{
    "{help h usage ? | | print this message}"
    "{@video | | Video file, if not defined try to use webcamera}"
};</pre></div><p>The first <a id="id79" class="indexterm"/>thing that we have to do for a command-line parser is define the parameters that we need or allow in a constant char vector; each line has this pattern:</p><div class="informalexample"><pre class="programlisting">{ name_param | default_value | description}</pre></div><p>The <code class="literal">name_param</code> can <a id="id80" class="indexterm"/>be preceded with <code class="literal">@</code>, which defines this parameter as a default input. We can use more than one <code class="literal">name_param</code>:</p><div class="informalexample"><pre class="programlisting">CommandLineParser parser(argc, argv, keys);</pre></div><p>The constructor will get the inputs of the main function and the key constants defined previously:</p><div class="informalexample"><pre class="programlisting">//If requires help show
if (parser.has("help"))
{
        parser.printMessage();
        return 0;
}</pre></div><p>The <code class="literal">.has</code> class method checks the parameter's existence. In this sample, we check whether the user has added the <code class="literal">–help</code> or ? <code class="literal">parameter</code>, and then, use the <code class="literal">printMessage</code> class function to show all the description parameters:</p><div class="informalexample"><pre class="programlisting">    String videoFile= parser.get&lt;String&gt;(0);</pre></div><p>With the <code class="literal">.get&lt;typename&gt;(parameterName)</code> function, we can access and read any of the input parameters:</p><div class="informalexample"><pre class="programlisting">    // Check if params are correctly parsed in his variables
    if (!parser.check())
    {
        parser.printErrors();
        return 0;
    }</pre></div><p>After getting all the required parameters, we can check whether these parameters are parsed correctly and show an error message if one of the parameters is not parsed. For example, add a string instead of a number:</p><div class="informalexample"><pre class="programlisting">VideoCapture cap; // open the default camera
if(videoFile != "")
    cap.open(videoFile);
    else
    cap.open(0);
    if(!cap.isOpened())  // check if we succeeded
    return -1;</pre></div><p>The class to read <a id="id81" class="indexterm"/>a video and camera is the same. The <code class="literal">VideoCapture</code> class <a id="id82" class="indexterm"/>belongs to the <code class="literal">videoio</code> submodel instead of the <code class="literal">highgui</code> submodule, as in the former version of OpenCV. After creating the object, we check whether the input command line <code class="literal">videoFile</code> parameter has a path filename. If it's empty, then we try to open a web camera and, if it has a filename, then we open the video file. To do this, we use the open function, giving the video filename or the index camera that we want to open as a parameter. If we have a single camera, we can use <code class="literal">0</code> as a parameter.</p><p>To check whether we can read the video filename or the camera, we use the <code class="literal">isOpened</code> function:</p><div class="informalexample"><pre class="programlisting">namedWindow("Video",1);
for(;;)
{
    Mat frame;
    cap &gt;&gt; frame; // get a new frame from camera
     if(frame)
       imshow("Video", frame);
    if(waitKey(30) &gt;= 0) break;
}
// Release the camera or video cap
cap.release();</pre></div><p>Finally, we create a window to show the frames with the <code class="literal">namedWindow</code> function and, with a non-finish loop, we grab each frame with the <code class="literal">&gt;&gt;</code> operation and show the image with the <code class="literal">imshow</code> function, if we correctly retrieve the frame. In this case, we don't want to stop the application, but we want to wait for 30 milliseconds to check whether users want to stop the application execution with any key using <code class="literal">waitKey(30)</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note07"/>Note</h3><p>To choose a good value to wait for the next frame, using a camera access is calculated from the speed of the camera. For example, if a camera works at 20 FPS, a great wait value is <span class="emphasis"><em>40 = 1000/20</em></span>.</p></div></div><p>When the <a id="id83" class="indexterm"/>user wants to finish the app, he has to only press a key, and then we <a id="id84" class="indexterm"/>have to release all the video resources using the <code class="literal">release</code> function.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note08"/>Note</h3><p>It is very important to release all the resources that we use in a Computer Vision application; if we do not do it, we can consume all the RAM memory. We can release the matrices with the <code class="literal">release</code> function.</p></div></div><p>The result of the code is a new window that shows a video or web camera in the BGR format, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/B04283_02_05.jpg" alt="Reading videos and cameras"/></div></div>
<div class="section" title="Other basic object types"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec20"/>Other basic object types</h1></div></div></div><p>We have learned <a id="id85" class="indexterm"/>about the Mat and Vec3b classes, but we need to learn about other classes as well.</p><p>In this section, we will learn about the most basic object types required in most of the projects:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Vec</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Scalar</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Point</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Size</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Rect</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">RotatedRect</code></li></ul></div><div class="section" title="The vec object type"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec26"/>The vec object type</h2></div></div></div><p>
<code class="literal">vec</code> <a id="id86" class="indexterm"/>is a template class that is used mainly for numerical vectors. We<a id="id87" class="indexterm"/> can define any type of vectors and a number of components:</p><div class="informalexample"><pre class="programlisting">Vec&lt;double,19&gt; myVector;</pre></div><p>Or we can use any of the predefined types:</p><div class="informalexample"><pre class="programlisting">typedef Vec&lt;uchar, 2&gt; Vec2b;
typedef Vec&lt;uchar, 3&gt; Vec3b;
typedef Vec&lt;uchar, 4&gt; Vec4b;

typedef Vec&lt;short, 2&gt; Vec2s;
typedef Vec&lt;short, 3&gt; Vec3s;
typedef Vec&lt;short, 4&gt; Vec4s;

typedef Vec&lt;int, 2&gt; Vec2i;
typedef Vec&lt;int, 3&gt; Vec3i;
typedef Vec&lt;int, 4&gt; Vec4i;

typedef Vec&lt;float, 2&gt; Vec2f;
typedef Vec&lt;float, 3&gt; Vec3f;
typedef Vec&lt;float, 4&gt; Vec4f;
typedef Vec&lt;float, 6&gt; Vec6f;

typedef Vec&lt;double, 2&gt; Vec2d;
typedef Vec&lt;double, 3&gt; Vec3d;
typedef Vec&lt;double, 4&gt; Vec4d;
typedef Vec&lt;double, 6&gt; Vec6d;</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note09"/>Note</h3><p>All the expected vector operations are also implemented, as follows:</p><p>
<code class="literal">v1 = v2 + v3</code>
</p><p>
<code class="literal">v1 = v2 - v3</code>
</p><p>
<code class="literal">v1 = v2 * scale</code>
</p><p>
<code class="literal">v1 = scale * v2</code>
</p><p>
<code class="literal">v1 = -v2</code>
</p><p>
<code class="literal">v1 += v2</code> and other augmenting operations</p><p>
<code class="literal">v1 == v2, v1 != v2</code>
</p><p>
<code class="literal">norm(v1) (euclidean norm)</code>
</p></div></div></div><div class="section" title="The Scalar object type"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec27"/>The Scalar object type</h2></div></div></div><p>The <a id="id88" class="indexterm"/>
<code class="literal">Scalar</code> object type<a id="id89" class="indexterm"/> is a template class derived from Vec with four elements. The <code class="literal">Scalar</code> type is widely used in OpenCV to pass and read pixel values.</p><p>To access the values of <code class="literal">Vec</code> and <code class="literal">Scalar</code>, we use the [] operator.</p></div><div class="section" title="The Point object type"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec28"/>The Point object type</h2></div></div></div><p>Another <a id="id90" class="indexterm"/>very common class template is <code class="literal">Point</code>. This <a id="id91" class="indexterm"/>class defines a 2D point specified by its <code class="literal">x</code> and <code class="literal">y</code> coordinates.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note10"/>Note</h3><p>Like the Point object type, there is a Point3 template class for 3D point support.</p></div></div><p>Like the <code class="literal">Vec</code> class, OpenCV defines the following <code class="literal">Point</code> aliases for our convenience:</p><div class="informalexample"><pre class="programlisting">typedef Point_&lt;int&gt; Point2i;
typedef Point2i Point;
typedef Point_&lt;float&gt; Point2f;
typedef Point_&lt;double&gt; Point2d;</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note11"/>Note</h3><p>The following operators are defined for points:</p><div class="informalexample"><pre class="programlisting">pt1 = pt2 + pt3;
pt1 = pt2 - pt3;
pt1 = pt2 * a;
pt1 = a * pt2;
pt1 = pt2 / a;
pt1 += pt2;
pt1 -= pt2;
pt1 *= a;
pt1 /= a;
double value = norm(pt); // L2 norm
pt1 == pt2;
pt1 != pt2;</pre></div></div></div></div><div class="section" title="The Size object type"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec29"/>The Size object type</h2></div></div></div><p>Another <a id="id92" class="indexterm"/>
<code class="literal">template</code> class that is very important <a id="id93" class="indexterm"/>and used in OpenCV is the <code class="literal">template</code> class used to specify the size of an image or rectangle, Size. This class adds two members: the width and height and a useful <code class="literal">area()</code>function.</p></div><div class="section" title="The Rect object type"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec30"/>The Rect object type</h2></div></div></div><p>
<code class="literal">Rect</code>
<a id="id94" class="indexterm"/> is another important template class used to define <a id="id95" class="indexterm"/>2D rectangles by the following parameters:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The coordinates of the top-left corner</li><li class="listitem" style="list-style-type: disc">The width and height of a rectangle</li></ul></div><p>The <code class="literal">Rect</code> template class can be used to define a <a id="id96" class="indexterm"/>
<span class="strong"><strong>ROI</strong></span> (<span class="strong"><strong>region of interest</strong></span>) of an image.</p></div><div class="section" title="RotatedRect object type"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec31"/>RotatedRect object type</h2></div></div></div><p>The <a id="id97" class="indexterm"/>last useful class is a particular rectangle called <a id="id98" class="indexterm"/>
<code class="literal">RotatedRect</code>. This class represents a rotated rectangle specified by a center point, the width and height of a rectangle, and the rotation angle in degrees:</p><div class="informalexample"><pre class="programlisting">RotatedRect(const Point2f&amp; center, const Size2f&amp; size, float angle);</pre></div><p>An interesting function of this class is <code class="literal">boundingBox</code>; this function returns a <code class="literal">Rect</code> that contains the <a id="id99" class="indexterm"/>rotated rectangle:</p><div class="mediaobject"><img src="graphics/B04283_02_06.jpg" alt="RotatedRect object type"/></div></div></div>
<div class="section" title="Basic matrix operations"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec21"/>Basic matrix operations</h1></div></div></div><p>In <a id="id100" class="indexterm"/>this section, we will learn some basic and important matrix operations that we can apply to images or any matrix data.</p><p>We learned how to load an image and store it in a <code class="literal">Mat</code> variable, but we can manually create a Mat variable. The most common constructor that provides the matrix size and type is as follows:</p><div class="informalexample"><pre class="programlisting">Mat a= Mat(Size(5,5), CV_32F);</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note12"/>Note</h3><p>You can create a new <code class="literal">Matrix link</code> with a stored buffer from third-party libraries, without copying the data, using the following constructor:</p><div class="informalexample"><pre class="programlisting">Mat(size, type, pointer_to_buffer)</pre></div></div></div><p>The supported types depend on the type of the number you want to store and the number of channels. The most common types are as follows:</p><div class="informalexample"><pre class="programlisting">CV_8UC1
CV_8UC3
CV_8UC4
CV_32FC1
CV_32FC3
CV_32FC4</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note13"/>Note</h3><p>You can create any type of a matrix using <code class="literal">CV_number_typeC(n)</code>, where <code class="literal">number_type</code> is 8U (8 bits unsigned) to 64F (64 float) and (n) is the number of channels. The number of channels allowed is from <code class="literal">1</code> to <code class="literal">CV_CN_MAX</code>.</p></div></div><p>This<a id="id101" class="indexterm"/> initialization does not set up the data values and you can get undesirable values. To avoid undesirable values, you can initialize the matrix with <code class="literal">zeros</code> or <code class="literal">ones</code> values with the <code class="literal">zeros</code> or <code class="literal">ones</code> function:</p><div class="informalexample"><pre class="programlisting">Mat mz= Mat::zeros(5,5, CV_32F);
Mat mo= Mat::ones(5,5, CV_32F);</pre></div><p>The output of the preceding matrix is as follows:</p><div class="mediaobject"><img src="graphics/B04283_02_07.jpg" alt="Basic matrix operations"/></div><p>A special matrix initialization is the <span class="strong"><strong>eye</strong></span> function that creates an <code class="literal">identity</code> matrix with the specified type (<code class="literal">CV_8UC1, CV_8UC3…</code>) and size:</p><div class="informalexample"><pre class="programlisting">Mat m= Mat::eye(5,5, CV_32F);</pre></div><p>The output is as follows:</p><div class="mediaobject"><img src="graphics/B04283_02_08.jpg" alt="Basic matrix operations"/></div><p>All matrix <a id="id102" class="indexterm"/>operations are allowed in the OpenCV Mat class. We can add or subtract two matrices with <code class="literal">+</code> and <code class="literal">-</code> operators:</p><div class="informalexample"><pre class="programlisting">Mat a= Mat::eye(Size(3,2), CV_32F);
Mat b= Mat::ones(Size(3,2), CV_32F);
Mat c= a+b;
Mat d= a-b;</pre></div><p>The results of the previous operations are as follows:</p><div class="mediaobject"><img src="graphics/B04283_02_09.jpg" alt="Basic matrix operations"/></div><p>We can multiply a matrix by a scalar with the <code class="literal">*</code> operator, a matrix per element matrix with the <code class="literal">mul</code> function, or a matrix by matrix multiplication with <code class="literal">*</code> operator:</p><div class="informalexample"><pre class="programlisting">Mat m1= Mat::eye(2,3, CV_32F);
Mat m2= Mat::ones(3,2, CV_32F);
// Scalar by matrix
cout &lt;&lt; "\nm1.*2\n" &lt;&lt; m1*2 &lt;&lt; endl;
// matrix per element multiplication
cout &lt;&lt; "\n(m1+2).*(m1+3)\n" &lt;&lt; (m1+1).mul(m1+3) &lt;&lt; endl;
// Matrix multiplication
cout &lt;&lt; "\nm1*m2\n" &lt;&lt; m1*m2 &lt;&lt; endl;</pre></div><p>The results<a id="id103" class="indexterm"/> of the previous operations are as follows:</p><div class="mediaobject"><img src="graphics/B04283_02_10.jpg" alt="Basic matrix operations"/></div><p>The other common mathematical matrix operations are transposition and matrix inversion, defined by the <code class="literal">t()</code> and <code class="literal">inv()</code> functions, respectively.</p><p>Other interesting functions that OpenCV provides us with are array operations in a matrix; for example, count the non-zero elements. This is useful to count the pixels or area of an object:</p><div class="informalexample"><pre class="programlisting">int countNonZero( src );</pre></div><p>OpenCV provides some statistical functions. The mean and standard deviation by channel can be calculated using the <code class="literal">meanStdDev</code> function:</p><div class="informalexample"><pre class="programlisting">meanStdDev(src, mean, stddev);</pre></div><p>The other useful statistical function is <code class="literal">minMaxLoc</code>. This function finds the minimum and the maximum of a matrix or array and returns its location and value:</p><div class="informalexample"><pre class="programlisting">minMaxLoc(src, minVal, maxVal, minLoc, maxLoc);</pre></div><p>Here, <code class="literal">src</code> is the input matrix, <code class="literal">minVal</code> and <code class="literal">maxVal</code> are double values detected, and <code class="literal">minLoc</code> and <code class="literal">maxLoc</code> are point values detected.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note14"/>Note</h3><p>Other core and useful functions are described in detail at <a class="ulink" href="http://docs.opencv.org/modules/core/doc/core.html">http://docs.opencv.org/modules/core/doc/core.html</a>.</p></div></div></div>
<div class="section" title="Basic data persistence and storage"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec22"/>Basic data persistence and storage</h1></div></div></div><p>Before <a id="id104" class="indexterm"/>we finish this chapter, we will explore the OpenCV functions to store and read our data. In many applications, such as calibration or machine learning, when we are done with the calculations, we need to save the results in order to retrieve them in the next executions. For this purpose, OpenCV provides an XML/YAML persistence layer.</p><div class="section" title="Writing to a file storage"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec32"/>Writing to a file storage</h2></div></div></div><p>To write a file <a id="id105" class="indexterm"/>with some OpenCV data or other numeric data, we can use the <code class="literal">FileStorage</code> class using the streaming c operator such as STL streaming:</p><div class="informalexample"><pre class="programlisting">#include "opencv2/opencv.hpp"
using namespace cv;

int main(int, char** argv)
{
    // create our writter
    FileStorage fs("test.yml", FileStorage::WRITE);
    // Save an int
    int fps= 5;
    fs &lt;&lt; "fps" &lt;&lt; fps;
    // Create some mat sample
    Mat m1= Mat::eye(2,3, CV_32F);
     Mat m2= Mat::ones(3,2, CV_32F);
     Mat result= (m1+1).mul(m1+3);
     // write the result
    fs &lt;&lt; "Result" &lt;&lt; result;
    // release the file
    fs.release();

    FileStorage fs2("test.yml", FileStorage::READ);

    Mat r;
    fs2["Result"] &gt;&gt; r;
    std::cout &lt;&lt; r &lt;&lt; std::endl;

    fs2.release();

    return 0;
}</pre></div><p>To create a <a id="id106" class="indexterm"/>file storage where we save the data, we only need to call the constructor by giving a path filename with the desired extension format (XML or YAML) with the second parameter set to <code class="literal">write</code>:</p><div class="informalexample"><pre class="programlisting">FileStorage fs("test.yml", FileStorage::WRITE);</pre></div><p>If we want to save the data, we only need to use the stream operator by giving an identifier in the first stage and the matrix or value that we want to save in the later stage. For example, to save an <code class="literal">int</code>, we need to write the following code:</p><div class="informalexample"><pre class="programlisting">int fps= 5;
fs &lt;&lt; "fps" &lt;&lt; fps;</pre></div><p>A <code class="literal">mat</code> is as follows:</p><div class="informalexample"><pre class="programlisting">Mat m1= Mat::eye(2,3, CV_32F);
Mat m2= Mat::ones(3,2, CV_32F);
Mat result= (m1+1).mul(m1+3);
// write the result
fs &lt;&lt; "Result" &lt;&lt; result;</pre></div><p>The result of the preceding code is in YAML format, which is as follows:</p><div class="informalexample"><pre class="programlisting">%YAML:1.0
fps: 5
Result: !!opencv-matrix
   rows: 2
   cols: 3
   dt: f
   data: [ 8., 3., 3., 3., 8., 3. ]</pre></div><p>Reading from a saved file previously is very similar to save functions:</p><div class="informalexample"><pre class="programlisting">#include "opencv2/opencv.hpp"
using namespace cv;

int main(int, char** argv)
{
    FileStorage fs2("test.yml", FileStorage::READ);

   Mat r;
   fs2["Result"] &gt;&gt; r;
   std::cout &lt;&lt; r &lt;&lt; std::endl;

   fs2.release();

   return 0;
}</pre></div><p>First, we have to <a id="id107" class="indexterm"/>open a saved file with the <code class="literal">FileStorage</code> constructor using the appropriate path and <code class="literal">FileStorage::READ</code> parameters:</p><div class="informalexample"><pre class="programlisting">FileStorage fs2("test.yml", FileStorage::READ);</pre></div><p>To read any stored variable, we only need to use the common <code class="literal">&gt;&gt;</code> stream operator using our <code class="literal">FileStorage</code> object and the identifier with the <code class="literal">[]</code> operator:</p><div class="informalexample"><pre class="programlisting">Mat r;
fs2["Result"] &gt;&gt; r;</pre></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec23"/>Summary</h1></div></div></div><p>In this chapter, we learned the basics of how to access images and videos and how they are stored in matrices.</p><p>We learned the basic matrix operations and other basic OpenCV classes to store pixels, vectors, and so on.</p><p>Finally, we learned how to save our data in files to allow them to be read in other applications or executions.</p><p>In the next chapter, we will learn how to create our first application by learning the basics of a Graphical User Interface that OpenCV gives us. We will create buttons and sliders and introduce some image processing basics.</p></div></body></html>