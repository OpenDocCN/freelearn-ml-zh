<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">RevoScaleR Package</h1>
                
            
            <article>
                
<p class="calibre2">The <kbd class="calibre11">RevoScaleR</kbd> package comes with Microsoft Machine Learning R Server and R Services. It is also available with R Client, but with some limitations discussed in <a target="_blank" href="part0025.html#NQU20-e3f81285367248f4bbc6431bcd4f926d" class="calibre10">Chapter 2</a>, <em class="calibre12">Overview of Microsoft Machine Learning Server and SQL Server</em>. Given the rapid development and constant upgrades, this chapter will cover version 8.X and version 9.X-the latter is also available with SQL Server 2017. Changes and upgrades in version 9.X are not to be overlooked and will be covered as well.</p>
<p class="calibre2">The following topics are covered in this chapter:</p>
<ul class="calibre7">
<li class="calibre8">Limitations of R challenged</li>
<li class="calibre8">Scalable and distributive computational environment</li>
<li class="calibre8">Functions for data preparation</li>
<li class="calibre8">Functions for descriptive statistics</li>
<li class="calibre8">Functions for statistical tests and sampling</li>
<li class="calibre8">Functions for predictive modeling</li>
</ul>
<p class="calibre2">Primarily, this R package is designed to be handled in ecosystems where clients would be connecting to Microsoft R Server in order to have R code executed against a much more powerful server, which would presumably hold whole datasets, not just a smaller portion, on which people working on client machines would be dealing with.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Overcomming R language limitations</h1>
                
            
            <article>
                
<p class="calibre2">Prior to SQL Server 2016 (and 2017) BI and data scientists had the OLAP cubes, DMX language, and all super awesome and cool Microsoft algorithms available within <strong class="calibre1">SQL Server Analysis Services </strong>(<strong class="calibre1">SSAS</strong>). But, with rapid changes and bigger market demands, the need for integration of an open-source product (whether R, Python, Perl,or any other) was practically already there. And the next logical step was to integrate it with one. Microsoft sought a solution and ended up acquiring Revolution Analytics, which has put them on track again. Revolution R has addressed major issues concerning the R language.</p>
<p class="calibre2">Microsoft addressed R's limitations. Many of these limitations were aimed at faster data exploration and parallel programming techniques in R. In addition to this, also MKL computations have been enhanced, therefore making matrix-wise calculations even faster, along with scalar calculation and also calculation resulting in cartesian-products.</p>
<p class="calibre2">The following limitations were addressed and also solved:</p>
<ul class="calibre7">
<li class="calibre8">Communication overhead is particularly an issue with fine-grained parallelism consisting of a very large number of relatively small tasks</li>
<li class="calibre8">Load balance is where computing resources aren't contributing equally to the problem</li>
<li class="calibre8">Impacts from the use of RAM and virtual memory, such as cache misses and page faults</li>
<li class="calibre8">Network effects, such as latency and bandwidth, that impact performance and communication overhead</li>
<li class="calibre8">Interprocess conflicts and thread scheduling</li>
<li class="calibre8">Data access and other I/O considerations</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Scalable and distributive computational environments</h1>
                
            
            <article>
                
<p class="calibre2">The <kbd class="calibre11">RevoScaleR</kbd> package has the following functions available, which will be covered in detail throughout the chapter.</p>
<p class="calibre2">To get a list of all the <kbd class="calibre11">ScaleR</kbd> functions, the following T-SQL can be used:</p>
<pre class="calibre19"><strong class="calibre1">EXEC sp_execute_external_script</strong>
<strong class="calibre1">      @language = N'R'</strong>
<strong class="calibre1">      ,@script = N'require(RevoScaleR)</strong>
<strong class="calibre1">                        OutputDataSet &lt;- data.frame(ls("package:RevoScaleR"))'</strong>
<strong class="calibre1">WITH RESULT SETS</strong>
<strong class="calibre1">      (( Functions NVARCHAR(200)))</strong>  </pre>
<p class="calibre2">You get a table in SSMS with all the relevant <kbd class="calibre11">rx</kbd> functions that can be used with the <kbd class="calibre11">RevoScaleR</kbd> package.</p>
<p class="calibre2">Based on the list of these functions, a simpler and better overview of the functions can be prepared:</p>
<div class="packt_figure"><img src="../images/00070.jpeg" class="calibre27"/></div>
<div class="cdpaligncenter">Figure 1: List of RevoScaleR functions (source: Microsoft)</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Functions for data preparation</h1>
                
            
            <article>
                
<p class="calibre2">Importing data is the first of the many processes in data preparation. Importing data is a process of bringing data into your system from any external system using an external file or by establishing a connection to a live data source. In the following part, we will look at importing data that is stored as SPSS or SAS files and using an ODBC connection string to connect directly to an external live database system.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Data import from SAS, SPSS, and ODBC</h1>
                
            
            <article>
                
<p class="calibre2">Importing data into R or SQL Server tables is not the main focus of <kbd class="calibre11">RevoScaleR</kbd> library, but since this is on the list, let's briefly look into it. In this manner, based on your data source, the <kbd class="calibre11">RevoScaleR</kbd> package gives many abilities to connect to different data sources. Among these are also SAS and SPSS - two very broad and common statistical programs for data analysis and predictive analytics. We will simply focus on SAS software (<a href="https://www.sas.com/" class="calibre10">https://www.sas.com/</a>), SPSS Statistics, acquired by IBM in 2009 (<a href="https://www.ibm.com/products/spss-statistics" class="calibre10">https://www.ibm.com/products/spss-statistics</a>), or SPSS Modeler (<a href="https://www.ibm.com/products/spss-modeler" target="_blank" class="calibre10">https://www.ibm.com/products/spss-modeler</a>).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Importing SAS data</h1>
                
            
            <article>
                
<p class="calibre2">SAS is among the popular programs for data analysis if not the most popular for statistical analysis, data mining, and machine learning. Therefore, let's create a simple SAS file and read it using the <kbd class="calibre11">ScaleR</kbd> function.</p>
<p class="calibre2">With the following SAS code (the code is available along with the book), you can very easily create a sample dataset:</p>
<div class="packt_figure"><img class="aligncenter45" src="../images/00071.gif"/></div>
<div class="cdpaligncenter">Figure 2: Outlook of SAS code</div>
<p class="calibre2">Now, let's assume that our SAS data is stored in the file <kbd class="calibre11">sas_data.sas7bdat</kbd> as the code suggests in the <kbd class="calibre11">PROC DATA</kbd> statement.</p>
<p class="calibre2">With the following R code, we can extract and import this dataset into the R <kbd class="calibre11">data.frame</kbd>:</p>
<pre class="calibre19"><strong class="calibre1">EXEC sp_execute_external_script</strong>
<strong class="calibre1">      @language = N'R'</strong>
<strong class="calibre1">      ,@script = N'</strong>
<strong class="calibre1">                  library(RevoScaleR)</strong>
<strong class="calibre1">                        SampleSASFile &lt;- file.path(rxGetOption("sampleDataDir"), "sas_data.sas7bdat")</strong>
<strong class="calibre1">                        #import into Dataframe</strong>
<strong class="calibre1">                        OutputDataSet &lt;- rxImport(SampleSASFile)</strong>
<strong class="calibre1">                        '</strong>
<strong class="calibre1">WITH RESULT SETS</strong>
<strong class="calibre1">      ((</strong>
<strong class="calibre1">       income  INT</strong>
<strong class="calibre1">      ,gender  INT</strong>
 <strong class="calibre1">     ,[count] INT</strong>
<strong class="calibre1">      ))</strong></pre>
<p class="calibre2">Make sure that your <kbd class="calibre11">sampleDataDir</kbd> holds the data sample. Also, you could specify some other path such as:</p>
<pre class="calibre19"><strong class="calibre1">SampleSASFile &lt;- file.path(("C:\\Users\\TomazK\\Documents\\CH05"), "sas_data.sas7bdat")</strong>  </pre>
<p class="calibre2">However, you need to make sure that you have granted access to this working folder. In both ways, you should get results presented as a table, read from the SAS file as follows:</p>
<div class="packt_figure"><img src="../images/00072.gif" class="calibre50"/></div>
<div class="cdpaligncenter">Figure 3: Outlook of SAS code result</div>
<p class="calibre2">Another way of importing the SAS file is by using <kbd class="calibre11">RxSasData</kbd> directly (in this case, from R):</p>
<pre class="calibre19"><strong class="calibre1">SampleSASFile &lt;- file.path(("C:\\Users\\tomazK\\CH05"), "sas_data.sas7bdat")</strong>
<strong class="calibre1">sasDS &lt;- RxSasData(SampleSASFile, stringsAsFactors = TRUE, </strong>
<strong class="calibre1">                   colClasses = c(income = "integer", gender= "integer", count="integer"),</strong>
<strong class="calibre1">rowsPerRead = 1000)</strong>
<strong class="calibre1">rxHistogram( ~F(gender)|F(income), data = sasDS)</strong>  </pre>
<p class="calibre2">You can easily generate a histogram from the SAS data file.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Importing SPSS data</h1>
                
            
            <article>
                
<p class="calibre2">With SPSS, the procedure is similar. The following SPSS syntax (the syntax is included with this chapter) generates the sample dataset, which is stored on your local machine:</p>
<div class="packt_figure"><img class="aligncenter46" src="../images/00073.gif"/></div>
<div class="cdpaligncenter">Figure 4: Outlook of SPSS syntax</div>
<p class="calibre2">This involves getting data into R Services using the SPSS save file that is generated from the preceding SPSS syntax, which is relatively the same as with the SAS file:</p>
<pre class="calibre19"><strong class="calibre1">EXEC sp_execute_external_script</strong>
<strong class="calibre1">      @language = N'R'</strong>
<strong class="calibre1">      ,@script = N'</strong>
<strong class="calibre1">                  library(RevoScaleR)</strong>
<strong class="calibre1">                        SampleSPSSFile &lt;- file.path(rxGetOption("sampleDataDir"), "spss_data.sav")</strong>
<strong class="calibre1">                        #import into Dataframe</strong>
<strong class="calibre1">                        OutputDataSet &lt;- rxImport(SampleSPSSFile)</strong>
<strong class="calibre1">                        '</strong>
<strong class="calibre1">WITH RESULT SETS</strong>
<strong class="calibre1">      ((</strong>
<strong class="calibre1">       income  INT</strong>
<strong class="calibre1">      ,gender  INT</strong>
<strong class="calibre1">      ,[count] INT</strong>
<strong class="calibre1">      ))</strong>
  </pre>
<p class="calibre2">In addition to this, the <kbd class="calibre11">RevoScaleR</kbd><span> </span>package has a special function to directly read the SPSS file called <kbd class="calibre11">RxSpssData</kbd>. The following R code can accomplish the same result as the preceding T-SQL code:</p>
<pre class="calibre19"><strong class="calibre1">SampleSPSSFile &lt;- file.path(("C:\\Users\\tomazK\\CH05"), "spss_data.sav")</strong>
<strong class="calibre1">spssDS &lt;- RxSpssData(SampleSPSSFile, stringsAsFactors = TRUE, </strong>
    <strong class="calibre1">                   colClasses = c(income = "integer", gender= "integer", count="integer"),rowsPerRead = 1000)</strong>
<strong class="calibre1">rxHistogram( ~F(income)|F(count), data = spssDS)</strong>
  </pre>
<p class="calibre2">And the <kbd class="calibre11">RevoScaleR</kbd> histogram can be used directly with the SPSS datasource, generating a simple histogram:</p>
<div class="packt_figure"><img src="../images/00074.jpeg" class="calibre27"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Importing data using ODBC</h1>
                
            
            <article>
                
<p class="calibre2">Using the ODBC driver extends accessibility to almost any kind of database whose driver you can obtain and that has  a common RDBM model.</p>
<p class="calibre2">The <kbd class="calibre11">RevoScaleR</kbd> package extends the list of ODBS drivers also to support systems on Linux and other systems. Using ODBC, you can connect to MySQL, Oracle, PostgreSQL, SQL Server on Linux, Cloudera, and Teradata (which in this case is much better to use than the <kbd class="calibre11">RxTeradata</kbd> function).</p>
<p class="calibre2">The following example will use the ODBC driver to get data from another SQL server instance, both using the <kbd class="calibre11">RxOdbcData</kbd> and <kbd class="calibre11">RxSqlServerData</kbd> function, since they are interchangeable:</p>
<pre class="calibre19"><strong class="calibre1">EXEC sp_execute_external_script</strong>
<strong class="calibre1">      @language = N'R'</strong>
<strong class="calibre1">      ,@script = N'</strong>
<strong class="calibre1">                  library(RevoScaleR)</strong>
<strong class="calibre1">            sConnectStr &lt;- "Driver={ODBC Driver 13 for SQL Server};Server=TOMAZK\MSSQLSERVER2017;Database=AdventureWorks;Trusted_Connection=Yes"</strong>
<strong class="calibre1">            sQuery = "SELECT TOP 10 BusinessEntityID,[Name],SalesPersonID FROM [Sales].[Store] ORDER BY BusinessEntityID ASC"</strong>
<strong class="calibre1">            sDS &lt;-RxOdbcData(sqlQuery=sQuery, connectionString=sConnectStr)</strong>
<strong class="calibre1">            OutputDataSet &lt;- data.frame(rxImport(sDS))</strong>
    <strong class="calibre1">                        '</strong>
<strong class="calibre1">WITH RESULT SETS</strong>
<strong class="calibre1">      ((</strong>
<strong class="calibre1">       BusinessEntityID  INT</strong>
<strong class="calibre1">      ,[Name]  NVARCHAR(50)</strong>
<strong class="calibre1">      ,SalesPersonID INT</strong>
<strong class="calibre1">      ));</strong>
  </pre>
<p class="calibre2">This would be the same as running the following on the same server:</p>
<pre class="calibre19"><strong class="calibre1">USE AdventureWorks;</strong>
<strong class="calibre1">GO</strong>
    
    
<strong class="calibre1">SELECT</strong>
<strong class="calibre1">TOP 10</strong>
<strong class="calibre1">BusinessEntityID</strong>
<strong class="calibre1">,[Name]</strong>
<strong class="calibre1">,SalesPersonID</strong>
<strong class="calibre1">FROM [Sales].[Store]</strong>
<strong class="calibre1">ORDER BY BusinessEntityID ASC</strong>
  </pre>
<p class="calibre2">In the case of using the <kbd class="calibre11">RxOdbcData</kbd> function, you should check the credentials and you might also want to check which user you are using to run the script. You can also create a new login and user and use it to check and execute the script: the <kbd class="calibre11">Adventureworks</kbd> database is available to download from Microsoft's GitHub website (<a href="https://github.com/Microsoft/sql-server-samples/tree/master/samples/databases/adventure-works" target="_blank" class="calibre10">https://github.com/Microsoft/sql-server-samples/tree/master/samples/databases/adventure-works</a>):</p>
<pre class="calibre19"><strong class="calibre1">EXECUTE AS USER='MSSQLSERVER01'</strong>
<strong class="calibre1">GO</strong>
<strong class="calibre1">-- YOUR CODE</strong>
<strong class="calibre1">REVERT;</strong>
<strong class="calibre1">GO</strong>
  </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Variable creation and data transformation</h1>
                
            
            <article>
                
<p class="calibre2">Variable creation and data transformation are two processes when defining data munging and data wrangling tasks. These tasks are important for proper data preparation and make it easier to analyze data for future tasks.</p>
<p class="calibre2">The functions<span> that we will be exploring a</span>re as follows:</p>
<ul class="calibre7">
<li class="calibre8">Variable creation and recoding</li>
<li class="calibre8">Data transformation</li>
<li class="calibre8">Handling missing values</li>
<li class="calibre8">Sorting, merging, and splitting datasets</li>
<li class="calibre8">Aggregate by category (which means sums), which is similar to T-SQL aggregations and Windows functions</li>
</ul>
<p class="calibre2">This part will cover some of the following functions, mainly focusing on data transformation, handling missing values, and splitting datasets:</p>
<p class="calibre2"><kbd class="calibre11">RxDataSource</kbd>, <kbd class="calibre11">rxDataStep</kbd>, <kbd class="calibre11">rxDataStepXdf</kbd>, <kbd class="calibre11">RxFileSystem</kbd>, <kbd class="calibre11">rxFindFileInPath</kbd>, <kbd class="calibre11">rxFindPackage</kbd>, <kbd class="calibre11">rxFisherTest</kbd>, <kbd class="calibre11">RxForeachDoPar</kbd>, <kbd class="calibre11">rxGetInfo</kbd>, <kbd class="calibre11">rxGetInfoXdf</kbd>, <kbd class="calibre11">rxGetJobInfo</kbd>, <kbd class="calibre11">rxGetJobInfo</kbd>, <kbd class="calibre11">rxGetOption</kbd>, <kbd class="calibre11">rxGetVarInfo</kbd>, <kbd class="calibre11">rxGetVarNames</kbd>, <kbd class="calibre11">rxImport</kbd>, <kbd class="calibre11">rxImportToXdf</kbd>, <kbd class="calibre11">rxIsOpen</kbd>, <kbd class="calibre11">rxOdbcData</kbd>, <kbd class="calibre11">rxOptions</kbd>, <kbd class="calibre11">rxOpen</kbd>, <kbd class="calibre11">rxQuantile</kbd>, <kbd class="calibre11">rxReadXdf</kbd>, <kbd class="calibre11">rxResultsDF</kbd>, <kbd class="calibre11">rxSetFileSystem</kbd>, <kbd class="calibre11">rxSetInfo</kbd>, <kbd class="calibre11">rxSetInfoXdf</kbd>, <kbd class="calibre11">rxSort</kbd>, <kbd class="calibre11">rxSetVarInfoXdf</kbd>, <kbd class="calibre11">rxSetVarInfo</kbd>, <kbd class="calibre11">rxMarginals</kbd>, <kbd class="calibre11">rxMerge</kbd>, <kbd class="calibre11">rxMergeXdf</kbd></p>
<p class="calibre2">When using In-database R Service (or the in-database machine learning service, also counting Python for SQL Server 2017), you should keep in mind where and how to do any kind of data transformation, data wrangling, as well as sorting and/or merging. After running many performance and speed tests, it became very clear that many of the munging and wrangling tasks should be done in-database, before sending the dataset to be executed by <kbd class="calibre11">sp_execute_external_script</kbd>. This set of functions is the only set where the computation context should be considered as a very important one. All the other functions for statistical tests, descriptive statistics, and predictive statistics can easily be used with external procedure, without compromising on performance or time.</p>
<p class="calibre2">Starting with the <kbd class="calibre11">rxDataStep</kbd> function, it gives us many opportunities to extract and generate XDF files, using in-database R:</p>
<pre class="calibre19"><strong class="calibre1">EXEC sp_execute_external_script</strong>
<strong class="calibre1">      @language = N'R'</strong>
<strong class="calibre1">      ,@script = N'</strong>
<strong class="calibre1">                  df_sql &lt;- InputDataSet        </strong>
 <strong class="calibre1">                 df_sql4 &lt;- data.frame(df_sql)</strong>
<strong class="calibre1">                  outfile &lt;- file.path(rxGetOption("sampleDataDir"), "df_sql4.xdf") </strong>
<strong class="calibre1">                  rxDataStep(inData = df_sql4, outFile = outfile, overwrite = TRUE)'</strong>
<strong class="calibre1">      ,@input_data_1 = N'</strong>
<strong class="calibre1">                  SELECT </strong>
<strong class="calibre1">                   BusinessEntityID</strong>
  <strong class="calibre1">                ,[Name]</strong>
    <strong class="calibre1">              ,SalesPersonID</strong>
    <strong class="calibre1">              FROM [Sales].[Store]'</strong>
  </pre>
<p class="calibre2">This will generate the <kbd class="calibre11">df_sql4.xdf</kbd> file on your sample data directory. If you are interested in where this folder is pointing to, you can do the following:</p>
<pre class="calibre19"><strong class="calibre1">EXEC sp_execute_external_script</strong>
<strong class="calibre1">      @language = N'R'</strong>
<strong class="calibre1">      ,@script = N'</strong>
<strong class="calibre1">         OutputDataSet &lt;- data.frame(path = file.path(rxGetOption("sampleDataDir")))'</strong>
  </pre>
<p class="calibre2">It will be something similar to what is shown in the following screenshot:</p>
<div class="packt_figure"><img class="aligncenter47" src="../images/00075.gif"/></div>
<p class="calibre2">And make sure that you have granted access for the user, executing the <kbd class="calibre11">rxDataStep</kbd> code, because the code will be creating a physical XDF file on the destination location.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Variable creation and recoding</h1>
                
            
            <article>
                
<p class="calibre2">Using <kbd class="calibre11">rxGetVarInfo</kbd> will expose the information about the <kbd class="calibre11">data.frame</kbd> to the <kbd class="calibre11">sp_execute_external_script</kbd> output. It is obvious that some of these functions were never designed for presenting the output to <kbd class="calibre11">data.frame</kbd>, but were designed only for exploring the dataset. Some of these functions-for example, <kbd class="calibre11">rxGetVarInfo</kbd>-will give a nice output in the R environment, but will be hard to manipulate in data frames for outputting in the SQL Server database:</p>
<pre class="calibre19"><strong class="calibre1">EXEC sp_execute_external_script</strong>
<strong class="calibre1">      @language = N'R'</strong>
<strong class="calibre1">      ,@script = N'</strong>
<strong class="calibre1">                  library(RevoScaleR)</strong>
<strong class="calibre1">                  df_sql &lt;- InputDataSet        </strong>
  <strong class="calibre1">                var_info &lt;- rxGetVarInfo(df_sql)</strong>
<strong class="calibre1">                  OutputDataSet &lt;- data.frame(unlist(var_info))'</strong>
<strong class="calibre1">      ,@input_data_1 = N'</strong>
<strong class="calibre1">                  SELECT </strong>
<strong class="calibre1">                   BusinessEntityID</strong>
<strong class="calibre1">                  ,[Name]</strong>
<strong class="calibre1">                  ,SalesPersonID</strong>
<strong class="calibre1">                  FROM [Sales].[Store]'</strong>
  </pre>
<p class="calibre2">Note that we are using the <kbd class="calibre11">unlist</kbd> function that unlists the set of lists in a single vector. Just to compare the output, we can run the same script in the R environment:</p>
<pre class="calibre19">library(RevoScaleR) 
sConnectStr &lt;- "Driver={ODBC Driver 13 for SQLServer};Server=TOMAZK\\MSSQLSERVER2017;Database=AdventureWorks;Trusted_Connection=Yes" 
sQuery = "SELECT  BusinessEntityID,[Name],SalesPersonID FROM [Sales].[Store] ORDER BY BusinessEntityID ASC" 
sDS &lt;-RxOdbcData(sqlQuery=sQuery, connectionString=sConnectStr) 
df_sql &lt;- data.frame(rxImport(sDS)) </pre>
<p class="calibre2">Now, running the <kbd class="calibre11">rxGetVarInfo(df_sql)</kbd> will give you a slightly different export:</p>
<pre class="calibre19">&gt; var_info &lt;- rxGetVarInfo(df_sql) 
&gt; var_info 
Var 1: BusinessEntityID, Type: integer, Low/High: (292, 2051) 
Var 2: Name, Type: character 
Var 3: SalesPersonID, Type: integer, Low/High: (275, 290) </pre>
<p class="calibre2">And after unlisting with the <kbd class="calibre11">unlist()</kbd> function, we get the same information, written in a slightly different manner:</p>
<pre class="calibre19">&gt; df &lt;- data.frame(unlist(var_info)) 
&gt; df 
                         unlist.var_info. 
BusinessEntityID.varType          integer 
BusinessEntityID.storage            int32 
BusinessEntityID.low                  292 
BusinessEntityID.high                2051 
Name.varType                    character 
Name.storage                       string 
SalesPersonID.varType             integer 
SalesPersonID.storage               int32 
SalesPersonID.low                     275 
SalesPersonID.high                    290 </pre>
<p class="calibre2">This indicates that some of these functions for variable creation and recoding were meant more for R data engineers than for T-SQL data engineers.</p>
<p class="calibre2">The <kbd class="calibre11">rxGetInfo()</kbd> function will get you the size of your dataset and the number of observations/variables:</p>
<pre class="calibre19"><strong class="calibre1">EXEC sp_execute_external_script</strong>
<strong class="calibre1">      @language = N'R'</strong>
<strong class="calibre1">      ,@script = N'</strong>
 <strong class="calibre1">                 library(RevoScaleR)</strong>
<strong class="calibre1">                  df_sql &lt;- InputDataSet        </strong>
  <strong class="calibre1">                var_info &lt;- rxGetInfo(df_sql)</strong>
<strong class="calibre1">                  OutputDataSet &lt;- data.frame(unlist(var_info))'</strong>
<strong class="calibre1">      ,@input_data_1 = N'</strong>
<strong class="calibre1">                  SELECT </strong>
    <strong class="calibre1">               BusinessEntityID</strong>
   <strong class="calibre1">               ,[Name]</strong>
  <strong class="calibre1">                ,SalesPersonID</strong>
  <strong class="calibre1">                FROM [Sales].[Store]'</strong>
  </pre>
<p class="calibre2">The same logic applies: if you run this R environment, you will get a neater display of information:</p>
<pre class="calibre19">&gt; rxGetInfo(df_sql) 
Data frame: df_sql  
Number of observations: 701  
Number of variables: 3  </pre>
<p class="calibre2">Adding some additional parameters to this function also yields a richer output, as follows:</p>
<pre class="calibre19">&gt; rxGetInfo(df_sql, getVarInfo = TRUE) 
Data frame: df_sql  
Number of observations: 701  
Number of variables: 3  
Variable information:  
Var 1: BusinessEntityID, Type: integer, Low/High: (292, 2051) 
Var 2: Name, Type: character 
Var 3: SalesPersonID, Type: integer, Low/High: (275, 290) </pre>
<p class="calibre2">A with <kbd class="calibre11">rxGetVarInfo</kbd>, <kbd class="calibre11">rxGetInfo</kbd> will create a list of elements. <kbd class="calibre11">rxGetVarInfo</kbd> will generate a list of lists, where the number of tuples equals the number of variables, and <kbd class="calibre11">rxGetInfo</kbd> will generate a list of six elements, where each list will hold information about the object:</p>
<div class="packt_figure"><img class="aligncenter48" src="../images/00076.gif"/></div>
<p class="calibre2">Knowing this, the preceding T-SQL executions can be slightly altered so that the relevant information is displayed in a more readable format, by presenting elements (tuples) to the result set:</p>
<pre class="calibre19"><strong class="calibre1">EXEC sp_execute_external_script</strong>
<strong class="calibre1">      @language = N'R'</strong>
<strong class="calibre1">      ,@script = N'</strong>
<strong class="calibre1">            library(RevoScaleR)</strong>
<strong class="calibre1">            df_sql &lt;- InputDataSet        </strong>
<strong class="calibre1">            get_Info &lt;- rxGetInfo(df_sql)             </strong>
<strong class="calibre1">            Object_names &lt;- c("Object Name", "Number of Rows", "Number of Variables")</strong>
<strong class="calibre1">            Object_values &lt;- c(get_Info$objName, get_Info$numRows, get_Info$numVars)</strong>
<strong class="calibre1">            OutputDataSet &lt;- data.frame(Object_names, Object_values)'</strong>
<strong class="calibre1">      ,@input_data_1 = N'</strong>
<strong class="calibre1">                  SELECT </strong>
 <strong class="calibre1">                  BusinessEntityID</strong>
 <strong class="calibre1">                 ,[Name]</strong>
   <strong class="calibre1">               ,SalesPersonID</strong>
   <strong class="calibre1">               FROM [Sales].[Store]'</strong>
<strong class="calibre1">WITH RESULT SETS</strong>
<strong class="calibre1">      ((</strong>
<strong class="calibre1">       ObjectName NVARCHAR(100)</strong>
<strong class="calibre1">      ,ObjectValue NVARCHAR(MAX)</strong>
<strong class="calibre1">      ));</strong>
  </pre>
<p class="calibre2">The results returned in SQL Server Management Studio:</p>
<div class="packt_figure"><img class="aligncenter49" src="../images/00077.gif"/></div>
<p class="calibre2">This looks very neat and spending some extra effort will for sure give much better formatted results that will be easier to read as well as much more informative.</p>
<p class="calibre2">In this example, you have also seen how to create a new variable. This especially comes in handy when cleaning data or recoding/bucketing data.</p>
<p class="calibre2">Let's suppose that you want to recode the values of existing variables in the dataset and create a new one. It can be done using standard R code as follows:</p>
<pre class="calibre19"><strong class="calibre1">EXEC sp_execute_external_script</strong>
<strong class="calibre1">      @language = N'R'</strong>
<strong class="calibre1">      ,@script = N'</strong>
<strong class="calibre1">            df_sql &lt;- InputDataSet</strong>
<strong class="calibre1">            #first create an empty variable</strong>
<strong class="calibre1">            df_sql$BusinessType &lt;- NA</strong>
<strong class="calibre1">            df_sql$BusinessType[df_sql$BusinessEntityID&lt;=1000] &lt;- "Car Business"</strong>
<strong class="calibre1">            df_sql$BusinessType[df_sql$BusinessEntityID&gt;1000] &lt;- "Food Business"</strong>
<strong class="calibre1">            OutputDataSet &lt;- df_sql'</strong>
<strong class="calibre1">      ,@input_data_1 = N'</strong>
<strong class="calibre1">                  SELECT </strong>
<strong class="calibre1">                   BusinessEntityID</strong>
<strong class="calibre1">                  ,[Name]</strong>
<strong class="calibre1">                  ,SalesPersonID</strong>
<strong class="calibre1">                  FROM [Sales].[Store]'</strong>
<strong class="calibre1">WITH RESULT SETS</strong>
<strong class="calibre1">      ((</strong>
<strong class="calibre1">       BusinessEntityID INT</strong>
<strong class="calibre1">      ,[Name] NVARCHAR(MAX)</strong>
<strong class="calibre1">      ,SalesPersonID INT</strong>
<strong class="calibre1">      ,TypeOfBusiness NVARCHAR(MAX)</strong>
<strong class="calibre1">      ));</strong>
  </pre>
<p class="calibre2">Alternatively, you can do this using the <kbd class="calibre11">rxDataStep()</kbd> function and the <kbd class="calibre11">transformFunc</kbd> parameter with an additional function for creating a new variable by transforming old values:</p>
<pre class="calibre19"><strong class="calibre1">EXEC sp_execute_external_script</strong>
<strong class="calibre1">      @language = N'R'</strong>
<strong class="calibre1">      ,@script = N'</strong>
<strong class="calibre1">                  library(RevoScaleR)</strong>
<strong class="calibre1">                  df_sql &lt;- InputDataSet</strong>
<strong class="calibre1">                  df_sql$BusinessEntityID_2 &lt;- NA</strong>

<strong class="calibre1">            myXformFunc &lt;- function(dataList) {</strong>
<strong class="calibre1">             #dataList$BussEnt &lt;- 100 * dataList$BusinessEntityID</strong>
<strong class="calibre1">            if (dataList$BusinessEntityID&lt;=1000){dataList$BussEnt &lt;- "Car Business"} else {dataList$BussEnt &lt;- "Food Business"}</strong>
<strong class="calibre1">                  return (dataList)</strong>
<strong class="calibre1">                  }</strong>
 
<strong class="calibre1">                  df_sql &lt;- rxDataStep(inData = df_sql, transformFunc = myXformFunc)</strong>
<strong class="calibre1">                  OutputDataSet &lt;- df_sql'</strong>
<strong class="calibre1">      ,@input_data_1 = N'</strong>
<strong class="calibre1">                  SELECT </strong>
<strong class="calibre1">                   BusinessEntityID</strong>
<strong class="calibre1">                  ,[Name]</strong>
<strong class="calibre1">                  ,SalesPersonID</strong>
<strong class="calibre1">                  FROM [Sales].[Store]'</strong>
<strong class="calibre1">WITH RESULT SETS</strong>
<strong class="calibre1">      ((</strong>
<strong class="calibre1">       BusinessEntityID INT</strong>
<strong class="calibre1">      ,[Name] NVARCHAR(MAX)</strong>
<strong class="calibre1">      ,SalesPersonID INT</strong>
<strong class="calibre1">      ,TypeOfBusiness NVARCHAR(MAX)</strong>
<strong class="calibre1">      ));</strong></pre>
<p class="calibre2"><kbd class="calibre11">rxDataStep()X</kbd> is a very powerful function mainly for data selection, subsetting, data transformation, and the creation of new variables for the desired dataset.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Dataset subsetting</h1>
                
            
            <article>
                
<p class="calibre2">Subsetting the data is also relatively straightforward using the <kbd class="calibre11">rxDataStep()</kbd> function:</p>
<pre class="calibre19"><strong class="calibre1">EXEC sp_execute_external_script</strong>
<strong class="calibre1">      @language = N'R'</strong>
<strong class="calibre1">      ,@script = N'</strong>
<strong class="calibre1">                  library(RevoScaleR)</strong>
<strong class="calibre1">                  df_sql &lt;- InputDataSet</strong>
<strong class="calibre1">                  df_sql_subset &lt;- rxDataStep(inData = df_sql, varsToKeep = NULL, rowSelection = (BusinessEntityID&lt;=1000))</strong>
<strong class="calibre1">                  OutputDataSet &lt;- df_sql_subset'</strong>
<strong class="calibre1">      ,@input_data_1 = N'</strong>
<strong class="calibre1">                  SELECT </strong>
<strong class="calibre1">                   BusinessEntityID</strong>
<strong class="calibre1">                  ,[Name]</strong>
<strong class="calibre1">                  ,SalesPersonID</strong>
<strong class="calibre1">                  FROM [Sales].[Store]'</strong>
<strong class="calibre1">WITH RESULT SETS</strong>
<strong class="calibre1">      ((</strong>
<strong class="calibre1">       BusinessEntityID INT</strong>
<strong class="calibre1">      ,[Name] NVARCHAR(MAX)</strong>
<strong class="calibre1">      ,SalesPersonID INT</strong>
<strong class="calibre1">      ));</strong>
  </pre>
<p class="calibre2">Keep in mind that subsetting operations using R code might bring unnecessary memory and I/O costs, especially when pumping whole datasets into R, instead of subsetting the data beforehand. In the preceding example, using the <kbd class="calibre11">rowSelection</kbd> parameter in <kbd class="calibre11">rxDataStep</kbd> can easily be replaced with the <kbd class="calibre11">WHERE</kbd> clause in the <kbd class="calibre11">@input_data_1</kbd> argument. So bear this in mind and always avoid unnecessary traffic.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Dataset merging</h1>
                
            
            <article>
                
<p class="calibre2">The <kbd class="calibre11">rxMerge()</kbd> function merges two datasets into one. The datasets must be a dataframe (or XDF format) and operate similarly to the <kbd class="calibre11">JOIN</kbd> clause in T-SQL (the <kbd class="calibre11">rxMerge()</kbd> function should not be confused with T-SQL's <kbd class="calibre11">MERGE</kbd> statement). Two datasets are merged based on one or more variables using the <kbd class="calibre11">matchVars</kbd> argument. In addition, when using the local compute context (which we are using in the next sample), the sorting of the data needs to be defined as well, since <kbd class="calibre11">data.frames</kbd>-as a collection of vectors-in R are not presorted or do not hold any sorts whatsoever. So, if no presorting is done, the <kbd class="calibre11">autoSort</kbd> argument must be set to true (<kbd class="calibre11">autosort = TRUE</kbd>):</p>
<pre class="calibre19"><strong class="calibre1">EXEC sp_execute_external_script</strong>
<strong class="calibre1">      @language = N'R'</strong>
<strong class="calibre1">      ,@script = N'</strong>
<strong class="calibre1">      library(RevoScaleR)</strong>
<strong class="calibre1">      df_sql &lt;- InputDataSet</strong>
<strong class="calibre1">      someExtraData &lt;- data.frame(BusinessEntityID = 1:1200, department = rep(c("a", "b", "c", "d"), 25), Eff_score = rnorm(100))</strong>
<strong class="calibre1">      df_sql_merged &lt;- rxMerge(inData1 = df_sql, inData2 = someExtraData, overwrite = TRUE, matchVars = "BusinessEntityID", type = "left" ,autoSort = TRUE)</strong>
<strong class="calibre1">      OutputDataSet &lt;- df_sql_merged'</strong>
<strong class="calibre1">      ,@input_data_1 = N'</strong>
<strong class="calibre1">                  SELECT </strong>
<strong class="calibre1">                   BusinessEntityID</strong>
<strong class="calibre1">                  ,[Name]</strong>
<strong class="calibre1">                  ,SalesPersonID</strong>
<strong class="calibre1">                  FROM [Sales].[Store]'</strong>
<strong class="calibre1">WITH RESULT SETS</strong>
<strong class="calibre1">      ((</strong>
<strong class="calibre1">       BusinessEntityID INT</strong>
<strong class="calibre1">      ,[Name] NVARCHAR(MAX)</strong>
<strong class="calibre1">      ,SalesPersonID INT</strong>
<strong class="calibre1">      ,Department CHAR(1)</strong>
<strong class="calibre1">      ,Department_score FLOAT</strong>
<strong class="calibre1">      ));</strong>
  </pre>
<p class="calibre2">This T-SQL code creates a left join on both the datasets. Dataframe 2 (called <kbd class="calibre11">someExtraData</kbd>) is created on the fly, but it can be any other dataframe read from an XDF file or any manually inserted dataset, and will be joined at R runtime. Also, pay attention to which is the first and which is the second data frame in combination to which type of join you are using. The preceding example specifies the following:</p>
<pre class="calibre19">inData1 = df_sql, inData2 = someExtraData, type = "left" </pre>
<p class="calibre2">However, the order of the data frames could be changed as follows:</p>
<pre class="calibre19">inData1 = someExtraData , inData2 = df_sql, type = "left" </pre>
<p class="calibre2">Then, the output would be presented differently (the sorting of the columns in the data frame would be changed).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Functions for descriptive statistics</h1>
                
            
            <article>
                
<p class="calibre2">Descriptive statistics give insights into understanding data. These are summary statistics that describe a given dataset by summarizing features and measures, such as central tendency and measure of spread (or variability). Central tendency includes calculation of the mean, median, mode, whereas measures of variability include range, quartiles, minimum and maximum value, variance and standard deviation, as well as skewness and kurtosis.</p>
<p class="calibre2">These statistics are covered by<kbd class="calibre11">rx-</kbd> functions in <kbd class="calibre11">RevoScaleR</kbd> package, which means that you can use all the computational advantages of the package by calling: <kbd class="calibre11">rxSummary</kbd>, <kbd class="calibre11">rxCrossTabs</kbd>, <kbd class="calibre11">rxMarginals</kbd>, <kbd class="calibre11">rxQuantile</kbd>, <kbd class="calibre11">rxCube</kbd>, and <kbd class="calibre11">rxHistogram</kbd>, without worrying about the performance, out of memory exceptions, or which R package holds the right function.</p>
<p class="calibre2">We will be using the<kbd class="calibre11">[Sales].[vPersonDemographics]</kbd> view in the <kbd class="calibre11">AdventureWorks</kbd> database to neatly show the usability of these functions:</p>
<pre class="calibre18"><strong class="calibre1">EXEC sp_execute_external_script</strong>
<strong class="calibre1">      @language = N'R'</strong>
<strong class="calibre1">      ,@script = N'</strong>
<strong class="calibre1">            library(RevoScaleR)</strong>
<strong class="calibre1">            df_sql &lt;- InputDataSet</strong>
<strong class="calibre1">            summary &lt;- rxSummary(~ TotalChildren,  df_sql, summaryStats = c( "Mean", "StdDev", "Min", "Max","Sum","ValidObs", "MissingObs"))</strong>
<strong class="calibre1">            OutputDataSet &lt;- summary$sDataFrame'</strong>
<strong class="calibre1">      ,@input_data_1 = N'</strong>
<strong class="calibre1">      SELECT * FROM [Sales].[vPersonDemographics] WHERE [DateFirstPurchase] IS NOT NULL'</strong>
<strong class="calibre1">WITH RESULT SETS</strong>
<strong class="calibre1">      ((</strong>
<strong class="calibre1">        VariableName NVARCHAR(MAX)</strong>
<strong class="calibre1">      ,"Mean"NVARCHAR(100)</strong>
<strong class="calibre1">      ,"StdDev"NVARCHAR(100)</strong>
<strong class="calibre1">      ,"Min"NVARCHAR(100)</strong>
<strong class="calibre1">      ,"Max"NVARCHAR(100)</strong>
<strong class="calibre1">      ,"Sum"NVARCHAR(100)</strong>
<strong class="calibre1">      ,"ValidObs"NVARCHAR(100)</strong>
<strong class="calibre1">      ,"MissingObs"NVARCHAR(100)</strong>
<strong class="calibre1">      ));</strong>
  </pre>
<p class="calibre2">With one line of R code, you can get some summary statistics. I prefer using the <kbd class="calibre11">summaryStats</kbd> argument to list the statistics, but note that the order of the statistics does not mean that the order of the output will be the same. In addition, using the element <kbd class="calibre11">summary$sDataFrame</kbd> dataframe as a result from <kbd class="calibre11">rxSummary</kbd> will automatically generate the data frame that will contain all the summaries for numeric variables.</p>
<p class="calibre2">The result of the T-SQL query is as follows:</p>
<div class="packt_figure"><img class="aligncenter50" src="../images/00078.gif"/></div>
<p class="calibre2">The <kbd class="calibre11">rxSummary()</kbd> function also holds a formula, whereby you can specify which variables the function will take into account while calculating descriptive statistics. In our case, we have used only the <kbd class="calibre11">TotalChildren</kbd> variable:</p>
<pre class="calibre19">rxSummary(~ TotalChildren, ... </pre>
<p class="calibre2">But let's assume, we want to get descriptives for all the variables; we simply write the following:</p>
<pre class="calibre19">rxSummary(~.,  .... </pre>
<p class="calibre2">This will give us statistics for all the variables as shown in the following screenshot:</p>
<div class="packt_figure"><img class="aligncenter51" src="../images/00079.gif"/></div>
<p class="calibre2">Note that only the integer (continuous) type of variables will be taken into consideration, whereas variables such as <kbd class="calibre11">MaritalStatus</kbd>, <kbd class="calibre11">Education</kbd>, and <kbd class="calibre11">Occupation</kbd>, will be presented as <kbd class="calibre11">NULL</kbd>, since these variables are treated as categorical variables in R.</p>
<p class="calibre2">For this, firstly, we will need to specify the factor variable, and based on that we will be able to run the statistics:</p>
<pre class="calibre19"><strong class="calibre1">EXEC sp_execute_external_script</strong>
<strong class="calibre1">      @language = N'R'</strong>
<strong class="calibre1">      ,@script = N'</strong>
<strong class="calibre1">      library(RevoScaleR)</strong>
<strong class="calibre1">      df_sql &lt;- InputDataSet</strong>
<strong class="calibre1">      df_sql_r &lt;- rxFactors(inData = df_sql, sortLevels = TRUE,</strong>
<strong class="calibre1">factorInfo = list(MS = list(levels = c("M","S"), otherLevel=NULL, varName="MaritalStatus")))</strong>
<strong class="calibre1">                  summary &lt;- rxSummary(~ MS,  df_sql_r)</strong>
<strong class="calibre1">                  OutputDataSet &lt;- data.frame(summary$categorical)'</strong>
<strong class="calibre1">      ,@input_data_1 = N'</strong>
<strong class="calibre1">      SELECT * FROM [Sales].[vPersonDemographics] WHERE [DateFirstPurchase] IS NOT NULL'</strong>
<strong class="calibre1">WITH RESULT SETS</strong>
<strong class="calibre1">      ((</strong>
<strong class="calibre1">        MS NVARCHAR(MAX)</strong>
<strong class="calibre1">        ,"Counts"INT</strong>
<strong class="calibre1">      ));</strong>
  </pre>
<p class="calibre2">This function will give simple counts for the <kbd class="calibre11">MaritalStatus</kbd> factor:</p>
<pre class="calibre19"><strong class="calibre1">MS Counts 
M  10011 
S   8473</strong> </pre>
<p class="calibre2">The same logic can be applied to all other categorical variables. The formula in the <kbd class="calibre11">rxSummary()</kbd> function also gives users the ability to combine different variables. For example, instead of using the following code:</p>
<pre class="calibre19">rxSummary(~ TotalChildren, df_sql_r) </pre>
<p class="calibre2">We can also use the following code:</p>
<pre class="calibre19">rxSummary(NumberCarsOwned ~ TotalChildren, df_sql_r) </pre>
<p class="calibre2">This will calculate the observed statistics for both the variables together:</p>
<pre class="calibre19"><strong class="calibre1">Name                          Mean     StdDev   Min Max Sum   ValidObs MissObs 
NumberCarsOwned:TotalChildren 3.258656 4.473517 0   20  60233 18484    0      </strong>    </pre>
<p class="calibre2">This can also be calculated for categorical variables. These variables need to be recoded into factors first and later the same summary statistics can be calculated:</p>
<pre class="calibre19">rxSummary(~ TotalChildren:F(MS), df_sql_r) </pre>
<p class="calibre2">And the complete R and T-SQL code using <kbd class="calibre11">sp_execute_external_script</kbd> is as follows:</p>
<pre class="calibre19"><strong class="calibre1">EXEC sp_execute_external_script</strong>
<strong class="calibre1">      @language = N'R'</strong>
<strong class="calibre1">      ,@script = N'</strong>
<strong class="calibre1">            library(RevoScaleR)</strong>
<strong class="calibre1">            df_sql &lt;- InputDataSet</strong>
<strong class="calibre1">            df_sql_r &lt;- rxFactors(inData = df_sql, sortLevels = TRUE,factorInfo = list(MS = list(levels = c("M","S"), otherLevel=NULL, varName="MaritalStatus")))</strong>
<strong class="calibre1">      summary &lt;- rxSummary(~F(MS):TotalChildren, df_sql_r, summaryStats = c( "Mean", "StdDev", "Min", "Max", "ValidObs", "MissingObs", "Sum"), categorical=c("MS"))</strong>
<strong class="calibre1">                  OutputDataSet &lt;- data.frame(summary$categorical)'</strong>
<strong class="calibre1">      ,@input_data_1 = N'</strong>
<strong class="calibre1">      SELECT * FROM [Sales].[vPersonDemographics] WHERE [DateFirstPurchase] IS NOT NULL'</strong>
<strong class="calibre1">WITH RESULT SETS</strong>
<strong class="calibre1">      ((</strong>
<strong class="calibre1">        Category NVARCHAR(MAX)</strong>
<strong class="calibre1">      ,"MS"NVARCHAR(MAX)</strong>
<strong class="calibre1">      ,"Means"FLOAT</strong>
<strong class="calibre1">      ,"StDev"FLOAT</strong>
<strong class="calibre1">      ,"Min"INT</strong>
<strong class="calibre1">      ,"Max"INT</strong>
<strong class="calibre1">      ,"Sum"INT</strong>
<strong class="calibre1">      ,"ValidObs"INT</strong>
<strong class="calibre1">      ));</strong>
  </pre>
<p class="calibre2">The following are the results for each factor level:</p>
<pre class="calibre19"><strong class="calibre1">Name               Mean     StdDev   Min Max Sum   ValidObs MissingObs</strong>
<strong class="calibre1"> TotalChildren:F_MS 1.844352 1.612408 0   5   34091 18484    0         </strong>
    
<strong class="calibre1">Statistics by category (2 categories):</strong>
    
<strong class="calibre1">Category                  F_MS Means    StdDev   Min Max Sum   ValidObs</strong>
<strong class="calibre1">TotalChildren for F(MS)=M M    2.080412 1.583326 0   5   20827 10011   </strong>
<strong class="calibre1">TotalChildren for F(MS)=S S    1.565443 1.601977 0   5   13264  8473   </strong>
  </pre>
<p class="calibre2">Quantiles and deciles are also very useful to view the data distribution and the <kbd class="calibre11">RevoScaleR</kbd> packages provides the <kbd class="calibre11">rxQuantile</kbd> function. Using T-SQL, the result set can be returned as follows:</p>
<pre class="calibre19"><strong class="calibre1">EXEC sp_execute_external_script</strong>
<strong class="calibre1">      @language = N'R'</strong>
<strong class="calibre1">      ,@script = N'</strong>
<strong class="calibre1">                  library(RevoScaleR)</strong>
   <strong class="calibre1">               df_sql &lt;- InputDataSet</strong>
  <strong class="calibre1">                quan &lt;- rxQuantile(data = df_sql, varName = "TotalChildren")</strong>
  <strong class="calibre1">                quan &lt;- data.frame(quan)</strong>
<strong class="calibre1">                  values &lt;- c("0%","25%","50%","75%","100%")</strong>
<strong class="calibre1">                  OutputDataSet &lt;- data.frame(values,quan)'</strong>
<strong class="calibre1">      ,@input_data_1 = N'</strong>
<strong class="calibre1">      SELECT * FROM [Sales].[vPersonDemographics] WHERE [DateFirstPurchase] IS NOT NULL'</strong>
 <strong class="calibre1">WITH RESULT SETS</strong>
    <strong class="calibre1">  ((</strong>
 <strong class="calibre1">           Quartile NVARCHAR(100)</strong>
   <strong class="calibre1">         ,QValue FLOAT</strong>
<strong class="calibre1">      ));</strong>
  </pre>
<p class="calibre2">This gives us the following result:</p>
<pre class="calibre19"><strong class="calibre1">0%  25%  50%  75% 100% </strong>
<strong class="calibre1">0    0    2    3    5 </strong>
  </pre>
<p class="calibre2">We can also modify and calculate deciles with a slight change to the <kbd class="calibre11">rxQuantile()</kbd> function:</p>
<pre class="calibre19"><strong class="calibre1">EXEC sp_execute_external_script</strong>
<strong class="calibre1">      @language = N'R'</strong>
<strong class="calibre1">      ,@script = N'</strong>
<strong class="calibre1">            library(RevoScaleR)</strong>
<strong class="calibre1">            df_sql &lt;- InputDataSet</strong>
<strong class="calibre1">            dec &lt;- rxQuantile(data = df_sql, varName = "TotalChildren",  probs = seq(from = 0, to = 1, by = .1))</strong>
<strong class="calibre1">            dec &lt;- data.frame(dec)</strong>
<strong class="calibre1">      values &lt;- c("0%","10%","20%","30%","40%","50%","60%","70%","80%","90%","100%")</strong>
<strong class="calibre1">            OutputDataSet &lt;- data.frame(values,dec)'</strong>
<strong class="calibre1">      ,@input_data_1 = N'</strong>
<strong class="calibre1">      SELECT * FROM [Sales].[vPersonDemographics] WHERE [DateFirstPurchase] IS NOT NULL'</strong>
<strong class="calibre1">WITH RESULT SETS</strong>
<strong class="calibre1">      ((</strong>
<strong class="calibre1">             Decile NVARCHAR(100)</strong>
<strong class="calibre1">            ,DValue FLOAT</strong>
<strong class="calibre1">      ));</strong>
  </pre>
<p class="calibre2">Calculating crosstabulations-the relationship between two (or more) variables-we will use two functions: <kbd class="calibre11">rxCrossTabs</kbd> and <kbd class="calibre11">rxMargins</kbd>. Crosstabulations are usually expressed in a contingency table or any other <em class="calibre12">[n]*[m] </em>table format; this really depends on the number of levels each variable will have.</p>
<p class="calibre2">We will use our two variables <kbd class="calibre11">NumberCarsOwned</kbd> and <kbd class="calibre11">TotalChildren</kbd> to explore the <kbd class="calibre11">rxCrossTabs</kbd>:</p>
<pre class="calibre19"><strong class="calibre1">EXEC sp_execute_external_script</strong>
<strong class="calibre1">      @language = N'R'</strong>
 <strong class="calibre1">     ,@script = N'</strong>
<strong class="calibre1">                  library(RevoScaleR)</strong>
<strong class="calibre1">                  df_sql &lt;- InputDataSet</strong>
  <strong class="calibre1">                crosstab &lt;- rxCrossTabs(N(NumberCarsOwned) ~ F(TotalChildren),  df_sql, means=FALSE) #means=TRUE</strong>
<strong class="calibre1">                  children &lt;- c(0,1,2,3,4,5)</strong>
    <strong class="calibre1">              OutputDataSet &lt;- data.frame(crosstab$sums, children)'</strong>
<strong class="calibre1">      ,@input_data_1 = N'</strong>
<strong class="calibre1">      SELECT * FROM [Sales].[vPersonDemographics] WHERE [DateFirstPurchase] IS NOT NULL'</strong>
<strong class="calibre1">WITH RESULT SETS</strong>
  <strong class="calibre1">    ((</strong>
 <strong class="calibre1">            NumberOfCarsOwnedSUM INT</strong>
   <strong class="calibre1">         ,NumberOfChildren INT</strong>
<strong class="calibre1">      ));</strong>
  </pre>
<p class="calibre2">Calculating crosstabulations using <kbd class="calibre11">rxCrossTabs</kbd> can give you two types of statistics: the count of observations and the mean of observations, given the category of intersect. This is manipulated using the means <kbd class="calibre11">= TRUE</kbd> or means <kbd class="calibre11">= FALSE</kbd> argument. The function operates in a way that will need the dependent variable(s) and independent variables(s) and in our example, the information can be retrieved from the results as follows:</p>
<pre class="calibre19"><strong class="calibre1">Cross Tabulation Results for: N(NumberCarsOwned) ~ F(TotalChildren)</strong>
<strong class="calibre1">Data: df_sql</strong>
<strong class="calibre1">Dependent variable(s): N(NumberCarsOwned)</strong>
<strong class="calibre1">Number of valid observations: 18484</strong>
<strong class="calibre1">Number of missing observations: 0 </strong>
<strong class="calibre1">Statistic: sums </strong>
  </pre>
<p class="calibre2">In order to have the crosstabulation successfully calculated, independent variables must be presented as factors. In this case, the <kbd class="calibre11">TotalChildren</kbd> variable has a <kbd class="calibre11">F()</kbd> function wrapped, denoting a factor conversion in the runtime.</p>
<p class="calibre2">This can be visualized using a standard barplot in the base package or R:</p>
<div class="packt_figure"><img src="../images/00080.jpeg" class="calibre51"/></div>
<p class="calibre2">Use the following code to plot the histogram using <kbd class="calibre11">barplot</kbd> function:</p>
<pre class="calibre19">library(RColorBrewer) 
barplot(OutputDataSet$V1, xlab = "Number of children",ylab = "Number of cars owned", 
        legend.text = c("0 Child","1 Child","2 Child","3 Child","4 Child","5 Child"), col=brewer.pal(6, "Paired")) </pre>
<p class="calibre2">Using variables that are categorical, there is no need for explicit conversion:</p>
<pre class="calibre19"><strong class="calibre1">EXEC sp_execute_external_script</strong>
 <strong class="calibre1">     @language = N'R'</strong>
<strong class="calibre1">      ,@script = N'</strong>
 <strong class="calibre1">           library(RevoScaleR)</strong>
  <strong class="calibre1">          df_sql &lt;- InputDataSet</strong>
<strong class="calibre1">            crosstab &lt;- rxCrossTabs(NumberCarsOwned ~ MaritalStatus,  df_sql, means=FALSE) </strong>
 <strong class="calibre1">           status &lt;- c("M","S")</strong>
  <strong class="calibre1">          OutputDataSet &lt;- data.frame(crosstab$sums, status)'</strong>
<strong class="calibre1">      ,@input_data_1 = N'</strong>
<strong class="calibre1">      SELECT * FROM [Sales].[vPersonDemographics] WHERE [DateFirstPurchase] IS NOT NULL'</strong>
<strong class="calibre1">WITH RESULT SETS</strong>
   <strong class="calibre1">   ((</strong>
  <strong class="calibre1">           NumberOfCarsOwnedSUM INT</strong>
   <strong class="calibre1">          ,MaritalStatus NVARCHAR(100)</strong>
<strong class="calibre1">      ));</strong>
  </pre>
<p class="calibre2">Also, the transform argument can be used to recode, recalculate, or somehow transform any of the variables. Marginal statistics from the contingency tables deriving from <kbd class="calibre11">rxCrossTabs</kbd> can be called using the <kbd class="calibre11">rxMarginals</kbd> functions, which is simply wrapped around the <kbd class="calibre11">rxCrossTabs</kbd>.</p>
<p class="calibre2">Marginal statistics will give you the sum, counts, or mean for each of the totals per row or per column for the desired variable:</p>
<pre class="calibre19"><strong class="calibre1">EXEC sp_execute_external_script</strong>
<strong class="calibre1">      @language = N'R'</strong>
<strong class="calibre1">      ,@script = N'</strong>
  <strong class="calibre1">                library(RevoScaleR)</strong>
    <strong class="calibre1">              df_sql &lt;- InputDataSet</strong>
    <strong class="calibre1">              mar &lt;- rxMarginals(rxCrossTabs(NumberCarsOwned ~ F(TotalChildren), data=df_sql, margin=TRUE, mean=FALSE))</strong>
<strong class="calibre1">                  OutputDataSet  &lt;- data.frame(mar$NumberCarsOwned$grand)'</strong>
<strong class="calibre1">      ,@input_data_1 = N'</strong>
 <strong class="calibre1">     SELECT * FROM [Sales].[vPersonDemographics] WHERE [DateFirstPurchase] IS NOT NULL'</strong>
<strong class="calibre1">WITH RESULT SETS</strong>
<strong class="calibre1">      ((</strong>
  <strong class="calibre1">          GrandTotal INT</strong>
<strong class="calibre1">      ));</strong>
  </pre>
<p class="calibre2">The result is as follows:</p>
<pre class="calibre19"><strong class="calibre1">&gt; mar$NumberCarsOwned$grand 
[1] 27776</strong> </pre>
<p class="calibre2">Exploring the data can also be done using the graphs and the <kbd class="calibre11">RevoScaleR</kbd> package comes with a Line and bar plot, both designed to tackle large datasets.</p>
<p class="calibre2">The following is a simplistic preview of one of the variables:</p>
<div class="packt_figure"><img src="../images/00081.jpeg" class="calibre52"/></div>
<p class="calibre2">Use the following line of R code:</p>
<pre class="calibre19">rxHistogram(~NumberCarsOwned, data=df_sql) </pre>
<p class="calibre2">This has already been converted to marital status factor as follows:</p>
<pre class="calibre19">rxHistogram(~F(MS), data=df_sql_r) </pre>
<div class="packt_figure"><img class="aligncenter52" src="../images/00082.jpeg"/></div>
<p class="calibre2">Also, variables can be combined as follows (the marital status with the number of cars owned):</p>
<pre class="calibre19">rxHistogram(~ NumberCarsOwned | F(MS), title="Cars owned per Marital Status",  numBreaks=10, data = df_sql_r) 
 </pre>
<p class="calibre2">And we get the following plot, showing marital status (<strong class="calibre1">M</strong> - married; <strong class="calibre1">S</strong> - single) and the total number of cars owned as a categorical variable (<strong class="calibre1">0</strong> - no car, <strong class="calibre1">1</strong> - 1 car owned, <strong class="calibre1">2</strong> - two cars owned, <strong class="calibre1">3</strong> - three cars owned, and <strong class="calibre1">4</strong> - four cars owned):</p>
<div class="packt_figure"><img src="../images/00083.jpeg" class="calibre53"/></div>
<p class="calibre2">Instead of a bar plot, we can also use a Line plot, but this time with different variables:</p>
<pre class="calibre19">rxLinePlot(as.numeric(log(TotalPurchaseYTD)) ~ as.factor(DateFirstPurchase), data = df_sql_r, rowSelection=  
             DateFirstPurchase &gt;= "2001-07-01 00:00:00.000"&amp;amp; DateFirstPurchase &lt;= "2001-07-17 00:00:00.000", type="p") </pre>
<p class="calibre2">For the time period of little over half a year (between January 01 and July 17<sup class="calibre38">th</sup> 2001), the plot is showing a logarithmic variable for the total amount of purchases in this time period. In this case, we need to factorize the date variable and we are also using the <kbd class="calibre11">log()</kbd> function to level the purchases. And instead of using <kbd class="calibre11">rxHistogram</kbd>, we are using <kbd class="calibre11">rxLinePlot</kbd>, another <kbd class="calibre11">RevoScaleR</kbd> function, to plot graphs for large datasets. <kbd class="calibre11">rxLinePlot</kbd> represents a line chart:</p>
<div class="packt_figure"><img src="../images/00084.jpeg" class="calibre54"/></div>
<p class="calibre2">So, in the end, we can combine all three graphs using the <kbd class="calibre11">par()</kbd> function, arranging two columns, each having one or two graphs:</p>
<pre class="calibre19"># combined 
h1 &lt;- rxHistogram(~NumberCarsOwned, data=df_sql) 
h2 &lt;- rxHistogram(~F(MS), data=df_sql_r) 
p1 &lt;- rxLinePlot(as.numeric(log(TotalPurchaseYTD)) ~ as.factor(DateFirstPurchase), data = df_sql_r, rowSelection=  
             DateFirstPurchase &gt;= "2001-07-01 00:00:00.000"&amp;amp; DateFirstPurchase &lt;= "2001-07-17 00:00:00.000", type="p") 
 
print(h1, position = c(0, 0.5, 0.5, 1), more = TRUE) 
print(h2, position = c(0.5, 0.5, 1, 1), more = TRUE) 
print(p1, position = c(0.5, 0.05, 1, 0.5)) </pre>
<p class="calibre2">Using graphs is good for storytelling, customer journey, or simply by great and fast understanding of the data, when combining the most informative variables. Another good way is to use markdown documentation and include multiple graphs in one block. An addition when using the <kbd class="calibre11">par()</kbd> function in combination with <kbd class="calibre11">rxHistogram</kbd> or <kbd class="calibre11">rxLinePlot</kbd> is that it might not always display graphs as expected. This is due to some compatibility issues with the <kbd class="calibre11">par()</kbd> function. Alternatively, using <kbd class="calibre11">print()</kbd> function and positioning each graph is another way to do it, without running into possible problems:</p>
<div class="packt_figure"><img src="../images/00085.jpeg" class="calibre55"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Functions for statistical tests and sampling</h1>
                
            
            <article>
                
<p class="calibre2">Statistical tests are important for determining the correlation between two (or more) variables and what is their direction of correlation (positive, neutral, or negative). Statistically speaking, the correlation is a measure of the strength of the association between two variables and their direction. The <kbd class="calibre11">RevoScaleR</kbd> package supports calculation of Chi-square, Fischer, and Kendall rank correlation. Based on the types of variable, you can distinguish between Kendall, Spearman, or Pearson correlation coefficient.</p>
<p class="calibre2">For Chi-Square test, we will be using the <kbd class="calibre11">rxChiSquareTest()</kbd> function that uses the contingency table to see if two variables are related. A small chi-square test statistic means that the observed data fits your expected data very well, denoting there is a correlation, respectively. The formula for calculating chi-square is as follows:</p>
<div class="packt_figure1"><img src="../images/00086.jpeg" class="calibre56"/></div>
<p class="calibre2">Prior to calculating this statistical independence test, we must have data in the <kbd class="calibre11">xCrossTab</kbd> or xCube format. Therefore, the T-SQL query will need to generate the crosstabulations first in order to calculate the chi-square coefficient.</p>
<p class="calibre2">Chi-square is generated on two categorical variables as follows:</p>
<pre class="calibre19"><strong class="calibre1">EXEC sp_execute_external_script</strong>
<strong class="calibre1">      @language = N'R'</strong>
<strong class="calibre1">      ,@script = N'</strong>
<strong class="calibre1">            library(RevoScaleR)</strong>
<strong class="calibre1">            df_sql &lt;- InputDataSet</strong>
<strong class="calibre1">            df_sql_r &lt;- rxFactors(inData = df_sql, sortLevels = TRUE,factorInfo = list(MS = list(levels = c("M","S"), otherLevel=NULL, varName="MaritalStatus")))</strong>
<strong class="calibre1">            df_sql_r$Occupation &lt;- as.factor(df_sql_r$Occupation)</strong>
<strong class="calibre1">            df_sql_r$MS &lt;- df_sql_r$MS</strong>
<strong class="calibre1">            testData &lt;- data.frame(Occupation = df_sql_r$Occupation, Status=df_sql_r$MS)</strong>
<strong class="calibre1">            d &lt;- rxCrossTabs(~Occupation:Status,  testData, returnXtabs = TRUE)</strong>
<strong class="calibre1">            chi_q &lt;- rxChiSquaredTest(d)</strong>
    
<strong class="calibre1">            #results</strong>
<strong class="calibre1">            xs &lt;- chi_q$''X-squared''</strong>
<strong class="calibre1">            p &lt;- chi_q$''p-value''</strong>
<strong class="calibre1">            OutputDataSet &lt;- data.frame(xs,p)'</strong>
<strong class="calibre1">      ,@input_data_1 = N'</strong>
<strong class="calibre1">      SELECT * FROM [Sales].[vPersonDemographics] WHERE [DateFirstPurchase] IS NOT NULL'</strong>
<strong class="calibre1">WITH RESULT SETS</strong>
<strong class="calibre1">      ((</strong>
<strong class="calibre1">             Chi_square_value NVARCHAR(100)</strong>
<strong class="calibre1">            ,Stat_significance NVARCHAR(100)</strong>
<strong class="calibre1">      ));</strong>
  </pre>
<p class="calibre2">The following results are returned:</p>
<pre class="calibre19"><strong class="calibre1">Chi-squared test of independence between Occupation and Status </strong>
<strong class="calibre1"> X-squared df p-value</strong>
<strong class="calibre1"> 588.2861  4  5.312913e-126</strong>
  </pre>
<p class="calibre2">With Kendall Tau you can calculate the correlation between the ranks and the result of the preceding correlation using R code:</p>
<pre class="calibre19"><strong class="calibre1">rxKendallCor(d, type = "b")</strong>
  </pre>
<p class="calibre2">The following are the results:</p>
<pre class="calibre19"><strong class="calibre1">  estimate 1 p-value</strong>
<strong class="calibre1"> -0.05179647       0</strong>
<strong class="calibre1">   HA: two.sided </strong>
  </pre>
<p class="calibre2">This same principle can be used in a T-SQL query:</p>
<pre class="calibre19"><strong class="calibre1">EXEC sp_execute_external_script</strong>
    <strong class="calibre1">      @language = N'R'</strong>
    <strong class="calibre1">      ,@script = N'</strong>
    <strong class="calibre1">            library(RevoScaleR)</strong>
    <strong class="calibre1">            df_sql &lt;- InputDataSet</strong>
    <strong class="calibre1">            df_sql_r &lt;- rxFactors(inData = df_sql, factorInfo = list(MS = list(levels = c("M","S"), otherLevel=NULL, varName="MaritalStatus")))</strong>
    <strong class="calibre1">            df_sql_r$Occupation &lt;- as.factor(df_sql_r$Occupation)</strong>
    <strong class="calibre1">            df_sql_r$MS &lt;- df_sql_r$MS</strong>
    <strong class="calibre1">            testData &lt;- data.frame(Occupation = df_sql_r$Occupation, Status=df_sql_r$MS)</strong>
    <strong class="calibre1">            d &lt;- rxCrossTabs(~Occupation:Status,  testData, returnXtabs = TRUE)</strong>
    <strong class="calibre1">            ken &lt;- rxKendallCor(d, type = "b")</strong>
    
    <strong class="calibre1">            k &lt;- ken$`estimate 1`</strong>
    <strong class="calibre1">            p &lt;- ken$`p-value`</strong>
    
    <strong class="calibre1">            #results</strong>
    <strong class="calibre1">            OutputDataSet &lt;- data.frame(k,p)'</strong>
    <strong class="calibre1">      ,@input_data_1 = N'</strong>
    <strong class="calibre1">      SELECT * FROM [Sales].[vPersonDemographics] WHERE [DateFirstPurchase] IS NOT NULL'</strong>
    <strong class="calibre1">WITH RESULT SETS</strong>
    <strong class="calibre1">      ((</strong>
    <strong class="calibre1">             Kendall_value NVARCHAR(100)</strong>
    <strong class="calibre1">            ,Stat_significance NVARCHAR(100)</strong>
    <strong class="calibre1">      ));</strong>
  </pre>
<p class="calibre2">Many other principles can be used to calculate correlations among variables. But this is beyond the scope of this book, and therefore we have focused only on the necessary ones.</p>
<p class="calibre2">Functions for predictive modeling will be covered in the next chapter - <a target="_blank" href="part0096.html#2RHM00-e3f81285367248f4bbc6431bcd4f926d" class="calibre10">Chapter 6</a>, <em class="calibre12">Predictive Modeling</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre2">This chapter has covered important functions (among many others) for data manipulation and data wrangling. These steps are absolutely and utterly important for understanding the structure of the dataset, the content of the dataset, and how the data is distributed. These are used to mainly understand frequencies, descriptive statistics, and also some statistical sampling, as well as statistical correlations.</p>
<p class="calibre2">These steps must be done (or should be done) prior to data cleaning and data merging in order to get a better understanding of the data. Cleaning the data is of the highest importance, as outliers might bring sensitive data (or any kind of data) to strange or false conclusions: it might also sway the results in some other direction. So, treating these steps as highly important by using the powerful <kbd class="calibre11">rx</kbd>- functions (or classes) should be the task of every data engineer, data wrangler, as well as data scientist. The next chapter will be focused on <kbd class="calibre11">RevoScaleR</kbd> functions for predictive modeling, mainly focusing on creating models and running the predictions against these models.</p>


            </article>

            
        </section>
    </body></html>