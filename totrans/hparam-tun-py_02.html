<html><head></head><body>
		<div id="_idContainer016">
			<h1 id="_idParaDest-15"><em class="italic"><a id="_idTextAnchor014"/>Chapter 1</em>: Evaluating Machine Learning Models</h1>
			<p><strong class="bold">Machine Learning</strong> (<strong class="bold">ML</strong>) models need to be thoroughly evaluated to ensure they will work in production. We have to ensure the model is not <em class="italic">memorizing</em> the training data and also ensure it learns enough from the given training data. Choosing the appropriate evaluation method is also critical when we want to perform hyperparameter tuning at a later stage.</p>
			<p>In this chapter, we'll learn about all the important things we need to know when it comes to evaluating ML models. First, we need to understand the concept of overfitting. Then, we will look at the idea of splitting data into train, validation, and test sets. Additionally, we'll learn about the difference between random and stratified splits and when to use each of them. </p>
			<p>We'll discuss the concept of cross-validation and its numerous variations of strategy: k-fold repeated k-fold, <strong class="bold">Leave One Out</strong> (<strong class="bold">LOO</strong>), <strong class="bold">Leave P Out</strong> (<strong class="bold">LPO</strong>), and a specific strategy when dealing with time-series data, called time-series cross-validation. We'll also learn how to implement each of the evaluation strategies using the Scikit-Learn package.</p>
			<p>By the end of this chapter, you will have a good understanding of why choosing a proper evaluation strategy is critical in the ML model development life cycle. Also, you will be aware of numerous evaluation strategies and will be able to choose the most appropriate one for your situation. Furthermore, you will also be able to implement each of the evaluation strategies using the Scikit-Learn package.</p>
			<p>In this chapter, we're going to cover the following main topics:</p>
			<ul>
				<li>Understanding the concept of overfitting</li>
				<li>Creating training, validation, and test sets</li>
				<li>Exploring random and stratified split</li>
				<li>Discovering k-fold cross-validation</li>
				<li>Discovering repeated k-fold cross-validation</li>
				<li>Discovering LOO cross-validation</li>
				<li>Discovering LPO cross-validation</li>
				<li>Discovering time-series cross-validation</li>
			</ul>
			<h1 id="_idParaDest-16"><a id="_idTextAnchor015"/>Technical requirements</h1>
			<p>We will learn how to implement each of the evaluation strategies using the Scikit-Learn package. To ensure that you can reproduce the code examples in this chapter, you will need the following:</p>
			<ul>
				<li>Python 3 (version 3.7 or above)</li>
				<li>The pandas package installed (version 1.3.4 or above) </li>
				<li>The Scikit-Learn package installed (version 1.0.1 or above)</li>
			</ul>
			<p>All of the code examples for this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/Hyperparameter-Tuning-with-Python/blob/main/01_Evaluating-Machine-Learning-Models.ipynb">https://github.com/PacktPublishing/Hyperparameter-Tuning-with-Python/blob/main/01_Evaluating-Machine-Learning-Models.ipynb</a>.</p>
			<h1 id="_idParaDest-17"><a id="_idTextAnchor016"/>Understanding the concept of overfitting</h1>
			<p><strong class="bold">Overfitting</strong> occurs when the trained ML model learns too much from the given training data. In this situation, the trained model successfully gets a high evaluation score on the training data but <a id="_idIndexMarker000"/>a far lower score on new, unseen data. In other words, the trained ML model fails to generalize the knowledge learned from the training data to the unseen data. </p>
			<p>So, how exactly does the trained ML model get decent performance on the training data but fail to give a reasonable performance on unseen data? Well, that happens when the model <em class="italic">tries too hard</em> to achieve high performance on the training data and has picked up knowledge that is only applicable to that specific training data. Of course, this will negatively impact the model's ability to generalize, which results in bad performance when the model is evaluated on unseen data.</p>
			<p>To detect whether our trained ML model faces an overfitting issue, we can monitor the performance of our model on the training data versus unseen data. Performance can be defined as the loss value of our model or metrics that we care about, for example, accuracy, precision, and the mean absolute error. If the performance of the training data keeps getting better, while the performance on the unseen data starts to become stagnant or even <a id="_idIndexMarker001"/>gets worse, then this is a sign of an overfitting issue (see <em class="italic">Figure 1.1</em>):</p>
			<div>
				<div id="_idContainer008" class="IMG---Figure">
					<img src="image/B18753_01_001.jpg" alt="Figure 1.1 – The model's performance on training data versus unseen data (overfitting)&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.1 – The model's performance on training data versus unseen data (overfitting)  </p>
			<p class="callout-heading">Note</p>
			<p class="callout">The preceding diagram image has been reproduced according to the license specified: <a href="https://commons.wikimedia.org/wiki/File:Overfitting_svg.svg">https://commons.wikimedia.org/wiki/File:Overfitting_svg.svg</a>.</p>
			<p>Now that you are aware of the overfitting problem, we need to learn how to prevent this from happening in our ML development life cycle. We will discuss this in the following sections.</p>
			<h1 id="_idParaDest-18"><a id="_idTextAnchor017"/>Creating training, validation, and test sets</h1>
			<p>We understand that overfitting can be detected by monitoring the model's performance on the <a id="_idIndexMarker002"/>training data versus the unseen data, but what exactly is unseen data? Is it <a id="_idIndexMarker003"/>just random data that has not yet been seen by <a id="_idIndexMarker004"/>the model during the training phase? </p>
			<p>Unseen data is a portion of our original complete data that was not seen by the model during the training phase. We usually refer to this unseen data as the <strong class="bold">test set</strong>. Let's imagine you have 100,000 samples of data, to begin with; you can take out a portion of the data, let's say 10% of it, to become the test set. So, now we have 90,000 samples as the training set and 10,000 samples as the testing set. </p>
			<p>However, it is <a id="_idIndexMarker005"/>better to not just split our original data into train and test sets but also into a <strong class="bold">validation set</strong>, <em class="italic">especially when we want to perform hyperparameter tuning</em> on our model. Let's say that out of 100,000 original samples, we held out 10% of it to become the validation set and another 10% to become the test set. Therefore, we will have 80,000 samples as the train set, 10,000 samples as the validation set, and 10,000 samples as the test set.</p>
			<p>You might be wondering why do we need a validation set apart from the test set. Actually, we do not need it if we do not want to perform hyperparameter tuning or any other <em class="italic">model-centric</em> approaches. This is because the purpose of having a validation set is to have an unbiased evaluation of the test set using the final version of the trained model.</p>
			<p>A validation set can help us to get an unbiased evaluation of the test set because we only incorporate the validation set during the hyperparameter tuning phase. Once we finish the hyperparameter tuning phase and get the final model configuration, we can then evaluate our model on the purely unseen data, which <a id="_idIndexMarker006"/>is called the test set. </p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">If you are going to perform any data preprocessing steps (for example, missing value imputation, feature engineering, standardization, label encoding, and more), you have to build the function based on the train set and then apply it to the validation and test set. Do <em class="italic">not</em> perform those data preprocessing steps on the full original data (before data splitting). That's because <a id="_idIndexMarker007"/>it might lead to a <strong class="bold">data leakage</strong> problem.</p>
			<p>There is no specific rule when it comes to choosing the proportions for each of the train, validation, and test sets. You have to choose the split proportion by yourself based on the condition you are faced with. However, the common splitting proportion used by the data science community is 8:2 or 9:1 for the train set and the validation and test set, respectively. Usually, the validation and test set will have a proportion of 1:1. Therefore, the common splitting proportion is 8:1:1 or 9:0.5:0.5 for the train, validation, and test sets, respectively.</p>
			<p>Now that <a id="_idIndexMarker008"/>we are aware of the train, validation, and test set concept, we need <a id="_idIndexMarker009"/>to learn how to build those sets. Do we just randomly <a id="_idIndexMarker010"/>split our original data into three sets? Or can we also apply some predefined rules? In the next section, we will explore this topic in more detail. </p>
			<h1 id="_idParaDest-19"><a id="_idTextAnchor018"/>Exploring random and stratified splits</h1>
			<p>The most straightforward way (but <em class="italic">not entirely a correct way</em>) to split our original full data into train, validation, and test sets is by choosing the proportions for each set and then directly <a id="_idIndexMarker011"/>splitting them into three sets based on the order of the index. </p>
			<p>For instance, the <a id="_idIndexMarker012"/>original full data has 100,000 samples, and we want to split this into train, validation, and test sets with a proportion of 8:1:1. Then, the training set will be the samples from index 1 until 80,000. The validation and test set will be the index from 81,000 until 90,000 and 91,000 until 100,000, respectively. </p>
			<p>So, what's wrong with that approach? There is nothing wrong with that approach <em class="italic">as long as the original full data is shuffled</em>. It might cause a problem when there is some kind of pattern between the indices of the samples. </p>
			<p>For instance, we have data consisting of 10,000 samples and 3 columns. The first and second columns contain weight and height information, respectively. The third column contains the "weight status" class (for example, underweight, normal weight, overweight, and obesity). Our task is to build an ML classifier model to predict what the "weight status" class of a person is, given their weight and height. It is not impossible for the data to be given to us in the condition that it was ordered based on the third column. So, the first 80,000 rows only consist of the underweight and normal weight classes. In comparison, the overweight and obesity classes are only located in the last 20,000 rows. If this is the case, and we apply the data splitting logic from earlier, then there is no way our classifier can predict a new person has the overweight or obesity "weight status" classes. Why? Because our classifier has never seen those classes before during the training phase! </p>
			<p>Therefore, it is very important to ensure the original full data is shuffled in the first place, and essentially, this is what <a id="_idIndexMarker013"/>we mean by the random split. <strong class="bold">Random split</strong> works by first shuffling the original full data and then splitting it into the train, validation, and test sets based on the order of the index.</p>
			<p>There is also another splitting <a id="_idIndexMarker014"/>logic called the <strong class="bold">stratified split</strong>. This logic ensures that the train, validation, and test set will get <em class="italic">a similar proportion number of samples for each target class</em> found in the original full data. </p>
			<p>Using the same "weight status" class prediction case example, let's say that we found that the proportion of each class in the full original data is 3:5:1.5:0.5 for underweight, normal weight, overweight, and obese, respectively. The stratified split logic will ensure that we can find a similar proportion of those classes in the train, validation, and test sets. So, out of 80,000 samples of the train set, around 24,000 samples are in the underweight class, around 40,000 samples are in the normal weight class, around 12,000 samples are overweight, and around 4,000 samples are in the obesity class. This will also be applied to the validation and test set.</p>
			<p>The remaining question is understanding <em class="italic">when it is the right time</em> to use the random split/stratified split logic. Often, the stratified split logic is used when we are faced with an imbalanced class problem. However, it is also often used when we want to make sure that we have <a id="_idIndexMarker015"/>a similar proportion of samples based on a specific variable (not necessarily the target class). If you are not faced with this kind of situation, then <a id="_idIndexMarker016"/>the random split is the go-to logic that you can always choose.</p>
			<p>To implement both of the data splitting logics, you can write the code by yourself from scratch or utilize the well-known <a id="_idIndexMarker017"/>package called <strong class="bold">Scikit-Learn</strong>. The following is an example to perform a random split with a proportion of 8:1:1: </p>
			<pre class="source-code">from sklearn.model_selection import train_test_split</pre>
			<pre class="source-code">df_train, df_unseen = train_test_split(df, <strong class="bold">test_size=0.2</strong>, random_state=0)</pre>
			<pre class="source-code">df_val, df_test = train_test_split(df_unseen, <strong class="bold">test_size=0.5</strong>, random_state=0)</pre>
			<p>The <strong class="source-inline">df</strong> variable is our complete original data that was stored in the Pandas DataFrame object. The <strong class="source-inline">train_test_split</strong> function splits the Pandas DataFrame, array, or matrix into shuffled train and test sets. In lines 2–3, first, we split the original full data into <strong class="source-inline">df_train</strong> and <strong class="source-inline">df_unseen</strong> with a proportion of 8:2, as specified by the <strong class="source-inline">test_size</strong> argument. Then, we split <strong class="source-inline">df_unseen</strong> into <strong class="source-inline">df_val</strong> and <strong class="source-inline">df_test</strong> with a proportion of 1:1.</p>
			<p>To perform the <em class="italic">stratify split</em> logic, you can just add the <strong class="source-inline">stratify</strong> argument to the <strong class="source-inline">train_test_split</strong> function and fill it with the target array:</p>
			<pre class="source-code">df_train, df_unseen = train_test_split(df, test_size=0.2, random_state=0, <strong class="bold">stratify=df['class']</strong>)</pre>
			<pre class="source-code">df_val, df_test = train_test_split(df_unseen, test_size=0.5, random_state=0, <strong class="bold">stratify=df_unseen['class']</strong>)</pre>
			<p>The <strong class="source-inline">stratify</strong> argument will ensure the data is split in the stratified fashion based on the given target array.</p>
			<p>In this section, we have <a id="_idIndexMarker018"/>learned the importance of shuffling the <a id="_idIndexMarker019"/>original full data before performing data splitting and also understand the difference between the random and stratified split, as well as when to use each of them. In the next section, we will start learning variations of the data splitting strategies and how to implement each of them using the Scikit-learn package.</p>
			<p>Discovering k-fold cross-validation</p>
			<p><strong class="bold">Cross-validation</strong> is a way to <a id="_idIndexMarker020"/>evaluate our ML model by performing <em class="italic">multiple evaluations</em> on our original full data via a resampling procedure. This is a variation from the vanilla train-validation-test split that we learned about in previous sections. Additionally, the concept of <a id="_idIndexMarker021"/>random and stratified splits can be applied in cross-validation.  </p>
			<p>In cross-validation, we perform multiple splits for the <em class="italic">train and validation</em> sets, where each split is <a id="_idIndexMarker022"/>usually referred to <strong class="bold">Fold</strong>. What about the test set? Well, it still acts as the purely unseen data where we can test the final model configuration on it. Therefore, in the beginning, it is only separated once from the train and validation set.</p>
			<p>There are <a id="_idIndexMarker023"/>several variations of the cross-validation strategy. The first one is called <strong class="bold">k-fold cross-validation</strong>. It works by performing k times of training and evaluation with a proportion of (k-1):1 for the train and validation set, respectively, in each fold. To have a clearer understanding of k-fold cross-validation, please refer to <em class="italic">Figure 1.2</em>:</p>
			<div>
				<div id="_idContainer009" class="IMG---Figure">
					<img src="image/B18753_01_002.jpg" alt="Figure 1.2 – K-fold cross-validation&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">   </p>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.2 – K-fold cross-validation</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The preceding <a id="_idIndexMarker024"/>diagram has been reproduced according to the license specified: <a href="https://commons.wikimedia.org/wiki/File:K-fold_cross_validation.jpg">https://commons.wikimedia.org/wiki/File:K-fold_cross_validation.jpg</a>.</p>
			<p>For instance, let's choose k = 4 to match the illustration in <em class="italic">Figure 1.2</em>. The green and red balls correspond to the target class, where, in this case, we only have two target classes. The <a id="_idIndexMarker025"/>data is shuffled beforehand, which can be seen from the absence of a pattern of green and red balls. It is also worth mentioning that the <em class="italic">shuffling was previously only done once</em>. That's why the order of green and red balls is always the same for each iteration (fold). The black box in each fold corresponds to the validation set (the test data is in the illustration).</p>
			<p>As you can see in <em class="italic">Figure 1.2</em>, the proportion of the training set versus the validation set is (k-1):1, or in this case, 3:1. During each fold, the model will be trained on the train set and evaluated on the validation set. Notice that the training and validation sets are <em class="italic">different across each fold</em>. The final evaluation score can be calculated by taking the average score of all of the folds.</p>
			<p>In summary, k-fold cross-validation works as follows:</p>
			<ol>
				<li>Shuffling the original full data</li>
				<li>Holding out the test data</li>
				<li>Performing the k-fold multiple evaluation strategy on the rest of the original full data</li>
				<li>Calculating the final evaluation score by taking the average score of all of the folds</li>
				<li>Evaluating the test data using the final model configuration</li>
			</ol>
			<p>You might ask <a id="_idIndexMarker026"/>why do we need to perform cross-validation in the first place? Why is the vanilla train-validation-test splitting strategy not enough? There are several reasons why we need to apply the cross-validation strategy:</p>
			<ul>
				<li>Having only a small amount of training data.</li>
				<li>To get a more confident conclusion from the evaluation performance.</li>
				<li>To get a clearer picture of our model's learning ability and/or the complexity of the given data.</li>
			</ul>
			<p>The first and second reasons are quite straightforward. The third reason is more interesting and should be discussed. How can cross-validation help us to get a better idea about our model's learning ability and/or the data complexity? Well, this happens when the variation of evaluation scores from each fold is quite big. For instance, out of 4 folds, we get accuracy scores of 45%, 82%, 64%, and 98%. This scenario should trigger our curiosity: what is wrong with our model and/or data? It could be that the data is too hard to learn and/or our model can't learn properly.</p>
			<p>The following is the syntax to perform k-fold cross-validation via the Scikit-Learn package: </p>
			<pre class="source-code">From sklearn.model_selection import train_test_split, <strong class="bold">Kfold</strong></pre>
			<pre class="source-code">df_cv, df_test = train_test_split(df, test_size=0.2, random_state=0)</pre>
			<pre class="source-code">kf = Kfold(n_splits=4)</pre>
			<pre class="source-code">for train_index, val_index in kf.split(df_cv):</pre>
			<pre class="source-code">df_train, df_val = df_cv.iloc[train_index], df_cv.iloc[val_index]</pre>
			<pre class="source-code">#perform training or hyperparameter tuning here</pre>
			<p>Notice that, first, we hold out the test set and only work with <strong class="source-inline">df_cv</strong> when performing the k-fold cross-validation. By default, the <strong class="source-inline">Kfold</strong> function will disable the shuffling procedure. However, this is not a problem for us since the data has already shuffled beforehand when we called the <strong class="source-inline">train_test_split</strong> function. If you want to run the shuffling procedure again, you can pass <strong class="source-inline">shuffle=True</strong> in the <strong class="source-inline">Kfold</strong> function.</p>
			<p>Here is another <a id="_idIndexMarker027"/>example if you are interested in learning how to apply the concept of stratifying splits in k-fold cross-validation:</p>
			<pre class="source-code">From sklearn.model_selection import train_test_split, <strong class="bold">StratifiedKFold</strong></pre>
			<pre class="source-code">df_cv, df_test = train_test_split(df, test_size=0.2, random_state=0, <strong class="bold">stratify=df['class']</strong>)</pre>
			<pre class="source-code">skf = StratifiedKFold(n_splits=4)</pre>
			<pre class="source-code">for train_index, val_index in skf.split(df_cv, <strong class="bold">df_cv['class']</strong>):</pre>
			<pre class="source-code">df_train, df_val = df_cv.iloc[train_index], df_cv.iloc[val_index]</pre>
			<pre class="source-code">#perform training or hyperparameter tuning here</pre>
			<p>The only difference is to import <strong class="source-inline">StratifiedKFold</strong> instead of the <strong class="source-inline">Kfold</strong> function and add the array of target variables, which will be used to split the data in a stratified fashion.</p>
			<p>In this section, you have learned what cross-validation is, when the right time is to perform cross-validation, and the first (and the <em class="italic">most widely used</em>) cross-validation strategy variation, which is called k-fold cross-validation. In the subsequent sections, we will also learn other variations of cross-validation and how to implement them using the Scikit-Learn package.</p>
			<h1 id="_idParaDest-20"><a id="_idTextAnchor019"/>Discovering repeated k-fold cross-validation</h1>
			<p><strong class="bold">Repeated k-fold cross-validation</strong> involves <a id="_idIndexMarker028"/>simply <a id="_idIndexMarker029"/>performing the k-fold cross-validation repeatedly, <em class="italic">N</em> times, with different randomizations in each repetition. The final evaluation score is the average of all scores from all folds of each repetition. This strategy will increase our confidence in  our model. </p>
			<p>So, why repeat the k-fold cross-validation? Why don't we just increase the value of k in k-fold? Surely, increasing the value of k will reduce the bias of our model's estimated performance. However, increasing the value of k will increase the variation, especially when we have a small number of samples. Therefore, usually, repeating the k-folds is a better way to gain higher confidence in our model's estimated performance. Of course, this comes with a drawback, which is the increase in computation time.</p>
			<p>To implement <a id="_idIndexMarker030"/>this strategy, we can simply perform a manual for-loop, where we apply the k-fold cross-validation strategy to each loop. Fortunately, the Scikit-Learn package provide us with a specific function in which to implement this strategy:</p>
			<pre class="source-code">from sklearn.model_selection import train_test_split, <strong class="bold">RepeatedKFold</strong></pre>
			<pre class="source-code">df_cv, df_test = train_test_split(df, test_size=0.2, random_state=0)</pre>
			<pre class="source-code">rkf = RepeatedKFold(n_splits=4, <strong class="bold">n_repeats=3</strong>, random_state=0)</pre>
			<pre class="source-code">for train_index, val_index in rkf.split(df_cv):</pre>
			<pre class="source-code">df_train, df_val = df_cv.iloc[train_index], df_cv.iloc[val_index]</pre>
			<pre class="source-code">#perform training or hyperparameter tuning here</pre>
			<p>Choosing <strong class="source-inline">n_splits=4</strong> and <strong class="source-inline">n_repeats=3</strong> means that we will have 12 different train and validation sets. The final evaluation score is then just the average of all 12 scores. As you might expect, there is also a dedicated function to implement the repeated k-fold in a stratified fashion:</p>
			<pre class="source-code">from sklearn.model_selection import train_test_split, <strong class="bold">RepeatedStratifiedKFold</strong></pre>
			<pre class="source-code">df_cv, df_test = train_test_split(df, test_size=0.2, random_state=0, <strong class="bold">stratify=df['class']</strong>)</pre>
			<pre class="source-code">rskf = RepeatedStratifiedKFold(n_splits=4, n_repeats=3, random_state=0)</pre>
			<pre class="source-code">for train_index, val_index in rskf.split(df_cv, <strong class="bold">df_cv['class']</strong>):</pre>
			<pre class="source-code">df_train, df_val = df_cv.iloc[train_index], df_cv.iloc[val_index]</pre>
			<pre class="source-code">#perform training or hyperparameter tuning here</pre>
			<p>The <strong class="source-inline">RepeatedStratifiedKFold</strong> function will perform stratified k-fold cross-validation repeatedly, <strong class="source-inline">n_repeats</strong> times.</p>
			<p>Now that <a id="_idIndexMarker031"/>you have learned another variation of the cross-validation strategy, called repeated k-fold cross-validation, let's learn about the other variations next.</p>
			<h1 id="_idParaDest-21"><a id="_idTextAnchor020"/>Discovering Leave-One-Out cross-validation</h1>
			<p>Essentially, <strong class="bold">Leave One Out (LOO) cross-validation</strong> is just k-fold cross-validation where k = n, where n is <a id="_idIndexMarker032"/>the number of samples. This <a id="_idIndexMarker033"/>means there are n-1 samples for the training set and 1 sample for the validation set in each fold (see <em class="italic">Figure 1.3</em>). Undoubtedly, this is a very <em class="italic">computationally expensive</em> strategy and will result in a <em class="italic">very high variance</em> evaluation score estimator: </p>
			<div>
				<div id="_idContainer010" class="IMG---Figure">
					<img src="image/B18753_01_003.jpg" alt="Figure 1.3 – LOO cross-validation&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.3 – LOO cross-validation</p>
			<p>So, when <a id="_idIndexMarker034"/>is LOO preferred over k-fold cross-validation? Well, LOO works best when you have a very small dataset. It is also good to choose LOO over k-fold if you prefer the high confidence of the model's performance estimation over the computational cost limitation.</p>
			<p>Implementing this strategy from scratch is actually very simple. We just need to loop through each of the indexes of data and do some data manipulation. However, the Scikit-Learn package also provides the implementation for LOO, which we can use:</p>
			<pre class="source-code">from sklearn.model_selection import train_test_split, <strong class="bold">LeaveOneOut</strong></pre>
			<pre class="source-code">df_cv, df_test = train_test_split(df, test_size=0.2, random_state=0)</pre>
			<pre class="source-code">loo = LeaveOneOut()</pre>
			<pre class="source-code">for train_index, val_index in loo.split(df_cv):</pre>
			<pre class="source-code">df_train, df_val = df_cv.iloc[train_index], df_cv.iloc[val_index]</pre>
			<pre class="source-code">#perform training or hyperparameter tuning here</pre>
			<p>Notice that <a id="_idIndexMarker035"/>there is no argument provided in the <strong class="source-inline">LeaveOneOut</strong> function since this strategy is very straightforward and involves no stochastic procedure. There is also no stratified version of the LOO since the validation set will always contain one sample.</p>
			<p>Now that you are aware of the concept of LOO, in the next section, we will learn about a slight variation of LOO.</p>
			<h1 id="_idParaDest-22"><a id="_idTextAnchor021"/>Discovering LPO cross-validation</h1>
			<p><strong class="bold">LPO cross-validation</strong> is a <a id="_idIndexMarker036"/>variation of the LOO cross-validation strategy, where the validation set in each fold contains <em class="italic">p</em> samples instead of only 1 sample. Similar to LOO, this strategy will ensure that we get all possible combinations <a id="_idIndexMarker037"/>of train-validation pairs. To be more precise, there will be <img src="image/Formula_B18753_01_001.png" alt=""/> number of folds assuming there are <em class="italic">n</em> samples on our data. For example, there will be <img src="image/Formula_B18753_01_002.png" alt=""/> or 142,506 folds if we want to perform Leave-5-Out cross-validation on data that has 50 samples.</p>
			<p>LPO is suitable when you have a small number of samples and want to get even higher confidence in the model's estimated performance compared to the LOO method. LPO will result in an exploding number of folds when you have a large number of samples.</p>
			<p>This strategy is a bit different from k-fold or LOO in terms of the overlapping between the validation sets. For P &gt; 1, LPO will result in overlapping validation sets, while k-fold and LOO will always result in non-overlapping validation sets. Also, note that LPO is different from k-fold with K = N // P since k-fold will always create non-overlapping validation sets, but not with the LPO strategy:</p>
			<pre class="source-code">from sklearn.model_selection import train_test_split, <strong class="bold">LeavePOut</strong></pre>
			<pre class="source-code">df_cv, df_test = train_test_split(df, test_size=0.2, random_state=0)</pre>
			<pre class="source-code">lpo = LeavePOut(<strong class="bold">p=2</strong>)</pre>
			<pre class="source-code">for train_index, val_index in lpo.split(df_cv):</pre>
			<pre class="source-code">df_train, df_val = df_cv.iloc[train_index], df_cv.iloc[val_index]</pre>
			<pre class="source-code">#perform training or hyperparameter tuning here</pre>
			<p>Unlike LOO, we <a id="_idIndexMarker038"/>have to provide the <strong class="source-inline">p</strong> argument to LPO, which refers to the p values in LPO. </p>
			<p>In this section, we have learned about the variations of the LOO cross-validation strategy. In the next section, we will learn how to perform cross-validation on time-series data.</p>
			<h1 id="_idParaDest-23"><a id="_idTextAnchor022"/>Discovering time-series cross-validation</h1>
			<p><strong class="bold">Time-series</strong> data has <a id="_idIndexMarker039"/>a unique characteristic in nature. Unlike "normal" data, which <a id="_idIndexMarker040"/>is assumed to be <strong class="bold">independent and identically distributed</strong> (<strong class="bold">IID</strong>), time-series data does not follow that assumption. In fact, each sample is dependent on previous samples, meaning changing the <a id="_idIndexMarker041"/>order of the samples will result in different data interpretations.</p>
			<p>Several examples <a id="_idIndexMarker042"/>of time-series data are listed as follows:</p>
			<ul>
				<li>Daily stock market price</li>
				<li>Hourly temperature data</li>
				<li>Minute-by-minute web page clicks count</li>
			</ul>
			<p>There will be a <strong class="bold">look-ahead bias</strong> if we <a id="_idIndexMarker043"/>apply previous cross-validation strategies (for example, k-fold or random or stratified splits) to time-series data. Look-ahead bias happens when we use the future value of the data that is supposedly not available for the current time of the simulation.  </p>
			<p>For instance, we are working with hourly temperature data. We want to predict what the temperature will be in 2 hours, but we use the temperature value of the next hour or the next 3 hours, which is supposedly not available yet. This kind of bias will happen easily if we apply the previous cross-validation strategies since those strategies are designed to work well only on IID distribution.</p>
			<p><strong class="bold">Time-series cross-validation</strong> is the cross-validation strategy that is specifically designed <a id="_idIndexMarker044"/>to handle time-series data. It works similarly to k-fold in terms of accepting the predefined values of folds, which then generates k test sets. The difference is that the <em class="italic">data</em> <em class="italic">is not shuffled in the first place</em>, and the training set in the next iteration is the <em class="italic">superset</em> of the one in the previous iteration, meaning the training set keeps getting bigger over the number of iterations. Once <a id="_idIndexMarker045"/>we finish with the cross-validation and get the final model configuration, we can then test our final model on the test data (see <em class="italic">Figure 1.4</em>):</p>
			<div>
				<div id="_idContainer013" class="IMG---Figure">
					<img src="image/B18753_01_004.jpg" alt="Figure 1.4 – Time-series cross-validation&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.4 – Time-series cross-validation</p>
			<p>Also, the Scikit-Learn package provides us with a nice implementation of this strategy:</p>
			<pre class="source-code">from sklearn.model_selection import train_test_split, <strong class="bold">TimeSeriesSplit</strong></pre>
			<pre class="source-code">df_cv, df_test = train_test_split(df, test_size=0.2, random_state=0, <strong class="bold">shuffle=False</strong>)</pre>
			<pre class="source-code">tscv = TimeSeriesSplit(<strong class="bold">n_splits=5</strong>)</pre>
			<pre class="source-code">for train_index, val_index in tscv.split(df_cv):</pre>
			<pre class="source-code">df_train, df_val = df_cv.iloc[train_index], df_cv.iloc[val_index]</pre>
			<pre class="source-code">#perform training or hyperparameter tuning here</pre>
			<p>Providing n_splits=5 will ensure that there are five test sets generated. It is worth noting that, by default, the train set will have the size of <img src="image/Formula_B18753_01_003.png" alt=""/> for the ith fold, while the test set will have the size of <img src="image/Formula_B18753_01_004.png" alt=""/>.</p>
			<p>However, you <a id="_idIndexMarker046"/>can change the train and test set size via the <strong class="source-inline">max_train_size</strong> and <strong class="source-inline">test_size</strong> arguments of the <strong class="source-inline">TimeSeriesSplit</strong> function. Additionally, there is also a <strong class="source-inline">gap</strong> argument that can be utilized to exclude G samples from the end of each train set, where G is the value needed to be specified by the developer.</p>
			<p>You need to be aware that the Scikit-Learn implementation will always make sure that <em class="italic">there is no overlap between test sets</em>, which is actually not necessary. Currently, there is no way to enable the overlap between the test sets using the Scikit-Learn implementation. You need to <em class="italic">write the code from scratch</em> to perform that kind of strategy. </p>
			<p>In this section, we learned about the unique characteristic of time-series data and how to perform a cross-validation strategy on it. There are other variations of the cross-validation strategy that haven't been covered in this book. If you are interested, you might find some pointers in the <em class="italic">Further reading</em> section.</p>
			<h1 id="_idParaDest-24"><a id="_idTextAnchor023"/>Summary</h1>
			<p>In this chapter, we learned a lot of important things that we need to know regarding how to evaluate ML models properly. Starting from the concept of overfitting, numerous data splitting strategies, how to choose the best data splitting strategy based on the given situation, and how to implement each of them using the Scikit-Learn package. Understanding these concepts is important since you can't perform a good hyperparameter tuning process without applying the appropriate data splitting strategy. </p>
			<p>In the next chapter, we will discuss hyperparameter tuning. We will not only discuss the definition but also several misconceptions and types of hyperparameter distributions.</p>
			<h1 id="_idParaDest-25"><a id="_idTextAnchor024"/>Further reading</h1>
			<p>In this chapter, we have covered a lot of topics. However, there are still many uncovered interesting algorithms related to cross-validation due to the scope of this book. If you want to learn more about those algorithms and the implementation details of each of them, you can refer to this awesome page created by the Scikit-Learn authors at <a href="https://scikit-learn.org/stable/modules/cross_validation.html">https://scikit-learn.org/stable/modules/cross_validation.html</a>. </p>
		</div>
	</body></html>