<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Setting Up the ML.NET Environment</h1>
                </header>
            
            <article>
                
<p>Now that you have a firm grasp of the basics of machine learning, an understanding of what Microsoft's ML.NET is, and what it provides, it is time to train and create your first machine learning model! We will be building a simple restaurant sentiment analysis model based on reviews and integrating this model into a simple .NET Core application. Before we can jump into training and creating our model, we will first have to configure the development environment.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Setting up your development environment</li>
<li>Creating your first model, from start to finish, with ML.NET</li>
<li>Evaluating the model</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting up your development environment</h1>
                </header>
            
            <article>
                
<p>Fortunately, configuring your environment for ML.NET is relatively easy. In this section, we will be installing Visual Studio 2019 and .NET Core 3. If you are unsure whether you have either installed, please observe the following steps. In addition, there are some organizational elements and processes to establish early on as we proceed through this book and you begin experimenting on your own.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Installing Visual Studio</h1>
                </header>
            
            <article>
                
<p>At the heart of ML.NET development is Microsoft Visual Studio. For all samples and screenshots used throughout this book, Microsoft Visual Studio 2019 Professional on Windows 10 19H2 will be used. At the time of writing, 16.3.0 is the latest version. Please use the latest version available. If you do not have Visual Studio 2019, a fully featured Community version is available for free on <a href="http://www.visualstudio.com">www.visualstudio.com</a>.</p>
<p>For the scope of this book as mentioned in <a href="b8d873e1-9234-4f11-ad94-76df5ffbb228.xhtml">Chapter 1</a>, <em>Getting Started with Machine Learning and ML.NET</em>,<em> </em>we will be creating a wide range of application types to demonstrate ML.NET in various problem areas on specific application platforms. Hence, we are going to install several of the available workloads upfront to avoid having to return to the installer in later chapters:</p>
<ol>
<li>Firstly, ensure that<span> </span><strong>.NET desktop development</strong><span>, </span><strong>Universal Windows Platform Development</strong><span>, and </span><strong>ASP.NET and web development</strong><span> </span>are checked. These workloads will enable you to create UWP, WPF, and ASP.NET applications that we will be using in later chapters:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-574 image-border" src="assets/f155b5c9-7175-43c2-b406-ff163fdf625b.png" style="width:65.92em;height:36.75em;"/></p>
<ol start="2">
<li><span> In addition, ensure that </span><strong>.NET Core cross-platform development</strong><span> is also checked. This will enable .NET Core development for both command-line and desktop apps, such as the app we will be making later in this chapter:</span></li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-575 image-border" src="assets/b00ccd5b-b95d-450e-be33-a9e28239b89c.png" style="width:69.67em;height:39.33em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Installing .NET Core 3</h1>
                </header>
            
            <article>
                
<p>As mentioned in <a href="b8d873e1-9234-4f11-ad94-76df5ffbb228.xhtml">Chapter 1</a>, <em>Getting Started with Machine Learning and ML.NET</em>, .NET Core 3 is the preferred .NET framework at the time of writing when targeting multiple platforms, due to the optimization work achieved during the development of .NET Core 3. At the time of writing .NET Core 3 is not bundled with the Visual Studio Installer prior to version 16.3.0 and needs to be downloaded separately here: <a href="https://dotnet.microsoft.com/download/dotnet-core/3.0">https://dotnet.microsoft.com/download/dotnet-core/3.0</a>. The download specifically used through the scope of this book is version 3.0.100, but a newer version may be available by the time you are reading this. For those readers who are curious, the runtime is bundled with the SDK.</p>
<p>You can verify that the installation was successful by opening a PowerShell or Command Prompt and executing the following command:</p>
<pre><strong>dotnet --version</strong><br/>3.0.100</pre>
<p>The output should begin with <em>3</em>, as shown here. At the time of writing, 3.0.100 is the latest production version available.</p>
<div class="packt_infobox">Be sure to install both 32-bit and 64-bit versions to avoid issues when targeting 32-bit and 64-bit platforms later on in this book and your future experiments.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a process</h1>
                </header>
            
            <article>
                
<p>Over the course of this book and your own explorations, you will gather sample data, build models, and try various applications. Establishing a process early on to keep these elements organized will make things easier in the long run. Here are a few suggestions to keep in mind:</p>
<ul>
<li>Always use source control for all of your code.</li>
<li>Ensure that test and training sets are named properly in their own folders (versioned if possible).</li>
<li>Versioning models with both naming and source control.</li>
<li>Retain evaluation metrics in a spreadsheet along with the parameters used.</li>
</ul>
<p>As you develop your skillset and create more complex problems, additional tooling such as Apache Spark or other clustering platforms will more than likely be required. We will discuss this in <a href="116bbc2d-9659-4d34-9b2b-26593e29f54a.xhtml">Chapter 11</a>,<strong> </strong><em>Training and Building Production Models</em>, along with other suggestions on training at scale.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating your first ML.NET application</h1>
                </header>
            
            <article>
                
<p>The time has come to start creating your first ML.NET application. For this first application, we will create a .NET Core console application. <span>T</span>his application will classify a sentence of words as either a positive statement or a negative statement, training on a small sample dataset <span>provided</span>. For<span> this project, we will use a binary logistic regression classification model using the <strong>Stochastic Dual Coordinate Ascent</strong> (<strong>SDCA</strong>) method. In </span><a href="8bcfc000-9adc-4eda-a91a-e09f676eac85.xhtml">Chapter 3</a>,<span> <em>Regression Model</em>, we will go into greater depth on this method.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating the project in Visual Studio</h1>
                </header>
            
            <article>
                
<p>Upon opening, and depending on your configuration in Visual Studio, it will either open directly on to the project creation screen, or will be an empty Visual Studio window. If your environment displays the latter, simply click <strong>File</strong>, then <strong>New</strong>, and then <strong>Project</strong>:</p>
<ol>
<li><span>When the window opens, type </span><kbd>console app</kbd><span> in the search field to find </span><strong>Console App (.NET Core)</strong><span>. Make sure that the language type is C# (there are Visual Basic templates of the same name), highlight this template, and then click <strong>Next</strong>:</span></li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-576 image-border" src="assets/597d9e75-4c16-48cc-bec9-9f2a1b4a6f05.png" style="width:53.75em;height:38.58em;"/></p>
<ol start="2">
<li><span>I suggest giving the project name something you can refer back to, such as <kbd>Chapter02</kbd>, to help you find the project later:</span></li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-577 image-border" src="assets/4a2a7bc0-6834-49ad-86d8-a1b239db193c.png" style="width:47.50em;height:36.25em;"/></p>
<ol start="3">
<li><span>At this point, you have a .NET Core 3 console application, so now let's add the <kbd>ML.NET</kbd> NuGet package. Right-click on the project and click </span><strong>Manage NuGet Packages</strong>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-578 image-border" src="assets/23558c59-1a57-46d2-895f-d68fcb12d343.png" style="width:25.83em;height:28.83em;"/></p>
<ol start="4">
<li>Type <kbd>microsoft ml</kbd> into the search field. You should see the latest <kbd>Microsoft.ML</kbd> version available:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img style="font-size: 1em;width:68.42em;height:12.42em;" class="alignnone size-full wp-image-579 image-border" src="assets/25864161-c542-4cab-a55d-b4085469a101.png"/></p>
<ol start="5">
<li>Once found, click the <strong>Install</strong> button. Simple!</li>
</ol>
<div class="packt_infobox">At the time of writing, 1.3.1 is the latest version available and all examples throughout this book will use that version. Prior to 1.0, the syntax was very much in flux, but since then has been consistent, so using a newer version should function identically.</div>
<p>At this point, the project is configured for ML.NET—all future projects will reference ML.NET in this fashion and refer you back to these steps.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Project architecture</h1>
                </header>
            
            <article>
                
<p>The simple project will be split into two primary functions:</p>
<ul>
<li>Training and evaluation</li>
<li>Model runs</li>
</ul>
<p><span>This split between functionality models real-world production applications that utilize machine learning, as there are often teams dedicated to each.</span></p>
<p>For those who wish to start with a completed project and follow along with the rest of this section, you can get the code from here: <a href="https://github.com/PacktPublishing/Hands-On-Machine-Learning-With-ML.NET/tree/master/chapter02">https://github.com/PacktPublishing/Hands-On-Machine-Learning-With-ML.NET/tree/master/chapter02</a></p>
<p><span>The following screenshot shows the project breakdown in Solution Explorer of Visual Studio. As mentioned earlier, the project is split into two main classes—<kbd>Predictor</kbd> and <kbd>Trainer</kbd>:</span></p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-580 image-border" src="assets/b4131596-ad64-4b3c-b897-e5b8a14cb398.png" style="width:17.58em;height:26.83em;"/></p>
<p>The <kbd>Trainer</kbd> class contains all the model building and evaluation code, while the <kbd>Predictor</kbd> class, as the name implies, contains the code to run predictions with a trained model.</p>
<p>The <kbd>BaseML</kbd> class is what we will be using in subsequent chapters and expanding upon throughout the remainder of the book. The idea behind this class is to cut down on the <strong>DRY</strong> (<strong>don't</strong> <strong>repeat</strong> <strong>yourself</strong>) violations and to create a cohesive and easy to iterate framework. The <kbd>Constants</kbd> class further assists this idea—to cut down on magic strings as we move into more complex applications; this design will be used in all future chapter projects.</p>
<p>Lastly, the <kbd>Program</kbd> class is the main entry point for our console application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Running the code</h1>
                </header>
            
            <article>
                
<p>We will now deep dive into the various classes used within this project, including the following classes:</p>
<ul>
<li><kbd>RestaurantFeedback</kbd></li>
<li><kbd>RestaurantPrediction</kbd></li>
<li><kbd>Trainer</kbd></li>
<li><kbd>Predictor</kbd></li>
<li><kbd>BaseML</kbd></li>
<li><kbd>Program</kbd></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The RestaurantFeedback class</h1>
                </header>
            
            <article>
                
<p>The <kbd>RestaurantFeedback</kbd> class provides the input class for our model. In ML.NET (and other frameworks), the traditional approach is to have a structured input to feed into your data pipeline, which, in turn, is passed into the training phase and eventually your trained model.</p>
<p>The following class defines our container class to hold our prediction values. This is the approach that we will use throughout the rest of the book:</p>
<pre>using Microsoft.ML.Data;<br/><br/>namespace chapter02.ML.Objects<br/>{<br/>     public class RestaurantFeedback<br/>     {<br/>          [LoadColumn(0)]<br/>          public bool Label { get; set; }<br/><br/>          [LoadColumn(1)]<br/>          public string Text { get; set; }<br/>     }<br/>}</pre>
<p>You might be wondering what the correlation between the <kbd>Label</kbd> and <kbd>Text</kbd> properties in the <kbd>RestarauntFeedback</kbd> class and the source data is at first glance. Contained within the <kbd>Data</kbd> folder, there is a file named <kbd>sampledata.csv</kbd>. This file contains the following:</p>
<pre>0    "Great Pizza"<br/>0    "Awesome customer service"<br/>1    "Dirty floors"<br/>1    "Very expensive"<br/>0    "Toppings are good"<br/>1    "Parking is terrible"<br/>0    "Bathrooms are clean"<br/>1    "Management is unhelpful"<br/>0    "Lighting and atmosphere are romantic"<br/>1    "Crust was burnt"<br/>0    "Pineapple was fresh"<br/>1    "Lack of garlic cloves is upsetting"<br/>0    "Good experience, would come back"<br/>0    "Friendly staff"<br/>1    "Rude customer service"<br/>1    "Waiters never came back"<br/>1    "Could not believe the napkins were $10!"<br/>0    "Supersized Pizza is a great deal"<br/>0    "$5 all you can eat deal is good"<br/>1    "Overpriced and was shocked that utensils were an upcharge"</pre>
<p>The first column maps to the <kbd>Label</kbd> property. As you might recall in <a href="b8d873e1-9234-4f11-ad94-76df5ffbb228.xhtml">Chapter 1</a>, <em>Getting Started with Machine Learning and ML.NET</em>, supervised learning such as that being performed in this sample requires labeling. In this project, our label is a Boolean. False (0) in the dataset indicates positive feedback, while True (1) indicates negative feedback.</p>
<p>The second column maps to the <kbd>Text</kbd> property to propagate the sentiment (which is, the sentence to feed into the model).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The RestaurantPrediction class</h1>
                </header>
            
            <article>
                
<p>The <kbd>RestaurantPrediction</kbd> class contains the output properties that will come out of our model runs. Depending on the algorithm used, the output class, as you will find in future chapters, will contain many more properties:</p>
<pre>using Microsoft.ML.Data;<br/><br/>namespace chapter02.ML.Objects<br/>{<br/>    public class RestaurantPrediction<br/>    {<br/>        [ColumnName("PredictedLabel")]<br/>        public bool Prediction { get; set; }<br/><br/>        public float Probability { get; set; }<br/><br/>        public float Score { get; set; }<br/>    }<br/>}</pre>
<p>Akin to the <kbd>RestaurantFeedback Label</kbd> property, the <kbd>Prediction</kbd> property contains the overall result of positive or negative feedback. The <kbd>Probability</kbd> property contains the confidence of our model of that decision. The <kbd>Score</kbd> property is used for the evaluation of our model.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Trainer class</h1>
                </header>
            
            <article>
                
<p>In the following, you will find the sole method in the <kbd>Trainer</kbd> class. The <kbd>Trainer</kbd> method at a high level does the following:</p>
<ul>
<li>It loads the training data (in this case our CSV) into memory.</li>
<li>It builds a training set and a test set.</li>
<li>It creates the pipeline.</li>
<li>It trains and saves the model.</li>
<li>It performs an evaluation on the model.</li>
</ul>
<p>This is the structure and flow we will follow throughout the rest of this book. Now, let's dive into the code behind the <kbd>Train</kbd> method:</p>
<ol>
<li>First, we check to make sure that the training data filename exists:</li>
</ol>
<pre style="padding-left: 60px"><span>if (!File.Exists(trainingFileName)) {<br/>    Console.WriteLine($"Failed to find training data file ({trainingFileName}");<br/><br/>    return;<br/>}</span></pre>
<p style="padding-left: 60px">Even though this is a simple test application, it is always a good practice to treat it like a production-grade application. In addition, since this is a console application, you may incorrectly pass in a path for the training data, which then can cause exceptions further on in the method.</p>
<ol start="2">
<li><span>Use</span> the <kbd>LoadFromTextFile</kbd> helper method that ML.NET provides to assist with the loading of text files into an <kbd>IDataView</kbd> object:</li>
</ol>
<pre style="padding-left: 60px"><span>IDataView trainingDataView = MlContext.Data.LoadFromTextFile&lt;RestaurantFeedback&gt;(trainingFileName);</span></pre>
<p style="padding-left: 60px">As you can see, we are passing in both the training filename and the type; in this case, it is the <kbd>RestaurantFeedback</kbd> class mentioned earlier. It should be noted that this method has several other parameters, including the following:</p>
<ul>
<li style="padding-left: 60px"><kbd>separatorChar</kbd>: This is the column separator character; it defaults to <kbd>\t</kbd> (in other words, a tab).</li>
<li style="padding-left: 60px"><kbd>hasHeader</kbd>: If set to <kbd>true</kbd>, the dataset's first row has the header; it defaults to <kbd>false</kbd>.</li>
<li style="padding-left: 60px"><kbd>allowQuoting</kbd>: This defines whether the source file can contain columns defined by a quoted string; it defaults to false.</li>
<li style="padding-left: 60px"><kbd>trimWhitespace</kbd>: This removes trailing whitespace from the rows; it defaults to false.</li>
<li style="padding-left: 60px"><kbd>allowSparse</kbd>: This defines whether the file can contain numerical vectors in sparse format; it defaults to false. The sparse format requires a new column to have the number of features.</li>
</ul>
<p style="padding-left: 60px">For most projects used throughout this book, we will use the default settings.</p>
<ol start="3">
<li><span>Given the <kbd>IDataView</kbd> object we created previously, use the </span><kbd>TrainTestSplit</kbd><span> method that ML.NET provides to create a test set from the main training data:</span></li>
</ol>
<pre style="padding-left: 60px"><span>DataOperationsCatalog.TrainTestData dataSplit = MlContext.Data.TrainTestSplit(trainingDataView, testFraction: 0.2);</span></pre>
<p style="padding-left: 60px">As mentioned in <a href="b8d873e1-9234-4f11-ad94-76df5ffbb228.xhtml">Chapter 1</a>, <em>Getting Started with Machine Learning and ML.NET</em>, sample data is split into two sets—training and test. The parameter, <kbd>testFraction</kbd>, specifies the percentage of the dataset to hold back for testing, in our case, 20%. By default, this parameter is set to 0.2.</p>
<ol start="4">
<li>Firstly, we create the pipeline:</li>
</ol>
<pre style="padding-left: 60px"><span>TextFeaturizingEstimator dataProcessPipeline = MlContext.Transforms.Text.FeaturizeText(outputColumnName: "Features",<br/>        inputColumnName: nameof(RestaurantFeedback.Text));</span></pre>
<p style="padding-left: 60px">Future examples will have a much more complex pipeline. In this example, we are simply mapping the <kbd>Text</kbd> property discussed earlier to the <kbd>Features</kbd> output column.</p>
<ol start="5">
<li>Next, we instantiate our <kbd>Trainer</kbd> class:</li>
</ol>
<pre style="padding-left: 60px"><span>SdcaLogisticRegressionBinaryTrainer sdcaRegressionTrainer = MlContext.BinaryClassification.Trainers.SdcaLogisticRegression(<br/>        labelColumnName: nameof(RestaurantFeedback.Label),<br/>        featureColumnName: "Features");<br/></span></pre>
<p style="padding-left: 60px">As you might remember from <a href="b8d873e1-9234-4f11-ad94-76df5ffbb228.xhtml">Chapter 1</a>, <em>Getting Started with Machine Learning and ML.NET</em>, the various algorithms found in ML.NET are referred to as trainers. In this project, we are using an SCDA trainer.</p>
<ol start="6">
<li>Then, we complete the pipeline by appending the trainer we instantiated previously:</li>
</ol>
<pre style="padding-left: 60px"><span>EstimatorChain&lt;BinaryPredictionTransformer&lt;CalibratedModelParametersBase&lt;LinearBinaryModelParameters, PlattCalibrator&gt;&gt;&gt; trainingPipeline = dataProcessPipeline.Append(sdcaRegressionTrainer);</span></pre>
<ol start="7">
<li>Next, we train the model with the dataset we created earlier in the chapter:</li>
</ol>
<pre style="padding-left: 60px"><span>ITransformer trainedModel = trainingPipeline.Fit(dataSplit.TrainSet);</span></pre>
<ol start="8">
<li>We save our newly created model to the filename specified, matching the training set's schema:</li>
</ol>
<pre style="padding-left: 60px"><span>MlContext.Model.Save(trainedModel, dataSplit.TrainSet.Schema, ModelPath);</span></pre>
<ol start="9">
<li>Now, we transform our newly created model with the test set we created earlier:</li>
</ol>
<pre style="padding-left: 60px"><span>IDataView testSetTransform = trainedModel.Transform(dataSplit.TestSet);</span></pre>
<ol start="10">
<li>Finally, we will use the <kbd>testSetTransform</kbd> function created previously and pass it into the <kbd>BinaryClassification</kbd> class's <kbd>Evaluate</kbd> method:</li>
</ol>
<pre style="padding-left: 60px"><span>CalibratedBinaryClassificationMetrics modelMetrics = MlContext.BinaryClassification.Evaluate(<br/>        data: testSetTransform,<br/>        labelColumnName: nameof(RestaurantFeedback.Label),<br/>        scoreColumnName: nameof(RestaurantPrediction.Score));<br/><br/></span><span>Console.WriteLine($"Area Under Curve: {modelMetrics.AreaUnderRocCurve:P2}{Environment.NewLine}" +<br/>        $"Area Under Precision Recall Curve: {modelMetrics.AreaUnderPrecisionRecallCurve:P2}" +                    $"{Environment.NewLine}" +<br/>        $"Accuracy: {modelMetrics.Accuracy:P2}{Environment.NewLine}" +<br/>        $"F1Score: {modelMetrics.F1Score:P2}{Environment.NewLine}" +<br/>        $"Positive Recall: {modelMetrics.PositiveRecall:#.##}{Environment.NewLine}" +<br/>        $"Negative Recall: {modelMetrics.NegativeRecall:#.##}{Environment.NewLine}");</span></pre>
<p><span>This method allows us to generate model metrics. W</span>e then print the main metrics using the trained model with the test set. We will dive into these properties specifically in the <em>Evaluating the Model</em> section of this chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Predictor class</h1>
                </header>
            
            <article>
                
<p>The <kbd>Predictor</kbd> class, as noted earlier, is the class that provides prediction support in our project. The idea behind this method is to provide a simple interface to run the model, given the relatively simple input. In future chapters, we will be expanding this method structure to support more complex integrations, such as those hosted in a web application:</p>
<ol>
<li><span>Akin to what was done in the </span><kbd>Trainer</kbd><span> class, we verify that the model exists prior to reading it:</span></li>
</ol>
<pre style="padding-left: 60px">if (!File.Exists(ModelPath)) {<br/>    Console.WriteLine($"Failed to find model at {ModelPath}");<br/><br/>    return;<br/>}</pre>
<ol start="2">
<li><span>Then, we define the </span><kbd>ITransformer</kbd><span> object:</span></li>
</ol>
<pre style="padding-left: 60px">ITransformer mlModel;<br/><br/>using (var stream = new FileStream(ModelPath, FileMode.Open, FileAccess.Read, FileShare.Read)) {<br/>    mlModel = MlContext.Model.Load(stream, out _);<br/>}<br/><br/>if (mlModel == null) {<br/>    Console.WriteLine("Failed to load model");<br/><br/>    return;<br/>}</pre>
<p style="padding-left: 60px">This object will contain our model once we load via the <kbd>Model.Load</kbd> method. This method can also take a direct file path. However, the stream approach lends itself to support non on-disk approaches that we will use in later chapters.</p>
<ol start="3">
<li>Next, <span>create a </span><kbd>PredictionEngine</kbd><span> object given the model we loaded earlier:</span></li>
</ol>
<pre style="padding-left: 60px">var predictionEngine = MlContext.Model.CreatePredictionEngine&lt;RestaurantFeedback,                        RestaurantPrediction&gt;(mlModel);</pre>
<p style="padding-left: 60px">We are passing in both TSrc and TDst, in our case for this project, <kbd>RestaurantFeedback</kbd> and <kbd>RestaurantPrediction</kbd>, respectively.</p>
<ol start="4">
<li><span>Then, call the </span><kbd>Predict</kbd><span> method on the </span><kbd>PredictionEngine</kbd><span> class:</span></li>
</ol>
<pre style="padding-left: 60px">var prediction = predictionEngine.Predict(new RestaurantFeedback { Text = inputData });</pre>
<p style="padding-left: 60px">Because, when we created the object with TSrc, the type was set to <kbd>RestaurantFeedback</kbd>, we have a strongly typed interface to our model. We then create the <kbd>RestaurantFeedback</kbd> object with the <kbd>inputData</kbd> variable that contains the string with the sentence we are going to run our model on.</p>
<ol start="5">
<li>Finally, display the prediction output along with the probability: </li>
</ol>
<pre style="padding-left: 60px">Console.WriteLine($"Based on \"{inputData}\", the feedback is predicted to be:{Environment.NewLine}" +<br/>        "{(prediction.Prediction ? "Negative" : "Positive")} at a {prediction.Probability:P0}" +                 " confidence");</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The BaseML class</h1>
                </header>
            
            <article>
                
<p>The <kbd>BaseML</kbd> class, as discussed earlier, is going to contain the common code between our <kbd>Trainer</kbd> and <kbd>Predictor</kbd> classes, starting with this chapter. Over the remainder of the book, we will build on top of the <kbd>BaseML</kbd> class defined as follows:</p>
<pre>using System;<br/>using System.IO;<br/><br/>using chapter02.Common;<br/><br/>using Microsoft.ML;<br/><br/>namespace chapter02.ML.Base<br/>{<br/>    public class BaseML<br/>    {<br/>        protected static string ModelPath =&gt; Path.Combine(AppContext.BaseDirectory,                                                           Constants.MODEL_FILENAME);<br/><br/>        protected readonly MLContext MlContext;<br/><br/>        protected BaseML()<br/>        {<br/>            MlContext = new MLContext(2020);<br/>        }<br/>    }<br/>}</pre>
<p>For all ML.NET applications in both training and predictions, an <kbd>MLContext</kbd> object is required. Initializing the object with a specific seed value is needed to create more consistent results during the testing component. Once a model is loaded, the seed value (or lack thereof) does not affect the output.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Program class</h1>
                </header>
            
            <article>
                
<p>Those of you who have created console applications should be familiar with the <kbd>Program</kbd> class and the <kbd>Main</kbd> method within. We will follow this structure for other console-based applications throughout the remainder of the book. The following code block contains the program class from which the application will begin execution:</p>
<pre class="mce-root">using System;<br/><br/>using chapter02.ML;<br/><br/>namespace chapter02<br/>{<br/>    class Program<br/>    {<br/>        static void Main(string[] args)<br/>        {<br/>            if (args.Length != 2)<br/>            {<br/>                Console.WriteLine($"Invalid arguments passed in, exiting.{Environment.NewLine}" +                            $"{Environment.NewLine}Usage: {Environment.NewLine}" +<br/>                    $"predict &lt;sentence of text to predict against&gt;{Environment.NewLine}" +<br/>                    $"or {Environment.NewLine}" +<br/>                    $"train &lt;path to training data file&gt;{Environment.NewLine}");<br/><br/>                return;<br/>            }<br/><br/>            switch (args[0])<br/>            {<br/>                case "predict":<br/>                    new Predictor().Predict(args[1]);<br/>                    break;<br/>                case "train":<br/>                    new Trainer().Train(args[1]);<br/>                    break;<br/>                default:<br/>                    Console.WriteLine($"{args[0]} is an invalid option");<br/>                    break;<br/>            }<br/>        }<br/>    }<br/>}</pre>
<p>This constitutes a fairly straightforward method implementation for those familiar with parsing command-line arguments. A simple two-argument approach is used as the help text indicates.</p>
<div class="packt_infobox">When executing a more complex command-line application that takes in several arguments (optional and required), Microsoft has provided a simple-to-use NuGet package, which is available here: <a href="https://github.com/dotnet/command-line-api">https://github.com/dotnet/command-line-api</a></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Running the example</h1>
                </header>
            
            <article>
                
<p>To run both the training and prediction, simply build the project and then pass in the appropriate data.</p>
<p>For training, you can use the included <kbd>sampledata.csv</kbd> file or create your own. We will do this by opening a PowerShell window and passing in the relative path:</p>
<pre><strong>.\chapter02.exe train ..\..\..\Data\sampledata.csv</strong><br/>Area Under Curve: 100.00%<br/>Area Under Precision Recall Curve: 100.00%<br/>Accuracy: 100.00%<br/>F1Score: 100.00%<br/>Positive Recall: 1<br/>Negative Recall: 1</pre>
<p>Once the model is built, you can run the prediction as follows:</p>
<pre><strong>.\chapter02.exe predict "bad"</strong><br/>Based on "bad", the feedback is predicted to be:<br/>Negative at a 64% confidence</pre>
<p>Feel free to try various phrases to test the efficacy of the model, and congratulations on training your first model!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Evaluating the model</h1>
                </header>
            
            <article>
                
<p>As you saw when running the trainer component of the sample project, there are various elements of model evaluation. For each model type, there are different metrics to look at when analyzing the performance of a model.</p>
<p>In binary classification models like the one found in the example project, the following properties are exposed in <kbd>CalibratedBiniaryClassificationMetrics</kbd> that we set after calling the <kbd>Evaluate</kbd> method. However, first, we need to define the four prediction types in a binary classification:</p>
<ul>
<li>True negative: Properly classified as negative</li>
<li>True positive: Properly classified as positive</li>
<li>False negative: Improperly classified as negative</li>
<li>False positive: Improperly classified as positive</li>
</ul>
<p>The first metric to understand is <strong>Accuracy</strong>. As the name implies, accuracy is one of the most commonly used metrics when evaluating a model. This metric is calculated simply as the ratio of correctly classified predictions to total classifications.</p>
<p>The next metric to understand is <strong>Precision</strong>. Precision is defined as the proportion of true results over all the positive results in a model. For example, a precision of 1 means there were no false positives, an ideal scenario. A false positive is classifying something as positive when it should be classified as negative, as mentioned previously. A common example of a false positive is misclassifying a file as malicious when it is actually benign.</p>
<p>The next metric to understand is <strong>Recall</strong>. Recall is the fraction of all correct results returned by the model. For example, a recall of 1 means there were no false negatives, another ideal scenario. A false negative is classifying something as negative when it should have been classified as positive.</p>
<p>The next metric to understand is the <strong>F-score</strong>, which utilizes both precision and recall, producing a weighted average based on the false positives and false negatives. F-scores give another perspective on the performance of the model compared to simply looking at accuracy. The range of values is between 0 and 1, with an ideal value of 1.</p>
<p><strong>Area Under the Curve</strong>, also referred to as AUC, is, as the name implies, the area under the curve plotted with true positives on the y-axis and false positives on the x-axis. For classifiers such as the model that we trained earlier in this chapter, as you saw, this returned values of between 0 and 1.</p>
<p>Lastly, <strong>Average Log Loss</strong> and <strong>Training Log Loss</strong> are both used to further explain the performance of the model. The average log loss is effectively expressing the penalty for wrong results in a single number by taking the difference between the true classification and the one the model predicts. Training log loss represents the uncertainty of the model using probability versus the known values. As you train your model, you will look to have a low number (lower numbers are better).</p>
<p>As regards the other model types, we will deep dive into how to evaluate them in their respective chapters, where we will cover regression and clustering metrics.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>Over the course of this chapter, we have set up our development environment and learned about the proper organization of files going forward. We also created our first ML.NET application in addition to training, evaluating, and running predictions against a new model. Lastly, we explored how to evaluate a model and what the various properties mean.</p>
<p>In the next chapter, we will deep dive into logistic regression algorithms.</p>


            </article>

            
        </section>
    </body></html>