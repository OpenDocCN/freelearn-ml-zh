["```py\nFROM ubuntu:20.04\nENV DEBIAN_FRONTEND=noninteractive\nRUN apt-get update && apt-get install -y --no-install-recommends \\\nwget \\         \npython3-pip \\         \npython3-dev \\         \nbuild-essential \\         \nlibffi-dev \\         \nlibssl-dev \\         \nnginx \\         \nca-certificates \\    \n&& rm -rf /var/lib/apt/lists/*\nRUN pip --no-cache-dir install numpy scipy scikit-learn pandas flask unicor \n```", "```py\napiVersion: apps/v1 # k8s API version used for creating this deployment\nkind: Deployment # the type of object. In this case, it is deployment\nmetadata:\nname: nginx-deployment # name of the deployment\nspec:\nselector:\nmatchLabels:\napp: nginx # an app label for the deployment.  This can be used to look up/select Pods\nreplicas: 2 # tells deployment to run 2 Pods matching the template\ntemplate:\nmetadata:\nlabels:\napp: nginx\nspec:\ncontainers:\n- name: nginx\nimage: nginx:1.14.2 # Docker container image used for the deployment\nports:\n- containerPort: 80 # the networking port to communicate with the containers \n```", "```py\napiVersion: batch/v1\nkind: Job # indicate that this is the Kubernetes Job resource\nmetadata:\nname: train-job\nspec:\ntemplate:\nspec:\ncontainers:\n- name: train-container\nimagePullPolicy: Always # tell the job to always pull a new container image when it is started\nimage: <uri to Docker image containing training script>\ncommand: [\"python3\",  \"train.py\"]  # tell the container to run this command after it is started\nrestartPolicy: Never\nbackoffLimit: 0 \n```", "```py\napiVersion: v1\nkind: Service\nmetadata:\nname: nginx-service\nspec:\nselector:\napp: nginx\nports:\n- protocol: TCP\nport: 80\ntargetPort: 9376 \n```", "```py\napiVersion: v1\nkind: Endpoints\nmetadata:\nname: nginx-service\nsubsets:\n- addresses:\n- ip: 192.0.2.42\nports:\n- port: 9376 \n```", "```py\n    http://localhost:<port number>/api/v1/proxy/namespaces/<NAMESPACE>/services/<SERVICE NAME>:<PORT NAME> \n    ```", "```py\n    {\n    \"apiVersion\": \"abac.authorization.kubernetes.io/v1beta1\",\n    \"kind\": \"Policy\",\n    \"spec\": {\n    \"user\": \"joe\",\n    \"namespace\": \"*\",\n    \"resource\": \"*\",\n    \"apiGroup\": \"*\"\n    }\n    } \n    ```", "```py\n    {\n    \"apiVersion\": \"abac.authorization.kubernetes.io/v1beta1\",\n    \"kind\": \"Policy\",\n    \"spec\": {\n    \"user\": \"system:serviceaccount:kube-system:default\",\n    \"namespace\": \"*\",\n    \"resource\": \"*\",\n    \"apiGroup\": \"*\"\n    }\n    } \n    ```", "```py\napiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\nnamespace: default\nname: pod-reader\nrules:\n- apiGroups: [\"\"]\n  resources: [\"pods\"]\n  verbs: [\"get\", \"watch\", \"list\"] \n```", "```py\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\nname: nodes-reader\nrules:\n- apiGroups: [\"\"]\n  resources: [\"nodes\"]\n  verbs: [\"get\", \"watch\", \"list\"] \n```", "```py\napiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\nname: read-pods\nnamespace: default\nsubjects:\n- kind: User\nname: joe\napiGroup: rbac.authorization.k8s.io\nroleRef:\nkind: Role\nname: pod-reader\napiGroup: rbac.authorization.k8s.io \n```", "```py\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\nname: read-secrets-global\nsubjects:\n- kind: ServiceAccount\nname: SA-name\nnamespace: default\nroleRef:\nkind: ClusterRole\nname: secret-reader\napiGroup: rbac.authorization.k8s.io \n```", "```py\napiVersion: v1\nkind: Secret\nmetadata:\nname: aws-secret\ntype: Opaque\ndata:\nAWS_ACCESS_KEY_ID: XXXX\nAWS_SECRET_ACCESS_KEY: XXXX \n```", "```py\n    apiVersion: v1\n    kind: Pod\n    metadata:\n    name: secret-env-pod\n    spec:\n    containers:\n    - name: mycontainer\n    image: redis\n    env:\n    - name: SECRET_AWS_ACCESS_KEY\n    valueFrom:\n    secretKeyRef:\n    name: aws-secret\n    key: AWS_ACCESS_KEY_ID\n    - name: SECRET_AWS_SECRET_ACCESS_KEY\n    valueFrom:\n    secretKeyRef:\n    name: aws-secret\n    key: AWS_SECRET_ACCESS_KEY\n    restartPolicy: Never \n    ```", "```py\n    apiVersion: v1\n    kind: Pod\n    metadata:\n    name: pod-ml\n    spec:\n    containers:\n    - name: pod-ml\n    image: <Docker image uri>\n    volumeMounts:\n    - name: vol-ml\n    mountPath: \"/etc/aws\"\n    readOnly: true\n    volumes:\n    - name: vol-ml\n    Secret:\n    secretName: aws-secret \n    ```", "```py\n    eksctl create cluster --name <cluster name> --region us-west-2 \n    ```", "```py\n        eksctl get nodegroup --cluster=<cluster name> \n        ```", "```py\n    cat << EOF > deploy_Jupyter_notebook.yaml\n    apiVersion: apps/v1\n    kind: Deployment\n    metadata:\n    name: jupyter-notebook\n    labels:\n    app: jupyter-notebook\n    spec:\n    replicas: 1\n    selector:\n    matchLabels:\n    app: jupyter-notebook\n    template:\n    metadata:\n    labels:\n    app: jupyter-notebook\n    spec:\n    containers:\n    - name: minimal-notebook\n    image: jupyter/minimal-notebook:latest\n    ports:\n    - containerPort: 8888\n    EOF \n    ```", "```py\n    kubectl apply -f deploy_Jupyter_notebook.yaml. \n    ```", "```py\n    cat << EOF > jupyter_svc.yaml\n    apiVersion: v1\n    kind: Service\n    metadata:\n    name: jupyter-service\n    annotations:\n    service.beta.kubernetes.io/aws-load-balancer-type: alb\n    spec:\n    selector:\n    app: jupyter-notebook\n    ports:\n    - protocol: TCP\n    port: 80\n    targetPort: 8888\n    type: LoadBalancer\n    EOF \n    ```"]