<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch07"/>Chapter 7. OpenCV on the Server Side</h1></div></div></div><p>As the Internet gets more and more interactive, a subject of great interest is how to deal with image processing on the server side that enables you to create web applications dealing with OpenCV. As Java is among the languages of choice when developing web apps, this chapter shows the entire architecture of an application that lets users upload an image and add a fedora hat on top of detected faces using techniques learned throughout the book.</p><p>In this chapter, we will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Setting up an OpenCV web application</li><li class="listitem" style="list-style-type: disc">Mixed reality</li><li class="listitem" style="list-style-type: disc">Image uploading</li><li class="listitem" style="list-style-type: disc">Dealing with HTTP requests</li></ul></div><p>By the end of this chapter you will know how to create a complete web application with image processing, obtain input from the user, process the image on the server side, and return the processed image to the user.</p><div><div><div><div><h1 class="title"><a id="ch07lvl1sec53"/>Setting up an OpenCV web application</h1></div></div></div><p>Since this chapter covers the <a id="id236" class="indexterm"/>development of a web application using Java OpenCV, it is important to address a couple of differences when going to the server side. The first thing is to tell the web container, generally Tomcat, Jetty, JBoss, or Websphere, about the location of native libraries. Other details deal with loading the native code. This should happen as soon as the web server goes up and should not occur again.</p><p>The advantages of using the web architecture are significant. As certain image-processing tasks are compute intensive, they could easily drain the device's battery in no time, so, taking them to a more robust hardware on the cloud would relieve local processing. Besides that, there's no need for users to install anything more than the web browser, and the updates happening on the server side are also very handy.</p><p>On the other hand, there are a few drawbacks. If, instead of hosting the web application on the <a id="id237" class="indexterm"/>administrator infrastructure, one intends to host it on Java servers online, it should be clear whether it allows native code to be run or not. At the time of writing, Google's App Engine does not allow it, but it is easy to set up a Linux server on Amazon EC2 or Google's Compute Engine that smoothly runs it although this won't be covered in this book. Another thing to be considered is that several computer vision applications need to be run in real time, even at the rate of 20 frames per second, for instance, which would be impractical in a web architecture, due to long upload times, and this type of application should be run locally.</p><p>In order to create our web application, we will go through the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Creating a Maven-based web application.</li><li class="listitem">Adding OpenCV dependencies.</li><li class="listitem">Running the web application.</li><li class="listitem">Importing the project to Eclipse.</li></ol></div><p>In the following sections, we will cover these steps in detail.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec17"/>Creating a Maven-based web application</h2></div></div></div><p>There are several <a id="id238" class="indexterm"/>ways to <a id="id239" class="indexterm"/>create web applications in Java. Spring MVC, Apache Wicket, and Play Framework are all great options among others. Also, on top of these frameworks, we can put JavaServer Faces, PrimeFaces, or RichFaces as component-based user interfaces for these web applications. For this chapter though, instead of addressing all these technologies, the approach will be to only use servlets for you to choose your frameworks. You should notice that a servlet is simply a Java class used to extend the capabilities of a server, and this is generally used to process or store data that was submitted through an HTML form. The servlet API has been around since 1997, so it has been exhaustively used, and there are several books and samples about it. Although this chapter focuses on Servlet 2.x for simplicity, we need to be aware that the API is synchronous and that it might be better to use an asynchronous one, such as Servlet 3.x, for applications that will receive several clients together.</p><p>Although any IDE can easily generate a web application through a wizard—such as going to Eclipse and navigating to <strong>File</strong> | <strong>New</strong> | <strong>Project…</strong> | <strong>Web</strong> | <strong>Dynamic Web Project</strong>—we'll focus on starting it with the help of Maven since we can easily get native dependencies. As long as it has been installed correctly according to instructions in <a class="link" href="ch01.html" title="Chapter 1. Setting Up OpenCV for Java">Chapter 1</a>, <em>Setting Up OpenCV for Java</em>, Maven can set up a web application through the use of a prototype. This is achieved through the following command:</p><div><pre class="programlisting">
<strong>mvn archetype:generate -DgroupId=com.mycompany.app -DartifactId=my-webapp -DarchetypeArtifactId=maven-archetype-webapp -DinteractiveMode=false</strong>
</pre></div><p>This command <a id="id240" class="indexterm"/>will call the <code class="literal">generate</code> goal from the <code class="literal">archetype</code> plugin. Think of <code class="literal">archetype</code> as a project <a id="id241" class="indexterm"/>template. This Maven plugin will generate a web application from a template because we have set <code class="literal">archetypeArtifactId</code> as <code class="literal">maven-archetype-webapp</code> through the <code class="literal">-DarchetypeArtifactId=maven-archetype-webapp</code> option. The other option, <code class="literal">DartifactId=my-webapp</code>, will simply set the folder name of the web application as defined in this option, while <code class="literal">groupId</code> is Maven's universally unique identifier for a project.</p><p>Note that the following structure will be created:</p><div><img src="img/3972OS_07_06.jpg" alt="Creating a Maven-based web application"/></div><p>The preceding is a simple structure for a web application. You should pay attention to the <code class="literal">web.xml</code> file, which is used for mapping servlets, as well as <code class="literal">index.jsp</code>, which is a simple Java Server Page file. By now you should be able to run this web application in Tomcat, for instance, with little effort. Simply type the following command:</p><div><pre class="programlisting">
<strong>cd my-webapp</strong>
<strong>mvn tomcat:run</strong>
</pre></div><p>Now, if the you access the address <code class="literal">http://localhost:8080/my-webapp/</code>, the following response should be seen in the browser:</p><div><img src="img/3972OS_07_01.jpg" alt="Creating a Maven-based web application"/></div><p>Notice that it means <a id="id242" class="indexterm"/>that we <a id="id243" class="indexterm"/>have successfully created a web project, we are running it through a Tomcat web container, and it is available through <code class="literal">localhost</code> server, in port <code class="literal">8080</code>, through the name <code class="literal">my-webapp</code>. The <code class="literal">Hello World!</code> message can be seen in<code class="literal"> index.jsp</code>. In the following section, you are going to customize the <code class="literal">pom</code> file in order to add OpenCV dependencies.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec18"/>Adding OpenCV dependencies</h2></div></div></div><p>Since the <a id="id244" class="indexterm"/>web application <a id="id245" class="indexterm"/>archetype has created a project structure for us, we are going to add OpenCV dependencies for the generated <code class="literal">pom.xml</code>. If you open it, you will see the following code:</p><div><pre class="programlisting">&lt;project  
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;groupId&gt;com.mycompany.app&lt;/groupId&gt;
  &lt;artifactId&gt;my-webapp&lt;/artifactId&gt;
  &lt;packaging&gt;war&lt;/packaging&gt;
  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
  &lt;name&gt;my-webapp Maven Webapp&lt;/name&gt;
  &lt;url&gt;http://maven.apache.org&lt;/url&gt;
  <strong>&lt;dependencies&gt;</strong>
<strong>    &lt;dependency&gt;</strong>
<strong>      &lt;groupId&gt;junit&lt;/groupId&gt;</strong>
<strong>      &lt;artifactId&gt;junit&lt;/artifactId&gt;</strong>
<strong>      &lt;version&gt;3.8.1&lt;/version&gt;</strong>
<strong>      &lt;scope&gt;test&lt;/scope&gt;</strong>
<strong>    &lt;/dependency&gt;</strong>
<strong>  &lt;/dependencies&gt;</strong>
  &lt;build&gt;
    &lt;finalName&gt;my-webapp&lt;/finalName&gt;
  &lt;/build&gt;
&lt;/project&gt;</pre></div><p>Notice that the only <a id="id246" class="indexterm"/>dependency<a id="id247" class="indexterm"/> is on <code class="literal">junit</code>. Now add the following to the dependencies tag:</p><div><pre class="programlisting">&lt;dependency&gt;
  &lt;groupId&gt;org.javaopencvbook&lt;/groupId&gt;
  &lt;artifactId&gt;opencvjar&lt;/artifactId&gt;
  &lt;version&gt;3.0.0&lt;/version&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
  &lt;groupId&gt;org.javaopencvbook&lt;/groupId&gt;
  &lt;artifactId&gt;opencvjar-runtime&lt;/artifactId&gt;
  &lt;version&gt;3.0.0&lt;/version&gt;
  &lt;classifier&gt;natives-windows-x86&lt;/classifier&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
  &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
  &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;
  &lt;version&gt;3.0.1&lt;/version&gt;
  &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;</pre></div><p>The first two dependencies, <code class="literal">opencvjar</code> and <code class="literal">opencvjar-runtime</code>, are the same ones that have been discussed in <a class="link" href="ch01.html" title="Chapter 1. Setting Up OpenCV for Java">Chapter 1</a>, <em>Setting Up OpenCV for Java</em>. Now, the dependency on <code class="literal">javax.servlet-api</code> refers to the servlet API version 3.0.1, which is used to make files upload more easily. Besides using these dependencies, all other configurations are mentioned in <a class="link" href="ch01.html" title="Chapter 1. Setting Up OpenCV for Java">Chapter 1</a>, <em>Setting Up OpenCV for Java</em>, such as adding the <code class="literal">JavaOpenCVBook</code> repository, <code class="literal">maven-jar-plugin</code>, <code class="literal">maven-dependency-plugin</code>, and <code class="literal">maven-nativedependencies-plugin</code>.</p><p>The only new plugin is <code class="literal">tomcat7</code> as we would require it to use the file upload API from <code class="literal">servlet 3.0</code>. In order to add the <code class="literal">tomcat7</code> plugin, look for the <code class="literal">&lt;plugins&gt;</code> section in <code class="literal">pom.xml</code> and add the following code:</p><div><pre class="programlisting">&lt;plugin&gt;
  &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;
  &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;
  &lt;version&gt;2.2&lt;/version&gt;
  &lt;configuration&gt;
    &lt;port&gt;9090&lt;/port&gt;
    &lt;path&gt;/&lt;/path&gt;
  &lt;/configuration&gt;
&lt;/plugin&gt;</pre></div><p>Besides adding the <a id="id248" class="indexterm"/>ability to<a id="id249" class="indexterm"/> run <code class="literal">tomcat7</code> from Maven, it will also configure port <code class="literal">9090</code> as the default port for our server, but you can use another one. The final <code class="literal">pom.xml</code> file can be found in this chapter's source code project. Running an <code class="literal">mvn package</code> command will show that everything's been fine in the project setup. In the next section, we are going to check all the processes through a simple OpenCV call from the .<code class="literal">jsp</code> file.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec19"/>Running the web application</h2></div></div></div><p>Now that all the <a id="id250" class="indexterm"/>dependencies have been set up, it should be straightforward to run our web application. One detail should be noticed, though. Since our application relies on native code, the <code class="literal">opencv_java300.dll</code> file, or the shared object, we should put it in the Java library path prior to running the Tomcat server. There are several approaches to doing this, depending on your deployment strategy, but a simple one could be setting the path through the <code class="literal">MAVEN_OPTS</code> environment variable. You should type the following command in the terminal:</p><div><pre class="programlisting">
<strong>set MAVEN_OPTS=-Djava.library.path=D:/your_path/my-webapp/target/natives</strong>
</pre></div><p>Please remember to change <code class="literal">your_path</code> to the place you are setting up your project, the parent folder of <code class="literal">my-webapp</code>. In order to check that the application server can correctly load OpenCV native libraries, we are going to set up a simple servlet which is able to output the correct installed version. Change the <code class="literal">index.jsp</code> file generated in your <code class="literal">my-webapp\src\main\webapp</code> folder to the following code:</p><div><pre class="programlisting">&lt;html&gt;
  &lt;body&gt;
    &lt;h2&gt;OpenCV Webapp Working!&lt;/h2&gt;
    &lt;%@ page import = "org.opencv.core.Core" %&gt;
    Core.VERSION: &lt;%= Core.VERSION %&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre></div><p>Now, run your server typing <code class="literal">mvn tomcat7:run</code>. Try loading <a id="id251" class="indexterm"/>your application in your web browser at the address <code class="literal">http://localhost:9090</code>, and you should see the page outputting your loaded OpenCV version. Although this code doesn't really load native libraries, since <code class="literal">Core.VERSION</code> can be retrieved from pure Java JAR, it's not a good practice to mix business code—the one that really does your image processing—with your presentation code, that is, the Java Server Page we just edited. In order to deal with image processing, we are going to concentrate the code in a servlet that only deals with it.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec20"/>Importing the project to Eclipse</h2></div></div></div><p>Now that the<a id="id252" class="indexterm"/> project is all <a id="id253" class="indexterm"/>set up with Maven, it should be easy to import it to Eclipse. Simply issue the following Maven command:</p><div><pre class="programlisting">
<strong>mvn eclipse:eclipse -Dwtpversion=2.0</strong>
</pre></div><p>Remember to add the <code class="literal">-Dwtpversion=2.0</code> flag to add support for WTP version 2.0, which is Eclipse's Web Tools platform. If you have not set up your <code class="literal">M2_REPO</code> as explained in <a class="link" href="ch01.html" title="Chapter 1. Setting Up OpenCV for Java">Chapter 1</a>, <em>Setting Up OpenCV for Java</em>, a simple trick can automate it for you. Type the following command:</p><div><pre class="programlisting">
<strong>mvn -Declipse.workspace="YOUR_WORKSPACE_PATH" eclipse:configure-workspace</strong>
</pre></div><p>The <code class="literal">YOUR_WORKSPACE_PATH</code> path should be changed to something similar to <code class="literal">C:\Users\baggio\workspace</code> if that is where your Eclipse workspace is located.</p><p>In Eclipse, navigate through <strong>File</strong> | <strong>Import</strong> | <strong>General</strong> | <strong>Existing Projects</strong> into the workspace and point to your <code class="literal">my-webapp</code> folder. Notice that your Eclipse should have WTP support. In case you receive a <code class="literal">Java compiler level does not match the version of the installed Java project facet</code> message, simply right-click it and in the <strong>Quick Fix</strong> menu, choose <strong>Change Java Project Facet version to Java 1.8</strong>. Now you can run it by right-clicking in <a id="id254" class="indexterm"/>your<a id="id255" class="indexterm"/> project, navigating to <strong>Run as</strong> | <strong>Run on Server</strong>, selecting <strong>Apache</strong> | <strong>Tomcat v7.0 Server</strong>, and hitting <strong>Next</strong>. If you don't have an existing Tomcat 7 installation, select <strong>Download and Install</strong>, as shown in the next screenshot:</p><div><img src="img/3972OS_07_02.jpg" alt="Importing the project to Eclipse"/></div><p>Select a folder for your Tomcat7 installation and click on <strong>Next</strong> and <strong>Finish</strong>. Now, you can run your application directly from Eclipse, by right-clicking on your project and clicking on <strong>Run as</strong> | <strong>Run on Server</strong>. In case you receive a "java.lang.UnsatisfiedLinkError: no opencv_java300 in java.library.path", right-click your project, "Run As -&gt;Run Configurations..." and in the Arguments tab, in the VM arguments text box, add the -Djava.library.path="C:\path_to_your\target\natives". Click in "Apply" and restart your server by going to the Server tab and right-clicking your Tomcat7 execution -&gt; Restart.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec54"/>Mixed reality web applications</h1></div></div></div><p>The web<a id="id256" class="indexterm"/> application we are going to develop draws Fedora hats on top of the detected heads in a given image. In order to do this, the user uploads the image through a simple form, and then it is converted to an OpenCV matrix in memory. After conversion, a cascade classifier looking for faces is run over the matrix. A simple scale and a translation are applied to estimate the hat's position and scale. A transparent fedora image is then drawn on the specified position for each of the detected faces. The result is then returned through HTTP by giving the mixed reality picture to the user. Notice that all the processing happens on the server side, so the client is only left to upload and download the image, which is very useful for clients that rely on batteries, such as smartphones.</p><div><div><h3 class="title"><a id="note11"/>Note</h3><p><em>Mixed reality (MR), sometimes referred to as hybrid reality (encompassing both augmented reality and augmented virtuality), refers to the merging of real and virtual worlds to produce new environments and visualisations where physical and digital objects co-exist and interact in real time. Not taking place only in the physical world or the virtual world, but a mix of reality and virtual reality, encompassing augmented reality and augmented virtuality.</em></p><p><em>Source: Fleischmann, Monika; Strauss, Wolfgang (eds.) (2001). Proceedings of »CAST01//Living in Mixed Realities« Intl. Conf. On Communication of Art, Science and Technology, Fraunhofer IMK 2001, 401. ISSN 1618–1379 (Print), ISSN 1618–1387 (Internet).</em></p></div></div><p>This web application can be divided into a couple of simpler steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Image upload.</li><li class="listitem">Image processing.</li><li class="listitem">Response image.</li></ol></div><p>The following sections will cover these steps in detail.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec21"/>Image upload</h2></div></div></div><p>Firstly, we are <a id="id257" class="indexterm"/>going to <a id="id258" class="indexterm"/>turn our dummy Java Server Page into a form that will require the user to choose a local file, similar to the one seen in the following screenshot:</p><div><img src="img/3972OS_07_03.jpg" alt="Image upload"/></div><p>The following code shows the complete Java Server Page. Note the form element, which states that it will call a <code class="literal">post</code> method being processed in the <code class="literal">doPost</code> part of the servlet and requests that the web server to accept the data enclosed in the form for storage. The <code class="literal">enctype= "multipart/form-data"</code> states that no characters are going to be encoded, as can be seen in the <code class="literal">"text/plain" </code>encryption type, which converts spaces to <code class="literal">+</code> symbols. Another important attribute is <code class="literal">action="upload"</code>. It makes sure that the data encoded in the form is sent to the "<code class="literal">/upload</code>" URL. The input element with the type "file" simply works as a call to the operating system's file dialog, which pops up and lets the user specify the file location. Finally, the input element with the "submit" type deals with sending the request with form data when the button is clicked:</p><div><pre class="programlisting">&lt;%@ page language="java" contentType="text/html; charset=ISO-8859-1"
    pageEncoding="ISO-8859-1"%&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
    "http://www.w3.org/TR/html4/loose.dtd"&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"&gt;
&lt;title&gt;File Upload&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;center&gt;
    &lt;h1&gt;File Upload&lt;/h1&gt;
    &lt;form method="post" action="upload"
        enctype="multipart/form-data"&gt;
        Select file to upload: &lt;input type="file" name="file" size="60" /&gt;&lt;br /&gt;
        &lt;br /&gt; &lt;input type="submit" value="Upload" /&gt;
    &lt;/form&gt;
&lt;/center&gt;
&lt;/body&gt;
&lt;/html&gt;</pre></div><p>When pressing<a id="id259" class="indexterm"/> the <strong>Submit</strong> button, a stream of bytes is sent to the server, which will forward them to a <a id="id260" class="indexterm"/>servlet called <code class="literal">Upload</code>. Note that mapping from the <code class="literal">/upload</code> URL to the <code class="literal">Upload</code> servlet happens in the <code class="literal">/src/main/webapp/WEB-INF/web.xml</code> file, as shown in the following lines:</p><div><pre class="programlisting">&lt;web-app&gt;
  &lt;servlet&gt;
    &lt;servlet-name&gt;Upload&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.javaopencvbook.webapp.UploadServlet&lt;/servlet-class&gt;
  &lt;/servlet&gt;
  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;Upload&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/upload&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;
&lt;/web-app&gt;</pre></div><p>Pay attention to the fact that, when the user hits the <strong>Submit</strong> button from the form, the <code class="literal">doPost</code> method from the mapped servlet class, <code class="literal">UploadServlet</code>, is called. This method is the core of this web application, and we are going to see it in detail in the following code:</p><div><pre class="programlisting">@Override
protected void doPost(HttpServletRequest request, HttpServletResponse response)
throws ServletException, IOException {
  System.loadLibrary(Core.NATIVE_LIBRARY_NAME);
  
  loadCascade();
  
  Mat image = receiveImage(request);
  Mat overlay = loadOverlayImage();
  detectFaceAndDrawHat(image, overlay);
  writeResponse(response, image);
}</pre></div><p>The main action in the <code class="literal">doPost</code> method starts by loading the OpenCV library, as seen in the previous chapters, and then loading the cascade which will be used later for face detection. For<a id="id261" class="indexterm"/> the sake of brevity, the initialization is made here, but in actual code, you should <a id="id262" class="indexterm"/>use <code class="literal">ServletContextListener</code> in order to initialize it. Then, the <code class="literal">receiveImage</code> method deals with receiving bytes from the upload and converting it to an OpenCV matrix. So, the other methods take care of loading the fedora hat image and detecting people's faces so that the overlay can be drawn through the <code class="literal">detectFaceAndDrawHat</code> method. Finally, the <code class="literal">writeResponse</code> method answers the request. We will cover <code class="literal">receiveImage</code> in more detail in the following code:</p><div><pre class="programlisting">private Mat receiveImage(HttpServletRequest request) throws IOException, ServletException {
  byte[] encodedImage = receiveImageBytes(request);
  return convertBytesToMatrix(encodedImage);
}</pre></div><p>Note that <code class="literal">receiveImage</code> simply grabs bytes from an upload request in <code class="literal">receiveImageBytes</code> and then converts them to a matrix. The following is the code for <code class="literal">receiveImageBytes</code>:</p><div><pre class="programlisting">private byte[] receiveImageBytes(HttpServletRequest request)
throws IOException, ServletException {
  InputStream is = (InputStream) request.getPart("file").getInputStream();
  BufferedInputStream bin = new BufferedInputStream(is);  
  ByteArrayOutputStream buffer = new ByteArrayOutputStream();  
  int ch =0;
  while((ch=bin.read())!=-1) {  
    buffer.write(ch);  
  }  
  buffer.flush();
  bin.close();  
  byte[] encodedImage = buffer.toByteArray();
  return encodedImage;
}</pre></div><p>This is the default code to receive an upload. It accesses the "file" field from the form and gets its stream through <code class="literal">request.getPart("file").getInputStream()</code>. Then, a buffer is created, so all data from the input stream is written through the <code class="literal">write()</code> method as long as<a id="id263" class="indexterm"/> there's <a id="id264" class="indexterm"/>data from the upload. The byte array is then returned through the <code class="literal">ByteArrayOutputStream</code> class's <code class="literal">toByteArray()</code> method. Since what we have received at this point is just a bunch of bytes, there is a need to decode the image format and convert it to an OpenCV matrix. Fortunately, there's already a method that does that, <code class="literal">imdecode</code>, from the <code class="literal">Imgcodecs</code> package, the signature of which is as follows:</p><div><pre class="programlisting">public static Mat imdecode(Mat buf, int flags)</pre></div><p>The <code class="literal">buf</code> argument is a <code class="literal">Mat</code> buffer that we will create from the byte array, and <code class="literal">flags</code> is an option used to convert the <code class="literal">Mat</code> buffer returned to grayscale or color, for instance.</p><p>The complete code for the decoding can be seen in the following lines:</p><div><pre class="programlisting">private Mat convertBytesToMatrix(byte[] encodedImage) {
  Mat encodedMat = new Mat(encodedImage.length,1,CvType.CV_8U);
  encodedMat.put(0, 0,encodedImage);
  Mat image = Imgcodecs.imdecode(encodedMat, Imgcodecs.CV_LOAD_IMAGE_ANYCOLOR);
  return image;
}</pre></div><p>Now it's done, we have received the user's image upload, and it is converted to our well-known <code class="literal">Mat</code> class. It's now time to create the mixed reality.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec55"/>Image processing</h1></div></div></div><p>In this section, we <a id="id265" class="indexterm"/>are going to describe how to process the received image in order to draw an image file <a id="id266" class="indexterm"/>on top of it. Now, a cascade classifier is run just as in the previous chapter. It is important to pay attention to the XML cascade file location. Throughout the code, we have used a helper function called <code class="literal">getResourcePath</code>, and we have used the convention of storing all the resources in the <code class="literal">src/main/resources/</code> folder. This way, the helper function works in a manner similar to that of  the following code:</p><div><pre class="programlisting">private String getResourcePath(String path) {
  String absoluteFileName = getClass().getResource(path).getPath();
  absoluteFileName = absoluteFileName.replaceFirst("/", "");
  return absoluteFileName;
}</pre></div><p>Using this function, one can load a cascade through the following call:</p><div><pre class="programlisting">private void loadCascade() {
  String cascadePath = getResourcePath("/cascades/lbpcascade_frontalface.xml");
  faceDetector = new CascadeClassifier(cascadePath);
}</pre></div><p>After the cascade has been correctly loaded, we are all set, and now it is time to explain how the hat's position is estimated. When running the face classifier, we have a good idea not <a id="id267" class="indexterm"/>only of the face's position, but also of the face's bounding rectangle. We will use this width to <a id="id268" class="indexterm"/>estimate the width of the hat. We can suppose that the width of the hat would be three times the face's bounding rectangle width. This way, we still need to keep the hat's aspect ratio. This is done with a simple rule of three, as shown here:</p><div><img src="img/3972OS_07_07.jpg" alt="Image processing"/></div><p>Now that the virtual hat's dimensions are defined, we still need to estimate its location. From a couple of tests, we could infer that 60 percent above the face's bounding rectangle should be fine for most of the pictures. Now, we have the hat's dimensions and position. In the end, instead of using the hat's width as three times the face's width, a value of 2.3 times the face's width seemed to work better. The following code shows the math used to<a id="id269" class="indexterm"/> set the <strong>region of interest</strong> (<strong>ROI</strong>) to draw the fedora as implemented in the method <code class="literal">detectFaceAndDrawHat</code>. A simple adjustment is made to the hat's dimensions when it goes beyond the bounds.</p><div><pre class="programlisting">double hatGrowthFactor = 2.3;
int hatWidth = (int) (rect.width *hatGrowthFactor);
int hatHeight = (int) (hatWidth * overlay.height() / overlay.width());
int roiX =  rect.x - (hatWidth-rect.width)/2;
int roiY =  (int) (rect.y  - 0.6*hatHeight);
roiX =  roiX&lt;0 ? 0 : roiX;
roiY = roiY&lt; 0? 0 :roiY;
hatWidth = hatWidth+roiX &gt; image.width() ? image.width() -roiX : hatWidth;

hatHeight = hatHeight+roiY &gt; image.height() ? image.height() - roiY : hatHeight;</pre></div><p>The following screenshot gives us an overview of the widths and the process of drawing the fedora overlay:</p><div><img src="img/3972OS_07_04.jpg" alt="Image processing"/></div><p>It is time to draw the<a id="id270" class="indexterm"/> hat! This should be as simple as locating the hat's position in the picture and copying the <a id="id271" class="indexterm"/>submatrix. We need to be careful, though, to correctly draw transparent pixels and not draw outside the picture. Mat's <code class="literal">copyTo</code> method is used to copy a submatrix into another one. This method also accepts a mask Mat parameter, the nonzero elements of which indicate which matrix elements must be copied. Notice that the hat image itself is passed as the mask parameter, and it actually works because all transparent pixels are made zero in all channels and all other pixels will have some value, working like a mask. The code to resize the fedora and copy it to the main image is as follows:</p><div><pre class="programlisting">Mat resized = new Mat();
Size size = new Size(hatWidth,hatHeight);
Imgproc.resize(overlay,resized, size);
Mat destinationROI = image.submat( roi );
resized.copyTo( destinationROI , resized);</pre></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec22"/>The response image</h2></div></div></div><p>We have successfully received an image and drawn hats over identified faces. Now, it's time to <a id="id272" class="indexterm"/>send<a id="id273" class="indexterm"/> the result back to the user. We do this by setting the content type of our response as <code class="literal">image/jpeg</code>, for instance. We then encode our response with the same format as defined in our header—if it is jpeg, we will encode it in JPEG—and write the bytes in our response servlet object:</p><div><pre class="programlisting">private void writeResponse(HttpServletResponse response, Mat image) throws IOException {
  MatOfByte outBuffer = new MatOfByte();
  Imgcodecs.imencode(".jpg", image, outBuffer);

  response.setContentType("image/jpeg");
  ServletOutputStream out;  
  out = response.getOutputStream();
  out.write(outBuffer.toArray());
}</pre></div><p>The input image and the output result appear in the following screenshot. Some fedora hats are distributed to Einstein and his friends in our augmented reality web application. The <a id="id274" class="indexterm"/>left-hand side photo is the uploaded image, while the right-hand side photo shows the<a id="id275" class="indexterm"/> hats drawn over the detected faces. According to our loop, hats will be drawn in the same order that detected faces are returned. This way, we can't grant a correct Z-order, which is what hat is drawn on top of another although we could try to infer it from face size. This is shown in the following images:</p><div><img src="img/3972OS_07_05.jpg" alt="The response image"/><div><p><a class="ulink" href="http://www.nobelprize.org/nobel_prizes/physics/laureates/1921/einstein-photo.html">http://www.nobelprize.org/nobel_prizes/physics/laureates/1921/einstein-photo.html</a></p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec56"/>Summary</h1></div></div></div><p>In this chapter, we sent our computer vision applications to the server-side world. We started covering the basics of a simple servlet-based web application configuration using Maven, which provided us with a general application structure. We then added OpenCV dependencies to our <code class="literal">pom.xml</code> configuration file as used in a standard OpenCV desktop application. We then checked other runtime configurations as we deployed our web server using Maven.</p><p>With every webapp configuration aspect solved, we moved on to the development of our mixed reality application that explored the details of image uploading, converting it to an OpenCV Mat object and then writing a response to our clients with a processed image.</p><p>It seems that all aspects of creating basic computer vision applications have been covered now. We dealt with setting up OpenCV for Java and then learned how to work with matrices. We then touched on the basics of creating Java Swing desktop applications and worked with image-processing algorithms to filter, change image morphology, and do essential thresholding. You also learned tools that are in every computer vision researcher's toolkit, such as Hough transformations to find lines and circles as well as special kernel convolution. We covered the important Fourier transform and warp operations. We then dived into machine learning and used handy OpenCV cascades, and you also learned how to create new object classifiers. Besides this, we studied certain background removal approaches and tested the incredible Kinect device to perform depth-based processing. We finally finished the book with a complete server-side example, and now, you are ready to count on Java for your own computer vision projects!</p></div></body></html>