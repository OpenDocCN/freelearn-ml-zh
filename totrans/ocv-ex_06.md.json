["```py\nbool train(const Ptr<TrainData>& trainData, int flags=0 );\nbool train(InputArray samples, int layout, InputArray responses);\nPtr<_Tp> train(const Ptr<TrainData>& data, const _Tp::Params& p, int flags=0 );\nPtr<_Tp> train(InputArray samples, int layout, InputArray responses, const _Tp::Params& p, int flags=0 );\n```", "```py\nfloat StatModel::predict(InputArray samples, OutputArray results=noArray(), int flags=0 )\n```", "```py\nvector< vector<float> > ExtractFeatures(Mat img, vector<int>* left=NULL, vector<int>* top=NULL)\n{\n  vector< vector<float> > output;\n  vector<vector<Point> > contours;\n  Mat input= img.clone();\n\n  vector<Vec4i> hierarchy;\n  findContours(input, contours, hierarchy, RETR_CCOMP, CHAIN_APPROX_SIMPLE);\n  // Check the number of objects detected\n  if(contours.size() == 0 ){\n    return output;\n  }\n  RNG rng( 0xFFFFFFFF );\n  for(int i=0; i<contours.size(); i++){\n\n    Mat mask= Mat::zeros(img.rows, img.cols, CV_8UC1);\n    drawContours(mask, contours, i, Scalar(1), FILLED, LINE_8, hierarchy, 1);\n    Scalar area_s= sum(mask);\n    float area= area_s[0];\n\n    if(area>500){ //if the area is greather than min.\n\n      RotatedRect r= minAreaRect(contours[i]);\n      float width= r.size.width;\n      float height= r.size.height;\n      float ar=(width<height)?height/width:width/height;\n\n      vector<float> row;\n      row.push_back(area);\n      row.push_back(ar);\n      output.push_back(row);\n      if(left!=NULL){\n          left->push_back((int)r.center.x);\n      }\n      if(top!=NULL){\n          top->push_back((int)r.center.y);\n      }\n\n      miw->addImage(\"Extract Features\", mask*255);\n      miw->render();\n      waitKey(10);\n    }\n  }\n  return output;\n}\n```", "```py\n      vector< vector<float> > output;\n      vector<vector<Point> > contours;\n      Mat input= img.clone();\n      vector<Vec4i> hierarchy;\n      findContours(input, contours, hierarchy, RETR_CCOMP, CHAIN_APPROX_SIMPLE);\n    ```", "```py\n    if(contours.size() == 0 ){\n        return output;\n      }\n    ```", "```py\n    for(int i=0; i<contours.size(); i++){\n    Mat mask= Mat::zeros(img.rows, img.cols, CV_8UC1);\n        drawContours(mask, contours, i, Scalar(1), FILLED, LINE_8, hierarchy, 1);\n    ```", "```py\n        Scalar area_s= sum(mask);\n        float area= area_s[0];\n    ```", "```py\n    if(area>MIN_AREA){ //if the area is greather than min.\n          RotatedRect r= minAreaRect(contours[i]);\n          float width= r.size.width;\n          float height= r.size.height;\n          float ar=(width<height)?height/width:width/height;\n    ```", "```py\n    vector<float> row;\n          row.push_back(area);\n          row.push_back(ar);\n          output.push_back(row);\n    ```", "```py\n      if(left!=NULL){\n              left->push_back((int)r.center.x);\n          }\n          if(top!=NULL){\n              top->push_back((int)r.center.y);\n          }\n    ```", "```py\n          miw->addImage(\"Extract Features\", mask*255);\n          miw->render();\n          waitKey(10);\n        }\n      }\n      return output;\n    ```", "```py\nPtr<SVM> svm;\n```", "```py\nvoid trainAndTest()\n{\n  vector< float > trainingData;\n  vector< int > responsesData;\n  vector< float > testData;\n  vector< float > testResponsesData;\n\n  int num_for_test= 20;\n\n  // Get the nut images\n  readFolderAndExtractFeatures(\"../data/nut/tuerca_%04d.pgm\", 0, num_for_test, trainingData, responsesData, testData, testResponsesData);\n  // Get and process the ring images\n  readFolderAndExtractFeatures(\"../data/ring/arandela_%04d.pgm\", 1, num_for_test, trainingData, responsesData, testData, testResponsesData);\n  // get and process the screw images\n  readFolderAndExtractFeatures(\"../data/screw/tornillo_%04d.pgm\", 2, num_for_test, trainingData, responsesData, testData, testResponsesData);\n\n  cout << \"Num of train samples: \" << responsesData.size() << endl;\n\n  cout << \"Num of test samples: \" << testResponsesData.size() << endl;\n\n  // Merge all data \n  Mat trainingDataMat(trainingData.size()/2, 2, CV_32FC1, &trainingData[0]);\n  Mat responses(responsesData.size(), 1, CV_32SC1, &responsesData[0]);\n\n  Mat testDataMat(testData.size()/2, 2, CV_32FC1, &testData[0]);\n  Mat testResponses(testResponsesData.size(), 1, CV_32FC1, &testResponsesData[0]);\n\n    svm = SVM::create();\n        svm->setType(SVM::C_SVC);\n        svm->setKernel(SVM::CHI2);\n        svm->setTermCriteria(TermCriteria(TermCriteria::MAX_ITER, 100, 1e-6));\n\n  svm->train(trainingDataMat, ROW_SAMPLE, responses);\n\n  if(testResponsesData.size()>0){\n    cout << \"Evaluation\" << endl;\n    cout << \"==========\" << endl;\n    // Test the ML Model\n    Mat testPredict;\n    svm->predict(testDataMat, testPredict);\n    cout << \"Prediction Done\" << endl;\n    // Error calculation\n    Mat errorMat= testPredict!=testResponses;\n    float error= 100.0f * countNonZero(errorMat) /testResponsesData.size();\n    cout << \"Error: \" << error << \"\\%\" << endl;\n    // Plot training data with error label\n    plotTrainData(trainingDataMat, responses, &error);\n\n  }else{\n    plotTrainData(trainingDataMat, responses);\n  }\n}\n```", "```py\n  vector< float > trainingData;\n  vector< int > responsesData;\n  vector< float > testData;\n  vector< float > testResponsesData;\n```", "```py\n  int num_for_test= 20;\n  // Get the nut images\n  readFolderAndExtractFeatures(\"../data/nut/tuerca_%04d.pgm\", 0, num_for_test, trainingData, responsesData, testData, testResponsesData);\n  // Get and process the ring images\n  readFolderAndExtractFeatures(\"../data/ring/arandela_%04d.pgm\", 1, num_for_test, trainingData, responsesData, testData, testResponsesData);\n  // get and process the screw images\n  readFolderAndExtractFeatures(\"../data/screw/tornillo_%04d.pgm\", 2, num_for_test, trainingData, responsesData, testData, testResponsesData);\n```", "```py\nbool readFolderAndExtractFeatures(string folder, int label, int num_for_test, \n  vector<float> &trainingData, vector<int> &responsesData, \n  vector<float> &testData, vector<float> &testResponsesData)\n{\n  VideoCapture images;\n  if(images.open(folder)==false){\n    cout << \"Can not open the folder images\" << endl;\n    return false;\n  }\n  Mat frame;\n  int img_index=0;\n  while( images.read(frame) ){\n    //// Preprocess image\n    Mat pre= preprocessImage(frame);\n    // Extract features\n    vector< vector<float> > features= ExtractFeatures(pre);\n    for(int i=0; i< features.size(); i++){\n      if(img_index >= num_for_test){\n        trainingData.push_back(features[i][0]);\n        trainingData.push_back(features[i][1]);\n        responsesData.push_back(label);\n      }else{\n        testData.push_back(features[i][0]);\n        testData.push_back(features[i][1]);\n        testResponsesData.push_back((float)label);\n      }\n    }\n    img_index++;\n  }\n  return true;\n}\n```", "```py\n// Merge all data \n  Mat trainingDataMat(trainingData.size()/2, 2, CV_32FC1, &trainingData[0]);\n  Mat responses(responsesData.size(), 1, CV_32SC1, &responsesData[0]);\n  Mat testDataMat(testData.size()/2, 2, CV_32FC1, &testData[0]);\n  Mat testResponses(testResponsesData.size(), 1, CV_32FC1, &testResponsesData[0]);\n```", "```py\n// Set up SVM's parameters\n  svm = SVM::create();\nsvm->setType(SVM::C_SVC);\nsvm->setKernel(SVM::CHI2);\nsvm->setTermCriteria(TermCriteria(TermCriteria::MAX_ITER, 100, 1e-6));\n```", "```py\n  // Train the SVM\n  svm->train(trainingDataMat, ROW_SAMPLE, responses);\n```", "```py\nif(testResponsesData.size()>0){\n    cout << \"Evaluation\" << endl;\n    cout << \"==========\" << endl;\n    // Test the ML Model\n    Mat testPredict;\n    svm->predict(testDataMat, testPredict);\n    cout << \"Prediction Done\" << endl;\n    // Error calculation\n    Mat errorMat= testPredict!=testResponses;\n    float error= 100.0f * countNonZero(errorMat) / testResponsesData.size();\n    cout << \"Error: \" << error << \"\\%\" << endl;\n    // Plot training data with error label\n    plotTrainData(trainingDataMat, responses, &error);\n  }else{\n    plotTrainData(trainingDataMat, responses);\n  }\n```", "```py\n    Mat pre= preprocessImage(img);\n    ```", "```py\n    // Extract features\n      vector<int> pos_top, pos_left;\n      vector< vector<float> > features= ExtractFeatures(pre, &pos_left, &pos_top);\n    ```", "```py\n    for(int i=0; i< features.size(); i++){\n        Mat trainingDataMat(1, 2, CV_32FC1, &features[i][0]);\n    ```", "```py\n    float result= svm->predict(trainingDataMat);\n    ```", "```py\n    stringstream ss;\n        Scalar color;\n        if(result==0){\n          color= green; // NUT\n          ss << \"NUT\";\n        }\n        else if(result==1){\n          color= blue; // RING\n          ss << \"RING\" ;\n        }\n        else if(result==2){\n          color= red; // SCREW\n          ss << \"SCREW\";\n        }\n    ```", "```py\n    putText(img_output, \n          ss.str(), \n          Point2d(pos_left[i], pos_top[i]), \n          FONT_HERSHEY_SIMPLEX, \n          0.4, \n          color);\n    ```", "```py\n      miw->addImage(\"Binary image\", pre);\n      miw->addImage(\"Result\", img_output);\n      miw->render();\n      waitKey(0);\n    ```"]