- en: Using ML.NET with UWP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have established how to create a production-grade .NET Core console
    application, in this chapter, we will deep dive into creating a fully functional
    Windows 10 application with the **Universal Windows Platform** (**UWP**) framework.
    This application will utilize an ML.NET binary classification model to make web-page-content
    classifications, in order to determine if the content is benign or malicious.
    In addition, we will explore breaking your code into a component-based architecture,
    using a .NET Standard Library to share between our desktop application and the
    console application that will train our model. By the end of the chapter, you
    should have a firm grasp of designing and coding a production-grade UWP desktop
    application with ML.NET.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Breaking down the UWP application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the web browser classification application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring additional production-application enhancements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Breaking down the UWP architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At a high level, UWP provides an easy framework to create rich desktop applications
    for Windows 10\. As discussed, with .NET Core, UWP allows the targeting of x86,
    x64, and **Advanced RISC Machine** (**ARM**). At the time of this writing, ARM
    is not supported with ML.NET. In addition, UWP applications can also be written
    with JavaScript and HTML.
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical UWP desktop application includes the following core code elements:'
  prefs: []
  type: TYPE_NORMAL
- en: Views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: View Models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These components form a common app architecture principle of the **Model**-**View**-**ViewModel**,
    otherwise known as **MVVM**. In addition to the code components, images and audio
    are also common, depending on the nature of your application or game.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly to mobile apps on the Android and iOS platforms, each app is sandboxed
    to specific permissions that you, the developer, request upon installation. Therefore,
    as you develop your own UWP applications, request only the required access that
    your app absolutely requires.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the example application we will be creating in this chapter, we only require
    access to the internet as a client, as found in the Capabilities tab labeled Internet
    (Client), as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/44a90379-b974-4863-bdcd-8b030ad9a880.png)'
  prefs: []
  type: TYPE_IMG
- en: The Internet (Client) and other permissions are defined in the `Package.appxmanifest`file
    found in the root of UWP applications, under the Capabilities tab. This file is
    shown in the Visual Studio Solution Explorer screenshot in the later *Exploring
    the project architecture* section.
  prefs: []
  type: TYPE_NORMAL
- en: To prepare for our deep dive into integrating ML.NET in a UWP application, let's
    dive into the three core components found in a UWP application.
  prefs: []
  type: TYPE_NORMAL
- en: Views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Views, as we defined in the previous chapter's Blazor discussion, contain the
    **user interface** (**UI**) components of an application. Views in UWP development,
    such as those found in **Windows Presentation Foundation** (**WPF**) and Xamarin.Forms,
    use the **Extensible Application Markup Language** (**XAML**) syntax. Those familiar
    with modern web development with Bootstrap's Grid pattern will be able to quickly
    see the parallels as we deep dive into this later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The biggest differentiation between web development and UWP development is the
    powerful two-way binding XAML views when used with the MVVM principle. As you
    will see in the deep dive, XAML binding eliminates the manual setting and getting
    of values in code behinds, as you might have performed in Windows Forms or WebForms
    projects previously.
  prefs: []
  type: TYPE_NORMAL
- en: For applications using the web approach, HTML would define your View as with
    our Blazor project in [Chapter 9](5f67e3b8-56bd-47ab-8a72-4f00b239d517.xhtml), *Using
    ML.NET with ASP.NET Core*.
  prefs: []
  type: TYPE_NORMAL
- en: Models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Models provide the container of data between the View and View Model. Think
    of the Model as purely the transport for containing the data between the View
    and View Model. For example, if you had a movie list, a `List` collection of `MovieItems`
    would be defined in your `MovieListingModel` class. This container class would
    be instantiated and populated in the View Model, to be in turn bound in your View.
  prefs: []
  type: TYPE_NORMAL
- en: View Models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: View Models provide the business-logic layer for populating your Model, and
    thereby your View indirectly. As mentioned previously, the MVVM binding provided
    in UWP development eases the management of trigger points to ensure your UI layer
    is up to date. This is achieved through the use of implementing the `INotifyPropertyChanged`
    interface in our View Model. For each property that we want to bind to our UI,
    we simply call `OnPropertyChanged`. The power behind this is that you can have
    complex forms with triggers within the setter of other properties, without having
    conditionals and endless code to handle the complexities.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to deep dive further into UWP development, Channel9 from Microsoft
    has a series called *Windows 10 Development for Absolute Beginners* that covers
    all of the main aspects of UWP development: [https://channel9.msdn.com/Series/Windows-10-development-for-absolute-beginners](https://channel9.msdn.com/Series/Windows-10-development-for-absolute-beginners).
  prefs: []
  type: TYPE_NORMAL
- en: Creating the web browser classification application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned earlier, the application we will be creating is a web browser classification
    application. Using the knowledge garnered in the logistic classification chapter,
    we will be using the `SdcaLogisticRegression` algorithm to take the text content
    of a web page, featurize the text, and provide a confidence level of maliciousness.
    In addition, we will be integrating this technique into a Windows 10 UWP application
    that mimics a web browser—effectively on navigation to a page—running the model,
    and making a determination as to whether the page was malicious. If found to be
    malicious, we redirect to a warning page. While in a real-world scenario this
    might prove too slow to run on every page, the benefits of a highly secured web
    browser, depending on the environment requirements might far outweigh the slight
    overhead running our model incurs.
  prefs: []
  type: TYPE_NORMAL
- en: As with previous chapters, the completed project code, sample dataset, and project
    files can be downloaded from [https://github.com/PacktPublishing/Hands-On-Machine-Learning-With-ML.NET/tree/master/chapter10](https://github.com/PacktPublishing/Hands-On-Machine-Learning-With-ML.NET/tree/master/chapter10).
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the project architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With this chapter, we will dive into a native Windows 10 desktop application.
    As mentioned in the first section of this chapter, we will be using the UWP framework
    to create our application.
  prefs: []
  type: TYPE_NORMAL
- en: No additional ML.NET NuGet packages are needed for this sample application.
    However, we will be using the `HtmlAgilityPack` NuGet package to provide a quick
    method to extract the text from a given web page. At the time of this writing,
    version 1.11.18 was the latest version and is the version used in this example.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following screenshot, you will find the Visual Studio Solution Explorer
    view of the solution. Given that this example comprises three separate projects
    (more akin to a production scenario), the amount of both new and significantly
    modified files is quite large. We will review in detail each of the new files
    shown in the solution screenshot, later on in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a9b4c475-b490-47d3-a201-c424ef6a8d04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `sampledata.csv` file (found in the `Data` folder in the code repository)
    contains eight rows of extracted text from URLs found in the `trainingURLList.csv`
    file (also found in the `Data` folder). Feel free to adjust the URL list file
    to test websites you frequently visit. Here is a snippet of one such row:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to the `sampledata.csv` file, we also added the `testdata.csv` file
    that contains additional data points to test the newly trained model against and
    to evaluate. Here is a snippet of a sample row of the data inside of `testdata.csv`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Due to the size of the example project, we will be diving into the code for
    each of the different components before running the applications at the end of
    this section in the following order:'
  prefs: []
  type: TYPE_NORMAL
- en: .NET Standard Library for common code between the two applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Windows 10 UWP browser application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: .NET Core console application for feature extraction and training
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Diving into the library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Due to the nature of this application and that of production applications where
    there are multiple platforms and/or ways to execute shared code, a library is
    being used in this chapter's example application. The benefit of using a library
    is that all common code can reside in a portable and dependency-free manner. Expanding
    the functionality in this sample application to include other platforms such as
    Linux or Mac applications with Xamarin would be a much easier lift than having
    the code either duplicated or kept in the actual applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Classes and enumerations that were changed or added in the library are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Constants`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WebPageResponseItem`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Converters`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ExtensionMethods`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WebPageInputItem`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WebPagePredictionItem`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WebContentFeatureExtractor`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WebContentPredictor`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WebContentTrainer`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Classification`, `TrainerActions`,and `BaseML `classes remain unmodified
    from [Chapter 9](5f67e3b8-56bd-47ab-8a72-4f00b239d517.xhtml), *Using ML.NET with
    ASP.NET Core*.
  prefs: []
  type: TYPE_NORMAL
- en: The Constants class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Constants` class, as used in all of our examples to this point, is the
    common class that contains our constant values used in our library, trainer, and
    UWP applications. For this chapter, the `MODEL_NAME` and `MALICIOUS_THRESHOLD`
    properties were added to hold our model''s name and an arbitrary threshold for
    when we should decide to classify our prediction as malicious or not, respectively.
    If you find your model too sensitive, try adjusting this threshold, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The WebPageResponseItem class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `WebPageResponseItem` class is our container class between our predictor
    and application. This class contains the properties we set after running the predictor
    and then use to display in our desktop application, as shown in the following
    code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The Converters class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Converters` class has been adjusted to provide an extension method to
    convert our container class into the type our model expects. In this example,
    we have the `Content` property, which simply maps to the `HTMLContent` variable
    in the `WebPageInputItem` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The ExtensionMethods class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `ExtensionMethods` class, as discussed previously in [Chapter 9](5f67e3b8-56bd-47ab-8a72-4f00b239d517.xhtml),
    *Using ML.NET with ASP.NET Core*, has been expanded to include the `ToWebContentString`
    extension method. In this method, we pass in the URL from which we want to retrieve
    the web content. Using the previously mentioned `HtmlAgilityPack`, we create an `HtmlWeb`
    object and call the `Load`method, prior to iterating through the **Document Object
    Model** (**DOM**). Given most websites have extensive scripts and style sheets,
    our purpose in this example is just to examine the text in the page, thus the
    filters of script and style nodes in our code. Once the nodes have been traversed
    and added to a `StringBuilder` object, we return the typecast of that object to
    a string, as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The WebPageInputItem class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `WebPageInputItem` class is our input object to our model, containing both
    the label and extracted content of our web page, as shown in the following code
    block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The WebPagePredictionItem class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `WebPagePredictionItem` class is the output object from our model, containing
    the prediction of whether a web page is malicious or benign, in addition to a
    probability score that the prediction is accurate and the `Score` value used in
    the evaluation phase of our model creation, as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The WebContentFeatureExtractor class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `WebContentFeatureExtractor` class contains our `GetContentFile` and `Extract`
    methods, which operate as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, our `GetContentFile` method takes the `inputFile` and `outputFile` values
    (the URL list CSV and feature-extracted CSV respectively). It then reads each
    URL, grabs the content, then outputs to the `outputFile` string, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we use the `Extract` method to call both the training and test extraction,
    passing in the output filenames for both, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The WebContentPredictor class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `WebContentPredictor` class provides the interface for both our command
    line and desktop applications, using an overloaded `Predict` method, described
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first `Predict` method is for our command-line application that simply
    takes in the URL and calls into the overload in *Step 3*, after calling the `ToWebContentString`
    extension method, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we create the `Initialize` method, in which we load our model from the
    embedded resource. If successful, the method returns `true`; otherwise, it returns
    `false`, as shown in the following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, we call our `Predict` method that creates our prediction engine.
    Then, we call the predictor''s `Predict` method, and then update the `Confidence`
    and `IsMalicious` properties, prior to returning the updated `WebPageResponseItem`
    object, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The WebContentTrainer class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `WebContentTrainer`class contains all of the code to train and evaluate
    our model. As with previous examples, this functionality is self-contained within
    one method called `Train`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first change is the use of the `WebPageInputItem` class to read the CSV
    into the `dataView` object separated by `|`, as shown in the following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we map our file data features to create our pipeline. In this example,
    we simply featurize the `HTMLContent` property and pass it to the `SdcaLogisticRegression`
    trainer, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we fit the model, and save the model to disk, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we load in the testing file, and call the `BinaryClassification` evaluation,
    like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Diving into the UWP browser application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the library code having been reviewed, the next component is the desktop
    application. As discussed in the opening section, our desktop application is a
    UWP application. For the scope of this example, we are using standard approaches
    for handling the application architecture, following the MVVM approach discussed
    in the opening section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The files we will be diving into in this section are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`MainPageViewModel`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MainPage.xaml`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MainPage.xaml.cs`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The rest of the files inside the UWP project, such as the tile images and app
    class files, are untouched from the default Visual Studio UWP application template.
  prefs: []
  type: TYPE_NORMAL
- en: The MainPageViewModel class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The purpose of the `MainPageViewModel` class is to contain our business logic
    and control the View:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we do is instantiate our previously discussed `WebContentPredictor`
    class to be used to run predictions, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The next block of code handles the power of MVVM for our **GO** button, the
    web service URL field, and the web classification properties. For each of these
    properties, we call `OnPropertyChanged` upon a change in values, which triggers
    the binding of the View to refresh for any field bound to these properties, as
    shown in the following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we define the `Initialize` method, which calls the predictor''s `Initialize`
    method. The method will return false if the model can''t be loaded or found, as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we take the entered URL the user entered via the `WebServiceURL` property.
    From that value, we validate that either `http` or `https` is prefixed. If not,
    `http://` is prefixed to the URL prior to converting it to a URI, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, onto our `Classify` method that takes the URL entered from the user. This
    method calls our `Predict` method, builds our status bar text, and, if found to
    be malicious, builds the HTML response to send back to our `WebView` object, as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'And lastly, we implement the `OnPropertyChanged` event handler and method that
    are the standard implementations of the `INotifyPropertyChanged` interface, as
    discussed in the opening section of this chapter and shown in the following code
    block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: MainPage.xaml
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As discussed in the opening section describing UWP development, XAML markup
    is used to define your UI. For the scope of this application, our UI is relatively
    simple:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we define is our `Grid`. In XAML, a `Grid` is a container similar
    to a `div` element in web development. We then define our Rows. Similar to Bootstrap,
    (but easier to understand, in my opinion) is to pre-define the height of each
    row. Setting a row to `Auto` will auto-size the height to the content''s height,
    while an asterisk translates to using all remaining height based on the main container''s
    height, as shown in the following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to the row definitions in *Step 1*, we pre-define columns. `"Auto"`
    and `"*"` equate to the same principle as they did for the rows, just in regard
    to width instead of height, as shown in the following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We then define our `TextBox` object for the URL entry. Note the `Binding`call
    in the `Text` value. This binds the textbox''s text field to the `WebServiceURL`
    property in our View Model, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we add the button to mimic a browser''s **GO** button, which triggers
    the navigation. Also, note the use of `Binding` to enable or disable the button
    itself (which is bound based on text being entered into the URL textbox), as shown
    in the following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We then add the `WebView` control that comes with UWP, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we add our status bar grid and `TextBlock` control to show the classification
    along the bottom of the window, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: MainPage.xaml.cs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `MainPage.xaml.cs` file contains the code behind the XAML view discussed
    previously:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we define is a wrapper property around the `DataContext` property
    built into the base `Page` class, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we define the constructor for `MainPage` to initialize the `DataContext`
    to our `MainPageViewModel` object, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We then override the base `OnNavigatedTo` method to initialize our View Model,
    and validate the model was loaded properly, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we add our `ShowMessage` wrapper to provide an easy one-liner to call
    throughout our application, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we handle the **GO** button click by calling the `Navigate` method, as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We then create our `Navigate` wrapper method, which builds the URI and passes
    it to the `WebView` object, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We also want to handle the keyboard input to listen for the user hitting the
    *Enter* key after entering a URL, to provide the user with the ability to either
    hit *Enter* or click the **GO** button, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we block navigation until a classification can be obtained by hooking
    into the WebView''s `OnNavigationStarting` event, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Diving into the trainer application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have reviewed the shared library and the desktop application, let
    us dive into the trainer application. With the major architectural changes being
    performed in Chapter 8's example, by design the trainer application has only minimal
    changes to handle the specific class objects used in this chapter's example.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will review the following files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ProgramArguments`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Program`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ProgramArguments class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Building off the work in Chapter 9''s `ProgramArguments` class, we are only
    making three additions to the class. The first two additions are to include both
    the `Training` and `Testing` output filenames to provide better flexibility with
    our example''s infrastructure. In addition, the `URL` property holds the URL you
    can pass, using the command line, into the trainer application to get a prediction,
    as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The Program class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Inside the `Program` class, we will now modify the `switch case` statement
    to use the classes/methods from [Chapter 10](9c105516-7e4f-4f99-b70f-8b0d6165d8c5.xhtml),
    *Using ML.NET with UWP*, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Running the trainer application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To begin running the trainer application, we will need to first run the `chapter10.trainer` application
    to perform feature extraction prior to the training of our model. To run the trainer
    application, the process is nearly identical to Chapter 9''s sample application,
    with the addition of passing in the test dataset filename path when training:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the trainer application, passing in the paths to the training and test
    URL list CSVs to perform feature extraction, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the application to train the model, based on *Step 1*''s sample and test
    data exports, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Feel free to modify the values and see how the prediction changes, based on
    the dataset on which the model was trained. A few areas of experimentation from
    this point might be to:'
  prefs: []
  type: TYPE_NORMAL
- en: Tweak the hyperparameters reviewed in the `Trainer` class on the **Stochastic
    Dual Coordinate Ascent** (**SDCA**) algorithm, such as `MaximumNumberOfIterations`,
    to see how accuracy is affected.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add new features in addition to simply using the HTML content—perhaps the connection
    type or the number of scripts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add more variation to the training and sample set to get a better sampling of
    both benign and malicious content.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For convenience, the GitHub repository includes all of the following data files
    in the `Data` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: The `testdata.csv` and `sampledata.csv` feature-extracted CSV files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `testingURLList.csv` and `trainingURLList.csv` URL list CSV files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running the browser application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that our model has been trained, we can run our desktop application and
    test the efficacy of the model. To run the example, make sure the `chapter10_app`
    is the startup app and hit *F5*. Upon launching our browser application, enter
    `www.google.com`, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9ea1a926-8764-4ea7-a41e-9c20058c0a4d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Note the status bar below the web page content in the preceding screenshot,
    indicating the malicious percentage after running the model. Next, type `dasmalwerk.eu`
    into your browser (this is a website that the default training URL list pre-classified
    as malicious), and note the forced redirect, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a1a7ca8d-2f87-4670-93be-a9ade98ee292.png)'
  prefs: []
  type: TYPE_IMG
- en: Feel free to try various files on your machine to see the confidence score,
    and if you receive a false positive, perhaps add additional features to the model
    to correct the classification.
  prefs: []
  type: TYPE_NORMAL
- en: Additional ideas for improvements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have completed our deep dive, there are a couple of additional elements
    to possibly further enhance the application. A few ideas are discussed here.
  prefs: []
  type: TYPE_NORMAL
- en: Single-download optimization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Currently, when a new URL is entered or the page is changed in the `WebView`
    UWP control, the navigation is halted until a classification can be made. When
    this occurs—as we detailed previously—with the use of the `HtmlAgilityPack` library,
    we download and extract the text. If the page is deemed to be clean (as one would
    more than likely encounter the majority of the time), we would effectively be
    downloading the content twice. An optimization here would be to store the text
    in the application's sandbox storage once classification is done, then point the
    `WebView` object to that stored content. In addition, if this approach is used,
    add a purge background worker to remove older data so that your end users don't
    end up with several gigabytes of web page content.
  prefs: []
  type: TYPE_NORMAL
- en: Logging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with our previous chapter's deep dive into logging, adding logging could
    be crucial to remotely understand when an error occurs on a desktop application.
    Unlike our web application in the previous chapter, where your errors would be
    more than likely server-side and could be accessed remotely, your desktop application
    could be installed on any number of configurations of Windows 10, with an almost
    unlimited number of permutations. As mentioned previously, logging utilizing NLog ([https://nlog-project.org/](https://nlog-project.org/))
    or a similar open source project is highly recommended, coupled with a remote
    logging solution such as Loggly so that you can get error data from your user's
    machines. Given the **General Data Protection Regulation** (**GDPR**) and the
    recent **California Consumer Privacy Act** (**CCPA**), ensure that the fact this
    data is leaving the end user's machines is conveyed, and do not include personal
    data in these logs.
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing a database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Users typically visit the same websites fairly frequently, therefore storing
    the classification of a particular website's URL in a local database such as LiteDB
    ([http://www.litedb.org/](http://www.litedb.org/)) would significantly improve
    the performance for the end user. One implementation method would be to store
    a SHA256 hash of the URL locally as the key, with the classification as the value.
    Longer term, you could provide a web URL reputation database, with the SHA256
    hash of the URL being sent up to a scalable cloud storage solution such as Microsoft's
    Cosmos DB. Storing the SHA256 hash of the URL avoids any questions from your end
    users about personally identifiable information and anonymity.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Over the course of this chapter, we have deep dived into what goes into a production-ready
    Windows 10 UWP application architecture, using the work performed in previous
    chapters as a foundation. We also created a brand new web-page-classification
    Windows 10 application, utilizing the `SdcaLogisticRegression` algorithm from
    ML.NET. Lastly, we also discussed some ways to further enhance the example application
    (and production applications in general).
  prefs: []
  type: TYPE_NORMAL
- en: With the conclusion of this chapter, this ends the real-world application section.
    The next section of the book includes both general machine learning practices
    in an agile production team and extending ML.NET with TensorFlow and **Open Neural
    Network Exchange** (**ONNX**) models. In the next chapter, we will focus on the
    former.
  prefs: []
  type: TYPE_NORMAL
