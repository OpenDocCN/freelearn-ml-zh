<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Setting Up the Wiki Game</h1>
                </header>
            
            <article>
                
<p class="calibre2">I hope you're excited about Julia by now. The friendly, expressive, and intuitive syntax, the powerful <strong class="calibre4">read-eval-print loop</strong> (<strong class="calibre4">REPL</strong>), the great performance, and the richness of both built-in and third-party libraries are a game-changing combination for data science in particular—and programming in general. The fact that in just two introductory chapters we were able to grasp the basics of the language and configure a data science setup powerful enough to analyze the Iris dataset is quite amazing—congratulations, we've done a great job!</p>
<p class="calibre2">But we are literally just starting. The foundation we've laid is now strong enough to allow us to develop pretty much any kind of program using Julia. Hard to believe? Well, here's the proof—in the next three chapters, we'll develop a web-based game with Julia!</p>
<p class="calibre2">It will follow the narrative of the internet-famous <em class="calibre16">Six Degrees of Wikipedia</em>. If you've never heard of it, the idea is that any two articles on Wikipedia can be connected, using only the links on the pages, in six clicks or fewer. It is also called <strong class="calibre4">six degrees of separation</strong>.</p>
<p class="calibre2">In case you're wondering what this has to do with Julia, it is a playful excuse to learn about data mining and web scraping and to learn more about the language and apply our newly acquired knowledge to build a web app.</p>
<p class="calibre2">In this chapter, we will lay the foundations of the web scraper. We'll take a look at how requests are made over the web in a client-server architecture and how to use the <kbd class="calibre12">HTTP</kbd> package to fetch web pages. We'll learn about HTML documents, HTML and CSS selectors, and <kbd class="calibre12">Gumbo</kbd>, a HTML parser for Julia. In the process, we'll experiment with more code in the REPL and we'll learn about other key features of the language, such as dictionaries, error handling, functions, and conditional statements. We'll also get to set up our first Julia project.</p>
<p class="calibre2">The topics we will cover in this chapter include the following:</p>
<ul class="calibre10">
<li class="calibre11">What web scraping is and how it is used for data harvesting</li>
<li class="calibre11">How to use Julia to make requests and fetch web pages</li>
<li class="calibre11">Understanding the <kbd class="calibre12">Pair</kbd> type</li>
<li class="calibre11">Learning about the dictionary, one of Julia's more versatile data structures</li>
<li class="calibre11">Exception handling, to help us capture errors in our code</li>
<li class="calibre11">Functions, the basic building blocks and one of the most important code units in Julia—we'll learn how to define and use them to create reusable, modular code</li>
<li class="calibre11">A handful of useful Julia tricks, such as the pipe operator and short-circuit evaluation</li>
<li class="calibre11">Setting up a Julia project using <kbd class="calibre12">Pkg</kbd></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p class="calibre2">The Julia package ecosystem is under continuous development and new package versions are released on a daily basis. Most of the times this is great news, as new releases bring new features and bug fixes. However, since many of the packages are still in beta (version 0.x), any new release can introduce breaking changes. As a result, the code presented in the book can stop working. In order to ensure that your code will produce the same results as described in the book, it is recommended to use the same package versions. Here are the external packages used in this chapter and their specific versions:</p>
<pre class="calibre17">Gumbo@v0.5.1<br class="title-page-name"/>HTTP@v0.7.1<br class="title-page-name"/>IJulia@v1.14.1<br class="title-page-name"/>OrderedCollections@v1.0.2</pre>
<p class="calibre2">In order to install a specific version of a package you need to run:</p>
<pre class="calibre17"><strong class="calibre1">pkg&gt; add PackageName@vX.Y.Z</strong> </pre>
<p class="calibre2">For example:</p>
<pre class="calibre17"><strong class="calibre1">pkg&gt; add IJulia@v1.14.1</strong></pre>
<p class="calibre2">Alternatively you can install all the used packages by downloading the <kbd class="calibre12">Project.toml</kbd> file provided with the chapter and using <kbd class="calibre12">pkg&gt;</kbd> instantiate as follows:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; download("https://raw.githubusercontent.com/PacktPublishing/Julia-Programming-Projects/master/Chapter03/Project.toml", "Project.toml")</strong><br class="title-page-name"/><strong class="calibre1">pkg&gt; activate . </strong><br class="title-page-name"/><strong class="calibre1">pkg&gt; instantiate</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Data harvesting through web scraping</h1>
                </header>
            
            <article>
                
<p class="calibre2">The technique for extracting data from web pages using software is called <strong class="calibre4">web scraping</strong>. It is an important component of data harvesting, typically implemented through programs called <strong class="calibre4">web crawlers</strong>. Data harvesting or data mining is a useful technique, often used in data science workflows to collect information from the internet, usually from websites (as opposed to APIs), and then to process that data for different purposes using various algorithms. </p>
<p class="calibre2">At a very high level, the process involves making a request for a web page, fetching its content, parsing its structure, and then extracting the desired information. This can be images, paragraphs of text, or tabular data containing stock information and prices, for example—pretty much anything that is present on a web page. If the content is spread across multiple web pages, the crawler will also extract the links and will automatically follow them to pull the rest of the pages, repeatedly applying the same crawling process.</p>
<p class="calibre2">The most common use of web scrapers is for web indexing, as done by search engines such as Google or Bing. Online price monitoring and price comparison, personal data mining (or contact scraping), and online reputation systems, as well as product review platforms, represent other common use cases for web scrapers.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How the web works – a crash course</h1>
                </header>
            
            <article>
                
<p class="calibre2">The internet has become an integral part of our lives over the last decade. Most of us use it extensively to access a wealth of information, day in and day out. Googling things like rambunctious (noisy and lacking in restraint or discipline), catching up with friends on social networks, checking out the latest gourmet restaurants on Instagram, watching a blockbuster on Netflix, or reading the Wikipedia entry about Attitogon (a place in Togo where they practice voodoo)—they're all just a click away. All these, although different in nature, function in pretty much the same way.</p>
<p class="calibre2">An internet-connected device, be it a computer using Wi-Fi or a smartphone connected to a mobile data network, together with an app for accessing the web (generally a web browser such as Chrome or Firefox, but also a dedicated one such as Facebook or Netflix's mobile apps), represent <em class="calibre16">the client</em>. At the other end we have <em class="calibre16">the server—</em>a computer that stores the information, be it in the form of web pages, videos, or entire web apps.</p>
<p class="calibre2">When a client wants to access the information available on the server, it initiates a <em class="calibre16">request</em>. If the server determines that the client has the permission to access the resource, a copy of the information is downloaded from the server onto the client, to be displayed.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Making HTTP requests</h1>
                </header>
            
            <article>
                
<p class="calibre2">The <strong class="calibre4">Hypertext Transfer Protocol</strong> (<strong class="calibre4"><span class="calibre5">HTTP</span></strong>) is a communication protocol for transmitting documents over a network. It was designed for communication between web browsers and web servers. HTTP implements the standard client-server model, where a client opens a connection and makes a request, then waits for a response.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Learning about HTTP methods</h1>
                </header>
            
            <article>
                
<p class="calibre2">HTTP defines a set of request methods to indicate the action to be performed for a given resource. The most common method is <kbd class="calibre12">GET</kbd>, which is meant to retrieve data from the server. It is used when navigating the internet using links. The <kbd class="calibre12">POST</kbd> method requests the server to accept an enclosed data payload, most commonly the result of submitting a web form. There are a few more methods, including <kbd class="calibre12">HEAD</kbd>, <kbd class="calibre12">PUT</kbd>, <kbd class="calibre12">DELETE</kbd>, <kbd class="calibre12">PATCH</kbd>, and others—but they are less used and less supported by clients and web servers. As we won't need them for our web crawler, they won't be covered.</p>
<div class="packttip">If you're interested, you can read about them at <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods" class="calibre19"><span>https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods</span></a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding HTTPS</h1>
                </header>
            
            <article>
                
<p class="calibre2"><strong class="calibre4">HTTP Secure</strong> (<strong class="calibre4"><span class="calibre5">HTTPS</span></strong>) is basically HTTP over an encrypted connection. It started as an alternative protocol used primarily for processing payments over the web and transferring sensitive corporate information. But in recent years, it has begun to see widespread usage, with a push from major companies to replace plain HTTP connections on the internet. For the purpose of our discussion, HTTP and HTTPS can be used interchangeably.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding HTML documents</h1>
                </header>
            
            <article>
                
<p class="calibre2">In order to extract data from the fetched web pages, we need to isolate and manipulate the structural elements that contain the desired information. That's why a basic understanding of the generic structure of the web pages is helpful when performing web scraping. If you've done web scraping before, maybe using a different programming language, or if you just know enough about HTML documents, feel free to skip this section. On the other hand, if you're new to this or just need a quick refresher, please read on.</p>
<p class="calibre2"><strong class="calibre4">Hypertext Markup Language </strong>(<strong class="calibre4">HTML</strong>) is the gold standard for creating web pages and web applications. HTML goes hand in hand with HTTP, the protocol for transmitting HTML documents over the internet.</p>
<p class="calibre2">The building blocks of HTML pages are the <em class="calibre16">HTML elements</em>. They provide both the content and the structure of a web page. They can be nested to define complex relationships with each other (such as parents, children, siblings, ancestors, and so on). HTML elements are denoted by <em class="calibre16">tags</em>, written between angle brackets (<kbd class="calibre12">&lt;tag&gt;...&lt;/tag&gt;</kbd>). The official W3C specification defines a wealth of such tags, representing everything from headings and paragraphs, to lists, forms, links, images, quotes, and much more.</p>
<p class="calibre2">To give you an idea, here's how the main heading is represented in HTML on Julia's Wikipedia page at <a href="https://en.wikipedia.org/wiki/Julia_(programming_language)" class="calibre9"><span>https://en.wikipedia.org/wiki/Julia_(programming_language)</span></a>:</p>
<pre class="calibre17">&lt;h1&gt;Julia (programming language)&lt;/h1&gt; </pre>
<p class="calibre2">This HTML code renders in a modern browser, like this:</p>
<p class="CDPAlignCenter"><img src="assets/f6a9965d-2c15-4643-bd33-f82a58f07ae4.png" class="calibre45"/></p>
<p class="calibre2">A more elaborate example can present a nested structure such as the following:</p>
<pre class="calibre17">&lt;div&gt; 
    &lt;h2&gt;Language features&lt;/h2&gt; 
    &lt;p&gt;According to the official website, the main features of the language are:&lt;/p&gt; 
    &lt;ul&gt; 
           &lt;li&gt;Multiple dispatch&lt;/li&gt; 
           &lt;li&gt;Dynamic type sytem&lt;/li&gt; 
           &lt;li&gt;Good performance&lt;/li&gt; 
    &lt;/ul&gt; 
&lt;/div&gt; </pre>
<p class="calibre2">The snippet renders a secondary heading (<kbd class="calibre12">&lt;h2&gt;</kbd>), a paragraph of text (<kbd class="calibre12">&lt;p&gt;</kbd>), and an unordered list (<kbd class="calibre12">&lt;ul&gt;</kbd>), with three list items (<kbd class="calibre12">&lt;li&gt;</kbd>), all within a page section (<kbd class="calibre12">&lt;div&gt;</kbd>):</p>
<p class="CDPAlignCenter"><img src="assets/651176fc-fa07-42b3-84e8-e8926b7e6d81.png" class="calibre46"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">HTML selectors</h1>
                </header>
            
            <article>
                
<p class="calibre2">HTML's purpose is to provide content and structure. That's all we need in order to convey any kind of information, no matter how complex. However, as computers and web browsers became more powerful and the use of web pages more widespread, users and developers wanted more. They asked for ways to extend HTML to also include beautiful formatting (design) and rich behavior (interactivity).</p>
<p class="calibre2">That is why <strong class="calibre4">Cascading Style Sheets </strong>(<strong class="calibre4">CSS</strong>) was created—a style language that defines the design of HTML documents. Additionally, JavaScript emerged as the programming language of choice for the client side, adding interactivity to web pages.</p>
<p class="calibre2">The style rules and the interactive features provided by CSS and JavaScript are associated with well-defined HTML elements. That is, styling and interactivity have to explicitly target elements from the associated HTML document. For example, a CSS rule can target the main heading of the page—or a JavaScript validation rule can target text input in the login form. If you think of a web page as a structured collection of HTML elements, this targeting is achieved by <em class="calibre16">selecting</em> (sub-collections of) elements.</p>
<p class="calibre2">Selecting elements can be done, in its simplest form, by identifying the HTML tags by type and structure (hierarchy). In the previous example, where we looked at representing a list of Julia's features, we can select all the list items (the <kbd class="calibre12">&lt;li&gt;</kbd> elements) by indicating a hierarchy like <kbd class="calibre12">div &gt; ul &gt; li</kbd>, representing all the <kbd class="calibre12">li</kbd> items, nested within a <kbd class="calibre12">ul</kbd> element, nested within a <kbd class="calibre12">div</kbd>. These are called <strong class="calibre4">HTML selectors</strong>.</p>
<p class="calibre2">However, this approach has limitations. On the one hand, when dealing with large, complex, and deeply nested HTML documents, we have to handle equally complex hierarchies, a tedious and error-prone task. On the other hand, such an approach might not provide enough specificity to allow us to select the element we want to target. For example, on the same Julia Wikipedia page, how would we differentiate the list of features from the list of external links? They both have similar structures.</p>
<p class="calibre2">The list of <strong class="calibre4">External links</strong> on Julia's Wikipedia page looks like this:</p>
<p class="CDPAlignCenter"><img src="assets/d619d904-331b-4876-829a-c4fda798db99.png" class="calibre47"/></p>
<p class="calibre2">The <strong class="calibre4">Language features</strong> section has a similar structure:</p>
<p class="CDPAlignCenter"><img src="assets/fd81a3ab-09e3-4adb-aa2a-1b209715d3b1.png" class="calibre48"/></p>
<p class="calibre2">The fact that the two HTML elements are structurally identical makes it difficult to select the list items for the language features alone.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Learning about the HTML attributes</h1>
                </header>
            
            <article>
                
<p class="calibre2">This is where HTML attributes come into play. These are key-value pairs that enhance HTML tags, providing extra information. For example, in order to define a link, we're going to use the <kbd class="calibre12">&lt;a&gt;</kbd> tag—<kbd class="calibre12">&lt;a&gt;This is a link&lt;/a&gt;</kbd>.</p>
<p class="calibre2">But clearly, this is not enough. If this is a link, what does it link to? As developers, we need to provide extra information about the linked location. This is done by adding the <kbd class="calibre12">href</kbd> attribute with its corresponding value:</p>
<pre class="calibre17">&lt;a <strong class="calibre1">href="https://julialang.org/"</strong>&gt;This is a link to Julia's home page&lt;/a&gt;</pre>
<p class="calibre2">Ah yes, now we're talking! A super handy link to Julia's home page.</p>
<p class="calibre2">In general, all the attributes can be used when selecting HTML elements. But not all of them are equally useful. The most important one is arguably the <kbd class="calibre12">id</kbd> attribute. It allows us to assign a unique identifier to an element and then reference it in a very efficient way. Another important attribute is the <kbd class="calibre12">class</kbd>, extensively used for CSS styling rules.</p>
<p class="calibre2">This is what our previous example would look like with extra attributes:</p>
<pre class="calibre17">&lt;a href="https://julialang.org/" <strong class="calibre1">id="julia_link"</strong> <strong class="calibre1">class="external_link"</strong>&gt;This is a link to Julia's home page&lt;/a&gt;</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Learning about CSS and JavaScript selectors</h1>
                </header>
            
            <article>
                
<p class="calibre2">Historically, JavaScript started off using selectors based on the <kbd class="calibre12">id</kbd> attribute and the names of the HTML elements (the tags). Later on, the CSS specification came with a more powerful set of selectors, employing not only the <kbd class="calibre12">class</kbd>, the <kbd class="calibre12">id</kbd>, and the tags, but also the presence of attributes and their values, states of the elements (such as <kbd class="calibre12">focused</kbd> or <kbd class="calibre12">disabled</kbd>), and more specific element hierarchies that take into account relationships.</p>
<p class="calibre2">Here are a few examples of CSS selectors that can be used to target the previously discussed <kbd class="calibre12">&lt;a&gt;</kbd> tag:</p>
<ul class="calibre10">
<li class="calibre11"><kbd class="calibre12">#julia_link</kbd> is the selector for the <kbd class="calibre12">id</kbd> attribute (the <kbd class="calibre12">#</kbd>)</li>
<li class="calibre11"><kbd class="calibre12">.external_link</kbd> is the selector for the <kbd class="calibre12">class</kbd> attribute (the <kbd class="calibre12">.</kbd>)</li>
<li class="calibre11"><kbd class="calibre12">a</kbd> is the selector for the <kbd class="calibre12">&lt;a&gt;</kbd> tag</li>
<li class="calibre11"><kbd class="calibre12">a[href*="julialang.org"]</kbd> will select all the <kbd class="calibre12">&lt;a&gt;</kbd> tags with a <kbd class="calibre12">href</kbd> attribute that contains <kbd class="calibre12">"julialang.org"</kbd></li>
</ul>
<div class="packttip">You can read more about CSS selectors at <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors" class="calibre19"><span>https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors</span></a>. It's worth keeping this resource close as web scraping relies heavily on CSS selectors, as we'll see in the next chapter.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding the structure of a link</h1>
                </header>
            
            <article>
                
<p class="calibre2">Links, in technical lingo called <strong class="calibre4">Uniform Resource Locators</strong> (<strong class="calibre4">URLs</strong>), are strings of characters that uniquely identify a resource on the internet. They are informally known as <strong class="calibre4">web addresses</strong>. Sometimes you might see them called <strong class="calibre4">Uniform Resource Identifiers</strong> (<strong class="calibre4">URIs</strong>).</p>
<p class="calibre2">In our previous example, Julia's Wikipedia web page was accessible at the URL <a href="https://en.wikipedia.org/wiki/Julia_(programming_language)" class="calibre9"><span>https://en.wikipedia.org/wiki/Julia_(programming_language)</span></a>. This URL refers to the resource <kbd class="calibre12">/wiki/Julia_(programming_language)</kbd> whose representation, as a HTML document, can be requested via the HTTPS protocol (<kbd class="calibre12">https:</kbd>) from a network host whose domain name is <kbd class="calibre12">wikipedia.org</kbd>. (Wow, that's a mouthful, but now you can understand how complex the process of requesting a web page on the internet is).</p>
<p class="calibre2">Thus, a common URL can be broken down into the following parts—<kbd class="calibre12">scheme://host/path?query#fragment</kbd>.</p>
<p class="calibre2">For example, if we take a look at <a href="https://en.wikipedia.org/wiki/Julia_(programming_language)?uselang=en#Interaction" class="calibre9">https://en.wikipedia.org/wiki/Julia_(programming_language)?uselang=en#Interaction</a>, we have <kbd class="calibre12">https</kbd> as the <kbd class="calibre12">scheme</kbd>, <kbd class="calibre12">en.wikipedia.org</kbd> as the <kbd class="calibre12">host</kbd>, <kbd class="calibre12">/wiki/Julia_(programming_language)</kbd> as the <kbd class="calibre12">path</kbd>, <kbd class="calibre12">?uselang=en</kbd> as the <kbd class="calibre12">query</kbd>, and, finally, <kbd class="calibre12">#Interaction</kbd> as the <kbd class="calibre12">fragment</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Accessing the internet from Julia</h1>
                </header>
            
            <article>
                
<p class="calibre2">Now that you have a good understanding of how web pages are accessed on the internet through client-server interactions, let's see how we can do this with Julia.</p>
<p class="calibre2">The most common web clients are the web browsers—apps such as Chrome or Firefox. However, these are meant to be used by human users, rendering web pages with fancy styled UIs and sophisticated interactions. Web scraping can be done manually through a web browser, it's true, but the most efficient and scalable way is through a fully automated, software-driven process. Although web browsers can be automated (with something like Selenium from <a href="https://www.seleniumhq.org" target="_blank" class="calibre9"><span>https://www.seleniumhq.org</span></a>), it's a more difficult, error-prone, and resource-intensive task. For most use cases, the preferred approach is to use a dedicated HTTP client.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Making requests with the HTTP package</h1>
                </header>
            
            <article>
                
<p class="calibre2"><kbd class="calibre12">Pkg</kbd>, Julia's built-in package manager, provides access to the excellent <kbd class="calibre12">HTTP</kbd> package. It exposes a powerful functionality for building web clients and servers—and we'll use it extensively.</p>
<p class="calibre2">As you're already accustomed to, extra functionality is only two commands away—<kbd class="calibre12">pkg&gt; add HTTP</kbd> and <kbd class="calibre12">julia&gt; using HTTP</kbd>.</p>
<p class="calibre2">Recall our discussion about HTTP methods from the previous section; the most important ones were <kbd class="calibre12">GET</kbd>, used to ask for a resource from the server, and <kbd class="calibre12">POST</kbd>, which sends a data payload to the server and accepts the response. The <kbd class="calibre12">HTTP</kbd> package exposes a matching set of functions—we get access to <kbd class="calibre12">HTTP.get</kbd>, <kbd class="calibre12">HTTP.post</kbd>, <kbd class="calibre12">HTTP.delete</kbd>, <kbd class="calibre12">HTTP.put</kbd>, and so on.</p>
<p class="calibre2">Let's say we want to request Julia's Wikipedia page. All we need is the page's URL and the <kbd class="calibre12">HTTP.get</kbd> method:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; HTTP.get("https://en.wikipedia.org/wiki/Julia_(programming_language)")</strong> </pre>
<p class="calibre2">The result will be a <kbd class="calibre12">Response</kbd> object that represents Julia's Wikipedia page in all its glory. The REPL displays the headers and the first lines of the response body, truncating the rest:</p>
<p class="CDPAlignCenter"><img src="assets/40970dc4-f4d3-409d-bccf-6a67b91a9cc1.png" class="calibre49"/></p>
<p class="calibre2">The screenshot shows the details of the <kbd class="calibre12">HTTP.Messages.Response</kbd> object we received—the list of HTTP headers and the first part of the response body. Let's make sure we keep it in a variable so we can reference it later. Remember that Julia provisionally stores the result of the last computation in the <kbd class="calibre12">ans</kbd> REPL variable, so let's pick it up from there:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; resp = ans</strong> </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Handling HTTP responses</h1>
                </header>
            
            <article>
                
<p class="calibre2">After receiving and processing a request, the server sends back a HTTP response message. These messages have a standardized structure. They contain a wealth of information, with the most important pieces being the status code, the headers, and the body.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">HTTP status codes</h1>
                </header>
            
            <article>
                
<p class="calibre2">The status code is a three-digit integer where the first digit represents the category, while the next two digits are used to define the subcategory. They are as follows:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="calibre1">1XX - Informational</strong>: Request was received. This indicates a provisional response.</li>
<li class="calibre11"><strong class="calibre1">2XX - Success</strong>: This is the most important response status, acknowledging that the request was successfully received, understood, and accepted. It's what we're looking for in our web-mining scripts.</li>
<li class="calibre11"><strong class="calibre1">3XX - Redirection</strong>: This class of status codes indicates that the client must take additional action. It usually means that additional requests must be made in order to get to the resource, so our scripts will have to handle this scenario. We also need to actively prevent cyclical redirects. We won't deal with such complex scenarios in our project, but in real-life applications, 3XX status codes will require specialized handling based on the subcategory.</li>
</ul>
<div class="packttip">Wikipedia provides a good description of the various 3XX status codes and instructions for what to do in each case: <a href="https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#3xx_Redirection" class="calibre19"><span>https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#3xx_Redirection</span></a>.</div>
<ul class="calibre10">
<li class="calibre11"><strong class="calibre1">4XX - Client Error</strong>: This means that we've probably made a mistake when sending our request. Maybe the URL is wrong and the resource cannot be found (<kbd class="calibre12">404</kbd>) or maybe we're not allowed to access the page (<kbd class="calibre12">401</kbd> and <kbd class="calibre12">403</kbd> status codes). There's a long list of 4XX response codes and, similar to 3XX ones, our program should handle the various scenarios to ensure that the requests are eventually successful.</li>
<li class="calibre11"><strong class="calibre1">5XX - Server Error</strong>: Congratulations, you found or caused a problem on the server! Depending on the actual status code, this may or may not be actionable. <kbd class="calibre12">503</kbd> (service unavailable) or <kbd class="calibre12">504</kbd> (gateway timeout) are relevant as they indicate that we should try again later.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Learning about HTTP headers</h1>
                </header>
            
            <article>
                
<p class="calibre2">HTTP headers allow the client and the server to pass additional information. We won't go into the details of header transmission since Julia's <kbd class="calibre12">HTTP</kbd> library saves us from having to deal with raw headers. However, a few are worth mentioning, as they are important for web scraping:</p>
<ul class="calibre10">
<li class="calibre11"><kbd class="calibre12">Age</kbd>, <kbd class="calibre12">Cache-Control</kbd>, and <kbd class="calibre12">Expires</kbd> represent the validity of the page and can be used to set data refresh times</li>
<li class="calibre11"><kbd class="calibre12">Last-Modified</kbd>, <kbd class="calibre12">Etag</kbd>, and <kbd class="calibre12">If-Modified-Since</kbd> can be used for content versioning, to check if the page has changed since it was last retrieved</li>
<li class="calibre11"><kbd class="calibre12">Cookie</kbd> and <kbd class="calibre12">Set-Cookie</kbd> have to be used in order to read and write cookies that are required for correct communication with the server</li>
<li class="calibre11">The <kbd class="calibre12">Content-*</kbd> family of headers, such as <kbd class="calibre12">Content-Disposition</kbd>, <kbd class="calibre12">Content-Length</kbd>, <kbd class="calibre12">Content-Type</kbd>, <kbd class="calibre12">Content-Encoding</kbd>, and so on, help when handling and validating the response message</li>
</ul>
<div class="packttip">Check <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers" class="calibre19"><span>https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers</span></a> and <a href="https://en.wikipedia.org/wiki/List_of_HTTP_header_fields" class="calibre19"><span>https://en.wikipedia.org/wiki/List_of_HTTP_header_fields</span></a> for a complete discussion on the HTTP header fields.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The HTTP message body</h1>
                </header>
            
            <article>
                
<p class="calibre2">The message body, the most important part and the reason for web scraping (the content of the web page itself), is actually an optional part of the response. The presence of the body, its properties, and its size are specified by the <kbd class="calibre12">Content-*</kbd> family of headers.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding HTTP responses</h1>
                </header>
            
            <article>
                
<p class="calibre2">The result of the <kbd class="calibre12">HTTP.get</kbd> invocation is an object that closely mirrors a raw HTTP response. The package makes our lives easier by extracting the raw HTTP data and neatly setting it up in a data structure, which makes manipulating it a breeze.</p>
<p class="calibre2">Let's take a look at its properties (or <em class="calibre16">fields</em> in Julia's lingo):</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; fieldnames(typeof(resp)) 
(:version, :status, :headers, :body, :request)</strong> </pre>
<p class="calibre2">The <kbd class="calibre12">fieldnames</kbd> function accepts a type as its argument and returns a tuple containing the names of the fields (or properties) of the argument. In order to get the type of a value, we can use the <kbd class="calibre12">typeof</kbd> function, like in the previous example.</p>
<p class="calibre2">Right! The <kbd class="calibre12">status</kbd>, <kbd class="calibre12">headers</kbd>, and <kbd class="calibre12">body</kbd> fields should by now sound familiar. The <kbd class="calibre12">version</kbd> field represents the version of the HTTP protocol (the <kbd class="calibre12">HTTP/1.1</kbd> part in the first line of the response). Most web servers on the internet today use version 1.1 of the protocol, but a new major version, 2.0, is almost ready for wide deployment. Finally, the <kbd class="calibre12">request</kbd> field holds a reference to the <kbd class="calibre12">HTTP.Messages.Request</kbd> object that triggered the current response.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The status code</h1>
                </header>
            
            <article>
                
<p class="calibre2">Let's take a closer look at the status code:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; resp.status 200</strong> </pre>
<p class="calibre2">Sure enough, we got back a valid response, hereby confirmed by the <kbd class="calibre12">200</kbd> status code.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The headers</h1>
                </header>
            
            <article>
                
<p class="calibre2">What about the headers? As already mentioned, they contain critical information indicating whether a message body is present. Let's check them out:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; resp.headers</strong> </pre>
<p class="calibre2">The output is as follows:</p>
<p class="CDPAlignCenter"><img src="assets/3f152978-7e46-46bd-b503-682191cc7121.png" class="calibre50"/></p>
<p class="calibre2">Your output will be different in regard to some of the values, but it should be easy to spot the key HTTP headers we mentioned before. <kbd class="calibre12">Content-Length</kbd> confirms the presence of a response body. The <kbd class="calibre12">Content-Type</kbd> provides information about how to interpret the encoding of the message body (it's a HTML document using UTF-8 character encoding). And we can use the <kbd class="calibre12">Last-Modified</kbd> value to optimize the caching and the update frequency of our web crawler.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The message body</h1>
                </header>
            
            <article>
                
<p class="calibre2">Since we just confirmed that we have a response body, let's see it:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; resp.body 
193324-element Array{UInt8,1}: 
 0x3c 
 0x21 
 0x44  
# ... output truncated ... </strong> </pre>
<p class="calibre2">Oops, that doesn't look like the web page we were expecting. No worries though, these are the bytes of the raw response—which we can easily convert to a human-readable HTML string. Remember that I mentioned the <kbd class="calibre12">String</kbd> method when learning about strings? Well, this is where it comes in handy:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; resp_body = String(resp.body)</strong> </pre>
<p class="calibre2">Your REPL should now be outputting a long HTML string that represents Julia's Wikipedia page.</p>
<p class="calibre2">If we take a look at the first <kbd class="calibre12">500</kbd> characters, we'll start to see familiar patterns:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; resp_body[1:500]</strong> </pre>
<p class="calibre2">The output is as follows:</p>
<p class="CDPAlignCenter"><img src="assets/8aa4f988-cd12-4e2b-b699-c9e9fa77d70f.png" class="calibre51"/></p>
<p class="calibre2">Sure enough, using Chrome's view page source will reveal the same HTML:</p>
<p class="CDPAlignCenter"><img src="assets/837384ea-fd70-4459-80ae-71b4b2f99c81.png" class="calibre52"/></p>
<p class="calibre2">It's confirmed—we just took our first successful step toward building our web crawler!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Learning about pairs</h1>
                </header>
            
            <article>
                
<p class="calibre2">While looking at the response header, you might've noticed that its type is an <kbd class="calibre12">Array</kbd> of <kbd class="calibre12">Pair</kbd> objects:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; resp.headers 
25-element Array{Pair{SubString{String},SubString{String}},1}</strong> </pre>
<p class="calibre2">A <kbd class="calibre12">Pair</kbd> represents a Julia data structure—and the corresponding type. The <kbd class="calibre12">Pair</kbd> contains a couple of values that are generally used to reference key-value relationships. The types of the two elements determine the concrete type of the <kbd class="calibre12">Pair</kbd>.</p>
<p class="calibre2">For example, we can construct a <kbd class="calibre12">Pair</kbd> with the following:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; Pair(:foo, "bar") 
:foo =&gt; "bar"</strong> </pre>
<p class="calibre2">If we check its type we'll see that it's a <kbd class="calibre12">Pair</kbd> of <kbd class="calibre12">Symbol</kbd> and <kbd class="calibre12">String</kbd>:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; typeof(Pair(:foo, "bar")) 
Pair{Symbol,String}</strong> </pre>
<p class="calibre2">We can also create <kbd class="calibre12">Pairs</kbd> by using the <kbd class="calibre12">x =&gt; y</kbd> <span class="calibre5">literal notation:</span></p>
<pre class="calibre17"><strong class="calibre1">julia&gt; 3 =&gt; 'C' 
3 =&gt; 'C' 
 
julia&gt; typeof(3 =&gt; 'C') 
Pair{Int64,Char}</strong> 
 </pre>
<p class="calibre2">The <kbd class="calibre12">=&gt;</kbd> <span class="calibre5">double arrow </span>should look familiar. It's what we saw in the response header, for example:</p>
<pre class="calibre17">"Content-Type" =&gt; "text/html; charset=UTF-8"</pre>
<p class="calibre2">Obviously, once created, it is possible to access the values stored in a <kbd class="calibre12">Pair</kbd>. One way to do it is by indexing into it:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; p = "one" =&gt; 1 
"one" =&gt; 1 
 
julia&gt; p[1] 
"one" 
 
julia&gt; p[2] 
1</strong> 
 </pre>
<p class="calibre2">We can also access the <kbd class="calibre12">first</kbd> and <kbd class="calibre12">second</kbd> fields in order to get to the <kbd class="calibre12">first</kbd> and <kbd class="calibre12">second</kbd> values, respectively:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; p.first 
"one" 
 
julia&gt; p.second 
1</strong> </pre>
<p class="calibre2">Just like the tuples, the <kbd class="calibre12">Pairs</kbd> are immutable, so this won't work:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; p.first = "two" 
ERROR: type Pair is immutable 
 
julia&gt; p[1] = "two" 
ERROR: MethodError: no method matching setindex!(::Pair{String,Int64} </strong></pre>
<p class="calibre2"><kbd class="calibre12">Pairs</kbd> are one of the building blocks of Julia and can be used, among other things, for creating dictionaries, one of the most important types and data structures.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Dictionaries</h1>
                </header>
            
            <article>
                
<p class="calibre2">The dictionary, called <kbd class="calibre12">Dict</kbd>, is one of Julia's most powerful and versatile data structures. It's an associative collection—it <em class="calibre16">associates </em>keys with values. You can think of a <kbd class="calibre12">Dict</kbd> as a look-up table implementation—given a single piece of information, the key, it will return the corresponding value.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Constructing dictionaries</h1>
                </header>
            
            <article>
                
<p class="calibre2">Creating an empty instance of a <kbd class="calibre12">Dict</kbd> is as simple as the following:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; d = Dict() 
Dict{Any,Any} with 0 entries</strong> </pre>
<p class="calibre2">The information between the curly brackets, <kbd class="calibre12">{Any,Any}</kbd>, represents the types of keys and values of the <kbd class="calibre12">Dict</kbd>. Thus, the concrete type of a <kbd class="calibre12">Dict</kbd> itself is defined by the type of its keys and values. The compiler will do its best to infer the type of the collection from the types of its parts. In this case, since the dictionary was empty, no information could be inferred, so Julia defaulted to <kbd class="calibre12">Any</kbd> and <kbd class="calibre12">Any</kbd>.</p>
<p class="calibre2">An <kbd class="calibre12">{Any,Any}</kbd> type of <kbd class="calibre12">Dict</kbd> allows us to add any kind of data, indiscriminately. We can use the <kbd class="calibre12">setindex!</kbd> method to add a new key-value pair to the collection:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; setindex!(d, "World", "Hello") 
Dict{Any,Any} with 1 entry: 
  "Hello" =&gt; "World"</strong> </pre>
<p class="calibre2">However, adding values to a <kbd class="calibre12">Dict</kbd> is routinely done using the square bracket notation (which is similar to indexing into it, while also performing an assignment):</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; d["Hola"] = "Mundo" 
"Mundo" </strong> </pre>
<p class="calibre2">Till now, we've only added <kbd class="calibre12">Strings</kbd>—but like I said, because our <kbd class="calibre12">Dict</kbd> accepts any kind of keys and value, there aren't any constraints:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; d[:speed] = 6.4 
6.4</strong> </pre>
<p class="calibre2">Here is our <kbd class="calibre12">Dict</kbd> now:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; d 
Dict{Any,Any} with 3 entries: 
  "Hello" =&gt; "World" 
  :speed  =&gt; 6.4 
  "Hola"  =&gt; "Mundo"</strong> </pre>
<div class="packttip">Note that the key <kbd class="calibre24">=&gt;</kbd> value pairs are not in the order in which we added them. <kbd class="calibre24">Dicts</kbd> are not ordered collections in Julia. We'll talk more about this in a few paragraphs.</div>
<p class="calibre2">If the key already exists, the corresponding value will be updated, returning the new value:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; d["Hello"] = "Earth" "Earth"</strong> </pre>
<p class="calibre2">Here's our updated <kbd class="calibre12">Dict</kbd>. Note that <kbd class="calibre12">"Hello"</kbd> now points to <kbd class="calibre12">"Earth"</kbd> and not <kbd class="calibre12">"World"</kbd>:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; d 
Dict{Any,Any} with 3 entries: 
  "Hello" =&gt; "Earth" 
  :speed  =&gt; 6.4 
  "Hola"  =&gt; "Mundo"  </strong> </pre>
<p class="calibre2">If we provide some initial data when instantiating the <kbd class="calibre12">Dict</kbd>, the compiler will be able to do better at identifying the types:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; dt = Dict("age" =&gt; 12) 
Dict{String,Int64} with 1 entry: 
  "age" =&gt; 12</strong> </pre>
<p class="calibre2">We can see that the type of the <kbd class="calibre12">Dict</kbd> is now constraining the keys to be <kbd class="calibre12">String</kbd>, and the values to be <kbd class="calibre12">Int</kbd>—which are the types of the <kbd class="calibre12">Pair</kbd> we used to instantiate the <kbd class="calibre12">Dict</kbd>. Now, if a different type is passed for a key or a value, Julia will attempt to convert it—if that fails, an error will occur:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; dt[:price] = 9.99 
MethodError: Cannot `convert` an object of type Symbol to an object of type String</strong> </pre>
<p class="calibre2">In some instances, the automatic conversion works:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; dx = Dict(1 =&gt; 11) 
Dict{Int64,Int64} with 1 entry: 
  1 =&gt; 11 </strong><br class="title-page-name"/><strong class="calibre1">julia&gt; dx[2.0] = 12 
12</strong><br class="title-page-name"/><br class="title-page-name"/></pre>
<p class="calibre2">Julia has silently converted <kbd class="calibre12">2.0</kbd> to the corresponding <kbd class="calibre12">Int</kbd> value:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; dx 
Dict{Int64,Int64} with 2 entries: 
  2 =&gt; 12 
  1 =&gt; 11</strong> </pre>
<p class="calibre2">But that won't always work:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; dx[2.4] = 12 
InexactError: Int64(Int64, 2.4)</strong> </pre>
<p class="calibre2">We can store randomly complex data in a <kbd class="calibre12">Dict</kbd> and its type will be correctly inferred by Julia:</p>
<pre class="calibre17"><strong class="calibre1"> julia&gt; clients_purchases = Dict( 
       "John Roche" =&gt; ["soap", "wine", "apples", "bread"], 
       "Merry Lou"  =&gt; ["bottled water", "apples", "cereals", "milk"] 
       ) 
Dict{String,Array{String,1}} with 2 entries: 
  "John Roche" =&gt; ["soap", "wine", "apples", "bread"] 
  "Merry Lou"  =&gt; ["bottled water", "apples", "cereals", "milk"]</strong> </pre>
<p class="calibre2">You can also specify and constrain the type of <kbd class="calibre12">Dict</kbd> upon constructing it, instead of leaving it up to Julia:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; dd = Dict{String,Int}("" =&gt; 2.0) 
Dict{String,Int64} with 1 entry: 
  "x" =&gt; 2</strong> </pre>
<p class="calibre2">Here, we can see how the type definition overruled the type of the <kbd class="calibre12">2.0</kbd> value, which is a <kbd class="calibre12">Float64</kbd> (of course, as in the previous example, Julia has converted <kbd class="calibre12">2.0</kbd> to its integer counterpart).</p>
<p class="calibre2">We can also use <kbd class="calibre12">Pairs</kbd> to create a <kbd class="calibre12">Dict</kbd>:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; p1 = "a" =&gt; 1 
"a"=&gt;1 </strong><br class="title-page-name"/><strong class="calibre1">julia&gt; p2 = Pair("b", 2) 
"b"=&gt;2 </strong><br class="title-page-name"/><strong class="calibre1">julia&gt; Dict(p1, p2) 
Dict{String,Int64} with 2 entries: 
  "b" =&gt; 2 
  "a" =&gt; 1</strong> </pre>
<p class="calibre2">We can also use an <kbd class="calibre12">Array</kbd> of <kbd class="calibre12">Pair</kbd>:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; Dict([p1, p2]) 
Dict{String,Int64} with 2 entries: 
  "b" =&gt; 2 
  "a" =&gt; 1</strong> </pre>
<p class="calibre2">We can do the same with arrays of tuples:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; Dict([("a", 5), ("b", 10)]) 
Dict{String,Int64} with 2 entries: 
  "b" =&gt; 10 
  "a" =&gt; 5</strong> </pre>
<p class="calibre2">Finally, a <kbd class="calibre12">Dict</kbd> can be constructed using comprehensions:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; using Dates 
julia&gt; Dict([x =&gt; Dates.dayname(x) for x = (1:7)]) 
Dict{Int64,String} with 7 entries: 
  7 =&gt; "Sunday" 
  4 =&gt; "Thursday" 
  2 =&gt; "Tuesday" 
  3 =&gt; "Wednesday" 
  5 =&gt; "Friday" 
  6 =&gt; "Saturday" 
  1 =&gt; "Monday"</strong> </pre>
<p class="calibre2">Your output will be different as it's likely that the keys won't be ordered from <kbd class="calibre12">1</kbd> to <kbd class="calibre12">7</kbd>. That's a very important point—as already mentioned, in Julia, the <kbd class="calibre12">Dict</kbd> is not ordered.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Ordered dictionaries</h1>
                </header>
            
            <article>
                
<p class="calibre2">If you ever need your dictionaries to stay ordered, you can use the <kbd class="calibre12">OrderedCollections</kbd> package (<a href="https://github.com/JuliaCollections/%20OrderedCollections.jl" class="calibre9">https://github.com/JuliaCollections/ OrderedCollections.jl</a>), specifically the <kbd class="calibre12">OrderedDict</kbd>:</p>
<pre class="calibre17"><strong class="calibre1">pkg&gt; add OrderedCollections 
julia&gt; using OrderedCollections, Dates 
julia&gt; OrderedDict(x =&gt; Dates.monthname(x) for x = (1:12)) 
DataStructures.OrderedDict{Any,Any} with 12 entries: 
  1  =&gt; "January" 
  2  =&gt; "February" 
  3  =&gt; "March" 
  4  =&gt; "April" 
  5  =&gt; "May" 
  6  =&gt; "June" 
  7  =&gt; "July" 
  8  =&gt; "August" 
  9  =&gt; "September" 
  10 =&gt; "October" 
  11 =&gt; "November" 
  12 =&gt; "December"</strong> </pre>
<p class="calibre2">Now the elements are stored in the order in which they are added to the collection (from <kbd class="calibre12">1</kbd> to <kbd class="calibre12">12</kbd>).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Working with dictionaries</h1>
                </header>
            
            <article>
                
<p class="calibre2">As we've already seen, we can index into a <kbd class="calibre12">Dict</kbd> using the square bracket notation:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; d = Dict(:foo =&gt; 1, :bar =&gt; 2) 
Dict{Symbol,Int64} with 2 entries: 
  :bar =&gt; 2 
  :foo =&gt; 1 </strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">julia&gt; d[:bar] </strong><br class="title-page-name"/><strong class="calibre1">2</strong> </pre>
<p class="calibre2">Attempting to access a key that has not been defined will result in a <kbd class="calibre12">KeyError</kbd>, as follows:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; d[:baz] 
ERROR: KeyError: key :baz not found</strong> </pre>
<p class="calibre2">To avoid such situations, we can check if the key exists in the first place:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; haskey(d, :baz) 
false</strong> </pre>
<p class="calibre2">As an alternative, if we want to also get a default value when the key does not exist, we can use the following:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; get(d, :baz, 0) 
0</strong> </pre>
<p class="calibre2">The <kbd class="calibre12">get</kbd> function has a more powerful twin, <kbd class="calibre12">get!</kbd>, which also stores the searched key into the <kbd class="calibre12">Dict</kbd>, using the default value:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; d 
Dict{Symbol,Int64} with 2 entries: 
  :bar =&gt; 2 
  :foo =&gt; 1 </strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">julia&gt; get!(d, :baz, 100) 
100 </strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">julia&gt; d 
Dict{Symbol,Int64} with 3 entries: 
  :baz =&gt; 100 
  :bar =&gt; 2 
  :foo =&gt; 1 </strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">julia&gt; haskey(d, :baz) 
true </strong> </pre>
<p class="calibre2">In case you're wondering, the exclamation mark at the end of the function name is valid—and denotes an important Julia naming convention. It should be taken as a warning that using the function will modify its arguments' data. In this case, the <kbd class="calibre12">get!</kbd> function will add the <kbd class="calibre12">:baz = 100</kbd> <kbd class="calibre12">Pair</kbd> to the <kbd class="calibre12">d</kbd> <kbd class="calibre12">Dict</kbd>.</p>
<p class="calibre2">Removing a key-value <kbd class="calibre12">Pair</kbd> is just a matter of invoking <kbd class="calibre12">delete!</kbd> (note the presence of the exclamation mark here too):</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; delete!(d, :baz) 
Dict{Symbol,Int64} with 2 entries: 
  :bar =&gt; 2 
  :foo =&gt; 1 </strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">julia&gt; haskey(d, :baz) 
false</strong> </pre>
<p class="calibre2"/>
<p class="calibre2">As requested, the <kbd class="calibre12">:baz</kbd> key and its corresponding value have vanished.</p>
<p class="calibre2">We can ask for the collections of keys and values using the aptly named functions <kbd class="calibre12">keys</kbd> and <kbd class="calibre12">values</kbd>. They will return iterators over their underlying collections:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; keys(d) 
Base.KeySet for a Dict{Symbol,Int64} with 2 entries. Keys: 
  :bar 
  :foo </strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">julia&gt; values(d) 
Base.ValueIterator for a Dict{Symbol,Int64} with 2 entries. Values: 
  2 
  1</strong> </pre>
<p class="calibre2">Use <kbd class="calibre12">collect</kbd> to retrieve the corresponding arrays:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; collect(keys(d)) 
2-element Array{Symbol,1}: 
 :bar 
 :foo 
 
julia&gt; collect(values(d)) 
2-element Array{Int64,1}: 
 2 
 1</strong> </pre>
<p class="calibre2">We can combine a <kbd class="calibre12">Dict</kbd> with another <kbd class="calibre12">Dict</kbd>:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; d2 = Dict(:baz =&gt; 3) 
Dict{Symbol,Int64} with 1 entry: 
  :baz =&gt; 3 </strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">julia&gt; d3 = merge(d, d2) 
Dict{Symbol,Int64} with 3 entries: 
  :baz =&gt; 3 
  :bar =&gt; 2 
  :foo =&gt; 1</strong> </pre>
<p class="calibre2">If some of the keys are present in multiple dictionaries, the values from the last collection will be preserved:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; merge(d3, Dict(:baz =&gt; 10)) 
Dict{Symbol,Int64} with 3 entries: 
  :baz =&gt; 10 
  :bar =&gt; 2 
  :foo =&gt; 1</strong> </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using the HTTP response</h1>
                </header>
            
            <article>
                
<p class="calibre2">Armed with a good understanding of Julia's dictionary data structure, we can now take a closer look at the <kbd class="calibre12">headers</kbd> property of <kbd class="calibre12">resp</kbd>, our <kbd class="calibre12">HTTP</kbd> response object.</p>
<p class="calibre2">To make it easier to access the various headers, first let's convert the array of <kbd class="calibre12">Pair</kbd> to a <kbd class="calibre12">Dict</kbd>:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; headers = Dict(resp.headers) 
Dict{SubString{String},SubString{String}} with 23 entries: 
"Connection"     =&gt; "keep-alive" 
  "Via"          =&gt; "1.1 varnish (Varnish/5.1), 1.1 varnish (Varni... 
  "X-Analytics"  =&gt; "ns=0;page_id=38455554;https=1;nocookies=1" 
#... output truncated... #</strong></pre>
<p class="calibre2">We can check the <kbd class="calibre12">Content-Length</kbd> value to determine whether or not we have a response body. If it's larger than <kbd class="calibre12">0</kbd>, that means we got back a HTML message:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; headers["Content-Length"] 
"193324"</strong> </pre>
<p class="calibre2">It's important to remember that all the values in the <kbd class="calibre12">headers</kbd> dictionary are strings, so we can't go comparing them straight away:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; headers["Content-Length"] &gt; 0 
ERROR: MethodError: no method matching isless(::Int64, ::String)</strong> </pre>
<p class="calibre2">We'll need to parse it into an integer first:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; parse(Int, headers["Content-Length"]) &gt; 0 
true</strong> </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Manipulating the response body</h1>
                </header>
            
            <article>
                
<p class="calibre2">Earlier, we read the response body into a <kbd class="calibre12">String</kbd> and stored it into the <kbd class="calibre12">resp_body</kbd> variable. It's a long HTML string and, in theory, we could use <kbd class="calibre12">Regex</kbd> and other string-processing functions to find and extract the data that we need. However, such an approach would be extremely complicated and error-prone. The best way to search for content in a HTML document is via HTML and CSS selectors. The only problem is that these selectors don't operate on strings—they only work against a <strong class="calibre4">Document Object Model</strong><span class="calibre5"> (</span><strong class="calibre4">DOM</strong><span class="calibre5">)</span>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building a DOM representation of the page</h1>
                </header>
            
            <article>
                
<p class="calibre2">The DOM represents an in-memory structure of an HTML document. It is a data structure that allows us to programmatically manipulate the underlying HTML elements. The DOM represents a document as a logical tree, and we can use selectors to traverse and query this hierarchy.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Parsing HTML with Gumbo</h1>
                </header>
            
            <article>
                
<p class="calibre2">Julia's <kbd class="calibre12">Pkg</kbd> ecosystem provides access to <kbd class="calibre12">Gumbo</kbd>, a HTML parser library. Provided with a HTML string, <kbd class="calibre12">Gumbo</kbd> will parse it into a document and its corresponding DOM. This package is an important tool for web scraping with Julia, so let's add it.</p>
<p class="calibre2">As usual, install using the following:</p>
<pre class="calibre17"><strong class="calibre1">pkg&gt; add Gumbo 
julia&gt; using Gumbo </strong> </pre>
<p class="calibre2">We're now ready to parse the HTML string into a DOM as follows:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; dom = parsehtml(resp_body)</strong><br class="title-page-name"/><strong class="calibre1"> HTML Document</strong></pre>
<p class="calibre2">The <kbd class="calibre12">dom</kbd> variable now references a <kbd class="calibre12">Gumbo.HTMLDocument</kbd>, an in-memory Julia representation of the web page. It's a simple object that has only two fields:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; fieldnames(typeof(dom)) 
(:doctype, :root)</strong>  </pre>
<p class="calibre2">The <kbd class="calibre12">doctype</kbd> represents the HTML <kbd class="calibre12">&lt;!DOCTYPE html&gt;</kbd> element, which is what the Wikipedia page uses:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; dom.doctype 
"html"</strong> </pre>
<p class="calibre2">Now, let's focus on the <kbd class="calibre12">root</kbd> property. This is effectively the outermost element of the HTML page—the <kbd class="calibre12">&lt;html&gt;</kbd> tag containing the rest of the elements. It provides us with an entry point into the DOM. We can ask <kbd class="calibre12">Gumbo</kbd> about its attributes:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; dom.root.attributes 
Dict{AbstractString,AbstractString} with 3 entries: 
  "class" =&gt; "client-nojs" 
  "lang"  =&gt; "en" 
  "dir"   =&gt; "ltr"</strong> </pre>
<p class="calibre2">It's a <kbd class="calibre12">Dict</kbd>, the keys representing HTML attributes and the values—the attributes' values. And sure enough, they match the page's HTML:</p>
<p class="CDPAlignCenter"><img src="assets/c0902ff6-5eb5-4e1e-9b3f-e3f3d130e397.png" class="calibre53"/></p>
<p class="calibre2">There's also a similar <kbd class="calibre12">attrs</kbd> method, which serves the same purpose:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; attrs(dom.root) 
Dict{AbstractString,AbstractString} with 3 entries: 
  "class" =&gt; "client-nojs" 
  "lang"  =&gt; "en" 
  "dir"   =&gt; "ltr"</strong> </pre>
<p class="calibre2">When in doubt, we can just ask about the name of an element using the <kbd class="calibre12">tag</kbd> method:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; tag(dom.root) 
:HTML</strong> </pre>
<p class="calibre2"><kbd class="calibre12">Gumbo</kbd> exposes a <kbd class="calibre12">children</kbd> method which returns an array containing all the nested <kbd class="calibre12">HTMLElement</kbd>. If you just go ahead and execute <kbd class="calibre12">julia&gt; children(dom.root)</kbd>, the REPL output will be hard to follow. The REPL representation of an <kbd class="calibre12">HTMLElement</kbd> is its HTML code, which, for top-level elements with many children, will fill up many Terminal screens. Let's use a <kbd class="calibre12">for</kbd> loop to iterate over the children and show just their tags:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; for c in children(dom.root) 
           @show tag(c) 
       end 
tag(c) = :head 
tag(c) = :body</strong> </pre>
<p class="calibre2">Much better!</p>
<p class="calibre2">Since the children are part of a collection, we can index into them:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; body = children(dom.root)[2];</strong> </pre>
<p class="calibre2">Please note the closing semicolon (<kbd class="calibre12">;</kbd>). When used in the REPL at the end of an expression, it will suppress the output (so we won't see the very long HTML code of the <kbd class="calibre12">&lt;body&gt;</kbd> that would otherwise be output). The <kbd class="calibre12">body</kbd> variable will now reference an instance of <kbd class="calibre12">HTMLElement{:body}</kbd>:</p>
<pre class="calibre17">HTMLElement{:body}: 
&lt;body class="mediawiki ltr sitedir-ltr mw-hide-empty-elt ns-0 ns-subject page-Julia_programming_language rootpage-Julia_programming_language skin-vector action-view"&gt; 
# ... output truncated ...</pre>
<p class="calibre2">The last method that we'll need is <kbd class="calibre12">getattr</kbd>, which returns the value of an attribute name. If the attribute is not defined for the element, it raises a <kbd class="calibre12">KeyError</kbd>:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; getattr(dom.root, "class") 
"client-nojs"</strong> <br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">julia&gt; getattr(dom.root, "href") # oops! 
ERROR: KeyError: key "href" not found</strong> </pre>
<p class="calibre2">Asking about the <kbd class="calibre12">href</kbd> attribute of a <kbd class="calibre12">&lt;html&gt;</kbd> tag doesn't make any sense. And sure enough, we promptly got a <kbd class="calibre12">KeyError</kbd>, since <kbd class="calibre12">href</kbd> was not an attribute of this <kbd class="calibre12">HTMLElement</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Coding defensively</h1>
                </header>
            
            <article>
                
<p class="calibre2">An error like the previous one, when part of a larger script, has the potential to completely alter a program's execution, leading to undesired and potentially costly results. In general, when something unexpected occurs during the execution of a program, it may leave the software in an erroneous state, making it impossible to return a correct value. In such cases, rather than pushing on and potentially propagating the problem throughout the whole execution stack, it's preferable to explicitly notify the calling code about the situation by throwing an <kbd class="calibre12">Exception</kbd>.</p>
<p class="calibre2">Many functions, both in Julia's core and within third-party packages, make good use of the error-throwing mechanism. It's good practice to check the docs for the functions you use and to see what kinds of errors they throw. An error is called an exception in programming lingo.</p>
<p class="calibre2">As in the case of <kbd class="calibre12">getattr</kbd>, the author of the <kbd class="calibre12">Gumbo</kbd> package warned us that attempting to read an attribute that was not defined would result in a <kbd class="calibre12">KeyError</kbd> exception. We'll learn soon how to handle exceptions by capturing them in our code, getting info about the problem, and stopping or allowing the exception to propagate further up the call stack. Sometimes it's the best approach, but it's not a technique we want to abuse since handling errors this way can be resource-intensive. Dealing with exceptions is considerably slower than performing simple data integrity checks and branching.</p>
<p class="calibre2">For our project, the first line of defense is to simply check if the attribute is in fact defined in the element. We can do this by retrieving the keys of the attributes <kbd class="calibre12">Dict</kbd> and checking if the one we want is part of the collection. It's a one-liner:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; in("href", collect(keys(attrs(dom.root)))) 
false</strong> </pre>
<p class="calibre2">Clearly, <kbd class="calibre12">href</kbd> is not an attribute of the <kbd class="calibre12">&lt;html&gt;</kbd> tag.</p>
<p class="calibre2">Using this approach, we can easily write logic to check for the existence of an attribute before we attempt to look up its value.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The pipe operator</h1>
                </header>
            
            <article>
                
<p class="calibre2">Reading multiple nested functions can be taxing on the brain. The previous example, <kbd class="calibre12">collect(keys(attrs(dom.root)))</kbd>, can be rewritten to improve readability using Julia's pipe operator, <kbd class="calibre12">|&gt;</kbd>.</p>
<p class="calibre2">For example, the following snippet nests three function calls, each inner function becoming the argument of the outermost one:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; collect(keys(attrs(dom.root))) 
3-element Array{AbstractString,1}: 
 "class" 
 "lang" 
 "dir"</strong></pre>
<p class="calibre2">This can be rewritten for improved readability as a chain of functions using the pipe operator. This code produces the exact same result:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; dom.root |&gt; attrs |&gt; keys |&gt; collect 
3-element Array{AbstractString,1}: 
 "class" 
 "lang" 
 "dir"</strong> </pre>
<p class="calibre2">What the <kbd class="calibre12">|&gt;</kbd> operator does is that it takes the output of the first value and <em class="calibre16">pipes</em> it as the argument of the next function. So <kbd class="calibre12">dom.root |&gt; attrs</kbd> is identical to <kbd class="calibre12">attrs(dom.root)</kbd>. Unfortunately, the pipe operator works only for one-argument functions. But it's still very useful for decluttering code, massively improving readability.</p>
<div class="packttip">For more advanced piping functionality you can check out the <kbd class="calibre24">Lazy</kbd> package, specifically <kbd class="calibre24">@&gt;</kbd> and <kbd class="calibre24">@&gt;&gt;</kbd> at <a href="https://github.com/MikeInnes/Lazy.jl#macros" class="calibre19"><span>https://github.com/MikeInnes/Lazy.jl#macros</span>.</a></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Handling errors like a pro</h1>
                </header>
            
            <article>
                
<p class="calibre2">Sometimes, coding defensively won't be the solution. Maybe a key part of your program requires reading a file on the network or accessing a database. If the resource can't be accessed due to a temporary network failure, there's really not much you can do in the absence of the data.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The try...catch statements</h1>
                </header>
            
            <article>
                
<p class="calibre2">If you identify parts of your code where you think the execution can go off the rails due to conditions that are out of your control (that is, <em class="calibre16">exceptional</em> conditions—hence the name <em class="calibre16">exception</em>), you can use Julia's <kbd class="calibre12">try...catch</kbd> statements. This is exactly what it sounds like—you instruct the compiler to <em class="calibre16">try</em> a piece of code and if, as a result of a problem, an exception is <em class="calibre16">thrown</em><em class="calibre16">,</em> to <em class="calibre16">catch</em> it. The fact that an exception is <em class="calibre16">caught</em> implies that it won't propagate throughout the whole application.</p>
<p class="calibre2">Let's see it in action:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; try 
    getattr(dom.root, "href") 
catch 
    println("The $(tag(dom.root)) tag doesn't have a 'href' attribute.") 
end 
The HTML tag doesn't have a 'href' attribute.</strong> </pre>
<p class="calibre2">In this example, once an error is encountered, the execution of the code in the <kbd class="calibre12">try</kbd> branch is stopped exactly at that point, and the execution flow continues right away, in the <kbd class="calibre12">catch</kbd> branch.</p>
<p class="calibre2">It becomes clearer if we modify the snippet as follows:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; try 
    getattr(dom.root, "href") 
    println("I'm here too") 
catch 
    println("The $(tag(dom.root)) tag doesn't have a 'href' attribute.") 
end 
The HTML tag doesn't have a 'href' attribute.</strong> </pre>
<p class="calibre2">The newly added line, <kbd class="calibre12">println("I'm here too")</kbd>, is not executed, as demonstrated by the fact that the message is not output.</p>
<p class="calibre2">Of course, things change if no exception is thrown:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; try 
getattr(dom.root, "class") 
    println("I'm here too") 
catch 
    println("The $(tag(dom.root)) tag doesn't have a 'href' attribute.") 
end 
I'm here too</strong> </pre>
<p class="calibre2">The <kbd class="calibre12">catch</kbd> construct takes an optional argument, the <kbd class="calibre12">Exception</kbd> object that's been thrown by the <kbd class="calibre12">try</kbd> block. This allows us to inspect the exception and branch our code depending on its properties.</p>
<p class="calibre2">In our example, the <kbd class="calibre12">KeyError</kbd> exception is built into Julia. It is thrown when we attempt to access or delete a non-existent element (such as a key in a <kbd class="calibre12">Dict</kbd> or an attribute of a <kbd class="calibre12">HTMLElement</kbd>). All instances of <kbd class="calibre12">KeyError</kbd> have a key property, which provides information about the missing data. Thus, we can make our code more generic:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; try 
     getattr(dom.root, "href") 
catch ex 
    if isa(ex, KeyError)  
            println("The $(tag(dom.root)) tag doesn't have a '$(ex.key)' attribute.") 
    else  
           println("Some other exception has occurred") 
    end 
end 
The HTML tag doesn't have a 'href' attribute.</strong> </pre>
<p class="calibre2">Here, we pass the exception into the <kbd class="calibre12">catch</kbd> block as the <kbd class="calibre12">ex</kbd> variable. We then check if we're dealing with a <kbd class="calibre12">KeyError</kbd> exception—if we are, we use this information to display a custom error by accessing the <kbd class="calibre12">ex.key</kbd> field to retrieve the missing key. If it's a different type of exception, we show a generic error message:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; try 
     error("Oh my!") 
catch ex 
    if isa(ex, KeyError)  
            println("The $(tag(dom.root)) tag doesn't have a '$(ex.key)' attribute.") 
    else  
           println("Some exception has occurred") 
    end 
end 
Some exception has occurred</strong> </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The finally clause</h1>
                </header>
            
            <article>
                
<p class="calibre2">In code that performs state changes or uses resources such as files or databases, there is typically some clean-up work (such as closing files or database connections) that needs to be done when the code is finished. This code would normally go into the <kbd class="calibre12">try</kbd> branch—but what happens if an exception is thrown?</p>
<p class="calibre2">In such cases, the <kbd class="calibre12">finally</kbd> clause comes into play. This can be added after a <kbd class="calibre12">try</kbd> or after a <kbd class="calibre12">catch</kbd> branch. The code within the <kbd class="calibre12">finally</kbd> block is <em class="calibre16">guaranteed</em> to be executed, regardless of whether exceptions are thrown or not:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; try 
    getattr(dom.root, "href") 
catch ex 
    println("The $(tag(dom.root)) tag doesn't have a '$(ex.key)' attribute.") 
finally 
    println("I always get called") 
end 
The HTML tag doesn't have a 'href' attribute. 
I always get called</strong> </pre>
<p class="calibre2">It is illegal to have a <kbd class="calibre12">try</kbd> without a <kbd class="calibre12">catch</kbd> or a <kbd class="calibre12">finally</kbd>:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; try getattr(dom.root, "href") end syntax: try without catch or finally</strong> </pre>
<p class="calibre2">We need to provide either a <kbd class="calibre12">catch</kbd> or a <kbd class="calibre12">finally</kbd> block (or both).</p>
<p class="calibre2">The <kbd class="calibre12">try/catch/finally</kbd> blocks will return the last expression evaluated, so we can capture it in a variable:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; result = try 
           error("Oh no!") 
       catch ex 
           "Everything is under control" 
        end 
"Everything is under control" 
 
julia&gt; result 
"Everything is under control"</strong> </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Throwing exceptions on errors</h1>
                </header>
            
            <article>
                
<p class="calibre2">As developers, we too have the option to create and throw exceptions when our code encounters a problem and shouldn't continue. Julia provides a long list of built-in exceptions that cover a multitude of use cases. You can read about them at <a href="https://docs.julialang.org/en/stable/manual/control-flow/#Built-in-Exceptions-1" class="calibre9"><span>https://docs.julialang.org/en/stable/manual/control-flow/#Built-in-Exceptions-1</span></a><span class="calibre5">.</span></p>
<p class="calibre2">In order to throw an exception, we use the aptly named <kbd class="calibre12">throw</kbd> function. For example, if we want to replicate the error raised by Gumbo's <kbd class="calibre12">getattr</kbd> method, all we have to do is call the following:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; throw(KeyError("href")) 
ERROR: KeyError: key "href" not found</strong> </pre>
<p class="calibre2">If the built-in exceptions provided by Julia aren't relevant enough for your situation, the language provides a generic error type, the <kbd class="calibre12">ErrorException</kbd>. It takes an additional <kbd class="calibre12">msg</kbd> argument which should offer more details about the nature of the error:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; ex = ErrorException("To err is human, but to really foul things up you need a computer.") 
ErrorException("To err is human, but to really foul things up you need a computer.") </strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">julia&gt; throw(ex) 
ERROR: To err is human, but to really foul things up you need a computer. 
 
julia&gt; ex.msg 
"To err is human, but to really foul things up you need a computer."</strong> </pre>
<p class="calibre2">Julia provides a shortcut for throwing <kbd class="calibre12">ErrorException</kbd>, the <kbd class="calibre12">error</kbd> function:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; error(<a class="calibre30">"</a><a class="calibre30">To err is </a><a class="calibre30">human</a><a class="calibre30"> - to blame it on a computer is even more so.</a>") 
ERROR: To err is human - to blame it on a computer is even more so. </strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Rethrowing exceptions</h1>
                </header>
            
            <article>
                
<p class="calibre2">But what do we do if we realize that the exception we've caught cannot (or should not) be handled by our code? For example, say we were expecting to catch a possible missing attribute, but it turned out we got a <kbd class="calibre12">Gumbo</kbd> parsing exception instead. Such an issue would have to be handled higher up the execution stack, maybe by trying to fetch the web page again and reparsing it, or by logging an error message for the admin.</p>
<p class="calibre2">If we <kbd class="calibre12">throw</kbd> the exception ourselves, the origin (the <kbd class="calibre12">stacktrace</kbd>) of the initial error would be lost. For such cases, Julia provides the <kbd class="calibre12">rethrow</kbd> function, which can be used as follows:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; try 
           Dict()[:foo] 
       catch ex 
           "nothing to see here" 
       end 
"nothing to see here"</strong> </pre>
<p class="calibre2">If we simply throw the exception ourselves, this is what happens:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; try 
           Dict()[:foo] 
       catch ex 
           throw(ex) 
       end 
ERROR: KeyError: key :foo not found 
Stacktrace: 
 [1] top-level scope at REPL</strong> </pre>
<p class="calibre2">We throw the <kbd class="calibre12">KeyError</kbd> exception, but the origin of the exception is lost; it appears as if it originates in our code in the <kbd class="calibre12">catch</kbd> block. Contrast this with the following example, where we use <kbd class="calibre12">rethrow</kbd>:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; try 
           Dict()[:foo] 
       catch ex 
            rethrow(ex) 
       end 
ERROR: KeyError: key :foo not found 
Stacktrace: 
 [1] getindex(::Dict{Any,Any}, ::Symbol) at ./dict.jl:474 
 [2] top-level scope at REPL[140]</strong></pre>
<p class="calibre2">The original exception is being rethrown, without changing the stacktrace. Now we can see that the exception originated within the <kbd class="calibre12">dict.jl</kbd> file.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Learning about functions</h1>
                </header>
            
            <article>
                
<p class="calibre2">Before we get to write our first full-fledged Julia program, the web crawler, we need to take yet another important detour. It's the last one, I promise.</p>
<p class="calibre2">As our code becomes more and more complex, we should start using functions. The REPL is great for exploratory programming due to its quick input-output feedback loop, but for any non-trivial piece of software, using functions is the way to go. Functions are an integral part of Julia, promoting readability, code reuse, and performance.</p>
<p class="calibre2">In Julia, a function is an object that takes a tuple of values as an argument and returns a value:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; function add(x, y) 
           x + y 
       end 
add (generic function with 1 method)</strong> </pre>
<p class="calibre2">There's also a compact <em class="calibre16">assignment form</em> for function declaration:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; add(x, y) = x + y 
add (generic function with 1 method)</strong> </pre>
<p class="calibre2">This second form is great for simple one-line functions.</p>
<p class="calibre2">Invoking a function is simply a matter of calling its name and passing it the required arguments:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; add(1, 2) 
3</strong> </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The return keyword</h1>
                </header>
            
            <article>
                
<p class="calibre2">If you have previous programming experience, you might be surprised to see that invoking the <kbd class="calibre12">add</kbd> function correctly returns the expected value, despite the fact that we didn't put any explicit <kbd class="calibre12">return</kbd> statement in the function's body. In Julia, a function automatically returns the result of the last expression that was evaluated. This is usually the last expression in the body of the function.</p>
<p class="calibre2">An explicit <kbd class="calibre12">return</kbd> keyword is also available. Using it will cause the function to exit immediately, with the value passed to the <kbd class="calibre12">return</kbd> statement:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; function add(x, y) 
           return "I don't feel like doing math today" 
           x + y 
       end 
add (generic function with 1 method) </strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">julia&gt; add(1, 2) 
"I don't feel like doing math today"</strong> </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Returning multiple values</h1>
                </header>
            
            <article>
                
<p class="calibre2">Although Julia does not support returning multiple values, it does offer a neat trick that's very close to the actual thing. Any function can return a tuple. And because constructing and destructing tuples is very flexible, this approach is very powerful and readable:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; function addremove(x, y) 
           x+y, x-y 
       end 
addremove (generic function with 1 method) </strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">julia&gt; a, b = addremove(10, 5) 
(15, 5) </strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">julia&gt; a 
15 </strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">julia&gt; b 
5</strong> </pre>
<p class="calibre2">Here we defined a function, <kbd class="calibre12">addremove</kbd>, which returns a tuple of two integers. We can extract the values within the tuple by simply assigning a variable corresponding to each of its elements.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Optional arguments</h1>
                </header>
            
            <article>
                
<p class="calibre2">Function arguments can have sensible defaults. For such situations, Julia allows defining default values. When they are provided, the corresponding arguments no longer have to be passed explicitly on every call:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; function addremove(x=100, y=10) 
           x+y, x-y 
       end 
addremove (generic function with 3 methods)</strong> </pre>
<p class="calibre2">This function has default values for both <kbd class="calibre12">x</kbd> and <kbd class="calibre12">y</kbd>. We can invoke it without passing any of the arguments:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; addremove() 
(110, 90)</strong> </pre>
<p class="calibre2">This snippet demonstrates how Julia uses the default values when they are not provided upon function invocation.</p>
<p class="calibre2">We can pass the first argument only—and for the second one, the default value will be used:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; addremove(5) 
(15, -5)</strong> </pre>
<p class="calibre2">Finally, we can pass both arguments; all the defaults will be overwritten:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; addremove(5, 1) 
(6, 4)</strong> </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Keyword arguments</h1>
                </header>
            
            <article>
                
<p class="calibre2">The functions that require a long list of arguments can be hard to use, as the programmer has to remember the order and the types of the expected values. For such cases, we can define functions that accept labeled arguments instead. These are called <strong class="calibre4">keyword arguments</strong>.</p>
<p class="calibre2">In order to define functions that accept keyword arguments, we need to add a semicolon after the function's list of unlabeled arguments and follow it with one or more <kbd class="calibre12">keyword=value</kbd> pairs. We actually encountered such functions in <a href="b9056286-1d26-4cb4-bf90-bdc76722b3fb.xhtml" class="calibre9">Chapter 2</a>, <em class="calibre16">Creating Our First Julia App</em>, when we used <kbd class="calibre12">Gadfly</kbd> to plot the Iris flower dataset:</p>
<pre class="calibre17">plot(iris, x=:SepalLength, y=:PetalLength, color=:Species) </pre>
<p class="calibre2">In this example, <kbd class="calibre12">x</kbd>, <kbd class="calibre12">y</kbd>, and <kbd class="calibre12">color</kbd> are all keyword arguments.</p>
<p class="calibre2">The definition of a function with keyword arguments looks like this:</p>
<pre class="calibre17">function thermal_confort(temperature, humidity<strong class="calibre1">;</strong> scale = :celsius, age = 35) </pre>
<p class="calibre2">Here, we define a new function, <kbd class="calibre12">thermal_confort</kbd>, which has two required arguments, <kbd class="calibre12">temperature</kbd> and <kbd class="calibre12">humidity</kbd>. The function also accepts two keyword arguments, <kbd class="calibre12">scale</kbd> and <kbd class="calibre12">age</kbd>, which have the default values of <kbd class="calibre12">:celsius</kbd> and <kbd class="calibre12">35</kbd>, respectively. It is necessary for all the keyword arguments to have default values.</p>
<p class="calibre2">Invoking such a function implies using the positional as well as the keyword arguments:</p>
<pre class="calibre17">thermal_confort(27, 56, age = 72, scale = :fahrenheit)</pre>
<p class="calibre2">If the values for the keyword arguments are not supplied, the default values are used.</p>
<p class="calibre2">Keyword argument default values are evaluated left to right, which means that default expressions may refer to prior keyword arguments:</p>
<pre class="calibre17">function thermal_confort(temperature, humidity; scale = :celsius, age = 35, <strong class="calibre1">health_risk = age/100</strong>) </pre>
<p class="calibre2">Note that we reference the keyword argument <kbd class="calibre12">age</kbd> in the default value of <kbd class="calibre12">health_risk</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Documenting functions</h1>
                </header>
            
            <article>
                
<p class="calibre2">Julia comes out of the box with powerful code-documenting features. The usage is straightforward—any string appearing at the top level, right before an object, will be interpreted as documentation (it's called a <strong class="calibre4">docstring</strong>). The docstring is interpreted as markdown, so we can use markup for rich formatting.</p>
<p class="calibre2">The documentation for the <kbd class="calibre12">thermal_confort</kbd> function could be as follow:</p>
<pre class="calibre17">""" 
        thermal_confort(temperature, humidity; &lt;keyword arguments&gt;) <br class="title-page-name"/>Compute the thermal comfort index based on temperature and humidity. It can optionally take into account the age of the patient. Works for both Celsius and Fahrenheit.  <br class="title-page-name"/># Examples: 
```julia-repl 
julia&gt; thermal_confort(32, 78) 
12 
``` <br class="title-page-name"/># Arguments <br class="title-page-name"/>- temperature: the current air temperature 
- humidity: the current air humidity 
- scale: whether :celsius or :fahrenheit, defaults to :celsius 
- age: the age of the patient 
""" 
function thermal_confort(temperature, humidity; scale = :celsius, age = 35)</pre>
<p class="calibre2">Now we can access the documentation of our function by using the REPL's help mode:</p>
<pre class="calibre17"><strong class="calibre1">help?&gt; thermal_confort</strong> </pre>
<p class="calibre2">The output is as follows:</p>
<p class="CDPAlignCenter"><img src="assets/12ccbd57-9f44-4685-8595-dbdfb105fecc.png" class="calibre54"/></p>
<p class="calibre2">Pretty useful, isn't it? Docstrings can also be used to generate complete documentation for your Julia projects, with the help of external packages which build full API docs as standalone websites, markdown documents, PDF documents, etcetera. We'll see how to do this in <a href="8391f749-e95c-4ff9-ba40-d71c91b1d7fd.xhtml" class="calibre9">Chapter 11</a>, <em class="calibre16">Creating Julia Packages</em>. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Writing a basic web crawler – take one</h1>
                </header>
            
            <article>
                
<p class="calibre2">We're now ready to write our first fully-fledged Julia program—a simple web crawler. This first iteration will make a request for Julia's Wikipedia page, will parse it and extract all the internal URLs, storing them in an <kbd class="calibre12">Array</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting up our project</h1>
                </header>
            
            <article>
                
<p class="calibre2">The first thing we need to do is to set up a dedicated project. This is done by using <kbd class="calibre12">Pkg</kbd>. It is a very important step as it allows us to efficiently manage and version the packages on which our program depends.</p>
<p class="calibre2">For starters, we need a folder for our software. Create one—let's call it <kbd class="calibre12">WebCrawler</kbd>. I'll use Julia to make it, but you do it however you like:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; mkdir("WebCrawler") 
"WebCrawler" 
 
julia&gt; cd("WebCrawler/")</strong> </pre>
<p class="calibre2">Now we can use <kbd class="calibre12">Pkg</kbd> to add the dependencies. When we start a new project, we need to initialise it. This is achieved with the following:</p>
<pre class="calibre17"><strong class="calibre1">pkg&gt; activate .</strong></pre>
<p class="calibre2">This tells <kbd class="calibre12">Pkg</kbd> that we want to manage dependencies in the current project as opposed to doing it globally. You will notice that the cursor has changed, indicating the name of the active project, <kbd class="calibre12">WebCrawler</kbd>:</p>
<pre class="calibre17"><strong class="calibre1">(WebCrawler) pkg&gt;</strong> </pre>
<p class="calibre2">All the other packages we installed up until this point were in the global environment, which was indicated by the <kbd class="calibre12">(v1.0)</kbd> cursor:</p>
<pre class="calibre17"><strong class="calibre1">(v1.0) pkg&gt;</strong> </pre>
<div class="packttip"><kbd class="calibre24">(v1.0)</kbd> is the global environment, labeled with the currently installed Julia version. If you try the examples on a different Julia version, you'll get a different label.</div>
<p class="calibre2">If we check the status, we'll see that no packages were installed yet in the project's environment:</p>
<pre class="calibre17"><strong class="calibre1">(WebCrawler) pkg&gt; st 
    Status `Project.toml`</strong> </pre>
<p class="calibre2">Our software will have two dependencies—<kbd class="calibre12">HTTP</kbd> and <kbd class="calibre12">Gumbo</kbd>. It's time to add them:</p>
<pre class="calibre17"><strong class="calibre1">(WebCrawler) pkg&gt; add HTTP 
(WebCrawler) pkg&gt; add Gumbo</strong> </pre>
<p class="calibre2">Now we can create a new file to host our code. Let's call it <kbd class="calibre12">webcrawler.jl</kbd>. It can be created using Julia:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; touch("webcrawler.jl") 
"webcrawler.jl"</strong> </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Writing a Julia program</h1>
                </header>
            
            <article>
                
<p class="calibre2">Unlike our previous work in the REPL and IJulia notebooks, this will be a standalone program: all the logic will go inside this <kbd class="calibre12">webcrawler.jl</kbd> file, and when ready, we'll use the <kbd class="calibre12">julia</kbd> binary to execute it.</p>
<p class="calibre2">Julia files are parsed top to bottom, so we need to provide all the necessary instructions in the right order (using statements, variables initialization, function definitions, etcetera). We'll pretty much condense all the steps we took so far in this chapter to build this small program.</p>
<p class="calibre2">To make things simpler, it's best to use a full-fledged Julia editor. Open <kbd class="calibre12">webcrawler.jl</kbd> in Atom/Juno or Visual Studio Code (or whatever your favorite editor is).</p>
<p class="calibre2">The first thing we want to do is to inform Julia that we plan on using the <kbd class="calibre12">HTTP</kbd> and <kbd class="calibre12">Gumbo</kbd> packages. We can write a single <kbd class="calibre12">using</kbd> statement and list multiple dependencies, separated by a comma:</p>
<pre class="calibre17">using HTTP, Gumbo </pre>
<p class="calibre2">Also, we decided that we wanted to use Julia's Wikipedia page to test our crawler. The link is <a href="https://en.wikipedia.org/wiki/Julia_(programming_language)" class="calibre9">https://en.wikipedia.org/wiki/Julia_(programming_language)</a>. It's good practice to store such configuration-like values in constants, rather than spreading <em class="calibre16">magic strings</em> throughout the whole code base:</p>
<pre class="calibre17">const PAGE_URL = "https://en.wikipedia.org/wiki/Julia_(programming_language)" </pre>
<p class="calibre2">We also said that we wanted to store all the links in an <kbd class="calibre12">Array</kbd>—let's set that up too. Remember that constants in Julia are concerned mostly with types, so there is no problem if we push values into the array after it's declared:</p>
<pre class="calibre17">const LINKS = String[] </pre>
<p class="calibre2">Here, we initialize the <kbd class="calibre12">LINKS</kbd> constant as an empty <kbd class="calibre12">Array</kbd> of <kbd class="calibre12">String</kbd>. The notation <kbd class="calibre12">String[]</kbd> produces the same result as <kbd class="calibre12">Array{String,1}()</kbd> and <kbd class="calibre12">Vector{String}()</kbd>. It basically represents the empty <kbd class="calibre12">Array</kbd> literal <kbd class="calibre12">[]</kbd> plus the <kbd class="calibre12">Type</kbd> constraint <kbd class="calibre12">String</kbd>—creating a <kbd class="calibre12">Vector</kbd> of <kbd class="calibre12">String</kbd> values.</p>
<p class="calibre2">The next steps are—fetch the page, look for a successful response (status <kbd class="calibre12">200</kbd>), and then check the headers to see if we received a message body (<kbd class="calibre12">Content-Length</kbd> greater than zero). In this first iteration, we only have to do this one time. But thinking ahead, for the final version of our game, we'll have to repeat this process up to six times per game session (because there will be up to Six Degrees of Wikipedia, so we'll have to crawl up to six pages). The best thing we can do is to write a generic function which takes a page URL as its only parameter, fetches the page, performs the necessary checks, and returns the message body if available. Let's call this function <kbd class="calibre12">fetchpage</kbd>:</p>
<pre class="calibre17">function fetchpage(url)<br class="title-page-name"/>    response = HTTP.get(url)<br class="title-page-name"/>    if response.status == 200 &amp;&amp; parse(Int, Dict(response.headers)["Content-Length"]) &gt; 0<br class="title-page-name"/>        String(response.body)<br class="title-page-name"/>    else<br class="title-page-name"/>        ""<br class="title-page-name"/>    end<br class="title-page-name"/>end   </pre>
<p class="calibre2">First, we call <kbd class="calibre12">HTTP.get(url)</kbd>, storing the <kbd class="calibre12">HTTP.Messages.Response</kbd> object in the <kbd class="calibre12">response</kbd> variable. Then we check if the response status is <kbd class="calibre12">200</kbd> and if the <kbd class="calibre12">Content-Length</kbd> header is greater than <kbd class="calibre12">0</kbd>. If they are, we read the message body into a string. If not, we return an empty string, <kbd class="calibre12">""</kbd>, to represent the empty body. That's a lot of <em class="calibre16">ifs</em>—looks like it's time we take a closer look at the conditional <kbd class="calibre12">if/else</kbd> statements, as they're really important.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Conditional evaluation of if, elseif, and else statements</h1>
                </header>
            
            <article>
                
<p class="calibre2">All, except maybe the most basic, programs must be able to evaluate variables and execute different logical branches depending on their current values. Conditional evaluation allows portions of the code to be executed (or not) depending on the value of a Boolean expression. Julia provides the <kbd class="calibre12">if</kbd>, <kbd class="calibre12">elseif</kbd>, and <kbd class="calibre12">else</kbd> statements for writing conditional expressions. They work like this:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; x = 5 
5 </strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">julia&gt; if x &lt; 0 
           println("x is a negative number") 
      elseif x &gt; 0 
           println("x is a positive number greater than 0") 
      else  
           println("x is 0") 
      end 
x is a positive number greater than 0</strong> </pre>
<p class="calibre2">If the condition <kbd class="calibre12">x &lt; 0</kbd> is true, then its underlying block is evaluated. If not, the expression <kbd class="calibre12">x &gt; 0</kbd> is evaluated, as part of the <kbd class="calibre12">elseif</kbd> branch. If it is true, its corresponding block is evaluated. If neither expression is true, the <kbd class="calibre12">else</kbd> block is evaluated.</p>
<p class="calibre2">The <kbd class="calibre12">elseif</kbd> and <kbd class="calibre12">else</kbd> blocks are optional, and we can use as many <kbd class="calibre12">elseif</kbd> blocks as we want. The conditions in the <kbd class="calibre12">if</kbd>,<kbd class="calibre12">elseif</kbd> and <kbd class="calibre12">else</kbd> construct are evaluated until the first one returns <kbd class="calibre12">true</kbd>. Then the associated block is evaluated and its last computed value is returned, exiting the conditional evaluation. Thus, conditional statements in Julia also return a value—the last executed statement in the branch that was chosen. The following code shows this:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; status = if x &lt; 0 
                         "x is a negative number" 
                  elseif x &gt; 0 
                         "x is a positive number greater than 0" 
                   else  
                         "x is 0" 
                   end 
"x is a positive number greater than 0" </strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">julia&gt; status 
"x is a positive number greater than 0"</strong> </pre>
<p class="calibre2">Finally, it's very important to keep in mind that <kbd class="calibre12">if</kbd> blocks do not introduce local scope. That is, variables defined within them will be accessible after the block is exited (of course, provided that the respective branch has been evaluated):</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; status = if x &lt; 0 
            "x is a negative number" 
       elseif x &gt; 0 
            y = 20 
            "x is a positive number greater than 0" 
       else  
            "x is 0" 
       end 
"x is a positive number greater than 0" 
 
julia&gt; y 
20</strong> </pre>
<p class="calibre2">We can see here that the <kbd class="calibre12">y</kbd> variable, initialized within the <kbd class="calibre12">elseif</kbd> block, is still accessible outside the conditional expression.</p>
<p class="calibre2">This can be avoided if we declare the variable to be <kbd class="calibre12">local</kbd>:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; status = if x &lt; 0 
            "x is a negative number" 
       elseif x &gt; 0 
            local z = 20 
            "x is a positive number greater than 0" 
       else  
            "x is 0" 
       end 
"x is a positive number greater than 0" 
 
julia&gt; z 
UndefVarError: z not defined</strong></pre>
<p class="calibre2">When declared <kbd class="calibre12">local</kbd>, the variable no longer <em class="calibre16">leaks</em> outside the <kbd class="calibre12">if</kbd> block.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The ternary operator</h1>
                </header>
            
            <article>
                
<p class="calibre2">An <kbd class="calibre12">if</kbd>,<kbd class="calibre12">then</kbd> and <kbd class="calibre12">else</kbd> type of condition can be expressed using the ternary operator <kbd class="calibre12">? :</kbd>. Its syntax is as follows:</p>
<pre class="calibre17">x ? y : z </pre>
<p class="calibre2"/>
<p class="calibre2">If <kbd class="calibre12">x</kbd> is true, the expression <kbd class="calibre12">y</kbd> is evaluated—otherwise, <kbd class="calibre12">z</kbd> gets evaluated instead. For instance, consider the following code:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; x = 10 
10 
 
julia&gt; x &lt; 0 ? "negative" : "positive" 
"positive"</strong> </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Short-circuit evaluation</h1>
                </header>
            
            <article>
                
<p class="calibre2">Julia provides an even more concise type of evaluation—short-circuit evaluation. In a series of Boolean expressions connected by <kbd class="calibre12">&amp;&amp;</kbd> and <kbd class="calibre12">||</kbd> operators, only the minimum number of expressions are evaluated—as many as are necessary in order to determine the final Boolean value of the entire chain. We can exploit this to return certain values, depending on what gets to be evaluated. For instance:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; x = 10 
10 
 
<a class="calibre30">julia&gt; x &gt; 5 &amp;&amp; "bigger than 5"<br class="title-page-name"/></a>"bigger than 5"</strong></pre>
<p class="calibre2">In an expression <kbd class="calibre12">A &amp;&amp; B</kbd>, the second expression <kbd class="calibre12">B</kbd> is only evaluated if and only if <kbd class="calibre12">A</kbd> evaluates to <kbd class="calibre12">true</kbd>. In this case, the whole expression has the return value of the sub-expression <kbd class="calibre12">B</kbd>, which in the previous example is <kbd class="calibre12">bigger than 5</kbd>.</p>
<p class="calibre2">If, on the contrary, <kbd class="calibre12">A</kbd> evaluates to <kbd class="calibre12">false</kbd>, <kbd class="calibre12">B</kbd> does not get evaluated at all. Thus, beware—the whole expression will return a <kbd class="calibre12">false</kbd> Boolean (not a string!):</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; x &gt; 15 &amp;&amp; "bigger than 15" 
false</strong> </pre>
<p class="calibre2">The same logic applies to the logical <kbd class="calibre12">or</kbd> operator, <kbd class="calibre12">||</kbd>:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; x &lt; 5 || <a class="calibre30">"greater </a>than 5"</strong><br class="title-page-name"/><strong class="calibre1">"greater than 5"</strong></pre>
<p class="calibre2">In an expression <kbd class="calibre12">A || B</kbd>, the second expression <kbd class="calibre12">B</kbd> is only evaluated if <kbd class="calibre12">A</kbd> evaluates to <kbd class="calibre12">false</kbd>. The same logic applies when the first sub-expression is evaluated to <kbd class="calibre12">true</kbd>; <kbd class="calibre12">true</kbd> will be the return value of the whole expression:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; x &gt; 5 || "less than 5" 
true</strong> </pre>
<p class="calibre2"/>
<p class="calibre2"/>
<p class="calibre2"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Beware of operator precedence</h1>
                </header>
            
            <article>
                
<p class="calibre2">Sometimes short-circuit expressions can confuse the compiler, resulting in errors or unexpected results. For example, short-circuit expressions are often used with assignment operations, as follows:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; x &gt; 15 || message = "That's a lot"</strong> </pre>
<p class="calibre2">This will fail with the <kbd class="calibre12">syntax: invalid assignment location "(x &gt; 15) || message"</kbd> error because the <kbd class="calibre12">=</kbd> assignment operator has higher precedence than logical <kbd class="calibre12">or</kbd> and <kbd class="calibre12">||</kbd>. It can easily be fixed by using brackets to explicitly control the evaluation order:</p>
<pre class="calibre17"><strong class="calibre1">julia&gt; x &gt; 15 || (message = "That's a lot") 
"That's a lot"</strong> </pre>
<p class="calibre2">It's something to keep in mind as it's a common source of errors for beginners.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Carrying on with the crawler's implementation</h1>
                </header>
            
            <article>
                
<p class="calibre2">So far, your code should look like this:</p>
<pre class="calibre17">using HTTP, Gumbo <br class="title-page-name"/><br class="title-page-name"/>const PAGE_URL = "https://en.wikipedia.org/wiki/Julia_(programming_language)" 
const LINKS = String[] <br class="title-page-name"/><br class="title-page-name"/>function fetchpage(url) 
  response = HTTP.get(url) 
  if response.status == 200 &amp;&amp; parse(Int, Dict(response.headers)["Content-Length"]) &gt; 0 
    String(response.body) 
  else 
    "" 
  end 
end </pre>
<p class="calibre2">It should be now clear that either the response body or an empty string is returned by the <kbd class="calibre12">if/else</kbd> statement. And since this is the last piece of code evaluated inside the <kbd class="calibre12">fetchpage</kbd> function, this value also becomes the return value of the whole function.</p>
<p class="calibre2">All good, we can now use the <kbd class="calibre12">fetchpage</kbd> function to get the HTML content of the Wikipedia page and store it in the <kbd class="calibre12">content</kbd> variable:</p>
<pre class="calibre17">content = fetchpage(PAGE_URL)  </pre>
<p class="calibre2">If the fetch operation is successful and the <kbd class="calibre12">content</kbd> is not an empty string, we can pass the HTML string to <kbd class="calibre12">Gumbo</kbd> to construct the DOM. Then, we can loop through all the children of this DOM's <kbd class="calibre12">root</kbd> element and look for links (using the <kbd class="calibre12">a</kbd> tag selector). For each element, we want to check the <kbd class="calibre12">href</kbd> attribute and store its value only if it points to another Wikipedia page:</p>
<pre class="calibre17">if ! isempty(content) 
  dom = Gumbo.parsehtml(content) <br class="title-page-name"/>  extractlinks(dom.root) 
end</pre>
<p class="calibre2">The function for extracting the links is:</p>
<pre class="calibre17">function extractlinks(elem) 
  if  isa(elem, HTMLElement) &amp;&amp;  
      tag(elem) == :a &amp;&amp; in("href", collect(keys(attrs(elem)))) 
        url = getattr(elem, "href") 
        startswith(url, "/wiki/") &amp;&amp; push!(LINKS, url) 
  end 
 
  for child in children(elem) 
    extractlinks(child) 
  end 
end </pre>
<p class="calibre2">Here, we declare an <kbd class="calibre12">extractlinks</kbd> function which takes a <kbd class="calibre12">Gumbo</kbd> element, called <kbd class="calibre12">elem</kbd>, as its only parameter. We then check if <kbd class="calibre12">elem</kbd> is a <kbd class="calibre12">HTMLElement</kbd> and, if it is, we check if it corresponds to a link tag (the <kbd class="calibre12">:a</kbd> Julia <kbd class="calibre12">Symbol</kbd> which represents an <kbd class="calibre12">&lt;a&gt;</kbd> HTML tag). Then we check if the element defines a <kbd class="calibre12">href</kbd> attribute in order to avoid getting a <kbd class="calibre12">KeyError</kbd>. If all is good, we get the value of the <kbd class="calibre12">href</kbd> element. And finally, if the value of the <kbd class="calibre12">href</kbd> is an internal URL—that is, a URL that starts with <kbd class="calibre12">/wiki/</kbd>—we add it to our <kbd class="calibre12">LINKS</kbd> <kbd class="calibre12">Array</kbd>.</p>
<p class="calibre2">Once we're done checking the element for links, we check if it contains other nested HTML elements. If it does, we want to repeat the same process for each of its children. That's what the final <kbd class="calibre12">for</kbd> loop does.</p>
<p class="calibre2">The only thing left to do is to display the populated <kbd class="calibre12">LINKS</kbd> <kbd class="calibre12">Array</kbd>, at the very end of our file. Since some of the links might come up in the page more than once, let's make sure we reduce the <kbd class="calibre12">Array</kbd> to the unique elements only, by using the <kbd class="calibre12">unique</kbd> function:</p>
<pre class="calibre17">display(unique(LINKS))  </pre>
<p class="calibre2">Now we can execute this script by opening a terminal in the folder where the file is stored. And then run—<kbd class="calibre12">$ julia webcrawler.jl</kbd>.</p>
<p class="calibre2">There's plenty of links, so the output will be quite long. Here's the top of the list:</p>
<pre class="calibre17"><strong class="calibre1"> $ julia webcrawler.jl 
440-element Array{String,1}: 
 "/wiki/Programming_paradigm" 
 "/wiki/Multi-paradigm_programming_language" 
 "/wiki/Multiple_dispatch" 
 "/wiki/Object-oriented_programming" 
 "/wiki/Procedural_programming" 
# ... output truncated ...</strong> </pre>
<p class="calibre2"><span class="calibre5">By looking at the output, we'll notice that in the first optimization</span> some links point to special Wikipedia pages—the ones containing parts such as <kbd class="calibre12">/File:</kbd>, <kbd class="calibre12">/Category:</kbd>, <kbd class="calibre12">/Help:</kbd>, <kbd class="calibre12">/Special:</kbd>, and so on. So we can just go ahead and skip all the URLs that contain a column, <kbd class="calibre12">:</kbd>, since these are not articles and are not useful for our game.</p>
<p class="calibre2">To do this, look for the line that reads:</p>
<pre class="calibre17">startswith(url, "/wiki/") &amp;&amp; push!(LINKS, url)</pre>
<p class="calibre2">Replace the preceding line with the following:</p>
<pre class="calibre17">startswith(url, "/wiki/") &amp;&amp; ! occursin(":", url) &amp;&amp; push!(LINKS, url) </pre>
<p class="calibre2">If you run the program now, you should see a list of all the URLs from Julia's Wikipedia page that link to other Wikipedia articles.</p>
<p class="calibre2">This is the full code:</p>
<pre class="calibre17">using HTTP, Gumbo <br class="title-page-name"/><br class="title-page-name"/>const PAGE_URL = "https://en.wikipedia.org/wiki/Julia_(programming_language)" 
const LINKS = String[] <br class="title-page-name"/><br class="title-page-name"/>function fetchpage(url) 
  response = HTTP.get(url) 
  if response.status == 200 &amp;&amp; parse(Int, Dict(response.headers)["Content-Length"]) &gt; 0 
    String(response.body) 
  else 
    "" 
  end 
end 
 
function extractlinks(elem) 
  if  isa(elem, HTMLElement) &amp;&amp; tag(elem) == :a &amp;&amp; in("href", collect(keys(attrs(elem)))) 
        url = getattr(elem, "href") 
        startswith(url, "/wiki/") &amp;&amp; ! occursin(":", url) &amp;&amp; push!(LINKS, url) 
  end 
 
  for child in children(elem) 
    extractlinks(child) 
  end 
end 
  
content = fetchpage(PAGE_URL) <br class="title-page-name"/><br class="title-page-name"/>if ! isempty(content) 
  dom = Gumbo.parsehtml(content)<br class="title-page-name"/>  extractlinks(dom.root) <br class="title-page-name"/>end<br class="title-page-name"/> <br class="title-page-name"/>display(unique(LINKS)) </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p class="calibre2">Web scraping is a key component of data mining and Julia provides a powerful toolbox for handling these tasks. In this chapter, we addressed the fundamentals of building a web crawler. We learned how to request web pages with a Julia web client and how to read the responses, how to work with Julia's powerful <kbd class="calibre12">Dict</kbd> data structure to read HTTP information, how to make our software more resilient by handling errors, how to better organize our code by writing functions and documenting them, and how to use conditional logic to make decisions.</p>
<p class="calibre2">Armed with this knowledge, we built the first version of our web crawler. In the next chapter, we will improve it and will use it to extract the data for our upcoming Wiki game. In the process, we'll dive deeper into the language, learning about types, methods and modules, and how to interact with relational databases.</p>


            </article>

            
        </section>
    </body></html>