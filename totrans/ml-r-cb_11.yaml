- en: Chapter 11. Dimension Reduction
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章. 降维
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Performing feature selection with FSelector
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用FSelector进行特征选择
- en: Performing dimension reduction with PCA
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用PCA进行降维
- en: Determining the number of principal components using a scree test
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用scree测试确定主成分的数量
- en: Determining the number of principal components using the Kaiser method
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Kaiser方法确定主成分的数量
- en: Visualizing multivariate data using biplot
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用双图可视化多元数据
- en: Performing dimension reduction with MDS
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用MDS进行降维
- en: Reducing dimensions with SVD
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用奇异值分解（SVD）降维
- en: Compressing images with SVD
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用SVD压缩图像
- en: Performing nonlinear dimension reduction with ISOMAP
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用ISOMAP进行非线性降维
- en: Performing nonlinear dimension deduction with Local Linear Embedding
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用局部线性嵌入进行非线性降维
- en: Introduction
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Most datasets contain features (such as attributes or variables) that are highly
    redundant. In order to remove irrelevant and redundant data to reduce the computational
    cost and avoid overfitting, you can reduce the features into a smaller subset
    without a significant loss of information. The mathematical procedure of reducing
    features is known as dimension reduction.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数数据集都包含高度冗余的特征（如属性或变量）。为了去除无关和冗余的数据，以降低计算成本并避免过拟合，你可以将特征减少到较小的子集，而不会造成信息损失。减少特征的数学过程称为降维。
- en: 'The reduction of features can increase the efficiency of data processing. Dimension
    reduction is, therefore, widely used in the fields of pattern recognition, text
    retrieval, and machine learning. Dimension reduction can be divided into two parts:
    feature extraction and feature selection. Feature extraction is a technique that
    uses a lower dimension space to represent data in a higher dimension space. Feature
    selection is used to find a subset of the original variables.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 特征的减少可以提高数据处理效率。因此，降维在模式识别、文本检索和机器学习等领域得到广泛应用。降维可以分为两个部分：特征提取和特征选择。特征提取是一种使用低维空间来表示高维空间中数据的技巧。特征选择用于找到原始变量的子集。
- en: The objective of feature selection is to select a set of relevant features to
    construct the model. The techniques for feature selection can be categorized into
    feature ranking and feature selection. Feature ranking ranks features with a certain
    criteria and then selects features that are above a defined threshold. On the
    other hand, feature selection searches the optimal subset from a space of feature
    subsets.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 特征选择的目的是选择一组相关特征来构建模型。特征选择的技术可以分为特征排名和特征选择。特征排名根据一定标准对特征进行排名，然后选择超过定义阈值的特征。另一方面，特征选择从特征子集空间中搜索最优子集。
- en: In feature extraction, the problem can be categorized as linear or nonlinear.
    The linear method searches an affine space that best explains the variation of
    data distribution. In contrast, the nonlinear method is a better option for data
    that is distributed on a highly nonlinear curved surface. Here, we list some common
    linear and nonlinear methods.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在特征提取中，问题可以分为线性或非线性。线性方法搜索一个最佳解释数据分布变化的仿射空间。相比之下，非线性方法对于分布在高度非线性曲面上数据的处理是一个更好的选择。在此，我们列出一些常见的线性和非线性方法。
- en: 'Here are some common linear methods:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些常见的线性方法：
- en: '**PCA**: Principal component analysis maps data to a lower dimension, so that
    the variance of the data in a low dimension representation is maximized.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PCA**：主成分分析将数据映射到低维空间，使得低维表示中的数据方差最大化。'
- en: '**MDS**: Multidimensional scaling is a method that allows you to visualize
    how near (pattern proximities) objects are to each other and can produce a representation
    of your data with lower dimension space. PCA can be regarded as the simplest form
    of MDS if the distance measurement used in MDS equals the covariance of data.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MDS**：多维尺度分析是一种方法，它允许你可视化对象之间的接近程度（模式邻近性），并且可以使用低维空间表示你的数据。如果MDS中使用的距离测量等于数据的协方差，则PCA可以被视为MDS的最简单形式。'
- en: '**SVD**: Singular value decomposition removes redundant features that are linear
    correlated from the perspective of linear algebra. PCA can also be regarded as
    a specific case of SVD.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SVD**：奇异值分解从线性代数的角度移除了线性相关的冗余特征。PCA也可以被视为SVD的特例。'
- en: 'Here are some common nonlinear methods:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些常见的非线性方法：
- en: '**ISOMAP**: ISOMAP can be viewed as an extension of MDS, which uses the distance
    metric of geodesic distances. In this method, geodesic distance is computed by
    graphing the shortest path distances.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ISOMAP**：ISOMAP可以看作是多维尺度分析（MDS）的扩展，它使用测地距离的距离度量。在此方法中，测地距离是通过绘制最短路径距离来计算的。'
- en: '**LLE**: Locally linear embedding performs local PCA and global eigen-decomposition.
    LLE is a local approach, which involves selecting features for each category of
    the class feature. In contrast, ISOMAP is a global approach, which involves selecting
    features for all features.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**LLE**：局部线性嵌入（Locally linear embedding）执行局部PCA和全局特征分解。LLE是一种局部方法，它涉及为每个类特征类别选择特征。相比之下，ISOMAP是一种全局方法，它涉及为所有特征选择特征。'
- en: In this chapter, we will first discuss how to perform feature ranking and selection.
    Next, we will focus on the topic of feature extraction and cover recipes in performing
    dimension reduction with both linear and nonlinear methods. For linear methods,
    we will introduce how to perform PCA, determine the number of principal components,
    and its visualization. We then move on to MDS and SVD. Furthermore, we will introduce
    the application of SVD to compress images. For nonlinear methods, we will introduce
    how to perform dimension reduction with ISOMAP and LLE.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将首先讨论如何进行特征排名和选择。接下来，我们将聚焦于特征提取的主题，并涵盖使用线性和非线性方法进行降维的食谱。对于线性方法，我们将介绍如何执行主成分分析（PCA），确定主成分的数量及其可视化。然后，我们将继续介绍多维尺度分析（MDS）和奇异值分解（SVD）。此外，我们将介绍SVD在图像压缩中的应用。对于非线性方法，我们将介绍如何使用ISOMAP和LLE进行降维。
- en: Performing feature selection with FSelector
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用FSelector进行特征选择
- en: The `FSelector` package provides two approaches to select the most influential
    features from the original feature set. Firstly, rank features by some criteria
    and select the ones that are above a defined threshold. Secondly, search for optimum
    feature subsets from a space of feature subsets. In this recipe, we will introduce
    how to perform feature selection with the `FSelector` package.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`FSelector`包提供了两种从原始特征集中选择最具影响力的特征的方法。首先，根据某些标准对特征进行排名，并选择那些高于定义阈值的特征。其次，从一个特征子集的空间中搜索最佳特征子集。在本食谱中，我们将介绍如何使用`FSelector`包进行特征选择。'
- en: Getting ready
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will continue to use the telecom `churn` dataset as the input
    data source to train the support vector machine. For those who have not prepared
    the dataset, please refer to [Chapter 5](part0060_split_000.html#page "Chapter 5. Classification
    (I) – Tree, Lazy, and Probabilistic"), *Classification (I) – Tree, Lazy, and Probabilistic*,
    for detailed information.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将继续使用电信`churn`数据集作为输入数据源来训练支持向量机。对于那些尚未准备数据集的人，请参阅[第5章](part0060_split_000.html#page
    "第5章. 分类（I） – 树、懒惰和概率"), *分类（I） – 树、懒惰和概率*，以获取详细信息。
- en: How to do it...
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Perform the following steps to perform feature selection on a `churn` dataset:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以在`churn`数据集上执行特征选择：
- en: 'First, install and load the package, `FSelector`:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，安装并加载包，`FSelector`：
- en: '[PRE0]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, we can use `random.forest.importance` to calculate the weight for each
    attribute, where we set the importance type to 1:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以使用`random.forest.importance`计算每个属性的权重，我们将重要性类型设置为1：
- en: '[PRE1]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, we can use the `cutoff` function to obtain the attributes of the top
    five weights:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们可以使用`cutoff`函数获取前五个权重的属性：
- en: '[PRE2]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, we can make an evaluator to select the feature subsets:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们可以创建一个评估器来选择特征子集：
- en: '[PRE3]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Finally, we can find the optimum feature subset using a hill climbing search:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以使用爬山搜索找到最佳特征子集：
- en: '[PRE4]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How it works...
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In this recipe, we present how to use the `FSelector` package to select the
    most influential features. We first demonstrate how to use the feature ranking
    approach. In the feature ranking approach, the algorithm first employs a weight
    function to generate weights for each feature. Here, we use the random forest
    algorithm with the mean decrease in accuracy (where `importance.type = 1`) as
    the importance measurement to gain the weights of each attribute. Besides the
    random forest algorithm, you can select other feature ranking algorithms (for
    example, `chi.squared`, `information.gain`) from the `FSelector` package. Then,
    the process sorts attributes by their weight. At last, we can obtain the top five
    features from the sorted feature list with the `cutoff` function. In this case,
    `number_customer_service_calls`, `international_plan, total_day_charge`, `total_day_minutes`,
    and `total_intl_calls` are the five most important features.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们展示了如何使用`FSelector`包来选择最有影响力的特征。我们首先演示了如何使用特征排名方法。在特征排名方法中，算法首先使用一个权重函数为每个特征生成权重。在这里，我们使用随机森林算法，以平均准确度下降（其中`importance.type
    = 1`）作为重要性度量来获取每个属性的权重。除了随机森林算法之外，您还可以从`FSelector`包中选择其他特征排名算法（例如，`chi.squared`，`information.gain`）。然后，该过程按权重对属性进行排序。最后，我们可以使用`cutoff`函数从排序的特征列表中获得前五个特征。在这种情况下，`number_customer_service_calls`，`international_plan`，`total_day_charge`，`total_day_minutes`和`total_intl_calls`是五个最重要的特征。
- en: Next, we illustrate how to search for optimum feature subsets. First, we need
    to make a five-fold cross-validation function to evaluate the importance of feature
    subsets. Then, we use the hill climbing searching algorithm to find the optimum
    feature subsets from the original feature sets. Besides the hill-climbing method,
    one can select other feature selection algorithms (for example, `forward.search`)
    from the `FSelector` package. Lastly, we can find that `international_plan + voice_mail_plan
    + number_vmail_messages + total_day_minutes + total_day_calls + total_eve_minutes
    + total_eve_charge + total_intl_minutes + total_intl_calls + total_intl_charge
    + number_customer_service_calls` are optimum feature subsets.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将说明如何搜索最佳特征子集。首先，我们需要创建一个五折交叉验证函数来评估特征子集的重要性。然后，我们使用爬山搜索算法从原始特征集中找到最佳特征子集。除了爬山法之外，您还可以从`FSelector`包中选择其他特征选择算法（例如，`forward.search`）。最后，我们可以发现`international_plan
    + voice_mail_plan + number_vmail_messages + total_day_minutes + total_day_calls
    + total_eve_minutes + total_eve_charge + total_intl_minutes + total_intl_calls
    + total_intl_charge + number_customer_service_calls`是最佳特征子集。
- en: See also
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考内容
- en: You can also use the `caret` package to perform feature selection. As we have
    discussed related recipes in the model assessment chapter, you can refer to [Chapter
    7](part0083_split_000.html#page "Chapter 7. Model Evaluation"), *Model Evaluation*,
    for more detailed information.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您也可以使用`caret`包来进行特征选择。正如我们在模型评估章节中讨论了相关食谱，您可以参考[第7章](part0083_split_000.html#page
    "第7章。模型评估")，*模型评估*，以获取更详细的信息。
- en: 'For both feature ranking and optimum feature selection, you can explore the
    package, `FSelector`, for more related functions:'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于特征排名和最佳特征选择，您可以探索`FSelector`包以获取更多相关函数：
- en: '[PRE5]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Performing dimension reduction with PCA
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用PCA进行降维
- en: '**Principal component analysis** (**PCA**) is the most widely used linear method
    in dealing with dimension reduction problems. It is useful when data contains
    many features, and there is redundancy (correlation) within these features. To
    remove redundant features, PCA maps high dimension data into lower dimensions
    by reducing features into a smaller number of principal components that account
    for most of the variance of the original features. In this recipe, we will introduce
    how to perform dimension reduction with the PCA method.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**主成分分析**（**PCA**）是处理降维问题中最广泛使用的线性方法。当数据包含许多特征，并且这些特征之间存在冗余（相关性）时，它非常有用。为了去除冗余特征，PCA通过将特征减少到更少的、解释原始特征大部分方差的主成分，将高维数据映射到低维。在这个示例中，我们将介绍如何使用PCA方法进行降维。'
- en: Getting ready
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will use the `swiss` dataset as our target to perform PCA.
    The `swiss` dataset includes standardized fertility measures and socio-economic
    indicators from around the year 1888 for each of the 47 French-speaking provinces
    of Switzerland.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将使用`swiss`数据集作为我们的目标来执行PCA。`swiss`数据集包括来自瑞士47个法语省份大约1888年的标准化生育指标和社会经济指标。
- en: How to do it...
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Perform the following steps to perform principal component analysis on the
    `swiss` dataset:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以对`swiss`数据集进行主成分分析：
- en: 'First, load the `swiss` dataset:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，加载`swiss`数据集：
- en: '[PRE6]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Exclude the first column of the `swiss` data:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 排除`swiss`数据的第一列：
- en: '[PRE7]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You can then perform principal component analysis on the `swiss` data:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，你可以对`swiss`数据进行主成分分析：
- en: '[PRE8]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Obtain a summary from the PCA results:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从PCA结果中获取摘要：
- en: '[PRE9]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Lastly, you can use the `predict` function to output the value of the principal
    component with the first row of data:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，你可以使用`predict`函数输出数据第一行的主成分值：
- en: '[PRE10]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: How it works...
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Since the feature selection method may remove some correlated but informative
    features, you have to consider combining these correlated features into a single
    feature with the feature extraction method. PCA is one of the feature extraction
    methods, which performs orthogonal transformation to convert possibly correlated
    variables into principal components. Also, you can use these principal components
    to identify the directions of variance.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 由于特征选择方法可能会移除一些相关但具有信息量的特征，你必须考虑使用特征提取方法将这些相关特征组合成一个单一的特征。PCA是特征提取方法之一，它通过正交变换将可能相关的变量转换为主成分。此外，你可以使用这些主成分来识别方差的方向。
- en: 'The process of PCA is carried on by the following steps: firstly, find the
    mean vector, ![How it works...](img/00217.jpeg), where ![How it works...](img/00218.jpeg)
    indicates the data point, and *n* denotes the number of points. Secondly, compute
    the covariance matrix by the equation, ![How it works...](img/00219.jpeg). Thirdly,
    compute the eigenvectors,![How it works...](img/00220.jpeg), and the corresponding
    eigenvalues. In the fourth step, we rank and choose the top *k* eigenvectors.
    In the fifth step, we construct a *d x k* dimensional eigenvector matrix, U. Here,
    *d* is the number of original dimensions and *k* is the number of eigenvectors.
    Finally, we can transform data samples to a new subspace in the equation, ![How
    it works...](img/00221.jpeg).'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: PCA的过程通过以下步骤进行：首先，找到均值向量，![它是如何工作的...](img/00217.jpeg)，其中![它是如何工作的...](img/00218.jpeg)表示数据点，*n*表示点的数量。其次，通过方程计算协方差矩阵，![它是如何工作的...](img/00219.jpeg)。第三，计算特征向量，![它是如何工作的...](img/00220.jpeg)，以及相应的特征值。在第四步，我们按顺序选择前*k*个特征向量。在第五步，我们构建一个*d
    x k*维的特征向量矩阵，U。在这里，*d*是原始维度的数量，*k*是特征向量的数量。最后，我们可以在方程中变换数据样本到新的子空间，![它是如何工作的...](img/00221.jpeg)。
- en: 'In the following figure, it is illustrated that we can use two principal components,
    ![How it works...](img/00222.jpeg), and ![How it works...](img/00223.jpeg), to
    transform the data point from a two-dimensional space to new two-dimensional subspace:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下图中，说明了我们可以使用两个主成分，![它是如何工作的...](img/00222.jpeg)和![它是如何工作的...](img/00223.jpeg)，将数据点从二维空间转换到新的二维子空间：
- en: '![How it works...](img/00224.jpeg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/00224.jpeg)'
- en: A sample illustration of PCA
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: PCA的一个示例说明
- en: In this recipe we use the `prcomp` function from the `stats` package to perform
    PCA on the `swiss` dataset. First, we remove the standardized fertility measures
    and use the rest of the predictors as input to the function, `prcomp`. In addition
    to this, we set `swiss` as an input dataset; the variable should be shifted to
    the zero center by specifying `center=TRUE`; scale variables into the unit variance
    with the option, `scale=TRUE`, and store the output in the variable, `swiss.pca`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们使用`stats`包中的`prcomp`函数对`swiss`数据集进行PCA。首先，我们移除标准化的生育率指标，并将剩余的预测变量作为输入传递给函数`prcomp`。此外，我们将`swiss`作为输入数据集；变量应通过指定`center=TRUE`移至零中心；通过选项`scale=TRUE`将变量缩放到单位方差，并将输出存储在变量`swiss.pca`中。
- en: Then, as we print out the value stored in `swiss.pca`, we can find the standard
    deviation and rotation of the principal component. The standard deviation indicates
    the square root of the eigenvalues of the covariance/correlation matrix. On the
    other hand, the rotation of the principal components shows the coefficient of
    the linear combination of the input features. For example, PC1 equals *Agriculture
    * 0.524 + Examination * -0.572 + Education * -0.492 + Catholic* 0.385 + Infant.Mortality
    * 0.092*. Here, we can find that the attribute, *Agriculture*, contributes the
    most for PC1, for it has the highest coefficient.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当我们打印出存储在 `swiss.pca` 中的值时，我们可以找到主成分的标准差和旋转。标准差表示协方差/相关矩阵的特征值的平方根。另一方面，主成分的旋转显示了输入特征的线性组合的系数。例如，PC1
    等于 *Agriculture * 0.524 + Examination * -0.572 + Education * -0.492 + Catholic*
    0.385 + Infant.Mortality * 0.092*。在这里，我们可以发现属性 *Agriculture* 对 PC1 的贡献最大，因为它具有最高的系数。
- en: Additionally, we can use the `summary` function to obtain the importance of
    components. The first row shows the standard deviation of each principal component,
    the second row shows the proportion of variance explained by each component, and
    the third row shows the cumulative proportion of the explained variance. Finally,
    you can use the `predict` function to obtain principal components from the input
    features. Here, we input the first row of the dataset, and retrieve five principal
    components.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以使用 `summary` 函数获取成分的重要性。第一行显示每个主成分的标准差，第二行显示每个成分解释的方差比例，第三行显示解释的方差累积比例。最后，你可以使用
    `predict` 函数从输入特征中获取主成分。在这里，我们输入数据集的第一行，并检索五个主成分。
- en: There's more...
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Another principal component analysis function is `princomp`. In this function,
    the calculation is performed by using eigen on a correlation or covariance matrix
    instead of a single value decomposition used in the `prcomp` function. In general
    practice, using `prcomp` is preferable; however, we cover how to use `princomp`
    here:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个主成分分析函数是 `princomp`。在这个函数中，计算是通过在相关或协方差矩阵上使用特征值而不是 `prcomp` 函数中使用的单一值分解来进行的。在一般实践中，使用
    `prcomp` 是首选的；然而，我们在这里介绍了如何使用 `princomp`：
- en: 'First, use `princomp` to perform PCA:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，使用 `princomp` 执行主成分分析（PCA）：
- en: '[PRE11]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You can then obtain the summary information:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，你可以获取摘要信息：
- en: '[PRE12]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You can use the `predict` function to obtain principal components from the
    input features:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以使用 `predict` 函数从输入特征中获取主成分：
- en: '[PRE13]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In addition to the `prcomp` and `princomp` functions from the `stats` package,
    you can use the `principal` function from the `psych` package:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `stats` 包中的 `prcomp` 和 `princomp` 函数外，你还可以使用 `psych` 包中的 `principal` 函数：
- en: 'First, install and load the `psych` package:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，安装并加载 `psych` 包：
- en: '[PRE14]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You can then use the `principal` function to retrieve the principal components:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，你可以使用 `principal` 函数检索主成分：
- en: '[PRE15]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Determining the number of principal components using the scree test
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用斯皮尔曼测试确定主成分的数量
- en: As we only need to retain the principal components that account for most of
    the variance of the original features, we can either use the Kaiser method, scree
    test, or the percentage of variation explained as the selection criteria. The
    main purpose of a scree test is to graph the component analysis results as a scree
    plot and find where the obvious change in the slope (elbow) occurs. In this recipe,
    we will demonstrate how to determine the number of principal components using
    a scree plot.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们只需要保留解释原始特征大部分方差的主成分，我们可以使用凯撒方法、斯皮尔曼测试或解释的方差百分比作为选择标准。斯皮尔曼测试的主要目的是将成分分析结果以斯皮尔曼图的形式绘制出来，并找到斜率（肘部）发生明显变化的位置。在这个菜谱中，我们将演示如何使用斯皮尔曼图确定主成分的数量。
- en: Getting ready
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Ensure that you have completed the previous recipe by generating a principal
    component object and save it in the variable, `swiss.pca`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你已经完成了前面的菜谱，通过生成主成分对象并将其保存在变量 `swiss.pca` 中。
- en: How to do it...
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Perform the following steps to determine the number of principal components
    with the scree plot:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以使用斯皮尔曼图确定主成分的数量：
- en: 'First, you can generate a bar plot by using `screeplot`:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，你可以使用 `screeplot` 生成条形图：
- en: '[PRE16]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '![How to do it...](img/00225.jpeg)'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/00225.jpeg)'
- en: The scree plot in bar plot form
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以条形图形式展示的斯皮尔曼图
- en: 'You can also generate a line plot by using `screeplot`:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你也可以使用 `screeplot` 生成线形图：
- en: '[PRE17]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '![How to do it...](img/00226.jpeg)'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/00226.jpeg)'
- en: The scree plot in line plot form
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以线形图形式展示的斯皮尔曼图
- en: How it works...
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In this recipe, we demonstrate how to use a scree plot to determine the number
    of principal components. In a scree plot, there are two types of plots, namely,
    bar plots and line plots. As both generated scree plots reveal, the obvious change
    in slope (the so-called elbow or knee) occurs at component 2\. As a result, we
    should retain component 1, where the component is in a steep curve before component
    2, which is where the flat line trend commences. However, as this method can be
    ambiguous, you can use other methods (such as the Kaiser method) to determine
    the number of components.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在本菜谱中，我们展示了如何使用碎石图来确定主成分的数量。在碎石图中，有两种类型的图形，即柱状图和线形图。正如生成的碎石图所揭示的，斜率（所谓的拐点或膝部）的明显变化发生在第2个成分处。因此，我们应该保留第1个成分，在第2个成分之前，该成分处于陡峭的曲线，这是平坦线趋势开始的地方。然而，由于这种方法可能存在歧义，您可以使用其他方法（如凯撒方法）来确定成分的数量。
- en: There's more...
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'By default, if you use the `plot` function on a generated principal component
    object, you can also retrieve the scree plot. For more details on `screeplot`,
    please refer to the following document:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，如果您在生成的主成分对象上使用`plot`函数，您也可以检索碎石图。有关`screeplot`的更多详细信息，请参阅以下文档：
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You can also use `nfactors` to perform parallel analysis and nongraphical solutions
    to the Cattell scree test:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`nfactors`进行并行分析和Cattell碎石测试的非图形解决方案：
- en: '[PRE19]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '![There''s more...](img/00227.jpeg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![更多内容...](img/00227.jpeg)'
- en: Non-graphical solution to scree test
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 碎石测试的非图形解决方案
- en: Determining the number of principal components using the Kaiser method
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用凯撒方法确定主成分的数量
- en: In addition to the scree test, you can use the Kaiser method to determine the
    number of principal components. In this method, the selection criteria retains
    eigenvalues greater than `1`. In this recipe, we will demonstrate how to determine
    the number of principal components using the Kaiser method.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 除了碎石测试外，您还可以使用凯撒方法来确定主成分的数量。在此方法中，选择标准是保留大于`1`的特征值。在本菜谱中，我们将展示如何使用凯撒方法确定主成分的数量。
- en: Getting ready
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Ensure that you have completed the previous recipe by generating a principal
    component object and save it in the variable, `swiss.pca`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您已经完成了前面的菜谱，通过生成主成分对象并将其保存在变量`swiss.pca`中。
- en: How to do it...
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Perform the following steps to determine the number of principal components
    with the Kaiser method:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤使用凯撒方法确定主成分的数量：
- en: 'First, you can obtain the standard deviation from `swiss.pca`:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，您可以从`swiss.pca`中获取标准差：
- en: '[PRE20]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Next, you can obtain the variance from `swiss.pca`:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接着，您可以从`swiss.pca`中获取方差：
- en: '[PRE21]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Select components with a variance above 1:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择方差大于1的成分：
- en: '[PRE22]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You can also use the scree plot to select components with a variance above
    1:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您还可以使用碎石图来选择方差大于1的成分：
- en: '[PRE23]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '![How to do it...](img/00228.jpeg)'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/00228.jpeg)'
- en: Select component with variance above 1
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 选择方差大于1的成分
- en: How it works...
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: You can also use the Kaiser method to determine the number of components. As
    the computed principal component object contains the standard deviation of each
    component, we can compute the variance as the standard deviation, which is the
    square root of variance. From the computed variance, we find both component 1
    and 2 have a variance above 1\. Therefore, we can determine the number of principal
    components as 2 (both component 1 and 2). Also, we can draw a red line on the
    scree plot (as shown in the preceding figure) to indicate that we need to retain
    component 1 and 2 in this case.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用凯撒方法来确定成分的数量。由于计算出的主成分对象包含每个成分的标准差，我们可以将方差计算为标准差，即方差的平方根。从计算出的方差中，我们发现第1个和第2个成分的方差都大于1。因此，我们可以确定主成分的数量为2（第1个和第2个成分）。此外，我们可以在碎石图上画一条红线（如图所示）来表示在这种情况下我们需要保留第1个和第2个成分。
- en: See also
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考资料也
- en: 'In order to determine which principal components to retain, please refer to:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定要保留哪些主成分，请参考以下内容：
- en: 'Ledesma, R. D., and Valero-Mora, P. (2007). *Determining the Number of Factors
    to Retain in EFA: an easy-to-use computer program for carrying out Parallel Analysis*.
    *Practical Assessment, Research & Evaluation*, 12(2), 1-11.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ledesma, R. D. 和 Valero-Mora, P. (2007). *在EFA中确定要保留的因素数量：一个用于执行并行分析的易于使用的计算机程序*.
    *实用评估、研究和评估*, 12(2), 1-11.
- en: Visualizing multivariate data using biplot
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用双图可视化多元数据
- en: In order to find out how data and variables are mapped in regard to the principal
    component, you can use `biplot`, which plots data and the projections of original
    features on to the first two components. In this recipe, we will demonstrate how
    to use `biplot` to plot both variables and data on the same figure.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找出数据变量如何映射到主成分上，您可以使用`biplot`，它将数据以及原始特征在第一两个成分上的投影绘制出来。在这个菜谱中，我们将演示如何使用`biplot`在同一张图上绘制变量和数据。
- en: Getting ready
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Ensure that you have completed the previous recipe by generating a principal
    component object and save it in the variable, `swiss.pca`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您已经完成了之前的菜谱，通过生成主成分对象并将其保存在变量`swiss.pca`中。
- en: How to do it...
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Perform the following steps to create a biplot:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以创建biplot：
- en: 'You can create a scatter plot using component 1 and 2:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以使用成分1和2创建散点图：
- en: '[PRE24]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '![How to do it...](img/00229.jpeg)'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/00229.jpeg)'
- en: The scatter plot of first two components from PCA result
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: PCA结果的前两个成分的散点图
- en: 'If you would like to add features on the plot, you can create biplot using
    the generated principal component object:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您想在图上添加特征，您可以使用生成的主成分对象创建biplot：
- en: '[PRE25]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '![How to do it...](img/00230.jpeg)'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/00230.jpeg)'
- en: The biplot using PCA result
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用PCA结果的biplot
- en: How it works...
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In this recipe, we demonstrate how to use `biplot` to plot data and projections
    of original features on to the first two components. In the first step, we demonstrate
    that we can actually use the first two components to create a scatter plot. Furthermore,
    if you want to add variables on the same plot, you can use `biplot`. In `biplot`,
    you can see the provinces with higher indicators in the agriculture variable,
    lower indicators in the education variable, and examination variables scores that
    are higher in PC1\. On the other hand, the provinces with higher infant mortality
    indicators and lower agriculture indicators score higher in PC2.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们演示了如何使用`biplot`绘制数据和原始特征在第一两个成分上的投影。在第一步中，我们演示了实际上我们可以使用前两个成分来创建散点图。此外，如果您想在同一张图上添加变量，您可以使用`biplot`。在`biplot`中，您可以看到在农业变量中指标较高的省份，在教育变量中指标较低的省份，以及在PC1中得分较高的考试变量。另一方面，婴儿死亡率指标较高且农业指标较低的省份在PC2中得分较高。
- en: There's more...
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Besides `biplot` in the `stats` package, you can also use `ggbiplot`. However,
    you may not find this package from CRAN; you have to first install `devtools`
    and then install `ggbiplot` from GitHub:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`stats`包中的`biplot`，您还可以使用`ggbiplot`。但是，您可能无法从CRAN找到这个包；您必须首先安装`devtools`，然后从GitHub安装`ggbiplot`：
- en: '[PRE26]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '![There''s more...](img/00231.jpeg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多...](img/00231.jpeg)'
- en: The ggbiplot using PCA result
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 使用PCA结果的ggbiplot
- en: Performing dimension reduction with MDS
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用MDS进行降维
- en: '**Multidimensional scaling** (**MDS**) is a technique to create a visual presentation
    of similarities or dissimilarities (distance) of a number of objects. The *multi*
    prefix indicates that one can create a presentation map in one, two, or more dimensions.
    However, we most often use MDS to present the distance between data points in
    one or two dimensions.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**多维尺度分析**（**MDS**）是一种创建多个对象相似性或差异性（距离）的视觉表示的技术。*多*前缀表示可以在一维、二维或更多维度中创建一个表示图。然而，我们最常使用MDS来展示一维或二维数据点之间的距离。'
- en: In MDS, you can either use a metric or a nonmetric solution. The main difference
    between the two solutions is that metric solutions try to reproduce the original
    metric, while nonmetric solutions assume that the ranks of the distance are known.
    In this recipe, we will illustrate how to perform MDS on the `swiss` dataset.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在MDS中，您可以使用度量或非度量解决方案。两种解决方案之间的主要区别在于，度量解决方案试图重现原始度量，而非度量解决方案假设距离的排名是已知的。在这个菜谱中，我们将说明如何在`swiss`数据集上执行MDS。
- en: Getting ready
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will continue using the `swiss` dataset as our input data
    source.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将继续使用`swiss`数据集作为我们的输入数据源。
- en: How to do it...
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Perform the following steps to perform multidimensional scaling using the metric
    method:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以使用度量方法执行多维尺度分析：
- en: 'First, you can perform metric MDS with a maximum of two dimensions:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，您可以使用最多两个维度执行度量MDS：
- en: '[PRE27]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'You can then plot the `swiss` data in a two-dimension scatter plot:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，您可以将`swiss`数据绘制在二维散点图中：
- en: '[PRE28]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '![How to do it...](img/00232.jpeg)'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/00232.jpeg)'
- en: The 2-dimension scatter plot from cmdscale object
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从cmdscale对象得到的二维散点图
- en: 'In addition, you can perform nonmetric MDS with `isoMDS`:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，您可以使用`isoMDS`执行非度量MDS：
- en: '[PRE29]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You can also plot the data points in a two-dimension scatter plot:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你也可以在二维散点图上绘制数据点：
- en: '[PRE30]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '![How to do it...](img/00233.jpeg)'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/00233.jpeg)'
- en: The 2-dimension scatter plot from isoMDS object
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从isoMDS对象生成的二维散点图
- en: 'You can then plot the data points in a two-dimension scatter plot:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你还可以在二维散点图上绘制数据点：
- en: '[PRE31]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '![How to do it...](img/00234.jpeg)'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/00234.jpeg)'
- en: The Shepard plot from isoMDS object
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从isoMDS对象生成的谢泼德图
- en: How it works...
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作...
- en: 'MDS reveals the structure of the data by providing a visual presentation of
    similarities among a set of objects. In more detail, MDS places an object in an
    n-dimensional space, where the distances between pairs of points corresponds to
    the similarities among the pairs of objects. Usually, the dimensional space is
    a two-dimensional Euclidean space, but it may be non-Euclidean and have more than
    two dimensions. In accordance with the meaning of the input matrix, MDS can be
    mainly categorized into two types: metric MDS, where the input matrix is metric-based,
    nonmetric MDS, where the input matrix is nonmetric-based.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: MDS通过提供一组对象之间相似性的视觉表示来揭示数据的结构。更详细地说，MDS将一个对象放置在n维空间中，其中点对之间的距离对应于对象对之间的相似性。通常，维空间是二维欧几里得空间，但它可能是非欧几里得空间，并且具有超过两个维度。根据输入矩阵的意义，MDS可以主要分为两种类型：度量MDS，其中输入矩阵基于度量，非度量MDS，其中输入矩阵基于非度量。
- en: Metric MDS is also known as principal coordinate analysis, which first transforms
    a distance into similarities. In the simplest form, the process linearly projects
    original data points to a subspace by performing principal components analysis
    on similarities. On the other hand, the process can also perform a nonlinear projection
    on similarities by minimizing the stress value, ![How it works...](img/00235.jpeg),
    where ![How it works...](img/00236.jpeg) is the distance measurement between the
    two points, ![How it works...](img/00237.jpeg) and ![How it works...](img/00238.jpeg),
    and ![How it works...](img/00239.jpeg) is the similarity measure of two projected
    points, ![How it works...](img/00240.jpeg) and ![How it works...](img/00241.jpeg).
    As a result, we can represent the relationship among objects in the Euclidean
    space.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 度量MDS也称为主坐标分析，它首先将距离转换为相似性。在最简单的情况下，该过程通过在相似性上执行主成分分析，将原始数据点线性投影到子空间。另一方面，该过程也可以通过最小化应力值![如何工作...](img/00235.jpeg)对相似性进行非线性投影，其中![如何工作...](img/00236.jpeg)是两点之间的距离测量，![如何工作...](img/00237.jpeg)和![如何工作...](img/00238.jpeg)，而![如何工作...](img/00239.jpeg)是两个投影点的相似性度量，![如何工作...](img/00240.jpeg)和![如何工作...](img/00241.jpeg)。因此，我们可以在欧几里得空间中表示对象之间的关系。
- en: In contrast to metric MDS, which use a metric-based input matrix, a nonmetric-based
    MDS is used when the data is measured at the ordinal level. As only the rank order
    of the distances between the vectors is meaningful, nonmetric MDS applies a monotonically
    increasing function, f, on the original distances and projects the distance to
    new values that preserve the rank order. The normalized equation can be formulated
    as ![How it works...](img/00242.jpeg).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用基于度量的输入矩阵的度量MDS相比，当数据在序数级别测量时，使用基于非度量的MDS。由于只有向量之间距离的秩序是有意义的，非度量MDS在原始距离上应用单调递增函数f，并将距离投影到新的值，以保留秩序。归一化方程可以表示为![如何工作...](img/00242.jpeg)。
- en: In this recipe, we illustrate how to perform metric and nonmetric MDS on the
    `swiss` dataset. To perform metric MDS, we first need to obtain the distance metric
    from the `swiss` data. In this step, you can replace the distance measure to any
    measure as long as it produces a similarity/dissimilarity measure of data points.
    You can use `cmdscale` to perform metric multidimensional scaling. Here, we specify
    `k = 2`, so the maximum generated dimensions equals `2`. You can also visually
    present the distance of the data points on a two-dimensional scatter plot.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们展示了如何在`swiss`数据集上执行度量和非度量MDS。要执行度量MDS，我们首先需要从`swiss`数据中获得距离度量。在这个步骤中，你可以将距离度量替换为任何度量，只要它产生数据点的相似性/不相似性度量。你可以使用`cmdscale`来执行度量多维度缩放。在这里，我们指定`k
    = 2`，因此生成的最大维度等于`2`。你还可以在二维散点图上直观地表示数据点的距离。
- en: Next, you can perform nonmetric MDS with `isoMDS`. In nonmetric MDS, we do not
    match the distances, but only arrange them in order. We also set `swiss` as an
    input dataset with maximum dimensions of two. Similar to the metric MDS example,
    we can plot the distance between data points on a two-dimensional scatter plot.
    Then, we use a Shepard plot, which shows how well the projected distances match
    those in the distance matrix. As per the figure in step 4, the projected distance
    matches well in the distance matrix.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你可以使用`isoMDS`执行非度量MDS。在非度量MDS中，我们不匹配距离，而只是按顺序排列它们。我们还将`swiss`设置为输入数据集，最大维度为两个。与度量MDS示例类似，我们可以在二维散点图上绘制数据点之间的距离。然后，我们使用谢泼德图，它显示了投影距离与距离矩阵中的距离匹配得有多好。根据步骤4中的图，投影距离在距离矩阵中匹配得很好。
- en: There's more...
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Another visualization method is to present an MDS object as a graph. A sample
    code is listed here:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种可视化方法是将以图形的形式表示MDS对象。以下是一个示例代码：
- en: '[PRE32]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '![There''s more...](img/00243.jpeg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多...](img/00243.jpeg)'
- en: The graph presentation of MDS object
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: MDS对象的图形表示
- en: 'You can also compare differences between the generated results from MDS and
    PCA. You can compare their differences by drawing the projected dimensions on
    the same scatter plot. If you use a Euclidean distance on MDS, the projected dimensions
    are exactly the same as the ones projected from PCA:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以比较MDS和PCA生成的结果之间的差异。你可以通过在同一散点图上绘制投影维度来比较它们的差异。如果你在MDS中使用欧几里得距离，则投影维度与从PCA投影的维度完全相同：
- en: '[PRE33]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '![There''s more...](img/00244.jpeg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多...](img/00244.jpeg)'
- en: The comparison between MDS and PCA
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: MDS与PCA的比较
- en: Reducing dimensions with SVD
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SVD降维
- en: '**Singular value decomposition** (**SVD**) is a type of matrix factorization
    (decomposition), which can factorize matrices into two orthogonal matrices and
    diagonal matrices. You can multiply the original matrix back using these three
    matrices. SVD can reduce redundant data that is linear dependent from the perspective
    of linear algebra. Therefore, it can be applied to feature selection, image processing,
    clustering, and many other fields. In this recipe, we will illustrate how to perform
    dimension reduction with SVD.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '**奇异值分解**（**SVD**）是一种矩阵分解（分解）类型，可以将矩阵分解为两个正交矩阵和对角矩阵。你可以使用这三个矩阵将原始矩阵乘回。从线性代数的角度来看，SVD可以减少线性相关的冗余数据。因此，它可以应用于特征选择、图像处理、聚类以及许多其他领域。在这个菜谱中，我们将说明如何使用SVD进行降维。'
- en: Getting ready
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will continue using the dataset, `swiss`, as our input data
    source.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将继续使用数据集`swiss`作为我们的输入数据源。
- en: How to do it...
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Perform the following steps to perform dimension reduction using SVD:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以使用SVD进行降维：
- en: 'First, you can perform `svd` on the `swiss` dataset:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，你可以在`swiss`数据集上执行`svd`：
- en: '[PRE34]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'You can then plot the percentage of variance explained and the cumulative variance
    explained in accordance with the SVD column:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，你可以根据SVD列绘制解释的方差百分比和累积解释的方差百分比：
- en: '[PRE35]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '![How to do it...](img/00245.jpeg)'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/00245.jpeg)'
- en: The percent of variance explained
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 解释的方差百分比
- en: '[PRE36]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '![How to do it...](img/00246.jpeg)'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/00246.jpeg)'
- en: Cumulative percent of variance explained
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 累积方差百分比
- en: 'Next, you can reconstruct the data with only one singular vector:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，你可以使用仅一个奇异向量来重建数据：
- en: '[PRE37]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Lastly, you can compare the original dataset with the constructed dataset in
    an image:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，你可以在图像中比较原始数据集与构建的数据集：
- en: '[PRE38]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '![How to do it...](img/00247.jpeg)'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/00247.jpeg)'
- en: The comparison between original dataset and re-constructed dataset
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 原始数据集与重建数据集之间的比较
- en: How it works...
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作...
- en: SVD is a factorization of a real or complex matrix. In detail, the SVD of m
    x n matrix, A, is the factorization of A into the product of three matrices, ![How
    it works...](img/00248.jpeg). Here, U is an m x m orthonormal matrix, D has singular
    values and is an m x n diagonal matrix, and V^T is an n x n orthonormal matrix.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: SVD是实数或复数矩阵的分解。具体来说，m x n矩阵A的SVD是将A分解为三个矩阵的乘积![如何工作...](img/00248.jpeg)。在这里，U是一个m
    x m的正交矩阵，D包含奇异值，是一个m x n的对角矩阵，V^T是一个n x n的正交矩阵。
- en: 'In this recipe, we demonstrate how to perform dimension reduction with SVD.
    First, you can apply the `svd` function on the `swiss` dataset to obtain factorized
    matrices. You can then generate two plots: one shows the variance explained in
    accordance to a singular vector, the other shows the cumulative variance explained
    in accordance to a singular vector.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们展示了如何使用SVD进行降维。首先，你可以在`swiss`数据集上应用`svd`函数以获得分解矩阵。然后你可以生成两个图表：一个显示了根据奇异向量解释的方差，另一个显示了根据奇异向量解释的累积方差。
- en: The preceding figure shows that the first singular vector can explain 80 percent
    of variance. We now want to compare the differences from the original dataset
    and the reconstructed dataset with a single singular vector. We, therefore, reconstruct
    the data with a single singular vector and use the `image` function to present
    the original and reconstructed datasets side-by-side and see how they differ from
    each other. The next figure reveals that these two images are very similar.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图表明第一个奇异向量可以解释80%的方差。我们现在想比较原始数据集和仅使用一个奇异向量重建的数据集之间的差异。因此，我们使用单个奇异向量重建数据，并使用`image`函数将原始和重建的数据集并排展示，以查看它们之间的差异。下一个图显示这两个图像非常相似。
- en: See also
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考阅读
- en: 'As we mentioned earlier, PCA can be regarded as a specific case of SVD. Here,
    we generate the orthogonal vector from the `swiss` data from SVD and obtained
    the rotation from `prcomp`. We can see that the two generated matrices are the
    same:'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如我们之前提到的，PCA可以被视为SVD的一个特例。在这里，我们从SVD生成的`swiss`数据的正交向量，并从`prcomp`获得旋转。我们可以看到这两个生成的矩阵是相同的：
- en: '[PRE39]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Compressing images with SVD
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SVD压缩图像
- en: In the previous recipe, we demonstrated how to factorize a matrix with SVD and
    then reconstruct the dataset by multiplying the decomposed matrix. Furthermore,
    the application of matrix factorization can be applied to image compression. In
    this recipe, we will demonstrate how to perform SVD on the classic image processing
    material, Lenna.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个食谱中，我们展示了如何使用SVD分解矩阵，然后通过乘以分解矩阵来重建数据集。此外，矩阵分解的应用可以应用于图像压缩。在这个食谱中，我们将展示如何对经典图像处理材料Lenna执行SVD。
- en: Getting ready
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, you should download the image of Lenna beforehand (refer to
    [http://www.ece.rice.edu/~wakin/images/lena512.bmp](http://www.ece.rice.edu/~wakin/images/lena512.bmp)
    for this), or you can prepare an image of your own to see how image compression
    works.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，你应该事先下载Lenna的图像（参考[http://www.ece.rice.edu/~wakin/images/lena512.bmp](http://www.ece.rice.edu/~wakin/images/lena512.bmp)），或者你可以准备你自己的图像来查看图像压缩是如何工作的。
- en: How to do it...
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Perform the following steps to compress an image with SVD:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以使用SVD压缩图像：
- en: 'First, install and load `bmp`:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，安装并加载`bmp`：
- en: '[PRE40]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'You can then read the image of Lenna as a numeric matrix with the `read.bmp`
    function. When the reader downloads the image, the default name is `lena512.bmp`:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以使用`read.bmp`函数将Lenna的图像读取为一个数值矩阵。当读取器下载图像时，默认名称是`lena512.bmp`：
- en: '[PRE41]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Rotate and plot the image:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 旋转并绘制图像：
- en: '[PRE42]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '![How to do it...](img/00249.jpeg)'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/00249.jpeg)'
- en: The picture of Lenna
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Lenna的图片
- en: 'Next, you can perform SVD on the read numeric matrix and plot the percentage
    of variance explained:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，你可以对读取的数值矩阵执行SVD并绘制解释方差的百分比：
- en: '[PRE43]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '![How to do it...](img/00250.jpeg)'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/00250.jpeg)'
- en: The percentage of variance explained
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 解释方差的百分比
- en: 'Next, you can obtain the number of dimensions to reconstruct the image:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，你可以获得重建图像所需的维度数：
- en: '[PRE44]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Obtain the point at which the singular vector can explain more than 90 percent
    of the variance:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获得奇异向量可以解释超过90%方差的点：
- en: '[PRE45]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'You can also wrap the code into a function, `lenna_compression`, and you can
    then use this function to plot compressed Lenna:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你也可以将代码封装成一个函数，`lenna_compression`，然后你可以使用这个函数来绘制压缩后的Lenna：
- en: '[PRE46]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Also, you can use 18 vectors to reconstruct the image:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，你可以使用18个向量来重建图像：
- en: '[PRE47]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '![How to do it...](img/00251.jpeg)'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/00251.jpeg)'
- en: The reconstructed image with 18 components
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由18个组件重建的图像
- en: You can obtain the point at which the singular vector can explain more than
    99 percent of the variance;
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以获得奇异向量可以解释超过99%方差的点；
- en: '[PRE48]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '![How to do it...](img/00252.jpeg)'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/00252.jpeg)'
- en: The reconstructed image with 92 components
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由92个组件重建的图像
- en: How it works...
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we demonstrate how to compress an image with SVD. In the first
    step, we use the package, `bmp`, to load the image, Lenna, to an R session. Then,
    as the read image is rotated, we can rotate the image back and use the `plot`
    function to plot Lenna in R (as shown in the figure in step 3). Next, we perform
    SVD on the image matrix to factorize the matrix. We then plot the percentage of
    variance explained in regard to the number of singular vectors.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在本菜谱中，我们展示了如何使用SVD压缩图像。在第一步中，我们使用`bmp`包将图像Lenna加载到R会话中。然后，由于读取的图像已旋转，我们可以将图像旋转回来并使用`plot`函数在R中绘制Lenna（如图3步中的图所示）。接下来，我们对图像矩阵进行SVD分解，然后绘制与奇异向量数量相关的方差解释百分比。
- en: Further, as we discover that we can use 18 components to explain 90 percent
    of the variance, we then use these 18 components to reconstruct Lenna. Thus, we
    make a function named `lenna_compression` with the purpose of reconstructing the
    image by matrix multiplication. As a result, we enter 18 as the input to the function,
    which returns a rather blurry Lenna image (as shown in the figure in step 8).
    However, we can at least see an outline of the image. To obtain a clearer picture,
    we discover that we can use 92 components to explain 99 percent of the variance.
    We, therefore, set the input to the function, `lenna_compression`, as 92\. The
    figure in step 9 shows that this generates a clearer picture than the one constructed
    using merely 18 components.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们发现可以使用18个成分解释90%的方差，因此我们使用这18个成分来重建Lenna。因此，我们创建了一个名为`lenna_compression`的函数，其目的是通过矩阵乘法重建图像。结果，我们将18作为函数的输入，返回一个相当模糊的Lenna图像（如图8步中的图所示）。然而，我们至少可以看到图像的轮廓。为了获得更清晰的图像，我们发现可以使用92个成分解释99%的方差。因此，我们将函数`lenna_compression`的输入设置为92。第9步中的图显示，这比仅使用18个成分构建的图像更清晰。
- en: See also
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The Lenna picture is one of the most widely used standard test images for compression
    algorithms. For more details on the Lenna picture, please refer to [http://www.cs.cmu.edu/~chuck/lennapg/](http://www.cs.cmu.edu/~chuck/lennapg/).
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lenna图片是压缩算法最广泛使用的标准测试图像之一。有关Lenna图片的更多详细信息，请参阅[http://www.cs.cmu.edu/~chuck/lennapg/](http://www.cs.cmu.edu/~chuck/lennapg/)。
- en: Performing nonlinear dimension reduction with ISOMAP
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ISOMAP进行非线性降维
- en: ISOMAP is one of the approaches for manifold learning, which generalizes linear
    framework to nonlinear data structures. Similar to MDS, ISOMAP creates a visual
    presentation of similarities or dissimilarities (distance) of a number of objects.
    However, as the data is structured in a nonlinear format, the Euclidian distance
    measure of MDS is replaced by the geodesic distance of a data manifold in ISOMAP.
    In this recipe, we will illustrate how to perform a nonlinear dimension reduction
    with ISOMAP.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: ISOMAP是流形学习的一种方法，它将线性框架推广到非线性数据结构。与MDS类似，ISOMAP创建了一系列对象相似性或差异性（距离）的视觉表示。然而，由于数据以非线性格式结构化，MDS的欧几里得距离度量在ISOMAP中被数据流形的地形距离所取代。在本菜谱中，我们将说明如何使用ISOMAP进行非线性降维。
- en: Getting ready
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will use the `digits` data from `RnavGraphImageData` as our
    input source.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在本菜谱中，我们将使用来自`RnavGraphImageData`的`digits`数据作为我们的输入源。
- en: How to do it...
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Perform the following steps to perform nonlinear dimension reduction with ISOMAP:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以使用ISOMAP进行非线性降维：
- en: 'First, install and load the `RnavGraphImageData` and `vegan` packages:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，安装并加载`RnavGraphImageData`和`vegan`包：
- en: '[PRE49]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'You can then load the dataset, `digits`:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，你可以加载数据集`digits`：
- en: '[PRE50]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Rotate and plot the image:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 旋转并绘制图像：
- en: '[PRE51]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '![How to do it...](img/00253.jpeg)'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/00253.jpeg)'
- en: A sample image from the digits dataset
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 来自数字数据集的一个示例图像
- en: 'Next, you can randomly sample 300 digits from the population:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，你可以从总体中随机抽取300个数字：
- en: '[PRE52]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Transpose the selected digit data and then compute the dissimilarity between
    objects using `vegdist`:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将选定的数字数据转置，然后使用`vegdist`计算对象之间的差异：
- en: '[PRE53]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Next, you can use `isomap` to perform dimension reduction:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，你可以使用`isomap`进行降维：
- en: '[PRE54]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '![How to do it...](img/00254.jpeg)'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/00254.jpeg)'
- en: A 2-dimension scatter plot from ISOMAP object
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ISOMAP对象的一个二维散点图
- en: Finally, you can overlay the scatter plot with the minimum spanning tree, marked
    in red;
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，你可以将散点图与红色标记的最小生成树叠加；
- en: '[PRE55]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '![How to do it...](img/00255.jpeg)'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/00255.jpeg)'
- en: A 2-dimension scatter plot overlay with minimum spanning tree
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 二维散点图与最小生成树的叠加
- en: How it works...
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: ISOMAP is a nonlinear dimension reduction method and a representative of isometric
    mapping methods. ISOMAP can be regarded as an extension of the metric MDS, where
    pairwise the Euclidean distance among data points is replaced by geodesic distances
    induced by a neighborhood graph.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: ISOMAP 是一种非线性降维方法，也是等距映射方法的代表。ISOMAP 可以被视为度量 MDS 的扩展，其中数据点之间的成对欧几里得距离被由邻域图诱导的测地距离所取代。
- en: The description of the ISOMAP algorithm is shown in four steps. First, determine
    the neighbor of each point. Secondly, construct a neighborhood graph. Thirdly,
    compute the shortest distance path between two nodes. At last, find a low dimension
    embedding of the data by performing MDS.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: ISOMAP 算法的描述分为四个步骤。首先，确定每个点的邻居。其次，构建一个邻域图。第三，计算两个节点之间的最短距离路径。最后，通过执行 MDS 找到数据的一个低维嵌入。
- en: In this recipe, we demonstrate how to perform a nonlinear dimension reduction
    using ISOMAP. First, we load the digits data from `RnavGraphImageData`. Then,
    after we select one digit and plot its rotated image, we can see an image of the
    handwritten digit (the numeral 3, in the figure in step 3).
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们展示了如何使用 ISOMAP 进行非线性降维。首先，我们从 `RnavGraphImageData` 加载数字数据。然后，在我们选择一个数字并绘制其旋转图像后，我们可以看到一个手写数字的图像（第3步中的图中的数字3）。
- en: Next, we randomly sample 300 digits as our input data to ISOMAP. We then transpose
    the dataset to calculate the distance between each image object. Once the data
    is ready, we calculate the distance between each object and perform a dimension
    reduction. Here, we use `vegdist` to calculate the dissimilarities between each
    object using a Euclidean measure. We then use ISOMAP to perform a nonlinear dimension
    reduction on the `digits` data with the dimension set as `6`, number of shortest
    dissimilarities retained for a point as `8`, and ensure that you analyze the largest
    connected group by specifying `fragmentedOK` as `TRUE`.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们随机抽取300个数字作为我们的输入数据给 ISOMAP。然后我们将数据集转置以计算每个图像对象之间的距离。一旦数据准备就绪，我们计算每个对象之间的距离并进行降维。在这里，我们使用
    `vegdist` 通过欧几里得度量计算每个对象之间的不相似性。然后我们使用 ISOMAP 对 `digits` 数据进行非线性降维，维度设置为 `6`，保留一个点的最短不相似性数量为
    `8`，并确保通过指定 `fragmentedOK` 为 `TRUE` 来分析最大的连通组。
- en: Finally, we can use the generated ISOMAP object to make a two-dimension scatter
    plot (figure in step 6), and also overlay the minimum spanning tree with lines
    in red on the scatter plot (figure in step 7).
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以使用生成的 ISOMAP 对象制作一个二维散点图（第6步中的图），并在散点图上用红色线条叠加最小生成树（第7步中的图）。
- en: There's more...
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: You can also use the `RnavGraph` package to visualize high dimensional data
    (digits in this case) using graphs as a navigational infrastructure. For more
    information, please refer to [http://www.icesi.edu.co/CRAN/web/packages/RnavGraph/vignettes/RnavGraph.pdf](http://www.icesi.edu.co/CRAN/web/packages/RnavGraph/vignettes/RnavGraph.pdf).
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 `RnavGraph` 包通过图形作为导航基础设施来可视化高维数据（在这个例子中是数字）。有关更多信息，请参阅 [http://www.icesi.edu.co/CRAN/web/packages/RnavGraph/vignettes/RnavGraph.pdf](http://www.icesi.edu.co/CRAN/web/packages/RnavGraph/vignettes/RnavGraph.pdf)。
- en: 'Here is a description of how you can use `RnavGraph` to visualize high dimensional
    data in a graph:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是关于如何使用 `RnavGraph` 在图中可视化高维数据的描述：
- en: 'First, install and load the `RnavGraph` and `graph` packages:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，安装并加载 `RnavGraph` 和 `graph` 包：
- en: '[PRE56]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'You can then create an `NG_data` object from the `digit` data:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，你可以从 `digit` 数据创建一个 `NG_data` 对象：
- en: '[PRE57]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Create an `NG_graph` object from `NG_data`:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `NG_data` 创建一个 `NG_graph` 对象：
- en: '[PRE58]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Finally, you can visualize the graph in the `tk2d` plot:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，你可以在 `tk2d` 绘图中可视化图形：
- en: '[PRE59]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '![There''s more...](img/00256.jpeg)'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![还有更多...](img/00256.jpeg)'
- en: A 3-D Transition graph plot
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一个三维转换图
- en: One can also view a 4D transition graph plot:![There's more...](img/00257.jpeg)
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还可以查看一个四维转换图：![还有更多...](img/00257.jpeg)
- en: A 4D transition graph plot
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一个四维转换图
- en: Performing nonlinear dimension reduction with Local Linear Embedding
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用局部线性嵌入进行非线性降维
- en: '**Locally linear embedding** (**LLE**) is an extension of PCA, which reduces
    data that lies on a manifold embedded in a high dimensional space into a low dimensional
    space. In contrast to ISOMAP, which is a global approach for nonlinear dimension
    reduction, LLE is a local approach that employs a linear combination of the k-nearest
    neighbor to preserve local properties of data. In this recipe, we will give a
    short introduction of how to use LLE on an s-curve data.'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '**局部线性嵌入**（**LLE**）是 PCA 的扩展，它将嵌入在高维空间中的流形上的数据降低到低维空间。与 ISOMAP 不同，ISOMAP 是一种用于非线性降维的全局方法，LLE
    是一种局部方法，它使用 k 近邻的线性组合来保留数据的局部属性。在本菜谱中，我们将简要介绍如何在 s 曲线数据上使用 LLE。'
- en: Getting ready
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will use digit data from `lle_scurve_data` within the `lle`
    package as our input source.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在本菜谱中，我们将使用 `lle` 包中的 `lle_scurve_data` 中的数字数据作为我们的输入源。
- en: How to do it...
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Perform the following steps to perform nonlinear dimension reduction with LLE:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以使用 LLE 进行非线性降维：
- en: 'First, you need to install and load the package, `lle`:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，您需要安装并加载包，`lle`：
- en: '[PRE60]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'You can then load `ll_scurve_data` from `lle`:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以从 `lle` 中加载 `ll_scurve_data`：
- en: '[PRE61]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Next, perform `lle` on `lle_scurve_data`:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，对 `lle_scurve_data` 执行 `lle`：
- en: '[PRE62]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Examine the result with the `str` and `plot` function:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `str` 和 `plot` 函数检查结果：
- en: '[PRE63]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '![How to do it...](img/00258.jpeg)'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/00258.jpeg)'
- en: A 2-D scatter plot of embedded data
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 嵌入数据的 2-D 散点图
- en: 'Lastly, you can use `plot_lle` to plot the LLE result:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，您可以使用 `plot_lle` 来绘制 LLE 结果：
- en: '[PRE64]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '![How to do it...](img/00259.jpeg)'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/00259.jpeg)'
- en: A LLE plot of LLE result
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: LLE 结果的 LLE 图
- en: How it works...
  id: totrans-321
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作...
- en: 'LLE is a nonlinear dimension reduction method, which computes a low dimensional,
    neighborhood, preserving embeddings of high dimensional data. The algorithm of
    LLE can be illustrated in these steps: first, LLE computes the k-neighbors of
    each data point, ![How it works...](img/00218.jpeg). Secondly, it computes a set
    of weights for each point, which minimizes the residual sum of errors, which can
    best reconstruct each data point from its neighbors. The residual sum of errors
    can be described as ![How it works...](img/00260.jpeg), where ![How it works...](img/00261.jpeg)
    if ![How it works...](img/00262.jpeg) is not one of ![How it works...](img/00218.jpeg)''s
    k-nearest neighbor, and for each i, ![How it works...](img/00263.jpeg). Finally,
    find the vector, Y, which is best reconstructed by the weight, W. The cost function
    can be illustrated as ![How it works...](img/00264.jpeg), with the constraint
    that ![How it works...](img/00265.jpeg), and ![How it works...](img/00266.jpeg).'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: LLE 是一种非线性降维方法，它计算高维数据的低维、邻域保留嵌入。LLE 的算法可以按以下步骤说明：首先，LLE 计算每个数据点的 k 个邻居，![如何工作...](img/00218.jpeg)。其次，它为每个点计算一组权重，这些权重最小化了残差误差之和，可以从其邻居中最佳地重建每个数据点。残差误差之和可以描述为
    ![如何工作...](img/00260.jpeg)，其中 ![如何工作...](img/00261.jpeg) 如果 ![如何工作...](img/00262.jpeg)
    不是 ![如何工作...](img/00218.jpeg) 的 k 个最近邻之一，并且对于每个 i，![如何工作...](img/00263.jpeg)。最后，找到由权重
    W 最佳重建的向量 Y。成本函数可以表示为 ![如何工作...](img/00264.jpeg)，约束条件为 ![如何工作...](img/00265.jpeg)，和
    ![如何工作...](img/00266.jpeg)。
- en: 'In this recipe, we demonstrate how to perform nonlinear dimension reduction
    using LLE. First, we load `lle_scurve_data` from `lle`. We then perform `lle`
    with two dimensions and 12 neighbors, and list the dimensions for every data point
    by specifying `id =TRUE`. The LLE has three steps, including: building a neighborhood
    for each point in the data, finding the weights for linearly approximating the
    data in that neighborhood, and finding the low dimensional coordinates.'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在本菜谱中，我们展示了如何使用 LLE 进行非线性降维。首先，我们从 `lle` 中加载 `lle_scurve_data`。然后，我们使用两个维度和
    12 个邻居执行 `lle`，并通过指定 `id = TRUE` 列出每个数据点的维度。LLE 有三个步骤，包括：为数据中的每个点构建邻域，找到在该邻域中线性逼近数据的权重，以及找到低维坐标。
- en: Next, we can examine the data using the `str` and `plot` functions. The `str`
    function returns X,Y, choice, and ID. Here, X represents the input data, Y stands
    for the embedded data, choice indicates the index vector of the kept data, while
    subset selection and ID show the dimensions of every data input. The `plot` function
    returns the scatter plot of the embedded data. Lastly, we use `plot_lle` to plot
    the result. Here, we enable the interaction mode by setting the inter equal to
    `TRUE`.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以使用 `str` 和 `plot` 函数来检查数据。`str` 函数返回 X、Y、choice 和 ID。在这里，X 代表输入数据，Y
    表示嵌入数据，choice 表示保留数据的索引向量，而子集选择和 ID 显示每个数据输入的维度。`plot` 函数返回嵌入数据的散点图。最后，我们使用 `plot_lle`
    来绘制结果。在这里，我们通过将交互模式设置为 `TRUE` 来启用交互模式。
- en: See also
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'Another useful package for nonlinear dimension reduction is `RDRToolbox`, which
    is a package for nonlinear dimension reduction with ISOMAP and LLE. You can use
    the following command to install `RDRToolbox`:'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个用于非线性降维的有用软件包是 `RDRToolbox`，这是一个包含 ISOMAP 和 LLE 的非线性降维软件包。您可以使用以下命令安装 `RDRToolbox`：
- en: '[PRE65]'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
