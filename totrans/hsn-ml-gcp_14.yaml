- en: Time Series with LSTMs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用LSTM的时间序列
- en: In many situations involving multiple fields of real life, the need to plan
    future actions arises. **Forecasting** is an important tool for efficient planning.
    Moreover, this tool makes the decision-maker less susceptible to unexpected events
    because it requires a more scientific approach to the knowledge of the environment
    in which it operates. Often, the planning of future action arises from the analysis
    of data accumulated over time to extract information for the characterization
    of the phenomenon under observation.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在涉及多个现实生活领域的许多情况下，需要规划未来的行动。**预测**是有效规划的重要工具。此外，这个工具使决策者对意外事件的影响降低，因为它要求对操作环境的知识采取更科学的方法。通常，未来行动的规划源于对随时间积累的数据的分析，以提取对观察现象特征化的信息。
- en: 'A chronological recording of events gives rise to a new type of act, which
    is precisely called a **time series**. A time series constitutes a sequence of
    observations on a phenomenon carried out in consecutive instants or time intervals.
    Usually, even if not necessarily, they are evenly spaced or of the same length.
    Time series prediction requires the neural network to have some sort of memory
    on the sequence of data. Specific architectures called **Long Short-Term Memory**
    (**LSTM**) network, are well suited for time series analysis. In this chapter
    we show how to create and train our own LSTMs using Keras on GCD and apply them
    to predicting financial time series. We''ll discover the most used modeling approaches:
    **autoregressive** (**AR**), **moving average** (**MA**), **autoregressive moving
    average** (**ARMA**), and **autoregressive integrated moving average** (**ARIMA**).'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 事件的按时间顺序记录产生了新的行为，这恰好被称为**时间序列**。时间序列是由在连续瞬间或时间间隔内对现象进行的观察序列组成的。通常，即使不是必然的，它们也是均匀分布的或长度相同。时间序列预测需要神经网络对数据序列有一定的记忆。称为**长短期记忆**（**LSTM**）的特定架构非常适合时间序列分析。在本章中，我们将展示如何使用Keras在GCD上创建和训练自己的LSTM，并将它们应用于预测金融时间序列。我们将发现最常用的建模方法：**自回归**（**AR**）、**移动平均**（**MA**）、**自回归移动平均**（**ARMA**）和**自回归积分移动平均**（**ARIMA**）。
- en: 'The topics covered in this chapter are:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的主题包括：
- en: Classical approach to time series
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间序列的经典方法
- en: Time series decomposition
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间序列分解
- en: Time series models
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间序列模型
- en: LSTM for time series analysis
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LSTM用于时间序列分析
- en: At the end of the chapter, we will be able to deal with problems regarding time
    series. We will know how to identify the different components of a time series,
    trend seasonality and residual, as well as eliminate seasonality to make predictions
    easier to understand. Finally, we will understand how to implement a recurring
    LSTM network with a practical example.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，我们将能够处理与时间序列相关的问题。我们将了解如何识别时间序列的不同组成部分，包括趋势、季节性和残差，以及消除季节性以使预测更容易理解。最后，我们将通过一个实际例子了解如何实现具有重复功能的LSTM网络。
- en: Introducing time series
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍时间序列
- en: A time series constitutes a sequence of observations on a phenomenon *y* carried
    out in consecutive instants or time intervals that are usually, even if not necessarily,
    evenly spaced or of the same length. The trend of commodity prices, stock market
    indices, the BTP/BUND spread, and the unemployment rate are just a few examples
    of times series.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 时间序列是由在连续瞬间或时间间隔内对现象 *y* 进行的观察序列组成的，这些瞬间或时间间隔通常是均匀分布的，即使不是必然的，长度也相同。商品价格趋势、股票市场指数、BTP/BUND利差和失业率只是时间序列的几个例子。
- en: Contrary to what happens in classical statistics, where it is assumed that an
    independent observations come from a single random variable, in a time series,
    it is assumed that there are n observations coming from as many dependent random
    variables. The inference of the time series is thus configured as a procedure
    that attempts to bring the time series back to its generating process.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 与经典统计学中假设独立观察来自单个随机变量相反，在时间序列中，假设有n个观察来自许多相关随机变量。因此，时间序列的推断被配置为一个试图将时间序列恢复到其生成过程的程序。
- en: 'The time series can be of two types:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 时间序列可以分为两种类型：
- en: '**Deterministic**: If the values of the variable can be exactly determined
    on the basis of the previous values'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**确定性**：如果变量的值可以根据先前值精确确定'
- en: '**Stochastic**: If the values of the variable can be determined on the basis
    of the previous values only partially'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**随机性**：如果变量的值只能根据先前值部分确定'
- en: The majority of time series are stochastic, and therefore it is impossible to
    draw up forecasts without errors. It is generally assumed that an observed time
    series is the result of the composition of these two components. The two sequences
    are not individually observable but must be determined on the basis of a sample.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时间序列都是随机的，因此没有错误地绘制预测是不可能的。通常假设观察到的时序是这两个组成部分组成的。这两个序列不能单独观察，但必须基于样本来确定。
- en: 'We indicate the series as the sum of these two contributions:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这个序列表示为这两个贡献的总和：
- en: '*Y[t] = f(t) + w(t)*'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*Y[t] = f(t) + w(t)*'
- en: According to the classical approach to time series, it is assumed that there
    exists a law of temporal evolution of the phenomenon, represented by *f(t)*. The
    random component *w(t)* is assumed to represent the set of circumstances, each
    of negligible entities, which we do not want or cannot consider in *Y[t]*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 根据时间序列的经典方法，假设存在现象的时间演化规律，由*f(t)*表示。随机成分*w(t)*被假设代表我们不想或不能在*Y[t]*中考虑的、每个都微不足道的情形集合。
- en: Therefore, the residual part of *Y[t]*, not explained by *f(t)*, is imputed
    to the case and assimilated to a set of accidental errors. This is equivalent
    to hypothesizing that the stochastic component *w(t)* is generated by a white
    noise process, that is, by a sequence of independent and identically distributed
    random variables of zero mean and constant variance. In summary, in the classic
    approach, the attention is concentrated on *f(t)**,* being *w(t)* considered a
    process with uncorrelated components and therefore negligible.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，*Y[t]*的残差部分，即未被*f(t)*解释的部分，被归因于偶然误差的情况，并同化为一系列偶然误差。这相当于假设随机成分*w(t)*是由一个白噪声过程生成的，即由一系列独立同分布的随机变量序列，均值为零，方差恒定。总之，在经典方法中，注意力集中在*f(t)*上，而*w(t)*被认为是一个具有不相关成分的过程，因此可以忽略不计。
- en: 'Denoting the time with *t = 1…. T*, we will indicate this sequence *y[t]*;
    time is the parameter that determines the sequence of events that cannot be neglected,
    so we also need to know the position of observation along the temporal dimension.
    Generally, it is used to represent the pair of values ​​*(t, y[t])* on a Cartesian
    diagram with a continuous line graph as if the phenomenon were detected continuously.
    This graph is called a **time series plot**. In the following graph, we see a
    time series plot of the flow of the river Nile at Aswan from 1871 to 1970:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 用*t = 1…. T*表示时间，我们将指示这个序列*y[t]*；时间是决定事件序列的参数，不能被忽略，因此我们还需要知道观察在时间维度上的位置。通常，它用于在笛卡尔图上表示值对*(t,
    y[t])*，以连续线图的形式，好像现象是连续检测到的。这种图表称为**时间序列图**。在下面的图表中，我们看到的是从1871年到1970年阿斯旺尼罗河流量的时间序列图：
- en: '![](img/d67c0c49-def5-4e0f-a85a-645ed7397742.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d67c0c49-def5-4e0f-a85a-645ed7397742.png)'
- en: A time series plot immediately reveals trends or regular oscillations, and other
    systematic trends over time. The previous graph shows annual data in a systematically
    decreasing trend over the long term. In particular, it has a zigzag pattern; since
    the data is monthly, there is the phenomenon called **seasonality**. It can be
    noted that high peaks are always recorded in those months when rains are expected.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 时间序列图可以立即揭示趋势或规律性振荡，以及随时间出现的其他系统性趋势。前一个图表显示了长期内系统性地下降的年度数据。特别是，它有一个锯齿状模式；由于数据是按月度计算的，存在称为**季节性**的现象。可以注意到，在预期有雨的那些月份总是记录到高峰值。
- en: The univariate analysis of the time series proposes to interpret the dynamic
    mechanism that generated the series, and to foresee future realizations of the
    phenomenon. In these operations, the information that is exploited regards only
    the couple *(t; Y[t])*, where *t = 1,…, T*. The fundamental point is that the
    past and the present contain relevant information to predict the future evolution
    of the phenomenon.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 时间序列的单变量分析旨在解释生成序列的动态机制，并预测现象的未来实现。在这些操作中，所利用的信息仅限于*(t; Y[t])*这对，其中*t = 1,…,
    T*。基本点是过去和现在都包含与预测现象未来演化相关的信息。
- en: It can be considered that univariate analysis is too restrictive; we usually
    have information on phenomena related to the one to be forecast, which should
    be appropriately incorporated in order to improve the performance of the model
    of revision. Nonetheless, it is a useful benchmark that allows validation more
    sophisticated alternatives.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 可以认为单变量分析过于限制；我们通常有与要预测的现象相关的信息，这些信息应该适当融入，以提高修订模型的性能。尽管如此，它是一个有用的基准，允许验证更复杂的替代方案。
- en: 'In a time series plot, four types of patterns can be identified with respect
    to time:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在时间序列图中，可以根据时间识别出四种类型的模式：
- en: '**Horizontal pattern**: In this case, the series oscillates around a constant
    value (series average). This series is called **stationary** on **average**. This
    is the typical case that occurs in quality control when the process is kept under
    control with respect to the average.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**水平模式**：在这种情况下，系列围绕一个常数值（系列平均值）波动。这种系列在平均意义上被称为**平稳的**。这是在质量控制中，当过程相对于平均值保持控制时出现的典型情况。'
- en: '**Seasonal pattern**: This exists when the series is influenced by seasonal
    factors (example, monthly, semi-annual, quarterly, and so on). Products such as
    ice cream, soft drinks, electricity consumption are subject to the seasonal phenomenon.
    The series influenced by seasonality are also called **periodic series** since
    the seasonal cycle repeats itself in a fixed period. In the annual data, seasonality
    is not present.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**季节性模式**：当系列受季节性因素影响时存在（例如，每月、半年、季度等）。冰淇淋、软饮料、电力消耗等产品都受到季节性现象的影响。受季节性影响的系列也被称为**周期性系列**，因为季节周期在固定周期内重复。在年度数据中，季节性不存在。'
- en: '**Cyclic pattern**: This type of trend is present when the series has increases
    and decreases that are not of fixed period. This is the main difference between
    cyclical and seasonal fluctuations. Moreover, the amplitude of cyclical oscillations
    is generally larger than that due to seasonality. In economic series, the cyclical
    pattern is determined by the expansions and contractions of the economy due to
    conjectural phenomena.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**周期模式**：当系列有非固定周期的增加和减少时，这种趋势类型就会出现。这是周期性和季节性波动之间的主要区别。此外，周期性振荡的幅度通常大于季节性引起的幅度。在经济系列中，周期模式由经济因猜测现象的扩张和收缩所决定。'
- en: '**Trend or underlying trend**: It is characterized by an increasing or decreasing
    long-term trend. The series of the world resident population is an example of
    an increasing trend; the series of monthly beer sales, on the other hand, does
    not show any trend. It has a horizontal background pattern.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**趋势或潜在趋势**：它以长期增加或减少的趋势为特征。世界居民人口系列就是一个增加趋势的例子；另一方面，月度啤酒销售系列没有显示出任何趋势。它有一个水平的背景模式。'
- en: Many series highlight a combination of these patterns. It is precisely this
    kind of complexity that makes the forecasting operation extremely interesting.
    The forecasting methods, in fact, must be able to recognize the various components
    of the series in order to reproduce them in the future, in the hypothesis that
    the past pattern continues to repeat itself in its evolutionary characteristics
    also in the future.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 许多系列强调了这些模式的组合。正是这种复杂性使得预测操作极其有趣。实际上，预测方法必须能够识别系列的各个组成部分，以便在未来的假设下，在它们的进化特征中继续重复过去的模式。
- en: 'The classic approach to time series is based on the decomposition of the deterministic
    part of the series into a set of signal components (which express the structural
    information of the series) with respect to the negligible part of noise. In practice,
    we will try to identify some of the patterns that we have previously listed in
    the time series trend. The following figure shows a time series with some components
    identified:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 时间序列的经典方法基于将系列的确定性部分分解成一系列信号成分（这些成分表达系列的结构性信息）相对于可忽略的噪声部分。在实践中，我们将尝试在时间序列趋势中识别我们之前列出的一些模式。以下图显示了一个时间序列，其中已识别出一些成分：
- en: '![](img/69e99378-6407-4224-a3d5-4d085775b33c.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/69e99378-6407-4224-a3d5-4d085775b33c.png)'
- en: 'In the previous figure, the components we have identified are:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的图中，我们已识别的组成部分是：
- en: '**Trend**: It is the underlying trend of the phenomenon considered, referring
    to a long period of time.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**趋势**：这是所考虑现象的潜在趋势，指的是一个长期的时间段。'
- en: '**Seasonal**: This consists of movements of the phenomena during the year.
    Due to the influence of climatic and social factors, they tend to repeat themselves
    in a similar way in the same period (for example, month, quarter, and so on).'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**季节性**：这包括现象在一年中的运动。由于气候和社会因素的影响，它们往往在相同时期（例如，月份、季度等）以类似的方式重复出现。'
- en: '**Residual**: In the time series models, there is never a perfect relation
    between the variable under observation and the different components. The accidental
    component takes into account this and the unpredictable behavior of economic agents,
    social, and so on.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**残差**：在时间序列模型中，观察变量与不同成分之间从未有过完美的关系。偶然成分考虑了这一点，以及经济主体、社会等方面的不可预测行为。'
- en: Finally, we can say that by adopting this approach a time series can be seen
    as the sum of the three components just analyzed (additive method).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以说，采用这种方法，时间序列可以被视为分析过的三个成分的总和（加法方法）。
- en: Classical approach to time series
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时间序列的经典方法
- en: 'So far we have dealt with time series according to a classic approach to the
    topic. In this perspective, the classic models that try to simulate the phenomenon
    can be of two types:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们根据经典方法处理时间序列。在这个视角下，试图模拟现象的经典模型可以分为两种类型：
- en: '**Composition models**: The elementary components are known, and, by assuming
    a certain form of aggregation, the resulting series is obtained'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组合模型**：已知基本组成部分，通过假设某种聚合形式，得到结果序列'
- en: '**Decomposition models**: From an observed series is hypothesized the existence
    of some elementary trends of which we want to establish the characteristics'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分解模型**：从观察序列中假设存在一些基本趋势，我们想要确定其特征'
- en: The decomposition models are the most used in practice, and, for this reason,
    we will analyze them in detail.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 分解模型在实践中最常使用，因此我们将详细分析它们。
- en: 'The components of a time series can be aggregated according to different types
    of methods:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 时间序列的成分可以根据不同类型的方法进行聚合：
- en: '**Additive method**: *Y(t) = τ(t) + C(t) + S(t) + r(t)*'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**加法方法**：*Y(t) = τ(t) + C(t) + S(t) + r(t)*'
- en: '**Multiplicative method**: *Y(t) = τ(t) * C(t) * S(t) * r(t)*'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**乘法方法**：*Y(t) = τ(t) * C(t) * S(t) * r(t)*'
- en: '**Mixed method**: *Y(t) = τ(t) * C(t) + S(t) * r(t)*'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**混合方法**：*Y(t) = τ(t) * C(t) + S(t) * r(t)*'
- en: 'In these formulas, the factors are defined as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些公式中，因子定义为以下：
- en: '*Y(t)* represents the time series'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Y(t)* 代表时间序列'
- en: '*τ(t)* represents the trend component'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*τ(t)* 代表趋势成分'
- en: '*C(t)* represents the cyclic component'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*C(t)* 代表周期成分'
- en: '*S(t)* represents the seasonality component'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*S(t)* 代表季节性成分'
- en: '*r(t)* represents the residual component'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*r(t)* 代表残差成分'
- en: 'The multiplicative model can be traced back to the additive model through a
    logarithmic transformation of the components of the series:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对时间序列成分的对数变换，乘法模型可以追溯到加法模型：
- en: '*Y(t) = τ(t) * C(t) * S(t) * r(t)*'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*Y(t) = τ(t) * C(t) * S(t) * r(t)*'
- en: 'This formula, by applying the logarithm function to all factors, becomes:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对所有因子应用对数函数，这个公式变为：
- en: '*lnY(t) = lnτ(t) + lnC(t) + lnS(t) + lnr(t)*'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*lnY(t) = lnτ(t) + lnC(t) + lnS(t) + lnr(t)*'
- en: Estimation of the trend component
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 趋势成分的估计
- en: Estimation of the trend component can occur in two different modes depending
    on the linear/non-linear characteristic.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 趋势成分的估计可以有两种不同的模式，这取决于线性/非线性特征。
- en: 'If the series trend is linear or linearizable in the parameters through a logarithmic
    transformation, then these trends can be estimated through the procedures derived
    from linear regression. We can hypothesize a polynomial trend that can be represented
    by the following equation:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果序列趋势在参数上通过对数变换是线性的或可线性化的，那么这些趋势可以通过从线性回归中推导出的程序进行估计。我们可以假设一个可以用以下方程表示的多项式趋势：
- en: '*τ (t) = α[0] + α[1] t + α[2] t[2] + ... + α[q] t[q] + εt*'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '*τ (t) = α[0] + α[1] t + α[2] t[2] + ... + α[q] t[q] + εt*'
- en: In this formula, *q* represents the degree of the polynomial.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个公式中，*q* 代表多项式的次数。
- en: 'Depending on the value assumed by *q*, the following cases can be represented:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 根据假设的 *q* 的值，可以表示以下情况：
- en: '| **q** | **Cases** |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| **q** | **情况** |'
- en: '| *0* | A constant trend is obtained |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| *0* | 获得一个常数趋势 |'
- en: '| *1* | We obtain a linear trend |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| *1* | 我们得到一个线性趋势 |'
- en: '| *2* | We obtain a parabolic trend |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| *2* | 我们得到一个抛物线趋势 |'
- en: On the contrary, the presence of a non-linear trend makes it difficult, if not
    impossible, to identify a known functional form *f(t)* with which to express the
    trend component.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，非线性行为的存在使得难以，如果不是不可能的话，识别出一个已知的函数形式 *f(t)* 来表达趋势成分。
- en: In these cases, the MA instrument is used. MA is an arithmetic mean (simple
    or weighted) that moves to each new iteration (at any time *t*) from the beginning
    to the end of the data sequence.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，使用 MA 工具。MA 是一个移动到每个新迭代（在任何时间 *t*）从数据序列的开始到结束的算术平均值（简单或加权）。
- en: 'Suppose we have *n* data terms:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有 *n* 个数据项：
- en: '*a1, a2, a3, ..., a^((n-1)), a^n*'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*a1, a2, a3, ..., a^((n-1)), a^n*'
- en: 'The following procedure is adopted:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 以下程序被采用：
- en: First, we calculate the average of the first three data and substitute the average
    value for the central data
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们计算前三个数据的平均值，并用平均值替换中间数据
- en: Then, we repeat the procedure with the second three data
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们用第二组三个数据重复该程序
- en: The procedure is exhausted when there is no more data available
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当没有更多数据可用时，程序将耗尽
- en: In the case considered, the MA is composed of only three data. The MA order
    can be extended to 5, 7, 9, and so on. In order for the MA to be centered with
    respect to the available data, the order must be odd.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑的情况下，MA 由仅三个数据组成。MA 的阶数可以扩展到 5，7，9，等等。为了使 MA 与可用数据居中，阶数必须是奇数。
- en: Estimating the seasonality component
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 估计季节性成分
- en: 'The study of the seasonality of a historical series can have the purpose of:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 研究历史序列的季节性可以有以下目的：
- en: Simply estimating the seasonal component
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单地估计季节性成分
- en: Eliminating it from the general course once it has been estimated
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦估计出来，就从一般课程中消除它
- en: If you have to compare several time series with different seasonality, the only
    way to compare them is by a seasonal adjustment of them.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果必须比较具有不同季节性的几个时间序列，唯一的方法是对它们进行季节性调整。
- en: There are several ways to estimate the seasonal component. One of these is the
    use of a regression model using dichotomous auxiliary variables (dummy variables).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以估计季节性成分。其中之一是使用二元辅助变量（虚拟变量）的回归模型。
- en: 'Suppose the existence of an additive model without a trend component:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 假设存在一个没有趋势成分的加性模型：
- en: '*Y(t) = S(t) + r(t)*'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*Y(t) = S(t) + r(t)*'
- en: 'And suppose we have measured the series on a monthly basis. The dummy variables
    can be defined in the following way:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们按月度测量了该序列。虚拟变量可以按以下方式定义：
- en: '*d[j](t)*: 1 if the observation *t* is relative to the *j^(th)* month of the
    year'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*d[j](t)*：如果观察值 *t* 是相对于年份的第 *j* 个月，则为 1'
- en: '*d[j](t)*: 0 otherwise'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*d[j](t)*：否则为 0'
- en: 'Once the periodic dummy variables have been created, the seasonal component
    can be estimated using the following regression model:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了周期性虚拟变量，就可以使用以下回归模型来估计季节性成分：
- en: '*Y(t) = β[1]D[1] + β[2]D[2] + ... + β[n]D[n] + ε(t)*'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*Y(t) = β[1]D[1] + β[2]D[2] + ... + β[n]D[n] + ε(t)*'
- en: The remaining *ε(t)* part of the model represents the part of the series not
    explained by seasonality. If a trend component is present in the series, it will
    coincide precisely with *ε(t)*.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 模型中剩余的 *ε(t)* 部分代表序列中未被季节性解释的部分。如果序列中存在趋势成分，它将与 *ε(t)* 完全一致。
- en: Time series models
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时间序列模型
- en: 'In the previous sections, we explored the basics behind time series. To perform
    correct predictions of future events based on what happened in the past, it is
    necessary to construct an appropriate numerical simulation model. Choosing an
    appropriate model is extremely important as it reflects the underlying structure
    of the series. In practice, two types of models are available: linear or non-linear
    (depending on whether the current value of the series is a linear or non-linear
    function of past observations).'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们探讨了时间序列的基本原理。为了根据过去发生的事件正确预测未来事件，有必要构建一个适当的数值模拟模型。选择一个合适的模型非常重要，因为它反映了序列的潜在结构。在实践中，有两种类型的模型可用：线性或非线性（取决于序列的当前值是否是过去观察值的线性或非线性函数）。
- en: 'The following are the most widely used models for forecasting time series data:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是最广泛用于预测时间序列数据的模型：
- en: AR
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AR
- en: MA
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MA
- en: ARMA
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ARMA
- en: ARIMA
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ARIMA
- en: Autoregressive models
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自回归模型
- en: AR models are a very useful tool to tackle the prediction problem in relation
    to a time series. A strong correlation between consecutive values of a series
    is often observed. In this case, we speak of autocorrelation of the first order
    when we consider adjacent values, of the second order if we refer to the relation
    between the values of the series after two periods, and in general of the *p^(th)*
    order if the values considered have *p* periods between them. AR models allow
    exploiting these bonds to obtain useful forecasts of the future behavior of the
    series.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: AR模型是解决与时间序列相关的预测问题的非常有用的工具。一个序列连续值之间的强相关性通常会被观察到。在这种情况下，当我们考虑相邻值时，我们谈论一阶自相关；如果我们指的是两个周期后序列值之间的关系，我们谈论二阶自相关；在一般情况下，如果考虑的值之间有
    *p* 个周期，我们谈论 *p* 阶自相关。AR模型允许利用这些联系来获得序列未来行为的有用预测。
- en: 'AR is a linear predictive modeling technique. This model tries to predict the
    time series based on the previous values assumed using the AR parameters as coefficients.
    The number of samples used for the forecast determines the order of the model
    (*p*). As the name indicates, it is a regression of the variable against itself;
    that is, a linear combination of past values of the variables is used to forecast
    the future value. The AR model of *p* order is defined as:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: AR是一种线性预测建模技术。该模型试图根据使用AR参数作为系数的先前值来预测时间序列。用于预测的样本数量决定了模型的阶数（*p*）。正如其名称所示，这是一个变量的自回归；也就是说，使用变量的过去值的线性组合来预测未来值。阶数为
    *p* 的AR模型定义为：
- en: '![](img/8eda0e86-d38f-4a1b-8bef-eaef767b632f.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8eda0e86-d38f-4a1b-8bef-eaef767b632f.png)'
- en: 'In the previous formula, the terms are defined as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的公式中，术语定义如下：
- en: '*Y[t]* is the actual value at time period *t*'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Y[t]* 是时间周期 *t* 的实际值'
- en: '*c* is a constant'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*c* 是一个常数'
- en: '*ϕ[i] (i = 1,2,..., p)* are model parameters'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*ϕ[i] (i = 1,2,..., p)* 是模型参数'
- en: '*Y[t-i]* is the past value at time period *t-i*'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Y[t-i]* 是时间周期 *t-i* 的过去值'
- en: '*ε[t]* is the random error at time period *t* (white noise)'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*ε[t]* 是时间周期 *t* 的随机误差（白噪声）'
- en: It may happen that the constant term is omitted; this is done to make the model
    as simple as possible.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会发生常数项被省略的情况；这样做是为了使模型尽可能简单。
- en: Moving average models
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移动平均模型
- en: The MA model specifies that the output variable depends linearly on the past
    and current past values of a stochastic term (imperfectly predictable). The MA
    model should not be confused with the MA we have seen in the previous sections.
    This is an essentially different concept although some similarities are evident.
    Unlike the AR model, the finished MA model is always stationary.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: MA模型规定输出变量线性依赖于随机项（不可完全预测）的过去和当前过去值。MA模型不应与我们在前几节中看到的MA混淆。这是一个本质上不同的概念，尽管有一些相似之处。与AR模型不同，完成的MA模型总是平稳的。
- en: Just as a model AR (*p*) regresses with respect to the past values of the series,
    an MA (*q*) model uses past errors as explanatory variables.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 正如AR (*p*) 模型相对于序列的过去值进行回归一样，MA (*q*) 模型使用过去误差作为解释变量。
- en: 'The MA model of *q* order is defined as:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 阶数为 *q* 的MA模型定义为：
- en: '![](img/c1d41ff4-ed45-4e09-8e06-0f0627147180.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c1d41ff4-ed45-4e09-8e06-0f0627147180.png)'
- en: 'In the previous formula, the terms are defined as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的公式中，术语定义如下：
- en: '*Y[t]* is the actual value at time period *t*'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Y[t]* 是时间周期 *t* 的实际值'
- en: '*μ* is the mean of the series'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*μ* 是序列的均值'
- en: '*θ[i] (i = 1,2,..., q)* are model parameters'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*θ[i] (i = 1,2,..., q)* 是模型参数'
- en: '*ε[t-i]* is the past random error at time period *t-i*'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*ε[t-i]* 是时间周期 *t-i* 的过去随机误差'
- en: '*ε[t]* is the random error at time period *t* (white noise)'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*ε[t]* 是时间周期 *t* 的随机误差（白噪声）'
- en: The MA model is essentially a finite impulsive response filter applied to white
    noise, with some additional interpretations placed on it.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: MA模型本质上是对白噪声应用有限脉冲响应滤波器，并对它附加了一些额外的解释。
- en: Autoregressive moving average model
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自回归移动平均模型
- en: ARMA is a type of linear mathematical model that provides instant by instant
    an output value based on the previous input and output values. The system is seen
    as an entity that, instant by instant, receives an input value (input) and generates
    an output (output), calculated on the basis of internal parameters that in turn
    vary according to linear laws. Each internal parameter, therefore, will be at
    each instant place equal to a linear combination of all internal parameters of
    the previous instant and the incoming value. The output value, in turn, will be
    a linear combination of internal parameters, and, in rare cases, also of the incoming
    one.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: ARMA是一种线性数学模型，它基于先前输入和输出值即时提供输出值。该系统被视为一个实体，它即时接收输入值（输入）并生成输出（输出），基于内部参数，这些参数根据线性规律变化。因此，每个内部参数在每个瞬间等于前一个瞬间的所有内部参数的线性组合和输入值。输出值反过来又将是内部参数的线性组合，在罕见情况下，也可能是输入值。
- en: Much more simply, ARMA can be seen as an effective combination of the AR and
    MA models to form a general and useful class of time series models.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 更简单地说，ARMA可以看作是AR和MA模型的有效组合，形成了一类通用且有用的时序模型。
- en: 'The model is generally defined as the ARMA model *(p, q)* where *p* is the
    order of the AR part and *q* is the order of the part of the MA. The ARMA model
    is defined by the following formula:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 该模型通常定义为ARMA模型 *(p, q)*，其中 *p* 是自回归部分的阶数，*q* 是移动平均部分的阶数。ARMA模型由以下公式定义：
- en: '![](img/7e0a27b4-8a05-46ac-9914-23ff6eb59e28.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7e0a27b4-8a05-46ac-9914-23ff6eb59e28.png)'
- en: 'The terms are defined as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 术语定义如下：
- en: '*Y[t]* is the actual value at time period *t*'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Y[t]* 是时间周期 *t* 的实际值'
- en: '*c* is again a constant'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*c* 仍然是一个常数'
- en: '*ϕ[i] (i = 1,2,..., p)* are AR model parameters'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*ϕ[i] (i = 1,2,..., p)* 是自回归模型参数'
- en: '*Y[t-i]* is the past value at time period *t-i*'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Y[t-i]* 是时间周期 *t-i* 的过去值'
- en: '*θ[i] (i = 1,2,..., q)* are MA model parameters'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*θ[i] (i = 1,2,..., q)* 是移动平均模型参数'
- en: '*ε[t-i]* is the past random error at time period *t-i*'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*ε[t-i]* 是时间周期 *t-i* 的过去随机误差'
- en: '*ε[t]* is the random error at time period *t* (white noise)'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*ε[t]* 是时间周期 *t* 的随机误差（白噪声）'
- en: In general, once the order *(p, q)* has been chosen, the parameters of an ARMA
    model *(p, q)* can be estimated through the maximum likelihood estimator, for
    example. As for the AR model, the choice of the model order must respond to the
    opposing needs of a good adaptation to the data and parsimony in the number of
    parameters to be estimated.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，一旦选择了阶数 *(p, q)*，ARMA模型 *(p, q)* 的参数可以通过最大似然估计器进行估计，例如。至于AR模型，模型阶数的选择必须满足对数据良好适应和参数估计数量简约性的对立需求。
- en: Autoregressive integrated moving average models
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自回归积分移动平均模型
- en: An ARIMA model is a generalization of a ARMA model. ARIMA models are applied
    in cases where data show a clear tendency to non-stationarity. In these cases,
    to eliminate the non-stationarity, an initial differentiation step is added to
    the ARMA algorithm (corresponding to the integrated part of the model) that is
    applied one or more times.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: ARIMA模型是ARMA模型的一种推广。ARIMA模型适用于数据表现出明显的非平稳趋势的情况。在这些情况下，为了消除非平稳性，在ARMA算法（对应于模型的积分部分）中添加了一个初始微分步骤，该步骤应用一次或多次。
- en: 'This algorithm is therefore essentially composed of three parts:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，该算法本质上由三个部分组成：
- en: The part AR that determines a regression on its own delayed (that is, previous)
    values ​​to the evolving variable of interest.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自回归部分决定了对其自身延迟（即先前）值进行回归的演变变量。
- en: The MA part. It indicates that the regression error is actually a linear combination
    of error terms whose values ​​have occurred simultaneously and at various times
    in the past.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MA部分。它表示回归误差实际上是过去同时发生并在不同时间出现的误差项的线性组合。
- en: The integrated part; it indicates that the data values ​​have been replaced
    with the difference between their current values ​​and the previous values ​​(and
    this differentiation process may have been performed more than once).
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 积分部分；它表示数据值已被替换为它们当前值与先前值之间的差值（并且这种微分过程可能已经执行过多次）。
- en: The purpose of each of these features is to make the model suitable for data
    in the best possible way.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 每个这些特征的目的都是为了以最佳方式使模型适合数据。
- en: 'To formulate the representative equation of the ARIMA model we start from the
    ARMA model equation:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 为了制定ARIMA模型的代表性方程，我们从ARMA模型方程开始：
- en: '![](img/fdfb1f75-0c54-4ca2-9945-90f23595341a.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fdfb1f75-0c54-4ca2-9945-90f23595341a.png)'
- en: 'Simply move the AR part to the right side of equation to obtain the following
    equation (less than the constant *c*):'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 简单地将AR部分移到方程的右侧，得到以下方程（小于常数 *c*）：
- en: '![](img/a889d8fd-b97c-47e2-b994-81c1815c0107.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a889d8fd-b97c-47e2-b994-81c1815c0107.png)'
- en: 'By introducing the lag operator (*L*), we can rewrite this equation as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 通过引入滞后算子 (*L*)，我们可以将这个方程重写如下：
- en: '![](img/e458fe3c-64d7-4820-94e3-a8b40bdebfc0.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e458fe3c-64d7-4820-94e3-a8b40bdebfc0.png)'
- en: 'Remember: The lag operator (*L*) operates on an element of a time series to
    produce the previous element, with the meaning that *LY[t] = Y[t-1]*.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 记住：滞后算子 (*L*) 对时间序列的一个元素进行操作，以产生前一个元素，其含义是 *LY[t] = Y[t-1]*。
- en: 'Assuming that:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 假设如下：
- en: '![](img/67e700d3-edea-4f37-8641-01f05a20fb3a.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](img/67e700d3-edea-4f37-8641-01f05a20fb3a.png)'
- en: 'Which expresses precisely the factoring procedure of order *d* previously carried
    out to eliminate the non-stationarity. Based on this assumption and setting *p
    = p''-d*, we can write the following equation to represent the mathematical formulation
    of the ARIMA *(p,d,q)* model using lag polynomials:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这精确地表达了之前为了消除非平稳性而进行的 *d* 阶因式分解过程。基于这个假设并设置 *p = p'-d*，我们可以写出以下方程来表示ARIMA *(p,d,q)*
    模型的数学公式，使用滞后多项式：
- en: '![](img/d7a23d6b-bc3e-45c2-b110-a3c4ae0931c7.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d7a23d6b-bc3e-45c2-b110-a3c4ae0931c7.png)'
- en: The *d* parameter controls the level of differentiating. Generally *d=1* is
    enough in most cases.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '*d* 参数控制着区分的程度。通常情况下，*d=1* 就足够了。'
- en: Removing seasonality from a time series
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从时间序列中去除季节性
- en: In economic and financial analyses, which are commonly carried out on the basis
    of numerous indicators, the use of data presented in a seasonally adjusted form
    (that is, net of seasonal fluctuations), is widely used in order to be able to
    grasp more clearly the short-term evolution of the phenomena considered.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在经济和金融分析中，这些分析通常基于众多指标，使用季节性调整形式（即净去季节性波动）的数据被广泛使用，以便更清楚地把握所考虑现象的短期演变。
- en: Seasonality, in the dynamics of a time series, is the component that repeats
    itself at regular intervals every year, with variations of intensity more or less
    similar in the same period (month, quarter, semester, and so on) of successive
    years; there is different intensity during the same year. Typical examples of
    this are a decrease in industrial production in August following holiday closures
    of many companies, and increase in retail sales in December due to the holiday
    season.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在时间序列的动态中，季节性是每年以固定间隔重复出现的成分，在连续年份的同一时期（月份、季度、学期等）中强度变化或多或少相似；在同年中强度不同。这种类型的典型例子是8月份在许多公司假期关闭后工业生产的下降，以及12月份由于假日季节零售销售的上升。
- en: Seasonal fluctuations, disguising other movements of interest (typically cyclical
    fluctuations), are often considered to be a nuisance in the analysis of economic
    conjuncture. The presence of seasonality creates, for example, problems in analysis
    and interpretation of the variations observed in a historical series between two
    consecutive periods (months and quarters) of the year—so-called **economic variation**.
    These are often influenced to a prevalent extent by seasonal fluctuations rather
    than movements due to other causes (for example, the economic cycle). The latter,
    on the other hand, can be correctly highlighted by calculating economic variations
    on seasonally adjusted data. Furthermore, since each time series is characterized
    by a specific seasonal profile, the use of seasonally adjusted data makes it possible
    to compare the evolution of different time series, and it is widely applied in
    joint use of statistics produced by different countries.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 季节性波动，伪装其他感兴趣的运动（通常是周期性波动），在分析经济周期时通常被视为一种干扰。季节性的存在会在例如分析历史序列中两个连续时期（月份和季度）之间观察到的变化时造成问题——所谓的**经济波动**。这些波动通常在很大程度上受到季节性波动的影响，而不是其他原因（例如，经济周期）的影响。另一方面，可以通过在季节性调整后的数据上计算经济波动来正确地突出显示后者。此外，由于每个时间序列都有其特定的季节性特征，使用季节性调整后的数据使得比较不同时间序列的演变成为可能，并且在联合使用不同国家产生的统计数据时得到了广泛应用。
- en: Analyzing a time series dataset
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析时间序列数据集
- en: 'To see how to perform a seasonality removal operation on a time series, we
    will use a dataset on monthly milk production (pounds per cow; January 1962 –
    December 1975). Here is some useful information about this dataset:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何在时间序列上执行季节性移除操作，我们将使用关于月度牛奶产量（每头牛的磅数；1962年1月 – 1975年12月）的数据集。以下是关于此数据集的一些有用信息：
- en: '**Units**: Pounds per cow'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单位**：每头牛的磅数'
- en: '**Dataset metrics**: 168 fact values in one time series'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据集度量**：一个时间序列中的 168 个事实值'
- en: '**Time granularity**: Month'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**时间粒度**：月份'
- en: '**Time range**: January 1962 – December 1975'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**时间范围**：1962年1月 – 1975年12月'
- en: '**Source**: Time Series Data Library'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**来源**：时间序列数据库'
- en: The **Time Series Data Library** (**TSDL**) was created by Rob Hyndman, a professor
    of statistics at Monash University, Australia.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '**时间序列数据库**（**TSDL**）是由澳大利亚莫纳什大学统计学教授 Rob Hyndman 创建的。'
- en: 'The data is available in a `.csv` file named `milk-production-pounds.csv`.
    To start, let''s see how to import the data into Python and then how to display
    it to identify the possible presence of seasonality. The first thing to do is
    to import the library that we will use:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 数据存储在一个名为 `milk-production-pounds.csv` 的 `.csv` 文件中。首先，让我们看看如何将数据导入 Python，然后如何显示它以识别可能存在的季节性。首先要做的事情是导入我们将要使用的库：
- en: '[PRE0]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: With the first line, we imported the `pandas` library, and with the second line,
    we imported the `pyplot` module from the `matplotlib` library.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行中，我们导入了 `pandas` 库，在第二行中，我们导入了来自 `matplotlib` 库的 `pyplot` 模块。
- en: '`pandas` is an open source, BSD-licensed library providing high-performance,
    easy-to-use data structures and data analysis tools for the Python programming
    language. In particular, it offers data structures and operations for manipulating
    numerical tables and time series.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`pandas` 是一个开源的 BSD 许可库，为 Python 编程语言提供高性能、易于使用的数据结构和数据分析工具。特别是，它提供了用于操作数值表和时间序列的数据结构和操作。'
- en: 'Matplotlib is a Python 2D plotting library that produces publication-quality
    figures in a variety of hard copy formats and interactive environments across
    platforms. Matplotlib can be used in Python scripts, the Python and IPython shell,
    Jupyter Notebook, web application servers, and four graphical user interface toolkits.
    The `matplotlib.pyplot` module contains functions that allow you to generate many
    kinds of plots quickly. Now let''s see how to import the data contained in the
    dataset in Python:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Matplotlib 是一个 Python 2D 绘图库，可以在各种硬拷贝格式和跨平台的交互式环境中生成出版物质量的图形。Matplotlib 可以用于
    Python 脚本、Python 和 IPython Shell、Jupyter Notebook、Web 应用服务器以及四个图形用户界面工具包。`matplotlib.pyplot`
    模块包含允许您快速生成许多类型图表的函数。现在让我们看看如何在 Python 中导入数据集中包含的数据：
- en: '[PRE1]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To import a dataset, we used the `read_csv` module of the `pandas` library.
    The `read_csv` method loads the data in a Pandas DataFrame we named `data`. To
    display the first five rows of the DataFrame imported on video, we can use the
    `head()` function as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 要导入数据集，我们使用了 `pandas` 库的 `read_csv` 模块。`read_csv` 方法将数据加载到我们命名为 `data` 的 Pandas
    DataFrame 中。为了显示视频导入的 DataFrame 的前五行，我们可以使用 `head()` 函数如下：
- en: '[PRE2]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following results are returned:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 以下结果返回：
- en: '[PRE3]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `head()` function, with no arguments, gets the first five rows of data
    from the DataFrame. Now the time series is available in our Python environment;
    to get a preview of the data contained in it, we can calculate a series of basic
    statistics. To do so, we will use the `describe()` function in the following way:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`head()` 函数不带任何参数时，从 DataFrame 中获取前五行数据。现在时间序列已在我们的 Python 环境中可用；为了预览其中包含的数据，我们可以计算一系列基本统计量。为此，我们将使用以下方式的
    `describe()` 函数：'
- en: '[PRE4]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following results are returned:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 以下结果返回：
- en: '[PRE5]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `describe()` function generates descriptive statistics that summarize the
    central tendency, dispersion, and shape of a dataset''s distribution, excluding
    NaN values. It analyzes both numeric and object series, as well as DataFrame column
    sets of mixed data types. The output will vary depending on what is provided.
    To extract further information, we can invoke the function `info()` as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`describe()` 函数生成描述性统计量，用于总结数据集分布的中心趋势、离散程度和形状，排除 NaN 值。它分析数值和对象序列，以及混合数据类型的
    DataFrame 列集。输出将根据提供的内容而变化。为了提取更多信息，我们可以按照以下方式调用 `info()` 函数：'
- en: '[PRE6]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The following results are returned:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 以下结果返回：
- en: '[PRE7]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'After having taken a look at the content of the dataset, we are going to perform
    an initial visual exploratory analysis. There''s a relatively extensive plotting
    functionality built into Pandas that can be used for exploratory charts—especially
    useful in data analysis. A huge amount of functionality is provided by the `.plot()`
    command natively by Pandas:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看数据集的内容之后，我们将进行初步的视觉探索性分析。Pandas 内置了相对广泛的绘图功能，可用于探索性图表——特别是在数据分析中非常有用。Pandas
    的 `.plot()` 命令本身提供了大量的功能：
- en: '[PRE8]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `data.plot()` command makes plots of the DataFrame using `matplotlib`/`pylab`.
    To display the graph just created on video, we have to use the `plt.show()` function,
    as shown in the following graph:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`data.plot()` 命令使用 `matplotlib`/`pylab` 绘制 DataFrame 的图表。为了在视频中显示刚刚创建的图表，我们必须使用
    `plt.show()` 函数，如下面的图表所示：'
- en: '![](img/92e6df22-1259-4c7e-bbd4-83510b84d329.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/92e6df22-1259-4c7e-bbd4-83510b84d329.png)'
- en: From the analysis of the previous figure, we can certainly recognize that milk
    production is growing (we note a positive trend) but denoting a certain variability
    (oscillations around a hypothetical trend line). This is maintained almost constantly
    with the passage of time.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 从前一个图表的分析中，我们可以肯定地认识到牛奶产量正在增长（我们注意到一个正向趋势），但同时也表现出一定的可变性（围绕假设趋势线的波动）。这种状态几乎随着时间的推移而持续不变。
- en: Identifying a trend in a time series
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 识别时间序列中的趋势
- en: 'If we want to try a prediction of milk production in the next January, we can
    think in the following way: with the acquired data, we can trace the trend line
    and extend it until the following January. In this way, we would have a rough
    estimate of milk production that we should expect in the immediate future.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要尝试预测下一个月的牛奶产量，我们可以这样思考：有了获取到的数据，我们可以追踪趋势线并将其延伸到下一个月。这样，我们就可以对即将到来的未来牛奶产量有一个粗略的估计。
- en: But tracing a trend line means tracing the regression line. The linear regression
    method consists of precisely identifying a line that is capable of representing
    point distribution in a two-dimensional plane. As is easy to imagine, if the points
    corresponding to the observations are near the line, then the chosen model will
    be able to effectively describe the link between the variables. In theory, there
    are an infinite number of lines that may approximate the observations. In practice,
    there is only one mathematical model that optimizes the representation of the
    data.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 但追踪趋势线意味着追踪回归线。线性回归方法包括精确地确定一条能够代表二维平面上点分布的线。正如容易想象的那样，如果对应于观察点的点靠近这条线，那么选定的模型将能够有效地描述变量之间的联系。在理论上，有无限多条可能近似观察点的线。在实践中，只有一个数学模型能够优化数据的表示。
- en: 'To fit a linear regression model, we start importing two more libraries:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 要拟合线性回归模型，我们首先需要导入两个额外的库：
- en: '[PRE9]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'NumPy is the fundamental package for scientific computing with Python. It contains,
    among other things:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 是 Python 科学计算的基础包。它包含，但不仅限于：
- en: A powerful N-dimensional array object
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个强大的 N 维数组对象
- en: Sophisticated (broadcasting) functions
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复杂的（广播）功能
- en: Tools for integrating C/C++ and FORTRAN code
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于集成 C/C++ 和 FORTRAN 代码的工具
- en: Useful linear algebra, Fourier transform, and random number capabilities
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有用的线性代数、傅里叶变换和随机数功能
- en: Besides its obvious scientific uses, NumPy can also be used as an efficient
    multi-dimensional container of generic data. Arbitrary datatypes can be defined.
    This allows NumPy to seamlessly and speedily integrate with a wide variety of
    databases.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 除了其明显的科学用途外，NumPy 还可以用作高效的多维通用数据容器。可以定义任意数据类型。这使得 NumPy 能够无缝且快速地与各种数据库集成。
- en: sklearn is a free software machine learning library for the Python programming
    language. It features various classification, regression and clustering algorithms
    including support vector machines, random forests, gradient boosting, k-means
    and DBSCAN, and is designed to interoperate with the Python numerical and scientific
    libraries NumPy and SciPy.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: sklearn 是一个用于 Python 编程语言的免费软件机器学习库。它包含各种分类、回归和聚类算法，包括支持向量机、随机森林、梯度提升、k-means
    和 DBSCAN，并且设计为与 Python 的数值和科学库 NumPy 和 SciPy 兼容。
- en: Remember, to import a library that is not present in the initial distribution
    of Python, you must use the `pip` install command followed by the name of the
    library. This command should be used only once and not every time you run the
    code.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，要导入Python初始分布中不存在的库，你必须使用`pip install`命令后跟库的名称。这个命令应该只使用一次，而不是每次运行代码时都使用。
- en: 'We begin to prepare the data:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始准备数据：
- en: '[PRE10]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'First, we counted the data; then we used the `reshape()` function to give a
    new shape to an array without changing its data. Finally, we inserted the time
    series values into the `y` variable. Now we can build the linear regression model:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们统计了数据；然后我们使用`reshape()`函数给一个数组赋予新的形状而不改变其数据。最后，我们将时间序列值插入到`y`变量中。现在我们可以构建线性回归模型：
- en: '[PRE11]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `LinearRegression()` function performs a ordinary least squares linear regression.
    The ordinary least squares method is an optimization technique (or regression)
    that allows us to find a function, represented by an optimal curve (or regression
    curve) that is as close as possible to a set of data. In particular, the function
    found must be one that minimizes the sum of squares of distances between the observed
    data and those of the curve that represents the function itself.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`LinearRegression()`函数执行普通最小二乘线性回归。普通最小二乘法是一种优化技术（或回归），它允许我们找到一个函数，该函数由一个最优曲线（或回归曲线）表示，该曲线尽可能接近一组数据。特别是，找到的函数必须是最小化观测数据与代表该函数本身的曲线之间的距离平方和的函数。'
- en: 'Given n points (*x[1]*, *y[1]*), (*x[2]*, *y[2]*), ... (*x[n]*, *y[n]*) in
    the observed population, a least squares regression line is defined as the equation
    line:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 给定观察群体中的n个点(*x[1]*, *y[1]*), (*x[2]*, *y[2]*), ... (*x[n]*, *y[n]*)，最小二乘回归线定义为方程线：
- en: '*y=α*x+β*'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '*y=α*x+β*'
- en: 'For which the following quantity is minimal:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 对于以下量是最小的：
- en: '![](img/030fe6e9-bb43-4d99-9110-c10d99248be8.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](img/030fe6e9-bb43-4d99-9110-c10d99248be8.png)'
- en: 'This quantity represents the sum of squares of distances of each experimental
    datum (*x[i], y[i]*) from the corresponding point on the straight line *(x[i],
    αx[i]+β)*, as shown in the following plot:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这个量表示每个实验数据(*x[i], y[i]*)到对应直线上的点(*x[i], αx[i]+β*)的距离平方和，如下所示：
- en: '![](img/c3f1540d-3f16-4fd4-b574-131621ec52d1.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c3f1540d-3f16-4fd4-b574-131621ec52d1.png)'
- en: 'Now, we have to apply the `fit` method to fit the linear model:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须应用`fit`方法来拟合线性模型：
- en: '[PRE12]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'A linear regression model basically finds the best value for the intercept
    and slope, which results in a line that best fits the data. To see the value of
    the intercept and slope calculated by the linear regression algorithm for our
    dataset, execute the following code:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 线性回归模型基本上找到截距和斜率的最佳值，从而得到一条最佳拟合数据的直线。为了查看线性回归算法为我们数据集计算出的截距和斜率的值，执行以下代码：
- en: '[PRE13]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The following results are returned:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 返回以下结果：
- en: '[PRE14]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The first is the intercept; the second is the coefficient of the regression
    line. Now that we have trained our algorithm, it''s time to make some predictions.
    To do so, we will use the whole data and see how accurately our algorithm predicts
    the percentage score. Remember, our scope is to locate the time series trend.
    To make predictions on the whole data, execute the following code:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是截距；第二个是回归线的系数。现在我们已经训练了我们的算法，是时候进行一些预测了。为了做到这一点，我们将使用全部数据并查看我们的算法预测百分比分数的准确性。记住，我们的目标是定位时间序列趋势。要对全部数据进行预测，执行以下代码：
- en: '[PRE15]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'It is time to visualize what we have achieved:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候可视化我们所取得的成果了：
- en: '[PRE16]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'With this code, we first traced the time series. So we added the regression
    line that represents the data trend, and finally we printed the whole thing, as
    shown in the following graph:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这段代码，我们首先追踪了时间序列。因此，我们添加了代表数据趋势的回归线，最后我们将整个图表打印出来，如下所示：
- en: '![](img/56c969c3-7c64-45f7-b228-360787f01f08.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![](img/56c969c3-7c64-45f7-b228-360787f01f08.png)'
- en: 'We recall that this represents a long-term monotonous trend movement, which
    highlights a structural evolution of the phenomenon due to causes that act in
    a systematic manner on the same. From the analysis of the previous figure, it
    is possible to note this: making a estimation of milk production in a precise
    period based on the line that indicates the trend of the time series can, in some
    cases, be disastrous. This is due to the fact that the seasonal highs and lows
    are at important distances from the line of regression. It is clear that it is
    not possible to use this line to make estimates of milk production.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们回顾一下，这代表了一种长期单调趋势运动，突出了由于在相同方面系统作用的原因而产生的现象的结构演变。从前图的分析中，我们可以注意到这一点：基于表示时间序列趋势的线条对精确时期牛奶产量进行估计，在某些情况下可能是灾难性的。这是因为季节性高点和低点与回归线的距离很重要。很明显，不能使用这条线来估计牛奶产量。
- en: Time series decomposition
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时间序列分解
- en: 'One of the fundamental purposes of the classical analysis of time series is
    to break down the series into its components, isolating them in order to study
    them better. Moreover, to be able to apply the stochastic approach to a time series,
    it is almost always necessary to eliminate the trend and the seasonality to have
    a steady process. As we have specified in the previous sections, the components
    of a time series are usually the following: trend, seasonality, cycle, and residual.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 时间序列经典分析的一个基本目的是将序列分解为其组成部分，以便更好地研究它们。此外，为了能够将随机方法应用于时间序列，通常几乎总是需要消除趋势和季节性，以获得稳定的过程。正如我们在前面的章节中指定的那样，时间序列的组成部分通常是以下这些：趋势、季节性、周期和残差。
- en: 'As already mentioned, they can be decomposed by an additive way:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，它们可以通过加法方式分解：
- en: '*Y(t) = τ(t) + S(t) + r(t)*'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '*Y(t) = τ(t) + S(t) + r(t)*'
- en: 'They can also be decomposed by a multiplicative method:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 它们也可以通过乘法方法分解：
- en: '*Y(t) = τ(t) * S(t) * r(t)*'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '*Y(t) = τ(t) * S(t) * r(t)*'
- en: In the following sections, we will look at how to derive these components using
    both these methods.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将探讨如何使用这两种方法推导出这些成分。
- en: Additive method
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加法方法
- en: To perform a time series decomposition, we can use automated procedures. The
    `stats` models library provides an implementation of the naive, or classical,
    decomposition method in a function called `seasonal_decompose()`. Additive or
    multiplicative methods are available.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行时间序列分解，我们可以使用自动化程序。`stats`模型库提供了一个名为`seasonal_decompose()`的函数，实现了朴素或经典分解方法的实现。加法或乘法方法都是可用的。
- en: 'We start importing the `stats` models library:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始导入`stats`模型库：
- en: '[PRE17]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In particular, we imported the `seasonal_decompose` module to perform seasonal
    decomposition using MAs. We perform the decomposition by applying the additive
    method:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是我们导入了`seasonal_decompose`模块，使用移动平均（MAs）进行季节分解。我们通过应用加法方法进行分解：
- en: '[PRE18]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The seasonal component is first removed by applying a convolution filter to
    the data. The average of this smoothed series for each period is the returned
    seasonal component. Let''s see what happened through the visualization of the
    components identified:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对数据进行卷积滤波器处理，首先移除季节成分。每个周期的平滑序列的平均值即为返回的季节成分。让我们通过识别成分的可视化来看看发生了什么：
- en: '[PRE19]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The following graph shows the decomposition results by additive method:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了加法方法的分解结果：
- en: '![](img/8cc10757-6cf6-406d-befa-8600a842f876.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8cc10757-6cf6-406d-befa-8600a842f876.png)'
- en: 'In this figure, the three components of the time series are clearly represented:
    trend, seasonal, and residual. These attributes are contained in the object returned
    by the method `seasonal_decompose()`. This means that we can use the content of
    that object to remove the effect of seasonality from the time series. Let''s see
    how:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在此图中，时间序列的三个成分被清晰地表示出来：趋势、季节和残差。这些属性包含在`seasonal_decompose()`方法返回的对象中。这意味着我们可以使用该对象的内容来从时间序列中去除季节性影响。让我们看看如何：
- en: '[PRE20]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'With this line of code, we have simplified the seasonal attribute returned
    by the `seasonal_decompose()` method from the data. At this point, we just have
    to visualize the result:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这一行代码，我们已经简化了`seasonal_decompose()`方法从数据返回的季节性属性。此时，我们只需可视化结果：
- en: '[PRE21]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The following graph shows the monthly milk production (pounds per cow from
    January 1962 – December 1975) net of seasonality:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了去除季节性后的月度牛奶产量（1962年1月至1975年12月每头牛的磅数）：
- en: '![](img/60c6dbf7-ad1c-45e7-a3ea-1c240e5f8ac1.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/60c6dbf7-ad1c-45e7-a3ea-1c240e5f8ac1.png)'
- en: In the graph obtained, the component due to seasonality has clearly been removed,
    while the one due to the trend is clearly visible.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在获得的图表中，由于季节性而产生的成分已被清楚地去除，而由于趋势而产生的成分则清晰可见。
- en: Multiplicative method
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 乘法方法
- en: 'As we said, the `seasonal_decompose()` performs both additive and multiplicative
    decomposition. To run multiplicative method, just type the following command:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所说的，`seasonal_decompose()`执行加法和乘法分解。要运行乘法方法，只需键入以下命令：
- en: '[PRE22]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'At this point, we just have to visualize the result:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只需可视化结果：
- en: '[PRE23]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The following graph shows the decomposition results by multiplicative method:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图表显示了乘法方法的分解结果：
- en: '![](img/cb7bd241-4501-42ec-bfd0-50badb4e87a2.png)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cb7bd241-4501-42ec-bfd0-50badb4e87a2.png)'
- en: In the previous figure, we can note that the trend and seasonality information
    extracted from the time series do seem reasonable. The residuals show an interesting
    variation; periods of high variability are clearly identified in the early and
    later years of the time series.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一幅图中，我们可以注意到从时间序列中提取的趋势和季节性信息似乎相当合理。残差显示出有趣的变异；在时间序列的早期和后期，高变异性时期被清楚地识别出来。
- en: LSTM for time series analysis
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用于时间序列分析的LSTM
- en: LSTM is a particular architecture of recurrent neural network, originally conceived
    by Hochreiter and Schmidhuber in 1997\. This type of neural network has been recently
    rediscovered in the context of deep learning because it is free from the problem
    of vanishing gradient, and in practice it offers excellent results and performance.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: LSTM是一种由Hochreiter和Schmidhuber在1997年最初构思的循环神经网络特定架构。这种类型的神经网络最近在深度学习背景下被重新发现，因为它摆脱了梯度消失的问题，并且在实践中提供了出色的结果和性能。
- en: LSTM-based networks are ideal for prediction and classification of time series,
    and are supplanting many classic machine learning approaches. This is due to the
    fact that LSTM networks are able to consider long-term dependencies between data,
    and in the case of speech recognition, this means managing the context within
    a sentence to improve recognition capacity.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 基于LSTM的网络非常适合时间序列的预测和分类，并且正在取代许多经典的机器学习方法。这是因为LSTM网络能够考虑数据之间的长期依赖关系，在语音识别的情况下，这意味着管理句子中的上下文以提高识别能力。
- en: Overview of the time series dataset
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时间序列数据集概述
- en: 'Scientists from the US **National Oceanic and Atmospheric Administration**
    (**NOAA**) have measured atmospheric carbon dioxide from 1965 to 1980 near the
    top of the Mauna Loa volcanic cone (Hawaii). The dataset covers carbon dioxide
    concentrations of 317.25 to 341.19 **parts per million** (**ppm**) by volume and
    contains 192 monthly records. Here is some useful information about this dataset:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 来自美国**国家海洋和大气管理局**（**NOAA**）的科学家们从1965年到1980年在夏威夷莫纳罗亚火山锥顶部（顶部）测量了大气二氧化碳。该数据集覆盖了317.25到341.19
    **百万分之一**（**ppm**）的二氧化碳浓度，并包含192个月的记录。以下是关于此数据集的一些有用信息：
- en: '**Units**: ppm'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单位**：ppm'
- en: '**Dataset metrics**: 192 fact values in one time series'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据集指标**：一个时间序列中有192个事实值'
- en: '**Time granularity**: Month'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**时间粒度**：月'
- en: '**Time range**: January 1965-December 1980'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**时间范围**：1965年1月-1980年12月'
- en: 'Source: TSDL, created by Rob Hyndman, a professor of statistics at Monash University,
    Australia.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 来源：TSDL，由澳大利亚莫纳什大学统计学教授Rob Hyndman创建。
- en: 'Data is available in the `.csv` file named `co2-ppm-mauna-loa-19651980.csv`.
    To start, let''s see how to import data into Python and then how to display them
    to identify the possible presence of seasonality. The first thing to do is to
    import the library that we will use:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 数据可在名为`co2-ppm-mauna-loa-19651980.csv`的`.csv`文件中找到。首先，让我们看看如何将数据导入Python，然后如何显示它们以识别可能存在的季节性。首先要做的事情是导入我们将要使用的库：
- en: '[PRE24]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'With the first line, we imported `pandas` and with second line we imported
    the `pyplot` module from the `matplotlib` library. Now let''s see how to import
    the data contained in the dataset in Python:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行中，我们导入了`pandas`，在第二行中，我们导入了来自`matplotlib`库的`pyplot`模块。现在让我们看看如何在Python中导入数据集中的数据：
- en: '[PRE25]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To import a dataset, we used the `read_csv` module of the `pandas` library.
    The `read_csv` method loads the data in a Pandas DataFrame we named dataset. To
    display on video the first five rows of DataFrame imported, we can use the `head()`
    function as follows:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 要导入数据集，我们使用了`pandas`库的`read_csv`模块。`read_csv`方法将数据加载到我们命名为`dataset`的Pandas DataFrame中。为了在视频中显示导入的DataFrame的前五行，我们可以使用以下`head()`函数：
- en: '[PRE26]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The following results are returned:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 返回以下结果：
- en: '[PRE27]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `head()` function, with no arguments, gets the first five rows of data
    from the DataFrame. Now the time series is now available in our Python environment;
    to get a preview of the data contained in it, we can calculate a series of basic
    statistics. To do so, we will use the `describe()` function in the following way:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '`head()`函数不带参数时，从DataFrame中获取前五行数据。现在时间序列已经存在于我们的Python环境中；为了预览其中的数据，我们可以计算一系列基本统计信息。为此，我们将使用以下方式的`describe()`函数：'
- en: '[PRE28]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The following results are returned:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 返回以下结果：
- en: '[PRE29]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `describe()` function generates descriptive statistics that summarize the
    central tendency, dispersion and shape of a dataset''s distribution, excluding
    NaN values. It analyzes both numeric and object series, as well as DataFrame column
    sets of mixed data types. The output will vary depending on what is provided.
    To extract further information, we can invoke the function `info()`:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`describe()`函数生成描述性统计信息，总结数据集分布的中心趋势、离散度和形状，排除NaN值。它分析数值和对象序列，以及混合数据类型的DataFrame列集。输出将根据提供的内容而变化。为了提取更多信息，我们可以调用`info()`函数：'
- en: '[PRE30]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The following results are returned:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 返回以下结果：
- en: '[PRE31]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'After having taken a look at the content of the dataset, we are going to perform
    an initial visual exploratory analysis. There''s a relatively extensive plotting
    functionality built into Pandas that can be used for exploratory charts; this
    is especially useful in data analysis. A huge amount of functionality is provided
    by the `.plot()` command natively by Pandas:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看数据集的内容之后，我们将进行初步的视觉探索性分析。Pandas内置了相对广泛的绘图功能，可用于探索性图表；这在数据分析中特别有用。Pandas的`.plot()`命令提供了大量的功能：
- en: '[PRE32]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The `dataset.plot()` command make plots of the DataFrame using `matplotlib`/`pylab`.
    To display the graph just created on video, we have to use the `plt.show()` function,
    as shown in the following graph:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '`dataset.plot()`命令使用`matplotlib`/`pylab`绘制DataFrame的图表。为了在视频中显示刚刚创建的图表，我们必须使用`plt.show()`函数，如下面的图表所示：'
- en: '![](img/c0e05687-3b9f-41fe-91da-f4d54da69b3f.png)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c0e05687-3b9f-41fe-91da-f4d54da69b3f.png)'
- en: From the analysis of the previous figure, we can certainly recognize that atmospheric
    carbon dioxide is growing. We note a positive trend. But it is also denoting a
    certain variability (oscillations around a hypothetical trend line), which is
    maintained almost constantly with the passage of time.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 从前一个图的分析中，我们可以肯定地认识到大气二氧化碳正在增长。我们注意到一个正向趋势。但这也表明了一定的可变性（围绕假设趋势线的振荡），这种可变性几乎随着时间的推移而持续保持。
- en: Data scaling
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据缩放
- en: '**Data scaling** is a preprocessing technique usually employed before feature
    selection and classification. Many artificial intelligence-based systems use features
    that are generated by many different feature extraction algorithms, with different
    kinds of sources. These features may have different dynamic ranges.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据缩放**是一种预处理技术，通常在特征选择和分类之前使用。许多基于人工智能的系统使用由许多不同的特征提取算法生成的特征，这些算法来自不同的来源。这些特征可能具有不同的动态范围。'
- en: In addition, in several data mining applications with huge numbers of features
    with large dynamic ranges, feature scaling may improve the performance of the
    fitting model. However, the appropriate choice of these techniques is an important
    issue, since applying scaling on the input could change the structure of data
    and thereby affect the outcome of multivariate analysis used in data mining.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在具有大量特征和较大动态范围的数据挖掘应用中，特征缩放可能会提高拟合模型的性能。然而，选择这些技术是重要的问题，因为对输入数据进行缩放可能会改变数据的结构，从而影响数据挖掘中使用的多元分析结果。
- en: 'To scaling the data we will use the min-max normalization (usually called **feature
    scaling**); it performs a linear transformation on the original data. This technique
    gets all the scaled data in the range (0,1). The formula to achieve this is:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 为了对数据进行缩放，我们将使用最小-最大归一化（通常称为**特征缩放**）；它对原始数据进行线性变换。这种技术将所有缩放数据都转换到（0,1）的范围内。实现这一目标的公式是：
- en: '![](img/7acb1819-3d3e-494d-844b-c4cd6ff64476.png)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7acb1819-3d3e-494d-844b-c4cd6ff64476.png)'
- en: Min-max normalization preserves the relationships among the original data values.
    The cost of having this bounded range is that we will end up with smaller standard
    deviations, which can suppress the effect of outliers.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 最小-最大归一化保留了原始数据值之间的关系。这种有界范围的代价是我们最终会得到较小的标准差，这可能会抑制异常值的影响。
- en: 'To perform min-max normalization, we will use the `MinMaxScaler()` module of
    the `sklearn.preprocessing` class. This module transforms features by scaling
    each feature to a given range. This estimator scales and translates each feature
    individually such that it is in the given range on the training set, that is,
    between zero and one. The following codes show how to apply this module to our
    data:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行最小-最大归一化，我们将使用`sklearn.preprocessing`类的`MinMaxScaler()`模块。此模块通过将每个特征缩放到给定范围来转换特征。这个估计器将每个特征单独缩放和转换，使其在训练集上位于给定的范围内，即零到一之间。以下代码显示了如何将此模块应用于我们的数据：
- en: '[PRE33]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: First we have used the `MinMaxScaler()` function to set the normalization interval
    (by default (0, 1)). In the second line of the code, we applied the `fit_transform()`
    function; it fits the transformer to the dataset and returns a transformed version
    of the data. This function is particularly useful as it stores the transformation
    parameters used. These parameters will be useful when, after having made the forecasts,
    we will have to report the data in the initial form (before normalization) to
    compare it with actual data.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用了`MinMaxScaler()`函数来设置归一化区间（默认为（0，1））。在代码的第二行中，我们应用了`fit_transform()`函数；它将转换器拟合到数据集，并返回数据的转换版本。这个函数特别有用，因为它存储了使用的转换参数。这些参数在做出预测后，我们将需要将这些数据以初始形式（归一化之前）报告出来，以便与实际数据进行比较。
- en: Data splitting
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据拆分
- en: Let's now split the data for the training and the test model. Training and testing
    the model forms the basis for further usage of the model for prediction in predictive
    analytics. Given a dataset of 192 rows of data, we split it into a convenient
    ratio (say 70:30), and allocate 134 rows for training and 58 rows for testing.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来拆分用于训练和测试模型的数据。训练和测试模型是进一步使用模型进行预测分析的基础。给定192行数据的数据集，我们将其拆分为一个方便的比例（比如说70:30），并将134行分配给训练，58行分配给测试。
- en: 'In general, in the algorithms based on artificial neural networks, the splitting
    is done by selecting rows randomly to reduce the bias. With the time series data,
    the sequence of values is important, so this procedure is not practicable. A simple
    method that we can use is to divide the ordered dataset into train and test. As
    we anticipated, the following code calculates the division point index and separates
    the data in the training datasets, with 70% of the observations for us to use
    to train our model; this leaves the remaining 30% to test the model:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在基于人工神经网络的算法中，拆分是通过随机选择行来进行的，以减少偏差。对于时间序列数据，值的顺序很重要，因此这个程序不可行。我们可以使用的一个简单方法是按照顺序将数据集分为训练集和测试集。正如我们所预期的，以下代码计算了分割点索引，并在训练数据集中分离数据，其中70%的观测值用于训练我们的模型；这留下了剩余的30%用于测试模型：
- en: '[PRE34]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The first two lines of code set the length of the two groups of data. The next
    two lines split the dataset into two parts: from row 1 to row `train_len -1` for
    the train set, and from the `train_len` row to the last row for the test set.
    To confirm the correct split of data, we can print the length of the two datasets:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的前两行设置了两组数据长度。接下来的两行将数据集分为两部分：从第1行到`train_len -1`行用于训练集，从`train_len`行到最后一行用于测试集。为了确认数据的正确拆分，我们可以打印两个数据集的长度：
- en: '[PRE35]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This gives the following results:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这给出了以下结果：
- en: '[PRE36]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As we anticipated, the operation divided the dataset into `134` (train set)
    and `58` rows (test set).
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所预期的，这个操作将数据集分为`134`行（训练集）和`58`行（测试集）。
- en: Building the model
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建模型
- en: 'Our aim is to use data in the dataset to make predictions. In particular, we
    want to predict the presence of carbon dioxide in the air based on the data available
    in the `.csv` file. We need input and output to train and test our network. It
    is clear that the input is represented by the data present in the dataset. We
    must then construct our output; we will do so by supposing we want to predict
    the CO2 present in the atmosphere at time *t + 1* with respect to the value measured
    at time *t*. So we will have:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是利用数据集中的数据来进行预测。具体来说，我们希望根据`.csv`文件中可用的数据预测空气中二氧化碳的存在。我们需要输入和输出数据来训练和测试我们的网络。很明显，输入由数据集中存在的数据表示。然后我们必须构建我们的输出；我们将通过假设我们想要预测时间`t
    + 1`时大气中存在的CO2相对于时间`t`时测量的值来做到这一点。所以我们将有：
- en: '*Input = data(t)*'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '*输入 = data(t)*'
- en: '*Output = data(t + 1)*'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '*输出 = data(t + 1)*'
- en: 'We have said that a recurrent network has memory, and it is maintained by fixing
    the so-called **time step**. The time step has to do with how many steps back
    in time backprop uses when calculating gradients for weight updates during training.
    In this way, we set *time step = 1*. Then we define a function that gives a dataset
    and a time step returns the input and output data:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经说过，循环网络具有记忆功能，并且通过固定所谓的**时间步**来维持。时间步与在训练期间计算权重更新梯度的反向传播中回溯的时间步数有关。这样，我们设置
    *时间步 = 1*。然后我们定义一个函数，它接受一个数据集和一个时间步返回输入和输出数据：
- en: '[PRE37]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In this function, `Xdata=Input= data(t)` is the input variable and `Ydata=output=
    data(t + 1)` is the predicted value at the next time period. Let''s use this function
    to set the train and test datasets that we will use in the next phase (network
    modeling):'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在此函数中，`Xdata=Input= data(t)` 是输入变量，`Ydata=output= data(t + 1)` 是下一个时间段的预测值。让我们使用这个函数来设置下一阶段（网络建模）中我们将使用的训练和测试数据集：
- en: '[PRE38]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In this way, we created all the data needed for the network training and testing.
    This function converts an array of values into a dataset matrix. Now we have to
    prepare the two input datasets (`trainX` and `testX`) in the form required by
    the machine learning algorithm we intend to use (LSTM). To do this, it is necessary
    to deepen this concept.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，我们创建了网络训练和测试所需的所有数据。此函数将值数组转换为数据集矩阵。现在我们必须准备两个输入数据集（`trainX` 和 `testX`），以符合我们打算使用的机器学习算法（LSTM）所需的形式。为此，有必要深化这一概念。
- en: 'In a classic feed-forward network, like those already analyzed in the previous
    chapters, the input contains the values assumed by the variables for each observation
    made. This means that the input takes the following shape:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个经典的正向传播网络中，如前几章已分析的，输入包含每个观测变量所假设的值。这意味着输入具有以下形状：
- en: '*(number of observations, number of features)*'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '*(观测数量，特征数量)*'
- en: 'In an LSTM/RNN network, the input for each LSTM layer must contain the following
    information:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在 LSTM/RNN 网络中，每个 LSTM 层的输入必须包含以下信息：
- en: '**Observations**: Number of observations collected'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**观测**：收集到的观测数量'
- en: '**Time steps**: A time step is an observation point in the sample'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**时间步**：样本中的一个观测点'
- en: '**Features**: One feature for each step'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**特征**：每个步骤一个特征'
- en: 'Therefore it is necessary to add a temporal dimension to those foreseen for
    a classical network. Thus the input shape becomes:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，有必要为那些经典网络预见的添加一个时间维度。因此，输入形状变为：
- en: '*(number of observations, number of time steps, number of features per steps)*'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '*(观测数量，时间步数，每步特征数量)*'
- en: 'In this way, the input for each LSTM layer becomes three-dimensional. To transform
    the input datasets in 3D form, we will use the `numpy.reshape()` function as follows:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，每个 LSTM 层的输入变为三维。为了将输入数据集转换为 3D 形式，我们将使用以下 `numpy.reshape()` 函数：
- en: '[PRE39]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `numpy.reshape()` function gives a new shape to an array without changing
    its data. The function parameters used are:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '`numpy.reshape()` 函数在不改变其数据的情况下，为数组赋予新的形状。所使用的函数参数包括：'
- en: '`trainX`, `testX`: Array to be reshaped'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`trainX`，`testX`：需要重塑的数组'
- en: '`(trainX.shape[0], 1, 1)`, `(testX.shape[0], 1, 1)`: New shape'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(trainX.shape[0], 1, 1)`，`(testX.shape[0], 1, 1)`：新形状'
- en: 'The new shape should be compatible with the original shape. In our case, the
    new shape is (133,1,1) for `trainX` and (57,1,1) for `testX`. Now that the data
    is in the right format, it''s time to create the model:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 新形状应该与原始形状兼容。在我们的例子中，新形状是 `trainX` 的 (133,1,1) 和 `testX` 的 (57,1,1)。现在数据已经以正确的格式，是时候创建模型了：
- en: '[PRE40]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We start defining the time steps; then we use a sequential model, that is,
    a linear stack of layers. To create a sequential model, we have to pass a list
    of layer instances to the constructor. We can also simply add layers via the `.add()`
    method:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始定义时间步；然后我们使用一个顺序模型，即层的线性堆叠。要创建一个顺序模型，我们必须将层实例的列表传递给构造函数。我们也可以通过 `.add()`
    方法简单地添加层：
- en: '[PRE41]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The first layer is an LSTM layer, with a hidden layer with four LSTM blocks.
    The model needs to know what input shape it should expect. For this reason, we
    passed an `input_shape` argument to this layer. In the next line, we added a dense
    layer that implements the default sigmoid activation function. Now, we have to
    configure the model for training:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 第一层是一个 LSTM 层，包含四个 LSTM 块的隐藏层。模型需要知道它应该期望的输入形状。因此，我们向这个层传递了一个 `input_shape`
    参数。在下一行，我们添加了一个实现默认 sigmoid 激活函数的密集层。现在，我们必须为训练配置模型：
- en: '[PRE42]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'To do this, we used the compile module. The arguments passed are a loss function
    as `mean_squared_error` and stochastic gradient descent as `optimizer`. Finally,
    we can fit the model:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们使用了编译模块。传递的参数是一个损失函数`mean_squared_error`和随机梯度下降`optimizer`。最后，我们可以拟合模型：
- en: '[PRE43]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In the training phase, the `trainX` and `trainY` data is used, with 1,000 epochs
    (full training cycle on the training set). A batch size of 1 (batch_size = number
    of samples per gradient update) is passed. Fynally `verbose=2` (verbose argument
    provides additional details as to what the computer is doing) prints the loss
    value for each epoch.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在训练阶段，使用`trainX`和`trainY`数据，共1,000个epoch（在训练集上的完整训练周期）。传递一个批大小为1（batch_size
    = 每个梯度更新中的样本数）。最后`verbose=2`（verbose参数提供了关于计算机正在做什么的额外细节）打印出每个epoch的损失值。
- en: Making predictions
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进行预测
- en: 'Our model is now ready for use. We can therefore use it to execute our predictions:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的模式现在已准备好使用。因此，我们可以用它来执行我们的预测：
- en: '[PRE44]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The `predict()` module has been used, which generates output predictions for
    the input samples. Computation is done in batches. A Numpy array of predictions
    is returned. Previously, when data scaling was performed, we used the `fit_transform()`
    function. As we said, this function is particularly useful as it stores the transformation
    parameters used. These parameters will be useful when, after having made the forecasts,
    we will have to report the data in the initial form (before normalization), to
    compare it to the actual data. In fact, now the predictions must be reported in
    original form to compare with the actual values:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 使用了`predict()`模块，它为输入样本生成输出预测。计算是在批处理中完成的。返回一个预测的Numpy数组。之前，当执行数据缩放时，我们使用了`fit_transform()`函数。正如我们所说的，这个函数特别有用，因为它存储了使用的转换参数。这些参数在做出预测后，当我们必须将数据报告为初始形式（在归一化之前），以便与实际数据进行比较时将是有用的。事实上，现在必须以原始形式报告预测，以便与实际值进行比较：
- en: '[PRE45]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This code block is used exclusively to cancel the effect of normalization and
    to restore the initial form to the dataset. To estimate the performance of the
    algorithm, we will calculate the root mean squared error:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码块仅用于取消归一化的影响，并将数据集恢复到初始形式。为了估计算法的性能，我们将计算均方根误差：
- en: '[PRE46]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '**Root mean square error** (**RMSE**) measures how much error there is between
    two datasets. In other words, it compares a predicted value and an observed value.'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '**均方根误差**（**RMSE**）衡量两个数据集之间的误差程度。换句话说，它比较了一个预测值和一个观察值。'
- en: 'The following results are returned:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 返回以下结果：
- en: '[PRE47]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'After evaluating the method''s performance, we can now visualize the results
    by drawing an appropriate graph. To display the time series correctly, a prediction
    shift is required. This operation must be carried out both on the train set and
    on the test set:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在评估了方法性能之后，我们现在可以通过绘制适当的图表来可视化结果。为了正确显示时间序列，需要进行预测偏移。这个操作必须在训练集和测试集上执行：
- en: '[PRE48]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Then perform the same operation on the test set:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在测试集上执行相同的操作：
- en: '[PRE49]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Finally, we have to plot the actual data and the predictions:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须绘制实际数据和预测：
- en: '[PRE50]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'In the following graph are shown the actual data and the predictions:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下图表中显示了实际数据和预测：
- en: '![](img/74b02eb1-05a0-43a4-9d19-74b49c5a736a.png)'
  id: totrans-354
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/74b02eb1-05a0-43a4-9d19-74b49c5a736a.png)'
- en: From the analysis of the previous graph, we can see that what is reported by
    the RMSE is confirmed by the graph. In fact, we can see that the model has done
    an excellent job in the fitting of both the training and test datasets.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 从前一个图表的分析中，我们可以看到RMSE报告的内容得到了图表的证实。事实上，我们可以看到模型在训练集和测试集的拟合方面做得非常出色。
- en: Summary
  id: totrans-356
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we explored time series data. A time series constitutes a
    sequence of observations on a phenomenon. In a time series, we can identify several
    components: trend, seasonality, cycle, and residual. We learned how to remove
    seasonality from a time series with a practical example.'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了时间序列数据。时间序列构成了一系列现象的观察序列。在一个时间序列中，我们可以识别出几个组成部分：趋势、季节性、周期和残差。我们通过一个实际例子学习了如何从一个时间序列中去除季节性。
- en: 'Then the most used models to represent time series were addressed: AR, MA,
    ARMA, and ARIMA. For each one, the basic concepts were analyzed and then a mathematical
    formulation of the model was provided.'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 然后讨论了表示时间序列的最常用的模型：AR、MA、ARMA和ARIMA。对于每一个，我们分析了基本概念，然后提供了模型的数学公式。
- en: Finally, an LSTM model for time series analysis was proposed. Using a practical
    example, we could see how to deal with a time series regression problem with a
    recurrent neural network model of the LSTM type.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，提出了一种用于时间序列分析的长短期记忆（LSTM）模型。通过一个实际例子，我们可以看到如何使用LSTM类型的循环神经网络模型来处理时间序列回归问题。
