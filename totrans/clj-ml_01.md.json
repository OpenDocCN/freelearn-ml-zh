["```py\n$ lein new default my-project\n\n```", "```py\n(defproject my-project \"0.1.0-SNAPSHOT\"\n  :description \"FIXME: write description\"\n  :url \"http://example.com/FIXME\"\n  :license \n  {:name \"Eclipse Public License\"\n   :url \"http://www.eclipse.org/legal/epl-v10.html\"}\n  :dependencies [[org.clojure/clojure \"1.5.1\"]])\n```", "```py\n  :dependencies [[org.clojure/clojure \"1.5.1\"]\n                 [net.mikera/core.matrix \"0.20.0\"]])\n```", "```py\n$ lein deps\n\n```", "```py\n$ lein repl\n\n```", "```py\n[net.mikera/core.matrix \"0.20.0\"]\n```", "```py\n(ns my-namespace\n  (:use clojure.core.matrix))\n```", "```py\nuser> (matrix [[0 1 2] [3 4 5]])    ;; using a vector\n[[0 1 2] [3 4 5]]\nuser> (matrix '((0 1 2) (3 4 5)))   ;; using a quoted list\n[[0 1 2] [3 4 5]]\n```", "```py\nuser> (def A (matrix [[0 1 2] [3 4 5]]))\n#'user/A\nuser> (pm A)\n[[0.000 1.000 2.000]\n [3.000 4.000 5.000]]\n```", "```py\n[clatrix \"0.3.0\"]\n```", "```py\n(ns my-namespace\n  (:use clojure.core.matrix)\n  (:require [clatrix.core :as cl]))\n```", "```py\nuser> (def A (cl/matrix [[0 1 2] [3 4 5]]))\n#'user/A\nuser> A\n A 2x3 matrix\n -------------\n 0.00e+00  1.00e+00  2.00e+00 \n 3.00e+00  4.00e+00  5.00e+00 \nuser> (pm A)\n[[0.000 1.000 2.000]\n [3.000 4.000 5.000]]\nnil\n```", "```py\nuser> (matrix :persistent-vector [[1 2] [2 1]])\n[[1 2] [2 1]]\nuser> (matrix :clatrix [[1 2] [2 1]])\n A 2x2 matrix\n -------------\n 1.00e+00  2.00e+00 \n 2.00e+00  1.00e+00\n```", "```py\nuser> (cl/matrix [0 1])\n A 2x1 matrix\n -------------\n 0.00e+00 \n 1.00e+00 \nuser> (cl/matrix [[0 1]])\n A 1x2 matrix\n -------------\n 0.00e+00  1.00e+00 \n```", "```py\nuser> (def A (cl/matrix [[0 1]]))\n#'user/A\nuser> (matrix? A)\ntrue\nuser> (cl/clatrix? A)\ntrue\nuser> (def B (matrix [[0 1]]))\n#'user/B\nuser> (matrix? B)\ntrue\nuser> (cl/clatrix? B)\nfalse\n```", "```py\nuser> (count (cl/matrix [0 1 2]))\n3\nuser> (row-count (cl/matrix [0 1 2]))\n3\nuser> (column-count (cl/matrix [0 1 2]))\n1\n```", "```py\nuser> (def A (cl/matrix [[0 1 2] [3 4 5]]))\n#'user/A\nuser> (cl/get A 1 1)\n4.0\nuser> (cl/get A 3)\n4.0\n```", "```py\nuser> (pm A)\n[[0.000 1.0002.000]\n [3.000 4.0005.000]]\nnil\nuser> (cl/set A 1 2 0)\n#<DoubleMatrix [0.000000, 1.000000, â€¦ , 0.000000]>\nuser> (pm A)\n[[0.000 1.000 2.000]\n [3.000 4.000 0.000]]\nnil\n```", "```py\nuser> (cl/map-indexed \n      (fn [i j m] (* m 2)) A)\n A 2x3 matrix\n -------------\n 0.00e+00  2.00e+00  4.00e+00 \n 6.00e+00  8.00e+00  1.00e+01 \nuser> (pm (cl/map-indexed (fn [i j m] i) A))\n[[0.000 0.000 0.000]\n [1.000 1.000 1.000]]\nnil\nuser> (pm (cl/map-indexed (fn [i j m] j) A))\n[[0.000 1.000 2.000]\n [0.000 1.000 2.000]]\nnil\n```", "```py\n(defn square-mat\n  \"Creates a square matrix of size n x n \n  whose elements are all e\"\n  [n e]\n  (let [repeater #(repeat n %)]\n    (matrix (-> e repeater repeater))))\n```", "```py\n(defn square-mat\n  \"Creates a square matrix of size n x n whose \n  elements are all e. Accepts an option argument \n  for the matrix implementation.\"\n  [n e & {:keys [implementation] \n          :or {implementation :persistent-vector}}]\n  (let [repeater #(repeat n %)]\n    (matrix implementation (-> e repeater repeater))))\n```", "```py\nuser> (square-mat 2 1)\n[[1 1] [1 1]]\nuser> (square-mat 2 1 :implementation :clatrix)\n A 2x2 matrix\n -------------\n 1.00e+00  1.00e+00\n 1.00e+00  1.00e+00\n```", "```py\n(defn id-mat\n  \"Creates an identity matrix of n x n size\"\n  [n]\n  (let [init (square-mat :clatrix n 0)\n       identity-f (fn [i j n]\n                     (if (= i j) 1 n))]\n    (cl/map-indexed identity-f init)))\n```", "```py\nuser> (id-mat 5)\n A 5x5 matrix\n -------------\n 1.00e+00  0.00e+00 0.00e+00 0.00e+00 0.00e+00\n 0.00e+00  1.00e+00 0.00e+00 0.00e+00 0.00e+00\n 0.00e+00  0.00e+00 1.00e+00 0.00e+00 0.00e+00\n 0.00e+00  0.00e+00 0.00e+00 1.00e+00 0.00e+00 \n 0.00e+00  0.00e+00 0.00e+00 0.00e+00 1.00e+00 \nuser> (pm (identity-matrix 5))\n[[1.000 0.000 0.000 0.000 0.000]\n [0.000 1.000 0.000 0.000 0.000]\n [0.000 0.000 1.000 0.000 0.000]\n [0.000 0.000 0.000 1.000 0.000]\n [0.000 0.000 0.000 0.000 1.000]]\nnil\n```", "```py\n(defn rand-square-mat \n  \"Generates a random matrix of size n x n\"\n  [n]\n  ;; this won't work\n  (matrix (repeat n (repeat n (rand-int 100))))) \n```", "```py\nuser> (rand-square-mat 4)\n[[94 94] [94 94] [94 94] [94 94]]\n```", "```py\n(defn rand-square-clmat\n  \"Generates a random clatrix matrix of size n x n\"\n  [n]\n  (cl/map rand-int (square-mat :clatrix n 100)))\n\n(defn rand-square-mat\n  \"Generates a random matrix of size n x n\"\n  [n]\n  (matrix\n   (repeatedly n #(map rand-int (repeat n 100)))))\n```", "```py\nuser> (pm (rand-square-mat 4))\n[[97.000 35.000 69.000 69.000]\n [50.000 93.000 26.000  4.000]\n [27.000 14.000 69.000 30.000]\n [68.000 73.000 0.0007 3.000]]\nnil\nuser> (rand-square-clmat 4)\n A 4x4 matrix\n -------------\n 5.30e+01  5.00e+00  3.00e+00  6.40e+01 \n 6.20e+01  1.10e+01  4.10e+01  4.20e+01 \n 4.30e+01  1.00e+00  3.80e+01  4.70e+01 \n 3.00e+00  8.10e+01  1.00e+01  2.00e+01\n```", "```py\nuser> (cl/rnorm 10 25 10 10)\n A 10x10 matrix\n ---------------\n-1.25e-01  5.02e+01 -5.20e+01  .  5.07e+01  2.92e+01  2.18e+01 \n-2.13e+01  3.13e+01 -2.05e+01  . -8.84e+00  2.58e+01  8.61e+00 \n 4.32e+01  3.35e+00  2.78e+01  . -8.48e+00  4.18e+01  3.94e+01 \n ... \n 1.43e+01 -6.74e+00  2.62e+01  . -2.06e+01  8.14e+00 -2.69e+01 \nuser> (cl/rnorm 5)\n A 5x1 matrix\n -------------\n 1.18e+00 \n 3.46e-01 \n-1.32e-01 \n 3.13e-01 \n-8.26e-02 \nuser> (cl/rnorm 3 4)\n A 3x4 matrix\n -------------\n-4.61e-01 -1.81e+00 -6.68e-01  7.46e-01 \n 1.87e+00 -7.76e-01 -1.33e+00  5.85e-01 \n 1.06e+00 -3.54e-01  3.73e-01 -2.72e-02 \n```", "```py\n(defn id-computed-mat\n  \"Creates an identity matrix of size n x n \n  using compute-matrix\"\n  [n]\n  (compute-matrix [n n] #(if (= %1 %2) 1 0)))\n\n(defn rand-computed-mat\n  \"Creates an n x m matrix of random elements \n  using compute-matrix\"\n  [n m]\n  (compute-matrix [n m] \n   (fn [i j] (rand-int 100))))\n```", "```py\nuser> (+ (matrix [[0 1]]) (matrix [[0 1]]))\nClassCastException clojure.lang.PersistentVector cannot be cast to java.lang.Number  clojure.lang.Numbers.add (Numbers.java:126)\n```", "```py\n(ns my-namespace\n  (:use clojure.core.matrix)\n  (:require [clojure.core.matrix.operators :as M]))\n```", "```py\n(ns my-namespace\n  (:use clojure.core.matrix)\n  (:require clojure.core.matrix.operators)\n  (:refer-clojure :exclude [+ - *])) \n```", "```py\nuser> (def A (matrix [[0 1 2] [3 4 5]]))\n#'user/A\nuser> (def B (matrix [[0 0 0] [0 0 0]]))\n#'user/B\nuser> (M/== B A)\nfalse\nuser> (def C (M/+ A B))\n#'user/C\nuser> C\n[[0 1 2] [3 4 5]]\nuser> (M/== C A)\ntrue\n```", "```py\n(defn mat-eq\n  \"Checks if two matrices are equal\"\n  [A B]\n  (and (= (count A) (count B))\n       (reduce #(and %1 %2) (map = A B))))\n```", "```py\n(defn mat-add\n  \"Add two matrices\"\n  [A B]\n  (mapv #(mapv + %1 %2) A B))\n```", "```py\n(defn mat-add\n  \"Add two or more matrices\"\n  ([A B]\n     (mapv #(mapv + %1 %2) A B))\n  ([A B & more]\n     (let [M (concat [A B] more)]\n       (reduce mat-add M))))\n```", "```py\nuser> (pm (M/* A B))\n[[140.000 200.000]\n [320.000 470.000]]\nnil\nuser> (pm (M/* A C))\nRuntimeException Mismatched vector sizes  clojure.core.matrix.impl.persistent-vector/... \nuser> (def N 10)\n#'user/N\nuser> (pm (M/* A N))\n[[10.000 20.000 30.000]\n [40.000 50.000 60.000]]\nnil\n```", "```py\n(defn time-mat-mul\n  \"Measures the time for multiplication of two matrices A and B\"\n  [A B]\n  (time (M/* A B)))\n\n(defn core-matrix-mul-time []\n  (let [A (rand-square-mat 100)\n        B (rand-square-mat 100)]\n    (time-mat-mul A B)))\n\n(defn clatrix-mul-time []\n  (let [A (rand-square-clmat 100)\n        B (rand-square-clmat 100)]\n    (time-mat-mul A B)))\n```", "```py\nuser> (pm (scale A 10))\n[[10.000 20.000 30.000]\n [40.000 50.000 60.000]]\nnil\nuser> (M/== (scale A 10) (M/* A 10))\ntrue\n```", "```py\nuser> (def A (matrix [[1 2 3] [4 5 6]]))\n#'user/A\nuser> (pm (transpose A))\n[[1.000 4.000]\n [2.000 5.000]\n [3.000 6.000]]\nnil\n```", "```py\nuser> (def A (cl/matrix [[2 0] [0 2]]))\n#'user/A\nuser> (M/* (inverse A) A)\n A 2x2 matrix\n -------------\n 1.00e+00  0.00e+00 \n 0.00e+00  1.00e+00\n```", "```py\nuser> (def A (cl/matrix [[1 2] [3 4]]))\n#'user/A\nuser> (inverse A)\n A 2x2 matrix\n -------------\n-2.00e+00  1.00e+00 \n 1.50e+00 -5.00e-01\n```", "```py\nuser> (def A (cl/matrix [[-2 2 3] [-1 1 3] [2 0 -1]]))\n#'user/A\nuser> (det A)\n6.0\n```", "```py\nuser> (def A (cl/matrix [[1 2 3] [4 5 6]]))\n#'user/A\nuser> (inverse A)\nExceptionInfo throw+: {:exception \"Cannot invert a non-square matrix.\"}  clatrix.core/i (core.clj:1033)\nuser> (def A (cl/matrix [[2 0] [2 0]]))\n#'user/A\nuser> (M/* (inverse A) A)\nLapackException LAPACK DGESV: Linear equation cannot be solved because the matrix was singular.  org.jblas.SimpleBlas.gesv (SimpleBlas.java:274)\n```", "```py\n(defn lmatrix [n]\n  (compute-matrix :clatrix [n (+ n 2)]\n                  (fn [i j] ({0 -1, 1 2, 2 -1} (- j i) 0))))\n```", "```py\nuser> (pm (lmatrix 4))\n[[-1.000 2.000 -1.000  0.000  0.000  0.000]\n[ 0.000 -1.000  2.000 -1.000  0.000  0.000]\n[ 0.000  0.000 -1.000  2.000 -1.000  0.000]\n[ 0.000  0.000  0.000 -1.000  2.000 -1.000]]\nnil\n```", "```py\n(defn problem\n  \"Return a map of the problem setup for a\n  given matrix size, number of observed values \n  and regularization parameter\"\n  [n n-observed lambda]\n  (let [i (shuffle (range n))]\n    {:L (M/* (lmatrix n) lambda)\n     :observed (take n-observed i)\n     :hidden (drop n-observed i)\n     :observed-values (matrix :clatrix\n                              (repeatedly n-observed rand))}))\n```", "```py\n(defn solve\n  \"Return a map containing the approximated value \ny of each hidden point x\"\n  [{:keys [L observed hidden observed-values] :as problem}]\n  (let [nc  (column-count L)\n        nr  (row-count L)\n        L1  (cl/get L (range nr) hidden)\n        L2  (cl/get L (range nr) observed)\n        l11 (M/* (transpose L1) L1)\n        l12 (M/* (transpose L1) L2)]\n    (assoc problem :hidden-values\n      (M/* -1 (inverse l11) l12 observed-values))))\n```", "```py\n[incanter \"1.5.4\"]\n```", "```py\n(ns my-namespace\n  (:use [incanter.charts :only [xy-plot add-points]]\n        [incanter.core   :only [view]])\n  (:require [clojure.core.matrix.operators :as M]\n            [clatrix.core :as cl]))\n```", "```py\n(defn plot-points\n  \"Plots sample points of a solution s\"\n  [s]\n  (let [X (concat (:hidden s) (:observed s))\n        Y (concat (:hidden-values s) (:observed-values s))]\n    (view\n     (add-points\n      (xy-plot X Y) (:observed s) (:observed-values s)))))\n```", "```py\n(defn plot-rand-sample []\n  (plot-points (solve (problem 150 10 30))))\n```"]