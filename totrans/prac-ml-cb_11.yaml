- en: Chapter 11. Deep Learning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Recurrent neural networks - predicting periodic signals
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of the machine learning algorithms work well due to predefined representations
    and input features. Machine learning algorithms optimize weights to best make
    a final prediction, while representation learning attempt to automatically learn
    good features or representations. Deep learning algorithms attempt to learn at
    multiple levels of representation by increasing complexity. Deep architectures
    are composed of multiple levels of non-linear operations, such as neural nets
    with many hidden layers. The main goal of deep learning techniques is to learn
    feature hierarchies. Deep learning techniques can be divided into three major
    classes; deep networks for unsupervised or generative learning, deep networks
    for supervised learning and hybrid deep networks
  prefs: []
  type: TYPE_NORMAL
- en: Recurrent neural networks - predicting periodic signals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Oscillators are circuits that produce specific, periodic waveforms such as square,
    triangular, sawtooth, and sinusoidal. In order to generate output, oscillators
    generally use some form of active device-lamp, which is surrounded by resistors,
    capacitors, and inductors. Two main classes of oscillators are relaxation and
    sinusoidal. Triangular, sawtooth and other non-sinusoidal waveforms are generated
    using relaxation oscillators, while sinusoidal oscillators consist of amplifiers
    with external components to generate oscillation. Normally, no harmonics are present
    in pure sine waves and they consist of a single frequency.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The task is to predict a cosine from a noisy sine wave. 5Hz frequency waves
    are used for the sine wave with some normally distributed noise and a smooth cosine
    wave. The dataset created is a set of 10 sequences, each of which consists of
    40 observations.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following packages need to be loaded as the first step to be carried out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Setting the initial seed as a random number for the purpose of reproducibility:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Initializing the required frequency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Creating the vector required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Generating sequences: The `seq()` function generates regular sequences. `0.005`
    is the starting value while `2` is the ending value. `by=0.005` determines the
    incremental sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Generating `sin` and `cos` values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Generating samples of time series: The `matrix()` function creates a matrix
    from `x` and `y` values. `nrow = 40` indicates the number of rows required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Plotting the noisy wave:. The `plot()` function is a generic function for the
    plotting of R objects. The `as.vector(X)` data frame is passed as a function value.
    `type=''l''` signifies lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_11_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_11_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Standardizing the values of `X`. The range of values lies between 0 and 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the values of `X`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_11_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Standardizing the values of `Y`. The range of values lies between 0 and 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the values of `X`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_11_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Transposing the values of `X` and `Y`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Creating training and testing sets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Training the recurrent neural network. `Y = Y[train,]` signifies an array of
    output values. `X = X[train,]` signifies an array of input values. `learningrate
    = 0.05` means the rate to be applied for weight iteration. `hidden_dim = 16` is
    the dimension of hidden layers. `numepochs = 1500` is the number of times the
    whole dataset undergoes training.
  prefs: []
  type: TYPE_NORMAL
- en: 'This phase will take time. The time taken depends on the learning rate, the
    number of dimensions, and the number of times the whole dataset undergoes training:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_11_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Predicting the output of the recurrent neural network:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Plotting the **Actual values vs the Predicted values**. The output constitutes
    the training set and the testing set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_11_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_11_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Plotting the **Actual values vs the Predicted values**. The output constitutes
    the testing set only:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_11_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_11_009.jpg)'
  prefs: []
  type: TYPE_IMG
