<html><head></head><body>
<div id="_idContainer212">
<h1 class="chapter-number" id="_idParaDest-273"><a id="_idTextAnchor274"/><span class="koboSpan" id="kobo.1.1">13</span></h1>
<h1 id="_idParaDest-274"><a id="_idTextAnchor275"/><span class="koboSpan" id="kobo.2.1">Determining Position Using Monte Carlo Localization</span></h1>
<p><span class="koboSpan" id="kobo.3.1">We now have several interesting sensors on our robot. </span><span class="koboSpan" id="kobo.3.2">However, we have yet to combine them to understand the </span><a id="_idIndexMarker723"/><span class="koboSpan" id="kobo.4.1">position of our robot. </span><span class="koboSpan" id="kobo.4.2">The </span><strong class="bold"><span class="koboSpan" id="kobo.5.1">Monte Carlo simulation</span></strong><span class="koboSpan" id="kobo.6.1"> is a method that uses multiple sensors and a model of a robot’s world to estimate its location and heading in </span><span class="No-Break"><span class="koboSpan" id="kobo.7.1">that world.</span></span></p>
<p><span class="koboSpan" id="kobo.8.1">You will learn how to make a test arena for a robot, followed by how to model this arena in code, and how to send this data over Bluetooth to view on a computer. </span><span class="koboSpan" id="kobo.8.2">You will practice statistical methods for the robot to start guessing its location. </span><span class="koboSpan" id="kobo.8.3">You will see how to enrich encoder data and move the guesses, and then integrate this with distance sensor data to refine the guesses, using a method that is effective in the face of noisy sensor data and can cope with minor inaccuracies. </span><span class="koboSpan" id="kobo.8.4">This will come together in a Monte Carlo guess and </span><span class="No-Break"><span class="koboSpan" id="kobo.9.1">check loop.</span></span></p>
<p><span class="koboSpan" id="kobo.10.1">In this chapter, we will cover the following </span><span class="No-Break"><span class="koboSpan" id="kobo.11.1">main topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.12.1">Creating a training area for </span><span class="No-Break"><span class="koboSpan" id="kobo.13.1">our robot</span></span></li>
<li><span class="koboSpan" id="kobo.14.1">Modeling </span><span class="No-Break"><span class="koboSpan" id="kobo.15.1">a space</span></span></li>
<li><span class="koboSpan" id="kobo.16.1">Using sensors to track a </span><span class="No-Break"><span class="koboSpan" id="kobo.17.1">relative pose</span></span></li>
<li><span class="koboSpan" id="kobo.18.1">Monte </span><span class="No-Break"><span class="koboSpan" id="kobo.19.1">Carlo localization</span></span></li>
</ul>
<h1 id="_idParaDest-275"><a id="_idTextAnchor276"/><span class="koboSpan" id="kobo.20.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.21.1">For this chapter, you will require </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.23.1">The robot and code from </span><a href="B18001_12.xhtml#_idTextAnchor252"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.24.1">Chapter 12</span></em></span></a><span class="koboSpan" id="kobo.25.1">, </span><em class="italic"><span class="koboSpan" id="kobo.26.1">Detecting Orientation with an IMU on Raspberry </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.27.1">Pi Pico</span></em></span></li>
<li><span class="koboSpan" id="kobo.28.1">A PC or laptop with Bluetooth LE </span></li>
<li><span class="koboSpan" id="kobo.29.1">Python 3.7 with the Python </span><strong class="source-inline"><span class="koboSpan" id="kobo.30.1">matplotlib</span></strong><span class="koboSpan" id="kobo.31.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.32.1">bleak</span></strong><span class="koboSpan" id="kobo.33.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.34.1">NumPy</span></strong><span class="koboSpan" id="kobo.35.1"> libraries installed </span></li>
<li><span class="koboSpan" id="kobo.36.1">10 x 10-mm A1 sheet </span><span class="No-Break"><span class="koboSpan" id="kobo.37.1">foam boards</span></span></li>
<li><span class="koboSpan" id="kobo.38.1">Duct or </span><span class="No-Break"><span class="koboSpan" id="kobo.39.1">gaffer tape</span></span></li>
<li><span class="koboSpan" id="kobo.40.1">A </span><span class="No-Break"><span class="koboSpan" id="kobo.41.1">tape measure</span></span></li>
<li><span class="koboSpan" id="kobo.42.1">A metal ruler, set square, </span><span class="No-Break"><span class="koboSpan" id="kobo.43.1">and pencil</span></span></li>
<li><span class="koboSpan" id="kobo.44.1">A sharp </span><span class="No-Break"><span class="koboSpan" id="kobo.45.1">craft knife</span></span></li>
<li><span class="koboSpan" id="kobo.46.1">A floor space of 1.5 </span><span class="No-Break"><span class="koboSpan" id="kobo.47.1">sq meters</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.48.1">You can find the code for this chapter </span><span class="No-Break"><span class="koboSpan" id="kobo.49.1">at </span></span><a href="https://github.com/PacktPublishing/Robotics-at-Home-with-Raspberry-Pi-Pico/tree/main/ch-13"><span class="No-Break"><span class="koboSpan" id="kobo.50.1">https://github.com/PacktPublishing/Robotics-at-Home-with-Raspberry-Pi-Pico/tree/main/ch-13</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.51.1">.</span></span></p>
<h1 id="_idParaDest-276"><a id="_idTextAnchor277"/><span class="koboSpan" id="kobo.52.1">Creating a training area for our robot</span></h1>
<p><span class="koboSpan" id="kobo.53.1">We will be estimating a robot’s location in a space. </span><span class="koboSpan" id="kobo.53.2">The robot needs a known space to work in, so we </span><a id="_idIndexMarker724"/><span class="koboSpan" id="kobo.54.1">will build a simple world for it to operate in. </span><span class="koboSpan" id="kobo.54.2">This training area, or arena, is loosely based on those used in Pi Wars (see </span><a href="https://piwars.org/2022-competition/general-rules/"><span class="koboSpan" id="kobo.55.1">https://piwars.org/2022-competition/general-rules/</span></a><span class="koboSpan" id="kobo.56.1"> under </span><em class="italic"><span class="koboSpan" id="kobo.57.1">Arena construction rules</span></em><span class="koboSpan" id="kobo.58.1">), a British robotics competition, where this algorithm could be used for a robot to </span><span class="No-Break"><span class="koboSpan" id="kobo.59.1">compete autonomously.</span></span></p>
<p><span class="koboSpan" id="kobo.60.1">Let’s take a closer look at </span><span class="No-Break"><span class="koboSpan" id="kobo.61.1">the arena.</span></span></p>
<h2 id="_idParaDest-277"><a id="_idTextAnchor278"/><span class="koboSpan" id="kobo.62.1">What we will make</span></h2>
<p><span class="koboSpan" id="kobo.63.1">The following diagram shows the arena we </span><span class="No-Break"><span class="koboSpan" id="kobo.64.1">will make:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer196">
<span class="koboSpan" id="kobo.65.1"><img alt="Figure 13.1 – A robot test arena " src="image/Figure_13.01_B18001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.66.1">Figure 13.1 – A robot test arena</span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.67.1">Figure 13</span></em></span><em class="italic"><span class="koboSpan" id="kobo.68.1">.1</span></em><span class="koboSpan" id="kobo.69.1"> shows a top-view drawing of an arena, complete with dimensions. </span><span class="koboSpan" id="kobo.69.2">The arena is mostly square to keep it simple to make and model. </span><span class="koboSpan" id="kobo.69.3">To help the Monte Carlo simulation work, there </span><a id="_idIndexMarker725"/><span class="koboSpan" id="kobo.70.1">must be a cutout on one side to prevent rotational symmetry – that is, you can’t rotate the arena and have it appear identical from </span><span class="No-Break"><span class="koboSpan" id="kobo.71.1">multiple angles.</span></span></p>
<p><span class="koboSpan" id="kobo.72.1">The arena should be large enough for the robot to move freely inside of it, without being excessively large, making 1,500 mm a good compromise. </span><span class="koboSpan" id="kobo.72.2">The arena walls should be tall enough that the robot’s distance sensors cannot miss them. </span><span class="koboSpan" id="kobo.72.3">A reasonable wall height would be 200 mm. </span><span class="koboSpan" id="kobo.72.4">We will work with </span><em class="italic"><span class="koboSpan" id="kobo.73.1">mm</span></em><span class="koboSpan" id="kobo.74.1"> throughout this chapter to keep things consistent. </span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.75.1">Arena size versus robot speed</span></p>
<p class="callout"><span class="koboSpan" id="kobo.76.1">Beware that you may want a larger arena for a faster robot, and that a smaller arena will give the robot less time to detect </span><span class="No-Break"><span class="koboSpan" id="kobo.77.1">its features.</span></span></p>
<p class="callout"><span class="koboSpan" id="kobo.78.1">The arena floor surface is important; if the robot’s wheels are slipping, then the calculations will suffer </span><span class="No-Break"><span class="koboSpan" id="kobo.79.1">in accuracy.</span></span></p>
<p><span class="koboSpan" id="kobo.80.1">Next, we can </span><a id="_idIndexMarker726"/><span class="koboSpan" id="kobo.81.1">see how we’ll </span><span class="No-Break"><span class="koboSpan" id="kobo.82.1">build this.</span></span></p>
<h2 id="_idParaDest-278"><a id="_idTextAnchor279"/><span class="koboSpan" id="kobo.83.1">How we will make the arena</span></h2>
<p><span class="koboSpan" id="kobo.84.1">We’ll use </span><a id="_idIndexMarker727"/><span class="koboSpan" id="kobo.85.1">foam board to build the arena, as it is lightweight and easy to cut; A1 boards are readily available, and panels can be cut </span><span class="No-Break"><span class="koboSpan" id="kobo.86.1">from these.</span></span></p>
<p><span class="koboSpan" id="kobo.87.1">The following figure shows how we can make </span><span class="No-Break"><span class="koboSpan" id="kobo.88.1">the arena:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer197">
<span class="koboSpan" id="kobo.89.1"><img alt="Figure 13.2 – Making an arena " src="image/Figure_13.02_B18001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.90.1">Figure 13.2 – Making an arena</span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.91.1">Figure 13</span></em></span><em class="italic"><span class="koboSpan" id="kobo.92.1">.2</span></em><span class="koboSpan" id="kobo.93.1"> shows a 3D view of the arena. </span><span class="koboSpan" id="kobo.93.2">The letters indicate different parts. </span><span class="koboSpan" id="kobo.93.3">The Dumont Cybernetics team inspired this style. </span><span class="koboSpan" id="kobo.93.4">We can make the arena in sections, slotting together corner joints, as shown between panels </span><em class="italic"><span class="koboSpan" id="kobo.94.1">D</span></em><span class="koboSpan" id="kobo.95.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.96.1">B</span></em><span class="koboSpan" id="kobo.97.1">, or use tape (such as duct tape) to make hinging sections, such as those between panels </span><em class="italic"><span class="koboSpan" id="kobo.98.1">A</span></em><span class="koboSpan" id="kobo.99.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.100.1">B</span></em><span class="koboSpan" id="kobo.101.1">. </span><span class="koboSpan" id="kobo.101.2">This arena is 1,500 mm, so it can be disassembled and folded small when not in use. </span></p>
<p><span class="koboSpan" id="kobo.102.1">The following diagram shows the parts we will need to </span><span class="No-Break"><span class="koboSpan" id="kobo.103.1">make this:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer198">
<span class="koboSpan" id="kobo.104.1"><img alt="Figure 13.3 – A drawing of the parts to make the arena " src="image/Figure_13.03_B18001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.105.1">Figure 13.3 – A drawing of the parts to make the arena</span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.106.1">Figure 13</span></em></span><em class="italic"><span class="koboSpan" id="kobo.107.1">.3</span></em><span class="koboSpan" id="kobo.108.1"> shows the parts to cut to make the arena. </span><span class="koboSpan" id="kobo.108.2">Each part has a letter, the number of pieces you’ll </span><a id="_idIndexMarker728"/><span class="koboSpan" id="kobo.109.1">need to make, and the measurements to cut the part. </span><span class="koboSpan" id="kobo.109.2">The slot profiles are all the same as panel </span><strong class="bold"><span class="koboSpan" id="kobo.110.1">A</span></strong><span class="koboSpan" id="kobo.111.1">, along with the </span><span class="No-Break"><span class="koboSpan" id="kobo.112.1">wall heights.</span></span></p>
<p><span class="koboSpan" id="kobo.113.1">Four A panels can be cut from a board with some material left over. </span><span class="koboSpan" id="kobo.113.2">Let’s see how to </span><span class="No-Break"><span class="koboSpan" id="kobo.114.1">cut them.</span></span></p>
<h2 id="_idParaDest-279"><a id="_idTextAnchor280"/><span class="koboSpan" id="kobo.115.1">Tips for cutting</span></h2>
<p><span class="koboSpan" id="kobo.116.1">You can cut </span><a id="_idIndexMarker729"/><span class="koboSpan" id="kobo.117.1">the foam board in a similar way to the plastics you cut in </span><a href="B18001_04.xhtml#_idTextAnchor080"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.118.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.119.1">,</span><em class="italic"><span class="koboSpan" id="kobo.120.1"> Building a Robot around Pico</span></em><span class="koboSpan" id="kobo.121.1">. </span><span class="koboSpan" id="kobo.121.2">Use the tape measure, large ruler, and set square to mark where you will cut in pencil. </span><span class="koboSpan" id="kobo.121.3">Ensure the surface you are using to cut is at a comfortable height so that the long, repeated cutting does not make your </span><span class="No-Break"><span class="koboSpan" id="kobo.122.1">back sore.</span></span></p>
<p><span class="koboSpan" id="kobo.123.1">Then, following a straight metal edge, draw a sharp knife along the cut multiple times. </span><span class="koboSpan" id="kobo.123.2">For the first cut, aim only to score the top plastic layer, and then keep making cuts until you are through. </span><span class="koboSpan" id="kobo.123.3">Take care to cut the same area – this is a matter of letting later cuts follow the earlier cuts by holding the blade lightly </span><span class="No-Break"><span class="koboSpan" id="kobo.124.1">over them.</span></span></p>
<p><span class="koboSpan" id="kobo.125.1">I suggest cutting wall height strips first, before marking slots and wall lengths </span><span class="No-Break"><span class="koboSpan" id="kobo.126.1">on them.</span></span></p>
<p><span class="koboSpan" id="kobo.127.1">These sheets often come sandwiched with throw-away foam padding; this will help as a cutting surface so that you do not damage a table or </span><span class="No-Break"><span class="koboSpan" id="kobo.128.1">floor underneath.</span></span></p>
<p><span class="koboSpan" id="kobo.129.1">If there is tearing, either you are applying too much pressure or need to change your blade for a sharp, fresh one. </span></p>
<p><span class="koboSpan" id="kobo.130.1">Take care </span><a id="_idIndexMarker730"/><span class="koboSpan" id="kobo.131.1">cutting the slots. </span><span class="koboSpan" id="kobo.131.2">The wall heights do not need to be super precise; within a few mm is good enough. </span><span class="koboSpan" id="kobo.131.3">The real world is often not as precise and clear as a simulation, and this algorithm will be able to cope </span><span class="No-Break"><span class="koboSpan" id="kobo.132.1">with this.</span></span></p>
<p><span class="koboSpan" id="kobo.133.1">Once you have cut the parts, assemble the corners of the arena, and then make tape hinges on the inside joins (not the slots). </span><span class="koboSpan" id="kobo.133.2">When you disassemble the first time, fold the parts along these hinges, and then put tape on the outside of this joint. </span><span class="koboSpan" id="kobo.133.3">With gaffer tape or duct tape, this should be </span><span class="No-Break"><span class="koboSpan" id="kobo.134.1">sturdy enough.</span></span></p>
<p><span class="koboSpan" id="kobo.135.1">Now that we have a real space, we’ll need to model this so that the robot can </span><span class="No-Break"><span class="koboSpan" id="kobo.136.1">use it.</span></span></p>
<h1 id="_idParaDest-280"><a id="_idTextAnchor281"/><span class="koboSpan" id="kobo.137.1">Modeling the space</span></h1>
<p><span class="koboSpan" id="kobo.138.1">The aim of a Monte Carlo system is to model or simulate a space and a robot’s location. </span><span class="koboSpan" id="kobo.138.2">In this section, we will </span><a id="_idIndexMarker731"/><span class="koboSpan" id="kobo.139.1">learn how code for the robot will represent this space. </span><span class="koboSpan" id="kobo.139.2">We will also look at how a computer can be used to visualize our robot’s guesses. </span><span class="koboSpan" id="kobo.139.3">Monte Carlo-based behavior code checks sensor readings frequently against the model of the space, so we should represent the space on the robot to </span><span class="No-Break"><span class="koboSpan" id="kobo.140.1">optimize this.</span></span></p>
<p><span class="koboSpan" id="kobo.141.1">The role of the computer and the robot in this are shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.142.1">following diagram:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer199">
<span class="koboSpan" id="kobo.143.1"><img alt="Figure 13.4 – Visualizing with the computer " src="image/Figure_13.04_B18001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.144.1">Figure 13.4 – Visualizing with the computer</span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.145.1">Figure 13</span></em></span><em class="italic"><span class="koboSpan" id="kobo.146.1">.4</span></em><span class="koboSpan" id="kobo.147.1"> shows an overview of this system’s display and control architecture. </span><span class="koboSpan" id="kobo.147.2">The behavior code runs on the robot. </span><span class="koboSpan" id="kobo.147.3">The computer displays the state of the robot code, along with start and stop controls. </span><span class="koboSpan" id="kobo.147.4">The arena and state of the system all belong to </span><span class="No-Break"><span class="koboSpan" id="kobo.148.1">the robot.</span></span></p>
<p><span class="koboSpan" id="kobo.149.1">Let’s look at how to represent the arena on </span><span class="No-Break"><span class="koboSpan" id="kobo.150.1">the robot.</span></span></p>
<h2 id="_idParaDest-281"><a id="_idTextAnchor282"/><span class="koboSpan" id="kobo.151.1">Representing the arena and robot position as numbers</span></h2>
<p><span class="koboSpan" id="kobo.152.1">For a model </span><a id="_idIndexMarker732"/><span class="koboSpan" id="kobo.153.1">like this, the boundaries of the arena are important. </span><span class="koboSpan" id="kobo.153.2">We can start by taking 2D </span><em class="italic"><span class="koboSpan" id="kobo.154.1">X</span></em><span class="koboSpan" id="kobo.155.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.156.1">Y</span></em><span class="koboSpan" id="kobo.157.1"> coordinates of the corners. </span></p>
<p><span class="koboSpan" id="kobo.158.1">Look at the following representation of </span><span class="No-Break"><span class="koboSpan" id="kobo.159.1">the arena:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer200">
<span class="koboSpan" id="kobo.160.1"><img alt="Figure 13.5 – The arena and poses as coordinates " src="image/Figure_13.05_B18001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.161.1">Figure 13.5 – The arena and poses as coordinates</span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.162.1">Figure 13</span></em></span><em class="italic"><span class="koboSpan" id="kobo.163.1">.5</span></em><span class="koboSpan" id="kobo.164.1"> shows a simplified version of the arena. </span><span class="koboSpan" id="kobo.164.2">Coordinates describe each corner as numbers. </span><span class="koboSpan" id="kobo.164.3">We can directly use those in the code. </span><span class="koboSpan" id="kobo.164.4">These corners can be joined as line segments. </span><span class="koboSpan" id="kobo.164.5">A line segment is a set of coordinates for the start and end of the line segment. </span><span class="koboSpan" id="kobo.164.6">All the coordinates in the code will be </span><span class="No-Break"><span class="koboSpan" id="kobo.165.1">in mm.</span></span></p>
<p><span class="koboSpan" id="kobo.166.1">Our robot will have a </span><strong class="bold"><span class="koboSpan" id="kobo.167.1">pose</span></strong><span class="koboSpan" id="kobo.168.1"> somewhere within the arena. </span><span class="koboSpan" id="kobo.168.2">A pose describes the robot’s location in space – in this case, anywhere in the 2D space of the arena and facing any of 360 degrees. </span><span class="koboSpan" id="kobo.168.3">Imagine this like a map pin, with an arrow point showing </span><span class="No-Break"><span class="koboSpan" id="kobo.169.1">the heading.</span></span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.170.1">Figure 13</span></em></span><em class="italic"><span class="koboSpan" id="kobo.171.1">.5</span></em><span class="koboSpan" id="kobo.172.1"> also shows two robot poses, </span><em class="italic"><span class="koboSpan" id="kobo.173.1">A</span></em><span class="koboSpan" id="kobo.174.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.175.1">B</span></em><span class="koboSpan" id="kobo.176.1">. </span><span class="koboSpan" id="kobo.176.2">Each has an </span><em class="italic"><span class="koboSpan" id="kobo.177.1">X</span></em><span class="koboSpan" id="kobo.178.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.179.1">Y</span></em><span class="koboSpan" id="kobo.180.1"> coordinate in mm within the arena, and each has a heading theta (θ) in degrees. </span><span class="koboSpan" id="kobo.180.2">These three numbers will represent every robot pose in this 2D space. </span><span class="koboSpan" id="kobo.180.3">At the start of a simulation, the robot could be at any position and facing any heading within the arena </span><span class="No-Break"><span class="koboSpan" id="kobo.181.1">in degrees.</span></span></p>
<p><span class="koboSpan" id="kobo.182.1">Our arena </span><a id="_idIndexMarker733"/><span class="koboSpan" id="kobo.183.1">representation has </span><em class="italic"><span class="koboSpan" id="kobo.184.1">0, 0</span></em><span class="koboSpan" id="kobo.185.1"> for the bottom left. </span><span class="koboSpan" id="kobo.185.2">Heading </span><em class="italic"><span class="koboSpan" id="kobo.186.1">0</span></em><span class="koboSpan" id="kobo.187.1"> faces right, with positive theta angles going anticlockwise. </span><span class="koboSpan" id="kobo.187.2">For example, pose </span><em class="italic"><span class="koboSpan" id="kobo.188.1">A</span></em><span class="koboSpan" id="kobo.189.1"> has a heading of around 30 degrees anticlockwise from the right, and pose </span><em class="italic"><span class="koboSpan" id="kobo.190.1">B</span></em><span class="koboSpan" id="kobo.191.1"> has a heading of 300 degrees from the right. </span></p>
<p><span class="koboSpan" id="kobo.192.1">In this system, we will have many pose estimates, which behave like particles. </span><span class="koboSpan" id="kobo.192.2">The Monte Carlo simulation here </span><a id="_idIndexMarker734"/><span class="koboSpan" id="kobo.193.1">is also known as a </span><strong class="bold"><span class="koboSpan" id="kobo.194.1">particle filter</span></strong><span class="koboSpan" id="kobo.195.1">, due to how poses are manipulated and then filtered away based on </span><span class="No-Break"><span class="koboSpan" id="kobo.196.1">sensor data.</span></span></p>
<p><span class="koboSpan" id="kobo.197.1">Now, let’s develop code for the arena boundary </span><span class="No-Break"><span class="koboSpan" id="kobo.198.1">line segments.</span></span></p>
<h3><span class="koboSpan" id="kobo.199.1">Converting the representation into code</span></h3>
<p><span class="koboSpan" id="kobo.200.1">We’ll represent the arena as code and render it on the computer. </span><span class="koboSpan" id="kobo.200.2">Then, we’ll move the arena </span><a id="_idIndexMarker735"/><span class="koboSpan" id="kobo.201.1">representation over to the robot, with the computer fetching data </span><span class="No-Break"><span class="koboSpan" id="kobo.202.1">from it.</span></span></p>
<p><span class="koboSpan" id="kobo.203.1">After creating the </span><strong class="source-inline"><span class="koboSpan" id="kobo.204.1">arena.py</span></strong><span class="koboSpan" id="kobo.205.1"> file, we can add the arena points </span><span class="No-Break"><span class="koboSpan" id="kobo.206.1">to it:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.207.1">
width = 1500
height = 1500
cutout_width = 500
cutout_height = 500
boundary_lines = [
    [(0,0), (0, height)],
    [(0, height), (width, height)],
    [(width, height), (width, cutout_height)],
    [(width, cutout_height), (width - cutout_width, cutout_height)],
    [(width - cutout_width, cutout_height), (width - cutout_width, 0)],
    [(width - cutout_width, 0), (0, 0)],
]</span></pre>
<p><span class="koboSpan" id="kobo.208.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.209.1">boundary_lines</span></strong><span class="koboSpan" id="kobo.210.1"> variable represents a list of line segments, each of which is an array of start and end coordinates, read as </span><strong class="source-inline"><span class="koboSpan" id="kobo.211.1">[(start_x, start_y), (end_x, end_y)]</span></strong><span class="koboSpan" id="kobo.212.1">. </span><span class="koboSpan" id="kobo.212.2">We also store the arena </span><strong class="source-inline"><span class="koboSpan" id="kobo.213.1">width</span></strong><span class="koboSpan" id="kobo.214.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.215.1">height</span></strong><span class="koboSpan" id="kobo.216.1"> values here. </span><span class="koboSpan" id="kobo.216.2">If your arena is a different size, please update </span><span class="No-Break"><span class="koboSpan" id="kobo.217.1">these values.</span></span></p>
<p><span class="koboSpan" id="kobo.218.1">We can </span><a id="_idIndexMarker736"/><span class="koboSpan" id="kobo.219.1">display this using </span><strong class="source-inline"><span class="koboSpan" id="kobo.220.1">matplotlib</span></strong><span class="koboSpan" id="kobo.221.1">, a mathematical plotting library for Python. </span><span class="koboSpan" id="kobo.221.2">To do this, first install Python 3.7 (or later) on your computer, and in a terminal, use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.222.1">python3 -mpip install matplotlib numpy</span></strong><span class="koboSpan" id="kobo.223.1"> command to get the libraries. </span><span class="koboSpan" id="kobo.223.2">For Linux, you may need additional </span><strong class="source-inline"><span class="koboSpan" id="kobo.224.1">python3-tk</span></strong><span class="koboSpan" id="kobo.225.1"> packages in your </span><span class="No-Break"><span class="koboSpan" id="kobo.226.1">package manager.</span></span></p>
<p><span class="koboSpan" id="kobo.227.1">Create the </span><strong class="source-inline"><span class="koboSpan" id="kobo.228.1">display_arena.py</span></strong><span class="koboSpan" id="kobo.229.1"> file to draw the arena. </span><span class="koboSpan" id="kobo.229.2">This file starts by importing </span><strong class="source-inline"><span class="koboSpan" id="kobo.230.1">matplotlib</span></strong><span class="koboSpan" id="kobo.231.1">. </span><span class="koboSpan" id="kobo.231.2">The convention is to import </span><strong class="source-inline"><span class="koboSpan" id="kobo.232.1">pyplot</span></strong><span class="koboSpan" id="kobo.233.1">, a data-plotting module, </span><span class="No-Break"><span class="koboSpan" id="kobo.234.1">as </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.235.1">plt</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.236.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.237.1">
from matplotlib import pyplot as plt
import arena
for line in arena.boundary_lines:
    plt.plot([line[0][0], line[1][0]], [line[0][1], line[1][1]], color="black")
plt.show()</span></pre>
<p><span class="koboSpan" id="kobo.238.1">We will loop over the lines in the arena. </span><span class="koboSpan" id="kobo.238.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.239.1">plot</span></strong><span class="koboSpan" id="kobo.240.1"> method takes </span><em class="italic"><span class="koboSpan" id="kobo.241.1">X</span></em><span class="koboSpan" id="kobo.242.1"> coordinates for a line, followed by </span><em class="italic"><span class="koboSpan" id="kobo.243.1">Y</span></em><span class="koboSpan" id="kobo.244.1"> coordinates for it, and allows us to specify a line color. </span><span class="koboSpan" id="kobo.244.2">Run this with </span><strong class="source-inline"><span class="koboSpan" id="kobo.245.1">python3 display_arena.py</span></strong><span class="koboSpan" id="kobo.246.1">, which will draw the arena </span><span class="No-Break"><span class="koboSpan" id="kobo.247.1">for us:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer201">
<span class="koboSpan" id="kobo.248.1"><img alt="Figure 13.6 – A matplotlib drawing of the arena " src="image/Figure_13.06_B18001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.249.1">Figure 13.6 – A matplotlib drawing of the arena</span></p>
<p><span class="koboSpan" id="kobo.250.1">The preceding </span><a id="_idIndexMarker737"/><span class="koboSpan" id="kobo.251.1">diagram shows the arena drawn by the computer from our code. </span><span class="koboSpan" id="kobo.251.2">It has grid coordinates along the left and </span><span class="No-Break"><span class="koboSpan" id="kobo.252.1">the bottom.</span></span></p>
<p><span class="koboSpan" id="kobo.253.1">We can now look at moving this model data to the robot where it will </span><span class="No-Break"><span class="koboSpan" id="kobo.254.1">be used.</span></span></p>
<h2 id="_idParaDest-282"><a id="_idTextAnchor283"/><span class="koboSpan" id="kobo.255.1">Serving the arena from the robot</span></h2>
<p><span class="koboSpan" id="kobo.256.1">The robot should </span><a id="_idIndexMarker738"/><span class="koboSpan" id="kobo.257.1">be the source of truth for arena data, so let’s put the arena model there. </span><span class="koboSpan" id="kobo.257.2">Make a </span><strong class="source-inline"><span class="koboSpan" id="kobo.258.1">robot</span></strong><span class="koboSpan" id="kobo.259.1"> folder on your computer and move </span><strong class="source-inline"><span class="koboSpan" id="kobo.260.1">arena.py</span></strong><span class="koboSpan" id="kobo.261.1"> into it. </span><span class="koboSpan" id="kobo.261.2">We will be copying the contents of this </span><strong class="source-inline"><span class="koboSpan" id="kobo.262.1">robot</span></strong><span class="koboSpan" id="kobo.263.1"> folder to Raspberry Pi Pico. </span><span class="koboSpan" id="kobo.263.2">From the previous chapters, copy </span><strong class="source-inline"><span class="koboSpan" id="kobo.264.1">robot.py</span></strong><span class="koboSpan" id="kobo.265.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.266.1">pid_controller.py</span></strong><span class="koboSpan" id="kobo.267.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.268.1">pio_encoder.py</span></strong><span class="koboSpan" id="kobo.269.1"> into the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.270.1">robot</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.271.1"> folder.</span></span></p>
<p><span class="koboSpan" id="kobo.272.1">We can then add a little code to serve up our arena boundary lines from the robot. </span><span class="koboSpan" id="kobo.272.2">In </span><strong class="source-inline"><span class="koboSpan" id="kobo.273.1">robot/code.py</span></strong><span class="koboSpan" id="kobo.274.1">, start with imports </span><span class="No-Break"><span class="koboSpan" id="kobo.275.1">and helpers:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.276.1">
import asyncio
import json
import arena
import robot
def send_json(data):
    robot.uart.write((json.dumps(data)+"\n").encode())
def read_json():
    data = robot.uart.readline()
    decoded = data.decode()
    return json.loads(decoded)</span></pre>
<p><span class="koboSpan" id="kobo.277.1">On the robot, we can handle commands as we have been since </span><a href="B18001_10.xhtml#_idTextAnchor210"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.278.1">Chapter 10</span></em></span></a><span class="koboSpan" id="kobo.279.1">, </span><em class="italic"><span class="koboSpan" id="kobo.280.1">Using the PID Algorithm to Follow Walls</span></em><span class="koboSpan" id="kobo.281.1">; however, we </span><a id="_idIndexMarker739"/><span class="koboSpan" id="kobo.282.1">will use </span><strong class="bold"><span class="koboSpan" id="kobo.283.1">JavaScript Object Notation</span></strong><span class="koboSpan" id="kobo.284.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.285.1">JSON</span></strong><span class="koboSpan" id="kobo.286.1">), a convenient method to represent more </span><span class="No-Break"><span class="koboSpan" id="kobo.287.1">complex information.</span></span></p>
<p><span class="koboSpan" id="kobo.288.1">Any data we </span><a id="_idIndexMarker740"/><span class="koboSpan" id="kobo.289.1">send is converted into JSON, and then a </span><strong class="source-inline"><span class="koboSpan" id="kobo.290.1">"\n"</span></strong><span class="koboSpan" id="kobo.291.1"> newline is added to show that it’s a complete message. </span><span class="koboSpan" id="kobo.291.2">We then encode this. </span><span class="koboSpan" id="kobo.291.3">The data we receive is unpacked with </span><strong class="source-inline"><span class="koboSpan" id="kobo.292.1">json.loads</span></strong><span class="koboSpan" id="kobo.293.1">, which will result in data structures </span><span class="No-Break"><span class="koboSpan" id="kobo.294.1">of dictionaries.</span></span></p>
<p><span class="koboSpan" id="kobo.295.1">We can then add a handler to this that will send back the arena </span><span class="No-Break"><span class="koboSpan" id="kobo.296.1">when requested:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.297.1">
async def command_handler():
    print("Starting handler")
    while True:
        if robot.uart.in_waiting:
            request = read_json()
            print("Received: ", request)
            if request["command"] == "arena":
                send_json({
                    "arena": arena.boundary_lines,
                })
        await asyncio.sleep(0.1)
asyncio.run(command_handler())</span></pre>
<p><span class="koboSpan" id="kobo.298.1">This will loop and wait for the arena command. </span><span class="koboSpan" id="kobo.298.2">It prints out any JSON it receives for troubleshooting. </span><span class="koboSpan" id="kobo.298.3">It will use the JSON to send back the arena data. </span></p>
<p><span class="koboSpan" id="kobo.299.1">The robot </span><a id="_idIndexMarker741"/><span class="koboSpan" id="kobo.300.1">can be interacted with via the Bluefruit app in UART mode by sending </span><strong class="source-inline"><span class="koboSpan" id="kobo.301.1">{"command": "arena"}</span></strong><span class="koboSpan" id="kobo.302.1">. </span><span class="koboSpan" id="kobo.302.2">The robot will send the boundary lines back as lists. </span><span class="koboSpan" id="kobo.302.3">However, ideally, we want the computer to display this from the robot with </span><strong class="source-inline"><span class="koboSpan" id="kobo.303.1">matplotlib</span></strong><span class="koboSpan" id="kobo.304.1">. </span><span class="koboSpan" id="kobo.304.2">We’ll need to connect the computer to the </span><span class="No-Break"><span class="koboSpan" id="kobo.305.1">robot first.</span></span></p>
<h2 id="_idParaDest-283"><a id="_idTextAnchor284"/><span class="koboSpan" id="kobo.306.1">The Bleak library</span></h2>
<p><span class="koboSpan" id="kobo.307.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.308.1">Bleak</span></strong><span class="koboSpan" id="kobo.309.1"> Python library </span><a id="_idIndexMarker742"/><span class="koboSpan" id="kobo.310.1">allows Python on a computer to connect and </span><a id="_idIndexMarker743"/><span class="koboSpan" id="kobo.311.1">interact with Bluetooth LE devices. </span><span class="koboSpan" id="kobo.311.2">In a terminal, use </span><strong class="source-inline"><span class="koboSpan" id="kobo.312.1">python3 -mpip install bleak</span></strong><span class="koboSpan" id="kobo.313.1"> to install </span><a id="_idIndexMarker744"/><span class="koboSpan" id="kobo.314.1">this. </span><span class="koboSpan" id="kobo.314.2">Bleak is documented </span><span class="No-Break"><span class="koboSpan" id="kobo.315.1">at </span></span><a href="https://bleak.readthedocs.io/en/latest/"><span class="No-Break"><span class="koboSpan" id="kobo.316.1">https://bleak.readthedocs.io/en/latest/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.317.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.318.1">We will also need information about the Adafruit Bluefruit system. </span><span class="koboSpan" id="kobo.318.2">Bluetooth LE has device IDs, and IDs for services on Bluetooth. </span><span class="koboSpan" id="kobo.318.3">See </span><a href="https://learn.adafruit.com/introducing-adafruit-ble-bluetooth-low-energy-friend/uart-service"><span class="koboSpan" id="kobo.319.1">https://learn.adafruit.com/introducing-adafruit-ble-bluetooth-low-energy-friend/uart-service</span></a><span class="koboSpan" id="kobo.320.1"> for details. </span><span class="koboSpan" id="kobo.320.2">We will be using these in the following piece </span><span class="No-Break"><span class="koboSpan" id="kobo.321.1">of code.</span></span></p>
<p><span class="koboSpan" id="kobo.322.1">We’ll start with an example to list the devices, to check whether we can find the robot’s Bluetooth UART. </span><span class="koboSpan" id="kobo.322.2">Create the </span><strong class="source-inline"><span class="koboSpan" id="kobo.323.1">find_devices.py</span></strong><span class="koboSpan" id="kobo.324.1"> file and add </span><span class="No-Break"><span class="koboSpan" id="kobo.325.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.326.1">
import asyncio
import bleak
async def run():
    ble_uuid = "6E400001-B5A3-F393-E0A9-E50E24DCCA9E"
    ble_name = "Adafruit Bluefruit LE"
    devices = await bleak.BleakScanner.discover(service_uuids=[ble_uuid])
    print(f"Found {len(devices)} devices")
    print([device.name for device in devices])
    matching_devices = [device for device in devices if device.name==ble_name]
    if len(matching_devices) == 0:
        raise RuntimeError("Could not find robot")
    ble_device_info = matching_devices[0]
    print(f"Found robot {ble_device_info.name}...")
asyncio.run(run())</span></pre>
<p><span class="koboSpan" id="kobo.327.1">This code starts by importing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.328.1">asyncio</span></strong><span class="koboSpan" id="kobo.329.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.330.1">bleak</span></strong><span class="koboSpan" id="kobo.331.1"> libraries. </span><span class="koboSpan" id="kobo.331.2">The run function needs to be asynchronous so that it can await the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.332.1">bleak</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.333.1"> scanner.</span></span></p>
<p><span class="koboSpan" id="kobo.334.1">We define the ID and name of the Adafruit Bluefruit based on the Adafruit documentation, and then ask the </span><strong class="source-inline"><span class="koboSpan" id="kobo.335.1">bleak</span></strong><span class="koboSpan" id="kobo.336.1"> library to discover available devices with the Adafruit UART service. </span><span class="koboSpan" id="kobo.336.2">After waiting </span><a id="_idIndexMarker745"/><span class="koboSpan" id="kobo.337.1">for the result, the next few lines print these out. </span><span class="koboSpan" id="kobo.337.2">The function </span><a id="_idIndexMarker746"/><span class="koboSpan" id="kobo.338.1">then filters for the device with the matching name, checks that it found it, and prints </span><span class="No-Break"><span class="koboSpan" id="kobo.339.1">it successfully.</span></span></p>
<p><span class="koboSpan" id="kobo.340.1">Run this with </span><strong class="source-inline"><span class="koboSpan" id="kobo.341.1">python3 find_devices.py</span></strong><span class="koboSpan" id="kobo.342.1">. </span><span class="koboSpan" id="kobo.342.2">If the robot is off, you will see a </span><strong class="source-inline"><span class="koboSpan" id="kobo.343.1">Could not find robot</span></strong><span class="koboSpan" id="kobo.344.1"> error. </span><span class="koboSpan" id="kobo.344.2">However, running with the robot turned on should show the </span><span class="No-Break"><span class="koboSpan" id="kobo.345.1">following output:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.346.1">
Found 1 devices
['Adafruit Bluefruit LE']
Found robot Adafruit Bluefruit LE...</span></pre>
<p><span class="koboSpan" id="kobo.347.1">From time to time, </span><strong class="source-inline"><span class="koboSpan" id="kobo.348.1">bleak</span></strong><span class="koboSpan" id="kobo.349.1"> will have trouble finding the robot and display the preceding error. </span><span class="koboSpan" id="kobo.349.2">You will need to rerun the example to find the robot. </span><span class="koboSpan" id="kobo.349.3">We can now put this code into a library that we can use in the remaining experiments in </span><span class="No-Break"><span class="koboSpan" id="kobo.350.1">this chapter.</span></span></p>
<h2 id="_idParaDest-284"><a id="_idTextAnchor285"/><span class="koboSpan" id="kobo.351.1">Creating a Bluetooth LE wrapper library</span></h2>
<p><span class="koboSpan" id="kobo.352.1">We’ll call </span><a id="_idIndexMarker747"/><span class="koboSpan" id="kobo.353.1">the library </span><strong class="source-inline"><span class="koboSpan" id="kobo.354.1">robot_ble_connection.py</span></strong><span class="koboSpan" id="kobo.355.1">. </span><span class="koboSpan" id="kobo.355.2">We’ll </span><a id="_idIndexMarker748"/><span class="koboSpan" id="kobo.356.1">start </span><span class="No-Break"><span class="koboSpan" id="kobo.357.1">with imports:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.358.1">
import asyncio
import bleak</span></pre>
<p><span class="koboSpan" id="kobo.359.1">We’ll put our connection handling into </span><span class="No-Break"><span class="koboSpan" id="kobo.360.1">a class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.361.1">
class BleConnection:
    ble_uuid = "6E400001-B5A3-F393-E0A9-E50E24DCCA9E"
    rx_gatt = "6E400003-B5A3-F393-E0A9-E50E24DCCA9E"
    tx_gatt = "6E400002-B5A3-F393-E0A9-E50E24DCCA9E"
    ble_name = "Adafruit Bluefruit LE"</span></pre>
<p><span class="koboSpan" id="kobo.362.1">See </span><a href="https://learn.adafruit.com/introducing-adafruit-ble-bluetooth-low-energy-friend/gatt-service-details"><span class="koboSpan" id="kobo.363.1">https://learn.adafruit.com/introducing-adafruit-ble-bluetooth-low-energy-friend/gatt-service-details</span></a><span class="koboSpan" id="kobo.364.1"> for an explanation of </span><span class="No-Break"><span class="koboSpan" id="kobo.365.1">these variables.</span></span></p>
<p><span class="koboSpan" id="kobo.366.1">When we create the object to handle the connection, we will have two functions that the client code can provide, one for a connection being complete and one for data </span><span class="No-Break"><span class="koboSpan" id="kobo.367.1">being received:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.368.1">
    def __init__(self, receive_handler):
        self.ble_client = None
        self.receive_handler = receive_handler</span></pre>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.369.1">receive_handler</span></strong><span class="koboSpan" id="kobo.370.1"> is a function that can be called with a Python </span><strong class="source-inline"><span class="koboSpan" id="kobo.371.1">bytes</span></strong><span class="koboSpan" id="kobo.372.1"> object holding the </span><a id="_idIndexMarker749"/><span class="koboSpan" id="kobo.373.1">received data. </span><span class="koboSpan" id="kobo.373.2">We’ll adapt our receive handler </span><a id="_idIndexMarker750"/><span class="koboSpan" id="kobo.374.1">into one that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.375.1">bleak</span></strong><span class="koboSpan" id="kobo.376.1"> library can use to </span><span class="No-Break"><span class="koboSpan" id="kobo.377.1">receive data:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.378.1">
    def _uart_handler(self, _, data: bytes):
        self.receive_handler(data)</span></pre>
<p><span class="koboSpan" id="kobo.379.1">Now, we add a connect method. </span><span class="koboSpan" id="kobo.379.2">This starts the same as the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.380.1">find_devices</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.381.1"> example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.382.1">
    async def connect(self):
        print("Scanning for devices...")
        devices = await bleak.BleakScanner.discover(
            service_uuids=[self.ble_uuid]
        )
        matching_devices = [device for device in devices if device.name==self.ble_name]
        if len(matching_devices) == 0:
            raise RuntimeError("Could not find robot")
        ble_device_info = matching_devices[0]
        print(f"Found robot {ble_device_info.name}...")</span></pre>
<p><span class="koboSpan" id="kobo.383.1">However, we then need to connect to this device and handle the </span><span class="No-Break"><span class="koboSpan" id="kobo.384.1">received data:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.385.1">
        self.ble_client = bleak.BleakClient(ble_device_info.address)
        await self.ble_client.connect()
        print("Connected to {}".format(ble_device_info.name))
        self.notify_task = asyncio.create_task(
            self.ble_client.start_notify(self.rx_gatt, self._uart_handler)
        )</span></pre>
<p><span class="koboSpan" id="kobo.386.1">We create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.387.1">BleakClient</span></strong><span class="koboSpan" id="kobo.388.1"> object and then wait for a connection to the robot. </span><span class="koboSpan" id="kobo.388.2">After connection, it will </span><a id="_idIndexMarker751"/><span class="koboSpan" id="kobo.389.1">create a background task to </span><a id="_idIndexMarker752"/><span class="koboSpan" id="kobo.390.1">notify the handler when data arrives. </span><span class="koboSpan" id="kobo.390.2">This </span><strong class="source-inline"><span class="koboSpan" id="kobo.391.1">start_notify</span></strong><span class="koboSpan" id="kobo.392.1"> method uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.393.1">rx_gatt</span></strong><span class="koboSpan" id="kobo.394.1"> to receive UART data from this Adafruit </span><span class="No-Break"><span class="koboSpan" id="kobo.395.1">Bluefruit device.</span></span></p>
<p><span class="koboSpan" id="kobo.396.1">We need to be able to close </span><span class="No-Break"><span class="koboSpan" id="kobo.397.1">the connection:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.398.1">
    async def close(self):
        await self.ble_client.disconnect()</span></pre>
<p><span class="koboSpan" id="kobo.399.1">Then, the final part of this code can send data to </span><span class="No-Break"><span class="koboSpan" id="kobo.400.1">the robot:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.401.1">
    async def send_uart_data(self, data):
        await self.ble_client.write_gatt_char(self. </span><span class="koboSpan" id="kobo.401.2">tx_gatt, data)</span></pre>
<p><span class="koboSpan" id="kobo.402.1">This will wait for data to be sent and use the right UUID for transmitting to </span><span class="No-Break"><span class="koboSpan" id="kobo.403.1">the UART.</span></span></p>
<p><span class="koboSpan" id="kobo.404.1">This </span><strong class="source-inline"><span class="koboSpan" id="kobo.405.1">robot_ble_connection</span></strong><span class="koboSpan" id="kobo.406.1"> library is now ready to be used </span><span class="No-Break"><span class="koboSpan" id="kobo.407.1">in code.</span></span></p>
<h2 id="_idParaDest-285"><a id="_idTextAnchor286"/><span class="koboSpan" id="kobo.408.1">Showing the robot’s data on the computer screen</span></h2>
<p><span class="koboSpan" id="kobo.409.1">We can </span><a id="_idIndexMarker753"/><span class="koboSpan" id="kobo.410.1">use </span><strong class="source-inline"><span class="koboSpan" id="kobo.411.1">matplotlib</span></strong><span class="koboSpan" id="kobo.412.1"> to display the data from the robot, connecting to the robot with the preceding code, and asking it for the arena. </span><span class="koboSpan" id="kobo.412.2">This demonstration will tie </span><strong class="source-inline"><span class="koboSpan" id="kobo.413.1">matplotlib</span></strong><span class="koboSpan" id="kobo.414.1"> together with a </span><span class="No-Break"><span class="koboSpan" id="kobo.415.1">Bluetooth connection.</span></span></p>
<p><span class="koboSpan" id="kobo.416.1">We’ll put this in a new file named </span><strong class="source-inline"><span class="koboSpan" id="kobo.417.1">display_from_robot.py</span></strong><span class="koboSpan" id="kobo.418.1">, starting with </span><span class="No-Break"><span class="koboSpan" id="kobo.419.1">the imports:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.420.1">
import asyncio
import json
import matplotlib.pyplot as plt
from robot_ble_connection import BleConnection</span></pre>
<p><span class="koboSpan" id="kobo.421.1">We’ll put our display system in a class </span><span class="No-Break"><span class="koboSpan" id="kobo.422.1">called </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.423.1">RobotDisplay</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.424.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.425.1">
class RobotDisplay:
    def __init__(self):
        self.ble_connection = BleConnection(self.handle_data)
        self.buffer = ""
        self.arena = {}
        self.closed = False
        self.fig, self.axes = plt.subplots()</span></pre>
<p><span class="koboSpan" id="kobo.426.1">The first </span><a id="_idIndexMarker754"/><span class="koboSpan" id="kobo.427.1">part sets up the BLE connection and prepares it with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.428.1">handle_data</span></strong><span class="koboSpan" id="kobo.429.1"> method (this is the BLE data handler, which we’ll </span><span class="No-Break"><span class="koboSpan" id="kobo.430.1">implement shortly).</span></span></p>
<p><span class="koboSpan" id="kobo.431.1">When data arrives via BLE to the computer, a whole message can be split across a few calls to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.432.1">handle_data</span></strong><span class="koboSpan" id="kobo.433.1"> method. </span><span class="koboSpan" id="kobo.433.2">We are working in lines of text, so we will use </span><strong class="source-inline"><span class="koboSpan" id="kobo.434.1">self.buffer</span></strong><span class="koboSpan" id="kobo.435.1"> to store any partial line until we get a line ending, signaling a line is complete. </span><span class="koboSpan" id="kobo.435.2">We also have a place to store the arena from the robot, and a flag to detect when the app is closed. </span><span class="koboSpan" id="kobo.435.3">The display system is prepared with </span><strong class="source-inline"><span class="koboSpan" id="kobo.436.1">plt.subplots</span></strong><span class="koboSpan" id="kobo.437.1">, which gets a figure and axes – we’ll use these in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.438.1">draw</span></strong><span class="koboSpan" id="kobo.439.1"> method to draw </span><span class="No-Break"><span class="koboSpan" id="kobo.440.1">the display.</span></span></p>
<p><span class="koboSpan" id="kobo.441.1">Let’s make a handler for the app </span><span class="No-Break"><span class="koboSpan" id="kobo.442.1">being closed:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.443.1">
    def handle_close(self, _):
        self.closed = True</span></pre>
<p><span class="koboSpan" id="kobo.444.1">This handler will just set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.445.1">closed</span></strong><span class="koboSpan" id="kobo.446.1"> flag to </span><strong class="source-inline"><span class="koboSpan" id="kobo.447.1">True</span></strong><span class="koboSpan" id="kobo.448.1">, which we can check for later. </span><strong class="source-inline"><span class="koboSpan" id="kobo.449.1">matplotlib</span></strong><span class="koboSpan" id="kobo.450.1"> will automatically create an app window for us to </span><span class="No-Break"><span class="koboSpan" id="kobo.451.1">display output.</span></span></p>
<p><span class="koboSpan" id="kobo.452.1">Next, we will build the BLE </span><span class="No-Break"><span class="koboSpan" id="kobo.453.1">data handler:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.454.1">
    def handle_data(self, data):
        self.buffer += data.decode()
        while "\n" in self.buffer:
            line, self.buffer = self.buffer.split("\n", 1)
            print(f"Received data: {line}")
            try:
                message = json.loads(line)
            except ValueError:
                print("Error parsing JSON")
                return
            if "arena" in message:
                self.arena = message</span></pre>
<p><span class="koboSpan" id="kobo.455.1">This collects decoded incoming data into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.456.1">self.buffer</span></strong><span class="koboSpan" id="kobo.457.1"> variable. </span><span class="koboSpan" id="kobo.457.2">While that buffer has line endings, </span><strong class="source-inline"><span class="koboSpan" id="kobo.458.1">"\n"</span></strong><span class="koboSpan" id="kobo.459.1">, it splits a single line off and decodes it as JSON. </span></p>
<p><span class="koboSpan" id="kobo.460.1">We then </span><a id="_idIndexMarker755"/><span class="koboSpan" id="kobo.461.1">check whether this JSON has arena data in it. </span><span class="koboSpan" id="kobo.461.2">If so, we store it in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.462.1">arena</span></strong><span class="koboSpan" id="kobo.463.1"> data member. </span></p>
<p><span class="koboSpan" id="kobo.464.1">Next, we put the arena line drawing into </span><span class="No-Break"><span class="koboSpan" id="kobo.465.1">a method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.466.1">
    def draw(self):
        self.axes.clear()
        if self.arena:
            for line in self.arena["arena"]:
                self.axes.plot(
                    [line[0][0], line[1][0]], [line[0][1], line[1][1]], color="black"
                )</span></pre>
<p><span class="koboSpan" id="kobo.467.1">This function clears the previous display using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.468.1">self.axes.clear()</span></strong><span class="koboSpan" id="kobo.469.1"> function and then redraws the </span><span class="No-Break"><span class="koboSpan" id="kobo.470.1">arena lines.</span></span></p>
<p><span class="koboSpan" id="kobo.471.1">The app </span><strong class="source-inline"><span class="koboSpan" id="kobo.472.1">main</span></strong><span class="koboSpan" id="kobo.473.1"> method starts the connection and asks the robot for </span><span class="No-Break"><span class="koboSpan" id="kobo.474.1">the arena:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.475.1">
    async def main(self):
        plt.ion()
        await self.ble_connection.connect()
        try:
            request = json.dumps({"command": "arena"}).encode()
            print(f"Sending request for arena: {request}")
            await self.ble_connection.send_uart_data(request)
            self.fig.canvas.mpl_connect("close_event", self.handle_close)</span></pre>
<p><span class="koboSpan" id="kobo.476.1">This function enables interactive mode in </span><strong class="source-inline"><span class="koboSpan" id="kobo.477.1">matplotlib</span></strong><span class="koboSpan" id="kobo.478.1"> with </span><strong class="source-inline"><span class="koboSpan" id="kobo.479.1">plt.ion()</span></strong><span class="koboSpan" id="kobo.480.1"> – this means we get to handle when the screen is redrawn, which suits our data model. </span></p>
<p><span class="koboSpan" id="kobo.481.1">We then </span><a id="_idIndexMarker756"/><span class="koboSpan" id="kobo.482.1">call and wait for the BLE </span><strong class="source-inline"><span class="koboSpan" id="kobo.483.1">connect</span></strong><span class="koboSpan" id="kobo.484.1"> function. </span><span class="koboSpan" id="kobo.484.2">Once a connection has been made, we wrap the rest in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.485.1">try</span></strong><span class="koboSpan" id="kobo.486.1">/</span><strong class="source-inline"><span class="koboSpan" id="kobo.487.1">finally</span></strong><span class="koboSpan" id="kobo.488.1"> block that will ensure the BLE connection is closed if this code is stopped or breaks. </span><span class="koboSpan" id="kobo.488.2">We then send a request to the robot, asking for </span><span class="No-Break"><span class="koboSpan" id="kobo.489.1">the arena.</span></span></p>
<p><span class="koboSpan" id="kobo.490.1">The code sets up the </span><strong class="source-inline"><span class="koboSpan" id="kobo.491.1">close</span></strong><span class="koboSpan" id="kobo.492.1"> handler so we can detect whether the window is closed, and immediately gets into a main </span><strong class="source-inline"><span class="koboSpan" id="kobo.493.1">while</span></strong><span class="koboSpan" id="kobo.494.1"> loop based on the </span><span class="No-Break"><span class="koboSpan" id="kobo.495.1">closed flag:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.496.1">
            while not self.closed:
                self.draw()
                plt.draw()
                plt.pause(0.05)
                await asyncio.sleep(0.01)
        finally:
            await self.ble_connection.close()</span></pre>
<p><span class="koboSpan" id="kobo.497.1">The main loop uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.498.1">plt.draw()</span></strong><span class="koboSpan" id="kobo.499.1"> to update the display and then waits 0.05 seconds, giving </span><strong class="source-inline"><span class="koboSpan" id="kobo.500.1">matplotlib</span></strong><span class="koboSpan" id="kobo.501.1"> time to handle interactive events. </span><span class="koboSpan" id="kobo.501.2">It also has a 0.01-second asynchronous sleep to give the BLE tasks time to run. </span><span class="koboSpan" id="kobo.501.3">These sleeps and pauses must be called frequently. </span><span class="koboSpan" id="kobo.501.4">At the end, </span><strong class="source-inline"><span class="koboSpan" id="kobo.502.1">finally</span></strong><span class="koboSpan" id="kobo.503.1"> ensures we close the </span><span class="No-Break"><span class="koboSpan" id="kobo.504.1">BLE connection.</span></span></p>
<p><span class="koboSpan" id="kobo.505.1">We then need to create an instance of the class and start the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.506.1">main</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.507.1"> loop:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.508.1">
robot_display = RobotDisplay()
asyncio.run(robot_display.main())</span></pre>
<p><span class="koboSpan" id="kobo.509.1">At this point, the display code is complete. </span><span class="koboSpan" id="kobo.509.2">Send the </span><strong class="source-inline"><span class="koboSpan" id="kobo.510.1">robot</span></strong><span class="koboSpan" id="kobo.511.1"> folder to Raspberry Pi Pico, and with battery power turned on, start the display code with </span><span class="No-Break"><span class="koboSpan" id="kobo.512.1">the following:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.513.1">
python3 display_from_robot.py</span></pre>
<p><span class="koboSpan" id="kobo.514.1">You should see the BLE connecting messages and then the following output on </span><span class="No-Break"><span class="koboSpan" id="kobo.515.1">the computer:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.516.1">
Sending request for arena: b'{"command": "arena"}'
Received data: {"arena": [[[0, 0], [0, 1500]], [[0, 1500], [1500, 1500]], [[1500, 1500], [1500, 500]], [[1500, 500], [1000, 500]], [[1000, 500], [1000, 0]], [[1000, 0], [0, 0]]]}</span></pre>
<p><span class="koboSpan" id="kobo.517.1">After around 30 seconds, you should see the computer display the arena. </span><span class="koboSpan" id="kobo.517.2">This will look identical to </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.518.1">Figure 13</span></em></span><em class="italic"><span class="koboSpan" id="kobo.519.1">.6</span></em><span class="koboSpan" id="kobo.520.1">, but the data is now coming from </span><span class="No-Break"><span class="koboSpan" id="kobo.521.1">the robot.</span></span></p>
<p><span class="koboSpan" id="kobo.522.1">We have </span><a id="_idIndexMarker757"/><span class="koboSpan" id="kobo.523.1">the computer connecting to the robot and retrieving arena information from it. </span><span class="koboSpan" id="kobo.523.2">The robot has modeled the space in </span><span class="No-Break"><span class="koboSpan" id="kobo.524.1">simple terms.</span></span></p>
<p><span class="koboSpan" id="kobo.525.1">In the next section, we’ll look more at robot poses, displaying them on our computer, and updating them from encoder sensors. </span></p>
<h1 id="_idParaDest-286"><a id="_idTextAnchor287"/><span class="koboSpan" id="kobo.526.1">Using sensors to track relative pose</span></h1>
<p><span class="koboSpan" id="kobo.527.1">In this </span><a id="_idIndexMarker758"/><span class="koboSpan" id="kobo.528.1">section, we will explore what a pose is, how to </span><a id="_idIndexMarker759"/><span class="koboSpan" id="kobo.529.1">create, send, and display poses, and how to move the poses relative to the movement of </span><span class="No-Break"><span class="koboSpan" id="kobo.530.1">the robot.</span></span></p>
<h2 id="_idParaDest-287"><a id="_idTextAnchor288"/><span class="koboSpan" id="kobo.531.1">Setting up poses</span></h2>
<p><span class="koboSpan" id="kobo.532.1">We’ll make </span><a id="_idIndexMarker760"/><span class="koboSpan" id="kobo.533.1">some random poses in </span><strong class="source-inline"><span class="koboSpan" id="kobo.534.1">robot/code.py</span></strong><span class="koboSpan" id="kobo.535.1"> using </span><strong class="bold"><span class="koboSpan" id="kobo.536.1">NumPy</span></strong><span class="koboSpan" id="kobo.537.1">, a numeric </span><a id="_idIndexMarker761"/><span class="koboSpan" id="kobo.538.1">manipulation library for fast array operations, with </span><strong class="source-inline"><span class="koboSpan" id="kobo.539.1">ulab</span></strong><span class="koboSpan" id="kobo.540.1"> providing this functionality in CircuitPython. </span><span class="koboSpan" id="kobo.540.2">This library also gives us handy ways of storing and dealing </span><span class="No-Break"><span class="koboSpan" id="kobo.541.1">with arrays.</span></span></p>
<p><span class="koboSpan" id="kobo.542.1">Import the </span><strong class="source-inline"><span class="koboSpan" id="kobo.543.1">ulab</span></strong><span class="koboSpan" id="kobo.544.1"> library, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.545.1">random</span></strong><span class="koboSpan" id="kobo.546.1"> to generate </span><span class="No-Break"><span class="koboSpan" id="kobo.547.1">random poses:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.548.1">
import asyncio
import json
</span><strong class="bold"><span class="koboSpan" id="kobo.549.1">import random</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.550.1">from ulab import numpy as np</span></strong></pre>
<p><span class="koboSpan" id="kobo.551.1">After the </span><strong class="source-inline"><span class="koboSpan" id="kobo.552.1">read_json</span></strong><span class="koboSpan" id="kobo.553.1"> function, we’ll add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.554.1">Simulation</span></strong><span class="koboSpan" id="kobo.555.1"> class to hold </span><span class="No-Break"><span class="koboSpan" id="kobo.556.1">the poses:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.557.1">
class Simulation:
    def __init__(self):
        self.population_size = 20
        self.poses = np.array(
            [(
                int(random.uniform(0, arena.width)),
                int(random.uniform(0, arena.height)),
                int(random.uniform(0, 360))) for _ in range(self.population_size)],
            dtype=np.float,
        )</span></pre>
<p><span class="koboSpan" id="kobo.558.1">We will create a small population of 20 random poses. </span><span class="koboSpan" id="kobo.558.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.559.1">poses</span></strong><span class="koboSpan" id="kobo.560.1"> variable is a </span><strong class="source-inline"><span class="koboSpan" id="kobo.561.1">NumPy</span></strong><span class="koboSpan" id="kobo.562.1"> array of </span><strong class="source-inline"><span class="koboSpan" id="kobo.563.1">population_size</span></strong><span class="koboSpan" id="kobo.564.1"> items, with each item an </span><em class="italic"><span class="koboSpan" id="kobo.565.1">X</span></em><span class="koboSpan" id="kobo.566.1">, </span><em class="italic"><span class="koboSpan" id="kobo.567.1">Y</span></em><span class="koboSpan" id="kobo.568.1"> heading pose. </span><span class="koboSpan" id="kobo.568.2">NumPy allows us to specify a datatype; we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.569.1">float</span></strong><span class="koboSpan" id="kobo.570.1"> type so that we can work in </span><span class="No-Break"><span class="koboSpan" id="kobo.571.1">fractional values.</span></span></p>
<p><span class="koboSpan" id="kobo.572.1">Add a </span><a id="_idIndexMarker762"/><span class="koboSpan" id="kobo.573.1">function (before </span><strong class="source-inline"><span class="koboSpan" id="kobo.574.1">Simulation</span></strong><span class="koboSpan" id="kobo.575.1">) to send </span><em class="italic"><span class="koboSpan" id="kobo.576.1">X</span></em><span class="koboSpan" id="kobo.577.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.578.1">Y</span></em><span class="koboSpan" id="kobo.579.1"> pose coordinates to </span><span class="No-Break"><span class="koboSpan" id="kobo.580.1">the computer:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.581.1">
def send_poses(samples):
    send_json({
        "poses": np.array(samples[:,:2], dtype=np.int16).tolist(),
    })</span></pre>
<p><span class="koboSpan" id="kobo.582.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.583.1">[:, :2]</span></strong><span class="koboSpan" id="kobo.584.1"> notation lets us extract the first two entries of each pose in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.585.1">poses</span></strong><span class="koboSpan" id="kobo.586.1"> array, the </span><em class="italic"><span class="koboSpan" id="kobo.587.1">X</span></em><span class="koboSpan" id="kobo.588.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.589.1">Y</span></em><span class="koboSpan" id="kobo.590.1"> coordinates. </span><span class="koboSpan" id="kobo.590.2">We convert this to </span><strong class="source-inline"><span class="koboSpan" id="kobo.591.1">int16</span></strong><span class="koboSpan" id="kobo.592.1"> to reduce how much data is being sent – the UART is easily overwhelmed by </span><span class="No-Break"><span class="koboSpan" id="kobo.593.1">pose data.</span></span></p>
<p><span class="koboSpan" id="kobo.594.1">The command handler can now send poses after the arena </span><span class="No-Break"><span class="koboSpan" id="kobo.595.1">for now:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.596.1">
async def command_handler(</span><strong class="bold"><span class="koboSpan" id="kobo.597.1">simulation</span></strong><span class="koboSpan" id="kobo.598.1">):
    print("Starting handler")
    while True:
        if robot.uart.in_waiting:
            request = read_json()
            print("Received: ", request)
            if request["command"] == "arena":
                send_json({
                    "arena": arena.boundary_lines,
                })
</span><strong class="bold"><span class="koboSpan" id="kobo.599.1">                send_poses(simulation.poses)</span></strong><span class="koboSpan" id="kobo.600.1">
        await asyncio.sleep(0.1)
</span><strong class="bold"><span class="koboSpan" id="kobo.601.1">simulation = Simulation()</span></strong><span class="koboSpan" id="kobo.602.1">
asyncio.run(command_handler(</span><strong class="bold"><span class="koboSpan" id="kobo.603.1">simulation</span></strong><span class="koboSpan" id="kobo.604.1">))</span></pre>
<p><span class="koboSpan" id="kobo.605.1">Now, </span><strong class="source-inline"><span class="koboSpan" id="kobo.606.1">command_handler</span></strong><span class="koboSpan" id="kobo.607.1"> has the simulation passed into it and sends the poses back after the arena. </span><span class="koboSpan" id="kobo.607.2">Before </span><a id="_idIndexMarker763"/><span class="koboSpan" id="kobo.608.1">we start the handler, we create </span><strong class="source-inline"><span class="koboSpan" id="kobo.609.1">simulation</span></strong><span class="koboSpan" id="kobo.610.1"> from its class. </span></p>
<p><span class="koboSpan" id="kobo.611.1">This code is now ready for the computer to display </span><span class="No-Break"><span class="koboSpan" id="kobo.612.1">these poses.</span></span></p>
<h2 id="_idParaDest-288"><a id="_idTextAnchor289"/><span class="koboSpan" id="kobo.613.1">Displaying poses</span></h2>
<p><span class="koboSpan" id="kobo.614.1">We can </span><a id="_idIndexMarker764"/><span class="koboSpan" id="kobo.615.1">now enhance our </span><strong class="source-inline"><span class="koboSpan" id="kobo.616.1">matplotlib</span></strong><span class="koboSpan" id="kobo.617.1"> file, </span><strong class="source-inline"><span class="koboSpan" id="kobo.618.1">display_from_robot.py</span></strong><span class="koboSpan" id="kobo.619.1">, with the poses. </span><span class="koboSpan" id="kobo.619.2">First, we will add </span><strong class="source-inline"><span class="koboSpan" id="kobo.620.1">numpy</span></strong><span class="koboSpan" id="kobo.621.1"> to </span><span class="No-Break"><span class="koboSpan" id="kobo.622.1">the imports:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.623.1">
import asyncio
import json
</span><strong class="bold"><span class="koboSpan" id="kobo.624.1">import numpy as np</span></strong><span class="koboSpan" id="kobo.625.1">
import matplotlib.pyplot as plt</span></pre>
<p><span class="koboSpan" id="kobo.626.1">When we set up the display in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.627.1">__init__</span></strong><span class="koboSpan" id="kobo.628.1"> method, we add an empty </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.629.1">poses</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.630.1"> member:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.631.1">
        self.fig, self.axes = plt.subplots()
</span><strong class="bold"><span class="koboSpan" id="kobo.632.1">        self.poses = None</span></strong></pre>
<p><span class="koboSpan" id="kobo.633.1">Next, we need to extend </span><strong class="source-inline"><span class="koboSpan" id="kobo.634.1">handle_data</span></strong><span class="koboSpan" id="kobo.635.1"> to load poses into an </span><strong class="source-inline"><span class="koboSpan" id="kobo.636.1">int16</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.637.1">NumPy array:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.638.1">
            if "arena" in message:
                self.arena = message
</span><strong class="bold"><span class="koboSpan" id="kobo.639.1">            if "poses" in message:</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.640.1">                self.poses = np.array(message["poses"], dtype=np.int16)</span></strong></pre>
<p><span class="koboSpan" id="kobo.641.1">We then add extend the </span><strong class="source-inline"><span class="koboSpan" id="kobo.642.1">draw</span></strong><span class="koboSpan" id="kobo.643.1"> method to display poses, checking whether any are loaded and, if so, putting them into a scatter plot, slicing into the </span><em class="italic"><span class="koboSpan" id="kobo.644.1">X</span></em><span class="koboSpan" id="kobo.645.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.646.1">Y</span></em><span class="koboSpan" id="kobo.647.1"> components to fit </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.648.1">matplotlib</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.649.1"> :</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.650.1">
        if self.arena:
            for line in self.arena["arena"]:
                self.axes.plot(
                    [line[0][0], line[1][0]], [line[0][1], line[1][1]], color="black"
                )
</span><strong class="bold"><span class="koboSpan" id="kobo.651.1">        if self.poses is not None:</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.652.1">            self.axes.scatter(self.poses[:,0], self.poses[:,1], color="blue")</span></strong></pre>
<p><span class="koboSpan" id="kobo.653.1">Send the </span><strong class="source-inline"><span class="koboSpan" id="kobo.654.1">robot</span></strong><span class="koboSpan" id="kobo.655.1"> folder over to Pico, and then run </span><strong class="source-inline"><span class="koboSpan" id="kobo.656.1">display_from_robot.py</span></strong><span class="koboSpan" id="kobo.657.1"> on the computer, and after </span><a id="_idIndexMarker765"/><span class="koboSpan" id="kobo.658.1">the BLE startup, you should see something like the </span><span class="No-Break"><span class="koboSpan" id="kobo.659.1">following screenshot:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer202">
<span class="koboSpan" id="kobo.660.1"><img alt="Figure 13.7 – Poses drawn in the arena " src="image/Figure_13.07_B18001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.661.1">Figure 13.7 – Poses drawn in the arena</span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.662.1">Figure 13</span></em></span><em class="italic"><span class="koboSpan" id="kobo.663.1">.7</span></em><span class="koboSpan" id="kobo.664.1"> shows the arena with 20 poses drawn as dots. </span><span class="koboSpan" id="kobo.664.2">Each dot is a potential guess of where the robot might be. </span><span class="koboSpan" id="kobo.664.3">Some are in the cutout area and will later </span><span class="No-Break"><span class="koboSpan" id="kobo.665.1">be eliminated.</span></span></p>
<p><span class="koboSpan" id="kobo.666.1">These poses will need to move when our robot moves, so let’s make our </span><span class="No-Break"><span class="koboSpan" id="kobo.667.1">robot move.</span></span></p>
<h2 id="_idParaDest-289"><a id="_idTextAnchor290"/><span class="koboSpan" id="kobo.668.1">Moving with collision avoidance</span></h2>
<p><span class="koboSpan" id="kobo.669.1">The robot will be moving while we perform the simulation, and it would be good to avoid collisions </span><a id="_idIndexMarker766"/><span class="koboSpan" id="kobo.670.1">while the robot moves. </span><span class="koboSpan" id="kobo.670.2">We’ll do this as an asynchronous routine so that other parts of the code can run at the same time. </span><span class="koboSpan" id="kobo.670.3">The following architecture diagram shows how </span><span class="No-Break"><span class="koboSpan" id="kobo.671.1">this works:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer203">
<span class="koboSpan" id="kobo.672.1"><img alt="Figure 13.8 – A simulation with a collision avoidance architecture " src="image/Figure_13.08_B18001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.673.1">Figure 13.8 – A simulation with a collision avoidance architecture</span></p>
<p><span class="koboSpan" id="kobo.674.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.675.1">command handler</span></strong><span class="koboSpan" id="kobo.676.1"> system accepts Bluetooth command requests. </span><span class="koboSpan" id="kobo.676.2">The command handler starts the </span><strong class="source-inline"><span class="koboSpan" id="kobo.677.1">main</span></strong><span class="koboSpan" id="kobo.678.1"> loop in </span><strong class="source-inline"><span class="koboSpan" id="kobo.679.1">simulation</span></strong><span class="koboSpan" id="kobo.680.1">. </span><span class="koboSpan" id="kobo.680.2">The simulation will start both a </span><strong class="bold"><span class="koboSpan" id="kobo.681.1">Collision Avoider</span></strong><span class="koboSpan" id="kobo.682.1"> and a </span><strong class="bold"><span class="koboSpan" id="kobo.683.1">Distance Sensor Tracker</span></strong><span class="koboSpan" id="kobo.684.1">, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.685.1">Figure 13</span></em></span><em class="italic"><span class="koboSpan" id="kobo.686.1">.8</span></em><span class="koboSpan" id="kobo.687.1">. </span><span class="koboSpan" id="kobo.687.2">The distance sensor tracker will </span><a id="_idIndexMarker767"/><span class="koboSpan" id="kobo.688.1">store sensor data used by the simulation and the collision avoider. </span><span class="koboSpan" id="kobo.688.2">The collision avoider will drive the robot’s motors. </span><span class="koboSpan" id="kobo.688.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.689.1">simulation</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.690.1">main</span></strong><span class="koboSpan" id="kobo.691.1"> method also sends poses </span><span class="No-Break"><span class="koboSpan" id="kobo.692.1">via Bluetooth.</span></span></p>
<p><span class="koboSpan" id="kobo.693.1">We will start with </span><strong class="source-inline"><span class="koboSpan" id="kobo.694.1">DistanceSensorTracker</span></strong><span class="koboSpan" id="kobo.695.1">, a class to keep tabs on the distance sensors and their last readings. </span><span class="koboSpan" id="kobo.695.2">Place this in </span><strong class="source-inline"><span class="koboSpan" id="kobo.696.1">robot/code.py</span></strong><span class="koboSpan" id="kobo.697.1"> under </span><span class="No-Break"><span class="koboSpan" id="kobo.698.1">the imports:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.699.1">
class DistanceSensorTracker:
    def __init__(self):
        robot.left_distance.distance_mode = 2
        robot.right_distance.distance_mode = 2
        self.left = 300
        self.right = 300</span></pre>
<p><span class="koboSpan" id="kobo.700.1">We are being explicit about sensor mode here, adjusting it to the size of the arena. </span><span class="koboSpan" id="kobo.700.2">We also put in starting values until a reading </span><span class="No-Break"><span class="koboSpan" id="kobo.701.1">is available.</span></span></p>
<p><span class="koboSpan" id="kobo.702.1">The sensor </span><a id="_idIndexMarker768"/><span class="koboSpan" id="kobo.703.1">tracker loop fetches readings when ready and resets the </span><span class="No-Break"><span class="koboSpan" id="kobo.704.1">sensor interrupts:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.705.1">
    async def main(self):
        robot.left_distance.start_ranging()
        robot.right_distance.start_ranging()
        while True:
            if robot.left_distance.data_ready and robot.left_distance.distance:
                self.left = robot.left_distance.distance * 10
                robot.left_distance.clear_interrupt()
            if robot.right_distance.data_ready and robot.right_distance.distance:
                self.right = robot.right_distance.distance * 10
                robot.right_distance.clear_interrupt()
            await asyncio.sleep(0.01)     </span></pre>
<p><span class="koboSpan" id="kobo.706.1">We are multiplying the sensor readings by 10 to convert them to mm, and then storing them. </span><span class="koboSpan" id="kobo.706.2">The remaining code can just use these </span><span class="No-Break"><span class="koboSpan" id="kobo.707.1">stored readings.</span></span></p>
<p><span class="koboSpan" id="kobo.708.1">Next, we’ll build the </span><strong class="source-inline"><span class="koboSpan" id="kobo.709.1">CollisionAvoid</span></strong><span class="koboSpan" id="kobo.710.1"> class to turn the robot away from a wall that it detects with the sensors. </span><span class="koboSpan" id="kobo.710.2">Add this class after the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.711.1">DistanceSensorTracker</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.712.1"> class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.713.1">
class CollisionAvoid:
    def __init__(self, distance_sensors):
        self.speed = 0.6
        self.distance_sensors = distance_sensors</span></pre>
<p><span class="koboSpan" id="kobo.714.1">This has an initial robot speed, along with a reference to the distance sensor tracker. </span><span class="koboSpan" id="kobo.714.2">This then has a </span><strong class="source-inline"><span class="koboSpan" id="kobo.715.1">main</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.716.1">collision-avoiding loop:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.717.1">
    async def main(self):
        while True:
            robot.set_right(self.speed)
            while self.distance_sensors.left &lt; 300 or \
                    self.distance_sensors.right &lt; 300:
                robot.set_left(-self.speed)
                await asyncio.sleep(0.3)
            robot.set_left(self.speed)
            await asyncio.sleep(0)</span></pre>
<p><span class="koboSpan" id="kobo.718.1">This loop starts the right motor moving, and if a collision looks likely, it will set the left motor going backward and wait before driving forward. </span><span class="koboSpan" id="kobo.718.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.719.1">asyncio.sleep</span></strong><span class="koboSpan" id="kobo.720.1"> delays mean that </span><a id="_idIndexMarker769"/><span class="koboSpan" id="kobo.721.1">other tasks can continue on </span><span class="No-Break"><span class="koboSpan" id="kobo.722.1">the robot.</span></span></p>
<p><span class="koboSpan" id="kobo.723.1">Inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.724.1">Simulation</span></strong><span class="koboSpan" id="kobo.725.1"> class, add the sensors and </span><strong class="source-inline"><span class="koboSpan" id="kobo.726.1">collision_avoider</span></strong><span class="koboSpan" id="kobo.727.1"> to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.728.1">__init__</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.729.1"> method:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.730.1">        self.distance_sensors = DistanceSensorTracker()</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.731.1">        self.collision_avoider = CollisionAvoid(self.distance_sensors)</span></strong></pre>
<p><span class="koboSpan" id="kobo.732.1">Then, we add a simulation </span><strong class="source-inline"><span class="koboSpan" id="kobo.733.1">main</span></strong><span class="koboSpan" id="kobo.734.1"> method below the </span><strong class="source-inline"><span class="koboSpan" id="kobo.735.1">__init__</span></strong><span class="koboSpan" id="kobo.736.1"> simulation. </span><span class="koboSpan" id="kobo.736.2">This starts tasks for the other components and then loops over, sending the poses back to </span><span class="No-Break"><span class="koboSpan" id="kobo.737.1">the computer:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.738.1">
    async def main(self):
        asyncio.create_task(self.distance_sensors.main())
        collision_avoider = asyncio.create_task(self.collision_avoider.main())
        try:
            while True:
                await asyncio.sleep(0.1)
                send_poses(self.poses)
        finally:
            collision_avoider.cancel()
            robot.stop()</span></pre>
<p><span class="koboSpan" id="kobo.739.1">There’s also error handling to stop the robot if anything goes wrong here – we cancel the collision avoider task (which would set the robot’s speed) and stop the motors. </span><span class="koboSpan" id="kobo.739.2">The sleep here allows the other tasks to run and avoids overwhelming the </span><span class="No-Break"><span class="koboSpan" id="kobo.740.1">BLE UART.</span></span></p>
<p><span class="koboSpan" id="kobo.741.1">Extend the </span><strong class="source-inline"><span class="koboSpan" id="kobo.742.1">command_handler</span></strong><span class="koboSpan" id="kobo.743.1"> method to start the simulat</span><a id="_idTextAnchor291"/><span class="koboSpan" id="kobo.744.1">ion’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.745.1">main</span></strong><span class="koboSpan" id="kobo.746.1"> task. </span><span class="koboSpan" id="kobo.746.2">We’ll do so based on a </span><strong class="bold"><span class="koboSpan" id="kobo.747.1">Start</span></strong><span class="koboSpan" id="kobo.748.1"> button in the display UI. </span><span class="koboSpan" id="kobo.748.2">First, we’ll store the task state at the top of </span><span class="No-Break"><span class="koboSpan" id="kobo.749.1">the handler:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.750.1">
async def command_handler(simulation):
    print("Starting handler")
</span><strong class="bold"><span class="koboSpan" id="kobo.751.1">    simulation_task = None</span></strong><span class="koboSpan" id="kobo.752.1">
    while True:</span></pre>
<p><span class="koboSpan" id="kobo.753.1">Then, we’ll </span><a id="_idIndexMarker770"/><span class="koboSpan" id="kobo.754.1">handle a </span><strong class="source-inline"><span class="koboSpan" id="kobo.755.1">start</span></strong><span class="koboSpan" id="kobo.756.1"> command </span><span class="No-Break"><span class="koboSpan" id="kobo.757.1">in it:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.758.1">
            if request["command"] == "arena":
                send_json({
                    "arena": arena.boundary_lines,
                })
</span><strong class="bold"><span class="koboSpan" id="kobo.759.1">            elif request["command"] == "start":</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.760.1">                if not simulation_task:</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.761.1">                    simulation_task = asyncio.create_task(simulation.main())</span></strong></pre>
<p><span class="koboSpan" id="kobo.762.1">The start button will run the simulation </span><strong class="source-inline"><span class="koboSpan" id="kobo.763.1">main</span></strong><span class="koboSpan" id="kobo.764.1"> task if it’s not yet </span><span class="No-Break"><span class="koboSpan" id="kobo.765.1">been run.</span></span></p>
<h3><span class="koboSpan" id="kobo.766.1">Adding the start button on the computer</span></h3>
<p><span class="koboSpan" id="kobo.767.1">We need </span><a id="_idIndexMarker771"/><span class="koboSpan" id="kobo.768.1">to add the corresponding button to the computer display code. </span><span class="koboSpan" id="kobo.768.2">Open </span><strong class="source-inline"><span class="koboSpan" id="kobo.769.1">display_from_robot.py</span></strong><span class="koboSpan" id="kobo.770.1">. </span><span class="koboSpan" id="kobo.770.2">In the imports, add </span><span class="No-Break"><span class="koboSpan" id="kobo.771.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.772.1">
from matplotlib.widgets import Button</span></pre>
<p><span class="koboSpan" id="kobo.773.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.774.1">RobotDisplay</span></strong><span class="koboSpan" id="kobo.775.1"> class, we can add a helper to send a JSON command, much as we did on the robot. </span><span class="koboSpan" id="kobo.775.2">Add this to the robot display class above its </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.776.1">main</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.777.1"> method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.778.1">
    async def send_command(self, command):
        request = (json.dumps({"command": command})  ).encode()
        print(f"Sending request: {request}")
        await self.ble_connection.send_uart_data(request)</span></pre>
<p><span class="koboSpan" id="kobo.779.1">This must be asynchronous to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.780.1">await</span></strong><span class="koboSpan" id="kobo.781.1"> on the BLE </span><strong class="source-inline"><span class="koboSpan" id="kobo.782.1">send_uart_data</span></strong><span class="koboSpan" id="kobo.783.1"> function. </span></p>
<p><span class="koboSpan" id="kobo.784.1">Above </span><strong class="source-inline"><span class="koboSpan" id="kobo.785.1">main</span></strong><span class="koboSpan" id="kobo.786.1">, add a start button handler to call when the button </span><span class="No-Break"><span class="koboSpan" id="kobo.787.1">is pressed:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.788.1">
    def start(self, _):
        self.button_task = asyncio.create_task(self.send_command("start"))</span></pre>
<p><span class="koboSpan" id="kobo.789.1">This will </span><a id="_idIndexMarker772"/><span class="koboSpan" id="kobo.790.1">start sending the data but not wait for it – so the </span><strong class="source-inline"><span class="koboSpan" id="kobo.791.1">matplotlib</span></strong><span class="koboSpan" id="kobo.792.1"> event loop doesn’t get </span><span class="No-Break"><span class="koboSpan" id="kobo.793.1">stuck waiting.</span></span></p>
<p><span class="koboSpan" id="kobo.794.1">We can replace the JSON sending in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.795.1">main</span></strong><span class="koboSpan" id="kobo.796.1"> method with the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.797.1">send_command</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.798.1"> method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.799.1">
        await self.ble_connection.connect()
        try:
</span><strong class="bold"><span class="koboSpan" id="kobo.800.1">            await self.send_command("arena")</span></strong></pre>
<p><span class="koboSpan" id="kobo.801.1">We then add the button. </span><span class="koboSpan" id="kobo.801.2">Add the highlighted code into the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.802.1">main</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.803.1"> method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.804.1">
            self.fig.canvas.mpl_connect("close_event", self.handle_close)
</span><strong class="bold"><span class="koboSpan" id="kobo.805.1">            start_button = Button(plt.axes([0.7, 0.05, 0.1, 0.075]), "Start")</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.806.1">            start_button.on_clicked(self.start)</span></strong><span class="koboSpan" id="kobo.807.1">
            while not self.closed:</span></pre>
<p><span class="koboSpan" id="kobo.808.1">The code uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.809.1">send_command</span></strong><span class="koboSpan" id="kobo.810.1"> wrapper to request the arena on startup. </span><span class="koboSpan" id="kobo.810.2">We then add </span><strong class="source-inline"><span class="koboSpan" id="kobo.811.1">start_button</span></strong><span class="koboSpan" id="kobo.812.1">, using </span><strong class="source-inline"><span class="koboSpan" id="kobo.813.1">plt.axes</span></strong><span class="koboSpan" id="kobo.814.1"> to </span><span class="No-Break"><span class="koboSpan" id="kobo.815.1">position it.</span></span></p>
<p><span class="koboSpan" id="kobo.816.1">We connect a button </span><strong class="source-inline"><span class="koboSpan" id="kobo.817.1">on_clicked</span></strong><span class="koboSpan" id="kobo.818.1"> handler to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.819.1">start</span></strong><span class="koboSpan" id="kobo.820.1"> method to enable </span><span class="No-Break"><span class="koboSpan" id="kobo.821.1">the button.</span></span></p>
<p><span class="koboSpan" id="kobo.822.1">Send the </span><strong class="source-inline"><span class="koboSpan" id="kobo.823.1">robot</span></strong><span class="koboSpan" id="kobo.824.1"> folder to Raspberry Pi Pico, and on the computer, run </span><strong class="source-inline"><span class="koboSpan" id="kobo.825.1">display_from_robot.py</span></strong><span class="koboSpan" id="kobo.826.1">. </span><span class="koboSpan" id="kobo.826.2">I recommend propping the robot up for troubleshooting while connected, and then test it in the arena. </span><span class="koboSpan" id="kobo.826.3">The display will look like the </span><span class="No-Break"><span class="koboSpan" id="kobo.827.1">following screenshot:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer204">
<span class="koboSpan" id="kobo.828.1"><img alt="Figure 13.9 – The arena display with a button " src="image/Figure_13.09_B18001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.829.1">Figure 13.9 – The arena display with a button</span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.830.1">Figure 13</span></em></span><em class="italic"><span class="koboSpan" id="kobo.831.1">.9</span></em><span class="koboSpan" id="kobo.832.1"> shows the </span><strong class="bold"><span class="koboSpan" id="kobo.833.1">Start</span></strong><span class="koboSpan" id="kobo.834.1"> button on the display. </span><span class="koboSpan" id="kobo.834.2">Press </span><strong class="bold"><span class="koboSpan" id="kobo.835.1">Start</span></strong><span class="koboSpan" id="kobo.836.1"> to get the robot running – poses </span><a id="_idIndexMarker773"/><span class="koboSpan" id="kobo.837.1">will appear, and the robot should be avoiding walls in the arena. </span><span class="koboSpan" id="kobo.837.2">If not, the next section </span><span class="No-Break"><span class="koboSpan" id="kobo.838.1">will help.</span></span></p>
<h3><span class="koboSpan" id="kobo.839.1">Troubleshooting</span></h3>
<p><span class="koboSpan" id="kobo.840.1">These </span><a id="_idIndexMarker774"/><span class="koboSpan" id="kobo.841.1">suggestions will help if you are having </span><span class="No-Break"><span class="koboSpan" id="kobo.842.1">trouble here:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.843.1">If the distance sensors are showing errors, please go back to </span><a href="B18001_08.xhtml#_idTextAnchor166"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.844.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.845.1">, </span><em class="italic"><span class="koboSpan" id="kobo.846.1">Sensing Distances to Detect Objects with Pico</span></em><span class="koboSpan" id="kobo.847.1">, and check the wiring, using the tests there. </span></li>
<li><span class="koboSpan" id="kobo.848.1">If the robot is turning too far and getting trapped in the corners, lower the sleep </span><span class="No-Break"><span class="koboSpan" id="kobo.849.1">after </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.850.1">robot.set_left(-self.speed)</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.851.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.852.1">If the robot is going very quickly, either reduce </span><strong class="source-inline"><span class="koboSpan" id="kobo.853.1">self.speed</span></strong><span class="koboSpan" id="kobo.854.1"> or replace the motors with a greater gear ratio – ideally, 298:1, as recommended in </span><a href="B18001_11.xhtml#_idTextAnchor233"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.855.1">Chapter 11</span></em></span></a><span class="koboSpan" id="kobo.856.1"> in the </span><em class="italic"><span class="koboSpan" id="kobo.857.1">Slowing the Robot </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.858.1">Down</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.859.1"> section.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.860.1">While the robot is now avoiding walls, the poses are not changing when the robot moves. </span><span class="koboSpan" id="kobo.860.2">To remedy this, we can add a motion model in the </span><span class="No-Break"><span class="koboSpan" id="kobo.861.1">next section.</span></span></p>
<h2 id="_idParaDest-290"><a id="_idTextAnchor292"/><span class="koboSpan" id="kobo.862.1">Moving poses with the encoders</span></h2>
<p><span class="koboSpan" id="kobo.863.1">We want </span><a id="_idIndexMarker775"/><span class="koboSpan" id="kobo.864.1">the poses to move with our robot’s motion, updating both their position and their heading. </span><span class="koboSpan" id="kobo.864.2">The wheel encoders provide data about each wheel’s motion, and we can convert this into rotations and translations of the pose. </span><span class="koboSpan" id="kobo.864.3">First, we need to store more data about the shape of the chassis </span><span class="No-Break"><span class="koboSpan" id="kobo.865.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.866.1">robot/robot.py</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.867.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.868.1">
ticks_per_revolution = encoder_poles * gear_ratio
</span><strong class="bold"><span class="koboSpan" id="kobo.869.1">ticks_to_mm = wheel_circumference_mm / ticks_per_revolution</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.870.1">ticks_to_m = ticks_to_mm / 1000</span></strong><span class="koboSpan" id="kobo.871.1">
m_to_ticks = 1 / ticks_to_m
</span><strong class="bold"><span class="koboSpan" id="kobo.872.1">wheelbase_mm = 170</span></strong></pre>
<p><span class="koboSpan" id="kobo.873.1">We ensure our tick conversion is in mm. </span><span class="koboSpan" id="kobo.873.2">We then add the wheelbase – this is a measurement </span><a id="_idIndexMarker776"/><span class="koboSpan" id="kobo.874.1">between the central contact point of each wheel. </span><span class="koboSpan" id="kobo.874.2">Use a value measured from your own robot. </span><span class="koboSpan" id="kobo.874.3">We can use the wheelbase to calculate the robot’s movement from the encoders, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.875.1">following diagram:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer205">
<span class="koboSpan" id="kobo.876.1"><img alt="Figure 13.10 – Calculating motion from encoders " src="image/Figure_13.10_B18001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.877.1">Figure 13.10 – Calculating motion from encoders</span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.878.1">Figure 13</span></em></span><em class="italic"><span class="koboSpan" id="kobo.879.1">.10 (a)</span></em><span class="koboSpan" id="kobo.880.1"> shows the robot moving along an arc. </span><span class="koboSpan" id="kobo.880.2">Each wheel encoder will sense travel along an arc on an inner radius or an outer radius. </span><span class="koboSpan" id="kobo.880.3">Our robot uses a differential drive, so we can assume all motion takes place around the axis between the two wheels. </span><span class="koboSpan" id="kobo.880.4">The center of the robot, our pose, travels along the turn radius. </span><span class="koboSpan" id="kobo.880.5">We can use these with the wheel distance – the distance between the two wheels to calculate </span><span class="No-Break"><span class="koboSpan" id="kobo.881.1">the arc.</span></span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.882.1">Figure 13</span></em></span><em class="italic"><span class="koboSpan" id="kobo.883.1">.10 (b)</span></em><span class="koboSpan" id="kobo.884.1"> relates an arc length to the arc angle and radius. </span><span class="koboSpan" id="kobo.884.2">Each wheel will have traveled an arc, and the encoder will have measured the arc length. </span><span class="koboSpan" id="kobo.884.3">This arc length is the radius multiplied by the angle (in radians). </span><span class="koboSpan" id="kobo.884.4">We will use this to calculate the arc. </span><span class="koboSpan" id="kobo.884.5">From the motion of the two wheels, measured by the encoders (arc lengths) and the wheel distance, we can get the radius and angle </span><span class="No-Break"><span class="koboSpan" id="kobo.885.1">change (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.886.1">d_theta</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.887.1">).</span></span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.888.1">Figure 13</span></em></span><em class="italic"><span class="koboSpan" id="kobo.889.1">.10 (c)</span></em><span class="koboSpan" id="kobo.890.1"> represents a robot motion. </span><span class="koboSpan" id="kobo.890.2">Although the robot has moved in an arc, for the simulation, we will simplify this arc motion into three components – </span><em class="italic"><span class="koboSpan" id="kobo.891.1">rotation 1</span></em><span class="koboSpan" id="kobo.892.1"> aligns the robot </span><a id="_idIndexMarker777"/><span class="koboSpan" id="kobo.893.1">for a straight-line </span><em class="italic"><span class="koboSpan" id="kobo.894.1">translation</span></em><span class="koboSpan" id="kobo.895.1">, and then </span><em class="italic"><span class="koboSpan" id="kobo.896.1">rotation 2</span></em><span class="koboSpan" id="kobo.897.1"> turns the robot to face the heading expected at the end of the curve. </span></p>
<p><span class="koboSpan" id="kobo.898.1">Add the following into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.899.1">Simulation</span></strong><span class="koboSpan" id="kobo.900.1"> class </span><span class="No-Break"><span class="koboSpan" id="kobo.901.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.902.1">robot/code.py</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.903.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.904.1">
    def convert_odometry_to_motion(self, left_encoder_delta, right_encoder_delta):
        left_mm = left_encoder_delta * robot.ticks_to_mm
        right_mm = right_encoder_delta * robot.ticks_to_mm
        if left_mm == right_mm:
            return 0, left_mm, 0</span></pre>
<p><span class="koboSpan" id="kobo.905.1">This function will take the changes (or deltas) in encoders and convert them to obtain representations of </span><em class="italic"><span class="koboSpan" id="kobo.906.1">rotation 1</span></em><span class="koboSpan" id="kobo.907.1">, </span><em class="italic"><span class="koboSpan" id="kobo.908.1">translation</span></em><span class="koboSpan" id="kobo.909.1">, and </span><em class="italic"><span class="koboSpan" id="kobo.910.1">rotation 2</span></em><span class="koboSpan" id="kobo.911.1">. </span><span class="koboSpan" id="kobo.911.2">The encoder changes are turned into measurements in mm. </span><span class="koboSpan" id="kobo.911.3">We then check for the straight-line case, and if it is there, return a translation component only. </span><span class="koboSpan" id="kobo.911.4">This prevents </span><strong class="source-inline"><span class="koboSpan" id="kobo.912.1">0</span></strong><span class="koboSpan" id="kobo.913.1"> causing the next part </span><span class="No-Break"><span class="koboSpan" id="kobo.914.1">to crash.</span></span></p>
<p><span class="koboSpan" id="kobo.915.1">The remaining cases now need us to calculate </span><span class="No-Break"><span class="koboSpan" id="kobo.916.1">an arc:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.917.1">
        radius = (robot.wheelbase_mm / 2) * (left_mm + right_mm) / (right_mm - left_mm)
        d_theta = (right_mm - left_mm) / robot.wheelbase_mm
        arc_length = d_theta * radius</span></pre>
<p><span class="koboSpan" id="kobo.918.1">The first line uses the wheelbase and the two encoder movements to calculate an arc radius. </span><span class="koboSpan" id="kobo.918.2">The difference between the motion of the two wheels is then used to calculate </span><strong class="source-inline"><span class="koboSpan" id="kobo.919.1">d_theta</span></strong><span class="koboSpan" id="kobo.920.1">, how much the robot’s heading changed throughout this arc. </span><span class="koboSpan" id="kobo.920.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.921.1">d</span></strong><span class="koboSpan" id="kobo.922.1"> prefix represents </span><span class="No-Break"><span class="koboSpan" id="kobo.923.1">a delta.</span></span></p>
<p><span class="koboSpan" id="kobo.924.1">The arc length is then </span><strong class="source-inline"><span class="koboSpan" id="kobo.925.1">d_theta</span></strong><span class="koboSpan" id="kobo.926.1"> multiplied by the radius. </span><span class="koboSpan" id="kobo.926.2">Because this will be called fairly frequently, we are going to assume that the arc length is close enough to the translation. </span></p>
<p><span class="koboSpan" id="kobo.927.1">From here, the rotation components can </span><span class="No-Break"><span class="koboSpan" id="kobo.928.1">be calculated:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.929.1">
        rot1 = np.degrees(d_theta/2)
        rot2 = rot1
        return rot1, arc_length, rot2</span></pre>
<p><span class="koboSpan" id="kobo.930.1">If we assume the arc to be regular, then each rotation component is half of the full arc rotation. </span><span class="koboSpan" id="kobo.930.2">We also convert this into degrees. </span></p>
<p><span class="koboSpan" id="kobo.931.1">We can </span><a id="_idIndexMarker778"/><span class="koboSpan" id="kobo.932.1">then write a method to move poses this way. </span><span class="koboSpan" id="kobo.932.2">Add this to </span><strong class="source-inline"><span class="koboSpan" id="kobo.933.1">Simulation</span></strong><span class="koboSpan" id="kobo.934.1"> by following </span><span class="No-Break"><span class="koboSpan" id="kobo.935.1">these steps:</span></span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.936.1">Define the method and add the first rotation into the array of pose rotations (the </span><span class="No-Break"><span class="koboSpan" id="kobo.937.1">third element):</span></span><pre class="console"><span class="koboSpan" id="kobo.938.1">
    def move_poses(self, rot1, trans, rot2):</span></pre><pre class="console"><span class="koboSpan" id="kobo.939.1">
        self.poses[:,2] += rot1</span></pre></li>
<li><span class="koboSpan" id="kobo.940.1">We then move the translation term in the new </span><span class="No-Break"><span class="koboSpan" id="kobo.941.1">pose direction:</span></span><pre class="console"><span class="koboSpan" id="kobo.942.1">
        rot1_radians = np.radians(self.poses[:,2])</span></pre><pre class="console"><span class="koboSpan" id="kobo.943.1">
        self.poses[:,0] += trans * np.cos(rot1_radians)</span></pre><pre class="console"><span class="koboSpan" id="kobo.944.1">
        self.poses[:,1] += trans * np.sin(rot1_radians)</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.945.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.946.1">rot1_radians</span></strong><span class="koboSpan" id="kobo.947.1"> variable will hold a </span><strong class="source-inline"><span class="koboSpan" id="kobo.948.1">NumPy</span></strong><span class="koboSpan" id="kobo.949.1"> array. </span><span class="koboSpan" id="kobo.949.2">This comes from the second element of the poses array, converted into radians. </span><span class="koboSpan" id="kobo.949.3">The ability of </span><strong class="source-inline"><span class="koboSpan" id="kobo.950.1">NumPy</span></strong><span class="koboSpan" id="kobo.951.1"> (or </span><strong class="source-inline"><span class="koboSpan" id="kobo.952.1">ulab</span></strong><span class="koboSpan" id="kobo.953.1">) to operate on whole arrays is handy here. </span><span class="koboSpan" id="kobo.953.2">We will use it again to calculate the </span><em class="italic"><span class="koboSpan" id="kobo.954.1">X</span></em><span class="koboSpan" id="kobo.955.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.956.1">Y</span></em><span class="koboSpan" id="kobo.957.1"> motions. </span><strong class="source-inline"><span class="koboSpan" id="kobo.958.1">trans * np.cos</span></strong><span class="koboSpan" id="kobo.959.1"> applies the cosine function to every element in </span><strong class="source-inline"><span class="koboSpan" id="kobo.960.1">rot1_radians</span></strong><span class="koboSpan" id="kobo.961.1"> and multiplies each one by the </span><span class="No-Break"><span class="koboSpan" id="kobo.962.1">translation term.</span></span></p>
<ol>
<li value="3"><span class="koboSpan" id="kobo.963.1">We then need to add the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.964.1">rot2</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.965.1"> term:</span></span><pre class="console"><span class="koboSpan" id="kobo.966.1">
        self.poses[:,2] += rot2</span></pre><pre class="console"><span class="koboSpan" id="kobo.967.1">
        self.poses[:,2] = np.array([float(theta % 360) for theta in self.poses[:,2]])</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.968.1">Finally, we constrain the angles between 0 and </span><span class="No-Break"><span class="koboSpan" id="kobo.969.1">360 degrees.</span></span></p>
<ol>
<li value="4"><span class="koboSpan" id="kobo.970.1">Next, we need to tie these together with getting the encoder deltas. </span><span class="koboSpan" id="kobo.970.2">First, we extend the </span><strong class="source-inline"><span class="koboSpan" id="kobo.971.1">Simulation.__init__</span></strong><span class="koboSpan" id="kobo.972.1"> method to get the initial </span><span class="No-Break"><span class="koboSpan" id="kobo.973.1">encoder readings:</span></span><pre class="console"><span class="koboSpan" id="kobo.974.1">
        self.collision_avoider = CollisionAvoid(self.distance_sensors)</span></pre><pre class="console">
<strong class="bold"><span class="koboSpan" id="kobo.975.1">        self.last_encoder_left = robot.left_encoder.read()</span></strong></pre><pre class="console">
<strong class="bold"><span class="koboSpan" id="kobo.976.1">        self.last_encoder_right = robot.right_encoder.read()</span></strong></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.977.1">We will use this encoder data in a motion model, moving all our poses with the robot’s motion. </span><span class="koboSpan" id="kobo.977.2">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.978.1">Simulation</span></strong><span class="koboSpan" id="kobo.979.1"> class, we will then add a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.980.1">motion_model</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.981.1"> method:</span></span></p>
<ol>
<li value="5"><span class="koboSpan" id="kobo.982.1">It first gets the latest </span><span class="No-Break"><span class="koboSpan" id="kobo.983.1">encoder readings:</span></span><pre class="console"><span class="koboSpan" id="kobo.984.1">
    def motion_model(self):</span></pre><pre class="console"><span class="koboSpan" id="kobo.985.1">
        new_encoder_left = robot.left_encoder.read()</span></pre><pre class="console"><span class="koboSpan" id="kobo.986.1">
        new_encoder_right = robot.right_encoder.read()</span></pre></li>
<li><span class="koboSpan" id="kobo.987.1">We calculate the deltas and feed these </span><span class="No-Break"><span class="koboSpan" id="kobo.988.1">into </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.989.1">convert_odometry_to_motion</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.990.1">:</span></span><pre class="console"><span class="koboSpan" id="kobo.991.1">
        rot1, trans, rot2 = self.convert_odometry_to_motion(</span></pre><pre class="console"><span class="koboSpan" id="kobo.992.1">
            new_encoder_left - self.last_encoder_left, </span></pre><pre class="console"><span class="koboSpan" id="kobo.993.1">
            new_encoder_right - self.last_encoder_right)</span></pre></li>
<li><span class="koboSpan" id="kobo.994.1">We must update the last encoder readings so that we'll get deltas </span><span class="No-Break"><span class="koboSpan" id="kobo.995.1">next time:</span></span><pre class="console"><span class="koboSpan" id="kobo.996.1">
        self.last_encoder_left = new_encoder_left</span></pre><pre class="console"><span class="koboSpan" id="kobo.997.1">
        self.last_encoder_right = new_encoder_right</span></pre></li>
<li><span class="koboSpan" id="kobo.998.1">Now, we apply these odometry values to </span><span class="No-Break"><span class="koboSpan" id="kobo.999.1">our poses:</span></span><pre class="console"><span class="koboSpan" id="kobo.1000.1">
        self.move_poses(rot1, trans, rot2)</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.1001.1">We now </span><a id="_idIndexMarker779"/><span class="koboSpan" id="kobo.1002.1">need to call this motion model. </span><span class="koboSpan" id="kobo.1002.2">In </span><strong class="source-inline"><span class="koboSpan" id="kobo.1003.1">Simulation.main</span></strong><span class="koboSpan" id="kobo.1004.1">, add the </span><span class="No-Break"><span class="koboSpan" id="kobo.1005.1">highlighted code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1006.1">
            while True:
                await asyncio.sleep(</span><strong class="bold"><span class="koboSpan" id="kobo.1007.1">0.05</span></strong><span class="koboSpan" id="kobo.1008.1">)
</span><strong class="bold"><span class="koboSpan" id="kobo.1009.1">                self.motion_model()</span></strong><span class="koboSpan" id="kobo.1010.1">
                send_poses(self.poses)</span></pre>
<p><span class="koboSpan" id="kobo.1011.1">This will apply the motion model at every cycle before sending the poses. </span><span class="koboSpan" id="kobo.1011.2">Since the motion model requires time to run, the sleep is reduced to compensate, keeping the UART data rate similar. </span><span class="koboSpan" id="kobo.1011.3">Copy the contents of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1012.1">robot</span></strong><span class="koboSpan" id="kobo.1013.1"> folder to Raspberry Pi Pico, and launch the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1014.1">display_from_robot</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1015.1"> app.</span></span></p>
<p><span class="koboSpan" id="kobo.1016.1">When you press </span><strong class="bold"><span class="koboSpan" id="kobo.1017.1">Start</span></strong><span class="koboSpan" id="kobo.1018.1">, you should now see the poses moving as the robot moves around the arena. </span><span class="koboSpan" id="kobo.1018.2">All the poses should follow the same path, but each from a different starting point </span><span class="No-Break"><span class="koboSpan" id="kobo.1019.1">and orientation.</span></span></p>
<p><span class="koboSpan" id="kobo.1020.1">These poses are moving, but the real world is messy, so let’s add randomness </span><span class="No-Break"><span class="koboSpan" id="kobo.1021.1">to this.</span></span></p>
<h2 id="_idParaDest-291"><a id="_idTextAnchor293"/><span class="koboSpan" id="kobo.1022.1">Pose movement probabilities</span></h2>
<p><span class="koboSpan" id="kobo.1023.1">Robot movement is not always certain; although we have encoders, wheels can slip, wheel sizes can </span><a id="_idIndexMarker780"/><span class="koboSpan" id="kobo.1024.1">have minor variations, and our calculations might not be 100% accurate. </span><span class="koboSpan" id="kobo.1024.2">Imagine that the preceding poses are in a cluster or the cloud, and then our robot drives in a particular direction. </span><span class="koboSpan" id="kobo.1024.3">The following diagram should </span><span class="No-Break"><span class="koboSpan" id="kobo.1025.1">demonstrate this:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer206">
<span class="koboSpan" id="kobo.1026.1"><img alt="Figure 13.11 – Movement probability distributions " src="image/Figure_13.11_B18001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1027.1">Figure 13.11 – Movement probability distributions</span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1028.1">Figure 13</span></em></span><em class="italic"><span class="koboSpan" id="kobo.1029.1">.11 (a)</span></em><span class="koboSpan" id="kobo.1030.1"> shows a section of the arena, with arena coordinates shown on the axes. </span><span class="koboSpan" id="kobo.1030.2">The cluster around the point (250,300) is the initial robot pose guesses. </span><span class="koboSpan" id="kobo.1030.3">The thick line and angle arc show a robot movement at 300 mm, bearing 30 degrees. </span><span class="koboSpan" id="kobo.1030.4">However, due to the uncertainties of the motion, the cluster gets spread out. </span><span class="koboSpan" id="kobo.1030.5">The arc shape is due to uncertainty in the angle of the motion, and the width of the arc represents the uncertainty of the forward motion of the robot. </span><span class="koboSpan" id="kobo.1030.6">This banana shape represents where a robot could end up. </span><span class="koboSpan" id="kobo.1030.7">The image </span><a id="_idIndexMarker781"/><span class="koboSpan" id="kobo.1031.1">here has been exaggerated, as the spread on the robot should be far less </span><span class="No-Break"><span class="koboSpan" id="kobo.1032.1">than this.</span></span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1033.1">Figure 13</span></em></span><em class="italic"><span class="koboSpan" id="kobo.1034.1">.11 (b)</span></em><span class="koboSpan" id="kobo.1035.1"> shows how we can model this uncertainty centered around a </span><strong class="bold"><span class="koboSpan" id="kobo.1036.1">mean</span></strong><span class="koboSpan" id="kobo.1037.1"> (average or most likely value) of 0, with a variation on either side. </span><span class="koboSpan" id="kobo.1037.2">A </span><strong class="bold"><span class="koboSpan" id="kobo.1038.1">probability distribution</span></strong><span class="koboSpan" id="kobo.1039.1"> maps how </span><a id="_idIndexMarker782"/><span class="koboSpan" id="kobo.1040.1">likely a value is to come up in a random selection. </span><span class="koboSpan" id="kobo.1040.2">The height of each point signifies how likely a particular value is to come up. </span><span class="koboSpan" id="kobo.1040.3">If we use a uniform distribution, all possibilities between -1.0 and +1.0 are equal, giving us a rectangle shown for </span><em class="italic"><span class="koboSpan" id="kobo.1041.1">n=1</span></em><span class="koboSpan" id="kobo.1042.1">. </span><span class="koboSpan" id="kobo.1042.2">However, we want this distribution centered around the mean. </span><span class="koboSpan" id="kobo.1042.3">If we sum two samples from the uniform distribution from -1.0 to 1.0 and divide by 2, we get the </span><em class="italic"><span class="koboSpan" id="kobo.1043.1">n=2</span></em><span class="koboSpan" id="kobo.1044.1"> graph. </span><span class="koboSpan" id="kobo.1044.2">This is approximately a triangle. </span><span class="koboSpan" id="kobo.1044.3">Here, </span><em class="italic"><span class="koboSpan" id="kobo.1045.1">n</span></em><span class="koboSpan" id="kobo.1046.1"> represents the number of uniform random sample picks we add together. </span><span class="koboSpan" id="kobo.1046.2">We could refine this to the </span><em class="italic"><span class="koboSpan" id="kobo.1047.1">n=4</span></em><span class="koboSpan" id="kobo.1048.1"> curve, using a sum of four uniform samples and dividing by 4; however, the trade-off between ideal curves and the time cost for each uniform distribution sample makes the triangle at </span><em class="italic"><span class="koboSpan" id="kobo.1049.1">n=2</span></em><span class="koboSpan" id="kobo.1050.1"> good enough for our purposes to center </span><span class="No-Break"><span class="koboSpan" id="kobo.1051.1">the distribution.</span></span></p>
<p><span class="koboSpan" id="kobo.1052.1">We will use the </span><em class="italic"><span class="koboSpan" id="kobo.1053.1">n=2</span></em><span class="koboSpan" id="kobo.1054.1"> distribution in our model. </span><span class="koboSpan" id="kobo.1054.2">In </span><strong class="source-inline"><span class="koboSpan" id="kobo.1055.1">robot/code.py</span></strong><span class="koboSpan" id="kobo.1056.1">, add the following piece of code before </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1057.1">class Simulation</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1058.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1059.1">
def get_random_sample(mean, scale):
    return mean + (random.uniform(-scale, scale) + random.uniform(-scale, scale)) / 2</span></pre>
<p><span class="koboSpan" id="kobo.1060.1">This code will add the two samples, scaling the uniform distributions to match how much the model varies, divide by 2, and then add </span><span class="No-Break"><span class="koboSpan" id="kobo.1061.1">the mean.</span></span></p>
<p><span class="koboSpan" id="kobo.1062.1">The other factor we will need to account for is that the larger the movement we make, the larger the random error factor will be. </span><span class="koboSpan" id="kobo.1062.2">A large forward motion will influence the rotation, and large rotations will affect the forward motion (translation). </span><span class="koboSpan" id="kobo.1062.3">It is conventional to refer to the factors for these influences as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1063.1">alpha</span></strong><span class="koboSpan" id="kobo.1064.1">. </span><span class="koboSpan" id="kobo.1064.2">Let’s add these values to our </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1065.1">Simulation.__init__</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1066.1"> class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1067.1">
        self.last_encoder_right = robot.right_encoder.read()
</span><strong class="bold"><span class="koboSpan" id="kobo.1068.1">        self.alpha_rot = 0.09</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1069.1">        self.alpha_rot_trans = 0.05</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1070.1">        self.alpha_trans = 0.12</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1071.1">        self.alpha_trans_rot = 0.05        </span></strong></pre>
<p><span class="koboSpan" id="kobo.1072.1">We have four terms here. </span><span class="koboSpan" id="kobo.1072.2">They should be values between 0 and 1 and kept low. </span><span class="koboSpan" id="kobo.1072.3">The value </span><strong class="source-inline"><span class="koboSpan" id="kobo.1073.1">0.05</span></strong><span class="koboSpan" id="kobo.1074.1"> will represent a 5% error. </span><span class="koboSpan" id="kobo.1074.2">Tune them to reflect the error seen in </span><span class="No-Break"><span class="koboSpan" id="kobo.1075.1">your robot.</span></span></p>
<p><span class="koboSpan" id="kobo.1076.1">We will </span><a id="_idIndexMarker783"/><span class="koboSpan" id="kobo.1077.1">use this to apply randomness to </span><span class="No-Break"><span class="koboSpan" id="kobo.1078.1">our model:</span></span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.1079.1">Add the following method in </span><strong class="source-inline"><span class="koboSpan" id="kobo.1080.1">Simulation</span></strong><span class="koboSpan" id="kobo.1081.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.1082.1">after </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1083.1">move_poses</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1084.1">:</span></span><pre class="console"><span class="koboSpan" id="kobo.1085.1">
    def randomise_motion(self, rot1, trans, rot2):</span></pre></li>
<li><span class="koboSpan" id="kobo.1086.1">Calculate the scaling factors from the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1087.1">alpha</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1088.1"> terms:</span></span><pre class="console"><span class="koboSpan" id="kobo.1089.1">
        rot1_scale = self.alpha_rot * abs(rot1) + self.alpha_rot_trans * abs(trans)</span></pre><pre class="console"><span class="koboSpan" id="kobo.1090.1">
        trans_scale = self.alpha_trans * abs(trans) + self.alpha_trans_rot * (abs(rot1) + abs(rot2))</span></pre><pre class="console"><span class="koboSpan" id="kobo.1091.1">
        rot2_scale = self.alpha_rot * abs(rot2) + self.alpha_rot_trans * abs(trans)</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.1092.1">The rotation scaling factors are based on the absolute value of each element; they must not be negative. </span><span class="koboSpan" id="kobo.1092.2">The rotation scales have both a rotation factor and a lower translation factor. </span><span class="koboSpan" id="kobo.1092.3">The translation scale has a translation factor (usually larger) and a factor based on both rotations. </span></p>
<ol>
<li value="3"><span class="koboSpan" id="kobo.1093.1">We will now use this to generate noise around the motion for </span><span class="No-Break"><span class="koboSpan" id="kobo.1094.1">every pose:</span></span><pre class="console"><span class="koboSpan" id="kobo.1095.1">
        rot1_model = np.array([get_random_sample(rot1, rot1_scale) for _ in range(self.poses.shape[0])])</span></pre><pre class="console"><span class="koboSpan" id="kobo.1096.1">
        trans_model = np.array([get_random_sample(trans, trans_scale) for _ in range(self.poses.shape[0])])</span></pre><pre class="console"><span class="koboSpan" id="kobo.1097.1">
        rot2_model = np.array([get_random_sample(rot2, rot2_scale) for _ in range(self.poses.shape[0])])</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.1098.1">This uses the scaled sample function we created, with our scale factor. </span><span class="koboSpan" id="kobo.1098.2">It uses the calculated rotation or translation as a mean. </span><span class="koboSpan" id="kobo.1098.3">We run this through loops for each pose dimension, so for a population of 200, we will get 200 random samples, centered around the calculated measurement, with variation scaled to the </span><span class="No-Break"><span class="koboSpan" id="kobo.1099.1">calculated factor.</span></span></p>
<ol>
<li value="4"><span class="koboSpan" id="kobo.1100.1">Finally, we return </span><span class="No-Break"><span class="koboSpan" id="kobo.1101.1">these models:</span></span><pre class="console"><span class="koboSpan" id="kobo.1102.1">
        return rot1_model, trans_model, rot2_model</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.1103.1">We now have a model that generates noise in our motion, meaning that it will compensate for the </span><a id="_idIndexMarker784"/><span class="koboSpan" id="kobo.1104.1">inaccuracies in the measurement by modeling the uncertainty in that measurement. </span><span class="koboSpan" id="kobo.1104.2">Add the highlighted code for this to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1105.1">motion_model</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1106.1"> method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1107.1">
    def motion_model(self):
        """Apply the motion model"""
        new_encoder_left = robot.left_encoder.read()
        new_encoder_right = robot.right_encoder.read()
        rot1, trans, rot2 = self.convert_odometry_to_motion(
            new_encoder_left - self.last_encoder_left, 
            new_encoder_right - self.last_encoder_right)
        self.last_encoder_left = new_encoder_left
        self.last_encoder_right = new_encoder_right
</span><strong class="bold"><span class="koboSpan" id="kobo.1108.1">        rot1_model, trans_model, rot2_model = self.randomise_motion(rot1, trans, rot2)</span></strong><span class="koboSpan" id="kobo.1109.1">
        self.move_poses(</span><strong class="bold"><span class="koboSpan" id="kobo.1110.1">rot1_model, trans_model, rot2_model</span></strong><span class="koboSpan" id="kobo.1111.1">)</span></pre>
<p><span class="koboSpan" id="kobo.1112.1">The changes swap the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1113.1">rot1</span></strong><span class="koboSpan" id="kobo.1114.1"> variable out for </span><strong class="source-inline"><span class="koboSpan" id="kobo.1115.1">rot1_model</span></strong><span class="koboSpan" id="kobo.1116.1"> and do a similar swap for the other pose elements. </span><span class="koboSpan" id="kobo.1116.2">As </span><strong class="source-inline"><span class="koboSpan" id="kobo.1117.1">rot1_model</span></strong><span class="koboSpan" id="kobo.1118.1"> has the same number of elements as our poses, passing this into </span><strong class="source-inline"><span class="koboSpan" id="kobo.1119.1">move_poses</span></strong><span class="koboSpan" id="kobo.1120.1"> will add each sample element-wise to the respective pose element. </span><span class="koboSpan" id="kobo.1120.2">This method takes advantage of how </span><strong class="source-inline"><span class="koboSpan" id="kobo.1121.1">NumPy</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1122.1">manipulates lists.</span></span></p>
<p><span class="koboSpan" id="kobo.1123.1">Copy the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1124.1">robot</span></strong><span class="koboSpan" id="kobo.1125.1"> folder to the robot and run the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1126.1">display_from_robot.py</span></strong><span class="koboSpan" id="kobo.1127.1"> app on your computer. </span><span class="koboSpan" id="kobo.1127.2">The motion will be a little randomized. </span><span class="koboSpan" id="kobo.1127.3">Now, let’s check that your robot code is working and behaving </span><span class="No-Break"><span class="koboSpan" id="kobo.1128.1">as expected.</span></span></p>
<h3><span class="koboSpan" id="kobo.1129.1">Troubleshooting</span></h3>
<p><span class="koboSpan" id="kobo.1130.1">If this </span><a id="_idIndexMarker785"/><span class="koboSpan" id="kobo.1131.1">example does not work, try the </span><span class="No-Break"><span class="koboSpan" id="kobo.1132.1">following methods:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1133.1">Run with the robot propped up and connected to the computer so that the Mu editor serial can see its state. </span><span class="koboSpan" id="kobo.1133.2">This will show you whether there are any errors in the code. </span></li>
<li><span class="koboSpan" id="kobo.1134.1">If the movements are too far or too little, adjust the measurements in </span><strong class="source-inline"><span class="koboSpan" id="kobo.1135.1">robot/robot.py</span></strong><span class="koboSpan" id="kobo.1136.1"> to match your robot, as they may vary from </span><span class="No-Break"><span class="koboSpan" id="kobo.1137.1">example values.</span></span></li>
<li><span class="koboSpan" id="kobo.1138.1">If you see sensor or I2C issues, backtrack to check the wiring and previous sensor demonstration examples. </span><span class="koboSpan" id="kobo.1138.2">Also, ensure that you have </span><span class="No-Break"><span class="koboSpan" id="kobo.1139.1">fresh batteries.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1140.1">We now </span><a id="_idIndexMarker786"/><span class="koboSpan" id="kobo.1141.1">have our poses motion model based on the encoders. </span><span class="koboSpan" id="kobo.1141.2">We can now bring the distance sensors and arena data into play with the Monte </span><span class="No-Break"><span class="koboSpan" id="kobo.1142.1">Carlo simulation.</span></span></p>
<h1 id="_idParaDest-292"><a id="_idTextAnchor294"/><span class="koboSpan" id="kobo.1143.1">Monte Carlo localization</span></h1>
<p><span class="koboSpan" id="kobo.1144.1">Our robot’s poses are going outside of the arena, and the distance sensor readings should show which </span><a id="_idIndexMarker787"/><span class="koboSpan" id="kobo.1145.1">guesses (poses) are more likely than others. </span><span class="koboSpan" id="kobo.1145.2">The </span><strong class="bold"><span class="koboSpan" id="kobo.1146.1">Monte Carlo</span></strong><span class="koboSpan" id="kobo.1147.1"> simulation can improve these guesses, based on the sensor-reading likelihood. </span></p>
<p><span class="koboSpan" id="kobo.1148.1">The simulation moves the poses and then observes the state of the sensors to create weights based on </span><a id="_idIndexMarker788"/><span class="koboSpan" id="kobo.1149.1">their likelihood, a process known as the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1150.1">observation model</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1151.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1152.1">The simulation </span><strong class="bold"><span class="koboSpan" id="kobo.1153.1">resamples</span></strong><span class="koboSpan" id="kobo.1154.1"> the guesses by picking them, so those with higher weights are more likely. </span><span class="koboSpan" id="kobo.1154.2">The result is a new generation of guesses. </span><span class="koboSpan" id="kobo.1154.3">This movement of particles followed by filtering is </span><a id="_idIndexMarker789"/><span class="koboSpan" id="kobo.1155.1">why this is also known as a </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1156.1">particle filter</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1157.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1158.1">Let’s start by giving our poses weights, based on being inside or outside the arena, and then we’ll look at how to resample </span><span class="No-Break"><span class="koboSpan" id="kobo.1159.1">from this.</span></span></p>
<h2 id="_idParaDest-293"><a id="_idTextAnchor295"/><span class="koboSpan" id="kobo.1160.1">Generating pose weights from a position</span></h2>
<p><span class="koboSpan" id="kobo.1161.1">The initial </span><a id="_idIndexMarker790"/><span class="koboSpan" id="kobo.1162.1">weight generation can be based on a simple question – is the robot inside the arena or not? </span><span class="koboSpan" id="kobo.1162.2">If not, then we can reduce the pose probability. </span><span class="koboSpan" id="kobo.1162.3">Note that we don’t eliminate these, as the robot could have been placed outside the arena map or been tested on your desk. </span><span class="koboSpan" id="kobo.1162.4">We will just give them a lower probability than those that are inside </span><span class="No-Break"><span class="koboSpan" id="kobo.1163.1">the arena.</span></span></p>
<p><span class="koboSpan" id="kobo.1164.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1165.1">robot/arena.py</span></strong><span class="koboSpan" id="kobo.1166.1"> file, do </span><span class="No-Break"><span class="koboSpan" id="kobo.1167.1">the following:</span></span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.1168.1">We can add a value to indicate a very low probability – close to but </span><span class="No-Break"><span class="koboSpan" id="kobo.1169.1">not zero:</span></span><pre class="console"><span class="koboSpan" id="kobo.1170.1">
low_probability = 10 ** -10</span></pre></li>
<li><span class="koboSpan" id="kobo.1171.1">Add a function to check whether the arena contains </span><span class="No-Break"><span class="koboSpan" id="kobo.1172.1">a point:</span></span><pre class="console"><span class="koboSpan" id="kobo.1173.1">
def contains(x, y):</span></pre></li>
<li><span class="koboSpan" id="kobo.1174.1">First, check whether the point’s outside the </span><span class="No-Break"><span class="koboSpan" id="kobo.1175.1">arena rectangle:</span></span><pre class="console"><span class="koboSpan" id="kobo.1176.1">
  if x &lt; 0 or x &gt; width \</span></pre><pre class="console"><span class="koboSpan" id="kobo.1177.1">
    or y &lt; 0 or y &gt; height:</span></pre><pre class="console"><span class="koboSpan" id="kobo.1178.1">
    return False</span></pre></li>
<li><span class="koboSpan" id="kobo.1179.1">Then, we check whether it’s in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1180.1">cutout section:</span></span><pre class="console"><span class="koboSpan" id="kobo.1181.1">
  if x &gt; (width - cutout_width) and y &lt; cutout_height:</span></pre><pre class="console"><span class="koboSpan" id="kobo.1182.1">
    return False</span></pre></li>
<li><span class="koboSpan" id="kobo.1183.1">Otherwise, this point is in </span><span class="No-Break"><span class="koboSpan" id="kobo.1184.1">the arena:</span></span><pre class="console"><span class="koboSpan" id="kobo.1185.1">
  return True</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.1186.1">We can </span><a id="_idIndexMarker791"/><span class="koboSpan" id="kobo.1187.1">then add an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1188.1">observation_model</span></strong><span class="koboSpan" id="kobo.1189.1"> method to our </span><strong class="source-inline"><span class="koboSpan" id="kobo.1190.1">robot/code.py</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.1191.1">Simulation</span></strong><span class="koboSpan" id="kobo.1192.1"> class to generate </span><span class="No-Break"><span class="koboSpan" id="kobo.1193.1">the weights:</span></span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.1194.1">We set up the weights to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1195.1">ones</span></strong><span class="koboSpan" id="kobo.1196.1">, with a weight </span><span class="No-Break"><span class="koboSpan" id="kobo.1197.1">per pose:</span></span><pre class="console"><span class="koboSpan" id="kobo.1198.1">
    def observation_model(self):</span></pre><pre class="console"><span class="koboSpan" id="kobo.1199.1">
        weights = np.ones(self.poses.shape[0], dtype=np.float)</span></pre></li>
<li><span class="koboSpan" id="kobo.1200.1">We can then loop over the poses, lowering the weights of those outside </span><span class="No-Break"><span class="koboSpan" id="kobo.1201.1">the arena:</span></span><pre class="console"><span class="koboSpan" id="kobo.1202.1">
        for index, pose in enumerate(self.poses):</span></pre><pre class="console"><span class="koboSpan" id="kobo.1203.1">
            if not arena.contains(pose[0], pose[1]):</span></pre><pre class="console"><span class="koboSpan" id="kobo.1204.1">
                weights[index] = arena.low_probability</span></pre></li>
<li><span class="koboSpan" id="kobo.1205.1">We then return </span><span class="No-Break"><span class="koboSpan" id="kobo.1206.1">the weights:</span></span><pre class="console"><span class="koboSpan" id="kobo.1207.1">
        return weights</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.1208.1">At this point, the weights aren’t being used. </span><span class="koboSpan" id="kobo.1208.2">We will need to resample them for them to act on </span><span class="No-Break"><span class="koboSpan" id="kobo.1209.1">the poses.</span></span></p>
<h2 id="_idParaDest-294"><a id="_idTextAnchor296"/><span class="koboSpan" id="kobo.1210.1">Resampling the poses</span></h2>
<p><span class="koboSpan" id="kobo.1211.1">As we </span><a id="_idIndexMarker792"/><span class="koboSpan" id="kobo.1212.1">step through the Monte Carlo simulation on the robot, we would like a subsequent generation of particles to favor more likely poses. </span><span class="koboSpan" id="kobo.1212.2">We are going to use a technique illustrated in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1213.1">following diagram:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer207">
<span class="koboSpan" id="kobo.1214.1"><img alt="Figure 13.12 – Low variance resampling " src="image/Figure_13.12_B18001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1215.1">Figure 13.12 – Low variance resampling</span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1216.1">Figure 13</span></em></span><em class="italic"><span class="koboSpan" id="kobo.1217.1">.12</span></em><span class="koboSpan" id="kobo.1218.1"> starts with </span><strong class="bold"><span class="koboSpan" id="kobo.1219.1">Weighted Sample Space</span></strong><span class="koboSpan" id="kobo.1220.1">, a number line between 0 and the sum of all </span><a id="_idIndexMarker793"/><span class="koboSpan" id="kobo.1221.1">weights. </span><span class="koboSpan" id="kobo.1221.2">Below this is a bar representing 10 samples (named </span><em class="italic"><span class="koboSpan" id="kobo.1222.1">a</span></em><span class="koboSpan" id="kobo.1223.1"> to </span><em class="italic"><span class="koboSpan" id="kobo.1224.1">j</span></em><span class="koboSpan" id="kobo.1225.1">) in a sample space. </span><span class="koboSpan" id="kobo.1225.2">The weights of these samples are represented by their widths. </span><span class="koboSpan" id="kobo.1225.3">The shading highlights the </span><span class="No-Break"><span class="koboSpan" id="kobo.1226.1">different samples.</span></span></p>
<p><span class="koboSpan" id="kobo.1227.1">In the diagram, we generate a new space with five samples </span><em class="italic"><span class="koboSpan" id="kobo.1228.1">(n=5</span></em><span class="koboSpan" id="kobo.1229.1">). </span><span class="koboSpan" id="kobo.1229.2">This number could be the same as </span><a id="_idIndexMarker794"/><span class="koboSpan" id="kobo.1230.1">the original space (for generating a new generation), may have a smaller number for sending via BLE, and may have a larger number </span><span class="No-Break"><span class="koboSpan" id="kobo.1231.1">for interpolating.</span></span></p>
<p><span class="koboSpan" id="kobo.1232.1">Resampling the original set starts by dividing the total sum by the number of new samples, which will give a sample interval size of </span><em class="italic"><span class="koboSpan" id="kobo.1233.1">sum/n</span></em><span class="koboSpan" id="kobo.1234.1">, shown as </span><strong class="bold"><span class="koboSpan" id="kobo.1235.1">Sample intervals</span></strong><span class="koboSpan" id="kobo.1236.1">. </span><span class="koboSpan" id="kobo.1236.2">We then generate a single uniform random number between 0 and </span><em class="italic"><span class="koboSpan" id="kobo.1237.1">sum/n</span></em><span class="koboSpan" id="kobo.1238.1">, which will shift </span><span class="No-Break"><span class="koboSpan" id="kobo.1239.1">the intervals.</span></span></p>
<p><span class="koboSpan" id="kobo.1240.1">We can then look at the weighted sample space and pick out the sample that matches the start of each interval – this is the </span><strong class="bold"><span class="koboSpan" id="kobo.1241.1">weight index</span></strong><span class="koboSpan" id="kobo.1242.1">. </span><span class="koboSpan" id="kobo.1242.2">This will produce </span><strong class="bold"><span class="koboSpan" id="kobo.1243.1">New sample space</span></strong><span class="koboSpan" id="kobo.1244.1">. </span><span class="koboSpan" id="kobo.1244.2">Note that sample </span><em class="italic"><span class="koboSpan" id="kobo.1245.1">c</span></em><span class="koboSpan" id="kobo.1246.1">, which has the highest weight, gets sampled more times. </span><span class="koboSpan" id="kobo.1246.2">With larger sample populations, the resampled space will more accurately resemble </span><span class="No-Break"><span class="koboSpan" id="kobo.1247.1">the original.</span></span></p>
<p><span class="koboSpan" id="kobo.1248.1">The new samples do not have weights and are all considered equally weighted, but some samples appear multiple times to represent their previous weight. </span></p>
<p><span class="koboSpan" id="kobo.1249.1">This technique </span><a id="_idIndexMarker795"/><span class="koboSpan" id="kobo.1250.1">of using random shifted intervals is </span><a id="_idIndexMarker796"/><span class="koboSpan" id="kobo.1251.1">known as the </span><strong class="bold"><span class="koboSpan" id="kobo.1252.1">low variance resampling</span></strong><span class="koboSpan" id="kobo.1253.1"> method. </span><span class="koboSpan" id="kobo.1253.2">We will now see how to perform this </span><span class="No-Break"><span class="koboSpan" id="kobo.1254.1">through code:</span></span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.1255.1">In </span><strong class="source-inline"><span class="koboSpan" id="kobo.1256.1">robot/code.py</span></strong><span class="koboSpan" id="kobo.1257.1">, inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1258.1">Simulation</span></strong><span class="koboSpan" id="kobo.1259.1"> class, add </span><span class="No-Break"><span class="koboSpan" id="kobo.1260.1">the following:</span></span><pre class="console"><span class="koboSpan" id="kobo.1261.1">
    def resample(self, weights, sample_count):</span></pre><pre class="console"><span class="koboSpan" id="kobo.1262.1">
        samples = np.zeros((sample_count, 3))</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.1263.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1264.1">weights</span></strong><span class="koboSpan" id="kobo.1265.1"> variable refers to the list of weights, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1266.1">sample_count</span></strong><span class="koboSpan" id="kobo.1267.1"> refers to the number of samples to get. </span><span class="koboSpan" id="kobo.1267.2">This method will sample new poses from the poses array. </span><span class="koboSpan" id="kobo.1267.3">We will set up a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1268.1">samples</span></strong><span class="koboSpan" id="kobo.1269.1"> variable to hold the </span><span class="No-Break"><span class="koboSpan" id="kobo.1270.1">new samples.</span></span></p>
<ol>
<li value="2"><span class="koboSpan" id="kobo.1271.1">Next, we set up the interval size based </span><span class="No-Break"><span class="koboSpan" id="kobo.1272.1">on </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1273.1">sample_count</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1274.1">:</span></span><pre class="console"><span class="koboSpan" id="kobo.1275.1">
        interval = np.sum(weights) / sample_count</span></pre><pre class="console"><span class="koboSpan" id="kobo.1276.1">
        shift = random.uniform(0, interval)</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.1277.1">We can use that to set the interval </span><strong class="source-inline"><span class="koboSpan" id="kobo.1278.1">shift</span></strong><span class="koboSpan" id="kobo.1279.1"> value – the </span><span class="No-Break"><span class="koboSpan" id="kobo.1280.1">start position.</span></span></p>
<ol>
<li value="3"><span class="koboSpan" id="kobo.1281.1">We are going to store the cumulative weights while we loop through the original samples (poses). </span><span class="koboSpan" id="kobo.1281.2">We will also store an index in the source </span><span class="No-Break"><span class="koboSpan" id="kobo.1282.1">sample set:</span></span><pre class="console"><span class="koboSpan" id="kobo.1283.1">
        cumulative_weights = weights[0]</span></pre><pre class="console"><span class="koboSpan" id="kobo.1284.1">
        source_index = 0</span></pre></li>
<li><span class="koboSpan" id="kobo.1285.1">The code will loop until we have the expected number of samples. </span><span class="koboSpan" id="kobo.1285.2">For each sample, there is a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1286.1">weight_index</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1287.1"> parameter:</span></span><pre class="console"><span class="koboSpan" id="kobo.1288.1">
        for current_index in range(sample_count):</span></pre><pre class="console"><span class="koboSpan" id="kobo.1289.1">
            weight_index = shift + current_index * interval</span></pre></li>
<li><span class="koboSpan" id="kobo.1290.1">We now start adding up weights from the source samples in </span><strong class="source-inline"><span class="koboSpan" id="kobo.1291.1">cumulative_weights</span></strong><span class="koboSpan" id="kobo.1292.1">, until they meet the </span><span class="No-Break"><span class="koboSpan" id="kobo.1293.1">weight index:</span></span><pre class="console"><span class="koboSpan" id="kobo.1294.1">
            while weight_index &gt; cumulative_weights:</span></pre><pre class="console"><span class="koboSpan" id="kobo.1295.1">
                source_index += 1</span></pre><pre class="console"><span class="koboSpan" id="kobo.1296.1">
                source_index = min(len(weights) - 1, source_index)</span></pre><pre class="console"><span class="koboSpan" id="kobo.1297.1">
                cumulative_weights += weights[source_index]</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.1298.1">We keep track of the source sample index that met this </span><span class="No-Break"><span class="koboSpan" id="kobo.1299.1">weight requirement.</span></span></p>
<ol>
<li value="6"><span class="koboSpan" id="kobo.1300.1">We can use this </span><strong class="source-inline"><span class="koboSpan" id="kobo.1301.1">source_index</span></strong><span class="koboSpan" id="kobo.1302.1"> to add a sample to </span><span class="No-Break"><span class="koboSpan" id="kobo.1303.1">our set:</span></span><pre class="console"><span class="koboSpan" id="kobo.1304.1">
            samples[current_index] = self.poses[source_index]</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.1305.1">This will drop out of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1306.1">while</span></strong><span class="koboSpan" id="kobo.1307.1"> loop and be the end of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1308.1">for</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1309.1"> loop.</span></span></p>
<ol>
<li value="7"><span class="koboSpan" id="kobo.1310.1">Finally, we return the new set </span><span class="No-Break"><span class="koboSpan" id="kobo.1311.1">of samples:</span></span><pre class="console"><span class="koboSpan" id="kobo.1312.1">
        return samples</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.1313.1">We can </span><a id="_idIndexMarker797"/><span class="koboSpan" id="kobo.1314.1">also increase our population, while sending only a subset. </span><span class="koboSpan" id="kobo.1314.2">In </span><strong class="source-inline"><span class="koboSpan" id="kobo.1315.1">Simulation.__init__</span></strong><span class="koboSpan" id="kobo.1316.1">, change the </span><span class="No-Break"><span class="koboSpan" id="kobo.1317.1">population size:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1318.1">
    def __init__(self):
        self.population_size = </span><strong class="bold"><span class="koboSpan" id="kobo.1319.1">200</span></strong></pre>
<p><span class="koboSpan" id="kobo.1320.1">We are limiting the population size here due to Pico </span><span class="No-Break"><span class="koboSpan" id="kobo.1321.1">memory constraints.</span></span></p>
<p><span class="koboSpan" id="kobo.1322.1">We can then apply our observation model in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1323.1">main</span></strong><span class="koboSpan" id="kobo.1324.1"> loop (</span><span class="No-Break"><span class="koboSpan" id="kobo.1325.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1326.1">Simulation.main</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1327.1">):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1328.1">
            while True:
</span><strong class="bold"><span class="koboSpan" id="kobo.1329.1">                weights = self.observation_model()</span></strong><span class="koboSpan" id="kobo.1330.1">
                send_poses(</span><strong class="bold"><span class="koboSpan" id="kobo.1331.1">self.resample(weights, 20)</span></strong><span class="koboSpan" id="kobo.1332.1">)
</span><strong class="bold"><span class="koboSpan" id="kobo.1333.1">                self.poses = self.resample(weights, self.population_size)</span></strong><span class="koboSpan" id="kobo.1334.1">
                await asyncio.sleep(0.05)
                self.motion_model()</span></pre>
<p><span class="koboSpan" id="kobo.1335.1">In our loop, we use the observation model to get weights for the poses. </span><span class="koboSpan" id="kobo.1335.2">We use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1336.1">resample</span></strong><span class="koboSpan" id="kobo.1337.1"> method to get 20 poses to send. </span><span class="koboSpan" id="kobo.1337.2">We then use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1338.1">resample</span></strong><span class="koboSpan" id="kobo.1339.1"> again to get a new population of poses. </span><span class="koboSpan" id="kobo.1339.2">The cycle of updating our poses, observing their state, weighting the poses, and then </span><a id="_idIndexMarker798"/><span class="koboSpan" id="kobo.1340.1">resampling them is known as a </span><strong class="bold"><span class="koboSpan" id="kobo.1341.1">recursive </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1342.1">Bayes filter</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1343.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1344.1">If you send the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1345.1">robot</span></strong><span class="koboSpan" id="kobo.1346.1"> folder to Raspberry Pi Pico and launch the app, you should start seeing the number of samples outside the arena being reduced. </span><span class="koboSpan" id="kobo.1346.2">They will jump around, since we are sampling 20 from a larger set </span><span class="No-Break"><span class="koboSpan" id="kobo.1347.1">of 200.</span></span></p>
<p><span class="koboSpan" id="kobo.1348.1">The system </span><a id="_idIndexMarker799"/><span class="koboSpan" id="kobo.1349.1">reduces the sample space to those that are more likely. </span><span class="koboSpan" id="kobo.1349.2">However, we can include distance sensors to improve </span><span class="No-Break"><span class="koboSpan" id="kobo.1350.1">this process.</span></span></p>
<h2 id="_idParaDest-295"><a id="_idTextAnchor297"/><span class="koboSpan" id="kobo.1351.1">Incorporating distance sensors</span></h2>
<p><span class="koboSpan" id="kobo.1352.1">Our robot has </span><a id="_idIndexMarker800"/><span class="koboSpan" id="kobo.1353.1">two distance sensors. </span><span class="koboSpan" id="kobo.1353.2">Our code will check </span><a id="_idIndexMarker801"/><span class="koboSpan" id="kobo.1354.1">distances the robot senses against model data. </span><span class="koboSpan" id="kobo.1354.2">If each pose is an imaginary map pin, then the distance to the nearest obstacle would be a string stretched out from this pin, or a sensor beam with a sensed </span><a id="_idIndexMarker802"/><span class="koboSpan" id="kobo.1355.1">endpoint – the </span><strong class="bold"><span class="koboSpan" id="kobo.1356.1">beam endpoint model</span></strong><span class="koboSpan" id="kobo.1357.1">. </span><span class="koboSpan" id="kobo.1357.2">With 200 poses, this could be slow. </span><span class="koboSpan" id="kobo.1357.3">Let’s see a faster method to </span><span class="No-Break"><span class="koboSpan" id="kobo.1358.1">model them.</span></span></p>
<h3><span class="koboSpan" id="kobo.1359.1">Modeling distance sensors in our space</span></h3>
<p><span class="koboSpan" id="kobo.1360.1">One way </span><a id="_idIndexMarker803"/><span class="koboSpan" id="kobo.1361.1">we could do this is to take an estimate of the robot’s position, and then perform the math needed to get the distance to the nearest obstacle. </span><span class="koboSpan" id="kobo.1361.2">However, we can make a lookup table to </span><span class="No-Break"><span class="koboSpan" id="kobo.1362.1">simplify this.</span></span></p>
<p><span class="koboSpan" id="kobo.1363.1">Let’s look at the </span><span class="No-Break"><span class="koboSpan" id="kobo.1364.1">following diagram:</span></span></p>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"> </p>
<div>
<div class="IMG---Figure" id="_idContainer208">
<span class="koboSpan" id="kobo.1365.1"><img alt="Figure 13.13 – Distance representation " src="image/Figure_13.13_B18001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1366.1">Figure 13.13 – Distance representation</span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1367.1">Figure 13</span></em></span><em class="italic"><span class="koboSpan" id="kobo.1368.1">.13 (a) </span></em><span class="koboSpan" id="kobo.1369.1">shows a </span><strong class="bold"><span class="koboSpan" id="kobo.1370.1">likelihood field</span></strong><span class="koboSpan" id="kobo.1371.1"> based on distance. </span><span class="koboSpan" id="kobo.1371.2">The white dot is the endpoint at the </span><a id="_idIndexMarker804"/><span class="koboSpan" id="kobo.1372.1">distance reading from the distance sensor. </span><span class="koboSpan" id="kobo.1372.2">The bright middle line of this grid represents an arena wall. </span><span class="koboSpan" id="kobo.1372.3">Each grid square has a value between 0 and 1 (shown as brightness), representing how likely a sensed distance projected here is to have detected the wall. </span><span class="koboSpan" id="kobo.1372.4">Instead of asking the question, </span><em class="italic"><span class="koboSpan" id="kobo.1373.1">Is this distance measurement a match?</span></em><span class="koboSpan" id="kobo.1374.1">, we can ask, </span><em class="italic"><span class="koboSpan" id="kobo.1375.1">How likely is this distance sensor a match?</span></em><span class="koboSpan" id="kobo.1376.1"> We can calculate this grid once only when the system starts up, so other code can make fast lookups into the grid to check for sensor readings. </span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1377.1">Figure 13</span></em></span><em class="italic"><span class="koboSpan" id="kobo.1378.1">.13 (b)</span></em><span class="koboSpan" id="kobo.1379.1"> shows how the likelihood changes, with a distance from 0 to 1,500 in a decaying function. </span><span class="koboSpan" id="kobo.1379.2">The </span><em class="italic"><span class="koboSpan" id="kobo.1380.1">Y</span></em><span class="koboSpan" id="kobo.1381.1"> axis shows the likelihood of it being a hit. </span><span class="koboSpan" id="kobo.1381.2">The dashed vertical line is a value, currently 250, at the inflection point, at which the curve changes direction. </span><span class="koboSpan" id="kobo.1381.3">A smaller inflection point makes a tighter curve; a larger value makes a </span><span class="No-Break"><span class="koboSpan" id="kobo.1382.1">wider curve.</span></span></p>
<p><span class="koboSpan" id="kobo.1383.1">Let’s import </span><strong class="source-inline"><span class="koboSpan" id="kobo.1384.1">numpy</span></strong><span class="koboSpan" id="kobo.1385.1"> at the top </span><span class="No-Break"><span class="koboSpan" id="kobo.1386.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1387.1">robot/arena.py</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1388.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1389.1">
from ulab import numpy as np</span></pre>
<p><span class="koboSpan" id="kobo.1390.1">We will convert </span><a id="_idIndexMarker805"/><span class="koboSpan" id="kobo.1391.1">these values to a grid of 50 mm</span><span class="superscript"><span class="koboSpan" id="kobo.1392.1">2</span></span><span class="koboSpan" id="kobo.1393.1"> cells. </span><span class="koboSpan" id="kobo.1393.2">As some poses will have distance endpoints outside the boundary, we’ll give the grid an overscan. </span><span class="koboSpan" id="kobo.1393.3">Extend the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1394.1">robot/arena.py</span></strong><span class="koboSpan" id="kobo.1395.1"> library with </span><span class="No-Break"><span class="koboSpan" id="kobo.1396.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1397.1">
grid_cell_size = 50
overscan = 2</span></pre>
<p><span class="koboSpan" id="kobo.1398.1">We’ll start with how we get the distance to a grid square. </span><span class="koboSpan" id="kobo.1398.2">In </span><strong class="source-inline"><span class="koboSpan" id="kobo.1399.1">robot/arena.py</span></strong><span class="koboSpan" id="kobo.1400.1">, after defining </span><strong class="source-inline"><span class="koboSpan" id="kobo.1401.1">boundary_lines</span></strong><span class="koboSpan" id="kobo.1402.1">, add </span><span class="No-Break"><span class="koboSpan" id="kobo.1403.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1404.1">
def get_distance_to_segment(x, y, segment):
    x1, y1 = segment[0]
    x2, y2 = segment[1]
    if y1 == y2 and x &gt;= min(x1, x2) and x &lt;= max(x1, x2):
        return abs(y - y1)
    if x1 == x2 and y &gt;= min(y1, y2) and y &lt;= max(y1, y2):
        return abs(x - x1)
    return np.sqrt(
        min(
            (x - x1) ** 2 + (y - y1) ** 2, 
            (x - x2) ** 2 + (y - y2) ** 2
        )
    )</span></pre>
<p><span class="koboSpan" id="kobo.1405.1">The code unpacks the line segment into </span><strong class="source-inline"><span class="koboSpan" id="kobo.1406.1">x1</span></strong><span class="koboSpan" id="kobo.1407.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1408.1">y1</span></strong><span class="koboSpan" id="kobo.1409.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1410.1">x2</span></strong><span class="koboSpan" id="kobo.1411.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1412.1">y2</span></strong><span class="koboSpan" id="kobo.1413.1">. </span><span class="koboSpan" id="kobo.1413.2">It then checks whether the line is horizontal (the same </span><em class="italic"><span class="koboSpan" id="kobo.1414.1">Y</span></em><span class="koboSpan" id="kobo.1415.1">), and whether the point being checked is above or below it; this allows a shortcut by subtracting the </span><em class="italic"><span class="koboSpan" id="kobo.1416.1">Y</span></em><span class="koboSpan" id="kobo.1417.1"> values. </span><span class="koboSpan" id="kobo.1417.2">The code can repeat this for </span><span class="No-Break"><span class="koboSpan" id="kobo.1418.1">vertical lines.</span></span></p>
<p><span class="koboSpan" id="kobo.1419.1">The code then uses Pythagoras’ theorem, where the resulting distance will be the hypotenuse. </span></p>
<p><span class="koboSpan" id="kobo.1420.1">We will convert </span><a id="_idIndexMarker806"/><span class="koboSpan" id="kobo.1421.1">distances into likelihoods with a decaying function, which will return a lower value as we get further from zero. </span><span class="koboSpan" id="kobo.1421.2">The following function will, for a specific point, find the nearest segment distance and then apply a decaying function </span><span class="No-Break"><span class="koboSpan" id="kobo.1422.1">to it:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1423.1">
def get_distance_likelihood(x, y):
    min_distance = None
    for segment in boundary_lines:
        distance = get_distance_to_segment(x, y, segment)
        if min_distance is None or distance &lt; min_distance:
            min_distance = distance
    return 1.0 / (1 + min_distance/100) ** 2</span></pre>
<p><span class="koboSpan" id="kobo.1424.1">We can make a function to generate this grid. </span><span class="koboSpan" id="kobo.1424.2">It starts by making a 2D array of float fields filled with zeros to hold the </span><span class="No-Break"><span class="koboSpan" id="kobo.1425.1">grid values:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1426.1">
def make_distance_grid():
    grid = np.zeros((
            width // grid_cell_size + 2 * overscan, 
            height // grid_cell_size + 2 * overscan
        ), dtype=np.float)</span></pre>
<p><span class="koboSpan" id="kobo.1427.1">The width of the grid in cells is the width of the arena divided by the cell sizes. </span><span class="koboSpan" id="kobo.1427.2">We then add in the overscan for either side of the arena. </span><span class="koboSpan" id="kobo.1427.3">The height uses a </span><span class="No-Break"><span class="koboSpan" id="kobo.1428.1">similar calculation.</span></span></p>
<p><span class="koboSpan" id="kobo.1429.1">We then loop over the grid rows and columns to fill in the cell data: </span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1430.1">
    for x in range(grid.shape[0]):
        column_x = x * grid_cell_size - (overscan * grid_cell_size)
        for y in range(grid.shape[1]):
            row_y = y * grid_cell_size - (overscan * grid_cell_size)
            grid[x, y] = get_distance_likelihood(
                column_x, row_y
            )
    return grid distance_grid = make_distance_grid()</span></pre>
<p><span class="koboSpan" id="kobo.1431.1">This loop gets </span><a id="_idIndexMarker807"/><span class="koboSpan" id="kobo.1432.1">the arena </span><em class="italic"><span class="koboSpan" id="kobo.1433.1">X</span></em><span class="koboSpan" id="kobo.1434.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.1435.1">Y</span></em><span class="koboSpan" id="kobo.1436.1"> coordinates for each cell and uses the coordinates to fetch the likelihood at that position, storing it in the grid. </span><span class="koboSpan" id="kobo.1436.2">We call this function and store the result in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1437.1">distance_grid</span></strong><span class="koboSpan" id="kobo.1438.1"> variable so that this calculation will run when the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1439.1">arena.py</span></strong><span class="koboSpan" id="kobo.1440.1"> file is imported. </span><span class="koboSpan" id="kobo.1440.2">The calculated distance grid looks like the </span><span class="No-Break"><span class="koboSpan" id="kobo.1441.1">following diagram:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer209">
<span class="koboSpan" id="kobo.1442.1"><img alt="Figure 13.14 – The distance-based likelihood field " src="image/Figure_13.14_B18001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1443.1">Figure 13.14 – The distance-based likelihood field</span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1444.1">Figure 13</span></em></span><em class="italic"><span class="koboSpan" id="kobo.1445.1">.14</span></em><span class="koboSpan" id="kobo.1446.1"> shows the distance-based likelihood field. </span></p>
<p><span class="koboSpan" id="kobo.1447.1">The overscan extends to -500 mm and 2,000 mm, and the boundary lines are drawn in black. </span><span class="koboSpan" id="kobo.1447.2">Each cell’s value is based on its </span><span class="No-Break"><span class="koboSpan" id="kobo.1448.1">bottom-left coordinate.</span></span></p>
<p><span class="koboSpan" id="kobo.1449.1">We can now use this likelihood field in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1450.1">observation model.</span></span></p>
<h3><span class="koboSpan" id="kobo.1451.1">Generating weights from the distance sensors</span></h3>
<p><span class="koboSpan" id="kobo.1452.1">For each pose, we will need to project the sensed distances from the sensor positions. </span><span class="koboSpan" id="kobo.1452.2">See the </span><span class="No-Break"><span class="koboSpan" id="kobo.1453.1">following diagram:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer210">
<span class="koboSpan" id="kobo.1454.1"><img alt="Figure 13.15 – Distance sensor geometry " src="image/Figure_13.15_B18001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1455.1">Figure 13.15 – Distance sensor geometry</span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1456.1">Figure 13</span></em></span><em class="italic"><span class="koboSpan" id="kobo.1457.1">.15 (1)</span></em><span class="koboSpan" id="kobo.1458.1"> shows poses </span><em class="italic"><span class="koboSpan" id="kobo.1459.1">A</span></em><span class="koboSpan" id="kobo.1460.1">, </span><em class="italic"><span class="koboSpan" id="kobo.1461.1">B</span></em><span class="koboSpan" id="kobo.1462.1">, and </span><em class="italic"><span class="koboSpan" id="kobo.1463.1">C</span></em><span class="koboSpan" id="kobo.1464.1"> as dots, with an arrow showing their heading. </span><span class="koboSpan" id="kobo.1464.2">There are </span><a id="_idIndexMarker808"/><span class="koboSpan" id="kobo.1465.1">dark bars representing the location of the two distance sensors relative to the pose – they stick out to the side and forward. </span><span class="koboSpan" id="kobo.1465.2">From this location, we will have sensor readings, represented by the arrows pointing from the front of </span><span class="No-Break"><span class="koboSpan" id="kobo.1466.1">the bars.</span></span></p>
<p><span class="koboSpan" id="kobo.1467.1">By projecting the sensor distances against the likelihood field, we can see that pose B is a more likely match than pose C, with A as the least likely </span><span class="No-Break"><span class="koboSpan" id="kobo.1468.1">pose here.</span></span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1469.1">Figure 13</span></em></span><em class="italic"><span class="koboSpan" id="kobo.1470.1">.15 (2)</span></em><span class="koboSpan" id="kobo.1471.1"> shows how we can project the sensors. </span><em class="italic"><span class="koboSpan" id="kobo.1472.1">Ds</span></em><span class="koboSpan" id="kobo.1473.1"> is how far the distance sensor goes out to the side (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1474.1">dist_side_mm</span></strong><span class="koboSpan" id="kobo.1475.1"> in the code). </span><em class="italic"><span class="koboSpan" id="kobo.1476.1">Df</span></em><span class="koboSpan" id="kobo.1477.1"> is how far forward the sensors are from the robot wheels (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1478.1">dist_forward_mm</span></strong><span class="koboSpan" id="kobo.1479.1">). </span><em class="italic"><span class="koboSpan" id="kobo.1480.1">Dr</span></em><span class="koboSpan" id="kobo.1481.1"> is the distance sensed, from </span><em class="italic"><span class="koboSpan" id="kobo.1482.1">Df</span></em><span class="koboSpan" id="kobo.1483.1">. </span><span class="koboSpan" id="kobo.1483.2">We will have to add this to every pose. </span><span class="koboSpan" id="kobo.1483.3">Pre-calculating a triangle from the sensed distance makes this a little easier. </span><em class="italic"><span class="koboSpan" id="kobo.1484.1">θ</span></em><span class="koboSpan" id="kobo.1485.1"> is the robot’s heading. </span><span class="koboSpan" id="kobo.1485.2">Using the </span><em class="italic"><span class="koboSpan" id="kobo.1486.1">SOHCAHTOA</span></em><span class="koboSpan" id="kobo.1487.1"> mnemonic, we can get </span><em class="italic"><span class="koboSpan" id="kobo.1488.1">θr</span></em><span class="koboSpan" id="kobo.1489.1">, the angle from the robots heading to the right sensor, and using Pythagoras’ theorem, we can get </span><em class="italic"><span class="koboSpan" id="kobo.1490.1">Hr</span></em><span class="koboSpan" id="kobo.1491.1">, the hypotenuse. </span><span class="koboSpan" id="kobo.1491.2">The adjacent side will be </span><em class="italic"><span class="koboSpan" id="kobo.1492.1">Df</span></em><span class="koboSpan" id="kobo.1493.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.1494.1">Dr</span></em><span class="koboSpan" id="kobo.1495.1">, and the opposite </span><em class="italic"><span class="koboSpan" id="kobo.1496.1">Ds</span></em><span class="koboSpan" id="kobo.1497.1">. </span><span class="koboSpan" id="kobo.1497.2">We can then add </span><em class="italic"><span class="koboSpan" id="kobo.1498.1">Hr</span></em><span class="koboSpan" id="kobo.1499.1"> at the </span><em class="italic"><span class="koboSpan" id="kobo.1500.1">θr</span></em><span class="koboSpan" id="kobo.1501.1"> angle to each pose to get the right sensor beam endpoint for every pose. </span><span class="koboSpan" id="kobo.1501.2">The same can be applied to the left sensor reading. </span><span class="koboSpan" id="kobo.1501.3">While complicated, this is faster than calculating the endpoint projecting out to the side and forward for </span><span class="No-Break"><span class="koboSpan" id="kobo.1502.1">each pose.</span></span></p>
<p><span class="koboSpan" id="kobo.1503.1">Measure the position of the distance sensors on your robot relative to the middle of the wheels (or use the CAD drawings). </span><span class="koboSpan" id="kobo.1503.2">The active part of each sensor to measure to is the shiny part at the top middle of </span><span class="No-Break"><span class="koboSpan" id="kobo.1504.1">each sensor.</span></span></p>
<p><span class="koboSpan" id="kobo.1505.1">We’ll add these distance sensor positions to our </span><strong class="source-inline"><span class="koboSpan" id="kobo.1506.1">robot/robot.py</span></strong><span class="koboSpan" id="kobo.1507.1"> measurement after the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1508.1">wheelbase_mm</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1509.1"> definition:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1510.1">
dist_side_mm = 37
dist_forward_mm = 66</span></pre>
<p><span class="koboSpan" id="kobo.1511.1">We need to add a function to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1512.1">robot/arena.py</span></strong><span class="koboSpan" id="kobo.1513.1"> to look up a position in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1514.1">distance grid:</span></span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.1515.1">The function converts an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1516.1">(x,y)</span></strong><span class="koboSpan" id="kobo.1517.1"> pose argument to </span><span class="No-Break"><span class="koboSpan" id="kobo.1518.1">grid coordinates:</span></span><pre class="console"><span class="koboSpan" id="kobo.1519.1">
def get_distance_likelihood_at(x, y):</span></pre><pre class="console"><span class="koboSpan" id="kobo.1520.1">
  """Return the distance grid value at the given point."""</span></pre><pre class="console"><span class="koboSpan" id="kobo.1521.1">
  grid_x = int(x // grid_cell_size + overscan)</span></pre><pre class="console"><span class="koboSpan" id="kobo.1522.1">
  grid_y = int(y // grid_cell_size + overscan)</span></pre></li>
<li><span class="koboSpan" id="kobo.1523.1">Out-of-bounds </span><a id="_idIndexMarker809"/><span class="koboSpan" id="kobo.1524.1">requests should return an incredibly </span><span class="No-Break"><span class="koboSpan" id="kobo.1525.1">low probability:</span></span><pre class="console"><span class="koboSpan" id="kobo.1526.1">
  if grid_x &lt; 0 or grid_x &gt;= distance_grid.shape[0] or grid_y &lt; 0 or grid_y &gt;= distance_grid.shape[1]:</span></pre><pre class="console"><span class="koboSpan" id="kobo.1527.1">
    return low_probability</span></pre></li>
<li><span class="koboSpan" id="kobo.1528.1">We can then return the result stored at the </span><span class="No-Break"><span class="koboSpan" id="kobo.1529.1">grid location:</span></span><pre class="console"><span class="koboSpan" id="kobo.1530.1">
  return distance_grid[grid_x, grid_y]</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.1531.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1532.1">robot/code.py</span></strong><span class="koboSpan" id="kobo.1533.1"> file, we can add a method to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1534.1">Simulation</span></strong><span class="koboSpan" id="kobo.1535.1"> class to perform the preceding triangle calculations, to get the sensor endpoints for </span><span class="No-Break"><span class="koboSpan" id="kobo.1536.1">each pose:</span></span></p>
<ol>
<li value="4"><span class="koboSpan" id="kobo.1537.1">This method will take the sensor reading, and inform us whether it’s on the </span><span class="No-Break"><span class="koboSpan" id="kobo.1538.1">right side:</span></span><pre class="console"><span class="koboSpan" id="kobo.1539.1">
    def get_sensor_endpoints(self, sensor_reading, right=False):</span></pre></li>
<li><span class="koboSpan" id="kobo.1540.1">We then calculate the adjacent and angle of </span><span class="No-Break"><span class="koboSpan" id="kobo.1541.1">our triangle:</span></span><pre class="console"><span class="koboSpan" id="kobo.1542.1">
        adjacent = sensor_reading + robot.dist_forward_mm</span></pre><pre class="console"><span class="koboSpan" id="kobo.1543.1">
        angle = np.atan(robot.dist_side_mm / adjacent)</span></pre><pre class="console"><span class="koboSpan" id="kobo.1544.1">
        if right:</span></pre><pre class="console"><span class="koboSpan" id="kobo.1545.1">
            angle = - angle</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.1546.1">Note here that we calculate the negative of the angle if it is on the </span><span class="No-Break"><span class="koboSpan" id="kobo.1547.1">right side.</span></span></p>
<ol>
<li value="6"><span class="koboSpan" id="kobo.1548.1">We then get the hypotenuse – this will be the distance from between the wheels to the sensor </span><span class="No-Break"><span class="koboSpan" id="kobo.1549.1">beam endpoints:</span></span><pre class="console"><span class="koboSpan" id="kobo.1550.1">
        hypotenuse = np.sqrt(robot.dist_side_mm**2 + adjacent**2)</span></pre></li>
<li><span class="koboSpan" id="kobo.1551.1">Now, we use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1552.1">numpy</span></strong><span class="koboSpan" id="kobo.1553.1"> to help us calculate the angle relative to each pose, converting the pose angle to radians as </span><span class="No-Break"><span class="koboSpan" id="kobo.1554.1">we go:</span></span><pre class="console"><span class="koboSpan" id="kobo.1555.1">
        pose_angles = np.radians(self.poses[:,2]) + angle</span></pre></li>
<li><span class="koboSpan" id="kobo.1556.1">We can then </span><a id="_idIndexMarker810"/><span class="koboSpan" id="kobo.1557.1">build a list of endpoints by projecting from the coordinate of each pose, with the hypotenuse at the </span><span class="No-Break"><span class="koboSpan" id="kobo.1558.1">calculated angle:</span></span><pre class="console"><span class="koboSpan" id="kobo.1559.1">
        sensor_endpoints = np.zeros((self.poses.shape[0], 2), dtype=np.float)</span></pre><pre class="console"><span class="koboSpan" id="kobo.1560.1">
        sensor_endpoints[:,0] = self.poses[:,0] + hypotenuse * np.cos(pose_angles)</span></pre><pre class="console"><span class="koboSpan" id="kobo.1561.1">
        sensor_endpoints[:,1] = self.poses[:,1] + hypotenuse * np.sin(pose_angles)</span></pre><pre class="console"><span class="koboSpan" id="kobo.1562.1">
        return sensor_endpoints</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.1563.1">We finally return these </span><span class="No-Break"><span class="koboSpan" id="kobo.1564.1">calculated lists.</span></span></p>
<p><span class="koboSpan" id="kobo.1565.1">We now create an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1566.1">observe_the_distance_sensors</span></strong><span class="koboSpan" id="kobo.1567.1"> method inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1568.1">Simulation</span></strong><span class="koboSpan" id="kobo.1569.1"> class and apply those to the existing set </span><span class="No-Break"><span class="koboSpan" id="kobo.1570.1">of weights:</span></span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.1571.1">Start by accepting an existing list of weights as </span><span class="No-Break"><span class="koboSpan" id="kobo.1572.1">an argument:</span></span><pre class="console"><span class="koboSpan" id="kobo.1573.1">
    def observe_distance_sensors(self, weights):</span></pre></li>
<li><span class="koboSpan" id="kobo.1574.1">We then call </span><strong class="source-inline"><span class="koboSpan" id="kobo.1575.1">get_sensor_endpoints</span></strong><span class="koboSpan" id="kobo.1576.1"> for </span><span class="No-Break"><span class="koboSpan" id="kobo.1577.1">each side:</span></span><pre class="console"><span class="koboSpan" id="kobo.1578.1">
        left_sensor = self.get_sensor_endpoints(self.distance_sensors.left)</span></pre><pre class="console"><span class="koboSpan" id="kobo.1579.1">
        right_sensor = self.get_sensor_endpoints(self.distance_sensors.right, True)</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.1580.1">We now have a list of distance sensor projections for every pose. </span><span class="koboSpan" id="kobo.1580.2">We can look up the distance likelihood grid at each of those points and </span><span class="No-Break"><span class="koboSpan" id="kobo.1581.1">add them:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1582.1">
        for index in range(self.poses.shape[0]):
            sensor_weight = arena. </span><span class="koboSpan" id="kobo.1582.2">get_distance_likelihood_at(left_sensor[index,0], left_sensor[index,1])
            sensor_weight += arena. </span><span class="koboSpan" id="kobo.1582.3">get_distance_likelihood_at(right_sensor[index,0], right_sensor[index,1])</span></pre>
<ol>
<li value="3"><span class="koboSpan" id="kobo.1583.1">We can then multiply this by the existing weight (inside or outside </span><span class="No-Break"><span class="koboSpan" id="kobo.1584.1">the arena):</span></span><pre class="console"><span class="koboSpan" id="kobo.1585.1">
            weights[index] *= sensor_weight</span></pre></li>
<li><span class="koboSpan" id="kobo.1586.1">Now, we leave this loop and return the </span><span class="No-Break"><span class="koboSpan" id="kobo.1587.1">modified weights:</span></span><pre class="console"><span class="koboSpan" id="kobo.1588.1">
        return weights</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.1589.1">We then </span><a id="_idIndexMarker811"/><span class="koboSpan" id="kobo.1590.1">need to incorporate this code into </span><strong class="source-inline"><span class="koboSpan" id="kobo.1591.1">observation_model</span></strong><span class="koboSpan" id="kobo.1592.1">. </span><span class="koboSpan" id="kobo.1592.2">Make the </span><span class="No-Break"><span class="koboSpan" id="kobo.1593.1">highlighted change:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1594.1">
    def observation_model(self):
        weights = np.ones(self.poses.shape[0], dtype=np.float)
        for index, pose in enumerate(self.poses):
            if not arena.contains(pose[0], pose[1]):
                weights[index] = arena.low_probability
</span><strong class="bold"><span class="koboSpan" id="kobo.1595.1">        weights = self.observe_distance_sensors(weights)</span></strong><span class="koboSpan" id="kobo.1596.1">
        weights = weights / np.sum(weights)
        return weights</span></pre>
<p><span class="koboSpan" id="kobo.1597.1">If you send this code to the robot, it will weigh and resample from two distance sensors. </span><span class="koboSpan" id="kobo.1597.2">The robot poses will start to form in blobs, located around likely positions for the sensors. </span><span class="koboSpan" id="kobo.1597.3">The blobs will form, scatter, and reform as the robot filters and moves them. </span><span class="koboSpan" id="kobo.1597.4">The following diagram shows what you will see on </span><span class="No-Break"><span class="koboSpan" id="kobo.1598.1">the display:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer211">
<span class="koboSpan" id="kobo.1599.1"><img alt="Figure 13.16 – The localization blob " src="image/Figure_13.16_B18001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1600.1">Figure 13.16 – The localization blob</span></p>
<p><span class="koboSpan" id="kobo.1601.1">In </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1602.1">Figure 13</span></em></span><em class="italic"><span class="koboSpan" id="kobo.1603.1">.16</span></em><span class="koboSpan" id="kobo.1604.1">, the poses have grouped together in a blob, roughly representing the robot’s position, which will move with the robot as it drives around </span><span class="No-Break"><span class="koboSpan" id="kobo.1605.1">the arena.</span></span></p>
<p><span class="koboSpan" id="kobo.1606.1">You may </span><a id="_idIndexMarker812"/><span class="koboSpan" id="kobo.1607.1">see one blob, or a few, and they may drive exactly with the robot or seem a little off. </span><span class="koboSpan" id="kobo.1607.2">This is where you will need to tune the model to better suit </span><span class="No-Break"><span class="koboSpan" id="kobo.1608.1">the situation.</span></span></p>
<h2 id="_idParaDest-296"><a id="_idTextAnchor298"/><span class="koboSpan" id="kobo.1609.1">Tuning and improving the Monte Carlo model</span></h2>
<p><span class="koboSpan" id="kobo.1610.1">Tuning the </span><a id="_idIndexMarker813"/><span class="koboSpan" id="kobo.1611.1">following factors can improve </span><span class="No-Break"><span class="koboSpan" id="kobo.1612.1">this model:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1613.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1614.1">ch-13/4.3-monte-carlo_perf</span></strong><span class="koboSpan" id="kobo.1615.1"> folder in the GitHub repository contains an instrumented </span><a id="_idIndexMarker814"/><span class="koboSpan" id="kobo.1616.1">version of the code in this chapter for troubleshooting. </span><span class="koboSpan" id="kobo.1616.2">You will need to tune </span><strong class="source-inline"><span class="koboSpan" id="kobo.1617.1">robot.py</span></strong><span class="koboSpan" id="kobo.1618.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1619.1">arena.py</span></strong><span class="koboSpan" id="kobo.1620.1"> for your own setup, but this code reports issues and tracebacks back to the computer for diagnosis, weight output from the observation model rendered on the display, and, if you are connected via USB, also sends </span><span class="No-Break"><span class="koboSpan" id="kobo.1621.1">performance data.</span></span></li>
<li><span class="koboSpan" id="kobo.1622.1">Measurements in </span><strong class="source-inline"><span class="koboSpan" id="kobo.1623.1">robot/robot.py</span></strong><span class="koboSpan" id="kobo.1624.1"> – the accuracy of measurements such as wheel diameters, wheelbase, gear ratio, and encoders will guide the odometry model. </span><span class="koboSpan" id="kobo.1624.2">If the movement of the blob doesn’t match the speed and turning, these are the likely suspects. </span><span class="koboSpan" id="kobo.1624.3">The model assumes wheels to be identical in size, which may be false if it’s consistently pulling to </span><span class="No-Break"><span class="koboSpan" id="kobo.1625.1">one side.</span></span></li>
<li><span class="koboSpan" id="kobo.1626.1">Similarly, if the distance sensor position measurements in </span><strong class="source-inline"><span class="koboSpan" id="kobo.1627.1">robot/robot.py</span></strong><span class="koboSpan" id="kobo.1628.1"> are incorrect or the sensors need calibration, the position will be consistently off. </span><span class="koboSpan" id="kobo.1628.2">The sensors can be disrupted by strong sunlight and flickering </span><span class="No-Break"><span class="koboSpan" id="kobo.1629.1">room lighting.</span></span></li>
<li><span class="koboSpan" id="kobo.1630.1">In the arena, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1631.1">get_distance_likelihood</span></strong><span class="koboSpan" id="kobo.1632.1"> factor, 100, adjusts the decay for the </span><a id="_idIndexMarker815"/><span class="koboSpan" id="kobo.1633.1">likelihood field around each boundary. </span><span class="koboSpan" id="kobo.1633.2">Lowering </span><a id="_idIndexMarker816"/><span class="koboSpan" id="kobo.1634.1">this will tighten </span><span class="No-Break"><span class="koboSpan" id="kobo.1635.1">the fields.</span></span></li>
<li><span class="koboSpan" id="kobo.1636.1">In </span><strong class="source-inline"><span class="koboSpan" id="kobo.1637.1">code.py</span></strong><span class="koboSpan" id="kobo.1638.1">, the number of poses is a major factor. </span><span class="koboSpan" id="kobo.1638.2">Increasing this will make for a better model, but beware of memory constraints on Raspberry </span><span class="No-Break"><span class="koboSpan" id="kobo.1639.1">Pi Pico.</span></span></li>
<li><span class="koboSpan" id="kobo.1640.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1641.1">code.py</span></strong><span class="koboSpan" id="kobo.1642.1"> alpha factors encode your certainty in the motion model; make these lower if you trust the motion </span><span class="No-Break"><span class="koboSpan" id="kobo.1643.1">model more.</span></span></li>
<li><span class="koboSpan" id="kobo.1644.1">The model also assumes the arena construction to be fairly accurate. </span><span class="koboSpan" id="kobo.1644.2">Errors in these assumptions can stack up to make it harder for the </span><span class="No-Break"><span class="koboSpan" id="kobo.1645.1">localization algorithm.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1646.1">You will need to spend time with these factors to make a model that is more likely to find its location, or is quicker in </span><span class="No-Break"><span class="koboSpan" id="kobo.1647.1">doing so.</span></span></p>
<p><span class="koboSpan" id="kobo.1648.1">Let’s summarize what we have learned in </span><span class="No-Break"><span class="koboSpan" id="kobo.1649.1">this chapter.</span></span></p>
<h1 id="_idParaDest-297"><a id="_idTextAnchor299"/><span class="koboSpan" id="kobo.1650.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.1651.1">In this chapter, we started by building a test arena for our robot using foam board construction, then modeled this in code, and displayed it along with a distance sensor likelihood field. </span><span class="koboSpan" id="kobo.1651.2">We put this on the robot, sent it over BLE, and then </span><span class="No-Break"><span class="koboSpan" id="kobo.1652.1">added poses.</span></span></p>
<p><span class="koboSpan" id="kobo.1653.1">We modeled how poses move using sensors, adding uncertainty to the model. </span><span class="koboSpan" id="kobo.1653.2">We then added a model of distance sensor observations, generating weights that we used in a resampling algorithm to generate new poses. </span></p>
<p><span class="koboSpan" id="kobo.1654.1">We finished with a look at tuning factors to improve the performance of </span><span class="No-Break"><span class="koboSpan" id="kobo.1655.1">this system.</span></span></p>
<p><span class="koboSpan" id="kobo.1656.1">In the next chapter, we will summarize your Raspberry Pi Pico robotics learning journey so far and discuss how you can continue your journey by improving this robot or building </span><span class="No-Break"><span class="koboSpan" id="kobo.1657.1">more robots.</span></span></p>
<h1 id="_idParaDest-298"><a id="_idTextAnchor300"/><span class="koboSpan" id="kobo.1658.1">Exercises</span></h1>
<p><span class="koboSpan" id="kobo.1659.1">The following exercises will deepen your understanding of the topics discussed in this chapter and make the robot </span><span class="No-Break"><span class="koboSpan" id="kobo.1660.1">code better:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1661.1">The IMU could be added by storing a previous state and calculating the delta. </span><span class="koboSpan" id="kobo.1661.2">You could mix this into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1662.1">rot1</span></strong><span class="koboSpan" id="kobo.1663.1">/</span><strong class="source-inline"><span class="koboSpan" id="kobo.1664.1">rot2</span></strong><span class="koboSpan" id="kobo.1665.1"> values by taking the average of encoder calculations versus the IMU angles, or consider whether one sensor is more trusted than the others. </span><span class="koboSpan" id="kobo.1665.2">You will need to calibrate the IMU before it can </span><span class="No-Break"><span class="koboSpan" id="kobo.1666.1">be used.</span></span></li>
<li><span class="koboSpan" id="kobo.1667.1">The robot’s pose guesses get stuck in </span><strong class="bold"><span class="koboSpan" id="kobo.1668.1">local maxima</span></strong><span class="koboSpan" id="kobo.1669.1"> – good but wrong guesses that are likely based on sensor positions. </span><span class="koboSpan" id="kobo.1669.2">Consider throwing in 10 fresh guesses at every population to nudge the code to try </span><span class="No-Break"><span class="koboSpan" id="kobo.1670.1">other options.</span></span></li>
<li><span class="koboSpan" id="kobo.1671.1">We are using only two observations per pose – having more distance sensors could improve this but will make the model slower. </span></li>
<li><span class="koboSpan" id="kobo.1672.1">Could you add a target zone to the arena? </span><span class="koboSpan" id="kobo.1672.2">Consider how PIDs could be used to steer the robot toward this. </span><span class="koboSpan" id="kobo.1672.3">Perhaps feed the PID with the </span><span class="No-Break"><span class="koboSpan" id="kobo.1673.1">mean pose.</span></span></li>
<li><span class="koboSpan" id="kobo.1674.1">You can improve the visualization by sending more pose data, including orientation. </span><span class="koboSpan" id="kobo.1674.2">You may need to consider the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1675.1">msgpack</span></strong><span class="koboSpan" id="kobo.1676.1"> library or switching to Wi-Fi or BLE over SPI, as the amount of data can easily overwhelm the BLE </span><span class="No-Break"><span class="koboSpan" id="kobo.1677.1">UART connection.</span></span></li>
</ul>
<h1 id="_idParaDest-299"><a id="_idTextAnchor301"/><span class="koboSpan" id="kobo.1678.1">Further reading</span></h1>
<p><span class="koboSpan" id="kobo.1679.1">These aids for further study will let you read on and dive deeper into the Monte Carlo algorithm and </span><span class="No-Break"><span class="koboSpan" id="kobo.1680.1">its quirks:</span></span></p>
<ul>
<li><em class="italic"><span class="koboSpan" id="kobo.1681.1">Probabilistic Robotics</span></em><span class="koboSpan" id="kobo.1682.1"> by Sebastian Thrun, Wolfram Burgard, and Dieter Fox, published by MIT Press, covers the Monte Carlo particle filter, along with the Kalman filter and other probability-based models in far more depth. </span></li>
<li><span class="koboSpan" id="kobo.1683.1">I strongly recommend the </span><em class="italic"><span class="koboSpan" id="kobo.1684.1">Khan Academy</span></em><span class="koboSpan" id="kobo.1685.1"> material on modeling data distributions for learning and practicing </span><span class="No-Break"><span class="koboSpan" id="kobo.1686.1">data distributions.</span></span></li>
<li><span class="koboSpan" id="kobo.1687.1">A playlist of 21 videos from Bonn University and Cyrill Stachniss at </span><a href="https://www.youtube.com/playlist?list=PLgnQpQtFTOGQEn33QDVGJpiZLi-SlL7vA"><span class="koboSpan" id="kobo.1688.1">https://www.youtube.com/playlist?list=PLgnQpQtFTOGQEn33QDVGJpiZLi-SlL7vA</span></a><span class="koboSpan" id="kobo.1689.1"> covers the topics used here in detail. </span><span class="koboSpan" id="kobo.1689.2">I recommend them if you want to dive far deeper into </span><span class="No-Break"><span class="koboSpan" id="kobo.1690.1">this topic.</span></span></li>
</ul>
</div>
</body></html>