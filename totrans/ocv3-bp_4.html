<html><head></head><body>
<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch04" class="calibre1"/>Chapter 4. Panoramic Image Stitching Application Using Android Studio and NDK</h1></div></div></div><p class="calibre8">Panorama is an interesting subject in application development. In OpenCV, the stitching module can easily create a panorama image from a sequence of images. One benefit of the stitching module is that the sequence of images don't have to be in order and can be in any direction. However, in the OpenCV Android SDK, the stitching module does not exist. Therefore, we must use the stitching module in the C++ interface. Luckily, Android provides the<a id="id388" class="calibre1"/> <strong class="calibre9">Native Development Kit</strong> (<strong class="calibre9">NDK</strong>) to support native development in C/C++. In this chapter, we will guide you through the steps to capture camera frames from Java and process the data in OpenCV C++ with the NDK.</p><p class="calibre8">In this chapter, you will learn:</p><div><ul class="itemizedlist"><li class="listitem">How to make a complete panorama stitching application</li><li class="listitem">How to use Java Native Interface (JNI) to use OpenCV C++ in Android Studio</li><li class="listitem">How to use the stitching module to create a panorama image</li></ul></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_1"><a id="ch04lvl1sec31" class="calibre1"/>Introducing the concept of panorama</h1></div></div></div><p class="calibre8">A <a id="id389" class="calibre1"/>panorama image gives the viewer a much broader field of view than a normal image and allows them to fully experience a scene. By extending the range of panorama to 360 degrees, viewers can simulate turning their head around. A panorama image can be created by stitching a sequence of overlapping images.</p><p class="calibre8">The following figure shows a demonstration of a panorama image captured with our application.</p><div><img src="img/00053.jpeg" alt="Introducing the concept of panorama" class="calibre11"/><div><p class="calibre28">A panorama image captured in an horizontal direction</p></div></div><p class="calibre12"> </p><p class="calibre8">In order<a id="id390" class="calibre1"/> to capture a panorama image, you must capture many images of the scene at different angles, as in the following figure. For example, you take your first picture at the left side of the room. Then, you move the phone straight to a new angle to start capturing. All the images will be stitched together to create a panorama image.</p><div><img src="img/00054.jpeg" alt="Introducing the concept of panorama" class="calibre11"/><div><p class="calibre28">Illustration showing how you pan the phone to create a panorama image</p></div></div><p class="calibre12"> </p><p class="calibre8">Normally, a panorama application only supports capturing images in horizontal. With the stitching module in OpenCV, we can extend the height of an image by capturing more images in both directions. The following figure shows an image that can be captured by changing the camera view in a horizontal and vertical direction.</p><div><img src="img/00055.jpeg" alt="Introducing the concept of panorama" class="calibre11"/><div><p class="calibre28">A panorama image captured in both directions</p></div></div><p class="calibre12"> </p><p class="calibre8">In this <a id="id391" class="calibre1"/>chapter, we will implement a panorama application in Android using OpenCV 3.0.0. The chapter contains two main sections:</p><div><ul class="itemizedlist"><li class="listitem"><strong class="calibre9">Android section</strong>: We<a id="id392" class="calibre1"/> will implement the user interface in Android Studio. In this chapter, we only implement the panorama capture activity with two buttons, <strong class="calibre9">Capture</strong> and <strong class="calibre9">Save</strong>. When the panorama is captured, we will save it to the phone's internal storage.</li><li class="listitem"><strong class="calibre9">OpenCV section</strong>: We<a id="id393" class="calibre1"/> will show the process to integrate OpenCV to Android Studio with NDK/JNI and implement the code to create a panorama image from a sequence of images captured in the Android section.</li></ul></div><p class="calibre8">In the following sections, we will show the process to create a user interface in Android Studio. If you<a id="id394" class="calibre1"/> want to review the OpenCV code, you can go to the <em class="calibre10">Integrating OpenCV into the Android Studio</em> section and come back to this later.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec32" class="calibre1"/>The Android section – an application user interface</h1></div></div></div><p class="calibre8">In this <a id="id395" class="calibre1"/>section, we will show you a basic user interface to capture and save the panorama to the internal storage. Basically, the user will see a fullscreen of the camera preview image. When the user presses the <strong class="calibre9">Capture</strong> button, the application will capture the current scene and put the captured image on an overlay layer above the current view. Therefore, the user knows what they have just captured and can change the phone position to capture the next image.</p><p class="calibre8">The following is a screenshot of the application when the user opens it and after the user captures an image:</p><div><img src="img/00056.jpeg" alt="The Android section – an application user interface" class="calibre11"/><div><p class="calibre28">An example of the user interface before and after a user captures an image</p></div></div><p class="calibre12"> </p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch04lvl2sec41" class="calibre1"/>The setup activity layout</h2></div></div></div><p class="calibre8">First, we <a id="id396" class="calibre1"/>will create a new Android project with a blank activity in Android Studio. Then, we will edit the layout xml for MainActivity in <code class="email">app/src/main/res/layout/activity_main.xml</code> as follows:</p><div><pre class="programlisting">&lt;RelativeLayout   
    
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".MainActivity"&gt;
    &lt;SurfaceView
        android:id="@+id/surfaceView"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        /&gt;
    &lt;SurfaceView
        android:id="@+id/surfaceViewOnTop"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        /&gt;
    &lt;Button
        android:id="@+id/capture"
        android:text="Capture"
        android:layout_width="wrap_content"
        android:layout_height="70dp"
        android:layout_alignParentBottom="true"
        android:layout_centerHorizontal="true"
        android:layout_marginBottom="10dp"
        android:padding="10dp"
        android:textColor="#FFF"
        android:background="@android:color/holo_blue_dark"
        /&gt;
    &lt;Button
        android:id="@+id/save"
        android:text="Save"
        android:layout_width="wrap_content"
        android:layout_height="70dp"
        android:padding="10dp"
        android:textColor="#FFF"
        android:background="@android:color/holo_purple"
        android:layout_marginRight="10dp"
        android:layout_alignTop="@+id/capture"
        android:layout_alignParentRight="true"
        android:layout_alignParentEnd="true" /&gt;
&lt;/RelativeLayout&gt;</pre></div><p class="calibre8">In this <a id="id397" class="calibre1"/>layout xml file, we have two SurfaceViews—one for the camera preview and one for the overlay layer. We also have two buttons—one for capturing the image and one for saving the panorama image to the internal storage.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch04lvl2sec42" class="calibre1"/>Capturing the camera frame</h2></div></div></div><p class="calibre8">In this section, we will implement the <a id="id398" class="calibre1"/>process to capture camera frames and view it on a SurfaceView<a id="id399" class="calibre1"/> with the ID <code class="email">surfaceView</code>.</p><p class="calibre8">At the begin of the <code class="email">MainActivity</code> class, we will create some objects to work with the layout:</p><div><pre class="programlisting">public class MainActivity extends ActionBarActivity {
    private Button captureBtn, saveBtn; // used to interact with capture and save Button in UI
    private SurfaceView mSurfaceView, mSurfaceViewOnTop; // used to display the camera frame in UI
    private Camera mCam;
    private boolean isPreview; // Is the camera frame displaying?
    private boolean safeToTakePicture = true; // Is it safe to capture a picture?</pre></div><p class="calibre8">In the preceding code, we created two buttons and two <code class="email">SurfaceViews</code> to interact with the user interface. We also create a Camera object, <code class="email">mCam</code>, to open the camera. In our implementation, we will open the camera and get the video frame in the Android approach. OpenCV also provides some other approaches to open the camera. However, we found that they may not work well on all Android devices, so we prefer using the camera with Android approach. In this chapter, we only need the Camera object from the Android API. The advantage of this approach is that you can expect it to work on almost any Android device. The disadvantage is that you have to do some conversion from camera byte array to Android Bitmap to display on the UI and to OpenCV Mat to do the image processing.</p><div><h3 class="title2"><a id="note57" class="calibre1"/>Note</h3><p class="calibre8">If you want to experience OpenCV classes to interact with the camera, you may want to check <a class="calibre1" title="Chapter 7. Gyroscopic Video Stabilization" href="part0058_split_000.html#1NA0K1-940925703e144daa867f510896bffb69">Chapter 7</a>, <em class="calibre10">Gyroscopic Video Stabilization</em>, of this book.</p></div><p class="calibre8">In the <code class="email">onCreate</code> function, we set up these objects as follows:</p><div><pre class="programlisting">@Override
protected void onCreate(Bundle savedInstanceState){
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);

    isPreview = false;
    mSurfaceView = (SurfaceView)findViewById(R.id.surfaceView);
    mSurfaceView.getHolder().addCallback(mSurfaceCallback);
    
    mSurfaceViewOnTop = (SurfaceView)findViewById(R.id.surfaceViewOnTop);
    mSurfaceViewOnTop.setZOrderOnTop(true);    // necessary
    mSurfaceViewOnTop.getHolder().setFormat(PixelFormat.TRANSPARENT);

    captureBtn = (Button) findViewById(R.id.capture);
    captureBtn.setOnClickListener(captureOnClickListener);

    saveBtn = (Button) findViewById(R.id.save);
    saveBtn.setOnClickListener(saveOnClickListener);
}</pre></div><p class="calibre8">First, we initialize <code class="email">isPreview</code> to false <a id="id400" class="calibre1"/>and assign <code class="email">mSurfaceView</code> to <code class="email">SurfaceView</code> in the layout. Then, we <a id="id401" class="calibre1"/>get the holder of <code class="email">mSurfaceView</code> and add a callback to it. The variable <code class="email">mSurfaceCallback</code> is an instance of <code class="email">SurfaceHolder.Callback</code> that we will create later. We also assign <code class="email">mSurfaceViewOnTop</code> to the other SurfaceView in the layout, since we want this SurfaceView to be an overlay layer on the camera view. We need to set the Z order to be true and set the holder format to <code class="email">TRANSPARENT</code>. Finally, we set up the capture and save buttons, and set the corresponding <code class="email">OnClickListener</code>. In the next part, we will work on displaying the camera frame on the <code class="email">SurfaceView</code>. So we will just create a basic <code class="email">OnClickListener</code> as follows:</p><div><pre class="programlisting">View.OnClickListener captureOnClickListener = new View.OnClickListener() {
    @Override
    public void onClick(View v) {
    }
};
View.OnClickListener saveOnClickListener = new View.OnClickListener() {
    @Override
    public void onClick(View v) {
    }
};</pre></div><div><div><div><div><h3 class="title2"><a id="ch04lvl3sec22" class="calibre1"/>Using the Camera API to get the camera frame</h3></div></div></div><p class="calibre8">As we said <a id="id402" class="calibre1"/>before, we will use the Android API to get the camera frame in Android. Currently, there are two versions of Camera API, <code class="email">android.hardware.Camera</code> and <code class="email">android.hardware.camera2</code>. We will use <code class="email">android.hardware.Camera</code> because it supports most of the Android devices up to Android 4.4. In Android 5.0 and later, this API is deprecated and replaced by camera2. We can still use <code class="email">android.hardware.Camera</code> on Android 5.0. If you want to target Android 5.0, we recommend you to try camera2 in your application.</p><p class="calibre8">In order to use the camera, we need to add the following lines to <code class="email">AndroidManifest.xml</code> to gain the permissions to the camera. Besides, we also request the permission to write to storage as we will save the panorama image to internal storage.</p><div><pre class="programlisting">&lt;uses-feature android:name="android.hardware.camera" /&gt;
&lt;uses-permission android:name="android.permission.CAMERA" /&gt;
&lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" /&gt;</pre></div><p class="calibre8">We want to set the <code class="email">mSurfaceView</code> to display the camera frame, so we will set up the camera parameters in the callback of <code class="email">mSurfaceView</code>. We need to create the variable <code class="email">mSurfaceCallback</code> as follows:</p><div><pre class="programlisting">SurfaceHolder.Callback mSurfaceCallback = new SurfaceHolder.Callback(){
    @Override
    public void surfaceCreated(SurfaceHolder holder) {
        try {
            // Tell the camera to display the frame on this surfaceview
            mCam.setPreviewDisplay(holder);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    @Override
    public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) {
        // Get the default parameters for camera
        Camera.Parameters myParameters = mCam.getParameters();
        // Select the best preview size
        Camera.Size myBestSize = getBestPreviewSize( myParameters );
        if(myBestSize != null){
            // Set the preview Size
            myParameters.setPreviewSize(myBestSize.width, myBestSize.height);
            // Set the parameters to the camera
            mCam.setParameters(myParameters);
            // Rotate the display frame 90 degree to view in portrait mode
            mCam.setDisplayOrientation(90);
            // Start the preview
            mCam.startPreview();
            isPreview = true;
        }
    }
    @Override
    public void surfaceDestroyed(SurfaceHolder holder) {
    }
};</pre></div><p class="calibre8">In this<a id="id403" class="calibre1"/> code, we call the <code class="email">setPreviewDisplay</code> method in the <code class="email">surfaceCreated</code> function to tell the camera to display the camera frame on <code class="email">mSurfaceView</code>. After this, in the <code class="email">surfaceChanged</code> function, we set the camera parameters, change the display orientation to 90 degrees and start the preview process. The function <code class="email">getBestPreviewSize</code> is a function to get the preview size that has the biggest number of pixels. The <code class="email">getBestPreviewSize</code> is simple, as follows:</p><div><pre class="programlisting">private Camera.Size getBestPreviewSize(Camera.Parameters parameters){
    Camera.Size bestSize = null;
    List&lt;Camera.Size&gt; sizeList = parameters.getSupportedPreviewSizes();
    bestSize = sizeList.get(0);
    for(int i = 1; i &lt; sizeList.size(); i++){
        if((sizeList.get(i).width * sizeList.get(i).height) &gt;
                (bestSize.width * bestSize.height)){
            bestSize = sizeList.get(i);
        }
    }
    return bestSize;
}</pre></div><p class="calibre8">Finally, we need to add some code to open the camera in <code class="email">onResume</code> and release the camera in <code class="email">onPause</code>:</p><div><pre class="programlisting">@Override
protected void onResume() {
    super.onResume();
    mCam = Camera.open(0); // 0 for back camera
}
@Override
protected void onPause() {
    super.onPause();
    if(isPreview){
        mCam.stopPreview();
    }
    mCam.release();
    mCam = null;
    isPreview = false;
}</pre></div><p class="calibre8">At this <a id="id404" class="calibre1"/>moment, we can install and run the application on a real device. The following figure shows a screenshot of our application on a Nexus 5 running Android 5.1.1:</p><div><img src="img/00057.jpeg" alt="Using the Camera API to get the camera frame" class="calibre11"/><div><p class="calibre28">A screenshot of the application in Camera Preview mode on Nexus 5 running Android 5.1.1</p></div></div><p class="calibre12"> </p><p class="calibre8">In our application, we don't want the layout to rotate so we set the activity orientation to portrait mode. It's optional. If you want to do this, you can simply change your activity in <code class="email">AndroidManifest.xml</code> as follows:</p><div><pre class="programlisting">&lt;activity   
    android:screenOrientation="portrait"
    android:name=".MainActivity"
    android:label="@string/app_name" &gt;</pre></div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch04lvl2sec43" class="calibre1"/>Implementing the Capture button</h2></div></div></div><p class="calibre8">In this section, we<a id="id405" class="calibre1"/> will show you how to implement the <code class="email">OnClickListener</code> of the <strong class="calibre9">Capture</strong> button. When the user clicks on the <strong class="calibre9">Capture</strong> button, we want the application to take a picture of the current scene. With the Camera API, we can use the <code class="email">takePicture</code> function to capture a picture. The benefit of this function is that the resolution of the output image is very high. For example, when our application runs on Nexus 5, even though the previewing size is 1920x1080, the resolution of the captured image is 3264x2448. We change <code class="email">captureOnClickListener</code> as follows:</p><div><pre class="programlisting">View.OnClickListener captureOnClickListener = new View.OnClickListener() {
    @Override
    public void onClick(View v) {
        if(mCam != null &amp;&amp; safeToTakePicture){
            // set the flag to false so we don't take two picture at a same time
            safeToTakePicture = false;
            mCam.takePicture(null, null, jpegCallback);
        }
    }
};</pre></div><p class="calibre8">In the <code class="email">onClick</code> function, we check whether the camera is initialized and the flag <code class="email">safeToTakePicture</code> is <code class="email">true</code>. Then, we set the flag to <code class="email">false</code> so that we don't take two pictures at the same time. The <code class="email">takePicture</code> function of the Camera instance requires three parameters. The first and second parameters are shutter call back and raw data call back respectively. These functions may be called differently on different devices so we don't want to use them and set them to null. The last parameter is the callback that is called when the camera saves the picture in the JPEG format.</p><div><pre class="programlisting">Camera.PictureCallback jpegCallback = new Camera.PictureCallback() {
    public void onPictureTaken(byte[] data, Camera camera) {
        // decode the byte array to a bitmap
        Bitmap bitmap = BitmapFactory.decodeByteArray(data, 0, data.length);
        // Rotate the picture to fit portrait mode
        Matrix matrix = new Matrix();
        matrix.postRotate(90);
        bitmap = Bitmap.createBitmap(bitmap, 0, 0, bitmap.getWidth(), bitmap.getHeight(), matrix, false);

        // TODO: Save the image to a List to pass them to OpenCV method

        Canvas canvas = null;
        try {
            canvas = mSurfaceViewOnTop.getHolder().lockCanvas(null);
            synchronized (mSurfaceViewOnTop.getHolder()) {
                // Clear canvas
                canvas.drawColor(Color.TRANSPARENT, PorterDuff.Mode.CLEAR);

                // Scale the image to fit the SurfaceView
                float scale = 1.0f * mSurfaceView.getHeight() / bitmap.getHeight();
                Bitmap scaleImage = Bitmap.createScaledBitmap(bitmap, (int)(scale * bitmap.getWidth()), mSurfaceView.getHeight() , false);
                Paint paint = new Paint();
                // Set the opacity of the image
                paint.setAlpha(200);
                // Draw the image with an offset so we only see one third of image.
                canvas.drawBitmap(scaleImage, -scaleImage.getWidth() * 2 / 3, 0, paint);
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (canvas != null) {
                mSurfaceViewOnTop.getHolder().unlockCanvasAndPost(canvas);
            }
        }
        // Start preview the camera again and set the take picture flag to true
        mCam.startPreview();
        safeToTakePicture = true;
    }
};</pre></div><p class="calibre8">First, <code class="email">onPictureTaken</code> provides a byte <a id="id406" class="calibre1"/>array of the captured image, so we would want to decode it to an instance of Bitmap. Because the camera sensor captured the image in landscape mode, we would want to apply a rotation matrix to obtain the image in the portrait mode. Then, we would want to save this image to pass a sequence of images to the OpenCV stitching module. Since this code needs the OpenCV library, we will implement this part later. After this, we will obtain the canvas of the overlay <code class="email">SurfaceView</code> and try to draw the image on the screen. The following is a demonstration of the overlay layer on top of the previewing layer. Finally, we will start the preview process again and also set the <code class="email">safeToTakePicture</code> flag<a id="id407" class="calibre1"/> to <code class="email">true</code>.</p><div><img src="img/00058.jpeg" alt="Implementing the Capture button" class="calibre11"/><div><p class="calibre28">A screenshot of the application after the user captured an image on a Nexus 5 running Android 5.1.1</p></div></div><p class="calibre12"> </p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_4"><a id="ch04lvl2sec44" class="calibre1"/>Implementing the Save button</h2></div></div></div><p class="calibre8">Currently, the <a id="id408" class="calibre1"/><strong class="calibre9">Save</strong> button is fairly simple. We will assume that when the user clicks on the <strong class="calibre9">Save</strong> button, we will start a new thread to perform the image processing task:</p><div><pre class="programlisting">View.OnClickListener saveOnClickListener = new View.OnClickListener() {
    @Override
    public void onClick(View v) {
        Thread thread = new Thread(imageProcessingRunnable);
        thread.start();
    }
};</pre></div><p class="calibre8">In <code class="email">imageProcessingRunnable</code>, we would want to show a processing dialog at the start of the process and close the dialog when everything is completed. In order to accomplish this, we will first create an instance of <code class="email">ProgressDialog</code>:</p><div><pre class="programlisting">ProgressDialog ringProgressDialog;</pre></div><p class="calibre8">Then, <code class="email">imageProcessingRunnable</code> is<a id="id409" class="calibre1"/> implemented as:</p><div><pre class="programlisting">private Runnable imageProcessingRunnable = new Runnable() {
    @Override
    public void run() {
        showProcessingDialog();
        // TODO: implement OpenCV parts
        closeProcessingDialog();
    }
};</pre></div><p class="calibre8">We will simply call <code class="email">showProcessingDialog</code> to show the progressing dialog and call <code class="email">closeProcessingDialog</code> to close the dialog. The steps in between are quite complex and requires lots of OpenCV functions, so we keep this part for a later section. The functions to show and close the progress dialog are as follows:</p><div><pre class="programlisting">private void showProcessingDialog(){
    runOnUiThread(new Runnable() {
        @Override
        public void run() {
            mCam.stopPreview();
            ringProgressDialog = ProgressDialog.show(MainActivity.this, "", "Panorama", true);
            ringProgressDialog.setCancelable(false);
        }
    });
}</pre></div><div><pre class="programlisting">private void closeProcessingDialog(){
    runOnUiThread(new Runnable() {
        @Override
        public void run() {
            mCam.startPreview();
            ringProgressDialog.dismiss();
        }
    });
}</pre></div><p class="calibre8">In <code class="email">showProcessingDialog</code>, we will stop the camera preview to reduce unnecessary computation cost on the device, whereas in <code class="email">closeProcessingDialog</code>, we start the camera preview again to allow the user to capture more panorama images. We must put these codes in <code class="email">runOnUiThread</code> since these codes interact with the UI elements.</p><p class="calibre8">In the following section, we will show you how<a id="id410" class="calibre1"/> to implement the remaining parts of our application with OpenCV.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec33" class="calibre1"/>Integrating OpenCV into the Android Studio</h1></div></div></div><p class="calibre8">In this<a id="id411" class="calibre1"/> section, we will show you the steps to <a id="id412" class="calibre1"/>integrate OpenCV in the Android Studio with the Native Development Kit and use the OpenCV stitching module in C++ to create the final panorama image. We will also do some computations with OpenCV Android SDK Java to show how the interaction goes about between Java and C++ interfaces.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch04lvl2sec45" class="calibre1"/>Compiling OpenCV Android SDK to the Android Studio project</h2></div></div></div><p class="calibre8">Officially, the OpenCV Android SDK is <a id="id413" class="calibre1"/>an Eclipse project, which means we can't simply use it in our Android <a id="id414" class="calibre1"/>Studio project. We need to convert the OpenCV Android SDK to an Android Studio project and import it as a module to our application.</p><div><h3 class="title2"><a id="note58" class="calibre1"/>Note</h3><p class="calibre8">We assume<a id="id415" class="calibre1"/> that you have downloaded the latest OpenCV for Android from <a class="calibre1" href="http://opencv.org/downloads.html">http://opencv.org/downloads.html</a>. At the time of writing, we now have OpenCV for Android 3.0.0.</p></div><p class="calibre8">Let's extract the downloaded file to your favorite path, for example, <code class="email">/Volumes/Data/OpenCV/OpenCV-android-sdk</code>.</p><p class="calibre8">Then, we need to open a new Android Studio window and select <strong class="calibre9">Import project</strong> (Eclipse ADT, Gradle, and so on). In the popup window, you should select the <code class="email">java</code> folder at <code class="email">OpenCV-android-sdk/sdk/java</code> and click on <strong class="calibre9">OK</strong>.</p><div><img src="img/00059.jpeg" alt="Compiling OpenCV Android SDK to the Android Studio project" class="calibre11"/><div><p class="calibre28">Import project visualization</p></div></div><p class="calibre12"> </p><p class="calibre8">In the<a id="id416" class="calibre1"/> next window, we <a id="id417" class="calibre1"/>will choose a path to store the new OpenCV SDK project. In our case, we choose <code class="email">/Volumes/Data/OpenCV/opencv-java</code> and click on <strong class="calibre9">Next</strong>.</p><div><img src="img/00060.jpeg" alt="Compiling OpenCV Android SDK to the Android Studio project" class="calibre11"/><div><p class="calibre28">Select import destination visualization</p></div></div><p class="calibre12"> </p><p class="calibre8">In <a id="id418" class="calibre1"/>the last window, we will<a id="id419" class="calibre1"/> simply click on <strong class="calibre9">Finish</strong> and wait until Android Studio completes the Gradle build process. Basically, Gradle is the default build system of Android Studio. At this step, we want to make sure that the OpenCV SDK can be compiled successfully. One of the common errors is that you haven't downloaded the required Android SDK. The error message is very straightforward. You can follow the message to solve the problem. In our case, there is no problem as in the following screenshot.</p><div><img src="img/00061.jpeg" alt="Compiling OpenCV Android SDK to the Android Studio project" class="calibre11"/><div><p class="calibre28">Build competition visualization</p></div></div><p class="calibre12"> </p><p class="calibre8">At this time, we can close this project and open our Panorama project.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch04lvl2sec46" class="calibre1"/>Setting up the Android Studio to work with OpenCV</h2></div></div></div><p class="calibre8">In <a id="id420" class="calibre1"/>order to use OpenCV in our project, we need to import the OpenCV Android SDK to our project. With this SDK, we can use the OpenCV Java API and perform image processing tasks easily. Moreover, we must make a further step to tell Android Studio to compile OpenCV C++ code to use OpenCV in the Native Development Kit (NDK). We will split this section into three subsections: Importing the Android SDK, Creating a Java-C++ interaction, and Compiling OpenCV C++.</p><div><div><div><div><h3 class="title2"><a id="ch04lvl3sec23" class="calibre1"/>Importing the OpenCV Android SDK</h3></div></div></div><p class="calibre8">We <a id="id421" class="calibre1"/>assume that you have opened the Panorama project. We need to import the converted OpenCV Android SDK in the previous section as follows:</p><p class="calibre8"><strong class="calibre9">File</strong> | <strong class="calibre9">New</strong> | <strong class="calibre9">Import Module</strong></p><p class="calibre8">In the <strong class="calibre9">New Module</strong> window, we will select the source directory to the converted project. In our case, we will choose <code class="email">/Volumes/Data/OpenCV/opencv-java</code>. Then, we'll check the import checkbox, change the module name to <code class="email">:opencv-java</code>, as shown in the following screenshot and click <strong class="calibre9">Finish</strong>:</p><div><img src="img/00062.jpeg" alt="Importing the OpenCV Android SDK" class="calibre11"/><div><p class="calibre28">A new module window</p></div></div><p class="calibre12"> </p><p class="calibre8">Next, we need to modify <code class="email">build.gradle</code> in the <code class="email">app</code> folder to add one line to the <code class="email">dependencies</code> section:</p><div><pre class="programlisting">dependencies {
    compile fileTree(dir: 'libs', include: ['*.jar'])
    compile 'com.android.support:appcompat-v7:22.1.1'

    compile project(":opencv-java")
}</pre></div><p class="calibre8">Finally, we<a id="id422" class="calibre1"/> must sync the project with the button <strong class="calibre9">Sync Project with Gradle Files</strong>.</p><div><h3 class="title2"><a id="note59" class="calibre1"/>Note</h3><p class="calibre8">If you only need the OpenCV Java Interface and don't want to use OpenCV C++, you must copy the <code class="email">libs</code> folder at <code class="email">OpenCV-android-sdk/sdk/native/libs</code> to your <code class="email">app/src/main</code> folder. Then, you must add the following <code class="email">loadLibrary</code> code to your class file:</p><div><pre class="programlisting">static {
    //If you use OpenCV 2.*, use "opencv_java"
    System.loadLibrary("opencv_java3");
}</pre></div></div></div><div><div><div><div><h3 class="title2"><a id="ch04lvl3sec24" class="calibre1"/>Creating a Java and C++ interaction with Java Native Interface (JNI)</h3></div></div></div><p class="calibre8">Before<a id="id423" class="calibre1"/> we start the compile process, we will create a class file named <code class="email">NativePanorama.java</code> and add a method to the <code class="email">NativePanorama</code> class:</p><div><pre class="programlisting">public class NativePanorama {
    public native static void processPanorama(long[] imageAddressArray, long outputAddress);
}</pre></div><p class="calibre8">The <code class="email">processPanorama</code> method will receive an array of long addresses of each image and a long address of an output image.</p><p class="calibre8">You must rebuild the project in order to follow the ensuing steps. The detailed explanation is in the next paragraph:</p><div><ul class="itemizedlist"><li class="listitem">Use the <code class="email">javah</code> command line to create a C++ header</li><li class="listitem">Create a <code class="email">.cpp</code> file for the newly created header in the <code class="email">jni</code> folder to implement the function in C++</li></ul></div><p class="calibre8">You may<a id="id424" class="calibre1"/> notice the keyword <code class="email">native</code> before the <code class="email">processPanorama</code> method. This means that we will use this method to interact between Java and C++ in our application. Therefore, we need to create some headers and source files to implement our C++ code. We must follow <strong class="calibre9">Java Native Interface</strong> (<strong class="calibre9">JNI</strong>) to use C++ code, so the process may be a bit complex and out of the scope of this book.</p><p class="calibre8">In the following parts, we will show you the steps to use OpenCV C++.</p><div><h3 class="title2"><a id="note60" class="calibre1"/>Note</h3><p class="calibre8">If you <a id="id425" class="calibre1"/>want to understand JNI, you may want to take a look at the JNI documentation found at:</p><p class="calibre8"><a class="calibre1" href="http://docs.oracle.com/javase/7/docs/technotes/guides/jni/">http://docs.oracle.com/javase/7/docs/technotes/guides/jni/</a></p><p class="calibre8">Also, have <a id="id426" class="calibre1"/>a look at the JNI tips from API guides found at:</p><p class="calibre8"><a class="calibre1" href="http://developer.android.com/training/articles/perf-jni.html">http://developer.android.com/training/articles/perf-jni.html</a></p></div><p class="calibre8">First, we<a id="id427" class="calibre1"/> will use the <code class="email">javah</code> command in the terminal to create the corresponding C++ header for the <code class="email">processPanorama</code> method. In order to do this, you need to open the terminal on your machine, then change the directory to the folder <code class="email">app/src/main</code> in your Android application and run the following command:</p><div><pre class="programlisting">javah -d jni -classpath ../../build/intermediates/classes/debug/ com.example.panorama.NativePanorama</pre></div><p class="calibre8">You only need to verify the package name and the name of the class file, <code class="email">NativePanorama</code>. The command will not display anything on the terminal, as shown in the following figure. You may want to rebuild the project if you encounter the following error: <strong class="calibre9">Error: Could not find class file for 'com.example.panorama.NativePanorama'</strong>.</p><div><img src="img/00063.jpeg" alt="Creating a Java and C++ interaction with Java Native Interface (JNI)" class="calibre11"/><div><p class="calibre28">The terminal after using the javah command</p></div></div><p class="calibre12"> </p><p class="calibre8">As the result of the <code class="email">javah</code> command, we now have a folder named <code class="email">jni</code> in our <code class="email">app/src/main</code> folder with a file <code class="email">com_example_panorama_NativePanorama.h</code>. This header contains a function to work with Java Interface. When <code class="email">processPanorama</code> is called, this function will run in C++.</p><p class="calibre8">Next, we will create a source file named <code class="email">com_example_panorama_NativePanorama.cpp</code> in the <code class="email">jni</code> folder. We recommend that you should copy the function declaration from the header file to the source file and add the parameter names as follows:</p><div><pre class="programlisting">#include "com_example_panorama_NativePanorama.h"
JNIEXPORT void JNICALL Java_com_example_panorama_NativePanorama_processPanorama
  (JNIEnv * env, jclass clazz, jlongArray imageAddressArray, jlong outputAddress){
}</pre></div><p class="calibre8">The <a id="id428" class="calibre1"/>only thing left is that we need to compile OpenCV C++ SDK to use it in the preceding source file.</p></div><div><div><div><div><h3 class="title2"><a id="ch04lvl3sec25" class="calibre1"/>Compiling OpenCV C++ with NDK/JNI</h3></div></div></div><p class="calibre8">In order <a id="id429" class="calibre1"/>to use OpenCV in C++ code, we need <a id="id430" class="calibre1"/>to compile OpenCV C++ and use an <code class="email">Android.mk</code> file as the make file to build and link our C++ file with OpenCV library. However, Android Studio doesn't support <code class="email">Android.mk</code> out of the box. We need to do lots of things to make this happen.</p><p class="calibre8">First, we will open the <code class="email">local.properties</code> file and set <code class="email">ndk.dir</code> to be your path to the Android NDK folder. In our case, the <code class="email">local.properties</code> will look like this:</p><div><pre class="programlisting">sdk.dir=/Users/quanhua92/Library/Android/sdk
ndk.dir=/Users/quanhua92/Software/android-ndk-r10e</pre></div><div><h3 class="title2"><a id="note61" class="calibre1"/>Note</h3><p class="calibre8">You <a id="id431" class="calibre1"/>can get the Android NDK at: <a class="calibre1" href="https://developer.android.com/ndk/index.html">https://developer.android.com/ndk/index.html</a></p></div><p class="calibre8">Secondly, we open the <code class="email">build.gradle</code> file in our app folder and add this line at the top:</p><div><pre class="programlisting">import org.apache.tools.ant.taskdefs.condition.Os</pre></div><p class="calibre8">Then, we need to add the following code between the <code class="email">defaultConfig</code> tag and <code class="email">buildType</code> tag to create a new Gradle task to build C++ code.</p><div><pre class="programlisting">// begin NDK OPENCV
sourceSets.main {
    jni.srcDirs = [] //disable automatic ndk-build call
}
task ndkBuild(type: Exec, description: 'Compile JNI source via NDK') {
    def rootDir = project.rootDir
    def localProperties = new File(rootDir, "local.properties")
    Properties properties = new Properties()
    localProperties.withInputStream { instr -&gt;
        properties.load(instr)
    }
    def ndkDir = properties.getProperty('ndk.dir')
    if (Os.isFamily(Os.FAMILY_WINDOWS)) {
        commandLine "$ndkDir\\ndk-build.cmd",
                'NDK_PROJECT_PATH=build/intermediates/ndk',
                'NDK_LIBS_OUT=src/main/jniLibs',
                'APP_BUILD_SCRIPT=src/main/jni/Android.mk',
                'NDK_APPLICATION_MK=src/main/jni/Application.mk'
    } else {
        commandLine "$ndkDir/ndk-build",
                'NDK_PROJECT_PATH=build/intermediates/ndk',
                'NDK_LIBS_OUT=src/main/jniLibs',
                'APP_BUILD_SCRIPT=src/main/jni/Android.mk',
                'NDK_APPLICATION_MK=src/main/jni/Application.mk'
    }
}
tasks.withType(JavaCompile) {
    compileTask -&gt; compileTask.dependsOn ndkBuild
}
//end</pre></div><p class="calibre8">You<a id="id432" class="calibre1"/> may <a id="id433" class="calibre1"/>want to look at the following figure for a screenshot of our <code class="email">build.gradle</code>.</p><div><img src="img/00064.jpeg" alt="Compiling OpenCV C++ with NDK/JNI" class="calibre11"/><div><p class="calibre28">A screenshot of our build.gradle</p></div></div><p class="calibre12"> </p><p class="calibre8">Next, we<a id="id434" class="calibre1"/> create a file named <code class="email">Application.mk</code> in the <code class="email">jni</code> folder and put the following lines in it:</p><div><pre class="programlisting">APP_STL := gnustl_static
APP_CPPFLAGS := -frtti -fexceptions
APP_ABI := all
APP_PLATFORM := android-16</pre></div><p class="calibre8">Finally, we create a file named <code class="email">Android.mk</code> in the <code class="email">jni</code> folder and set up this file as below to use OpenCV in our C++ code. You may need to change the <code class="email">OPENCVROOT</code> variable to the location of OpenCV-android-sdk in your machine:</p><div><pre class="programlisting">LOCAL_PATH := $(call my-dir)

include $(CLEAR_VARS)
#opencv
OPENCVROOT:= /Volumes/Data/OpenCV/OpenCV-android-sdk
OPENCV_CAMERA_MODULES:=on
OPENCV_INSTALL_MODULES:=on
OPENCV_LIB_TYPE:=SHARED
include ${OPENCVROOT}/sdk/native/jni/OpenCV.mk

LOCAL_SRC_FILES := com_example_panorama_NativePanorama.cpp
LOCAL_LDLIBS += -llog
LOCAL_MODULE := MyLib

include $(BUILD_SHARED_LIBRARY)</pre></div><p class="calibre8">With the <a id="id435" class="calibre1"/>preceding <code class="email">Android.mk</code>, Android Studio will build OpenCV into <code class="email">libopencv_java3.so</code> and build our C++ code into <code class="email">libMyLib.so</code> in the folder <code class="email">app/src/main/jniLibs</code>. We have to open our <code class="email">MainActivity.java</code> and load this library to use in our application as follows:</p><div><pre class="programlisting">public class MainActivity extends ActionBarActivity {
    static{
        System.loadLibrary("opencv_java3");
        System.loadLibrary("MyLib");
    }</pre></div><div><h3 class="title2"><a id="note62" class="calibre1"/>Note</h3><p class="calibre8">If you use OpenCV Android SDK Version 2.*, you should load <code class="email">opencv_java</code> instead of <code class="email">opencv_java3</code>.</p></div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch04lvl2sec47" class="calibre1"/>Implementing the OpenCV Java code</h2></div></div></div><p class="calibre8">In this <a id="id436" class="calibre1"/>section, we will show you OpenCV in Java side to prepare the data for the stitching module in the OpenCV C++ side.</p><p class="calibre8">First, we will create a list to store all of the captured images when the user presses the <strong class="calibre9">Capture</strong> button:</p><div><pre class="programlisting">private List&lt;Mat&gt; listImage = new ArrayList&lt;&gt;();</pre></div><p class="calibre8">Then, in the <code class="email">onPictureTaken</code> method of the <code class="email">jpegCallback</code> variable, we want to convert the captured Bitmap into an OpenCV Mat and store in this <code class="email">listImage</code> list. You need to add these lines before the drawing parts with Canvas:</p><div><pre class="programlisting">Mat mat = new Mat();
Utils.bitmapToMat(bitmap, mat);
listImage.add(mat);</pre></div><p class="calibre8">Finally, when<a id="id437" class="calibre1"/> the user clicks the <strong class="calibre9">Save</strong> button, we would want to send the address of the images in <code class="email">listImage</code> to the OpenCV C++ code to perform the stitching process.</p><p class="calibre8">In <code class="email">imageProcessingRunnable</code>, we will add these codes after the <code class="email">showProcessingDialog</code> function call:</p><div><pre class="programlisting">try {
    // Create a long array to store all image address
    int elems=  listImage.size();
    long[] tempobjadr = new long[elems];
    for (int i=0;i&lt;elems;i++){
        tempobjadr[i]=  listImage.get(i).getNativeObjAddr();
    }
    // Create a Mat to store the final panorama image
    Mat result = new Mat();
    // Call the OpenCV C++ Code to perform stitching process
    NativePanorama.processPanorama(tempobjadr, result.getNativeObjAddr());

    // Save the image to external storage
    File sdcard = Environment.getExternalStorageDirectory();
    final String fileName = sdcard.getAbsolutePath() + "/opencv_" + System.currentTimeMillis() + ".png";
    Imgcodecs.imwrite(fileName, result);

    runOnUiThread(new Runnable() {
        @Override
        public void run() {
            Toast.makeText(getApplicationContext(), "File saved at: " + fileName, Toast.LENGTH_LONG).show();
        }
    });

    listImage.clear();
} catch (Exception e) {
    e.printStackTrace();
}</pre></div><p class="calibre8">In the preceding code, we will create a long array to store all the native addresses of each Mat image. Then, we will pass this long array and the native address of a <code class="email">Mat result</code>, to store the panorama image. The OpenCV C++ code will run to perform stitching with the stitching <a id="id438" class="calibre1"/>module. After this, we save the result into the external storage and make a simple toast to indicate to the user that the panorama is saved. Finally, we clear the <code class="email">listImage</code> list to start a new section.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_4"><a id="ch04lvl2sec48" class="calibre1"/>Implementing the OpenCV C++ code</h2></div></div></div><p class="calibre8">At this<a id="id439" class="calibre1"/> moment, we want to implement the <code class="email">processPanorama</code> in OpenCV C++. The implementation is really simple; we will only edit the <code class="email">com_example_panorama_NativePanorama.cpp</code> file as follows:</p><div><pre class="programlisting">#include "com_example_panorama_NativePanorama.h"
#include "opencv2/opencv.hpp"
#include "opencv2/stitching.hpp"

using namespace std;
using namespace cv;

JNIEXPORT void JNICALL Java_com_example_panorama_NativePanorama_processPanorama
  (JNIEnv * env, jclass clazz, jlongArray imageAddressArray, jlong outputAddress){
  // Get the length of the long array
  jsize a_len = env-&gt;GetArrayLength(imageAddressArray);
  // Convert the jlongArray to an array of jlong
  jlong *imgAddressArr = env-&gt;GetLongArrayElements(imageAddressArray,0);
  // Create a vector to store all the image
  vector&lt; Mat &gt; imgVec;
  for(int k=0;k&lt;a_len;k++)
  {
    // Get the image
    Mat &amp; curimage=*(Mat*)imgAddressArr[k];
    Mat newimage;
    // Convert to a 3 channel Mat to use with Stitcher module
    cvtColor(curimage, newimage, CV_BGRA2RGB);
    // Reduce the resolution for fast computation
    float scale = 1000.0f / curimage.rows;
    resize(newimage, newimage, Size(scale * curimage.rows, scale * curimage.cols));
    imgVec.push_back(newimage);
  }
  Mat &amp; result  = *(Mat*) outputAddress;
  Stitcher stitcher = Stitcher::createDefault();
  stitcher.stitch(imgVec, result);
  // Release the jlong array 
  env-&gt;ReleaseLongArrayElements(imageAddressArray, imgAddressArr ,0);
}</pre></div><p class="calibre8">In the<a id="id440" class="calibre1"/> preceding code, we converted the long array of image addresses into images and pushed into a vector called <code class="email">imgVec</code>. We also resized the image for fast computation. The stitching module is really easy to use.</p><p class="calibre8">First, we will create an instance of <code class="email">Stitcher</code>.</p><div><pre class="programlisting">  Stitcher stitcher = Stitcher::createDefault();</pre></div><p class="calibre8">Then, we use this stitcher to stitch our vector image of Mat. The panorama image will be saved into a resultant Mat.</p><p class="calibre8">The following screenshot shows an example of a panorama image processed with the default configuration:</p><div><img src="img/00065.jpeg" alt="Implementing the OpenCV C++ code" class="calibre11"/><div><p class="calibre28">A sample image captured in the corridor</p></div></div><p class="calibre12"> </p></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec34" class="calibre1"/>Application showcase</h1></div></div></div><p class="calibre8">In this<a id="id441" class="calibre1"/> section, we show some panorama images captured with our application. You can see that the application is capable of processing panorama images in both horizontal and vertical directions.</p><p class="calibre8">First, this is an image captured from the fifth floor of a building. We took this picture through a window glass so the light was dim. However, the panorama is good because there are many details so the feature matcher can do a great job.</p><div><img src="img/00066.jpeg" alt="Application showcase" class="calibre11"/><div><p class="calibre28">A sample image captured by the application</p></div></div><p class="calibre12"> </p><p class="calibre8">The following screenshot is an image captured in the evening on a balcony. The region on the top-left corner of the panorama is bad since this only contains a blank wall and the sky. Therefore, there were too little features to compare between images. Hence, the final panorama is not perfect in this region.</p><div><img src="img/00067.jpeg" alt="Application showcase" class="calibre11"/><div><p class="calibre28">A sample image captured by the application in the evening</p></div></div><p class="calibre12"> </p><p class="calibre8">The following<a id="id442" class="calibre1"/> screenshot was captured through a window. The lower half of the image is good. However, the sky still has some problems due to the lack of features, as in the previous image.</p><div><img src="img/00068.jpeg" alt="Application showcase" class="calibre11"/><div><p class="calibre28">Another sample image captured by the application in the evening</p></div></div><p class="calibre12"> </p><p class="calibre8">The following image was shot in a courtyard in front of the building in the afternoon. The lighting was good and there were many details, so the final panorama is perfect.</p><div><img src="img/00069.jpeg" alt="Application showcase" class="calibre11"/><div><p class="calibre28">A sample image captured by the application in the afternoon</p></div></div><p class="calibre12"> </p><p class="calibre8">This image <a id="id443" class="calibre1"/>was taken at the same period with the previous image. However, this image was captured with a wide range of angles and the light was different at each shot. Therefore, the lighting in the final panorama is not consistent.</p><div><img src="img/00070.jpeg" alt="Application showcase" class="calibre11"/><div><p class="calibre28">Another sample image captured by the application in the afternoon</p></div></div><p class="calibre12"> </p></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec35" class="calibre1"/>Further improvement</h1></div></div></div><p class="calibre8">In this<a id="id444" class="calibre1"/> section, we will show some improvements that you can consider while creating a fully featured panorama application.</p><p class="calibre8">First, you can make a better user interface for the user to capture a panorama image. The current user interface doesn't show that the application can capture images in both directions. A suggestion is to use the motion sensors (accelerometer and gyroscope) in the Android API to obtain the rotation of the device and adjust the position of the overlay image.</p><div><h3 class="title2"><a id="note63" class="calibre1"/>Note</h3><p class="calibre8">Motion <a id="id445" class="calibre1"/>Sensors API documentation is available at <a class="calibre1" href="http://developer.android.com/guide/topics/sensors/sensors_motion.html">http://developer.android.com/guide/topics/sensors/sensors_motion.html</a>.</p></div><p class="calibre8">Secondly, the <a id="id446" class="calibre1"/>current application resizes the captured image to decrease computation time. You may want to change some parameters of the Stitcher to have better performance. We suggest that you look at the documentation of the stitching module for more details. In our implementation, we will use the Stitcher class for<a id="id447" class="calibre1"/> simplification. However, there is a detailed sample in the OpenCV repository at <code class="email">samples/cpp/stitching_detailed.cpp</code>, where they show many options to improve the stability and quality of the final panorama.</p><div><h3 class="title2"><a id="note64" class="calibre1"/>Note</h3><p class="calibre8">The <a id="id448" class="calibre1"/>detailed sample of using the stitching module is available at <a class="calibre1" href="https://github.com/Itseez/opencv/blob/master/samples/cpp/stitching_detailed.cpp">https://github.com/Itseez/opencv/blob/master/samples/cpp/stitching_detailed.cpp</a>.</p></div><p class="calibre8">Thirdly, you can change the logic of our application to perform real-time stitching. That means we make a stitching image whenever there are two captured images. Then, we show the result with the help of a 360-degree user interface so that the user can know which is the missing region, if any.</p></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec36" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">This chapter showed a complete panorama application in Android Studio where OpenCV 3 is used in both the Java interface and the C++ interface with the support of the Native Development Kit (NDK). The chapter also introduced us to how to use the Android Camera API with the OpenCV library. Also, the chapter illustrated some basic implementation with the OpenCV 3 stitching module to perform image stitching.</p></div></body></html>