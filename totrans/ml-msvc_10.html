<html><head></head><body>
			<h1 id="_idParaDest-115" class="chapter-number"><a id="_idTextAnchor115"/>10</h1>
			<h1 id="_idParaDest-116"><a id="_idTextAnchor116"/>Building an Intelligent MSA Enterprise System</h1>
			<p>In previous chapters, we gradually built the ABC-MSA to demonstrate some of an MSA system’s features, techniques, and <span class="No-Break">traffic patterns.</span></p>
			<p>In this chapter, we will combine both MSA concepts and AI concepts to build an ABC-Intelligent-MSA system, which is an enhanced version of our ABC-MSA. The intelligent version of the ABC-MSA will use various AI algorithms to enhance the performance and general operations of the original <span class="No-Break">ABC-MSA system.</span></p>
			<p>ABC-Intelligent-MSA will be able to examine different traffic patterns and detect potential problems and then <strong class="bold">self-rectify</strong> or self-adjust to try to prevent the problem from taking place before it <span class="No-Break">actually happens.</span></p>
			<p>The ABC-Intelligent-MSA will be able to <strong class="bold">self-learn</strong> the traffic behavior, API calls, and response patterns, and try to <strong class="bold">self-heal</strong> if a traffic anomaly or problematic pattern is detected for <span class="No-Break">whatever reason.</span></p>
			<p>The following topics are covered in <span class="No-Break">this chapter:</span></p>
			<ul>
				<li>The machine <span class="No-Break">learning advantage</span></li>
				<li>Building your first <span class="No-Break">AI microservice</span></li>
				<li>The intelligent MSA system <span class="No-Break">in action</span></li>
				<li>Analyzing AI <span class="No-Break">service operations</span></li>
			</ul>
			<h1 id="_idParaDest-117"><a id="_idTextAnchor117"/>The machine learning advantage</h1>
			<p>There are many areas in <a id="_idIndexMarker535"/>our MSA where we can leverage AI to enhance the system’s reliability and operability. We will focus our system on two main potential areas of enhancement. One is to enhance the system response in case of a microservice failure or performance degradation. The second area of enhancement is to add a proactive circuit <span class="No-Break">breaker role.</span></p>
			<p>As we discussed in <a href="B18934_03.xhtml#_idTextAnchor039"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, the circuit breaker pattern is used to prevent a system cascading failure when one of the system’s microservices fails to respond to API consumer requests promptly. Should a microservice fail or perform poorly, our AI will try to take proactive action to fix the problem rather than waiting for the problem to be manually fixed for the system to return to <span class="No-Break">normal operation.</span></p>
			<p>In <a href="B18934_07.xhtml#_idTextAnchor079"><span class="No-Break"><em class="italic">Chapter 7</em></span></a>, we discussed the advantages of using <strong class="bold">Machine Learning</strong> (<strong class="bold">ML</strong>) and DL in MSA in detail. This <a id="_idIndexMarker536"/>chapter will focus on building two AI microservices to enhance our <span class="No-Break">MSA system.</span></p>
			<p>The first AI microservice is called a <strong class="bold">Performance Baseline Watchdog</strong> (<strong class="bold">PBW</strong>) service. The PBW is an <a id="_idIndexMarker537"/>ML microservice that creates a baseline for the expected performance of each microservice in the MSA system under a certain system load. Should the <a id="_idIndexMarker538"/>operational <a id="_idIndexMarker539"/>performance of the measured microservice fall under the performance baseline by the configurable value of <em class="italic">x</em>, the system should <a id="_idIndexMarker540"/>send a warning message to the <strong class="bold">Operation Support System</strong> (<strong class="bold">OSS</strong>) or the <strong class="bold">Network Management System</strong> (<strong class="bold">NMS</strong>) and should performance fall by <em class="italic">y</em> (which is also configurable), the system then should take predefined action(s) to try to self-rectify and self-heal the <span class="No-Break">MSA system.</span></p>
			<p>The second AI microservice we will build in this chapter is the <strong class="bold">Performance Anomaly Detector</strong> (<strong class="bold">PAD</strong>) service. The PAD is <a id="_idIndexMarker541"/>an ML microservice that takes a holistic view of the entire MSA system. The PAD learns the MSA performance patterns and tries to detect any anomalous behavior. It identifies “problematic patterns,” tries to automatically detect a problem before it happens, and accordingly takes proactive action to fix the faulty area of <span class="No-Break">the system.</span></p>
			<h1 id="_idParaDest-118"><a id="_idTextAnchor118"/>Building your first AI microservice</h1>
			<p>Before we start building our <a id="_idIndexMarker542"/>two AI microservices, we need to think about our training and test data first – how we will collect our training data, build the model accordingly, test the model and measure its reliability, and enhance the algorithm’s reliability <span class="No-Break">if needed.</span></p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">The AI services we are building in our MSA system are only a proof of concept to demonstrate the value of implementing AI in MSA systems. Rather, businesses should consider an AI service or model that matches their unique needs, business process, and their deployed <span class="No-Break">MSA system.</span></p>
			<p>We will also need to simulate the use cases themselves. Simulate a system’s microservice failure <a id="_idIndexMarker543"/>or performance degradation, simulate a cascading failure, and we should also be able to simulate some system’s outlier patterns to see how the algorithm would detect and react to <span class="No-Break">pattern anomalies.</span></p>
			<p>To do all this, let’s first understand how the PBW and PAD microservices fit with the overall system’s operation and how they would normally interact with the different <span class="No-Break">system’s components.</span></p>
			<h2 id="_idParaDest-119"><a id="_idTextAnchor119"/>The anatomy of AI enhancements</h2>
			<p>The main role of both the PBW and PAD is to enhance the stability and reliability of our MSA system. It is therefore <a id="_idIndexMarker544"/>imperative for both services to constantly watch individual microservices and the overall system performance and then take the necessary action when performance issues <span class="No-Break">are detected.</span></p>
			<p>The training data is first collected in a controlled environment for a specific training period, where normal, stable system operations and the average user load are simulated and applied. This can be achieved using some of the simulation tools we built, which will be discussed later in <span class="No-Break">this section.</span></p>
			<p>This training period creates an ideal first baseline that will be the main reference for the AI services to use during actual production time. The collected training data will then be used to build the algorithm. To achieve better and more accurate results, the training data and algorithm can be regularly tuned later when more information about real-time production traffic <span class="No-Break">is collected.</span></p>
			<p>The simulated load and system operations are tweaked through multiple simulation parameters. These parameters are tweaked regularly to mimic the actual acceptable operational performance. The algorithm tweaks would eventually stop (or become very minor) as the AI algorithms mature. The cycle of onboarding the AI services to the ABC-MSA system is demonstrated in <span class="No-Break"><em class="italic">Figure 10</em></span><span class="No-Break"><em class="italic">.1</em></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer178" class="IMG---Figure">
					<img src="image/B18934_10_1.jpg" alt="Figure 10.1: AI microservices implementation in ABC-Intelligent-MSA"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.1: AI microservices implementation in ABC-Intelligent-MSA</p>
			<p>More information <a id="_idIndexMarker545"/>on the simulation tools and parameters is coming up in the <span class="No-Break">next section.</span></p>
			<p>Once the AI services are operational, they will start collecting performance stats from each of the system’s microservices through periodic API calls and then compare these performance stats with the expected performance <span class="No-Break">or behavior.</span></p>
			<p>Should an individual microservice or the overall system performance deviate from what the AI expects to see, a system action will be triggered to either warn the system administrators or self-heal whenever possible. <span class="No-Break"><em class="italic">Figure 10</em></span><em class="italic">.2</em> shows the high-level architecture of the PBW and <span class="No-Break">PAD services:</span></p>
			<div>
				<div id="_idContainer179" class="IMG---Figure">
					<img src="image/B18934_10_2.jpg" alt="Figure 10.2: PBW and PAD services in ABC-Intelligent-MSA"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.2: PBW and PAD services in ABC-Intelligent-MSA</p>
			<p>The PBW’s algorithm calculates the expected performance metrics based on the performance stats <a id="_idIndexMarker546"/>collected. Collected performance stats include API call response time stats, the failures or failure rate of individual microservices, the API response code, and the load applied on the <span class="No-Break">microservice itself.</span></p>
			<p>Pre-defined actions are triggered based on how far the microservice deviates from the calculated performance metric. Based on the configuration of the PBW, the higher the deviation, the more likely a proactive action is to be triggered to try to self-heal. In the case of a slight deviation, however, no healing action is supposed to be trigged; a system warning informing the system administrator <span class="No-Break">is sufficient.</span></p>
			<p>The following table shows some of the possible system issues that could be encountered during the operations of an ABC-Intelligent-MSA system, and the actions the PBW service would take to try to rectify <span class="No-Break">the problem.</span></p>
			<p>The list shown in the table is only a sample of potential issues and can, of course, grow as more use cases <span class="No-Break">are considered:</span></p>
			<table id="table001-4" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Microservice Issue</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Triggered Action</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Slow responsiveness</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Scale the microservice vertically/horizontally or restart <span class="No-Break">the microservice</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Intermittent timeouts</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Scale vertically/horizontally <span class="No-Break">or restart</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>API call HTTP <span class="No-Break">response errors</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Check Apache, Flask, the JVM, the Docker volume, SQL service, etc.<span lang="en-US" xml:lang="en-US"> </span>Restart the service <span class="No-Break">if needed</span></p>
							<p>Restart the <span class="No-Break">microservice’s container</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Service is <span class="No-Break">unresponsive (down)</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Restart the <span class="No-Break">microservice’s container</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 10.1 – Potential ABC-Intelligent-MSA operational issues and the PBW’s self-healing actions</p>
			<p>The healing mechanism <a id="_idIndexMarker547"/>can be applied to the MSA system using multiple AI services, not necessarily only using the PBW and PAD that we are implementing in our ABC-Intelligent-MSA. This is just <span class="No-Break">an example.</span></p>
			<h2 id="_idParaDest-120"><a id="_idTextAnchor120"/>The self-healing process</h2>
			<p>All of the PBW’s healing actions listed in <em class="italic">Table 10.1</em> should not be taken in isolation from the PAD’s <a id="_idIndexMarker548"/>operations, but rather should be carefully coordinated with the PAD’s healing actions. A single issue in a microservice could (although not necessarily) trigger actions from both the PBW and PAD services at the same time and could consequently create an <span class="No-Break">operational conflict.</span></p>
			<p>In terms of the self-healing process, and to avoid conflict between the system’s AI services when triggering self-healing actions, whenever an action is determined and before it is triggered, the AI service sends an API call to the other AI services first (either directly or through the API gateway), declaring a <strong class="bold">Self-Healing Lock State</strong> in the troubled <a id="_idIndexMarker549"/>microservice. Accordingly, all the other AI services in the MSA system will hold off any actions that may have been planned related to that <span class="No-Break">troubled microservice.</span></p>
			<p>During the self-healing lock state, the <a id="_idIndexMarker550"/>only AI service allowed to work on the troubled microservice is the <strong class="bold">Healer AI Service</strong>, which is the AI service that <span class="No-Break">locked it.</span></p>
			<p>Once the healer has fixed the problem and detects a normal operation in the affected microservice, the healer then sends another API call to the other AI services in the MSA system declaring that the lock state <span class="No-Break">is over.</span></p>
			<p>If the healer is unable to self-heal and gives up on resolving the issue, it sends an alarm to the NMS/OSS and <a id="_idIndexMarker551"/>marks that microservice as <strong class="bold">unhealable</strong> for a specific configurable period of time, known as the <strong class="bold">Unhealable Wait Period</strong> (by default, <span class="No-Break">15 minutes).</span></p>
			<p>The unhealable wait period allows other AI services to try to heal that microservice and gives the healer a breather to pace out its operation across all other microservices in the <span class="No-Break">MSA system.</span></p>
			<p>To prevent healers from consuming system resources by slipping into indefinite healing attempts, healers <a id="_idIndexMarker552"/>will try to heal the troubled microservices for a specific number of healing attempts, configured through the <strong class="bold">Maximum Healing Attempts</strong> value (four attempts, by default), and will then completely give up trying. If the maximum healing attempts are exhausted, a manual system intervention will be needed to fix the <span class="No-Break">troubled microservice.</span></p>
			<p>System administrators can still configure indefinite healing attempts if needed, but this can consume system resources and may not be effective depending on the nature of the problem the MSA system or a specific microservice <span class="No-Break">is experiencing.</span></p>
			<p>If another AI service can fix the troubled microservice or the microservice is manually fixed, the original healer will automatically clear the unhealable flag of the microservice after the unhealable wait period <span class="No-Break">is over.</span></p>
			<p>If on the other hand, no other AI service can fix the problem and no manual intervention is taken to fix the microservice, the original healer – and any other healer that may have tried to fix the microservice – will try to heal the microservice again once the unhealable wait period expires if and only if the troubled microservice is not in a self-healing <span class="No-Break">lock state.</span></p>
			<p>The following visual chart summarizes the self-healing process and may help better explain the <span class="No-Break">entire process.</span></p>
			<div>
				<div id="_idContainer180" class="IMG---Figure">
					<img src="image/B18934_10_3.jpg" alt="Figure 10.3: The self-healing process in MSA"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.3: The self-healing process in MSA</p>
			<p>It is important to also understand the main terminology used to explain the self-healing process. The following <a id="_idIndexMarker553"/>table shows a summary of the terminology of the main components of our <span class="No-Break">self-healing process:</span></p>
			<table id="table002-2" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Term</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Description</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Healer</span></p>
						</td>
						<td class="No-Table-Style">
							<p>An AI service that attempts to heal a <span class="No-Break">troubled microservice.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Healing Action</span></p>
						</td>
						<td class="No-Table-Style">
							<p>An action taken by the healer to try to fix an ongoing system <span class="No-Break">operational issue.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Self-Healing <span class="No-Break">Lock State</span></p>
						</td>
						<td class="No-Table-Style">
							<p>A microservice state in which an attempt is made by the healer to fix <span class="No-Break">the microservice.</span></p>
							<p>In this state, only one healer (the one that initiated the lock state) is allowed to work on the <span class="No-Break">troubled microservice.</span></p>
							<p>A microservice self-healing lock state is a state visible by the entire MSA system and not a <span class="No-Break">healer-specific state.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Retry <span class="No-Break">Wait Period</span></p>
						</td>
						<td class="No-Table-Style">
							<p>The time the healer for which has to wait when a healing action fails before it retries. The Retry Wait Period is 2 min <span class="No-Break">by default.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Unhealable State</span></p>
						</td>
						<td class="No-Table-Style">
							<p>The state in which the troubled microservice is marked unfixable by a healer after a healer’s failed attempt to fix the <span class="No-Break">troubled microservice.</span></p>
							<p dir="rtl">A microservice unhealable state is a healer-specific state and only visible to the healer that gave up on fixing that troubled microservice. Other healers can still try to fix the <span class="No-Break">troubled microservice.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Unhealable <span class="No-Break">Wait Period</span></p>
						</td>
						<td class="No-Table-Style">
							<p>The time for which the healer has to wait before it starts to make another attempt to fix the troubled microservice. The Unhealable Wait Period is 15 min <span class="No-Break">by default.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Maximum <span class="No-Break">Healing Attempts</span></p>
						</td>
						<td class="No-Table-Style">
							<p>The maximum number of attempts the healer will try after each unhealable wait period, and before the healer totally gives up on the troubled microservice and no longer attempt to fix it. By default, PBW tries 4 <span class="No-Break">healing attempts.</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 10.2: ABC-Intelligent-MSA operational issues with the self-rectifying actions of the PBW</p>
			<p>So far, we have explained the value of deploying AI services in the MSA system and shown some practical <a id="_idIndexMarker554"/>application examples to demonstrate the value of AI <span class="No-Break">in MSA.</span></p>
			<p>In order to build, run, and tweak AI services in MSA, we need to build certain tools to gather and log system <a id="_idIndexMarker555"/>statuses, operational dynamics, and operational statistics. In the following section, we will dive into what these tools are and how to <span class="No-Break">use them.</span></p>
			<h2 id="_idParaDest-121"><a id="_idTextAnchor121"/>Building the necessary tools</h2>
			<p>The purpose of creating project tools is to first be able to build the AI models, then simulate the <a id="_idIndexMarker556"/>entire ABC-Intelligent-MSA system, and then collect stats and analyze the <span class="No-Break">system’s operations.</span></p>
			<p>Although there may be tools available online that would help us achieve our purpose, instead, we will build simple tools customized specifically for our <span class="No-Break">use cases.</span></p>
			<p>We created multiple tools to help us collect training and test data, simulate the system and microservices load, and measure the performance of the microservices. All the tools are available in the <strong class="source-inline">tools</strong> directory in our <span class="No-Break">GitHub repository.</span></p>
			<p>The tools also help us scrub some of the generated logs and data for analysis and potential <span class="No-Break">future enhancements.</span></p>
			<p>The following are the main tools we need in our <span class="No-Break">ABC-Intelligent-MSA setup.</span></p>
			<h3>An API traffic simulator</h3>
			<p>The API traffic generator/simulator, <strong class="source-inline">simulate_api_rqsts.py</strong>, helps simulate the API request <a id="_idIndexMarker557"/>load for one or more of <a id="_idIndexMarker558"/>the <span class="No-Break">system’s microservices.</span></p>
			<p><strong class="source-inline">simulate_api_rqsts</strong> creates multi-threaded API requests across multiple target microservices. API HTTP requests are then sent to each microservice <span class="No-Break">in parallel.</span></p>
			<p>The API load is measured by requests per minute and API requests can either be uniformly or <span class="No-Break">randomly paced.</span></p>
			<p>The uniformly paced requests are paced out so that the time between each API call is always the same, so if we are configuring a uniformly paced load of 600 API requests/min, <strong class="source-inline">simulate_api_rqsts</strong> will send 1 API call every T = <span class="No-Break">100 ms.</span></p>
			<p>In the randomly-paced case, each API call is sent after a random period, T<span class="subscript">R</span>, from the time where the previous call was sent, but so that T<span class="subscript">R</span> can never be larger or smaller than 95% of T. So if we are configuring a randomly-paced load of 600 API requests/min, T<span class="subscript">R</span>, in that case, will be equal to a value greater than 5 ms and smaller than <span class="No-Break">195 ms.</span></p>
			<p><strong class="source-inline">simulate_api_rqsts</strong> will send 1 API <span class="No-Break">call every:</span></p>
			<p><em class="italic">(1-95%)T &lt;= T</em><span class="subscript">R</span><em class="italic"> &lt;= (1+95%)T</em> (i.e., for 600 requests/min: <em class="italic">5 ms &lt;= TR &lt;= </em><span class="No-Break"><em class="italic">195 ms</em></span><span class="No-Break">)</span></p>
			<p>The sum of all T<span class="subscript">R</span>s, however, will still be approximately equal to the configured requests/min. In our example here, the load is 600 <span class="No-Break">API requests/min.</span></p>
			<p>Uniformly paced <a id="_idIndexMarker559"/>requests are better when <a id="_idIndexMarker560"/>you are manually analyzing how a particular microservice responds to the API load, while randomly paced requests are a better representation of a real-time production API <span class="No-Break">request load.</span></p>
			<h3>The microservices performance monitor</h3>
			<p>The microservices performance monitor, <strong class="source-inline">ms_perfmon.py</strong>, is another multithreading tool and is <a id="_idIndexMarker561"/>initially used for collecting <a id="_idIndexMarker562"/>and building the AI training data during the simulation period of <span class="No-Break">ideal conditions.</span></p>
			<p><strong class="source-inline">ms_perfmon</strong> sends parallel API calls to each microservice in the system and then logs the API call hyperlink, the date and time at which it was sent, the receiving microservice response time, and the HTTP response code. The following is an example log entry of the collected data in a <span class="No-Break">comma-separated format:</span></p>
			<pre class="source-code">http://payment_ms:8080,2022-12-28 15:48:57.271370, 0.010991334915161133,200</pre>
			<p>Each microservice stat is collected in its own <strong class="bold">Comma-Separated Values</strong> (<strong class="bold">CSV</strong>) log file named <a id="_idIndexMarker563"/>after the API link itself (after cleaning up special characters). All the stat files are collected under the <strong class="source-inline">perfmon_stats</strong> directory in the <strong class="source-inline">ms_perfmon</strong> <span class="No-Break">working path.</span></p>
			<p>In real-time operation, both the PBW and PAD perform a similar job to <strong class="source-inline">ms_perfmon</strong>. They collect their own stats and measure the target microservice’s real-time performance against the baseline and the expected <span class="No-Break">normal behavior.</span></p>
			<p>Should we extend the MSA system’s AI capabilities by including more AI services for different purposes and use cases, which will likely require each AI service to conduct its own performance <span class="No-Break">statistics collection?</span></p>
			<p>Depending on the collection frequency and the type of data collected, as the number of collectors increases, scalability could become an issue. The <strong class="source-inline">ms_perfmon</strong> function, in that case, can be extended to become the main AI collector for all AI or non-AI services in the MSA system. This setup can help offload the system’s microservices and allow the MSA system to <span class="No-Break">scale better.</span></p>
			<div>
				<div id="_idContainer181" class="IMG---Figure">
					<img src="image/B18934_10_4.jpg" alt="Figure 10.4: A collect-once performance stats setup in ABC-Intelligent-MSA"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.4: A collect-once performance stats setup in ABC-Intelligent-MSA</p>
			<p><span class="No-Break"><em class="italic">Figure 10</em></span><em class="italic">.4</em> shows how <strong class="source-inline">ms_perfmon</strong> can handle stats collection on behalf of all other services in <a id="_idIndexMarker564"/>the MSA system and then <a id="_idIndexMarker565"/>act as a proxy and respond to API calls requesting whatever stats are needed for each particular AI (or <span class="No-Break">non-AI) service.</span></p>
			<h3>The response delay simulator</h3>
			<p>To simulate a delayed <a id="_idIndexMarker566"/>response or a troubled microservice, and <a id="_idIndexMarker567"/>solely for simulation and testing purposes, we added a feature in key microservices to simulate a delayed API <span class="No-Break">call response.</span></p>
			<p>The delay response feature, when enabled in the microservice, has two configurable values – the minimum delay and the maximum delay. When a microservice receives an API call, it will automatically assign a random delay value between the configured minimum delay and maximum delay, and then wait for that time before it responds to the consumer’s <span class="No-Break">API calls.</span></p>
			<p>The feature is very helpful for simulating a cascading system failure. As will be shown later in this chapter, the response delay feature can also help demonstrate the value of using AI services to enhance the operations of the MSA system compared to using the short circuit traffic pattern previously explained in <a href="B18934_03.xhtml#_idTextAnchor039"><span class="No-Break"><em class="italic">Chapter 3</em></span></a><span class="No-Break">.</span></p>
			<p>The response <a id="_idIndexMarker568"/>delay is enabled whenever the max delay is configured <a id="_idIndexMarker569"/>with a value greater than zero. When the value of max delay is higher than zero, a delay value is assigned to the microservice API’s call response, as shown in the following <span class="No-Break">code snippet:</span></p>
			<pre class="source-code">#Simulate a delay if received an API to do so
if delay_max_sec &gt; 0:
  delay_seconds = round(delay_min_sec + random.random()*(delay_max_sec-delay_min_sec), 3)
  #print("Adding a delay %s ..." %delay_seconds)
  time.sleep(delay_seconds)</pre>
			<p>The max and min delay values can be configured using an API call. The following is an example of using <strong class="source-inline">curl</strong> to send an API call to configure the maximum and minimum delay response <span class="No-Break">in milliseconds:</span></p>
			<pre class="source-code">curl http://inventory_ms:8080/api/simulatedelay?min=1500&amp;max=3500</pre>
			<p>Again, this feature is only for demo and test purposes. A more secure way of simulating a delay is using secured configuration files or local <span class="No-Break">parameters instead.</span></p>
			<h3>The API response error simulator</h3>
			<p>Similar to the response delay simulator, this feature is for demo purposes only. The API error <a id="_idIndexMarker570"/>simulator feature uses one configurable <a id="_idIndexMarker571"/>value – the average HTTP error per hour. When the feature is enabled in the microservice, the microservice will pick a randomly applicable server 500 error and respond to API requests with randomly paced responses that match the configured <span class="No-Break">error rate.</span></p>
			<p>The error rate can be configured using an API call. The following is an example of using <strong class="source-inline">curl</strong> to send an API call to configure an API error response rate of <strong class="source-inline">5</strong> HTTP errors <span class="No-Break">per hour:</span></p>
			<pre class="source-code">curl http://inventory_ms:8080/api/response_err?rate=5</pre>
			<p>Now, we know <a id="_idIndexMarker572"/>the testing and simulation <a id="_idIndexMarker573"/>tools available for us to use for training, testing, and simulating production for our <span class="No-Break">MSA system.</span></p>
			<p>In the next section, we will discuss our ABC-Intelligent-MSA operations – how to initialize the system, how to build and use training and testing data, and how to simulate the system’s <span class="No-Break">production traffic.</span></p>
			<h1 id="_idParaDest-122"><a id="_idTextAnchor122"/>The intelligent MSA system in action</h1>
			<p>In the previous sections of this chapter, we discussed how the different system components <a id="_idIndexMarker574"/>interact with each other and what tools we use to build the AI algorithms, test the system, and monitor the operations of <span class="No-Break">different components.</span></p>
			<p>In this section, we will put our ABC-Intelligent-MSA to the test. We will run all system microservices and tools, and see how the different system components actually interact with each other, what results we see, and how we can tweak the system to maintain smooth <span class="No-Break">end-to-end operations.</span></p>
			<p>The ABC-Intelligent-MSA will first run under an ideal simulation environment (no error simulation and no delays) to collect the training data necessary to build the AI models. Once enough data has been collected, we will then train the models and prepare the system for actual <span class="No-Break">production traffic.</span></p>
			<p>The system initialization steps, therefore, are <span class="No-Break">as follows:</span></p>
			<ol>
				<li>Start the system with no AI services to collect the necessary training data under an ideal operational situation and create an <span class="No-Break">operational baseline.</span></li>
				<li>Sanitize the collected data if needed and <span class="No-Break">remove outliers.</span></li>
				<li>Train the AI algorithms using the training <span class="No-Break">data collected.</span></li>
				<li>Re-initialize the system with all of its <span class="No-Break">AI services.</span></li>
				<li>Start production <a id="_idIndexMarker575"/>operations. In our example here, we will simulate actual production operations by injecting errors, data delay responses, service failures, and <span class="No-Break">so on.</span></li>
			</ol>
			<h2 id="_idParaDest-123"><a id="_idTextAnchor123"/>Initializing the ABC-Intelligent-MSA system</h2>
			<p>We start by initializing our MSA system using the system’s Docker compose file, <strong class="source-inline">abc_ msa.yaml</strong>, and <a id="_idIndexMarker576"/>using the <strong class="source-inline">docker-compose</strong> command <span class="No-Break">as follows,</span></p>
			<pre class="console">$ docker-compose -f abc_msa.yaml up &amp;</pre>
			<p>As discussed previously in <a href="B18934_09.xhtml#_idTextAnchor102"><span class="No-Break"><em class="italic">Chapter 9</em></span></a>, the preceding <strong class="source-inline">docker-compose</strong> command is much more convenient than using multiple <strong class="source-inline">docker run</strong> commands. <strong class="source-inline">docker-compose</strong> will read the system’s run parameters and configuration from the <strong class="source-inline">abc _msa.yaml</strong> file, and initialize all the system <span class="No-Break">components accordingly.</span></p>
			<p>In our example, this will start the analysis and monitoring tools, along with all the regular microservices in the system. Since we are still collecting training data, no AI services need to be <span class="No-Break">initialized yet.</span></p>
			<p>As shown in <span class="No-Break"><em class="italic">Figure 10</em></span><em class="italic">.2</em> and <span class="No-Break"><em class="italic">Figure 10</em></span><em class="italic">.4</em>, when we start the AI services (the PBW and PAD), they will need to be able to remotely control (start, stop, and restart) the system’s Docker containers. The PBW and PAD are designed to control the Docker containers using API calls. Therefore, we need to enable Docker Engine first to respond to API calls and for the PBW and PAD to be able to successfully communicate with <span class="No-Break">Docker Engine.</span></p>
			<p>The following are the steps needed to enable Docker’s API <span class="No-Break">remote management:</span></p>
			<ol>
				<li value="1">On your Ubuntu system, use <strong class="source-inline">vi</strong>, <strong class="source-inline">vim</strong>, or any other similar tool to edit the <strong class="source-inline">/</strong><span class="No-Break"><strong class="source-inline">lib/systemd/system/docker.service</strong></span><span class="No-Break"> file.</span></li>
				<li>Look for the <strong class="source-inline">ExecStart</strong> entry and make the necessary modifications for it to be like <span class="No-Break">the following:</span><pre class="source-code"><strong class="bold">ExecStart=/usr/bin/dockerd -H=fd:// -H=tcp://0.0.0.0:2375</strong></pre></li>
				<li>This will enable Docker Engine to listen to API calls. Make sure you save the file after <span class="No-Break">the modifications.</span></li>
				<li>Reload Docker Engine using the <span class="No-Break">following command:</span><pre class="source-code"><strong class="bold">systemctl daemon-reload</strong></pre></li>
				<li>To ensure Docker Engine is working properly and responding to API calls, use the <span class="No-Break">following command:</span><pre class="source-code"><strong class="bold">curl http://localhost:8080/version</strong></pre></li>
			</ol>
			<p>Now, the <a id="_idIndexMarker577"/>system is running and collecting training data. The longer you run the system, the more training data will be collected, and the more accurate your AI models will be. In our example, we will leave the system running for approximately <span class="No-Break">48 hours.</span></p>
			<p>In the next subsection, we will go over how to run the tools, build training data, collect some of the system performance logs, simulate real-time system operations, and analyze the collected <span class="No-Break">performance data.</span></p>
			<h2 id="_idParaDest-124"><a id="_idTextAnchor124"/>Building and using the training data</h2>
			<p>The <strong class="source-inline">ms_perfmon</strong> tool will create a separate stat file for each microservice in the <strong class="source-inline">&lt;ms_perfmon's working path&gt;/perfmon_stats</strong> directory. It is important that we <a id="_idIndexMarker578"/>leave the tool running and <a id="_idIndexMarker579"/>monitor the system’s performance stats under minimal <span class="No-Break">load conditions.</span></p>
			<p>We recommend at least 48 hours of training data collection. Ideally, however, data should be collected with seasonality load whenever applicable. In some environments, for example, the system load may increase on weekends over weekdays, during the shopping season, and so on. These situations should be considered in the training data to be able to build a more accurate <span class="No-Break">AI model.</span></p>
			<p>Performance data is pulled every 10 seconds, and accordingly, with 48h of active monitoring, <strong class="source-inline">ms_perfmon</strong> produces 17,280 entries for <span class="No-Break">each microservice.</span></p>
			<p>Regardless of the length of the system’s training period, whenever enough performance data has been collected, the <strong class="source-inline">training_data_cleanup.py</strong> tool should be run to detect any outliers and sanitize the performance data before using it in our <span class="No-Break">AI services.</span></p>
			<p>The <strong class="source-inline">training_data_cleanup</strong> tool scrubs all the performance data files in the <strong class="source-inline">&lt;ms_perfmon's working path&gt;/perfmon_stats</strong> directory, and automatically creates a <strong class="source-inline">scrubbed_stats</strong> directory with all the scrubbed data for each microservice. These scrubbed files are the files that we will later use for training the <span class="No-Break">AI services.</span></p>
			<p>We are now ready to write our Python code for training <span class="No-Break">the PBW:</span></p>
			<ol>
				<li value="1">We will <a id="_idIndexMarker580"/>use the <strong class="source-inline">numpy</strong> library for <a id="_idIndexMarker581"/>array and scientific data processing, <strong class="source-inline">pandas</strong> for reading our CSV training data files and testing data, and <strong class="source-inline">sklearn</strong> to build our <span class="No-Break">AI model:</span><pre class="source-code">import numpy as np
import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression</pre></li>
				<li>After importing the required libraries, we now need to copy all performance data into a DataFrame object. The following is a code example <span class="No-Break">of this:</span><pre class="source-code">payment_ms_stats_df = pd.read_csv('scrubbed_stats/ payment_ms_stats.csv')</pre></li>
			</ol>
			<p>The PBW’s AI model includes the microservice response time, the calculated request failure rate, and the calculated microservice load. The model should calculate the expected response time based on all the <span class="No-Break">preceding parameters.</span></p>
			<ol>
				<li value="3">In our Python code, we need to point to the data column that needs to be predicted. In our example, that would be the response time. The following is a code snippet for the <span class="No-Break">Payment microservice:</span><pre class="source-code">payment_ms_rt = np.array(payment_ms_stats_df['response_time'])</pre></li>
				<li>We need now to build our model, but before doing so, we need to load the rest of the performance data column into an array for training and testing processing. We do that by removing the “response time” column (an axis of <strong class="source-inline">1</strong>) from the created DataFrame and then loading that DataFrame into an array to be used in our <strong class="source-inline">sklearn</strong> object, <span class="No-Break">as follows:</span><pre class="source-code">model_data = payment_ms_stats_df.drop('response_time', axis = 1)
model_data = np.array(model_data)</pre></li>
				<li>The <a id="_idIndexMarker582"/>model data need to be <a id="_idIndexMarker583"/>split into training data and test data. We split the model data into 80% training and 20% test data <span class="No-Break">as follows:</span><pre class="source-code">model_data_train, model_data_test, payment_ms_rt_train, payment_ms_rt_test = train_test_split(model_data, payment_ms_rt, test_size = 0.20, shuffle=True)</pre></li>
				<li>Now, we build the model from the <span class="No-Break">training data:</span><pre class="source-code">lr_model = LinearRegression()
lr_model.fit(model_data_train, payment_ms_rt_train);</pre></li>
				<li>Save the data to a CSV file for <span class="No-Break">future use:</span><pre class="source-code">trend_payment_ms_rt_predictions = lr_model.predict(payment_ms_rt)
df = payment_ms_rt_df.assign(predicted_payment_ms_rt = trend_payment_ms_rt_predictions)
df.to_csv("predicted_payment_ms_rt_trend.csv", mode = 'w', index=False)</pre></li>
			</ol>
			<p>Now, we have the training data and the trained model. It is time to use the model for <span class="No-Break">production traffic.</span></p>
			<p>In the next subsection, we will simulate production operations and describe how that can be applied to our trained MSA system, <span class="No-Break">the ABC-Intelligent-MSA.</span></p>
			<h2 id="_idParaDest-125"><a id="_idTextAnchor125"/>Simulating the ABC-Intelligent-MSA’s operation</h2>
			<p>We need to reinitialize the system now with the trained model and production traffic. Since no actual <a id="_idIndexMarker584"/>production traffic is applied in our example, we need to simulate the production operation with its potential operational challenges, including high traffic loads, service failures, and potential <span class="No-Break">network hiccups.</span></p>
			<p>We start by reinitializing the ABC-Intelligent-MSA system using <strong class="source-inline">docker-compose</strong>, as described earlier, but using the <span class="No-Break"><strong class="source-inline">abc_intelligent_msa.yaml</strong></span><span class="No-Break"> file:</span></p>
			<pre class="console">$ docker-compose -f abc_intelligent_msa.yaml up &amp;</pre>
			<p>The main difference between <strong class="source-inline">abc_intelligent_msa.yaml</strong> and <strong class="source-inline">abc _msa.yaml</strong> is that the first file includes the initialization of the <span class="No-Break">AI services.</span></p>
			<p>Once the system is running, the AI tools will start monitoring and collecting the microservice’s performance and trigger healing actions whenever a system problem is detected and metrics exceed the configured <span class="No-Break">performance thresholds.</span></p>
			<p>The production traffic is ready to be simulated now using the <strong class="source-inline">simulate_api_rqsts</strong> API traffic simulator and the response delay simulator function <span class="No-Break">discussed earlier.</span></p>
			<p>Using the API response error simulator, occasional HTTP errors can also be simulated if needed. A more sophisticated simulation would involve injecting HTTP 500 error codes as well, but we will stick to response time performance delays <span class="No-Break">for simplicity.</span></p>
			<p>The <strong class="source-inline">ms_perfmon</strong> tool will still be running to collect data for our offline analysis <span class="No-Break">whenever needed.</span></p>
			<p>We now need to simulate specific production use cases and see how the AI tools will respond and self-heal the entire system. In the next section, we will discuss the operations of the PBW and PAD and look into how both AI services interact with system performance readings <span class="No-Break">and errors.</span></p>
			<h1 id="_idParaDest-126"><a id="_idTextAnchor126"/>Analyzing AI service operations</h1>
			<p>In the preceding <a id="_idIndexMarker585"/>sections, we started by building our first AI service and covered how to use AI to enhance the MSA system’s operations and resilience, the self-healing process, and the tools we built to generate training data and simulate the ABC-Intelligent-MSA <span class="No-Break">system’s operation.</span></p>
			<p>In this section, we will examine the system logs and check how the PBW and PAD interact with <a id="_idIndexMarker586"/>the system and actually enhance its operations. We will then simulate a cascading system failure and examine how the self-healing process is triggered and handled to bring the MSA system back to <span class="No-Break">normal operation.</span></p>
			<h2 id="_idParaDest-127"><a id="_idTextAnchor127"/>The PBW in action</h2>
			<p>During the training period, the PBW was able to build an AI model and calculate the expected <a id="_idIndexMarker587"/>response time of each microservice in <a id="_idIndexMarker588"/>the ABC-Intelligent-MSA system. As you can see from the following log sample, under a normal system load, the average response time of the Inventory microservice is about <span class="No-Break">20 ms:</span></p>
			<pre class="source-code">http://inventory_ms:8080,2022-11-23 15:48:25.094675, 0.01450204849243164,200
http://inventory_ms:8080,2022-11-23 15:48:35.816913, 0.0241086483001709,200
http://inventory_ms:8080,2022-11-23 15:48:46.543205, 0.02363872528076172,200
http://inventory_ms:8080,2022-11-23 15:48:57.271370, 0.010991334915161133,200
http://inventory_ms:8080,2022-11-23 15:49:07.983282, 0.021454334259033203,200
http://inventory_ms:8080,2022-11-23 15:49:18.645113, 0.012285232543945312,200
http://inventory_ms:8080,2022-11-23 15:49:29.310656, 0.0245664119720459,200
http://inventory_ms:8080,2022-11-23 15:49:40.010556, 0.013091325759887695,200
http://inventory_ms:8080,2022-11-23 15:49:50.744695, 0.021291017532348633,200
http://inventory_ms:8080,2022-11-23 15:50:01.715555, 0.024635791778564453,200</pre>
			<p>We configured the warning threshold for the PBW as 250 ms, and the action threshold as 750 ms. We will now start introducing an API call load to the Inventory microservice using <strong class="source-inline">simulate_api_rqsts</strong> and delays using the response delay simulator feature. Then, we will see how the PBW reacts from the PBW <span class="No-Break">action logs.</span></p>
			<p>The following are the PBW’s performance readings for about 1.5 minutes. As you can see from the <a id="_idIndexMarker589"/>readings, the response time is consistently <a id="_idIndexMarker590"/>above the 250 ms alarm threshold, but (with the exception of one reading) still below the 750 ms <span class="No-Break">action threshold:</span></p>
			<pre class="source-code">http://inventory_ms:8080,2022-11-23 18:24:00.518005, 0.6386377334594727,200
http://inventory_ms:8080,2022-11-23 18:24:11.469172, 0.7164063453674316,200
http://inventory_ms:8080,2022-11-23 18:24:22.203452, 0.7233438491821289,200
http://inventory_ms:8080,2022-11-23 18:24:32.942619, 0.7101089954376221,200
http://inventory_ms:8080,2022-11-23 18:24:43.668907, 0.6982685089111328,200
http://inventory_ms:8080,2022-11-23 18:24:54.777383, 0.8207950115203857,200
http://inventory_ms:8080,2022-11-23 18:25:05.410204, 0.6812236309051514,200
http://inventory_ms:8080,2022-11-23 18:25:16.101344, 0.6544813632965088,200
http://inventory_ms:8080,2022-11-23 18:25:27.072040, 0.7446155548095703,200
http://inventory_ms:8080,2022-11-23 18:25:37.828189, 0.6969136238098145,200</pre>
			<p>The readings will have to be consistently above the 750 ms action threshold for the PBW to trigger a healing action. One reading above 750 ms is not enough for an action to be triggered. However, since the readings are constantly above the 250 ms alarm threshold, the PBW is expected to trigger an alarm to the <span class="No-Break">NMS/OSS system.</span></p>
			<p>We need to verify the PBW’s behavior from the NMS/OSS system or the PBW’s action log. The following <a id="_idIndexMarker591"/>is a snippet of the PBW’s action <a id="_idIndexMarker592"/>log during the same period from the <span class="No-Break">previous example:</span></p>
			<pre class="source-code">2022-11-23 18:24:00.518005: Alarming high response time (0.6386377334594727) detected in inventory_ms. No alarm triggered yet.
2022-11-23 18:24:11.469172: Alarming high response time (0.7164063453674316) detected in inventory_ms. No alarm triggered yet.
2022-11-23 18:24:22.203452: Alarming high response time (0.7233438491821289) detected in inventory_ms. No alarm triggered yet.
2022-11-23 18:24:32.942619: Alarming high response time (0.7101089954376221) detected in inventory_ms. No alarm triggered yet.
2022-11-23 18:24:43.668907: Alarming high response time (0.6982685089111328) detected in inventory_ms. No alarm triggered yet.
2022-11-23 18:24:54.777383: Actionable high response time (0.8207950115203857) detected in inventory_ms. No action triggered yet.
2022-11-23 18:25:05.410204: Alarming high response time (0.6812236309051514) detected in inventory_ms. No alarm triggered yet.
2022-11-23 18:25:16.101344: Alarming high response time (0.6544813632965088) detected in inventory_ms. No alarm triggered yet.
2022-11-23 18:25:27.072040: Alarming high response time (0.7446155548095703) detected in inventory_ms. No alarm triggered yet.
2022-11-23 18:25:37.828189: Alarming high response time (0.6969136238098145) detected in inventory_ms. Yellow alarm triggered and sent to NMS/OSS system.
2022-11-23 18:25:48.637317: Alarming high response time (0.6777710914611816) detected in inventory_ms. Yellow alarm triggered and sent to NMS/OSS system.
2022-11-23 18:25:59.327946: Alarming high response time (0.6758050918579102) detected in inventory_ms. Yellow alarm triggered and sent to NMS/OSS system.
2022-11-23 18:26:10.014319: Alarming high response time (0.6641242504119873) detected in inventory_ms. Yellow alarm triggered and sent to NMS/OSS system.</pre>
			<p>As you can see from the preceding snippet’s last 4 log entries, after a consistent delay of more than 250 ms, an alarm was triggered and sent to the NMS/OSS system. We need to increase the inventory microservice’s load and response time to see how the PBW <span class="No-Break">will react.</span></p>
			<p>The following is <a id="_idIndexMarker593"/>another snippet of the PBW’s performance <a id="_idIndexMarker594"/>log. Only the last 4 log entries in a series of 10 consistent response delay readings are above <span class="No-Break">750 ms:</span></p>
			<pre class="source-code">http://inventory_ms:8080,2022-11-23 18:29:31.852330, 1.326528787612915,200
http://inventory_ms:8080,2022-11-23 18:29:43.196200, 1.4279899597167969,200
http://inventory_ms:8080,2022-11-23 18:30:05.310226, 1.0108487606048584,200
http://inventory_ms:8080,2022-11-23 18:30:16.334608, 1.1380960941314697,200</pre>
			<p>Normally, we would have configured all healing actions shown in <em class="italic">Table 10.1</em>. In our demo system, however, we have configured only one healing action to demo the system self-healing operations in general. We only configured a microservice container to restart if a problem is experienced in the microservice. The response delay simulator feature is therefore a more relevant simulation tool than the other tools we have <span class="No-Break">mentioned earlier.</span></p>
			<p>In case of slow performance due to high API call requests volume, the most appropriate healing action would be to try to scale the microservice first and allocate more resources to respond to the high volume of <span class="No-Break">API requests.</span></p>
			<p>We assume in our simulation that the problem in the Inventory microservice is not necessarily due to the API request load, but rather some unforeseen problem causing the Inventory service to become unstable and unable to handle API calls promptly, so restarting the Inventory microservice could therefore fix <span class="No-Break">the problem.</span></p>
			<p>Now, here is a <a id="_idIndexMarker595"/>look at the PBW’s action log during the <a id="_idIndexMarker596"/>same period. Please note that prior to the actionably high response time, an alarmingly high response time below 750 ms was previously detected. The response time was higher than 250 ms and below <span class="No-Break">750 ms:</span></p>
			<pre class="source-code">2022-11-23 18:29:31.852330: Actionable high response time (1.326528787612915) detected in inventory_ms. No action triggered yet. Yellow alarm triggered and sent to NMS/OSS system.
2022-11-23 18:29:43.196200: Actionable high response time (1.4279899597167969) detected in inventory_ms. No action triggered yet. Yellow alarm triggered and sent to NMS/OSS system.
2022-11-23 18:30:05.310226: Actionable high response time (1.0108487606048584) detected in inventory_ms. No action triggered yet. Yellow alarm triggered and sent to NMS/OSS system.
2022-11-23 18:30:16.334608: Actionable high response time (1.1380960941314697) detected in inventory_ms. Red Alarm triggered and sent to NMS/OSS system.
2022-11-23 18:30:16.334608: Self-healing lock state declared for inventory_ms container.
2022-11-23 18:30:16.334608: Self-healing action triggered. Restarting inventory_ms container (inventory_management_container).
2022-11-23 18:30:21.359377: Verifying inventory_ms operations...
2022-11-23 18:30:22.945823: inventory_ms was successfully restarted
2022-11-23 18:30:23.089051: Self-healing lock state cleared for inventory_ms container.</pre>
			<p>As you see from the last 4 entries in the action log, the PBW detected a consistent response time (above 750 ms) and accordingly sent a red alarm to the NMS/OSS system, indicating a critical delay in the Inventory service and the need for a self-healing action to be taken. The PBW then locked the Inventory microservice to avoid clashing with healing actions <a id="_idIndexMarker597"/>from other AI services. The PBW then <a id="_idIndexMarker598"/>restarted the Inventory microservice by sending a restart API call to Docker Engine, verified that the Inventory microservice was back online, and finally unlocked the <span class="No-Break">Inventory microservice.</span></p>
			<p>To restart a Docker container through API, you will need to send a <strong class="source-inline">POST</strong> request <span class="No-Break">as follows:</span></p>
			<pre class="source-code">/containers/&lt;container id or name&gt;/restart</pre>
			<p>You can also specify the number of seconds to wait before restarting the container using a <strong class="source-inline">t</strong> parameter. The following is a container restart <strong class="source-inline">POST</strong> example to restart the Inventory service container after a 10-second <span class="No-Break">wait time:</span></p>
			<pre class="source-code">/v1.24/containers/inventory_management_container/restart?t=10</pre>
			<p>For more information <a id="_idIndexMarker599"/>on how to control Docker Engine using API calls, check the Docker Engine API documentation <span class="No-Break">at </span><a href="https://docs.docker.com/engine/api/version-history/"><span class="No-Break">https://docs.docker.com/engine/api/version-history/</span></a><span class="No-Break">.</span></p>
			<p>However, was the PBW able to fix the Inventory <span class="No-Break">microservice problem?</span></p>
			<p>Let’s go back now to the PBW’s performance log and see how this self-healing action impacted the Inventory service performance. The following are the log entries just before the healing action <span class="No-Break">was triggered:</span></p>
			<pre class="source-code">http://inventory_ms:8080,2022-11-23 18:30:16.334608, 0.1380960941314697,200
http://inventory_ms:8080,2022-11-23 18:30:27.629649, 0.1693825721740723,200
http://inventory_ms:8080,2022-11-23 18:30:38.486793, 0.1700718116760254,200</pre>
			<p>Sure enough, the response time dropped from above 1 s to a maximum of 170 ms. Not as low as it was before the problem appeared, but the Inventory microservice for sure has some breathing room now. The performance issues may very well return if the underlying problem is not attended to and <span class="No-Break">properly fixed.</span></p>
			<p>In a more advanced AI model, we can train and configure the system to take more sophisticated actions to fully resolve the problem whenever needed, but in this book, we are limited to <a id="_idIndexMarker600"/>a specific scope to be able to <a id="_idIndexMarker601"/>demonstrate the idea in principle and pave the way for you to develop your own AI models and algorithms for your specific <span class="No-Break">use cases.</span></p>
			<p>We have demonstrated in this section how the PBW works and how an action is triggered when a microservice performance issue is detected. In the following section, we will go over the PAD AI service and how the PAD takes a rather more holistic view of the <span class="No-Break">entire system.</span></p>
			<h2 id="_idParaDest-128"><a id="_idTextAnchor128"/>The PAD in action</h2>
			<p>The best way to <a id="_idIndexMarker602"/>demonstrate the operations of <a id="_idIndexMarker603"/>the PAD is to simulate a cascading failure and see how the PAD can bring the MSA system back to <span class="No-Break">normal operation.</span></p>
			<p>To simulate a cascading failure and ensure that the PAD responds to the failure and tries to auto-heal, we will first need to disable the PBW AI service. This will prevent the PBW from triggering a healing action and prevent it from trying to resolve the problem before the PAD’s healing action(s) <span class="No-Break">kick in.</span></p>
			<p>Let’s quickly revisit what we have previously discussed in <a href="B18934_03.xhtml#_idTextAnchor039"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, an example of how a cascading <span class="No-Break">failure happens.</span></p>
			<p>As shown in <span class="No-Break"><em class="italic">Figure 10</em></span><em class="italic">.5</em>, under heavy API traffic, a failure to the Inventory microservice could cause the <strong class="bold">Payment</strong> microservice to pile up too many API calls in the queue, waiting for a response from the Inventory service. Eventually, these API calls will consume and exhaust the available resources in the <strong class="bold">Payment</strong> microservice, causing it to fail. A failure in the Payment microservice will produce a similar situation in the <strong class="bold">Order</strong> microservice, and eventually, produce a failure for the <strong class="bold">Order</strong> microservice <span class="No-Break">as well:</span></p>
			<div>
				<div id="_idContainer182" class="IMG---Figure">
					<img src="image/B18934_10_5.jpg" alt="Figure 10.5: The Payment microservice is down"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.5: The Payment microservice is down</p>
			<p>For the PAD to respond with healing actions, each of the PAD’s detected anomaly types has to have healing actions defined <span class="No-Break">for it.</span></p>
			<p>To successfully simulate the cascading failure, we only defined an action for a cascading failure situation. Otherwise, the PAD would automatically detect the failure in the Inventory <a id="_idIndexMarker604"/>service and self-heal it by restarting the <a id="_idIndexMarker605"/>Inventory microservice container, preventing a cascading failure from happening to <span class="No-Break">begin with.</span></p>
			<p>We will start by simulating a high volume of orders for the Order microservice and see how the system is going to respond to this situation in general, and specifically how the PAD will react under <span class="No-Break">the situation.</span></p>
			<p>To simulate a high volume of order requests, use the following <strong class="source-inline">simulate_api_rqsts</strong> command to target the Order microservice with a fixed uniformly paced order requests of 100,000 <span class="No-Break">per minute:</span></p>
			<pre class="source-code">simulate_api_rqsts 100000 http://order_ms:8080/place_order</pre>
			<p>We will now shut down the Inventory microservice and examine the PAD action logs. The following is a snippet of the log about a minute after the PAD started to detect a failure in the <span class="No-Break">Inventory microservice.</span></p>
			<p>Please note that we introduced sudden high-volume traffic into the system. This sudden traffic increase by itself is a traffic pattern anomaly that was picked up by the PAD, but the PAD did not respond to that specific anomaly because no healing action is specifically defined for <span class="No-Break">that anomaly:</span></p>
			<pre class="source-code">2022-11-24 11:39:13.602130: Traffic pattern anomaly detected, (inventory_ms) is likely down. No action is defined. No action triggered yet. Yellow alarm triggered and sent to NMS/OSS system.
2022-11-24 11:39:23.469204: Traffic pattern anomaly detected, (payment_ms) slow API response detected. No action is defined. No action triggered yet.
:
:
2022-11-24 11:40:26.836405: Traffic pattern anomaly detected, (payment_ms) slow API response detected. No action is defined. No action triggered yet. Yellow alarm triggered and sent to NMS/OSS system.</pre>
			<p>In the preceding snippet of the PAD log, the PAD automatically recognized the Inventory service failure since no response traffic was detected from the service. However, no action was taken by the PAD since no healing action was defined for that particular anomaly. Since the anomaly was consistent for more than 1 minute, the PAD sent an alarm to the NMS/OSS system to notify the system admins of <span class="No-Break">the problem.</span></p>
			<p>Because of the Inventory microservice failure, the Payment microservice started to run out of resources, and the PAD picked up an unusually slow traffic flow from the Payment <a id="_idIndexMarker606"/>microservice given the API call request load <a id="_idIndexMarker607"/>applied. Accordingly, and as seen in the log, a little over 1 minute later, the PAD started to generate alarms <span class="No-Break">to NMS/OSS.</span></p>
			<p>As shown in the following PAD log, a few minutes after the Payment microservice anomaly, the Order microservice started acting up, and accordingly, the PAD was able to correlate all these anomalies and detect a potential <span class="No-Break">cascading failure:</span></p>
			<pre class="source-code">2022-11-24 11:47:12.450897: Traffic pattern anomaly detected, (order_ms) slow API response detected. No action is defined. No action triggered yet. Yellow alarm triggered and sent to NMS/OSS system.
2022-11-24 11:47:12.450897: Traffic pattern anomaly detected, potential cascading failure detected. No action triggered yet. Yellow alarm triggered and sent to NMS/OSS system.</pre>
			<p>Please note that the only microservice failure we have so far is the one we manually shut down, the Inventory microservice. Both the Payment and Order microservices are still up and running but, as it seems from the log, may be suffering from <span class="No-Break">resource exhaustion.</span></p>
			<p>The system is still running so far, and should the Inventory service return back online, the system will automatically recover. The user experience during the heavy load would only be slow performance during the ordering process, but no orders have been denied or <span class="No-Break">failed yet.</span></p>
			<p>By examining all these previously mentioned PAD action logs, and as the situation stands so far, we are still okay. However, if no action is taken to resolve the Inventory microservice problem, the system will eventually fail and user orders will start to <span class="No-Break">be denied.</span></p>
			<p>The short circuit traffic pattern discussed in <a href="B18934_03.xhtml#_idTextAnchor039"><span class="No-Break"><em class="italic">Chapter 3</em></span></a> helps prevent a cascading failure from taking <a id="_idIndexMarker608"/>place, but it still cannot resolve the underlying <a id="_idIndexMarker609"/>problem. User orders in a traditional short circuit pattern implantation will still be rejected until manual intervention fixes the <span class="No-Break">Inventory microservice.</span></p>
			<p>That’s where the PAD comes in. Check the following PAD <span class="No-Break">action log!</span></p>
			<pre class="source-code">2022-11-24 11:48:13.638447: Traffic pattern anomaly detected, potential cascading failure detected. (inventory_ms) microservice is likely the root-cause. Red Alarm triggered and sent to NMS/OSS system.
2022-11-24 11:48:13.638447: Self-healing lock state declared for inventory_ms container.
2022-11-24 11:48:13.638447: Self-healing action triggered. Restarting inventory_ms container (inventory_management_container).
2022-11-24 11:48:18.663912: Verifying inventory_ms operations...
2022-11-24 11:48:20.325807: inventory_ms was successfully restarted
2022-11-24 11:48:20.474590: Self-healing lock state cleared for inventory_ms container.</pre>
			<p>The PAD was able to detect the cascading failure before it actually happened, and was able to identify the root cause of the problem. The PAD sent a red alarm to the NMS/OSS system, declared a self-healing lock state on the Inventory service to try to fix the problem’s root cause, was able to successfully restart the Inventory microservice container, and then cleared the self-healing lock on the <span class="No-Break">Inventory service.</span></p>
			<p>Let’s now <a id="_idIndexMarker610"/>check the microservices performance logs <a id="_idIndexMarker611"/>and ensure that the problem is fixed and that the ABC-Intelligent-MSA system and all of its microservices are <span class="No-Break">running normally.</span></p>
			<p>Here’s the Inventory m<a id="_idTextAnchor129"/><a id="_idTextAnchor130"/>icroservice’s <span class="No-Break">performance log:</span></p>
			<pre class="source-code">http://inventory_ms:8080,2022-11-24 11:51:33.132089, 0.033451717535487,200
http://inventory_ms:8080,2022-11-24 11:51:43.894705, 0.035784934718275,200
http://inventory_ms:8080,2022-11-24 11:51:54.809743, 0.027584526453594,200
http://inventory_ms:8080,2022-11-24 11:52:06.155834, 0.028615804809435,200</pre>
			<p>Here’s the Payment microservice’s <span class="No-Break">performance log:</span></p>
			<pre class="source-code">http://payment_ms:8080,2022-11-24 11:54:41.109835, 0.051435877463506,200
http://payment_ms:8080,2022-11-24 11:54:51.924508, 0.102346014326819,200
http://payment_ms:8080,2022-11-24 11:55:03.372841, 0.070163827689135,200
http://payment_ms:8080,2022-11-24 11:55:14.076832, 0.157682760576845,200</pre>
			<p>Here’s the Order microservice’s <span class="No-Break">performance log:</span></p>
			<pre class="source-code">http://order_ms:8080,2022-11-24 11:58:37.135827, 0.209097164508914,200
http://order_ms:8080,2022-11-24 11:58:47.584731, 0.193851625041193,200
http://order_ms:8080,2022-11-24 11:58:58.243759, 0.150628069240741,200
http://order_ms:8080,2022-11-24 11:59:08.961412, 0.138192362340785,200</pre>
			<p>As shown for <a id="_idIndexMarker612"/>the preceding Inventory, Payment, and Order <a id="_idIndexMarker613"/>microservices, all of those microservices are back online with normal performance readings. The system is now back to normal operation and should be able to handle the production load with <span class="No-Break">no issues.</span></p>
			<h1 id="_idParaDest-129"><a id="_idTextAnchor131"/>Summary</h1>
			<p>This chapter walked us through how we can build AI models to build an intelligent MSA system step by step. We accordingly built two main AI services – the PBW and the PAD – and leveraged these AI services to enhance our MSA demo system, ABC-MSA, to build an intelligent MSA system that we <span class="No-Break">named ABC-Intelligent-MSA.</span></p>
			<p>We explained the self-healing process design and dynamics in detail, as well as the tools we built to develop AI training data, how to simulate production operations, and how to measure the demo system’s performance. We then put the ABC-Intelligent-MSA to test, simulated a couple of use cases to demonstrate AI functions within the MSA system, and carefully examined the logs of our demo AI services to showcase the value of using AI <span class="No-Break">in MSA.</span></p>
			<p>Everything explained in this chapter is just an example of using AI in an MSA system. Enterprises should consider using AI services that are specifically appropriate for their own MSA system and use cases. These AI tools may very well be available through third parties or built in-house <span class="No-Break">whenever needed.</span></p>
			<p>In the next chapter, we will discuss the transformation process from a traditional MSA system to an intelligent MSA system – the things to consider in greenfield and brownfield implementations, and how to avoid integration challenges to make the corporate transformation as smooth <span class="No-Break">as possible.</span></p>
</body></html>