<html><head></head><body>
		<div class="Content" id="_idContainer166">
			<h1 id="_idParaDest-147"><em class="italics"><a id="_idTextAnchor188"/>Chapter 6</em></h1>
		</div>
		<div class="Content" id="_idContainer167">
			<h1 id="_idParaDest-148"><a id="_idTextAnchor189"/>Anomaly Detection</h1>
		</div>
		<div class="Content" id="_idContainer168">
			<h2>Learning Objectives</h2>
			<p>By the end of this chapter, you will be able to:</p>
			<ul>
				<li class="bullets">Use parametric and non-parametric methods to find outliers in univariate and multivariate data</li>
				<li class="bullets">Use data transformations to identify outliers in univariate and multivariate data</li>
				<li class="bullets">Work with Mahalanobis distances</li>
				<li class="bullets">Improve anomaly detection performance by incorporating a model of seasonality</li>
			</ul>
			<p>In this chapter, we will have a look at different anomaly detection techniques.</p>
		</div>
		<div class="Content" id="_idContainer189">
			<h2 id="_idParaDest-149"><a id="_idTextAnchor190"/>Introduction</h2>
			<p>Data analysis often begins with an implicit assumption that all observations are valid, accurate, and trustworthy. But this is not always a reasonable assumption. Consider the case of credit card companies, who collect data consisting of records of charges to an individual's credit card. If they assumed that all charges were valid, they would open the door to thieves and fraudsters to take advantage of them. Instead, they examine their transaction datasets and look for anomalies – transactions that deviate from the general observed pattern. Since fraudulent transactions are not labeled, they have to use unsupervised learning to find these anomalies and prevent criminal activity.</p>
			<p>There are many other situations in which anomaly detection is useful. For example, manufacturers may use anomaly detection methods to find defects in their products. Medical researchers may look for anomalies in otherwise regular heartbeat patterns to diagnose illnesses. IT security professionals try to find anomalous activities on servers or computers to identify malware. In each case, unsupervised learning methods can help separate the valid observations from the anomalous ones.</p>
			<p>This chapter will cover several anomaly detection techniques. We will begin by using parametric and non-parametric methods to find outliers in univariate and multivariate data. We will then discuss using data transformations to identify outliers in univariate and multivariate data. Next, we will have a look at Mahalanobis distances, a multivariate tool for anomaly detection. We will conclude the chapter with a discussion of using regression modeling to improve anomaly detection performance by incorporating a model of seasonality, and detection of contextual and collective anomalies.</p>
			<h2 id="_idParaDest-150"><a id="_idTextAnchor191"/>Univariate Outlier Detection</h2>
			<p>Anomaly detection is simplest in the univariate case, that is, when each observation is only one number. In this case, we might start by doing a common-sense check for anomalies by checking whether observations are missing, NULL, NA, or recorded as infinity or something that doesn't match the type of the rest of the observations. After performing this check, we can apply true unsupervised learning.</p>
			<p>For univariate data, anomaly detection consists of looking for outliers. R's built-in <strong class="inline">boxplot</strong> function makes an initial exploratory check for outliers quite easy, as can be seen in the following exercise.<a id="_idTextAnchor192"/></p>
			<h3 id="_idParaDest-151"><a id="_idTextAnchor193"/>Exercise 37: Performing an Exploratory Visual Check for Outliers Using R's boxplot Function</h3>
			<p>For univariate data, anomaly detection consists of looking for outliers. R's built-in boxplot function makes an initial exploratory check for outliers quite easy, as demonstrated in this exercise. We will use a dataset called <strong class="inline">mtcars</strong>, which is built into R.</p>
			<p>In this exercise, we will create a boxplot that you can see in Figure 6.3. A boxplot is an important type of univariate plot. Here, the thick horizontal line around 3 indicates the median value in the data. The box surrounding this median line has a lower limit at the first quartile (the 25th percentile) and an upper limit at the third quartile (the 75th percentile). The vertical dotted lines extend to the lower and upper ends of all of the non-outlier data. These dotted lines are called the whiskers of the plot, so this type of plot is sometimes called a "box and whiskers" plot. Finally, the two observations that are represented as circular points near the top of the plot are (at least, according to R) outliers.</p>
			<p>Percentiles can also be called <strong class="bold">quantiles</strong>, and we'll refer to them as such in this boxplot. A quantile is a point in the data that is greater than some fixed proportion of all data points. For example, a 0.1 quantile is an observation in the data that is greater than 10% of all observations, and less than the rest. The 0.25 quantile is also called the 25th percentile or the first quartile, and it is greater than 25% of the data, and the 75th percentile or 0.75 quantile is greater than 75% of the data. When we take an observation and find what proportion of observations it is greater than, that is called finding its quantile. When we take a quantile such as 0.25 and try to find an observation that corresponds to that quantile, we can call that taking an inverse quantile.</p>
			<p>To perform an exploratory visual check for outliers using R's <strong class="inline">boxplot</strong> function, perform the following steps:</p>
			<ol>
				<li>To load the data, open the R console and enter the following command:<p class="snippet">data(mtcars)</p></li>
				<li>Execute the following command to view the first six rows of the dataset:<p class="snippet">head(mtcars)</p><p>The output is as follows:</p><div class="IMG---Figure" id="_idContainer169"><img alt="Figure 6.1: Top six rows of the mtcars dataset" src="image/C12628_06_01.jpg"/></div><h6>Figure 6.1: Top six rows of the mtcars dataset</h6></li>
				<li>You can find details about this dataset by executing the following in the R console:<p class="snippet">?mtcars</p><p>The documentation is as follows:</p><div class="IMG---Figure" id="_idContainer170"><img alt="Figure 6.2: Section of output" src="image/C12628_06_02.jpg"/></div><h6>Figure 6.2: Section of output</h6></li>
				<li>Create a boxplot of the weights of cars as follows:<p class="snippet">boxplot(mtcars$wt) </p><p>The output will look like this:</p><div class="IMG---Figure" id="_idContainer171"><img alt="Figure 6.3: Boxplot representing weight of cars" src="image/C12628_06_03.jpg"/></div><h6>Figure 6.3: Boxplot representing weight of cars</h6></li>
				<li>There appear to be two observations that R has classified as outliers that appear to have values higher than 5. Note that these weights are measured in thousands of pounds, so actually these are weights higher than 5,000 pounds. We can determine these observations by running a simple filter on our data:<p class="snippet">highest&lt;-mtcars[which(mtcars$wt&gt;5),]</p><p class="snippet">print(highest)</p><p>The output is as follows:</p></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer172">
					<img alt="Figure 6.4: Cars with weights greater than 5,000 pounds" src="image/C12628_06_04.jpg"/>
				</div>
			</div>
			<h6>Figure 6.4: Cars with weights greater than 5,000 pounds</h6>
			<p>We can see that there are three models of car whose weights are higher than 5,000 pounds. Since we only observed two outliers, we conclude that the Cadillac Fleetwood, the car model with the third-highest weight, is not one of the outliers. This leaves the other two: the Lincoln Continental and the Chrysler Imperial, as the car models that apparently have outlier weights. These car models, when compared to the other car models, constitute anomalies. A potential next step for a researcher is to investigate why these car models appear to have anomalously high car weights.</p>
			<p>In <em class="italics">Chapter 3</em>, <em class="italics">Probability Distributions</em>, we discussed different distributions that datasets tend to follow. Many datasets have so-called long tails or fat tails, meaning that a disproportionate amount of observations are very far from the mean – not necessarily because they are anomalous outliers, but only because of the nature of their distribution. Our standard for defining an outlier should change if we happen to be working with a dataset that follows a fat-tailed distribution.</p>
			<p>In t<a id="_idTextAnchor194"/>he following exercise, we will transform a dataset that follows a fat-tailed distribution and observe the changes in which observations are reported as outliers.</p>
			<h3 id="_idParaDest-152"><a id="_idTextAnchor195"/>Exercise 38: Transforming a Fat-Tailed Dataset to Improve Outlier Classification</h3>
			<p>In t<a id="_idTextAnchor196"/>he following exercise, we will transform a dataset that follows a fat-tailed distribution and observe the changes in which observations are reported as outliers. We w<a id="_idTextAnchor197"/>ill use the <strong class="inline">rivers</strong> dataset, which comes pre-loaded into R:</p>
			<ol>
				<li value="1">Load the dataset as follows:<p class="snippet">data(rivers)</p></li>
				<li>Execute the following command to view the first six observations of the dataset:<p class="snippet">head(rivers)</p><p>The output is as follows:</p><p class="snippet">[1] 735 320 325 392 524 450</p></li>
				<li>You can see that the <strong class="inline">rivers</strong> dataset is a vector. You can find out more about it by typing this:<p class="snippet">?rivers</p><p>The documentation is as follows:</p><div class="IMG---Figure" id="_idContainer173"><img alt="Figure 6.5: Information of the rivers dataset" src="image/C12628_06_05.jpg"/></div><h6>Figure 6.5: Information of the rivers dataset</h6></li>
				<li>Observe the distribution of outliers. First, try a boxplot of the rivers data by running the following command:<p class="snippet">boxplot(rivers)</p><p>The boxplot looks like this:</p><div class="IMG---Figure" id="_idContainer174"><img alt="Figure 6.6: Boxplot of the rivers dataset" src="image/C12628_06_06.jpg"/></div><h6>Figure 6.6: Boxplot of the rivers dataset</h6><p>You can see that this boxplot looks different from the <strong class="inline">mtcars</strong> boxplot that we looked at previously. In particular, the box and whiskers take up a smaller portion of the plot, and a huge amount of the plot consists of observations that R has classified as outliers. However, outliers are not supposed to be extremely numerous in any datasets – by definition, they are supposed to be rare. When we observe a boxplot such as this, that presents many outliers that take up a large portion of the plot, we can reasonably conclude that our distribution is fat-tailed.</p></li>
				<li>In order to get a better classification of outliers, it could be helpful to transform the data. Many datasets related to nature and natural phenomena are known to follow a log-normal distribution. If we take the logarithm of every observation, the resulting distribution will be normal (and therefore not fat-tailed). To transform the data, you can use the following command:<p class="snippet">log_rivers&lt;-log(rivers)</p></li>
				<li>Observe the boxplot of the transformed data. Finally, we can execute the following command to see the boxplot of the transformed data:<p class="snippet">boxplot(log_rivers)</p><p>The boxplot will look as follows:</p></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer175">
					<img alt="Figure 6.7: Boxplot of transformed dataset" src="image/C12628_06_07.jpg"/>
				</div>
			</div>
			<h6>Figure 6.7: Boxplot of transformed dataset</h6>
			<p>As expected, the box and whiskers take up a greater proportion of the plot, and there are fewer observations that are classified as outliers. In this case, we can use the <strong class="inline">log_rivers</strong> plot instead of the <strong class="inline">rivers</strong> plot to classify outliers.</p>
			<p>The preceding exercise shows the importance of data preparation in anomaly detection. We can also attempt anomaly detection on a raw dataset. But sometimes, like in the example of <strong class="inline">rivers</strong> that we looked at, we can get different and better results by performing some simple data preparation. One thing to keep in mind is that there are many possible transformations of data. We have used the log transformation, but there are many others that could work. Another thing to keep in mind is that data preparation can be harmful as well as helpful: some data preparation methods, such as averaging and data smoothing, can cause us to throw out valuable information that will make our anomaly detection less effective.</p>
			<p>So far, we have relied on R's built-in outlier detection methods, and we have done simple visual inspections of boxplots to determine which observations were outliers. In the <a id="_idTextAnchor198"/>next exercise, we will determine which observations are outliers ourselves without using R's built-in outlier classification. We will be finding quantiles of the data – specifically the 0.25 and 0.75 quantiles.</p>
			<h3 id="_idParaDest-153"><a id="_idTextAnchor199"/>Exercise 39: Finding Outliers without Using R's Built-In boxplot Function</h3>
			<p>In this exercise, we will determine which observations are outliers ourselves without using R's built-in outlier classification. We will be finding quantiles of the data – specifically the .25 and .75 quantiles. We will use the <strong class="inline">rivers</strong> data again, which we used in the preceding exercise:</p>
			<ol>
				<li value="1">Load the data by executing the following command:<p class="snippet">data(rivers)</p></li>
				<li>The interquartile range is the difference between the first quartile (the 25th percentile) and the third quartile (the 75th percentile). So, we can store the interquartile range in a variable called <strong class="inline">interquartile_range</strong> by running the following:<p class="snippet"><strong class="inline">interquartile_range</strong>&lt;-unname(quantile(rivers,.75)-quantile(rivers,.25))</p><p>In this case, we use <strong class="inline">unname</strong> to make sure that <strong class="inline">interquartile_range</strong> is just a number instead of a DataFrame or list or other data type. This will make it easier and more reliable to work with later.</p></li>
				<li>Use the following command to check the interquartile range:<p class="snippet"><strong class="inline">print(interquartile_range)</strong></p><p>The output is as follows: </p><p class="snippet">[1] 370</p></li>
				<li>The standard method in R's boxplot function is to use 1.5 times the interquartile range as a limit to how far non-outlier observations can be dispersed. Then the upper limit of non-outliers is the third quartile plus 1.5 times the interquartile range, and the lower limit of non-outliers is the first quartile minus 1.5 times the interquartile range. We can calculate this as follows:<p class="snippet">upper_limit&lt;-unname(quantile(rivers,.75)+1.5*<strong class="inline">interquartile_range</strong>)</p><p class="snippet">lower_limit&lt;-unname(quantile(rivers,.25)-1.5*<strong class="inline">interquartile_range</strong>)</p></li>
				<li>Our outliers are the observations that are above our <strong class="inline">upper_limit</strong> or below our <strong class="inline">lower_limit</strong>. We can determine these as follows:<p class="snippet">rivers[which(rivers&gt;upper_limit | rivers&lt;lower_limit)]</p><p>This will output a list of observations that we classify as outliers:</p><p class="snippet">[1] 1459 1450 1243 2348 3710 2315 2533 1306 1270 1885 1770</p><h4>Note</h4><p class="callout">This exe<a id="_idTextAnchor200"/>rcise uses the method that is used in R's boxplot function. But with unsupervised learning, there is always flexibility about the details of the methods.</p></li>
				<li>Another way to look for outliers would be to use the method in the preceding exercise, but to use a different value for the upper and lower limits. We could do this by changing the coefficient that we multiply by <strong class="inline">interquartile_range</strong>, as follows:<p class="snippet">upper_limit&lt;-unname(quantile(rivers,.75)+3*<strong class="inline">interquartile_range</strong>)</p><p class="snippet">lower_limit&lt;-unname(quantile(rivers,.25)-3*<strong class="inline">interquartile_range</strong>)</p><p>We have changed the coefficient from 1.5 to 3. This change makes our method less likely to classify any particular observation as an outlier, because it increases the upper limit and decreases the lower limit. </p></li>
			</ol>
			<p>In general, you can try to be creative about changing unsupervised learning methods in ways that you believe are reasonable and will lead to good results.</p>
			<p>The method in the preceding exercise is what is called a <strong class="bold">non-parametric</strong> <strong class="bold">method</strong>. In statistics, there are some methods that are called parametric and others that are called non-parametric. Parametric methods make assumptions about the underlying distribution of data, for example, the assumption that the data follows a normal distribution. Non-parametric methods are meant to be free of these constraining assumptions. The method in the preceding exercise relies only on quantiles, so it does not make any assumptions about the distribution of the data or the parameters (such as mean and variance) that go with them. Because of this, we call it a non-parametric method. A parametric anomaly detection method, by contrast, is one that makes assumptions about the distribution of the data or its parameters (such as mean and variance). Please note, non-parametric methods and parametric methods are always looking for the same anomalies: there is no such thing as a parametric anomaly or a non-parametric anomaly, but only parametric methods and non-parametric methods. We will discuss a parametric anomaly detection method in the next exercise.</p>
			<p>We will calculate something called a <strong class="bold">z-score</strong>. A z-score is a standardized measurement of how far an observation is from the mean. Each z-score is measured in units of standard deviations. So, a z-score of 0 means that an observation is 0 standard deviations away from the mean; in other words, it is equal to the mean. A z-score of 1 means that an observation is 1 standard deviation above the mean. A z-score of -2.5 means that an observation is 2.5 standard deviations below the mean. It is conventional in some contexts to consider observations that are more than two standard deviations away from the mean unusual or anomalous.</p>
			<h3 id="_idParaDest-154">Exercis<a id="_idTextAnchor201"/>e 40: Detecting Outliers Using a Parametric Method</h3>
			<p>In this exercise, we will investigate anomalies by looking for observations whose z-scores are greater than 2 or less than -2. We will use the rivers dataset used in previous exercise:</p>
			<ol>
				<li value="1">Load the data and determine the standard deviation as follows:<p class="snippet">data(rivers)</p><p class="snippet">standard_deviation&lt;-sd(rivers)</p></li>
				<li>Determ<a id="_idTextAnchor202"/>ine z-scores for every observation by calculating how many standard deviations each observation is away from the mean:<p class="snippet">z_scores&lt;-(rivers-mean(rivers))/ standard_deviation</p></li>
				<li>Determine which observations are outliers by selecting observations whose z-scores are greater than 2 or less than -2:<p class="snippet">outliers&lt;-rivers[which(z_scores&gt;2 | z_scores&lt;(-2))]</p><p class="snippet">outliers</p><p>The output is as follows:</p><p class="snippet">[1] 2348 3710 2315 2533 1885 1770</p><p>In this case, we can see that there are six rivers that are classified as outliers – all of them with z-scores higher than 2. Here, <strong class="inline">outliers</strong> is perhaps a strong word for these anomalies, since a z-score of 2 is not particularly enormous. There is no strict rule about what defines an outlier, and whether to use the term will depend on the particular situation and context.</p></li>
			</ol>
			<p><strong class="bold">Parametric anomaly</strong> detection, as shown in this exercise, is common practice. However, its applicability depends on whether the parametric assumptions behind it are valid. In this case, we calculated a standard deviation and looked for outliers more than two standard deviations away from the mean. This practice is justified if the data comes from a Gaussian (normal) distribution. In this case, some evidence indicates that the rivers data does not come from a Gaussian distribution. For cases in which there is doubt about the distribution of the underlying data, a non-parametric or transformed method (as used in the previous exercises) could be more suitable.</p>
			<h3 id="_idParaDest-155"><a id="_idTextAnchor203"/>Multivariate Outlier Detection</h3>
			<p>All of the methods so far have focused on univariate outlier detection. However, in practice such data is actually rare. Most datasets contain observations about multiple attributes of data. In these cases, it is not clear how to calculate whether a point is an outlier or not. We can calculate a z-score on each individual dimension, but what should be done about observations whose z-scores are high on one dimension and low in the other, or relatively large in one dimension and average in the other? There is no easy answer. In these cases, we can calculate a multidimensional analogue of a z-score using something called <strong class="bold">Mahalanobis</strong> <strong class="bold">distance</strong>. Mahalanobis distance is a multidimensional analogue of a z-score. What that means is that it measures the distance between two points, but in special units that, just like a z-score, depend on the variance of the data. We will be better able to understand the meaning of a Mahalanobis distance after going through the following exercise. </p>
			<h3 id="_idParaDest-156"><a id="_idTextAnchor204"/>Exercise 41: Calculating Mahalanobis Distance</h3>
			<p>In this exercise, we will learn a new measurement that will eventually help us find which individuals are outliers compared to the general population when considering both their height and their weight. The expected output of this exercise will be a Mahalanobis distance for a single data point, measuring how far from the center of the data it is. </p>
			<h4>Note</h4>
			<p class="callout">For all the exercises and activities where we are importing external CSV files or images, go to <strong class="bold">RStudio</strong>-&gt; <strong class="bold">Session</strong>-&gt; <strong class="bold">Set Working Directory</strong>-&gt; <strong class="bold">To Source File Location</strong>. You can see in the console that the path is set automatically.</p>
			<p>In a later exercise, we will find the Mahalanobis distance for all the points in the dataset. We will then be able to use these measurements to classify which individuals are outliers compared to the general population when considering both their height and their weight:</p>
			<h4>Note</h4>
			<p class="callout">This dataset is taken from the Statistics Online Computational Resource. You can find the dataset at <a href="http://wiki.stat.ucla.edu/socr/index.php/SOCR_Data_Dinov_020108_HeightsWeights">http://wiki.stat.ucla.edu/socr/index.php/SOCR_Data_Dinov_020108_HeightsWeights</a>. We have downloaded the file and saved it at <a href="https://github.com/TrainingByPackt/Applied-Unsupervised-Learning-with-R/tree/master/Lesson06/Exercise41-42/heightsweights.csv">https://github.com/TrainingByPackt/Applied-Unsupervised-Learning-with-R/tree/master/Lesson06/Exercise41-42/heightsweights.csv</a>. We have used the first 200 rows of the data.</p>
			<ol>
				<li value="1">Start by loading this in R. First, download it from our GitHub repository at <a href="https://github.com/TrainingByPackt/Applied-Unsupervised-Learning-with-R/tree/master/Lesson06/Exercise41-42/heightsweights.csv">https://github.com/TrainingByPackt/Applied-Unsupervised-Learning-with-R/tree/master/Lesson06/Exercise41-42/heightsweights.csv</a>. Then, save it to your computer in R's working directory. Then, load it into R as follows:<p class="snippet">filename&lt;-'heightsweights.csv'</p><p class="snippet">raw&lt;-read.csv(filename, stringsAsFactors=FALSE)</p></li>
				<li>We have given the dataset the name <strong class="inline">raw</strong>. You can make sure the columns have the right names as follows:<p class="snippet">names(raw)&lt;-c('index','height','weight')</p></li>
				<li>Plot the data and observe the patterns:<p class="snippet">plot(raw$height,raw$weight)</p><p>The plot appears as follows:</p><div class="IMG---Figure" id="_idContainer176"><img alt="Figure 6.8: Plot of height and weight" src="image/C12628_06_08.jpg"/></div><h6>Figure 6.8: Plot of height and weight</h6><p>We can see that there is great variation in both heights and weights in this sample. Note that our univariate methods will not work in a straightforward way in this data. We could calculate a standard deviation or interquartile range for height, and find outliers for height. But the outliers for height will not necessarily be outliers for weight – they might be a normal weight, or exactly what is expected for weight. Similarly, outliers for weight might have completely average or expected heights. It is not immediately obvious how we should calculate "complete outliers," or observations that are outliers in some holistic sense, taking into account both height and weight.</p></li>
				<li>Next, we will calculate the multidimensional equivalent of the mean, called <strong class="inline">centroid</strong>:<p class="snippet">centroid&lt;-c(mean(raw$height),mean(raw$weight))</p></li>
				<li>Calculate the distance between any given point and the centroid. As an example, we will choose the first observation in the dataset:<p class="snippet">example_distance&lt;-raw[1,c('height','weight')]-centroid</p></li>
				<li>Calculate the inverse of the covariance matrix of our data. First, we calculate the covariance matrix of our height and weight data:<p class="snippet">cov_mat&lt;-cov(raw[,c('height','weight')])</p></li>
				<li>Calculate its inverse using the <strong class="inline">solve</strong> function, which calculates matrix inverses in R:<p class="snippet">inv_cov_mat&lt;-solve(cov_mat)</p></li>
				<li>Calculate the Mahalanobis distance between our point and the centroid of our dataset:<p class="snippet">mahalanobis_dist&lt;-t(matrix(as.numeric(example_distance)))%*% matrix(inv_cov_mat,nrow=2) %*% matrix(as.numeric(example_distance))</p><p>In this case, we use <strong class="inline">%*%</strong> because it indicates matrix multiplication, which is what we want to perform, and we likewise need to turn every argument into a numeric matrix.</p><p>The output of this exercise is a Mahalanobis distance, which is a generalization of a z-score in multiple dimensions: that is, a generalized measure of how many standard deviations each point is away from the mean. In this case, the Mahalanobis distance we found is 1.71672. Mahalanobis distances are like any type of distance measurement – 0 is the lowest possible measurement and the higher the number, the farther the distance. Only the centroid will have a measured Mahalanobis distance of 0. The advantage of Mahalanobis distances is that they are standardized in a way that takes into account the variances of each variable and makes them effective for outlier detection. Later on in this chapter, we will see how to use this type of measurement to find outliers in this multi-dimensional dataset. </p></li>
			</ol>
			<h3 id="_idParaDest-157">Detectin<a id="_idTextAnchor205"/>g Anomalies in Clusters</h3>
			<p>In the first two chapters, we discussed the different clustering methods. The method we are discussing now, Mahalanobis distances, could be used fruitfully in clustering applications, if you imagine that the data we are looking at is the data corresponding to one particular cluster. For example, in divisive clustering, the point with the highest Mahalanobis distance could be selected as the point to remove from a cluster. Also, the range of Mahalanobis distances could be used to express the dispersion of any given cluster.</p>
			<h3 id="_idParaDest-158"><a id="_idTextAnchor206"/>Other Methods for Multivariate Outlier Detection</h3>
			<p>There are other methods for multivariate outlier detection, including some that are known as <strong class="bold">non-parametric</strong> methods. Non-parametric methods, like some of the preceding exercises, may rely on quantiles, or in other words, the rank of each observation from largest to smallest, in order to classify outliers. Some non-parametric methods use the sums of such rankings to understand the distribution of data. However, such methods are not common and are not more effective than Mahalanobis distances in general, so we recommend relying on Mahalanobis distance for multivariate outlier detection.</p>
			<h3 id="_idParaDest-159"><a id="_idTextAnchor207"/>Exercise 42: Classifying Outliers based on Comparisons of Mahalanobis Distances</h3>
			<p>In this exercise, we will use a comparison of Mahalanobis distances to classify outliers. This exercise is a continuation of the previous exercise, and it will rely on the same dataset and some of the same variables. In that exercise, we found the Mahalanobis distance for one data point; now we're going to find it for all the data points. Before executing the following exercise, you should run all of the code in the previous exercise and make sure you are familiar with the ideas presented there:</p>
			<h4>Note</h4>
			<p class="callout">This dataset is taken from the UCI Machine Learning Repository. You can find the dataset at <a href="http://wiki.stat.ucla.edu/socr/index.php/SOCR_Data_Dinov_020108_HeightsWeights">http://wiki.stat.ucla.edu/socr/index.php/SOCR_Data_Dinov_020108_HeightsWeights</a>. We have downloaded the file and saved it at <a href="https://github.com/TrainingByPackt/Applied-Unsupervised-Learning-with-R/tree/master/Lesson06/Exercise41-42/heightsweights.csv">https://github.com/TrainingByPackt/Applied-Unsupervised-Learning-with-R/tree/master/Lesson06/Exercise41-42/heightsweights.csv</a>. We have used the first 200 rows of the data.</p>
			<ol>
				<li value="1">Create a <strong class="inline">NULL</strong> variable that will hold each of our calculated distances:<p class="snippet">all_distances&lt;-NULL</p></li>
				<li>Loop through each observation and find the Mahalanobis distance between it and the centroid of the data. The code inside this loop is taken from the previous exercise, where we learned how to calculate Mahalanobis distances:<p class="snippet">k&lt;-1</p><p class="snippet">while(k&lt;=nrow(raw)){</p><p class="snippet">the_distance&lt;-raw[k,c('height','weight')]-centroid</p><p class="snippet">mahalanobis_dist&lt;-t(matrix(as.numeric(the_distance)))%*% matrix(inv_cov_mat,nrow=2) %*% matrix(as.numeric(the_distance))</p><p class="snippet">all_distances&lt;-c(all_distances,mahalanobis_dist)</p><p class="snippet">k&lt;-k+1</p><p class="snippet">}</p><p>After running this loop, we have a measured Mahalanobis distance for each of the points in our data.</p></li>
				<li>Plot all observations that have particularly high Mahalanobis distances. In this case, we will say that particularly high means the highest 10% of Mahalanobis distances. This means all Mahalanobis distances that are higher than the 0.9 quantile of Mahalanobis distances, which we select in the following code:<p class="snippet">plot(raw$height,raw$weight)</p><p class="snippet">points(raw$height[which(all_distances&gt;quantile(all_distances,.9))],raw$weight[which(all_distances&gt;quantile(all_distances,.9))],col='red',pch=19)</p><p>The output is as follows:</p></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer177">
					<img alt="Figure 6.9: Observations with high Mahalanobis distances" src="image/C12628_06_09.jpg"/>
				</div>
			</div>
			<h6>Figure 6.9: Observations with high Mahalanobis distances</h6>
			<p>This plot shows solid red points for each point that is in the top 10% of Mahalanobis distances. We can see that some of them appear to be outliers both for height and for weight, and could be observed simply by performing our univariate outlier detection methods. However, many of the red points in the plot above are neither univariate outliers for height nor for weight. They are outliers only relative to the entire cloud of points, and Mahalanobis distances enable us to quantify and detect that.</p>
			<h3 id="_idParaDest-160"><a id="_idTextAnchor208"/>Detecting Outliers in Seasonal Data</h3>
			<p>So far, we have only discussed outlier detection as a way to detect anomalies. However, anomaly detection consists of more than only outlier detection. Some anomalies cannot easily be detected as raw outliers. Next, we will look at seasonal, trended data. In this data, we want to find anomalies that occur specifically in the context of a seasonal trend or cycle.</p>
			<p>We will use data from the <strong class="inline">expsmooth</strong> package in R.</p>
			<p>The data we will use records the monthly number of visitors to Australia between 1985 and 2005, measured in thousands of people.</p>
			<p>In the following exercise, we will be working with data that has a <strong class="bold">time trend</strong>. By time trend, we mean that over time, the observations tend to increase or decrease (in this case, they tend to increase). In order to detect outliers, we want to do something called <strong class="bold">de-trending</strong>. To de-trend data means to remove, as much as possible, its time trend so that we can find how much each observation deviates from the expected values.</p>
			<h3 id="_idParaDest-161"><a id="_idTextAnchor209"/>Exercise 43: Performing Seasonality Modeling</h3>
			<p>In this exercise, we will attempt to model this data to establish what we should regard as the expected values of the data, and what we should regard as deviations from expectations. The expected output is a set of error values, which we will use in a future exercise to classify outliers – the observations with the largest errors will be classified as the dataset's outliers:</p>
			<ol>
				<li value="1">First, load this data into R by executing the following commands:<p class="snippet">install.packages("expsmooth")</p><p class="snippet">library(expsmooth)</p><p class="snippet">data(visitors)</p><p class="snippet">plot(visitors)</p><p>The output is as follows:</p><div class="IMG---Figure" id="_idContainer178"><img alt="Figure 6.10: Plot of monthly visitors to Australia between 1985 and 2005" src="image/C12628_06_10.jpg"/></div><h6>Figure 6.10: Plot of monthly visitors to Australia between 1985 and 2005</h6></li>
				<li>Check the first six observations of the data as follows:<p class="snippet">head(visitors)</p><p>The output is as follows:</p><p class="snippet">       May   Jun   Jul   Aug   Sep   Oct</p><p class="snippet">1985  75.7  75.4  83.1  82.9  77.3 105.7</p><p>Check the last six observations as follows:</p><p class="snippet">tail(visitors)</p><p>The output is as follows:</p><p class="snippet">       Jan   Feb   Mar   Apr May Jun Jul Aug Sep Oct   Nov   Dec</p><p class="snippet">2004                                                 479.9 593.1</p><p class="snippet">2005 462.4 501.6 504.7 409.5                                    </p></li>
				<li>Since dates can be hard to work with, we can assign a numeric variable that tracks the dates in order. We will call this variable <strong class="inline">period</strong> and define it as follows:<p class="snippet">period&lt;-1:length(visitors)</p></li>
				<li>Combine the <strong class="inline">visitors</strong> data with the <strong class="inline">period</strong> variable we just created by putting them both into one DataFrame called <strong class="inline">raw</strong>:<p class="snippet">raw&lt;-data.frame(cbind(visitors,period))</p></li>
				<li>This step is technically supervised, rather than unsupervised, learning. In this case, we will use supervised learning, but only as an intermediate step on the way to doing unsupervised learning. To find the time trend in the data, we can run a linear regression relating the sales figures to the numeric time period as follows:<p class="snippet">timetrend&lt;-lm(visitors~period+I(log(period)),data=raw)</p></li>
				<li>Next, we can obtain fitted values for this time trend, and store them as part of the <strong class="inline">raw</strong> DataFrame:<p class="snippet">raw$timetrend&lt;-predict(timetrend,raw)</p></li>
				<li>The process of de-trending means we subtract the predicted trend that we found in <em class="italics">Step 6</em>. The reason we do this is that we want to find anomalies in the data. If we keep the trend in the data, something that looks like an anomaly may actually be the expected result of a trend. By removing the trend from the data, we can be sure that observed anomalies are not the result of a trend. We can accomplish de-trending as follows:<p class="snippet">raw$withouttimetrend&lt;-raw$visitors-raw$timetrend</p></li>
				<li>We can draw a simple plot of the de-trended data as follows:<p class="snippet">plot(raw$withouttimetrend,type='o')</p><p>The plot looks as follows:</p><div class="IMG---Figure" id="_idContainer179"><img alt="Figure 6.11: Plot of the de-trended data" src="image/C12628_06_11.jpg"/></div><h6>Figure 6.11: Plot of the de-trended data</h6><p>In this plot, you should notice that there is no apparent left-to-right trend in the data, showing that we have successfully de-trended it.</p><p>Our data records the monthly number of visitors to Australia. There are variations in temperature and weather across seasons in Australia, and it is reasonable to hypothesize that tourist visits could increase or decline depending on how favorable the weather tends to be in a particular month. There could even be variations in business or diplomatic visits to Australia that relate to seasons and weather changes throughout the year. So, it is reasonable to suppose that there are yearly patterns in visits to Australia. Our next step will be to remove these yearly patterns from our data.</p></li>
				<li>First, we create a matrix where each of the columns contains de-trended visitor data about a separate month of the year:<p class="snippet">seasonsmatrix = t(matrix(data = raw$withouttimetrend, nrow = 12))</p></li>
				<li>Take the mean of each column to get the mean of de-trended visitors in that particular month:<p class="snippet">seasons = colMeans(seasonsmatrix, na.rm = T)</p></li>
				<li>This gives us a vector with 12 values – one for each month of the year. Since we have 20 years of data, we repeat this vector 20 times:<p class="snippet">raw$seasons&lt;-c(rep(seasons,20))</p></li>
				<li>Finally, we can obtain our de-trended, de-cycled data, which we will name <strong class="inline">error</strong> because random error is the only thing remaining after removing the time trends and yearly cycles in the data:<p class="snippet">raw$error&lt;-raw$visitors-raw$timetrend-raw$seasons</p></li>
				<li>We can plot this to see what it looks like:<p class="snippet">plot(raw$error,type='o')</p><p>The plot looks as follows:</p><div class="IMG---Figure" id="_idContainer180"><img alt="Figure 6.12: Plot of the de-trended data" src="image/C12628_06_12.jpg"/></div><h6>Figure 6.12: Plot of the de-trended data</h6></li>
				<li>Plot all elements of seasonality modeling together. Finally, we can show all of the elements we have isolated from our seasonal data: a time trend, a yearly cycle, and random error:<p class="snippet">par(mfrow=c(3,1))</p><p class="snippet">plot(raw$timetrend,type='o')</p><p class="snippet">plot(raw$seasons,type='o')</p><p class="snippet">plot(raw$error,type='o')</p><p>The output is as follows:</p></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer181">
					<img alt="Figure 6.13: Plot of elements of seasonality modelling" src="image/C12628_06_13.jpg"/>
				</div>
			</div>
			<h6>Figure 6.13: Plot of elements of seasonality modelling</h6>
			<p>The three plots shown together in Figure 6.13 show a decomposition of the original data. The first plot shows the time trend, or in other words the overall pattern observed in the data that each month tends to have more visitors than the previous month. Of course, this is an oversimplification of the data, because there are also seasonal patterns: certain months tend to have more or fewer visitors than other months, irrespective of the overall trend. The second plot shows these seasonal patterns, which repeat in the same way year after year. Finally, the third plot shows the error, which is all of the variation in the data that is not captured by an overall time trend or by a seasonal pattern within each year. If you take the sum of all the data presented in these three plots, you will recover the original dataset. But in these three plots, we can see these elements decomposed, and this decomposition gives us a better understanding of how time trends, seasonality, and error interact to constitute the observed data.</p>
			<p>This exercise enabled us to create a variable called <strong class="inline">error</strong> that we added to the raw data frame. Now that we have created the error vector, we can use standard anomaly detection to find anomalies in the data frame.</p>
			<h3 id="_idParaDest-162"><a id="_idTextAnchor210"/>Exercise 44: Finding Anomalies in Seasonal Data Using a Parametric Method</h3>
			<p>In this exercise, we will do anomaly detection by finding the largest deviations from expected values:</p>
			<ol>
				<li value="1">Calculate the standard deviation of the error data calculated in the previous exercise:<p class="snippet">stdev&lt;-sd(raw$error)</p></li>
				<li>Find which data points are more than two standard deviations away from the mean value:<p class="snippet">high_outliers&lt;-which(raw$error&gt;(mean(raw$error)+2*sd(raw$error)))</p><p class="snippet">low_outliers&lt;-which(raw$error&lt;(mean(raw$error)-2*sd(raw$error)))</p></li>
				<li>Examine the observations that we have classified as outliers:<p class="snippet">raw[high_outliers,]</p><p>The output is as follows:</p><p class="snippet">    visitors period timetrend withouttimetrend   seasons    error</p><p class="snippet">1       75.7      1  67.18931         8.510688 -55.94655 64.45724</p><p class="snippet">130    392.7    130 305.93840        86.761602  24.35847 62.40313</p><p class="snippet">142    408.0    142 323.44067        84.559332  24.35847 60.20086</p><p class="snippet">147    397.4    147 330.70509        66.694909  11.55558 55.13933</p><p class="snippet">188    559.9    188 389.78579       170.114205  91.11673 78.99748</p><p>Low outliers are classified as follows:</p><p class="snippet">raw[low_outliers,]</p><p>The output is as follows:</p><p class="snippet">    visitors period timetrend withouttimetrend   seasons      error</p><p class="snippet">80     266.8     80  231.4934         35.30663  91.11673  -55.81010</p><p class="snippet">216    321.5    216  429.7569       -108.25691 -20.46137  -87.79553</p><p class="snippet">217    260.9    217  431.1801       -170.28007 -55.94655 -114.33352</p><p class="snippet">218    308.3    218  432.6029       -124.30295 -42.40371  -81.8992</p></li>
				<li>We can plot these points as follows:<p class="snippet">plot(raw$period,raw$visitors,type='o')</p><p class="snippet">points(raw$period[high_outliers],raw$visitors[high_outliers],pch=19,col='red')</p><p class="snippet">points(raw$period[low_outliers],raw$visitors[low_outliers],pch=19,col='blue')</p><p>The plot looks as follows:</p></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer182">
					<img alt="Figure 6.14: Plot of data classified as anomalies" src="image/C12628_06_14.jpg"/>
				</div>
			</div>
			<h6>Figure 6.14: Plot of data classified as anomalies</h6>
			<p>The plot shows all of our data and the points that we have classified as anomalies, with high anomalies plotted in red and low anomalies plotted in blue. You should note that not all of these points are immediately obvious as outliers. We have only been able to recognize them as outliers after doing the seasonality modeling exercise earlier, and determining expected values that the anomalies depart from.</p>
			<p>Next, we will introduce two more types of anomalies: contextual and collective anomalies. In order to introduce these concepts, we will generate an artificial dataset that contains both contextual and collective anomalies.</p>
			<h3 id="_idParaDest-163"><a id="_idTextAnchor211"/>Contextual and Collective Anomalies</h3>
			<p>At around x=1 in Figure 6.15, you can see a single point that is quite far from its neighbors. This is an example of a <strong class="bold">contextual anomaly</strong>, and we will discuss what that means and how to detect these types of anomalies first. At around x=3.6, you can see a region where y is flat, with every value equal to 0. Zero values are not anomalous in this data, but having so many of them together is anomalous. So, this collection of data is referred to as a <strong class="bold">collective anomaly</strong>.</p>
			<p>We will consider contextual anomalies first. Contextual anomalies are observations that are considered anomalies only because of their neighbors. In the dataset we have just generated, there is one point at x=1 where y=0. However, the values of y for x=0.99 and x=1.01 are close to 0.84, very far from 0 in this context. Contextual anomalies can be detected by finding observations that have anomalous distance from their neighbors, as we will see in the following exercise.</p>
			<h3 id="_idParaDest-164"><a id="_idTextAnchor212"/>Exercise 45: Detecting Contextual Anomalies</h3>
			<p>The following exercise shows how to detect contextual anomalies in the dataset we have just introduced. Since contextual anomalies are observations that are very different from their neighbors, we need to do an explicit comparison of each observation with its neighbor. In order to do this, we calculate a first difference. A first difference is simply the value of an observation minus the value of the observation before it.</p>
			<p>The expected outcome of this exercise will be the observations in the dataset that are contextual anomalies:</p>
			<ol>
				<li value="1">We will generate an artificial dataset that contains both contextual and collective anomalies. The dataset can be generated by running the following code in the R console:<p class="snippet">x&lt;-1:round(2*pi*100+100)/100</p><p class="snippet">y&lt;-rep(0,round(2*pi*100)+100)</p><p class="snippet">y[1:314]&lt;-sin(x[1:314])</p><p class="snippet">y[415:728]&lt;-sin(x[315:628])</p><p class="snippet">y[100]&lt;-0</p></li>
				<li>You can see what this data looks like by plotting <strong class="inline">x</strong> and <strong class="inline">y</strong> as follows:<p class="snippet">plot(x,y,type='o')</p><p>The output is as follows:</p><div class="IMG---Figure" id="_idContainer183"><img alt="Figure 6.15: Plot of generated dataset" src="image/C12628_06_15.jpg"/></div><h6>Figure 6.15: Plot of generated dataset</h6><p>This plot shows a sine curve: a simple type of curve that begins at 0, and slopes gently upward and downward, finally returning to 0 again. This data is artificially generated; however, we might imagine that it represents observations of temperature: low in some months, climbing higher in some months, high in some months, and climbing downward in other months. Temperature and weather data often follow a pattern that can be modeled with a trigonometric curve such as a sine or cosine. We have altered our sine curve so that it includes some anomalous data.</p></li>
				<li>Find the first difference for every observation at the same time as follows:<p class="snippet">difference_y&lt;-y[2:length(y)]-y[1:(length(y)-1)]</p></li>
				<li>Create a boxplot of the first difference data:<p class="snippet">boxplot(difference_y)</p><p>The resulting boxplot looks as follows:</p><div class="IMG---Figure" id="_idContainer184"><img alt="Figure 6.16: Boxplot of the first difference data" src="image/C12628_06_16.jpg"/></div><h6>Figure 6.16: Boxplot of the first difference data</h6><p>This boxplot shows that nearly all first differences are very close to zero, while two outlier differences are far away from the rest. We can see from the first difference boxplot that the single high outlier is larger than 0.5.</p><p>You may notice that there are two apparent outliers in Figure 6.16, but only one single outlier apparent in Figure 6.15. The reason for this is that Figure 6.16 shows first difference data, and the single outlier in the data leads to two large first differences: the difference between the 99th and the 100th values, and the difference between the 100th and 101st values. One outlier observation in the original data has led to two outlier observations in the first difference data.</p></li>
				<li>Determine which observation corresponds to this outlier by using R's useful <strong class="inline">which</strong> function:<p class="snippet">which(difference_y&gt;0.5)</p><p><strong class="inline">which</strong> returns the value 100, indicating that it is the 100th observation that is a contextual anomaly. If we check, <strong class="inline">y[100]</strong> is equal to 0, and its neighbors are not, so we have successfully found the contextual anomaly.</p></li>
			</ol>
			<p>Next, we will discuss collective anomalies. In our x-y plot, we pointed out the 100 observations that were all equal to 0 around x=3.64. A zero value is not in itself an anomaly in this dataset, but having 100 observations all equal to 0 is anomalous. The collection of 100 zero values together here is referred to as a collective anomaly. Collective anomalies are more difficult to detect than contextual anomalies, but we will attempt to detect them anyway in the following exercise.</p>
			<h3 id="_idParaDest-165"><a id="_idTextAnchor213"/>Exercise 46: Detecting Collective Anomalies</h3>
			<p>In the following exercise, we will detect collective anomalies in the dataset we created earlier. The expected outcome of this exercise is a list of observations that constitute collective anomalies:</p>
			<ol>
				<li value="1">In order to detect this kind of anomaly, we need to look for groups of observations, or neighborhoods, that contain no variation or only small variations. The following loop accomplishes this. It creates a vector that consists of the maximum value of two differences: the difference between an observation and the observation 50 periods before, and the difference between an observation and the observation 50 periods later. If the maximum of these differences is zero or very small, then we have detected a neighborhood that is extremely flat, a sign of this kind of collective anomaly. Here is the loop we will use:<p class="snippet">changes&lt;-NULL</p><p class="snippet">ks&lt;-NULL</p><p class="snippet">k&lt;-51</p><p class="snippet">while(k&lt;(length(y)-50)){</p><p class="snippet">changes&lt;-c(changes,max(abs(y[k-50]),abs(y[k+50])))</p><p class="snippet">ks&lt;-c(ks,k)</p><p class="snippet">k&lt;-k+1</p><p class="snippet">}</p><p>This loop has created a vector called <strong class="inline">changes</strong>. Each element of this vector measures the maximum difference observed between an observation and its neighbors 50 observations away. Especially small values of the <strong class="inline">changes</strong> vector will indicate that we could have a collective anomaly consisting of a flat neighborhood.</p></li>
				<li>Now that we have a vector measuring neighborhood changes, we can create a simple boxplot, the same as we have done in previous exercises:<p class="snippet">boxplot(changes)</p><p>The output is as follows:</p><div class="IMG---Figure" id="_idContainer185"><img alt="Figure 6.17: Boxplot of neighborhood changes" src="image/C12628_06_17.jpg"/></div><h6>Figure 6.17: Boxplot of neighborhood changes</h6><p>We can see that there are many observations classified as outliers, which shows evidence of very low neighborhood changes. </p></li>
				<li>We can find which observation leads to this collective anomaly as follows:<p class="snippet">print(ks[which(changes==min(changes))])</p><p>The output is 364.</p></li>
				<li>We can verify that this is an index corresponding to the collective anomaly by checking the y value at that index:<p class="snippet">print(y[ks[which(changes==min(changes))]])</p><p>So, y is 0, which is the value of y at the collective anomaly, providing evidence that we have found the right point.</p></li>
			</ol>
			<h2 id="_idParaDest-166"><a id="_idTextAnchor214"/>Kernel Density</h2>
			<p>To conclude the chapter, we will discuss using kernel density estimates to perform outlier detection on a set of blood samples. <strong class="bold">Kernel density</strong> estimation provides a natural way to test whether a particular set of blood results are anomalous, even without having specialized knowledge of the particular blood test being used or even of medicine in general.</p>
			<p>Suppose that you<a id="_idTextAnchor215"/> are working at a doctor's office and your boss asks you to do a new type of blood test on patients. Your boss wants to know if any of the patients have anomalous test results. However, you are not familiar with this new blood test and you do not know what normal and anomalous results are supposed to look like. All you have is a record of previous blood tests that your boss assures you are from normal patients. Suppose that these tests had the following results:</p>
			<p class="snippet">normal_results&lt;-c(100,95,106,92,109,190,210,201,198)</p>
			<p>Now suppose that your boss wants you to find anomalies (if any) in the following new blood test results:</p>
			<p class="snippet">new_results&lt;-c(98,35,270,140,200)</p>
			<p>In kernel density estimation, we model a dataset with a collection of kernels. For our purposes, the kernels will just be normal distributions with different means and variances. You can learn more about the normal distribution in <em class="italics">Chapter 3</em>, <em class="italics">Probability Distributions</em>. We will suppose that our data has a density that is captured by a sum of normal distributions. Then, any data that appears to be inconsistent with the sum of normal distributions that we specify can be classified as an anomaly.</p>
			<p>When we calculate kernel density, we will have to specify something called <strong class="bold">bandwidth</strong>. Here, the bandwidth will be a measure of the variance of the normal distributions that we are using to model our data. If we specify a high bandwidth, we are assuming that the data is widely dispersed, and if we specify a low bandwidth, we are assuming that the data is largely contained in a relatively narrow range. This should become more clearer to you as you work through the following exercise.</p>
			<h3 id="_idParaDest-167">Exercise 47: Find<a id="_idTextAnchor216"/>ing Anomalies Using Kernel Density Estimation</h3>
			<p>In this exercise, we will cover how to find anomalies using kernel density estimation. The expected output of this exercise is a list of observations that constitute anomalies according to a kernel density estimation method:</p>
			<ol>
				<li value="1">Specify our data and our parameters. For our data, we will use the <strong class="inline">normal results</strong> and <strong class="inline">new results</strong> we specified earlier:<p class="snippet">normal_results&lt;-c(100,95,106,92,109,190,210,201,198)</p><p class="snippet">new_results&lt;-c(98,35,270,140,200)</p></li>
				<li>Kernel density estimation relies on a parameter called <strong class="inline">bandwidth</strong>. For that, we will start with 25. The choice of bandwidth will depend on your own preferences and also on the original data. If you are not sure, you can choose a bandwidth that is about the same size as the standard deviation of your data. In this case, we will choose 25, which is lower than the standard deviation of our data. You can set the bandwidth at 25 as follows:<p class="snippet">bandwidth&lt;-25</p><h4>Note</h4><p class="callout">You can feel free to experiment with other bandwidth values if you like.</p></li>
				<li>Use R's <strong class="inline">density</strong> function to obtain a kernel density estimate:<p class="snippet">our_estimate&lt;-density(normal_results, bw=bandwidth)</p></li>
				<li>Plot the density estimate:<p class="snippet">plot(our_estimate)</p><p>The resulting plot appears as follows:</p><div class="IMG---Figure" id="_idContainer186"><img alt="Figure 6.18: Plot of density estimate" src="image/C12628_06_18.jpg"/></div><h6>Figure 6.18: Plot of density estimate</h6></li>
				<li>The shape of the graph in Figure 6.18 represents the distribution of our original data. You can learn more about probability distributions in <em class="italics">Chapter 3</em>, <em class="italics">Probability Distributions</em>. This distribution is called <strong class="inline">bimodal</strong>, which means that the data appears to cluster mainly around two points: most of the observations are close to either 100 or 200. We will interpret an observation as an anomaly if its corresponding point on the distribution shown in Figure 6.18 shows that it is particularly unlikely.</li>
				<li>We can obtain density estimates for each of our new results. For each of the observations in <strong class="inline">new_results</strong>, we will calculate the density estimate according to the kernel illustrated in Figure 6.18. We will store each of these density estimates in new variables as follows:<p class="snippet">new_density_1&lt;-density(normal_results,bw=25,n=1,from=new_results[1],to=new_results[1])$y</p><p class="snippet">new_density_2&lt;-density(normal_results,bw=25,n=1,from=new_results[2],to=new_results[2])$y</p><p class="snippet">new_density_3&lt;-density(normal_results,bw=25,n=1,from=new_results[3],to=new_results[3])$y</p><p class="snippet">new_density_4&lt;-density(normal_results,bw=25,n=1,from=new_results[4],to=new_results[4])$y</p><p class="snippet">new_density_5&lt;-density(normal_results,bw=25,n=1,from=new_results[5],to=new_results[5])$y</p><p>The output will be the heights on the graph from <em class="italics">Step 3</em> that corresponds to each of the x-values specified in the <strong class="inline">new_results</strong> vector. We can observe each of these values by printing them. Print <strong class="inline">new_density_1</strong> as follows:</p><p class="snippet">print(new_density_1)</p><p>The output is as follows:</p><p class="snippet">[1] 0.00854745</p><p>Print <strong class="inline">new_density_2</strong> as follows:</p><p class="snippet">print(new_density_2)</p><p>The output is as follows:</p><p class="snippet">[1] 0.0003474778</p><p>Print <strong class="inline">new_density_3</strong> as follows:</p><p class="snippet">print(new_density_3)</p><p>The output is as follows:</p><p class="snippet">[1] 0.0001787185</p><p>Print <strong class="inline">new_density_4</strong> as follows:</p><p class="snippet">print(new_density_4)</p><p>The output is as follows:</p><p class="snippet">[1] 0.003143966</p><p>Print <strong class="inline">new_density_5</strong> as follows:</p><p class="snippet">print(new_density_5)</p><p>The output is as follows:</p><p class="snippet">[1] 0.006817359</p></li>
				<li>We can plot these points on our density plot as follows:<p class="snippet">plot(our_estimate)</p><p class="snippet">points(new_results[1],new_density_1,col='red',pch=19)</p><p class="snippet">points(new_results[2],new_density_2,col='red',pch=19)</p><p class="snippet">points(new_results[3],new_density_3,col='red',pch=19)</p><p class="snippet">points(new_results[4],new_density_4,col='red',pch=19)</p><p class="snippet">points(new_results[5],new_density_5,col='red',pch=19)</p></li>
				<li>The result of executing these commands is the following plot:<div class="IMG---Figure" id="_idContainer187"><img alt="Figure 6.19: Points mapped on density plot&#13;&#10;" src="image/C12628_06_19.jpg"/></div><h6>Figure 6.19: Points mapped on density plot</h6><p>This shows the same density plot we examined earlier, with five points added – one for each of the new results that we are examining to find anomalies. Each of the points shows the relative likelihood of each particular observation: points that have a higher estimated density value are more likely to be observed, while points that have a lower estimated density value are less likely to be observed and are therefore more likely to be anomalies. There is no strict rule about which observations are anomalies and which are not, but in general the observations whose estimated densities are closest to zero are most likely to be anomalies.</p></li>
				<li>Interpret the results to classify anomalies. <p>Each of the density values appear quite close to zero. However, some are much closer to zero than others. In this case, the closer the density estimate is to zero, the more confident we are that the observation is an anomaly. In this case, we will choose a threshold value and say that blood test results whose kernel density estimates are lower than the threshold are anomalous, and results whose kernel density estimates are higher than the threshold are not anomalous. It seems that 0.001 is a reasonable threshold, since it separates the high-density values from the lowest-density values – the observations whose density values are lower than 0.001 appear on the plot shown in <em class="italics">Step 6</em> to be very unlikely. So, we will classify the blood test results 35 and 270 as anomalous results, and all of the others as reasonable, because we saw in step 4 that 35 and 270 corresponded to density estimates that were lower than 0.001.</p><p>So, the final output of our exercise is the conclusion that the blood test results 35 and 270 are anomalies, while the rest of the blood test results are reasonable. </p></li>
			</ol>
			<h3 id="_idParaDest-168"><a id="_idTextAnchor217"/>Continuing in Your Studies of Anomaly Detection</h3>
			<p>If you continue to learn about anomaly detection, you will find that there are a huge number of different anomaly detection techniques. However, all of them follow the same basic pattern that we have seen in our seasonality modeling example. Specifically, advanced anomaly detection usually consists of the following:</p>
			<ul>
				<li>Specifying a model of what is expected</li>
				<li>Calculating the difference between what is expected based on the model, and what is observed – this is called the error</li>
				<li>Using univariate outlier detection on the error vector to determine anomalies</li>
			</ul>
			<p>The biggest difficulty comes in the first step: specifying a useful model of what is expected. In this case, we specified a seasonal model. In other cases, it will be necessary to specify models that take into account multi-dimensional image data, audio recordings, or complicated economic indicators or other complex attributes. The right way to set up models for those cases will require study of the particular domains from which the data is drawn. However, in each case, anomaly detection will follow the three-step bulleted pattern listed earlier.</p>
			<h3 id="_idParaDest-169"><a id="_idTextAnchor218"/>Activity 14: Finding Univariate Anomalies Using a Parametric Method and a Non-parametric Method</h3>
			<p>The aim of the activity is to find univariate anomalies using a parametric method. For this activity, we will use a dataset that is built in to R, called <strong class="inline">islands</strong>. If you execute <strong class="inline">?islands</strong> in R, you can find the documentation of this dataset. In this documentation, you can notice that this dataset contains the areas in thousands of square miles of landmasses on Earth that exceed 10,000 square miles.</p>
			<p>This might be a dataset that would be of interest to a geologist who studied the formation of landmasses on earth. According to scientists, there are numerous ways that islands can form: sometimes through volcanic activity, sometimes through coral growth, and sometimes in other ways. A geologist might be interested in finding islands that are anomalously large or small – these islands might be the best places to do further research to try to understand the natural processes of island formation. In this activity, we will find anomalies in the <strong class="inline">islands</strong> dataset.</p>
			<p>These steps will help you complete the activity:</p>
			<ol>
				<li value="1">Load the data called <strong class="inline">islands</strong> in R's built-in datasets and create a boxplot of this data. What do you notice about the distribution of data and outliers?</li>
				<li>Transform the <strong class="inline">islands</strong> data with a logarithm transformation and create a boxplot of this transformed data. How has this changed the data points that are classified as outliers?</li>
				<li>Calculate the outliers in the islands dataset manually using a non-parametric method (the method that defines outliers as points lying more than 1.5 times the interquartile range above or below the first and third quartiles, respectively). Do the same for the log transformation of the islands data.</li>
				<li>Classify outliers in the <strong class="inline">islands</strong> dataset using a parametric method by calculating the mean and standard deviation of the data and classifying outliers as observations that are more than two standard deviations away from the mean. Do the same for the logarithm transformation of the islands data.</li>
				<li>Compare the results of each of these outlier detection methods.<h4>Note</h4><p class="callout">The solution for this activity can be found on page 234.</p></li>
			</ol>
			<h3 id="_idParaDest-170"><a id="_idTextAnchor219"/>Activity 15: Using Mahalanobis Distance to Find Anomalies</h3>
			<p>In the following activity, we will examine data related to the speed and stopping distance of cars. This data might be useful to an automotive engineer who is trying to research which cars perform the best. Cars that have especially low stopping distance relative to their speeds can be used as examples of high-performing cars, while those that have anomalously high stopping distance relative to their speeds may be candidates for further research to find areas for improvement. In this activity, we will find anomalies based on both speed and stopping distance. Because we are working with multivariate data, it makes sense to use Mahalanobis distance to find anomalies.</p>
			<p>These steps will help you complete this activity:</p>
			<ol>
				<li value="1">Load the <strong class="inline">cars</strong> dataset from R's built-in datasets. This dataset contains the speed of some very old cars together with the distance required to stop at that speed. Plot the data.</li>
				<li>Calculate the centroid of this data, and calculate the Mahalanobis distance between each point and the centroid. Find the outliers (points whose Mahalanobis distance from the centroid is the highest). Draw a plot showing all the observations and the outliers plotted together.<p>The plot will look as follows:</p></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer188">
					<img alt="Figure 6.20: Plot with outliers marked" src="image/C12628_06_20.jpg"/>
				</div>
			</div>
			<h6>Figure 6.20: Plot with o<a id="_idTextAnchor220"/>utliers marked</h6>
			<h4>Note</h4>
			<p class="callout">The solution for this activity is on page 237.</p>
			<h2 id="_idParaDest-171"><a id="_idTextAnchor221"/>Summary</h2>
			<p>In this chapter, we have discussed anomaly detection. We began with univariate anomaly detection, including non-parametric and parametric approaches. We discussed performing data transformations to obtain better classifications of outliers. We then discussed multivariate anomaly detection using Mahalanobis distances. We completed more advanced exercises to classify anomalies related to seasonally varying data. We discussed collective and contextual anomalies, and concluded the chapter with a discussion of how to use kernel density estimation in anomaly detection.</p>
		</div>
	</body></html>