- en: Implementing Recommender Systems with Julia
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Julia 实现推荐系统
- en: In the previous chapters, we took a deep dive into data mining and web development
    with Julia. I hope you enjoyed a few relaxing rounds of *Six Degrees of Wikipedia* while
    discovering some interesting articles. Randomly poking through the millions of
    Wikipedia articles as part of a game is a really fun way to stumble upon interesting
    new content. Although I'm sure that, at times, you've noticed that not all the
    articles are equally good—maybe they're stubs, or subjective, or not so well written,
    or simply irrelevant to you. If we were able to learn about each player's individual
    interests, we could filter out certain Wikipedia articles, which would turn each
    game session into a wonderful journey of discovery.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们深入探讨了使用 Julia 进行数据挖掘和网页开发。我希望你在发现一些有趣的文章的同时，也享受了几轮轻松的 *维基百科六度分隔* 游戏。作为游戏的一部分，随机浏览数百万篇维基百科文章是一种真正有趣的方式，可以偶然发现有趣的新内容。虽然我确信，有时你会注意到并非所有文章都同样出色——也许它们是简短的，或主观的，或写得不好，或者简单地与你无关。如果我们能够了解每个玩家的个人兴趣，我们就可以过滤掉某些维基百科文章，从而使每次游戏会话都变成一次美妙的发现之旅。
- en: It turns out that we're not the only ones struggling with this—information discovery
    is a multibillion-dollar problem, regardless of whether it's articles, news, books,
    music, movies, hotels, or really any kind of product or service that can be sold
    over the internet. As consumers, we are exposed to an immense variety of choices,
    while at the same time, we have less and less time to review them—and our attention
    span is getting shorter and shorter. Making relevant recommendations instantly
    is a key feature of all successful online platforms, from Amazon to Booking.com,
    to Netflix, to Spotify, to Udemy. All of these companies have invested in building
    powerful recommender systems, literally inventing new business models together
    with the accompanying data collection and recommendation algorithms.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，我们并非唯一在努力解决这一问题的人——信息发现是一个价值数十亿美元的问题，无论它是文章、新闻、书籍、音乐、电影、酒店，还是任何可以在互联网上销售的产品或服务。作为消费者，我们面临着巨大的选择多样性，同时，我们用于审查它们的时间越来越少——我们的注意力跨度也越来越短。即时提供相关推荐是所有成功在线平台的关键特性，从亚马逊到Booking.com，再到Netflix、Spotify、Udemy。所有这些公司都投资于构建强大的推荐系统，实际上是与伴随的数据收集和推荐算法一起创造了新的商业模式。
- en: 'In this chapter, we''ll learn about recommender systems—the most common and
    successful algorithms that are used in the wild for addressing a wide variety
    of business needs. We''ll look at the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习推荐系统——这些是最常见且最成功的算法，被广泛应用于解决各种商业需求。我们将探讨以下主题：
- en: What recommender systems are and how are they used
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 推荐系统是什么以及它们是如何被使用的
- en: Content-based versus collaborative filtering recommender systems
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于内容的推荐系统与协同过滤推荐系统
- en: User-based and item-based recommender systems
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于用户和基于物品的推荐系统
- en: More advanced data analysis using `DataFrames` and statistical functions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `DataFrames` 和统计函数进行更高级的数据分析
- en: How to roll out our own recommender systems using content-based and collaborative
    filtering algorithms
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用基于内容和协同过滤算法推出我们自己的推荐系统
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The Julia package ecosystem is under continuous development and new package
    versions are released on a daily basis. Most of the times this is great news,
    as new releases bring new features and bug fixes. However, since many of the packages
    are still in beta (version 0.x), any new release can introduce breaking changes.
    As a result, the code presented in the book can stop working. In order to ensure
    that your code will produce the same results as described in the book, it is recommended
    to use the same package versions. Here are the external packages used in this
    chapter and their specific versions:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 的包生态系统正在持续发展中，并且每天都有新的包版本发布。大多数时候这是一个好消息，因为新版本带来了新功能和错误修复。然而，由于许多包仍在测试版（版本
    0.x）中，任何新版本都可能引入破坏性更改。因此，书中展示的代码可能无法正常工作。为了确保您的代码将产生与书中描述相同的结果，建议使用相同的包版本。以下是本章中使用的外部包及其特定版本：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In order to install a specific version of a package you need to run:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了安装特定版本的包，您需要运行：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'For example:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Alternatively you can install all the used packages by downloading the `Project.toml`
    file provided with the chapter and using `pkg>` instantiate as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您也可以通过下载章节中提供的 `Project.toml` 文件，并使用 `pkg>` 命令如下实例化来安装所有使用的包：
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Understanding recommender systems
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解推荐系统
- en: In its broadest definition, a **recommender system** (**RS**) is a technique
    that's used for providing suggestions for items that are useful to a person. These
    suggestions are meant to help in various decision-making processes, usually related
    to buying or consuming a certain category of products or services. They can be
    about buying a book, listening to a song, watching a movie, eating out at a certain
    restaurant, reading a news article, or picking the hotel for your next holiday.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在其最广泛的意义上，**推荐系统**（**RS**）是一种用于为个人提供有用物品建议的技术。这些建议旨在帮助在各种决策过程中，通常与购买或消费某一类产品或服务相关。它们可能涉及购买书籍、听歌曲、看电影、在特定餐厅用餐、阅读新闻文章，或为你的下一次假期选择酒店。
- en: People have relied on recommendations pretty much since the beginning of history.
    Some RS researchers talk about the first recommendations as being the first orally
    transmitted information about dangerous plants, animals, or places. Others think
    that recommendations systems functioned even before language, by simply observing
    the effects on other humans of consuming plants or unwisely confronting dangerous
    creatures (that could count as an extreme and possibly violent example of implicit
    ratings, as we'll see in the following paragraphs).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 自从历史开始以来，人们就一直在依赖推荐。一些推荐系统研究人员认为，最早的推荐可能是关于危险植物、动物或地点的口头传播信息。其他人则认为，推荐系统在语言出现之前就已经存在，通过观察人类食用植物或不明智地面对危险生物（这可以算作一种极端且可能暴力的隐性评分例子，我们将在下一段中看到）对其他人类的影响来发挥作用。
- en: But we don't have to go that far into human history. In more recent (and less
    dangerous) times, we can find some great examples of highly successful recommender
    systems, such as librarians suggesting books based on your tastes and interests,
    the butcher presenting meat products for your Sunday recipe, your friends' opinion
    of the latest blockbuster, your neighbor's stories about the kindergarten across
    the street, and even your MD recommending what treatment to follow to alleviate
    the symptoms and eliminate the cause of your disease. Other recommender systems
    are more formal, but equally pervasive and familiar, such as the star category
    ranking of hotels or the blue flags on top beaches around the world.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们不必追溯到人类历史的深处。在更近（且不那么危险）的时代，我们可以找到一些非常成功的推荐系统实例，例如图书管理员根据你的品味和兴趣推荐书籍，肉店为你展示适合周日食谱的肉类产品，你的朋友对最新大片的观点，你邻居关于街对面的幼儿园的故事，甚至你的医生推荐的治疗方案以缓解症状和消除疾病原因。其他推荐系统可能更为正式，但同样普遍且熟悉，例如酒店星级分类排名或全球顶级海滩上的蓝色旗帜。
- en: For a very long time, the experts in various fields played the part of recommenders,
    using their expertise in combination with their understanding of our tastes and
    interests, skillfully probing us for details. However, the rise of the internet
    and online platforms (e-commerce websites, online radios, movie streaming platforms,
    and social networks) has replaced the traditional models by making a huge catalog
    of items (products) available to a potentially very large consumer base (now called
    **users**). Due to considerations like 24-hour availability, language barriers,
    and sheer volume, personal recommendations were no longer a feasible option (although
    in the last couple of years, there was a certain recurrence of human-curated recommendations,
    from music, to books, to luxury products—but that's a different discussion).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在很长一段时间里，各个领域的专家扮演着推荐者的角色，他们结合自己的专业知识和对我们品味和兴趣的理解，巧妙地探询我们的细节。然而，随着互联网和在线平台（电子商务网站、在线电台、电影流媒体平台和社交网络）的兴起，通过向潜在的大规模消费者群体（现在称为**用户**）提供大量商品（产品）目录，已经取代了传统模式。由于24小时可用性、语言障碍和数量庞大等因素的考虑，个人推荐已不再是一个可行的选择（尽管在过去的几年里，音乐、书籍、奢侈品等领域的由人编辑的推荐有所回归——但这又是另一个话题）。
- en: This expansion in the number of choices made finding the right product a very
    difficult task. At that point, software-based recommender systems entered the
    stage.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这种选择数量的增加使得找到合适的产品变得非常困难。在此阶段，基于软件的推荐系统登上了舞台。
- en: Amazon.com is credited as being the first online business that deployed software
    recommender systems at scale, with extraordinary business benefits. Later on,
    Netflix became famous for awarding a one million dollar prize to the team that
    came up with a recommendation algorithm better than theirs. Nowadays, automated
    recommender systems power all major platforms, from Spotify's *Discover Weekly* playlists
    to Udemy's recommended courses.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Amazon.com 被认为是第一个大规模部署软件推荐系统的在线业务，并带来了非凡的商业效益。后来，Netflix 因授予一个百万美元奖金给提出比他们更好的推荐算法的团队而闻名。如今，自动推荐系统为所有主要平台提供动力，从
    Spotify 的 *Discover Weekly* 播放列表到 Udemy 的推荐课程。
- en: Classifying recommender systems
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 推荐系统的分类
- en: Different business needs—from suggesting related products after buying your
    new laptop, to compiling the perfect driving playlist, to helping you reconnect
    with long lost schoolmates—led to the development of different recommendation
    algorithms. A key part of rolling out a recommender system is picking the right
    approach for the problem at hand to fully take advantage of the data available.
    We'll take a look at the most common and most successful algorithms.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的商业需求——从购买新笔记本电脑后推荐相关产品，到编制完美的驾驶播放列表，再到帮助您重新与久未联系的同学取得联系——导致了不同推荐算法的发展。推出推荐系统的一个关键部分是选择适合当前问题的正确方法，以充分利用可用的数据。我们将探讨最常见且最成功的算法。
- en: Learning about non-personalized, stereotyped, and personalized recommendations
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解非个性化、刻板印象化和个性化推荐
- en: The simplest types of recommendations, from a technical and algorithmic perspective,
    are the non-personalized ones. That is, they are not customized to take into account
    specific user preferences. Such recommendations can include best-selling products,
    various top 10 songs, blockbuster movies, or the most downloaded apps of the week.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术和算法的角度来看，最简单的推荐类型是非个性化的。也就是说，它们没有针对特定用户偏好进行定制。这类推荐可能包括畅销产品、各种前十名歌曲、热门电影或一周内下载量最高的应用程序。
- en: Non-personalized recommendations are less challenging technically, but also
    considerably less powerful. They can be good approximations in certain cases,
    especially when the product catalog is not very large (there are not that many
    Hollywood releases, for example). But for an e-commerce retailer like Amazon,
    with millions of products available at any given time, the chances of getting
    it right using generic recommendations are slim.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 非个性化推荐在技术上不太具有挑战性，但效力也相对较低。在某些情况下，它们可以是良好的近似，尤其是在产品目录不是很大时（例如，好莱坞发行的电影并不多）。但对于像
    Amazon 这样的电子商务零售商来说，在任意给定时间有数百万种产品可供选择，使用通用推荐正确的机会很小。
- en: 'An improvement in non-personalized recommendations comes from combining them
    with a classification strategy. By stereotyping, we can make the recommended items
    more relevant, especially when we can identify significantly different user demographics.
    A good example of this is app store recommendations, which are broken down by
    country. Take, for instance, the following list of recommended new games. This
    is what it looks like if you are a user accessing the app store from the US:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 非个性化推荐的改进来自于将它们与分类策略相结合。通过刻板印象化，我们可以使推荐的项目更加相关，尤其是在我们能够识别出显著不同的用户人口统计特征时。一个很好的例子是应用商店推荐，它们按国家划分。例如，以下是一份推荐的新游戏列表。如果您是从美国访问应用商店的用户，这将是您看到的情况：
- en: '![](img/65f54a74-a4ab-4792-b873-dd2077dd5775.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/65f54a74-a4ab-4792-b873-dd2077dd5775.png)'
- en: 'This is what it looks like for a user in Romania, at the exact same time:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是罗马尼亚用户在同一时间的情况：
- en: '![](img/5dc64b59-1d9e-438f-842a-6573e4dfeb3a.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5dc64b59-1d9e-438f-842a-6573e4dfeb3a.png)'
- en: You can easily notice that the top selections vary widely. This is driven by
    both cultural differences and preferences, but also by availability (copyright
    and distribution) issues.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以很容易地注意到顶级选择差异很大。这既是由文化差异和偏好驱动的，也是由可用性（版权和发行）问题驱动的。
- en: We won't focus on non-personalized recommendations in this chapter, since implementing
    them is quite straightforward. All that is needed for making such recommendations
    is to identify the relevant metrics and the best performing items, such as the
    number of downloads for apps, copies sold for a book, volume of streams for a
    song or movie, and so on. However, non-personalized recommendations, as a business
    solution, should not be dismissed, as they can be useful when dealing with users
    that don't present any relevant personal preferences—usually new users.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们不会关注非个性化推荐，因为实现它们相当直接。制作此类推荐所需的所有内容就是确定相关指标和表现最佳的项目，例如应用的下载数量、书籍的销量、歌曲或电影的播放量等等。然而，作为一个商业解决方案，非个性化推荐不应被忽视，因为当处理没有呈现任何相关个人偏好的用户时——通常是新用户——它们可能是有用的。
- en: Understanding personalized recommendations
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解个性化推荐
- en: Both from a business and a technical perspective, the most interesting recommender
    systems are the ones that take into account the user's preferences (or user's
    ranking).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 从商业和技术两个角度来看，最有趣的推荐系统是那些考虑用户偏好的（或用户排名）的系统。
- en: Explicit and implicit ratings
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显式和隐式评分
- en: When looking for personalization features, we must take into account both explicit
    data that's willingly provided by the user, as well as relevant information that's
    generated by their behavior in the app or on the website (or anywhere else where
    we're tracking user behavior really, since the boundary between the online and
    physical realms is becoming more blurry, for example, with the introduction of
    smart cars and autonomous shop checkouts, to name just a few). The explicit rating
    includes actions such as grading a product or an experience, awarding stars to
    a movie or purchase, and retweeting or liking a post. On the other hand, not bouncing
    back to the search results page, sharing a song, or watching a video until the
    end are all examples of an implicit positive rating, while returning a product,
    canceling a subscription, or not finishing an online training course or an eBook
    are instances of negative implicit ranking.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当寻找个性化功能时，我们必须考虑用户自愿提供的显式数据，以及他们在应用程序或网站上（或我们真正跟踪用户行为的任何其他地方）的行为产生的相关信息（例如，随着智能汽车和自主结账等技术的引入，线上和物理领域的界限变得越来越模糊，仅举几个例子）。显式评分包括对产品或体验进行评分、给电影或购买打星、转发或点赞帖子等行为。另一方面，不返回搜索结果页面、分享一首歌曲或观看视频直到结束都是隐式正面评分的例子，而退货、取消订阅或未完成在线培训课程或电子书都是负面隐式排名的例子。
- en: Understanding content-based recommender systems
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解基于内容的推荐系统
- en: One of the most common and successful types of recommendations are content-based.
    The core idea is that if I expressed a preference for a certain set of items,
    I will most likely be interested in more items that share the same attributes.
    For example, the fact that I watched `Finding Nemo (2003)` can be used as an indication
    that I will be interested in other movies from the animation and comedy genres.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见且最成功的推荐类型之一是基于内容的。核心思想是，如果我表达了对一组特定项目的偏好，我很可能对具有相同属性的其他项目也感兴趣。例如，我观看《海底总动员》（2003）的事实可以用作一个迹象，表明我对动画和喜剧类型的其他电影也感兴趣。
- en: Alternatively, watching one of the original *Star Wars* movie can be interpreted
    as a signal that I like other movies from the franchise, or movies with Harrison
    Ford, or directed by George Lucas, or science fiction in general. Indeed, Netflix
    employs such an algorithm, except at a more granular level. Per a recent article,
    Netflix has a large team that's tasked with watching and tagging movies in detail—later
    on, matching movie features with users groups. The users themselves are equally
    carefully classified into thousands of categories.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，观看一部原始的《星球大战》电影可以解释为我喜欢该系列的其他电影，或者哈里森·福特主演的电影，或者乔治·卢卡斯执导的电影，或者科幻电影。事实上，Netflix就采用了这样的算法，只是在更细粒度的层面上。根据最近的一篇文章，Netflix有一个大型团队，负责详细观看和标记电影——随后将电影特征与用户群体相匹配。用户本身也被仔细地分类到成千上万的类别中。
- en: More advanced content-based recommender systems also take into account the relative
    weight of the different tags. In the case of the previously mentioned `Finding
    Nemo (2003)`, the suggestions should be less about movies with fish and sharks
    and more about the fact that it's a funny, light-hearted family movie, so hopefully,
    the recommendation will be more `Finding Dory (2016)` and less *Jaws*.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 更高级的内容推荐系统还会考虑不同标签的相对权重。在之前提到的《海底总动员》（2003）的情况下，建议应该更少关于有鱼和鲨鱼的电影，而更多关于它是一部有趣、轻松的家庭电影的事实，因此希望推荐将更多地是《海底总动员2：多莉去哪儿》（2016）而不是*大白鲨*。
- en: 'Let''s see how we can build a basic movie recommender using a content-based
    algorithm. To keep things simple, I have set up a table with the top 10 movies
    of 2016 and their genres. You can find this file in this book''s GitHub repository,
    as `top_10_movies.tsv`, at [https://github.com/PacktPublishing/Julia-Programming-Projects/blob/master/Chapter06/top_10_movies.tsv](https://github.com/PacktPublishing/Julia-Programming-Projects/blob/master/Chapter06/top_10_movies.tsv):'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何使用基于内容的算法构建一个基本的电影推荐系统。为了使事情简单，我已经设置了一个包含2016年顶级10部电影及其类型的表格。你可以在本书的GitHub仓库中找到此文件，作为`top_10_movies.tsv`，网址为[https://github.com/PacktPublishing/Julia-Programming-Projects/blob/master/Chapter06/top_10_movies.tsv](https://github.com/PacktPublishing/Julia-Programming-Projects/blob/master/Chapter06/top_10_movies.tsv)：
- en: '![](img/8b432b80-4e1f-413f-a382-b89e3c79d870.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8b432b80-4e1f-413f-a382-b89e3c79d870.png)'
- en: In the preceding screenshot, you can see how we use a binary system to represent
    whether a movie belongs to a genre (encoded by a `1`) or not (a `0`).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，你可以看到我们如何使用二进制系统来表示一部电影是否属于某个类型（通过`1`编码）或不是（通过`0`编码）。
- en: 'We can easily load such a table from a CSV/TSV file into Julia by using the
    `readdlm` function, which is available in the `DelimitedFiles` module. This module
    comes with the default Julia installation, so there''s no need to add it:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用`readdlm`函数，该函数位于`DelimitedFiles`模块中，轻松地将这样的表从CSV/TSV文件加载到Julia中。此模块是Julia默认安装的一部分，因此无需添加：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'There is also the option of letting `readdlm` know that the first row is the
    header, passing `header = true`. However, this would change the return type of
    the function invocation to a tuple of `(data_cells, header_cells)`, which is not
    pretty-printed in interactive environments. At this exploratory phase, we''re
    better off with a table-like representation of the data. The result is a tabular
    data structure that contains our movie titles and their genres:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种选择是让`readdlm`知道第一行是标题，通过传递`header = true`。然而，这将改变函数调用的返回类型为`(data_cells,
    header_cells)`的元组，这在交互式环境中不会被漂亮地打印。在这个探索阶段，我们更倾向于以表格形式表示数据。结果是包含我们的电影标题及其类型的表格数据结构：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let''s see what movie from the top 10 list we could recommend to a user who
    watched the aforementioned movie, `Finding Nemo (2003)`. Rotten Tomatoes classifies
    `Finding Nemo (2003)` under the *Animation*, *Comedy,* and *Kids* genres. We can
    encode this as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们可以向观看上述电影《海底总动员》（2003）的用户推荐哪部电影。烂番茄将《海底总动员》（2003）归类为*动画*、*喜剧*和*儿童*类型。我们可以这样编码：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: To make a movie recommendation based on genre, all we have to do is find the
    ones that are the most similar, that is, the movies that share the most genres
    with our `Finding Nemo (2003)`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 要根据类型进行电影推荐，我们只需找到最相似的电影，即与我们观看的上述电影《海底总动员》（2003）共享最多类型的电影。
- en: There is a multitude of algorithms for computing the similarity (or on the contrary,
    the distance) between items—in our case, as we're dealing with binary values only,
    the Hamming distance looks like a good choice. The Hamming distance is a number
    that's used to denote the difference between two binary strings. This distance
    is calculated by comparing two binary values and taking into account the number
    of positions at which the corresponding bits are different. We'll compare each
    bit in succession and record either `1` or `0`, depending on whether or not the
    bits are different or the same. If they are the same, we record a `0`. For different
    bits, we record a `1`. Then, we add all the 1s and 0s in the record to obtain
    the Hamming distance.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 存在着许多用于计算项目之间相似度（或相反，距离）的算法——在我们的情况下，因为我们只处理二进制值，汉明距离看起来是一个不错的选择。汉明距离是一个用来表示两个二进制字符串之间差异的数字。这个距离是通过比较两个二进制值并考虑对应位不同的位置数量来计算的。我们将依次比较每个位，并根据位是否不同或相同记录`1`或`0`。如果它们相同，我们记录一个`0`。对于不同的位，我们记录一个`1`。然后，我们将记录中的所有`1`和`0`相加，以获得汉明距离。
- en: 'A function for calculating the Hamming distance is available in the `Distances`
    package. This is a third-party Julia package that provides access to a multitude
    of functions for evaluating distances between vectors, including Euclidian, Jaccard,
    Hemming, Cosine, and many others. All we need to do to access this treasure of
    functionality is run the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Distances`包中有一个用于计算汉明距离的函数。这是一个第三方Julia包，它提供了访问多种用于评估向量之间距离的函数，包括欧几里得、贾卡德、汉明、余弦等。我们只需运行以下命令即可访问这个功能丰富的宝藏：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then, we need to iterate over our movies matrix and compute the Hamming distance
    between each movie and `Finding Nemo (2003)`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要遍历我们的电影矩阵，并计算每部电影与《海底总动员》（2003）之间的汉明距离：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This is the end result:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是最终结果：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Since we're computing distances, the most similar movies are the ones within
    the shortest distance. So, according to our recommender, a user who watched `Finding
    Nemo (2003)` should next watch `Finding Dory (2016)` or `Zootopia (2016)` (distance
    `2`) and when done, should move on to `The Jungle Book (2016)` and `Moana (2016)` (both
    at a distance of `3`). If you haven't watched all of these recommended movies
    already, I can tell you that the suggestions are quite appropriate. Similarly,
    the least recommended movie is `Arrival (2016)`, which although is an excellent
    science fiction drama, has nothing in common with cute Nemo and forgetful Dory.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在计算距离，最相似的电影是那些距离最短的电影。因此，根据我们的推荐系统，一个看过《海底总动员》（2003）的用户接下来应该观看《海底总动员2：多莉去哪儿》（2016）或《疯狂动物城》（2016）（距离为`2`），看完之后，应该继续观看《森林书》（2016）和《莫阿娜》（2016）（两者距离均为`3`）。如果你还没有看过这些推荐的影片，我可以告诉你，这些建议相当合适。同样，最不推荐的影片是《降临》（2016），尽管它是一部优秀的科幻剧情片，但与可爱的尼莫和健忘的多莉没有任何共同之处。
- en: Beginning with association-based recommendations
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从基于关联的推荐开始
- en: Although content-based recommender systems can produce great results, they do
    have limitations. For starters, they can't be used to recommend new items. Based
    on my initial `Finding Nemo (2003)` ranking alone, I would be stuck getting suggestions
    for animated movies alone and I'd never get the chance to hear about any new documentaries
    or car or cooking shows that I sometimes enjoy.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管基于内容的推荐系统能够产生很好的结果，但它们确实存在局限性。首先，它们不能用来推荐新项目。仅基于我对《海底总动员》（2003）的初始排名，我可能会一直只得到动画电影的推荐，而永远没有机会听到关于任何我有时会喜欢的纪录片、汽车或烹饪节目。
- en: Also, it works best for categories of items that can be purchased repeatedly,
    like books, apps, songs, or movies, to name a few. But if I'm on Amazon and purchase
    a new dishwasher from the *Home and kitchen* category, it doesn't make a lot of
    sense to get recommendations about products within the same group, such as a fridge
    or a washing machine, as chances are I'm not replacing all of the expensive kitchen
    appliances at the same time. However, I will most likely need the corresponding
    joints and taps and pipes and whatever else is needed to install the dishwasher,
    together with the recommended detergent and maybe other accessories. Since the
    e-commerce platform is selling all of these products as well, it's beneficial
    to order them together and receive them at the same time, saving on transport
    too.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，它最适合那些可以重复购买的商品类别，例如书籍、应用、歌曲或电影等。但如果你在亚马逊上购买了一个新的洗碗机，属于`家居和厨房`类别，那么得到关于同一组产品（如冰箱或洗衣机）的推荐就没有太多意义，因为很可能你不会同时更换所有昂贵的厨房电器。然而，我可能需要相应的接头、阀门、管道以及其他安装洗碗机所需的东西，以及推荐的洗涤剂和其他配件。由于电子商务平台也在销售所有这些产品，因此一起订购并同时收到它们是有益的，这样可以节省运输费用。
- en: These bundles of products can form the foundation of a RS based on product association.
    These types of recommendations are quite common, and are usually presented as
    *frequently bought together* on e-commerce platforms. For physical stores, this
    type of data analysis—also known as **market basket analysis**—is used to place
    products that are purchased together in close physical proximity. Think, for example,
    about pasta being side by side with sauces, or shampoo with conditioners.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这些产品组合可以成为基于产品关联的RS的基础。这类推荐相当常见，通常在电子商务平台上以`经常一起购买`的形式呈现。对于实体店来说，这种数据分析——也称为**市场篮子分析**——用于将一起购买的产品放置在靠近的物理位置。例如，想想意大利面和酱料并排摆放，或者洗发水和护发素并排摆放。
- en: One of the most popular algorithms used for association based recommendations
    is the `Apriori` algorithm. It is used to identify items that frequently occur
    together in different scenarios (shopping baskets, web browsing, adverse drug
    reactions, and so on). The `Apriori` algorithm helps us identify correlations
    through data mining by employing association rules.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于关联的推荐系统中，最流行的算法之一是`Apriori`算法。它用于识别在不同场景（如购物篮、网页浏览、不良药物反应等）中经常一起出现的项目。`Apriori`算法通过使用关联规则帮助我们通过数据挖掘来识别相关性。
- en: Space constraints don't allow us to get into the details of building such as
    system, but if you would like to dive deeper into this topic, there are many free
    resources to get you started. I recommend beginning with *Movie Recommendation
    with Market Basket Analysis* ([https://rpubs.com/vitidN/203264](https://rpubs.com/vitidN/203264))
    as it builds a movie recommender that's very similar to ours.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 空间限制使我们无法深入了解构建此类系统的细节，但如果你想要深入了解这个话题，有许多免费资源可以帮助你入门。我建议从《基于市场篮子的电影推荐》开始，[https://rpubs.com/vitidN/203264](https://rpubs.com/vitidN/203264)，因为它构建的电影推荐器与我们非常相似。
- en: Learning about collaborative filtering
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解协同过滤
- en: '**Collaborative filtering** (**CF**) is another very successful and widely
    used recommendation algorithm. It is based on the idea that people with similar
    preferences will have similar interests. If two customers, let''s call them Annie
    and Bob, give `Finding Nemo (2003)` a good rating and Annie also highly ranks
    `Finding Dory (2016)`, then chances are that Bob will also like `Finding Dory
    (2016)`. Of course, comparing two users and two products may not seem like much, but
    applied to very large datasets representing both users and products, the recommendations
    become highly relevant.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**协同过滤**（**CF**）是另一种非常成功且广泛使用的推荐算法。它基于这样一个观点：具有相似偏好的用户将有相似的兴趣。如果两位客户，我们可以称他们为安妮和鲍勃，对《海底奇缘》（2003）给出了好评，并且安妮也高度评价了《海底总动员》（2016），那么鲍勃也很可能喜欢《海底总动员》（2016）。当然，比较两个用户和两个产品可能看起来不多，但应用到代表用户和产品的非常大数据集中，推荐就变得高度相关。'
- en: If you're confused as to what the difference between CF and content filtering
    is, since both can be used to infer `Finding Dory (2016)` based on `Finding Nemo
    (2003)`, the key point is that CF does not care about item attributes. Indeed,
    when using CF, we don't need the movie genre information, nor any other tags.
    The algorithm is not concerned with the classification of the items. It pretty
    much states that if, for whatever reason, the items were ranked highly by a subset
    of users, then other items that are highly ranked by the same subset of users
    will be relevant for our target user, hence making for a good recommendation.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对于CF（协同过滤）和内容过滤之间的区别感到困惑，因为两者都可以根据《海底总动员》（2016）推断出《海底奇缘》（2003），关键点在于CF不关心项目属性。实际上，在使用CF时，我们不需要电影类型信息，也不需要任何其他标签。算法并不关心项目的分类。它基本上表明，如果由于任何原因，某些项目被用户子集高度评价，那么其他被同一子集高度评价的项目对我们目标用户来说将是相关的，从而形成良好的推荐。
- en: Understanding user-item CF
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解用户-项目CF
- en: This was the basic idea, and with the advent of big data, the CF technique has
    become quite powerful. As it's been applied to different business needs and usage
    scenarios, the algorithm was refined to better address the problems it was attempting
    to solve. As a consequence, a few other approaches emerged, and the original one
    became known as **user-item CF**.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是基本思想，随着大数据的到来，CF技术变得相当强大。由于它被应用于不同的商业需求和用法场景，算法被改进以更好地解决它试图解决的问题。因此，出现了一些其他方法，原始方法因此被称为**用户-项目CF**。
- en: It's gotten this name because it takes as its input user data (user preferences,
    rankings) and outputs item data (item recommendations). It's also known as **user-based
    CF**.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 它之所以得名，是因为它以用户数据（用户偏好、排名）作为输入，并输出项目数据（项目推荐）。它也被称为**基于用户的CF**。
- en: 'You can see it illustrated in the following diagram:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下图表中看到它的说明：
- en: '![](img/b242774a-f1e2-4b9c-8641-6c93227d1fc8.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b242774a-f1e2-4b9c-8641-6c93227d1fc8.png)'
- en: The preceding diagram shows that **Annie** likes **A**, **B**, and **E**, while
    **Bob** likes **A**, **B**, **C**, and **D**.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图表显示，**安妮**喜欢**A**、**B**和**E**，而**鲍勃**喜欢**A**、**B**、**C**和**D**。
- en: The `recommender` algorithm established that, between **Annie** and **Bob**,
    there's a high degree of similarity because they both like items **A** and **B**.
    Next, it will assume that **Annie** will also like other items from Bob's list
    of preferences that she hasn't discovered yet, and the reverse for **Bob**—he'll
    like items from Annie's list that he hasn't discovered yet. Thus, since Annie
    also likes item E, we can recommend it to **Bob**, and since Bob's very fond of
    **C** and **D** and Annie has no knowledge about these yet, we can confidently
    suggest that she checks them out.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`recommender`算法确定，在**Annie**和**Bob**之间有很高的相似度，因为他们都喜欢项目**A**和**B**。接下来，它将假设**Annie**也会喜欢Bob偏好列表中她尚未发现的其它项目，反之亦然——**Bob**会喜欢Annie列表中他尚未发现的项目。因此，由于Annie也喜欢项目E，我们可以向**Bob**推荐它，并且由于**Bob**非常喜欢**C**和**D**，而Annie对这些一无所知，我们可以自信地建议她检查它们。'
- en: 'Let''s take another very simple example, also from the realm of movie recommendations.
    Sticking to our previous list of top 10 movies for the year 2016 on Rotten Tomatoes,
    this time, let''s ignore the classification by genre and imagine that we have
    user ratings data instead:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再举一个非常简单的例子，同样来自电影推荐领域。继续使用我们之前在烂番茄网站上列出的2016年十大电影，这次，让我们忽略按类型分类，而是想象我们有用户评分数据：
- en: '![](img/855a1095-b43b-486b-9f0a-06ae20a0db88.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/855a1095-b43b-486b-9f0a-06ae20a0db88.png)'
- en: The preceding screenshot shows a table of movie titles and users and their corresponding
    ratings. As it happens in real life, not all of the users have rated all of the
    moves—the absence of a rating is indicated by an empty cell.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的屏幕截图显示了一个包含电影标题和用户及其对应评分的表格。正如现实生活中发生的那样，并非所有用户都为所有电影评分——未评分的表示为空单元格。
- en: You will notice in the preceding screenshot that by a strange twist of faith,
    the user's names provide a hint as to what kind of movies they prefer. Acton is
    very much into action movies, while Annie loves animations. Comey's favorites
    are the comedies, while Dean enjoys good dramas. Kit's highest rankings went to
    kids movies, Missie loves mystery movies, while musical's are Musk reasons for
    binge watching. Finally, Sam is a science fiction fan.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你会在前面的屏幕截图中注意到，由于信仰的奇特转折，用户的姓名提供了他们偏好的电影类型的线索。Acton非常喜欢动作电影，而Annie则热爱动画。Comey的最爱是喜剧，而Dean则喜欢优秀的戏剧。Kit的最高排名是儿童电影，Missie喜欢悬疑电影，而音乐电影是Musk狂热观看的原因。最后，Sam是一位科幻迷。
- en: The dataset is provided in this chapter's files under the name `top_10_movies_user_rankings.csv`.
    Please download it from [https://github.com/PacktPublishing/Julia-Programming-Projects/blob/master/Chapter06/top_10_movies_user_rankings.csv](https://github.com/PacktPublishing/Julia-Programming-Projects/blob/master/Chapter06/top_10_movies_user_rankings.csv)
    and place it somewhere on your hard drive where you can easily access it from
    Julia's REPL.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 数据集在本章的文件中以`top_10_movies_user_rankings.csv`的名称提供。请从[https://github.com/PacktPublishing/Julia-Programming-Projects/blob/master/Chapter06/top_10_movies_user_rankings.csv](https://github.com/PacktPublishing/Julia-Programming-Projects/blob/master/Chapter06/top_10_movies_user_rankings.csv)下载它，并将其放置在您可以从Julia的REPL轻松访问的硬盘上的某个位置。
- en: 'We can load it into memory using the same `readdlm` Julia function as before:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用之前提到的相同的`readdlm` Julia函数将其加载到内存中：
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This file uses the `;` char as the column separator, so we need to pass that
    into the `readdlm` function call. Remember that in Julia, `";"` is different from
    `':'`. The first is a `String` of length one, while the second is a `Char`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件使用`;`字符作为列分隔符，因此我们需要将其传递给`readdlm`函数调用。记住，在Julia中，`";"`与`':'`不同。前者是一个长度为1的`String`，而后者是一个`Char`。
- en: 'This is the result of the `.csv` file being read—a matrix containing movies
    on rows and people on columns, with each person''s rating at the corresponding
    intersection between rows and columns:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这是读取`.csv`文件的结果——一个包含电影在行上和人在列上的矩阵，每个人的评分对应于行和列的交叉点：
- en: '![](img/f400846a-c6c9-4597-b0c1-cabaf04cd836.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f400846a-c6c9-4597-b0c1-cabaf04cd836.png)'
- en: It works, but the data doesn't look too good. As usually happens with data in
    real life, we don't always have ratings from all the users. The `missing` values
    were imported as empty strings `""`, and the headers were interpreted as entries
    in the matrix. Julia's `readdlm` is great for quick data imports, but for more
    advanced data wrangling, we can benefit considerably from using Julia's powerful
    `DataFrames` package.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 它是有效的，但数据看起来并不太好。在现实生活中，数据通常不会从所有用户那里都有评分。`缺失`值被导入为空字符串`""`，并且标题被解释为矩阵中的条目。Julia的`readdlm`非常适合快速导入数据，但对于更高级的数据处理，我们可以从使用Julia强大的`DataFrames`包中受益良多。
- en: '`DataFrames` is a third-party Julia package that exposes a rich set of functions
    for manipulating tabular data. You should remember it from our introduction in
    [Chapter 1](90a7f09d-d63b-45d7-baf5-576470d0910f.xhtml),* Getting Started with
    Julia Programming*—if not, please take a few minutes to review that part. The
    rest of our discussion will assume that you have a basic understanding of `DataFrames`
    so that we can now focus on the more advanced features and use cases.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`DataFrames`是一个第三方Julia包，它提供了一组丰富的函数来操作表格数据。你应该在我们的[第1章](90a7f09d-d63b-45d7-baf5-576470d0910f.xhtml)《Julia编程入门》中了解它——如果不是，请花几分钟时间回顾一下那部分内容。接下来的讨论将假设你对`DataFrames`有基本的了解，这样我们就可以现在专注于更高级的功能和用例。'
- en: 'If, for some reason, you no longer have the `DataFrames` package, `pkg> add
    DataFrames` is all we need. While we''re at it, let''s also install the `CSV`
    package—it''s a powerful utility library for handling delimited text files. We
    can add both in one step:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由于某种原因，你不再有`DataFrames`包，`pkg> add DataFrames`就是我们需要做的全部。在此同时，让我们也安装`CSV`包——它是一个强大的实用库，用于处理分隔文本文件。我们可以一步添加这两个包：
- en: '[PRE11]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We''ll use `CSV` to load the comma-separated file and produce a `DataFrame`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`CSV`来加载逗号分隔的文件并生成一个`DataFrame`：
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The resulting `DataFrame` should look like this:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 结果的`DataFrame`应该看起来像这样：
- en: '![](img/073d60f6-3d89-4c40-b5c9-94f99efdca91.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/073d60f6-3d89-4c40-b5c9-94f99efdca91.png)'
- en: We get a beautifully rendered tabular data structure, with the missing ratings
    correctly represented as `missing` data.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了一个美观的表格数据结构，缺失的评分被正确地表示为`missing`数据。
- en: 'We can get a quick summary of our data by using the `describe` function:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`describe`函数来快速总结我们的数据：
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The output for this is as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出的结果如下：
- en: '![](img/f7c3d11a-25f8-43f4-a6b2-a9ea4484c01f.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f7c3d11a-25f8-43f4-a6b2-a9ea4484c01f.png)'
- en: Multiple columns have `missing` values. A `missing` value represents a value
    that is absent in the dataset. It is defined in the `Missings` package ([https://github.com/JuliaData/Missings.jl](https://github.com/JuliaData/Missings.jl)),
    and it's the singleton instance of the `Missing` type. If you're familiar with `NULL`
    in SQL or `NA` in R, `missing` is the same in Julia.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 多个列存在`缺失`值。一个`缺失`值表示在数据集中不存在的数据。它在`Missings`包（[https://github.com/JuliaData/Missings.jl](https://github.com/JuliaData/Missings.jl)）中定义，并且是`Missing`类型的单例实例。如果你熟悉SQL中的`NULL`或R中的`NA`，那么在Julia中`missing`是相同的。
- en: Missing values are problematic when working with real-life datasets as they
    can affect the accuracy of the computations. For this reason, common operations
    that involve `missing` values usually propagate `missing`. For example, `1 + missing`
    and `cos(missing)` will both return `missing`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理现实生活中的数据集时，`缺失`值是有问题的，因为它们可能会影响计算的准确性。因此，涉及`missing`值的常见操作通常会传播`missing`。例如，`1
    + missing`和`cos(missing)`都会返回`missing`。
- en: 'We can check if a value is missing by using the `ismissing` function:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`ismissing`函数来检查一个值是否缺失：
- en: '[PRE14]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In many cases, `missing` values will have to be skipped or replaced with a valid
    value. What value is appropriate for replacing `missing` will depend from case
    to case, as dictated by the business logic. In our case, for the missing ratings,
    we can use the value `0`. By convention, we can agree that valid ratings range
    from `1` to `10`, and that a rating of `0` corresponds to no rating at all.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，`缺失`值需要被跳过或替换为有效值。替换`missing`的适当值将取决于具体情况，由业务逻辑决定。在我们的案例中，对于缺失的评分，我们可以使用值`0`。按照惯例，我们可以同意有效评分的范围是从`1`到`10`，并且评分`0`对应于没有任何评分。
- en: 'One way to do the replacement is to iterate over each column except `Movie
    title` and then over each cell, and if the corresponding value is missing, replace
    it with `0`. Here is the code:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 一种替换的方法是遍历除了`电影标题`之外的所有列，然后遍历每个单元格，如果相应的值是缺失的，就将其替换为`0`。以下是代码：
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We''re all done—our data is now clean, with zeroes replacing all the previously
    missing values:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了——我们的数据现在干净了，所有之前缺失的值都被零替换了：
- en: '![](img/2e5355cc-0f4a-4ab9-adf0-4ae0f421eb30.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2e5355cc-0f4a-4ab9-adf0-4ae0f421eb30.png)'
- en: 'It would help if you saved this clean version of our data as a *Tab* separated
    file, for future reference, with the following code:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您能将我们数据的这个干净版本保存为*Tab*分隔的文件，以供将来参考，以下代码将有所帮助：
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now that we have our ratings loaded into Julia, the next step is to compute
    the similarity between the various users. The Hamming distance, the formula that
    we used when computing content based recommendations, would not be a good choice
    for numerical data. A much better alternative is Pearson's correlation coefficient.
    This coefficient, also known as ***Pearson's r* or bivariate correlation**, is
    a measure of the linear correlation between two variables. It has a value between
    `+1` and `−1`. A value of `1` indicates total positive linear correlation (both
    values increase together), while `-1` represents total negative linear correlation
    (one value decreases while the other increases). The value `0` means that there's
    no linear correlation.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将评分加载到Julia中，下一步是计算不同用户之间的相似度。在计算基于内容的推荐时我们使用的汉明距离，对于数值数据来说不是一个好的选择。一个更好的替代方案是皮尔逊相关系数。这个系数也称为***皮尔逊r*或双变量相关**，是衡量两个变量之间线性相关程度的度量。它的值在`+1`和`−1`之间。`1`的值表示完全正线性相关（两个值同时增加），而`-1`表示完全负线性相关（一个值减少而另一个值增加）。`0`的值表示没有线性相关。
- en: 'Here are a few examples of scatter diagrams with different visualizations of
    the correlation coefficient (By Kiatdd—Own work, CC BY-SA 3.0, [https://commons.wikimedia.org/w/index.php?curid=37108966](https://commons.wikimedia.org/w/index.php?curid=37108966)):'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些散点图的示例，展示了相关系数的不同可视化（由Kiatdd—自行工作，CC BY-SA 3.0，[https://commons.wikimedia.org/w/index.php?curid=37108966](https://commons.wikimedia.org/w/index.php?curid=37108966)）：
- en: '![](img/8c9c0a1a-64df-47c0-92e8-6bf2d380b65d.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8c9c0a1a-64df-47c0-92e8-6bf2d380b65d.png)'
- en: 'Let''s see how we would calculate the similarity between `Acton` and `Annie`,
    based on the movie ratings they provided. Let''s make things simpler and focus
    strictly on their data by extracting the `Movie title` column, together with the
    `Acton` and `Annie` columns:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何根据他们提供的电影评分计算Acton和Annie之间的相似度。让我们简化问题，严格关注他们的数据，通过提取`Movie title`列以及`Acton`和`Annie`列：
- en: '[PRE17]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The output is as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/c61080ab-a58f-4399-89de-7547b64085bd.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c61080ab-a58f-4399-89de-7547b64085bd.png)'
- en: This returns another `DataFrame`, referenced as `acton_and_annie`, which corresponds
    to the columns one to three of the `movies` `DataFrame`, representing Acton's
    and Annie's ratings for each of the movies.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回另一个`DataFrame`，称为`acton_and_annie`，它对应于`movies` `DataFrame`中的一到三列，代表Acton和Annie对每部电影的评分。
- en: 'This is good, but we''re only interested in the movies that were rated by both
    users. If you remember from our discussion of `DataFrame` in [Chapter 1](90a7f09d-d63b-45d7-baf5-576470d0910f.xhtml), *Getting
    Started with Julia Programming, *we can select rows (and columns) by passing a
    Boolean value—`true` to select it, `false` to skip it. We can use this in combination
    with the dot syntax for element-wise operations to check if the values in the
    `:Acton` and `:Annie` columns are greater than `0`. The code will look like this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好，但我们只对两个用户都评分的电影感兴趣。如果您还记得我们在[第1章](90a7f09d-d63b-45d7-baf5-576470d0910f.xhtml)中关于`DataFrame`的讨论——“Julia编程入门”，我们可以通过传递布尔值来选择行（和列）——`true`表示选择，`false`表示跳过。我们可以结合点语法进行元素级操作，检查`:Acton`和`:Annie`列中的值是否大于`0`。代码将如下所示：
- en: '[PRE18]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, we apply the bitwise `&` operator, which is also element-wise, to the
    resulting arrays:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将位运算符`&`应用于结果数组，该运算符也是元素级的：
- en: '[PRE20]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The output is as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/4914a5e5-29d2-4d42-9de2-050e2270d142.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4914a5e5-29d2-4d42-9de2-050e2270d142.png)'
- en: Let's plot the ratings. Julia comes with quite a few options for plotting. We
    saw some in [Chapter 1](90a7f09d-d63b-45d7-baf5-576470d0910f.xhtml), *Getting
    Started with Julia Programming*, and we'll look at plotting in more detail in
    [Chapter 9](11df7c94-2e9a-4cc5-aba1-b9c9c93800a0.xhtml), *Working with Dates,
    Time, and Time Series*. For now, we'll use the appropriately named `Plots` library
    to quickly visualize our data.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们绘制评分。Julia 提供了相当多的绘图选项。我们在 [第 1 章](90a7f09d-d63b-45d7-baf5-576470d0910f.xhtml)，*开始使用
    Julia 编程* 中看到了一些，我们将在 [第 9 章](11df7c94-2e9a-4cc5-aba1-b9c9c93800a0.xhtml)，*处理日期、时间和时间序列*
    中更详细地探讨绘图。现在，我们将使用名为 `Plots` 的库来快速可视化我们的数据。
- en: '`Plots` is designed as a higher-level interface to other plotting libraries
    (named *backends* in `Plots` language), such as `GR` or `PyPlot`. It basically
    unifies multiple lower-level plotting packages (backends) under a common API.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`Plots` 是设计为一个高级接口，用于其他绘图库（在 `Plots` 语言中称为 *backends*），例如 `GR` 或 `PyPlot`。它基本上将多个低级绘图包（后端）统一在一个公共
    API 下。'
- en: As always, start with `pkg> add Plots` and continue with `using Plots`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，先使用 `pkg> add Plots` 命令，然后继续使用 `using Plots`。
- en: 'We''re now ready to generate the visualization:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以生成可视化：
- en: '[PRE21]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '![](img/2d60606a-81f7-4823-b621-b1df752e6245.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2d60606a-81f7-4823-b621-b1df752e6245.png)'
- en: By the looks of it, there is a good correlation between the user's movie preferences.
    But we can do even better.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 从外观上看，用户的电影偏好之间有很好的相关性。但我们还可以做得更好。
- en: Julia's ecosystem provides access to yet another powerful package that combines
    both plotting and statistical features. It's called `StatPlots` and actually works
    on top of the `Plots` package, providing statistical plotting recipes for `Plots`.
    It also supports `DataFrame` visualizations out of the box, so it's a perfect
    match for our needs.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 的生态系统提供了访问另一个强大的包，它结合了绘图和统计功能。它被称为 `StatPlots`，实际上是在 `Plots` 包之上工作的，为
    `Plots` 提供了统计绘图配方。它还支持开箱即用的 `DataFrame` 可视化，因此它非常适合我们的需求。
- en: 'Let''s add it with `pkg> add StatPlots` and bring it into scope (`using StatPlots`).
    We can now use the `@df` macro that''s exposed by `StatPlots` to generate a scatter
    plot of our data:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 `pkg> add StatPlots` 命令添加它，并将其引入作用域（`using StatPlots`）。现在我们可以使用 `StatPlots`
    提供的 `@df` 宏来生成我们数据的散点图：
- en: '[PRE22]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The preceding code will produce the following visualization:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将产生以下可视化效果：
- en: '![](img/bce24b5e-1b1e-4b77-8f99-5269aeb0c174.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bce24b5e-1b1e-4b77-8f99-5269aeb0c174.png)'
- en: This new plot shows the correlation between the movies, despite the outlier.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新的图表显示了电影之间的相关性，尽管存在异常值。
- en: 'Let''s compute the Pearson correlation between Acton''s and Annie''s ratings:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们计算 Acton 和 Annie 评分之间的皮尔逊相关系数：
- en: '[PRE23]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Pretty much any value over `0.6` indicates a good similarity, so it looks like
    we're onto something.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎任何超过 `0.6` 的值都表示良好的相似性，所以看起来我们正在找到一些东西。
- en: 'Now, we can recommend to Annie some of Acton''s favorites that she hasn''t
    seen, as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以向 Annie 推荐一些 Acton 的最爱电影，她还没有看过，如下所示：
- en: '[PRE24]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We''ll get a `DataFrame` with four rows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到一个包含四行的 `DataFrame`：
- en: '![](img/ef28b302-ae0d-4be7-9449-b9460bd13885.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ef28b302-ae0d-4be7-9449-b9460bd13885.png)'
- en: 'However, there''s a small glitch. We assumed that all the ratings indicate
    a strong preference, but in this case, many of Acton''s ratings are rather an
    indication of a dislike. With the exception of `Captain America: Civil War (2016)`,
    all the possible recommendations have bad ratings. Luckily, that is easy to fix—we
    just need to recommend movies that have a high rating, let''s say, of at least
    `7`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '然而，这里有一个小问题。我们假设所有评分都表示强烈的偏好，但在这个情况下，Acton 的许多评分实际上更像是表示不喜欢。除了 `Captain America:
    Civil War (2016)` 之外，所有可能的推荐都有不良的评分。幸运的是，这很容易解决——我们只需要推荐评分至少为 `7` 的电影：'
- en: '[PRE25]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This leaves us with only one movie, `Captain America: Civil War (2016)`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '这就留下了我们唯一一部电影，`Captain America: Civil War (2016)`：'
- en: '![](img/9266d9fe-9059-42d3-981d-07ec37e7fe1d.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9266d9fe-9059-42d3-981d-07ec37e7fe1d.png)'
- en: Now that we understand the logic of user-based recommender systems, let's put
    all of these steps together to create a simple recommender script.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经理解了基于用户的推荐系统的逻辑，让我们将这些步骤全部放在一起，创建一个简单的推荐脚本。
- en: We'll analyze our users' rating matrix in a script that will take advantage
    of all the available data to generate recommendations for all of our users.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在一个脚本中分析我们用户的评分矩阵，该脚本将利用所有可用数据为我们所有用户生成推荐。
- en: 'Here''s a possible implementation—please create a u`ser_based_movie_recommendations.jl`
    file with the following code. Do make sure that the `top_10_movies_user_rankings.tsv`
    file is in the same folder (or update the path in the code to match your location).
    Here''s the code:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个可能的实现——请创建一个名为`user_based_movie_recommendations.jl`的文件，并包含以下代码。请确保`top_10_movies_user_rankings.tsv`文件在同一个文件夹中（或者更新代码中的路径以匹配您的位置）。以下是代码：
- en: '[PRE26]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `user_similarity` function computes the similarity of our target user (the
    one passed into the function as the argument) with all the other users and returns
    a dictionary of the form:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`user_similarity`函数计算我们的目标用户（作为函数参数传入的用户）与其他所有用户的相似度，并返回一个形式的字典：'
- en: '[PRE27]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `dict` represents Annie's similarity with all the other users.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`dict`表示安妮与其他所有用户的相似度。'
- en: We use the similarities in the recommendations function to pick the relevant
    users and make recommendations based on their favorite movies, which were not
    already rated by our target user.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在推荐函数中使用相似度来选择相关的用户，并根据他们喜欢的电影（这些电影尚未被我们的目标用户评分）进行推荐。
- en: I've also added a little twist to make the recommendations more relevant—a weight
    factor. This is computed by multiplying the user's rating with the user's similarity.
    If, say, `Comey` gives a movie an 8 and is 100% similar to `Missie` (correlation
    coefficient equals 1), the weight of the recommendation will also be *8 (8 * 1)*.
    But if Comey is only 50% similar to Musk (0.5 correlation coefficient), then the
    weight of the recommendation (corresponding to the estimated rating) will be just
    *4 (8 * 0.5)*.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我还增加了一个小变化，使推荐更加相关——一个权重因子。这是通过将用户的评分与用户的相似度相乘来计算的。比如说，如果科米给一部电影打8分，并且与米西100%相似（相关系数等于1），那么推荐的权重也将是*8（8
    * 1）*。但如果科米只与马斯克50%相似（0.5的相关系数），那么推荐的权重（对应于估计的评分）将只是*4（8 * 0.5）*。
- en: At the end of the file, we bootstrap the whole process by looping through an
    array of all the users, and we produce and print the movie recommendations for
    each of them.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件末尾，我们通过遍历所有用户的数组来引导整个过程，并为每个用户生成和打印电影推荐。
- en: 'Running this will output movie recommendations, together with their weights
    for each of our users:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码将输出电影推荐，以及每个用户的权重：
- en: '[PRE28]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The data looks quite good, considering that this is a toy example. A production
    quality recommender system should be based on millions of such ratings.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这是一个玩具示例，数据看起来相当不错。一个生产质量的推荐系统应该基于数百万这样的评分。
- en: 'However, if you look closely, you might notice that something''s not quite
    right—the `Recommendations for Kit`. Kit likes kids movies—light-hearted animated
    comedies. Our system recommends him, with quite a lot of weight, a lot of dramas!
    What gives? If we look at the similarity data for Kit, we''ll see that he''s very
    well correlated with Dean and Dean likes drama. That might sound weird, but it''s
    actually correct if we check the data:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你仔细观察，可能会注意到有些地方不太对——`Kit的推荐`。基特喜欢儿童电影——轻松的动画喜剧。我们的系统推荐给他很多，权重很大，很多悲剧！这是怎么回事？如果我们查看基特的相似度数据，我们会看到他与迪恩非常相关，而迪恩喜欢悲剧。这听起来可能有些奇怪，但如果检查数据，这实际上是正确的：
- en: '[PRE29]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The output is as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/55770a5d-31dc-478e-8e62-acd08f85223d.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/55770a5d-31dc-478e-8e62-acd08f85223d.png)'
- en: Notice how the only movies they both watched are `The Jungle Book (2016)` and
    `Finding Dory (2016)`, and how the ratings are correlated since both give higher
    ratings to `Finding Dory (2016)`. Therefore, there is a strong positive correlation
    between Dean and Kit. But what our algorithm doesn't take into account is that
    even if Dean likes `Finding Dory (2016)` more than `The Jungle Book (2016)`, he
    still doesn't really like either, as indicated by the low ratings of `4` and `2`,
    respectively.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 注意他们俩都看过的电影只有《森林书》（2016）和《海底总动员》（2016），以及评分是如何相关的，因为两者都对《海底总动员》（2016）给出了更高的评分。因此，迪恩和基特之间存在强烈的正相关。但我们的算法没有考虑到，即使迪恩比《森林书》（2016）更喜欢《海底总动员》（2016），他实际上对这两部电影都不太喜欢，正如他给出的低评分（分别为4和2）所示。
- en: 'The solution is quite simple, though—we just need to remove ratings that don''t
    indicate a strong positive preference. Again, we can use a rating equal to or
    larger than `7` to count as a like. So, in the `user_similarity` function, please
    look for the following line:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案相当简单，尽管如此——我们只需要移除那些没有表明强烈正面偏好的评分。再次强调，我们可以使用等于或大于`7`的评分来计算喜欢。因此，在`user_similarity`函数中，请查找以下行：
- en: '[PRE30]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Replace `ratings[user] .> 0` with `ratings[user] .> 7` so that the whole line
    now reads as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 将`ratings[user] .> 0`替换为`ratings[user] .> 7`，这样整个行现在如下所示：
- en: '[PRE31]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: What this does is now compute similarity only based on favorites. As a result,
    `Kit` is no longer similar to `Dean` (the correlation coefficient is `0`).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这所做的现在是基于收藏夹来计算相似度。因此，`Kit`不再与`Dean`相似（相关系数为`0`）。
- en: 'Another consequence of the fact that our recommendations are more targeted
    is that we no longer have recommendations for all the users—but this is, again,
    caused by the fact that we''re working with a very small example dataset. Here
    are the final recommendations:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们推荐更加有针对性的另一个后果是，我们不再为所有用户提供推荐——但这同样是由于我们正在处理一个非常小的示例数据集。以下是最终的推荐：
- en: '[PRE32]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We only have suggestions for Acton, Comey, and Dean, but they are now much more
    accurate.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只为Acton、Comey和Dean提供建议，但现在它们更加准确。
- en: Item-item CF
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 物品-物品协同过滤
- en: User-based CF works quite well and is widely used in production in the wild,
    but it does have a few considerable downsides. First, it's difficult to get enough
    preference information from users, leaving many of them without a solid base for
    relevant recommendations. Second, as the platform and the underlying business
    grows, the number of users will grow much faster than the number of items. Netflix,
    for example, to keep the discussion in the familiar area of movies, grows its
    user base massively by expanding into new countries, while the production of movies
    stays pretty much the same on a yearly basis. Finally, the user's data does change
    quite a lot, so the rating matrix would have to be updated often, which is a resource-intensive
    and time-consuming process.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 基于用户的协同过滤工作得相当好，并且在野外生产中被广泛使用，但它确实有几个相当大的缺点。首先，很难从用户那里获取足够多的偏好信息，导致许多用户没有相关推荐的坚实基础。其次，随着平台和底层业务的增长，用户的数量将比物品的数量增长得快得多。例如，Netflix为了将讨论保持在熟悉的电影领域，通过扩展到新国家，其用户基础大幅增长，而电影的产量在每年基本上保持不变。最后，用户的数据确实变化很大，因此评分矩阵需要经常更新，这是一个资源密集和时间消耗的过程。
- en: These problems became painfully obvious at Amazon, some 10 years ago. They realized
    that since the number of products grows at a much slower rate than the number
    of users, instead of computing user similarity, they could compute item similarity
    and make recommendations stemming from the list of related items.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题在大约10年前的亚马逊变得非常明显。他们意识到，由于产品的数量增长速度远低于用户的数量，他们可以计算项目相似度，而不是用户相似度，并基于相关项目列表进行推荐。
- en: 'The following diagram should help you understand the difference between item-based
    (or item-item) and user-based (or user-item) CF:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图表应该有助于你理解基于物品（或物品-物品）和基于用户（或用户-物品）协同过滤之间的区别：
- en: '![](img/cfd88d93-1653-4b45-aa1e-324b48177322.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cfd88d93-1653-4b45-aa1e-324b48177322.png)'
- en: The preceding diagram shows that **Annie** purchased **A**, **B**, and **E**,
    **Bob** purchased **A**, **B**, and **D**, and **Charley** purchased **A** and
    **C**. The purchasing behavior of **Annie** and **Bob** will indicate a correlation
    between **A** and **B**, and since **Charley** already purchased **A** but not
    **B**, we can recommend **Charley** to take a look at **B**.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图表显示，**安妮**购买了**A**、**B**和**E**，**鲍勃**购买了**A**、**B**和**D**，而**查理**购买了**A**和**C**。**安妮**和**鲍勃**的购买行为将表明**A**和**B**之间存在相关性，由于**查理**已经购买了**A**但没有购买**B**，我们可以向**查理**推荐看看**B**。
- en: From an implementation perspective, there are similarities to user-item CF,
    but it is more involved as it includes an extra layer of analysis. Let's try this
    out with our imaginary movie rankings. Let's create a new file called `item_based_recommendations.jl`
    to host our code.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 从实现的角度来看，它与用户-项目协同过滤有相似之处，但它更为复杂，因为它包括一个额外的分析层。让我们用我们的假想电影排名来试试。让我们创建一个名为`item_based_recommendations.jl`的新文件来存放我们的代码。
- en: 'Here is the complete implementation:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是完整的实现：
- en: '[PRE33]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: To keep the code simpler, we're only generating recommendations for a single
    movie—but it should be relatively simple to extend it to come up with recommendations
    for each movie in our list (you can try this as an exercise). We'll only suggest
    similar movies to the users that have watched `Finding Dory (2016)`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使代码更简单，我们只为单部电影生成推荐——但将其扩展到为列表中的每部电影生成推荐相对简单（你可以尝试作为练习来做）。我们只会向看过《海底总动员》（2016）的用户推荐类似的电影。
- en: Let's take it apart and see how the script works.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将其拆开来看看脚本是如何工作的。
- en: As you can see, I've added some `println` and `@show` calls that output extra
    debug information—they're commented out, but feel free to uncomment them when
    running the file to help you better understand what each section does and what
    the workflow of the code is.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我添加了一些`println`和`@show`调用，它们输出额外的调试信息——它们被注释掉了，但当你运行文件时，请随意取消注释它们，以帮助你更好地理解每个部分的作用以及代码的工作流程。
- en: Setting up our data matrix is more difficult now. We need to transpose our initial
    dataset, that is, rotate it. The `setup_data` function is dedicated to this task
    alone—loading the data file, transposing the matrix, and setting up the data into
    a `DataFrame`. It's a proper **extract, transform, load** (**ETL**) process in
    just a few lines of code, which is pretty cool! Let's look at this closely—it's
    quite a common day-to-day data science task.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在设置数据矩阵更困难了。我们需要转置我们的初始数据集，即旋转它。`setup_data`函数专门用于这项任务——加载数据文件，转置矩阵，并将数据设置到`DataFrame`中。这只是一个几行代码的合适**提取、转换、加载**（**ETL**）过程，这相当酷！让我们仔细看看——这是一个相当常见的一天到晚的数据科学任务。
- en: 'In the first line of the function, we load the data into a Julia matrix. The
    `readdlm` function is not as powerful as `DataFrames`, so it has no knowledge
    of headers, gobbling everything into an `Array`:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数的第一行，我们将数据加载到一个Julia矩阵中。`readdlm`函数没有`DataFrames`强大，所以它没有标题的知识，将所有内容都吞进一个`Array`：
- en: '[PRE34]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We''ll end up with the following matrix:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终会得到以下矩阵：
- en: '![](img/21550340-67d6-4f77-afaf-7dfd21684eb9.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![](img/21550340-67d6-4f77-afaf-7dfd21684eb9.png)'
- en: As we can see, the headings are mixed with the actual data.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，标题与实际数据混合在一起。
- en: 'Now, we need to transpose the matrix. Unfortunately, transposing doesn''t work
    smoothly for all kinds of matrices in Julia yet, and the recommended way is to
    do this via `permutedims`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要转置矩阵。不幸的是，在Julia中，转置并不总是对所有类型的矩阵工作得很好，推荐的方法是通过`permutedims`来完成：
- en: '[PRE35]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The output is as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/98126d1d-de90-4aed-a074-3d811562d948.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![](img/98126d1d-de90-4aed-a074-3d811562d948.png)'
- en: We're getting closer!
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们越来越接近了！
- en: 'Next, we convert it into a `DataFrame`:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将其转换为`DataFrame`：
- en: '[PRE36]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The output is as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/d83bebec-1537-4045-af08-2594af140382.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d83bebec-1537-4045-af08-2594af140382.png)'
- en: If you run the previous code yourself, you might notice that the REPL will omit
    some of the `DataFrame` columns, since the output is too wide. To get Julia to
    display all the columns, like in this snippet, you can use the `showall` function,
    as in `showall(movies)`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你亲自运行前面的代码，你可能会注意到REPL会省略一些`DataFrame`列，因为输出太宽了。为了使Julia显示所有列，就像在这个片段中一样，你可以使用`showall`函数，例如`showall(movies)`。
- en: 'It looks good, but we need to give the columns proper names, using the data
    that is now on the first row. Let''s extract all the columns names into a `Vector`:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来不错，但我们需要给列赋予合适的名称，使用现在第一行上的数据。让我们将所有列名提取到一个`Vector`中：
- en: '[PRE37]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now, we can use it to name the columns:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以用它来命名列：
- en: '[PRE38]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The output is as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/4f684580-a0ec-4773-9c5c-f1b37e44829c.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4f684580-a0ec-4773-9c5c-f1b37e44829c.png)'
- en: 'Our `DataFrame` looks better already. The only things left to do are to remove
    the extra row with the headers and change the `Movie title` header to `User`:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`DataFrame`看起来已经好多了。剩下要做的只是删除带有标题的额外行，并将`Movie title`标题更改为`User`：
- en: '[PRE39]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The output is as follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/2db2e1c8-55e2-46f4-aa4d-a354f54c782a.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2db2e1c8-55e2-46f4-aa4d-a354f54c782a.png)'
- en: All done—our ETL process is complete!
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 完成了——我们的ETL过程已经完成！
- en: 'We start our recommender by invoking the `recommendations` function, passing
    in the name of the movie, `Finding Dory (2016)`, as a `Symbol`. The first thing
    this function does is invoke the `movie_similarity` function, which computes which
    other movies are similar to `Finding Dory (2016)` based on the users'' ratings.
    For our target movie, we''ll get the following results:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过调用`recommendations`函数开始我们的推荐器，传入电影名称`Finding Dory (2016)`作为一个`Symbol`。这个函数首先调用`movie_similarity`函数，该函数根据用户的评分计算与`Finding
    Dory (2016)`相似的其他电影。对于我们的目标电影，我们将得到以下结果：
- en: '[PRE40]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We can see here that there's an almost perfect negative correlation with `La
    La Land (2016)` (so users that like `La La Land (2016)` do not like `Finding Dory
    (2016)`). There is also a very strong positive correlation with `The Jungle Book
    (2016)`, `Zootopia (2016)`, and `Moana (2016)`, which makes sense, since they're
    all animations.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，与`La La Land (2016)`几乎有完美的负相关性（所以喜欢`La La Land (2016)`的用户不喜欢`Finding
    Dory (2016)`）。与`The Jungle Book (2016)`、`Zootopia (2016)`和`Moana (2016)`也有非常强的正相关性，这是有道理的，因为它们都是动画片。
- en: Here is where the logic gets a bit more complicated. Now, we have a list of
    movies that are similar to `Finding Dory (2016)`. To make recommendations, we
    want to look at all the users that have watched `Finding Dory (2016)` (and gave
    it a good enough rating), and suggest similar movies that they haven't watched
    yet (movies that have a rating of 0). This time, we'll be using a minimum rating
    of 5 instead of the previous 7, since given our very limited dataset, 7 would
    be too restrictive and would yield no recommendations. We'll compute the weight
    of the suggestions as the product between the user's rating of `Finding Dory (2016)` and
    the correlation coefficient between `Finding Dory (2016)` and the recommended
    movie. Makes sense? Let's see it in action!
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这里逻辑变得稍微复杂一些。现在，我们有一个与《海底总动员》（2016）相似的电影的列表。为了做出推荐，我们想要查看所有看过《海底总动员》（2016）并且给出了足够好的评分的用户，并建议他们尚未观看的相似电影（评分为零的电影）。这次，我们将使用最低评分为5而不是之前的7，因为鉴于我们的数据集非常有限，7会过于严格，并且不会产生任何推荐。我们将计算建议的权重，即用户对《海底总动员》（2016）的评分与《海底总动员》（2016）和推荐电影之间的相关系数的乘积。这说得通吗？让我们看看实际效果吧！
- en: 'If we run the script, we get the following output:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行脚本，我们会得到以下输出：
- en: '[PRE41]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The only user that would be (kind of) interested in watching movies similar
    to `Finding Dory (2016)` in our small dataset is `Comey`—but the recommendations
    won't be great. The algorithm estimates a weight (and thus, a rating) of `4.38693`
    for `The Jungle Book (2016)` and `4.66799` for `Moana (2016)`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的小数据集中，唯一可能对观看与《海底总动员》（2016）相似的电影感兴趣的（有点）用户是“Comey”——但推荐不会很好。算法估计《森林书》（2016）的权重（因此，评分）为4.38693，而《莫阿娜》（2016）的权重为4.66799。
- en: Summary
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This concludes the first part of our journey into recommender systems. They
    are an extremely important part of today's online business models and their usefulness
    is ever-growing, in direct relation to the exponential growth of data generated
    by our connected software and hardware. Recommender systems are a very efficient
    solution to the information overload problem—or rather, an information filter
    problem. Recommenders provide a level of filtering that's appropriate for each
    user, turning information, yet again, into a vector of customer empowerment.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这标志着我们探索推荐系统之旅的第一部分的结束。它们是当今在线商业模式中极其重要的组成部分，其有用性随着我们连接的软件和硬件生成数据的指数级增长而不断增长。推荐系统是解决信息过载问题——或者说，信息过滤问题的非常有效的解决方案。推荐器为每个用户提供适当的过滤级别，再次将信息转化为客户赋能的向量。
- en: Although it's critical to understand how the various types of recommender systems
    work, in order to be able to choose the right algorithm for the types of problems
    you'll solve in your work as a data scientist, implementing production-grade systems
    by hand is not something most people do. As with almost everything in the realm
    of software development, it's best to use stable, powerful, and mature existing
    libraries when they're available.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然理解各种推荐系统的工作原理对于选择适合你在数据科学家工作中解决的问题类型的算法至关重要，但手动实现生产级别的系统并不是大多数人会做的事情。就像软件开发领域的几乎所有事情一样，当有现成的稳定、强大和成熟的库可用时，最好使用它们。
- en: In the next chapter, we'll learn how to build a more powerful recommender system
    using existing Julia libraries. We'll generate recommendations for a dating site,
    taking advantage of publicly available and anonymized dating data. In the process,
    we'll learn about yet another type of recommender system, called model-based (as
    a side note, all of the algorithms that were discussed in this chapter were memory-based,
    but don't worry—I'll explain everything in a minute).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使用现有的 Julia 库构建一个更强大的推荐系统。我们将为约会网站生成推荐，利用公开可用的匿名约会数据。在这个过程中，我们将了解另一种类型的推荐系统，称为基于模型（顺便提一下，本章讨论的所有算法都是基于内存的，但不用担心——我马上会解释一切）。
