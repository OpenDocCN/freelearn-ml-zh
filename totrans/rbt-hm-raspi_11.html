<html><head></head><body>
<div id="_idContainer184">
<h1 class="chapter-number" id="_idParaDest-232"><a id="_idTextAnchor233"/><span class="koboSpan" id="kobo.1.1">11</span></h1>
<h1 id="_idParaDest-233"><a id="_idTextAnchor234"/><span class="koboSpan" id="kobo.2.1">Controlling Motion with Encoders on Raspberry Pi Pico</span></h1>
<p><span class="koboSpan" id="kobo.3.1">So far in this book, we’ve added sensors to our robot that can track counts as its wheels turn. </span><span class="koboSpan" id="kobo.3.2">We’ve also looked at a PID algorithm to close the robot control loop. </span><span class="koboSpan" id="kobo.3.3">We can combine these concepts to control our motors and wheels more precisely. </span></p>
<p><span class="koboSpan" id="kobo.4.1">This combination will let us maintain a known speed on each motor and correct their relative speeds for a straight line. </span><span class="koboSpan" id="kobo.4.2">Encoders with some geometry will let us drive the robot a predetermined distance. </span></p>
<p><span class="koboSpan" id="kobo.5.1">In this chapter, we will cover the following </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">main topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.7.1">Converting an encoder count into </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">a speed</span></span></li>
<li><span class="koboSpan" id="kobo.9.1">Using PID to maintain speed and a </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">straight line</span></span></li>
<li><span class="koboSpan" id="kobo.11.1">Driving a </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">known distance</span></span></li>
</ul>
<h1 id="_idParaDest-234"><a id="_idTextAnchor235"/><span class="koboSpan" id="kobo.13.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.14.1">For this chapter, you will require </span><span class="No-Break"><span class="koboSpan" id="kobo.15.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.16.1">The robot from </span><a href="B18001_10.xhtml#_idTextAnchor210"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.17.1">Chapter 10</span></em></span></a><span class="koboSpan" id="kobo.18.1">, </span><em class="italic"><span class="koboSpan" id="kobo.19.1">Using the PID Algorithm to </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.20.1">Follow Walls</span></em></span></li>
<li><span class="koboSpan" id="kobo.21.1">The robot, encoder, and PID code from </span><a href="B18001_10.xhtml#_idTextAnchor210"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.22.1">Chapter 10</span></em></span></a></li>
<li><span class="koboSpan" id="kobo.23.1">Around 2 square meters of floor to test the </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">robot on</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.25.1">Digital calipers</span></span></li>
<li><span class="koboSpan" id="kobo.26.1">A PC or laptop with </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">Python 3</span></span></li>
<li><span class="koboSpan" id="kobo.28.1">An Android/iOS smartphone with </span><span class="No-Break"><span class="koboSpan" id="kobo.29.1">Bluetooth LE</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.30.1">You can find the code for this chapter </span><span class="No-Break"><span class="koboSpan" id="kobo.31.1">at </span></span><a href="https://github.com/PacktPublishing/Robotics-at-Home-with-Raspberry-Pi-Pico/tree/main/ch-11"><span class="No-Break"><span class="koboSpan" id="kobo.32.1">https://github.com/PacktPublishing/Robotics-at-Home-with-Raspberry-Pi-Pico/tree/main/ch-11</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.33.1">.</span></span></p>
<h1 id="_idParaDest-235"><a id="_idTextAnchor236"/><span class="koboSpan" id="kobo.34.1">Converting an encoder count into a speed</span></h1>
<p><span class="koboSpan" id="kobo.35.1">In </span><a href="B18001_06.xhtml#_idTextAnchor115"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.36.1">Chapter 6</span></em></span></a><span class="koboSpan" id="kobo.37.1">, </span><em class="italic"><span class="koboSpan" id="kobo.38.1">Measuring Movement with Encoders on Raspberry Pi Pico</span></em><span class="koboSpan" id="kobo.39.1">, we used PIO to retrieve </span><a id="_idIndexMarker625"/><span class="koboSpan" id="kobo.40.1">a count from the motor encoding sensors. </span><span class="koboSpan" id="kobo.40.2">We ended that chapter by measuring for movement and counting encoder transitions over some time. </span></p>
<p><span class="koboSpan" id="kobo.41.1">In this section, we will relate wheel geometry to the encoder. </span><span class="koboSpan" id="kobo.41.2">Then, we will use that to convert encoder counts into a speed or </span><span class="No-Break"><span class="koboSpan" id="kobo.42.1">a distance.</span></span></p>
<h2 id="_idParaDest-236"><a id="_idTextAnchor237"/><span class="koboSpan" id="kobo.43.1">Loose bolts and nuts</span></h2>
<p><span class="koboSpan" id="kobo.44.1">Vibration can </span><a id="_idIndexMarker626"/><span class="koboSpan" id="kobo.45.1">sometimes cause nuts to drop out – a tiny dab of nail varnish across the nut and thread can </span><span class="No-Break"><span class="koboSpan" id="kobo.46.1">reduce this.</span></span></p>
<h2 id="_idParaDest-237"><a id="_idTextAnchor238"/><span class="koboSpan" id="kobo.47.1">Robot wheel geometry</span></h2>
<p><span class="koboSpan" id="kobo.48.1">Calculating the </span><a id="_idIndexMarker627"/><span class="koboSpan" id="kobo.49.1">distance traveled by a wheel requires its circumference. </span><span class="koboSpan" id="kobo.49.2">Let’s start by measuring the diameter of the wheel, </span><span class="No-Break"><span class="koboSpan" id="kobo.50.1">as shown:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer175">
<span class="koboSpan" id="kobo.51.1"><img alt="Figure 11.1 – Measuring wheels with calipers " src="image/Figure_11.1_B18001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.52.1">Figure 11.1 – Measuring wheels with calipers</span></p>
<p><span class="koboSpan" id="kobo.53.1">The preceding </span><a id="_idIndexMarker628"/><span class="koboSpan" id="kobo.54.1">diagram shows how you can measure wheel diameter with digital calipers. </span><span class="koboSpan" id="kobo.54.2">The diameter can be used in our code directly. </span><span class="koboSpan" id="kobo.54.3">In </span><strong class="source-inline"><span class="koboSpan" id="kobo.55.1">robot.py</span></strong><span class="koboSpan" id="kobo.56.1">, add your measurement rounded to the nearest </span><span class="No-Break"><span class="koboSpan" id="kobo.57.1">0.1 mm:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.58.1">
import math
wheel_diameter_mm = 70
wheel_circumference_mm = math.pi * wheel_diameter_mm</span></pre>
<p><span class="koboSpan" id="kobo.59.1">The preceding code calculates the circumference from the diameter. </span><span class="koboSpan" id="kobo.59.2">Each time a wheel makes a complete turn, it will move the wheel circumference in that direction, so we can already convert between wheel revolutions and distance. </span><span class="koboSpan" id="kobo.59.3">Next, we need the </span><span class="No-Break"><span class="koboSpan" id="kobo.60.1">encoder details.</span></span></p>
<h2 id="_idParaDest-238"><a id="_idTextAnchor239"/><span class="koboSpan" id="kobo.61.1">Encoder geometry</span></h2>
<p><span class="koboSpan" id="kobo.62.1">In </span><a href="B18001_06.xhtml#_idTextAnchor115"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.63.1">Chapter 6</span></em></span></a><span class="koboSpan" id="kobo.64.1">, </span><em class="italic"><span class="koboSpan" id="kobo.65.1">Measuring Movement with Encoders on Raspberry Pi Pico</span></em><span class="koboSpan" id="kobo.66.1">, we found the </span><a id="_idIndexMarker629"/><span class="koboSpan" id="kobo.67.1">number of poles on the encoder and the number of encoder revolutions per revolution. </span><span class="koboSpan" id="kobo.67.2">The N20 built-in magnetic encoders produce 28 edges or state changes for each encoder disk revolution. </span><span class="koboSpan" id="kobo.67.3">We then multiply this by the gear </span><span class="No-Break"><span class="koboSpan" id="kobo.68.1">ratio 298:1.</span></span></p>
<p><span class="koboSpan" id="kobo.69.1">We can add these calculations (use your motor gear ratio) to </span><strong class="source-inline"><span class="koboSpan" id="kobo.70.1">robot.py</span></strong><span class="koboSpan" id="kobo.71.1">: </span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.72.1">
gear_ratio = 298
encoder_poles = 28
ticks_per_revolution = encoder_poles * gear_ratio
ticks_to_m = (wheel_circumference_mm / ticks_per_revolution) / 1000</span></pre>
<p><span class="koboSpan" id="kobo.73.1">We use </span><a id="_idIndexMarker630"/><span class="koboSpan" id="kobo.74.1">m and m/s since this puts distances and speeds in the same order as the </span><span class="No-Break"><span class="koboSpan" id="kobo.75.1">motor speeds.</span></span></p>
<p><span class="koboSpan" id="kobo.76.1">Now, we can use these geometry measurements to get </span><span class="No-Break"><span class="koboSpan" id="kobo.77.1">a speed.</span></span></p>
<h2 id="_idParaDest-239"><a id="_idTextAnchor240"/><span class="koboSpan" id="kobo.78.1">Measuring the speed of each wheel</span></h2>
<p><span class="koboSpan" id="kobo.79.1">We will </span><a id="_idIndexMarker631"/><span class="koboSpan" id="kobo.80.1">calculate the speed of each wheel using the speed triangle </span><span class="No-Break"><span class="koboSpan" id="kobo.81.1">from physics:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer176">
<span class="koboSpan" id="kobo.82.1"><img alt="Figure 11.2 – The speed triangle " src="image/Figure_11.2_B18001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.83.1">Figure 11.2 – The speed triangle</span></p>
<p><span class="koboSpan" id="kobo.84.1">The triangle in the preceding diagram shows distance over speed and time. </span><span class="koboSpan" id="kobo.84.2">We want speed, so we get distance over time by covering speed. </span><span class="koboSpan" id="kobo.84.3">We can also see m/s. </span><span class="koboSpan" id="kobo.84.4">In our code, we’ll need to convert the difference in encoder ticks into a distance in m, then divide that by the time the difference covers: </span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.85.1">
speed = robot.ticks_to_m * (new_position – last_position) / time</span></pre>
<p><span class="koboSpan" id="kobo.86.1">We can use this calculation in an app to demonstrate </span><span class="No-Break"><span class="koboSpan" id="kobo.87.1">the principle.</span></span></p>
<h3><span class="koboSpan" id="kobo.88.1">Planning a speed-measurement app</span></h3>
<p><span class="koboSpan" id="kobo.89.1">We can build an app to demonstrate this and try different speeds. </span><span class="koboSpan" id="kobo.89.2">Using a UART command </span><a id="_idIndexMarker632"/><span class="koboSpan" id="kobo.90.1">system will make </span><span class="No-Break"><span class="koboSpan" id="kobo.91.1">it interactive.</span></span></p>
<p><span class="koboSpan" id="kobo.92.1">We’ll build the app using </span><strong class="source-inline"><span class="koboSpan" id="kobo.93.1">asyncio</span></strong><span class="koboSpan" id="kobo.94.1"> – asynchronous input/output. </span><strong class="source-inline"><span class="koboSpan" id="kobo.95.1">asyncio</span></strong><span class="koboSpan" id="kobo.96.1"> lets us run a few tasks simultaneously on the robot. </span><span class="koboSpan" id="kobo.96.2">Most tasks sleep between events, and CircuitPython can run another task during that time. </span><span class="koboSpan" id="kobo.96.3">The app must perform the </span><span class="No-Break"><span class="koboSpan" id="kobo.97.1">following tasks:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.98.1">Measure the encoders, convert them into a speed value, and send this value to </span><span class="No-Break"><span class="koboSpan" id="kobo.99.1">the UART.</span></span></li>
<li><span class="koboSpan" id="kobo.100.1">Accept the control commands to change settings or drive for </span><span class="No-Break"><span class="koboSpan" id="kobo.101.1">a while.</span></span></li>
<li><span class="koboSpan" id="kobo.102.1">Stop the robot after a </span><span class="No-Break"><span class="koboSpan" id="kobo.103.1">specific time.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.104.1">The command handlers we’ll want for this robot are </span><span class="No-Break"><span class="koboSpan" id="kobo.105.1">as follows:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.106.1">M0.7</span></strong><span class="koboSpan" id="kobo.107.1">: Set the motors speed </span><span class="No-Break"><span class="koboSpan" id="kobo.108.1">to 0.7</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.109.1">T0.3</span></strong><span class="koboSpan" id="kobo.110.1">: Change the measuring time interval </span><span class="No-Break"><span class="koboSpan" id="kobo.111.1">to 0.3</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.112.1">G3.0</span></strong><span class="koboSpan" id="kobo.113.1">: Go (start moving) for 3 seconds, </span><span class="No-Break"><span class="koboSpan" id="kobo.114.1">then stop</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.115.1">G</span></strong><span class="koboSpan" id="kobo.116.1">: Stop the robot from </span><span class="No-Break"><span class="koboSpan" id="kobo.117.1">moving immediately</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.118.1">With the design created, let’s build </span><span class="No-Break"><span class="koboSpan" id="kobo.119.1">the app.</span></span></p>
<h3><span class="koboSpan" id="kobo.120.1">Speed measurement app</span></h3>
<p><span class="koboSpan" id="kobo.121.1">We will use </span><a id="_idIndexMarker633"/><span class="koboSpan" id="kobo.122.1">the Adafruit </span><strong class="bold"><span class="koboSpan" id="kobo.123.1">circup</span></strong><span class="koboSpan" id="kobo.124.1"> tool to install libraries on Pico. </span><span class="koboSpan" id="kobo.124.2">circup can </span><a id="_idIndexMarker634"/><span class="koboSpan" id="kobo.125.1">install and update libraries on CircuitPython </span><a id="_idIndexMarker635"/><span class="koboSpan" id="kobo.126.1">devices, handling dependencies. </span><span class="koboSpan" id="kobo.126.2">See </span><a href="https://learn.adafruit.com/keep-your-circuitpython-libraries-on-devices-up-to-date-with-circup"><span class="koboSpan" id="kobo.127.1">https://learn.adafruit.com/keep-your-circuitpython-libraries-on-devices-up-to-date-with-circup</span></a><span class="koboSpan" id="kobo.128.1"> for details. </span><span class="koboSpan" id="kobo.128.2">Install the </span><strong class="source-inline"><span class="koboSpan" id="kobo.129.1">asyncio</span></strong><span class="koboSpan" id="kobo.130.1"> library with the </span><span class="No-Break"><span class="koboSpan" id="kobo.131.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.132.1">
circup install asyncio</span></pre>
<p><span class="koboSpan" id="kobo.133.1">First, we’ll move the UART into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.134.1">robot.py</span></strong><span class="koboSpan" id="kobo.135.1"> file. </span><span class="koboSpan" id="kobo.135.2">At the imports, add </span><span class="No-Break"><span class="koboSpan" id="kobo.136.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.137.1">
import busio
uart = busio.UART(board.GP12, board.GP13, baudrate=9600)</span></pre>
<p><span class="koboSpan" id="kobo.138.1">With that, the UART has been set up for any further examples. </span><span class="koboSpan" id="kobo.138.2">We will also add a convenience function at the end </span><span class="No-Break"><span class="koboSpan" id="kobo.139.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.140.1">robot.py</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.141.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.142.1">
def send_line(message):
    uart.write(f"{message}\n".encode())</span></pre>
<p><span class="koboSpan" id="kobo.143.1">This wraps </span><a id="_idIndexMarker636"/><span class="koboSpan" id="kobo.144.1">the usual interaction of adding a new line and encoding a message into bytes on </span><span class="No-Break"><span class="koboSpan" id="kobo.145.1">the UART.</span></span></p>
<p><span class="koboSpan" id="kobo.146.1">In a new folder, </span><strong class="source-inline"><span class="koboSpan" id="kobo.147.1">measuring_wheel_speeds</span></strong><span class="koboSpan" id="kobo.148.1">, make a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.149.1">code.py</span></strong><span class="koboSpan" id="kobo.150.1"> file starting with the </span><span class="No-Break"><span class="koboSpan" id="kobo.151.1">following imports:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.152.1">
import asyncio
import robot</span></pre>
<p><span class="koboSpan" id="kobo.153.1">These imports are familiar; however, instead of </span><strong class="source-inline"><span class="koboSpan" id="kobo.154.1">time</span></strong><span class="koboSpan" id="kobo.155.1">, we are importing </span><strong class="source-inline"><span class="koboSpan" id="kobo.156.1">asyncio</span></strong><span class="koboSpan" id="kobo.157.1">. </span></p>
<p><span class="koboSpan" id="kobo.158.1">We can create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.159.1">Settings</span></strong><span class="koboSpan" id="kobo.160.1"> class to store the current settings, </span><span class="No-Break"><span class="koboSpan" id="kobo.161.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.162.1">
class Settings:
  speed = 0.7
  time_interval = 0.2</span></pre>
<p><span class="koboSpan" id="kobo.163.1">This groups the settings; different tasks can access them. </span><strong class="source-inline"><span class="koboSpan" id="kobo.164.1">speed</span></strong><span class="koboSpan" id="kobo.165.1"> is the motor speed, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.166.1">time_interval</span></strong><span class="koboSpan" id="kobo.167.1"> is how frequently the code will read </span><span class="No-Break"><span class="koboSpan" id="kobo.168.1">the encoders.</span></span></p>
<p><span class="koboSpan" id="kobo.169.1">Let’s learn how to handle </span><span class="No-Break"><span class="koboSpan" id="kobo.170.1">the encoders:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.171.1">
async def motor_speed_loop():
  left_last, right_last = robot.left_encoder.read(), robot.right_encoder.read() </span></pre>
<p><span class="koboSpan" id="kobo.172.1">We use </span><strong class="source-inline"><span class="koboSpan" id="kobo.173.1">async def</span></strong><span class="koboSpan" id="kobo.174.1"> to turn the function into an async task. </span><span class="koboSpan" id="kobo.174.2">We are computing encoder differences, so we keep a last value. </span><span class="koboSpan" id="kobo.174.3">We start this with the current </span><span class="No-Break"><span class="koboSpan" id="kobo.175.1">encoder reading.</span></span></p>
<p><span class="koboSpan" id="kobo.176.1">Next, we go into the sensor reading loop, which uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.177.1">sleep</span></strong><span class="koboSpan" id="kobo.178.1"> to keep that </span><span class="No-Break"><span class="koboSpan" id="kobo.179.1">time interval:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.180.1">
  while True:
    await asyncio.sleep(Settings.time_interval)</span></pre>
<p><span class="koboSpan" id="kobo.181.1">This code performs an asynchronous sleep, allowing other tasks to run. </span><span class="koboSpan" id="kobo.181.2">We must read both sensors again, getting </span><span class="No-Break"><span class="koboSpan" id="kobo.182.1">new values:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.183.1">
    left_new, right_new = robot.left_encoder.read(), robot.right_encoder.read()
    left_speed = robot.ticks_to_m * (left_new - left_last) / Settings.time_interval
    left_last = left_new</span></pre>
<p><span class="koboSpan" id="kobo.184.1">We get the </span><a id="_idIndexMarker637"/><span class="koboSpan" id="kobo.185.1">speed by subtracting the last value from the new one. </span><span class="koboSpan" id="kobo.185.2">Then, we convert that into meters and divide it by the time interval to get a speed in meters </span><span class="No-Break"><span class="koboSpan" id="kobo.186.1">per second.</span></span></p>
<p><span class="koboSpan" id="kobo.187.1">We must also remember to update the last value. </span><span class="koboSpan" id="kobo.187.2">We can repeat this for the </span><span class="No-Break"><span class="koboSpan" id="kobo.188.1">right sensor:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.189.1">
    right_speed = robot.ticks_to_m * (right_new - right_last) / Settings.time_interval
    right_last = right_new</span></pre>
<p><span class="koboSpan" id="kobo.190.1">We can finish the motor speed loop by printing the speeds to </span><span class="No-Break"><span class="koboSpan" id="kobo.191.1">the UART:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.192.1">
    robot.send_line(f"{left_speed:.2f},{right_speed:.2f},0")</span></pre>
<p><span class="koboSpan" id="kobo.193.1">Notice </span><strong class="source-inline"><span class="koboSpan" id="kobo.194.1">,0</span></strong><span class="koboSpan" id="kobo.195.1"> at the end of the UART output. </span><span class="koboSpan" id="kobo.195.2">We must add this to anchor the graph at 0 so that the plot shows the speed relative </span><span class="No-Break"><span class="koboSpan" id="kobo.196.1">to zero.</span></span></p>
<p><span class="koboSpan" id="kobo.197.1">The next component we’ll need is the motor </span><span class="No-Break"><span class="koboSpan" id="kobo.198.1">stop task:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.199.1">
async def stop_motors_after(seconds):
  await asyncio.sleep(seconds)
  robot.stop()</span></pre>
<p><span class="koboSpan" id="kobo.200.1">This task will simply wait the given seconds and stop the </span><span class="No-Break"><span class="koboSpan" id="kobo.201.1">robot’s motors.</span></span></p>
<p><span class="koboSpan" id="kobo.202.1">We will also need a UART command handler in an </span><span class="No-Break"><span class="koboSpan" id="kobo.203.1">async task:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.204.1">
async def command_handler():
  while True:
    if robot.uart.in_waiting:
      command = robot.uart.readline().decode().strip()
      if command.startswith("M"):
        Settings.speed = float(command[1:])
      elif command.startswith("T"):
        Settings.time_interval = float(command[1:])
      elif command == "G":
        robot.stop()
      elif command.startswith("G"):
        await asyncio.sleep(5)
        robot.set_left(Settings.speed)
        robot.set_right(Settings.speed)
        asyncio.create_task(
          stop_motors_after(float(command[1:]))
        )</span></pre>
<p><span class="koboSpan" id="kobo.205.1">Sending </span><strong class="source-inline"><span class="koboSpan" id="kobo.206.1">G3.0</span></strong><span class="koboSpan" id="kobo.207.1"> instructs the robot to wait 5 seconds, drive, and stop after 3 seconds. </span><span class="koboSpan" id="kobo.207.2">This 5-second wait allows the user to start the plot tab before the robot </span><span class="No-Break"><span class="koboSpan" id="kobo.208.1">starts moving.</span></span></p>
<p><span class="koboSpan" id="kobo.209.1">The sleep </span><a id="_idIndexMarker638"/><span class="koboSpan" id="kobo.210.1">commands now use </span><strong class="source-inline"><span class="koboSpan" id="kobo.211.1">asyncio.sleep</span></strong><span class="koboSpan" id="kobo.212.1">. </span><span class="koboSpan" id="kobo.212.2">We also use </span><strong class="source-inline"><span class="koboSpan" id="kobo.213.1">asyncio.sleep(0)</span></strong><span class="koboSpan" id="kobo.214.1"> to let other tasks run while waiting for </span><span class="No-Break"><span class="koboSpan" id="kobo.215.1">UART input.</span></span></p>
<p><span class="koboSpan" id="kobo.216.1">Finally, we start the motor speed loop and the command handler, </span><span class="No-Break"><span class="koboSpan" id="kobo.217.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.218.1">
asyncio.create_task(motor_speed_loop())
asyncio.run(command_handler())</span></pre>
<p class="callout-heading"><span class="koboSpan" id="kobo.219.1">Is this multithreaded?</span></p>
<p class="callout"><span class="koboSpan" id="kobo.220.1">Async code is not multithreaded. </span><span class="koboSpan" id="kobo.220.2">Instead, when an </span><strong class="source-inline"><span class="koboSpan" id="kobo.221.1">asyncio.sleep</span></strong><span class="koboSpan" id="kobo.222.1"> is used, control is passed to another async block waiting to run. </span><span class="koboSpan" id="kobo.222.2">As a result, async code tasks do not access </span><span class="No-Break"><span class="koboSpan" id="kobo.223.1">variables simultaneously.</span></span></p>
<p><span class="koboSpan" id="kobo.224.1">Send this </span><a id="_idIndexMarker639"/><span class="koboSpan" id="kobo.225.1">all to the robot. </span><span class="koboSpan" id="kobo.225.2">Now, let’s see how this works and </span><span class="No-Break"><span class="koboSpan" id="kobo.226.1">test it.</span></span></p>
<h3><span class="koboSpan" id="kobo.227.1">Testing the speed measurement app</span></h3>
<p><span class="koboSpan" id="kobo.228.1">I recommend </span><a id="_idIndexMarker640"/><span class="koboSpan" id="kobo.229.1">propping the robot on a box for the first test so that its wheels aren’t in contact </span><span class="No-Break"><span class="koboSpan" id="kobo.230.1">with anything.</span></span></p>
<p><span class="koboSpan" id="kobo.231.1">Connect to the robot with the Bluefruit LE Connect app and use the UART menu item. </span><span class="koboSpan" id="kobo.231.2">You should see zeros. </span><span class="koboSpan" id="kobo.231.3">Send </span><strong class="source-inline"><span class="koboSpan" id="kobo.232.1">G20</span></strong><span class="koboSpan" id="kobo.233.1">, which should start the motors moving, and then press the back button and select the plot mode. </span><span class="koboSpan" id="kobo.233.2">You will see a graph like </span><span class="No-Break"><span class="koboSpan" id="kobo.234.1">the following:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer177">
<span class="koboSpan" id="kobo.235.1"><img alt="Figure 11.3 – Encoder speed with glitches " src="image/Figure_11.3_B18001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.236.1">Figure 11.3 – Encoder speed with glitches</span></p>
<p><span class="koboSpan" id="kobo.237.1">The preceding plot shows speed versus time from our robot. </span><span class="koboSpan" id="kobo.237.2">The </span><em class="italic"><span class="koboSpan" id="kobo.238.1">y</span></em><span class="koboSpan" id="kobo.239.1"> axis is the speed, while the </span><em class="italic"><span class="koboSpan" id="kobo.240.1">x</span></em><span class="koboSpan" id="kobo.241.1"> axis is the time in seconds. </span><span class="koboSpan" id="kobo.241.2">There is a clear 0 line. </span><span class="koboSpan" id="kobo.241.3">The graph then shows the two motor speeds. </span><span class="koboSpan" id="kobo.241.4">There are glitches – the speed drops to zero and </span><span class="No-Break"><span class="koboSpan" id="kobo.242.1">then doubles.</span></span></p>
<h2 id="_idParaDest-240"><a id="_idTextAnchor241"/><span class="koboSpan" id="kobo.243.1">Fixing the encoder glitches</span></h2>
<p><span class="koboSpan" id="kobo.244.1">These glitches are due to an interaction between our read loop and the encoders. </span><span class="koboSpan" id="kobo.244.2">Plotting on a UART makes 0.2 s (5 times per second) a good time base. </span><span class="koboSpan" id="kobo.244.3">However, our PIO outputs encoder </span><a id="_idIndexMarker641"/><span class="koboSpan" id="kobo.245.1">counts as often as they change. </span><span class="koboSpan" id="kobo.245.2">The PIO outputs these counts to an RX FIFO queue – see </span><a href="B18001_06.xhtml#_idTextAnchor115"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.246.1">Chapter 6</span></em></span></a><span class="koboSpan" id="kobo.247.1">, </span><em class="italic"><span class="koboSpan" id="kobo.248.1">Measuring Movement with Encoders on Raspberry </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.249.1">Pi Pico</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.250.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.251.1">The PIO </span><strong class="source-inline"><span class="koboSpan" id="kobo.252.1">push nowait</span></strong><span class="koboSpan" id="kobo.253.1"> instruction will write no more data when the FIFO queue is full, but the encoder code continues counting pulses. </span><span class="koboSpan" id="kobo.253.2">We can use another </span><strong class="source-inline"><span class="koboSpan" id="kobo.254.1">asyncio</span></strong><span class="koboSpan" id="kobo.255.1"> task to read data more frequently from the FIFO queue. </span><span class="koboSpan" id="kobo.255.2">In the imports at the top of </span><strong class="source-inline"><span class="koboSpan" id="kobo.256.1">pio_encoder.py</span></strong><span class="koboSpan" id="kobo.257.1">, add </span><span class="No-Break"><span class="koboSpan" id="kobo.258.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.259.1">
import asyncio</span></pre>
<p><span class="koboSpan" id="kobo.260.1">Add the following method somewhere </span><span class="No-Break"><span class="koboSpan" id="kobo.261.1">under </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.262.1">QuadratureEncoder</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.263.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.264.1">
    async def poll_loop(self):
        while True:
            await asyncio.sleep(0)
            while self.sm.in_waiting:
                self.sm.readinto(self._buffer)</span></pre>
<p><span class="koboSpan" id="kobo.265.1">Once started, this will continuously read the data into the buffer as frequently </span><span class="No-Break"><span class="koboSpan" id="kobo.266.1">as possible.</span></span></p>
<p><span class="koboSpan" id="kobo.267.1">Now, we must modify the </span><strong class="source-inline"><span class="koboSpan" id="kobo.268.1">QuadratureEncoder.__init__</span></strong><span class="koboSpan" id="kobo.269.1"> method to create a task for this. </span><span class="koboSpan" id="kobo.269.2">Add the highlighted line </span><span class="No-Break"><span class="koboSpan" id="kobo.270.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.271.1">
        self._buffer = array.array("i", [0])
</span><strong class="bold"><span class="koboSpan" id="kobo.272.1">        asyncio.create_task(self.poll_loop())</span></strong></pre>
<p><span class="koboSpan" id="kobo.273.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.274.1">read</span></strong><span class="koboSpan" id="kobo.275.1"> method can then return the most recent item from </span><span class="No-Break"><span class="koboSpan" id="kobo.276.1">the buffer:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.277.1">
    def read(self):
        if self.reversed:
            return -self._buffer[0]
        else:
            return self._buffer[0]</span></pre>
<p><span class="koboSpan" id="kobo.278.1">We can now use this encoder code in our </span><span class="No-Break"><span class="koboSpan" id="kobo.279.1">async code.</span></span></p>
<p><span class="koboSpan" id="kobo.280.1">Reupload the </span><strong class="source-inline"><span class="koboSpan" id="kobo.281.1">pio_encoder.py</span></strong><span class="koboSpan" id="kobo.282.1"> file so that we can try again. </span><span class="koboSpan" id="kobo.282.2">Start the motors with </span><strong class="source-inline"><span class="koboSpan" id="kobo.283.1">G5</span></strong><span class="koboSpan" id="kobo.284.1"> and switch to the plot screen; you should see a plot </span><span class="No-Break"><span class="koboSpan" id="kobo.285.1">like this:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer178">
<span class="koboSpan" id="kobo.286.1"><img alt="Figure 11.4 – Speed measurement without the glitches " src="image/Figure_11.4_B18001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.287.1">Figure 11.4 – Speed measurement without the glitches</span></p>
<p><span class="koboSpan" id="kobo.288.1">The graph now shows the speed of both motors without the glitches. </span><span class="koboSpan" id="kobo.288.2">It is a bit noisy, and one line </span><a id="_idIndexMarker642"/><span class="koboSpan" id="kobo.289.1">is slightly higher than the other. </span><span class="koboSpan" id="kobo.289.2">One of the motors is also quicker. </span><span class="koboSpan" id="kobo.289.3">The robot is moving at around 0.2 m/s. </span><span class="koboSpan" id="kobo.289.4">Battery freshness will affect </span><span class="No-Break"><span class="koboSpan" id="kobo.290.1">the speed.</span></span></p>
<p><span class="koboSpan" id="kobo.291.1">If you are not seeing this, please check that the encoders are reporting correctly with the examples provided in </span><a href="B18001_06.xhtml#_idTextAnchor115"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.292.1">Chapter 6</span></em></span></a><span class="koboSpan" id="kobo.293.1">, </span><em class="italic"><span class="koboSpan" id="kobo.294.1">Measuring Movement with Encoders on Raspberry </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.295.1">Pi Pico</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.296.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.297.1">We can use this measurement to drive a known distance, but it’s now clear that the robot won’t drive in a straight line like this. </span><span class="koboSpan" id="kobo.297.2">So, in the next section, we’ll correct the differences between </span><span class="No-Break"><span class="koboSpan" id="kobo.298.1">the motors.</span></span></p>
<h1 id="_idParaDest-241"><a id="_idTextAnchor242"/><span class="koboSpan" id="kobo.299.1">Using PID to maintain speed and a straight line</span></h1>
<p><span class="koboSpan" id="kobo.300.1">In this </span><a id="_idIndexMarker643"/><span class="koboSpan" id="kobo.301.1">section, we’ll learn how to combine the motor </span><a id="_idIndexMarker644"/><span class="koboSpan" id="kobo.302.1">distance measurement with a PID controller driving each motor, moving at a particular speed, and keeping the robot straight. </span><span class="koboSpan" id="kobo.302.2">Let’s start by understanding </span><span class="No-Break"><span class="koboSpan" id="kobo.303.1">this system.</span></span></p>
<h2 id="_idParaDest-242"><a id="_idTextAnchor243"/><span class="koboSpan" id="kobo.304.1">The speed control system</span></h2>
<p><span class="koboSpan" id="kobo.305.1">We can set a target speed in meters per second for the robot and compare the converted </span><a id="_idIndexMarker645"/><span class="koboSpan" id="kobo.306.1">wheel speeds with it. </span></p>
<p><span class="koboSpan" id="kobo.307.1">The following diagram shows how we’ll use this to regulate the robot’s </span><span class="No-Break"><span class="koboSpan" id="kobo.308.1">driving speed:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer179">
<span class="koboSpan" id="kobo.309.1"><img alt="Figure 11.5 – Controlling the speed of two motors " src="image/Figure_11.5_B18001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.310.1">Figure 11.5 – Controlling the speed of two motors</span></p>
<p><span class="koboSpan" id="kobo.311.1">The preceding diagram shows the control system. </span><span class="koboSpan" id="kobo.311.2">It starts at the left from a set speed and compares that with the actual speed. </span><span class="koboSpan" id="kobo.311.3">The actual speed comes from the encoders, with their ticks converted into m/s. </span><span class="koboSpan" id="kobo.311.4">The error is the difference between </span><span class="No-Break"><span class="koboSpan" id="kobo.312.1">the speeds.</span></span></p>
<p><span class="koboSpan" id="kobo.313.1">The error goes into the PID controller, which then produces an acceleration for the motor PWM. </span><span class="koboSpan" id="kobo.313.2">The motor power will increase for a positive control signal or decrease for a negative one. </span><span class="koboSpan" id="kobo.313.3">This control system repeats for </span><span class="No-Break"><span class="koboSpan" id="kobo.314.1">each wheel.</span></span></p>
<p><span class="koboSpan" id="kobo.315.1">We are building on the motor start/stop with the timer control we used previously. </span><span class="koboSpan" id="kobo.315.2">However, with a PID controller, this can cause the integral to wind up and accumulate errors. </span><span class="koboSpan" id="kobo.315.3">Let’s extend the </span><strong class="source-inline"><span class="koboSpan" id="kobo.316.1">PIDController</span></strong><span class="koboSpan" id="kobo.317.1"> class in </span><strong class="source-inline"><span class="koboSpan" id="kobo.318.1">pid_controller.py</span></strong><span class="koboSpan" id="kobo.319.1"> so that we can reset this. </span><span class="koboSpan" id="kobo.319.2">Make the </span><span class="No-Break"><span class="koboSpan" id="kobo.320.1">highlighted change:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.321.1">
class PIDController:
    def __init__(self, kp, ki, kd, d_filter_gain=0.1):
        self.kp = kp
        self.ki = ki
        self.kd = kd
        self.d_filter_gain = d_filter_gain
</span><strong class="bold"><span class="koboSpan" id="kobo.322.1">        self.reset()</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.323.1">    def reset(self):</span></strong><span class="koboSpan" id="kobo.324.1">
        self.integral = 0
        self.error_prev = 0
        self.derivative = 0</span></pre>
<p><span class="koboSpan" id="kobo.325.1">We’ve </span><a id="_idIndexMarker646"/><span class="koboSpan" id="kobo.326.1">moved the initial value settings out to a </span><strong class="source-inline"><span class="koboSpan" id="kobo.327.1">reset</span></strong><span class="koboSpan" id="kobo.328.1"> method, which we now use in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.329.1">__init__</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.330.1"> method.</span></span></p>
<p><span class="koboSpan" id="kobo.331.1">Now that we understand this concept, we can build </span><span class="No-Break"><span class="koboSpan" id="kobo.332.1">the code.</span></span></p>
<h2 id="_idParaDest-243"><a id="_idTextAnchor244"/><span class="koboSpan" id="kobo.333.1">Speed control code</span></h2>
<p><span class="koboSpan" id="kobo.334.1">Let’s build </span><a id="_idIndexMarker647"/><span class="koboSpan" id="kobo.335.1">our speed controller code. </span><span class="koboSpan" id="kobo.335.2">In a new folder, </span><strong class="source-inline"><span class="koboSpan" id="kobo.336.1">speed_control</span></strong><span class="koboSpan" id="kobo.337.1">, add a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.338.1">code.py</span></strong><span class="koboSpan" id="kobo.339.1"> file. </span><span class="koboSpan" id="kobo.339.2">We will start with the </span><span class="No-Break"><span class="koboSpan" id="kobo.340.1">regular imports:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.341.1">
import asyncio
import time
import robot
import pid_controller</span></pre>
<p><span class="koboSpan" id="kobo.342.1">We’ll add settings that we can adjust to control the system when the program </span><span class="No-Break"><span class="koboSpan" id="kobo.343.1">is running:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.344.1">
class Settings:
  speed = 0.17
  time_interval = 0.2
  motors_enabled = False</span></pre>
<p><span class="koboSpan" id="kobo.345.1">We have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.346.1">speed</span></strong><span class="koboSpan" id="kobo.347.1"> in m/s. </span><span class="koboSpan" id="kobo.347.2">This should be close to the speed you measured previously. </span><span class="koboSpan" id="kobo.347.3">We also added a </span><strong class="source-inline"><span class="koboSpan" id="kobo.348.1">time_interval</span></strong><span class="koboSpan" id="kobo.349.1"> for the loop and specified if the motors should currently </span><span class="No-Break"><span class="koboSpan" id="kobo.350.1">be driving.</span></span></p>
<p><span class="koboSpan" id="kobo.351.1">Next, we must </span><a id="_idIndexMarker648"/><span class="koboSpan" id="kobo.352.1">add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.353.1">SpeedController</span></strong><span class="koboSpan" id="kobo.354.1"> class, which we can use for each </span><span class="No-Break"><span class="koboSpan" id="kobo.355.1">wheel system:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.356.1">
class SpeedController:
  def __init__(self, encoder, motor_fn):
    self.encoder = encoder
    self.motor_fn = motor_fn
    self.pid = pid_controller.PIDController(3, 0, 1)
    self.reset()</span></pre>
<p><span class="koboSpan" id="kobo.357.1">We provide each </span><strong class="source-inline"><span class="koboSpan" id="kobo.358.1">SpeedController</span></strong><span class="koboSpan" id="kobo.359.1"> system with an encoder to read and a motor function (</span><strong class="source-inline"><span class="koboSpan" id="kobo.360.1">motor_fn</span></strong><span class="koboSpan" id="kobo.361.1">) to apply control signals. </span><span class="koboSpan" id="kobo.361.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.362.1">SpeedController</span></strong><span class="koboSpan" id="kobo.363.1"> creates a </span><strong class="source-inline"><span class="koboSpan" id="kobo.364.1">PIDController</span></strong><span class="koboSpan" id="kobo.365.1">. </span><span class="koboSpan" id="kobo.365.2">Each wheel will get an independent </span><strong class="source-inline"><span class="koboSpan" id="kobo.366.1">PIDController</span></strong><span class="koboSpan" id="kobo.367.1">. </span><span class="koboSpan" id="kobo.367.2">This then calls a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.368.1">reset</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.369.1"> function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.370.1">
  def reset(self):
    self.last_ticks = self.encoder.read()
    self.pwm = 0
    self.actual_speed = 0
    self.pid.reset()</span></pre>
<p><span class="koboSpan" id="kobo.371.1">This code puts the first read of the encoder into </span><strong class="source-inline"><span class="koboSpan" id="kobo.372.1">last_ticks</span></strong><span class="koboSpan" id="kobo.373.1">, which we’ll update when we get a reading. </span><strong class="source-inline"><span class="koboSpan" id="kobo.374.1">pwm</span></strong><span class="koboSpan" id="kobo.375.1"> is how much power we will give the motors. </span><span class="koboSpan" id="kobo.375.2">We track </span><strong class="source-inline"><span class="koboSpan" id="kobo.376.1">actual_speed</span></strong><span class="koboSpan" id="kobo.377.1"> so that we can print this value to the UART later. </span><span class="koboSpan" id="kobo.377.2">We also reset the PIDs so that any stored integral </span><span class="No-Break"><span class="koboSpan" id="kobo.378.1">is gone.</span></span></p>
<p><span class="koboSpan" id="kobo.379.1">Now, we need a method to update this </span><span class="No-Break"><span class="koboSpan" id="kobo.380.1">control system:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.381.1">
  def update(self, dt):
    current_ticks = self.encoder.read()
    speed_in_ticks = (current_ticks - self.last_ticks) / dt
    self.last_ticks = current_ticks
    self.actual_speed = robot.ticks_to_m * speed_in_ticks</span></pre>
<p><span class="koboSpan" id="kobo.382.1">This </span><strong class="source-inline"><span class="koboSpan" id="kobo.383.1">update</span></strong><span class="koboSpan" id="kobo.384.1"> method takes a delta time in seconds. </span><span class="koboSpan" id="kobo.384.2">While this might be close to </span><strong class="source-inline"><span class="koboSpan" id="kobo.385.1">time_interval</span></strong><span class="koboSpan" id="kobo.386.1">, we need to be accurate when calculating the speed or updating the PID. </span></p>
<p><span class="koboSpan" id="kobo.387.1">The method </span><a id="_idIndexMarker649"/><span class="koboSpan" id="kobo.388.1">reads the current encoder value and subtracts the previous encoder reading to get a distance in encoder ticks. </span><span class="koboSpan" id="kobo.388.2">To turn this into a speed, we must divide this by time. </span><span class="koboSpan" id="kobo.388.3">We must update </span><strong class="source-inline"><span class="koboSpan" id="kobo.389.1">self.last_ticks</span></strong><span class="koboSpan" id="kobo.390.1"> here for the next cycle. </span><span class="koboSpan" id="kobo.390.2">The speed is more useful to us in m/s, so we convert it using </span><strong class="source-inline"><span class="koboSpan" id="kobo.391.1">ticks_to_m</span></strong><span class="koboSpan" id="kobo.392.1">. </span></p>
<p><span class="koboSpan" id="kobo.393.1">We can now use this to update the PID and control </span><span class="No-Break"><span class="koboSpan" id="kobo.394.1">the motors:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.395.1">
    error = Settings.speed - self.actual_speed
    control_signal = self.pid.calculate(error, dt)
    self.pwm += control_signal
    self.motor_fn(self.pwm * Settings.motors_enabled)</span></pre>
<p><span class="koboSpan" id="kobo.396.1">We multiply the </span><strong class="source-inline"><span class="koboSpan" id="kobo.397.1">pwm</span></strong><span class="koboSpan" id="kobo.398.1"> output setting with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.399.1">enabled</span></strong><span class="koboSpan" id="kobo.400.1"> flag so that the motors will stop if the motors are disabled. </span><span class="koboSpan" id="kobo.400.2">We subtract the actual speed from this to get the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.401.1">error</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.402.1"> value.</span></span></p>
<p><span class="koboSpan" id="kobo.403.1">The code gets </span><strong class="source-inline"><span class="koboSpan" id="kobo.404.1">control_signal</span></strong><span class="koboSpan" id="kobo.405.1"> from the PID calculation with </span><strong class="source-inline"><span class="koboSpan" id="kobo.406.1">error</span></strong><span class="koboSpan" id="kobo.407.1"> and delta time. </span><span class="koboSpan" id="kobo.407.2">We then use this to accelerate/decelerate </span><strong class="source-inline"><span class="koboSpan" id="kobo.408.1">pwm</span></strong><span class="koboSpan" id="kobo.409.1">, which goes into the </span><span class="No-Break"><span class="koboSpan" id="kobo.410.1">motor function.</span></span></p>
<p><span class="koboSpan" id="kobo.411.1">We use this system to control </span><span class="No-Break"><span class="koboSpan" id="kobo.412.1">both motors:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.413.1">
left = SpeedController(robot.left_encoder, robot.set_left)
right = SpeedController(robot.right_encoder, robot.set_right)</span></pre>
<p><span class="koboSpan" id="kobo.414.1">Now, we need an async loop to drive </span><span class="No-Break"><span class="koboSpan" id="kobo.415.1">the system:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.416.1">
async def motor_speed_loop():
  last_time = time.monotonic()
  while True:
    await asyncio.sleep(Settings.time_interval)
    current_time = time.monotonic()
    dt = current_time - last_time
    last_time = current_time</span></pre>
<p><span class="koboSpan" id="kobo.417.1">So far, this loop </span><a id="_idIndexMarker650"/><span class="koboSpan" id="kobo.418.1">will sleep every interval and update the time, so we have an accurate delta time (</span><strong class="source-inline"><span class="koboSpan" id="kobo.419.1">dt</span></strong><span class="koboSpan" id="kobo.420.1">) value. </span><span class="koboSpan" id="kobo.420.2">We can use this to update </span><span class="No-Break"><span class="koboSpan" id="kobo.421.1">both sides:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.422.1">
    left.update(dt)
    right.update(dt)
    robot.send_line(f" {left.actual_speed:.2f},{Settings.speed * Settings.motors_enabled:.2f},0")</span></pre>
<p><span class="koboSpan" id="kobo.423.1">After updating both sides, we can send the expected speed versus the actual speed to be plotted </span><span class="No-Break"><span class="koboSpan" id="kobo.424.1">via UART.</span></span></p>
<p><span class="koboSpan" id="kobo.425.1">Next, we’ll add a modified </span><strong class="source-inline"><span class="koboSpan" id="kobo.426.1">stop_motors_after</span></strong><span class="koboSpan" id="kobo.427.1"> async function that updates the </span><strong class="source-inline"><span class="koboSpan" id="kobo.428.1">motors_enabled</span></strong><span class="koboSpan" id="kobo.429.1"> flag; it will not call the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.430.1">stop</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.431.1"> function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.432.1">
async def stop_motors_after(seconds):
  await asyncio.sleep(seconds)
  Settings.motors_enabled = False</span></pre>
<p><span class="koboSpan" id="kobo.433.1">We want to be able to interact with this. </span><span class="koboSpan" id="kobo.433.2">We’ll need the </span><strong class="source-inline"><span class="koboSpan" id="kobo.434.1">command_handler</span></strong><span class="koboSpan" id="kobo.435.1"> function from the speed measuring app with the </span><span class="No-Break"><span class="koboSpan" id="kobo.436.1">highlighted differences:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.437.1">
async def command_handler():
  while True:
    if robot.uart.in_waiting:
      command = robot.uart.readline().decode().strip()
      if command.startswith("M"):
        Settings.speed = float(command[1:])
      elif command.startswith("T"):
        Settings.time_interval = float(command[1:])
      elif command == "G":
</span><strong class="bold"><span class="koboSpan" id="kobo.438.1">        Settings.motors_enabled = False</span></strong><span class="koboSpan" id="kobo.439.1">
      elif command.startswith("G"):
        await asyncio.sleep(5)
asyncio.create_task(stop_motors_after(float(command[1:])))
</span><strong class="bold"><span class="koboSpan" id="kobo.440.1">        Settings.motors_enabled = True</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.441.1">        left.reset()</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.442.1">        right.reset()</span></strong><span class="koboSpan" id="kobo.443.1">
      elif command.startswith("?"):
        robot.send_line(f"M{Settings.speed:.1f}")
        robot.send_line(f"T{Settings.time_interval:.1f}")
        await asyncio.sleep(3)
    await asyncio.sleep(0)</span></pre>
<p><span class="koboSpan" id="kobo.444.1">When we send a </span><strong class="source-inline"><span class="koboSpan" id="kobo.445.1">G&lt;n&gt;</span></strong><span class="koboSpan" id="kobo.446.1"> command to start the robot moving, we reset left and right, resetting </span><a id="_idIndexMarker651"/><span class="koboSpan" id="kobo.447.1">both the previous encoder value and PID integrals. </span><span class="koboSpan" id="kobo.447.2">Otherwise, we may have an old encoder setting, and the integral may still hold a value from a </span><span class="No-Break"><span class="koboSpan" id="kobo.448.1">previous movement.</span></span></p>
<p><span class="koboSpan" id="kobo.449.1">All that is left is to start this </span><span class="No-Break"><span class="koboSpan" id="kobo.450.1">all up:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.451.1">
try:
  motors_task = asyncio.create_task(motor_speed_loop())
  asyncio.run(command_handler())
finally:
  motors_task.cancel()
  robot.stop()</span></pre>
<p><span class="koboSpan" id="kobo.452.1">This has </span><a id="_idIndexMarker652"/><span class="koboSpan" id="kobo.453.1">been wrapped in an additional </span><strong class="source-inline"><span class="koboSpan" id="kobo.454.1">try</span></strong><span class="koboSpan" id="kobo.455.1">/</span><strong class="source-inline"><span class="koboSpan" id="kobo.456.1">finally</span></strong><span class="koboSpan" id="kobo.457.1"> block that ensures the movement task is stopped and the robot is stopped if an </span><span class="No-Break"><span class="koboSpan" id="kobo.458.1">error occurs.</span></span></p>
<p><span class="koboSpan" id="kobo.459.1">This code is complete. </span><span class="koboSpan" id="kobo.459.2">Send it to the robot along with </span><strong class="source-inline"><span class="koboSpan" id="kobo.460.1">robot.py</span></strong><span class="koboSpan" id="kobo.461.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.462.1">pid_controller.py</span></strong><span class="koboSpan" id="kobo.463.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.464.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.465.1">pio_encoder.py</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.466.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.467.1">Ensure the motors are powered on and use the Bluefruit Connect app to send the </span><strong class="source-inline"><span class="koboSpan" id="kobo.468.1">G10</span></strong><span class="koboSpan" id="kobo.469.1"> sequence so that the robot starts moving. </span><span class="koboSpan" id="kobo.469.2">I propped the robot up so that its wheels could turn without moving it to initially test this code. </span><span class="koboSpan" id="kobo.469.3">This test also lets me keep it connected via USB to see any </span><span class="No-Break"><span class="koboSpan" id="kobo.470.1">code errors.</span></span></p>
<h2 id="_idParaDest-244"><a id="_idTextAnchor245"/><span class="koboSpan" id="kobo.471.1">Speed controller PID tuning</span></h2>
<p><span class="koboSpan" id="kobo.472.1">The PID values </span><a id="_idIndexMarker653"/><span class="koboSpan" id="kobo.473.1">are likely to need tuning here. </span><span class="koboSpan" id="kobo.473.2">The values that worked in my experiments were </span><strong class="source-inline"><span class="koboSpan" id="kobo.474.1">P</span></strong><span class="koboSpan" id="kobo.475.1">: 3, </span><strong class="source-inline"><span class="koboSpan" id="kobo.476.1">I</span></strong><span class="koboSpan" id="kobo.477.1">: 0, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.478.1">D</span></strong><span class="koboSpan" id="kobo.479.1">:1. </span><span class="koboSpan" id="kobo.479.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.480.1">P</span></strong><span class="koboSpan" id="kobo.481.1"> factor will continue accelerating so long as there’s a difference, with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.482.1">D</span></strong><span class="koboSpan" id="kobo.483.1"> value damping any </span><span class="No-Break"><span class="koboSpan" id="kobo.484.1">sudden changes.</span></span></p>
<p><span class="koboSpan" id="kobo.485.1">I was able to start with a low </span><strong class="source-inline"><span class="koboSpan" id="kobo.486.1">P</span></strong><span class="koboSpan" id="kobo.487.1"> value and, using the plot, adjust upward if the overshoot wasn’t too great. </span><span class="koboSpan" id="kobo.487.2">The following plots show how this </span><span class="No-Break"><span class="koboSpan" id="kobo.488.1">system responds:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer180">
<span class="koboSpan" id="kobo.489.1"><img alt="Figure 11.6 – Speed controller response plots " src="image/Figure_11.6_B18001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.490.1">Figure 11.6 – Speed controller response plots</span></p>
<p><span class="koboSpan" id="kobo.491.1">The preceding graphs show the speed controller system. </span><span class="koboSpan" id="kobo.491.2">There are two plots – one with the robot propped up so that its wheels have no load and another with the robot on the floor. </span><span class="koboSpan" id="kobo.491.3">The orange line shows the set point, which is raised to 0.15 m/s by the code. </span><span class="koboSpan" id="kobo.491.4">The blue line is the actual speed measured at one of the motors. </span><span class="koboSpan" id="kobo.491.5">The system is better tuned for running on </span><span class="No-Break"><span class="koboSpan" id="kobo.492.1">a floor.</span></span></p>
<p><span class="koboSpan" id="kobo.493.1">Increase the </span><strong class="source-inline"><span class="koboSpan" id="kobo.494.1">D</span></strong><span class="koboSpan" id="kobo.495.1"> term to damp the overshoot. </span><span class="koboSpan" id="kobo.495.2">Since we are controlling the acceleration of this system, a sustained value is not required for it to keep moving, so the </span><strong class="source-inline"><span class="koboSpan" id="kobo.496.1">I</span></strong><span class="koboSpan" id="kobo.497.1"> term can remain </span><span class="No-Break"><span class="koboSpan" id="kobo.498.1">at 0.</span></span></p>
<p><span class="koboSpan" id="kobo.499.1">There may be </span><a id="_idIndexMarker654"/><span class="koboSpan" id="kobo.500.1">other troubleshooting issues around motor and encoder connections that you can resolve by going back to the </span><span class="No-Break"><span class="koboSpan" id="kobo.501.1">previous examples.</span></span></p>
<p><span class="koboSpan" id="kobo.502.1">Now, you can control the speeds of two motors simultaneously and get a straight line while practicing PID tuning. </span><span class="koboSpan" id="kobo.502.2">We can now build on this to drive in a straight line for a known distance and an </span><span class="No-Break"><span class="koboSpan" id="kobo.503.1">expected speed.</span></span></p>
<h1 id="_idParaDest-245"><a id="_idTextAnchor246"/><span class="koboSpan" id="kobo.504.1">Driving a known distance</span></h1>
<p><span class="koboSpan" id="kobo.505.1">We’ll need to bring together some of the previous techniques for this. </span><span class="koboSpan" id="kobo.505.2">Then, we’ll build a variation </span><a id="_idIndexMarker655"/><span class="koboSpan" id="kobo.506.1">of the speed controller – a distance controller – so that we can update the distance and let the motor PIDs reach it. </span><span class="koboSpan" id="kobo.506.2">This app will use a similar structure, including control and asynchronous tasks, as in the </span><span class="No-Break"><span class="koboSpan" id="kobo.507.1">previous example.</span></span></p>
<h2 id="_idParaDest-246"><a id="_idTextAnchor247"/><span class="koboSpan" id="kobo.508.1">Theory of operation</span></h2>
<p><span class="koboSpan" id="kobo.509.1">The following </span><a id="_idIndexMarker656"/><span class="koboSpan" id="kobo.510.1">diagram shows the theory of operation for </span><span class="No-Break"><span class="koboSpan" id="kobo.511.1">this behavior:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer181">
<span class="koboSpan" id="kobo.512.1"><img alt="Figure 11.7 – Controlling distance and speed " src="image/Figure_11.7_B18001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.513.1">Figure 11.7 – Controlling distance and speed</span></p>
<p><span class="koboSpan" id="kobo.514.1">The preceding diagram shows an overview of this system. </span><span class="koboSpan" id="kobo.514.2">The distance tracker tracks distance over time at a given speed, and the distance controller directly controls the motors to try and match a distance. </span><span class="koboSpan" id="kobo.514.3">Note the feedback from the motor into the distance controller. </span><span class="koboSpan" id="kobo.514.4">We will have one of these </span><span class="No-Break"><span class="koboSpan" id="kobo.515.1">per motor.</span></span></p>
<p><span class="koboSpan" id="kobo.516.1">Let’s take a closer look at the </span><span class="No-Break"><span class="koboSpan" id="kobo.517.1">distance tracker:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer182">
<span class="koboSpan" id="kobo.518.1"><img alt="Figure 11.8 – The distance tracker " src="image/Figure_11.8_B18001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.519.1">Figure 11.8 – The distance tracker</span></p>
<p><span class="koboSpan" id="kobo.520.1">The left-hand side of the preceding diagram repeats the speed, time, and distance triangle. </span><span class="koboSpan" id="kobo.520.2">We have the distance and the speed; to get the time, we need to divide the distance by speed. </span><span class="koboSpan" id="kobo.520.3">The right-hand side shows this distance tracker system. </span></p>
<p><span class="koboSpan" id="kobo.521.1">The tracker </span><a id="_idIndexMarker657"/><span class="koboSpan" id="kobo.522.1">system must first convert the distance into </span><strong class="source-inline"><span class="koboSpan" id="kobo.523.1">total_time</span></strong><span class="koboSpan" id="kobo.524.1"> using distance over speed. </span><span class="koboSpan" id="kobo.524.2">We must also convert the distance in meters into </span><strong class="source-inline"><span class="koboSpan" id="kobo.525.1">total_distance_in_ticks</span></strong><span class="koboSpan" id="kobo.526.1">. </span><span class="koboSpan" id="kobo.526.2">These two values will remain constant until we set a new speed or distance. </span><span class="koboSpan" id="kobo.526.3">This lighter portion only needs to run when we update the speed or reset </span><span class="No-Break"><span class="koboSpan" id="kobo.527.1">the distance.</span></span></p>
<p><span class="koboSpan" id="kobo.528.1">If we wish to run the system many times, we need to keep track of the current position so that we aren’t counting from a position of 0 </span><span class="No-Break"><span class="koboSpan" id="kobo.529.1">each time.</span></span></p>
<p><span class="koboSpan" id="kobo.530.1">When the system runs, the gray portion will run in a loop, and it will be updating the </span><strong class="source-inline"><span class="koboSpan" id="kobo.531.1">elapsed_time</span></strong><span class="koboSpan" id="kobo.532.1"> since the system was last reset. </span><span class="koboSpan" id="kobo.532.2">Dividing </span><strong class="source-inline"><span class="koboSpan" id="kobo.533.1">elapsed_time</span></strong><span class="koboSpan" id="kobo.534.1"> by </span><strong class="source-inline"><span class="koboSpan" id="kobo.535.1">total_time</span></strong><span class="koboSpan" id="kobo.536.1"> gives us a proportion of </span><strong class="source-inline"><span class="koboSpan" id="kobo.537.1">time_proportion</span></strong><span class="koboSpan" id="kobo.538.1">, which will sweep between 0.0 and 1.0. </span><span class="koboSpan" id="kobo.538.2">We multiply this by </span><strong class="source-inline"><span class="koboSpan" id="kobo.539.1">total_distance_in_ticks</span></strong><span class="koboSpan" id="kobo.540.1"> to get </span><strong class="source-inline"><span class="koboSpan" id="kobo.541.1">expected_distance_in_ticks</span></strong><span class="koboSpan" id="kobo.542.1">, tracking the distance the robot should have moved in ticks at any time. </span><span class="koboSpan" id="kobo.542.2">Since this component is tracking time, it will also pass along a delta time (</span><strong class="source-inline"><span class="koboSpan" id="kobo.543.1">dt</span></strong><span class="koboSpan" id="kobo.544.1">) to the </span><span class="No-Break"><span class="koboSpan" id="kobo.545.1">next component.</span></span></p>
<p><span class="koboSpan" id="kobo.546.1">The next component is the distance controller. </span><span class="koboSpan" id="kobo.546.2">Let’s take a closer look </span><span class="No-Break"><span class="koboSpan" id="kobo.547.1">at this:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer183">
<span class="koboSpan" id="kobo.548.1"><img alt="Figure 11.9 – The distance controller " src="image/Figure_11.9_B18001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.549.1">Figure 11.9 – The distance controller</span></p>
<p><span class="koboSpan" id="kobo.550.1">The preceding </span><a id="_idIndexMarker658"/><span class="koboSpan" id="kobo.551.1">diagram shows the update method of a </span><strong class="source-inline"><span class="koboSpan" id="kobo.552.1">DistanceController</span></strong><span class="koboSpan" id="kobo.553.1"> class. </span><strong class="source-inline"><span class="koboSpan" id="kobo.554.1">control_signal</span></strong><span class="koboSpan" id="kobo.555.1"> directly drives the motor. </span><span class="koboSpan" id="kobo.555.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.556.1">update</span></strong><span class="koboSpan" id="kobo.557.1"> method has two inputs –</span><strong class="source-inline"><span class="koboSpan" id="kobo.558.1">dt</span></strong><span class="koboSpan" id="kobo.559.1"> and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.560.1">expected</span></strong><span class="koboSpan" id="kobo.561.1"> distance in ticks. </span><span class="koboSpan" id="kobo.561.2">We subtract the </span><strong class="source-inline"><span class="koboSpan" id="kobo.562.1">actual</span></strong><span class="koboSpan" id="kobo.563.1"> distance in encoder ticks from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.564.1">expected</span></strong><span class="koboSpan" id="kobo.565.1"> distance to get the </span><strong class="source-inline"><span class="koboSpan" id="kobo.566.1">error</span></strong><span class="koboSpan" id="kobo.567.1"> value, which is used with </span><strong class="source-inline"><span class="koboSpan" id="kobo.568.1">dt</span></strong><span class="koboSpan" id="kobo.569.1"> to update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.570.1">PID</span></strong><span class="koboSpan" id="kobo.571.1">. </span><span class="koboSpan" id="kobo.571.2">The output should result in a wheel/motor turning faster if it is behind the expected number of ticks or slower if </span><span class="No-Break"><span class="koboSpan" id="kobo.572.1">it’s ahead.</span></span></p>
<p><span class="koboSpan" id="kobo.573.1">We will also use the same graphing and control routines as before, but we will alter the </span><strong class="source-inline"><span class="koboSpan" id="kobo.574.1">G</span></strong><span class="koboSpan" id="kobo.575.1"> control handler to specify a distance in meters instead of time in seconds – so, </span><strong class="source-inline"><span class="koboSpan" id="kobo.576.1">G0.5</span></strong><span class="koboSpan" id="kobo.577.1"> would signal the robot to drive half a meter at the current speed, then stop. </span></p>
<p><span class="koboSpan" id="kobo.578.1">Now, we have enough information to update </span><span class="No-Break"><span class="koboSpan" id="kobo.579.1">the code.</span></span></p>
<h2 id="_idParaDest-247"><a id="_idTextAnchor248"/><span class="koboSpan" id="kobo.580.1">Code to control distance and speed</span></h2>
<p><span class="koboSpan" id="kobo.581.1">Let’s start </span><a id="_idIndexMarker659"/><span class="koboSpan" id="kobo.582.1">with a copy of the previous example code. </span><span class="koboSpan" id="kobo.582.2">We will update the specific </span><span class="No-Break"><span class="koboSpan" id="kobo.583.1">changed routines.</span></span></p>
<p><span class="koboSpan" id="kobo.584.1">First, we need to add another number </span><span class="No-Break"><span class="koboSpan" id="kobo.585.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.586.1">robot.py</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.587.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.588.1">
m_to_ticks = 1 / ticks_to_m</span></pre>
<p><span class="koboSpan" id="kobo.589.1">This lets us convert differently so that we can get </span><strong class="source-inline"><span class="koboSpan" id="kobo.590.1">m</span></strong><span class="koboSpan" id="kobo.591.1"> from ticks. </span><span class="koboSpan" id="kobo.591.2">Let’s create the new </span><strong class="source-inline"><span class="koboSpan" id="kobo.592.1">code.py</span></strong><span class="koboSpan" id="kobo.593.1"> file with the </span><span class="No-Break"><span class="koboSpan" id="kobo.594.1">familiar imports:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.595.1">
import asyncio
import time
import robot
import pid_controller</span></pre>
<p><span class="koboSpan" id="kobo.596.1">Now, let’s add the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.597.1">DistanceController</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.598.1"> class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.599.1">
class DistanceController:
  def __init__(self, encoder, motor_fn):
    self.encoder = encoder
    self.motor_fn = motor_fn
    self.pid = pid_controller.PIDController(3.25, 0.5, 0.5, d_filter_gain=1)
    self.start_ticks = self.encoder.read()
    self.pwm = 0
    self.error = 0</span></pre>
<p><span class="koboSpan" id="kobo.600.1">Here, we initialized the </span><strong class="source-inline"><span class="koboSpan" id="kobo.601.1">PID</span></strong><span class="koboSpan" id="kobo.602.1"> controller and renamed </span><strong class="source-inline"><span class="koboSpan" id="kobo.603.1">last_ticks</span></strong><span class="koboSpan" id="kobo.604.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.605.1">start_ticks</span></strong><span class="koboSpan" id="kobo.606.1"> – the ticks the </span><a id="_idIndexMarker660"/><span class="koboSpan" id="kobo.607.1">encoder is at when we start this behavior. </span><span class="koboSpan" id="kobo.607.2">We kept </span><strong class="source-inline"><span class="koboSpan" id="kobo.608.1">error</span></strong><span class="koboSpan" id="kobo.609.1"> so that we can plot it. </span><span class="koboSpan" id="kobo.609.2">The code sets </span><strong class="source-inline"><span class="koboSpan" id="kobo.610.1">filter_gain</span></strong><span class="koboSpan" id="kobo.611.1"> for the derivative to </span><strong class="source-inline"><span class="koboSpan" id="kobo.612.1">1</span></strong><span class="koboSpan" id="kobo.613.1"> so that the derivative is not too slow in </span><span class="No-Break"><span class="koboSpan" id="kobo.614.1">catching up.</span></span></p>
<p><span class="koboSpan" id="kobo.615.1">Next, we need an </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.616.1">update</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.617.1"> method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.618.1">
  def update(self, dt, expected):
    self.actual = self.encoder.read() - self.start_ticks
    self.error = (expected - self.actual) / robot.ticks_per_revolution
    control_signal = self.pid.calculate(self.error, dt)
    self.motor_fn(control_signal)</span></pre>
<p><span class="koboSpan" id="kobo.619.1">First, we have an additional </span><strong class="source-inline"><span class="koboSpan" id="kobo.620.1">expected</span></strong><span class="koboSpan" id="kobo.621.1"> parameter (in ticks). </span><span class="koboSpan" id="kobo.621.2">We get an </span><strong class="source-inline"><span class="koboSpan" id="kobo.622.1">actual</span></strong><span class="koboSpan" id="kobo.623.1"> (in moved ticks) by subtracting </span><strong class="source-inline"><span class="koboSpan" id="kobo.624.1">start_ticks</span></strong><span class="koboSpan" id="kobo.625.1"> from the current encoder reading. </span><span class="koboSpan" id="kobo.625.2">We store it as </span><strong class="source-inline"><span class="koboSpan" id="kobo.626.1">self.actual</span></strong><span class="koboSpan" id="kobo.627.1"> so that we can </span><span class="No-Break"><span class="koboSpan" id="kobo.628.1">graph this.</span></span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.629.1">error</span></strong><span class="koboSpan" id="kobo.630.1"> is far simpler; subtracting </span><strong class="source-inline"><span class="koboSpan" id="kobo.631.1">expected</span></strong><span class="koboSpan" id="kobo.632.1"> from </span><strong class="source-inline"><span class="koboSpan" id="kobo.633.1">actual</span></strong><span class="koboSpan" id="kobo.634.1"> gives us the number of encoder ticks we are short or ahead of. </span><span class="koboSpan" id="kobo.634.2">However, to scale it down, we must divide by ticks per revolution. </span><span class="koboSpan" id="kobo.634.3">This goes into the PID calculation, along with </span><strong class="source-inline"><span class="koboSpan" id="kobo.635.1">dt</span></strong><span class="koboSpan" id="kobo.636.1">. </span></p>
<p><span class="koboSpan" id="kobo.637.1">We use </span><a id="_idIndexMarker661"/><span class="koboSpan" id="kobo.638.1">the output of the PID to control </span><span class="No-Break"><span class="koboSpan" id="kobo.639.1">the motor.</span></span></p>
<p><span class="koboSpan" id="kobo.640.1">We’ve completed the </span><strong class="source-inline"><span class="koboSpan" id="kobo.641.1">DistanceController</span></strong><span class="koboSpan" id="kobo.642.1"> code. </span><span class="koboSpan" id="kobo.642.2">Next, we need to create the </span><strong class="source-inline"><span class="koboSpan" id="kobo.643.1">DistanceTracker</span></strong><span class="koboSpan" id="kobo.644.1"> class. </span><span class="koboSpan" id="kobo.644.2">We start by storing the </span><span class="No-Break"><span class="koboSpan" id="kobo.645.1">controller’s settings:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.646.1">
class DistanceTracker:
  def __init__(self):
    self.speed = 0.17
    self.time_interval = 0.2
    self.start_time = time.monotonic()
    self.current_position = 0
    self.total_distance_in_ticks = 0
    self.total_time = 0.1</span></pre>
<p><span class="koboSpan" id="kobo.647.1">After setting the </span><strong class="source-inline"><span class="koboSpan" id="kobo.648.1">speed</span></strong><span class="koboSpan" id="kobo.649.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.650.1">time_interval</span></strong><span class="koboSpan" id="kobo.651.1"> fields, we store a </span><strong class="source-inline"><span class="koboSpan" id="kobo.652.1">start_time</span></strong><span class="koboSpan" id="kobo.653.1"> to count the time elapsed. </span><span class="koboSpan" id="kobo.653.2">We also set up initial values for </span><strong class="source-inline"><span class="koboSpan" id="kobo.654.1">current_position</span></strong><span class="koboSpan" id="kobo.655.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.656.1">total_distance_in_ticks</span></strong><span class="koboSpan" id="kobo.657.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.658.1">total_time</span></strong><span class="koboSpan" id="kobo.659.1">. </span><span class="koboSpan" id="kobo.659.2">Note that </span><strong class="source-inline"><span class="koboSpan" id="kobo.660.1">total_time</span></strong><span class="koboSpan" id="kobo.661.1"> must not be zero as we use it in </span><span class="No-Break"><span class="koboSpan" id="kobo.662.1">the division.</span></span></p>
<p><span class="koboSpan" id="kobo.663.1">We will need to set these values when we update </span><span class="No-Break"><span class="koboSpan" id="kobo.664.1">the distance:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.665.1">
  def set_distance(self, new_distance):
    self.current_position += self.total_distance_in_ticks
    self.total_distance_in_ticks = robot.m_to_ticks * new_distance
    self.total_time = max(0.1, abs(new_distance / self.speed))
    self.start_time = time.monotonic()</span></pre>
<p><span class="koboSpan" id="kobo.666.1">The first thing we must do is add any previous movement to </span><strong class="source-inline"><span class="koboSpan" id="kobo.667.1">current_position</span></strong><span class="koboSpan" id="kobo.668.1">. </span><span class="koboSpan" id="kobo.668.2">This means we keep track of the expected position so that the system doesn’t accumulate too </span><span class="No-Break"><span class="koboSpan" id="kobo.669.1">many errors.</span></span></p>
<p><span class="koboSpan" id="kobo.670.1">Then, we must calculate a total distance, converting from meters into ticks into </span><strong class="source-inline"><span class="koboSpan" id="kobo.671.1">total_distance_in_ticks</span></strong><span class="koboSpan" id="kobo.672.1">. </span><span class="koboSpan" id="kobo.672.2">The code calculates the total time by dividing </span><strong class="source-inline"><span class="koboSpan" id="kobo.673.1">new_distance</span></strong><span class="koboSpan" id="kobo.674.1"> by </span><strong class="source-inline"><span class="koboSpan" id="kobo.675.1">speed</span></strong><span class="koboSpan" id="kobo.676.1">. </span><span class="koboSpan" id="kobo.676.2">However, since going backward would be a negative speed, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.677.1">abs</span></strong><span class="koboSpan" id="kobo.678.1"> function to get only a positive time. </span><span class="koboSpan" id="kobo.678.2">Also, to avoid that division by zero, we clamp this value to be above </span><span class="No-Break"><span class="koboSpan" id="kobo.679.1">0.1 seconds.</span></span></p>
<p><span class="koboSpan" id="kobo.680.1">Finally, this resets to a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.681.1">start_time</span></strong><span class="koboSpan" id="kobo.682.1">, from which </span><strong class="source-inline"><span class="koboSpan" id="kobo.683.1">total_time</span></strong><span class="koboSpan" id="kobo.684.1"> will </span><span class="No-Break"><span class="koboSpan" id="kobo.685.1">be relative.</span></span></p>
<p><span class="koboSpan" id="kobo.686.1">Now, we </span><a id="_idIndexMarker662"/><span class="koboSpan" id="kobo.687.1">can build the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.688.1">DistanceTracker</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.689.1"> loop:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.690.1">
  async def loop(self):
    left = DistanceController(robot.left_encoder, robot.set_left)
    right = DistanceController(robot.right_encoder, robot.set_right)
    last_time = time.monotonic()</span></pre>
<p><span class="koboSpan" id="kobo.691.1">This code creates two </span><strong class="source-inline"><span class="koboSpan" id="kobo.692.1">DistanceController</span></strong><span class="koboSpan" id="kobo.693.1"> instances and stores a </span><strong class="source-inline"><span class="koboSpan" id="kobo.694.1">last_time</span></strong><span class="koboSpan" id="kobo.695.1"> value for </span><strong class="source-inline"><span class="koboSpan" id="kobo.696.1">dt</span></strong><span class="koboSpan" id="kobo.697.1"> calculations. </span><span class="koboSpan" id="kobo.697.2">The next part of the code is all </span><span class="No-Break"><span class="koboSpan" id="kobo.698.1">about time:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.699.1">
    while True:
      await asyncio.sleep(self.time_interval)
      current_time = time.monotonic()
      dt = current_time - last_time
      last_time = current_time
      elapsed_time = current_time - self.start_time
      time_proportion = min(1, elapsed_time / self.total_time)</span></pre>
<p><span class="koboSpan" id="kobo.700.1">First, we sleep for </span><strong class="source-inline"><span class="koboSpan" id="kobo.701.1">time_interval</span></strong><span class="koboSpan" id="kobo.702.1">, then get </span><strong class="source-inline"><span class="koboSpan" id="kobo.703.1">current_time</span></strong><span class="koboSpan" id="kobo.704.1">. </span><span class="koboSpan" id="kobo.704.2">From this, we can calculate </span><strong class="source-inline"><span class="koboSpan" id="kobo.705.1">dt</span></strong><span class="koboSpan" id="kobo.706.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.707.1">elapsed_time</span></strong><span class="koboSpan" id="kobo.708.1">. </span><span class="koboSpan" id="kobo.708.2">We calculate a </span><strong class="source-inline"><span class="koboSpan" id="kobo.709.1">time_proportion</span></strong><span class="koboSpan" id="kobo.710.1"> between 0 and 1 by dividing </span><strong class="source-inline"><span class="koboSpan" id="kobo.711.1">current_time</span></strong><span class="koboSpan" id="kobo.712.1"> by </span><strong class="source-inline"><span class="koboSpan" id="kobo.713.1">total_time</span></strong><span class="koboSpan" id="kobo.714.1">. </span><span class="koboSpan" id="kobo.714.2">This </span><strong class="source-inline"><span class="koboSpan" id="kobo.715.1">time_proportion</span></strong><span class="koboSpan" id="kobo.716.1"> lets us track where we are in the current motion. </span><span class="koboSpan" id="kobo.716.2">Note that we clamp this to a limit of 1 so that the time ratio doesn’t multiply to a value larger than the </span><span class="No-Break"><span class="koboSpan" id="kobo.717.1">intended distance.</span></span></p>
<p><span class="koboSpan" id="kobo.718.1">Then, we can multiply </span><strong class="source-inline"><span class="koboSpan" id="kobo.719.1">time_proportion</span></strong><span class="koboSpan" id="kobo.720.1"> by </span><strong class="source-inline"><span class="koboSpan" id="kobo.721.1">total_distance_in_ticks</span></strong><span class="koboSpan" id="kobo.722.1"> to get the </span><a id="_idIndexMarker663"/><span class="koboSpan" id="kobo.723.1">relative tick position for the robot. </span><span class="koboSpan" id="kobo.723.2">As this is a relatively expected position, we add </span><strong class="source-inline"><span class="koboSpan" id="kobo.724.1">current_position</span></strong><span class="koboSpan" id="kobo.725.1"> again. </span><span class="koboSpan" id="kobo.725.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.726.1">expected</span></strong><span class="koboSpan" id="kobo.727.1"> value is an absolute position from when we start </span><span class="No-Break"><span class="koboSpan" id="kobo.728.1">the code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.729.1">
      expected = time_proportion * self.total_distance_in_ticks + self.current_position
      left.update(dt, expected)
      right.update(dt, expected)
      robot.send_line(f"{expected:.2f},{left.actual:.2f},0")</span></pre>
<p><span class="koboSpan" id="kobo.730.1">Now, we must update the two </span><strong class="source-inline"><span class="koboSpan" id="kobo.731.1">DistanceController</span></strong><span class="koboSpan" id="kobo.732.1"> instances and write data to the UART to </span><span class="No-Break"><span class="koboSpan" id="kobo.733.1">be plotted.</span></span></p>
<p><span class="koboSpan" id="kobo.734.1">We can start this part of the system by creating an instance </span><span class="No-Break"><span class="koboSpan" id="kobo.735.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.736.1">DistanceTracker</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.737.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.738.1">
distance_tracker = DistanceTracker()</span></pre>
<p><span class="koboSpan" id="kobo.739.1">We can complete this behavior by creating a UART </span><span class="No-Break"><span class="koboSpan" id="kobo.740.1">command handler:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.741.1">
async def command_handler():
  while True:
    if robot.uart.in_waiting:
      command = robot.uart.readline().decode().strip()
      if command.startswith("M"):
        distance_tracker.speed = float(command[1:])
      elif command.startswith("T"):
        distance_tracker.time_interval = float(command[1:])
      elif command == "G":
        distance_tracker.set_distance(0)
      elif command.startswith("G"):
        await asyncio.sleep(5)
        distance_tracker.set_distance(float(command[1:]))
    await asyncio.sleep(0)</span></pre>
<p><span class="koboSpan" id="kobo.742.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.743.1">G&lt;number&gt;</span></strong><span class="koboSpan" id="kobo.744.1"> command now updates a distance instead of time; stopping the robot sets a new distance </span><span class="No-Break"><span class="koboSpan" id="kobo.745.1">of zero.</span></span></p>
<p><span class="koboSpan" id="kobo.746.1">All that </span><a id="_idIndexMarker664"/><span class="koboSpan" id="kobo.747.1">remains is to start the async tasks and </span><span class="No-Break"><span class="koboSpan" id="kobo.748.1">handle errors:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.749.1">
try:
  motors_task = asyncio.create_task(distance_tracker.loop())
  asyncio.run(command_handler())
finally:
  motors_task.cancel()
  robot.stop()</span></pre>
<p><span class="koboSpan" id="kobo.750.1">We now have code that tracks a distance at a given speed; however, you will likely need to tune the PID. </span><strong class="source-inline"><span class="koboSpan" id="kobo.751.1">DistanceController</span></strong><span class="koboSpan" id="kobo.752.1"> needs to provide enough </span><strong class="source-inline"><span class="koboSpan" id="kobo.753.1">control_signal</span></strong><span class="koboSpan" id="kobo.754.1"> to keep up with a changing </span><strong class="source-inline"><span class="koboSpan" id="kobo.755.1">expected</span></strong><span class="koboSpan" id="kobo.756.1"> position. </span><span class="koboSpan" id="kobo.756.2">There will be a non-zero </span><strong class="source-inline"><span class="koboSpan" id="kobo.757.1">error</span></strong><span class="koboSpan" id="kobo.758.1"> value in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.759.1">update</span></strong><span class="koboSpan" id="kobo.760.1"> method if it’s not completed the motion. </span><span class="koboSpan" id="kobo.760.2">This PID system will be dominantly proportional so that the motors keep up with the expected position. </span><span class="koboSpan" id="kobo.760.3">The tips at </span><a href="https://pidexplained.com/how-to-tune-a-pid-controller/"><span class="koboSpan" id="kobo.761.1">https://pidexplained.com/how-to-tune-a-pid-controller/</span></a><span class="koboSpan" id="kobo.762.1"> help with </span><span class="No-Break"><span class="koboSpan" id="kobo.763.1">this tuning.</span></span></p>
<p><span class="koboSpan" id="kobo.764.1">Note that if you change the motors, the floor type, or the time base, you may need to tune this </span><span class="No-Break"><span class="koboSpan" id="kobo.765.1">system again.</span></span></p>
<p><span class="koboSpan" id="kobo.766.1">You should now have a tuned system to drive a specific distance at a </span><span class="No-Break"><span class="koboSpan" id="kobo.767.1">specific speed.</span></span></p>
<h1 id="_idParaDest-248"><a id="_idTextAnchor249"/><span class="koboSpan" id="kobo.768.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.769.1">In this chapter, you learned how to use the encoder more usefully. </span><span class="koboSpan" id="kobo.769.2">You looked at how to use wheel geometry to convert encoder pulses into metric measurements and then used these measurements to </span><span class="No-Break"><span class="koboSpan" id="kobo.770.1">measure speed.</span></span></p>
<p><span class="koboSpan" id="kobo.771.1">Once we can measure speed, we can use a PID to control the speed of each wheel and see significantly </span><span class="No-Break"><span class="koboSpan" id="kobo.772.1">less veering.</span></span></p>
<p><span class="koboSpan" id="kobo.773.1">We could then take this to the next level and drive a specific distance at a specific speed, providing fully </span><span class="No-Break"><span class="koboSpan" id="kobo.774.1">controlled motion.</span></span></p>
<p><span class="koboSpan" id="kobo.775.1">In the next chapter, we will connect an IMU to our robot so that we can measure a compass heading and control the </span><span class="No-Break"><span class="koboSpan" id="kobo.776.1">robot’s direction.</span></span></p>
<h1 id="_idParaDest-249"><a id="_idTextAnchor250"/><span class="koboSpan" id="kobo.777.1">Exercises</span></h1>
<p><span class="koboSpan" id="kobo.778.1">These exercises will deepen your understanding of the topics covered in this chapter and make the robot’s </span><span class="No-Break"><span class="koboSpan" id="kobo.779.1">code better:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.780.1">All the preceding examples could benefit from the PID modification and printing menu in the UART command handler – consider adding it </span><span class="No-Break"><span class="koboSpan" id="kobo.781.1">to them.</span></span></li>
<li><span class="koboSpan" id="kobo.782.1">In the distance control, we set the derivative filter gain to 1, disabling it. </span><span class="koboSpan" id="kobo.782.2">How does this system behave with other filter </span><span class="No-Break"><span class="koboSpan" id="kobo.783.1">gain values?</span></span></li>
<li><span class="koboSpan" id="kobo.784.1">Instead of starting motions with the phone app, could you chain some of these movements together? </span><span class="koboSpan" id="kobo.784.2">Or even alter the phone G instruction to make a few motions with a single </span><span class="No-Break"><span class="koboSpan" id="kobo.785.1">command sequence?</span></span></li>
</ul>
<h1 id="_idParaDest-250"><a id="_idTextAnchor251"/><span class="koboSpan" id="kobo.786.1">Further reading</span></h1>
<p><span class="koboSpan" id="kobo.787.1">These further study aids will help you learn more and dive deeper into using encoders to control </span><span class="No-Break"><span class="koboSpan" id="kobo.788.1">robot motion:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.789.1">In </span><em class="italic"><span class="koboSpan" id="kobo.790.1">Learn Robotics Programming Second Edition</span></em><span class="koboSpan" id="kobo.791.1">, </span><a href="B18001_11.xhtml#_idTextAnchor233"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.792.1">Chapter 11</span></em></span></a><em class="italic"><span class="koboSpan" id="kobo.793.1">, Programming Encoders with Python</span></em><span class="koboSpan" id="kobo.794.1">, I used simpler encoders but dove into the calculations needed to make specific turns with encoders that could be adapted to </span><span class="No-Break"><span class="koboSpan" id="kobo.795.1">the Pico.</span></span></li>
<li><span class="koboSpan" id="kobo.796.1">The Arduino-based tutorial at </span><a href="https://circuitdigest.com/microcontroller-projects/arduino-based-encoder-motor-using-pid-controller"><span class="koboSpan" id="kobo.797.1">https://circuitdigest.com/microcontroller-projects/arduino-based-encoder-motor-using-pid-controller</span></a><span class="koboSpan" id="kobo.798.1"> shows how to use a </span><span class="No-Break"><span class="koboSpan" id="kobo.799.1">PID controller.</span></span></li>
<li><span class="koboSpan" id="kobo.800.1">This Python file at </span><a href="https://github.com/pimoroni/pimoroni-pico/blob/main/micropython/examples/inventor2040w/motors/position_control.py"><span class="koboSpan" id="kobo.801.1">https://github.com/pimoroni/pimoroni-pico/blob/main/micropython/examples/inventor2040w/motors/position_control.py</span></a><span class="koboSpan" id="kobo.802.1"> from Pimoroni shows a similar Python approach in MicroPython for </span><span class="No-Break"><span class="koboSpan" id="kobo.803.1">the Pico.</span></span></li>
</ul>
</div>
</body></html>