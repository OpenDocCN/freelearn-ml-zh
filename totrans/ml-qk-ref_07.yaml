- en: Temporal and Sequential Pattern Discovery
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时间和顺序模式发现
- en: Many of us have visited retail shops such as Reliance and Walmart for our household
    needs. Let's say that we are planning to buy an iPhoneX from Reliance Digital.
    What we would typically do is search for the model by visiting the mobile section
    of the store, and then select the product and head toward the billing counter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们中的许多人为了家庭需求去过像Reliance和Walmart这样的零售商店。假设我们计划从Reliance Digital购买一部iPhoneX。我们通常会做的是访问商店的移动部门，搜索型号，然后选择产品并前往结账柜台。
- en: But, in today's world, the goal of the organization is to increase revenue.
    Can this be done by pitching just one product at a time to the customer? The answer
    is a clear **no**. Hence, organizations began mining data relating to frequently
    bought items. They try to find out associations between different items and products
    that can be sold together, which gives assisting in right product placement. Typically,
    it figures out what products are being bought together and organizations can place
    products in a similar manner.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在当今世界，组织的目标是增加收入。这仅仅通过一次向客户推销一个产品就能实现吗？答案是明确的**不**。因此，组织开始挖掘与频繁购买项目相关的数据。他们试图找出不同项目之间的关联，以及可以一起销售的产品，这有助于正确的产品定位。通常，它会找出哪些产品是共同购买的，组织可以以类似的方式摆放产品。
- en: This is what we are going to talk about in this chapter. How do we come up with
    such rules by means of machine learning? We will discuss number of techniques
    here.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们将在本章中讨论的内容。我们如何通过机器学习手段制定这样的规则？我们将在这里讨论多种技术。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Association rules
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关联规则
- en: Frequent pattern growth
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 频繁模式增长
- en: Validation
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证
- en: Association rules
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关联规则
- en: Association rule mining is a technique that focuses upon observing frequently
    occurring patterns and associations from datasets found in databases such as relational
    and transactional databases. These rules do not say anything about the preferences
    of an individual; rather, they rely chiefly on the items within transactions to
    deduce a certain association. Every transaction is identified by a primary key
    (distinct ID) called, **transaction ID**. All these transactions are studied as
    a group and patterns are mined.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 关联规则挖掘是一种技术，它关注于从数据库中观察频繁出现的模式和关联，如关系数据库和事务数据库。这些规则并没有说任何关于个人偏好的内容；相反，它们主要依赖于交易中的项目来推断某种关联。每个交易都有一个主键（唯一的ID），称为，**交易ID**。所有这些交易都被作为一个整体进行研究，并从中挖掘模式。
- en: 'Association rules can be thought of as an **if—then** relationship. Just to
    elaborate on that, we have to come up with a rule: **if** an item **A** is being
    bought by the customer, **then** the chances of item **B** being picked by the
    customer too under the same transaction ID (along with item **A**) is found out.
    You needs to understand here that it''s not a causality, rather, it is co-occurrence
    pattern that comes to the fore.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 关联规则可以被视为一个**如果—那么**的关系。为了详细阐述这一点，我们必须制定一条规则：**如果**客户购买了一个项目**A**，**那么**在相同的交易ID下（与项目**A**一起），客户选择项目**B**的概率被找到。在这里，你需要理解这不是因果关系，而是一种共现模式，它浮出水面。
- en: 'There are two elements of these rules:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这些规则有两个要素：
- en: '**Antecedent (if)**: This is an item/group of items that are typically found
    in the itemsets or datasets'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**前件（如果）**：这是通常在项集或数据集中找到的项目/项目组'
- en: '**Consequent (then)**: This comes along as an item with an antecedent/group
    of antecedents'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**后件（那么）**：这是一个与前件/前件组一起出现的项目'
- en: 'Have a look at the following rule:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 看看以下规则：
- en: '*{Bread, milk} ⇒ {Butter}*'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*{面包，牛奶} ⇒ {黄油}*'
- en: The first part of this rule is called **antecedent** and the second part (after
    the arrow) is **consequent**. It is able to convey that there is a chance of *Butter* being
    picked in a transaction if *Bread* and  *Milk* are picked earlier. However, the
    percentage chance for the consequent to be present in an itemset, given the antecedent,
    is not clear.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这条规则的第一个部分被称为**前件**，第二个部分（在箭头之后）是**后件**。它能够传达在交易中如果先选择了*面包*和*牛奶*，那么选择*黄油*的可能性。然而，给定前件，后件在项集中出现的百分比概率并不明确。
- en: 'Let''s look at a few metrics that will help us in getting there:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些有助于我们达到目标的指标：
- en: '**Support**: This is a measure of the frequency of the itemset in all the transactions.
    For example, there are two itemsets popping up through the number of transactions
    for a retail outlet such as Walmart: itemset *A = {Milk}*, itemset *B = {laptop}*.
    Given that support is how frequent the itemset is in all the transactions, we
    are asked to find out which itemset has got the higher support. We know that itemset
    *A* will have higher support because *Milk* features in everyday grocery lists
    (and, in turn, the transaction) at a greater probability than *laptop*. Let''s
    add another level of association and study with two new itemsets: itemset *A=
    {milk, cornflakes}*, itemset *B= {milk, USB Drive}*. The purchasing frequency
    of *milk* and *cornflakes* together will be higher than *milk and USB Drive*.
    It will make the support metric higher for *A*.'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**支持度**：这是度量项目集在所有交易中的频率。例如，通过零售店如沃尔玛的交易数量，会出现两个项目集：项目集*A = {Milk}*)，项目集*B
    = {laptop}*)。鉴于支持度是项目集在所有交易中的频率，我们需要找出哪个项目集具有更高的支持度。我们知道项目集*A*将具有更高的支持度，因为*Milk*出现在日常杂货清单（以及交易）中的概率比*laptop*更高。让我们增加一个关联级别，并使用两个新的项目集进行研究：项目集*A=
    {milk, cornflakes}*)，项目集*B= {milk, USB Drive}*)。*milk*和*cornflakes*一起的购买频率将高于*milk
    and USB Drive*。这将使*A*的支持度指标更高。'
- en: 'Let''s translate this into mathematics:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这转化为数学表达式：
- en: '*Support(A, B) = Transactions comprising A and B/Total number of transactions*'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*支持度(A, B) = 包含A和B的交易/总交易数*'
- en: 'Here''s an example:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: The total number of transactions is 10,000
  id: totrans-22
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总交易数是10,000
- en: Transactions comprising *A* and *B = 500*
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含*A*和*B*的交易 = 500*
- en: Then support *(A, B) = 500/10000= 0.05*
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 那么，支持度*(A, B) = 500/10000= 0.05*
- en: 5% of transactions contain *A* and *B* together
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 5%的交易包含*A*和*B*一起
- en: '**Confidence**: This indicates how likely item 1 is to be purchased/picked
    when item 2 is already picked. In other words, it measures the likelihood of the
    occurrence of consequent transactions given that the antecedent is already there
    in the transaction. In other words, it is the probability of the occurrence of
    *Butter* in the transaction if *Bread* has already been part of that transaction.
    It is quite clear that it is a conditional probability of the occurrence of the
    consequent while having the antecedent:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**信心**：这表示当项目2已经被选中时，项目1被购买/选中的可能性。换句话说，它衡量的是在先导交易已经存在的情况下，后续交易发生的可能性。换句话说，如果*Bread*已经参与了该交易，那么它衡量的是交易中发生*Butter*的概率。很明显，这是在具有先导条件的情况下，后续事件发生的条件概率：'
- en: '*Confidence(A ⇒ B) = Transactions comprising A and B/Transactions comprising
    A*'
  id: totrans-27
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*信心(A ⇒ B) = 包含A和B的交易/包含A的交易*'
- en: '*Confidence can be transformed in terms of support*'
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*信心可以转换为支持度*'
- en: '*Confidence(A ⇒ B) = Support(A, B)/Support(A)*'
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*信心(A ⇒ B) = 支持度(A, B)/支持度(A)*'
- en: 'Here''s an example:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: Transactions with the itemset as *milk = 50*
  id: totrans-31
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含项目集*milk*的交易 = 50*
- en: Transactions with the itemset as *cereal = 30*
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含项目集*cereal*的交易 = 30*
- en: Transactions comprising *milk* and *cereal = 10*
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含*milk*和*cereal*的交易 = 10*
- en: Total number of transactions = 100
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总交易数 = 100
- en: '*Confidence(milk ⇒ Cereal) = 10/(50 +10) = 0.167*'
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*信心(milk ⇒ Cereal) = 10/(50 +10) = 0.167*'
- en: It means that there is 16.7% probability of that event taking place.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着该事件发生的概率是16.7%。
- en: A drawback of the confidence is it only accounts for how popular item 1 is,
    but not item 2\. If item 2 is equally frequent, there will be a higher chance
    that a transaction containing item 1 will also contain item 2\. Hence, it will
    result in an inflated outcome. To account for the frequency of both constituent
    items, we use a third measure called **lift**.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 信心的一个缺点是它只考虑了项目1的流行程度，但没有考虑项目2。如果项目2同样频繁，那么包含项目1的交易也包含项目2的可能性会更高。因此，这会导致结果被夸大。为了考虑两个构成项目的频率，我们使用一个称为**提升**的第三个度量。
- en: '**Lift**: This is an indicator of how likely it is that item B will be picked
    in the cart/transaction, given that item *A* is already picked, while keeping
    a tab on the frequency of item *B.* A lift value greater than 1 says that there
    is a great association between item *A* and item *B,* which implies that there
    is a good chance that item *B* will be picked if item *A* is already in the cart.
    A lift value of less than 1 means that the chances are slim that item *B* will
    be picked if item *A* is already present. If the lift value hits zero, it means
    no association can be established here.'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Lift(A⇒B) = (Transactions comprising A and B/(Transactions comprising A))/fraction
    of Transaction comprising B*'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 'Implies:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '*= Support(A, B)/(Support(A) * Support(B))*'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '*Lift(milk⇒cereal) = ( 10/(50+10))/0.4*'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '*= 0.416*'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: We will see this in a better format here. The probability of having cereal in
    the cart with the knowledge that milk is already in the cart (which is called
    **confidence**) = *10/(50+10) = 0.167.*
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: The probability of having cereal in the cart without the knowledge that milk
    is in the *cart = (30+10)/100 = 0.4*.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: It means that having knowledge that milk is already in the cart reduces the
    chance of picking cereal from *0.4* to *0.167*. It is a lift of *0.167/0.4= 0.416*
    and is less than *1*. Hence, the chances of picking cereal while milk is already
    in the cart are very small.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Apriori algorithm
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Apriori is a classical algorithm that is used to mine frequent itemsets to derive
    various association rules. It will help set up a retail store in a much better
    way, which will aid revenue generation.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: 'The anti-monotonicity of the support measure is one of the prime concepts around
    which Apriori revolves. It assumes the following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: All subsets of a frequent itemset must be frequent
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Similarly, for any infrequent itemset, all its supersets must be infrequent
    too
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s look at an example and explain it:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '| **Transaction ID** | **Milk** | **Butter** | **Cereal** | **Bread** | **Book**
    |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
- en: '| t1 | 1 | 1 | 1 | 0 | 0 |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
- en: '| t2 | 0 | 1 | 1 | 1 | 0 |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
- en: '| t3 | 0 | 0 | 0 | 1 | 1 |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
- en: '| t4 | 1 | 1 | 0 | 1 | 0 |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
- en: '| t5 | 1 | 1 | 1 | 0 | 1 |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
- en: '| t6 | 1 | 1 | 1 | 1 | 1 |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
- en: We have got the transaction ID and items such as milk, butter, cereal, bread,
    and book. 1 denotes that item is part of the transaction and 0 means that it is
    not.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'We came up with a frequency table for all the items along, with support (division
    by 6):'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| **Items** | **Number of transactions** | **Support** |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
- en: '| Milk | 4 | 67% |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
- en: '| Butter | 5 | 83% |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
- en: '| Cereal | 4 | 67% |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
- en: '| Bread | 4 | 67% |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
- en: '| Book | 3 | 50% |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
- en: 'We will put a threshold of support at 60%, which will filter out the items
    by frequency as these are the ones that can be addressed as frequent itemsets
    in this scenario:'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| **Items** | **Number of transactions** |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
- en: '| Milk | 4 |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
- en: '| Butter | 5 |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
- en: '| Cereal | 4 |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
- en: '| Bread | 4 |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
- en: 'Similarly, we form the number of combinations (two at a time, three at a time,
    and four at a time) with these items and find out frequencies:'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| **Items** | **Number of transactions** |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
- en: '| Milk, Butter | 4 |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
- en: '| Milk, Cereal | 3 |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
- en: '| Milk, Bread | 2 |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
- en: '| Butter, Bread | 3 |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
- en: '| Butter, Cereal | 4 |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
- en: '| Cereal, Bread | 2 |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
- en: Now, again, we have to find out the support for the preceding examples and filter
    them by threshold, which is support at 60%
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, the combinations have to be formed with three items at a time (for
    example, Milk, Butter, and Bread) and support needs to be calculated for them.
    And, finally, we will filter them out by threshold. The same process needs to
    be done by doing four items at a time. The step that we have done till now is
    called **frequent itemset generation**.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Finding association rules
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to find the association rules, we have to first search for all of
    the rules that have support greater than the threshold support. But the question
    arises: how do we find these? A possible way to find this is by brute force, which
    means to list all the possible association rules and calculate the support and
    confidence for each rule. Later, remove all the rules that fail the confidence
    and support thresholds.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Given there are *n* items in the set* I*, the total number of possible association
    rules is *3^n - 2^(n+1) + 1*.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: If *X* is a frequent itemset with *k* elements, then there are *2^k - 2* association
    rules.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how to execute association rules in Python:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If we are asking for an item to appear three times in a day for seven days''
    time, the support will be *3 x 7/7051*. *7051* is the total number of transactions.
    We will keep the confidence as 20% in the beginning:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can visualize the output by running the `results` command from the preceding
    code:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fc03af0b-27fb-4b45-b579-87be6c9ecb77.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
- en: Frequent pattern growth
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Frequent pattern growth** (**FP-growth**) is a frequent itemset generation
    technique (similar to Apriori). FP-Growth builds a compact-tree structure and
    uses the tree for frequent itemset mining and generating rules. It is faster than
    Apriori and can throw results with large datasets.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go through the steps of FP-Growth:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '**Setting up the transactions**: This step sets up the items by frequency.
    However, the items are set up vertically, not horizontally. That means transforming
    input from transaction to items:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **t_id** | **Items** |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
- en: '| 1 | (B, C, D, A) |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
- en: '| 2 | (B, C, D) |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
- en: '| 3 | (D, A) |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
- en: '| 4 | (A, B) |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
- en: '| 5 | (A, C, B) |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
- en: '**Finding the frequency**: Now we have to find out the frequency of each item
    individually:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **Items** | **Frequency** |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
- en: '| A | 4 |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
- en: '| B | 4 |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
- en: '| C | 3 |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
- en: '| D | 3 |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
- en: 'Let''s set up the minimum threshold or minimum support as 50%:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Min Support = (5*50/100) = 2.5
  id: totrans-111
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: Ceiling of minimum support = 2.5 ~ 3
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Prioritize the items by frequency**: Since all the items have a frequency
    greater than or equal to minimum support, all the items will be part of it. Also,
    based on their frequency, priority or rank will be assigned to the items:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **Items** | **Frequency** | **Rank** |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
- en: '| A | 4 | 1 |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
- en: '| B | 4 | 2 |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
- en: '| C | 3 | 3 |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
- en: '| D | 3 | 4 |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
- en: 'The order of the items is: A, B, C, and D (by frequency in descending order)'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '**Ordering the items by priority**: Now the order of items will be set according
    to the priority given to various items based on frequency. Currently, the order
    is A, B, C, and D:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **t_id** | **Items** | **Order by priority** |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
- en: '| 1 | (B, C, D, A) | (A, B, C, D) |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
- en: '| 2 | (B, C, D) | (B, C, D) |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
- en: '| 3 | (D, A) | (A, D) |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
- en: '| 4 | (A, B) | (A, B) |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
- en: '| 5 | (A, C, B) | (A, B, C) |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
- en: Frequent pattern tree growth
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will study the different frequent pattern tree growth from the following
    rows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '**Row 1**: Every FP-Tree starts with a null node as a root node. Let''s draw
    the first row of the tree order along with their frequency:'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/6018c3aa-74dd-46d3-97ba-c8cfb4792d04.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
- en: '**Row 2**: It has got *{B,C,D}*. *A* is missing, so we can not merge it with
    the earlier node. Hence, we will have to create another node, altogether as shown
    here:'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/64811bcc-9002-4203-a764-0e28f7b0d86b.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
- en: '**Row 3**: It has got *{A,D}*. *B* and *C* are missing, but we can tie it with
    the earlier node. *A* encounters a repetition, so frequency will change. It becomes
    *2* now:'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/7e0a0970-2717-4b76-ba4a-722a683fa292.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
- en: '**Row 4**: It has got *{A,B}*. We can tie it with the earlier node and will
    traverse on the previous node. *A* and *B* encounters a repetition, so frequency
    will change for it. It becomes 3 and 2 respectively:'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/bbb3d66b-ce39-4fff-bcdf-9af564cfb132.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
- en: '**Row 5**: It has got *{A,B,C}*. Again, it can be tied with the earlier node
    and A, B, and C see a repetition, so the frequency will change for them. It becomes
    4, 3, and 2 respectively:'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/53cfa7ef-1d4e-48a0-83bc-52cf57af72bc.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
- en: Validation
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s count the frequency of the final tree that we have got and compare
    the frequency of each item with the table to ensure that we have got the correct
    frequencies in the table:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '**A:4**'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**B:4**'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**C:3**'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**D:3**'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now we will go from bottom to top. We will find out the branches where D appears:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/613380ab-1fe4-4529-8db5-b1527163ee34.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
- en: 'We can see that there are three branches where D appears:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: 'BC: 1'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ABC: 1'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A: 1'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These branches are termed as conditional pattern base for D. While we do this,
    there are points to be kept in mind:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Even if we traverse from bottom to top, we write the branches in a top-to-bottom
    manner
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: D is not part of it
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 represents the frequency of occurrence of D in each branch
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, the conditional pattern for D results in the conditional frequencies for
    A, B, and C, which are 2, 2, and 2\. All are less than the minimum support (3).
    Hence, there can't be any conditional FP- Tree for it.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s do it for C. C is appears in the following branches:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c42a910a-7183-4359-a62e-77209960285c.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
- en: 'The branches end up like this:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: B:1
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AB:2
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It results in A:2 and B:3\. So, B fit with the bill in accordance with the
    minimum support. Now the conditional tree ends up like this:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ede86a39-0990-469c-96e9-89dac495cb1b.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
- en: Similarly, conditional pattern finding is done for different combinations. Thus,
    it sets up the frequent item dataset.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，对于不同的组合进行条件模式查找。因此，它建立了频繁项集数据集。
- en: Let's see how it can be done in Python. We will be using a library called `pyfpgrowth`.
    Also, we shall create an itemset in the following section.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在Python中实现。我们将使用一个名为`pyfpgrowth`的库。此外，我们将在下一节创建一个项集。
- en: Importing the library
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导入库
- en: 'In order to perform validation we will import the library and build the transactions
    as shown here:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行验证，我们将导入库并构建如所示的交易：
- en: '[PRE2]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We build our transactions like so:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们构建我们的交易如下：
- en: '[PRE3]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Minimum support is defined now to find the pattern. `find_frequent_patterns()`*,*
    where `transactions` are the list of items bought at each transaction, and `2`
    is the minimum threshold set for support count:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在定义最小支持度以找到模式。`find_frequent_patterns()`，其中`transactions`是每次交易中购买的项目列表，`2`是设置的最小支持度阈值：
- en: '[PRE4]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Finally, we have to define the confidence to get the rules. Rules are generated
    based on the patterns and `0.5` is the minimum threshold set for confidence. Then,
    we store the rules in a dataframe named `rules`. `rules` initially consists of
    an antecedent, a consequent, and the confidence value:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须定义置信度以获取规则。规则是基于模式生成的，`0.5`是置信度的最小阈值。然后，我们将规则存储在名为`rules`的数据框中。`rules`最初包含一个前件、一个后件和置信度值：
- en: '[PRE5]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We get the output as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到以下输出：
- en: '![](img/af558284-73fa-4c72-a90e-b8fcf6389188.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/af558284-73fa-4c72-a90e-b8fcf6389188.png)'
- en: This is how we get the rules. FP-growth tends to have the edge over Apriori
    as it is faster and more efficient.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们获取规则的方式。FP-growth通常比Apriori有优势，因为它更快、更高效。
- en: Summary
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have studied association rules. We also discussed the Apriori
    algorithm, which is used for mining frequent itemsets to derive various association
    rules. We also learned about frequent pattern growth (FP-growth), which is similar
    to Apriori and about the frequent itemset generation technique, which is similar
    to the Apriori algorithm. Finally, we saw how FP-growth tends to have an edge
    over Apriori, as it is faster and more efficient, using an example.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了关联规则。我们还讨论了Apriori算法，该算法用于挖掘频繁项集以推导出各种关联规则。我们还了解了频繁模式增长（FP-growth），它与Apriori类似，以及频繁项集生成技术，它与Apriori算法类似。最后，我们看到了FP-growth如何比Apriori有优势，因为它更快、更高效，并通过一个例子来说明。
- en: In the next chapter, we will study probabilistic graphical models. We will learn
    in depth about the Bayesian rules and Bayesian networks.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习概率图模型。我们将深入了解贝叶斯规则和贝叶斯网络。
