- en: Quantum Computing – The Future
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 量子计算 – 未来
- en: We will end this series with the beginning of another topic, **quantum computing**.
    Quantum computing is the future, it's coming, and it's real. It uses quantum-mechanical
    phenomena, such as superposition and entanglement, and bases its computations
    on something called **quantum bits** (**qubits**). Where normal computers are
    transistor-based and use the ever-famous one and zero, quantum computing uses
    qubits, which can be in superpositions of a state, not just on or off.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以另一个话题的开始来结束这个系列，**量子计算**。量子计算是未来，它正在到来，它是真实的。它使用量子力学现象，如叠加和纠缠，其计算基于称为**量子比特**（**qubits**）的东西。普通计算机是基于晶体管，并使用著名的0和1，而量子计算使用量子比特，它们可以处于状态的叠加，而不仅仅是开或关。
- en: At the time of writing, quantum computing is still in its infancy, but progress
    is being made. As such, this chapter will be short, but we want to expose you
    to the future so that you are aware.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，量子计算仍处于起步阶段，但正在取得进展。因此，这一章将会很短，但我们希望让你了解未来，以便你有所了解。
- en: 'In this chapter, we will cover:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Superposition
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 叠加
- en: Teleportation
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传送
- en: Many experiments are being run, and Microsoft has released its quantum computing
    **Software Development Kit** (**SDK**). Both Microsoft and IBM are developing
    their own versions of quantum computers. But before we get to that, let's go over
    a few terms you'll need to know. These will go into your super buzzword-compliant
    checklist!
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 正在进行许多实验，微软发布了其量子计算**软件开发工具包**（**SDK**）。微软和IBM都在开发他们自己的量子计算机版本。但在我们到达那里之前，让我们回顾一下你需要了解的一些术语。这些将进入你的超级术语清单！
- en: 'Here is a **Bloch sphere**, which is a qubit representation in **Hilbert space**,
    and it is the most fundamental component of quantum computing:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个**布洛赫球面**，它是**希尔伯特空间**中量子比特的表示，它是量子计算最基本的部分：
- en: '![](img/60afb700-6c6f-4139-b162-ea478afc2470.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/60afb700-6c6f-4139-b162-ea478afc2470.png)'
- en: A classical computer has its memory made up of bits—ones and zeros. A quantum
    computer, however, is comprised of a series of qubits. A single qubit can represent
    a one, a zero, or any quantum superposition of these two qubit states. A single
    qubit can be in any one of two states. A pair of qubits can be in any superposition
    of two states, and three qubits can be in any superposition of eight states. So,
    quantum computers can be in superpositions of many different states, whereas conventional
    computers can only be in one of those states at any given moment in time.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 一个经典计算机的内存由比特组成——1和0。然而，量子计算机由一系列量子比特组成。单个量子比特可以代表一个1、一个0，或者这两个量子比特状态的任何量子叠加。单个量子比特可以处于两种状态中的任何一种。一对量子比特可以处于两种状态的任何叠加，三个量子比特可以处于八种状态的任何叠加。因此，量子计算机可以处于许多不同状态的叠加，而传统计算机在任何给定时刻只能处于这些状态中的任何一个。
- en: 'A quantum computer operates using quantum gates and quantum logic gates (similar
    to logic gates for a conventional computer), and the problem it is trying to solve
    is encoded by setting the initial values of the qubits, just like a conventional
    computer does. Quantum algorithms are considered mostly probabilistic, in that
    they provide a correct solution only with a known probability:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 量子计算机通过量子门和量子逻辑门（类似于传统计算机的逻辑门）运行，它试图解决的问题是通过设置量子比特的初始值来编码的，就像传统计算机一样。量子算法被认为是大多数概率性的，即在已知概率下提供正确解决方案：
- en: '![](img/ac1d09ff-d2d3-416c-bc7a-145518ef28ab.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ac1d09ff-d2d3-416c-bc7a-145518ef28ab.png)'
- en: Qubits are made up of controlled particles and the means of control (for example,
    devices that trap particles and switch them from one state to another).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 量子比特由受控粒子和控制手段（例如，捕获粒子并将它们从一个状态切换到另一个状态的设备）组成。
- en: Superposition
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 叠加
- en: 'Wikipedia defines **superposition** as:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 维基百科将**叠加**定义为：
- en: '"... a fundamental principle of quantum mechanics. It states that, much like
    waves in classical physics, any two (or more) quantum states can be added together
    ("superposed") and the result will be another valid quantum state; and conversely,
    every quantum state can be represented as a sum of two or more other distinct
    states. Mathematically, it refers to a property of solutions to the Schrodinger
    equation; since the Schrodinger equation is linear, any linear combination of
    solutions will also be a solution."'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '"...量子力学的一个基本原理。它指出，与经典物理学中的波类似，任何两个（或更多）量子状态可以相加（“叠加”），其结果将是另一个有效的量子状态；反之，每个量子状态都可以表示为两个或更多其他不同状态的和。在数学上，它指的是薛定谔方程解的性质；由于薛定谔方程是线性的，任何解的线性组合也将是解。"'
- en: What that really means is that a quantum system can be in multiple states at
    the same time when not being observed. They can exist across all possible states
    simultaneously. Think of a windy day on a pond with lots of waves. No doubt you've
    seen them overlapping at some point. That is a brutally simplistic explanation
    of superposition in a nutshell.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上意味着，当量子系统没有被观察时，它可以同时处于多个状态。它们可以同时存在于所有可能的状态中。想象一下风大的日子里池塘上有很多波浪。毫无疑问，你看到它们在某些时候是重叠的。这就是量子叠加的简单粗暴的解释。
- en: Teleportation
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 超光速
- en: In quantum computing, **teleportation** refers to the method of moving a quantum
    state from one location to another without having to move any physical particles.
    This process is usually accompanied by **entanglement** between the sending and
    receiving locations. Teleportation of a quantum state uses the phenomenon of quantum
    entanglement (our next topic) as a means of transmission. When two or more particles
    are entangled, their quantum states are interdependent, no matter how far apart
    they are. In effect, they act as a single quantum object.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在量子计算中，**超光速**指的是将量子状态从一个位置移动到另一个位置的方法，而不需要移动任何物理粒子。这个过程通常伴随着发送和接收位置之间的**纠缠**。量子状态的传输使用量子纠缠现象（我们下一个话题）作为手段。当两个或更多粒子纠缠在一起时，它们的量子状态是相互依赖的，无论它们相隔多远。实际上，它们作为一个单一的量子对象起作用。
- en: Entanglement
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 量子纠缠
- en: Quantum entanglement is a physical phenomenon that occurs when pairs or groups
    of particles are generated or interact in ways such that the state of each particle
    cannot be described independently of the state of the other, even when the particles
    are separated by a large distance—instead, a quantum state must be described for
    the system as a whole.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 量子纠缠是一种物理现象，当成对或成组的粒子以某种方式生成或相互作用，使得每个粒子的状态不能独立于其他粒子的状态来描述，即使粒子之间相隔很远——相反，必须为整个系统描述一个量子状态。
- en: Maybe a more visual example is in order. Let say that you have todays newspaper,
    and that it's 100 pages in length. If you ready 10 pages, you would know 10% of
    the content. If you read another 10 pages, you'd now know 20% of the content,
    and so on. However, if the newspaper was highly entangled, if you read 10 pages
    you would know almost nothing. Why, because the information is in between those
    pages, not on them. So you'd have to figure out a way to read all of the pages
    at once.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 或许需要一个更直观的例子。假设你有一份今天的报纸，它有100页长。如果你阅读了10页，你就知道了10%的内容。如果你再阅读另外10页，你现在就知道了20%的内容，以此类推。然而，如果报纸非常复杂，如果你阅读了10页，你几乎什么也不知道。为什么？因为信息分布在那些页面之间，而不是在页面上。所以你必须想出一个方法一次性阅读所有页面。
- en: Now that we've described those terms, let's show you a quick sample from Microsoft's
    quantum computing SDK. As we mentioned, quantum computing is in its infancy at
    the time of writing, so the best we can do is show you where it's heading. We'll
    do that with a very brief example, and then leave it up to you if you wish to
    learn more.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经描述了这些术语，让我们向您展示一个来自微软量子计算SDK的快速示例。正如我们提到的，在撰写本文时，量子计算还处于起步阶段，所以我们能做的最好的就是向您展示它的方向。我们将用一个非常简短的例子来做到这一点，然后如果您愿意，您可以继续学习。
- en: 'So what does a quantum computing program look like? Like this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，量子计算程序看起来是什么样子呢？就像这样：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Yep, that's it! Well, sort of. You see, a quantum computing program using the
    Microsoft quantum SDK is comprised of two parts. The first is the C# component
    you see here. Actually, it can be C#, Python, and several other languages on the
    frontend. On the backend, which we will see in a moment, is the quantum side of
    things, written in Q#; that's Microsoft's new language for quantum computing.
    Each Q# operation generates a corresponding C# class of the same name, which will
    have a `Run` method. This method is asynchronous because the operation will run
    asynchronously on the quantum computer.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，就是这样！好吧，差不多。你看，使用微软量子SDK的量子计算程序由两部分组成。第一部分是你在这里看到的C#组件。实际上，前端可以是C#、Python以及几种其他语言。后端，我们稍后会看到，是量子部分，用Q#编写；这是微软的新量子计算语言。每个Q#操作都会生成一个同名的C#类，该类将有一个`Run`方法。这个方法是异步的，因为操作将在量子计算机上异步运行。
- en: 'According to the Microsoft documentation on Q#:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 根据微软关于Q#的文档：
- en: '"Q# (Q-sharp) is a domain-specific programming language used for expressing
    quantum algorithms. It is to be used for writing sub-programs that execute on
    an adjunct quantum processor, under the control of a classical host program and
    computer.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '"Q#（Q-Sharp）是一种用于表达量子算法的领域特定编程语言。它用于编写在经典主机程序和计算机控制下运行的子程序，在辅助量子处理器上执行。'
- en: Q# provides a small set of primitive types, along with two ways (arrays and
    tuples) for creating new, structured types. It supports a basic procedural model
    for writing programs, with loops and if/then statements. The top-level constructs
    in Q# are user defined types, operations, and functions."
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Q#提供了一组原始类型，以及两种创建新结构类型的方式（数组和解包）。它支持一个基本的程序模型来编写程序，包括循环和if/then语句。Q#中的顶级构造是用户定义的类型、操作和函数。
- en: 'So let''s talk about what our C# code does. It simply sends a message using
    teleportation (and now you know why we started with terminology!). Let''s take
    a look at the backend and see what''s going on:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们来谈谈我们的C#代码做了什么。它只是通过量子传输（现在你知道我们为什么从术语开始！）发送一条消息。让我们看看后端，看看发生了什么：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: And now there are many thoughts running through your head. More questions than
    answers, right? Fear not; it's a bit more of a technical approach to writing software
    for sure, but we'll give you a little bit of insight so that it will all make
    sense.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在许多想法在你的脑海中涌现。问题比答案多，对吧？别担心；这确实是一种更技术性的软件编写方法，但我们会给你一点启示，让你明白这一切。
- en: '`H`, `CNOT`, `M`, what is going on? These are all Q#-defined functions and
    will exist in the Q# component file of your project. Let''s take a look at one
    of them and explain what''s going on.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`H`、`CNOT`、`M`，发生了什么？这些都是Q#定义的函数，并将存在于你的项目中的Q#组件文件中。让我们看看其中一个，并解释一下发生了什么。'
- en: CNOT
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CNOT
- en: This applies the `CNOT` gate (a controlled NOT gate) to a qubit. The CNOT gate
    is the "quantization" of a classical gate, and can be used to entangle and disentangle
    EPR states. For those interested in EPR, I would recommend reading up on The Einstein–Podolsky–Rosen
    paradox (EPR).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这将`CNOT`门（一个受控非门）应用于一个量子比特。CNOT门是经典门的“量子化”，可以用来纠缠和解纠缠EPR状态。对于那些对EPR感兴趣的人，我建议阅读一下爱因斯坦-波多尔斯基-罗森佯谬（EPR）。
- en: 'A `CNOT` gate is a set of rows and columns, similar to this:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`CNOT`门是一组行和列的集合，类似于这样：'
- en: '![](img/20e9ba8b-72f2-465d-8ff5-d0b5bed1c76c.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/20e9ba8b-72f2-465d-8ff5-d0b5bed1c76c.png)'
- en: H
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: H
- en: This function applies the **Hadamard** transformation to a single qubit. It
    will basically flip the qubit halfway instead of all the way. The Haramard transform
    is used in data encryption, as well as signal processing algorithms such as JPEG
    XR and MPEG-4 Audio Video Codec. In video compression it is usually used in order
    to for the sum of absolute transformed differences. The Hadamard transformation
    is also used in scientific methods such as mass spectroscopy and crystallography
    among others.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将**哈达玛**变换应用于单个量子比特。它基本上会翻转量子比特的一半，而不是全部。哈达玛变换用于数据加密，以及JPEG XR和MPEG-4音频视频编解码器等信号处理算法。在视频压缩中，它通常用于绝对变换差分的总和。哈达玛变换还用于质谱学、晶体学等科学方法中。
- en: 'Currently, the Hadamard function is defined as:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，哈达玛函数定义为：
- en: '![](img/d9cda2d4-9664-4781-a145-b5f5402bd087.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d9cda2d4-9664-4781-a145-b5f5402bd087.png)'
- en: M
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: M
- en: 'This measures a single qubit in the **Pauli-Z** basis such that the output
    result is given by the distribution. The `M` operation is defined as:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这测量单个量子比特在**泡利Z**基下的状态，输出结果由分布给出。`M`操作定义为：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: How does the Q# language differ from C#? Here are a few points.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Q#语言与C#有何不同？以下是一些要点。
- en: The `using` statement is different from that of C#. It's used to allocate an
    array of qubits for processing. Like the `using` statement in C#, the qubits are
    released at the end of the `using` statement. There are no qubits that are used
    for the entire lifetime of the application.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`using`语句与C#中的不同。它用于为处理分配量子比特数组。与C#中的`using`语句类似，量子比特在`using`语句结束时被释放。在整个应用程序的生命周期中，没有量子比特被使用。'
- en: Q# has a different `for` loop that is used to iterate through a range. There
    is no direct equivalent of a C# `for` loop.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Q#有一个不同的`for`循环，用于遍历范围。没有C# `for`循环的直接等效。
- en: Q#, by default, has all variables as immutable, meaning that once they are assigned,
    they cannot be changed. There is a `let` keyword that will allow binding of the
    variable. Operational arguments are always immutable regardless. That being said,
    there is (at the time of writing) the ability to declare a variable with the `mutable`
    keyword and set the value later using the `set` statement.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Q#中的所有变量都是不可变的，这意味着一旦它们被分配，就不能更改。有一个`let`关键字可以用来绑定变量。操作参数始终是不可变的。尽管如此，(在撰写本文时)有声明变量并使用`set`语句稍后设置其值的能力。
- en: Summary
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Well folks, I hope you enjoyed reading this book as much as I did writing it.
    Remember, there is so much to cover, and things expand/change on a daily basis!
    For the next book in our series, I plan on diving deeper into the world of deep
    learning and really explore the internals of some interesting things.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我希望你们阅读这本书的乐趣和我写作时的乐趣一样。记住，还有很多东西要介绍，而且每天都有新的发展和变化！在系列书的下一本书中，我计划深入探索深度学习的世界，并真正探索一些有趣事物的内部。
- en: For now, I hope you've found a way to take up these invaluable open source projects
    and make them a part of your daily life. Whether you are a machine learning developer,
    a data scientist, or just a regular C# developer interested in all of the previous,
    there's something for everyone in this book. Explore the open source projects,
    their samples, and test cases; build a framework that allows you to integrate
    these into your daily life.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我希望你们已经找到了一种方法来接受这些宝贵的开源项目，并将它们融入到你们的日常生活中。无论你是机器学习开发者、数据科学家，还是对上述所有内容都感兴趣的普通C#开发者，这本书中都有适合每个人的内容。探索开源项目、它们的示例和测试用例；构建一个框架，允许你将它们整合到你的日常生活中。
- en: For now, thank you so very much for reading this book, and I wish you all the
    best in your future endeavors of machine learning! I want to thank all those involved
    in creating this book and bringing it to market. The Packt team has been so amazingly
    helpful and courteous, and has made the process easy and fun. To all the proofreaders
    out there, thank you so much for your time and effort. Your comments have helped
    to make this book so much better.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，非常感谢您阅读这本书，并祝您在未来的机器学习努力中一切顺利！我想感谢所有参与创建这本书并将其推向市场的人。Packt团队非常乐于助人且礼貌，使整个过程变得简单而有趣。对所有校对者，非常感谢您的时间和努力。您的评论帮助使这本书变得更好。
