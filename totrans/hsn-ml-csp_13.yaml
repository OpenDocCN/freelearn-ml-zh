- en: Quantum Computing – The Future
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will end this series with the beginning of another topic, **quantum computing**.
    Quantum computing is the future, it's coming, and it's real. It uses quantum-mechanical
    phenomena, such as superposition and entanglement, and bases its computations
    on something called **quantum bits** (**qubits**). Where normal computers are
    transistor-based and use the ever-famous one and zero, quantum computing uses
    qubits, which can be in superpositions of a state, not just on or off.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, quantum computing is still in its infancy, but progress
    is being made. As such, this chapter will be short, but we want to expose you
    to the future so that you are aware.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Superposition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Teleportation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many experiments are being run, and Microsoft has released its quantum computing
    **Software Development Kit** (**SDK**). Both Microsoft and IBM are developing
    their own versions of quantum computers. But before we get to that, let's go over
    a few terms you'll need to know. These will go into your super buzzword-compliant
    checklist!
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a **Bloch sphere**, which is a qubit representation in **Hilbert space**,
    and it is the most fundamental component of quantum computing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/60afb700-6c6f-4139-b162-ea478afc2470.png)'
  prefs: []
  type: TYPE_IMG
- en: A classical computer has its memory made up of bits—ones and zeros. A quantum
    computer, however, is comprised of a series of qubits. A single qubit can represent
    a one, a zero, or any quantum superposition of these two qubit states. A single
    qubit can be in any one of two states. A pair of qubits can be in any superposition
    of two states, and three qubits can be in any superposition of eight states. So,
    quantum computers can be in superpositions of many different states, whereas conventional
    computers can only be in one of those states at any given moment in time.
  prefs: []
  type: TYPE_NORMAL
- en: 'A quantum computer operates using quantum gates and quantum logic gates (similar
    to logic gates for a conventional computer), and the problem it is trying to solve
    is encoded by setting the initial values of the qubits, just like a conventional
    computer does. Quantum algorithms are considered mostly probabilistic, in that
    they provide a correct solution only with a known probability:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ac1d09ff-d2d3-416c-bc7a-145518ef28ab.png)'
  prefs: []
  type: TYPE_IMG
- en: Qubits are made up of controlled particles and the means of control (for example,
    devices that trap particles and switch them from one state to another).
  prefs: []
  type: TYPE_NORMAL
- en: Superposition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Wikipedia defines **superposition** as:'
  prefs: []
  type: TYPE_NORMAL
- en: '"... a fundamental principle of quantum mechanics. It states that, much like
    waves in classical physics, any two (or more) quantum states can be added together
    ("superposed") and the result will be another valid quantum state; and conversely,
    every quantum state can be represented as a sum of two or more other distinct
    states. Mathematically, it refers to a property of solutions to the Schrodinger
    equation; since the Schrodinger equation is linear, any linear combination of
    solutions will also be a solution."'
  prefs: []
  type: TYPE_NORMAL
- en: What that really means is that a quantum system can be in multiple states at
    the same time when not being observed. They can exist across all possible states
    simultaneously. Think of a windy day on a pond with lots of waves. No doubt you've
    seen them overlapping at some point. That is a brutally simplistic explanation
    of superposition in a nutshell.
  prefs: []
  type: TYPE_NORMAL
- en: Teleportation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In quantum computing, **teleportation** refers to the method of moving a quantum
    state from one location to another without having to move any physical particles.
    This process is usually accompanied by **entanglement** between the sending and
    receiving locations. Teleportation of a quantum state uses the phenomenon of quantum
    entanglement (our next topic) as a means of transmission. When two or more particles
    are entangled, their quantum states are interdependent, no matter how far apart
    they are. In effect, they act as a single quantum object.
  prefs: []
  type: TYPE_NORMAL
- en: Entanglement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Quantum entanglement is a physical phenomenon that occurs when pairs or groups
    of particles are generated or interact in ways such that the state of each particle
    cannot be described independently of the state of the other, even when the particles
    are separated by a large distance—instead, a quantum state must be described for
    the system as a whole.
  prefs: []
  type: TYPE_NORMAL
- en: Maybe a more visual example is in order. Let say that you have todays newspaper,
    and that it's 100 pages in length. If you ready 10 pages, you would know 10% of
    the content. If you read another 10 pages, you'd now know 20% of the content,
    and so on. However, if the newspaper was highly entangled, if you read 10 pages
    you would know almost nothing. Why, because the information is in between those
    pages, not on them. So you'd have to figure out a way to read all of the pages
    at once.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've described those terms, let's show you a quick sample from Microsoft's
    quantum computing SDK. As we mentioned, quantum computing is in its infancy at
    the time of writing, so the best we can do is show you where it's heading. We'll
    do that with a very brief example, and then leave it up to you if you wish to
    learn more.
  prefs: []
  type: TYPE_NORMAL
- en: 'So what does a quantum computing program look like? Like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Yep, that's it! Well, sort of. You see, a quantum computing program using the
    Microsoft quantum SDK is comprised of two parts. The first is the C# component
    you see here. Actually, it can be C#, Python, and several other languages on the
    frontend. On the backend, which we will see in a moment, is the quantum side of
    things, written in Q#; that's Microsoft's new language for quantum computing.
    Each Q# operation generates a corresponding C# class of the same name, which will
    have a `Run` method. This method is asynchronous because the operation will run
    asynchronously on the quantum computer.
  prefs: []
  type: TYPE_NORMAL
- en: 'According to the Microsoft documentation on Q#:'
  prefs: []
  type: TYPE_NORMAL
- en: '"Q# (Q-sharp) is a domain-specific programming language used for expressing
    quantum algorithms. It is to be used for writing sub-programs that execute on
    an adjunct quantum processor, under the control of a classical host program and
    computer.'
  prefs: []
  type: TYPE_NORMAL
- en: Q# provides a small set of primitive types, along with two ways (arrays and
    tuples) for creating new, structured types. It supports a basic procedural model
    for writing programs, with loops and if/then statements. The top-level constructs
    in Q# are user defined types, operations, and functions."
  prefs: []
  type: TYPE_NORMAL
- en: 'So let''s talk about what our C# code does. It simply sends a message using
    teleportation (and now you know why we started with terminology!). Let''s take
    a look at the backend and see what''s going on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: And now there are many thoughts running through your head. More questions than
    answers, right? Fear not; it's a bit more of a technical approach to writing software
    for sure, but we'll give you a little bit of insight so that it will all make
    sense.
  prefs: []
  type: TYPE_NORMAL
- en: '`H`, `CNOT`, `M`, what is going on? These are all Q#-defined functions and
    will exist in the Q# component file of your project. Let''s take a look at one
    of them and explain what''s going on.'
  prefs: []
  type: TYPE_NORMAL
- en: CNOT
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This applies the `CNOT` gate (a controlled NOT gate) to a qubit. The CNOT gate
    is the "quantization" of a classical gate, and can be used to entangle and disentangle
    EPR states. For those interested in EPR, I would recommend reading up on The Einstein–Podolsky–Rosen
    paradox (EPR).
  prefs: []
  type: TYPE_NORMAL
- en: 'A `CNOT` gate is a set of rows and columns, similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/20e9ba8b-72f2-465d-8ff5-d0b5bed1c76c.png)'
  prefs: []
  type: TYPE_IMG
- en: H
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This function applies the **Hadamard** transformation to a single qubit. It
    will basically flip the qubit halfway instead of all the way. The Haramard transform
    is used in data encryption, as well as signal processing algorithms such as JPEG
    XR and MPEG-4 Audio Video Codec. In video compression it is usually used in order
    to for the sum of absolute transformed differences. The Hadamard transformation
    is also used in scientific methods such as mass spectroscopy and crystallography
    among others.
  prefs: []
  type: TYPE_NORMAL
- en: 'Currently, the Hadamard function is defined as:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d9cda2d4-9664-4781-a145-b5f5402bd087.png)'
  prefs: []
  type: TYPE_IMG
- en: M
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This measures a single qubit in the **Pauli-Z** basis such that the output
    result is given by the distribution. The `M` operation is defined as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: How does the Q# language differ from C#? Here are a few points.
  prefs: []
  type: TYPE_NORMAL
- en: The `using` statement is different from that of C#. It's used to allocate an
    array of qubits for processing. Like the `using` statement in C#, the qubits are
    released at the end of the `using` statement. There are no qubits that are used
    for the entire lifetime of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Q# has a different `for` loop that is used to iterate through a range. There
    is no direct equivalent of a C# `for` loop.
  prefs: []
  type: TYPE_NORMAL
- en: Q#, by default, has all variables as immutable, meaning that once they are assigned,
    they cannot be changed. There is a `let` keyword that will allow binding of the
    variable. Operational arguments are always immutable regardless. That being said,
    there is (at the time of writing) the ability to declare a variable with the `mutable`
    keyword and set the value later using the `set` statement.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Well folks, I hope you enjoyed reading this book as much as I did writing it.
    Remember, there is so much to cover, and things expand/change on a daily basis!
    For the next book in our series, I plan on diving deeper into the world of deep
    learning and really explore the internals of some interesting things.
  prefs: []
  type: TYPE_NORMAL
- en: For now, I hope you've found a way to take up these invaluable open source projects
    and make them a part of your daily life. Whether you are a machine learning developer,
    a data scientist, or just a regular C# developer interested in all of the previous,
    there's something for everyone in this book. Explore the open source projects,
    their samples, and test cases; build a framework that allows you to integrate
    these into your daily life.
  prefs: []
  type: TYPE_NORMAL
- en: For now, thank you so very much for reading this book, and I wish you all the
    best in your future endeavors of machine learning! I want to thank all those involved
    in creating this book and bringing it to market. The Packt team has been so amazingly
    helpful and courteous, and has made the process easy and fun. To all the proofreaders
    out there, thank you so much for your time and effort. Your comments have helped
    to make this book so much better.
  prefs: []
  type: TYPE_NORMAL
