- en: Deploying Computer Vision Applications on Jetson TX1
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Jetson TX1上部署计算机视觉应用
- en: The previous chapter described the installation of OpenCV and CUDA on a Jetson
    TX1 development board. This chapter will describe how to use these features on
    the board. The properties of the Jetson TX1 GPU that make it useful for parallel
    processing will be described in detail. The chapter will also describe how we
    can execute the CUDA and C++ codes, seen earlier in this book, on Jetson TX1\.
    It will also demonstrate the performance of the Jetson TX1 GPU in executing CUDA
    code. The primary motive of this chapter will be to demonstrate the use of Jetson
    TX1 in deploying image- and video-processing applications. Basic image-processing
    applications such as image reading, displaying, addition, thresholding, and filtering
    are taken as examples to demonstrate the use of Jetson TX1 for computer vision
    applications. Moreover, camera interfacing is important for the deployment of
    the board in real-life scenarios. This chapter will describe the procedure to
    use the onboard camera or USB camera for video-capturing and processing applications.
    How to deploy some advanced applications, like face detection and background subtraction,
    will be explained in the last part of the chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章介绍了在Jetson TX1开发板上安装OpenCV和CUDA的过程。本章将描述如何使用这些功能。将详细描述Jetson TX1 GPU的属性，这些属性使其适用于并行处理。本章还将描述如何在我们这本书中之前看到的CUDA和C++代码在Jetson
    TX1上执行。它还将展示Jetson TX1 GPU在执行CUDA代码时的性能。本章的主要动机将是展示如何使用Jetson TX1部署图像和视频处理应用。以基本的图像处理应用，如图像读取、显示、加法、阈值和滤波为例，来展示如何使用Jetson
    TX1进行计算机视觉应用。此外，摄像头接口对于在实际场景中部署该板非常重要。本章将描述使用板载摄像头或USB摄像头进行视频捕获和处理应用的步骤。本章的最后部分将解释如何部署一些高级应用，如人脸检测和背景减法。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Device properties of a Jetson TX1 board
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jetson TX1板的设备属性
- en: Running CUDA programs on a Jetson TX1 board
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Jetson TX1板上运行CUDA程序
- en: Image processing on a Jetson TX1 board
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Jetson TX1板上进行图像处理
- en: Interfacing cameras with a Jetson TX1 development board
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将摄像头与Jetson TX1开发板连接
- en: Advanced applications such as face detection, eye detection, and background
    subtraction on a Jetson TX1 development board
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Jetson TX1开发板上执行高级应用，如人脸检测、眼检测和背景减法
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'This chapter requires a good understanding of the OpenCV, CUDA, and any programming
    language. It also requires any Nvidia GPU development board, like Jetson TK1,
    TX1, or TX2\. The code files used in this chapter can be downloaded from the following
    GitHub link: [https://github.com/PacktPublishing/Hands-On-GPU-Accelerated-Computer-Vision-with-OpenCV-and-CUDA](https://github.com/PacktPublishing/Hands-On-GPU-Accelerated-Computer-Vision-with-OpenCV-and-CUDA).'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章需要具备对OpenCV、CUDA和任何编程语言的良好理解。它还需要任何Nvidia GPU开发板，如Jetson TK1、TX1或TX2。本章使用的代码文件可以从以下GitHub链接下载：[https://github.com/PacktPublishing/Hands-On-GPU-Accelerated-Computer-Vision-with-OpenCV-and-CUDA](https://github.com/PacktPublishing/Hands-On-GPU-Accelerated-Computer-Vision-with-OpenCV-and-CUDA)。
- en: 'Check out the following video to see the Code in Action:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 观看以下视频以查看代码的实际运行情况：
- en: '[http://bit.ly/2xDtHhm](http://bit.ly/2xDtHhm)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://bit.ly/2xDtHhm](http://bit.ly/2xDtHhm)'
- en: Device properties of Jetson TX1 GPU
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Jetson TX1 GPU的设备属性
- en: CUDA provides a simple interface to determine the capabilities of a GPU device,
    which is Tegra X1 present on a Jetson TX1 board. It is important to find out the
    properties of the device that will help in writing optimal programs for it. The
    program to find the properties of the device is available in the CUDA sample programs
    installed with JetPack in the home folder. You can also run the program we developed
    in the second chapter to find out the device properties.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: CUDA提供了一个简单的接口来确定GPU设备的性能，这是Jetson TX1板上存在的Tegra X1。了解设备的属性对于编写针对它的优化程序非常重要。查找设备属性的程序包含在JetPack安装的CUDA示例程序中，位于主文件夹中。您还可以运行我们在第二章中开发的程序来查找设备属性。
- en: 'The output of the program on an Nvidia Tegra X1 GPU is as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 程序在Nvidia Tegra X1 GPU上的输出如下：
- en: '![](img/3691873c-0729-4c74-a7db-d8605b91b509.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3691873c-0729-4c74-a7db-d8605b91b509.png)'
- en: The JetPack 3.3 installs the CUDA 9.0 runtime version. The global memory for
    the GPU device is around 4 GB, with a GPU clock speed of around 1 GHz. This clock
    speed is slower than the GeForce 940 GPU mentioned earlier in this book. The memory
    clock speed is only 13 MHz compared to 2.505 GHz on GeForce 940, which makes Jetson
    TX1 slower. The L2 cache is 256 KB compared to 1 MB on GeForce 940\. Most of the
    other properties are similar to GeForce 940.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: JetPack 3.3安装了CUDA 9.0运行时版本。GPU设备的全局内存大约为4 GB，GPU时钟速度约为1 GHz。这个时钟速度比本书前面提到的GeForce
    940 GPU慢。内存时钟速度仅为13 MHz，而GeForce 940为2.505 GHz，这使得Jetson TX1较慢。与GeForce 940的1
    MB相比，L2缓存为256 KB。大多数其他属性与GeForce 940相似。
- en: The maximum number of threads that can be launched per block in *X*, *Y*, and
    *Z* directions are 1,024, 1,024, and 64 respectively. These numbers should be
    used while determining the number of parallel threads to be launched from a program.
    The same care should be taken while launching the number of parallel blocks per
    grid.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在X、Y和Z方向上，每个块可以启动的最大线程数分别为1,024、1,024和64。在确定从程序中启动的并行线程数量时，应使用这些数字。在启动每个网格的并行块数量时，也应采取相同的谨慎措施。
- en: To summarize, we have seen the device properties of the Tegra X1 GPU available
    on a Jetson TX1 development board. It is an embedded board so memory is available
    and the clock rate is comparatively slower than for GPU devices like GeForce 940
    that comes with a laptop. Still, it is way faster than embedded platforms like
    Arduino and Raspberry Pi. It can be easily used in deploying computer vision applications
    that require high computational power. Now that we have seen the device properties,
    we will start by developing the first program using CUDA on Jetson TX1\.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，我们已经看到了Jetson TX1开发板上可用的Tegra X1 GPU的设备属性。它是一个嵌入式板，因此内存可用，时钟速度相对于笔记本电脑中配备的GPU设备（如GeForce
    940）较慢。然而，它比Arduino和Raspberry Pi等嵌入式平台快得多。它可以很容易地用于部署需要高性能计算能力的计算机视觉应用。现在我们已经看到了设备属性，我们将从在Jetson
    TX1上使用CUDA开发第一个程序开始。
- en: Basic CUDA program on Jetson TX1
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于Jetson TX1的CUDA基础程序
- en: In this section, the example of adding two large arrays is taken to demonstrate
    the use of a Jetson TX1 development board in executing CUDA programs. The performance
    of the program is also measured using CUDA events.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们通过添加两个大数组的示例来展示使用Jetson TX1开发板执行CUDA程序。程序的性能也使用CUDA事件进行了测量。
- en: 'The kernel function for adding two large arrays with 50,000 elements is as
    follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 添加具有50,000个元素的两个大数组的内核函数如下：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The kernel function takes two device pointers, which point to input arrays
    as input, and one device pointer, which points to output arrays in the device
    memory as arguments. The thread ID of the current kernel execution is calculated
    and array elements indexed by the thread index are added by the kernel. If the
    number of kernels launched is less than the number of array elements, then the
    same kernel will add `Array` elements offset by the block dimension as shown in
    the `while` loop. The `main` function for adding two arrays is as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 内核函数接收两个设备指针，这些指针指向输入数组作为输入，以及一个设备指针，该指针指向设备内存中输出数组的参数。计算当前内核执行的线程ID，并由内核将线程索引索引的数组元素相加。如果启动的内核数量少于数组元素数量，则相同的内核将在`while`循环中添加由块维度偏移的`Array`元素。添加两个数组的`main`函数如下：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Two host arrays are defined and memory is allocated to them using the `cudaMalloc`
    function. They are initialized to some random values and uploaded to the device
    memory. Two CUDA events are created to measure the performance of the CUDA program.
    The kernel is launched with 1,024 blocks in parallel, with each block having 1,024
    threads. These numbers are taken from the device properties, as explained in the
    last section. The result from the kernel function is transferred to the host memory.
    The time taken by the kernel function is recorded by the `e_start` and `e_stop`
    events, before and after the kernel launch. The time taken by the function is
    displayed on the console.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了两个主机数组，并使用`cudaMalloc`函数为它们分配内存。它们被初始化为一些随机值，并上传到设备内存。创建了两个CUDA事件来测量CUDA程序的性能。内核以并行方式启动了1,024个块，每个块有1,024个线程。这些数字来自设备属性，如上一节所述。内核函数的结果被传输到主机内存。内核函数的时间由`e_start`和`e_stop`事件在内核启动前后记录。函数所花费的时间显示在控制台上。
- en: 'The following code is added to verify the correctness of the result, computed
    by the GPU, and to clean up the memory used by the program:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码被添加以验证由GPU计算的结果的正确性，并清理程序使用的内存：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The same array addition operation is performed on the CPU and compared with
    the result obtained from the GPU to verify whether the GPU has computed the result
    correctly or not. This is also displayed on the console. All the memory used by
    the program is freed up by using the `cudaFree` function.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在CPU上执行相同的数组加法操作，并与从GPU获得的结果进行比较，以验证GPU是否正确计算了结果。这也在控制台上显示。通过使用`cudaFree`函数释放程序使用的所有内存。
- en: 'The following two commands need to be run from the Terminal to execute the
    program. The program should be in the current working directory:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 需要从终端运行以下两个命令来执行程序。程序应位于当前工作目录中：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `nvcc` command is used to compile CUDA code with an Nvidia CUDA compiler.
    The file name is passed as an argument to the command. The name of the object
    file, which will be created by the compiler, is specified with the `-o` option.
    This filename will be used to execute the program. This is done by the second
    command. The output of the program is as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`nvcc`命令通过Nvidia CUDA编译器编译CUDA代码。文件名作为命令的参数传递。编译器将创建的目标文件名通过`-o`选项指定。此文件名将用于执行程序。这是通过第二个命令完成的。程序输出如下：
- en: '![](img/adb67283-4e75-494c-978d-b230fc682b6c.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/adb67283-4e75-494c-978d-b230fc682b6c.png)'
- en: As can be seen from the result, Jetson TX1 takes `3.4ms` to compute the sum
    of two arrays with 50,000 elements, which is slower than GeForce 940 used in the
    third chapter of this book, but still it is faster than sequential execution on
    a CPU.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 从结果可以看出，Jetson TX1计算包含50,000个元素的两个数组的和需要`3.4ms`，这比本书第三章中使用的GeForce 940慢，但仍然比CPU上的顺序执行快。
- en: To summarize, this section demonstrated the use of a Jetson TX1 development
    board in the execution of CUDA programs. The syntax is the same as we have seen
    earlier in this book. So all CUDA programs developed earlier in the book can be
    executed on Jetson TX1 without much modification. The procedure to execute the
    program is also described. The next section will describe the use of Jetson TX1
    for image-processing applications.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，本节展示了在执行CUDA程序中使用Jetson TX1开发板的方法。语法与我们在这本书中之前看到的相同。因此，书中之前开发的全部CUDA程序都可以在Jetson
    TX1上执行，无需太多修改。程序执行的步骤也进行了描述。下一节将描述使用Jetson TX1进行图像处理应用的方法。
- en: Image processing on Jetson TX1
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Jetson TX1上进行的图像处理
- en: This section will demonstrate the use of Jetson TX1 in the deployment of image-processing
    applications. We will again use OpenCV and CUDA for accelerating computer vision
    applications on Jetson TX1\. In the last chapter, we saw the installation procedure
    for JetPack 3.3, which contains OpenCV and CUDA. But in the latest JetPack, OpenCV
    is not compiled with CUDA support nor has it GStreamer support, which is needed
    for accessing the camera from the code. So, it is a good idea to remove the OpenCV
    installation that comes with JetPack and to compile the new version of OpenCV
    with CUDA and GStreamer support. The next section will demonstrate the procedure
    to do that.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将展示在部署图像处理应用中使用Jetson TX1的方法。我们还将再次使用OpenCV和CUDA来加速Jetson TX1上的计算机视觉应用。在上一章中，我们看到了包含OpenCV和CUDA的JetPack
    3.3的安装过程。但在最新的JetPack中，OpenCV没有编译带有CUDA支持，也没有GStreamer支持，这是从代码中访问摄像头所必需的。因此，删除JetPack附带的OpenCV安装，并编译带有CUDA和GStreamer支持的OpenCV新版本是一个好主意。下一节将展示如何执行此过程。
- en: Compiling OpenCV with CUDA support (if necessary)
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: （编译带有CUDA支持的OpenCV，如果需要）
- en: 'Though OpenCV which comes with JetPack, can work with a new OpenCV installation,
    it is a good idea to remove the old installation first and then start a new one.
    This will avoid unnecessary confusion. To accomplish that, the following steps
    have to be performed:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管JetPack附带的OpenCV可以与新安装的OpenCV一起工作，但先删除旧安装然后开始新的安装是一个好主意。这将避免不必要的混淆。为了完成这个任务，必须执行以下步骤：
- en: 'Run the following command from the Terminal:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从终端运行以下命令：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Make sure that all the packages installed are the latest versions. If that
    is not the case, then you can update them by running the following two commands:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保安装的所有软件包都是最新版本。如果不是这样，可以通过运行以下两个命令来更新它们：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The latest versions of cmake and gcc compiler are needed to compile OpenCV
    from the source so they can be installed by running the following two commands:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译从源代码编译 OpenCV 需要最新的 cmake 和 gcc 编译器版本，因此可以通过运行以下两个命令来安装：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'There are some dependencies that need to be installed to compile OpenCV with
    GStreamer support. This can be done by the following command:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要安装一些依赖项以编译支持 GStreamer 的 OpenCV。这可以通过以下命令完成：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Download the source for the latest version of OpenCV and extract it in a folder
    by executing the following commands:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行以下命令下载 OpenCV 最新版本的源代码，并将其提取到一个文件夹中：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now go inside the `opencv` folder and create the `build` directory. Then go
    inside this newly created `build` directory. These can be done by executing the
    following commands from Command Prompt.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，进入 `opencv` 文件夹，创建 `build` 目录。然后进入这个新创建的 `build` 目录。这些可以通过从命令提示符执行以下命令来完成。
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `cmake` command is used to compile `opencv` with CUDA support. Make sure
    the `WITH_CUDA` flag is set to `ON` in this command. Note `CUDA_ARCH_BIN` should
    be set to `5.3` for a Jetson TX1 development board and `6.2` for Jetson TX2\.
    The examples are not built to save time and space. The entire `cmake` command
    is as follows:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`cmake` 命令用于编译具有 CUDA 支持的 `opencv`。确保在此命令中将 `WITH_CUDA` 标志设置为 `ON`。注意，对于 Jetson
    TX1 开发板，`CUDA_ARCH_BIN` 应设置为 `5.3`，对于 Jetson TX2，应设置为 `6.2`。示例没有构建以节省时间和空间。整个
    `cmake` 命令如下：'
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: It will start the configuration and creation of `makefile`. The `cmake` command
    will create `makefile` in the `build` directory after successful configuration.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它将启动配置和创建 `makefile` 的过程。在配置成功后，`cmake` 命令将在 `build` 目录中创建 `makefile`。
- en: To compile OpenCV using `makefile` execute the `make -j4` command from the command
    window.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用 `makefile` 编译 OpenCV，请在命令窗口中执行 `make -j4` 命令。
- en: After successful compilation, to install OpenCV you have to execute the command
    `sudo make install` from the command line.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译成功后，您必须从命令行执行 `sudo make install` 命令来安装 OpenCV。
- en: If these steps are executed successfully then OpenCV 3.4.0 will be installed
    with CUDA and GStreamer support on Jetson TX1, and any computer vision application
    made using OpenCV can be deployed on it. The next section will demonstrate simple
    image-processing operations on the board.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些步骤执行成功，则 OpenCV 3.4.0 将在 Jetson TX1 上安装，并支持 CUDA 和 GStreamer，使用 OpenCV 制作的任何计算机视觉应用都可以部署到它上面。下一节将演示在板上进行简单的图像处理操作。
- en: Reading and displaying images
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取和显示图像
- en: 'The first basic operation needed for any computer vision application is that
    of reading and displaying images that are stored on the disk. This section will
    demonstrate a simple code to do this operation on Jetson TX1\. The OpenCV syntax
    will not change much as we move from the GPU on the computer to the Jetson TX1
    development board. A few minor changes will be there. The code for reading and
    displaying images on Jetson TX1 is as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何计算机视觉应用，所需的基本操作之一是读取和显示存储在磁盘上的图像。本节将演示一个简单的代码，在 Jetson TX1 上执行此操作。当我们从计算机上的
    GPU 移动到 Jetson TX1 开发板时，OpenCV 语法不会改变太多。将有一些小的变化。在 Jetson TX1 上读取和显示图像的代码如下：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The necessary OpenCV libraries are included in the code. The image is read using
    the `imread` function inside the `Main` function. The image is read as a grayscale
    image because the second argument to the `imread` command is specified as `0`.
    To read an image as a color image, it can be specified as `1`. The `if` statement
    checks whether the image is read or not, and if it is not then the code is terminated
    after displaying an error on the console. When the name of the image is incorrect
    or the image is not stored in the specified path, then an error in reading an
    image can happen. This error is handled by the `if` statement. The image is displayed
    using the `imshow` command. The `waitKey` function is used to display the image
    until any key is pressed on the keyboard.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 必要的 OpenCV 库包含在代码中。图像是通过 `Main` 函数内的 `imread` 函数读取的。由于 `imread` 命令的第二个参数指定为
    `0`，因此图像被读取为灰度图像。要将图像读取为彩色图像，可以指定为 `1`。`if` 语句检查图像是否被读取，如果没有，则在控制台上显示错误后终止代码。当图像名称不正确或图像未存储在指定的路径时，可能会发生读取图像的错误。这个错误由
    `if` 语句处理。图像是通过 `imshow` 命令显示的。`waitKey` 函数用于显示图像，直到按下键盘上的任何键。
- en: 'The preceding code shown can be saved as the `image_read.cpp` file and executed
    using the following command from the Terminal. Make sure that the program file
    is stored in the current working directory of the Terminal:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 所示的前面代码可以保存为`image_read.cpp`文件，并使用以下命令从终端执行。请确保程序文件存储在终端的当前工作目录中：
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The output of the program is as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的输出如下：
- en: '![](img/e845b1c3-7dcf-4e95-98ba-48b43c16ec77.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e845b1c3-7dcf-4e95-98ba-48b43c16ec77.png)'
- en: This section demonstrated the procedure to read and display an image on Jetson
    TX1\. In the next section, we will see some more image-processing operations and
    also try to measure the performance of them on Jetson TX1.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 本节演示了在Jetson TX1上读取和显示图像的步骤。在下节中，我们将看到一些更多的图像处理操作，并尝试测量它们在Jetson TX1上的性能。
- en: Image addition
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图像加法
- en: 'This section will demonstrate the use of Jetson TX1 for simple image-processing
    applications like image addition. The intensities of pixels at the same location
    are added to construct the new image after addition. Suppose in two images, the
    pixel at (0,0) has intensity values 50 and 150 respectively, then the intensity
    value in the resultant image will be 200, which is the addition of the two intensity
    values. OpenCV addition is a saturated operation, which means that if an answer
    of addition goes above 255 then it will be saturated at 255\. The code to perform
    addition on Jetson TX1 is as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将演示使用Jetson TX1进行简单的图像处理应用，如图像加法。在加法后，相同位置的像素强度被相加以构建新的图像。假设在两个图像中，(0,0)位置的像素强度值分别为50和150，那么结果图像中的强度值将是200，这是两个强度值的和。OpenCV的加法操作是饱和操作，这意味着如果加法的结果超过255，则将饱和在255。在Jetson
    TX1上执行加法的代码如下：
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: One thing to be kept in mind while doing image addition is that both the images
    should be of the same size. If it is not the case, then they should be resized
    before addition. In the preceding code, two images of the same size are read from
    the disk and uploaded to the device memory for addition on a GPU. The `add` function
    from the `cv::cuda` module is used to perform image addition on the device. The
    resultant image is downloaded to the host and displayed on the console.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行图像加法时需要注意的一点是，两个图像应该具有相同的大小。如果不是这种情况，那么在加法之前应该将它们调整大小。在前面代码中，从磁盘读取了两个相同大小的图像，并将它们上传到设备内存中进行GPU上的加法。使用`cv::cuda`模块中的`add`函数在设备上执行图像加法。结果图像被下载到主机并在控制台上显示。
- en: 'The output of the program is as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的输出如下：
- en: '![](img/060e8009-68ad-4fe0-a469-d40c3aff8e01.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/060e8009-68ad-4fe0-a469-d40c3aff8e01.png)'
- en: 'The performance of image addition is also measured using the `cv::getTickCount()`
    and `cv::getTickFrequency()` functions. The time taken by the addition operation
    is displayed on the console as shown in the following screenshot:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`cv::getTickCount()`和`cv::getTickFrequency()`函数也测量了图像加法的性能。加法操作所需的时间显示在下面的屏幕截图上：
- en: '![](img/9e92015f-18e5-499d-998d-3a42d70b0232.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9e92015f-18e5-499d-998d-3a42d70b0232.png)'
- en: As can be seen from the preceding screenshot, it takes around `0.26ms` to add
    two images of the size 256 x 256 on Jetson TX1\. This is a very good performance
    for an embedded platform. It should be noted that performance should be measured
    before the `imshow` function to measure the accurate time for the addition operation.
    The `imshow` function takes more time to display an image, so the time measured
    will not be an accurate estimation of time taken to do an add operation.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述屏幕截图所示，在Jetson TX1上添加两个大小为256 x 256的图像大约需要`0.26ms`。这对于嵌入式平台来说是一个非常不错的性能。需要注意的是，在测量加法操作的准确时间之前，应该测量`imshow`函数。`imshow`函数显示图像需要更多的时间，因此测量的时间不会是加法操作所需时间的准确估计。
- en: Image thresholding
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图像阈值化
- en: This section will demonstrate the use of Jetson TX1 for more computationally
    intensive computer vision applications, like image thresholding. Image thresholding
    is a very simple image segmentation technique used to extract important regions
    from a grayscale image, based on certain intensity values. In this technique,
    if the pixel value is greater than a certain threshold value then it is assigned
    one value, or else it is assigned another value.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将演示使用Jetson TX1进行更复杂的计算机视觉应用，如图像阈值化。图像阈值化是一种非常简单的图像分割技术，用于根据某些强度值从灰度图像中提取重要区域。在这种技术中，如果像素值大于某个阈值值，则分配一个值，否则分配另一个值。
- en: 'OpenCV provides different types of thresholding techniques, and it is decided
    by the last argument of the function. These thresholding types are:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV提供了不同类型的阈值技术，这由函数的最后一个参数决定。这些阈值类型包括：
- en: '`cv:.THRES H_BINARY`: If the intensity of the pixel is greater than the threshold,
    then set the pixel intensity equal to the `maxVal` constant, or else set the pixel
    intensity to zero.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cv:.THRES H_BINARY`: 如果像素的强度大于阈值，则将像素强度设置为等于`maxVal`常量，否则将像素强度设置为等于零。'
- en: '`cv::THRESH_BINARY_INV`: If the intensity of the pixel is greater than the
    threshold, then set the pixel intensity equal to zero, or else set the pixel intensity
    to the `maxVal` constant.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cv::THRESH_BINARY_INV`: 如果像素的强度大于阈值，则将像素强度设置为等于零，否则将像素强度设置为`maxVal`常量。'
- en: '`cv::THRESH_TRUNC`: This is basically a truncation operation. If the intensity
    of the pixel is greater than the threshold, then set the pixel intensity equal
    to the threshold, or else keep the intensity value as it is.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cv::THRESH_TRUNC`: 这基本上是一个截断操作。如果像素的强度大于阈值，则将像素强度设置为等于阈值，否则保持强度值不变。'
- en: '`cv::THRESH_TOZERO`: If the intensity of the pixel is greater than the threshold,
    then keep the pixel intensity as it is, or else set the pixel intensity to zero.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cv::THRESH_TOZERO`: 如果像素的强度大于阈值，则保持像素强度不变，否则将像素强度设置为等于零。'
- en: '`cv::THRESH_TOZERO_INV`: If the intensity of the pixel is greater than the
    threshold, then set that pixel intensity equal to zero, or else keep the pixel
    intensity as it is.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cv::THRESH_TOZERO_INV`: 如果像素的强度大于阈值，则将该像素强度设置为等于零，否则保持像素强度不变。'
- en: 'The program to implement all these thresholding techniques using OpenCV and
    CUDA on Jetson TX1 is shown as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在Jetson TX1上使用OpenCV和CUDA实现所有这些阈值技术的程序如下所示：
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The function used for image thresholding in OpenCV and CUDA on a GPU is `cv::cuda::threshold`.
    This function has many arguments. The first argument is the source image, which
    should be a grayscale image. The second argument is the destination at which the
    result is to be stored. The third argument is the threshold value, which is used
    to segment the pixel values. The fourth argument is the `maxVal` constant, which
    represents the value to be given if the pixel value is more than the threshold
    value. The final argument is the thresholding methods discussed earlier. The output
    of the program that shows the original image and the output of five thresholding
    techniques is as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在OpenCV和CUDA的GPU上用于图像阈值化的函数是`cv::cuda::threshold`。此函数有许多参数。第一个参数是源图像，它应该是一个灰度图像。第二个参数是结果要存储的目标位置。第三个参数是阈值值，用于分割像素值。第四个参数是`maxVal`常量，表示如果像素值超过阈值值时赋予的值。最后一个参数是前面讨论过的阈值方法。以下程序显示了原始图像和五种阈值技术输出的输出：
- en: '![](img/97d3d2e4-1bbe-4207-a477-4016201eaa19.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/97d3d2e4-1bbe-4207-a477-4016201eaa19.png)'
- en: 'The performance of image thresholding is also measured using the `cv::getTickCount()`
    and `cv::getTickFrequency()` functions. The time taken by five thresholding operations
    is displayed on the console, as shown in the following screenshot:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`cv::getTickCount()`和`cv::getTickFrequency()`函数测量图像阈值化的性能。五个阈值操作所需的时间显示在控制台上，如下面的截图所示：
- en: '![](img/95e2352a-1d63-44ca-bcb5-702a117b41ad.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/95e2352a-1d63-44ca-bcb5-702a117b41ad.png)'
- en: It takes `0.32ms` to do five thresholding operations on Jetson TX1, which is
    again a very good performance for an image segmentation task on embedded platforms.
    The next section will describe the filtering operations on Jetson TX1.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在Jetson TX1上执行五个阈值操作需要`0.32ms`，这对于嵌入式平台上的图像分割任务来说，性能非常好。下一节将描述Jetson TX1上的滤波操作。
- en: Image filtering on Jetson TX1
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Jetson TX1上的图像滤波
- en: Image filtering is a very important step in image preprocessing and feature
    extractions. Low pass filters, like averaging, Gaussian, and median filters, are
    used to remove different types of noise in an image, while high pass filters,
    like Sobel, Scharr, and Laplacian, are used to detect edges in an image. Edges
    are important features that can be used for computer vision tasks like object
    detection and classification. Image filtering is explained in detail earlier in
    this book.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图像滤波是图像预处理和特征提取中的一个非常重要的步骤。低通滤波器，如平均、高斯和中值滤波器，用于去除图像中的不同类型的噪声，而高通滤波器，如Sobel、Scharr和Laplacian，用于检测图像中的边缘。边缘是重要的特征，可用于计算机视觉任务，如目标检测和分类。本书中已详细解释了图像滤波。
- en: 'This section describes the procedure to apply low pass and high pass filters
    on an image on Jetson TX1\. The code for this is as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 本节描述了在Jetson TX1上对图像应用低通和高通滤波器的步骤。相应的代码如下：
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Laplacian is a second-order derivative used to extract both vertical and horizontal
    images from an image. It is highly sensitive to noise so sometimes it is necessary
    to remove noise using a low pass filter, like the Gaussian blur, and then apply
    a Laplacian filter. So in the code, the Gaussian filter of size 3 x 3 is applied
    to an input image with a standard deviation equal to `1`. The filter is created
    using the `cv::cuda::createGaussianFilter` function of OpenCV. The Laplacian filter
    is then applied to the Gaussian blurred image. The Laplacian filter is created
    using the `cv::cuda::createLaplacianFilter` function of OpenCV. The output of
    the Gaussian blurring and Laplacian filter is downloaded back to the host memory
    for display on the console. The performance of the filtering operations is also
    measured in the code. The output of the program is shown in the following screenshot:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 拉普拉斯算子是一种二阶导数，用于从图像中提取垂直和水平图像。它对噪声非常敏感，因此有时需要使用低通滤波器（如高斯模糊）来去除噪声，然后再应用拉普拉斯滤波器。因此，在代码中，使用标准差等于`1`的3x3高斯滤波器对输入图像进行处理。该滤波器是通过OpenCV的`cv::cuda::createGaussianFilter`函数创建的。然后，将拉普拉斯滤波器应用于高斯模糊后的图像。拉普拉斯滤波器是通过OpenCV的`cv::cuda::createLaplacianFilter`函数创建的。高斯模糊和拉普拉斯滤波器的输出被下载回主机内存，以便在控制台上显示。代码中还测量了滤波操作的性能。程序的输出如下截图所示：
- en: '![](img/fb538e16-9cee-4b60-ab1b-808e7831baae.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fb538e16-9cee-4b60-ab1b-808e7831baae.png)'
- en: As can be seen from the output, the Laplacian filter on a blurred image will
    remove false edges from an image. It will also remove Gaussian noise present in
    an input image. If an input image is distorted by salt and pepper noise then the
    median filter should be used as a preprocessing step to a Laplacian filter for
    edge detection.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中可以看出，对模糊图像应用拉普拉斯滤波器将去除图像中的虚假边缘。它还将去除输入图像中存在的高斯噪声。如果输入图像被盐和胡椒噪声扭曲，则应在拉普拉斯滤波器进行边缘检测之前使用中值滤波器作为预处理步骤。
- en: To summarize, we have seen different image-processing functions such as image
    addition, image thresholding and image filtering on Jetson TX1\. We have also
    seen that the performance of these operations on Jetson TX1 is much better than
    the performance of the same code on a CPU. The next section will describe the
    interfacing of the camera with a Jetson TX1 so that it can be used in real-life
    situations.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，我们已经在Jetson TX1上看到了不同的图像处理函数，如图像加法、图像阈值和图像滤波。我们还看到，这些操作在Jetson TX1上的性能比在CPU上执行相同的代码要好得多。下一节将描述如何将摄像头与Jetson
    TX1连接，以便在现实生活中的场景中使用。
- en: Interfacing cameras with Jetson TX1
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与Jetson TX1连接摄像头
- en: 'Jetson TX1 can be interfaced with USB cameras or CSI cameras. The development
    board comes with one camera of 5 MP already interfaced with Jetson TX1\. This
    camera can be used to capture video just like a webcam on a laptop. Camera interfacing
    is an important feature that makes the Jetson TX1 development board useful in
    real-time situations. It supports up to six-lane cameras. The detailed list of
    cameras supported by Jetson TX1 can be found at the following link: [https://elinux.org/Jetson_TX1
    .](https://elinux.org/Jetson_TX1)'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Jetson TX1可以与USB摄像头或CSI摄像头连接。开发板已预装了一款5兆像素的摄像头，并与Jetson TX1连接。这款摄像头可以像笔记本电脑上的网络摄像头一样捕获视频。摄像头连接是Jetson
    TX1开发板在实时应用中的重要特性，它支持多达六通道的摄像头。Jetson TX1支持的摄像头详细列表可以在以下链接中找到：[https://elinux.org/Jetson_TX1](https://elinux.org/Jetson_TX1)
- en: This section will demonstrate the procedure to capture videos using a camera
    interfaced with Jetson TX1 and how these videos can be used to develop computer
    vision applications, like face detection and background subtraction.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将演示使用与Jetson TX1连接的摄像头捕获视频的步骤，以及如何使用这些视频开发计算机视觉应用，如人脸检测和背景减法。
- en: Reading and displaying video from onboard camera
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从机载摄像头读取和显示视频
- en: This section will describe the method used to capture video from a USB camera
    or onboard camera interfaced with Jetson TX1\. For this, OpenCV should be compiled
    with GStreamer support; otherwise, the format of the captured video will not be
    supported by OpenCV.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将描述从USB摄像头或与Jetson TX1连接的机载摄像头捕获视频的方法。为此，OpenCV应编译为支持GStreamer；否则，OpenCV将不支持捕获视频的格式。
- en: 'The following code can be used to capture video from a camera and display it
    on the screen:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码可以用来从摄像头捕获视频并在屏幕上显示：
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The code is more or less similar to a code used for capturing video from a
    webcam on a desktop. Instead of using a device ID as an argument to capture an
    object, the string that specifies GStreamer pipeline is used. This is shown as
    follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 代码与用于在台式机上从网络摄像头捕获视频的代码大致相似。而不是使用设备ID作为参数来捕获对象，使用指定GStreamer管道的字符串。如下所示：
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The width and height of the captured video are specified as 1,280 and 720 pixels.
    The frame rate is also specified. These values will change according to formats
    supported by interfaced cameras. Use `nvvidconv` to convert video to BGR format
    that is supported by OpenCV. It is also used for image scaling and flipping. To
    flip the captured video, the flip method can be specified as an integer value
    other than zero.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获的视频的宽度和高度被指定为1,280和720像素。帧率也被指定。这些值将根据接口摄像头的支持的格式而变化。使用`nvvidconv`将视频转换为OpenCV支持的BGR格式。它还用于图像缩放和翻转。要翻转捕获的视频，可以将flip方法指定为一个非零的整数值。
- en: The `cap.isOpened` property is used to check whether capturing from the camera
    has started or not. Then the frames are read one by one using the read method
    and displayed on the screen until `q` is pressed by the user. The rate of frame
    capturing is also measured in the code.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`cap.isOpened`属性来检查是否已从摄像头开始捕获。然后使用read方法逐个读取帧并在屏幕上显示，直到用户按下`q`键。代码中也测量了帧捕获的速率。
- en: 'The output of the live video is captured by the camera for two different frames,
    and the frame rate is shown in the following screenshot:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 摄像头捕获了实时视频的两个不同帧，帧率显示在下面的屏幕截图上：
- en: '![](img/2993e7b3-e147-4021-a841-5ed772f34066.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2993e7b3-e147-4021-a841-5ed772f34066.png)'
- en: To summarize, in this section we have seen the procedure to capture video from
    a camera interfaced with a Jetson TX1 development board. This captured video can
    be used to develop useful real-time computer vision applications as described
    in the next section.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，在本节中，我们看到了从与Jetson TX1开发板相连的摄像头捕获视频的步骤。这个捕获的视频可以用于开发下一节所述的有用的实时计算机视觉应用。
- en: Advanced applications on Jetson TX1
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Jetson TX1上的高级应用
- en: This section will describe the use of a Jetson TX1 embedded platform in the
    deployment of advanced computer vision applications, like face detection, eye
    detection, and background subtraction.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将描述在部署高级计算机视觉应用（如人脸检测、眼检测和背景减法）中使用Jetson TX1嵌入式平台。
- en: Face detection using Haar cascades
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Haar级联进行人脸检测
- en: A Haar cascade uses rectangular features to detect an object. It uses rectangles
    of different sizes to calculate different line and edge features. The idea behind
    the Haar-like feature detection algorithm is to compute the difference between
    the sum of white pixels and the sum of black pixels inside the rectangle.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Haar级联使用矩形特征来检测对象。它使用不同大小的矩形来计算不同的线和边缘特征。Haar-like特征检测算法背后的思想是计算矩形内白色像素总和与黑色像素总和之间的差异。
- en: The main advantage of this method is the fast sum computation using the integral
    image approach. This makes the Haar cascade ideal for real-time object detection.
    It requires less time for processing an image than other algorithms used for object
    detection. The Haar cascade is ideal for deployment on embedded systems like Jetson
    TX1 because of its low computational complexity and low memory footprint. So in
    this section, this algorithm is used to deploy face detection applications on
    Jetson TX1.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的主要优势是使用积分图方法进行快速的求和计算。这使得Haar级联非常适合实时目标检测。它处理图像所需的时间比其他用于目标检测的算法要少。由于Haar级联具有低计算复杂性和低内存占用，因此非常适合部署在嵌入式系统如Jetson
    TX1上。因此，在本节中，使用此算法在Jetson TX1上部署人脸检测应用。
- en: 'The code for face detection from a video captured by a camera interfaced with
    Jetson TX1 is as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 从与Jetson TX1接口的摄像头捕获的视频进行人脸检测的代码如下：
- en: '[PRE18]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The Haar cascade is an algorithm which needs to be trained to do a particular
    task. It is difficult to train a Haar cascade from scratch for a particular application,
    so OpenCV provides some trained XML files which can be used to detect objects.
    These XML files are provided in the `\usr\local\opencv\data\haarcascades_cuda`
    directory of the OpenCV and CUDA installations.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Haar级联是一种需要训练以执行特定任务的算法。从头开始训练特定应用的Haar级联是困难的，因此OpenCV提供了一些训练好的XML文件，可用于检测对象。这些XML文件位于OpenCV和CUDA安装的`\usr\local\opencv\data\haarcascades_cuda`目录中。
- en: The webcam is initialized, and frames from the webcam are captured one by one.
    The frame is uploaded to the device memory for processing on the GPU. OpenCV and
    CUDA provide the `CascadeClassifier` class that can be used for implementing the
    Haar cascade. The create method is used to create an object of that class. It
    requires the filename of the trained XML file to be loaded.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化网络摄像头，并逐个捕获网络摄像头的帧。将帧上传到设备内存以在GPU上处理。OpenCV和CUDA提供了`CascadeClassifier`类，可用于实现Haar级联。使用`create`方法创建该类的对象。它需要加载训练好的XML文件的文件名。
- en: Inside the `while` loop,the `detectMultiscale` method is applied to every frame
    so that faces of different sizes can be detected in each frame. The detected location
    is converted to a rectangle vector, using the convert method. Then, this vector
    is iterated using the `for` loop so that a bounding box can be drawn using a rectangle
    function on all the detected faces. This procedure is repeated for every frame
    captured from the webcam. The performance of the algorithm is also measured in
    terms of frames per second.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在`while`循环内部，将`detectMultiscale`方法应用于每一帧，以便在每一帧中检测不同大小的人脸。使用`convert`方法将检测到的位置转换为矩形向量。然后，使用`for`循环迭代此向量，以便在所有检测到的人脸上使用矩形函数绘制边界框。此过程对从网络摄像头捕获的每一帧重复进行。算法的性能也以每秒帧数来衡量。
- en: 'The output of the program is as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的输出如下：
- en: '![](img/203b7c76-1671-45d1-97b5-5b4cd0fc34bd.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/203b7c76-1671-45d1-97b5-5b4cd0fc34bd.png)'
- en: As can be seen from the output, the face is correctly localized in two different
    frames of the webcam at different positions. The second frame is a little bit
    blurred, but it is not affecting the algorithm. The performance of the algorithm
    on Jetson TX1 is also shown in the right image. The algorithm works at around
    five frames per second.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中可以看出，人脸在两个不同位置的两个不同的网络摄像头帧中被正确定位。第二帧有点模糊，但这不会影响算法。Jetson TX1上算法的性能也在右图显示。算法在大约每秒五帧的速度下工作。
- en: To summarize, this section demonstrates the use of Jetson TX1 in detecting faces
    from a live video captured from a webcam. This application can be used for person
    identification, face locking, attendance monitoring, and so on.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，本节展示了使用Jetson TX1从网络摄像头捕获的实时视频中检测人脸。此应用程序可用于人员识别、人脸锁定、考勤监控等。
- en: Eye detection using Haar cascades
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Haar级联进行眼检测
- en: 'This section will describe the use of Haar cascades in detecting the eyes of
    humans. The XML file for a trained Haar cascade for eye detection is provided
    in the OpenCV installation directory. This file is used to detect eyes. The code
    for it is as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将描述使用Haar级联检测人类眼睛的使用。用于眼检测的训练好的Haar级联的XML文件位于OpenCV安装目录中。此文件用于检测眼睛。其代码如下：
- en: '[PRE19]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The code is similar to the code for face detection. This is the advantage of
    using Haar cascades. If an XML file for a trained Haar cascade on a given object
    is available then the same code will work in all applications. Just the name of
    the XML file needs to change while creating an object of the `CascadeClassifier`
    class. In the preceding code, `haarcascade_eye.xml` , which is the trained XML
    file for eye detection, is used. The other code is self-explanatory. The scale
    factor is set at `1.02` so that image size will be reduced by `1.02` at every
    scale. The output of the eye detection program is as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 代码与面部检测的代码类似。这是使用Haar级联的优势。如果有一个给定对象的训练好的Haar级联的XML文件可用，那么相同的代码将在所有应用程序中工作。只需在创建`CascadeClassifier`类的对象时更改XML文件的名称。在前面的代码中，使用了用于眼检测的训练XML文件`haarcascade_eye.xml`。其他代码是自解释的。缩放因子设置为`1.02`，以便在每次缩放时图像大小将减少`1.02`。眼检测程序的输出如下：
- en: '![](img/a440675f-7e4d-4361-9348-7813b5d8500e.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a440675f-7e4d-4361-9348-7813b5d8500e.png)'
- en: Now that we have detected objects from video and images using a Haar cascade,
    the captured video can also be used to detect and track objects using the background
    subtraction method as described in the next section.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经使用Haar级联从视频和图像中检测到对象，因此捕获的视频也可以使用下一节中描述的背景减法方法来检测和跟踪对象。
- en: Background subtraction using Mixture of Gaussian (MoG)
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用高斯混合（MoG）的背景减法
- en: Background subtraction is an important preprocessing step for object detection
    and tracking applications. It can also be used for unusual activity detection
    from CCTV footage. This section demonstrates the use of Jetson TX1 in a background
    subtraction application. The camera interfaced with Jetson TX1 is mounted in a
    room for activity detection inside the room. The background of the room is initialized
    in the first frame.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 背景减法是目标检测和跟踪应用的重要预处理步骤。它也可以用于从监控录像中检测异常活动。本节展示了在背景减法应用中使用Jetson TX1。与Jetson
    TX1接口的摄像头被安装在一个房间内，用于检测房间内的活动。房间的背景在第一帧中被初始化。
- en: The MoG, which is a widely used background subtraction method used for separating
    the foreground from the background based on Gaussian mixtures, is used for activity
    detection. The background is continuously updated from the sequence of frames.
    A mixture of K Gaussian distribution is used to categorize pixels as foreground
    or background. The time sequence of the frame is also weighted to improve background
    modeling. The intensities that are continuously changing are categorized as foreground,
    and intensities that are static are categorized as background.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: MoG是一种广泛使用的背景减法方法，用于根据高斯混合将前景与背景分离，用于活动检测。背景从帧序列中持续更新。使用K个高斯分布的混合来将像素分类为前景或背景。帧的时间序列也被加权以改进背景建模。持续变化的强度被分类为前景，而静态的强度被分类为背景。
- en: 'The code for activity monitoring using MoG is as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 使用MoG进行活动监控的代码如下：
- en: '[PRE20]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The camera interfaced with Jetson TX1 is initialized with the GStreamer pipeline.
    The `createBackgroundSubtractorMOG` class is used to create an object for MoG
    implementation. The `apply` method of the created object is used to create a foreground
    mask from the first frame. It requires an input image, an `image` array to store
    foreground mask, and learning rate as the input. The image of the room without
    any activity is initialized as a background for the MoG. So, any activity that
    will happen will be categorized as foreground by the algorithm.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 与Jetson TX1接口的摄像头使用GStreamer管道初始化。`createBackgroundSubtractorMOG`类用于创建MoG实现的对象。创建的对象的`apply`方法用于从第一帧创建前景掩码。它需要一个输入图像、一个`image`数组来存储前景掩码，以及学习率作为输入。没有活动的房间图像被初始化为MoG的背景。因此，任何发生的活动都将被算法归类为前景。
- en: This foreground mask and the background image are continuously updated after
    every frame inside the `while` loop. The `getBackgroundImage` function is used
    to fetch the current background model.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在`while`循环的每一帧之后，都会持续更新前景掩码和背景图像。`getBackgroundImage`函数用于获取当前的背景模型。
- en: The foreground mask is used to create a foreground image, which indicates which
    objects are currently moving. It is basically logical and operates between the
    original frame and foreground mask. The foreground mask, foreground image, and
    the modeled background are downloaded to the host memory after every frame, for
    displaying on the screen.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 前景掩码用于创建前景图像，指示哪些对象当前正在移动。它基本上是逻辑操作，在原始帧和前景掩码之间进行。在每一帧之后，前景掩码、前景图像和建模的背景都会下载到主机内存中，以便在屏幕上显示。
- en: 'The output of two different frames from the video is shown in the following
    screenshot:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了从视频中提取的两个不同帧的输出：
- en: '![](img/cf472126-4abb-4203-a695-d60f675917bb.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cf472126-4abb-4203-a695-d60f675917bb.png)'
- en: 'The first row indicates the background of the room without any activity. When
    someone moves a hand in front of the camera, it will be detected as foreground,
    as shown in the second frame result. In the same way, if someone puts a cell phone
    in front of the camera, that will also be categorized as foreground, as shown
    in the third frame. The performance of the code in terms of frames per second
    is shown in the following screenshot:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行表示房间内没有任何活动时的背景。当有人将手放在摄像头前时，它将被检测为前景，如第二帧结果所示。同样，如果有人将手机放在摄像头前，它也将被归类为前景，如第三帧所示。以下截图显示了代码在每秒帧数方面的性能：
- en: '![](img/6c0f9dae-08fd-438f-96ab-fa6067dd7a20.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6c0f9dae-08fd-438f-96ab-fa6067dd7a20.png)'
- en: The technique works at around 60-70 frames per second, which can easily be used
    to take a real-time decision. Though the demonstration in this section is very
    trivial, this application can be used in many real-life situations. The activity
    inside a room can be used to control the appliances present in the room. This
    will help in saving electricity when no person is present. This application can
    also be used at an ATM for monitoring activity inside it. It can also be used
    for other video surveillance applications in public places. Python can also be
    used as the programming language on Jetson TX1, which will be explained in the
    next section.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 该技术在每秒大约60-70帧的速度下工作，可以很容易地用于实时决策。尽管本节中的演示非常简单，但这种应用可以在许多实际情况下使用。房间内的活动可以用来控制房间内现有的设备。这有助于在没有人的情况下节省电力。此应用还可以用于ATM机内活动的监控。它还可以用于公共场所的其他视频监控应用。Python也可以用作Jetson
    TX1上的编程语言，这将在下一节中解释。
- en: Computer vision using Python and OpenCV on Jetson TX1
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Jetson TX1上使用Python和OpenCV进行计算机视觉
- en: Up till now, we have developed all computer vision applications using C/C++,
    OpenCV, and CUDA. Jetson TX1 also supports the Python programming language for
    computer vision applications. When OpenCV is compiled on Jetson TX1, it also installs
    Python binaries for OpenCV. So programmers who are comfortable in Python programming
    language can use a Python interface for OpenCV in developing computer vision applications
    and deploying them on Jetson TX1\. Python also comes preinstalled with Jetson
    TX1 as is the case for all Linux operating systems. Windows users can install
    Python separately. The installation procedure and advantages of Python are explained
    in the next chapter.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们使用C/C++、OpenCV和CUDA开发了所有计算机视觉应用。Jetson TX1也支持Python编程语言用于计算机视觉应用。当在Jetson
    TX1上编译OpenCV时，它也会安装OpenCV的Python二进制文件。因此，熟悉Python编程语言的程序员可以使用Python接口开发OpenCV计算机视觉应用，并在Jetson
    TX1上部署它们。Python也像所有Linux操作系统一样预安装在Jetson TX1上。Windows用户可以单独安装Python。Python的安装过程和优势将在下一章中解释。
- en: 'One disadvantage of using Python is that OpenCV Python interface is still not
    greatly benefited by CUDA acceleration. Still, the ease of learning Python and
    the wide range of applications in which it can be used have encouraged many software
    developers to use Python for computer vision applications. The sample code for
    reading and displaying images using Python and OpenCV is as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Python的一个缺点是，OpenCV Python接口尚未从CUDA加速中受益很大。尽管如此，Python学习的简便性和其广泛的应用范围已经鼓励了许多软件开发者使用Python进行计算机视觉应用。使用Python和OpenCV读取和显示图像的示例代码如下：
- en: '[PRE21]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In Python,the `import` command is used to include a library in a file. So the
    `cv2` library is included by using the `import cv2` command. Images are stored
    as `numpy` arrays so `numpy` is also imported in a file. The `imread` function
    is used to read an image in the same way as C++. All OpenCV functions have to
    be prefixed with `cv2.` in Python. The `imshow` function is used to display an
    image. All OpenCV functions have a similar signature and functionality in Python
    as C++.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，`import`命令用于在文件中包含一个库。因此，使用`import cv2`命令包含`cv2`库。图像以`numpy`数组的形式存储，所以`numpy`也被导入到文件中。`imread`函数用于以与C++相同的方式读取图像。所有OpenCV函数在Python中都必须以`cv2.`为前缀。`imshow`函数用于显示图像。在Python中，所有OpenCV函数都具有与C++类似的签名和功能。
- en: 'The following command can be used to execute the code from the Terminal:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下命令在终端中执行代码：
- en: '[PRE22]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The output of the program is shown in the following screenshot:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的输出如下所示：
- en: '![](img/79d8b542-c442-41a4-927e-6f40e2831558.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](img/79d8b542-c442-41a4-927e-6f40e2831558.png)'
- en: This section is just included to make you aware that Python can also be used
    as a programming language for developing computer vision applications using OpenCV
    and deploying it on Jetson TX1.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这一节只是为了让您知道Python也可以用作编程语言，通过OpenCV开发计算机视觉应用，并在Jetson TX1上部署它。
- en: Summary
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter described the use of Jetson TX1 in the deployment of CUDA and OpenCV
    code. The properties of the GPU device present on a TX1 board that make it ideal
    for deploying computationally complex applications are explained in detail. The
    performance of Jetson TX1 for CUDA applications such as adding two large arrays
    is measured and compared with GPUs present on laptops. The procedure to work with
    images on Jetson TX1 is explained in detail in this chapter. The image-processing
    applications like image addition, image thresholding, and image filtering are
    deployed on Jetson TX1 and performance is measured for them.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 本章描述了在部署 CUDA 和 OpenCV 代码时使用 Jetson TX1。本章详细解释了 TX1 板上 GPU 设备的特性，使其非常适合部署计算复杂的应用。本章测量并比较了
    Jetson TX1 在执行如添加两个大型数组这样的 CUDA 应用时的性能，并与书中之前提到的笔记本电脑上的 GPU 进行了比较。本章详细解释了在 Jetson
    TX1 上处理图像的流程。图像处理应用，如图像相加、图像阈值和图像滤波，在 Jetson TX1 上部署，并对它们的性能进行了测量。
- en: The best part of Jetson TX1 is that multiple cameras can be interfaced with
    it in an embedded environment, and videos from that camera can be processed to
    design complex computer vision applications. The procedure to capture video from
    an onboard or USB camera interfaced with Jetson TX1 is explained in detail.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Jetson TX1 的最佳之处在于，可以在嵌入式环境中与多个摄像头进行接口连接，并且可以从该摄像头处理视频以设计复杂的计算机视觉应用。从 Jetson
    TX1 上连接的板载或 USB 摄像头捕获视频的流程在本文中详细解释。
- en: The chapter also described the deployment of advanced computer vision applications
    like face detection, eye detection, and background subtraction on Jetson TX1\.
    The Python language can also be used to deploy computer vision applications on
    Jetson TX1\. This concept is explained in the last part of the chapter. So far,
    we have seen how the C/C++ language can leverage the advantages of CUDA and GPU
    acceleration.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还描述了在 Jetson TX1 上部署高级计算机视觉应用，如人脸检测、眼睛检测和背景减法。Python 语言也可以用于在 Jetson TX1 上部署计算机视觉应用。这一概念在章节的最后部分进行了解释。到目前为止，我们已经看到了如何利用
    C/C++ 语言的优势来利用 CUDA 和 GPU 加速。
- en: The next couple of chapters will demonstrate the use of CUDA and GPU acceleration
    for the Python language using the PyCUDA module.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的几章将演示使用 PyCUDA 模块在 Python 语言中使用 CUDA 和 GPU 加速。
- en: Questions
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Compare the performance of a GPU device on Jetson TX1 with a GeForce 940 GPU
    seen earlier in the book.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 Jetson TX1 上的 GPU 设备性能与书中之前提到的 GeForce 940 GPU 进行比较。
- en: 'State True or False: All CUDA programs seen earlier in the book can be executed
    on Jetson TX1 without modification.'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 判断正误：书中之前提到的所有 CUDA 程序都可以在 Jetson TX1 上执行，无需修改。
- en: What is the need for recompiling OpenCV on Jetson TX1?
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Jetson TX1 上重新编译 OpenCV 的需要是什么？
- en: 'State True or False: OpenCV can''t capture video from a camera connected to
    the USB port.'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 判断正误：OpenCV 无法从连接到 USB 端口的摄像头捕获视频。
- en: 'State True or False: It is better to use a CSI camera for computationally intensive
    applications than a USB camera.'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 判断正误：对于计算密集型应用，使用 CSI 摄像头比使用 USB 摄像头更好。
- en: If you are developing computationally intensive computer vision applications
    using OpenCV, which language would you prefer for faster performance?
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你正在使用 OpenCV 开发计算密集型的计算机视觉应用，你更倾向于哪种语言以获得更快的性能？
- en: Is there a need to install separate OpenCV Python binding or Python interpreter
    on Jetson TX1?
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Jetson TX1 上是否有必要安装单独的 OpenCV Python 绑定或 Python 解释器？
