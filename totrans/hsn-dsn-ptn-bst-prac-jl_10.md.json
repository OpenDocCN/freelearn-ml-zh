["```py\nmodule MyPackage\ninclude(\"sub_module1.jl\")\ninclude(\"sub_module2.jl\")\ninclude(\"sub_module3.jl\")\nend\n```", "```py\n# MyPackage.jl\nmodule MyPackage\ninclude(\"sub_module1/sub_module1.jl\")\ninclude(\"sub_module2/sub_module2.jl\")\ninclude(\"sub_module3.jl\")\nend\n```", "```py\n# sub_module1.jl\nmodule SubModule1\ninclude(\"file1.jl\")\ninclude(\"file2.jl\")\ninclude(\"file3.jl\")\nend\n```", "```py\n# Calculator.jl\nmodule Calculator\n\ninclude(\"Mortgage.jl\")\n\nexport interest, rate\n\nfunction interest(amount, rate)\n    return amount * (1 + rate)\nend\n\nfunction rate(amount, interest)\n    return interest / amount\nend\n\nend # module\n```", "```py\n# Mortgage.jl\nmodule Mortgage\n\nfunction payment(amount, rate, years)\n    # TODO code to calculate monthly payment for the loan\n    return 100.00\nend \n\nend # module\n```", "```py\n# Mortgage.jl\nmodule Mortgage\n\nfunction payment(amount, rate, years)\n    monthly_rate = rate / 12.0\n    factor = (1 + monthly_rate) ^ (years * 12.0)\n    return amount * (monthly_rate * factor / (factor - 1))\nend \n\nend # module\n```", "```py\n# Calculator.jl\nmodule Calculator\n\n# include sub-modules\ninclude(\"Mortgage.jl\")\nusing .Mortgage: payment\n\n# functions for the main module\ninclude(\"funcs.jl\")\n\nend # module\n```", "```py\n# funcs.jl - common calculation functions\n\nexport interest, rate, mortgage\n\nfunction interest(amount, rate)\n    return amount * (1 + rate)\nend\n\nfunction rate(amount, interest)\n    return interest / amount\nend\n\n# uses payment function from Mortgage.jl\nfunction mortgage(home_price, down_payment, rate, years)\n    return payment(home_price - down_payment, rate, years)\nend\n```", "```py\n# Mortgage.jl\nmodule Mortgage\n\n# access to parent module's variable\nusing ..Calculator: days_per_year\n\nend # module  \n```", "```py\n# Calculator.jl\nmodule Calculator\n\nconst days_per_year = 365\n\ninclude(\"Mortgage.jl\")\nusing .Mortgage: payment\n\nfunction do_something()\n    return payment(1000.00, 3.25, 5; days_per_year = days_per_year)\nend\n\nend # module\n```", "```py\nstruct TextStyle\n    font_family\n    font_size\n    font_weight\n    foreground_color\n    background_color\n    alignment\n    rotation\nend\n```", "```py\nstyle = TextStyle(\"Arial\", 11, \"Bold\", \"black\", \"white\", \"left\", 0)\n```", "```py\nfunction TextStyle(;\n        font_family,\n        font_size,\n        font_weight = \"Normal\",\n        foreground_color = \"black\",\n        background_color = \"white\", \n        alignment = \"left\",\n        rotation = 0)\n    return TextStyle(\n        font_family,\n        font_size,\n        font_weight,\n        foreground_color,\n        background_color,\n        alignment,\n        rotation)\nend\n```", "```py\nstyle = TextStyle(\n    alignment = \"left\",\n    font_family = \"Arial\",\n    font_weight = \"Bold\",\n    font_size = 11)\n```", "```py\nBase.@kwdef struct TextStyle\n    font_family\n    font_size\n    font_weight = \"Normal\"\n    foreground_color = \"black\"\n    background_color= \"white\"\n    alignment = \"center\"\n    rotation = 0\nend\n```", "```py\nconst INFO    = 1\nconst WARNING = 2\nconst ERROR   = 3\n```", "```py\nstruct Logger\n    filename   # log file name\n    level      # minimum level acceptable to be logged\n    handle     # file handle\nend\n```", "```py\nLogger(filename, level) = Logger(filename, level, open(filename, \"w\"))\n```", "```py\nusing Dates\n\nfunction info!(logger::Logger, args...)\n    if logger.level <= INFO\n        let io = logger.handle\n            print(io, trunc(now(), Dates.Second), \" [INFO] \")\n            for (idx, arg) in enumerate(args)\n                idx > 0 && print(io, \" \")\n                print(io, arg)\n            end\n            println(io)\n            flush(io)\n        end\n    end\nend\n```", "```py\nfor level in (:info, :warning, :error)\n    lower_level_str = String(level)\n    upper_level_str = uppercase(lower_level_str)\n    upper_level_sym = Symbol(upper_level_str)\n\n    fn = Symbol(lower_level_str * \"!\")\n    label = \" [\" * upper_level_str * \"] \"\n\n    @eval function $fn(logger::Logger, args...)\n        if logger.level <= $upper_level_sym\n            let io = logger.handle\n                print(io, trunc(now(), Dates.Second), $label)\n                for (idx, arg) in enumerate(args)\n                    idx > 0 && print(io, \" \")\n                    print(io, arg)\n                end\n                println(io)\n                flush(io)\n            end\n        end\n    end\nend\n```", "```py\nfunction logme!(level, label, logger::Logger, args...)\n    if logger.level <= level\n        let io = logger.handle\n            print(io, trunc(now(), Dates.Second), label)\n            for (idx, arg) in enumerate(args)\n                idx > 0 && print(io, \" \")\n                print(io, arg)\n            end\n            println(io)\n            flush(io)\n        end\n    end\nend\n```", "```py\ninfo!   (logger::Logger, msg...) = logme!(INFO,    \" [INFO] \",    logger, msg...)\nwarning!(logger::Logger, msg...) = logme!(WARNING, \" [WARNING] \", logger, msg...)\nerror!  (logger::Logger, msg...) = logme!(ERROR,   \" [ERROR] \",   logger, msg...)\n```", "```py\nfunction make_log_func(level, label)\n    (logger::Logger, args...) -> begin\n        if logger.level <= level\n            let io = logger.handle\n                print(io, trunc(now(), Dates.Second), \" [\", label, \"] \")\n                for (idx, arg) in enumerate(args)\n                    idx > 0 && print(io, \" \")\n                    print(io, arg)\n                end\n                println(io)\n                flush(io)\n            end\n        end\n    end\nend\n```", "```py\ninfo!    = make_log_func(INFO,    \"INFO\")\nwarning! = make_log_func(WARNING, \"WARNING\")\nerror!   = make_log_func(ERROR,   \"ERROR\")\n```", "```py\n@ode_def begin\n  dx = σ * (y - x)\n  dy = x * (ρ - z) - y\n  dz = x * y - β * z\nend σ ρ β\n```", "```py\nAxiom: A\n  Rule: A -> AB\n  Rule: B -> A\n```", "```py\nAxiom: A\n  Rule: A -> AB\n  Rule: B -> A\n```", "```py\nmodel = LModel(\"A\")\nadd_rule!(model, \"A\", \"AB\")\nadd_rule!(model, \"B\", \"A\")\n```", "```py\nmodel = @lsys begin\n    axiom : A\n    rule  : A → AB\n    rule  : B → A\nend\n```", "```py\nstruct LModel\n    axiom\n    rules\nend\n```", "```py\n\"Create a L-system model.\"\nLModel(axiom) = LModel([axiom], Dict())\n```", "```py\n\"Add rule to a model.\"\nfunction add_rule!(model::LModel, left::T, right::T) where {T <: AbstractString}\n    model.rules[left] = split(right, \"\")\n    return nothing\nend\n```", "```py\n\"Display model nicely.\"\nfunction Base.show(io::IO, model::LModel)\n    println(io, \"LModel:\")\n    println(io, \" Axiom: \", join(model.axiom))\n    for k in sort(collect(keys(model.rules)))\n        println(io, \" Rule: \", k, \" → \", join(model.rules[k]))\n    end\nend\n```", "```py\nstruct LState\n    model\n    current_iteration\n    result\nend\n```", "```py\n\"Create a L-system state from a `model`.\"\nLState(model::LModel) = LState(model, 1, model.axiom)\n```", "```py\nfunction next(state::LState)\n    new_result = []\n    for el in state.result\n        # Look up `el` from the rules dictionary and append to `new_result`.\n        # Just default to the element itself when it is not found\n        next_elements = get(state.model.rules, el, el)\n        append!(new_result, next_elements)\n    end\n    return LState(state.model, state.current_iteration + 1, new_result)\nend\n```", "```py\n\"Compact the result suitable for display\"\nresult(state::LState) = join(state.result)\n\nBase.show(io::IO, s::LState) = \n    print(io, \"LState(\", s.current_iteration, \"): \", result(s))\n```", "```py\nmacro lsys(ex)\n    return MacroTools.postwalk(walk, ex)\nend\n```", "```py\nfunction walk(ex)\n\n    match_axiom = @capture(ex, axiom : sym_)\n    if match_axiom\n        sym_str = String(sym)\n        return :( model = LModel($sym_str) )\n    end\n\n    match_rule = @capture(ex, rule : original_ → replacement_)\n    if match_rule\n        original_str = String(original)\n        replacement_str = String(replacement)\n        return :(\n            add_rule!(model, $original_str, $replacement_str)\n        )\n    end\n\n    return ex\nend\n```", "```py\nmatch_axiom = @capture(ex, axiom : sym_)\n```", "```py\n    if match_axiom\n        sym_str = String(sym)\n        return :( model = LModel($sym_str) )\n    end\n```", "```py\nmodel = LModel(\"A\")\n```", "```py\n    match_rule = @capture(ex, rule : original_ → replacement_)\n```", "```py\nmacro lsys(ex)\n    ex = MacroTools.postwalk(walk, ex)\n    push!(ex.args, :( model ))\n    return ex\nend\n```"]