<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Getting Started with Machine Learning and ML.NET</h1>
                </header>
            
            <article>
                
<p>By opening this book, you are taking the first step in disrupting your own knowledge by approaching solutions to complex problems with machine learning. You will be achieving this with the use of Microsoft's ML.NET framework. Having spent several years applying machine learning to cybersecurity, I'm confident that the knowledge you garner from this book will not only open career opportunities to you but also open up your thought processes and change the way you approach problems. No longer will you even approach a complex problem without thinking about how machine learning could possibly solve it.</p>
<p>Over the course of this book, you will learn about the following:</p>
<ul>
<li>How and when to use five different algorithms that ML.NET provides</li>
<li>Real-world end-to-end examples demonstrating ML.NET algorithms</li>
<li>Best practices when training your models, building your training sets, and feature engineering</li>
<li>Using pre-trained models in both TensorFlow and ONNX formats</li>
</ul>
<p>This book does assume that you have a reasonably solid understanding of C#. If you have other experience with a strongly typed object-oriented programming language such as C++ or Java, the syntax and design patterns are similar enough to not hinder your ability to follow the book. However, if this is your first deep dive into a strongly typed language such as C#, I strongly suggest picking up <em>Learn C# in 7 Days</em>,<em> </em>by Gaurav Aroraa, published by<em> </em>Packt Publishing, to get a quick foundation. In addition, no prior machine learning experience is required or expected, although a cursory understanding will accelerate your learning.</p>
<p class="mce-root"/>
<p>In this chapter, we will cover the following:</p>
<ul>
<li>The importance of learning about machine learning today</li>
<li>The model-building process</li>
<li>Exploring types of learning</li>
<li>Exploring various machine learning algorithms</li>
<li>Introduction to ML.NET</li>
</ul>
<p>By the end of the chapter, you should have a fundamental understanding of what it takes to build a model from start to finish, providing the basis for the remainder of the book.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The importance of learning about machine learning today</h1>
                </header>
            
            <article>
                
<p>In recent years, machine learning and artificial intelligence have become an integral part of many of our lives in use cases as diverse as finding cancer cells in an MRI and facial and object recognition during a professional basketball game. Over the course of just the four years between 2013 and 2017, machine learning patents alone grew 34%, while spending is estimated to grow to $57.6B by 2021 (<a href="https://www.forbes.com/sites/louiscolumbus/2018/02/18/roundup-of-machine-learning-forecasts-and-market-estimates-2018/#794d6f6c2225">https://www.forbes.com/sites/louiscolumbus/2018/02/18/roundup-of-machine-learning-forecasts-and-market-estimates-2018/#794d6f6c2225</a>). </p>
<p>Despite its status as a growing technology, the term machine learning was coined back in 1959 by Arthur Samuel—so what caused the 60-year gap before its adoption? Perhaps the two most significant factors were the availability of technology able to process model predictions fast enough, and the amount of data being captured every minute digitally. According to DOMO Inc, a study in 2017 concluded that 2.5 quintillion bytes were generated daily and that at that time, 90% of the world's data was created between 2015 and 2017 (<a href="https://www.domo.com/learn/data-never-sleeps-5?aid=ogsm072517_1&amp;sf100871281=1">https://www.domo.com/learn/data-never-sleeps-5?aid=ogsm072517_1&amp;sf100871281=1</a>). By 2025, it is estimated that 463 exabytes of data are going to be created daily (<a href="https://www.visualcapitalist.com/how-much-data-is-generated-each-day/">https://www.visualcapitalist.com/how-much-data-is-generated-each-day/</a>), much of which will come from cars, videos, pictures, IoT devices, emails, and even devices that have not made the transition to the smart movement yet. </p>
<p class="mce-root"/>
<p>The amount that data has grown in the last decade has led to questions about how a business or corporation can use such data for better sales forecasting, anticipating a customer's needs, or detecting malicious bytes in a file. Traditional statistical approaches could potentially require exponentially more staff to keep up with current demands, let alone scale with the data captured. Take, for instance, Google Maps. With Google's acquisition of Waze in 2013, users of Google Maps have been provided with extremely accurate routing suggestions based on the anonymized GPS data of its users. With this model, the more data points (in this case GPS data from smartphones), the better predictions Google can make for your travel. As we will discuss later in this chapter, quality datasets are a critical component of machine learning, especially in the case of Google Maps, where, without a proper dataset, the user experience would be subpar.</p>
<p>In addition, the speed of computer hardware, specifically specialized hardware tailored for machine learning, has also played a role. The use of <strong>Application-Specific Integrated Circuits</strong> (<strong>ASICs</strong>) has grown exponentially. One of the most popular ASICs on the market is the Google <strong>Tensor Processing Unit</strong> (<strong>TPU</strong>). Originally released in 2016, it has since gone through two iterations and provides cloud-based acceleration for machine learning tasks on Google Cloud Platform. Other cloud platforms, such as Amazon's AWS and Microsoft's Azure, also provide FPGAs.</p>
<p>Additionally, <strong>Graphics Processing Units</strong> (<strong>GPUs</strong>) from both AMD and NVIDIA are accelerating both cloud-based and local workloads, with ROCm Platform and CUDA-accelerated libraries respectively. In addition to accelerated workloads, typical professional GPUs offered by <span>AMD and NVIDIA</span> provide a much higher density of processors than the traditional CPU-only approach. For instance, the AMD Radeon Instinct MI60 provides 4,096 stream processors. While not a full-fledged x86 core, it is not a one-to-one comparison, and the peak performance of double-precision floating-point tasks is rated at 7.373 TFLOPs compared to the 2.3 TFLOPs in AMD's extremely powerful EPYC 7742 server CPU. From a cost and scalability perspective, utilizing GPUs in even a workstation configuration would provide an exponential reduction in training time if the algorithms were accelerated to take advantage of the more specialized cores offered by AMD and NVIDIA. Fortunately, ML.NET provides GPU acceleration with little additional effort.</p>
<p>From a software engineering career perspective, with this growth and demand far outpacing the supply, there has never been a better time to develop machine learning skills as a software engineer. Furthermore, software engineers also possess skills that traditional data scientists do not have – for instance, being able to automate tasks such as the model building process rather than relying on manual scripts. Another example of where a software engineer can provide more value is by adding both unit tests and efficacy tests as part of the full pipeline when training a model. In a large production application, having these automated tests is critical to avoid production issues.</p>
<p>Finally, in 2018, for the first time ever, data was considered more valuable than oil. As industries continue to adopt the use of data gathering and existing industries take advantage of the data they have, machine learning will be intertwined with the data. Machine learning to data is what refining plants are to oil.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The model building process</h1>
                </header>
            
            <article>
                
<p>Before diving into ML.NET, an understanding of core machine learning concepts is required. These concepts will help create a foundation for you to build on as we start building models and learning the various algorithms ML.NET provides over the course of this book. At a high level, producing a model is a complex process; however, it can be broken down into six main steps:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-666 image-border" src="assets/d24862da-3f93-48e3-b3a7-45d10dede281.png" style="width:12.42em;height:26.33em;"/></p>
<p>Over the next few sections, we will go through each of these steps in detail to provide you with a clear understanding of how to perform each step and how each step relates to the overall machine learning process as a whole.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining your problem statement</h1>
                </header>
            
            <article>
                
<p>Effectively, what problem are you attempting to solve? Being specific at this point is crucial as a less concise problem can lead to considerable re-work. For example, take the following problem statement: <em>Predicting the outcome of an election</em>. My first question upon hearing that problem statement would be, at what level? County, state, or national? Each level more than likely requires considerably more features and data to properly predict than the last. A better problem statement, especially early on in your machine learning journey, would be for a specific position at a county level, such as <em>Predicting the 2020 John Doe County Mayor</em>. With this more direct problem statement, your features and dataset are much more focused and more than likely attainable. Even with more experience in machine learning, proper scoping of your problem statement is critical. The five Ws of Who, What, When, Where, and Why should be followed to keep your statement concise.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining your features</h1>
                </header>
            
            <article>
                
<p>The second step in machine learning is defining your features. Think of features as components or attributes of the problem you wish to solve. In machine learning – specifically, when creating a new model – features are one of the biggest impacts on your model's performance. Properly thinking through your problem statement will promote an initial set of features that will drive differentiation between your dataset and model results. Going back to the Mayor example in the preceding section, what features would you consider data points for the citizen? Perhaps start by looking at the Mayor's competition and where he/she sits on issues in ways that differ from other candidates. These values could be turned into features and then made into a poll for citizens of John Doe County to answer. Using these data points would create a solid first pass at features. One aspect here that is also found in model building is running several iterations of feature engineering and model training, especially as your dataset grows. After model evaluation, <em>feature importance</em> is used to determine what features are actually driving your predictions. Occasionally, you will find that gut-instinct features can actually be inconsequential after a few iterations of model training and feature engineering.</p>
<p>In <a href="116bbc2d-9659-4d34-9b2b-26593e29f54a.xhtml">Chapter 11</a>, <em>Training and Building Production Models</em>, we will deep dive into best practices when defining features and common approaches to complex problems to obtain a solid first pass at feature engineering.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Obtaining a dataset</h1>
                </header>
            
            <article>
                
<p>As you can imagine, one of the most important aspects of the model building process is obtaining a high-quality dataset. A dataset is used to train the model on what the output should be in the case of the aforementioned case of supervised learning. In the case of unsupervised learning, labeling is required for the dataset. A common misconception when creating a dataset is that bigger is better. This is far from the truth in a lot of cases. Continuing the preceding example, what if all of the poll results answered the same way for every single question? At that point, your dataset is composed of all the same data points and your model will not be able to properly predict any of the other candidates. This outcome is called <em>overfitting</em>. A diverse but representative dataset is required for machine learning algorithms to properly build a production-ready model. </p>
<p>In <a href="116bbc2d-9659-4d34-9b2b-26593e29f54a.xhtml">Chapter 11</a>, <em>Training and Building Production Models</em>, we will deep dive into the methodology of obtaining quality datasets, looking at helpful resources, ways to manage your datasets, and transforming data, commonly referred to as data wrangling.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Feature extraction and pipeline</h1>
                </header>
            
            <article>
                
<p>Once your features and datasets have been obtained, the next step is to perform feature extraction. Feature extraction, depending on the size of your dataset and your features, could be one of the most time-consuming elements of the model building process. </p>
<p>For example, let's say that the results from the aforementioned fictitious John Doe County Election Poll had 40,000 responses. Each response was stored in a SQL database captured from a web form. Performing a SQL query, let's say you then returned all of the data into a CSV file, using which your model can be trained. At a high level, this is your feature extraction and pipeline. For more complex scenarios, such as predicting malicious web content or image classification, the extraction will include binary extraction of specific bytes in files. Properly storing this data to avoid having to re-run the extraction is crucial to iterating quickly (assuming the features did not change). </p>
<p>In Chapter 11, <em>Training and Building Production Models,</em> we will deep dive into ways to version your feature-extracted data and maintain control over your data, especially as your dataset grows in size.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Model training</h1>
                </header>
            
            <article>
                
<p>After feature extraction, you are now prepared to train your model. Model training with ML.NET, thankfully, is very straightforward. Depending on the amount of data extracted in the feature extraction phase, the complexity of the pipeline, and the specifications of the host machine, this step could take several hours to complete. When your pipeline becomes much larger and your model becomes more complex, you may find yourself requiring potentially more compute resources than your laptop or desktop can provide; tooling such as Spark exists to help you scale to <em>n</em> number of nodes.</p>
<p>In Chapter 11, <em>Training and Building Production Models</em>, we will discuss tooling and tips for scaling this step using an easy-to-use open source project.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Model evaluation</h1>
                </header>
            
            <article>
                
<p>Once the model is trained, the last step is to evaluate the model. The typical approach to model evaluation is to <em>hold out</em> a portion of your dataset for evaluation. The idea behind this is to take known data, submit it to your trained model, and measure the efficacy of your model. The critical part of this step is to hold out a representative dataset of your data. If your holdout set is swayed one way or the other, then you will more than likely get a false sense of either high performance or low performance. In the next chapter, we will deep dive into the various scoring and evaluation metrics. ML.NET provides a relatively easy interface to evaluate a model; however, each algorithm has unique properties to verify, which we will review as we deep dive into the various algorithms.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Exploring types of learning</h1>
                </header>
            
            <article>
                
<p>Now that you understand the steps that make up the model building process, the next major component to introduce is the two main types of learning. There are several other types of machine learning, such as reinforcement learning. However, for the scope of this book, we will focus on the two types used for the algorithms ML.NET provides—supervised learning and unsupervised learning. If you are curious about the other types of learning, check out <em>Machine Learning Algorithms</em>, Giuseppe Bonaccorso, Packt Publishing.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Supervised learning</h1>
                </header>
            
            <article>
                
<p>Supervised learning is the more common of the two types, and, as such, it is also used for most of the algorithms we will cover in this book. Simply put, supervised learning entails you, as the data scientist, passing the known outputs as part of the training to the model. Take, for instance, the election example discussed earlier in this chapter. With supervised learning, every data point in the election polls that is used as a feature along with whom they say will vote for, are sent to the model during training. This step is traditionally called <strong>labeling</strong> in classification algorithms, in which the output values will be one of the pre-training labels.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Unsupervised learning</h1>
                </header>
            
            <article>
                
<p>Conversely, in unsupervised learning, the typical use case is when figuring out the input and output labels proves to be difficult. Using the election scenario, when you are unsure of what features are really going to provide data points for the model to determine a voter's vote, unsupervised learning could provide value and insight. The benefit of this approach is that the algorithm of your choice determines what features drive your labeling. For instance, using a clustering algorithm such as k-means, you could submit all of the voter data points to the model. The algorithm would then be able to group voter data into clusters and predict unseen data. We will deep dive into unsupervised learning with clustering in Chapter 5<em>, Clustering Model</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Exploring various machine learning algorithms</h1>
                </header>
            
            <article>
                
<p>At the heart of machine learning are the various algorithms used to solve complex problems. As mentioned in the introduction, this book will cover five algorithms:</p>
<ul>
<li>Binary classification</li>
<li>Regression</li>
<li>Anomaly detection</li>
<li>Clustering</li>
<li>Matrix factorization</li>
</ul>
<p class="mce-root">Each will be the focus of a chapter later in the book, but for now, let's get a quick overview of them.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Binary classification</h1>
                </header>
            
            <article>
                
<p>One of the easiest algorithms to understand is binary classification. Binary classification is a supervised machine learning algorithm. As the name implies, the output of a model trained with a binary classification algorithm will return a true or false conviction (as in 0 or 1). Problems best suited to a binary classification model include determining whether a comment is hateful or whether a file is malicious. ML.NET provides several binary classification model algorithms, which we will cover in Chapter 4, <em>Classification Model</em>, along with a working example of determining whether a file is malicious or not.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Regression</h1>
                </header>
            
            <article>
                
<p>Another powerful yet easy-to-understand algorithm is regression. Regression is another supervised machine learning algorithm. Regression algorithms return a real value as opposed to a binary algorithm or ones that return from a set of specific values. You can think of regression algorithms as an algebra equation solver where there are a number of known values and the goal is to predict the one unknown value. Some examples of problems best suited to regression algorithms are predicting attrition, weather forecasting, stock market predictions, and house pricing, to name a few. </p>
<p>In addition, there is a subset of regression algorithms called <strong>logistic regression</strong> models. Whereas a traditional linear regression algorithm, as described earlier, returns the predicted value, a logistic regression model will return the probability of the outcome occurring.</p>
<p>ML.NET provides several regression model algorithms, which we will cover in Chapter 3, <em>Regression Model</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Anomaly detection</h1>
                </header>
            
            <article>
                
<p>Anomaly detection, as the name implies, looks for unexpected events in the data submitted to the model. Data for this algorithm, as you can probably guess, requires data over a period of time. Anomaly detection in ML.NET looks at both spikes and change points. <strong>Spikes</strong>, as the name implies, are temporary, whereas <strong>change points</strong> are the starting points of a longer change.</p>
<p>ML.NET provides an anomaly detection algorithm, which we will cover in Chapter 6, <em>Anomaly Detection Model</em>.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Clustering</h1>
                </header>
            
            <article>
                
<p>Clustering algorithms are unsupervised algorithms and offer a unique solution to problems where finding the closest match to related items is the desired solution. During the training of the data, the data is grouped based on the features, and then during the prediction, the closest match is chosen. Some examples of the use of clustering algorithms include file type classification and predicting customer choices. </p>
<p>ML.NET uses the k-means algorithm specifically, which we will deep dive into in Chapter 5, <em>Clustering Model</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Matrix factorization</h1>
                </header>
            
            <article>
                
<p>Last but not least, the matrix factorization algorithm provides a powerful and easy-to-use algorithm for providing recommendations. This algorithm is tailored to problems where historical data is available and the problem to solve is predicting a selection from that data, such as movie or music predictions. Netflix's movie suggestion system uses a form of matrix factorization for its suggestions about what movies it thinks you will enjoy. </p>
<p>We will cover matrix factorization in detail in Chapter 7, <em>Matrix Factorization Model</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">What is ML.NET?</h1>
                </header>
            
            <article>
                
<p><span>Now that you have a fairly firm understanding of the core machine learning concepts, we can now dive into Microsoft's ML.NET framework. </span>ML.NET is Microsoft's premier machine learning framework. It provides an easy-to-use framework to train, create, and run models with relative ease all in the confines of the .NET ecosystem.</p>
<p>Microsoft's ML.NET was announced and released (version 0.1) in May 2018 at Microsoft's developer conference BUILD in Seattle, Washington. The project itself is open source with an MIT License on GitHub (<a href="https://github.com/dotnet/machinelearning">https://github.com/dotnet/machinelearning</a>) and has seen a total of 17 updates since the first release at the time of writing.</p>
<p>Some products using ML.NET internally at Microsoft include Chart Decisions in Excel, Slide Designs in PowerPoint, Windows Hello, and Azure Machine Learning. This emphasizes the production-readiness of ML.NET for your own production deployments.</p>
<p class="mce-root"/>
<p>ML.NET, from the outset, was designed and built to facilitate the use of machine learning for C# and F# developers using an architecture that would come naturally to someone familiar with .NET Framework. Until ML.NET arrived, there was not a full-fledged and supported framework where you could not only train but also run a model without leaving the .NET ecosystem. Google's TensorFlow, for instance, has an open-source wrapper written by Miguel de Icaza available on GitHub (<a href="https://github.com/migueldeicaza/TensorFlowSharp">https://github.com/migueldeicaza/TensorFlowSharp</a>); however, at the time of writing this book, most workflows require the use of Python to train a model, which can then be consumed by a C# wrapper to run a prediction.</p>
<p>In addition, Microsoft was intent on supporting all of the major platforms .NET developers have grown accustomed to publishing their applications in the last several years. Here are some examples of a few of the platforms, with the frameworks they targeted in parentheses:</p>
<ul>
<li>Web (ASP.NET)</li>
<li>Mobile (Xamarin)</li>
<li>Desktop (UWP, WPF, and WinForms)</li>
<li>Gaming (MonoGame and SharpDX)</li>
<li>IoT (.NET Core and UWP)</li>
</ul>
<p>Later in this book, we will implement several real-world applications on most of these platforms to demonstrate how to integrate ML.NET into various application types and platforms. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical details of ML.NET</h1>
                </header>
            
            <article>
                
<p>With the release of ML.NET 1.4, the targeting of .NET Core 3.0 or later is recommended to take advantage of the hardware intrinsics added as part of .NET Core 3.0. For those unfamiliar, .NET Core 2.x (and earlier) along with .NET Framework are optimized for CPUs with <strong>Streaming</strong> <strong>SIMD</strong> <strong>Extensions </strong>(<strong>SSE</strong>). Effectively, these instructions provide an optimized path for performing several CPU instructions on a dataset. This approach is referred to as <strong>Single Instruction Multiple Data</strong> (<strong>SIMD</strong>). Given that the SSE CPU extensions were first added in the Pentium III back in 1999 and later added by AMD in the Athlon XP in 2001, this has provided an extremely backward-compatible path. However, this also does not allow code to take advantage of all the advancements made in CPU extensions made in the last 20 years. One such advancement is the <strong>Advanced Vector Extensions</strong> (<strong>AVX</strong>) available on most Intel and AMD CPUs created in 2011 or later.</p>
<p class="mce-root"/>
<p>This provides eight 32-bit operations in a single instruction, compared to the four SSE provides. As you can probably guess, machine learning can take advantage of this doubling of instructions. For CPUs in .NET Core 3 that are not supported yet (such as ARM), .NET Core 3 automatically falls back to a software-based implementation.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Components of ML.NET</h1>
                </header>
            
            <article>
                
<p>As mentioned previously, ML.NET was designed to be intuitive for experienced .NET developers. The architecture and components are very similar to the patterns found in ASP.NET and WPF.</p>
<p>At the heart of ML.NET is the <kbd>MLContext</kbd> object. Similar to <kbd>AppContext</kbd> in a .NET application, <kbd>MLContext</kbd> is a singleton class. The <kbd>MLContext</kbd> object itself provides access to all of the trainer catalogs ML.NET offers (some are offered by additional NuGet packages). You can think of a trainer catalog in ML.NET as a specific algorithm such as binary classification or clustering.</p>
<p>Here are some of the ML.NET catalogs:</p>
<ul>
<li>Anomaly detection</li>
<li>Binary classification</li>
<li>Clustering</li>
<li>Forecasting</li>
<li>Regression</li>
<li>Time series</li>
</ul>
<p>These six groups of algorithms were reviewed earlier in this chapter and will be covered in more detail in subsequent dedicated chapters in this book.</p>
<p>In addition, added recently in ML.NET 1.4 was the ability to import data directly from a database. This feature, while in preview at the time of writing, can facilitate not only an easier feature extraction process, but also expands the possibilities of making real-time predictions in an existing application or pipeline possible. All major databases are supported, including SQL Server, Oracle, SQLite, PostgreSQL, MySQL, DB2, and Azure SQL. We will explore this feature in Chapter 4, <em>Classification Model</em>, with a console application using a SQLite database.</p>
<p class="mce-root"/>
<p>The following diagram presents the high-level architecture of ML.NET:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-667 image-border" src="assets/0f58aa45-9a06-4e5a-8b4f-c83da9236fbd.png" style="width:11.92em;height:25.08em;"/></p>
<p>Here, you can see an almost exact match to the traditional machine learning process. This was intentionally done to reduce the learning curve for those familiar with other frameworks. Each step in the architecture can be summarized as follows:</p>
<ol>
<li><strong>IDataView</strong>: This is used to store the loaded training data into memory.</li>
<li><strong>Creating a Pipeline</strong>: The pipeline creation maps the <kbd>IDataView</kbd> object properties to values to send to the model for training.</li>
<li class="CDPAlignLeft CDPAlign"><strong>Fit()</strong>: Regardless of the algorithm, after the pipeline has been created, calling <kbd>Fit()</kbd> kicks off the actual model training.</li>
<li><strong>Save()</strong>: As the name implies, this saves the model (in a binary format) to a file.</li>
<li><strong>ITransformer</strong>:<strong> </strong>This loads the model back into memory to run predictions.</li>
<li><strong>Evaluate()</strong>: As the name implies, this evaluates the model (<a href="b8decd34-4bcb-4b1b-80d2-b2bfd0fa31c1.xhtml">Chapter 2</a>, <em>Setting Up the ML.NET Environment</em> will dive further into the evaluation architecture).</li>
</ol>
<p>Over the course of this book, we will dive into these methods more thoroughly.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Extensibility of ML.NET</h1>
                </header>
            
            <article>
                
<p>Lastly, ML.NET, like most robust frameworks, provides considerable extensibility. Microsoft has since launched added extensibility support to be able to run the following externally trained model types, among others:</p>
<ul>
<li>TensorFlow</li>
<li>ONNX</li>
<li>Infer.Net</li>
<li>CNTK</li>
</ul>
<p>TensorFlow (<a href="https://www.tensorflow.org/">https://www.tensorflow.org/</a>), as mentioned previously, is Google's machine learning framework with officially supported bindings for C++, Go, Java, and JavaScript. Additionally, TensorFlow can be accelerated with GPUs and, as previously mentioned, Google's own TPUs. In addition, like ML.NET, it offers the ability to run predictions on a wide variety of platforms, including iOS, Android, macOS, ARM, Linux, and Windows. Google provides several pre-trained models. One of the more popular models is the image classification model, which classifies objects in a submitted image. Recent improvements in ML.NET have enabled you to create your own image classifier based on that pre-trained model. We will be covering this scenario in detail in <a href="049e90c4-05b0-466d-af93-d56df861a843.xhtml">Chapter 12</a>, <em>Using TensorFlow with ML.NET</em>.</p>
<p>ONNX (<a href="https://onnx.ai/">https://onnx.ai/</a>), an acronym for Open Neural Network Exchange Format, is a widely used format in the data science field due to the ability to export to a common format. ONNX has converters for XGBoost, TensorFlow, scikit-learn, LibSVM, and CoreML, to name a few. Microsoft's native support of the ONNX format in ML.NET will not only allow better extensibility with existing machine learning pipelines but also increase the adoption of ML.NET in the machine learning world. We will utilize a pre-trained ONNX format model in <a href="788ee637-ad9b-4ddf-8018-b804d3004404.xhtml">Chapter 13</a>, <em>Using ONNX with ML.NET</em>.</p>
<p>Infer.Net is another open source Microsoft machine learning framework that focuses on probabilistic programming. You might be wondering what probabilistic programming is. At a high level, probabilistic programming handles the grey area where traditional variable types are definite, such as Booleans or integers. Probabilistic programming uses random variables that have a range of values that the result could be, akin to an array. The difference between a regular array and the variables in probabilistic programming is that for every value, there is a probability that the specific value would occur.</p>
<p>A great real-world use of Infer.Net is the technology behind Microsoft's TrueSkill. TrueSkill is a rating system that powers the matchmaking in <em>Halo</em> and <em>Gears of War</em>, where players are matched based on a multitude of variables, play types, and also, maps can all be attributed to how even two players are. While outside the scope of this book, a great whitepaper diving further into Infer.Net and probabilistic programming, in general, can be found here: <a href="https://dotnet.github.io/infer/InferNet_Intro.pdf">https://dotnet.github.io/infer/InferNet_Intro.pdf</a>.</p>
<p>CNTK, also from Microsoft, which is short for Cognitive Toolkit, is a deep learning toolkit with a focus on neural networks. One of the unique features of CNTK is its use of describing neural networks via a directed graph. While outside the scope of this book (we will cover neural networks in Chapter 12 with TensorFlow), the world of feed-forward Deep Neural Networks, Convolutional Neural Networks, and Recurrent Neural Networks is extremely fascinating. To dive further into neural networks specifically, I would suggest <em>Hands-On Neural Network Programming with C#</em>, also from Packt.</p>
<p>Additional extensibility into Azure and other model support such as PyTorch (<a href="https://pytorch.org/">https://pytorch.org/</a>) is on the roadmap, but no timeline has been established at the time of writing.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, you have learned the importance of discovering machine learning. In addition, you have also learned the core concepts of machine learning, including the differences in learning and the various algorithms we will cover later in this book. You have also received an introduction to ML.NET. The core concepts in this chapter are the foundation for the rest of the book and we will be building on them with each subsequent chapter. In the next chapter, we will be setting up your environment and training your first model in ML.NET! </p>


            </article>

            
        </section>
    </body></html>