<html><head></head><body>
        

                            
                    <h1 class="header-title">An Introduction to the Basics of OpenCV</h1>
                
            
            
                
<p>After covering OpenCV installation on different operating systems in <a href="96b225d4-84bc-4d49-b8b3-079b15f05cf0.xhtml">Chapter 1</a>, <em>Getting Started with OpenCV</em>, we are going to introduce the basics of OpenCV development in this chapter. It begins with showing how to create our project using CMake. We are going to introduce the basic image data structures and matrices, along with other structures that are required to work in our projects. We are going to introduce how to save our variables and data into files using the XML/YAML persistence OpenCV functions.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Configuring projects with CMake</li>
<li>Reading/writing images from/to disk</li>
<li>Reading videos and accessing camera devices</li>
<li>The main image structures (for example, matrices)</li>
<li>Other important and basic structures (for example, vectors and scalars)</li>
<li>An introduction to basic matrix operations</li>
<li>File storage operations with XML/YAML persistence OpenCV API</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Technical requirements</h1>
                
            
            
                
<p>This chapter requires familiarity with the basic C++ programming language. All the code used in this chapter can be downloaded from the following GitHub link: <a href="https://github.com/PacktPublishing/Learn-OpenCV-4-By-Building-Projects-Second-Edition/tree/master/Chapter_02">https://github.com/PacktPublishing/Learn-OpenCV-4-By-Building-Projects-Second-Edition/tree/master/Chapter_02</a>. The code can be executed on any operating system, though it is only tested on Ubuntu.<br/>
Check out the following video to see the Code in Action:<br/>
<a href="http://bit.ly/2QxhNBa">http://bit.ly/2QxhNBa</a></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Basic CMake configuration file</h1>
                
            
            
                
<p>To configure and check all the requisite dependencies for our project, we are going to use CMake, but it is not the only way that this can be done; we can configure our project in any other tool or IDE, such as <strong>Makefiles</strong> or <strong>Visual Studio</strong>, but CMake is a more portable way to configure multiplatform <strong>C++</strong> projects.</p>
<p>CMake uses configuration files called <kbd>CMakeLists.txt</kbd>, where the compilation and dependencies process is defined. For a basic project based on an executable built from a single source code file, a <kbd>CMakeLists.txt</kbd> file comprising three lines is all that is required. The file looks as follows:</p>
<pre>cmake_minimum_required (VERSION 3.0) 
project (CMakeTest) 
add_executable(${PROJECT_NAME} main.cpp) </pre>
<p>The first line defines the minimum version of CMake required. This line is mandatory in our <kbd>CMakeLists.txt</kbd> file and allows us to use the functionality of CMake defined from a specific version; in our case, we require a minimum of CMake 3.0. The second line defines the project name. This name is saved in a variable called <kbd>PROJECT_NAME</kbd>.</p>
<p>The last line creates an executable command (<kbd>add_executable()</kbd>) from the <kbd>main.cpp</kbd> file, gives it the same name as our project (<kbd>${PROJECT_NAME}</kbd>), and compiles our source code into an executable called <strong>CMakeTest</strong> which is the name that we set up as a project name. The <kbd>${}</kbd> expression allows access to any variable defined in our environment. Then, we can use the <kbd>${PROJECT_NAME}</kbd> variable as an executable output name.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a library</h1>
                
            
            
                
<p>CMake allows us to create libraries used by the OpenCV build system. Factorizing shared code among multiple applications is a common and useful practice in software development. In big applications, or common code shared in multiple applications, this practice is very useful. In this case, we do not create a binary executable, but instead we create a compiled file that includes all the functions, classes, and so on. We can then share this library file with other applications without sharing our source code.</p>
<p>CMake includes the <kbd>add_library</kbd> function to this end:</p>
<pre># Create our hello library 
    add_library(Hello hello.cpp hello.h) 
 
# Create our application that uses our new library 
    add_executable(executable main.cpp) 
 
# Link our executable with the new library 
    target_link_libraries(executable Hello) </pre>
<p>The lines starting with <kbd>#</kbd> add comments and are ignored by CMake. The <kbd>add_library</kbd> (<kbd>Hello hello.cpp hello.h</kbd>) command defines the source files of our library and its name, where <kbd>Hello</kbd> is the library name and <kbd>hello.cpp</kbd> and <kbd>hello.h</kbd> are the source files. We add the header file too to allow IDEs such as Visual Studio to link to the header files. This line is going to generate a shared (<kbd>.so</kbd> for Mac OS X, and Unix or <kbd>.dll</kbd> for Windows) or static library (<kbd>.a</kbd> for Mac OS X, and Unix or <kbd>.lib</kbd> for Windows) file, depending on whether we add a <kbd>SHARED</kbd> or <kbd>STATIC</kbd> word between library name and source files. <kbd>target_link_libraries(executable Hello)</kbd> is the function that links our executable to the desired library, in our case, the <kbd>Hello</kbd> library.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Managing dependencies</h1>
                
            
            
                
<p>CMake has the ability to search our dependencies and external libraries, giving us the ability to build complex projects, depending on the external components in our projects, and add some requirements.</p>
<p>In this book, the most important dependency is, of course, OpenCV, and we will add it to all of our projects:</p>
<pre>    cmake_minimum_required (VERSION 3.0) 
    PROJECT(Chapter2) 
# Requires OpenCV 
    FIND_PACKAGE( OpenCV 4.0.0 REQUIRED ) 
# Show a message with the opencv version detected 
    MESSAGE("OpenCV version : ${OpenCV_VERSION}") <br/># Add the paths to the include directories/to the header files
    include_directories(${OpenCV_INCLUDE_DIRS}) <br/># Add the paths to the compiled libraries/objects
    link_directories(${OpenCV_LIB_DIR}) 
# Create a variable called SRC 
    SET(SRC main.cpp) 
# Create our executable 
    ADD_EXECUTABLE(${PROJECT_NAME} ${SRC}) 
# Link our library 
    TARGET_LINK_LIBRARIES(${PROJECT_NAME} ${OpenCV_LIBS})</pre>
<p class="mce-root"/>
<p>Now, let's understand the working of the script from the following:</p>
<pre>cmake_minimum_required (VERSION 3.0) 
cmake_policy(SET CMP0012 NEW) 
PROJECT(Chapter2) </pre>
<p>The first line defines the minimum CMake version, and the second line tells CMake to use the new behavior of CMake to facilitate recognition of the correct numbers and Boolean constants without dereferencing variables with such names; this policy was introduced in CMake 2.8.0, and CMake warns when the policy is not set from version 3.0.2. Finally, the last line defines the project title. After defining the project name, we have to define the requirements, libraries, and dependencies:</p>
<pre># Requires OpenCV 
    FIND_PACKAGE( OpenCV 4.0.0 REQUIRED ) 
# Show a message with the opencv version detected 
    MESSAGE("OpenCV version : ${OpenCV_VERSION}") 
    include_directories(${OpenCV_INCLUDE_DIRS}) 
    link_directories(${OpenCV_LIB_DIR})</pre>
<p>Here is where we search for our OpenCV dependency. <kbd>FIND_PACKAGE</kbd> is the function that allows us to find our dependencies, the minimum version required, and whether this dependency is required or optional. In this sample script, we look for OpenCV in version 4.0.0 or greater and state that it is a required package.</p>
<p>The <kbd>FIND_PACKAGE</kbd> command includes all OpenCV submodules, but you can specify the submodules that you want to include in the project by executing your application smaller and faster. For example, if we are only going to work with the basic OpenCV types and core functionality, we can use the following command: <kbd>FIND_PACKAGE(OpenCV 4.0.0 REQUIRED core)</kbd>.</p>
<p>If CMake does not find it, it returns an error and does not prevent us from compiling our application. The <kbd>MESSAGE</kbd> function shows a message in the terminal or CMake GUI. In our case, we are showing the OpenCV version as follows:</p>
<pre>OpenCV version : 4.0.0</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The <kbd>${OpenCV_VERSION}</kbd> is a variable where CMake stores the OpenCV package version.  <kbd>include_directories()</kbd> and <kbd>link_directories()</kbd> add to our environment the headers and the directory of the specified library. OpenCV CMake's module saves this data in the <kbd>${OpenCV_INCLUDE_DIRS}</kbd> and <kbd>${OpenCV_LIB_DIR}</kbd> variables. These lines are not required in all platforms, such as Linux, because these paths normally are in the environment, but it's recommended to have more than one OpenCV version to choose the correct link and include directories. Now is the time to include our developed sources:</p>
<pre># Create a variable called SRC 
    SET(SRC main.cpp) 
# Create our executable 
    ADD_EXECUTABLE(${PROJECT_NAME} ${SRC}) 
# Link our library 
    TARGET_LINK_LIBRARIES(${PROJECT_NAME} ${OpenCV_LIBS}) </pre>
<p>This last line creates the executable and links the executable with the OpenCV library, as we saw in the previous section, <em>Creating a library</em>. There is a new function in this piece of code, <kbd>SET</kbd>; this function creates a new variable and adds to it any value that we need. In our case, we incorporate the <kbd>main.cpp</kbd> value in the <kbd>SRC</kbd> variable. We can add more and more values to the same variable, as can be seen in the following script:</p>
<pre>SET(SRC main.cpp 
        utils.cpp 
        color.cpp<br/>)</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Making the script more complex</h1>
                
            
            
                
<p>In this section, we are showing a more complex script that includes subfolders, libraries, and executables; all told, just two files and a few lines, as demonstrated in this script. It's not mandatory to create multiple <kbd>CMakeLists.txt</kbd> files, because we can specify everything in the main <kbd>CMakeLists.txt</kbd> file. However, it is more common to use different <kbd>CMakeLists.txt</kbd> files for each project subfolder, thereby making it more flexible and portable.</p>
<p>This example has a code structure folder, which contains one folder for a <kbd>utils</kbd> library and the root folder, which contains the main executable:</p>
<pre>CMakeLists.txt 
main.cpp 
utils/ 
   CMakeLists.txt 
   computeTime.cpp 
   computeTime.h 
   logger.cpp 
   logger.h 
   plotting.cpp 
   plotting.h </pre>
<p>Then, we have to define two <kbd>CMakeLists.txt</kbd> files, one in the root folder and the other in the <kbd>utils</kbd> folder. The <kbd>CMakeLists.txt</kbd> root folder file has the following content:</p>
<pre>    cmake_minimum_required (VERSION 3.0) 
    project (Chapter2) 
 
# Opencv Package required 
    FIND_PACKAGE( OpenCV 4.0.0 REQUIRED ) 
 
#Add opencv header files to project 
    include_directories(${OpenCV_INCLUDE_DIR}) 
    link_directories(${OpenCV_LIB_DIR}) 
<br/># Add a subdirectory to the build. 
    add_subdirectory(utils)
 
# Add optional log with a precompiler definition 
    option(WITH_LOG "Build with output logs and images in tmp" OFF) 
    if(WITH_LOG) 
       add_definitions(-DLOG) 
    endif(WITH_LOG) 
 
# generate our new executable 
    add_executable(${PROJECT_NAME} main.cpp) 
# link the project with his dependencies 
    target_link_libraries(${PROJECT_NAME} ${OpenCV_LIBS} Utils) </pre>
<p>Almost all lines are described in previous sections, except some functions which we will explain. <kbd>add_subdirectory()</kbd> tells CMake to analyze <kbd>CMakeLists.txt</kbd> of a desired subfolder. Before continuing with the main <kbd>CMakeLists.txt</kbd> file explanation, we are going to explain the <kbd>CMakeLists.txt</kbd> file in <kbd>utils</kbd>.</p>
<p>In the <kbd>CMakeLists.txt</kbd> file of the <kbd>utils</kbd> folders, we are going to write a new library to include in our main project folder:</p>
<pre># Add new variable for src utils lib 
    SET(UTILS_LIB_SRC 
       computeTime.cpp  
       logger.cpp  
       plotting.cpp 
    ) 
# create our new utils lib 
    add_library(Utils ${UTILS_LIB_SRC}) 
# make sure the compiler can find include files for our library 
    target_include_directories(Utils PUBLIC ${CMAKE_CURRENT_SOURCE_DIR}) </pre>
<p>This CMake script file defines a variable, <kbd>UTILS_LIB_SRC</kbd>, where we add all source files included in our library, generate the library with the <kbd>add_library</kbd> function, and use the <kbd>target_include_directories</kbd> function to allow our main project to detect all header files. Leaving the <kbd>utils</kbd> subfolder and continuing with the root CMake script, the Option function creates a new variable, in our case <kbd>WITH_LOG</kbd>, with a small description attached. This variable could be changed through the <kbd>ccmake</kbd> command line or CMake GUI interface, where the description appears, and a check that allows users to enable or disable this option. This function is very useful for allowing the user to decide about compile-time features, such as whether we want enabling or disabling logs or not, compiling with Java or Python support, just as OpenCV does, and so on.</p>
<p>In our case, we use this option to enable a logger in our application. To enable the logger, we use a pre-compiler definition in our code, as follows:</p>
<pre>#ifdef LOG 
    logi("Number of iteration %d", i); 
#endif </pre>
<p class="mce-root">This LOG macro can be defined in our <kbd>CMakeLists.txt</kbd> through a call to the <kbd>add_definitions</kbd> function (<kbd>-DLOG</kbd>), which itself can be run or hidden by the CMake variable <kbd>WITH_LOG</kbd> with a simple condition:</p>
<pre>if(WITH_LOG) 
   add_definitions(-DLOG) 
endif(WITH_LOG) </pre>
<p class="CDPAlignLeft CDPAlign">Now we are ready to create our CMake script files to compile our computer vision projects in any operating system. Then, we are going to continue with the OpenCV basics before starting with a sample project.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Images and matrices</h1>
                
            
            
                
<p class="CDPAlignLeft CDPAlign">The most important structure in computer vision is, without doubt, the images. The image in a computer vision is the representation of the physical world captured with a digital device. This picture is only a sequence of numbers stored in a matrix format (refer to the following diagram). Each number is a measurement of the light intensity for the considered wavelength (for example, red, green, or blue in color images) or for a wavelength range (for panchromatic devices). Every point in an image is called a <strong>pixel</strong> (for a picture element), and each pixel can store one or more values depending on whether it is a black and white image (also referred to as a binary image) that stores only one value, such as <kbd>0</kbd> or <kbd>1</kbd>, a grayscale-level image that stores two values, or a color image that stores three values. These values are usually between <kbd>0</kbd> and <kbd>255</kbd> in an integer number, but you can use other ranges, for example <kbd>0</kbd> to <kbd>1</kbd> in floating point numbers, as in <strong>h</strong><strong>igh dynamic range imaging</strong> (<strong>HDRI</strong>) or thermal images:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-789 image-border" src="img/b3fbe085-1348-4509-b06e-19b81bd90ff2.png" style="width:27.50em;height:18.83em;"/></p>
<p class="CDPAlignLeft CDPAlign">The image is stored in a matrix format, where each pixel has a position in it and can be referenced by the number of the column and row. OpenCV uses the <kbd>Mat</kbd> class for this purpose. In the case of a grayscale image, a single matrix is used, as demonstrated in the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-790 image-border" src="img/3eaa7307-485b-4c00-920c-214e393189f5.png" style="width:27.42em;height:25.42em;"/></p>
<p>In the case of a color image, such as the following diagram, we use a matrix of width x height x the number of color channels:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-791 image-border" src="img/0e7d1b24-152c-4bd4-a135-a25dab51c9af.png" style="width:30.75em;height:26.08em;"/></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>But the <kbd>Mat</kbd> class is not only for storing images; it also enables you to store any type of matrix and different sizes. You can use it as an algebraic matrix and perform operations with it. In the following sections, we are going to describe the most important matrix operations, such as addition,  multiplication, diagonalization. But, before that, it's important to know how the matrix is stored internally in the computer memory, because it is always more efficient to access the memory slots instead of accessing each pixel with the OpenCV functions.</p>
<p>In memory, the matrix is saved as an array or sequence of values ordered by columns and rows. The following table shows the sequence of pixels in <strong>BGR</strong> image format:</p>
<table style="border-collapse: collapse;width: 660px;height: 307px" class="table" border="1">
<tbody>
<tr style="height: 67px">
<td style="width: 208px;height: 67px" colspan="9">
<p class="CDPAlignLeft CDPAlign">Row 0</p>
</td>
<td style="width: 207px;height: 67px" class="CDPAlignLeft CDPAlign" colspan="9">
<p>Row 1</p>
</td>
<td style="width: 235px;height: 67px" class="CDPAlignLeft CDPAlign" colspan="9">
<p>Row 2</p>
</td>
</tr>
<tr style="height: 58px">
<td style="width: 63px;height: 58px" colspan="3">
<p>Col 0</p>
</td>
<td style="width: 68px;height: 58px" colspan="3">
<p>Col 1</p>
</td>
<td style="width: 71px;height: 58px" colspan="3">
<p>Col 2</p>
</td>
<td style="width: 65px;height: 58px" colspan="3">
<p>Col 0</p>
</td>
<td style="width: 68px;height: 58px" colspan="3">
<p>Col 1</p>
</td>
<td style="width: 68px;height: 58px" colspan="3">
<p>Col 2</p>
</td>
<td style="width: 70px;height: 58px" colspan="3">
<p>Col 0</p>
</td>
<td style="width: 75px;height: 58px" colspan="3">
<p>Col 1</p>
</td>
<td style="width: 84px;height: 58px" colspan="3">
<p>Col 2</p>
</td>
</tr>
<tr style="height: 74.2656px">
<td style="width: 63px;height: 74.2656px" colspan="3">
<p>Pixel  1</p>
</td>
<td style="width: 68px;height: 74.2656px" colspan="3">
<p>Pixel 2</p>
</td>
<td style="width: 71px;height: 74.2656px" colspan="3">
<p>Pixel 3</p>
</td>
<td style="width: 65px;height: 74.2656px" colspan="3">
<p>Pixel 4</p>
</td>
<td style="width: 68px;height: 74.2656px" colspan="3">
<p>Pixel 5</p>
</td>
<td style="width: 68px;height: 74.2656px" colspan="3">
<p>Pixel 6</p>
</td>
<td style="width: 70px;height: 74.2656px" colspan="3">
<p>Pixel 7</p>
</td>
<td style="width: 75px;height: 74.2656px" colspan="3">
<p>Pixel 8</p>
</td>
<td style="width: 84px;height: 74.2656px" colspan="3">
<p>Pixel 9</p>
</td>
</tr>
<tr style="height: 64px">
<td style="width: 17px;height: 64px">
<p>B</p>
</td>
<td style="width: 20px;height: 64px">
<p>G</p>
</td>
<td style="width: 20px;height: 64px">
<p>R</p>
</td>
<td style="width: 21px;height: 64px">
<p>B</p>
</td>
<td style="width: 22px;height: 64px">
<p>G</p>
</td>
<td style="width: 19px;height: 64px">
<p>R</p>
</td>
<td style="width: 20px;height: 64px">
<p>B</p>
</td>
<td style="width: 23px;height: 64px">
<p>G</p>
</td>
<td style="width: 22px;height: 64px">
<p>R</p>
</td>
<td style="width: 21px;height: 64px">
<p>B</p>
</td>
<td style="width: 19px;height: 64px">
<p>G</p>
</td>
<td style="width: 19px;height: 64px">
<p>R</p>
</td>
<td style="width: 23px;height: 64px">
<p>B</p>
</td>
<td style="width: 21px;height: 64px">
<p>G</p>
</td>
<td style="width: 18px;height: 64px">
<p>R</p>
</td>
<td style="width: 18px;height: 64px">
<p>B</p>
</td>
<td style="width: 21px;height: 64px">
<p>G</p>
</td>
<td style="width: 23px;height: 64px">
<p>R</p>
</td>
<td style="width: 18px;height: 64px">
<p>B</p>
</td>
<td style="width: 17px;height: 64px">
<p>G</p>
</td>
<td style="width: 29px;height: 64px">
<p>R</p>
</td>
<td style="width: 20px;height: 64px">
<p>B</p>
</td>
<td style="width: 30px;height: 64px">
<p>G</p>
</td>
<td style="width: 19px;height: 64px">
<p>R</p>
</td>
<td style="width: 25px;height: 64px">
<p>B</p>
</td>
<td style="width: 23px;height: 64px">
<p>G</p>
</td>
<td style="width: 30px;height: 64px">
<p>R</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>With this order, we can access any pixel by observing the following formula:</p>
<pre>Value= Row_i*num_cols*num_channels + Col_i + channel_i </pre>
<p>OpenCV functions are quite optimized for random access, but sometimes, direct access to the memory (work with pointer arithmetic) is more efficient, for example, when we have to access all pixels in a loop.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Reading/writing images</h1>
                
            
            
                
<p>Following the introduction to matrices, we are going to start with the OpenCV code basics. The first thing that we have to learn is how to read and write images:</p>
<pre>#include &lt;iostream&gt; 
#include &lt;string&gt; 
#include &lt;sstream&gt; 
using namespace std; 
 
// OpenCV includes 
#include "opencv2/core.hpp" 
#include "opencv2/highgui.hpp" 
using namespace cv; 
 
int main(int argc, const char** argv) 
{ 
   // Read images 
   Mat color= imread("../lena.jpg"); 
   Mat gray= imread("../lena.jpg",CV_LOAD_IMAGE_GRAYSCALE); 
<br/>  if(! color.data ) // Check for invalid input<br/> {<br/> cout &lt;&lt; "Could not open or find the image" &lt;&lt; std::endl ;<br/> return -1;<br/> }
   // Write images 
   imwrite("lenaGray.jpg", gray); 
    
   // Get same pixel with opencv function 
   int myRow=color.cols-1; 
   int myCol=color.rows-1; 
   Vec3b pixel= color.at&lt;Vec3b&gt;(myRow, myCol); 
   cout &lt;&lt; "Pixel value (B,G,R): (" &lt;&lt; (int)pixel[0] &lt;&lt; "," &lt;&lt; (int)pixel[1] &lt;&lt; "," &lt;&lt; (int)pixel[2] &lt;&lt; ")" &lt;&lt; endl; 
    
   // show images 
   imshow("Lena BGR", color); 
   imshow("Lena Gray", gray); 
   // wait for any key press 
   waitKey(0); 
   return 0; 
} 
 </pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Let's now move on to understanding the code:</p>
<pre>// OpenCV includes 
#include "opencv2/core.hpp" 
#include "opencv2/highgui.hpp" 
using namespace cv; </pre>
<p>First, we have to include the declarations of the functions that we need in our sample. These functions come from <kbd>core</kbd> (basic image data handling) and <kbd>highgui</kbd> (cross-platform I/O functions provided by OpenCV are <kbd>core</kbd> and <kbd>highui;</kbd>; the first includes the basic classes, such as matrices, while the second includes the functions to read, write, and show images with graphical interfaces). Now it is time to read images:</p>
<pre>// Read images 
Mat color= imread("../lena.jpg"); 
Mat gray= imread("../lena.jpg",CV_LOAD_IMAGE_GRAYSCALE); </pre>
<p><kbd>imread</kbd> is the main function for reading images. This function opens an image and stores it in a matrix format. <kbd>imread</kbd> accepts two parameters. The first parameter is a string containing the image's path, while the second is optional and, by default, loads the image as a color image. The second parameter allows the following options:</p>
<ul>
<li><kbd>cv::IMREAD_UNCHANGED</kbd>: If set, this returns a 16-bit/32-bit image when the input has the corresponding depth, otherwise it converts it to 8-bit</li>
<li><kbd>cv::IMREAD_COLOR</kbd>: If set, this always converts an image to a color one (BGR, 8-bit unsigned)</li>
<li><kbd>cv::IMREAD_GRAYSCALE</kbd>: If set, this always converts an image to a grayscale one (8-bit unsigned)</li>
</ul>
<p>To save images, we can use the <kbd>imwrite</kbd> function, which stores a matrix image in our computer:</p>
<pre>// Write images 
imwrite("lenaGray.jpg", gray); </pre>
<p>The first parameter is the path where we want to save the image with the extension format that we desire. The second parameter is the matrix image that we want to save. In our code sample, we create and store a gray version of the image and then save it as a <kbd>.jpg</kbd> file. The gray image that we loaded will be stored in the gray variable:</p>
<pre>// Get same pixel with opencv function 
int myRow=color.cols-1; 
int myCol=color.rows-1;</pre>
<p>Using the <kbd>.cols</kbd> and <kbd>.rows</kbd> attributes of a matrix, we can get access to the number of columns and rows in an image, or, in other words, the width and height:</p>
<pre>Vec3b pixel= color.at&lt;Vec3b&gt;(myRow, myCol); 
cout &lt;&lt; "Pixel value (B,G,R): (" &lt;&lt; (int)pixel[0] &lt;&lt; "," &lt;&lt; (int)pixel[1] &lt;&lt; "," &lt;&lt; (int)pixel[2] &lt;&lt; ")" &lt;&lt; endl; </pre>
<p>To access one pixel of the image, we use the template function <kbd>cv::Mat::at&lt;typename t&gt;(row,col)</kbd> from the <kbd>Mat</kbd> OpenCV class. The template parameter is the desired return type. A type name in an 8-bit color image is a <kbd>Vec3b</kbd> class that stores three unsigned char data (Vec = vector, 3 = number of components, and b = 1 byte). In the case of the gray image, we can directly use the unsigned character, or any other number format used in the image, such as <kbd>uchar pixel= color.at&lt;uchar&gt;(myRow, myCol)</kbd>. Finally, in order to show the images, we can use the <kbd>imshow</kbd> function, which creates a window with a title as a first parameter and the image matrix as a second parameter:</p>
<pre>// show images 
imshow("Lena BGR", color); 
imshow("Lena Gray", gray); 
// wait for any key press 
waitKey(0); </pre>
<p>If we want to stop the application from waiting, we can use the OpenCV function <kbd>waitKey</kbd>, with a parameter of the number of milliseconds we want to wait for a key press. If we set up the parameter to <kbd>0</kbd>, then the function will wait until a key is pressed.</p>
<p>The result of the preceding code is demonstrated in the following image. The left-hand image is a color image, and the right-hand image is a grayscale image:</p>
<div><img class="alignnone size-full wp-image-792 image-border" src="img/34f29b0b-0443-4a78-8b77-a21936798f0a.png" style="width:85.33em;height:44.50em;"/></div>
<p>Finally, by way of an example for the following samples, we are going to create the <kbd>CMakeLists.txt</kbd> file and see how to compile the code using the file.</p>
<p>The following code describes the <kbd>CMakeLists.txt</kbd> file:</p>
<pre>cmake_minimum_required (VERSION 3.0) 
cmake_policy(SET CMP0012 NEW) 
PROJECT(project) 
 
# Requires OpenCV 
FIND_PACKAGE( OpenCV 4.0.0 REQUIRED ) 
MESSAGE("OpenCV version : ${OpenCV_VERSION}") 
 
include_directories(${OpenCV_INCLUDE_DIRS}) 
link_directories(${OpenCV_LIB_DIR}) 
 
ADD_EXECUTABLE(sample main.cpp) 
TARGET_LINK_LIBRARIES(sample ${OpenCV_LIBS})</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>To compile our code using this <kbd>CMakeLists.txt</kbd> file, we have to carry out the following steps:</p>
<ol>
<li>Create a <kbd>build</kbd> folder.</li>
<li>Inside the <kbd>build</kbd> folder, execute CMake or open CMake GUI app in Windows, choose the <kbd>source</kbd> and <kbd>build</kbd> folders, and press the Configure and Generate buttons.</li>
<li>If you are on Linux or macOS, generate a Makefile as usual, and then compile the project using the <kbd>make</kbd> command. If you are on Windows, open the project using the editor selected in step 2 and then compile.</li>
</ol>
<p>Finally, after compiling our application, we will have an executable called <kbd>app</kbd> in the build folder that we can execute.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Reading videos and cameras</h1>
                
            
            
                
<p>This section introduces you to video and camera reading using this simple example. Before explaining how to read videos or camera input, we want to introduce a new, very useful class that helps us to manage the input command-line parameters. This new class was introduced in OpenCV version 3.0, and is the <kbd>CommandLineParser</kbd> class:</p>
<pre>// OpenCV command line parser functions 
// Keys accepted by command line parser 
const char* keys = 
{ 
   "{help h usage ? | | print this message}" 
    "{@video | | Video file, if not defined try to use webcamera}" 
}; </pre>
<p>The first thing that we have to do for <kbd>CommandLineParser</kbd> is define what parameters we need or allow in a constant <kbd>char</kbd> vector; each line has the following pattern:</p>
<pre>"{name_param | default_value | description}"</pre>
<p><kbd>name_param</kbd> can be preceded with <kbd>@</kbd>, which defines this parameter as a default input. We can use more than one <kbd>name_param</kbd>:</p>
<pre>CommandLineParser parser(argc, argv, keys);</pre>
<p>The constructor will get the inputs of the main function and the key constants defined previously:</p>
<pre>//If requires help show 
if (parser.has("help")) 
{ 
       parser.printMessage(); 
       return 0; 
} </pre>
<p>The <kbd>.has</kbd> class method checks the existence of the parameter. In the sample, we check whether the user adds the parameter <kbd>help</kbd> or <kbd>?</kbd>, and then use the class function <kbd>printMessage</kbd> to show all the description parameters:</p>
<pre>   String videoFile= parser.get&lt;String&gt;(0);</pre>
<p>With the <kbd>.get&lt;typename&gt;(parameterName)</kbd> function, we can access and read any of input parameters:</p>
<pre>   // Check if params are correctly parsed in his variables 
   if (!parser.check()) 
   { 
       parser.printErrors(); 
       return 0; 
   } </pre>
<p>After obtaining all the requisite parameters, we can check whether these parameters are parsed correctly and show an error message if one of the parameters was not parsed, for example, add a string instead of a number:</p>
<pre>VideoCapture cap; // open the default camera 
if(videoFile != "") 
   cap.open(videoFile); 
else 
   cap.open(0); 
if(!cap.isOpened())  // check if we succeeded 
   return -1;  </pre>
<p>The class for video reading and camera reading is the same: the <kbd>VideoCapture</kbd> class that belongs to the <kbd>videoio</kbd> submodule instead of the <kbd>highgui</kbd> submodule, as in the previous version of OpenCV. After creating the object, we check whether the input command-line parameter <kbd>videoFile</kbd> has a path filename. If it's empty, then we try to open a web camera; if it has a filename, then open the video file. To do this, we use the <kbd>open</kbd> function, giving as a parameter the video filename or the index camera that we want to open. If we have a single camera, we can use <kbd>0</kbd> as a parameter.</p>
<p class="mce-root"/>
<p>To check whether we can read the video filename or the camera, we use the <kbd>isOpened</kbd> function:</p>
<pre>namedWindow("Video",1); 
for(;;) 
{ 
    Mat frame; 
    cap &gt;&gt; frame; // get a new frame from camera 
    if(frame) 
       imshow("Video", frame); 
    if(waitKey(30) &gt;= 0) break; 
} 
// Release the camera or video cap 
cap.release(); </pre>
<p>Finally, we create a window to show the frames with the <kbd>namedWindow</kbd> function and, with an infinite loop, we grab each frame using the <kbd>&gt;&gt;</kbd> operation and show the frame with the <kbd>imshow</kbd> function if we retrieve the frame correctly. In this case, we don't want to stop the application, but will wait 30 milliseconds to check whether any users want to stop the application execution with any key using <kbd>waitKey(30)</kbd>.</p>
<p>The time required to wait for the next frame using camera access is calculated from the camera speed and our spent algorithm time. For example, if a camera works at 20 fps, and our algorithm spent 10 milliseconds, a great waiting value is <em>30</em> = (<em>1000</em>/<em>20</em>) - <em>10</em> milliseconds. This value is calculated considering a wait of a sufficient amount of time to ensure that the next frame is in the buffer. If our camera takes 40 milliseconds to take each image, and we use 10 milliseconds in our algorithm, then we only need to stop with waitKey 30 milliseconds, because 30 milliseconds of wait time, plus 10 milliseconds of our algorithm, is the same amount of time for which each frame of the camera is accessible.</p>
<p>When the user wants to finish the application, all they have to do is press any key and then we have to release all video resources using the release function.</p>
<p>It is very important to release all resources that we use in a computer vision application. If we do not, we can consume all RAM memory. We can release the matrices using the <kbd>release</kbd> function.</p>
<p>The result of the previous code is a new window showing a video or web camera in BGR format.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Other basic object types</h1>
                
            
            
                
<p>We have learned about the <kbd>Mat</kbd> and <kbd>Vec3b</kbd> classes, but there are many more classes that we have to learn.</p>
<p>In this section, we will learn the most basic object types required in the majority of projects:</p>
<ul>
<li><kbd>Vec</kbd></li>
<li><kbd>Scalar</kbd></li>
<li><kbd>Point</kbd></li>
<li><kbd>Size</kbd></li>
<li><kbd>Rect</kbd></li>
<li><kbd>RotatedRect</kbd></li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Vec object type</h1>
                
            
            
                
<p><kbd>Vec</kbd> is a template class mainly for numerical vectors. We can define any type of vector and the number of components:</p>
<pre>Vec&lt;double,19&gt; myVector; </pre>
<p>We can also use any of the predefined types:</p>
<p> </p>
<pre>typedef Vec&lt;uchar, 2&gt; Vec2b; 
typedef Vec&lt;uchar, 3&gt; Vec3b; 
typedef Vec&lt;uchar, 4&gt; Vec4b; 
 
typedef Vec&lt;short, 2&gt; Vec2s; 
typedef Vec&lt;short, 3&gt; Vec3s; 
typedef Vec&lt;short, 4&gt; Vec4s; 
 
typedef Vec&lt;int, 2&gt; Vec2i; 
typedef Vec&lt;int, 3&gt; Vec3i; 
typedef Vec&lt;int, 4&gt; Vec4i; 
 
typedef Vec&lt;float, 2&gt; Vec2f; 
typedef Vec&lt;float, 3&gt; Vec3f; 
typedef Vec&lt;float, 4&gt; Vec4f; 
typedef Vec&lt;float, 6&gt; Vec6f; 
 
typedef Vec&lt;double, 2&gt; Vec2d; 
typedef Vec&lt;double, 3&gt; Vec3d; 
typedef Vec&lt;double, 4&gt; Vec4d; 
typedef Vec&lt;double, 6&gt; Vec6d; 
 </pre>
<p>All the following vector operations are also implemented:<br/>
<kbd>v1 = v2 + v3</kbd><br/>
<kbd>v1 = v2 - v3</kbd><br/>
<kbd>v1 = v2 * scale</kbd><br/>
<kbd>v1 = scale * v2</kbd><br/>
<kbd>v1 = -v2</kbd><br/>
<kbd>v1 += v2</kbd>  <br/>
<br/>
Other augmenting operations implemented are the following:<br/>
<kbd>v1 == v2, v1 != v2</kbd><br/>
<kbd>norm(v1) (euclidean norm)</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Scalar object type</h1>
                
            
            
                
<p>The <kbd>Scalar</kbd> object type is a template class derived from <kbd>Vec</kbd> with four elements. The <kbd>Scalar</kbd> type is widely used in OpenCV to pass and read pixel values.</p>
<p>To access <kbd>Vec</kbd> and <kbd>Scalar</kbd> values, we use the <kbd>[]</kbd> operator, which can be initialized from another scalar, vector, or value by value, as in the following sample:</p>
<pre>Scalar s0(0);<br/>Scalar s1(0.0, 1.0, 2.0, 3.0);<br/>Scalar s2(s1);</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Point object type</h1>
                
            
            
                
<p>Another very common class template is <kbd>Point</kbd>. This class defines a 2D point specified by its coordinates <kbd>x</kbd> and <kbd>y</kbd>.</p>
<p>Like <kbd>Point</kbd>, there is a <kbd>Point3</kbd> template class for 3D point support.</p>
<p>Like the <kbd>Vec</kbd> class, OpenCV defines the following <kbd>Point</kbd> aliases for our convenience:</p>
<pre>typedef Point_&lt;int&gt; Point2i; 
typedef Point2i Point; 
typedef Point_&lt;float&gt; Point2f; 
typedef Point_&lt;double&gt; Point2d; 
 The following operators are defined for points:<br/>    pt1 = pt2 + pt3; 
    pt1 = pt2 - pt3; 
    pt1 = pt2 * a; 
    pt1 = a * pt2; 
    pt1 = pt2 / a; 
    pt1 += pt2; 
    pt1 -= pt2; 
    pt1 *= a; 
    pt1 /= a; 
    double value = norm(pt); // L2 norm 
    pt1 == pt2; 
    pt1 != pt2; </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Size object type</h1>
                
            
            
                
<p>Another template class that is very important and widely used in OpenCV is the template class for specifying the size of an image or rectangle—<kbd>Size</kbd>. This class adds two members, width and height, and the useful <kbd>area()</kbd> function. In the following sample, we can see a number of ways of using size:</p>
<pre>Size s(100,100);<br/>Mat img=Mat::zeros(s, CV_8UC1); // 100 by 100 single channel matrix<br/>s.width= 200;<br/>int area= s.area(); returns 100x200</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Rect object type</h1>
                
            
            
                
<p><kbd>Rect</kbd> is another important template class for defining 2D rectangles defined by the following parameters:</p>
<ul>
<li>
<p>The coordinates of the upper-left corner</p>
</li>
<li>
<p>The width and height of a rectangle</p>
</li>
</ul>
<p>The <kbd>Rect</kbd> template class can be used to define a <strong>region of interest</strong> (<strong>ROI</strong>) of an image, as follows:</p>
<pre>Mat img=imread("lena.jpg");<br/>Rect rect_roi(0,0,100,100);<br/>Mat img_roi=img(r);</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">RotatedRect object type</h1>
                
            
            
                
<p>The last useful class is a particular rectangle called <kbd>RotatedRect</kbd>. This class represents a rotated rectangle specified by a center point, the width and height of a rectangle, and the rotation angle in degrees:</p>
<pre>RotatedRect(const Point2f&amp; center, const Size2f&amp; size, float angle); </pre>
<p>An interesting function of this class is <kbd>boundingBox</kbd>. This function returns <kbd>Rect</kbd>, which contains the rotated rectangle:</p>
<div><img class="alignnone size-full wp-image-793 image-border" src="img/41cc5cdd-ba17-4332-8a06-456a685c7664.png" style="width:15.00em;height:12.08em;"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Basic matrix operations</h1>
                
            
            
                
<p>In this section, we will learn a number of basic and important matrix operations that we can apply to images or any matrix data. We learned how to load an image and store it in a <kbd>Mat</kbd> variable, but we can create <kbd>Mat</kbd> manually. The most common constructor is giving the matrix a size and type, as follows:</p>
<pre>Mat a= Mat(Size(5,5), CV_32F); </pre>
<p>You can create a new matrix linking with a stored buffer from third-party libraries without copying data using this constructor: <kbd>Mat(size, type, pointer_to_buffer)</kbd>.</p>
<p>The types supported depend on the type of number you want to store and the number of channels. The most common types are as follows:</p>
<pre>CV_8UC1 
CV_8UC3 
CV_8UC4 
CV_32FC1 
CV_32FC3 
CV_32FC4</pre>
<p>You can create any type of matrix using <kbd>CV_number_typeC(n)</kbd>, where the <kbd>number_type</kbd> is 8 bits unsigned (8U) to 64 float (64F), and where <kbd>(n)</kbd> is the number of channels; the number of channels permitted ranges from <kbd>1</kbd> to <kbd>CV_CN_MAX</kbd>.</p>
<p>The initialization does not set up the data values, and hence you can get undesirable values. To avoid undesirable values, you can initialize the matrix with <kbd>0</kbd> or <kbd>1</kbd> values with their respective functions:</p>
<pre>Mat mz= Mat::zeros(5,5, CV_32F); 
Mat mo= Mat::ones(5,5, CV_32F); </pre>
<p>The results of the preceding matrix are as follows:</p>
<div><img class="alignnone size-full wp-image-794 image-border" src="img/9060dc5f-9679-40b5-9c50-cb5169b7b9a3.png" style="width:14.25em;height:6.08em;"/></div>
<p>A special matrix initialization is the eye function that creates an identity matrix with the specified type and size:</p>
<pre>Mat m= Mat::eye(5,5, CV_32F); </pre>
<p>The output is as follows:</p>
<div><img class="alignnone size-full wp-image-795 image-border" src="img/34066e0f-e427-405f-b8c2-5eb43384b04a.png" style="width:6.17em;height:5.83em;"/></div>
<p>All matrix operations are allowed in OpenCV's <kbd>Mat</kbd> class. We can add or subtract two matrices of the same size using the <kbd>+</kbd> and <kbd>-</kbd> operators, as demonstrated in the following code block:</p>
<pre>Mat a= Mat::eye(Size(3,2), CV_32F); 
Mat b= Mat::ones(Size(3,2), CV_32F); 
Mat c= a+b; 
Mat d= a-b;</pre>
<p class="mce-root"/>
<p>The results of the preceding operations are as follows:</p>
<div><img class="alignnone size-full wp-image-796 image-border" src="img/8611f073-1b05-4c37-94be-bf1281099d44.png" style="width:14.92em;height:5.17em;"/></div>
<p>We can multiply by a scalar using the <kbd>*</kbd> operator or a matrix per element using the <kbd>mul</kbd> function, and we can perform matrix multiplication using the  <kbd>*</kbd> operator:</p>
<pre>Mat m1= Mat::eye(2,3, CV_32F); 
Mat m2= Mat::ones(3,2, CV_32F); 
// Scalar by matrix 
cout &lt;&lt; "nm1.*2n" &lt;&lt; m1*2 &lt;&lt; endl; 
// matrix per element multiplication 
cout &lt;&lt; "n(m1+2).*(m1+3)n" &lt;&lt; (m1+1).mul(m1+3) &lt;&lt; endl; 
// Matrix multiplication 
cout &lt;&lt; "nm1*m2n" &lt;&lt; m1*m2 &lt;&lt; endl; </pre>
<p>The results of the preceding operations are as follows:</p>
<div><img class="alignnone size-full wp-image-797 image-border" src="img/505d4ca1-d9a4-4a09-be73-4716a1eaea21.png" style="width:12.92em;height:8.58em;"/></div>
<p>Other common mathematical matrix operations are <strong>transposition</strong> and <strong>matrix inversion</strong>, defined by the <kbd>t()</kbd> and <kbd>inv()</kbd> functions, respectively. Other interesting functions that OpenCV provides are array operations in matrix, for example, counting the nonzero elements. This is useful for counting the pixels or areas of objects:</p>
<pre>int countNonZero(src); </pre>
<p>OpenCV provides some statistical functions. Mean and standard deviation by channel can be calculated using the <kbd>meanStdDev</kbd> function:</p>
<pre>meanStdDev(src, mean, stddev); </pre>
<p>Another useful statistical function is <kbd>minMaxLoc</kbd>. This function finds the minimum and the maximum of a matrix or array, and returns the location and value:</p>
<pre>minMaxLoc(src, minVal, maxVal, minLoc, maxLoc); </pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Here <kbd>src</kbd> is the input matrix, <kbd>minVal</kbd> and <kbd>maxVal</kbd> are double values detected, and <kbd>minLoc</kbd> and <kbd>maxLoc</kbd> are <kbd>Point</kbd> values detected.</p>
<p>Other core and useful functions are described in detail at: <a href="https://docs.opencv.org/master/dc/d84/group__core__basic.html">http://docs.opencv.org/modules/core/doc/core.html</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Basic data persistence and storage</h1>
                
            
            
                
<p>Before finishing this chapter, we will explore the OpenCV functions to store and read our data. In many applications, such as calibration or machine learning, when we finish performing a number of calculations, we need to save these results to retrieve them in subsequent operations. OpenCV provides an XML/YAML persistence layer to this end.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Writing to FileStorage</h1>
                
            
            
                
<p>To write a file with some OpenCV or other numeric data, we can use the <kbd>FileStorage</kbd> class, using a streaming <kbd>&lt;&lt;</kbd> operator such as STL streaming:</p>
<pre>#include "opencv2/opencv.hpp" 
using namespace cv; 
 
int main(int, char** argv) 
{ 
   // create our writer 
    FileStorage fs("test.yml", FileStorage::WRITE); 
    // Save an int 
    int fps= 5; 
    fs &lt;&lt; "fps" &lt;&lt; fps; 
    // Create some mat sample 
    Mat m1= Mat::eye(2,3, CV_32F); 
    Mat m2= Mat::ones(3,2, CV_32F); 
    Mat result= (m1+1).mul(m1+3); 
    // write the result 
    fs &lt;&lt; "Result" &lt;&lt; result; 
    // release the file 
    fs.release(); 
 
    FileStorage fs2("test.yml", FileStorage::READ); 
 
    Mat r; 
    fs2["Result"] &gt;&gt; r; 
    std::cout &lt;&lt; r &lt;&lt; std::endl; 
 
    fs2.release(); 
 
    return 0; 
} </pre>
<p>To create a file storage where we save the data, we only need to call the constructor, giving a path filename with the extension format desired (XML or YAML), and the second parameter set to write:</p>
<pre>FileStorage fs("test.yml", FileStorage::WRITE); </pre>
<p>If we want to save data, we only need to use the stream operator by giving an identifier in the first stage, and later the matrix or value that we want to save. For example, to save an <kbd>int</kbd> variable, we only have to write the following lines of code:</p>
<pre>int fps= 5; 
fs &lt;&lt; "fps" &lt;&lt; fps; </pre>
<p>Otherwise, we can write/save <kbd>mat</kbd> as shown:</p>
<pre>Mat m1= Mat::eye(2,3, CV_32F); 
Mat m2= Mat::ones(3,2, CV_32F); 
Mat result= (m1+1).mul(m1+3); 
// write the result 
fs &lt;&lt; "Result" &lt;&lt; result;</pre>
<p>The result of the preceding code is a YAML format:</p>
<pre>%YAML:1.0 
fps: 5 
Result: !!opencv-matrix 
   rows: 2 
   cols: 3 
   dt: f 
   data: [ 8., 3., 3., 3., 8., 3. ] </pre>
<p>Reading from a file storage to read a file saved previously is very similar to the <kbd>save</kbd> functions:</p>
<pre>#include "opencv2/opencv.hpp" 
using namespace cv; 
 
int main(int, char** argv) 
{ 
   FileStorage fs2("test.yml", FileStorage::READ); 
 
   Mat r; 
   fs2["Result"] &gt;&gt; r; 
   std::cout &lt;&lt; r &lt;&lt; std::endl; 
 
   fs2.release(); 
 
   return 0; 
} </pre>
<p>The first stage is to open a saved file with the <kbd>FileStorage</kbd> constructor using the appropriate parameters, path, and <kbd>FileStorage::READ</kbd>:</p>
<pre>FileStorage fs2("test.yml", FileStorage::READ); </pre>
<p>To read any stored variable, we only need to use the common stream operator <kbd>&gt;&gt;</kbd> using our <kbd>FileStorage</kbd> object and the identifier with the <kbd>[]</kbd> operator:</p>
<pre>Mat r; 
fs2["Result"] &gt;&gt; r; </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we learned the basics and the most important types and operations of OpenCV, access to images and videos, and how they are stored in matrices. We learned the basic matrix operations and other basic OpenCV classes to store pixels, vectors, and so on. Finally, we learned how to save our data in files to allow them to be read in other applications or other executions.</p>
<p>In the next chapter, we are going to learn how to create our first application, learning the basics of graphical user interfaces that OpenCV provides. We will create buttons and sliders, and introduce some image processing basics.</p>


            

            
        
    </body></html>