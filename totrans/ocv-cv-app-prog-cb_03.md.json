["```py\nint main()\n{\n   // 1\\. Create image processor object\n   ColorDetector cdetect;\n\n   // 2\\. Read input image\n   cv::Mat image= cv::imread(\"boldt.jpg\");\n   if (image.empty())\n      return 0;\n   // 3\\. Set input parameters\n   cdetect.setTargetColor(230,190,130); // here blue sky\n\n   cv::namedWindow(\"result\");\n\n   // 4\\. Process the image and display the result\n   cv::imshow(\"result\",cdetect.process(image));\n\n   cv::waitKey();\n\n   return 0;\n}\n```", "```py\n     // get the iterators\n     cv::Mat_<cv::Vec3b>::const_iterator it= \n                           image.begin<cv::Vec3b>();\n     cv::Mat_<cv::Vec3b>::const_iterator itend= \n                           image.end<cv::Vec3b>();\n     cv::Mat_<uchar>::iterator itout= result.begin<uchar>();\n\n     // for each pixel\n     for ( ; it!= itend; ++it, ++itout) {\n\n            // compute distance from target color\n            if (getDistanceToTargetColor(*it)<=maxDist) {\n                 *itout= 255;\n            } else {\n                 *itout= 0;\n            }\n    }\n```", "```py\n// Computes the distance from target color.\nint getDistanceToTargetColor(const cv::Vec3b& color) const {\n  return getColorDistance(color, target);\n}\n// Computes the city-block distance between two colors.\nint getColorDistance(const cv::Vec3b& color1, \n                     const cv::Vec3b& color2) const {\n  return abs(color1[0]-color2[0])+\n                abs(color1[1]-color2[1])+\n                abs(color1[2]-color2[2]);\n}\n```", "```py\ncv::Mat ColorDetector::process(const cv::Mat &image) {\n\n     // re-allocate binary map if necessary\n     // same size as input image, but 1-channel\n     result.create(image.size(),CV_8U);\n     // processing loop above goes here\n      ...\n\n     return result;\n}\n```", "```py\nclass ColorDetector {\n\n  private:\n\n     // minimum acceptable distance\n     int maxDist; \n\n     // target color\n     cv::Vec3b target;\n\n     // image containing resulting binary map\n     cv::Mat result;\n```", "```py\n     // empty constructor\n     // default parameter initialization here\n     ColorDetector() : maxDist(100), target(0,0,0) {}\n```", "```py\n     // Sets the color distance threshold.\n     // Threshold must be positive, \n     // otherwise distance threshold is set to 0.\n     void setColorDistanceThreshold(int distance) {\n\n        if (distance<0)\n           distance=0;\n        maxDist= distance;\n     }\n\n     // Gets the color distance threshold\n     int getColorDistanceThreshold() const {\n\n        return maxDist;\n     }\n```", "```py\n     // Sets the color to be detected\n     void setTargetColor(uchar blue, \n                         uchar green, \n                         uchar red) {\n       // BGR order\n       target = cv::Vec3b(blue, green, red);\n     }\n\n       // Sets the color to be detected\n     void setTargetColor(cv::Vec3b color) {\n\n     target= color;\n     }\n\n       // Gets the color to be detected\n     cv::Vec3b getTargetColor() const {\n\n       return target;\n     }\n```", "```py\nreturn abs(color[0]-target[0])+\n       abs(color[1]-target[1])+\n       abs(color[2]-target[2]);\n```", "```py\nreturn static_cast<int>(\n   cv::norm<int,3>(cv::Vec3i(color[0]-target[0],\n                             color[1]-target[1],\n                             color[2]-target[2])));\n```", "```py\nreturn static_cast<int>(\n   cv::norm<uchar,3>(color-target)); // wrong!\n```", "```py\n   cv::Vec3b dist;\n   cv::absdiff(color,target,dist);\n   return cv::sum(dist)[0];\n```", "```py\n  cv::Mat ColorDetector::process(const cv::Mat &image) {\n\n         cv::Mat output;\n         // compute absolute difference with target color\n         cv::absdiff(image,cv::Scalar(target),output);\n         // split the channels into 3 images\n         std::vector<cv::Mat> images;\n         cv::split(output,images);\n         // add the 3 channels (saturation might occurs here)\n         output= images[0]+images[1]+images[2];\n         // apply threshold\n         cv::threshold(output,  // input image\n                       output,  // output image\n                       maxDist, // threshold (must be < 256)\n                       255,     // max value\n         cv::THRESH_BINARY_INV); // thresholding mode\n\n         return output;\n   }\n```", "```py\n  // full constructor\n  ColorDetector(uchar blue, uchar green, uchar red, \n                int maxDist=100): maxDist(maxDist) { \n\n    // target color\n    setTargetColor(blue, green, red);\n  }\n```", "```py\n  cv::Mat operator()(const cv::Mat &image) {\n\n    // color detection code here …\n  }\n```", "```py\nColorDetector colordetector(230,190,130,  // color\n                                    100); // threshold\ncv::Mat result= colordetector(image);   // functor call\n```", "```py\nclass ColorDetectController {\n\n  private:\n\n   // the algorithm class\n   ColorDetector *cdetect;\n\n   cv::Mat image;   // The image to be processed\n   cv::Mat result;  // The image result\n\n  public:\n\n   ColorDetectController() { \n\n        //setting up the application\n        cdetect= new ColorDetector();\n   }\n```", "```py\n     // Sets the color distance threshold\n     void setColorDistanceThreshold(int distance) {\n\n        cdetect->setColorDistanceThreshold(distance);\n     }\n\n     // Gets the color distance threshold\n     int getColorDistanceThreshold() const {\n\n        return cdetect->getColorDistanceThreshold();\n     }\n\n     // Sets the color to be detected\n     void setTargetColor(unsigned char red, \n        unsigned char green, unsigned char blue) {\t\n             cdetect->setTargetColor(blue,green,red);\n     }\n\n     // Gets the color to be detected\n     void getTargetColor(unsigned char &red, \n        unsigned char &green, unsigned char &blue) const {\n\n        cv::Vec3b color= cdetect->getTargetColor();\n\n        red= color[2];\n        green= color[1];\n        blue= color[0];\n     }\n\n     // Sets the input image. Reads it from file.\n     bool setInputImage(std::string filename) {\n\n        image= cv::imread(filename);\n\n        return !image.empty();\n     }\n\n     // Returns the current input image.\n     const cv::Mat getInputImage() const {\n\n        return image;\n     }\n```", "```py\n     // Performs image processing.\n     void process() {\n\n        result= cdetect->process(image);\n     }\n```", "```py\n     // Returns the image result from the latest processing.\n     const cv::Mat getLastResult() const {\n\n        return result;\n     }\n```", "```py\n     // Deletes processor objects created by the controller.\n     ~ColorDetectController() {\n\n        delete cdetect; // release memory of dynamically\n     }                  // allocated class instance\n```", "```py\n// Callback method of \"Open\" button.\nvoid OnOpen()\n{\n    // MFC widget to select a file of type bmp or jpg\n    CFileDialog dlg(TRUE, _T(\"*.bmp\"), NULL,\n     OFN_FILEMUSTEXIST|OFN_PATHMUSTEXIST|OFN_HIDEREADONLY,\n     _T(\"image files (*.bmp; *.jpg) \n         |*.bmp;*.jpg|All Files (*.*)|*.*||\"),NULL);\n\n    dlg.m_ofn.lpstrTitle= _T(\"Open Image\");\n\n    // if a filename has been selected\n    if (dlg.DoModal() == IDOK) {\n\n      // get the path of the selected filename\n      std::string filename= dlg.GetPathName();  \n\n      // set and display the input image\n      colordetect.setInputImage(filename);\n      cv::imshow(\"Input Image\",colordetect.getInputImage());\n    }\n}\n```", "```py\n// Callback method of \"Process\" button.\nvoid OnProcess()\n{\n   // target color is hard-coded here\n   colordetect.setTargetColor(130,190,230);\n   // process the input image and display result\n   colordetect.process();\n   cv::imshow(\"Output Result\",colordetect.getLastResult());\n}\n```", "```py\ncv::Mat ColorDetector::process(const cv::Mat &image) {\n\n     // re-allocate binary map if necessary\n     // same size as input image, but 1-channel\n     result.create(image.rows,image.cols,CV_8U);\n     // Converting to Lab color space \n     cv::cvtColor(image, converted, CV_BGR2Lab);\n\n     // get the iterators of the converted image \n     cv::Mat_<cv::Vec3b>::iterator it= \n                 converted.begin<cv::Vec3b>();\n     cv::Mat_<cv::Vec3b>::iterator itend= \n                 converted.end<cv::Vec3b>();\n     // get the iterator of the output image \n     cv::Mat_<uchar>::iterator itout= result.begin<uchar>();\n\n     // for each pixel\n     for ( ; it!= itend; ++it, ++itout) {\n     …\n```", "```py\nclass ColorDetector {\n\n  private:\n     // image containing color converted image\n     cv::Mat converted;\n```", "```py\n     // Sets the color to be detected\n     void setTargetColor(unsigned char red, \n           unsigned char green, unsigned char blue) {\n\n         // Temporary 1-pixel image\n         cv::Mat tmp(1,1,CV_8UC3);\n         tmp.at<cv::Vec3b>(0,0)= cv::Vec3b(blue, green, red);\n\n         // Converting the target to Lab color space \n         cv::cvtColor(tmp, tmp, CV_BGR2Lab);\n\n         target= tmp.at<cv::Vec3b>(0,0);\n     }\n```", "```py\n         cv::cvtColor(color, gray, CV_BGR2Gray);\n```", "```py\n    // convert into HSV space\n    cv::Mat hsv;\n    cv::cvtColor(image, hsv, CV_BGR2HSV);\n```", "```py\n    // split the 3 channels into 3 images\n    std::vector<cv::Mat> channels;\n    cv::split(hsv,channels);\n    // channels[0] is the Hue\n    // channels[1] is the Saturation\n    // channels[2] is the Value\n```", "```py\n  // convert into HSV space\n  cv::Mat hsv;\n  cv::cvtColor(image, hsv, CV_BGR2HSV);\n  // split the 3 channels into 3 images\n  std::vector<cv::Mat> channels;\n  cv::split(hsv,channels);\n  // Value channel will be 255 for all pixels\n  channels[2]= 255;  \n  // merge back the channels\n  cv::merge(channels,hsv);\n  // reconvert to BGR\n  cv::Mat newImage;\n  cv::cvtColor(hsv,newImage,CV_HSV2BGR);\n```", "```py\nvoid detectHScolor(const cv::Mat& image,  // input image \n  double minHue, double maxHue,  // Hue interval \n  double minSat, double maxSat,  // saturation interval\n  cv::Mat& mask) {               // output mask\n\n  // convert into HSV space\n  cv::Mat hsv;\n  cv::cvtColor(image, hsv, CV_BGR2HSV);\n\n  // split the 3 channels into 3 images\n  std::vector<cv::Mat> channels;\n  cv::split(hsv, channels);\n  // channels[0] is the Hue\n  // channels[1] is the Saturation\n  // channels[2] is the Value\n  // Hue masking\n  cv::Mat mask1; // under maxHue\n  cv::threshold(channels[0], mask1, maxHue, 255,\n  cv::THRESH_BINARY_INV);\n  cv::Mat mask2; // over minHue\n  cv::threshold(channels[0], mask2, minHue, 255,\n  cv::THRESH_BINARY);\n\n  cv::Mat hueMask; // hue mask\n  if (minHue < maxHue)\n      hueMask = mask1 & mask2;\n  else // if interval crosses the zero-degree axis\n      hueMask = mask1 | mask2;\n\n  // Saturation masking\n  // under maxSat\n  cv::threshold(channels[1], mask1, maxSat, 255,\n  cv::THRESH_BINARY_INV);\n  // over minSat\n  cv::threshold(channels[1], mask2, minSat, 255,\n  cv::THRESH_BINARY);\n\n  cv::Mat satMask; // saturation mask\n  satMask = mask1 & mask2;\n\n  // combined mask\n  mask = hueMask&satMask;\n}\n```", "```py\n  // detect skin tone\n  cv::Mat mask;\n  detectHScolor(image, \n        160, 10, // hue from 320 degrees to 20 degrees \n        25, 166, // saturation from ~0.1 to 0.65\n        mask);\n\n  // show masked image\n  cv::Mat detected(image.size(), CV_8UC3, cv::Scalar(0, 0, 0));\n  image.copyTo(detected, mask);\n```"]