- en: Chapter 5. Transforming Images with Morphological Operations
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章. 使用形态学操作转换图像
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下食谱：
- en: Eroding and dilating images using morphological filters
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用形态学滤波器进行图像腐蚀和膨胀
- en: Opening and closing images using morphological filters
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用形态学滤波器进行图像开闭操作
- en: Applying morphological operators on gray-level images
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在灰度图像上应用形态学算子
- en: Segmenting images using watersheds
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用分水岭进行图像分割
- en: Extracting distinctive regions using MSER
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用MSER提取特征区域
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: '**Mathematical morphology** is a theory that was developed in the 1960s for
    the analysis and processing of discrete images. It defines a series of operators
    that transform an image by probing it with a predefined shape element. The way
    this shape element intersects the neighborhood of a pixel determines the result
    of the operation. This chapter presents the most important morphological operators.
    It also explores the problems of image segmentation and feature detection using
    algorithms based on morphological operators.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**数学形态学**是20世纪60年代为分析和处理离散图像而开发的一种理论。它定义了一系列通过探针预定义的形状元素来转换图像的算子。这个形状元素与像素邻域的交集方式决定了操作的结果。本章介绍了最重要的形态学算子。它还探讨了使用基于形态学算子的算法进行图像分割和特征检测的问题。'
- en: Eroding and dilating images using morphological filters
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用形态学滤波器进行图像腐蚀和膨胀
- en: Erosion and dilation are the most fundamental morphological operators. Therefore,
    we will present them in this first recipe. The fundamental component in mathematical
    morphology is the **structuring element**. A structuring element can be simply
    defined as a configuration of pixels (the square shape in the following figure)
    on which an origin is defined (also called an **anchor point**). Applying a morphological
    filter consists of probing each pixel of the image using this structuring element.
    When the origin of the structuring element is aligned with a given pixel, its
    intersection with the image defines a set of pixels on which a particular morphological
    operation is applied (the nine shaded pixels in the following figure). In principle,
    the structuring element can be of any shape, but most often, a simple shape such
    as a square, circle, or diamond with the origin at the center is used. Custom
    structuring elements can be useful to emphasize or eliminate regions of particular
    shapes.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 腐蚀和膨胀是最基本的形态学算子。因此，我们将在这第一个食谱中介绍它们。数学形态学的基本组成部分是**结构元素**。结构元素可以简单地定义为定义了原点（也称为**锚点**）的像素配置（以下图中的正方形形状）。应用形态学滤波器包括使用这个结构元素探测图像中的每个像素。当结构元素的原点与给定的像素对齐时，它与图像的交集定义了一个特定形态学操作应用的像素集（以下图中的九个阴影像素）。原则上，结构元素可以是任何形状，但最常用的是具有原点在中心的简单形状，如正方形、圆形或菱形。自定义结构元素可以用来强调或消除特定形状的区域。
- en: '![Eroding and dilating images using morphological filters](img/image_05_001.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![使用形态学滤波器进行图像腐蚀和膨胀](img/image_05_001.jpg)'
- en: Getting ready
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: As morphological filters often work on binary images, we will use the binary
    image that was created through thresholding in the first recipe of the previous
    chapter. However, since the convention is to have the foreground objects represented
    by high (white) pixel values and the background objects by low (black) pixel values
    in morphology, we have negated the image.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 由于形态学滤波器通常在二值图像上工作，我们将使用上一章第一个食谱中通过阈值创建的二值图像。然而，由于在形态学中通常用高（白色）像素值表示前景对象，用低（黑色）像素值表示背景对象，因此我们对图像进行了取反。
- en: 'In morphological terms, the following image is said to be the **complement**
    of the image that was created in the previous chapter:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在形态学术语中，以下图像被认为是上一章创建的图像的**补码**：
- en: '![Getting ready](img/image_05_002.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![准备中](img/image_05_002.jpg)'
- en: How to do it...
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Erosion and dilation are implemented in OpenCV as simple functions, which are
    `cv::erode` and `cv::dilate`. Their usage is straightforward:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 腐蚀和膨胀在OpenCV中作为简单的函数实现，分别是`cv::erode`和`cv::dilate`。它们的用法简单直接：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The two images produced by these function calls are seen in the following images.
    The first one shows erosion:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数调用产生的两个图像如下所示。第一个显示了腐蚀：
- en: '![How to do it...](img/image_05_003.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/image_05_003.jpg)'
- en: 'The second image shows the dilation result:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 第二张图像显示了膨胀的结果：
- en: '![How to do it...](img/image_05_006.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/image_05_006.jpg)'
- en: How it works...
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As for all morphological filters, the two filters of this recipe operate on
    sets of pixels defined by a structuring element. Recall that when applied to a
    given pixel, the anchor point of the structuring element is aligned with this
    pixel location, and all the pixels that intersect the structuring element are
    included in the current set. **Erosion** replaces the current pixel with the minimum
    pixel value found in the defined pixel set. **Dilation** is the complementary
    operator, and it replaces the current pixel with the maximum pixel value found
    in the defined pixel set. Since the input binary image contains only black (value
    `0`) and white (value `255`) pixels, each pixel is replaced by either a white
    or black pixel.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有形态学滤波器，本配方中的两个滤波器作用于由结构元素定义的像素集。回想一下，当应用于一个特定的像素时，结构元素的锚点与该像素位置对齐，并且所有与结构元素相交的像素都包含在当前集中。**腐蚀**用在定义的像素集中找到的最小像素值替换当前像素。**膨胀**是互补操作符，它用在定义的像素集中找到的最大像素值替换当前像素。由于输入的二值图像只包含黑色（值为`0`）和白色（值为`255`）像素，每个像素将被替换为白色或黑色像素。
- en: 'A good way to picturize the effect of these two operators is to think in terms
    of background (black) and foreground (white) objects. With erosion, if the structuring
    element when placed at a given pixel location touches the background (that is,
    one of the pixels in the intersecting set is black), then this pixel will be sent
    to the background. In the case of dilation, if the structuring element on a background
    pixel touches a foreground object, then this pixel will be assigned a white value.
    This explains why the size of the objects has been reduced (the shape has been
    eroded) in the eroded image while it has been expanded in the dilated image. Note
    how some of the small objects (which can be considered as "noisy" background pixels)
    have also been completely eliminated in the eroded image. Similarly, the dilated
    objects are now larger, and some of the "holes" inside them have been filled.
    By default, OpenCV uses a `3x3` square structuring element. This default structuring
    element is obtained when an empty matrix (that is, `cv::Mat()`) is specified as
    the third argument in the function call, as it was done in the preceding example.
    You can also specify a structuring element of the size (and shape) you want by
    providing a matrix in which the nonzero element defines the structuring element.
    For example, to apply a `7x7` structuring element, you would proceed as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 一种形象化这两个操作效果的好方法是考虑背景（黑色）和前景（白色）对象。在腐蚀过程中，如果结构元素放置在特定的像素位置时接触到背景（即，相交集中的某个像素是黑色的），那么这个像素将被发送到背景。在膨胀的情况下，如果结构元素在背景像素上接触到前景对象，那么这个像素将被赋予白色值。这解释了为什么在腐蚀图像中对象的大小已经减小（形状已经被腐蚀），而在膨胀图像中对象已经扩展。注意，一些小对象（可以被认为是“噪声”背景像素）在腐蚀图像中也被完全消除。同样，膨胀的对象现在更大，它们内部的一些“空洞”也被填充了。默认情况下，OpenCV使用一个`3x3`的正方形结构元素。当在函数调用中将空矩阵（即`cv::Mat()`）指定为第三个参数时，就得到了这个默认的结构元素，就像在先前的例子中那样。您也可以通过提供一个矩阵来指定您想要的（大小和形状）结构元素，其中非零元素定义了结构元素。例如，要应用一个`7x7`的结构元素，您将按以下步骤进行：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The effect is much more destructive in this case, as shown in the following
    screenshot:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，效果要破坏性得多，如下面的截图所示：
- en: '![How it works...](img/image_05_008.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/image_05_008.jpg)'
- en: 'Another way to obtain a similar result is to repetitively apply the same structuring
    element on an image. The two functions have an optional parameter to specify the
    number of repetitions:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 获得类似结果的另一种方法是重复应用相同的结构元素到图像上。这两个函数有一个可选参数可以指定重复的次数：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `cv::Point(-1,-1)` argument means that the origin is at the center of the
    matrix (default); it can be defined anywhere on the structuring element. The image
    that is obtained will be identical to the image we obtained with the `7x7` structuring
    element. Indeed, eroding an image twice is similar to eroding an image with a
    structuring element dilated with itself. This also applies to dilation.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`cv::Point(-1,-1)`参数表示原点位于矩阵的中心（默认）；它可以在结构元素的任何位置定义。获得图像将与使用`7x7`结构元素获得的图像相同。实际上，腐蚀图像两次类似于用自身膨胀的结构元素腐蚀图像。这也适用于膨胀。'
- en: 'Finally, since the notion of background/foreground is arbitrary, we can make
    the following observation (which is a fundamental property of the erosion/dilation
    operators). Eroding the foreground objects with a structuring element can be seen
    as a dilation of the background part of the image. In other words, we can make
    the following observations:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，由于背景/前景的概念是任意的，我们可以做出以下观察（这是腐蚀/膨胀算子的基本属性）。使用结构元素腐蚀前景对象可以看作是图像背景部分的膨胀。换句话说，我们可以得出以下结论：
- en: The erosion of an image is equivalent to the complement of the dilation of the
    complement image
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像的腐蚀相当于补集图像膨胀的补集
- en: The dilation of an image is equivalent to the complement of the erosion of the
    complement image
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像的膨胀相当于补集图像腐蚀的补集
- en: There's more...
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: Note that even though we applied our morphological filters on binary images
    here, these filters can be applied on gray-level or even color images with the
    same definitions. The third recipe of this chapter will present few morphological
    operators and their effect on gray-level images.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管我们在这里对二值图像应用了形态学滤波器，但这些滤波器可以使用相同的定义应用于灰度图像甚至彩色图像。本章的第三个配方将介绍一些形态学算子及其对灰度图像的影响。
- en: 'Also, note that the OpenCV morphological functions support in-place processing.
    This means that you can use the input image as the destination image, as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，OpenCV的形态学函数支持就地处理。这意味着您可以使用输入图像作为目标图像，如下所示：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: OpenCV will create the required temporary image for you for this to work properly.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV将为您创建所需的临时图像，以确保此操作正常工作。
- en: See also
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Opening and closing images using morphological filters* recipe applies
    the erosion and dilation filters in cascade to produce new operators
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用形态学滤波器进行图像的**打开和关闭**的配方将腐蚀和膨胀滤波器级联应用以产生新的算子
- en: The *Applying morphological operators on gray-level images* recipe introduces
    other morphological operators that can usefully be applied to gray-level images
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在灰度图像上应用形态学算子**的配方介绍了其他可以有效地应用于灰度图像的形态学算子'
- en: Opening and closing images using morphological filters
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用形态学滤波器打开和关闭图像
- en: 'The previous recipe introduced you to the two fundamental morphological operators:
    dilation and erosion. From these, other operators can be defined. The next two
    recipes will present some of them. The opening and closing operators are presented
    in this recipe.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个配方向您介绍了两个基本的形态学算子：膨胀和腐蚀。从这些算子中，可以定义其他算子。接下来的两个配方将介绍其中的一些。打开和关闭算子在本配方中介绍。
- en: How to do it...
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'In order to apply higher-level morphological filters, you need to use the `cv::morphologyEx`
    function with the appropriate function code. For example, the following call will
    apply the closing operator:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了应用高级形态学滤波器，您需要使用带有适当功能代码的`cv::morphologyEx`函数。例如，以下调用将应用关闭算子：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Note that we used a `5x5` structuring element to make the effect of the filter
    more apparent. If we use the binary image of the preceding recipe as input, we
    will obtain the following image:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用了`5x5`的结构元素来使滤波器效果更加明显。如果我们使用前一个配方的二值图像作为输入，我们将获得以下图像：
- en: '![How to do it...](img/image_05_009.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/image_05_009.jpg)'
- en: 'Similarly, applying the morphological opening operator will result in the following
    image:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，应用形态学打开算子将得到以下图像：
- en: '![How to do it...](img/image_05_011.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/image_05_011.jpg)'
- en: 'The preceding image is obtained from the following code:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图像是从以下代码获得的：
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How it works...
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The opening and closing filters are simply defined in terms of the basic erosion
    and dilation operations. **Closing** is defined as the erosion of the dilation
    of an image. **Opening** is defined as the dilation of the erosion of an image.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 打开和关闭滤波器简单地定义为基本腐蚀和膨胀操作。**关闭**定义为图像膨胀后的腐蚀。**打开**定义为图像腐蚀后的膨胀。
- en: 'Consequently, one can compute the closing of an image using the following calls:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，可以使用以下调用计算图像的关闭：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The opening filter can be obtained by interchanging these two function calls.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 打开滤波器可以通过交换这两个函数调用来获得。
- en: While examining the result of the closing filter, it can be seen that the small
    holes of the white foreground objects have been filled. The filter also connects
    several adjacent objects together. Basically, any holes or gaps that are too small
    to completely contain the structuring element will be eliminated by the filter.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查闭合过滤器的结果时，可以看到白色前景对象的微小孔洞已被填充。过滤器还连接了几个相邻的对象。基本上，任何太小而无法完全包含结构元素的孔洞或缝隙都将被过滤器消除。
- en: Reciprocally, the opening filter eliminated several small objects from the scene.
    All the objects that were too small to contain the structuring element have been
    removed.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，开放过滤器从场景中消除了几个小对象。所有太小而无法包含结构元素的对象都已移除。
- en: These filters are often used in object detection. The closing filter connects
    the objects erroneously fragmented into smaller pieces together, while the opening
    filter removes the small blobs introduced by the image noise. Therefore, it is
    advantageous to use them in a sequence. You can then apply the opening filter
    before the closing filter if you wish to prioritize noise filtering, but this
    could be at the price of eliminating parts of fragmented objects.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这些过滤器通常用于目标检测。闭合过滤器将错误地分割成更小片段的对象连接在一起，而开放过滤器则移除了由图像噪声引入的小块。因此，按顺序使用它们是有利的。如果您希望优先考虑噪声过滤，则可以在闭合过滤器之前应用开放过滤器，但这可能会以消除部分破碎对象为代价。
- en: 'The following image is the result of applying the opening filter before the
    closing filter:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像是在应用闭合过滤器之前应用开放过滤器的结果：
- en: '![How it works...](img/image_05_013.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/image_05_013.jpg)'
- en: Note that applying the same opening (and similarly the closing) operator on
    an image several times has no effect. Indeed, as the holes have been filled by
    the first opening filter, an additional application of the same filter will not
    produce any other changes to the image. In mathematical terms, these operators
    are said to be **idempotent**.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，对图像应用相同的开放（以及类似地闭合）算子多次没有效果。实际上，由于孔洞已经被第一次开放过滤器填充，再次应用相同的过滤器不会对图像产生任何其他变化。从数学的角度来看，这些算子被称为**幂等的**。
- en: See also
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The opening and closing operators are often used to clean up an image before
    extracting its connected components as explained in the *Extracting connected
    components* recipe of [Chapter 7](ch07.html "Chapter 7. Extracting Lines, Contours,
    and Components") , *Extracting Lines, Contours, and Components*
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开放和闭合算子通常用于在提取图像的连通组件之前清理图像，如第7章中“提取连通组件”配方中所述，[第7章](ch07.html "第7章。提取线条、轮廓和组件")，*提取线条、轮廓和组件*
- en: Applying morphological operators on gray-level images
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在灰度图像上应用形态学算子
- en: More advanced morphological operators can be composited by combining the different
    basic morphological filters introduced in this chapter. This recipe will present
    two morphological operators that, when applied to gray-level images, can lead
    to the detection of interesting image features.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 更高级的形态学算子可以通过组合本章中介绍的不同基本形态学过滤器来组合。本配方将介绍两个形态学算子，当应用于灰度图像时，可以导致检测到有趣的图像特征。
- en: How to do it...
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'One interesting morphological operator is the morphological gradient that allows
    extracting the edges of an image. This one can be accessed through the `cv::morphologyEx`
    function as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有趣的形态学算子是形态学梯度，它允许提取图像的边缘。这个算子可以通过以下`cv::morphologyEx`函数访问：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The following result shows the extracted contours of the image''s elements
    (the resulting image has been inverted for better viewing):'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 以下结果显示了图像元素的提取轮廓（为了更好的查看，结果图像已被反转）：
- en: '![How to do it...](img/image_05_016.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/image_05_016.jpg)'
- en: 'Another useful morphological operator is the top-hat transform. This operator
    can be used to extract local small foreground objects in an image. The effect
    of this operator can be demonstrated by applying it on the book image of the last
    recipe of the previous chapter. This image shows an unevenly illuminated page
    of a book. A black top-hat transform will extract the characters of this page
    (considered here as the foreground objects). This operator is also called by using
    the `cv::morphologyEx` function with the appropriate flag:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的形态学算子是顶帽变换。这个算子可以用来从图像中提取局部的小前景对象。通过将此算子应用于上一章最后菜谱的书籍图像，可以演示该算子的效果。这张图像显示了一本书页面的不均匀照明。一个黑色的顶帽变换将提取该页面的字符（在此处被视为前景对象）。此算子也可以通过使用带有适当标志的`cv::morphologyEx`函数来调用：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As it can be seen in the following image, this operator successfully extracted
    most of the characters of the original image:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如下图中所示，此算子成功提取了原始图像中的大多数字符：
- en: '![How to do it...](img/image_05_017.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/image_05_017.jpg)'
- en: How it works...
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: A good way to understand the effect of morphological operators on a gray-level
    image is to consider an image as a topological relief in which the gray levels
    correspond to elevation (or altitude). Under this perspective, the bright regions
    correspond to mountains, while the dark areas correspond to the valleys of the
    terrain. Also, since edges correspond to a rapid transition between the dark and
    bright pixels, these can be pictured as abrupt cliffs. If an erosion operator
    is applied on such a terrain, the net result will be to replace each pixel by
    the lowest value in a certain neighborhood, thus reducing its height. As a result,
    cliffs will be eroded as the valleys expand. Dilation has the exact opposite effect;
    that is, cliffs will gain terrain over the valleys. However, in both cases, the
    plateau (that is, the area of constant intensity) will remain relatively unchanged.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解形态学算子对灰度图像的影响，可以将图像视为一个拓扑地形，其中灰度级别对应于海拔（或高度）。从这种角度来看，明亮区域对应于山脉，而暗区对应于地形的山谷。此外，由于边缘对应于暗亮像素之间的快速过渡，这些可以想象为陡峭的悬崖。如果在此类地形上应用侵蚀算子，最终结果将是用一定邻域中的最低值替换每个像素，从而降低其高度。因此，随着山谷的扩张，悬崖将被侵蚀。膨胀具有完全相反的效果；也就是说，悬崖将在山谷上方获得地形。然而，在这两种情况下，高原（即强度恒定的区域）将相对保持不变。
- en: These observations lead to a simple way to detect the edges (or cliffs) of an
    image. This can be done by computing the difference between the dilated and eroded
    images. Since these two transformed images differ mostly at the edge locations,
    the image edges will be emphasized by the subtraction. This is exactly what the
    `cv::morphologyEx` function does when the `cv::MORPH_GRADIENT` argument is inputted.
    Obviously, the larger the structuring element is, the thicker the detected edges
    will be. This edge detection operator is called the **Beucher ** **gradient**
    (the next chapter will discuss the concept of an image gradient in more detail).
    Note that similar results can also be obtained by simply subtracting the original
    image from the dilated one or the eroded image from the original. The resulting
    edges would simply be thinner.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这些观察结果导致了一种简单的方法来检测图像的边缘（或悬崖）。这可以通过计算膨胀图像和侵蚀图像之间的差异来实现。由于这两个转换图像主要在边缘位置不同，因此减法将强调图像边缘。这正是当输入`cv::MORPH_GRADIENT`参数时`cv::morphologyEx`函数所做的事情。显然，结构元素越大，检测到的边缘就越粗。这个边缘检测算子被称为**Beucher梯度**（下一章将更详细地讨论图像梯度的概念）。请注意，通过简单地从原始图像减去膨胀图像或从原始图像减去侵蚀图像也可以获得类似的结果。得到的边缘将只是更细。
- en: The top-hat operator is also based on image difference. This time, the operator
    uses opening and closing. When a gray-level image is morphologically opened, its
    local peaks are eliminated; this is due to the erosion operator that is applied
    first. The rest of the image is preserved. Consequently, the difference between
    the original image and the opened one is the set of local peaks. These local peaks
    are the foreground objects we want to extract. In the book example of this recipe,
    the objective was to extract the characters of the page. Since the foreground
    objects are, in this case, black over a white background, we used the complementary
    operator, called the black top-hat, which consists of subtracting the original
    image from its closing. We used a `7x7` structuring element in order to have the
    closing operation big enough to remove the characters.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 顶帽算子也是基于图像差异的。这次，算子使用开运算和闭运算。当一个灰度图像被形态学开运算时，其局部峰值被消除；这是由于首先应用的腐蚀算子。其余的图像被保留。因此，原始图像与开运算后的图像之间的差异是局部峰值的集合。这些局部峰值是我们想要提取的前景对象。在这个配方示例书中，目标是提取页面上的字符。由于在这种情况下，前景对象是黑色背景上的黑色，我们使用了互补算子，称为黑色顶帽，它由从原始图像中减去其闭运算组成。我们使用了一个`7x7`的结构元素，以便闭运算足够大，可以去除字符。
- en: See also
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Applying directional filters to detect edges* recipe in [Chapter 6](ch06.html
    "Chapter 6. Filtering the Images"), *Filtering the Images*, describes the other
    filters that perform edge detection
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第6章](ch06.html "第6章。图像滤波")的“应用方向滤波检测边缘”配方中，*滤波图像*描述了其他执行边缘检测的滤波器
- en: The article, *The Morphological gradients, J.-F. Rivest, P. Soille, and S. Beucher,
    ISET's symposium on electronic imaging science and technology, SPIE*, Feb. 1992,
    discusses the concept of morphological gradients in more detail
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文章，“形态学梯度，J.-F. Rivest，P. Soille，和S. Beucher，ISET的电子成像科学和技术研讨会，SPIE*”，1992年2月，更详细地讨论了形态学梯度的概念
- en: The article *Morphological operator for corner detection*, *R. Laganière*, *Pattern
    Recognition*, volume 31, issue 11, 1998, presents an operator for the detection
    of corners using morphological filters
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文章“用于角点检测的形态学算子”，R. Laganière，*模式识别*，第31卷，第11期，1998年，提出了一种使用形态学滤波器检测角点的算子
- en: Segmenting images using watersheds
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用水平集分割图像
- en: The watershed transformation is a popular image processing algorithm that is
    used to quickly segment an image into homogenous regions. It relies on the idea
    that when the image is seen as a topological relief, the homogeneous regions correspond
    to relatively flat basins delimited by steep edges. With the watershed algorithm,
    segmentation is achieved by flooding this relief by gradually increasing the level
    of water in this one. As a result of its simplicity, the original version of this
    algorithm tends to over-segment the image, which produces multiple small regions.
    This is why OpenCV proposes a variant of this algorithm that uses a set of predefined
    markers to guide the definition of the image segments.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 水平集变换是一种流行的图像处理算法，用于快速将图像分割成同质区域。它依赖于这样的想法：当图像被视为拓扑起伏时，同质区域对应于相对平坦的盆地，这些盆地由陡峭的边缘所限定。使用水平集算法，通过逐渐增加该盆地中的水位来淹没这个起伏，从而实现分割。由于其简单性，该算法的原版往往会导致图像过度分割，从而产生多个小区域。这就是为什么OpenCV提出了这个算法的一个变体，该变体使用一组预定义的标记来引导图像区域的定义。
- en: How to do it...
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The watershed segmentation is obtained through the use of the `cv::watershed`
    function. The input for this function is a 32-bit signed integer marker image
    in which each nonzero pixel represents a label. The idea is to mark some pixels
    of the image that are known to belong to a given region. From this initial labeling,
    the watershed algorithm will determine the regions to which the other pixels belong.
    In this recipe, we will first create the marker image as a gray-level image and
    then convert it into an image of integers. We have conveniently encapsulated this
    step into a `WatershedSegmenter` class containing a method to specify the marker
    image and a method to compute the watershed:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 水平集分割是通过使用`cv::watershed`函数获得的。该函数的输入是一个32位有符号整数标记图像，其中每个非零像素代表一个标签。其想法是标记图像中已知属于某个区域的某些像素。从这个初始标记开始，水平集算法将确定其他像素所属的区域。在这个配方中，我们首先创建标记图像作为一个灰度图像，然后将其转换为整数图像。我们方便地将这一步骤封装到一个包含指定标记图像的方法和一个计算水平集的方法的`WatershedSegmenter`类中：
- en: '[PRE9]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The way these markers are obtained depends on the application. For example,
    some preprocessing steps might have resulted in the identification of some pixels
    that belong to an object of interest. The watershed would then be used to delimitate
    the complete object from that initial detection. In this recipe, we will simply
    use the binary image used throughout this chapter in order to identify the animals
    of the corresponding original image (this is the image shown at the beginning
    of [Chapter 4](ch04.html "Chapter 4. Counting the Pixels with Histograms") , *Counting
    the Pixels with Histograms*). Therefore, from our binary image, we need to identify
    pixels that belong to the foreground (the animals) and pixels that belong to the
    background (mainly the grass). Here, we will mark the foreground pixels with the
    label `255` and the background pixels with the label `128` (this choice is totally
    arbitrary; any label number other than `255` will work). The other pixels, that
    is, the ones for which the labeling is unknown, are assigned the value `0`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这些标记的获取方式取决于应用。例如，一些预处理步骤可能导致了识别出一些属于感兴趣对象的像素。然后，水线算法将被用来从初始检测中界定整个对象。在本食谱中，我们将简单地使用本章中使用的二值图像来识别对应原始图像中的动物（这是[第4章](ch04.html
    "第4章. 使用直方图计数像素")中展示的图像，*使用直方图计数像素*）。因此，从我们的二值图像中，我们需要识别属于前景（动物）的像素和属于背景（主要是草地）的像素。在这里，我们将前景像素标记为标签`255`，背景像素标记为标签`128`（这种选择完全是任意的；除了`255`之外的任何标签数字都可以工作）。其他像素，即标签未知的那部分像素，被分配值为`0`。
- en: 'As of now, the binary image includes white pixels that belong to the various
    parts of the image. We will then severely erode this image in order to retain
    only the pixels that certainly belong to the foreground objects:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，二值图像包括属于图像各个部分的白色像素。然后我们将严重腐蚀此图像，以保留仅属于前景对象的像素：
- en: '[PRE10]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The result is the following image:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是以下图像：
- en: '![How to do it...](img/image_05_020.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/image_05_020.jpg)'
- en: 'Note that a few pixels that belong to the background forest are still present.
    Let''s keep them. Therefore, they will be considered to correspond to an object
    of interest. Similarly, we can select a few pixels of the background by a large
    dilation of the original binary image:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，一些属于背景森林的像素仍然存在。让我们保留它们。因此，它们将被认为是属于感兴趣对象的。同样，我们可以通过原始二值图像的大膨胀来选择一些背景像素：
- en: '[PRE11]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The resulting black pixels correspond to background pixels. This is why the
    thresholding operation assigns the value `128` to these pixels immediately after
    the dilation. The following image is obtained:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 结果中的黑色像素对应于背景像素。这就是为什么阈值操作在膨胀之后立即将这些像素的值分配为`128`。得到的图像如下：
- en: '![How to do it...](img/image_05_022.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/image_05_022.jpg)'
- en: 'These images are combined to form the marker image as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这些图像如下组合成标记图像：
- en: '[PRE12]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Note how we used the overloaded `operator+` here in order to combine the images.
    The following image will be used as the input to the watershed algorithm:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们在这里如何使用重载的`operator+`来组合图像。以下图像将被用作水线算法的输入：
- en: '![How to do it...](img/image_05_024.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/image_05_024.jpg)'
- en: 'In this input image, the white areas belong, for sure, to the foreground objects,
    the gray areas are a part of the background, and the black areas have an unknown
    label. The role of the watershed segmentation is therefore to assign a label (background/foreground)
    to the black marked pixels by establishing the exact border delimitating the foreground
    objects from the background. This segmentation is then obtained as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个输入图像中，白色区域肯定属于前景对象，灰色区域是背景的一部分，黑色区域具有未知标签。因此，水线分割的作用是通过建立精确的前景对象与背景之间的边界来为黑色标记像素分配标签（背景/前景）。这种分割如下获得：
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The marker image is then updated such that each zero pixel is assigned one
    of the input labels, while the pixels that belong to the found boundaries have
    a value `-1`. The resulting image of the labels is as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 标记图像随后更新，使得每个零像素被分配一个输入标签，而属于找到的边界的像素具有值`-1`。标签的最终图像如下：
- en: '![How to do it...](img/image_05_026.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/image_05_026.jpg)'
- en: 'And the boundary image is as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 边界图像如下：
- en: '![How to do it...](img/image_05_028.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/image_05_028.jpg)'
- en: How it works...
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As we did in the preceding recipes, we will use the topological map analogy
    in the description of the watershed algorithm. In order to create watershed segmentation,
    the idea is to progressively flood the image starting at level 0\. As the level
    of water progressively increases (to levels 1, 2, 3, and so on), catchment basins
    are formed. The size of these basins also gradually increases and, consequently,
    the water of two different basins will eventually merge. When this happens, a
    watershed is created in order to keep the two basins separated. Once the level
    of water has reached its maximum level, the sets of these created basins and watersheds
    form the watershed segmentation.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的菜谱中所做的那样，我们将在流域算法的描述中使用拓扑图类比。为了创建流域分割，想法是从级别0开始逐步洪水淹没图像。随着水位的逐步增加（到级别1、2、3等等），会形成集水盆地。这些盆地的尺寸也逐步增加，因此，两个不同盆地的水最终会合并。当这种情况发生时，会创建一个流域以保持两个盆地的分离。一旦水位达到最大级别，这些创建的盆地和流域的集合形成流域分割。
- en: As expected, the flooding process initially creates many small individual basins.
    When all of these are merged, many watershed lines are created, which results
    in an over-segmented image. To overcome this problem, a modification to this algorithm
    has been proposed in which the flooding process starts from a predefined set of
    marked pixels. The basins created from these markers are labeled in accordance
    with the values assigned to the initial marks. When two basins having the same
    label merge, no watershed is created, thus preventing over-segmentation. This
    is what happens when the `cv::watershed` function is called. The input marker
    image is updated to produce the final watershed segmentation. Users can input
    a marker image with any number of labels and pixels of unknown labeling left to
    value `0`. The marker image is chosen to be an image of a 32-bit signed integer
    in order to be able to define more than `255` labels. It also allows the special
    value, `-1`, to be assigned to the pixels associated with a watershed.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，洪水过程最初会创建许多小的独立盆地。当所有这些盆地合并时，会创建许多流域线，这导致图像过度分割。为了克服这个问题，已经提出了一种修改后的算法，其中洪水过程从一组预定义的标记像素开始。从这些标记创建的盆地根据分配给初始标记的值进行标记。当两个具有相同标签的盆地合并时，不会创建流域，从而防止过度分割。这就是调用`cv::watershed`函数时发生的情况。输入标记图像被更新以产生最终的流域分割。用户可以输入带有任何数量标签和未知标记像素保留为值`0`的标记图像。标记图像被选择为32位有符号整数的图像，以便能够定义超过`255`个标签。它还允许将特殊值`-1`分配给与流域相关的像素。
- en: 'To facilitate the display of the result, we have introduced two special methods.
    The first method returns an image of the labels (with watersheds at value `0`).
    This is easily done through thresholding, as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了便于显示结果，我们引入了两种特殊方法。第一种方法返回标签图像（流域值为`0`）。这可以通过以下阈值操作轻松完成：
- en: '[PRE14]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Similarly, the second method returns an image in which the watershed lines
    are assigned the value `0`, and the rest of the image is at `255`. This time,
    the `cv::convertTo` method is used to achieve this result, as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，第二种方法返回一个图像，其中流域线被分配值为`0`，其余图像为`255`。这次，使用`cv::convertTo`方法来实现这个结果，如下所示：
- en: '[PRE15]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The linear transformation that is applied before the conversion allows the `-1`
    pixels to be converted into `0` (since `-1*255+255=0`).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在转换之前应用的线性变换允许`-1`像素转换为`0`（因为`-1*255+255=0`）。
- en: Pixels with a value greater than `255` are assigned the value `255`. This is
    due to the saturation operation that is applied when signed integers are converted
    into unsigned characters.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 值大于`255`的像素被分配值为`255`。这是由于在将有符号整数转换为无符号字符时应用的饱和操作。
- en: There's more...
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Obviously, the marker image can be obtained in many different ways. For example,
    users can be interactively asked to mark the objects of an image by painting some
    areas on the objects and the background of a scene. Alternatively, in an attempt
    to identify an object located at the center of an image, one can also simply input
    an image with the central area marked with a certain label and the border of the
    image (where the background is assumed to be present) marked with another label.
    This marker image can be created by drawing thick rectangles on a marker image
    as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，标记图像可以通过多种方式获得。例如，可以交互式地要求用户通过在对象和场景背景上绘制一些区域来标记图像中的对象。或者，为了识别位于图像中心的对象，也可以简单地输入一个带有中心区域标记的图像，该区域带有某种标签，图像的边缘（假设存在背景）带有另一个标签。可以通过以下方式在标记图像上绘制粗矩形来创建这个标记图像：
- en: '[PRE16]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If we superimpose this marker image on a test image, we will obtain the following
    image:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将这个标记图像叠加到测试图像上，我们将获得以下图像：
- en: '![There''s more...](img/image_05_030.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多...](img/image_05_030.jpg)'
- en: 'The following is the resulting watershed image:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的结果是流域图像：
- en: '![There''s more...](img/image_05_032.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多...](img/image_05_032.jpg)'
- en: See also
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The article, *The viscous watershed transform*, *C. Vachier* and *F. Meyer*,
    *Journal of Mathematical Imaging and Vision*, volume 22, issue 2-3, May 2005,
    gives more information on the watershed transform
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文章《粘性流域变换》，作者C. Vachier和F. Meyer，《数学图像与视觉杂志》，第22卷，第2-3期，2005年5月，提供了关于流域变换的更多信息
- en: Extracting distinctive regions using MSER
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用MSER提取独特区域
- en: In the previous recipe, you learned how an image can be segmented into regions
    by gradually flooding it and creating watersheds. The **Maximally Stable External
    Regions** (**MSER**) algorithm uses the same immersion analogy in order to extract
    meaningful regions in an image. These regions will also be created by flooding
    the image level by level, but this time, we will be interested in the basins that
    remain relatively stable for a period of time during the immersion process. It
    will be observed that these regions correspond to some distinctive parts of the
    scene objects pictured in the image.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的菜谱中，你学习了如何通过逐渐淹没图像并创建流域来将图像分割成区域。**最大稳定外部区域**（**MSER**）算法使用相同的沉浸类比来从图像中提取有意义的区域。这些区域将通过逐级淹没图像来创建，但这次，我们将对在沉浸过程中相对稳定的盆地感兴趣。将观察到这些区域对应于图像中场景对象的某些独特部分。
- en: How to do it...
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The basic class to compute the MSER of an image is `cv::MSER`. This class is
    an abstract interface that inherits from the `cv::Feature2D` class; in fact, all
    feature detectors in OpenCV inherit from this super-class. An instance of the
    `cv::MSER` class can be created by using the `create` method. Here, we initialize
    it by specifying a minimum and maximum size for the detected regions in order
    to limit the number of detected features as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 计算图像MSER的基本类是`cv::MSER`。这个类是从`cv::Feature2D`类继承的抽象接口；实际上，OpenCV中的所有特征检测器都继承自这个超类。可以通过使用`create`方法创建`cv::MSER`类的实例。在这里，我们通过指定检测区域的最小和最大尺寸来初始化它，以限制检测到的特征数量，如下所示：
- en: '[PRE17]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, the MSER can be obtained by a call to the `detectRegions` method, specifying
    the input image and the appropriate output data structures, as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，可以通过调用`detectRegions`方法来获得MSER，指定输入图像和适当的数据结构，如下所示：
- en: '[PRE18]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The detection results are provided in the form of a vector of regions represented
    by the pixel points that compose each of them and by a vector of bounding boxes
    enclosing the regions. In order to visualize the results, we create a blank image
    on which we will display the detected regions in different colors (which are randomly
    chosen). This is done as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 检测结果以由像素点组成的区域向量形式提供，这些像素点构成了每个区域，以及包围区域的边界框向量。为了可视化结果，我们在一个空白图像上创建一个图像，将在不同颜色（随机选择）上显示检测到的区域。这是按照以下步骤进行的：
- en: '[PRE19]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Note that the MSER form a hierarchy of regions. Therefore, to make all of these
    visible, we have chosen not to overwrite the larger regions when they include
    smaller ones. We can detect MSERs on the following image:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，MSER形成了一个区域层次结构。因此，为了使所有这些区域都可见，我们选择在较大区域包含较小区域时，不覆盖较大区域。我们可以在以下图像上检测到MSER：
- en: '![How to do it...](img/image_05_034.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/image_05_034.jpg)'
- en: 'The resulting image will be as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 结果图像将如下所示：
- en: '![How to do it...](img/image_05_036.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/image_05_036.jpg)'
- en: Not all regions are visible in this image. Nevertheless, it can be observed
    how this operator has been able to extract some meaningful regions (for example,
    the building's windows) from this image.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有区域都可见于这张图像中。然而，我们可以观察到这个算子是如何从这张图像中提取出一些有意义的区域（例如，建筑的窗户）的。
- en: How it works...
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: MSER uses the same mechanism as the watershed algorithm; that is, it proceeds
    by gradually flooding the image from level `0` to level `255`. Note that in image
    processing, the set of pixels above a certain threshold is often call a **level
    set**. As the level of water increases, you can observe that the sharply delimitated
    darker areas form basins that have a relatively stable shape for a period of time
    (recall that under the immersion analogy, the water levels correspond to the intensity
    levels). These stable basins are the MSER. These are detected by considering the
    connected regions (the basins) at each level and measuring their stability. This
    is done by comparing the current area of a region with the area it previously
    had when the level was down by a value of delta. When this relative variation
    reaches a local minimum, the region is identified as a MSER. The delta value that
    is used to measure the relative stability is the first parameter in the constructor
    of the `cv::MSER` class; its default value is `5`. In addition, to be considered,
    the size of a region must be within a certain predefined range. The acceptable
    minimum and maximum region sizes are the next two parameters of the constructor.
    We must also ensure that the MSER is stable (the fourth parameter), that is, the
    relative variation of its shape is small enough. Stable regions can be included
    in the larger regions (called parent regions).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: MSER 使用与分水岭算法相同的机制；也就是说，它是通过逐渐从级别 `0` 到级别 `255` 浇灌图像来进行的。请注意，在图像处理中，高于某个阈值的像素集通常被称为
    **水平集**。随着水位的升高，你可以观察到那些尖锐界定的较暗区域形成了具有相对稳定形状的盆地（回想一下，在沉浸类比中，水位对应于强度水平）。这些稳定的盆地就是
    MSER。这些是通过考虑每个级别的连通区域（盆地）并测量它们的稳定性来检测的。这是通过比较一个区域的当前面积与当级别下降 delta 值时的先前面积来完成的。当这种相对变化达到局部最小值时，该区域被识别为
    MSER。用于测量相对稳定性的 delta 值是 `cv::MSER` 类构造函数的第一个参数；其默认值是 `5`。此外，要考虑的区域大小必须在某个预定义的范围内。可接受的区域最小和最大大小是构造函数的下一个两个参数。我们还必须确保
    MSER 是稳定的（第四个参数），也就是说，其形状的相对变化足够小。稳定的区域可以包含在更大的区域中（称为父区域）。
- en: To be valid, a parent MSER must be sufficiently different from its child; this
    is the diversity criterion, and it is specified by the fifth parameter of the
    `cv::MSER` constructor. In the example used in the previous section, the default
    values for these last two parameters were used. (The default values are `0.25`
    for the maximum allowable variation of a MSER and `0.2` for the minimum diversity
    of a parent MSER). As you see, the detection of MSERs requires the specification
    of several parameters which can make it difficult to work well in various contexts.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 要有效，父 MSER 必须与其子区域有足够的差异；这是多样性标准，它由 `cv::MSER` 构造函数的第五个参数指定。在上一节中使用的示例中，使用了这两个最后参数的默认值。（这些最后两个参数的默认值是
    MSER 允许的最大变化为 `0.25`，父 MSER 的最小多样性为 `0.2`）。正如你所见，MSER 的检测需要指定多个参数，这可能会使其在不同环境中难以有效工作。
- en: 'The first output of the MSER detector is a vector of point sets; each of these
    point sets constitutes a region. Since we are generally more interested in a region
    as a whole rather than its individual pixel locations, it is common to represent
    a MSER by a simple geometrical shape that enclosed the detected region. The second
    output of the detection is therefore a list of bounding boxes. We can therefore
    show the result of the detection by drawing all these rectangular bounding boxes.
    However, this may represent a large number of rectangles to be drawn which would
    make the results difficult to visualize (remember that we also have regions inside
    regions which makes the representation even more cluttered). In the case of our
    example, let''s assume we are mainly interested in detecting the building''s windows.
    We will therefore extract all regions that have an upright rectangular shape.
    This could be done by comparing the area of each bounding box with the area of
    the corresponding detected region. If both have the same value (here, we check
    if the ratio of these two areas is greater than `0.6`), then we accept this MSER.
    The following code implements this test:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: MSER检测器的第一个输出是一个点集向量；这些点集中的每一个都构成一个区域。由于我们通常对整个区域更感兴趣，而不是其单个像素位置，因此通常用包围检测到的区域的一个简单几何形状来表示MSER。因此，检测的第二个输出是一个边界框列表。因此，我们可以通过绘制所有这些矩形边界框来显示检测的结果。然而，这可能会表示出大量的矩形，使得结果难以可视化（记住我们还有区域内的区域，这使得表示更加杂乱）。在我们的例子中，让我们假设我们主要对检测建筑物的窗户感兴趣。因此，我们将提取所有具有直立矩形形状的区域。这可以通过比较每个边界框的面积与相应检测区域的面积来完成。如果两者具有相同的值（在这里，我们检查这两个面积的比率是否大于`0.6`），那么我们接受这个MSER。以下代码实现了这个测试：
- en: '[PRE20]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The extracted MSERs are then as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 提取的MSER如下所示：
- en: '![How it works...](img/image_05_037.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/image_05_037.jpg)'
- en: Other criteria and representation can also be adopted depending on the application.
    The following code tests if the detected region is not too elongated (based on
    the aspect ratio of its rotated bounding rectangle) and then displays them using
    properly oriented bounding ellipses.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 根据应用的不同，也可以采用其他标准和表示方法。以下代码测试检测到的区域是否不太细长（基于其旋转边界矩形的纵横比），然后使用适当方向的边界椭圆显示它们。
- en: '[PRE21]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The result is the following image:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下所示：
- en: '![How it works...](img/image_05_038.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/image_05_038.jpg)'
- en: Note how the child and parent MSER are often represented by very similar ellipses.
    In some cases, it would then be interesting to apply a minimum variation criterion
    on these ellipses in order to eliminate these repeated representations.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 注意子MSER和父MSER通常由非常相似的椭圆表示。在某些情况下，然后对这些椭圆应用最小变化标准以消除这些重复表示可能是有趣的。
- en: See also
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Computing components' shape descriptors* recipe in [Chapter 7](ch07.html
    "Chapter 7. Extracting Lines, Contours, and Components") , *Extracting Lines,
    Contours, and Components*, will show you how to compute other properties of connected
    point sets
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第7章的计算组件形状描述符](ch07.html "第7章。提取线条、轮廓和组件")中的“提取线条、轮廓和组件”配方将向您展示如何计算连接点集的其他属性'
- en: '[Chapter 8](ch08.html "Chapter 8. Detecting Interest Points") , *Detecting
    Interest Points*, will explain how to use MSER as an interest point detector'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第8章检测兴趣点](ch08.html "第8章。检测兴趣点")将解释如何将MSER用作兴趣点检测器'
