- en: Chapter 7. Unsupervised Learning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Self-organizing map **- visualizing heatmaps'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Vector quantization**--Image clustering'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Self-organizing map (SOM)**: The self-organizing map belongs to a class of
    unsupervised learning that is based on competitive learning, in which output neurons
    compete amongst themselves to be activated, with the result that only one is activated
    at any one time. This activated neuron is called the winning neuron. Such competition
    can be induced/implemented by having lateral inhibition connections (negative
    feedback paths) between the neurons, resulting in the neurons organizing themselves.
    SOM can be imagined as a sheet-like neural network, with nodes arranged as regular,
    usually two-dimensional grids. The principal goal of a SOM is to transform an
    incoming arbitrary dimensional signal into a one- or two-dimensional discrete
    map, and to perform this transformation adaptively in a topologically ordered
    fashion. The neurons are selectively tuned to various input patterns (stimuli)
    or classes of input patterns during the course of the competitive learning. The
    locations of the neurons so tuned (the winning neurons) become ordered, and a
    meaningful coordinate system for input features is created on the lattice. The
    SOM thus forms the required topographic map of the input patterns.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Vector quantization**: Quantization is the process of mapping an infinite
    set of scalar or vector quantities by a finite set of scalar or vector quantities.
    Quantization has applications in the areas of signal processing, speech processing,
    and image processing. Vector quantization performs quantization over blocks of
    data, instead of a single scalar value. The quantization output is an index value
    that indicates another data block (vector) from a finite set of vectors, called
    the codebook. The selected vector is usually an approximation of the input data
    block. Reproduction vectors are known as encoders and decoders. The encoder takes
    an input vector, which determines the best representing reproduction vector, and
    transmits the index of that vector. The decoder takes that index and forms the
    reproduction vector.'
  prefs: []
  type: TYPE_NORMAL
- en: Self-organizing map - visualizing of heatmaps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Over the past decade, there has been exponential growth in information. Gaining
    new knowledge from such databases is difficult, costly, and time-consuming if
    done manually. It may even be impossible when the data exceeds certain limits
    of size and complexity. As a result, the automated analysis and visualization
    of massive multidimensional datasets have been the focus of much scientific research
    over the last few years. The principal objective of this analysis and visualization
    is to find regularities and relationships in the data, thereby gaining access
    to hidden and potentially useful knowledge. A self-organizing map (SOM) is an
    unsupervised neural network algorithm that projects high-dimensional data onto
    a two-dimensional map. The projection preserves the topology of the data so that
    similar data items will be mapped to nearby locations on the map.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's get into the details.
  prefs: []
  type: TYPE_NORMAL
- en: Step 1 - exploring data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following packages first need to be loaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Version info: Code for this page was tested in R version 3.3.2 (2016-10-31)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a sample dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Changing the data frame with training data to a matrix: `scale()` as a function
    centers and scales the columns of a `training_frame` matrix. The `as.matrix()`
    function creates a matrix from the result of `scale(training_frame)`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the `training_matrix`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 1 - exploring data](img/image_07_001.jpg)![Step 1 - exploring data](img/image_07_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Step 2 - training the model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Creating the SOM Grid: `somgrid()` plots the functions of the self-organizing
    map''s grids. `xdim = 20` and `ydim=20` are the dimensions of the grid, while
    `topo="hexagonal"` represents the topology of the grid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Training the Self Organizing Maps: `som()` is a function of self-organizing
    maps that is used to map high-dimensional spectra or patterns to 2D. The Euclidean
    distance measure is used. `training_matrix` is the data matrix, `rlen=1000` is
    the number of times the complete dataset will be presented to the network for
    training, and alpha is the learning rate. `keep.data = TRUE` means that the data
    needs to be saved in the return object and `n.hood="circular"` indicates the shape
    of the neighborhood:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Step 3 - plotting the model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Plotting the `som_model` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - plotting the model](img/image_07_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Plotting the model based on node count:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - plotting the model](img/image_07_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Plotting the model based on the neighborhood distance.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - plotting the model](img/image_07_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The following code plots the model based on the `type = "codes"`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - plotting the model](img/image_07_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The following code plots the model based on property plot.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - plotting the model](img/image_07_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Vector quantization - image clustering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The development of technology in the field of digital media generates huge amounts
    of non-textual information in the form of images. If programs could comprehend
    the significance of these images and understand what they mean, this could result
    in a vast number of different applications. One such application could be the
    use of robots to extract malign tissue from hospital patients using body scan
    images to interpret the location of the tissue. Images are considered one of the
    most important media for conveying information. The potential for the retrieval
    of information is vast, so much so that users may be overwhelmed by the sheer
    amount of information retrieved. The unstructured format of images challenges
    classification and clustering techniques. Machine learning algorithms are used
    to extract information to understand images. One of the first steps towards understanding
    images is to segment them and identify the different objects within them. To do
    this, features like histogram plots and frequency domain transform can be used.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: Step 1 - collecting and describing data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The JPEG file is used.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's get into the details.
  prefs: []
  type: TYPE_NORMAL
- en: Step 2 - exploring data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following packages first need to be loaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Version info: Code for this page was tested in R version 3.3.2'
  prefs: []
  type: TYPE_NORMAL
- en: The `readJPEG()` function is used to read an image in the JPEG file format,
    and converts it into a raster array:.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Step 3 - data cleaning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Exploring the dimensions of the `img`: the `dim()` function returns the dimensions
    of the `img` frame. The `img` data frame is passed as an input parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s print the `img_Dim`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - data cleaning](img/image_07_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we are assigning RGB (red, green, and blue--RGB channels roughly follow
    the color receptors in the human eye) channels to the data frame. The result is
    then stored in the `img_RGB_channels` data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Step 4 - visualizing cleaned data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s plot the original image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 - visualizing cleaned data](img/image_07_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Step 5 - building the model and visualizing it
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Assigning the clustering colors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Performing k-means clustering: `kmeans()` as a function performs clustering
    on the data matrix `img_RGB_channels`. `centers = kClusters` signifies the number
    of initial clusters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Creating colours corresponding to the given intensities of red, green and blue
    primaries.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Plotting the image with three clusters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 5 - building the model and visualizing it](img/image_07_010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Assigning the clustering colors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Performing k-means clustering:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Creating colours corresponding to the given intensities of red, green and blue
    primaries.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Plotting the image with five clusters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 5 - building the model and visualizing it](img/image_07_011.jpg)'
  prefs: []
  type: TYPE_IMG
