- en: Chapter 7. Unsupervised Learning
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。无监督学习
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: '**Self-organizing map **- visualizing heatmaps'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自组织映射** - 热图可视化'
- en: '**Vector quantization**--Image clustering'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**矢量量化**--图像聚类'
- en: Introduction
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: '**Self-organizing map (SOM)**: The self-organizing map belongs to a class of
    unsupervised learning that is based on competitive learning, in which output neurons
    compete amongst themselves to be activated, with the result that only one is activated
    at any one time. This activated neuron is called the winning neuron. Such competition
    can be induced/implemented by having lateral inhibition connections (negative
    feedback paths) between the neurons, resulting in the neurons organizing themselves.
    SOM can be imagined as a sheet-like neural network, with nodes arranged as regular,
    usually two-dimensional grids. The principal goal of a SOM is to transform an
    incoming arbitrary dimensional signal into a one- or two-dimensional discrete
    map, and to perform this transformation adaptively in a topologically ordered
    fashion. The neurons are selectively tuned to various input patterns (stimuli)
    or classes of input patterns during the course of the competitive learning. The
    locations of the neurons so tuned (the winning neurons) become ordered, and a
    meaningful coordinate system for input features is created on the lattice. The
    SOM thus forms the required topographic map of the input patterns.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '**自组织映射（SOM）**：自组织映射属于基于竞争学习的一种无监督学习类别，在这种学习中，输出神经元之间相互竞争以被激活，结果是任何给定时间只有一个被激活。这个被激活的神经元被称为获胜神经元。这种竞争可以通过在神经元之间具有侧抑制连接（负反馈路径）来诱导/实现，从而导致神经元自我组织。SOM可以想象成一种片状的神经网络，节点排列成规则的、通常是二维的网格。SOM的主要目标是将任意维度的输入信号转换为一维或二维的离散映射，并以拓扑有序的方式自适应地执行这种转换。在竞争学习过程中，神经元被选择性地调整以适应各种输入模式（刺激）或输入模式的类别。这样调整的神经元（获胜神经元）的位置是有序的，并在晶格上创建了一个有意义的输入特征坐标系。因此，SOM形成了输入模式的所需拓扑映射。'
- en: '**Vector quantization**: Quantization is the process of mapping an infinite
    set of scalar or vector quantities by a finite set of scalar or vector quantities.
    Quantization has applications in the areas of signal processing, speech processing,
    and image processing. Vector quantization performs quantization over blocks of
    data, instead of a single scalar value. The quantization output is an index value
    that indicates another data block (vector) from a finite set of vectors, called
    the codebook. The selected vector is usually an approximation of the input data
    block. Reproduction vectors are known as encoders and decoders. The encoder takes
    an input vector, which determines the best representing reproduction vector, and
    transmits the index of that vector. The decoder takes that index and forms the
    reproduction vector.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '**矢量量化**：量化是将无限集合的标量或矢量量通过有限集合的标量或矢量量进行映射的过程。量化在信号处理、语音处理和图像处理等领域有应用。矢量量化对数据块进行量化，而不是单个标量值。量化输出是一个索引值，它指示来自有限矢量集合（称为码本）的另一个数据块（矢量）。所选矢量通常是输入数据块的近似。再现矢量被称为编码器和解码器。编码器接收一个输入矢量，确定最佳表示的再现矢量，并传输该矢量的索引。解码器接收该索引并形成再现矢量。'
- en: Self-organizing map - visualizing of heatmaps
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自组织映射 - 热图可视化
- en: Over the past decade, there has been exponential growth in information. Gaining
    new knowledge from such databases is difficult, costly, and time-consuming if
    done manually. It may even be impossible when the data exceeds certain limits
    of size and complexity. As a result, the automated analysis and visualization
    of massive multidimensional datasets have been the focus of much scientific research
    over the last few years. The principal objective of this analysis and visualization
    is to find regularities and relationships in the data, thereby gaining access
    to hidden and potentially useful knowledge. A self-organizing map (SOM) is an
    unsupervised neural network algorithm that projects high-dimensional data onto
    a two-dimensional map. The projection preserves the topology of the data so that
    similar data items will be mapped to nearby locations on the map.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去十年中，信息呈指数增长。如果手动从这样的数据库中获取新知识，将会很困难、成本高且耗时。当数据超过一定的大小和复杂度限制时，甚至可能无法实现。因此，在过去的几年中，对大规模多维数据集的自动分析和可视化一直是科学研究的重点。本分析和可视化的主要目标是找到数据中的规律性和关系，从而获取隐藏的潜在有用知识。自组织映射（SOM）是一种无监督的神经网络算法，它将高维数据投影到二维映射上。这种投影保留了数据的拓扑结构，使得相似的数据项将被映射到地图上的相邻位置。
- en: How to do it...
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Let's get into the details.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解细节。
- en: Step 1 - exploring data
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 1 步 - 探索数据
- en: 'The following packages first need to be loaded:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 以下包首先需要加载：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Version info: Code for this page was tested in R version 3.3.2 (2016-10-31)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 版本信息：本页面的代码在 R 版本 3.3.2（2016-10-31）中进行了测试
- en: 'Create a sample dataset:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个示例数据集：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Changing the data frame with training data to a matrix: `scale()` as a function
    centers and scales the columns of a `training_frame` matrix. The `as.matrix()`
    function creates a matrix from the result of `scale(training_frame)`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 将带有训练数据的 data frame 转换为矩阵：`scale()` 函数作为 `training_frame` 矩阵的列进行中心化和缩放。`as.matrix()`
    函数从 `scale(training_frame)` 的结果创建一个矩阵。
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Printing the `training_matrix`:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 打印 `training_matrix`：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The result is as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '![Step 1 - exploring data](img/image_07_001.jpg)![Step 1 - exploring data](img/image_07_002.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![第 1 步 - 探索数据](img/image_07_001.jpg)![第 1 步 - 探索数据](img/image_07_002.jpg)'
- en: Step 2 - training the model
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 2 步 - 训练模型
- en: 'Creating the SOM Grid: `somgrid()` plots the functions of the self-organizing
    map''s grids. `xdim = 20` and `ydim=20` are the dimensions of the grid, while
    `topo="hexagonal"` represents the topology of the grid:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 SOM 网格：`somgrid()` 绘制自组织映射网格的函数。`xdim = 20` 和 `ydim=20` 是网格的维度，而 `topo="hexagonal"`
    表示网格的拓扑结构：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Training the Self Organizing Maps: `som()` is a function of self-organizing
    maps that is used to map high-dimensional spectra or patterns to 2D. The Euclidean
    distance measure is used. `training_matrix` is the data matrix, `rlen=1000` is
    the number of times the complete dataset will be presented to the network for
    training, and alpha is the learning rate. `keep.data = TRUE` means that the data
    needs to be saved in the return object and `n.hood="circular"` indicates the shape
    of the neighborhood:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 训练自组织映射：`som()` 是自组织映射的一个函数，用于将高维光谱或模式映射到 2D。使用欧几里得距离度量。`training_matrix` 是数据矩阵，`rlen=1000`
    是完整数据集将向网络展示以进行训练的次数，alpha 是学习率。`keep.data = TRUE` 表示数据需要保存在返回对象中，`n.hood="circular"`
    表示邻域的形状：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Step 3 - plotting the model
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 3 步 - 绘制模型
- en: 'Plotting the `som_model` object:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制 `som_model` 对象：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The result is as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '![Step 3 - plotting the model](img/image_07_003.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![步骤 3 - 绘制模型](img/image_07_003.jpg)'
- en: 'Plotting the model based on node count:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 基于节点计数绘制模型：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The result is as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '![Step 3 - plotting the model](img/image_07_004.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![步骤 3 - 绘制模型](img/image_07_004.jpg)'
- en: Plotting the model based on the neighborhood distance.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 基于邻域距离绘制模型。
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The result is as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '![Step 3 - plotting the model](img/image_07_005.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![步骤 3 - 绘制模型](img/image_07_005.jpg)'
- en: The following code plots the model based on the `type = "codes"`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码基于 `type = "codes"` 绘制模型。
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The result is as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '![Step 3 - plotting the model](img/image_07_006.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![步骤 3 - 绘制模型](img/image_07_006.jpg)'
- en: The following code plots the model based on property plot.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码基于属性图绘制模型。
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The result is as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '![Step 3 - plotting the model](img/image_07_007.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![步骤 3 - 绘制模型](img/image_07_007.jpg)'
- en: Vector quantization - image clustering
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向量量化 - 图像聚类
- en: The development of technology in the field of digital media generates huge amounts
    of non-textual information in the form of images. If programs could comprehend
    the significance of these images and understand what they mean, this could result
    in a vast number of different applications. One such application could be the
    use of robots to extract malign tissue from hospital patients using body scan
    images to interpret the location of the tissue. Images are considered one of the
    most important media for conveying information. The potential for the retrieval
    of information is vast, so much so that users may be overwhelmed by the sheer
    amount of information retrieved. The unstructured format of images challenges
    classification and clustering techniques. Machine learning algorithms are used
    to extract information to understand images. One of the first steps towards understanding
    images is to segment them and identify the different objects within them. To do
    this, features like histogram plots and frequency domain transform can be used.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 数字媒体领域的科技发展产生了大量的非文本信息，以图像的形式存在。如果程序能够理解这些图像的重要性并理解它们的意义，这将导致大量不同的应用。其中一种应用可能是使用机器人从医院患者的身体扫描图像中提取恶性组织，以解释组织的位置。图像被认为是传达信息最重要的媒体之一。信息检索的潜力巨大，以至于用户可能会被检索到的信息量所淹没。图像的无结构格式对分类和聚类技术构成了挑战。机器学习算法用于提取信息以理解图像。理解图像的第一步是分割它们并识别其中的不同对象。为此，可以使用直方图和频域变换等特征。
- en: Getting ready
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Let's get started.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: Step 1 - collecting and describing data
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤 1 - 收集和描述数据
- en: The JPEG file is used.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 JPEG 文件。
- en: How to do it...
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Let's get into the details.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解。
- en: Step 2 - exploring data
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤 2 - 探索数据
- en: 'The following packages first need to be loaded:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 以下包首先需要加载：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Version info: Code for this page was tested in R version 3.3.2'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 版本信息：本页面的代码在 R 版本 3.3.2 中进行了测试
- en: The `readJPEG()` function is used to read an image in the JPEG file format,
    and converts it into a raster array:.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `readJPEG()` 函数读取 JPEG 文件格式的图像，并将其转换为栅格数组：。
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Step 3 - data cleaning
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤 3 - 数据清洗
- en: 'Exploring the dimensions of the `img`: the `dim()` function returns the dimensions
    of the `img` frame. The `img` data frame is passed as an input parameter:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 探索 `img` 的维度：`dim()` 函数返回 `img` 框架的维度。将 `img` 数据框作为输入参数传递：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now let''s print the `img_Dim`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来打印 `img_Dim`：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The result is as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '![Step 3 - data cleaning](img/image_07_008.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![步骤 3 - 数据清洗](img/image_07_008.jpg)'
- en: 'Now, we are assigning RGB (red, green, and blue--RGB channels roughly follow
    the color receptors in the human eye) channels to the data frame. The result is
    then stored in the `img_RGB_channels` data frame:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将 RGB（红色、绿色和蓝色--RGB 通道大致遵循人眼中的颜色受体）通道分配给数据框。结果存储在 `img_RGB_channels` 数据框中：
- en: '[PRE15]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Step 4 - visualizing cleaned data
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤 4 - 可视化清洗后的数据
- en: 'Let''s plot the original image:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们绘制原始图像：
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The result is as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '![Step 4 - visualizing cleaned data](img/image_07_009.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![步骤 4 - 可视化清洗后的数据](img/image_07_009.jpg)'
- en: Step 5 - building the model and visualizing it
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤 5 - 构建模型并可视化
- en: 'Assigning the clustering colors:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 分配聚类颜色：
- en: '[PRE17]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Performing k-means clustering: `kmeans()` as a function performs clustering
    on the data matrix `img_RGB_channels`. `centers = kClusters` signifies the number
    of initial clusters:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 k-means 聚类：`kmeans()` 函数对数据矩阵 `img_RGB_channels` 进行聚类。`centers = kClusters`
    表示初始聚类的数量：
- en: '[PRE18]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Creating colours corresponding to the given intensities of red, green and blue
    primaries.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 创建与给定红色、绿色和蓝色基色强度相对应的颜色。
- en: '[PRE19]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Plotting the image with three clusters:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 使用三个聚类绘制图像：
- en: '[PRE20]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The result is as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '![Step 5 - building the model and visualizing it](img/image_07_010.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![步骤 5 - 构建模型并可视化](img/image_07_010.jpg)'
- en: 'Assigning the clustering colors:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 分配聚类颜色：
- en: '[PRE21]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Performing k-means clustering:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 k-means 聚类：
- en: '[PRE22]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Creating colours corresponding to the given intensities of red, green and blue
    primaries.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 创建与给定红色、绿色和蓝色基色强度相对应的颜色。
- en: '[PRE23]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Plotting the image with five clusters:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 使用五个聚类绘制图像：
- en: '[PRE24]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The result is as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '![Step 5 - building the model and visualizing it](img/image_07_011.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![步骤 5 - 构建模型并可视化](img/image_07_011.jpg)'
